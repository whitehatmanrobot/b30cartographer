= pszArg)
    {
        pszArg = "";
    }
    
    // Figure out the size of the resulting buffer
    cchBuff = lstrlen(pszTmpl) + lstrlen(pszArg) + 2;

    // Allocate the needed space
    if (FAILED(HrAlloc((VOID **) &pszBuff, cchBuff * sizeof(*pszBuff))))
    {
        goto exit;
    }

    // Create the output string
    wnsprintf(pszBuff, cchBuff, pszTmpl, pszArg);

    // Print the buffer to the log file
    pILogFile->WriteLog(LOGFILE_DB, pszBuff);

exit:
    SafeMemFree(pszBuff);
    return;
}
#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\oejunk.h ===
// --------------------------------------------------------------------------
// OEJUNK.H
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------
#if _MSC_VER > 1000
#pragma once
#endif

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
extern HINSTANCE    g_hInst;
extern IMalloc *    g_pMalloc;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\oejunk.cpp ===
// --------------------------------------------------------------------------
// OEJUNK.CPP
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------
#include "pch.hxx"

// --------------------------------------------------------------------------------
// Globals
// --------------------------------------------------------------------------------
HINSTANCE   g_hInst = NULL;
IMalloc *   g_pMalloc = NULL;

// --------------------------------------------------------------------------------
// Dll Entry Point
// --------------------------------------------------------------------------------
extern "C" BOOL WINAPI DllMain(HANDLE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // Process Attach
    if (DLL_PROCESS_ATTACH == dwReason)
    {
        // Save hInstance
        g_hInst = (HINSTANCE)hInst;

        // We don't care about thread attachs
        SideAssert(DisableThreadLibraryCalls((HINSTANCE)hInst));

        // Get the OLE Task Memory Allocator
        CoGetMalloc(1, &g_pMalloc);
        AssertSz(g_pMalloc, "We are in trouble now.");        
    }

    // Process Detach
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        // Release the task allocator
        SafeRelease(g_pMalloc);
    }

    // Done
    return TRUE;
}

// --------------------------------------------------------------------------------
// GetDllMajorVersion
// --------------------------------------------------------------------------------
OEDLLVERSION WINAPI GetDllMajorVersion(void)
{
    return OEDLL_VERSION_CURRENT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\junkutil.cpp ===
/*

  JUNKUTIL.CPP
  (c) copyright 1998 Microsoft Corp

  Shared utility functions

  Created by Robert Rounthwaite (RobertRo@microsoft.com)

  Modified by Brian Moore (brimo@microsoft.com)

*/

#include <pch.hxx>
#include "junkutil.h"
#include <msoedbg.h>
#define _WIN32_OE 0x0501
#include <mimeole.h>

WORD WGetStringTypeEx(LPCSTR pszText)
{
    WORD wType = 0;

    if (NULL == pszText)
    {
        wType = 0;
        goto exit;
    }

    if (IsDBCSLeadByte(*pszText))
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, pszText, 2, &wType));
    else
        SideAssert(GetStringTypeEx(LOCALE_USER_DEFAULT, CT_CTYPE1, pszText, 1, &wType));
        
exit:
    return wType;
}

BOOL FMatchToken(BOOL fStart, BOOL fEnd, LPCSTR pszPrev, DWORD * pdwFlagsPrev, LPCSTR pszWord, ULONG cchWord, DWORD * pdwFlagsWord, LPCSTR pszEnd)
{
    BOOL    fRet = FALSE;
    DWORD   dwFlagsEnd = 0;
    LPCSTR  pszEndWord = NULL;

    // this code checks to see that the spot we found is a "word" and not a subword
    // we want the character before and after to be word break, unless the character on that end of the 
    // string already is not a word break (or we're at the beginning of the string, for the char before)
    // front checking
    // f1: in either case we don't have to check the front if this is the first character; otherwise,
    // f2: either the first character of the string is alnum and the previous character is not (and is not an "internal" character)
    // f3: or the first character of the string isn't alnum, the previous character either is, or is a whitespace character
    // rear checking
    // r1: either we are at the end of the string
    // r2: or the last character is alpha and the following character is not alpha or number (and is not an "internal" character)
    // r3: or the last character is not alpha or num and the following character either is, or is a whitespace character
    // r4: or the last character is num and the test depends on the first character: 
    // r5:      if it was alphanum, then the following character is not alpha or number (and is not an "internal" character)
    // r6:      or it wasn't alphanum, then the following character is alpha or is a whitespace character
    // Whew! This mimics the criteria used by GetNextFeature() in splitting up the string. The easiest way to understand this criteria
    // is to examine that function
    if ((FALSE != fStart) ||                                                                                // f1
            ((FALSE != FDoWordMatchStart(pszWord, pdwFlagsWord, CT_START_ALPHANUM)) &&
                    (FALSE == FDoWordMatchStart(pszPrev, pdwFlagsPrev, CT_START_ALPHANUM)) &&
                    (FALSE == FIsInternalChar(*pszPrev))) ||                                                // f2               
            ((FALSE == FDoWordMatchStart(pszWord, pdwFlagsWord, CT_START_ALPHANUM)) &&
                    (FALSE != FDoWordMatchStart(pszPrev, pdwFlagsPrev, CT_START_ALPHANUMSPACE))))           // f3
    {
        // Make it a little more readable
        pszEndWord = pszWord + cchWord - 1;
        
        if ((FALSE != fEnd) ||                                                                              // r1
                ((FALSE != FDoWordMatchEnd(pszEndWord, pdwFlagsWord, CT_END_ALPHA)) &&
                        (FALSE == FDoWordMatchEnd(pszEnd, &dwFlagsEnd, CT_END_ALPHANUM)) &&
                        (FALSE == FIsInternalChar(*pszEnd))) ||                                             // r2
                ((FALSE == FDoWordMatchEnd(pszEndWord, pdwFlagsWord, CT_END_ALPHANUM)) &&
                        (FALSE != FDoWordMatchEnd(pszEnd, &dwFlagsEnd, CT_END_ALPHASPACE))) ||              // r3
                ((FALSE != FDoWordMatchEnd(pszEndWord, pdwFlagsWord, CT_END_NUM)) &&                        // r4
                    (((FALSE != FDoWordMatchStart(pszWord, pdwFlagsWord, CT_START_ALPHANUM)) &&
                            (FALSE == FDoWordMatchEnd(pszEnd, &dwFlagsEnd, CT_END_ALPHANUM)) &&
                                    (FALSE == FIsInternalChar(*pszEnd))) ||                                 // r5
                        ((FALSE == FDoWordMatchStart(pszWord, pdwFlagsWord, CT_START_ALPHANUM)) &&
                            (FALSE != FDoWordMatchEnd(pszEnd, &dwFlagsEnd, CT_END_ALPHANUMSPACE))))))       // r6
        {
            // Good match
            fRet = TRUE;
        }
    }

    return fRet;
}

/////////////////////////////////////////////////////////////////////////////
// FWordPresent
//
// Determines if the given "word" is present in the Text. A word in this
// case is any string of characters with a non-alpha character on either
// side (or with the beginning or end of the text on either side).
// Case sensitive.
/////////////////////////////////////////////////////////////////////////////
BOOL FWordPresent(LPSTR pszText, DWORD * pdwFlags, LPSTR pszWord, ULONG cchWord, LPSTR * ppszMatch)
{
    BOOL    fRet = FALSE;
    LPSTR   pszLoc = NULL;
    DWORD   dwFlagsPrev = 0;
    
    // If there's nothing to do then just exit
    if ((NULL == pszText) || ('\0' == pszText[0]) || (NULL == pszWord) || (NULL == pdwFlags) || (0 == cchWord))
    {
        fRet = FALSE;
        goto exit;
    }
    
    // How big is the text
    for (pszLoc = pszText; NULL != (pszLoc = StrStr(pszLoc, pszWord)); pszLoc = CharNext(pszLoc))
    {
        if (FALSE != FMatchToken((pszLoc == pszText), ('\0' == pszLoc[cchWord]),
                    (pszLoc != pszText) ? CharPrev(pszText, pszLoc) : NULL,
                    &dwFlagsPrev, pszWord, cchWord, pdwFlags, pszLoc + cchWord))
        {
            // Good match
            if (NULL != ppszMatch)
            {
                *ppszMatch = pszLoc;
            }
            fRet = TRUE;
            goto exit;
        }

        // Don't cache these flags...
        dwFlagsPrev = 0;        
    }
    
exit:
    return fRet;
}

/////////////////////////////////////////////////////////////////////////////
// Special feature implementations
//
/////////////////////////////////////////////////////////////////////////////

// This feature is 25% of first 50 words contain no lowercase letters (includes words with no letters at all)
// p20_BODY_INTRO_UPPERCASE_WORDS

const UINT      g_cWordsMax = 50;
const DOUBLE    g_cNonLowerWordsThreshold = 0.25;
BOOL FSpecialFeatureUpperCaseWords(LPCSTR pszText)
{
    BOOL    fRet = FALSE;
    UINT    cWords = 0;
    UINT    cNonLowerWords = 0;
    BOOL    fHasLowerLetter = FALSE;
    LPCSTR  pszPos = NULL; 
    WORD    wType = 0;

    if (NULL == pszText)
    {
        fRet = FALSE;
        goto exit;
    }

    // Skip over the leading spaces
    pszPos = PszSkipWhiteSpace(pszText);

    if ('\0' == *pszPos)
    {
        fRet = FALSE;
        goto exit;
    }
    
    while (cWords < g_cWordsMax)
    {
        // Are we at the end of a word?
        wType = WGetStringTypeEx(pszPos);
        
        if ((0 != (wType & C1_SPACE)) || ('\0' == *pszPos))
        {
            // We found a word
            cWords++;
            
            // Did we have any lower case letters in the word
            if (FALSE == fHasLowerLetter)
            {
                cNonLowerWords++;
            }
            else
            {
                fHasLowerLetter = FALSE;
            }

            // Skip over the trailing spaces
            pszPos = PszSkipWhiteSpace(pszPos);
            
            // Are we done with the string?
            if ('\0' == *pszPos)
            {
                break;
            }
        }
        else
        {
            fHasLowerLetter |= (0 != (wType & C1_LOWER));

            // Move to the next character
            pszPos = CharNext(pszPos);
        }
    }

    // Set the return value
    fRet = ((cWords > 0) && ((cNonLowerWords / (double)cWords) >= g_cNonLowerWordsThreshold));
    
exit:
    return fRet;
}

BOOL FSpecialFeatureUpperCaseWordsStm(IStream * pIStm)
{
    BOOL            fRet = FALSE;
    TCHAR           rgchBuff[4096 + 1];
    ULONG           chRead = 0;
    LARGE_INTEGER   liZero = {0};
    
    if (NULL == pIStm)
    {
        fRet = FALSE;
        goto exit;
    }

    // Seek to the start of the stream
    if (FAILED(pIStm->Seek(liZero, STREAM_SEEK_SET, NULL)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Fill up the buffer
    if (FAILED(pIStm->Read(rgchBuff, 4096, &chRead)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Make sure the buffer is zero terminated
    rgchBuff[chRead] = '\0';
    
    fRet = FSpecialFeatureUpperCaseWords(rgchBuff);
    
exit:
    return fRet;
}

// This feature is: 8% of first 200 non-space and non-numeric characters aren't letters
// p20_BODY_INTRO_NONALPHA
const UINT      g_cchTextMax = 200;
const DOUBLE    g_cNonSpaceNumThreshold = 0.08;
BOOL FSpecialFeatureNonAlpha(LPCSTR pszText)
{
    BOOL    fRet = FALSE;
    UINT    cchText = 0;
    UINT    cchNonAlpha = 0;
    LPCSTR  pszPos = NULL; 
    WORD    wType = 0;

    if (NULL == pszText)
    {
        fRet = FALSE;
        goto exit;
    }

    // Skip over the leading spaces
    pszPos = PszSkipWhiteSpace(pszText);

    for (; '\0' != *pszPos; pszPos = CharNext(pszPos))
    {
        wType = WGetStringTypeEx(pszPos);
        
        // Are we not a space or a digit?
        if ((0 == (wType & C1_SPACE)) && (0 == (wType & C1_DIGIT)))
        {
            cchText++;
            
            if (0 == (wType & C1_ALPHA))
            {
                cchNonAlpha++;
            }

            // Have we checked enough characters?
            if (cchText >= g_cchTextMax)
            {
                break;
            }
        }
    }

    // Set the return value
    fRet = (cchText > 0) && ((cchNonAlpha / (double)cchText) >= g_cNonSpaceNumThreshold);
    
exit:
    return fRet;
}

BOOL FSpecialFeatureNonAlphaStm(IStream * pIStm)
{
    BOOL            fRet = FALSE;
    TCHAR           rgchBuff[1024 + 1];
    ULONG           chRead = 0;
    LARGE_INTEGER   liZero = {0};
    
    if (NULL == pIStm)
    {
        fRet = FALSE;
        goto exit;
    }

    // Seek to the start of the stream
    if (FAILED(pIStm->Seek(liZero, STREAM_SEEK_SET, NULL)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Fill up the buffer
    if (FAILED(pIStm->Read(rgchBuff, 1024, &chRead)))
    {
        fRet = FALSE;
        goto exit;
    }

    // Make sure the buffer is zero terminated
    rgchBuff[chRead] = '\0';
    
    fRet = FSpecialFeatureNonAlpha(rgchBuff);
    
exit:
    return fRet;
}

// --------------------------------------------------------------------------------
// FStreamStringSearch
// --------------------------------------------------------------------------------
#define CB_STREAMMATCH  0x00000FFF
BOOL FStreamStringSearch(LPSTREAM pstm, DWORD * pdwFlagsSearch, LPSTR pszSearch, ULONG cchSearch, DWORD dwFlags)
{
    BOOL            fRet = FALSE;
    ULONG           cbSave = 0;
    CHAR            rgchBuff[CB_STREAMMATCH + 1];
    LPSTR           pszRead = NULL;
    ULONG           cbRead = 0;
    ULONG           cbIn = 0;
    ULONG           cchGood = NULL;
    CHAR            chSave = '\0';
    LONG            cbSize = 0;
    LPSTR           pszMatch = NULL;
    ULONG           cbWalk = 0;

    // Check incoming params
    if ((NULL == pstm) || (NULL == pszSearch) || (0 == cchSearch))
    {
        goto exit;
    }

    // We want to save off the lead char and
    // a possible ending lead byte...
    cbSave = cchSearch + 2;
    if (cbSave > ARRAYSIZE(rgchBuff))
    {
        // we've got a problem - this can cause a buffer overflow later on
        Assert(0);
        goto exit;
  	}
    
    // Get the stream size
    if (FAILED(HrGetStreamSize(pstm, (ULONG *) &cbSize)))
    {
        goto exit;
    }

    // Reset the stream to the beginning
    if (FAILED(HrRewindStream(pstm)))
    {
        goto exit;
    }

    // Set up the defaults
    pszRead = rgchBuff;
    cbRead = CB_STREAMMATCH;
    
    // Search for string through the entire stream
    while ((cbSize > 0) && (S_OK == pstm->Read(pszRead, cbRead, &cbIn)))
    {
        // We're done if we read nothing...
        if (0 == cbIn)
        {
            goto exit;
        }
        
        // Note that we've read the bytes
        cbSize -= cbIn;
        
        // Zero terminate the buffer
        pszRead[cbIn] = '\0';

        // Should we convert the buffer to upper case
        if (0 == (dwFlags & SSF_CASESENSITIVE))
        {
            cchGood = CharUpperBuff(rgchBuff, (ULONG)(cbIn + pszRead - rgchBuff));
        }
        else
        {
            // We need to spin over the buffer figuring out if the end character is a lead
            // byte without a corresponding tail byte
            cbWalk = (ULONG) (cbIn + pszRead - rgchBuff);
            for (cchGood = 0; cchGood < cbWalk; cchGood++)
            {
                if (IsDBCSLeadByte(rgchBuff[cchGood]))
                {
                    if ((cchGood + 1) >= cbWalk)
                    {
                        break;
                    }

                    cchGood++;
                }
            }
        }

        chSave = rgchBuff[cchGood];
        rgchBuff[cchGood] = '\0';
        
        // Search for string
        if (FALSE != FWordPresent(rgchBuff, pdwFlagsSearch, pszSearch, cchSearch, &pszMatch))
        {
            // If we aren't at the end of the stream and we can't
            // tell if we are at a word break
            if ((0 >= cbSize) || ((pszMatch + cchSearch) != (pszRead + cchGood)))
            {
                fRet = TRUE;
                break;
            }
        }
        
        // Are we done with the stream
        if (0 >= cbSize)
        {
            break;
        }

        rgchBuff[cchGood] = chSave;
        
        // Save part of the buffer
        
        // How much space do we have in the buffer
        cbRead = CB_STREAMMATCH - cbSave;
        
        // Save the characters
        MoveMemory(rgchBuff, rgchBuff + cbRead, cbSave);

        // Figure out the new start of the buffer
        pszRead = rgchBuff + cbSave;
    }

exit:
    return(fRet);
}

HRESULT HrConvertHTMLToPlainText(IStream * pIStmHtml, IStream ** ppIStmText)
{
    HRESULT         hr = S_OK;
    IDataObject *   pIDataObj = NULL;
    FORMATETC       fetc = {0};
    STGMEDIUM       stgmed = {0};

    // Check incoming params
    if ((NULL == pIStmHtml) || (NULL == ppIStmText))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing param
    *ppIStmText = NULL;
    
    hr = MimeEditDocumentFromStream(pIStmHtml, IID_IDataObject, (VOID **)&pIDataObj);
    if (FAILED(hr))
    {
        goto exit;
    }

    // Set up the format
    fetc.cfFormat = CF_TEXT;
    fetc.dwAspect = DVASPECT_CONTENT;
    fetc.lindex = -1;
    fetc.tymed = TYMED_ISTREAM;

    // Get the data
    hr = pIDataObj->GetData(&fetc, &stgmed);
    if (FAILED(hr))
    {
        goto exit;
    }

    if (NULL == stgmed.pstm)
    {
        hr = E_FAIL;
        goto exit;
    }
    
    // Save the item
    *ppIStmText = stgmed.pstm;
    (*ppIStmText)->AddRef();

    // addref the pUnk as it will be release in releasestgmed
    if(NULL != stgmed.pUnkForRelease)
    {
        (stgmed.pUnkForRelease)->AddRef();
    }
        
    hr = S_OK;
    
exit:
    ReleaseStgMedium(&stgmed);
    ReleaseObj(pIDataObj);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\junkutil.h ===
/*

  JUNKUTIL.H
  (c) copyright 1998 Microsoft Corp

  Declarations for shared utility functions

  Robert Rounthwaite (RobertRo@microsoft.com)

  Modified by Brian Moore (brimo@microsoft.com)

*/

#pragma once

// Used with FStreamStringSearch
const DWORD CT_START_SET        = 0x00000001;
const DWORD CT_START_ALPHA      = 0x00000002;
const DWORD CT_START_NUM        = 0x00000004;
const DWORD CT_START_SPACE      = 0x00000008;
const DWORD CT_END_SET          = 0x00000010;
const DWORD CT_END_ALPHA        = 0x00000020;
const DWORD CT_END_NUM          = 0x00000040;
const DWORD CT_END_SPACE        = 0x00000080;
const DWORD CT_MASK             = 0x000000FF;

const DWORD CT_START_ALPHANUM       = CT_START_ALPHA | CT_START_NUM;
const DWORD CT_START_ALPHANUMSPACE  = CT_START_ALPHA | CT_START_NUM | CT_START_SPACE;

const DWORD CT_END_ALPHANUM         = CT_END_ALPHA | CT_END_NUM;
const DWORD CT_END_ALPHASPACE       = CT_END_ALPHA | CT_END_SPACE;
const DWORD CT_END_ALPHANUMSPACE    = CT_END_ALPHA | CT_END_NUM | CT_END_SPACE;

#define SSF_CASESENSITIVE   0x00000001

BOOL FSpecialFeatureUpperCaseWords(LPCSTR pszText);
BOOL FSpecialFeatureUpperCaseWordsStm(IStream * pIStm);
BOOL FSpecialFeatureNonAlpha(LPCSTR pszText);
BOOL FSpecialFeatureNonAlphaStm(IStream * pIStm);
BOOL FMatchToken(BOOL fStart, BOOL fEnd, LPCSTR pszPrev, DWORD * pdwFlagsPrev,
                    LPCSTR pszWord, ULONG cchWord, DWORD * pdwFlagsWord, LPCSTR pszEnd);
BOOL FWordPresent(LPSTR pszText, DWORD * pdwFlags, LPSTR pszWord,
                    ULONG cchWord, LPSTR * ppszMatch);

WORD WGetStringTypeEx(LPCSTR pszText);

inline LPCSTR PszSkipWhiteSpace(LPCSTR psz)
{

    for (; '\0' != *psz; psz = CharNext(psz))
    {
        if (0 == (C1_SPACE & WGetStringTypeEx(psz)))
        {
            break;
        }
    }

    return psz;
}

inline BOOL FDoWordMatchStart(LPCSTR pszText, DWORD * pdwFlags, DWORD dwFlagPresent)
{
    WORD    wFlags = 0;
    
    Assert(NULL != pszText);
    Assert(NULL != pdwFlags);
    
    if (0 == ((*pdwFlags) & CT_START_SET))
    {
        // Set the flags
        wFlags = WGetStringTypeEx(pszText);

        if (0 != (C1_ALPHA & wFlags))
        {
            *pdwFlags |= CT_START_ALPHA;
        }

        if (0 != (C1_DIGIT & wFlags))
        {
            *pdwFlags |= CT_START_NUM;
        }

        if (0 != (C1_SPACE & wFlags))
        {
            *pdwFlags |= CT_START_SPACE;
        }
        
        // Note that we have checked it
        (*pdwFlags) |= CT_START_SET;
    }

    return (0 != ((*pdwFlags) & dwFlagPresent));
}

inline BOOL FDoWordMatchEnd(LPCSTR pszText, DWORD * pdwFlags, DWORD dwFlagPresent)
{
    WORD    wFlags = 0;
    
    Assert(NULL != pszText);
    Assert(NULL != pdwFlags);
    
    if (0 == ((*pdwFlags) & CT_END_SET))
    {
        // Set the flags
        wFlags = WGetStringTypeEx(pszText);

        if (0 != (C1_ALPHA & wFlags))
        {
            *pdwFlags |= CT_END_ALPHA;
        }

        if (0 != (C1_DIGIT & wFlags))
        {
            *pdwFlags |= CT_END_NUM;
        }

        if (0 != (C1_SPACE & wFlags))
        {
            *pdwFlags |= CT_END_SPACE;
        }
        
        // Note that we have checked it
        (*pdwFlags) |= CT_END_SET;
    }

    return (0 != ((*pdwFlags) & dwFlagPresent));
}

inline BOOL FIsInternalChar(CHAR ch)
{
    return (('-' == ch) || ('\'' == ch));
}

BOOL FStreamStringSearch(LPSTREAM pstm, DWORD * pdwFlagsSearch, LPSTR pszSearch, ULONG cchSearch, DWORD dwFlags);
HRESULT HrConvertHTMLToPlainText(IStream * pIStmHtml, IStream ** ppIStmText);

inline BOOL FTimeEmpty(FILETIME * pft)
{
    return ((0 == pft->dwLowDateTime) && (0 == pft->dwHighDateTime));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\parsestm.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  ParseStm.h
//
///////////////////////////////////////////////////////////////////////////////

// Bring in only once
#if _MSC_VER > 1000
#pragma once
#endif

class CParseStream
{
  // Private constants
  private:
    enum { CCH_BUFF_MAX = 256 };

  // Private member variables
  private:
    IStream *   m_pStm;
    TCHAR       m_rgchBuff[CCH_BUFF_MAX];
    ULONG       m_cchBuff;
    ULONG       m_idxBuff;

  public:
    // Constructor/destructor
    CParseStream();
    ~CParseStream();

    HRESULT HrSetFile(DWORD dwFlags, LPCTSTR pszFilename);
    HRESULT HrSetStream(DWORD dwFlags, IStream * pStm);
    HRESULT HrReset(VOID);
    HRESULT HrGetLine(DWORD dwFlags, LPTSTR * ppszLine, ULONG * pcchLine);
    
  private:
    HRESULT _HrFillBuffer(DWORD dwFlags);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\parsestm.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//  ParseStm.cpp
//
///////////////////////////////////////////////////////////////////////////////

#include <pch.hxx>
#include "parsestm.h"

// Constructor
CParseStream::CParseStream()
{
    m_pStm = NULL;
    m_rgchBuff[0] = '\0';
    m_cchBuff = 0;
    m_idxBuff = 0;
}

// Desctructor
CParseStream::~CParseStream()
{
    if (NULL != m_pStm)
    {
        m_pStm->Release();
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrSetFile
//
//  This sets which stream we should be parsing.
//
//  dwFlags     - modifiers on how to load the stream
//  pszFilename - the file to parse
//
//  Returns:    S_OK, on success
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CParseStream::HrSetFile(DWORD dwFlags, LPCTSTR pszFilename)
{
    HRESULT     hr = S_OK;
    IStream *   pIStm = NULL;

    // Check incoming params
    if ((0 != dwFlags) || (NULL == pszFilename))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Create a stream on the file
    hr = CreateStreamOnHFile((LPTSTR) pszFilename, GENERIC_READ, FILE_SHARE_READ, NULL, 
            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL, &pIStm);
    if (FAILED(hr))
    {
        goto exit;
    }
    
    // Reset the read buffer
    m_cchBuff = 0;
    m_idxBuff = 0;
    
    // Free up any old stream
    if (NULL != m_pStm)
    {
        m_pStm->Release();
    }

    m_pStm = pIStm;
    pIStm = NULL;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeRelease(pIStm);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrSetStream
//
//  This sets which stream we should be parsing.
//
//  dwFlags - modifiers on how to load the stream
//  pStm    - the stream to parse
//
//  Returns:    S_OK, on success
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CParseStream::HrSetStream(DWORD dwFlags, IStream * pStm)
{
    HRESULT     hr = S_OK;

    // Check incoming params
    if ((0 != dwFlags) || (NULL == pStm))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Reset the read buffer
    m_cchBuff = 0;
    m_idxBuff = 0;
    
    // Free up any old stream
    if (NULL != m_pStm)
    {
        m_pStm->Release();
    }

    m_pStm = pStm;
    m_pStm->AddRef();
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrReset
//
//  This resets the stream to parse from the beginning.
//
//  Returns:    S_OK, on success
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CParseStream::HrReset(VOID)
{
    HRESULT         hr = S_OK;
    LARGE_INTEGER   liZero = {0};

    // Reset the read buffer
    m_cchBuff = 0;
    m_idxBuff = 0;
    
    // Free up any old stream
    if (NULL != m_pStm)
    {
        m_pStm->Seek(liZero, STREAM_SEEK_SET, NULL);
    }

    // Set the proper return value
    hr = S_OK;
    
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  HrGetLine
//
//  This gets a line from the stream.
//
//  dwFlags     - modifiers on how to get the line from the stream
//  ppszLine    - an allocated buffer holding the line parsed from the stream
//  pcchLine    - the number of characters in the line buffer
//
//  Returns:    S_OK, on success
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CParseStream::HrGetLine(DWORD dwFlags, LPTSTR * ppszLine, ULONG * pcchLine)
{
    HRESULT     hr = S_OK;
    BOOL        fFoundCRLF = FALSE;
    ULONG       cchAlloc = 0;
    ULONG       cchLine = 0;
    LPTSTR      pszLine = NULL;
    ULONG       idxStart = 0;
    TCHAR       chPrev = '\0';

    // Check incoming params
    if ((0 != dwFlags) || (NULL == ppszLine) || (NULL == pcchLine))
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Initialize the outgoing params
    *ppszLine = NULL;
    *pcchLine = 0;

    // while we have found the end of the line
    while (FALSE == fFoundCRLF)
    {
        // Fill the buffer
        if (m_idxBuff == m_cchBuff)
        {
            hr = _HrFillBuffer(0);
            if (S_OK != hr)
            {
                break;
            }
        }

        // While we have room in the buffer
        for (idxStart = m_idxBuff; m_idxBuff < m_cchBuff; m_idxBuff++)
        {
            // Search for the end of line marker
            if ((chCR == chPrev) && (chLF == m_rgchBuff[m_idxBuff]))
            {
                m_idxBuff++;
                fFoundCRLF = TRUE;
                break;
            }

            chPrev = m_rgchBuff[m_idxBuff];
        }
        
        // Make enough space to hold the new characters
        cchAlloc += m_idxBuff - idxStart;
        if (NULL == pszLine)
        {
            hr = HrAlloc((void **) &pszLine, (cchAlloc + 1) * sizeof(*pszLine));
            if (FAILED(hr))
            {
                goto exit;
            }
        }
        else
        {
            hr = HrRealloc((void **) &pszLine, (cchAlloc + 1) * sizeof(*pszLine));
            if (FAILED(hr))
            {
                goto exit;
            }
        }

        // Copy the data into the buffer
        CopyMemory(pszLine + cchLine, m_rgchBuff + idxStart, m_idxBuff - idxStart);
        cchLine += m_idxBuff - idxStart;
    }

    // Remove the CRLF
    cchLine -= 2;
    
    // Terminate the line
    pszLine[cchLine] = '\0';
    
    // Set the return values
    *ppszLine = pszLine;
    pszLine = NULL;
    *pcchLine = cchLine;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    SafeMemFree(pszLine);
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
//  _HrFillBuffer
//
//  This fills the buffer from the stream if necessary.
//
//  dwFlags     - modifiers on how to fill the buffer from the stream
//
//  Returns:    S_OK, on success
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CParseStream::_HrFillBuffer(DWORD dwFlags)
{
    HRESULT     hr = S_OK;
    ULONG       cchRead = 0;

    // Check incoming params
    if (0 != dwFlags)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    hr = m_pStm->Read((void *) m_rgchBuff, CCH_BUFF_MAX, &cchRead);
    if (FAILED(hr))
    {
        goto exit;
    }

    m_cchBuff = cchRead;
    m_idxBuff = 0;
    
    // Set the proper return value
    hr = S_OK;
    
exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\strtodbl.c ===
#ifndef _CRTBLD
#define _CRTBLD
#endif

#include <windows.h>
#include <shlwapi.h>

/***
* double StrToDbl(const char *str, char **strStop) - convert string to double
*
* Purpose:
*           To convert a string into a double.  This function supports
*           simple double representations like '1.234', '.5678'.  It also support
*           the a killobyte computaion by appending 'k' to the end of the string
*           as in '1.5k' or '.5k'.  The results would then become 1536 and 512.5.
*
* Return:
*           The double representation of the string.
*           strStop points to the character that caused the scan to stop.
*
*******************************************************************************/

double __cdecl StrToDbl(const char *str, char **strStop)
{
    double dbl = 0;
    char *psz;
    int iMult = 1;
    int iKB = 1;
    int iVal = 0;
    BOOL bHaveDot = FALSE;

    psz = (char*)str;
    while(*psz)
    {
        if((*psz >= '0') && (*psz <= '9'))
        {
            iVal = (iVal * 10) + (*psz - '0');
            if(bHaveDot)
                iMult *= 10;
        }
        else if((*psz == '.') && !bHaveDot)
        {
            bHaveDot = TRUE;
        }
        else if((*psz == 'k') || (*psz == 'K'))
        {
            iKB = 1024;
            psz++;
            break;
        }
        else
        {
            break;
        }
        psz++;
    }
    *strStop = psz;

    dbl = (double) (iVal * iKB) / iMult;
    
    return(dbl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oemiglib\defguid.cpp ===
//--------------------------------------------------------------------------
// Defguid.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include <initguid.h>
#include <ole2.h>
#define DEFINE_DIRECTDB
#include <oestore.h>
#define INITGUID
#include "oe5imp.h"
#include <msident.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\original\svmhandler.h ===
/*

  SVMHANDLER.H
  (c) copyright 1998 Microsoft Corp

  Contains the class encapsulating the Support Vector Machine used to do on the fly spam detection

  Robert Rounthwaite (RobertRo@microsoft.com)

*/

#pragma once

#ifndef REAL
typedef double REAL;
#endif

#define SAFE_FREE( p ) if (p!=NULL) free(p);

enum boolop
{
	boolopOr,
	boolopAnd
};

#include "svmutil.h"

class MAILFILTER
{
	/* 
		The public interface to the MAILFILTER class is below. Normal use of this class to filter mail
		will entail:
		Calling the following once: FSetSVMDataLocation() and SetSpamCutoff()
		Setting the "Properties of the user"
		...and, for each message you filter
			- Calling BCalculateSpamProb()
	*/
public:
	// Sets the location of the SVM Data file(.LKO file). Must be called before calling any other methods
	// Data file must be present at time function is called
	// returns true if successful, false otherwise
	bool FSetSVMDataLocation(char *szFullPath);

	// Sets the Spam cutoff percentage. Must be in range from 0 to 100
	bool SetSpamCutoff(REAL rCutoff);
	// returns value set with SetSpamCutoff. Defaults == DefaultSpamCutoff
	// if no value has been set when SVM output file is read
	REAL GetSpamCutoff();
	// returns default value for SpamCutoff. read from SVM output file.
	// should call FSetSVMDataLocation before calling this function
	REAL GetDefaultSpamCutoff();

	// Properties of the user
	void SetFirstName(char *szFirstName);
	void SetLastName(char *szLastName);
	void SetCompanyName(char *szCompanyName);

	// Calculates the probability that the current message (defined by the properties of the message) is spam.
	// !Note! that the IN string params may be modified by the function.
	// Returns the probability (0 to 1) that the message is spam in prSpamProb
	// the boolean return is determined by comparing to the spam cutoff
	// if the value of a boolean param is unknown use false, use 0 for unknown time.
	bool BCalculateSpamProb(/* IN params */
							char *szFrom,
							char *szTo,
							char *szSubject,
							char *szBody,
							bool bDirectMessage,
							bool bHasAttach,
							FILETIME tMessageSent,
							/* OUT params */
							REAL *prSpamProb, 
							bool * pbIsSpam);

	MAILFILTER();
	~MAILFILTER();

	// Reads the default spam cutoff without parsing entire file
	// Use GetDefaultSpamCutoff if using FSetSVMDataLocation;
	static bool BReadDefaultSpamCutoff(char *szFullPath, REAL *prDefCutoff);

private: // members
	struct FeatureComponent
	{
		FeatureLocation loc;
		union
		{
			char *szFeature;
			UINT iRuleNum; // used with locSpecial
		};
		// map feature to location in dst file/location in SVM output
		// more than one feature component may map to the same location, combined with the op
		int iFeature;
		boolop bop; // first feature in group is alway bopOr
		bool fPresent;
		FeatureComponent() { loc = locNil; }
		~FeatureComponent() 
		{ 
			if ((loc>locNil) && (loc < locSpecial))
			{
				free(szFeature);
			}
		}
	};

	FeatureComponent *rgfeaturecomps;

	// weights from SVM output
	REAL *rgrSVMWeights;
	// Other SVM file variables
	REAL _rCC;
	REAL _rDD;
	REAL _rThresh;
	REAL _rDefaultThresh;

	// Counts
	UINT _cFeatures;
	UINT _cFeatureComps;

	// is Feature present? -1 indicates not yet set, 0 indicates not present, 1 indicates present
	int *_rgiFeatureStatus;

	// Properties of the user
	char *_szFirstName;
	char *_szLastName;
	char *_szCompanyName;

	// Set via FSetSVMDataLocation() and SetSpamCutoff()
	CString _strFName;
	REAL _rSpamCutoff;

	// Properties of the message
	char *_szFrom; 
	char *_szTo; 
	char *_szSubject; 
	char *_szBody;
	bool _bDirectMessage;
	FILETIME _tMessageSent;
	bool _bHasAttach;

	// Cached special rule results used during spam calculations
	bool _bRule14;
	bool _bRule17;

private: // methods
	bool ReadSVMOutput(LPCTSTR lpszFileName);
	void EvaluateFeatureComponents();
	void ProcessFeatureComponentPresence();
	REAL RDoSVMCalc();
	bool FInvokeSpecialRule(UINT iRuleNum);
	void HandleCaseSensitiveSpecialRules();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\original\svmutil.h ===
#pragma once
#ifndef _SVMUTIL_H_
#define _SVMUTIL_H_
/*

  SVMUTIL.H
  (c) copyright 1998 Microsoft Corp

  Declarations for shared utility functions

  Robert Rounthwaite (RobertRo@microsoft.com)

*/


inline bool FTimeEmpty(FILETIME &ft)
{
	return ((ft.dwLowDateTime == 0) && (ft.dwHighDateTime == 0));
}

inline bool FTimeEmpty(CTime &t)
{
	return (t.GetYear()<=1970);
}


enum FeatureLocation
{
	locNil = 0,
	locBody = 1,
	locSubj = 2,
	locFrom = 3,
	locTo = 4,
	locSpecial = 5
};

bool SpecialFeatureUpperCaseWords(char *pszText);
bool SpecialFeatureNonAlpha(char *pszText);
bool FWordPresent(char *szText, char *szWord);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\original\svmhandler.cpp ===
/*

  SVMHANDLER.CPP
  (c) copyright 1998 Microsoft Corp

  Contains the class encapsulating the Support Vector Machine used to do on the fly spam detection

  Robert Rounthwaite (RobertRo@microsoft.com)

*/

#include <afx.h>
#include <stdlib.h>
#include <memory.h>
#include <string.h>
#include <math.h>
#include <assert.h>
#include "svmhandler.h"
typedef unsigned int        UINT;

#ifdef  _UNICODE
#define stoul wcstoul
#define stod wcstod
#else
#define stoul strtoul
#define stod strtod
#endif

char *szCountFeatureComp = "FeatureComponentCount =";
char *szDefaultThresh = "dThresh =";

/////////////////////////////////////////////////////////////////////////////
// ReadSVMOutput
//
// Read the SVM output from a file (".LKO file")
/////////////////////////////////////////////////////////////////////////////
bool MAILFILTER::ReadSVMOutput(LPCTSTR lpszFileName)
{
	try 
	{
		CStdioFile sfile(lpszFileName, CFile::modeRead);
		CString strBuf;
		int iBufPos;
		BOOL bComplete = false;
		UINT iSVMW; // index to rgrSVMWeights;
		UINT iFeatureComp = 0;
		int cFeatureComponents;

		// skip first two lines
		if ((!sfile.ReadString(strBuf)) ||
			(!sfile.ReadString(strBuf)) ||
			(!sfile.ReadString(strBuf)))
		{
			return false;
		}
		LPCTSTR szBuf = (LPCTSTR)strBuf;
		LPTSTR szBufPtr = NULL;
		// parse 3rd line: only care about CC and DD
		_rCC = stod(&((LPCTSTR)strBuf)[34], NULL);
		_rDD = stod(&((LPCTSTR)strBuf)[49], NULL);

		if (!sfile.ReadString(strBuf))
		{
			return false;
		}
		char *pszDefThresh = strstr(&((LPCTSTR)strBuf)[11], ::szDefaultThresh);
		assert(pszDefThresh != NULL);
		if (pszDefThresh == NULL)
		{
			return false;
		}
		pszDefThresh += strlen(::szDefaultThresh);
		_rDefaultThresh = stod(pszDefThresh, NULL);
		if (_rSpamCutoff == -1)
		{
			_rSpamCutoff = _rDefaultThresh;
		}
		
		_rThresh = stod(&((LPCTSTR)strBuf)[11], NULL);
		if (!sfile.ReadString(strBuf))
		{
			return false;
		}
		_cFeatures = stoul(&((LPCTSTR)strBuf)[8], NULL, 10);

		if (!sfile.ReadString(strBuf))
		{
			return false;
		}
		iBufPos = strBuf.Find(szCountFeatureComp) + strlen(szCountFeatureComp);
		cFeatureComponents = stoul(&((LPCTSTR)strBuf)[iBufPos], NULL, 10);

		if (cFeatureComponents < _cFeatures)
			cFeatureComponents = _cFeatures * 2;

		while (strBuf != "Weights")
		{
			if (!sfile.ReadString(strBuf)) // skip "Weights" line
			{
				return false;
			}
		} 
		
		rgrSVMWeights = (REAL *)malloc(sizeof(REAL) * _cFeatures);
		_rgiFeatureStatus = (int *)malloc(sizeof(int) * _cFeatures);
		memset(_rgiFeatureStatus, -1, sizeof(int) * _cFeatures);
		rgfeaturecomps = (FeatureComponent *)malloc(sizeof(FeatureComponent) * cFeatureComponents);

		for (iSVMW = 0; iSVMW < _cFeatures; iSVMW++)
		{
			UINT uiLoc;
			UINT cbStr;
			boolop bop;
			char *szFeature;
			bool fContinue;
			if (!sfile.ReadString(strBuf))
			{
				return false;
			}
			// read the SVM weight
			rgrSVMWeights[iSVMW] = stod(strBuf, &szBufPtr);
			szBufPtr++; // skip the separator
			bop = boolopOr;
			fContinue = false;
			// load all of the feature components
			do
			{
				FeatureComponent *pfeaturecomp = &rgfeaturecomps[iFeatureComp++];
				// Location (or "special")
				uiLoc = stoul(szBufPtr, &szBufPtr, 10);
				szBufPtr++; // skip the separator

				pfeaturecomp->loc = (FeatureLocation)uiLoc;
				pfeaturecomp->iFeature = iSVMW;
				pfeaturecomp->bop = bop;
				if (uiLoc == 5) // special feature
				{
					UINT uiRuleNumber = stoul(szBufPtr, &szBufPtr, 10);
					szBufPtr++; // skip the separator

					pfeaturecomp->iRuleNum = uiRuleNumber;
				}
				else  // it is a standard string component
				{
					cbStr  = stoul(szBufPtr, &szBufPtr, 10);
					szBufPtr++;
					szFeature = (char *)malloc((cbStr + 1)*sizeof(char));
					memcpy(szFeature, szBufPtr, cbStr);
					szBufPtr += cbStr;
					if (*szBufPtr != '\0')
					{
						szBufPtr++; // skip the separator
					}
					szFeature[cbStr] = '\0';
					assert(strlen(szFeature) == cbStr);
					pfeaturecomp->szFeature = szFeature;
				}
				switch(*szBufPtr)
				{
					case '|':  
						bop = boolopOr;
						fContinue = true;
						break;
					case '&':  
						bop = boolopAnd;
						fContinue = true;
						break;
					default: 
						fContinue = false;
						break;
				}
				szBufPtr++;
			}
			while (fContinue);
		}
		_cFeatureComps = iFeatureComp;

	}
	catch (CFileException *)
	{
		return false;
	}
	return true;
}


/////////////////////////////////////////////////////////////////////////////
// SetSpamCutoff
//
// Sets the Spam cutoff percentage. Must be in range from 0 to 100
/////////////////////////////////////////////////////////////////////////////
bool MAILFILTER::SetSpamCutoff(REAL rCutoff)
{
	if ((rCutoff >= 0) && (rCutoff <= 100))
	{
		_rSpamCutoff = rCutoff;
		return true;
	}
	else
	{
		return false;
	}
}

/////////////////////////////////////////////////////////////////////////////
// GetSpamCutoff
//
// returns value set with SetSpamCutoff. Defaults == DefaultSpamCutoff
// if no value has been set when SVM output file is read
/////////////////////////////////////////////////////////////////////////////
REAL MAILFILTER::GetSpamCutoff()
{
	return _rSpamCutoff;
}

/////////////////////////////////////////////////////////////////////////////
// GetDefaultSpamCutoff
//
// returns default value for SpamCutoff. read from SVM output file.
// should call FSetSVMDataLocation before calling this function
/////////////////////////////////////////////////////////////////////////////
REAL MAILFILTER::GetDefaultSpamCutoff()
{
	assert(!_strFName.IsEmpty());

	return _rDefaultThresh;
}


/////////////////////////////////////////////////////////////////////////////
// FInvokeSpecialRule
//
// Invokes the special rule that is this FeatureComponent. 
// Returns the state of the feature.
/////////////////////////////////////////////////////////////////////////////
bool MAILFILTER::FInvokeSpecialRule(UINT iRuleNum)
{
	switch (iRuleNum)
	{
		case 1: 
			return FWordPresent(_szBody, _szFirstName);
			break;
		case 2: 
			return FWordPresent(_szBody, _szLastName);
			break;
		case 3:
			return FWordPresent(_szBody, _szCompanyName);
			break;
		case 4: 
			// year message received
			if (FTimeEmpty(_tMessageSent))
			{
				return false;
			}
			else
			{
				CTime time(_tMessageSent, -1);
				char szYear[6];
				wnsprintf(szYear, ARRAYSIZE(szYear), "%i", time.GetYear());
				return FWordPresent(_szBody, szYear);
			}
			break;
		case 5:
			// message received in the wee hours (>= 7pm or <6am
			if (FTimeEmpty(_tMessageSent))
			{
				return false;
			}
			else
			{
				CTime time(_tMessageSent, -1);
				return (time.GetHour() >= (7+12)) || (time.GetHour() < 6);
			}
			break;
		case 6:
			// message received on weekend
			if (FTimeEmpty(_tMessageSent))
			{
				return false;
			}
			else
			{
				CTime time(_tMessageSent, -1);
				return ((time.GetDayOfWeek() == 7) || (time.GetDayOfWeek() == 1));
			}
			break;
		case 14:
			return _bRule14; // set in HandleCaseSensitiveSpecialRules()
			break;
		case 15:
			return SpecialFeatureNonAlpha(_szBody);
			break;
		case 16:
			return _bDirectMessage;
			break;
		case 17:
			return _bRule17; // set in HandleCaseSensitiveSpecialRules()
			break;
		case 18:
			return SpecialFeatureNonAlpha(_szSubject);
			break;
		case 19:
			return (*_szTo=='\0');
			break;
		case 20:
			return _bHasAttach;
			break;
		case 40:
			return (strlen(_szBody) >= 125);
		case 41:
			return (strlen(_szBody) >= 250);
		case 42:
			return (strlen(_szBody) >= 500);
		case 43:
			return (strlen(_szBody) >= 1000);
		case 44:
			return (strlen(_szBody) >= 2000);
		case 45:
			return (strlen(_szBody) >= 4000);
		case 46:
			return (strlen(_szBody) >= 8000);
		case 47:
			return (strlen(_szBody) >= 16000);
		default:
			return false;
			//assert(false == "unsupported special feature");
			break;
	}
	return true;
}


/////////////////////////////////////////////////////////////////////////////
// HandleCaseSensitiveSpecialRules
//
// Called from EvaluateFeatureComponents().
// Some special rules are case sensitive, so if they're present, we'll 
// evaluate them before we make the texts uppercase and cache the result
// for when they are actually used.
/////////////////////////////////////////////////////////////////////////////
void MAILFILTER::HandleCaseSensitiveSpecialRules()
{
	for (UINT i = 0; i<_cFeatureComps; i++)
	{
		FeatureComponent *pfcomp = &rgfeaturecomps[i];
		
		if (pfcomp->loc == locSpecial)
		{
			switch (pfcomp->iRuleNum)
			{
				case 14:
					_bRule14 = SpecialFeatureUpperCaseWords(_szBody);
					break;
				case 17:
					_bRule17 = SpecialFeatureUpperCaseWords(_szSubject);
					break;
				default: 
					;// nothing
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
// EvaluateFeatureComponents
//
// Evaluates all of the feature components. Sets fPresent in each component
// to true if the feature is present, false otherwise
/////////////////////////////////////////////////////////////////////////////
void MAILFILTER::EvaluateFeatureComponents()
{
	HandleCaseSensitiveSpecialRules();

	_strupr(_szFrom); 
	_strupr(_szTo); 
	_strupr(_szSubject); 
	_strupr(_szBody);

	for (UINT i = 0; i<_cFeatureComps; i++)
	{
		FeatureComponent *pfcomp = &rgfeaturecomps[i];
		
		switch(pfcomp->loc)
		{
			case locNil:
				assert(pfcomp->loc != locNil);
				pfcomp->fPresent = false;
				break;
			case locBody:
				pfcomp->fPresent = FWordPresent(_szBody, pfcomp->szFeature);
				break;
			case locSubj:
				pfcomp->fPresent = FWordPresent(_szSubject, pfcomp->szFeature);
				break;
			case locFrom:
				pfcomp->fPresent = FWordPresent(_szFrom, pfcomp->szFeature);
				break;
			case locTo:
				pfcomp->fPresent = FWordPresent(_szTo, pfcomp->szFeature);
				break;
			case locSpecial:
				pfcomp->fPresent = FInvokeSpecialRule(pfcomp->iRuleNum);
				break;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// ProcessFeatureComponentPresence
//
// Processes the presence (or absence) of the individual feature components,
// setting the feature status of each feature (which may me made up of
// multiple feature components).
/////////////////////////////////////////////////////////////////////////////
void MAILFILTER::ProcessFeatureComponentPresence()
{
	for (UINT i = 0; i < _cFeatureComps; i++)
	{
		FeatureComponent *pfcomp = &rgfeaturecomps[i];
		UINT iFeature = pfcomp->iFeature;
		if (_rgiFeatureStatus[iFeature] == -1) // first feature of this feature
		{
			if (pfcomp->fPresent)
			{
				_rgiFeatureStatus[iFeature] = 1;
			}
			else
			{
				_rgiFeatureStatus[iFeature] = 0;
			}
		}
		else
		{
			switch (pfcomp->bop)
			{
				case boolopOr:
					if (pfcomp->fPresent)
					{
						_rgiFeatureStatus[iFeature] = 1;
					}
					break;
				case boolopAnd:
					if (!pfcomp->fPresent)
					{
						_rgiFeatureStatus[iFeature] = 0;
					}
					break;
				default:
					assert(false);
					break;
			}

		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// RDoSVMCalc
//
// Does the actual support vector machine calculation.
// Returns the probability that the message is spam
/////////////////////////////////////////////////////////////////////////////
REAL MAILFILTER::RDoSVMCalc()
{
	REAL rAccum; // accumulator for result
	REAL rResult;

	rAccum = 0.0;
	for (UINT i = 0; i < _cFeatures; i++)
	{
		if (_rgiFeatureStatus[i] == 1)
			rAccum+=rgrSVMWeights[i];
		else if (_rgiFeatureStatus[i] != 0)
			assert(false);
	}
	// Apply threshold;
	rAccum -= _rThresh;

	// Apply sigmoid
	rResult = (1 / (1 + exp((_rCC * rAccum) + _rDD)));

	return rResult;
}

/*
// for timing version
#include <sys\\types.h> 
#include <sys\\timeb.h>
*/

//#include "..\SpamLearner\MailIndexer.cpp"

/////////////////////////////////////////////////////////////////////////////
// BCalculateSpamProb
//
// Calculates the probability that the current message is spam.
// Returns the probability (0 to 1) that the message is spam in prSpamProb
// the boolean return is determined by comparing to the spam cutoff
/////////////////////////////////////////////////////////////////////////////
bool MAILFILTER::BCalculateSpamProb(/* IN params */
							char *szFrom,
							char *szTo,
							char *szSubject,
							char *szBody,
							bool bDirectMessage,
							bool bHasAttach,
							FILETIME tMessageSent,
							/* OUT params */
							REAL *prSpamProb, 
							bool * pbIsSpam)
{
	//_strFName = "d:\\test\\test.lko";
	//_strFName = "G:\\SPAM\\SPAM.lko";

	_szFrom = szFrom;
	_szTo = szTo;        
	_szSubject = szSubject;   
	_szBody = szBody;      
	_bDirectMessage = bDirectMessage;
	_bHasAttach = bHasAttach;
	_tMessageSent = tMessageSent;

	EvaluateFeatureComponents();
	//ProcessMessage(_szFrom, _szTo, _szSubject, _szBody);
	ProcessFeatureComponentPresence();

	*prSpamProb = RDoSVMCalc();
	
	*pbIsSpam = (*prSpamProb>(_rSpamCutoff/100));

	return true;


/* timing version
	_timeb start, finish;
	int ij = strlen(szBody);

	_ftime( &start );

	ReadSVMOutput("d:\\test\\test.lko");

	for (int i=0;i<1000;i++)
	{
		ProcessMessage(szFrom, szTo, szSubject, szBody);
		DetermineFeatureStatus(bDirectMessage);

		*pr = RDoSVMCalc();
	}
	
	_ftime( &finish );
	*pr = (finish.time-start.time + (finish.millitm-start.millitm)/1000.0);
	return true;
	*/
}

/////////////////////////////////////////////////////////////////////////////
// BReadDefaultSpamCutoff
//
// Reads the default spam cutoff without parsing entire file
// Use GetDefaultSpamCutoff if using FSetSVMDataLocation;
// static member function
/////////////////////////////////////////////////////////////////////////////
bool MAILFILTER::BReadDefaultSpamCutoff(char *szFullPath, REAL *prDefCutoff)
{
	try 
	{
		CStdioFile sfile(szFullPath, CFile::modeRead);
		CString strBuf;
		
		// skip first three lines
		if ((!sfile.ReadString(strBuf)) ||
			(!sfile.ReadString(strBuf)) ||
			(!sfile.ReadString(strBuf)) ||
			(!sfile.ReadString(strBuf)))
		{
			return false;
		}
		char *pszDefThresh = strstr(&((LPCTSTR)strBuf)[11], ::szDefaultThresh);
		assert(pszDefThresh != NULL);
		if (pszDefThresh == NULL)
		{
			return false;
		}
		pszDefThresh += strlen(::szDefaultThresh);
		*prDefCutoff = stod(pszDefThresh, NULL);
		if (*prDefCutoff < .9 ) // since the default has been shifted to 2 std dev, we only take it if it is greater than .9
		{
			*prDefCutoff = 0.9;
		}
	}
	catch (CFileException *)
	{
		return false;
	}

	return true;
}


/////////////////////////////////////////////////////////////////////////////
// FSetSVMDataLocation
//
// Sets the location of the SVM Data file(.LKO file). Must be called before 
// calling any other methods
// Data file must be present at time function is called
// returns true if successful, false otherwise
/////////////////////////////////////////////////////////////////////////////
bool MAILFILTER::FSetSVMDataLocation(char *szFullPath)
{
	if (_strFName != szFullPath)
	{
		_strFName = szFullPath;
		if (!ReadSVMOutput(_strFName))
		{
#ifdef DEBUG
			char szErr[200];
			wnsprintf(szErr, ARRAYSIZE(szErr), "Unable to successfully read filter params from %s", _strFName);
			MessageBox(NULL, szErr, "Junk mail filter error", MB_APPLMODAL | MB_OK);
#endif
			return false;
		}
	}
	
	return true;
}


/////////////////////////////////////////////////////////////////////////////
// Property set methods
//
/////////////////////////////////////////////////////////////////////////////
void MAILFILTER::SetFirstName(char *szFirstName)
{
	SAFE_FREE( _szFirstName );
	if (szFirstName!=NULL)
	{
		_szFirstName = strdup(szFirstName);
		_strupr(_szFirstName);
	}
	else
	{
		_szFirstName = NULL;
	}
}

void MAILFILTER::SetLastName(char *szLastName)
{
	SAFE_FREE( _szLastName );
	if (szLastName!=NULL)
	{
		_szLastName = strdup(szLastName);
		_strupr(_szLastName);
	}
	else
	{
		_szLastName = NULL;
	}
}

void MAILFILTER::SetCompanyName(char *szCompanyName)
{
	SAFE_FREE( _szCompanyName );
	if (szCompanyName!=NULL)
	{
		_szCompanyName = strdup(szCompanyName);
		_strupr(_szCompanyName);
	}
	else
	{
		_szCompanyName = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////
// Constructor/destructor
//
/////////////////////////////////////////////////////////////////////////////
MAILFILTER::MAILFILTER()
{
	_szFirstName = NULL;
	_szLastName = NULL;
	_szCompanyName = NULL;

	_rDefaultThresh = -1;
	_rThresh = -1;
	_cFeatureComps = 0;
	rgrSVMWeights = NULL;
}

MAILFILTER::~MAILFILTER()
{
	SAFE_FREE( _szFirstName );
	SAFE_FREE( _szLastName );
	SAFE_FREE( _szCompanyName );

	for (unsigned int i=0;i<_cFeatureComps;i++)
		rgfeaturecomps[i].~FeatureComponent();

	SAFE_FREE( rgrSVMWeights );
	SAFE_FREE( _rgiFeatureStatus );
	SAFE_FREE( rgfeaturecomps );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oemiglib\dllmain.cpp ===
//--------------------------------------------------------------------------
// Dllmain.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "shared.h"

//--------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------
IMalloc            *g_pMalloc=NULL;
HINSTANCE           g_hInst=NULL;
LONG                g_cRef=0;
LONG                g_cLock=0;
CRITICAL_SECTION    g_csDllMain={0};

//--------------------------------------------------------------------------
// DllMain
//--------------------------------------------------------------------------
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved)
{
    // DLL_PROCESS_ATTACH
    if (DLL_PROCESS_ATTACH == dwReason)
    {
	    g_hInst = hInst;
        CoGetMalloc(1, &g_pMalloc);
        InitializeCriticalSection(&g_csDllMain);
        DisableThreadLibraryCalls(hInst);
    }

    // DLL_PROCESS_DETACH
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        DeleteCriticalSection(&g_csDllMain);
        SafeRelease(g_pMalloc);
    }

    // Done
    return(TRUE);
}

// --------------------------------------------------------------------------------
// DllAddRef
// --------------------------------------------------------------------------------
ULONG DllAddRef(void)
{
    return((ULONG)InterlockedIncrement(&g_cRef));
}

// --------------------------------------------------------------------------------
// DllRelease
// --------------------------------------------------------------------------------
ULONG DllRelease(void)
{
    return((ULONG)InterlockedDecrement(&g_cRef));
}

// --------------------------------------------------------------------------------
// DllCanUnloadNow
// --------------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    EnterCriticalSection(&g_csDllMain);
    HRESULT hr = (0 == g_cRef && 0 == g_cLock) ? S_OK : S_FALSE;
    LeaveCriticalSection(&g_csDllMain);
    return(hr);
}

// --------------------------------------------------------------------------------
// DllRegisterServer
// --------------------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    return(CallRegInstall(g_hInst, g_hInst, c_szReg, NULL));
}

// --------------------------------------------------------------------------------
// DllUnregisterServer
// --------------------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    return(CallRegInstall(g_hInst, g_hInst, c_szUnReg, NULL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oejunk\original\svmutil.cpp ===
/*

  SVMUTIL.CPP
  (c) copyright 1998 Microsoft Corp

  Shared utility functions

  Robert Rounthwaite (RobertRo@microsoft.com)

*/
#include <afx.h>
#include <assert.h>


/////////////////////////////////////////////////////////////////////////////
// FWordPresent
//
// Determines if the given "word" is present in the Text. A word in this
// case is any string of characters with a non-alpha character on either
// side (or with the beginning or end of the text on either side).
// Case sensitive.
/////////////////////////////////////////////////////////////////////////////
bool FWordPresent(char *szText, char *szWord)
{
	assert(szText != NULL);

	if (szWord != NULL)
	{
		char *szLoc;
		UINT cbSz = strlen(szWord);
		do
		{
			szLoc = strstr(szText, szWord);
			if (szLoc != NULL)
			{
				// this code checks to see that the spot we found is a "word" and not a subword
				// we want the character before and after to be !isalnum, unless the character on that end of the 
				// string already is !isalnum (or we're at the beginning of the string, for the char before)
				if ((!isalnum(*szLoc) || ((szLoc == szText) || !isalnum(*(szLoc-1)))) && // prev char is not alnum and
					((!isalnum(szLoc[cbSz-1])) || (!isalnum(szLoc[cbSz]))))	 			     // next char is not alnum
				{
					// we've found the word!
					return true;
				}
				szText = szLoc + cbSz;
			}
		}
		while (szLoc != NULL); // note dependency on exit condition in if above
	}
	return false;
}

/////////////////////////////////////////////////////////////////////////////
// Special feature implementations
//
/////////////////////////////////////////////////////////////////////////////

inline BOOL BIsWhiteSpace(const char c)
{
	return isspace(c);
}
// This feature is 20% of first 50 words contain no lowercase letters (includes words with no letters at all)
// p20_BODY_INTRO_UPPERCASE_WORDS
bool SpecialFeatureUpperCaseWords(char *pszText)
{
	UINT cWords = 0;
	UINT cNonLowerWords = 0;
	bool bHasLowerLetter = false;
	char *pszPos = pszText;				 

	if (pszText == NULL)
	{
		return false;
	}

	while (BIsWhiteSpace(*pszPos))
	{
		pszPos++;
	}
	while ((*pszPos != '\0') && (cWords < 50))
	{
		if (BIsWhiteSpace(*pszPos)) // word end
		{
			cWords++;
			if (!bHasLowerLetter)
			{
				cNonLowerWords++;
			}
			else
			{
				bHasLowerLetter = false;
			}
		}
		else
		{
			bHasLowerLetter |= (islower(*pszPos) != FALSE);
		}
		pszPos++;
	}

	return (cWords>0) && ((cNonLowerWords/(double)cWords) >= 0.25);
}

// This feature is: 6% of first 200 non-space and non-numeric characters aren't letters
// p20_BODY_INTRO_NONALPHA
bool SpecialFeatureNonAlpha(char *pszText)
{
	UINT cChars = 0;
	UINT cNonAlphaChars = 0;
	char *pszPos = pszText;				 

	if (pszText == NULL)
	{
		return false;
	}

	while (BIsWhiteSpace(*pszPos))
	{
		pszPos++;
	}
	while ((*pszPos != '\0') && (cChars < 200))
	{
		if ((!BIsWhiteSpace(*pszPos)) && (!isdigit(*pszPos))) // character
		{
			cChars++;
			if (!isalpha(*pszPos))
			{
				cNonAlphaChars++;
			}
		}
		pszPos++;
	}

	return (cChars>0) && ((cNonAlphaChars/(double)cChars) >= 0.08);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oemiglib\dllmain.h ===
//--------------------------------------------------------------------------
// Dllmain.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Globals
//--------------------------------------------------------------------------
extern IMalloc            *g_pMalloc;
extern HINSTANCE           g_hInst;
extern LONG                g_cRef;
extern LONG                g_cLock;
extern CRITICAL_SECTION    g_csDllMain;

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
ULONG DllRelease(void);
ULONG DllAddRef(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oemiglib\factory.cpp ===
//--------------------------------------------------------------------------
// Factory.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "factory.h"
#include "oe5imp.h"

//--------------------------------------------------------------------------
// Constants
//--------------------------------------------------------------------------
#define OBJTYPE0        0
#define OBJTYPE1        OIF_ALLOWAGGREGATION

//--------------------------------------------------------------------------
// Global Object Info Table
//--------------------------------------------------------------------------
static CClassFactory g_rgFactory[] = {
    CClassFactory(&CLSID_COE5Import, OBJTYPE0, (PFCREATEINSTANCE)COE5Import_CreateInstance)
};
                 
//--------------------------------------------------------------------------
// DllGetClassObject
//--------------------------------------------------------------------------
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       i;

    // Bad param
    if (ppv == NULL)
    {
        hr = TraceResult(E_INVALIDARG);
        goto exit;
    }

    // No memory allocator
    if (NULL == g_pMalloc)
    {
        hr = TraceResult(E_OUTOFMEMORY);
        goto exit;
    }

    // Find Object Class
    for (i=0; i<ARRAYSIZE(g_rgFactory); i++)
    {
        // Compare for clsids
        if (IsEqualCLSID(rclsid, *g_rgFactory[i].m_pclsid))
        {
            // Delegate to the factory
            IF_FAILEXIT(hr = g_rgFactory[i].QueryInterface(riid, ppv));

            // Done
            goto exit;
        }
    }

    // Otherwise, no class
    hr = TraceResult(CLASS_E_CLASSNOTAVAILABLE);

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// CClassFactory::CClassFactory
//--------------------------------------------------------------------------
CClassFactory::CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance)
    : m_pclsid(pclsid), m_dwFlags(dwFlags), m_pfCreateInstance(pfCreateInstance)
{
}

//--------------------------------------------------------------------------
// CClassFactory::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    // Invalid Arg
    if (NULL == ppvObj)
        return TraceResult(E_INVALIDARG);

    // IClassFactory or IUnknown
    if (!IsEqualIID(riid, IID_IClassFactory) && !IsEqualIID(riid, IID_IUnknown))
        return TraceResult(E_NOINTERFACE);

    // Return the Class Facotry
    *ppvObj = (LPVOID)this;

    // Add Ref the dll
    DllAddRef();

    // Done
    return S_OK;
}

//--------------------------------------------------------------------------
// CClassFactory::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::AddRef(void)
{
    DllAddRef();
    return 2;
}

//--------------------------------------------------------------------------
// CClassFactory::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CClassFactory::Release(void)
{
    DllRelease();
    return 1;
}

//--------------------------------------------------------------------------
// CClassFactory::CreateInstance
//--------------------------------------------------------------------------
STDMETHODIMP CClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObj)
{
    // Locals
    HRESULT         hr=S_OK;
    IUnknown       *pObject=NULL;

    // Bad param
    if (ppvObj == NULL)
        return TraceResult(E_INVALIDARG);

    // Init
    *ppvObj = NULL;

    // Verify that a controlling unknown asks for IUnknown
    if (NULL != pUnkOuter && IID_IUnknown != riid)
        return TraceResult(CLASS_E_NOAGGREGATION);

    // No memory allocator
    if (NULL == g_pMalloc)
        return TraceResult(E_OUTOFMEMORY);

    // Can I do aggregaton
    if (pUnkOuter !=NULL && !(m_dwFlags & OIF_ALLOWAGGREGATION))  
        return TraceResult(CLASS_E_NOAGGREGATION);

    // Create the object...
    IF_FAILEXIT(hr = CreateObjectInstance(pUnkOuter, &pObject));

    // Aggregated, then we know we're looking for an IUnknown, return pObject, otherwise, QI
    if (pUnkOuter)
    {
        // Matches Release after Exit
        pObject->AddRef();

        // Return pObject::IUnknown
        *ppvObj = (LPVOID)pObject;
    }

    // Otherwise
    else
    {
        // Get the interface requested from pObj
        IF_FAILEXIT(hr = pObject->QueryInterface(riid, ppvObj));
    }
   
exit:
    // Cleanup
    SafeRelease(pObject);

    // Done
    Assert(FAILED(hr) ? NULL == *ppvObj : TRUE);
    return(hr);
}

//--------------------------------------------------------------------------
// CClassFactory::LockServer
//--------------------------------------------------------------------------
STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock) InterlockedIncrement(&g_cLock);
    else       InterlockedDecrement(&g_cLock);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oemiglib\factory.h ===
//--------------------------------------------------------------------------
// Factory.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
class CClassFactory;

//--------------------------------------------------------------------------
// Object Flags
//--------------------------------------------------------------------------
#define OIF_ALLOWAGGREGATION  0x0001

//--------------------------------------------------------------------------
// Object Creation Prototypes
//--------------------------------------------------------------------------
typedef HRESULT (APIENTRY *PFCREATEINSTANCE)(IUnknown *pUnkOuter, IUnknown **ppUnknown);
#define CreateObjectInstance (*m_pfCreateInstance)

//--------------------------------------------------------------------------
// ClassFactory
//--------------------------------------------------------------------------
class CClassFactory : public IClassFactory
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    CClassFactory(CLSID const *pclsid, DWORD dwFlags, PFCREATEINSTANCE pfCreateInstance);

    //----------------------------------------------------------------------
    // IUnknown members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IClassFactory members
    //----------------------------------------------------------------------
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);

public:
    //----------------------------------------------------------------------
    // Data
    //----------------------------------------------------------------------
    CLSID const        *m_pclsid;
    DWORD               m_dwFlags;
    PFCREATEINSTANCE    m_pfCreateInstance;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oemiglib\makefile.inc ===
$(O)\oemiglib.res : $(O)\selfreg.inf

selfreg.src : reg.src strings.src

$(O)\selfreg.inx : selfreg.src
    cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
    $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oemiglib\resource.h ===
// --------------------------------------------------------------------------------
// Resource.h
// --------------------------------------------------------------------------------
#define IDD_IMPORTOE5                   101
#define IDC_FROM_ID                     1000
#define IDC_IDLIST                      1001
#define IDC_FROM_DIRECTORY              1002
#define IDC_OE5ONLY                     1003
#define IDS_SELECT_ID                   1006
#define IDS_TITLE                       1007
#define IDS_CANT_IMPORT_ID              1008
#define IDC_STATIC                      -1
#define IDD_PASSWORD                    1009
#define IDS_PROMPT                      1010
#define IDE_PASSWORD                    1011
#define IDS_PASSWORD_ERROR              1012
#define IDS_ACCESS_DENIED               1013
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\public\inc\mimedisp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996-1997               **
//*********************************************************************

#ifndef __MIMEDISP_H__
#define __MIMEDISP_H__

#define DISPID_IMIMEEDIT_BASE       100

#define DISPID_IMIMEEDIT_SRC        (DISPID_IMIMEEDIT_BASE + 1)
#define DISPID_IMIMEEDIT_STYLE      (DISPID_IMIMEEDIT_BASE + 2)
#define DISPID_IMIMEEDIT_EDITMODE   (DISPID_IMIMEEDIT_BASE + 3)
#define DISPID_IMIMEEDIT_MSGSRC     (DISPID_IMIMEEDIT_BASE + 4)
#define DISPID_IMIMEEDIT_TEXT       (DISPID_IMIMEEDIT_BASE + 5)
#define DISPID_IMIMEEDIT_HTML       (DISPID_IMIMEEDIT_BASE + 6)
#define DISPID_IMIMEEDIT_CLEAR      (DISPID_IMIMEEDIT_BASE + 7)
#define DISPID_IMIMEEDIT_DOCUMENT   (DISPID_IMIMEEDIT_BASE + 8)


#endif //__MIMEDISP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oemiglib\oe5imp.h ===
//--------------------------------------------------------------------------
// oe5imp.h
//--------------------------------------------------------------------------
#pragma once

//--------------------------------------------------------------------------
// Depends
//--------------------------------------------------------------------------
#include <newimp.h>
#include <oestore.h>
#include <shared.h>
#include <database.h>

//--------------------------------------------------------------------------
// Forward Decls
//--------------------------------------------------------------------------
typedef struct tagIMPFOLDERNODE IMPFOLDERNODE;
typedef struct tagFLDINFO *LPFLDINFO;

//--------------------------------------------------------------------------
// {A1006DE3-2173-11d2-9A7C-00C04FA309D4}
//--------------------------------------------------------------------------
DEFINE_GUID(CLSID_COE5Import, 0xa1006de3, 0x2173, 0x11d2, 0x9a, 0x7c, 0x0, 0xc0, 0x4f, 0xa3, 0x9, 0xd4);

//--------------------------------------------------------------------------
// IMPORTOPTIONS
//--------------------------------------------------------------------------
typedef struct tagIMPORTOPTIONS {
    CHAR            szStoreRoot[MAX_PATH + MAX_PATH];
    BOOL            fOE5Only;
} IMPORTOPTIONS, *LPIMPORTOPTIONS;

//--------------------------------------------------------------------------
// COE5EnumFolders
//--------------------------------------------------------------------------
class COE5EnumFolders : public IEnumFOLDERS
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    COE5EnumFolders(IMPFOLDERNODE *plist);
    ~COE5EnumFolders(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IEnumFOLDERS Members
    //----------------------------------------------------------------------
    STDMETHODIMP Next(IMPORTFOLDER *pfldr);
    STDMETHODIMP Reset(void);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG            m_cRef;
    IMPFOLDERNODE  *m_pList;
    IMPFOLDERNODE  *m_pNext;
};

//--------------------------------------------------------------------------
// COE5Import
//--------------------------------------------------------------------------
class COE5Import : public IMailImport
{
public:
    //----------------------------------------------------------------------
    // Construction
    //----------------------------------------------------------------------
    COE5Import(void);
    ~COE5Import(void);

    //----------------------------------------------------------------------
    // IUnknown Members
    //----------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //----------------------------------------------------------------------
    // IMailImport Members
    //----------------------------------------------------------------------
    STDMETHODIMP InitializeImport(HWND hwnd);
    STDMETHODIMP GetDirectory(LPSTR pszDir, UINT cch);
    STDMETHODIMP SetDirectory(LPSTR pszDir);
    STDMETHODIMP EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum);
    STDMETHODIMP ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport);

private:
    //----------------------------------------------------------------------
    // Private Methods
    //----------------------------------------------------------------------
    void _FreeFolderList(IMPFOLDERNODE *pNode);
    HRESULT _BuildFolderList(IDatabase *pDB);
    HRESULT _BuildFolderHierarchy(DWORD cDepth, FOLDERID idParent, IMPFOLDERNODE *pParent);

private:
    //----------------------------------------------------------------------
    // Private Data
    //----------------------------------------------------------------------
    LONG                m_cRef;
    CHAR                m_szDirectory[MAX_PATH];
    DWORD               m_cFolders;
    LPFOLDERINFO        m_prgFolder;
    IMPFOLDERNODE      *m_pList;
    BOOL                m_fGotMeSomeFolders;
    IMPORTOPTIONS       m_Options;
    IDatabase          *m_pFolderDB;
    IDatabaseSession   *m_pSession;
    HWND                m_hwndParent;
};

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
COE5Import_CreateInstance(IUnknown *pUnkOuter, IUnknown **ppUnknown);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\public\inc\wab.h ===
/*
 * WAB.H
 *
 * Top level public header for WAB API functions.
 *
 */

#include <wabdefs.h>
#include <wabcode.h>
#include <wabtags.h>
#include <wabutil.h>
#include <wabiab.h>
#include <wabapi.h>
#include <wabmem.h>
#include <wabnot.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\oemiglib\oe5imp.cpp ===
//--------------------------------------------------------------------------
// OE5Imp.cpp
//--------------------------------------------------------------------------
#include "pch.hxx"
#include "dllmain.h"
#include "oe5imp.h"
#include <impapi.h>
#include "resource.h"
#include <msident.h>
#include <oestore.h>
#include <shlwapi.h>

//--------------------------------------------------------------------------
// String Constants
//--------------------------------------------------------------------------
const static char c_szFoldersFile[] = "folders.dbx";
const static char c_szEmpty[]= "";

//--------------------------------------------------------------------------
// USERINFO
//--------------------------------------------------------------------------
typedef struct tagUSERINFO {
    CHAR        szIdNameA[CCH_IDENTITY_NAME_MAX_LENGTH];
    GUID        guidCookie;
    HKEY        hKey;
} USERINFO, *LPUSERINFO;

//--------------------------------------------------------------------------
// Prototypes
//--------------------------------------------------------------------------
INT_PTR CALLBACK ImportOptionsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

//--------------------------------------------------------------------------
// COE5Import_CreateInstance
//--------------------------------------------------------------------------
COE5Import_CreateInstance(IUnknown *pUnkOuter, IUnknown **ppUnknown)
{
    // Trace
    TraceCall("COE5Import_CreateInstance");

    // Initialize
    *ppUnknown = NULL;

    // Create me
    COE5Import *pNew=NULL;
    pNew = new COE5Import();
    if (NULL == pNew)
        return TraceResult(E_OUTOFMEMORY);

    // Cast to unknown
    *ppUnknown = SAFECAST(pNew, IMailImport *);

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// COE5Import::COE5Import
//--------------------------------------------------------------------------
COE5Import::COE5Import(void)
{
    TraceCall("COE5Import::COE5Import");
    m_cRef = 1;
    m_pList = NULL;
    *m_szDirectory = '\0';
    m_cFolders = 0;
    m_prgFolder = NULL;
    m_fGotMeSomeFolders = FALSE;
    m_pFolderDB = NULL;
    m_pSession = NULL;
    m_hwndParent = NULL;
    ZeroMemory(&m_Options, sizeof(IMPORTOPTIONS));
}

//--------------------------------------------------------------------------
// COE5Import::~COE5Import
//--------------------------------------------------------------------------
COE5Import::~COE5Import(void)
{
    TraceCall("COE5Import::~COE5Import");
    _FreeFolderList(m_pList);
    if (m_pFolderDB)
    {
        for (DWORD i=0;i<m_cFolders; i++)
        {
            m_pFolderDB->FreeRecord(&m_prgFolder[i]);
        }
    }
    SafeMemFree(m_prgFolder);
    SafeRelease(m_pFolderDB);
    SafeRelease(m_pSession);
}

//--------------------------------------------------------------------------
// COE5Import::_FreeFolderList
//--------------------------------------------------------------------------
void COE5Import::_FreeFolderList(IMPFOLDERNODE *pNode)
{
    // Locals
    IMPFOLDERNODE *pNext;
    IMPFOLDERNODE *pCurrent=pNode;

    // Loop
    while (pCurrent)
    {
        // Save next
        pNext = pCurrent->pnext;

        // Free Children ?
        if (pCurrent->pchild)
        {
            // Free
            _FreeFolderList(pCurrent->pchild);
        }

        // Free szName
        g_pMalloc->Free(pCurrent->szName);

        // Free pCurrent
        g_pMalloc->Free(pCurrent);

        // Set Current
        pCurrent = pNext;
    }
}

//--------------------------------------------------------------------------
// COE5Import::QueryInterface
//--------------------------------------------------------------------------
STDMETHODIMP COE5Import::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COE5Import::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IMailImport == riid)
        *ppv = (IMailImport *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE5Import::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COE5Import::AddRef(void)
{
    TraceCall("COE5Import::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// COE5Import::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COE5Import::Release(void)
{
    TraceCall("COE5Import::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// COE5Import::InitializeImport
//--------------------------------------------------------------------------
STDMETHODIMP COE5Import::InitializeImport(HWND hwnd)
{
    // Save this handle
    m_hwndParent = hwnd;

    // Do my UI
    return(IDOK == DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_IMPORTOE5), hwnd, ImportOptionsDlgProc, (LPARAM)&m_Options) ? S_OK : E_FAIL);
}

//--------------------------------------------------------------------------
// COE5Import::GetDirectory
//--------------------------------------------------------------------------
STDMETHODIMP COE5Import::GetDirectory(LPSTR pszDir, UINT cch)
{
    // Let Importer Ask for the Directory
    StrCpyN(pszDir, m_Options.szStoreRoot, cch);
    return(S_OK);
}

//--------------------------------------------------------------------------
// COE5Import::SetDirectory
//--------------------------------------------------------------------------
STDMETHODIMP COE5Import::SetDirectory(LPSTR pszDir)
{
    // Trace
    TraceCall("COE5Import::SetDirectory");

    // Save the Directory
    StrCpyN(m_szDirectory, pszDir, ARRAYSIZE(m_szDirectory));

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// COE5Import::EnumerateFolders
//--------------------------------------------------------------------------
STDMETHODIMP COE5Import::EnumerateFolders(DWORD_PTR dwCookie, IEnumFOLDERS **ppEnum)
{
    // Locals
    HRESULT             hr=S_OK;
    DWORD               cchDir;
    DWORD               cRows;
    CHAR                szFilePath[MAX_PATH + MAX_PATH];
    IMPFOLDERNODE      *pList;
    IMPFOLDERNODE      *pNode=(IMPFOLDERNODE *)dwCookie;
    COE5EnumFolders    *pEnum=NULL;
    HROWSET             hRowset=NULL;

    // Trace
    TraceCall("COE5Import::EnumerateFolders");

    // Invalid Args
    Assert(ppEnum);

    // Get Folders ?
    if (NULL == m_prgFolder && 0 == m_cFolders && FALSE == m_fGotMeSomeFolders)
    {
        // Append \Mail onto m_szDirectory
        cchDir = lstrlen(m_szDirectory);

        // Need a Wack ?
        if (m_szDirectory[cchDir - 1] != '\\')
            StrCatBuff(m_szDirectory, "\\", ARRAYSIZE(m_szDirectory));

        // Make Path to folders.nch file
        IF_FAILEXIT(hr = MakeFilePath(m_szDirectory, c_szFoldersFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));

        // Create an IDatabase
        IF_FAILEXIT(hr = CoCreateInstance(CLSID_DatabaseSession, NULL, CLSCTX_INPROC_SERVER, IID_IDatabaseSession, (LPVOID *)&m_pSession)); 

        // Open an IDatabase
        IF_FAILEXIT(hr = m_pSession->OpenDatabase(szFilePath, OPEN_DATABASE_NOCREATE | OPEN_DATABASE_NORESET | OPEN_DATABASE_NOEXTENSION | OPEN_DATABASE_EXCLUSEIVE, &g_FolderTableSchema, NULL, &m_pFolderDB));

        // Get Record Count
        IF_FAILEXIT(hr = m_pFolderDB->GetRecordCount(IINDEX_SUBSCRIBED, &m_cFolders));

        // Allocate Folder Array
        IF_NULLEXIT(m_prgFolder = (LPFOLDERINFO)ZeroAllocate(sizeof(FOLDERINFO) * m_cFolders));

        // Create a Rowset
        IF_FAILEXIT(hr = m_pFolderDB->CreateRowset(IINDEX_SUBSCRIBED, 0, &hRowset));

        // Read all the rows
        IF_FAILEXIT(hr = m_pFolderDB->QueryRowset(hRowset, m_cFolders, (LPVOID *)m_prgFolder, &cRows));

        // Validate
        Assert(m_cFolders == cRows);

        // Build Hierarchy
        IF_FAILEXIT(hr = _BuildFolderHierarchy(0, FOLDERID_LOCAL_STORE, NULL));

        // Got me some folders
        m_fGotMeSomeFolders = TRUE;
    }

    // Not Folders ?
    else if (NULL == m_prgFolder)
    {
        hr = TraceResult(E_FAIL);
        goto exit;
    }

    // What should I 
    if (dwCookie == COOKIE_ROOT)
        pList = m_pList;
    else
        pList = pNode->pchild;

    // Create Folder Enumerator
    IF_NULLEXIT(pEnum = new COE5EnumFolders(pList));

    // Return Enumerator
    *ppEnum = (IEnumFOLDERS *)pEnum;

    // Don't Free
    pEnum = NULL;

exit:
    // Cleanup
    if (hRowset && m_pFolderDB)
        m_pFolderDB->CloseRowset(&hRowset);
    SafeRelease(pEnum);

    // Try to show a good error....
    if (DB_E_ACCESSDENIED == hr)
    {
        // Locals
        CHAR szTitle[255];
        CHAR szError[255];

        // Get the error
        LoadString(g_hInst, IDS_ACCESS_DENIED, szError, 255);

        // Get tht title
        LoadString(g_hInst, IDS_TITLE, szTitle, 255);

        // Show the error
        MessageBox(m_hwndParent, szError, szTitle, MB_OK | MB_ICONEXCLAMATION);
    }
    
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE5Import::_BuildFolderHierarchy
//--------------------------------------------------------------------------
HRESULT COE5Import::_BuildFolderHierarchy(DWORD cDepth, FOLDERID idParent,
    IMPFOLDERNODE *pParent)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           i;
    DWORD           cchName;
    IMPFOLDERNODE  *pPrevious=NULL;
    IMPFOLDERNODE  *pNode;

    // Trace
    TraceCall("COE5Import::_BuildFolderHierarchy");

    // Walk through prgFolder and find items with parent of idParent
    for (i=0; i<m_cFolders; i++)
    {
        // Correct Parent ?
        if (idParent == m_prgFolder[i].idParent && m_prgFolder[i].pszFile && m_prgFolder[i].pszName)
        {
            // Allocate the Root
            IF_NULLEXIT(pNode = (IMPFOLDERNODE *)ZeroAllocate(sizeof(IMPFOLDERNODE)));

            // Set Parent
            pNode->pparent = pParent;

            // Set Depth
            pNode->depth = cDepth;

            // Get Length of Name
            cchName = lstrlen(m_prgFolder[i].pszName);

            // Copy name
            IF_NULLEXIT(pNode->szName = (LPSTR)g_pMalloc->Alloc(cchName + 1));

            // Copy name
            CopyMemory(pNode->szName, m_prgFolder[i].pszName, cchName + 1);

            // Count of Messages
            pNode->cMsg = m_prgFolder[i].cMessages;

            // Handle Non-special folder
            if (m_prgFolder[i].tySpecial > FOLDER_DRAFT)
                pNode->type = FOLDER_TYPE_NORMAL;

            // Otherwise, map to type
            else
                pNode->type = (IMPORTFOLDERTYPE)(m_prgFolder[i].tySpecial);

            // Set lParam
            pNode->lparam = i;

            // Link pNode into List
            if (pPrevious)
                pPrevious->pnext = pNode;
            else if (pParent)
                pParent->pchild = pNode;
            else
            {
                Assert(NULL == m_pList);
                m_pList = pNode;
            }

            // Set pPrevious
            pPrevious = pNode;

            // Enumerate Children
            IF_FAILEXIT(hr = _BuildFolderHierarchy(cDepth + 1, m_prgFolder[i].idFolder, pNode));
        }
    }

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE5Import::ImportFolder
//--------------------------------------------------------------------------
STDMETHODIMP COE5Import::ImportFolder(DWORD_PTR dwCookie, IFolderImport *pImport)
{
    // Locals
    HRESULT             hr=S_OK;
    LPFOLDERINFO        pFolder;
    CHAR                szFilePath[MAX_PATH + MAX_PATH];
    IMPFOLDERNODE      *pNode=(IMPFOLDERNODE *)dwCookie;
    IDatabaseSession   *pSession=NULL;
    IDatabase          *pDB=NULL;
    DWORD               cRecords;
    HROWSET             hRowset=NULL;
    MESSAGEINFO         Message;
    DWORD               dwMsgState = 0;
    IStream            *pStream=NULL;

    // Trace
    TraceCall("COE5Import::ImportFolder");

    // Set pFolder
    pFolder = &m_prgFolder[pNode->lparam];

    //  path
    IF_FAILEXIT(hr = MakeFilePath(m_szDirectory, pFolder->pszFile, c_szEmpty, szFilePath, ARRAYSIZE(szFilePath)));

    // Open an IDatabase
    Assert(m_pSession);
    IF_FAILEXIT(hr = m_pSession->OpenDatabase(szFilePath, OPEN_DATABASE_NORESET | OPEN_DATABASE_NOEXTENSION | OPEN_DATABASE_EXCLUSEIVE, &g_MessageTableSchema, NULL, &pDB));

    // Get the Record Count
    IF_FAILEXIT(hr = pDB->GetRecordCount(IINDEX_PRIMARY, &cRecords));

    // Set Message Count
    pImport->SetMessageCount(cRecords);

    // Create a Rowset
    IF_FAILEXIT(hr = pDB->CreateRowset(IINDEX_PRIMARY, 0, &hRowset));

    // Walk the Rowset
    while (S_OK == pDB->QueryRowset(hRowset, 1, (LPVOID *)&Message, NULL))
    {
        // Import it ?
        if (FALSE == m_Options.fOE5Only || !ISFLAGSET(Message.dwFlags, 0x00000010) && Message.faStream)
        {
            // Open the Stream
            if (SUCCEEDED(pDB->OpenStream(ACCESS_READ, Message.faStream, &pStream)))
            {
                // State
                dwMsgState = 0; // set initially to 0
                if (!ISFLAGSET(Message.dwFlags, ARF_READ))
                    FLAGSET(dwMsgState, MSG_STATE_UNREAD);
                if (ISFLAGSET(Message.dwFlags, ARF_UNSENT))
                    FLAGSET(dwMsgState, MSG_STATE_UNSENT);
                if (ISFLAGSET(Message.dwFlags, ARF_SUBMITTED))
                    FLAGSET(dwMsgState, MSG_STATE_SUBMITTED);
                if (IMSG_PRI_LOW == Message.wPriority)
                    FLAGSET(dwMsgState, MSG_PRI_LOW);
                else if (IMSG_PRI_HIGH == Message.wPriority)
                    FLAGSET(dwMsgState, MSG_PRI_HIGH);
                else
                    FLAGSET(dwMsgState, MSG_PRI_NORMAL);

                // Import It
                pImport->ImportMessage(MSG_TYPE_MAIL, dwMsgState, pStream, NULL, 0);

                // Cleanup
                SafeRelease(pStream);
            }
        }

        // Free It
        pDB->FreeRecord(&Message);
    }

exit:
    // Done
    if (pDB && hRowset)
        pDB->CloseRowset(&hRowset);
    SafeRelease(pStream);
    SafeRelease(pDB);
    SafeRelease(pSession);

    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE5EnumFolders::COE5EnumFolders
//--------------------------------------------------------------------------
COE5EnumFolders::COE5EnumFolders(IMPFOLDERNODE *pList)
{
    TraceCall("COE5EnumFolders::COE5EnumFolders");
    m_cRef = 1;
    m_pList = pList;
    m_pNext = pList;
}

//--------------------------------------------------------------------------
// COE5EnumFolders::COE5EnumFolders
//--------------------------------------------------------------------------
COE5EnumFolders::~COE5EnumFolders(void)
{
    TraceCall("COE5EnumFolders::~COE5EnumFolders");
}

//--------------------------------------------------------------------------
// COE5EnumFolders::COE5EnumFolders
//--------------------------------------------------------------------------
STDMETHODIMP COE5EnumFolders::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT     hr=S_OK;

    // Stack
    TraceCall("COE5EnumFolders::QueryInterface");

    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IEnumFOLDERS == riid)
        *ppv = (IEnumFOLDERS *)this;
    else
    {
        *ppv = NULL;
        hr = TraceResult(E_NOINTERFACE);
        goto exit;
    }

    // AddRef It
    ((IUnknown *)*ppv)->AddRef();

exit:
    // Done
    return(hr);
}

//--------------------------------------------------------------------------
// COE5EnumFolders::AddRef
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COE5EnumFolders::AddRef(void)
{
    TraceCall("COE5EnumFolders::AddRef");
    return InterlockedIncrement(&m_cRef);
}

//--------------------------------------------------------------------------
// COE5EnumFolders::Release
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) COE5EnumFolders::Release(void)
{
    TraceCall("COE5EnumFolders::Release");
    LONG cRef = InterlockedDecrement(&m_cRef);
    if (0 == cRef)
        delete this;
    return (ULONG)cRef;
}

//--------------------------------------------------------------------------
// COE5EnumFolders::Next
//--------------------------------------------------------------------------
STDMETHODIMP COE5EnumFolders::Next(IMPORTFOLDER *pFolder)
{
    // Locals
    HRESULT     hr=S_OK;

    // Trace
    TraceCall("COE5EnumFolders::Next");

    // Invalid Args
    Assert(pFolder != NULL);

    // Done
    if (NULL == m_pNext)
        return(S_FALSE);

    // Zero
    ZeroMemory(pFolder, sizeof(IMPORTFOLDER));

    // Store pNext into dwCookie
    pFolder->dwCookie = (DWORD_PTR)m_pNext;

    // Copy Folder Name
    StrCpyN(pFolder->szName, m_pNext->szName, ARRAYSIZE(pFolder->szName));

    // Copy Type
    pFolder->type = m_pNext->type;

    // Has Sub Folders ?
    pFolder->fSubFolders = (m_pNext->pchild != NULL);

    // Goto Next
    m_pNext = m_pNext->pnext;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// COE5EnumFolders::Reset
//--------------------------------------------------------------------------
STDMETHODIMP COE5EnumFolders::Reset(void)
{
    // Trace
    TraceCall("COE5EnumFolders::Reset");

    // Reset
    m_pNext = m_pList;

    // Done
    return(S_OK);
}

//--------------------------------------------------------------------------
// GetPasswordDlgProc
//--------------------------------------------------------------------------
#define CCHMAX_PASSWORDID 255
INT_PTR CALLBACK GetPasswordDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    HRESULT hr;
    CHAR szPrompt[255];
    CHAR szTitle[255 + CCH_IDENTITY_NAME_MAX_LENGTH];
    LPUSERINFO pUserInfo=(LPUSERINFO)GetWndThisPtr(hwnd);
    IUserIdentityManager *pManager;
    IPrivateIdentityManager *pPrivate;

    // Handle the Message
    switch(uMsg)
    {
    // Dialog Init
    case WM_INITDIALOG:
        // Store lParam...
        Assert(0 != lParam);
        pUserInfo = (LPUSERINFO)lParam;
        SetWndThisPtr(hwnd, lParam);

        // Get the title
        GetWindowText(GetDlgItem(hwnd, IDS_PROMPT), szPrompt, ARRAYSIZE(szPrompt) - 1);

        // Format the title
        wnsprintf(szTitle, ARRAYSIZE(szTitle), szPrompt, pUserInfo->szIdNameA);

        // Set the text
        SetWindowText(GetDlgItem(hwnd, IDS_PROMPT), szTitle);

        // Set Text Length
        SendMessage(GetDlgItem(hwnd, IDE_PASSWORD), EM_SETLIMITTEXT, 0, CCHMAX_PASSWORDID - 1);

        // Set the Focus
        SetFocus(GetDlgItem(hwnd, IDE_PASSWORD));

        // Done
        return(0);

    // Command
    case WM_COMMAND:

        // Handle ControlId
        switch(LOWORD(wParam))
        {
        // Ok
        case IDOK:

            // Create an Id Manager
            hr = CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, IID_IUserIdentityManager, (LPVOID *)&pManager); 
            if (SUCCEEDED(hr))
            {
                // Get the Private
                hr = pManager->QueryInterface(IID_IPrivateIdentityManager, (LPVOID *)&pPrivate);
                if (SUCCEEDED(hr))
                {
                    // Locals
                    CHAR szPassword[CCHMAX_PASSWORDID];
                    WCHAR wszPassword[CCHMAX_PASSWORDID];

                    // Get the password
                    GetWindowText(GetDlgItem(hwnd, IDE_PASSWORD), szPassword, ARRAYSIZE(szPassword));

                    // Convert to Unicode
                    hr = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szPassword, -1, wszPassword, CCHMAX_PASSWORDID);
                    if (SUCCEEDED(hr))
                    {
                        // Confirm the password
                        hr = pPrivate->ConfirmPassword(&pUserInfo->guidCookie, wszPassword);
                    }

                    // Release
                    pPrivate->Release();
                }

                // Release
                pManager->Release();
            }

            // Failure
            if (FAILED(hr))
            {
                // Locals
                CHAR szRes[255];
                CHAR szTitle[255];

                // Get the error
                LoadString(g_hInst, IDS_PASSWORD_ERROR, szRes, 255);

                // Get tht title
                LoadString(g_hInst, IDS_TITLE, szTitle, 255);

                // Show the error
                MessageBox(hwnd, szRes, szTitle, MB_OK | MB_ICONEXCLAMATION);
            }

            // Otherwise, all good
            else
                EndDialog(hwnd, IDOK);

            // Done
            return(1);

        // Cancel
        case IDCANCEL:
            EndDialog(hwnd, IDCANCEL);
            return(1);
        }
    }

    // Not Handled
    return(0);
}

//--------------------------------------------------------------------------
// ImportOptionsDlgProc
//--------------------------------------------------------------------------
INT_PTR CALLBACK ImportOptionsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Locals
    HRESULT hr;
    IUserIdentityManager *pManager;
    DWORD cIds=0;
    LPIMPORTOPTIONS pOptions=(LPIMPORTOPTIONS)GetWndThisPtr(hwnd);

    // Handle the Message
    switch(uMsg)
    {
    // Dialog Init
    case WM_INITDIALOG:
        {
            // Store lParam...
            Assert(0 != lParam);
            SetWndThisPtr(hwnd, lParam);

            // Create an Id Manager
            hr = CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, IID_IUserIdentityManager, (LPVOID *)&pManager); 
            if (SUCCEEDED(hr))
            {
                // Enumerator
                IEnumUserIdentity *pEnum;

                // Enumerate Ids
                hr = pManager->EnumIdentities(&pEnum);
                if (SUCCEEDED(hr))
                {
                    // Locals
                    IUnknown *pUnk;
                    ULONG cFetched;

                    // Walk the ids
                    while (S_OK == pEnum->Next(1, &pUnk, &cFetched))
                    {
                        // Locals
                        IUserIdentity *pId;

                        // Get IUserIdentity
                        hr = pUnk->QueryInterface(IID_IUserIdentity, (LPVOID *)&pId);
                        if (SUCCEEDED(hr))
                        {
                            // Locals
                            WCHAR szIdNameW[CCH_IDENTITY_NAME_MAX_LENGTH];

                            // Get the Name
                            hr = pId->GetName(szIdNameW, CCH_IDENTITY_NAME_MAX_LENGTH);
                            if (SUCCEEDED(hr))
                            {
                                // Locals
                                CHAR szIdNameA[CCH_IDENTITY_NAME_MAX_LENGTH];

                                // Convert to ansi
                                hr = WideCharToMultiByte(CP_ACP, 0, (WCHAR *)szIdNameW, -1, szIdNameA, CCH_IDENTITY_NAME_MAX_LENGTH, NULL, NULL);
                                if (SUCCEEDED(hr))
                                {
                                    // Locals
                                    HKEY hKey=NULL;

                                    // Get the hKey for this user...
                                    hr = pId->OpenIdentityRegKey(KEY_READ, &hKey);
                                    if (SUCCEEDED(hr))
                                    {
                                        // Locals
                                        GUID guidCookie;

                                        // Get the Id Cookie 
                                        hr = pId->GetCookie(&guidCookie);
                                        if (SUCCEEDED(hr))
                                        {
                                            // Locals
                                            LPUSERINFO pUserInfo;

                                            // Allocate it
                                            pUserInfo = (LPUSERINFO)CoTaskMemAlloc(sizeof(USERINFO));

                                            // Allocate a Place to store this
                                            if (pUserInfo)
                                            {
                                                // Locals
                                                LRESULT iItem;

                                                // Store the Data
                                                pUserInfo->hKey = hKey;
                                                pUserInfo->guidCookie = guidCookie;
                                                StrCpyN(pUserInfo->szIdNameA, szIdNameA, ARRAYSIZE(pUserInfo->szIdNameA));

                                                // Add the String
                                                iItem = SendMessage(GetDlgItem(hwnd, IDC_IDLIST), LB_ADDSTRING, 0, (LPARAM)szIdNameA);

                                                // Store the key as item data...
                                                SendMessage(GetDlgItem(hwnd, IDC_IDLIST), LB_SETITEMDATA, iItem, (LPARAM)pUserInfo);

                                                // Increment Count
                                                cIds++;

                                                // Don't Close It
                                                hKey = NULL;
                                            }
                                        }

                                        // Close the Key
                                        if (hKey)
                                            RegCloseKey(hKey);
                                    }
                                }
                            }

                            // Release pId
                            pId->Release();
                        }

                        // Release pUnk
                        pUnk->Release();

                        // Done
                        if (FAILED(hr))
                            break;
                    }

                    // Release
                    pEnum->Release();
                }

                // Release
                pManager->Release();
            }

            // If there are ids
            if (cIds > 0)
            {
                CheckDlgButton(hwnd, IDC_FROM_ID, BST_CHECKED);
                SendMessage(GetDlgItem(hwnd, IDC_IDLIST), LB_SETSEL, TRUE, 0);
                SetFocus(GetDlgItem(hwnd, IDC_IDLIST));
                return(0);
            }

            // Otherwise...
            else
            {
                CheckDlgButton(hwnd, IDC_FROM_DIRECTORY, BST_CHECKED);
                EnableWindow(GetDlgItem(hwnd, IDC_FROM_ID), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_IDLIST), FALSE);
                return(1);
            }
        }

    // Command
    case WM_COMMAND:

        // Handle ControlId
        switch(LOWORD(wParam))
        {
        // Ok
        case IDOK:
        case IDCANCEL:

            // Ok ?
            if (IDOK == LOWORD(wParam))
            {
                // Option Checked to get oe5 only mail?
                pOptions->fOE5Only = IsDlgButtonChecked(hwnd, IDC_OE5ONLY);

                // Importing form Ids
                if (IsDlgButtonChecked(hwnd, IDC_FROM_ID))
                {
                    // Locals
                    HKEY        hOE;
                    LRESULT     iSel;
                    LONG        lResult;
                    DWORD       dwType;
                    LPUSERINFO  pUserInfo;

                    // Get the Selected Item
                    iSel = SendMessage(GetDlgItem(hwnd, IDC_IDLIST), LB_GETCURSEL, 0, 0);
                    if (LB_ERR == iSel)
                    {
                        // Locals
                        CHAR szRes[255];
                        CHAR szTitle[255];

                        // Get the error
                        LoadString(g_hInst, IDS_SELECT_ID, szRes, 255);

                        // Get tht title
                        LoadString(g_hInst, IDS_TITLE, szTitle, 255);

                        // Show the error
                        MessageBox(hwnd, szRes, szTitle, MB_OK | MB_ICONEXCLAMATION);

                        // Put focus where the user should correct their mistake
                        SetFocus(GetDlgItem(hwnd, IDC_IDLIST));

                        // Done
                        return(1);
                    }

                    // Get the hKey
                    pUserInfo = (LPUSERINFO)SendMessage(GetDlgItem(hwnd, IDC_IDLIST), LB_GETITEMDATA, iSel, 0);

                    // Create an Id Manager
                    hr = CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, IID_IUserIdentityManager, (LPVOID *)&pManager); 
                    if (SUCCEEDED(hr))
                    {
                        // Locals
                        IPrivateIdentityManager *pPrivate;

                        // Get the Private
                        hr = pManager->QueryInterface(IID_IPrivateIdentityManager, (LPVOID *)&pPrivate);
                        if (SUCCEEDED(hr))
                        {
                            // Locals
                            WCHAR wszPassword[CCHMAX_PASSWORDID];

                            // Init
                            *wszPassword = L'\0';

                            // Confirm the password
                            hr = pPrivate->ConfirmPassword(&pUserInfo->guidCookie, wszPassword);

                            // Release
                            pPrivate->Release();
                        }

                        // Release
                        pManager->Release();
                    }

                    // Set hr
                    if (S_OK != hr)
                    {
                        // Get the password...
                        if (IDCANCEL == DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_PASSWORD), hwnd, GetPasswordDlgProc, (LPARAM)pUserInfo))
                        {
                            // Don't Import
                            return(1);
                        }
                    }

                    // Format path to the OE key...
                    lResult = RegOpenKeyEx(pUserInfo->hKey, "Software\\Microsoft\\Outlook Express\\5.0", 0, KEY_READ, &hOE);
                    if (ERROR_SUCCESS == lResult)
                    {
                        // Set cb
                        DWORD cb = ARRAYSIZE(pOptions->szStoreRoot);

                        // Get the Store Root
                        lResult = RegQueryValueEx(hOE, "Store Root", NULL, &dwType, (LPBYTE)pOptions->szStoreRoot, &cb);

                        // Success
                        if (ERROR_SUCCESS == lResult)
                        {
                            // Expand the string's enviroment vars
                            if (dwType == REG_EXPAND_SZ)
                            {
                                // Locals
                                CHAR szExpanded[MAX_PATH + MAX_PATH];

                                // Expand enviroment strings
                                ExpandEnvironmentStrings(pOptions->szStoreRoot, szExpanded, ARRAYSIZE(szExpanded));

                                // Copy into szRoot
                                StrCpyN(pOptions->szStoreRoot, szExpanded, ARRAYSIZE(pOptions->szStoreRoot));
                            }
                        }

                        // Close the Key
                        RegCloseKey(hOE);
                    }

                    // Failure ?
                    if (ERROR_SUCCESS != lResult)
                    {
                        // Locals
                        CHAR szRes[255];
                        CHAR szTitle[255];

                        // Get the error
                        LoadString(g_hInst, IDS_CANT_IMPORT_ID, szRes, 255);

                        // Get tht title
                        LoadString(g_hInst, IDS_TITLE, szTitle, 255);

                        // Show the error
                        MessageBox(hwnd, szRes, szTitle, MB_OK | MB_ICONEXCLAMATION);

                        // Put focus where the user should correct their mistake
                        SetFocus(GetDlgItem(hwnd, IDC_IDLIST));

                        // Done
                        return(1);
                    }
                }
            }

            // Delete all the hkey
            cIds = (int) SendMessage(GetDlgItem(hwnd, IDC_IDLIST), LB_GETCOUNT, 0, 0);
            if (LB_ERR != cIds)
            {
                // Loop through the items
                for (LRESULT iItem=0; iItem<(LRESULT)cIds; iItem++)
                {
                    // Get the hKey
                    LPUSERINFO pUserInfo = (LPUSERINFO)SendMessage(GetDlgItem(hwnd, IDC_IDLIST), LB_GETITEMDATA, iItem, 0);

                    // Close the Reg Key
                    RegCloseKey(pUserInfo->hKey);

                    // Free pUserInfo
                    CoTaskMemFree(pUserInfo);
                }
            }

            // Fone with dialog
            EndDialog(hwnd, LOWORD(wParam));

            // Done
            return(1);

        // Id List
        case IDC_FROM_DIRECTORY:
        case IDC_FROM_ID:
            {
                BOOL f = IsDlgButtonChecked(hwnd, IDC_FROM_ID);
                EnableWindow(GetDlgItem(hwnd, IDC_IDLIST), f);
            }
            return(1);
        }
        
        // Done
        break;
    }

    // Not Handled
    return(0);
}


IMailImport *OE5SimpleCreate(PSTR pszDir)
{
    HRESULT hr = S_OK;

    // Trace
    TraceCall("OE5SimpleCreate");

    // Create me
    COE5Import *pNew=NULL;
    pNew = new COE5Import();
    IF_NULLEXIT(pNew);

    hr = pNew->SetDirectory(pszDir);
    if (FAILED(hr)) {
        pNew->Release();
        pNew = NULL;
    }

exit:

    return (IMailImport *)pNew;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\public\inc\wabapi.h ===
#ifndef _WABAPI_H_
#define _WABAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN16
#ifdef GetLastError
#undef GetLastError
#endif // GetLastError
#endif // WIN16

typedef struct _WABACTIONITEM * LPWABACTIONITEM;

/* IWABObject Interface ---------------------------------------------------- */

#define CBIWABOBJECT sizeof(IWABOBJECT)


#define WAB_IWABOBJECT_METHODS(IPURE)                       \
        MAPIMETHOD(GetLastError)                            \
            (THIS_  HRESULT hResult,                        \
                    ULONG   ulFlags,                        \
                    LPMAPIERROR FAR * lppMAPIError) IPURE;  \
        MAPIMETHOD(AllocateBuffer)                          \
            (THIS_  ULONG   cbSize,                         \
                    LPVOID FAR *    lppBuffer) IPURE;       \
        MAPIMETHOD(AllocateMore)                            \
            (THIS_  ULONG   cbSize,                         \
                    LPVOID  lpObject,                       \
                    LPVOID  FAR *   lppBuffer) IPURE;       \
        MAPIMETHOD(FreeBuffer)                              \
            (THIS_  LPVOID  lpBuffer) IPURE;                \
        MAPIMETHOD(Backup)                                  \
            (THIS_  LPSTR  lpFileName) IPURE;              \
        MAPIMETHOD(Import)                                  \
            (THIS_  LPSTR lpImportParam) IPURE;           \
        MAPIMETHOD(Find)                                    \
            (THIS_  LPADRBOOK lpIAB,                        \
                    HWND    hWnd) IPURE;                    \
        MAPIMETHOD(VCardDisplay)                            \
            (THIS_  LPADRBOOK lpIAB,                        \
                    HWND    hWnd,                           \
                    LPSTR  lpszFileName) IPURE;            \
        MAPIMETHOD(LDAPUrl)                                 \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    HWND        hWnd,                       \
                    ULONG       ulFlags,                    \
                    LPSTR       lpszURL,                    \
                    LPMAILUSER *lppMailUser) IPURE;         \
        MAPIMETHOD(VCardCreate)                             \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    ULONG       ulFlags,                    \
                    LPSTR       lpszVCard,                  \
                    LPMAILUSER  lpMailUser) IPURE;          \
        MAPIMETHOD(VCardRetrieve)                           \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    ULONG       ulFlags,                    \
                    LPSTR       lpszVCard,                  \
                    LPMAILUSER *lppMailUser) IPURE;         \
        MAPIMETHOD(GetMe)                                   \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    ULONG       ulFlags,                    \
                    DWORD *     lpdwAction,                 \
                    SBinary *   lpsbEID,                    \
                    ULONG       ulParam) IPURE;          \
        MAPIMETHOD(SetMe)                                   \
            (THIS_  LPADRBOOK   lpIAB,                      \
                    ULONG       ulFlags,                    \
                    SBinary     sbEID,                      \
                    ULONG       ulParam) IPURE;          \



#undef           INTERFACE
#define          INTERFACE      IWABObject
DECLARE_MAPI_INTERFACE_(IWABObject, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        WAB_IWABOBJECT_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IWABObject, LPWABOBJECT);


#undef  INTERFACE
#define INTERFACE       struct _IWABOBJECT

#undef  METHOD_PREFIX
#define METHOD_PREFIX   IWABOBJECT_

#undef  LPVTBL_ELEM
#define LPVTBL_ELEM             lpvtbl

#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_DECLARE(type, method, IWABOBJECT_)
                MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       MAPIMETHOD_TYPEDEF(type, method, IWABOBJECT_)
                MAPI_IUNKNOWN_METHODS(IMPL)
       WAB_IWABOBJECT_METHODS(IMPL)
#undef  MAPIMETHOD_
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(IWABOBJECT_)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(IMPL)
   WAB_IWABOBJECT_METHODS(IMPL)
};


/*** WABObject_LDAPUrl flags ***/

// If this flag is specified and the LDAPUrl returns a single
// query result, instructs the WAB to return the result in the
// form of a MailUser object instead of displaying Details on it
// If there are multiple results to the query, fail ..
#define WABOBJECT_LDAPURL_RETURN_MAILUSER   0x00000001

// WAB 5.0x and higher:
// If your application supports Unicode and wants to pass ina Unicode
//  URL to the WAB, you can cast the Unicode URL to an LPSTR and pass it
// to the LDAPUrl API, *also* setting ulFlags to MAPI_UNICODE to mark the URL
// as such. Casting is prefered to converting the string because 
// (a) Converting the string may result in loss of data (b) since this is an
// already published interface we can't modify the interface.
//      MAPI_UNICODE                        0x80000000



/*** WABObject_GetMe returned parameter ***/
// If the GetMe call results in the creation of a new 'Me' contact,
// the lpdwAction returned parameter will contain this value
// indicating to the caller that the object is freshly created and
// does not have any properties in it
#define WABOBJECT_ME_NEW                    0x00000001



/*** WABObject_GetMe flags ***/
// WABObject_GetMe will create a new ME object by default, if 
// none already exists. To force the call to not-create an object, if
// one doesn't already exist, specify the WABOBJECT_ME_NOCREATE flag.
// If no me is found, the call fails with MAPI_E_NOT_FOUND.
// Other flag for WABObject_GetMe is AB_NO_DIALOG defined in wabdefs.h
#define WABOBJECT_ME_NOCREATE               0x00000002



/*** IWABObject_VCard Create/Retrieve ***/
// Flags the WAB whether the lpszVCard parameter is a filename or if
// it is a NULL terminated string containing the compelte VCard contents
//
#define WAB_VCARD_FILE                      0x00000000
#define WAB_VCARD_STREAM                    0x00000001





#ifdef WIN16
BOOL WINAPI WABInitThread();
#endif


//
// Input information to pass to WABOpen
//
typedef struct _tagWAB_PARAM
{
    ULONG   cbSize;         // sizeof(WAB_PARAM).
    HWND    hwnd;           // hWnd of calling client Application. Can be NULL
    LPSTR   szFileName;     // WAB File name to open. if NULL, opens default.
    ULONG   ulFlags;        // See below
    GUID    guidPSExt;      // A GUID that identifies the calling application's Property Sheet extensions
                            // The GUID can be used to determine whether the extension prop sheets are displayed or not.
} WAB_PARAM, * LPWAB_PARAM;

//flags for WAB_PARAM
#define WAB_USE_OE_SENDMAIL     0x00000001  // Tells WAB to use Outlook Express for e-mail before checking for a 
                                            // default Simple MAPI client. Default behaviour is to check for the 
                                            // Simple MAPI client first

#define WAB_ENABLE_PROFILES     0x00400000  // Invokes WAB in a Identity-aware session using Identity-Manager 
                                            // based profiles


//
// Root public entry points for WAB API
//
STDMETHODIMP WABOpen(LPADRBOOK FAR * lppAdrBook, LPWABOBJECT FAR * lppWABObject,
  LPWAB_PARAM lpWP, DWORD Reserved2);

typedef HRESULT (STDMETHODCALLTYPE WABOPEN)(
    LPADRBOOK FAR * lppAdrBook,
    LPWABOBJECT FAR * lppWABObject,
    LPWAB_PARAM lpWP,
    DWORD Reserved2
);
typedef WABOPEN FAR * LPWABOPEN;


STDMETHODIMP WABOpenEx(LPADRBOOK FAR * lppAdrBook,
  LPWABOBJECT FAR * lppWABObject,
  LPWAB_PARAM lpWP,
  DWORD Reserved,
  ALLOCATEBUFFER * fnAllocateBuffer,
  ALLOCATEMORE * fnAllocateMore,
  FREEBUFFER * fnFreeBuffer);

typedef HRESULT (STDMETHODCALLTYPE WABOPENEX)(
    LPADRBOOK FAR * lppAdrBook,
    LPWABOBJECT FAR * lppWABObject,
    LPWAB_PARAM lpWP,
    DWORD Reserved,
    ALLOCATEBUFFER * fnAllocateBuffer,
    ALLOCATEMORE * fnAllocateMore,
    FREEBUFFER * fnFreeBuffer
);
typedef WABOPENEX FAR * LPWABOPENEX;

/* --------------------- */
typedef struct _WABIMPORTPARAM
{
    ULONG cbSize;       // sizeof(WABIMPORTPARAM)
    LPADRBOOK lpAdrBook;// ptr to the IAdrBook object (required)
    HWND hWnd;          // Parent HWND for any dialogs
    ULONG ulFlags;      // 0 or MAPI_DIALOG to show progress dialog and messages
    LPSTR lpszFileName; // FileName to import or NULL .. if NULL will show FileOpen dialog 
} WABIMPORTPARAM, FAR * LPWABIMPORTPARAM;



/* ---- WABEXTDISPLAY ----------------- */
/* WABEXTDISPLAY Structure used in extending the WAB Details Property Dialogs 
    and for doing WAB Context Menu verb extensions.
   The structure is passed into the IWABExtInit::Initialize method
    of the implementor */

// Flags
#define WAB_DISPLAY_LDAPURL 0x00000001  // The object being displayed is an LDAP URL
                                        // The URL can be found in the lpsz struct member

#define WAB_CONTEXT_ADRLIST 0x00000002  // THe lpv parameter contains a pointer to an
                                        // AdrList structure corresponding to selected items
                                        // on which to display a context menu

#define WAB_DISPLAY_ISNTDS  0x00000004  // Identifies that the entry being displayed originated
                                        // on the NT Directory Service, for clients that use ADSI and
                                        // retrieve additional information from the service.

//      MAPI_UNICODE        0x80000000  // Indicates that the WED.lpsz string is actually a UNICODE
                                        //  string and should be cast to a (LPWSTR) before using it
                                        // If this flag is not present then the WED.lpsz is a DBCS string
                                        //  and should be cast to an LPSTR before using.

// Struct
typedef struct _WABEXTDISPLAY
{
    ULONG cbSize;
    LPWABOBJECT lpWABObject;    // pointer to IWABObject
    LPADRBOOK lpAdrBook;        // pointer to IAdrBook object
    LPMAPIPROP lpPropObj;       // Object being displayed
    BOOL fReadOnly;             // Indicates if this is a ReadOnly mode
    BOOL fDataChanged;          // Set by extension sheet to signal data change
    ULONG ulFlags;              // See above
    LPVOID lpv;                 // Used for passing in specific data
    LPTSTR lpsz;               // Used for passing in specific data
} WABEXTDISPLAY, FAR * LPWABEXTDISPLAY;

/* --------------------- */

#define WAB_IWABEXTINIT_METHODS(IPURE)                          \
        MAPIMETHOD(Initialize)                                  \
            (THIS_  LPWABEXTDISPLAY lpWABExtDisplay)    IPURE;  \

#undef           INTERFACE
#define          INTERFACE      IWABExtInit
DECLARE_MAPI_INTERFACE_(IWABExtInit, IUnknown)
{
        BEGIN_INTERFACE
        MAPI_IUNKNOWN_METHODS(PURE)
        WAB_IWABEXTINIT_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IWABExtInit, LPWABEXTINIT);

DEFINE_GUID(IID_IWABExtInit, 
0xea22ebf0, 0x87a4, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);


/* --------------------- */

#ifndef WIN16
#define WAB_DLL_NAME TEXT("WAB32.DLL")
#else
#define WAB_DLL_NAME "WAB16.DLL"
#endif

#define WAB_DLL_PATH_KEY TEXT("Software\\Microsoft\\WAB\\DLLPath")

#ifdef __cplusplus
}
#endif

#endif /* _WABAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\public\inc\wabcode.h ===
/*
 *  WABCODE.H
 *
 *  Status Codes returned by WAB routines
 *
 *  Copyright 1993-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(MAPICODE_H) && !defined(WABCODE_H)
#define WABCODE_H

/* Define S_OK and ITF_* */

#ifdef WIN32
#include <objerror.h>
#endif

/*
 *  WAB Status codes follow the style of OLE 2.0 sCodes as defined in the
 *  OLE 2.0 Programmer's Reference and header file scode.h (Windows 3.x)
 *  or objerror.h (Windows NT 3.5 and Windows 95).
 *
 */

/*  On Windows 3.x, status codes have 32-bit values as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+---------------------+-------+-------------------------------+
 *  |S|       Context       | Facil |               Code            |
 *  +-+---------------------+-------+-------------------------------+
 *
 *  where
 *
 *      S - is the severity code
 *
 *          0 - SEVERITY_SUCCESS
 *          1 - SEVERITY_ERROR
 *
 *      Context - context info
 *
 *      Facility - is the facility code
 *
 *          0x0 - FACILITY_NULL     generally useful errors ([SE]_*)
 *          0x1 - FACILITY_RPC      remote procedure call errors (RPC_E_*)
 *          0x2 - FACILITY_DISPATCH late binding dispatch errors
 *          0x3 - FACILITY_STORAGE  storage errors (STG_E_*)
 *          0x4 - FACILITY_ITF      interface-specific errors
 *
 *      Code - is the facility's status code
 *
 *
 */

/*
 *  On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *  laid out as follows:
 *
 *    3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *    1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *   |S|R|C|N|r|    Facility         |               Code            |
 *   +-+-+-+-+-+---------------------+-------------------------------+
 *
 *   where
 *
 *      S - Severity - indicates success/fail
 *
 *          0 - Success
 *          1 - Fail (COERROR)
 *
 *      R - reserved portion of the facility code, corresponds to NT's
 *          second severity bit.
 *
 *      C - reserved portion of the facility code, corresponds to NT's
 *          C field.
 *
 *      N - reserved portion of the facility code. Used to indicate a
 *          mapped NT status value.
 *
 *      r - reserved portion of the facility code. Reserved for internal
 *          use. Used to indicate HRESULT values that are not status
 *          values, but are instead message ids for display strings.
 *
 *      Facility - is the facility code
 *          FACILITY_NULL                    0x0
 *          FACILITY_RPC                     0x1
 *          FACILITY_DISPATCH                0x2
 *          FACILITY_STORAGE                 0x3
 *          FACILITY_ITF                     0x4
 *          FACILITY_WIN32                   0x7
 *          FACILITY_WINDOWS                 0x8
 *
 *      Code - is the facility's status code
 *
 */




/*
 *  We can't use OLE 2.0 macros to build sCodes because the definition has
 *  changed and we wish to conform to the new definition.
 */
#define MAKE_MAPI_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/* The following two macros are used to build OLE 2.0 style sCodes */

#define MAKE_MAPI_E( err )  (MAKE_MAPI_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_MAPI_S( warn ) (MAKE_MAPI_SCODE( 0, FACILITY_ITF, warn ))

#ifdef  SUCCESS_SUCCESS
#undef  SUCCESS_SUCCESS
#endif
#define SUCCESS_SUCCESS     0L

/* General errors (used by more than one WAB object) */

#define MAPI_E_CALL_FAILED                              E_FAIL
#define MAPI_E_NOT_ENOUGH_MEMORY                        E_OUTOFMEMORY
#define MAPI_E_INVALID_PARAMETER                        E_INVALIDARG
#define MAPI_E_INTERFACE_NOT_SUPPORTED                  E_NOINTERFACE
#define MAPI_E_NO_ACCESS                                E_ACCESSDENIED

#define MAPI_E_NO_SUPPORT                               MAKE_MAPI_E( 0x102 )
#define MAPI_E_BAD_CHARWIDTH                            MAKE_MAPI_E( 0x103 )
#define MAPI_E_STRING_TOO_LONG                          MAKE_MAPI_E( 0x105 )
#define MAPI_E_UNKNOWN_FLAGS                            MAKE_MAPI_E( 0x106 )
#define MAPI_E_INVALID_ENTRYID                          MAKE_MAPI_E( 0x107 )
#define MAPI_E_INVALID_OBJECT                           MAKE_MAPI_E( 0x108 )
#define MAPI_E_OBJECT_CHANGED                           MAKE_MAPI_E( 0x109 )
#define MAPI_E_OBJECT_DELETED                           MAKE_MAPI_E( 0x10A )
#define MAPI_E_BUSY                                     MAKE_MAPI_E( 0x10B )
#define MAPI_E_NOT_ENOUGH_DISK                          MAKE_MAPI_E( 0x10D )
#define MAPI_E_NOT_ENOUGH_RESOURCES                     MAKE_MAPI_E( 0x10E )
#define MAPI_E_NOT_FOUND                                MAKE_MAPI_E( 0x10F )
#define MAPI_E_VERSION                                  MAKE_MAPI_E( 0x110 )
#define MAPI_E_LOGON_FAILED                             MAKE_MAPI_E( 0x111 )
#define MAPI_E_SESSION_LIMIT                            MAKE_MAPI_E( 0x112 )
#define MAPI_E_USER_CANCEL                              MAKE_MAPI_E( 0x113 )
#define MAPI_E_UNABLE_TO_ABORT                          MAKE_MAPI_E( 0x114 )
#define MAPI_E_NETWORK_ERROR                            MAKE_MAPI_E( 0x115 )
#define MAPI_E_DISK_ERROR                               MAKE_MAPI_E( 0x116 )
#define MAPI_E_TOO_COMPLEX                              MAKE_MAPI_E( 0x117 )
#define MAPI_E_BAD_COLUMN                               MAKE_MAPI_E( 0x118 )
#define MAPI_E_EXTENDED_ERROR                           MAKE_MAPI_E( 0x119 )
#define MAPI_E_COMPUTED                                 MAKE_MAPI_E( 0x11A )
#define MAPI_E_CORRUPT_DATA                             MAKE_MAPI_E( 0x11B )
#define MAPI_E_UNCONFIGURED                             MAKE_MAPI_E( 0x11C )
#define MAPI_E_FAILONEPROVIDER                          MAKE_MAPI_E( 0x11D )

/* WAB base function and status object specific errors and warnings */

#define MAPI_E_END_OF_SESSION                           MAKE_MAPI_E( 0x200 )
#define MAPI_E_UNKNOWN_ENTRYID                          MAKE_MAPI_E( 0x201 )
#define MAPI_E_MISSING_REQUIRED_COLUMN                  MAKE_MAPI_E( 0x202 )
#define MAPI_W_NO_SERVICE                               MAKE_MAPI_S( 0x203 )

/* Property specific errors and warnings */

#define MAPI_E_BAD_VALUE                                MAKE_MAPI_E( 0x301 )
#define MAPI_E_INVALID_TYPE                             MAKE_MAPI_E( 0x302 )
#define MAPI_E_TYPE_NO_SUPPORT                          MAKE_MAPI_E( 0x303 )
#define MAPI_E_UNEXPECTED_TYPE                          MAKE_MAPI_E( 0x304 )
#define MAPI_E_TOO_BIG                                  MAKE_MAPI_E( 0x305 )
#define MAPI_E_DECLINE_COPY                             MAKE_MAPI_E( 0x306 )
#define MAPI_E_UNEXPECTED_ID                            MAKE_MAPI_E( 0x307 )

#define MAPI_W_ERRORS_RETURNED                          MAKE_MAPI_S( 0x380 )

/* Table specific errors and warnings */

#define MAPI_E_UNABLE_TO_COMPLETE                       MAKE_MAPI_E( 0x400 )
#define MAPI_E_TIMEOUT                                  MAKE_MAPI_E( 0x401 )
#define MAPI_E_TABLE_EMPTY                              MAKE_MAPI_E( 0x402 )
#define MAPI_E_TABLE_TOO_BIG                            MAKE_MAPI_E( 0x403 )

#define MAPI_E_INVALID_BOOKMARK                         MAKE_MAPI_E( 0x405 )

#define MAPI_W_POSITION_CHANGED                         MAKE_MAPI_S( 0x481 )
#define MAPI_W_APPROX_COUNT                             MAKE_MAPI_S( 0x482 )

#define MAPI_W_PARTIAL_COMPLETION						 MAKE_MAPI_S( 0x680 )

/* Address Book specific errors and warnings */

#define MAPI_E_AMBIGUOUS_RECIP                          MAKE_MAPI_E( 0x700 )


/* Miscellaneous errors */
#define MAPI_E_COLLISION                                MAKE_MAPI_E( 0x604 )
#define MAPI_E_NOT_INITIALIZED                          MAKE_MAPI_E( 0x605 )
#define MAPI_E_FOLDER_CYCLE                             MAKE_MAPI_E( 0x60B )

/* The range 0x0800 to 0x08FF is reserved */

/* Obsolete typing shortcut that will go away eventually. */
#ifndef MakeResult
#define MakeResult(_s)  ResultFromScode(_s)
#endif

/* We expect these to eventually be defined by OLE, but for now,
 * here they are.  When OLE defines them they can be much more
 * efficient than these, but these are "proper" and don't make
 * use of any hidden tricks.
 */
#ifndef HR_SUCCEEDED
#define HR_SUCCEEDED(_hr) SUCCEEDED((SCODE)(_hr))
#define HR_FAILED(_hr) FAILED((SCODE)(_hr))
#endif

#endif  /* WABCODE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\public\inc\cryptdlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cryptdlg.h
//
//  Contents:   Common Cryptographic Dialog API Prototypes and Definitions
//
//----------------------------------------------------------------------------

#ifndef __CRYPTDLG_H__
#define __CRYPTDLG_H__

#if defined (_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef _CRYPTDLG_
#define CRYPTDLGAPI
#else
#define CRYPTDLGAPI DECLSPEC_IMPORT
#endif

#if (_WIN32_WINNT >= 0x0400) || defined(_MAC) || defined(WIN16)

#include <prsht.h>

#ifdef __cplusplus
extern "C" {
#endif

// Master flags to control how revocation is managed

#define CRYTPDLG_FLAGS_MASK                 0xff000000
#define CRYPTDLG_REVOCATION_DEFAULT         0x00000000
#define CRYPTDLG_REVOCATION_ONLINE          0x80000000
#define CRYPTDLG_REVOCATION_CACHE           0x40000000
#define CRYPTDLG_REVOCATION_NONE            0x20000000


// Policy flags which control how we deal with user's certificates

#define CRYPTDLG_POLICY_MASK                0x0000FFFF
#define POLICY_IGNORE_NON_CRITICAL_BC       0x00000001

#define CRYPTDLG_ACTION_MASK                0xFFFF0000
#define ACTION_REVOCATION_DEFAULT_ONLINE    0x00010000
#define ACTION_REVOCATION_DEFAULT_CACHE     0x00020000

//
//  Many of the common dialogs can be passed a filter proc to reduce
//      the set of certificates displayed.  A generic filter proc has been
//      provided to cover many of the generic cases.
//  Return TRUE to display and FALSE to hide

typedef BOOL (WINAPI * PFNCMFILTERPROC)(
        IN PCCERT_CONTEXT pCertContext,
        IN LPARAM,   // lCustData, a cookie
        IN DWORD,   // dwFlags
        IN DWORD);  // dwDisplayWell

//  Display Well Values
#define CERT_DISPWELL_SELECT                    1
#define CERT_DISPWELL_TRUST_CA_CERT             2
#define CERT_DISPWELL_TRUST_LEAF_CERT           3
#define CERT_DISPWELL_TRUST_ADD_CA_CERT         4
#define CERT_DISPWELL_TRUST_ADD_LEAF_CERT       5
#define CERT_DISPWELL_DISTRUST_CA_CERT          6
#define CERT_DISPWELL_DISTRUST_LEAF_CERT        7
#define CERT_DISPWELL_DISTRUST_ADD_CA_CERT      8
#define CERT_DISPWELL_DISTRUST_ADD_LEAF_CERT    9

//
typedef UINT (WINAPI * PFNCMHOOKPROC)(
        IN HWND hwndDialog,
        IN UINT message,
        IN WPARAM wParam,
        IN LPARAM lParam);

//
#define CSS_SELECTCERT_MASK             0x00ffffff
#define CSS_HIDE_PROPERTIES             0x00000001
#define CSS_ENABLEHOOK                  0x00000002
#define CSS_ALLOWMULTISELECT            0x00000004
#define CSS_SHOW_HELP                   0x00000010
#define CSS_ENABLETEMPLATE              0x00000020
#define CSS_ENABLETEMPLATEHANDLE        0x00000040

#define SELCERT_OK                      IDOK
#define SELCERT_CANCEL                  IDCANCEL
#define SELCERT_PROPERTIES              100
#define SELCERT_FINEPRINT               101
#define SELCERT_CERTLIST                102
#define SELCERT_HELP                    IDHELP
#define SELCERT_ISSUED_TO               103
#define SELCERT_VALIDITY                104
#define SELCERT_ALGORITHM               105
#define SELCERT_SERIAL_NUM              106
#define SELCERT_THUMBPRINT              107

typedef struct tagCSSA {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCSTR              pTemplateName;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    LPARAM              lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_STRUCT_A, *PCERT_SELECT_STRUCT_A;

typedef struct tagCSSW {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    LPCWSTR             pTemplateName;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    DWORD               cCertStore;
    HCERTSTORE *        arrayCertStore;
    LPCSTR              szPurposeOid;
    DWORD               cCertContext;
    PCCERT_CONTEXT *    arrayCertContext;
    LPARAM              lCustData;
    PFNCMHOOKPROC       pfnHook;
    PFNCMFILTERPROC     pfnFilter;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    HCRYPTPROV          hprov;
} CERT_SELECT_STRUCT_W, *PCERT_SELECT_STRUCT_W;

#ifdef UNICODE
typedef CERT_SELECT_STRUCT_W CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_W PCERT_SELECT_STRUCT;
#else
typedef CERT_SELECT_STRUCT_A CERT_SELECT_STRUCT;
typedef PCERT_SELECT_STRUCT_A PCERT_SELECT_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateA(
        IN OUT PCERT_SELECT_STRUCT_A pCertSelectInfo
        );
#ifdef MAC
#define CertSelectCertificate CertSelectCertificateA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertSelectCertificateW(
        IN OUT PCERT_SELECT_STRUCT_W pCertSelectInfo
        );
#ifdef UNICODE
#define CertSelectCertificate CertSelectCertificateW
#else
#define CertSelectCertificate CertSelectCertificateA
#endif
#endif  // MAC

/////////////////////////////////////////////////////////////

#define CM_VIEWFLAGS_MASK       0x00ffffff
#define CM_ENABLEHOOK           0x00000001
#define CM_SHOW_HELP            0x00000002
#define CM_SHOW_HELPICON        0x00000004
#define CM_ENABLETEMPLATE       0x00000008
#define CM_HIDE_ADVANCEPAGE     0x00000010
#define CM_HIDE_TRUSTPAGE       0x00000020
#define CM_NO_NAMECHANGE        0x00000040
#define CM_NO_EDITTRUST         0x00000080
#define CM_HIDE_DETAILPAGE      0x00000100
#define CM_ADD_CERT_STORES      0x00000200
#define CERTVIEW_CRYPTUI_LPARAM 0x00800000

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_A {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCSTR              szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    LPARAM              lCustData;
    DWORD               dwPad;
    LPCSTR              szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_A, *PCERT_VIEWPROPERTIES_STRUCT_A;

typedef struct tagCERT_VIEWPROPERTIES_STRUCT_W {
    DWORD               dwSize;
    HWND                hwndParent;
    HINSTANCE           hInstance;
    DWORD               dwFlags;
    LPCWSTR             szTitle;
    PCCERT_CONTEXT      pCertContext;
    LPSTR *             arrayPurposes;
    DWORD               cArrayPurposes;
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    HCRYPTPROV          hprov;          // Provider to use for verification
    LPARAM              lCustData;
    DWORD               dwPad;
    LPCWSTR             szHelpFileName;
    DWORD               dwHelpId;
    DWORD               nStartPage;
    DWORD               cArrayPropSheetPages;
    PROPSHEETPAGE *     arrayPropSheetPages;
} CERT_VIEWPROPERTIES_STRUCT_W, *PCERT_VIEWPROPERTIES_STRUCT_W;

#ifdef UNICODE
typedef CERT_VIEWPROPERTIES_STRUCT_W CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_W PCERT_VIEWPROPERTIES_STRUCT;
#else
typedef CERT_VIEWPROPERTIES_STRUCT_A CERT_VIEWPROPERTIES_STRUCT;
typedef PCERT_VIEWPROPERTIES_STRUCT_A PCERT_VIEWPROPERTIES_STRUCT;
#endif // UNICODE

CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesA(
        PCERT_VIEWPROPERTIES_STRUCT_A pCertViewInfo
        );
#ifdef MAC
#define CertViewProperties CertViewPropertiesA
#else   // !MAC
CRYPTDLGAPI
BOOL
WINAPI
CertViewPropertiesW(
        PCERT_VIEWPROPERTIES_STRUCT_W pCertViewInfo
        );

#ifdef UNICODE
#define CertViewProperties CertViewPropertiesW
#else
#define CertViewProperties CertViewPropertiesA
#endif
#endif  // MAC


//
//  We provide a default filter function that people can use to do some
//      of the most simple things.
//

#define CERT_FILTER_OP_EXISTS           1
#define CERT_FILTER_OP_NOT_EXISTS       2
#define CERT_FILTER_OP_EQUALITY         3

typedef struct tagCMOID {
    LPCSTR              szExtensionOID;         // Extension to filter on
    DWORD               dwTestOperation;
    LPBYTE              pbTestData;
    DWORD               cbTestData;
} CERT_FILTER_EXTENSION_MATCH;

#define CERT_FILTER_INCLUDE_V1_CERTS    0x0001
#define CERT_FILTER_VALID_TIME_RANGE    0x0002
#define CERT_FILTER_VALID_SIGNATURE     0x0004
#define CERT_FILTER_LEAF_CERTS_ONLY     0x0008
#define CERT_FILTER_ISSUER_CERTS_ONLY   0x0010
#define CERT_FILTER_KEY_EXISTS          0x0020

typedef struct tagCMFLTR {
    DWORD               dwSize;
    DWORD               cExtensionChecks;
    CERT_FILTER_EXTENSION_MATCH * arrayExtensionChecks;
    DWORD               dwCheckingFlags;
} CERT_FILTER_DATA;

//
//  Maybe this should not be here -- but until it goes into wincrypt.h
//

//
//   Get a formatted friendly name for a certificate

CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertA(PCCERT_CONTEXT pccert, LPSTR pchBuffer,
                             DWORD cchBuffer);
CRYPTDLGAPI
DWORD
WINAPI
GetFriendlyNameOfCertW(PCCERT_CONTEXT pccert, LPWSTR pchBuffer,
                              DWORD cchBuffer);
#ifdef UNICODE
#define GetFriendlyNameOfCert GetFriendlyNameOfCertW
#else
#define GetFriendlyNameOfCert GetFriendlyNameOfCertA
#endif


//
//  We also provide a WinTrust provider which performs the same set of
//      parameter checking that we do in order to validate certificates.
//

#define CERT_CERTIFICATE_ACTION_VERIFY  \
  { /* 7801ebd0-cf4b-11d0-851f-0060979387ea */  \
    0x7801ebd0, \
    0xcf4b,     \
    0x11d0,     \
    {0x85, 0x1f, 0x00, 0x60, 0x97, 0x93, 0x87, 0xea} \
  }
#define szCERT_CERTIFICATE_ACTION_VERIFY    \
    "{7801ebd0-cf4b-11d0-851f-0060979387ea}"  

typedef HRESULT (WINAPI * PFNTRUSTHELPER)(
        IN PCCERT_CONTEXT       pCertContext,
        IN LPARAM               lCustData,
        IN BOOL                 fLeafCertificate,
        IN LPBYTE               pbTrustBlob);
//
//  Failure Reasons:
//

#define CERT_VALIDITY_BEFORE_START              0x00000001
#define CERT_VALIDITY_AFTER_END                 0x00000002
#define CERT_VALIDITY_SIGNATURE_FAILS           0x00000004
#define CERT_VALIDITY_CERTIFICATE_REVOKED       0x00000008
#define CERT_VALIDITY_KEY_USAGE_EXT_FAILURE     0x00000010
#define CERT_VALIDITY_EXTENDED_USAGE_FAILURE    0x00000020
#define CERT_VALIDITY_NAME_CONSTRAINTS_FAILURE  0x00000040
#define CERT_VALIDITY_UNKNOWN_CRITICAL_EXTENSION 0x00000080
#define CERT_VALIDITY_ISSUER_INVALID            0x00000100
#define CERT_VALIDITY_OTHER_EXTENSION_FAILURE   0x00000200
#define CERT_VALIDITY_PERIOD_NESTING_FAILURE    0x00000400
#define CERT_VALIDITY_OTHER_ERROR               0x00000800
#define CERT_VALIDITY_ISSUER_DISTRUST           0x02000000
#define CERT_VALIDITY_EXPLICITLY_DISTRUSTED     0x01000000
#define CERT_VALIDITY_NO_ISSUER_CERT_FOUND      0x10000000
#define CERT_VALIDITY_NO_CRL_FOUND              0x20000000
#define CERT_VALIDITY_CRL_OUT_OF_DATE           0x40000000
#define CERT_VALIDITY_NO_TRUST_DATA             0x80000000
#define CERT_VALIDITY_MASK_TRUST                0xffff0000
#define CERT_VALIDITY_MASK_VALIDITY             0x0000ffff

#define CERT_TRUST_MASK                         0x00ffffff
#define CERT_TRUST_DO_FULL_SEARCH               0x00000001
#define CERT_TRUST_PERMIT_MISSING_CRLS          0x00000002
#define CERT_TRUST_DO_FULL_TRUST                0x00000005
#define CERT_TRUST_ADD_CERT_STORES              CM_ADD_CERT_STORES

//
//  Trust data structure
//
//      Returned data arrays will be allocated using LocalAlloc and must
//      be freed by the caller.  The data in the TrustInfo array are individually
//      allocated and must be freed.  The data in rgChain must be freed by
//      calling CertFreeCertificateContext.
//
//  Defaults:
//      pszUsageOid == NULL     indicates that no trust validation should be done
//      cRootStores == 0        Will default to User's Root store
//      cStores == 0            Will default to User's CA and system's SPC stores
//      cTrustStores == 0       Will default to User's TRUST store
//      hprov == NULL           Will default to RSABase
//      any returned item which has a null pointer will not return that item.
//  Notes:
//      pfnTrustHelper is nyi

typedef struct _CERT_VERIFY_CERTIFICATE_TRUST {
    DWORD               cbSize;         // Size of this structure
    PCCERT_CONTEXT      pccert;         // Certificate to be verified
    DWORD               dwFlags;        // CERT_TRUST_*
    DWORD               dwIgnoreErr;    // Errors to ignore (CERT_VALIDITY_*)
    DWORD *             pdwErrors;      // Location to return error flags
    LPSTR               pszUsageOid;    // Extended Usage OID for Certificate
    HCRYPTPROV          hprov;          // Crypt Provider to use for validation
    DWORD               cRootStores;    // Count of Root Stores
    HCERTSTORE *        rghstoreRoots;  // Array of root stores
    DWORD               cStores;        // Count of other stores to search
    HCERTSTORE *        rghstoreCAs;    // Array of other stores to search
    DWORD               cTrustStores;   // Count of trust stores
    HCERTSTORE *        rghstoreTrust;  // Array of trust stores
    LPARAM              lCustData;      //
    PFNTRUSTHELPER      pfnTrustHelper; // Callback function for cert validation
    DWORD *             pcChain;        // Count of items in the chain array
    PCCERT_CONTEXT **   prgChain;       // Chain of certificates used
    DWORD **            prgdwErrors;    // Errors on a per certificate basis
    DATA_BLOB **        prgpbTrustInfo; // Array of trust information used
} CERT_VERIFY_CERTIFICATE_TRUST, * PCERT_VERIFY_CERTIFICATE_TRUST;

//
//  Trust list manipulation routine
//
//  CertModifyCertificatesToTrust can be used to do modifications to the set of certificates
//      on trust lists for a given purpose.
//      if hcertstoreTrust is NULL, the System Store TRUST in Current User will be used
//      if pccertSigner is specified, it will be used to sign the resulting trust lists,
//              it also restricts the set of trust lists that may be modified.
//

#define CTL_MODIFY_REQUEST_ADD_NOT_TRUSTED      1
#define CTL_MODIFY_REQUEST_REMOVE               2
#define CTL_MODIFY_REQUEST_ADD_TRUSTED          3

typedef struct _CTL_MODIFY_REQUEST {
    PCCERT_CONTEXT      pccert;         // Certificate to change trust on
    DWORD               dwOperation;    // Operation to be performed
    DWORD               dwError;        // Operation error code
} CTL_MODIFY_REQUEST, * PCTL_MODIFY_REQUEST;

CRYPTDLGAPI
HRESULT
WINAPI
CertModifyCertificatesToTrust(
        int cCerts,                     // Count of modifications to be done
        PCTL_MODIFY_REQUEST rgCerts,    // Array of modification requests
        LPCSTR szPurpose,               // Purpose OID to for modifications
        HWND hwnd,                      // HWND for any dialogs
        HCERTSTORE hcertstoreTrust,     // Cert Store to store trust information in
        PCCERT_CONTEXT pccertSigner);   // Certificate to be used in signing trust list

#ifdef WIN16
// Need to define export functions in WATCOM.
BOOL
WINAPI CertConfigureTrustA(void);

BOOL
WINAPI FormatVerisignExtension(
    DWORD /*dwCertEncodingType*/,
    DWORD /*dwFormatType*/,
    DWORD /*dwFormatStrType*/,
    void * /*pFormatStruct*/,
    LPCSTR /*lpszStructType*/,
    const BYTE * /*pbEncoded*/,
    DWORD /*cbEncoded*/,
    void * pbFormat,
    DWORD * pcbFormat);
#endif // !WIN16

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif // (_WIN32_WINNT >= 0x0400)

#endif // _CRYPTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\sendfile\main.h ===
#ifndef _MAIN_H
#define _MAIN_H

extern UINT g_msgSMTP;

#endif //_MAIN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\sendfile\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sendfile.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\public\inc\wabnot.h ===
/*
 *	WABNOT.H
 *
 * Defines Notification structures.  These are also defined in mapispi.h.
 *
 * Copyright 1986-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(MAPISPI_H) && !defined(WABSPI_H)
#define WABSPI_H
/* Include common MAPI header files if they haven't been already. */


#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* Notification key structure for the MAPI notification engine */

typedef struct
{
	ULONG		cb;				/* How big the key is */
	BYTE		ab[MAPI_DIM];	/* Key contents */
} NOTIFKEY, FAR * LPNOTIFKEY;

#define CbNewNOTIFKEY(_cb)		(offsetof(NOTIFKEY,ab) + (_cb))
#define CbNOTIFKEY(_lpkey)		(offsetof(NOTIFKEY,ab) + (_lpkey)->cb)
#define SizedNOTIFKEY(_cb, _name) \
	struct _NOTIFKEY_ ## _name \
{ \
	ULONG		cb; \
	BYTE		ab[_cb]; \
} _name


/* For Subscribe() */

#define NOTIFY_SYNC				((ULONG) 0x40000000)

/* For Notify() */

#define NOTIFY_CANCELED			((ULONG) 0x80000000)


/* From the Notification Callback function (well, this is really a ulResult) */

#define CALLBACK_DISCONTINUE	((ULONG) 0x80000000)

/* For Transport's SpoolerNotify() */

#define NOTIFY_NEWMAIL			((ULONG) 0x00000001)
#define NOTIFY_READYTOSEND		((ULONG) 0x00000002)
#define NOTIFY_SENTDEFERRED		((ULONG) 0x00000004)
#define NOTIFY_CRITSEC			((ULONG) 0x00001000)
#define NOTIFY_NONCRIT			((ULONG) 0x00002000)
#define NOTIFY_CONFIG_CHANGE	((ULONG) 0x00004000)
#define NOTIFY_CRITICAL_ERROR	((ULONG) 0x10000000)

/* For Message Store's SpoolerNotify() */

#define NOTIFY_NEWMAIL_RECEIVED	((ULONG) 0x20000000)

/* For ModifyStatusRow() */

#define	STATUSROW_UPDATE		((ULONG) 0x10000000)

/* For IStorageFromStream() */

#define STGSTRM_RESET			((ULONG) 0x00000000)
#define STGSTRM_CURRENT			((ULONG) 0x10000000)
#define STGSTRM_MODIFY			((ULONG) 0x00000002)
#define STGSTRM_CREATE			((ULONG) 0x00001000)

/* For GetOneOffTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/* For CreateOneOff() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO	((ULONG) 0x00010000) */

/* For ReadReceipt() */
#define MAPI_NON_READ			((ULONG) 0x00000001)

/* For DoConfigPropSheet() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#ifdef __cplusplus
}
#endif

#endif /* MAPISPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\public\inc\wabdefs.h ===
/*
 *  WABDEFS.H
 *
 *  Definitions used by WAB clients
 *
 *  Copyright 1993-1998 Microsoft Corporation. All Rights Reserved.
 */

#ifdef WIN16
#ifdef GetLastError
#undef GetLastError
#endif // GetLastError
#endif // WIN16

#if !defined(MAPIDEFS_H) && !defined(WABDEFS_H)
#define WABDEFS_H
#if defined (WIN32)

#if defined (NT) && !defined (_WINNT)
#pragma message ("\nWARNING!!\n NT defined but not _WINNT.\n    You must define _WINNT to ensure "\
    "successful compile of Windows NT code\n")
#define _WINNT
#endif /* defined NT and not defined _WINNT */
#endif /* WIN32 */

#if defined (WIN32) && !defined (MAC)   /* Must include WINDOWS.H on Win32 */
#ifndef _WINDOWS_
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Windows NT; Windows 95 needs it */
#define _INC_OLE /* Windows 95 will include OLE1 without this */
#include <windows.h>
#endif

#ifndef _OLEERROR_H_
#include <objerror.h>
#endif
#ifndef _OBJBASE_H_
#include <objbase.h>
#endif
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16) || defined (MAC)
#ifndef _COMPOBJ_H_
#include <compobj.h>
#endif
#endif

#ifndef _INC_STDDEF
#include <stddef.h>
#endif

/* Array dimension for structures with variable-sized arrays at the end. */

#ifndef MAPI_DIM
#define MAPI_DIM    1
#endif

/* Provider init type. Force to cdecl always */

#ifndef STDMAPIINITCALLTYPE
#if !defined (_MAC) && defined (WIN32)
#define STDMAPIINITCALLTYPE     __cdecl
#else
#define STDMAPIINITCALLTYPE     STDMETHODCALLTYPE
#endif
#define STDINITMETHODIMP        HRESULT STDMAPIINITCALLTYPE
#define STDINITMETHODIMP_(type) type STDMAPIINITCALLTYPE
#endif

#ifdef  __cplusplus
extern "C" {
#endif

/* Simple data types */


#if !defined(UNIX) && !defined(WIN16)
typedef WORD                WCHAR;
#endif

#ifdef UNICODE
typedef WCHAR               TCHAR;
#else
typedef char                TCHAR;
#endif

typedef WCHAR FAR *         LPWSTR;
typedef const WCHAR FAR *   LPCWSTR;
typedef TCHAR FAR *         LPTSTR;
typedef const TCHAR FAR *   LPCTSTR;
typedef BYTE FAR *          LPBYTE;
typedef ULONG FAR *         LPULONG;

#ifndef __LHANDLE
#define __LHANDLE
typedef ULONG_PTR   LHANDLE, FAR * LPLHANDLE;
#endif

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME;
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 *  This flag is used in many different MAPI calls to signify that
 *  the object opened by the call should be modifiable (MAPI_MODIFY).
 *  If the flag MAPI_MAX_ACCESS is set, the object returned should be
 *  returned at the maximum access level allowed.  An additional
 *  property available on the object (PR_ACCESS_LEVEL) uses the same
 *  MAPI_MODIFY flag to say just what this new access level is.
 */

#define MAPI_MODIFY             ((ULONG) 0x00000001)

/*
 *  The following flags are used to indicate to the client what access
 *  level is permissible in the object. They appear in PR_ACCESS in
 *  message and folder objects as well as in contents and associated
 *  contents tables
 */

#define MAPI_ACCESS_MODIFY                  ((ULONG) 0x00000001)
#define MAPI_ACCESS_READ                    ((ULONG) 0x00000002)
#define MAPI_ACCESS_DELETE                  ((ULONG) 0x00000004)
#define MAPI_ACCESS_CREATE_HIERARCHY        ((ULONG) 0x00000008)
#define MAPI_ACCESS_CREATE_CONTENTS         ((ULONG) 0x00000010)
#define MAPI_ACCESS_CREATE_ASSOCIATED       ((ULONG) 0x00000020)

/*
 *  The MAPI_UNICODE flag is used in many different MAPI calls to signify
 *  that strings passed through the interface are in Unicode (a 16-bit
 *  character set). The default is an 8-bit character set.
 *
 *  The value fMapiUnicode can be used as the 'normal' value for
 *  that bit, given the application's default character set.
 */

#define MAPI_UNICODE            ((ULONG) 0x80000000)

#ifdef UNICODE
#define fMapiUnicode            MAPI_UNICODE
#else
#define fMapiUnicode            0
#endif

/* successful HRESULT */
#define hrSuccess               0



/* Recipient types */
#ifndef MAPI_ORIG               /* also defined in mapi.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_P1     0x10000000  /* Recipient is a P1 resend recipient       */
#define MAPI_SUBMITTED 0x80000000 /* Recipient is already processed         */
/* #define MAPI_AUTHORIZE 4        recipient is a CMC authorizing user      */
/*#define MAPI_DISCRETE 0x10000000 Recipient is a P1 resend recipient       */
#endif

/* Bit definitions for abFlags[0] of ENTRYID */
#define MAPI_SHORTTERM          0x80
#define MAPI_NOTRECIP           0x40
#define MAPI_THISSESSION        0x20
#define MAPI_NOW                0x10
#define MAPI_NOTRESERVED        0x08

/* Bit definitions for abFlags[1] of ENTRYID */
#define MAPI_COMPOUND           0x80

/* ENTRYID */
typedef struct
{
    BYTE    abFlags[4];
    BYTE    ab[MAPI_DIM];
} ENTRYID, FAR *LPENTRYID;

#define CbNewENTRYID(_cb)       (offsetof(ENTRYID,ab) + (_cb))
#define CbENTRYID(_cb)          (offsetof(ENTRYID,ab) + (_cb))
#define SizedENTRYID(_cb, _name) \
    struct _ENTRYID_ ## _name \
{ \
    BYTE    abFlags[4]; \
    BYTE    ab[_cb]; \
} _name

/* Byte-order-independent version of GUID (world-unique identifier) */
typedef struct _MAPIUID
{
    BYTE ab[16];
} MAPIUID, FAR * LPMAPIUID;

/* Note:  need to include C run-times (memory.h) to use this macro */

#define IsEqualMAPIUID(lpuid1, lpuid2)  (!memcmp(lpuid1, lpuid2, sizeof(MAPIUID)))


/* Object type */

#define MAPI_STORE      ((ULONG) 0x00000001)    /* Message Store */
#define MAPI_ADDRBOOK   ((ULONG) 0x00000002)    /* Address Book */
#define MAPI_FOLDER     ((ULONG) 0x00000003)    /* Folder */
#define MAPI_ABCONT     ((ULONG) 0x00000004)    /* Address Book Container */
#define MAPI_MESSAGE    ((ULONG) 0x00000005)    /* Message */
#define MAPI_MAILUSER   ((ULONG) 0x00000006)    /* Individual Recipient */
#define MAPI_ATTACH     ((ULONG) 0x00000007)    /* Attachment */
#define MAPI_DISTLIST   ((ULONG) 0x00000008)    /* Distribution List Recipient */
#define MAPI_PROFSECT   ((ULONG) 0x00000009)    /* Profile Section */
#define MAPI_STATUS     ((ULONG) 0x0000000A)    /* Status Object */
#define MAPI_SESSION    ((ULONG) 0x0000000B)    /* Session */
#define MAPI_FORMINFO   ((ULONG) 0x0000000C)    /* Form Information */


/*
 *  Maximum length of profile names and passwords, not including
 *  the null termination character.
 */
#ifndef cchProfileNameMax
#define cchProfileNameMax   64
#define cchProfilePassMax   64
#endif


/* Property Types */

#define MV_FLAG         0x1000          /* Multi-value flag */

#define PT_UNSPECIFIED  ((ULONG)  0)    /* (Reserved for interface use) type doesn't matter to caller */
#define PT_NULL         ((ULONG)  1)    /* NULL property value */
#define PT_I2           ((ULONG)  2)    /* Signed 16-bit value */
#define PT_LONG         ((ULONG)  3)    /* Signed 32-bit value */
#define PT_R4           ((ULONG)  4)    /* 4-byte floating point */
#define PT_DOUBLE       ((ULONG)  5)    /* Floating point double */
#define PT_CURRENCY     ((ULONG)  6)    /* Signed 64-bit int (decimal w/    4 digits right of decimal pt) */
#define PT_APPTIME      ((ULONG)  7)    /* Application time */
#define PT_ERROR        ((ULONG) 10)    /* 32-bit error value */
#define PT_BOOLEAN      ((ULONG) 11)    /* 16-bit boolean (non-zero true) */
#define PT_OBJECT       ((ULONG) 13)    /* Embedded object in a property */
#define PT_I8           ((ULONG) 20)    /* 8-byte signed integer */
#define PT_STRING8      ((ULONG) 30)    /* Null terminated 8-bit character string */
#define PT_UNICODE      ((ULONG) 31)    /* Null terminated Unicode string */
#define PT_SYSTIME      ((ULONG) 64)    /* FILETIME 64-bit int w/ number of 100ns periods since Jan 1,1601 */
#define PT_CLSID        ((ULONG) 72)    /* OLE GUID */
#define PT_BINARY       ((ULONG) 258)   /* Uninterpreted (counted byte array) */
/* Changes are likely to these numbers, and to their structures. */

/* Alternate property type names for ease of use */
#define PT_SHORT    PT_I2
#define PT_I4       PT_LONG
#define PT_FLOAT    PT_R4
#define PT_R8       PT_DOUBLE
#define PT_LONGLONG PT_I8

/*
 *  The type of a MAPI-defined string property is indirected, so
 *  that it defaults to Unicode string on a Unicode platform and to
 *  String8 on an ANSI or DBCS platform.
 *
 *  Macros are defined here both for the property type, and for the
 *  field of the property value structure which should be
 *  dereferenced to obtain the string pointer.
 */

#ifdef  UNICODE
#define PT_TSTRING          PT_UNICODE
#define PT_MV_TSTRING       (MV_FLAG|PT_UNICODE)
#define LPSZ                lpszW
#define LPPSZ               lppszW
#define MVSZ                MVszW
#else
#define PT_TSTRING          PT_STRING8
#define PT_MV_TSTRING       (MV_FLAG|PT_STRING8)
#define LPSZ                lpszA
#define LPPSZ               lppszA
#define MVSZ                MVszA
#endif


/* Property Tags
 *
 * By convention, MAPI never uses 0 or FFFF as a property ID.
 * Use as null values, initializers, sentinels, or what have you.
 */

#define PROP_TYPE_MASK          ((ULONG)0x0000FFFF) /* Mask for Property type */
#define PROP_TYPE(ulPropTag)    (((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag)      (((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID)   ((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL            0
#define PROP_ID_INVALID         0xFFFF
#define PR_NULL                 PROP_TAG( PT_NULL, PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType) \
                        (((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)


/* Multi-valued Property Types */

#define PT_MV_I2        (MV_FLAG|PT_I2)
#define PT_MV_LONG      (MV_FLAG|PT_LONG)
#define PT_MV_R4        (MV_FLAG|PT_R4)
#define PT_MV_DOUBLE    (MV_FLAG|PT_DOUBLE)
#define PT_MV_CURRENCY  (MV_FLAG|PT_CURRENCY)
#define PT_MV_APPTIME   (MV_FLAG|PT_APPTIME)
#define PT_MV_SYSTIME   (MV_FLAG|PT_SYSTIME)
#define PT_MV_STRING8   (MV_FLAG|PT_STRING8)
#define PT_MV_BINARY    (MV_FLAG|PT_BINARY)
#define PT_MV_UNICODE   (MV_FLAG|PT_UNICODE)
#define PT_MV_CLSID     (MV_FLAG|PT_CLSID)
#define PT_MV_I8        (MV_FLAG|PT_I8)

/* Alternate property type names for ease of use */
#define PT_MV_SHORT     PT_MV_I2
#define PT_MV_I4        PT_MV_LONG
#define PT_MV_FLOAT     PT_MV_R4
#define PT_MV_R8        PT_MV_DOUBLE
#define PT_MV_LONGLONG  PT_MV_I8

/*
 *  Property type reserved bits
 *
 *  MV_INSTANCE is used as a flag in table operations to request
 *  that a multi-valued property be presented as a single-valued
 *  property appearing in multiple rows.
 */

#define MV_INSTANCE     0x2000
#define MVI_FLAG        (MV_FLAG | MV_INSTANCE)
#define MVI_PROP(tag)   ((tag) | MVI_FLAG)

/* --------------- */
/* Data Structures */
/* --------------- */

/* Property Tag Array */

typedef struct _SPropTagArray
{
    ULONG   cValues;
    ULONG   aulPropTag[MAPI_DIM];
} SPropTagArray;
typedef SPropTagArray UNALIGNED FAR * LPSPropTagArray;

#define CbNewSPropTagArray(_ctag) \
    (offsetof(SPropTagArray,aulPropTag) + (_ctag)*sizeof(ULONG))
#define CbSPropTagArray(_lparray) \
    (offsetof(SPropTagArray,aulPropTag) + \
    (UINT)((_lparray)->cValues)*sizeof(ULONG))
/*  SPropTagArray */
#define SizedSPropTagArray(_ctag, _name) \
struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name

/* -------------- */
/* Property Value */
/* -------------- */

typedef struct _SPropValue  SPropValue;


/* 32-bit CURRENCY definition stolen from oaidl.h */
/* 16-bit CURRENCY definition stolen from variant.h */

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if (defined (WIN16) || defined (DOS)) && !defined (_VARIANT_H_)
typedef struct FARSTRUCT tagCY {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
} CY;
#elif defined (WIN32)
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
    };
    LONGLONG int64;
} CY;
#endif /* 16-bit vs 32-bit definition */
#endif
            /* size is 8 */
typedef CY CURRENCY;

typedef struct _SBinary
{
    ULONG   cb;
    LPBYTE  lpb;
} SBinary;

typedef SBinary UNALIGNED FAR * LPSBinary;

typedef struct _SShortArray
{
    ULONG       cValues;
    short int UNALIGNED FAR *lpi;
} SShortArray;

typedef struct _SGuidArray
{
    ULONG       cValues;
    GUID UNALIGNED FAR *lpguid;
} SGuidArray;

typedef struct _SRealArray
{
    ULONG       cValues;
    float UNALIGNED FAR *lpflt;
} SRealArray;

typedef struct _SLongArray
{
    ULONG                  cValues;
    LONG UNALIGNED FAR *lpl;
} SLongArray;

typedef struct _SLargeIntegerArray
{
    ULONG       cValues;
    LARGE_INTEGER UNALIGNED FAR *lpli;
} SLargeIntegerArray;

typedef struct _SDateTimeArray
{
    ULONG       cValues;
    FILETIME UNALIGNED FAR *lpft;
} SDateTimeArray;

typedef struct _SAppTimeArray
{
    ULONG       cValues;
    double UNALIGNED FAR *lpat;
} SAppTimeArray;

typedef struct _SCurrencyArray
{
    ULONG       cValues;
    CURRENCY UNALIGNED FAR *lpcur;
} SCurrencyArray;

typedef struct _SBinaryArray
{
    ULONG       cValues;
    SBinary UNALIGNED FAR *lpbin;
} SBinaryArray;

typedef struct _SDoubleArray
{
    ULONG       cValues;
    double UNALIGNED FAR *lpdbl;
} SDoubleArray;

typedef struct _SWStringArray
{
    ULONG       cValues;
    LPWSTR UNALIGNED FAR *lppszW;
} SWStringArray;

typedef struct _SLPSTRArray
{
    ULONG       cValues;
    LPSTR UNALIGNED FAR *lppszA;
} SLPSTRArray;

typedef union _PV
{
    short int           i;          /* case PT_I2 */
    LONG                l;          /* case PT_LONG */
    ULONG               ul;         /* alias for PT_LONG */
    float               flt;        /* case PT_R4 */
    double              dbl;        /* case PT_DOUBLE */
    unsigned short int  b;          /* case PT_BOOLEAN */
    CURRENCY            cur;        /* case PT_CURRENCY */
    double              at;         /* case PT_APPTIME */
    FILETIME            ft;         /* case PT_SYSTIME */
    LPSTR               lpszA;      /* case PT_STRING8 */
    SBinary             bin;        /* case PT_BINARY */
    LPWSTR              lpszW;      /* case PT_UNICODE */
    GUID UNALIGNED     *lpguid;     /* case PT_CLSID */
    LARGE_INTEGER       li;         /* case PT_I8 */
    SShortArray         MVi;        /* case PT_MV_I2 */
    SLongArray          MVl;        /* case PT_MV_LONG */
    SRealArray          MVflt;      /* case PT_MV_R4 */
    SDoubleArray        MVdbl;      /* case PT_MV_DOUBLE */
    SCurrencyArray      MVcur;      /* case PT_MV_CURRENCY */
    SAppTimeArray       MVat;       /* case PT_MV_APPTIME */
    SDateTimeArray      MVft;       /* case PT_MV_SYSTIME */
    SBinaryArray        MVbin;      /* case PT_MV_BINARY */
    SLPSTRArray         MVszA;      /* case PT_MV_STRING8 */
    SWStringArray       MVszW;      /* case PT_MV_UNICODE */
    SGuidArray          MVguid;     /* case PT_MV_CLSID */
    SLargeIntegerArray  MVli;       /* case PT_MV_I8 */
    SCODE               err;        /* case PT_ERROR */
    LONG                x;          /* case PT_NULL, PT_OBJECT (no usable value) */
} __UPV;

typedef struct _SPropValue
{
    ULONG       ulPropTag;
    ULONG       dwAlignPad;
    union _PV   Value;
} SPropValue;

typedef SPropValue UNALIGNED FAR * LPSPropValue;


/* --------------------------------------------- */
/* Property Problem and Property Problem Arrays */
/* --------------------------------------------- */

typedef struct _SPropProblem
{
    ULONG   ulIndex;
    ULONG   ulPropTag;
    SCODE   scode;
} SPropProblem, FAR * LPSPropProblem;

typedef struct _SPropProblemArray
{
    ULONG           cProblem;
    SPropProblem    aProblem[MAPI_DIM];
} SPropProblemArray, FAR * LPSPropProblemArray;

#define CbNewSPropProblemArray(_cprob) \
    (offsetof(SPropProblemArray,aProblem) + (_cprob)*sizeof(SPropProblem))
#define CbSPropProblemArray(_lparray) \
    (offsetof(SPropProblemArray,aProblem) + \
    (UINT) ((_lparray)->cProblem*sizeof(SPropProblem)))
#define SizedSPropProblemArray(_cprob, _name) \
struct _SPropProblemArray_ ## _name \
{ \
    ULONG           cProblem; \
    SPropProblem    aProblem[_cprob]; \
} _name

/*
 *  ENTRYLIST
 */

typedef SBinaryArray ENTRYLIST, FAR *LPENTRYLIST;

/*
 *  FLATENTRYLIST
 *  MTSID
 *  FLATMTSIDLIST
 */

typedef struct {
    ULONG cb;
    BYTE abEntry[MAPI_DIM];
} FLATENTRY, FAR *LPFLATENTRY;

typedef struct {
    ULONG       cEntries;
    ULONG       cbEntries;
    BYTE        abEntries[MAPI_DIM];
} FLATENTRYLIST, FAR *LPFLATENTRYLIST;

typedef struct {
    ULONG       cb;
    BYTE        ab[MAPI_DIM];
} MTSID, FAR *LPMTSID;

typedef struct {
    ULONG       cMTSIDs;
    ULONG       cbMTSIDs;
    BYTE        abMTSIDs[MAPI_DIM];
} FLATMTSIDLIST, FAR *LPFLATMTSIDLIST;

#define CbNewFLATENTRY(_cb)     (offsetof(FLATENTRY,abEntry) + (_cb))
#define CbFLATENTRY(_lpentry)   (offsetof(FLATENTRY,abEntry) + (_lpentry)->cb)
#define CbNewFLATENTRYLIST(_cb) (offsetof(FLATENTRYLIST,abEntries) + (_cb))
#define CbFLATENTRYLIST(_lplist) (offsetof(FLATENTRYLIST,abEntries) + (_lplist)->cbEntries)
#define CbNewMTSID(_cb)         (offsetof(MTSID,ab) + (_cb))
#define CbMTSID(_lpentry)       (offsetof(MTSID,ab) + (_lpentry)->cb)
#define CbNewFLATMTSIDLIST(_cb) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_cb))
#define CbFLATMTSIDLIST(_lplist) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_lplist)->cbMTSIDs)
/* No SizedXXX macros for these types. */

/* ------------------------------ */
/* ADRENTRY, ADRLIST */

typedef struct _ADRENTRY
{
    ULONG           ulReserved1;    /* Never used */
    ULONG           cValues;
    LPSPropValue    rgPropVals;
} ADRENTRY, FAR * LPADRENTRY;

typedef struct _ADRLIST
{
    ULONG           cEntries;
    ADRENTRY        aEntries[MAPI_DIM];
} ADRLIST, FAR * LPADRLIST;

#define CbNewADRLIST(_centries) \
    (offsetof(ADRLIST,aEntries) + (_centries)*sizeof(ADRENTRY))
#define CbADRLIST(_lpadrlist) \
    (offsetof(ADRLIST,aEntries) + (UINT)(_lpadrlist)->cEntries*sizeof(ADRENTRY))
#define SizedADRLIST(_centries, _name) \
struct _ADRLIST_ ## _name \
{ \
    ULONG           cEntries; \
    ADRENTRY        aEntries[_centries]; \
} _name

/* ------------------------------ */
/* SRow, SRowSet */

typedef struct _SRow
{
    ULONG           ulAdrEntryPad;  /* Pad so SRow's can map to ADRENTRY's */
    ULONG           cValues;        /* Count of property values */
    LPSPropValue    lpProps;        /* Property value array */
} SRow, FAR * LPSRow;

typedef struct _SRowSet
{
    ULONG           cRows;          /* Count of rows */
    SRow            aRow[MAPI_DIM]; /* Array of rows */
} SRowSet, FAR * LPSRowSet;

#define CbNewSRowSet(_crow)     (offsetof(SRowSet,aRow) + (_crow)*sizeof(SRow))
#define CbSRowSet(_lprowset)    (offsetof(SRowSet,aRow) + \
                                    (UINT)((_lprowset)->cRows*sizeof(SRow)))
#define SizedSRowSet(_crow, _name) \
struct _SRowSet_ ## _name \
{ \
    ULONG           cRows; \
    SRow            aRow[_crow]; \
} _name

/* MAPI Allocation Routines ------------------------------------------------ */

typedef SCODE (STDMETHODCALLTYPE ALLOCATEBUFFER)(
    ULONG           cbSize,
    LPVOID UNALIGNED FAR * lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE ALLOCATEMORE)(
    ULONG           cbSize,
    LPVOID          lpObject,
    LPVOID UNALIGNED FAR * lppBuffer
);

typedef ULONG (STDAPICALLTYPE FREEBUFFER)(
    LPVOID          lpBuffer
);

typedef ALLOCATEBUFFER FAR *LPALLOCATEBUFFER;
typedef ALLOCATEMORE FAR *  LPALLOCATEMORE;
typedef FREEBUFFER FAR *    LPFREEBUFFER;

/* MAPI Component Object Model Macros -------------------------------------- */

#if defined(MAPI_IF) && (!defined(__cplusplus) || defined(CINTERFACE))
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface;            \
        struct iface##Vtbl
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_MAPI_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef struct iface##Vtbl iface##Vtbl, FAR * iface, FAR * FAR * piface;
#else
#define DECLARE_MAPI_INTERFACE(iface)                                   \
        DECLARE_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
        DECLARE_INTERFACE_(iface, baseiface)
#ifdef __cplusplus
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        interface iface; typedef iface FAR * piface
#else
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
        typedef interface iface iface, FAR * piface
#endif
#endif

#define MAPIMETHOD(method)              MAPIMETHOD_(HRESULT, method)
#define MAPIMETHOD_(type, method)       STDMETHOD_(type, method)
#define MAPIMETHOD_DECLARE(type, method, prefix) \
        STDMETHODIMP_(type) prefix##method
#define MAPIMETHOD_TYPEDEF(type, method, prefix) \
        typedef type (STDMETHODCALLTYPE prefix##method##_METHOD)

#define MAPI_IUNKNOWN_METHODS(IPURE)                                    \
    MAPIMETHOD(QueryInterface)                                          \
        (THIS_ REFIID riid, LPVOID FAR * ppvObj) IPURE;                 \
    MAPIMETHOD_(ULONG,AddRef)  (THIS) IPURE;                            \
    MAPIMETHOD_(ULONG,Release) (THIS) IPURE;                            \

#undef  IMPL
#define IMPL

/* Pointers to MAPI Interfaces --------------------------------------------- */

typedef const IID FAR * LPCIID;

DECLARE_MAPI_INTERFACE_PTR(IMsgStore,       LPMDB);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFolder,     LPMAPIFOLDER);
DECLARE_MAPI_INTERFACE_PTR(IMessage,        LPMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IAttach,         LPATTACH);
DECLARE_MAPI_INTERFACE_PTR(IAddrBook,       LPADRBOOK);
DECLARE_MAPI_INTERFACE_PTR(IABContainer,    LPABCONT);
DECLARE_MAPI_INTERFACE_PTR(IMailUser,       LPMAILUSER);
DECLARE_MAPI_INTERFACE_PTR(IDistList,       LPDISTLIST);
DECLARE_MAPI_INTERFACE_PTR(IMAPIStatus,     LPMAPISTATUS);
DECLARE_MAPI_INTERFACE_PTR(IMAPITable,      LPMAPITABLE);
DECLARE_MAPI_INTERFACE_PTR(IProfSect,       LPPROFSECT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProp,       LPMAPIPROP);
DECLARE_MAPI_INTERFACE_PTR(IMAPIContainer,  LPMAPICONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIAdviseSink, LPMAPIADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProgress,   LPMAPIPROGRESS);
DECLARE_MAPI_INTERFACE_PTR(IProviderAdmin,  LPPROVIDERADMIN);

/* Extended MAPI Error Information ----------------------------------------- */

typedef struct _MAPIERROR
{
    ULONG   ulVersion;
    LPTSTR  lpszError;
    LPTSTR  lpszComponent;
    ULONG   ulLowLevelError;
    ULONG   ulContext;

} MAPIERROR;
typedef MAPIERROR UNALIGNED FAR * LPMAPIERROR;


/* IMAPIAdviseSink Interface ----------------------------------------------- */

/*
 *  Notification event types. The event types can be combined in a bitmask
 *  for filtering. Each one has a parameter structure associated with it:
 *
 *      fnevCriticalError       ERROR_NOTIFICATION
 *      fnevNewMail             NEWMAIL_NOTIFICATION
 *      fnevObjectCreated       OBJECT_NOTIFICATION
 *      fnevObjectDeleted       OBJECT_NOTIFICATION
 *      fnevObjectModified      OBJECT_NOTIFICATION
 *      fnevObjectCopied        OBJECT_NOTIFICATION
 *      fnevSearchComplete      OBJECT_NOTIFICATION
 *      fnevTableModified       TABLE_NOTIFICATION
 *      fnevStatusObjectModified OBJECT_NOTIFICATION
 *
 *      fnevExtended            EXTENDED_NOTIFICATION
 */

#define fnevCriticalError           ((ULONG) 0x00000001)
#define fnevNewMail                 ((ULONG) 0x00000002)
#define fnevObjectCreated           ((ULONG) 0x00000004)
#define fnevObjectDeleted           ((ULONG) 0x00000008)
#define fnevObjectModified          ((ULONG) 0x00000010)
#define fnevObjectMoved             ((ULONG) 0x00000020)
#define fnevObjectCopied            ((ULONG) 0x00000040)
#define fnevSearchComplete          ((ULONG) 0x00000080)
#define fnevTableModified           ((ULONG) 0x00000100)
#define fnevStatusObjectModified    ((ULONG) 0x00000200)
#define fnevReservedForMapi         ((ULONG) 0x40000000)
#define fnevExtended                ((ULONG) 0x80000000)

/* TABLE_NOTIFICATION event types passed in ulTableEvent */

#define TABLE_CHANGED       1
#define TABLE_ERROR         2
#define TABLE_ROW_ADDED     3
#define TABLE_ROW_DELETED   4
#define TABLE_ROW_MODIFIED  5
#define TABLE_SORT_DONE     6
#define TABLE_RESTRICT_DONE 7
#define TABLE_SETCOL_DONE   8
#define TABLE_RELOAD        9

/* Event Structures */

typedef struct _ERROR_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;
    SCODE       scode;
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPMAPIERROR lpMAPIError;        /* Detailed error information */
} ERROR_NOTIFICATION;

typedef struct _NEWMAIL_NOTIFICATION
{
    ULONG       cbEntryID;
    LPENTRYID   lpEntryID;          /* identifies the new message */
    ULONG       cbParentID;
    LPENTRYID   lpParentID;         /* identifies the folder it lives in */
    ULONG       ulFlags;            /* 0 or MAPI_UNICODE */
    LPTSTR      lpszMessageClass;   /* message class (UNICODE or string8) */
    ULONG       ulMessageFlags;     /* copy of PR_MESSAGE_FLAGS */
} NEWMAIL_NOTIFICATION;

typedef struct _OBJECT_NOTIFICATION
{
    ULONG               cbEntryID;
    LPENTRYID           lpEntryID;      /* EntryID of object */
    ULONG               ulObjType;      /* Type of object */
    ULONG               cbParentID;
    LPENTRYID           lpParentID;     /* EntryID of parent object */
    ULONG               cbOldID;
    LPENTRYID           lpOldID;        /* EntryID of old object */
    ULONG               cbOldParentID;
    LPENTRYID           lpOldParentID;  /* EntryID of old parent */
    LPSPropTagArray     lpPropTagArray;
} OBJECT_NOTIFICATION;

typedef struct _TABLE_NOTIFICATION
{
    ULONG               ulTableEvent;   /* Identifies WHICH table event */
    HRESULT             hResult;        /* Value for TABLE_ERROR */
    SPropValue          propIndex;      /* This row's "index property" */
    SPropValue          propPrior;      /* Preceding row's "index property" */
    SRow                row;            /* New data of added/modified row */
    ULONG               ulPad;          /* Force to 8-byte boundary */
} TABLE_NOTIFICATION;

typedef struct _EXTENDED_NOTIFICATION
{
    ULONG       ulEvent;                    /* extended event code */
    ULONG       cb;                         /* size of event parameters */
    LPBYTE      pbEventParameters;          /* event parameters */
} EXTENDED_NOTIFICATION;

typedef struct
{
    ULONG           cbEntryID;
    LPENTRYID       lpEntryID;
    ULONG           cValues;
    LPSPropValue    lpPropVals;
} STATUS_OBJECT_NOTIFICATION;

typedef struct _NOTIFICATION
{
    ULONG   ulEventType;        /* notification type, i.e. fnevSomething */
    ULONG   ulAlignPad;         /* Force to 8-byte boundary */
    union
    {
        ERROR_NOTIFICATION          err;
        NEWMAIL_NOTIFICATION        newmail;
        OBJECT_NOTIFICATION         obj;
        TABLE_NOTIFICATION          tab;
        EXTENDED_NOTIFICATION       ext;
        STATUS_OBJECT_NOTIFICATION  statobj;
    } info;
} NOTIFICATION, FAR * LPNOTIFICATION;


/* Interface used for registering and issuing notification callbacks. */

#define MAPI_IMAPIADVISESINK_METHODS(IPURE)                             \
    MAPIMETHOD_(ULONG, OnNotify)                                        \
        (THIS_  ULONG                       cNotif,                     \
                LPNOTIFICATION              lpNotifications) IPURE;     \

#undef       INTERFACE
#define      INTERFACE  IMAPIAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIADVISESINK_METHODS(PURE)
};

/* Callback function type for MAPIAllocAdviseSink */

typedef long (STDAPICALLTYPE NOTIFCALLBACK) (
    LPVOID          lpvContext,
    ULONG           cNotification,
    LPNOTIFICATION  lpNotifications);
typedef NOTIFCALLBACK FAR * LPNOTIFCALLBACK;

/*
 *  Message name for the 16-bit MAPI notififcation engine.
 *  This can be used in 16-bit applications to force processing
 *  of notification callbacks.
 */

#define szMAPINotificationMsg "MAPI Notify window message"


/* IMAPIProgress Interface ------------------------------------------------- */

/* Flag values for the progress indicator */

#define MAPI_TOP_LEVEL      ((ULONG) 0x00000001)

#define MAPI_IMAPIPROGRESS_METHODS(IPURE)                               \
    MAPIMETHOD(Progress)                                                \
        (THIS_  ULONG                       ulValue,                    \
                ULONG                       ulCount,                    \
                ULONG                       ulTotal) IPURE;             \
    MAPIMETHOD(GetFlags)                                                \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(GetMax)                                                  \
        (THIS_  ULONG FAR *                 lpulMax) IPURE;             \
    MAPIMETHOD(GetMin)                                                  \
        (THIS_  ULONG FAR *                 lpulMin) IPURE;             \
    MAPIMETHOD(SetLimits)                                               \
        (THIS_  LPULONG                     lpulMin,                    \
                LPULONG                     lpulMax,                    \
                LPULONG                     lpulFlags) IPURE;           \

#undef      INTERFACE
#define     INTERFACE   IMAPIProgress
DECLARE_MAPI_INTERFACE_(IMAPIProgress, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROGRESS_METHODS(PURE)
};


/* IMAPIProp Interface ----------------------------------------------------- */

/* GetLastError */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/*
 *  Version:
 */
#define MAPI_ERROR_VERSION      0x00000000L

/* GetPropList */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetProps */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* SaveChanges */

#define KEEP_OPEN_READONLY      ((ULONG) 0x00000001)
#define KEEP_OPEN_READWRITE     ((ULONG) 0x00000002)
#define FORCE_SAVE              ((ULONG) 0x00000004)
/* define MAPI_DEFERRED_ERRORS  ((ULONG) 0x00000008) below */

/* OpenProperty  - ulFlags */
/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
#define MAPI_CREATE             ((ULONG) 0x00000002)
#define STREAM_APPEND           ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* OpenProperty  - ulInterfaceOptions, IID_IMAPITable */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* CopyTo, CopyProps */

#define MAPI_MOVE               ((ULONG) 0x00000001)
#define MAPI_NOREPLACE          ((ULONG) 0x00000002)
#define MAPI_DECLINE_OK         ((ULONG) 0x00000004)

#ifndef MAPI_DIALOG             /* also defined in mapi.h */
#define MAPI_DIALOG             ((ULONG) 0x00000008)
#endif

#ifndef MAPI_USE_DEFAULT        /* also defined in mapi.h */
#define MAPI_USE_DEFAULT        0x00000040  /* Use default profile in logon */
#endif

/* Flags used in GetIDsFromNames  */
/****** MAPI_CREATE             ((ULONG) 0x00000002) above */

/* Flags used in GetNamesFromIDs  (bit fields) */
#define MAPI_NO_STRINGS         ((ULONG) 0x00000001)
#define MAPI_NO_IDS             ((ULONG) 0x00000002)

/*  Union discriminator  */
#define MNID_ID                 0
#define MNID_STRING             1
typedef struct _MAPINAMEID
{
    LPGUID lpguid;
    ULONG ulKind;
    union {
        LONG lID;
        LPWSTR lpwstrName;
    } Kind;

} MAPINAMEID, FAR * LPMAPINAMEID;

#define MAPI_IMAPIPROP_METHODS(IPURE)                                   \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(SaveChanges)                                             \
        (THIS_ ULONG                        ulFlags) IPURE;             \
    MAPIMETHOD(GetProps)                                                \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcValues,                  \
                LPSPropValue FAR *          lppPropArray) IPURE;        \
    MAPIMETHOD(GetPropList)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTagArray) IPURE;     \
    MAPIMETHOD(OpenProperty)                                            \
        (THIS_  ULONG                       ulPropTag,                  \
                LPCIID                      lpiid,                      \
                ULONG                       ulInterfaceOptions,         \
                ULONG                       ulFlags,                    \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetProps)                                                \
        (THIS_  ULONG                       cValues,                    \
                LPSPropValue                lpPropArray,                \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(DeleteProps)                                             \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyTo)                                                  \
        (THIS_  ULONG                       ciidExclude,                \
                LPCIID                      rgiidExclude,               \
                LPSPropTagArray             lpExcludeProps,             \
                ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(CopyProps)                                               \
        (THIS_  LPSPropTagArray             lpIncludeProps,             \
                ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestObj,                  \
                ULONG                       ulFlags,                    \
                LPSPropProblemArray FAR *   lppProblems) IPURE;         \
    MAPIMETHOD(GetNamesFromIDs)                                         \
        (THIS_  LPSPropTagArray FAR *       lppPropTags,                \
                LPGUID                      lpPropSetGuid,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcPropNames,               \
                LPMAPINAMEID FAR * FAR *    lpppPropNames) IPURE;       \
    MAPIMETHOD(GetIDsFromNames)                                         \
        (THIS_  ULONG                       cPropNames,                 \
                LPMAPINAMEID FAR *          lppPropNames,               \
                ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lppPropTags) IPURE;         \

#undef       INTERFACE
#define      INTERFACE  IMAPIProp
DECLARE_MAPI_INTERFACE_(IMAPIProp, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
};

/* IMAPITable Interface ---------------------------------------------------- */

/* Table status */

#define TBLSTAT_COMPLETE            ((ULONG) 0)
#define TBLSTAT_QCHANGED            ((ULONG) 7)
#define TBLSTAT_SORTING             ((ULONG) 9)
#define TBLSTAT_SORT_ERROR          ((ULONG) 10)
#define TBLSTAT_SETTING_COLS        ((ULONG) 11)
#define TBLSTAT_SETCOL_ERROR        ((ULONG) 13)
#define TBLSTAT_RESTRICTING         ((ULONG) 14)
#define TBLSTAT_RESTRICT_ERROR      ((ULONG) 15)


/* Table Type */

#define TBLTYPE_SNAPSHOT            ((ULONG) 0)
#define TBLTYPE_KEYSET              ((ULONG) 1)
#define TBLTYPE_DYNAMIC             ((ULONG) 2)


/* Sort order */

/* bit 0: set if descending, clear if ascending */

#define TABLE_SORT_ASCEND       ((ULONG) 0x00000000)
#define TABLE_SORT_DESCEND      ((ULONG) 0x00000001)
#define TABLE_SORT_COMBINE      ((ULONG) 0x00000002)


/* Data structures */

typedef struct _SSortOrder
{
    ULONG   ulPropTag;          /* Column to sort on */
    ULONG   ulOrder;            /* Ascending, descending, combine to left */
} SSortOrder, FAR * LPSSortOrder;

typedef struct _SSortOrderSet
{
    ULONG           cSorts;     /* Number of sort columns in aSort below*/
    ULONG           cCategories;    /* 0 for non-categorized, up to cSorts */
    ULONG           cExpanded;      /* 0 if no categories start expanded, */
                                    /*      up to cExpanded */
    SSortOrder      aSort[MAPI_DIM];    /* The sort orders */
} SSortOrderSet, FAR * LPSSortOrderSet;

#define CbNewSSortOrderSet(_csort) \
    (offsetof(SSortOrderSet,aSort) + (_csort)*sizeof(SSortOrder))
#define CbSSortOrderSet(_lpset) \
    (offsetof(SSortOrderSet,aSort) + \
    (UINT)((_lpset)->cSorts*sizeof(SSortOrder)))
#define SizedSSortOrderSet(_csort, _name) \
struct _SSortOrderSet_ ## _name \
{ \
    ULONG           cSorts;         \
    ULONG           cCategories;    \
    ULONG           cExpanded;      \
    SSortOrder      aSort[_csort];  \
} _name

typedef ULONG       BOOKMARK;

#define BOOKMARK_BEGINNING  ((BOOKMARK) 0)      /* Before first row */
#define BOOKMARK_CURRENT    ((BOOKMARK) 1)      /* Before current row */
#define BOOKMARK_END        ((BOOKMARK) 2)      /* After last row */

/* Fuzzy Level */

#define FL_FULLSTRING       ((ULONG) 0x00000000)
#define FL_SUBSTRING        ((ULONG) 0x00000001)
#define FL_PREFIX           ((ULONG) 0x00000002)

#define FL_IGNORECASE       ((ULONG) 0x00010000)
#define FL_IGNORENONSPACE   ((ULONG) 0x00020000)
#define FL_LOOSE            ((ULONG) 0x00040000)

/* Restrictions */

typedef struct _SRestriction    FAR * LPSRestriction;

/* Restriction types */

#define RES_AND             ((ULONG) 0x00000000)
#define RES_OR              ((ULONG) 0x00000001)
#define RES_NOT             ((ULONG) 0x00000002)
#define RES_CONTENT         ((ULONG) 0x00000003)
#define RES_PROPERTY        ((ULONG) 0x00000004)
#define RES_COMPAREPROPS    ((ULONG) 0x00000005)
#define RES_BITMASK         ((ULONG) 0x00000006)
#define RES_SIZE            ((ULONG) 0x00000007)
#define RES_EXIST           ((ULONG) 0x00000008)
#define RES_SUBRESTRICTION  ((ULONG) 0x00000009)
#define RES_COMMENT         ((ULONG) 0x0000000A)

/* Relational operators. These apply to all property comparison restrictions. */

#define RELOP_LT        ((ULONG) 0)     /* <  */
#define RELOP_LE        ((ULONG) 1)     /* <= */
#define RELOP_GT        ((ULONG) 2)     /* >  */
#define RELOP_GE        ((ULONG) 3)     /* >= */
#define RELOP_EQ        ((ULONG) 4)     /* == */
#define RELOP_NE        ((ULONG) 5)     /* != */
#define RELOP_RE        ((ULONG) 6)     /* LIKE (Regular expression) */

/* Bitmask operators, for RES_BITMASK only. */

#define BMR_EQZ     ((ULONG) 0)     /* ==0 */
#define BMR_NEZ     ((ULONG) 1)     /* !=0 */

/* Subobject identifiers for RES_SUBRESTRICTION only. See MAPITAGS.H. */

/* #define PR_MESSAGE_RECIPIENTS  PROP_TAG(PT_OBJECT,0x0E12) */
/* #define PR_MESSAGE_ATTACHMENTS PROP_TAG(PT_OBJECT,0x0E13) */

typedef struct _SAndRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SAndRestriction;

typedef struct _SOrRestriction
{
    ULONG           cRes;
    LPSRestriction  lpRes;
} SOrRestriction;

typedef struct _SNotRestriction
{
    ULONG           ulReserved;
    LPSRestriction  lpRes;
} SNotRestriction;

typedef struct _SContentRestriction
{
    ULONG           ulFuzzyLevel;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SContentRestriction;

typedef struct _SBitMaskRestriction
{
    ULONG           relBMR;
    ULONG           ulPropTag;
    ULONG           ulMask;
} SBitMaskRestriction;

typedef struct _SPropertyRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    LPSPropValue    lpProp;
} SPropertyRestriction;

typedef struct _SComparePropsRestriction
{
    ULONG           relop;
    ULONG           ulPropTag1;
    ULONG           ulPropTag2;
} SComparePropsRestriction;

typedef struct _SSizeRestriction
{
    ULONG           relop;
    ULONG           ulPropTag;
    ULONG           cb;
} SSizeRestriction;

typedef struct _SExistRestriction
{
    ULONG           ulReserved1;
    ULONG           ulPropTag;
    ULONG           ulReserved2;
} SExistRestriction;

typedef struct _SSubRestriction
{
    ULONG           ulSubObject;
    LPSRestriction  lpRes;
} SSubRestriction;

typedef struct _SCommentRestriction
{
    ULONG           cValues; /* # of properties in lpProp */
    LPSRestriction  lpRes;
    LPSPropValue    lpProp;
} SCommentRestriction;

typedef struct _SRestriction
{
    ULONG   rt;         /* Restriction type */
    union
    {
        SComparePropsRestriction    resCompareProps;    /* first */
        SAndRestriction             resAnd;
        SOrRestriction              resOr;
        SNotRestriction             resNot;
        SContentRestriction         resContent;
        SPropertyRestriction        resProperty;
        SBitMaskRestriction         resBitMask;
        SSizeRestriction            resSize;
        SExistRestriction           resExist;
        SSubRestriction             resSub;
        SCommentRestriction         resComment;
    } res;
} SRestriction;

/* SComparePropsRestriction is first in the union so that */
/* static initializations of 3-value restriction work.    */

/* Flags of the methods of IMAPITable */

/* QueryColumn */

#define TBL_ALL_COLUMNS     ((ULONG) 0x00000001)

/* QueryRows */
/* Possible values for PR_ROW_TYPE (for categorization) */

#define TBL_LEAF_ROW            ((ULONG) 1)
#define TBL_EMPTY_CATEGORY      ((ULONG) 2)
#define TBL_EXPANDED_CATEGORY   ((ULONG) 3)
#define TBL_COLLAPSED_CATEGORY  ((ULONG) 4)

/* Table wait flag */

#define TBL_NOWAIT          ((ULONG) 0x00000001)
/* alternative name for TBL_NOWAIT */
#define TBL_ASYNC           ((ULONG) 0x00000001)
#define TBL_BATCH           ((ULONG) 0x00000002)

/* FindRow */

#define DIR_BACKWARD        ((ULONG) 0x00000001)

/* Table cursor states */

#define TBL_NOADVANCE       ((ULONG) 0x00000001)

#define MAPI_IMAPITABLE_METHODS(IPURE)                                  \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(GetStatus)                                               \
        (THIS_  ULONG FAR *                 lpulTableStatus,            \
                ULONG FAR *                 lpulTableType) IPURE;       \
    MAPIMETHOD(SetColumns)                                              \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QueryColumns)                                            \
        (THIS_  ULONG                       ulFlags,                    \
                LPSPropTagArray FAR *       lpPropTagArray) IPURE;      \
    MAPIMETHOD(GetRowCount)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulCount) IPURE;           \
    MAPIMETHOD(SeekRow)                                                 \
        (THIS_  BOOKMARK                    bkOrigin,                   \
                LONG                        lRowCount,                  \
                LONG FAR *                  lplRowsSought) IPURE;       \
    MAPIMETHOD(SeekRowApprox)                                           \
        (THIS_  ULONG                       ulNumerator,                \
                ULONG                       ulDenominator) IPURE;       \
    MAPIMETHOD(QueryPosition)                                           \
        (THIS_  ULONG FAR *                 lpulRow,                    \
                ULONG FAR *                 lpulNumerator,              \
                ULONG FAR *                 lpulDenominator) IPURE;     \
    MAPIMETHOD(FindRow)                                                 \
        (THIS_  LPSRestriction              lpRestriction,              \
                BOOKMARK                    bkOrigin,                   \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(Restrict)                                                \
        (THIS_  LPSRestriction              lpRestriction,              \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateBookmark)                                          \
        (THIS_  BOOKMARK FAR *              lpbkPosition) IPURE;        \
    MAPIMETHOD(FreeBookmark)                                            \
        (THIS_  BOOKMARK                    bkPosition) IPURE;          \
    MAPIMETHOD(SortTable)                                               \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(QuerySortOrder)                                          \
        (THIS_  LPSSortOrderSet FAR *       lppSortCriteria) IPURE;     \
    MAPIMETHOD(QueryRows)                                               \
        (THIS_  LONG                        lRowCount,                  \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows) IPURE;             \
    MAPIMETHOD(Abort) (THIS) IPURE;                                     \
    MAPIMETHOD(ExpandRow)                                               \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulRowCount,                 \
                ULONG                       ulFlags,                    \
                LPSRowSet FAR *             lppRows,                    \
                ULONG FAR *                 lpulMoreRows) IPURE;        \
    MAPIMETHOD(CollapseRow)                                             \
        (THIS_  ULONG                       cbInstanceKey,              \
                LPBYTE                      pbInstanceKey,              \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulRowCount) IPURE;        \
    MAPIMETHOD(WaitForCompletion)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       ulTimeout,                  \
                ULONG FAR *                 lpulTableStatus) IPURE;     \
    MAPIMETHOD(GetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbInstanceKey,              \
                LPBYTE                      lpbInstanceKey,             \
                ULONG FAR *                 lpcbCollapseState,          \
                LPBYTE FAR *                lppbCollapseState) IPURE;   \
    MAPIMETHOD(SetCollapseState)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbCollapseState,            \
                LPBYTE                      pbCollapseState,            \
                BOOKMARK FAR *              lpbkLocation) IPURE;        \

#undef       INTERFACE
#define      INTERFACE  IMAPITable
DECLARE_MAPI_INTERFACE_(IMAPITable, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPITABLE_METHODS(PURE)
};

/* IProfSect Interface ----------------------------------------------------- */

/* Standard section for public profile properties */

#define PS_PROFILE_PROPERTIES_INIT \
{   0x98, 0x15, 0xAC, 0x08, 0xAA, 0xB0, 0x10, 0x1A, \
    0x8C, 0x93, 0x08, 0x00, 0x2B, 0x2A, 0x56, 0xC2  }


#define MAPI_IPROFSECT_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IProfSect
DECLARE_MAPI_INTERFACE_(IProfSect, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IPROFSECT_METHODS(PURE)
};

/* IMAPIStatus Interface --------------------------------------------------- */

/* Values for PR_RESOURCE_TYPE, _METHODS, _FLAGS */

#define MAPI_STORE_PROVIDER     ((ULONG) 33)    /* Message Store */
#define MAPI_AB                 ((ULONG) 34)    /* Address Book */
#define MAPI_AB_PROVIDER        ((ULONG) 35)    /* Address Book Provider */
#define MAPI_TRANSPORT_PROVIDER ((ULONG) 36)    /* Transport Provider */
#define MAPI_SPOOLER            ((ULONG) 37)    /* Message Spooler */
#define MAPI_PROFILE_PROVIDER   ((ULONG) 38)    /* Profile Provider */
#define MAPI_SUBSYSTEM          ((ULONG) 39)    /* Overall Subsystem Status */
#define MAPI_HOOK_PROVIDER      ((ULONG) 40)    /* Spooler Hook */

#define STATUS_VALIDATE_STATE   ((ULONG) 0x00000001)
#define STATUS_SETTINGS_DIALOG  ((ULONG) 0x00000002)
#define STATUS_CHANGE_PASSWORD  ((ULONG) 0x00000004)
#define STATUS_FLUSH_QUEUES     ((ULONG) 0x00000008)

#define STATUS_DEFAULT_OUTBOUND ((ULONG) 0x00000001)
#define STATUS_DEFAULT_STORE    ((ULONG) 0x00000002)
#define STATUS_PRIMARY_IDENTITY ((ULONG) 0x00000004)
#define STATUS_SIMPLE_STORE     ((ULONG) 0x00000008)
#define STATUS_XP_PREFER_LAST   ((ULONG) 0x00000010)
#define STATUS_NO_PRIMARY_IDENTITY ((ULONG) 0x00000020)
#define STATUS_NO_DEFAULT_STORE ((ULONG) 0x00000040)
#define STATUS_TEMP_SECTION     ((ULONG) 0x00000080)
#define STATUS_OWN_STORE        ((ULONG) 0x00000100)
/****** HOOK_INBOUND            ((ULONG) 0x00000200) Defined in MAPIHOOK.H */
/****** HOOK_OUTBOUND           ((ULONG) 0x00000400) Defined in MAPIHOOK.H */
#define STATUS_NEED_IPM_TREE    ((ULONG) 0x00000800)
#define STATUS_PRIMARY_STORE    ((ULONG) 0x00001000)
#define STATUS_SECONDARY_STORE  ((ULONG) 0x00002000)


/*
 * PR_STATUS_CODE bit. Low 16 bits for common values; High 16 bits
 * for provider type-specific values. (DCR 304)
 */

#define STATUS_AVAILABLE        ((ULONG) 0x00000001)
#define STATUS_OFFLINE          ((ULONG) 0x00000002)
#define STATUS_FAILURE          ((ULONG) 0x00000004)

/* Transport values of PR_STATUS_CODE */

#define STATUS_INBOUND_ENABLED  ((ULONG) 0x00010000)
#define STATUS_INBOUND_ACTIVE   ((ULONG) 0x00020000)
#define STATUS_INBOUND_FLUSH    ((ULONG) 0x00040000)
#define STATUS_OUTBOUND_ENABLED ((ULONG) 0x00100000)
#define STATUS_OUTBOUND_ACTIVE  ((ULONG) 0x00200000)
#define STATUS_OUTBOUND_FLUSH   ((ULONG) 0x00400000)
#define STATUS_REMOTE_ACCESS    ((ULONG) 0x00800000)

/* ValidateState flags */

#define SUPPRESS_UI                 ((ULONG) 0x00000001)
#define REFRESH_XP_HEADER_CACHE     ((ULONG) 0x00010000)
#define PROCESS_XP_HEADER_CACHE     ((ULONG) 0x00020000)
#define FORCE_XP_CONNECT            ((ULONG) 0x00040000)
#define FORCE_XP_DISCONNECT         ((ULONG) 0x00080000)
#define CONFIG_CHANGED              ((ULONG) 0x00100000)
#define ABORT_XP_HEADER_OPERATION   ((ULONG) 0x00200000)
#define SHOW_XP_SESSION_UI          ((ULONG) 0x00400000)

/* SettingsDialog flags */

#define UI_READONLY     ((ULONG) 0x00000001)

/* FlushQueues flags */

#define FLUSH_UPLOAD        ((ULONG) 0x00000002)
#define FLUSH_DOWNLOAD      ((ULONG) 0x00000004)
#define FLUSH_FORCE         ((ULONG) 0x00000008)
#define FLUSH_NO_UI         ((ULONG) 0x00000010)
#define FLUSH_ASYNC_OK      ((ULONG) 0x00000020)

#define MAPI_IMAPISTATUS_METHODS(IPURE)                                 \
    MAPIMETHOD(ValidateState)                                           \
        (THIS_  ULONG_PTR                   ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SettingsDialog)                                          \
        (THIS_  ULONG_PTR                   ulUIParam,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ChangePassword)                                          \
        (THIS_  LPTSTR                      lpOldPass,                  \
                LPTSTR                      lpNewPass,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(FlushQueues)                                             \
        (THIS_  ULONG_PTR                   ulUIParam,                  \
                ULONG                       cbTargetTransport,          \
                LPENTRYID                   lpTargetTransport,          \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMAPIStatus
DECLARE_MAPI_INTERFACE_(IMAPIStatus, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPISTATUS_METHODS(PURE)
};

/* IMAPIContainer Interface ------------------------------------------------ */

/* Flags for OpenEntry() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
#define MAPI_BEST_ACCESS        ((ULONG) 0x00000010)

/* GetContentsTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED         ((ULONG) 0x00000040) below */
#define WAB_LOCAL_CONTAINERS    0x00100000
#define WAB_PROFILE_CONTENTS    0x00200000

/* GetHierarchyTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define CONVENIENT_DEPTH        ((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* GetSearchCriteria */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define SEARCH_RUNNING          ((ULONG) 0x00000001)
#define SEARCH_REBUILD          ((ULONG) 0x00000002)
#define SEARCH_RECURSIVE        ((ULONG) 0x00000004)
#define SEARCH_FOREGROUND       ((ULONG) 0x00000008)

/* SetSearchCriteria */
#define STOP_SEARCH             ((ULONG) 0x00000001)
#define RESTART_SEARCH          ((ULONG) 0x00000002)
#define RECURSIVE_SEARCH        ((ULONG) 0x00000004)
#define SHALLOW_SEARCH          ((ULONG) 0x00000008)
#define FOREGROUND_SEARCH       ((ULONG) 0x00000010)
#define BACKGROUND_SEARCH       ((ULONG) 0x00000020)

#define MAPI_IMAPICONTAINER_METHODS(IPURE)                              \
    MAPIMETHOD(GetContentsTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(GetHierarchyTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetSearchCriteria)                                       \
        (THIS_  LPSRestriction              lpRestriction,              \
                LPENTRYLIST                 lpContainerList,            \
                ULONG                       ulSearchFlags) IPURE;       \
    MAPIMETHOD(GetSearchCriteria)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPSRestriction FAR *        lppRestriction,             \
                LPENTRYLIST FAR *           lppContainerList,           \
                ULONG FAR *                 lpulSearchState)IPURE;      \

#undef       INTERFACE
#define      INTERFACE  IMAPIContainer
DECLARE_MAPI_INTERFACE_(IMAPIContainer, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
};

/* IABContainer Interface -------------------------------------------------- */

/*
 *  IABContainer PR_CONTAINER_FLAGS values
 *  If AB_UNMODIFIABLE and AB_MODIFIABLE are both set, it means the container
 *  doesn't know if it's modifiable or not, and the client should
 *  try to modify the contents but we won't expect it to work.
 *  If the AB_RECIPIENTS flag is set and neither AB_MODIFIABLE or AB_UNMODIFIABLE
 *  bits are set, it is an error.
 */

typedef struct _flaglist
{
    ULONG cFlags;
    ULONG ulFlag[MAPI_DIM];
} FlagList, FAR * LPFlagList;


/*
 *  Container flags
 */
#define AB_RECIPIENTS           ((ULONG) 0x00000001)
#define AB_SUBCONTAINERS        ((ULONG) 0x00000002)
#define AB_MODIFIABLE           ((ULONG) 0x00000004)
#define AB_UNMODIFIABLE         ((ULONG) 0x00000008)
#define AB_FIND_ON_OPEN         ((ULONG) 0x00000010)
#define AB_NOT_DEFAULT          ((ULONG) 0x00000020)

/* CreateEntry() */

#define CREATE_CHECK_DUP_STRICT ((ULONG) 0x00000001)
#define CREATE_CHECK_DUP_LOOSE  ((ULONG) 0x00000002)
#define CREATE_REPLACE          ((ULONG) 0x00000004)
#define CREATE_MERGE            ((ULONG) 0x00000008)

/* ResolveNames() - ulFlags */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */
#define WAB_IGNORE_PROFILES     0x00800000

/* ResolveNames() - rgulFlags */
#define MAPI_UNRESOLVED         ((ULONG) 0x00000000)
#define MAPI_AMBIGUOUS          ((ULONG) 0x00000001)
#define MAPI_RESOLVED           ((ULONG) 0x00000002)


#define MAPI_IABCONTAINER_METHODS(IPURE)                                \
    MAPIMETHOD(CreateEntry)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulCreateFlags,              \
                LPMAPIPROP FAR  *           lppMAPIPropEntry) IPURE;    \
    MAPIMETHOD(CopyEntries)                                             \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteEntries)                                           \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ResolveNames)                                            \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                LPADRLIST                   lpAdrList,                  \
                LPFlagList                  lpFlagList) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IABContainer
DECLARE_MAPI_INTERFACE_(IABContainer, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IABCONTAINER_METHODS(PURE)
};

/* IMailUser Interface ----------------------------------------------------- */

/*  Any call which can create a one-off entryID (i.e. MAPISupport::CreateOneOff
    or IAddrBook::CreateOneOff) can encode the value for PR_SEND_RICH_INFO by
    passing in the following flag in the ulFlags parameter.  Setting this flag
    indicates that PR_SEND_RICH_INFO will be FALSE.
*/
#define MAPI_SEND_NO_RICH_INFO      ((ULONG) 0x00010000)




/* Values of PR_NDR_DIAG_CODE */

#define MAPI_DIAG(_code)    ((LONG) _code)

#define MAPI_DIAG_NO_DIAGNOSTIC                     MAPI_DIAG( -1 )
#define MAPI_DIAG_OR_NAME_UNRECOGNIZED              MAPI_DIAG( 0 )
#define MAPI_DIAG_OR_NAME_AMBIGUOUS                 MAPI_DIAG( 1 )
#define MAPI_DIAG_MTS_CONGESTED                     MAPI_DIAG( 2 )
#define MAPI_DIAG_LOOP_DETECTED                     MAPI_DIAG( 3 )
#define MAPI_DIAG_RECIPIENT_UNAVAILABLE             MAPI_DIAG( 4 )
#define MAPI_DIAG_MAXIMUM_TIME_EXPIRED              MAPI_DIAG( 5 )
#define MAPI_DIAG_EITS_UNSUPPORTED                  MAPI_DIAG( 6 )
#define MAPI_DIAG_CONTENT_TOO_LONG                  MAPI_DIAG( 7 )
#define MAPI_DIAG_IMPRACTICAL_TO_CONVERT            MAPI_DIAG( 8 )
#define MAPI_DIAG_PROHIBITED_TO_CONVERT             MAPI_DIAG( 9 )
#define MAPI_DIAG_CONVERSION_UNSUBSCRIBED           MAPI_DIAG( 10 )
#define MAPI_DIAG_PARAMETERS_INVALID                MAPI_DIAG( 11 )
#define MAPI_DIAG_CONTENT_SYNTAX_IN_ERROR           MAPI_DIAG( 12 )
#define MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD         MAPI_DIAG( 13 )
#define MAPI_DIAG_NUMBER_CONSTRAINT_VIOLATD         MAPI_DIAG( 14 )
#define MAPI_DIAG_CONTENT_TYPE_UNSUPPORTED          MAPI_DIAG( 15 )
#define MAPI_DIAG_TOO_MANY_RECIPIENTS               MAPI_DIAG( 16 )
#define MAPI_DIAG_NO_BILATERAL_AGREEMENT            MAPI_DIAG( 17 )
#define MAPI_DIAG_CRITICAL_FUNC_UNSUPPORTED         MAPI_DIAG( 18 )
#define MAPI_DIAG_CONVERSION_LOSS_PROHIB            MAPI_DIAG( 19 )
#define MAPI_DIAG_LINE_TOO_LONG                     MAPI_DIAG( 20 )
#define MAPI_DIAG_PAGE_TOO_LONG                     MAPI_DIAG( 21 )
#define MAPI_DIAG_PICTORIAL_SYMBOL_LOST             MAPI_DIAG( 22 )
#define MAPI_DIAG_PUNCTUATION_SYMBOL_LOST           MAPI_DIAG( 23 )
#define MAPI_DIAG_ALPHABETIC_CHARACTER_LOST         MAPI_DIAG( 24 )
#define MAPI_DIAG_MULTIPLE_INFO_LOSSES              MAPI_DIAG( 25 )
#define MAPI_DIAG_REASSIGNMENT_PROHIBITED           MAPI_DIAG( 26 )
#define MAPI_DIAG_REDIRECTION_LOOP_DETECTED         MAPI_DIAG( 27 )
#define MAPI_DIAG_EXPANSION_PROHIBITED              MAPI_DIAG( 28 )
#define MAPI_DIAG_SUBMISSION_PROHIBITED             MAPI_DIAG( 29 )
#define MAPI_DIAG_EXPANSION_FAILED                  MAPI_DIAG( 30 )
#define MAPI_DIAG_RENDITION_UNSUPPORTED             MAPI_DIAG( 31 )
#define MAPI_DIAG_MAIL_ADDRESS_INCORRECT            MAPI_DIAG( 32 )
#define MAPI_DIAG_MAIL_OFFICE_INCOR_OR_INVD         MAPI_DIAG( 33 )
#define MAPI_DIAG_MAIL_ADDRESS_INCOMPLETE           MAPI_DIAG( 34 )
#define MAPI_DIAG_MAIL_RECIPIENT_UNKNOWN            MAPI_DIAG( 35 )
#define MAPI_DIAG_MAIL_RECIPIENT_DECEASED           MAPI_DIAG( 36 )
#define MAPI_DIAG_MAIL_ORGANIZATION_EXPIRED         MAPI_DIAG( 37 )
#define MAPI_DIAG_MAIL_REFUSED                      MAPI_DIAG( 38 )
#define MAPI_DIAG_MAIL_UNCLAIMED                    MAPI_DIAG( 39 )
#define MAPI_DIAG_MAIL_RECIPIENT_MOVED              MAPI_DIAG( 40 )
#define MAPI_DIAG_MAIL_RECIPIENT_TRAVELLING         MAPI_DIAG( 41 )
#define MAPI_DIAG_MAIL_RECIPIENT_DEPARTED           MAPI_DIAG( 42 )
#define MAPI_DIAG_MAIL_NEW_ADDRESS_UNKNOWN          MAPI_DIAG( 43 )
#define MAPI_DIAG_MAIL_FORWARDING_UNWANTED          MAPI_DIAG( 44 )
#define MAPI_DIAG_MAIL_FORWARDING_PROHIB            MAPI_DIAG( 45 )
#define MAPI_DIAG_SECURE_MESSAGING_ERROR            MAPI_DIAG( 46 )
#define MAPI_DIAG_DOWNGRADING_IMPOSSIBLE            MAPI_DIAG( 47 )


#define MAPI_IMAILUSER_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IMailUser
DECLARE_MAPI_INTERFACE_(IMailUser, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAILUSER_METHODS(PURE)
};

/* IDistList Interface ----------------------------------------------------- */

#define MAPI_IDISTLIST_METHODS(IPURE)                                   \
    MAPIMETHOD(CreateEntry)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulCreateFlags,              \
                LPMAPIPROP FAR  *           lppMAPIPropEntry) IPURE;    \
    MAPIMETHOD(CopyEntries)                                             \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteEntries)                                           \
        (THIS_  LPENTRYLIST                 lpEntries,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(ResolveNames)                                            \
        (THIS_  LPSPropTagArray             lpPropTagArray,             \
                ULONG                       ulFlags,                    \
                LPADRLIST                   lpAdrList,                  \
                LPFlagList                  lpFlagList) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IDistList
DECLARE_MAPI_INTERFACE_(IDistList, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IDISTLIST_METHODS(PURE)
};

/* IMAPIFolder Interface --------------------------------------------------- */

/* IMAPIFolder folder type (enum) */

#define FOLDER_ROOT             ((ULONG) 0x00000000)
#define FOLDER_GENERIC          ((ULONG) 0x00000001)
#define FOLDER_SEARCH           ((ULONG) 0x00000002)

/* CreateMessage */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED         ((ULONG) 0x00000040) below */

/* CopyMessages */

#define MESSAGE_MOVE            ((ULONG) 0x00000001)
#define MESSAGE_DIALOG          ((ULONG) 0x00000002)
/****** MAPI_DECLINE_OK         ((ULONG) 0x00000004) above */

/* CreateFolder */

#define OPEN_IF_EXISTS          ((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* DeleteFolder */

#define DEL_MESSAGES            ((ULONG) 0x00000001)
#define FOLDER_DIALOG           ((ULONG) 0x00000002)
#define DEL_FOLDERS             ((ULONG) 0x00000004)

/* EmptyFolder */
#define DEL_ASSOCIATED          ((ULONG) 0x00000008)

/* CopyFolder */

#define FOLDER_MOVE             ((ULONG) 0x00000001)
/****** FOLDER_DIALOG           ((ULONG) 0x00000002) above */
/****** MAPI_DECLINE_OK         ((ULONG) 0x00000004) above */
#define COPY_SUBFOLDERS         ((ULONG) 0x00000010)
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */


/* SetReadFlags */

/****** SUPPRESS_RECEIPT        ((ULONG) 0x00000001) below */
/****** MESSAGE_DIALOG          ((ULONG) 0x00000002) above */
/****** CLEAR_READ_FLAG         ((ULONG) 0x00000004) below */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
#define GENERATE_RECEIPT_ONLY   ((ULONG) 0x00000010)


/* GetMessageStatus */

#define MSGSTATUS_HIGHLIGHTED   ((ULONG) 0x00000001)
#define MSGSTATUS_TAGGED        ((ULONG) 0x00000002)
#define MSGSTATUS_HIDDEN        ((ULONG) 0x00000004)
#define MSGSTATUS_DELMARKED     ((ULONG) 0x00000008)

/* Bits for remote message status */

#define MSGSTATUS_REMOTE_DOWNLOAD   ((ULONG) 0x00001000)
#define MSGSTATUS_REMOTE_DELETE     ((ULONG) 0x00002000)

/* SaveContentsSort */

#define RECURSIVE_SORT          ((ULONG) 0x00000002)

/* PR_STATUS property */

#define FLDSTATUS_HIGHLIGHTED   ((ULONG) 0x00000001)
#define FLDSTATUS_TAGGED        ((ULONG) 0x00000002)
#define FLDSTATUS_HIDDEN        ((ULONG) 0x00000004)
#define FLDSTATUS_DELMARKED     ((ULONG) 0x00000008)

#define MAPI_IMAPIFOLDER_METHODS(IPURE)                                 \
    MAPIMETHOD(CreateMessage)                                           \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMESSAGE FAR *             lppMessage) IPURE;          \
    MAPIMETHOD(CopyMessages)                                            \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestFolder,               \
                ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteMessages)                                          \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(CreateFolder)                                            \
        (THIS_  ULONG                       ulFolderType,               \
                LPTSTR                      lpszFolderName,             \
                LPTSTR                      lpszFolderComment,          \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPMAPIFOLDER FAR *          lppFolder) IPURE;           \
    MAPIMETHOD(CopyFolder)                                              \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                LPVOID                      lpDestFolder,               \
                LPTSTR                      lpszNewFolderName,          \
                ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(DeleteFolder)                                            \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetReadFlags)                                            \
        (THIS_  LPENTRYLIST                 lpMsgList,                  \
                ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetMessageStatus)                                        \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulMessageStatus) IPURE;   \
    MAPIMETHOD(SetMessageStatus)                                        \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulNewStatus,                \
                ULONG                       ulNewStatusMask,            \
                ULONG FAR *                 lpulOldStatus) IPURE;       \
    MAPIMETHOD(SaveContentsSort)                                        \
        (THIS_  LPSSortOrderSet             lpSortCriteria,             \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(EmptyFolder)                                             \
        (THIS_  ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMAPIFolder
DECLARE_MAPI_INTERFACE_(IMAPIFolder, IMAPIContainer)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMAPICONTAINER_METHODS(PURE)
    MAPI_IMAPIFOLDER_METHODS(PURE)
};

/* IMsgStore Interface ----------------------------------------------------- */

/*  PR_STORE_SUPPORT_MASK bits */
#define STORE_ENTRYID_UNIQUE    ((ULONG) 0x00000001)
#define STORE_READONLY          ((ULONG) 0x00000002)
#define STORE_SEARCH_OK         ((ULONG) 0x00000004)
#define STORE_MODIFY_OK         ((ULONG) 0x00000008)
#define STORE_CREATE_OK         ((ULONG) 0x00000010)
#define STORE_ATTACH_OK         ((ULONG) 0x00000020)
#define STORE_OLE_OK            ((ULONG) 0x00000040)
#define STORE_SUBMIT_OK         ((ULONG) 0x00000080)
#define STORE_NOTIFY_OK         ((ULONG) 0x00000100)
#define STORE_MV_PROPS_OK       ((ULONG) 0x00000200)
#define STORE_CATEGORIZE_OK     ((ULONG) 0x00000400)
#define STORE_RTF_OK            ((ULONG) 0x00000800)
#define STORE_RESTRICTION_OK    ((ULONG) 0x00001000)
#define STORE_SORT_OK           ((ULONG) 0x00002000)

/* PR_STORE_STATE bits, try not to collide with PR_STORE_SUPPORT_MASK */

#define STORE_HAS_SEARCHES      ((ULONG) 0x01000000)


/* OpenEntry() */

/****** MAPI_MODIFY             ((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** MAPI_BEST_ACCESS        ((ULONG) 0x00000010) above */

/* SetReceiveFolder() */

/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetReceiveFolder() */

/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetReceiveFolderTable() */

/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */

/* StoreLogoff() */

#define LOGOFF_NO_WAIT          ((ULONG) 0x00000001)
#define LOGOFF_ORDERLY          ((ULONG) 0x00000002)
#define LOGOFF_PURGE            ((ULONG) 0x00000004)
#define LOGOFF_ABORT            ((ULONG) 0x00000008)
#define LOGOFF_QUIET            ((ULONG) 0x00000010)

#define LOGOFF_COMPLETE         ((ULONG) 0x00010000)
#define LOGOFF_INBOUND          ((ULONG) 0x00020000)
#define LOGOFF_OUTBOUND         ((ULONG) 0x00040000)
#define LOGOFF_OUTBOUND_QUEUE   ((ULONG) 0x00080000)

/* SetLockState() */

#define MSG_LOCKED              ((ULONG) 0x00000001)
#define MSG_UNLOCKED            ((ULONG) 0x00000000)

/* Flag bits for PR_VALID_FOLDER_MASK */

#define FOLDER_IPM_SUBTREE_VALID        ((ULONG) 0x00000001)
#define FOLDER_IPM_INBOX_VALID          ((ULONG) 0x00000002)
#define FOLDER_IPM_OUTBOX_VALID         ((ULONG) 0x00000004)
#define FOLDER_IPM_WASTEBASKET_VALID    ((ULONG) 0x00000008)
#define FOLDER_IPM_SENTMAIL_VALID       ((ULONG) 0x00000010)
#define FOLDER_VIEWS_VALID              ((ULONG) 0x00000020)
#define FOLDER_COMMON_VIEWS_VALID       ((ULONG) 0x00000040)
#define FOLDER_FINDER_VALID             ((ULONG) 0x00000080)

#define MAPI_IMSGSTORE_METHODS(IPURE)                                   \
    MAPIMETHOD(Advise)                                                  \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
                LPMAPIADVISESINK            lpAdviseSink,               \
                ULONG FAR *                 lpulConnection) IPURE;      \
    MAPIMETHOD(Unadvise)                                                \
        (THIS_  ULONG                       ulConnection) IPURE;        \
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPUNKNOWN FAR *             lppUnk) IPURE;              \
    MAPIMETHOD(SetReceiveFolder)                                        \
        (THIS_  LPTSTR                      lpszMessageClass,           \
                ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(GetReceiveFolder)                                        \
        (THIS_  LPTSTR                      lpszMessageClass,           \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpcbEntryID,                \
                LPENTRYID FAR *             lppEntryID,                 \
                LPTSTR FAR *                lppszExplicitClass) IPURE;  \
    MAPIMETHOD(GetReceiveFolderTable)                                   \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(StoreLogoff)                                             \
        (THIS_  ULONG FAR *                 lpulFlags) IPURE;           \
    MAPIMETHOD(AbortSubmit)                                             \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetOutgoingQueue)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(SetLockState)                                            \
        (THIS_  LPMESSAGE                   lpMessage,                  \
                ULONG                       ulLockState) IPURE;         \
    MAPIMETHOD(FinishedMsg)                                             \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID) IPURE;           \
    MAPIMETHOD(NotifyNewMail)                                           \
        (THIS_  LPNOTIFICATION              lpNotification) IPURE;      \

#undef       INTERFACE
#define      INTERFACE  IMsgStore
DECLARE_MAPI_INTERFACE_(IMsgStore, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMSGSTORE_METHODS(PURE)
};

/* IMessage Interface ------------------------------------------------------ */

/* SubmitMessage */

#define FORCE_SUBMIT                ((ULONG) 0x00000001)

/* Flags defined in PR_MESSAGE_FLAGS */

#define MSGFLAG_READ            ((ULONG) 0x00000001)
#define MSGFLAG_UNMODIFIED      ((ULONG) 0x00000002)
#define MSGFLAG_SUBMIT          ((ULONG) 0x00000004)
#define MSGFLAG_UNSENT          ((ULONG) 0x00000008)
#define MSGFLAG_HASATTACH       ((ULONG) 0x00000010)
#define MSGFLAG_FROMME          ((ULONG) 0x00000020)
#define MSGFLAG_ASSOCIATED      ((ULONG) 0x00000040)
#define MSGFLAG_RESEND          ((ULONG) 0x00000080)
#define MSGFLAG_RN_PENDING		((ULONG) 0x00000100)
#define MSGFLAG_NRN_PENDING		((ULONG) 0x00000200)

/* Flags defined in PR_SUBMIT_FLAGS */

#define SUBMITFLAG_LOCKED       ((ULONG) 0x00000001)
#define SUBMITFLAG_PREPROCESS   ((ULONG) 0x00000002)

/* GetAttachmentTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* GetRecipientTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* ModifyRecipients */

/* ((ULONG) 0x00000001 is not a valid flag on ModifyRecipients. */
#define MODRECIP_ADD            ((ULONG) 0x00000002)
#define MODRECIP_MODIFY         ((ULONG) 0x00000004)
#define MODRECIP_REMOVE         ((ULONG) 0x00000008)

/* SetReadFlag */

#define SUPPRESS_RECEIPT        ((ULONG) 0x00000001)
#define CLEAR_READ_FLAG         ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) below */
/****** GENERATE_RECEIPT_ONLY   ((ULONG) 0x00000010) above */
#define GENERATE_RECEIPT_ONLY	((ULONG) 0x00000010)
#define CLEAR_RN_PENDING		((ULONG) 0x00000020)
#define CLEAR_NRN_PENDING		((ULONG) 0x00000040)

/* DeleteAttach */

#define ATTACH_DIALOG           ((ULONG) 0x00000001)

/* PR_SECURITY values */
#define SECURITY_SIGNED         ((ULONG) 0x00000001)
#define SECURITY_ENCRYPTED      ((ULONG) 0x00000002)

/* PR_PRIORITY values */
#define PRIO_URGENT             ((long)  1)
#define PRIO_NORMAL             ((long)  0)
#define PRIO_NONURGENT          ((long) -1)

/* PR_SENSITIVITY values */
#define SENSITIVITY_NONE                    ((ULONG) 0x00000000)
#define SENSITIVITY_PERSONAL                ((ULONG) 0x00000001)
#define SENSITIVITY_PRIVATE                 ((ULONG) 0x00000002)
#define SENSITIVITY_COMPANY_CONFIDENTIAL    ((ULONG) 0x00000003)

/* PR_IMPORTANCE values */
#define IMPORTANCE_LOW          ((long) 0)
#define IMPORTANCE_NORMAL       ((long) 1)
#define IMPORTANCE_HIGH         ((long) 2)

#define MAPI_IMESSAGE_METHODS(IPURE)                                    \
    MAPIMETHOD(GetAttachmentTable)                                      \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(OpenAttach)                                              \
        (THIS_  ULONG                       ulAttachmentNum,            \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPATTACH FAR *              lppAttach) IPURE;           \
    MAPIMETHOD(CreateAttach)                                            \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulAttachmentNum,          \
                LPATTACH FAR *              lppAttach) IPURE;           \
    MAPIMETHOD(DeleteAttach)                                            \
        (THIS_  ULONG                       ulAttachmentNum,            \
                ULONG_PTR                   ulUIParam,                  \
                LPMAPIPROGRESS              lpProgress,                 \
                ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(GetRecipientTable)                                       \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(ModifyRecipients)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPADRLIST                   lpMods) IPURE;              \
    MAPIMETHOD(SubmitMessage)                                           \
        (THIS_  ULONG                       ulFlags) IPURE;             \
    MAPIMETHOD(SetReadFlag)                                             \
        (THIS_  ULONG                       ulFlags) IPURE;             \

#undef       INTERFACE
#define      INTERFACE  IMessage
DECLARE_MAPI_INTERFACE_(IMessage, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IMESSAGE_METHODS(PURE)
};

/* IAttach Interface ------------------------------------------------------- */

/* IAttach attachment methods: PR_ATTACH_METHOD values */

#define NO_ATTACHMENT           ((ULONG) 0x00000000)
#define ATTACH_BY_VALUE         ((ULONG) 0x00000001)
#define ATTACH_BY_REFERENCE     ((ULONG) 0x00000002)
#define ATTACH_BY_REF_RESOLVE   ((ULONG) 0x00000003)
#define ATTACH_BY_REF_ONLY      ((ULONG) 0x00000004)
#define ATTACH_EMBEDDED_MSG     ((ULONG) 0x00000005)
#define ATTACH_OLE              ((ULONG) 0x00000006)

#define MAPI_IATTACH_METHODS(IPURE)

#undef       INTERFACE
#define      INTERFACE  IAttach
DECLARE_MAPI_INTERFACE_(IAttach, IMAPIProp)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPIPROP_METHODS(PURE)
    MAPI_IATTACH_METHODS(PURE)
};

/* --------------------------------- */
/* Address Book interface definition */

/* ADRPARM ulFlags - top 4 bits used for versioning */

#define GET_ADRPARM_VERSION(ulFlags)  (((ULONG)ulFlags) & 0xF0000000)
#define SET_ADRPARM_VERSION(ulFlags, ulVersion)  (((ULONG)ulVersion) | (((ULONG)ulFlags) & 0x0FFFFFFF))

/*  Current versions of ADRPARM  */
#define ADRPARM_HELP_CTX        ((ULONG) 0x00000000)


/*  ulFlags   - bit fields */
#define DIALOG_MODAL            ((ULONG) 0x00000001)
#define DIALOG_SDI              ((ULONG) 0x00000002)
#define DIALOG_OPTIONS          ((ULONG) 0x00000004)
#define ADDRESS_ONE             ((ULONG) 0x00000008)
#define AB_SELECTONLY           ((ULONG) 0x00000010)
#define AB_RESOLVE              ((ULONG) 0x00000020)

/* --------------------------------- */
/*  PR_DISPLAY_TYPEs                 */
/*
 *  These standard display types are
 *  by default handled by MAPI.
 *  They have default icons associated
 *  with them.
 */

/*  For address book contents tables */
#define DT_MAILUSER         ((ULONG) 0x00000000)
#define DT_DISTLIST         ((ULONG) 0x00000001)
#define DT_FORUM            ((ULONG) 0x00000002)
#define DT_AGENT            ((ULONG) 0x00000003)
#define DT_ORGANIZATION     ((ULONG) 0x00000004)
#define DT_PRIVATE_DISTLIST ((ULONG) 0x00000005)
#define DT_REMOTE_MAILUSER  ((ULONG) 0x00000006)

/*  For address book hierarchy tables */
#define DT_MODIFIABLE       ((ULONG) 0x00010000)
#define DT_GLOBAL           ((ULONG) 0x00020000)
#define DT_LOCAL            ((ULONG) 0x00030000)
#define DT_WAN              ((ULONG) 0x00040000)
#define DT_NOT_SPECIFIC     ((ULONG) 0x00050000)

/*  For folder hierarchy tables */
#define DT_FOLDER           ((ULONG) 0x01000000)
#define DT_FOLDER_LINK      ((ULONG) 0x02000000)

/*  Accelerator callback for DIALOG_SDI form of AB UI */
typedef BOOL (STDMETHODCALLTYPE ACCELERATEABSDI)(ULONG_PTR ulUIParam,
                                                LPVOID lpvmsg);
typedef ACCELERATEABSDI FAR * LPFNABSDI;

/*  Callback to application telling it that the DIALOG_SDI form of the */
/*  AB UI has been dismissed.  This is so that the above LPFNABSDI     */
/*  function doesn't keep being called.                                */
typedef void (STDMETHODCALLTYPE DISMISSMODELESS)(ULONG_PTR ulUIParam,
                                                LPVOID lpvContext);
typedef DISMISSMODELESS FAR * LPFNDISMISS;

/*
 * Prototype for the client function hooked to an optional button on
 * the address book dialog
 */

typedef SCODE (STDMETHODCALLTYPE FAR * LPFNBUTTON)(
    ULONG_PTR           ulUIParam,
    LPVOID              lpvContext,
    ULONG               cbEntryID,
    LPENTRYID           lpSelection,
    ULONG               ulFlags
);


/* Parameters for the address book dialog */
typedef struct _ADRPARM
{
    ULONG           cbABContEntryID;
    LPENTRYID       lpABContEntryID;
    ULONG           ulFlags;

    LPVOID          lpReserved;
    ULONG           ulHelpContext;
    LPTSTR          lpszHelpFileName;

    LPFNABSDI       lpfnABSDI;
    LPFNDISMISS     lpfnDismiss;
    LPVOID          lpvDismissContext;
    LPTSTR          lpszCaption;
    LPTSTR          lpszNewEntryTitle;
    LPTSTR          lpszDestWellsTitle;
    ULONG           cDestFields;
    ULONG           nDestFieldFocus;
    LPTSTR FAR *    lppszDestTitles;
    ULONG FAR *     lpulDestComps;
    LPSRestriction  lpContRestriction;
    LPSRestriction  lpHierRestriction;
} ADRPARM, FAR * LPADRPARM;


/* ------------ */
/* Random flags */

/* Flag set in MAPI one off entryids */
#define MAPI_ONE_OFF_NO_RICH_INFO	0x0001

/* Flag for deferred error */
#define MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008)

/* Flag for creating and using Folder Associated Information Messages */
#define MAPI_ASSOCIATED         ((ULONG) 0x00000040)

/* Flags for OpenMessageStore() */

#define MDB_NO_DIALOG           ((ULONG) 0x00000001)
#define MDB_WRITE               ((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS    ((ULONG) 0x00000008) above */
/****** MAPI_BEST_ACCESS        ((ULONG) 0x00000010) above */
#define MDB_TEMPORARY           ((ULONG) 0x00000020)
#define MDB_NO_MAIL             ((ULONG) 0x00000080)

/* Flags for OpenAddressBook */

#define AB_NO_DIALOG            ((ULONG) 0x00000001)

/* IMAPIControl Interface -------------------------------------------------- */

/* Interface used in controls (particularly the button) defined by */
/* Display Tables. */

/*  Flags for GetState */

#define  MAPI_ENABLED       ((ULONG) 0x00000000)
#define  MAPI_DISABLED      ((ULONG) 0x00000001)

#define MAPI_IMAPICONTROL_METHODS(IPURE)                                \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(Activate)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG_PTR                   ulUIParam) IPURE;           \
    MAPIMETHOD(GetState)                                                \
        (THIS_  ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulState) IPURE;           \

#undef       INTERFACE
#define      INTERFACE  IMAPIControl
DECLARE_MAPI_INTERFACE_(IMAPIControl, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IMAPICONTROL_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPIControl, LPMAPICONTROL);

/* Display Tables ---------------------------------------------------------- */

/* Flags used in display tables - that is, PR_CONTROL_FLAGS */

#define DT_MULTILINE        ((ULONG) 0x00000001)
#define DT_EDITABLE         ((ULONG) 0x00000002)
#define DT_REQUIRED         ((ULONG) 0x00000004)
#define DT_SET_IMMEDIATE    ((ULONG) 0x00000008)
#define DT_PASSWORD_EDIT    ((ULONG) 0x00000010)
#define DT_ACCEPT_DBCS      ((ULONG) 0x00000020)
#define DT_SET_SELECTION    ((ULONG) 0x00000040)

/* Display Table structures */

#define DTCT_LABEL          ((ULONG) 0x00000000)
#define DTCT_EDIT           ((ULONG) 0x00000001)
#define DTCT_LBX            ((ULONG) 0x00000002)
#define DTCT_COMBOBOX       ((ULONG) 0x00000003)
#define DTCT_DDLBX          ((ULONG) 0x00000004)
#define DTCT_CHECKBOX       ((ULONG) 0x00000005)
#define DTCT_GROUPBOX       ((ULONG) 0x00000006)
#define DTCT_BUTTON         ((ULONG) 0x00000007)
#define DTCT_PAGE           ((ULONG) 0x00000008)
#define DTCT_RADIOBUTTON    ((ULONG) 0x00000009)
#define DTCT_MVLISTBOX      ((ULONG) 0x0000000B)
#define DTCT_MVDDLBX        ((ULONG) 0x0000000C)

/* Labels */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLLABEL
{
    ULONG ulbLpszLabelName;
    ULONG ulFlags;
} DTBLLABEL, FAR * LPDTBLLABEL;
#define SizedDtblLabel(n,u) \
struct _DTBLLABEL_ ## u \
{ \
    DTBLLABEL   dtbllabel; \
    TCHAR       lpszLabelName[n]; \
} u


/*  Simple Text Edits  */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLEDIT
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPropTag;
} DTBLEDIT, FAR * LPDTBLEDIT;
#define SizedDtblEdit(n,u) \
struct _DTBLEDIT_ ## u \
{ \
    DTBLEDIT    dtbledit; \
    TCHAR       lpszCharsAllowed[n]; \
} u

/*  List Box  */
/* Valid ulFlags:
 */
#define MAPI_NO_HBAR        ((ULONG) 0x00000001)
#define MAPI_NO_VBAR        ((ULONG) 0x00000002)

typedef struct _DTBLLBX
{
    ULONG ulFlags;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
} DTBLLBX, FAR * LPDTBLLBX;


/*  Combo Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCOMBOBOX
{
    ULONG ulbLpszCharsAllowed;
    ULONG ulFlags;
    ULONG ulNumCharsAllowed;
    ULONG ulPRPropertyName;
    ULONG ulPRTableName;
} DTBLCOMBOBOX, FAR * LPDTBLCOMBOBOX;
#define SizedDtblComboBox(n,u) \
struct _DTBLCOMBOBOX_ ## u \
{ \
    DTBLCOMBOBOX    dtblcombobox; \
    TCHAR           lpszCharsAllowed[n]; \
} u


/*  Drop Down   */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLDDLBX
{
    ULONG ulFlags;
    ULONG ulPRDisplayProperty;
    ULONG ulPRSetProperty;
    ULONG ulPRTableName;
} DTBLDDLBX, FAR * LPDTBLDDLBX;


/*  Check Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCHECKBOX
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRPropertyName;
} DTBLCHECKBOX, FAR * LPDTBLCHECKBOX;
#define SizedDtblCheckBox(n,u) \
struct _DTBLCHECKBOX_ ## u \
{ \
    DTBLCHECKBOX    dtblcheckbox; \
    TCHAR       lpszLabel[n]; \
} u



/*  Group Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLGROUPBOX
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
} DTBLGROUPBOX, FAR * LPDTBLGROUPBOX;
#define SizedDtblGroupBox(n,u) \
struct _DTBLGROUPBOX_ ## u \
{ \
    DTBLGROUPBOX    dtblgroupbox; \
    TCHAR           lpszLabel[n]; \
} u

/*  Button control   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLBUTTON
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulPRControl;
} DTBLBUTTON, FAR * LPDTBLBUTTON;
#define SizedDtblButton(n,u) \
struct _DTBLBUTTON_ ## u \
{ \
    DTBLBUTTON  dtblbutton; \
    TCHAR       lpszLabel[n]; \
} u

/*  Pages   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLPAGE
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulbLpszComponent;
    ULONG ulContext;
} DTBLPAGE, FAR * LPDTBLPAGE;
#define SizedDtblPage(n,n1,u) \
struct _DTBLPAGE_ ## u \
{ \
    DTBLPAGE    dtblpage; \
    TCHAR       lpszLabel[n]; \
    TCHAR       lpszComponent[n1]; \
} u

/*  Radio button   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLRADIOBUTTON
{
    ULONG ulbLpszLabel;
    ULONG ulFlags;
    ULONG ulcButtons;
    ULONG ulPropTag;
    long lReturnValue;
} DTBLRADIOBUTTON, FAR * LPDTBLRADIOBUTTON;
#define SizedDtblRadioButton(n,u) \
struct _DTBLRADIOBUTTON_ ## u \
{ \
    DTBLRADIOBUTTON dtblradiobutton; \
    TCHAR           lpszLabel[n]; \
} u


/*  MultiValued listbox */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVLISTBOX
{
    ULONG ulFlags;
    ULONG ulMVPropTag;
} DTBLMVLISTBOX, FAR * LPDTBLMVLISTBOX;


/*  MultiValued dropdown */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVDDLBX
{
    ULONG ulFlags;
    ULONG ulMVPropTag;
} DTBLMVDDLBX, FAR * LPDTBLMVDDLBX;





/* IProviderAdmin Interface ---------------------------------------------- */

/* Flags for ConfigureMsgService */

#define UI_SERVICE                  0x00000002
#define SERVICE_UI_ALWAYS           0x00000002      /* Duplicate UI_SERVICE for consistency and compatibility */
#define SERVICE_UI_ALLOWED          0x00000010
#define UI_CURRENT_PROVIDER_FIRST   0x00000004
/* MSG_SERVICE_UI_READ_ONLY         0x00000008 - in MAPISPI.H */

/* GetProviderTable() */
/****** MAPI_UNICODE            ((ULONG) 0x80000000) above */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define MAPI_IPROVIDERADMIN_METHODS(IPURE)                              \
    MAPIMETHOD(GetLastError)                                            \
        (THIS_  HRESULT                     hResult,                    \
                ULONG                       ulFlags,                    \
                LPMAPIERROR FAR *           lppMAPIError) IPURE;        \
    MAPIMETHOD(GetProviderTable)                                        \
        (THIS_  ULONG                       ulFlags,                    \
                LPMAPITABLE FAR *           lppTable) IPURE;            \
    MAPIMETHOD(CreateProvider)                                          \
        (THIS_  LPTSTR                      lpszProvider,               \
                ULONG                       cValues,                    \
                LPSPropValue                lpProps,                    \
                ULONG_PTR                   ulUIParam,                  \
                ULONG                       ulFlags,                    \
                MAPIUID FAR *               lpUID) IPURE;               \
    MAPIMETHOD(DeleteProvider)                                          \
        (THIS_  LPMAPIUID                   lpUID) IPURE;               \
    MAPIMETHOD(OpenProfileSection)                                      \
        (THIS_  LPMAPIUID                   lpUID,                      \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                LPPROFSECT FAR *            lppProfSect) IPURE;         \


#undef       INTERFACE
#define      INTERFACE  IProviderAdmin
DECLARE_MAPI_INTERFACE_(IProviderAdmin, IUnknown)
{
    BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IPROVIDERADMIN_METHODS(PURE)
};

#ifndef WIN16

typedef HANDLE  HANDLE_16;
typedef WPARAM  WPARAM_16;

#define EXTERN_C_16
#define WINAPI_16
#define CALLBACK_16
#define EXPORT_16
#define LOADDS_16
#define HUGEP_16
#define APIENTRY_16    APIENTRY

#else   // ndef WIN16

typedef LPVOID HANDLE_16;
typedef DWORD  WPARAM_16;

#define EXTERN_C_16    EXTERN_C
#define WINAPI_16      WINAPI
#define CALLBACK_16    CALLBACK
#define EXPORT_16      __export
#define LOADDS_16      __loadds
#define HUGEP_16       HUGEP
#define APIENTRY_16    CALLBACK

#endif  // ndef WIN16

#ifndef WIN16

#define IF_WIN16(x)
#define IF_NOT_WIN16(x)     x
#define IF_WIN32(x)         x

#else   // ndef WIN16

#define IF_WIN16(x)         x
#define IF_NOT_WIN16(x)
#define IF_WIN32(x)

#endif  // ndef WIN16

#ifdef  __cplusplus
}       /*  extern "C" */
#endif

#endif /* WABDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\public\inc\wabiab.h ===
/* IAddrBook Interface ----------------------------------------------------- */

/*  CreateOneOff */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO		((ULONG) 0x00010000) */

/*  RecipOptions */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  QueryDefaultRecipOpt */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  GetSearchPath */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */


#ifndef WABIAB_H
#define WABIAB_H

// These are WAB only flags for IAdrBook::ResolveName
//      MAPI_UNICODE                        ((ULONG) 0x80000000)
#define WAB_RESOLVE_LOCAL_ONLY              ((ULONG) 0x80000000) 
#define WAB_RESOLVE_ALL_EMAILS              ((ULONG) 0x40000000)
#define WAB_RESOLVE_NO_ONE_OFFS             ((ULONG) 0x20000000)
#define WAB_RESOLVE_NEED_CERT               ((ULONG) 0x10000000)
#define WAB_RESOLVE_NO_NOT_FOUND_UI         ((ULONG) 0x08000000)
#define WAB_RESOLVE_USE_CURRENT_PROFILE     ((ULONG) 0x04000000)
#define WAB_RESOLVE_FIRST_MATCH             ((ULONG) 0x02000000)
#define WAB_RESOLVE_UNICODE                 ((ULONG) 0x01000000)
//      MAPI_DIALOG                         ((ULONG) 0x00000008)

#ifndef MAPIX_H

#define MAPI_IADDRBOOK_METHODS(IPURE)									\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;	\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(CreateOneOff)											\
		(THIS_	LPTSTR						lpszName,					\
				LPTSTR						lpszAdrType,				\
				LPTSTR						lpszAddress,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(NewEntry)												\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cbEIDContainer,				\
				LPENTRYID					lpEIDContainer,				\
				ULONG						cbEIDNewEntryTpl,			\
				LPENTRYID					lpEIDNewEntryTpl,			\
				ULONG FAR *					lpcbEIDNewEntry,			\
				LPENTRYID FAR *				lppEIDNewEntry) IPURE;		\
	MAPIMETHOD(ResolveName)												\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				LPTSTR						lpszNewEntryTitle,			\
				LPADRLIST					lpAdrList) IPURE;			\
	MAPIMETHOD(Address)													\
		(THIS_	ULONG_PTR FAR *				lpulUIParam,				\
				LPADRPARM					lpAdrParms,					\
				LPADRLIST FAR *				lppAdrList) IPURE;			\
	MAPIMETHOD(Details)													\
		(THIS_	ULONG_PTR FAR *				lpulUIParam,				\
				LPFNDISMISS					lpfnDismiss,				\
				LPVOID						lpvDismissContext,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPFNBUTTON					lpfButtonCallback,			\
				LPVOID						lpvButtonContext,			\
				LPTSTR						lpszButtonText,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RecipOptions)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				LPADRENTRY					lpRecip) IPURE;				\
	MAPIMETHOD(QueryDefaultRecipOpt)									\
		(THIS_	LPTSTR						lpszAdrType,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(GetPAB)													\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetPAB)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetDefaultDir)											\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetDefaultDir)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet FAR *				lppSearchPath) IPURE;		\
	MAPIMETHOD(SetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSearchPath) IPURE;		\
	MAPIMETHOD(PrepareRecips)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray				lpPropTagArray,				\
				LPADRLIST					lpRecipList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IAddrBook
DECLARE_MAPI_INTERFACE_(IAddrBook, IMAPIProp)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IADDRBOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IAddrBook, LPADRBOOK);
#endif  // MAPIX_H
#endif  // WABIAB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\public\inc\wabmem.h ===
#if !defined(WABMEM_H)
#define WABMEM_H

#if !defined(MAPIX_H)
typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEBUFFER)(
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEMORE)(
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE MAPIFREEBUFFER)(
	LPVOID			lpBuffer
);

typedef MAPIALLOCATEBUFFER FAR	*LPMAPIALLOCATEBUFFER;
typedef MAPIALLOCATEMORE FAR	*LPMAPIALLOCATEMORE;
typedef MAPIFREEBUFFER FAR 		*LPMAPIFREEBUFFER;

#endif  // MAPIX_H

typedef SCODE (STDMETHODCALLTYPE WABALLOCATEBUFFER)(
   LPWABOBJECT     lpWABObject,
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE WABALLOCATEMORE)(
   LPWABOBJECT     lpWABObject,
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE WABFREEBUFFER)(
   LPWABOBJECT     lpWABObject,
	LPVOID			lpBuffer
);

typedef WABALLOCATEBUFFER FAR	*LPWABALLOCATEBUFFER;
typedef WABALLOCATEMORE FAR	*LPWABALLOCATEMORE;
typedef WABFREEBUFFER FAR 		*LPWABFREEBUFFER;
#endif  // WABMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\public\inc\wabtags.h ===
/*
 *  WABTAGS.H
 *
 *  Property tag definitions for standard properties of WAB
 *  objects.
 *
 *  The following ranges should be used for all property IDs. Note that
 *  property IDs for objects other than messages and recipients should
 *  all fall in the range 0x3000 to 0x3FFF:
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  0001    0BFF    MAPI_defined envelope property
 *  0C00    0DFF    MAPI_defined per-recipient property
 *  0E00    0FFF    MAPI_defined non-transmittable property
 *  1000    2FFF    MAPI_defined message content property
 *
 *  3000    3FFF    MAPI_defined property (usually not message or recipient)
 *
 *  4000    57FF    Transport-defined envelope property
 *  5800    5FFF    Transport-defined per-recipient property
 *  6000    65FF    User-defined non-transmittable property
 *  6600    67FF    Provider-defined internal non-transmittable property
 *  6800    7BFF    Message class-defined content property
 *  7C00    7FFF    Message class-defined non-transmittable
 *                  property
 *
 *  8000    FFFE    User-defined Name-to-id mapped property
 *
 *  The 3000-3FFF range is further subdivided as follows:
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    33FF    Common property such as display name, entry ID
 *  3400    35FF    Message store object
 *  3600    36FF    Folder or AB container
 *  3700    38FF    Attachment
 *  3900    39FF    Address book object
 *  3A00    3BFF    Mail user
 *  3C00    3CFF    Distribution list
 *  3D00    3DFF    Profile section
 *  3E00    3FFF    Status object
 *
 *  Copyright 1993-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(MAPITAGS_H) && !defined(WABTAGS_H)
#define WABTAGS_H

/* Determine if a property is transmittable. */

#define FIsTransmittable(ulPropTag) \
    ((PROP_ID (ulPropTag) <  (ULONG)0x0E00) || \
    (PROP_ID (ulPropTag)  >= (ULONG)0x8000) || \
    ((PROP_ID (ulPropTag) >= (ULONG)0x1000) && (PROP_ID (ulPropTag) < (ULONG)0x6000)) || \
    ((PROP_ID (ulPropTag) >= (ULONG)0x6800) && (PROP_ID (ulPropTag) < (ULONG)0x7C00)))


/*
 * The range of non-message and non-recipient property IDs (0x3000 - 0x3FFF) is
 * further broken down into ranges to make assigning new property IDs easier.
 *
 *  From    To      Kind of property
 *  --------------------------------
 *  3000    32FF    MAPI_defined common property
 *  3200    33FF    MAPI_defined form property
 *  3400    35FF    MAPI_defined message store property
 *  3600    36FF    MAPI_defined Folder or AB Container property
 *  3700    38FF    MAPI_defined attachment property
 *  3900    39FF    MAPI_defined address book property
 *  3A00    3BFF    MAPI_defined mailuser property
 *  3C00    3CFF    MAPI_defined DistList property
 *  3D00    3DFF    MAPI_defined Profile Section property
 *  3E00    3EFF    MAPI_defined Status property
 *  3F00    3FFF    MAPI_defined display table property
 */

/*
 *  Properties common to numerous MAPI objects.
 *
 *  Those properties that can appear on messages are in the
 *  non-transmittable range for messages. They start at the high
 *  end of that range and work down.
 *
 *  Properties that never appear on messages are defined in the common
 *  property range (see above).
 */

/*
 * properties that are common to multiple objects (including message objects)
 * -- these ids are in the non-transmittable range
 */

#define PR_ENTRYID                                  PROP_TAG( PT_BINARY,    0x0FFF)
#define PR_OBJECT_TYPE                              PROP_TAG( PT_LONG,      0x0FFE)
#define PR_ICON                                     PROP_TAG( PT_BINARY,    0x0FFD)
#define PR_MINI_ICON                                PROP_TAG( PT_BINARY,    0x0FFC)
#define PR_STORE_ENTRYID                            PROP_TAG( PT_BINARY,    0x0FFB)
#define PR_STORE_RECORD_KEY                         PROP_TAG( PT_BINARY,    0x0FFA)
#define PR_RECORD_KEY                               PROP_TAG( PT_BINARY,    0x0FF9)
#define PR_MAPPING_SIGNATURE                        PROP_TAG( PT_BINARY,    0x0FF8)
#define PR_ACCESS_LEVEL                             PROP_TAG( PT_LONG,      0x0FF7)
#define PR_INSTANCE_KEY                             PROP_TAG( PT_BINARY,    0x0FF6)
#define PR_ROW_TYPE                                 PROP_TAG( PT_LONG,      0x0FF5)
#define PR_ACCESS                                   PROP_TAG( PT_LONG,      0x0FF4)

/*
 * properties that are common to multiple objects (usually not including message objects)
 * -- these ids are in the transmittable range
 */

#define PR_ROWID                                    PROP_TAG( PT_LONG,      0x3000)
#define PR_DISPLAY_NAME                             PROP_TAG( PT_TSTRING,   0x3001)
#define PR_DISPLAY_NAME_W                           PROP_TAG( PT_UNICODE,   0x3001)
#define PR_DISPLAY_NAME_A                           PROP_TAG( PT_STRING8,   0x3001)
#define PR_ADDRTYPE                                 PROP_TAG( PT_TSTRING,   0x3002)
#define PR_ADDRTYPE_W                               PROP_TAG( PT_UNICODE,   0x3002)
#define PR_ADDRTYPE_A                               PROP_TAG( PT_STRING8,   0x3002)
#define PR_EMAIL_ADDRESS                            PROP_TAG( PT_TSTRING,   0x3003)
#define PR_EMAIL_ADDRESS_W                          PROP_TAG( PT_UNICODE,   0x3003)
#define PR_EMAIL_ADDRESS_A                          PROP_TAG( PT_STRING8,   0x3003)
#define PR_COMMENT                                  PROP_TAG( PT_TSTRING,   0x3004)
#define PR_COMMENT_W                                PROP_TAG( PT_UNICODE,   0x3004)
#define PR_COMMENT_A                                PROP_TAG( PT_STRING8,   0x3004)
#define PR_DEPTH                                    PROP_TAG( PT_LONG,      0x3005)
#define PR_PROVIDER_DISPLAY                         PROP_TAG( PT_TSTRING,   0x3006)
#define PR_PROVIDER_DISPLAY_W                       PROP_TAG( PT_UNICODE,   0x3006)
#define PR_PROVIDER_DISPLAY_A                       PROP_TAG( PT_STRING8,   0x3006)
#define PR_CREATION_TIME                            PROP_TAG( PT_SYSTIME,   0x3007)
#define PR_LAST_MODIFICATION_TIME                   PROP_TAG( PT_SYSTIME,   0x3008)
#define PR_RESOURCE_FLAGS                           PROP_TAG( PT_LONG,      0x3009)
#define PR_PROVIDER_DLL_NAME                        PROP_TAG( PT_TSTRING,   0x300A)
#define PR_PROVIDER_DLL_NAME_W                      PROP_TAG( PT_UNICODE,   0x300A)
#define PR_PROVIDER_DLL_NAME_A                      PROP_TAG( PT_STRING8,   0x300A)
#define PR_SEARCH_KEY                               PROP_TAG( PT_BINARY,    0x300B)
#define PR_PROVIDER_UID                             PROP_TAG( PT_BINARY,    0x300C)
#define PR_PROVIDER_ORDINAL                         PROP_TAG( PT_LONG,      0x300D)


/* Proptags 35E8-35FF reserved for folders "guaranteed" by PR_VALID_FOLDER_MASK */


/*
 *  Folder and AB Container properties
 */

#define PR_CONTAINER_FLAGS                          PROP_TAG( PT_LONG,      0x3600)
#define PR_FOLDER_TYPE                              PROP_TAG( PT_LONG,      0x3601)
#define PR_CONTENT_COUNT                            PROP_TAG( PT_LONG,      0x3602)
#define PR_CONTENT_UNREAD                           PROP_TAG( PT_LONG,      0x3603)
#define PR_CREATE_TEMPLATES                         PROP_TAG( PT_OBJECT,    0x3604)
#define PR_DETAILS_TABLE                            PROP_TAG( PT_OBJECT,    0x3605)
#define PR_SEARCH                                   PROP_TAG( PT_OBJECT,    0x3607)
#define PR_SELECTABLE                               PROP_TAG( PT_BOOLEAN,   0x3609)
#define PR_SUBFOLDERS                               PROP_TAG( PT_BOOLEAN,   0x360a)
#define PR_STATUS                                   PROP_TAG( PT_LONG,      0x360b)
#define PR_ANR                                      PROP_TAG( PT_TSTRING,   0x360c)
#define PR_ANR_W                                    PROP_TAG( PT_UNICODE,   0x360c)
#define PR_ANR_A                                    PROP_TAG( PT_STRING8,   0x360c)
#define PR_CONTENTS_SORT_ORDER                      PROP_TAG( PT_MV_LONG,   0x360d)
#define PR_CONTAINER_HIERARCHY                      PROP_TAG( PT_OBJECT,    0x360e)
#define PR_CONTAINER_CONTENTS                       PROP_TAG( PT_OBJECT,    0x360f)
#define PR_FOLDER_ASSOCIATED_CONTENTS               PROP_TAG( PT_OBJECT,    0x3610)
#define PR_DEF_CREATE_DL                            PROP_TAG( PT_BINARY,    0x3611)
#define PR_DEF_CREATE_MAILUSER                      PROP_TAG( PT_BINARY,    0x3612)
#define PR_CONTAINER_CLASS                          PROP_TAG( PT_TSTRING,   0x3613)
#define PR_CONTAINER_CLASS_W                        PROP_TAG( PT_UNICODE,   0x3613)
#define PR_CONTAINER_CLASS_A                        PROP_TAG( PT_STRING8,   0x3613)
#define PR_CONTAINER_MODIFY_VERSION                 PROP_TAG( PT_I8,        0x3614)
#define PR_AB_PROVIDER_ID                           PROP_TAG( PT_BINARY,    0x3615)
#define PR_DEFAULT_VIEW_ENTRYID                     PROP_TAG( PT_BINARY,    0x3616)
#define PR_ASSOC_CONTENT_COUNT                      PROP_TAG( PT_LONG,      0x3617)
/* Don't use 36FE and 36FF */


/*
 *  AB Object properties
 */

#define PR_DISPLAY_TYPE                             PROP_TAG( PT_LONG,      0x3900)
#define PR_TEMPLATEID                               PROP_TAG( PT_BINARY,    0x3902)
#define PR_PRIMARY_CAPABILITY                       PROP_TAG( PT_BINARY,    0x3904)
#define PR_7BIT_DISPLAY_NAME                        PROP_TAG( PT_STRING8,   0x39FF)

/*
 *  Mail user properties
 */

#define PR_ACCOUNT                                  PROP_TAG( PT_TSTRING,   0x3A00)
#define PR_ACCOUNT_W                                PROP_TAG( PT_UNICODE,   0x3A00)
#define PR_ACCOUNT_A                                PROP_TAG( PT_STRING8,   0x3A00)
#define PR_ALTERNATE_RECIPIENT                      PROP_TAG( PT_BINARY,    0x3A01)
#define PR_CALLBACK_TELEPHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A02)
#define PR_CONVERSION_PROHIBITED                    PROP_TAG( PT_BOOLEAN,   0x3A03)
#define PR_DISCLOSE_RECIPIENTS                      PROP_TAG( PT_BOOLEAN,   0x3A04)
#define PR_GENERATION                               PROP_TAG( PT_TSTRING,   0x3A05)
#define PR_GENERATION_W                             PROP_TAG( PT_UNICODE,   0x3A05)
#define PR_GENERATION_A                             PROP_TAG( PT_STRING8,   0x3A05)
#define PR_GIVEN_NAME                               PROP_TAG( PT_TSTRING,   0x3A06)
#define PR_GIVEN_NAME_W                             PROP_TAG( PT_UNICODE,   0x3A06)
#define PR_GIVEN_NAME_A                             PROP_TAG( PT_STRING8,   0x3A06)
#define PR_GOVERNMENT_ID_NUMBER                     PROP_TAG( PT_TSTRING,   0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_W                   PROP_TAG( PT_UNICODE,   0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_A                   PROP_TAG( PT_STRING8,   0x3A07)
#define PR_BUSINESS_TELEPHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A08)
#define PR_OFFICE_TELEPHONE_NUMBER                  PR_BUSINESS_TELEPHONE_NUMBER
#define PR_OFFICE_TELEPHONE_NUMBER_W                PR_BUSINESS_TELEPHONE_NUMBER_W
#define PR_OFFICE_TELEPHONE_NUMBER_A                PR_BUSINESS_TELEPHONE_NUMBER_A
#define PR_HOME_TELEPHONE_NUMBER                    PROP_TAG( PT_TSTRING,   0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_W                  PROP_TAG( PT_UNICODE,   0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_A                  PROP_TAG( PT_STRING8,   0x3A09)
#define PR_INITIALS                                 PROP_TAG( PT_TSTRING,   0x3A0A)
#define PR_INITIALS_W                               PROP_TAG( PT_UNICODE,   0x3A0A)
#define PR_INITIALS_A                               PROP_TAG( PT_STRING8,   0x3A0A)
#define PR_KEYWORD                                  PROP_TAG( PT_TSTRING,   0x3A0B)
#define PR_KEYWORD_W                                PROP_TAG( PT_UNICODE,   0x3A0B)
#define PR_KEYWORD_A                                PROP_TAG( PT_STRING8,   0x3A0B)
#define PR_LANGUAGE                                 PROP_TAG( PT_TSTRING,   0x3A0C)
#define PR_LANGUAGE_W                               PROP_TAG( PT_UNICODE,   0x3A0C)
#define PR_LANGUAGE_A                               PROP_TAG( PT_STRING8,   0x3A0C)
#define PR_LOCATION                                 PROP_TAG( PT_TSTRING,   0x3A0D)
#define PR_LOCATION_W                               PROP_TAG( PT_UNICODE,   0x3A0D)
#define PR_LOCATION_A                               PROP_TAG( PT_STRING8,   0x3A0D)
#define PR_MAIL_PERMISSION                          PROP_TAG( PT_BOOLEAN,   0x3A0E)
#define PR_MHS_COMMON_NAME                          PROP_TAG( PT_TSTRING,   0x3A0F)
#define PR_MHS_COMMON_NAME_W                        PROP_TAG( PT_UNICODE,   0x3A0F)
#define PR_MHS_COMMON_NAME_A                        PROP_TAG( PT_STRING8,   0x3A0F)
#define PR_ORGANIZATIONAL_ID_NUMBER                 PROP_TAG( PT_TSTRING,   0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_A               PROP_TAG( PT_STRING8,   0x3A10)
#define PR_SURNAME                                  PROP_TAG( PT_TSTRING,   0x3A11)
#define PR_SURNAME_W                                PROP_TAG( PT_UNICODE,   0x3A11)
#define PR_SURNAME_A                                PROP_TAG( PT_STRING8,   0x3A11)
#define PR_ORIGINAL_ENTRYID                         PROP_TAG( PT_BINARY,    0x3A12)
#define PR_ORIGINAL_DISPLAY_NAME                    PROP_TAG( PT_TSTRING,   0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_W                  PROP_TAG( PT_UNICODE,   0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_A                  PROP_TAG( PT_STRING8,   0x3A13)
#define PR_ORIGINAL_SEARCH_KEY                      PROP_TAG( PT_BINARY,    0x3A14)
#define PR_POSTAL_ADDRESS                           PROP_TAG( PT_TSTRING,   0x3A15)
#define PR_POSTAL_ADDRESS_W                         PROP_TAG( PT_UNICODE,   0x3A15)
#define PR_POSTAL_ADDRESS_A                         PROP_TAG( PT_STRING8,   0x3A15)
#define PR_COMPANY_NAME                             PROP_TAG( PT_TSTRING,   0x3A16)
#define PR_COMPANY_NAME_W                           PROP_TAG( PT_UNICODE,   0x3A16)
#define PR_COMPANY_NAME_A                           PROP_TAG( PT_STRING8,   0x3A16)
#define PR_TITLE                                    PROP_TAG( PT_TSTRING,   0x3A17)
#define PR_TITLE_W                                  PROP_TAG( PT_UNICODE,   0x3A17)
#define PR_TITLE_A                                  PROP_TAG( PT_STRING8,   0x3A17)
#define PR_DEPARTMENT_NAME                          PROP_TAG( PT_TSTRING,   0x3A18)
#define PR_DEPARTMENT_NAME_W                        PROP_TAG( PT_UNICODE,   0x3A18)
#define PR_DEPARTMENT_NAME_A                        PROP_TAG( PT_STRING8,   0x3A18)
#define PR_OFFICE_LOCATION                          PROP_TAG( PT_TSTRING,   0x3A19)
#define PR_OFFICE_LOCATION_W                        PROP_TAG( PT_UNICODE,   0x3A19)
#define PR_OFFICE_LOCATION_A                        PROP_TAG( PT_STRING8,   0x3A19)
#define PR_PRIMARY_TELEPHONE_NUMBER                 PROP_TAG( PT_TSTRING,   0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_W               PROP_TAG( PT_UNICODE,   0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_A               PROP_TAG( PT_STRING8,   0x3A1A)
#define PR_BUSINESS2_TELEPHONE_NUMBER               PROP_TAG( PT_TSTRING,   0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_A             PROP_TAG( PT_STRING8,   0x3A1B)
#define PR_OFFICE2_TELEPHONE_NUMBER                 PR_BUSINESS2_TELEPHONE_NUMBER
#define PR_OFFICE2_TELEPHONE_NUMBER_W               PR_BUSINESS2_TELEPHONE_NUMBER_W
#define PR_OFFICE2_TELEPHONE_NUMBER_A               PR_BUSINESS2_TELEPHONE_NUMBER_A
#define PR_MOBILE_TELEPHONE_NUMBER                  PROP_TAG( PT_TSTRING,   0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_W                PROP_TAG( PT_UNICODE,   0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_A                PROP_TAG( PT_STRING8,   0x3A1C)
#define PR_CELLULAR_TELEPHONE_NUMBER                PR_MOBILE_TELEPHONE_NUMBER
#define PR_CELLULAR_TELEPHONE_NUMBER_W              PR_MOBILE_TELEPHONE_NUMBER_W
#define PR_CELLULAR_TELEPHONE_NUMBER_A              PR_MOBILE_TELEPHONE_NUMBER_A
#define PR_RADIO_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A1D)
#define PR_CAR_TELEPHONE_NUMBER                     PROP_TAG( PT_TSTRING,   0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_W                   PROP_TAG( PT_UNICODE,   0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_A                   PROP_TAG( PT_STRING8,   0x3A1E)
#define PR_OTHER_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A1F)
#define PR_TRANSMITABLE_DISPLAY_NAME                PROP_TAG( PT_TSTRING,   0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_W              PROP_TAG( PT_UNICODE,   0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_A              PROP_TAG( PT_STRING8,   0x3A20)
#define PR_PAGER_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A21)
#define PR_BEEPER_TELEPHONE_NUMBER                  PR_PAGER_TELEPHONE_NUMBER
#define PR_BEEPER_TELEPHONE_NUMBER_W                PR_PAGER_TELEPHONE_NUMBER_W
#define PR_BEEPER_TELEPHONE_NUMBER_A                PR_PAGER_TELEPHONE_NUMBER_A
#define PR_USER_CERTIFICATE                         PROP_TAG( PT_BINARY,    0x3A22)
#define PR_PRIMARY_FAX_NUMBER                       PROP_TAG( PT_TSTRING,   0x3A23)
#define PR_PRIMARY_FAX_NUMBER_W                     PROP_TAG( PT_UNICODE,   0x3A23)
#define PR_PRIMARY_FAX_NUMBER_A                     PROP_TAG( PT_STRING8,   0x3A23)
#define PR_BUSINESS_FAX_NUMBER                      PROP_TAG( PT_TSTRING,   0x3A24)
#define PR_BUSINESS_FAX_NUMBER_W                    PROP_TAG( PT_UNICODE,   0x3A24)
#define PR_BUSINESS_FAX_NUMBER_A                    PROP_TAG( PT_STRING8,   0x3A24)
#define PR_HOME_FAX_NUMBER                          PROP_TAG( PT_TSTRING,   0x3A25)
#define PR_HOME_FAX_NUMBER_W                        PROP_TAG( PT_UNICODE,   0x3A25)
#define PR_HOME_FAX_NUMBER_A                        PROP_TAG( PT_STRING8,   0x3A25)
#define PR_COUNTRY                                  PROP_TAG( PT_TSTRING,   0x3A26)
#define PR_COUNTRY_W                                PROP_TAG( PT_UNICODE,   0x3A26)
#define PR_COUNTRY_A                                PROP_TAG( PT_STRING8,   0x3A26)
#define PR_LOCALITY                                 PROP_TAG( PT_TSTRING,   0x3A27)
#define PR_LOCALITY_W                               PROP_TAG( PT_UNICODE,   0x3A27)
#define PR_LOCALITY_A                               PROP_TAG( PT_STRING8,   0x3A27)
#define PR_STATE_OR_PROVINCE                        PROP_TAG( PT_TSTRING,   0x3A28)
#define PR_STATE_OR_PROVINCE_W                      PROP_TAG( PT_UNICODE,   0x3A28)
#define PR_STATE_OR_PROVINCE_A                      PROP_TAG( PT_STRING8,   0x3A28)
#define PR_STREET_ADDRESS                           PROP_TAG( PT_TSTRING,   0x3A29)
#define PR_STREET_ADDRESS_W                         PROP_TAG( PT_UNICODE,   0x3A29)
#define PR_STREET_ADDRESS_A                         PROP_TAG( PT_STRING8,   0x3A29)
#define PR_POSTAL_CODE                              PROP_TAG( PT_TSTRING,   0x3A2A)
#define PR_POSTAL_CODE_W                            PROP_TAG( PT_UNICODE,   0x3A2A)
#define PR_POSTAL_CODE_A                            PROP_TAG( PT_STRING8,   0x3A2A)
#define PR_POST_OFFICE_BOX                          PROP_TAG( PT_TSTRING,   0x3A2B)
#define PR_POST_OFFICE_BOX_W                        PROP_TAG( PT_UNICODE,   0x3A2B)
#define PR_POST_OFFICE_BOX_A                        PROP_TAG( PT_STRING8,   0x3A2B)
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX         PR_POST_OFFICE_BOX
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_W       PR_POST_OFFICE_BOX_W
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_A       PR_POST_OFFICE_BOX_A
#define PR_TELEX_NUMBER                             PROP_TAG( PT_TSTRING,   0x3A2C)
#define PR_TELEX_NUMBER_W                           PROP_TAG( PT_UNICODE,   0x3A2C)
#define PR_TELEX_NUMBER_A                           PROP_TAG( PT_STRING8,   0x3A2C)
#define PR_ISDN_NUMBER                              PROP_TAG( PT_TSTRING,   0x3A2D)
#define PR_ISDN_NUMBER_W                            PROP_TAG( PT_UNICODE,   0x3A2D)
#define PR_ISDN_NUMBER_A                            PROP_TAG( PT_STRING8,   0x3A2D)
#define PR_ASSISTANT_TELEPHONE_NUMBER               PROP_TAG( PT_TSTRING,   0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_W             PROP_TAG( PT_UNICODE,   0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_A             PROP_TAG( PT_STRING8,   0x3A2E)
#define PR_HOME2_TELEPHONE_NUMBER                   PROP_TAG( PT_TSTRING,   0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_W                 PROP_TAG( PT_UNICODE,   0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_A                 PROP_TAG( PT_STRING8,   0x3A2F)
#define PR_ASSISTANT                                PROP_TAG( PT_TSTRING,   0x3A30)
#define PR_ASSISTANT_W                              PROP_TAG( PT_UNICODE,   0x3A30)
#define PR_ASSISTANT_A                              PROP_TAG( PT_STRING8,   0x3A30)
#define PR_SEND_RICH_INFO                           PROP_TAG( PT_BOOLEAN,   0x3A40)
#define PR_WEDDING_ANNIVERSARY                      PROP_TAG( PT_SYSTIME,   0x3A41)
#define PR_BIRTHDAY                                 PROP_TAG( PT_SYSTIME,   0x3A42)
#define PR_HOBBIES                                  PROP_TAG( PT_TSTRING,   0x3A43)
#define PR_HOBBIES_W                                PROP_TAG( PT_UNICODE,   0x3A43)
#define PR_HOBBIES_A                                PROP_TAG( PT_STRING8,   0x3A43)
#define PR_MIDDLE_NAME                              PROP_TAG( PT_TSTRING,   0x3A44)
#define PR_MIDDLE_NAME_W                            PROP_TAG( PT_UNICODE,   0x3A44)
#define PR_MIDDLE_NAME_A                            PROP_TAG( PT_STRING8,   0x3A44)
#define PR_DISPLAY_NAME_PREFIX                      PROP_TAG( PT_TSTRING,   0x3A45)
#define PR_DISPLAY_NAME_PREFIX_W                    PROP_TAG( PT_UNICODE,   0x3A45)
#define PR_DISPLAY_NAME_PREFIX_A                    PROP_TAG( PT_STRING8,   0x3A45)
#define PR_PROFESSION                               PROP_TAG( PT_TSTRING,   0x3A46)
#define PR_PROFESSION_W                             PROP_TAG( PT_UNICODE,   0x3A46)
#define PR_PROFESSION_A                             PROP_TAG( PT_STRING8,   0x3A46)
#define PR_PREFERRED_BY_NAME                        PROP_TAG( PT_TSTRING,   0x3A47)
#define PR_PREFERRED_BY_NAME_W                      PROP_TAG( PT_UNICODE,   0x3A47)
#define PR_PREFERRED_BY_NAME_A                      PROP_TAG( PT_STRING8,   0x3A47)
#define PR_SPOUSE_NAME                              PROP_TAG( PT_TSTRING,   0x3A48)
#define PR_SPOUSE_NAME_W                            PROP_TAG( PT_UNICODE,   0x3A48)
#define PR_SPOUSE_NAME_A                            PROP_TAG( PT_STRING8,   0x3A48)
#define PR_COMPUTER_NETWORK_NAME                    PROP_TAG( PT_TSTRING,   0x3A49)
#define PR_COMPUTER_NETWORK_NAME_W                  PROP_TAG( PT_UNICODE,   0x3A49)
#define PR_COMPUTER_NETWORK_NAME_A                  PROP_TAG( PT_STRING8,   0x3A49)
#define PR_CUSTOMER_ID                              PROP_TAG( PT_TSTRING,   0x3A4A)
#define PR_CUSTOMER_ID_W                            PROP_TAG( PT_UNICODE,   0x3A4A)
#define PR_CUSTOMER_ID_A                            PROP_TAG( PT_STRING8,   0x3A4A)
#define PR_TTYTDD_PHONE_NUMBER                      PROP_TAG( PT_TSTRING,   0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_W                    PROP_TAG( PT_UNICODE,   0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_A                    PROP_TAG( PT_STRING8,   0x3A4B)
#define PR_FTP_SITE                                 PROP_TAG( PT_TSTRING,   0x3A4C)
#define PR_FTP_SITE_W                               PROP_TAG( PT_UNICODE,   0x3A4C)
#define PR_FTP_SITE_A                               PROP_TAG( PT_STRING8,   0x3A4C)
#define PR_GENDER                                   PROP_TAG( PT_SHORT,     0x3A4D)
#define PR_MANAGER_NAME                             PROP_TAG( PT_TSTRING,   0x3A4E)
#define PR_MANAGER_NAME_W                           PROP_TAG( PT_UNICODE,   0x3A4E)
#define PR_MANAGER_NAME_A                           PROP_TAG( PT_STRING8,   0x3A4E)
#define PR_NICKNAME                                 PROP_TAG( PT_TSTRING,   0x3A4F)
#define PR_NICKNAME_W                               PROP_TAG( PT_UNICODE,   0x3A4F)
#define PR_NICKNAME_A                               PROP_TAG( PT_STRING8,   0x3A4F)
#define PR_PERSONAL_HOME_PAGE                       PROP_TAG( PT_TSTRING,   0x3A50)
#define PR_PERSONAL_HOME_PAGE_W                     PROP_TAG( PT_UNICODE,   0x3A50)
#define PR_PERSONAL_HOME_PAGE_A                     PROP_TAG( PT_STRING8,   0x3A50)
#define PR_BUSINESS_HOME_PAGE                       PROP_TAG( PT_TSTRING,   0x3A51)
#define PR_BUSINESS_HOME_PAGE_W                     PROP_TAG( PT_UNICODE,   0x3A51)
#define PR_BUSINESS_HOME_PAGE_A                     PROP_TAG( PT_STRING8,   0x3A51)
#define PR_CONTACT_VERSION                          PROP_TAG( PT_CLSID,     0x3A52)
#define PR_CONTACT_ENTRYIDS                         PROP_TAG( PT_MV_BINARY, 0x3A53)
#define PR_CONTACT_ADDRTYPES                        PROP_TAG( PT_MV_TSTRING, 0x3A54)
#define PR_CONTACT_ADDRTYPES_W                      PROP_TAG( PT_MV_UNICODE, 0x3A54)
#define PR_CONTACT_ADDRTYPES_A                      PROP_TAG( PT_MV_STRING8, 0x3A54)
#define PR_CONTACT_DEFAULT_ADDRESS_INDEX            PROP_TAG( PT_LONG,      0x3A55)
#define PR_CONTACT_EMAIL_ADDRESSES                  PROP_TAG( PT_MV_TSTRING, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_W                PROP_TAG( PT_MV_UNICODE, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_A                PROP_TAG( PT_MV_STRING8, 0x3A56)
#define PR_COMPANY_MAIN_PHONE_NUMBER                PROP_TAG( PT_TSTRING,   0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_W              PROP_TAG( PT_UNICODE,   0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_A              PROP_TAG( PT_STRING8,   0x3A57)
#define PR_CHILDRENS_NAMES                          PROP_TAG( PT_MV_TSTRING, 0x3A58)
#define PR_CHILDRENS_NAMES_W                        PROP_TAG( PT_MV_UNICODE, 0x3A58)
#define PR_CHILDRENS_NAMES_A                        PROP_TAG( PT_MV_STRING8, 0x3A58)
#define PR_HOME_ADDRESS_CITY                        PROP_TAG( PT_TSTRING,   0x3A59)
#define PR_HOME_ADDRESS_CITY_W                      PROP_TAG( PT_UNICODE,   0x3A59)
#define PR_HOME_ADDRESS_CITY_A                      PROP_TAG( PT_STRING8,   0x3A59)
#define PR_HOME_ADDRESS_COUNTRY                     PROP_TAG( PT_TSTRING,   0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_W                   PROP_TAG( PT_UNICODE,   0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_A                   PROP_TAG( PT_STRING8,   0x3A5A)
#define PR_HOME_ADDRESS_POSTAL_CODE                 PROP_TAG( PT_TSTRING,   0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_W               PROP_TAG( PT_UNICODE,   0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_A               PROP_TAG( PT_STRING8,   0x3A5B)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE           PROP_TAG( PT_TSTRING,   0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_W         PROP_TAG( PT_UNICODE,   0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_A         PROP_TAG( PT_STRING8,   0x3A5C)
#define PR_HOME_ADDRESS_STREET                      PROP_TAG( PT_TSTRING,   0x3A5D)
#define PR_HOME_ADDRESS_STREET_W                    PROP_TAG( PT_UNICODE,   0x3A5D)
#define PR_HOME_ADDRESS_STREET_A                    PROP_TAG( PT_STRING8,   0x3A5D)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX             PROP_TAG( PT_TSTRING,   0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_W           PROP_TAG( PT_UNICODE,   0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_A           PROP_TAG( PT_STRING8,   0x3A5E)
#define PR_OTHER_ADDRESS_CITY                       PROP_TAG( PT_TSTRING,   0x3A5F)
#define PR_OTHER_ADDRESS_CITY_W                     PROP_TAG( PT_UNICODE,   0x3A5F)
#define PR_OTHER_ADDRESS_CITY_A                     PROP_TAG( PT_STRING8,   0x3A5F)
#define PR_OTHER_ADDRESS_COUNTRY                    PROP_TAG( PT_TSTRING,   0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_W                  PROP_TAG( PT_UNICODE,   0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_A                  PROP_TAG( PT_STRING8,   0x3A60)
#define PR_OTHER_ADDRESS_POSTAL_CODE                PROP_TAG( PT_TSTRING,   0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_W              PROP_TAG( PT_UNICODE,   0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_A              PROP_TAG( PT_STRING8,   0x3A61)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE          PROP_TAG( PT_TSTRING,   0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_W        PROP_TAG( PT_UNICODE,   0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_A        PROP_TAG( PT_STRING8,   0x3A62)
#define PR_OTHER_ADDRESS_STREET                     PROP_TAG( PT_TSTRING,   0x3A63)
#define PR_OTHER_ADDRESS_STREET_W                   PROP_TAG( PT_UNICODE,   0x3A63)
#define PR_OTHER_ADDRESS_STREET_A                   PROP_TAG( PT_STRING8,   0x3A63)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX            PROP_TAG( PT_TSTRING,   0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_W          PROP_TAG( PT_UNICODE,   0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_A          PROP_TAG( PT_STRING8,   0x3A64)
#define PR_USER_X509_CERTIFICATE                    PROP_TAG( PT_MV_BINARY, 0x3A70)
#define PR_SEND_INTERNET_ENCODING                   PROP_TAG( PT_LONG,      0x3A71)



#define PR_BUSINESS_ADDRESS_CITY                    PR_LOCALITY
#define PR_BUSINESS_ADDRESS_COUNTRY                 PR_COUNTRY
#define PR_BUSINESS_ADDRESS_POSTAL_CODE             PR_POSTAL_CODE
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE       PR_STATE_OR_PROVINCE
#define PR_BUSINESS_ADDRESS_STREET                  PR_STREET_ADDRESS


/*
 *	Message recipient properties
 */

#define PR_RECIPIENT_TYPE                           PROP_TAG( PT_LONG,      0x0C15)

/*
 * Secure property id range
 */

#define PROP_ID_SECURE_MIN                          0x67F0
#define PROP_ID_SECURE_MAX                          0x67FF


/* These are the bits that show up in PR_SEND_INTERNET_ENCODING */

/* whether or not an encoding preference is specified
 1 - pay attention to the rest of the bits for the encoding preferences
 0 - let the mail system choose what's best for it
*/
#define ENCODING_PREFERENCE                     ((ULONG) 0x00020000)

/*
 1 - message in MIME;
 0 - plain text/uuencode attachments
*/
#define ENCODING_TEXT                           ((ULONG) 0x00000000)
#define ENCODING_MIME                           ((ULONG) 0x00040000)


/* Specifies how the body of the message is encoded.
 00 - Body encoded as text
 01 - body encoded as HTML (only valid if message in MIME)
 10 - (actualy 1X) Text and HTML as multipart alternative (only valid if message in MIME)
*/
#define BODY_ENCODING_MASK                      ((ULONG) 0x00180000)
#define BODY_ENCODING_TEXT                      ((ULONG) 0x00000000) /* for completeness */
#define BODY_ENCODING_HTML                      ((ULONG) 0x00080000)
#define BODY_ENCODING_TEXT_AND_HTML             ((ULONG) 0x00100000)

/* Specifies how to handle Mac attachments
 00 - BinHex
 01 - UUENCODED (not valid if message in MIME - will be ignored, BinHex used instead)
 10 - Apple Single (only valid if message in MIME)
 11 - Apple Double (only valid if message in MIME)
*/
#define MAC_ATTACH_ENCODING_MASK                ((ULONG) 0x00600000)
#define MAC_ATTACH_ENCODING_BINHEX              ((ULONG) 0x00000000)
#define MAC_ATTACH_ENCODING_UUENCODE            ((ULONG) 0x00200000)
#define MAC_ATTACH_ENCODING_APPLESINGLE         ((ULONG) 0x00400000)
#define MAC_ATTACH_ENCODING_APPLEDOUBLE         ((ULONG) 0x00600000)


// Values for PR_GENDER property
enum Gender {
	genderUnspecified = 0,
	genderFemale,
	genderMale
};

#endif  /* WABTAGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\public\inc\wabutil.h ===
/*
 *	WABUTIL.H
 *
 *  Definitions and prototypes for utility functions provided by MAPI
 *  in MAPI[xx].DLL.
 *
 *  Copyright 1986-1998 Microsoft Corporation. All Rights Reserved.
 */

#if !defined(_MAPIUTIL_H) && !defined(_WABUTIL_H)
#define _WABUTIL_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif


/* IMAPITable in memory */

/* ITableData Interface ---------------------------------------------------- */

DECLARE_MAPI_INTERFACE_PTR(ITableData, LPTABLEDATA);

typedef void (STDAPICALLTYPE CALLERRELEASE)(
	ULONG		ulCallerData,
	LPTABLEDATA	lpTblData,
	LPMAPITABLE	lpVue
);

#define MAPI_ITABLEDATA_METHODS(IPURE)									\
	MAPIMETHOD(HrGetView)												\
		(THIS_	LPSSortOrderSet				lpSSortOrderSet,			\
				CALLERRELEASE FAR *			lpfCallerRelease,			\
				ULONG						ulCallerData,				\
				LPMAPITABLE FAR *			lppMAPITable) IPURE;		\
	MAPIMETHOD(HrModifyRow)												\
		(THIS_	LPSRow) IPURE;											\
	MAPIMETHOD(HrDeleteRow)												\
		(THIS_	LPSPropValue				lpSPropValue) IPURE;		\
	MAPIMETHOD(HrQueryRow)												\
		(THIS_	LPSPropValue				lpsPropValue,				\
				LPSRow FAR *				lppSRow,					\
				ULONG FAR *					lpuliRow) IPURE;			\
	MAPIMETHOD(HrEnumRow)												\
		(THIS_	ULONG						ulRowNumber,				\
				LPSRow FAR *				lppSRow) IPURE;				\
	MAPIMETHOD(HrNotify)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cValues,					\
				LPSPropValue				lpSPropValue) IPURE;		\
	MAPIMETHOD(HrInsertRow)												\
		(THIS_	ULONG						uliRow,						\
				LPSRow						lpSRow) IPURE;				\
	MAPIMETHOD(HrModifyRows)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSRowSet) IPURE;			\
	MAPIMETHOD(HrDeleteRows)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lprowsetToDelete,			\
				ULONG FAR *					cRowsDeleted) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE	ITableData
DECLARE_MAPI_INTERFACE_(ITableData, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_ITABLEDATA_METHODS(PURE)
};


/* Entry Point for in memory ITable */


/*	CreateTable()
 *		Creates the internal memory structures and object handle
 *		to bring a new table into existence.
 *
 *	lpInterface
 *		Interface ID of the TableData object (IID_IMAPITableData)
 *
 *	lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *		Function addresses are provided by the caller so that
 *		this DLL allocates/frees memory appropriately.
 *	lpvReserved
 *		Reserved.  Should be NULL.
 *	ulTableType
 *		TBLTYPE_DYNAMIC, etc.  Visible to the calling application
 *		as part of the GetStatus return data on its views
 *	ulPropTagIndexColumn
 *		Index column for use when changing the data
 *	lpSPropTagArrayColumns
 *		Column proptags for the minimum set of columns in the table
 *	lppTableData
 *		Address of the pointer which will receive the TableData object
 */

STDAPI_(SCODE)
CreateTable( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 ULONG					ulTableType,
			 ULONG					ulPropTagIndexColumn,
			 LPSPropTagArray		lpSPropTagArrayColumns,
			 LPTABLEDATA FAR *		lppTableData );


/*	HrGetView()
 *		This function obtains a new view on the underlying data
 *		which supports the IMAPITable interface.  All rows and columns
 *		of the underlying table data are initially visible
 *	lpSSortOrderSet
 *		if specified, results in the view being sorted
 *	lpfCallerRelease
 *		pointer to a routine to be called when the view is released, or
 *		NULL.
 *	ulCallerData
 *		arbitrary data the caller wants saved with this view and returned in
 *		the Release callback.
 */

/*	HrModifyRows()
 *		Add or modify a set of rows in the table data
 *	ulFlags
 *		Must be zero
 *	lpSRowSet
 *		Each row in the row set contains all the properties for one row
 *		in the table.  One of the properties must be the index column.  Any
 *		row in the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added.
 *		Each row in LPSRowSet MUST have a unique Index column!
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */

/*	HrModifyRow()
 *		Add or modify one row in the table
 *	lpSRow
 *		This row contains all the properties for one row in the table.
 *		One of the properties must be the index column.	 Any row in
 *		the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */

/*	HrDeleteRows()
 *		Delete a row in the table.
 *	ulFlags
 *		TAD_ALL_ROWS - Causes all rows in the table to be deleted
 *					   lpSRowSet is ignored in this case.
 *	lpSRowSet
 *		Each row in the row set contains all the properties for one row
 *		in the table.  One of the properties must be the index column.  Any
 *		row in the table with the same value for its index column is
 *		deleted.
 *		Each row in LPSRowSet MUST have a unique Index column!
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */
#define	TAD_ALL_ROWS	1

/*	HrDeleteRow()
 *		Delete a row in the table.
 *	lpSPropValue
 *		This property value specifies the row which has this value
 *		for its index column
 */

/*	HrQueryRow()
 *		Returns the values of a specified row in the table
 *	lpSPropValue
 *		This property value specifies the row which has this value
 *		for its index column
 *	lppSRow
 *		Address of where to return a pointer to an SRow
 *	lpuliRow
 *	  Address of where to return the row number. This can be NULL
 *	  if the row number is not required.
 *
 */

/*	HrEnumRow()
 *		Returns the values of a specific (numbered) row in the table
 *	ulRowNumber
 *		Indicates row number 0 to n-1
 *	lppSRow
 *		Address of where to return a pointer to a SRow
 */

/*	HrInsertRow()
 *		Inserts a row into the table.
 *	uliRow
 *		The row number before which this row will be inserted into the table.
 *		Row numbers can be from 0 to n where o to n-1 result in row insertion
 *	  a row number of n results in the row being appended to the table.
 *	lpSRow
 *		This row contains all the properties for one row in the table.
 *		One of the properties must be the index column.	 Any row in
 *		the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */


/* IMAPIProp in memory */

/* IPropData Interface ---------------------------------------------------- */


#define MAPI_IPROPDATA_METHODS(IPURE)									\
	MAPIMETHOD(HrSetObjAccess)											\
		(THIS_	ULONG						ulAccess) IPURE;			\
	MAPIMETHOD(HrSetPropAccess)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG FAR *					rgulAccess) IPURE;			\
	MAPIMETHOD(HrGetPropAccess)											\
		(THIS_	LPSPropTagArray FAR *		lppPropTagArray,			\
				ULONG FAR * FAR *			lprgulAccess) IPURE;		\
	MAPIMETHOD(HrAddObjProps)											\
		(THIS_	LPSPropTagArray				lppPropTagArray,			\
				LPSPropProblemArray FAR *	lprgulAccess) IPURE;


#undef		 INTERFACE
#define		 INTERFACE	IPropData
DECLARE_MAPI_INTERFACE_(IPropData, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IPROPDATA_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IPropData, LPPROPDATA);


/* Entry Point for in memory IMAPIProp */


/*	CreateIProp()
 *		Creates the internal memory structures and object handle
 *		to bring a new property interface into existance.
 *
 *	lpInterface
 *		Interface ID of the TableData object (IID_IMAPIPropData)
 *
 *	lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *		Function addresses are provided by the caller so that
 *		this DLL allocates/frees memory appropriately.
 *	lppPropData
 *		Address of the pointer which will receive the IPropData object
 *	lpvReserved
 *		Reserved.  Should be NULL.
 */

// If MAPI isn't included, use WABCreateIProp instead
#ifndef CreateIProp
STDAPI_(SCODE)
CreateIProp( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 LPPROPDATA FAR *		lppPropData );
#endif

STDAPI_(SCODE)
WABCreateIProp( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 LPPROPDATA FAR *		lppPropData );

/*
 *	Defines for prop/obj access
 */
#define IPROP_READONLY		((ULONG) 0x00000001)
#define IPROP_READWRITE		((ULONG) 0x00000002)
#define IPROP_CLEAN			((ULONG) 0x00010000)
#define IPROP_DIRTY			((ULONG) 0x00020000)

/*
 -	HrSetPropAccess
 -
 *	Sets access right attributes on a per-property basis.  By default,
 *	all properties are read/write.
 *
 */

/*
 -	HrSetObjAccess
 -
 *	Sets access rights for the object itself.  By default, the object has
 *	read/write access.
 *
 */

#ifndef NOIDLEENGINE

/* Idle time scheduler */

/*
 *	PRI
 *
 *	Priority of an idle task.
 *	The idle engine sorts tasks by priority, and the one with the higher
 *	value runs first. Within a priority level, the functions are called
 *	round-robin.
 */

#define PRILOWEST	-32768
#define PRIHIGHEST	32767
#define PRIUSER		0

/*
 *	IRO
 *
 *	Idle routine options.  This is a combined bit mask consisting of
 *	individual firo's.	Listed below are the possible bit flags.
 *
 *		FIROWAIT and FIROINTERVAL are mutually exclusive.
 *		If neither of the flags are specified, the default action
 *		is to ignore the time parameter of the idle function and
 *		call it as often as possible if firoPerBlock is not set;
 *		otherwise call it one time only during the idle block
 *		once the time constraint has been set. FIROINTERVAL
 *		is also incompatible with FIROPERBLOCK.
 *
 *		FIROWAIT		- time given is minimum idle time before calling
 *						  for the first time in the block of idle time,
 *						  afterwhich call as often as possible.
 *		FIROINTERVAL	- time given is minimum interval between each
 *						  successive call
 *		FIROPERBLOCK	- called only once per contiguous block of idle
 *						  time
 *		FIRODISABLED	- initially disabled when registered, the
 *						  default is to enable the function when registered.
 *		FIROONCEONLY	- called only one time by the scheduler and then
 *						  deregistered automatically.
 */

#define IRONULL			((USHORT) 0x0000)
#define FIROWAIT		((USHORT) 0x0001)
#define FIROINTERVAL	((USHORT) 0x0002)
#define FIROPERBLOCK	((USHORT) 0x0004)
#define FIRODISABLED	((USHORT) 0x0020)
#define FIROONCEONLY	((USHORT) 0x0040)

/*
 *	IRC
 *
 *	Idle routine change options. This is a combined bit mask consisting
 *	of individual firc's; each one identifies an aspect of the idle task
 *	that can be changed.
 *
 */

#define IRCNULL			((USHORT) 0x0000)
#define FIRCPFN			((USHORT) 0x0001)	/* change function pointer */
#define FIRCPV			((USHORT) 0x0002)	/* change parameter block  */
#define FIRCPRI			((USHORT) 0x0004)	/* change priority		   */
#define FIRCCSEC		((USHORT) 0x0008)	/* change time			   */
#define FIRCIRO			((USHORT) 0x0010)	/* change routine options  */

/*
 *	Type definition for idle functions.	 An idle function takes one
 *	parameter, an PV, and returns a BOOL value.
 */

typedef BOOL (STDAPICALLTYPE FNIDLE) (LPVOID);
typedef FNIDLE FAR *PFNIDLE;

/*
 *	FTG
 *
 *	Function Tag.  Used to identify a registered idle function.
 *
 */

typedef void FAR *FTG;
typedef FTG  FAR *PFTG;
#define FTGNULL			((FTG) NULL)

/*
 -	MAPIInitIdle/MAPIDeinitIdle
 -
 *	Purpose:
 *		Initialises the idle engine
 *		If the initialisation succeded, returns 0, else returns -1
 *
 *	Arguments:
 *		lpvReserved		Reserved, must be NULL.
 */

STDAPI_(LONG)
MAPIInitIdle (LPVOID lpvReserved);

STDAPI_(VOID)
MAPIDeinitIdle (VOID);


/*
 *	FtgRegisterIdleRoutine
 *
 *		Registers the function pfn of type PFNIDLE, i.e., (BOOL (*)(LPVOID))
 *		as an idle function.
 *
 *		The idle function will be called with the parameter pv by the
 *		idle engine. The function has initial priority priIdle,
 *		associated time csecIdle, and options iroIdle.
 */

STDAPI_(FTG)
FtgRegisterIdleRoutine (PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
	short priIdle, ULONG csecIdle, USHORT iroIdle);

/*
 *	DeregisterIdleRoutine
 *
 *		Removes the given routine from the list of idle routines.
 *		The routine will not be called again.  It is the responsibility
 *		of the caller to clean up any data structures pointed to by the
 *		pvIdleParam parameter; this routine does not free the block.
 */

STDAPI_(void)
DeregisterIdleRoutine (FTG ftg);

/*
 *	EnableIdleRoutine
 *
 *		Enables or disables an idle routine.
 */

STDAPI_(void)
EnableIdleRoutine (FTG ftg, BOOL fEnable);

/*
 *	ChangeIdleRoutine
 *
 *		Changes some or all of the characteristics of the given idle
 *		function. The changes to make are indicated with flags in the
 *		ircIdle parameter.
 */

STDAPI_(void)
ChangeIdleRoutine (FTG ftg, PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
	short priIdle, ULONG csecIdle, USHORT iroIdle, USHORT ircIdle);


#endif	/* ! NOIDLEENGINE */


/* IMalloc Utilities */

STDAPI_(LPMALLOC) MAPIGetDefaultMalloc(VOID);


/* StreamOnFile (SOF) */

/*
 *	Methods and #define's for implementing an OLE 2.0 storage stream
 *	(as defined in the OLE 2.0 specs) on top of a system file.
 */

#define SOF_UNIQUEFILENAME	((ULONG) 0x80000000)

STDMETHODIMP OpenStreamOnFile(
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPFREEBUFFER		lpFreeBuffer,
	ULONG				ulFlags,
	LPTSTR				lpszFileName,
	LPTSTR				lpszPrefix,
	LPSTREAM FAR *		lppStream);

typedef HRESULT (STDMETHODCALLTYPE FAR * LPOPENSTREAMONFILE) (
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPFREEBUFFER		lpFreeBuffer,
	ULONG				ulFlags,
	LPTSTR				lpszFileName,
	LPTSTR				lpszPrefix,
	LPSTREAM FAR *		lppStream);

#ifdef	_WIN32
#define OPENSTREAMONFILE "OpenStreamOnFile"
#endif
#ifdef	WIN16
#define OPENSTREAMONFILE "_OPENSTREAMONFILE"
#endif


/* Property interface utilities */

/*
 *	Copies a single SPropValue from Src to Dest.  Handles all the various
 *	types of properties and will link its allocations given the master
 *	allocation object and an allocate more function.
 */
STDAPI_(SCODE)
PropCopyMore( LPSPropValue		lpSPropValueDest,
			  LPSPropValue		lpSPropValueSrc,
			  ALLOCATEMORE *	lpfAllocMore,
			  LPVOID			lpvObject );

/*
 *	Returns the size in bytes of structure at lpSPropValue, including the
 *	Value.
 */
STDAPI_(ULONG)
UlPropSize(	LPSPropValue	lpSPropValue );


STDAPI_(BOOL)
FEqualNames( LPMAPINAMEID lpName1, LPMAPINAMEID lpName2 );

#if defined(_WIN32) && !defined(_WINNT) && !defined(_WIN95) && !defined(_MAC)
#define _WINNT
#endif

STDAPI_(void)
GetInstance(LPSPropValue lpPropMv, LPSPropValue lpPropSv, ULONG uliInst);

extern unsigned char rgchCsds[];
extern unsigned char rgchCids[];
extern unsigned char rgchCsdi[];
extern unsigned char rgchCidi[];

STDAPI_(BOOL)
FPropContainsProp( LPSPropValue	lpSPropValueDst,
				   LPSPropValue	lpSPropValueSrc,
				   ULONG		ulFuzzyLevel );

STDAPI_(BOOL)
FPropCompareProp( LPSPropValue	lpSPropValue1,
				  ULONG			ulRelOp,
				  LPSPropValue	lpSPropValue2 );

STDAPI_(LONG)
LPropCompareProp( LPSPropValue	lpSPropValueA,
				  LPSPropValue	lpSPropValueB );

STDAPI_(HRESULT)
HrAddColumns(	LPMAPITABLE			lptbl,
				LPSPropTagArray		lpproptagColumnsNew,
				LPALLOCATEBUFFER	lpAllocateBuffer,
				LPFREEBUFFER		lpFreeBuffer);

STDAPI_(HRESULT)
HrAddColumnsEx(	LPMAPITABLE			lptbl,
				LPSPropTagArray		lpproptagColumnsNew,
				LPALLOCATEBUFFER	lpAllocateBuffer,
				LPFREEBUFFER		lpFreeBuffer,
				void				(FAR *lpfnFilterColumns)(LPSPropTagArray ptaga));


/* Notification utilities */

/*
 *	Function that creates an advise sink object given a notification
 *	callback function and context.
 */

STDAPI
HrAllocAdviseSink( LPNOTIFCALLBACK lpfnCallback,
				   LPVOID lpvContext,
				   LPMAPIADVISESINK FAR *lppAdviseSink );


/*
 *	Wraps an existing advise sink with another one which guarantees
 *	that the original advise sink will be called in the thread on
 *	which it was created.
 */

STDAPI
HrThisThreadAdviseSink( LPMAPIADVISESINK lpAdviseSink,
						LPMAPIADVISESINK FAR *lppAdviseSink);



/*
 *	Allows a client and/or provider to force notifications
 *	which are currently queued in the MAPI notification engine
 *	to be dispatched without doing a message dispatch.
 */

STDAPI HrDispatchNotifications (ULONG ulFlags);


/* Service Provider Utilities */

/*
 *	Structures and utility function for building a display table
 *	from resources.
 */

typedef struct {
	ULONG			ulCtlType;			/* DTCT_LABEL, etc. */
	ULONG			ulCtlFlags;			/* DT_REQUIRED, etc. */
	LPBYTE			lpbNotif;			/*	pointer to notification data */
	ULONG			cbNotif;			/* count of bytes of notification data */
	LPTSTR			lpszFilter;			/* character filter for edit/combobox */
	ULONG			ulItemID;			/* to validate parallel dlg template entry */
	union {								/* ulCtlType discriminates */
		LPVOID			lpv;			/* Initialize this to avoid warnings */
		LPDTBLLABEL		lplabel;
		LPDTBLEDIT		lpedit;
		LPDTBLLBX		lplbx;
		LPDTBLCOMBOBOX	lpcombobox;
		LPDTBLDDLBX		lpddlbx;
		LPDTBLCHECKBOX	lpcheckbox;
		LPDTBLGROUPBOX	lpgroupbox;
		LPDTBLBUTTON	lpbutton;
		LPDTBLRADIOBUTTON lpradiobutton;
		LPDTBLMVLISTBOX	lpmvlbx;
		LPDTBLMVDDLBX	lpmvddlbx;
		LPDTBLPAGE		lppage;
	} ctl;
} DTCTL, FAR *LPDTCTL;

typedef struct {
	ULONG			cctl;
	LPTSTR			lpszResourceName;	/* as usual, may be an integer ID */
	union {								/* as usual, may be an integer ID */
		LPTSTR			lpszComponent;
		ULONG			ulItemID;
	};
	LPDTCTL			lpctl;
} DTPAGE, FAR *LPDTPAGE;



STDAPI
BuildDisplayTable(	LPALLOCATEBUFFER	lpAllocateBuffer,
					LPALLOCATEMORE		lpAllocateMore,
					LPFREEBUFFER		lpFreeBuffer,
					LPMALLOC			lpMalloc,
					HINSTANCE			hInstance,
					UINT				cPages,
					LPDTPAGE			lpPage,
					ULONG				ulFlags,
					LPMAPITABLE *		lppTable,
					LPTABLEDATA	*		lppTblData );


/* MAPI structure validation/copy utilities */

/*
 *	Validate, copy, and adjust pointers in MAPI structures:
 *		notification
 *		property value array
 *		option data
 */

STDAPI_(SCODE)
ScCountNotifications(int cNotifications, LPNOTIFICATION lpNotifications,
		ULONG FAR *lpcb);

STDAPI_(SCODE)
ScCopyNotifications(int cNotification, LPNOTIFICATION lpNotifications,
		LPVOID lpvDst, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocNotifications(int cNotification, LPNOTIFICATION lpNotifications,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);


STDAPI_(SCODE)
ScCountProps(int cValues, LPSPropValue lpPropArray, ULONG FAR *lpcb);

STDAPI_(LPSPropValue)
LpValFindProp(ULONG ulPropTag, ULONG cValues, LPSPropValue lpPropArray);

STDAPI_(SCODE)
ScCopyProps(int cValues, LPSPropValue lpPropArray, LPVOID lpvDst,
		ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocProps(int cValues, LPSPropValue lpPropArray,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScDupPropset(int cValues, LPSPropValue lpPropArray,
		LPALLOCATEBUFFER lpAllocateBuffer, LPSPropValue FAR *lppPropArray);


/* General utility functions */

/* Related to the OLE Component object model */

STDAPI_(ULONG)			UlAddRef(LPVOID lpunk);
STDAPI_(ULONG)			UlRelease(LPVOID lpunk);

/* Related to the MAPI interface */

STDAPI					HrGetOneProp(LPMAPIPROP lpMapiProp, ULONG ulPropTag,
						LPSPropValue FAR *lppProp);
STDAPI					HrSetOneProp(LPMAPIPROP lpMapiProp,
						LPSPropValue lpProp);
STDAPI_(BOOL)			FPropExists(LPMAPIPROP lpMapiProp, ULONG ulPropTag);
STDAPI_(LPSPropValue)	PpropFindProp(LPSPropValue lpPropArray, ULONG cValues,
						ULONG ulPropTag);
STDAPI_(void)			FreePadrlist(LPADRLIST lpAdrlist);
STDAPI_(void)			FreeProws(LPSRowSet lpRows);
STDAPI					HrQueryAllRows(LPMAPITABLE lpTable,
						LPSPropTagArray lpPropTags,
						LPSRestriction lpRestriction,
						LPSSortOrderSet lpSortOrderSet,
						LONG crowsMax,
						LPSRowSet FAR *lppRows);




/* C runtime substitutes */


STDAPI_(LPTSTR)			SzFindCh(LPCTSTR lpsz, USHORT ch);		/* strchr */
STDAPI_(LPTSTR)			SzFindLastCh(LPCTSTR lpsz, USHORT ch);	/* strrchr */
STDAPI_(LPTSTR)			SzFindSz(LPCTSTR lpsz, LPCTSTR lpszKey); /*strstr */
STDAPI_(unsigned int)	UFromSz(LPCTSTR lpsz);					/* atoi */

STDAPI_(SCODE)			ScUNCFromLocalPath(LPSTR lpszLocal, LPSTR lpszUNC,
						UINT cchUNC);
STDAPI_(SCODE)			ScLocalPathFromUNC(LPSTR lpszUNC, LPSTR lpszLocal,
						UINT cchLocal);

/* 64-bit arithmetic with times */

STDAPI_(FILETIME)		FtAddFt(FILETIME ftAddend1, FILETIME ftAddend2);
STDAPI_(FILETIME)		FtMulDwDw(DWORD ftMultiplicand, DWORD ftMultiplier);
STDAPI_(FILETIME)		FtMulDw(DWORD ftMultiplier, FILETIME ftMultiplicand);
STDAPI_(FILETIME)		FtSubFt(FILETIME ftMinuend, FILETIME ftSubtrahend);
STDAPI_(FILETIME)		FtNegFt(FILETIME ft);

/* Message composition */

STDAPI_(SCODE)			ScCreateConversationIndex (ULONG cbParent,
							LPBYTE lpbParent,
							ULONG FAR *	lpcbConvIndex,
							LPBYTE FAR * lppbConvIndex);

/* Store support */

STDAPI WrapStoreEntryID (ULONG ulFlags, LPTSTR lpszDLLName, ULONG cbOrigEntry,
	LPENTRYID lpOrigEntry, ULONG *lpcbWrappedEntry, LPENTRYID *lppWrappedEntry);

/* RTF Sync Utilities */

#define RTF_SYNC_RTF_CHANGED	((ULONG) 0x00000001)
#define RTF_SYNC_BODY_CHANGED	((ULONG) 0x00000002)

STDAPI_(HRESULT)
RTFSync (LPMESSAGE lpMessage, ULONG ulFlags, BOOL FAR * lpfMessageUpdated);


/* Flags for WrapCompressedRTFStream() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) mapidefs.h */
/****** STORE_UNCOMPRESSED_RTF	((ULONG) 0x00008000) mapidefs.h */

STDAPI_(HRESULT)
WrapCompressedRTFStream (LPSTREAM lpCompressedRTFStream,
		ULONG ulFlags, LPSTREAM FAR * lpUncompressedRTFStream);

/* Storage on Stream */

#if defined(_WIN32) || defined(WIN16)
STDAPI_(HRESULT)
HrIStorageFromStream (LPUNKNOWN lpUnkIn,
	LPCIID lpInterface, ULONG ulFlags, LPSTORAGE FAR * lppStorageOut);
#endif


/*
 * Setup and cleanup.
 *
 * Providers never need to make these calls.
 *
 * Test applications and the like which do not call MAPIInitialize
 * may want to call them, so that the few utility functions which
 * need MAPI allocators (and do not ask for them explicitly)
 * will work.
 */

/* All flags are reserved for ScInitMapiUtil. */

STDAPI_(SCODE)			ScInitMapiUtil(ULONG ulFlags);
STDAPI_(VOID)			DeinitMapiUtil(VOID);


/*
 *	Entry point names.
 *	
 *	These are for new entry points defined since MAPI first shipped
 *	in Windows 95. Using these names in a GetProcAddress call makes
 *	it easier to write code which uses them optionally.
 */

#if defined (WIN16)
#define szHrDispatchNotifications "HrDispatchNotifications"
#elif defined (_WIN32) && defined (_X86_)
#define szHrDispatchNotifications "_HrDispatchNotifications@4"
#elif defined (_AMD64_)
#define szHrDispatchNotifications "HrDispatchNotifications"
#endif

typedef HRESULT (STDAPICALLTYPE DISPATCHNOTIFICATIONS)(ULONG ulFlags);
typedef DISPATCHNOTIFICATIONS FAR * LPDISPATCHNOTIFICATIONS;

#if defined (WIN16)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#elif defined (_WIN32) && defined (_X86_)
#define szScCreateConversationIndex "_ScCreateConversationIndex@16"
#elif defined (_AMD64_)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#endif

typedef SCODE (STDAPICALLTYPE CREATECONVERSATIONINDEX)(ULONG cbParent,
	LPBYTE lpbParent, ULONG FAR *lpcbConvIndex, LPBYTE FAR *lppbConvIndex);
typedef CREATECONVERSATIONINDEX FAR *LPCREATECONVERSATIONINDEX;

#ifdef __cplusplus
}
#endif

#endif /* _WABUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\sendfile\main.cpp ===
#define DEFINE_STRCONST
#define INITGUID
#define INC_OLE2
#include <windows.h>
#include <initguid.h>

#include <mimeole.h>
//#include <mimeapi.h>
#include <urlmon.h>
#include "main.h"
#include "smtpcb.h"

#define ReleaseObj(x) (x?(x)->Release : 0)

typedef struct MSGDATA_tag
{
    TCHAR   rgchSubj[MAX_PATH];
    TCHAR   rgchTo[MAX_PATH];
    TCHAR   rgchFrom[MAX_PATH];
    TCHAR   rgchFile[MAX_PATH];
    TCHAR   rgchServer[MAX_PATH];
    TCHAR   rgchBase[MAX_PATH];
    BOOL    fRaw;
    BOOL    fB64;
} MSGDATA, *PMSGDATA;

UINT                g_msgSMTP;
ISMTPTransport      *g_pSMTP=NULL;

void WaitForCompletion(UINT uiMsg, DWORD wparam);

HRESULT HrParseCommandLine(LPSTR pszCmdLine, PMSGDATA pmsgData);
HRESULT HrSendFile(PMSGDATA pmsgData);
HRESULT HrInitSMTP(LPSTR lpszServer);
HRESULT HrSendStream(LPSTREAM pstm, PMSGDATA pMsgData);
HRESULT HrGetStreamSize(LPSTREAM pstm, ULONG *pcb);
HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb);
HRESULT HrRewindStream(LPSTREAM pstm);
HRESULT HrBaseStream(LPSTREAM pstm, LPSTR lpszURL, LPSTREAM *ppstmBase);


void Usage();
void err(LPSTR lpsz);

int CALLBACK WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, LPTSTR pszCmdLine, int nCmdShow)
{
    MSGDATA msgData={0};

    if (FAILED(CoInitialize(NULL)))
       {
        err("OLE Init Failed");
        return -1;
        }

    if (FAILED(HrParseCommandLine(pszCmdLine, &msgData)))
        {
        err("Bad CmdLine");
        return -1;
        }

    if (FAILED(HrSendFile(&msgData)))
        {
        err("Unable to send file");
        return -1;
        }

    CoUninitialize();
    return 0; 
}



HRESULT HrParseCommandLine(LPSTR pszCmdLine, PMSGDATA pmsgData)
{
    LPSTR   psz;
    BOOL    fQuote=FALSE;

    // find first switch

    while(*pszCmdLine && *pszCmdLine!='/')
        pszCmdLine++;

    while (pszCmdLine && *pszCmdLine)
        {
        if (_strnicmp(pszCmdLine, "file:", 5)==0)
            {
            pszCmdLine+=5;
            psz = pmsgData->rgchFile;
            while (*pszCmdLine && (*pszCmdLine!='/' || fQuote))
                {
                if (*pszCmdLine=='"')   // allow /file:"http://www.microsoft.com"
                    fQuote = !fQuote;
                else
                    *psz++ = *pszCmdLine;
                
                pszCmdLine++;
                }
                
            *psz =0;
            continue;
            }
        
        if (_strnicmp(pszCmdLine, "raw", 3)==0)
            {
            pmsgData->fRaw=TRUE;
            pszCmdLine+=3;
            continue;
            }

        if (_strnicmp(pszCmdLine, "B64", 3)==0)
            {
            pmsgData->fB64=TRUE;
            pszCmdLine+=3;
            continue;
            }

        if (_strnicmp(pszCmdLine, "to:", 3)==0)
            {
            pszCmdLine+=3;
            psz = pmsgData->rgchTo;
            while (*pszCmdLine && *pszCmdLine!='/')
                *psz++ = *pszCmdLine++;
            *psz =0;
            continue;
            }

        if (_strnicmp(pszCmdLine, "base:", 5)==0)
            {
            pszCmdLine+=5;
            psz = pmsgData->rgchBase;
            while (*pszCmdLine && (*pszCmdLine!='/' || fQuote))
                {
                if (*pszCmdLine=='"')   // allow /base:"http://www.microsoft.com"
                    fQuote = !fQuote;
                else
                    *psz++ = *pszCmdLine;
                
                pszCmdLine++;
                }
                
            *psz =0;
            continue;
            }

        if (_strnicmp(pszCmdLine, "subj:", 5)==0)
            {
            pszCmdLine+=5;
            psz = pmsgData->rgchSubj;
            while (*pszCmdLine && *pszCmdLine!='/')
                *psz++ = *pszCmdLine++;
            *psz =0;
            continue;
            }

        if (_strnicmp(pszCmdLine, "from:", 5)==0)
            {
            pszCmdLine+=5;
            psz = pmsgData->rgchFrom;
            while (*pszCmdLine && *pszCmdLine!='/')
                *psz++ = *pszCmdLine++;
            *psz =0;
            continue;
            }

        if (_strnicmp(pszCmdLine, "server:", 7)==0)
            {
            pszCmdLine+=7;
            psz = pmsgData->rgchServer;
            while (*pszCmdLine && *pszCmdLine!='/')
                *psz++ = *pszCmdLine++;
            *psz =0;
            continue;
            }

        pszCmdLine++;
        }

    return S_OK;
}



HRESULT HrSendFile(PMSGDATA pmsgData)
{
    HRESULT         hr;
    LPMIMEMESSAGE   pMsg=0;
    LPSTREAM        pstm=0,
                    pstmSend=0;

    if (*pmsgData->rgchFile==NULL || *pmsgData->rgchTo==NULL)
        {
        Usage();
        return E_FAIL;
        }
/*
    hr = CoCreateInstance(CLSID_IMimeMessage, NULL, CLSCTX_INPROC_SERVER, IID_IMimeMessage, (LPVOID *)&pMsg);
    if (FAILED(hr))
        {
        err("Could not create IMimeMessage");
        goto error;
        }
*/
    hr = URLOpenBlockingStream(NULL, pmsgData->rgchFile, &pstm, 0, NULL);
    if (FAILED(hr))
        {
        err("Could not open URL");
        goto error;
        }


    if (pmsgData->fRaw)
        {
        pstmSend = pstm;
        pstm->AddRef();
        }
    else
        {
        hr = MimeOleCreateMessage(NULL, &pMsg);
        if (FAILED(hr))
            {
            err("Could not create IMimeMessage");
            goto error;
            }

        hr = pMsg->InitNew();
        if (FAILED(hr))
            goto error;

        if (*pmsgData->rgchSubj)
            MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_SUBJECT), NOFLAGS, pmsgData->rgchSubj);

        MimeOleSetBodyPropA(pMsg, HBODY_ROOT, PIDTOSTR(PID_HDR_TO), NOFLAGS, pmsgData->rgchTo);

        if (pmsgData->rgchBase)
            {
            LPSTREAM    pstmBase=0;

            if (!FAILED(hr = HrBaseStream(pstm, pmsgData->rgchBase, &pstmBase)))
                {
                pstm->Release();
                pstm = pstmBase;
                }
            }

        hr = pMsg->SetTextBody(TXT_HTML, IET_DECODED, NULL, pstm, NULL);
        if (FAILED(hr))
            goto error;

        if (pmsgData->fB64)
            {
            PROPVARIANT     rVariant;            
            // HTML Text body encoding
            rVariant.vt = VT_UI4;
            rVariant.ulVal = IET_BASE64;
            pMsg->SetOption(OID_XMIT_HTML_TEXT_ENCODING, &rVariant);
            }

        hr = pMsg->GetMessageSource(&pstmSend, TRUE);
        if (FAILED(hr))
            goto error;
        }

    hr = HrInitSMTP(pmsgData->rgchServer);
    if (FAILED(hr))
        {
        err("Could not connect to SMTP Server");
        goto error;
        }

    hr = HrSendStream(pstmSend, pmsgData);
    if (FAILED(hr))
        goto error;

error:
    ReleaseObj(pMsg);
    ReleaseObj(pstm);
    ReleaseObj(pstmSend);
    return hr;
}



HRESULT HrInitSMTP(LPSTR lpszServer)
{
    HRESULT     hr;
    INETSERVER  rServer={0};
    SMTPMESSAGE rMsg={0};

    g_msgSMTP = RegisterWindowMessage("SMTPTransport_Notify");
    if (!g_msgSMTP)
        {
        hr = E_FAIL;
        goto error;
        }

    // Create smtp transport
    hr = HrCreateSMTPTransport(&g_pSMTP);
    if (FAILED(hr))
       goto error;

    if (!lpszServer || !*lpszServer)
        lstrcpy(rServer.szServerName, "popdog");   // default to popdog
    else
        lstrcpy(rServer.szServerName, lpszServer);

    rServer.dwPort = 25;
    rServer.dwTimeout = 30;

    hr = g_pSMTP->Connect(&rServer, TRUE, TRUE);
    if (FAILED(hr))
       goto error;

    // Wait for completion
    WaitForCompletion(g_msgSMTP, SMTP_CONNECTED);

error:
    return hr;
}



HRESULT HrSendStream(LPSTREAM pstm, PMSGDATA pMsgData)
{
    HRESULT         hr;
    INETADDR        rAddr[2];
    SMTPMESSAGE     rMsg={0};
    ULONG           cb=MAX_PATH;

    hr = HrGetStreamSize(pstm, &rMsg.cbSize);
    if (FAILED(hr))
        goto error;

    rMsg.pstmMsg = pstm;

    rAddr[0].addrtype = ADDR_FROM;
    if (*pMsgData->rgchFrom==NULL)        // default sender
        GetUserName(pMsgData->rgchFrom, &cb);

    lstrcpy(rAddr[0].szEmail, pMsgData->rgchFrom);

    rAddr[1].addrtype = ADDR_TO;
    lstrcpy(rAddr[1].szEmail, pMsgData->rgchTo);


    rMsg.rAddressList.cAddress = 2;
    rMsg.rAddressList.prgAddress = (LPINETADDR)&rAddr;

    hr = g_pSMTP->SendMessage(&rMsg);
    if (FAILED(hr))
        goto error;

    WaitForCompletion(g_msgSMTP, SMTP_SEND_MESSAGE);

error:
    return hr;
}



void WaitForCompletion(UINT uiMsg, DWORD wparam)
{
    MSG msg;
    
    while(GetMessage(&msg, NULL, 0, 0))
        {
        if (msg.message == uiMsg && msg.wParam == wparam || msg.wParam == IXP_DISCONNECTED)
            break;
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
}



HRESULT HrGetStreamSize(LPSTREAM pstm, ULONG *pcb)
{
    // Locals
    HRESULT hr=S_OK;
    ULARGE_INTEGER uliPos = {0,0};
    LARGE_INTEGER liOrigin = {0,0};

    // Seek
    hr = pstm->Seek(liOrigin, STREAM_SEEK_END, &uliPos);
    if (FAILED(hr))
        goto error;

    // set size
    *pcb = uliPos.LowPart;

error:
    // Done
    return hr;
}


void Usage()
{
    err("Usage:\n\r"
        "/TO:<recipient>\n\r"
        "/FILE:\"<file name or URL>\"\n\r"
        "[/FROM:<sender>]\n\r"
        "[/SUBJ:<subject>]\n\r"
        "[/SERVER:<SMTP server name>]\n\r"
        "[/BASE:<url base path>]\n\r"
        "[/RAW] (file points to raw rfc822 source)"
        "[/B64] (base64 encode)");
}

void err(LPSTR lpsz)
{
    MessageBox(GetFocus(), lpsz, "SendFile", MB_OK|MB_ICONEXCLAMATION);
}



HRESULT HrBaseStream(LPSTREAM pstm, LPSTR lpszURL, LPSTREAM *ppstmBase)
{
    HRESULT     hr;
    LPSTREAM    pstmBase=0;
    char        szBase[MAX_PATH + MAX_PATH];

    hr = CreateStreamOnHGlobal(NULL, TRUE, &pstmBase);
    if (FAILED(hr))
        goto error;

    wsprintf(szBase, "<BASE HREF=\"%s\">", lpszURL);

    hr = pstmBase->Write(szBase, lstrlen(szBase), NULL);
    if (FAILED(hr))
        goto error;

    hr = HrRewindStream(pstm);
    if (FAILED(hr))
        goto error;


    hr = HrCopyStream(pstm, pstmBase, NULL);
    if (FAILED(hr))
        goto error;

    pstmBase->AddRef();
    *ppstmBase = pstmBase;
        
error:
    ReleaseObj(pstmBase);
    return hr;

}




HRESULT HrCopyStream(LPSTREAM pstmIn, LPSTREAM pstmOut, ULONG *pcb)
{
    // Locals
    HRESULT        hr = S_OK;
    BYTE           buf[4096];
    ULONG          cbRead=0,
                   cbTotal=0;

    do
    {
        hr = pstmIn->Read(buf, sizeof(buf), &cbRead);
        if (FAILED(hr))
            goto exit;

        if (cbRead == 0) 
            break;
        
        hr = pstmOut->Write(buf, cbRead, NULL);
        if (FAILED(hr))
            goto exit;

        cbTotal += cbRead;
    }
    while (cbRead == sizeof (buf));

exit:
    if (pcb)
        *pcb = cbTotal;
    return hr;
}


HRESULT HrRewindStream(LPSTREAM pstm)
{
    LARGE_INTEGER  liOrigin = {0,0};

    return pstm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\sendfile\smtpcb.h ===
// --------------------------------------------------------------------------------
// Smtpcb.h
// --------------------------------------------------------------------------------
#ifndef __SMTPCB_H
#define __SMTPCB_H

#include "imnxport.h"

HRESULT HrCreateSMTPTransport(ISMTPTransport **ppSMTP);

// --------------------------------------------------------------------------------
// CSMTPCallback Implementation
// --------------------------------------------------------------------------------
class CSMTPCallback : public ISMTPCallback
{
private:
    ULONG m_cRef;

public:
    // ----------------------------------------------------------------------------
    // Construction
    // ----------------------------------------------------------------------------
    CSMTPCallback(void);
    ~CSMTPCallback(void);

    // ----------------------------------------------------------------------------
    // IUnknown methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ----------------------------------------------------------------------------
    // ITransportCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnLogonPrompt(
            LPINETSERVER            pInetServer,
            IInternetTransport     *pTransport);

    STDMETHODIMP_(INT) OnPrompt(
            HRESULT                 hrError, 
            LPCTSTR                 pszText, 
            LPCTSTR                 pszCaption, 
            UINT                    uType,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnStatus(
            IXPSTATUS               ixpstatus,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnError(
            IXPSTATUS               ixpstatus,
            LPIXPRESULT             pIxpResult,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnProgress(
            DWORD                   dwIncrement,
            DWORD                   dwCurrent,
            DWORD                   dwMaximum,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnCommand(
            CMDTYPE                 cmdtype,
            LPSTR                   pszLine,
            HRESULT                 hrResponse,
            IInternetTransport     *pTransport);

    STDMETHODIMP OnTimeout(
            DWORD                  *pdwTimeout,
            IInternetTransport     *pTransport);

    // ----------------------------------------------------------------------------
    // ISMTPCallback methods
    // ----------------------------------------------------------------------------
    STDMETHODIMP OnResponse(
            LPSMTPRESPONSE              pResponse);
};

#endif // __SMTPCB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\sendfile\smtpcb.cpp ===
// --------------------------------------------------------------------------------
// Smtpcall.cpp
// --------------------------------------------------------------------------------
#define INC_OLE2
#include "windows.h"
#include "main.h"
#include "smtpcb.h"

extern void err(LPSTR); // main.cpp

// --------------------------------------------------------------------------------
// HrCreateSMTPTransport
// --------------------------------------------------------------------------------
HRESULT HrCreateSMTPTransport(ISMTPTransport **ppSMTP)
{
    // Locals
    HRESULT             hr;
    CSMTPCallback      *pCallback=NULL;

    // Create callback object
    pCallback = new CSMTPCallback();
    if (NULL == pCallback)
        return E_OUTOFMEMORY;

    // Load SMTP Transport
    hr = CoCreateInstance(CLSID_ISMTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_ISMTPTransport, (LPVOID *)ppSMTP);
    if (FAILED(hr))
    {
        pCallback->Release();
        return E_FAIL;
    }

    // InitNew
    hr = (*ppSMTP)->InitNew(NULL, pCallback);
    if (FAILED(hr))
    {
        pCallback->Release();
        return E_FAIL;
    }

    // Done
    pCallback->Release();
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::CSMTPCallback
// --------------------------------------------------------------------------------
CSMTPCallback::CSMTPCallback(void)
{
    m_cRef = 1;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::~CSMTPCallback
// --------------------------------------------------------------------------------
CSMTPCallback::~CSMTPCallback(void)
{
}

// --------------------------------------------------------------------------------
// CSMTPCallback::QueryInterface
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // Locals
    HRESULT hr=S_OK;

    // Bad param
    if (ppv == NULL)
    {
        hr = E_INVALIDARG;
        goto exit;
    }

    // Init
    *ppv=NULL;

    // IID_IUnknown
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;

    // IID_ISMTPCallback
    else if (IID_ISMTPCallback == riid)
        *ppv = (ISMTPCallback *)this;

    // If not null, addref it and return
    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        goto exit;
    }

    // No Interface
    hr = E_NOINTERFACE;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::AddRef
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPCallback::AddRef(void) 
{
	return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::Release
// --------------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSMTPCallback::Release(void) 
{
	if (0 != --m_cRef)
		return m_cRef;
	delete this;
	return 0;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnLogonPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnLogonPrompt(
        LPINETSERVER            pInetServer,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnPrompt
// --------------------------------------------------------------------------------
STDMETHODIMP_(INT) CSMTPCallback::OnPrompt(
        HRESULT                 hrError, 
        LPCTSTR                 pszText, 
        LPCTSTR                 pszCaption, 
        UINT                    uType,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnError(
        IXPSTATUS               ixpstatus,
        LPIXPRESULT             pIxpResult,
        IInternetTransport     *pTransport)
{
	char    szErr[256];

    if (FAILED(pIxpResult->hrResult))
		{
        if (!pIxpResult->pszResponse)
            wsprintf(szErr, "OnError was called: hr=0x%x", pIxpResult->hrResult);
        else
            wsprintf(szErr, "Error: %s (hr=0x%x)", pIxpResult->pszResponse, pIxpResult->hrResult);

        err(szErr);
        }
	return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnStatus
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnStatus(
        IXPSTATUS               ixpstatus,
        IInternetTransport     *pTransport)
{
    INETSERVER rServer;

    pTransport->GetServerInfo(&rServer);

    switch(ixpstatus)
    {
    case IXP_DISCONNECTED:
        PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, IXP_DISCONNECTED, 0);
        PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_QUIT, 0);
        break;
    }
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnProgress
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnProgress(
        DWORD                   dwIncrement,
        DWORD                   dwCurrent,
        DWORD                   dwMaximum,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnCommand
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnCommand(
        CMDTYPE                 cmdtype,                                            
        LPSTR                   pszLine,
        HRESULT                 hrResponse,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnTimeout
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnTimeout(
        DWORD                  *pdwTimeout,
        IInternetTransport     *pTransport)
{
    return S_OK;
}

// --------------------------------------------------------------------------------
// CSMTPCallback::OnResponse
// --------------------------------------------------------------------------------
STDMETHODIMP CSMTPCallback::OnResponse(
        LPSMTPRESPONSE              pResponse)
{
    switch(pResponse->command)
    {
    case SMTP_NONE:
        break;

    case SMTP_BANNER:
        break;

    case SMTP_CONNECTED:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_CONNECTED, 0);
        break;

    case SMTP_SEND_MESSAGE:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_SEND_MESSAGE, 0);
        break;

    case SMTP_EHLO:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_EHLO, 0);
        break;

    case SMTP_HELO:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_HELO, 0);
        break;

    case SMTP_MAIL:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_MAIL, 0);
        break;

    case SMTP_RCPT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_RCPT, 0);
        break;

    case SMTP_RSET:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_RSET, 0);
        break;

    case SMTP_QUIT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_QUIT, 0);
        break;

    case SMTP_DATA:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_DATA, 0);
        break;

    case SMTP_DOT:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_DOT, 0);
        break;

    case SMTP_SEND_STREAM:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_SEND_STREAM, 0);
        break;

    case SMTP_CUSTOM:
        if (pResponse->fDone)
            PostThreadMessage(GetCurrentThreadId(), g_msgSMTP, SMTP_CUSTOM, 0);
        break;
    }

	char    szErr[256];

    if (FAILED(pResponse->rIxpResult.hrResult))
		{
        if (!pResponse->rIxpResult.pszResponse)
            wsprintf(szErr, "OnReponse reported an error: hr=0x%x", pResponse->rIxpResult.hrResult);
        else
            wsprintf(szErr, "Error: %s (hr=0x%x)", pResponse->rIxpResult.pszResponse, pResponse->rIxpResult.hrResult);

        err(szErr);
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\cab\astub.cpp ===
/*
    Astub.cpp
*/

#include "windows.h"
#include "shlwapi.h"
#include "badstrfunctions.h"

#define ARRAYSIZE(_exp_) (sizeof(_exp_) / sizeof(_exp_[0]))

static LPCTSTR c_rgszEXEList[] = 
{
    TEXT("internal.exe\" /Q"),
    TEXT("wabinst.exe\" /R:N /Q"),
    TEXT("setup50.exe\" /app:oe /install /prompt"),
#if defined(_X86_)
    TEXT("polmod.exe\"  /R:N /Q"),
#endif
};


BOOL CreateProcessAndWait(LPTSTR pszExe, DWORD *pdwRetValue)
{
    BOOL fOK = FALSE;
    PROCESS_INFORMATION pi;
    STARTUPINFO sti;

    // Initialize
    ZeroMemory(&sti, sizeof(sti));
    sti.cb = sizeof(sti);
    *pdwRetValue = 0;

    if (CreateProcess(NULL, pszExe, NULL, NULL, FALSE, 0, NULL, NULL, &sti, &pi))
    {
        WaitForSingleObject(pi.hProcess, INFINITE);
        GetExitCodeProcess(pi.hProcess, pdwRetValue);
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);

        fOK = TRUE;
    }

    return fOK;
}


int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    TCHAR szExe[MAX_PATH];
    int iEnd, i;
    DWORD dw;
    BOOL fNeedReboot = FALSE;
    
    // Figure out the dir we are running from
    // Start with a quote so we can wrap the filename to deal with spaces
    // Trailing quote is embedded in the string to run.
    szExe[0] = TEXT('\"');
    GetModuleFileName(NULL, &szExe[1], ARRAYSIZE(szExe) - 1);
    PathRemoveFileSpec(&szExe[1]);
    iEnd = lstrlen(szExe);
    szExe[iEnd++] = '\\';

    // Run each package sequentially
    for (i = 0; i < ARRAYSIZE(c_rgszEXEList); i++)
    {
        // Append exe name and args to dir path
        StrCpyN(&szExe[iEnd], c_rgszEXEList[i], ARRAYSIZE(szExe)-iEnd);
        
        CreateProcessAndWait(szExe, &dw);

        if (ERROR_SUCCESS_REBOOT_REQUIRED == dw)
            fNeedReboot = TRUE;
    }
    
    return (fNeedReboot ? ERROR_SUCCESS_REBOOT_REQUIRED : S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\cab\makefile.inc ===
$O\athver.bat : athver.tmp $(BASEDIR)\public\sdk\inc\ntverp.h $(BASEDIR)\public\sdk\inc\ieverp.h
    cl /EP /I$(BASEDIR)\public\sdk\inc /DNASHVILLE /Tc athver.tmp > $@

# Create oe50intl.inx for INTL
$O\oe50intl.inx : msimn.src $O\athver.bat
    $O\athver msimn.src $@

$O\msimn.srx : msimn.src $O\athver.bat
    $O\athver msimn.src $@

$O\oe9x50.inx : $O\msimn.srx $O\inetcomm.reg $O\inetcomm.str $O\msoe.reg $O\msoe.str $O\oeimport.reg $O\oeimport.str $O\oemiglib.reg $O\oemiglib.str $O\directdb.reg $O\directdb.str $O\msimn.reg $O\msimn.str
    cl /EP /DWIN9X $(COPYPDB) $(DEFINEX86) /Tc $O\msimn.srx > $O\oe9x50.tmp
    copy $O\oe9x50.tmp /B +$O\msoe.str /B +$O\oeimport.str /B +$O\oemiglib.str /B +$O\directdb.str /B +$O\msimn.str /B +$O\inetcomm.str /B $@
    del $O\oe9x50.tmp

$O\msoe50.inx.nt : $O\msimn.srx
    cl /EP $(COPYPDB) $(DEFINEX86) /Tc $** > $@

$O\msoe50.inx.exe : $O\msimn.srx
    cl /EP $(COPYPDB) $(DEFINEX86) /DIE5 /DOESETUP_EXE /Tc $** > $@

$O\msoe50.inx.cab : $O\msimn.srx
    cl /EP $(COPYPDB) $(DEFINEX86) /DIE5 /Tc $** > $@

$O\oe9x50.inf : $O\oe9x50.inx
    $(CLEANINF) $** $@
    del $**

$O\msoe50.inf.nt : $O\msoe50.inx.nt
    $(CLEANINF) $** $@
    del $**

$O\msoe50.inf : $O\msoe50.inf.nt
    copy $** $@

$O\msoe50.inf.exe : $O\msoe50.inx.exe
    $(CLEANINF) $** $@
    del $**

$O\msoe50.inf.cab : $O\msoe50.inx.cab
    $(CLEANINF) $** $@
    del $**

$O\internal.inf : internal.inx
    $(CLEANINF) $** $@

$O\oecab.sed  : oecab.src
    cl /EP $(COPYPDB) $(DEFINEX86) /DOESETUP_DEV /Tc $** > $@

$O\oeexe.se2 : oecab.src
    cl /EP $(COPYPDB) $(DEFINEX86) /DOESETUP_DEV /DOESETUP_EXE /Tc $** > $@

$O\oeexe.sed : $O\oeexe.se2 $O\athver.bat
    $O\athver $O\oeexe.se2 $@
    del oeexe.se2

$O\oecabl.sed : oecab.src
    cl /EP /Tc $** > $@

$O\oeexel.se2 : oecab.src
    cl /EP /DOESETUP_EXE /Tc $** > $@

$O\oeexel.sed : $O\oeexel.se2 $O\athver.bat
    $O\athver $O\oeexel.se2 $@
    del $O\oeexel.se2

$O\inetcomm.reg : $(ATHROOT)\inetcomm\res\reg.src
    copy $** $@

$O\inetcomm.str : $(ATHROOT)\inetcomm\res\strings.src
    copy $** $@

$O\msoe.reg : $(ATHROOT)\mailnews\build\reg.src
    copy $** $@

$O\msoe.str : $(ATHROOT)\mailnews\build\strings.src
    copy $** $@

$O\oeimport.reg : $(ATHROOT)\import\reg.src
    copy $** $@

$O\oeimport.str : $(ATHROOT)\import\strings.src
    copy $** $@

$O\oemiglib.reg : $(ATHROOT)\oemiglib\reg.src
    copy $** $@

$O\oemiglib.str : $(ATHROOT)\oemiglib\strings.src
    copy $** $@

$O\directdb.reg : $(ATHROOT)\directdb\res\reg.src
    copy $** $@

$O\directdb.str : $(ATHROOT)\directdb\res\strings.src
    copy $** $@

$O\msimn.reg    : $(ATHROOT)\shell\reg.src $(ATHROOT)\shell\reg2.src 
    copy $(ATHROOT)\shell\reg.src /B + $(ATHROOT)\shell\reg2.src /B $@

$O\msimn.str    : $(ATHROOT)\shell\strings.src
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\win9xupg\detect.cpp ===
// ---------------------------------------------------------------------------
// DETECT.CPP
// ---------------------------------------------------------------------------
// Copyright (c) 1999 Microsoft Corporation
//
// Helper functions to detect installed versions of WAB / OE
//
// ---------------------------------------------------------------------------
#include "pch.hxx"
#include <strings.h>
#include "main.h"
#include "detect.h"

const LPCTSTR c_szVers[] = { c_szVERnone, c_szVER1_0, c_szVER1_1, c_szVER4_0, c_szVER5B1 };
const LPCTSTR c_szBlds[] = { c_szBLDnone, c_szBLD1_0, c_szBLD1_1, c_szBLD4_0, c_szBLD5B1 };

#define FORCE_DEL(_sz) { \
if ((dwAttr = GetFileAttributes(_sz)) != 0xFFFFFFFF) \
{ \
    SetFileAttributes(_sz, dwAttr & ~FILE_ATTRIBUTE_READONLY); \
    DeleteFile(_sz); \
} }


/*******************************************************************

  NAME:       TranslateVers
  
  SYNOPSIS:   Takes 5.0B1 versions and translates to bld numbers
    
********************************************************************/
BOOL TranslateVers(OUT SETUPVER *psv,
                   OUT LPTSTR pszVer,
                   IN  int cch)
{
    BOOL fTranslated = FALSE;

    // Validate params
    Assert(pszVer);
    
    // Initialize out params
    *psv = VER_NONE;
    
    // Special case builds 624-702
    if (!lstrcmp(pszVer, c_szVER5B1old))
    {
        StrCpyN(pszVer, c_szBlds[VER_5_0_B1], cch);
        *psv = VER_5_0_B1;
        fTranslated = TRUE;
    }   
    else
    {
        for (int i = VER_NONE; i < VER_5_0; i++)
        {
            if (!lstrcmp(c_szVers[i], pszVer))
            {
                StrCpyN(pszVer, c_szBlds[i], cch);
                *psv = (SETUPVER)i;
                fTranslated = TRUE;
                break;
            }
        }
    }
    
    return fTranslated;
}


/*******************************************************************

  NAME:       ConvertStrToVer
  
********************************************************************/
void ConvertStrToVer(IN  LPCSTR pszStr,
                     OUT WORD *pwVer)
{
    int i;
    
    // Validate Params
    Assert(pszStr);
    Assert(pwVer);
    
    // Initialize out param
    ZeroMemory(pwVer, 4 * sizeof(*pwVer));
    
    for (i=0; i<4; i++)
    {
        while (*pszStr && (*pszStr != ',') && (*pszStr != '.'))
        {
            pwVer[i] *= 10;
            pwVer[i] = (WORD)(pwVer[i] + (*pszStr - '0'));
            pszStr++;
        }
        if (*pszStr)
            pszStr++;
    }
    
    return;
}


/*******************************************************************

  NAME:       ConvertVerToEnum
  
********************************************************************/
SETUPVER ConvertVerToEnum(IN WORD *pwVer)
{
    SETUPVER sv;
    
    // Validate params
    Assert(pwVer);
    
    switch (pwVer[0])
    {
    case 0:
        sv = VER_NONE;
        break;
        
    case 1:
        if (0 == pwVer[1])
            sv = VER_1_0;
        else
            sv = VER_1_1;
        break;
        
    case 4:
        sv = VER_4_0;
        break;
        
    case 5:
        sv = VER_5_0;
        break;
        
    default:
        sv = VER_MAX;
    }
    
    return sv;
}


/*******************************************************************

  NAME:       GetASetupVer
  
********************************************************************/
BOOL GetASetupVer(IN  LPCTSTR pszGUID,
                  OUT WORD *pwVer,   // OPTIONAL
                  OUT LPTSTR pszVer, // OPTIONAL
                  IN  int cch)       // OPTIONAL
{
    BOOL fInstalled = FALSE;
    DWORD dwValue, cb;
    HKEY hkey;
    TCHAR szPath[MAX_PATH], szVer[64];
    
    // Validate Params
    Assert(pszGUID);
    
    // Initialize out params
    if (pszVer)
        pszVer[0] = 0;
    if (pwVer)
        ZeroMemory(pwVer, 4 * sizeof(*pwVer));
    
    wnsprintf(szPath, ARRAYSIZE(szPath), c_szPathFileFmt, c_szRegASetup, pszGUID);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPath, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(dwValue);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szIsInstalled, 0, NULL, (LPBYTE)&dwValue, &cb))
        {
            if (1 == dwValue)
            {
                cb = sizeof(szVer);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szValueVersion, 0, NULL, (LPBYTE)szVer, &cb))
                {
                    if (pwVer)
                        ConvertStrToVer(szVer, pwVer);
                    if (pszVer)
                        StrCpyN(pszVer, szVer, cch);
                    fInstalled = TRUE;
                }
            }
        }
        RegCloseKey(hkey);
    }
    
    return fInstalled;
}


/*******************************************************************

  NAME:       GetExePath
  
********************************************************************/
BOOL GetExePath(IN  LPCTSTR szExe,
                OUT TCHAR *szPath,
                IN  DWORD cch,
                IN  BOOL fDirOnly)
{
    BOOL  fRet = FALSE;
    HKEY  hkey;
    DWORD dwType, cb;
    TCHAR sz[MAX_PATH], szT[MAX_PATH];
    
    // Validate params
    Assert(szExe != NULL);
    Assert(szPath != NULL);
    Assert(cch);
        
    wnsprintf(sz, ARRAYSIZE(sz), c_szPathFileFmt, c_szAppPaths, szExe);
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(szT);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, fDirOnly ? c_szRegPath : NULL, 0, &dwType, (LPBYTE)szT, &cb) && cb)
        {
            if (REG_EXPAND_SZ == dwType)
            {
                cb = ExpandEnvironmentStrings(szT, szPath, cch);
                if (cb != 0 && cb <= cch)
                    fRet = TRUE;
            }
            else
            {
                Assert(REG_SZ == dwType);
                StrCpyN(szPath, szT, cch);
                fRet = TRUE;
            }
        }
        
        RegCloseKey(hkey);
    }
    
    return(fRet);
}


/*******************************************************************

  NAME:       GetFileVer
  
********************************************************************/
HRESULT GetFileVer(IN  LPCTSTR pszExePath,
                   OUT LPTSTR pszVer,
                   IN  DWORD cch)
{
    DWORD   dwVerInfoSize, dwVerHnd;
    HRESULT hr = S_OK;
    LPSTR   pszInfo = NULL;
    LPSTR   pszVersion;
    LPWORD  pwTrans;
    TCHAR   szGet[MAX_PATH];
    UINT    uLen;
    
    // Validate Parameters
    Assert(pszExePath);
    Assert(pszVer);
    Assert(cch);
    
    // Initialize out parameters
    pszVer[0] = TEXT('\0');
    
    // Allocate space for version info block
    if (0 == (dwVerInfoSize = GetFileVersionInfoSize(const_cast<LPTSTR> (pszExePath), &dwVerHnd)))
    {
        hr = E_FAIL;
        TraceResult(hr);
        goto exit;
    }
    IF_NULLEXIT(pszInfo = (LPTSTR)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, dwVerInfoSize));
    
    // Get Version info block
    IF_FALSEEXIT(GetFileVersionInfo(const_cast<LPTSTR> (pszExePath), dwVerHnd, dwVerInfoSize, pszInfo), E_FAIL);
    
    // Figure out language for version info
    IF_FALSEEXIT(VerQueryValue(pszInfo, "\\VarFileInfo\\Translation", (LPVOID *)&pwTrans, &uLen) && uLen >= (2 * sizeof(WORD)), E_FAIL);
    
    // Set up buffer with correct language and get version
    wnsprintf(szGet, ARRAYSIZE(szGet), "\\StringFileInfo\\%04X%04X\\FileVersion", pwTrans[0], pwTrans[1]);
    IF_FALSEEXIT(VerQueryValue(pszInfo, szGet, (LPVOID *)&pszVersion, &uLen) && uLen, E_FAIL);
    
    // Copy version out of version block, into out param
    Assert(pszVersion);
    StrCpyN(pszVer, pszVersion, cch);
    
exit:
    if (pszInfo)
        GlobalFree((HGLOBAL)pszInfo);
    
    return hr;
}


/*******************************************************************

  NAME:       GetExeVer
  
********************************************************************/
HRESULT GetExeVer(IN  LPCTSTR pszExeName,
                  OUT WORD *pwVer,   // OPTIONAL
                  OUT LPTSTR pszVer, // OPTIONAL
                  IN  int cch)       // OPTIONAL
{
    HRESULT hr = S_OK;
    TCHAR   szPath[MAX_PATH];
    TCHAR   szVer[64];
    
    // Validate params
    Assert(pszExeName);
    
    // Initialize out params
    if (pszVer)
    {
        Assert(cch);
        pszVer[0] = 0;
    }
    if (pwVer)
        // Version is an array of 4 words 
        ZeroMemory(pwVer, 4 * sizeof(*pwVer));
    
    // Find the exe
    IF_FALSEEXIT(GetExePath(pszExeName, szPath, ARRAYSIZE(szPath), FALSE), E_FAIL);
    
    // Get the string representation of the version
    IF_FAILEXIT(hr = GetFileVer(szPath, szVer, ARRAYSIZE(szVer)));
    
    // Fill in out params
    if (pwVer)
        ConvertStrToVer(szVer, pwVer);
    if (pszVer)
        StrCpyN(pszVer, szVer, cch);
    
exit:
    return hr;
}


/*******************************************************************

  NAME:       DetectPrevVer
  
    SYNOPSIS:   Called when there is no ver info for current app
    
********************************************************************/
SETUPVER DetectPrevVer(IN  SETUPAPP saApp,
                       OUT LPTSTR pszVer,
                       IN  int cch)
{
    DWORD       dwAttr;
    SETUPVER    sv;
    TCHAR       szVer[VERLEN] = {0};
    TCHAR       szFile[MAX_PATH];
    TCHAR       szFile2[MAX_PATH];
    UINT        uLen, uLen2;
    WORD        wVer[4];
    
    // Validate params
    Assert(pszVer);
    
    uLen = GetSystemDirectory(szFile, ARRAYSIZE(szFile));
    if ('\\' != *CharPrev(szFile, szFile + uLen))
        szFile[uLen++] = '\\';
    
    switch (saApp)
    {
    case APP_OE:
        StrCpyN(&szFile[uLen], c_szMAILNEWS, ARRAYSIZE(szFile) - uLen);
        
        // See what version we've told IE Setup, is installed
        // Or what version msimn.exe is (to cover the case in which the 
        // ASetup info has been damaged - OE 5.01 80772)
        if (GetASetupVer(c_szOEGUID, wVer, szVer, ARRAYSIZE(szVer)) ||
            SUCCEEDED(GetExeVer(c_szOldMainExe, wVer, szVer, ARRAYSIZE(szVer))))
            sv = ConvertVerToEnum(wVer);
        else
        {
            // 1.0 or none
            
            // Does mailnews.dll exist?
            if(0xFFFFFFFF == GetFileAttributes(szFile))
                sv = VER_NONE;
            else
                sv = VER_1_0;
        }

        // If active setup, these will be rollably deleted
        FORCE_DEL(szFile);
        break;
        
    case APP_WAB:
        StrCpyN(&szFile[uLen], c_szWAB32, ARRAYSIZE(szFile) - uLen);
        uLen2 = GetWindowsDirectory(szFile2, ARRAYSIZE(szFile2));
        if ('\\' != *CharPrev(szFile2, szFile2 + uLen2))
            szFile2[uLen2++] = '\\';
        StrCpyN(&szFile2[uLen2], c_szWABEXE, ARRAYSIZE(szFile2) - uLen2);

        if (GetASetupVer(c_szWABGUID, wVer, szVer, ARRAYSIZE(szVer)))
        {
            // 5.0 or later
            if (5 == wVer[0])
                sv = VER_5_0;
            else
                sv = VER_MAX;
        }
        else if (GetASetupVer(c_szOEGUID, wVer, szVer, ARRAYSIZE(szVer)) ||
                 SUCCEEDED(GetExeVer(c_szOldMainExe, wVer, szVer, ARRAYSIZE(szVer))))
        {
            // 4.0x or 5.0 Beta 1
            if (5 == wVer[0])
                sv = VER_5_0_B1;
            else if (4 == wVer[0])
                sv = VER_4_0;
            else
                sv = VER_MAX;
        }
        else
        {
            // 1.0, 1.1 or none
            
            // WAB32.dll around?
            if(0xFFFFFFFF == GetFileAttributes(szFile))
                sv = VER_NONE;
            else
            {
                // \Windows\Wab.exe around?
                if(0xFFFFFFFF == GetFileAttributes(szFile2))
                    sv = VER_1_0;
                else
                    sv = VER_1_1;
            }
        }
        
        // If active setup, these will be rollably deleted
        FORCE_DEL(szFile);
        FORCE_DEL(szFile2);
        break;
        
    default:
        sv = VER_NONE;
    }
    
    // Figure out the build number for this ver
    if (szVer[0])
        // Use real ver
        StrCpyN(pszVer, szVer, cch);
    else
        // Fake Ver
        StrCpyN(pszVer, c_szBlds[sv], cch);
    
    return sv;
}


/*******************************************************************

  NAME:       LookForApp
  
********************************************************************/
BOOL LookForApp(IN  SETUPAPP saApp,
                OUT LPTSTR pszVer,
                IN  int cch,
                OUT SETUPVER svInterimVer) 
{
    BOOL        fReg = FALSE;
    DWORD       cb;
    HKEY        hkey;
    LPCTSTR     pszVerInfo;
    SETUPVER    svCurr = VER_MAX, svPrev = VER_MAX;
    TCHAR       szCurrVer[VERLEN]={0};
    TCHAR       szPrevVer[VERLEN]={0};
    LPTSTR      psz = szCurrVer;
    WORD        wVer[4];

    // Validate Params
    Assert(pszVer);
    Assert(cch);

    // Initialize out params
    svInterimVer = VER_NONE;
    *pszVer = TEXT('\0');

    switch (saApp)
    {
    case APP_OE:
        pszVerInfo = c_szRegVerInfo;
        break;

    case APP_WAB:
        pszVerInfo = c_szRegWABVerInfo;
        break;

    default:
        // Should never happen
        AssertFalseSz("Looking up an unknown app?");
        goto exit;
    }
        
    
    // Always try to use the version info
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszVerInfo, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(szPrevVer);
        RegQueryValueEx(hkey, c_szRegPrevVer, NULL, NULL, (LPBYTE)szPrevVer, &cb);
        // Change to a bld # if needed
        if (!TranslateVers(&svPrev, szPrevVer, ARRAYSIZE(szPrevVer)))
        {
            // Convert bld to enum
            ConvertStrToVer(szPrevVer, wVer);
            svPrev = ConvertVerToEnum(wVer);
        }
        
        // If version info shows that a ver info aware version was uninstalled, throw out the info
        // and redetect
        if (VER_NONE == svPrev)
            // Sniff the machine for current version
            svCurr = DetectPrevVer(saApp, szCurrVer, ARRAYSIZE(szCurrVer));
        else
        {
            // There was previous version reg goo - and it's legit
            fReg = TRUE;
            
            cb = sizeof(szCurrVer);
            RegQueryValueEx(hkey, c_szRegCurrVer, NULL, NULL, (LPBYTE)szCurrVer, &cb);
            // Change to a bld # if needed
            if (!TranslateVers(&svCurr, szCurrVer, ARRAYSIZE(szCurrVer)))
            {
                // Convert bld to enum
                ConvertStrToVer(szCurrVer, wVer);
                svCurr = ConvertVerToEnum(wVer);
            }
        }
        
        RegCloseKey(hkey);
    }
    else 
    {
        // Sniff the machine for current version
        svCurr = DetectPrevVer(saApp, szCurrVer, ARRAYSIZE(szCurrVer));
    }
    
    // Should we change the previous version entry?
    if (VER_5_0 != svCurr)
    {
        // Know this is B1 OE if we translated
        // Know this is B1 WAB if we detected it
        if (VER_5_0_B1 == svCurr)
        {
            svInterimVer = svCurr;
            
            // Did we read a previous value?
            if (fReg)
                // As there were reg entries, just translate the previous entry
                psz = szPrevVer;
            else
            {
                // We don't have a bld number and yet we are B1, better be the WAB
                Assert(APP_WAB == saApp);
            
                // Peek at OE's ver info
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegVerInfo, 0, KEY_QUERY_VALUE, &hkey))
                {
                    cb = sizeof(szPrevVer);
                    // Read a build or a string
                    RegQueryValueExA(hkey, c_szRegPrevVer, NULL, NULL, (LPBYTE)szPrevVer, &cb);
                    // If it's a string, convert it to a build
                    TranslateVers(&svPrev, szPrevVer, ARRAYSIZE(szPrevVer));
                
                    // We'll use the build (translated or direct)
                    psz = szPrevVer;
                    RegCloseKey(hkey);
                }
            }
        }
    
        // Fill in out param
        StrCpyN(pszVer, psz, cch);
    }

exit:
    return (VER_NONE != svCurr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\win9xupg\resource.h ===
// ---------------------------------------------------------------------------
// RESOURCE.H
// ---------------------------------------------------------------------------
// Copyright (c) 1999 Microsoft Corporation
//
// ---------------------------------------------------------------------------
#pragma once

#define CCHMAX_STRINGRES 512

// String Resource IDs
#define IDS_FIRST       1000

#define IDS_PRODUCTID       (IDS_FIRST + 1)
#define IDS_COMPANY         (IDS_FIRST + 2)
#define IDS_PHONE           (IDS_FIRST + 3)
#define IDS_URL             (IDS_FIRST + 4)
#define IDS_INSTRUCTIONS    (IDS_FIRST + 5)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\win9xupg\detect.h ===
// ---------------------------------------------------------------------------
// DETECT.H
// ---------------------------------------------------------------------------
// Copyright (c) 1999 Microsoft Corporation
//
// Helper functions to detect installed versions of WAB / OE
//
// ---------------------------------------------------------------------------
#pragma once

#include <wizdef.h>
BOOL LookForApp(SETUPAPP app, LPTSTR pszVer, int cch, SETUPVER svInterimVer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\win9xupg\strings.cpp ===
// ---------------------------------------------------------------------------
// STRINGS.CPP
// ---------------------------------------------------------------------------
// Copyright (c) 1999 Microsoft Corporation
//
// Strings
//
// ---------------------------------------------------------------------------
#include "pch.hxx"
#define DEFINE_STRING_CONSTANTS
#include <strings.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\win9xupg\main.cpp ===
// ---------------------------------------------------------------------------
// MAIN.CPP
// ---------------------------------------------------------------------------
// Copyright (c) 1999 Microsoft Corporation
//
// Migration DLL for Outlook Express and Windows Address Book moving from
// Win9X to NT5.
//
// ---------------------------------------------------------------------------
#include "pch.hxx"
#include <setupapi.h>
#include <strings.h>
#include "resource.h"
#include "detect.h"
#include "main.h"

// Used for resources
static HMODULE s_hInst = NULL;

// These settings are init'd during Initialize9x and used later
static LPSTR s_pszMigratePath           = NULL;
static TCHAR s_szOEVer[VERLEN]          = "";
static SETUPVER s_svOEInterimVer        = VER_NONE;
static TCHAR s_szWABVer[VERLEN]         = "";
static SETUPVER s_svWABInterimVer       = VER_NONE;

static const char c_szMigrateINF[]      = "migrate.inf";

// Dll Entry point
INT WINAPI DllMain(IN HINSTANCE hInstance,
                   IN DWORD     dwReason,
                      PVOID     pvReserved)
{
    UNREFERENCED_PARAMETER(pvReserved);

    // Validate Params
    Assert(hInstance);

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH :
        DisableThreadLibraryCalls(hInstance);

        // Open Error Log.  FALSE indicates that any current
        // log is not deleted.  Use SetupErrorLog() to record
        // any errors encountered within the Migration DLL.
        //SetupOpenLog(FALSE);

        // Need this global to figure out the others
        s_hInst = hInstance;
        break;

    case DLL_PROCESS_DETACH :
        //SetupCloseLog();
        if (s_pszMigratePath)
        {
            GlobalFree(s_pszMigratePath);
            s_pszMigratePath = NULL;
        }
        break;

    default:
        break;
    }

    return TRUE;
}

////////////////////////////////////
// QueryVersion()
EXPORT_FUNCTION LONG CALLBACK QueryVersion(OUT LPCSTR       *ppcszProductID,
                                           OUT UINT         *pnDllVersion,
                                           OUT INT          **ppnCodePageArray, // Optional
                                           OUT LPCSTR       *ppcszExeNamesBuf,  // Optional
                                           OUT VENDORINFO   **ppVendorInfo)
{
    // These need to be static as their addresses are given to setup
    // - ie. they need to live as long as they can.
    static CHAR s_szProductID[CCHMAX_STRINGRES]       = "";
    static CHAR s_szCompany[CCHMAX_STRINGRES]         = "";
    static CHAR s_szPhone[CCHMAX_STRINGRES]           = "";
    static CHAR s_szURL[CCHMAX_STRINGRES]             = "";
    static CHAR s_szInstructions[CCHMAX_STRINGRES]    = "";
    static VENDORINFO s_VendInfo;
    
    // Validate Params
    Assert(ppcszProductID);
    Assert(pnDllVersion);
    Assert(ppnCodePageArray);
    Assert(ppcszExeNamesBuf);
    Assert(ppVendorInfo);

    // Validate global state
    Assert(s_hInst);

    // Initialize statics
    LoadStringA(s_hInst, IDS_PRODUCTID,     s_szProductID,     ARRAYSIZE(s_szProductID));
    LoadStringA(s_hInst, IDS_COMPANY,       s_szCompany,       ARRAYSIZE(s_szCompany));
    LoadStringA(s_hInst, IDS_PHONE,         s_szPhone,         ARRAYSIZE(s_szPhone));
    LoadStringA(s_hInst, IDS_URL,           s_szURL,           ARRAYSIZE(s_szURL));
    LoadStringA(s_hInst, IDS_INSTRUCTIONS,  s_szInstructions,  ARRAYSIZE(s_szInstructions));

    StrCpyN(s_VendInfo.CompanyName,        s_szCompany,       ARRAYSIZE(s_VendInfo.CompanyName));
    StrCpyN(s_VendInfo.SupportNumber,      s_szPhone,         ARRAYSIZE(s_VendInfo.SupportNumber));
    StrCpyN(s_VendInfo.SupportUrl,         s_szURL,           ARRAYSIZE(s_VendInfo.SupportNumber));
    StrCpyN(s_VendInfo.InstructionsToUser, s_szInstructions,  ARRAYSIZE(s_VendInfo.InstructionsToUser));

    // Return information
    *ppcszProductID = s_szProductID;
    *pnDllVersion = MIGDLL_VERSION;

    // We don't have locale-specific migration work
    *ppnCodePageArray = NULL;
    
    // We don't need setup to locate any exes for us
    *ppcszExeNamesBuf = NULL;

    *ppVendorInfo = &s_VendInfo;

    return ERROR_SUCCESS;
}

////////////////////////////////////
// Initialize9x()
EXPORT_FUNCTION LONG CALLBACK Initialize9x (IN LPCSTR   pszWorkingDir,
                                            IN LPCSTR   pszSourceDirs,
                                               LPVOID   pvReserved)
{
    BOOL fWABInstalled = FALSE;
    BOOL fOEInstalled  = FALSE;
    INT  nLen;
    INT  nLenEnd;
    INT  nLenSlash;
    LONG lRet          = ERROR_NOT_INSTALLED;
    
    UNREFERENCED_PARAMETER(pszSourceDirs);
    UNREFERENCED_PARAMETER(pvReserved);

    // Validate Params
    Assert(pszWorkingDir);
    Assert(pszSourceDirs);
    
    // See if either the WAB or OE is installed
    fOEInstalled  = LookForApp(APP_OE, s_szOEVer, ARRAYSIZE(s_szOEVer), s_svOEInterimVer);
    fWABInstalled = LookForApp(APP_WAB, s_szWABVer, ARRAYSIZE(s_szWABVer), s_svWABInterimVer);

    // If OE is installed, WAB better be too
    Assert(!fOEInstalled || fWABInstalled);

    if (fWABInstalled || fOEInstalled)
    {
        // Validate global state
        Assert(NULL == s_pszMigratePath);

        // ---- Figure out largest needed size and slash terminate

        // Parameter length (without null)
        nLenEnd = lstrlenA(pszWorkingDir);
        
        // Space for a slash
        if (*CharPrev(pszWorkingDir, pszWorkingDir + nLenEnd) != '\\')
            nLenSlash = 1;
        else 
            nLenSlash = 0;

        // Space for migrate.inf and a NULL (null is incl in ARRAYSIZE)
        nLen = nLenEnd + nLenSlash + ARRAYSIZE(c_szMigrateINF);

        // Allocate the space
        s_pszMigratePath = (LPSTR)GlobalAlloc(GMEM_FIXED, nLen * sizeof(*s_pszMigratePath));
        if (NULL != s_pszMigratePath)
        {
            // Build path from working dir, slash and filename
            StrCpyN(s_pszMigratePath, pszWorkingDir, nLen);
            if (nLenSlash)
                s_pszMigratePath[nLenEnd] = '\\';

            StrCpyN(&s_pszMigratePath[nLenEnd+nLenSlash], c_szMigrateINF, nLen - (nLenEnd+nLenSlash));

            lRet = ERROR_SUCCESS;
        }
    }

    // Return ERROR_NOT_INSTALLED to stop further calls to this DLL.
    return lRet;
}


////////////////////////////////////
// MigrateUser9x()
EXPORT_FUNCTION  LONG CALLBACK MigrateUser9x (IN HWND         hwndParent,
                                              IN LPCSTR       pcszAnswerFile,
                                              IN HKEY         hkeyUser,
                                              IN LPCSTR       pcszUserName,
                                                 LPVOID       pvReserved)
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(pcszAnswerFile);
    UNREFERENCED_PARAMETER(hkeyUser);
    UNREFERENCED_PARAMETER(pcszUserName);
    UNREFERENCED_PARAMETER(pvReserved);

    // Validate Params
    Assert(pcszAnswerFile);
    Assert(hkeyUser);
    Assert(pcszUserName);

    // We will migrate per-user settings in the per-user stub
    // Nothing to do now
    return ERROR_NOT_INSTALLED;
}


////////////////////////////////////
// MigrateSystem9x()
EXPORT_FUNCTION  LONG CALLBACK MigrateSystem9x(IN HWND      hwndParent,
                                               IN LPCSTR    pcszAnswerFile,
                                                  LPVOID    pvReserved)
{
    UNREFERENCED_PARAMETER(hwndParent);
    UNREFERENCED_PARAMETER(pcszAnswerFile);
    UNREFERENCED_PARAMETER(pvReserved);

    // Validate Params
    Assert(pcszAnswerFile);

    // Validate global state
    Assert(s_pszMigratePath);
    Assert(s_pszMigratePath[0]);

    // Record Version info
    if (s_szOEVer[0])
        WritePrivateProfileString("Outlook-Express", "PreviousVer", s_szOEVer, s_pszMigratePath);
    if (VER_NONE != s_svOEInterimVer)
        WritePrivateProfileStruct("Outlook-Express", "InterimVer", 
                                  (LPVOID)&s_svOEInterimVer, sizeof(s_svOEInterimVer), s_pszMigratePath);
    if (s_szWABVer[0])
        WritePrivateProfileString("Windows-Address-Book", "PreviousVer", s_szWABVer, s_pszMigratePath);
    if (VER_NONE != s_svWABInterimVer)
        WritePrivateProfileStruct("Windows-Address-Book", "InterimVer", 
                                  (LPVOID)&s_svWABInterimVer, sizeof(s_svWABInterimVer), s_pszMigratePath);

    // Modify Migrate.INF appropriately.  Consider adding entries to
    // the following sections :
    // [HANDLED] - Files, Paths, and Registry entries you migrate (causing setup to leave files and paths alone; registry entries placed here are not copied into the NT5 registry automatically)
    // [MOVED] - Indicate Files that are moved, renamed, or deleted.  Setup updates shell links to these files.
    // [INCOMPATIBLE MESSAGES] - Used to create a incompatibility report for this application.  User will be provided the opportunity to read this before committing to the upgrade.

    // TODO : return ERROR_NOT_INSTALLED if your application requires no system wide changes.
    return (s_szOEVer[0] || s_szWABVer[0]) ? ERROR_SUCCESS : ERROR_NOT_INSTALLED;
}


////////////////////////////////////
// InitializeNT()
EXPORT_FUNCTION LONG CALLBACK InitializeNT (IN LPCWSTR  pcwszWorkingDir,
                                            IN LPCWSTR  pcwszSourceDirs,
                                               LPVOID   pvReserved)
{
    int cb, cch;
    LONG lErr = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(pcwszSourceDirs);
    UNREFERENCED_PARAMETER(pvReserved);   

    // Validate Params
    Assert(pcwszWorkingDir);
    Assert(pcwszSourceDirs);

    // Validate global state
    Assert(NULL == s_pszMigratePath);
    
    // Strings sent on NT side of setup are Unicode
    // How big a buffer do we need?
    cb = WideCharToMultiByte(CP_ACP, 0, pcwszWorkingDir, -1, NULL, 0, NULL, NULL);
    if (0 == cb)
    {
        // This will fail the entire OE/WAB migration
        lErr = GetLastError();
        goto exit;
    }
    
    // Try to alloc the buffer
    // Allow space for possible slash (+1) and migrate.inf (ARRAYSIZE - 1 for null)
    // NULL was included in WideCharToMultiByte's count
    s_pszMigratePath = (LPSTR)GlobalAlloc(GMEM_FIXED, cb + 
                                          ((1+(ARRAYSIZE(c_szMigrateINF)-1))*sizeof(*s_pszMigratePath)));

    // Set cch to the number of characters that can be contained in s_pszMigratePath
    cch = cb / sizeof(*s_pszMigratePath) + (1+(ARRAYSIZE(c_szMigrateINF)-1));
    if (NULL == s_pszMigratePath)
    {
        // This will fail the entire OE/WAB migration
        lErr = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    // Do the conversion
    cb = WideCharToMultiByte(CP_ACP, 0, pcwszWorkingDir, -1, s_pszMigratePath, cb, NULL, NULL);
    if (0 == cb)
    {
        // This will fail the entire OE/WAB migration
        lErr = GetLastError();
        goto exit;
    }
    
    // WideCharToMultiByte includes NULL in count
    cb--;

    // Append a backslash if needed
    if ('\\' != *CharPrev(s_pszMigratePath, s_pszMigratePath + cb))
        s_pszMigratePath[cb++] = '\\';

    // Append the name of the inf
    StrCpyN(&s_pszMigratePath[cb], "migrate.inf", cch - cb); 

exit:
    return lErr;
}


////////////////////////////////////
// MigrateUserNT()
EXPORT_FUNCTION LONG CALLBACK MigrateUserNT(IN HINF         hinfAnswerFile,
                                            IN HKEY         hkeyUser,
                                            IN LPCWSTR      pcwszUserName,
                                               LPVOID       pvReserved)
{
    UNREFERENCED_PARAMETER(hinfAnswerFile);
    UNREFERENCED_PARAMETER(hkeyUser);
    UNREFERENCED_PARAMETER(pcwszUserName);
    UNREFERENCED_PARAMETER(pvReserved);

    // Validate Params
    Assert(hinfAnswerFile);
    Assert(hkeyUser);

    // pcwszUserName can be NULL
    
    // We will migrate per-user settings in the per-user stub
    // Nothing to do now
    return ERROR_SUCCESS;
}


////////////////////////////////////
// MigrateSystemNT()
EXPORT_FUNCTION LONG CALLBACK MigrateSystemNT(IN HINF       hinfAnswerFile,
                                                 LPVOID     pvReserved)
{
    HKEY hkey;
    DWORD dwDisp;

    UNREFERENCED_PARAMETER(hinfAnswerFile);
    UNREFERENCED_PARAMETER(pvReserved);

    // Validate params
    Assert(hinfAnswerFile);

    // Validate global state
    Assert(s_pszMigratePath);
    Assert(s_pszMigratePath[0]);

    // Read information we gathered from Win9x
    GetPrivateProfileString("Outlook-Express", "PreviousVer", "", s_szOEVer, ARRAYSIZE(s_szOEVer), s_pszMigratePath);
    GetPrivateProfileStruct("Outlook-Express", "InterimVer", (LPVOID)&s_svOEInterimVer, sizeof(s_svOEInterimVer), s_pszMigratePath);
    GetPrivateProfileString("Windows-Address-Book", "PreviousVer", "", s_szWABVer, ARRAYSIZE(s_szWABVer), s_pszMigratePath);
    GetPrivateProfileStruct("Windows-Address-Book", "InterimVer", (LPVOID)&s_svWABInterimVer, sizeof(s_svWABInterimVer), s_pszMigratePath);

    // Update machine with information
    if (s_szOEVer[0])
    {
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szRegVerInfo, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dwDisp))
        {
            RegSetValueEx(hkey, c_szRegPrevVer, 0, REG_SZ, (LPBYTE)s_szOEVer, lstrlenA(s_szOEVer)+1);
            if (s_svOEInterimVer != VER_NONE)
                RegSetValueEx(hkey, c_szRegInterimVer, 0, REG_DWORD, (LPBYTE)&s_svOEInterimVer, sizeof(s_svOEInterimVer));
            
            RegCloseKey(hkey);
        }
    }
    if (s_szWABVer[0])
    {
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szRegWABVerInfo, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dwDisp))
        {
            RegSetValueEx(hkey, c_szRegPrevVer, 0, REG_SZ, (LPBYTE)s_szWABVer, lstrlenA(s_szWABVer)+1);
            if (s_svWABInterimVer != VER_NONE)
                RegSetValueEx(hkey, c_szRegInterimVer, 0, REG_DWORD, (LPBYTE)&s_svWABInterimVer, sizeof(s_svWABInterimVer));
            
            RegCloseKey(hkey);
        }
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\win9xupg\util.h ===
// ---------------------------------------------------------------------------
// UTIL.H
// ---------------------------------------------------------------------------
// Copyright (c) 1999 Microsoft Corporation
//
// Helper functions to detect installed versions of WAB / OE
//
// ---------------------------------------------------------------------------
#pragma once

HRESULT GetExeVer(LPCTSTR pszExeName, WORD *pwVer, LPTSTR pszVer, int cch);
HRESULT GetFileVer(LPCTSTR pszExePath, LPTSTR pszVer, DWORD cch);
void GetVers(WORD *pwVerCurr,WORD *pwVerPrev);
BOOL GoodEnough(WORD *pwVerGot, WORD *pwVerNeed);
void ConvertStrToVer(LPCSTR pszStr, WORD *pwVer);
SETUPVER ConvertVerToEnum(WORD *pwVer);
void GetVerInfo(SETUPVER *psvCurr, SETUPVER *psvPrev);
BOOL InterimBuild(SETUPVER *psv);
BOOL GetASetupVer(LPCTSTR pszGUID, WORD *pwVer, LPTSTR pszVer, int cch);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\win9xupg\main.h ===
// ---------------------------------------------------------------------------
// MAIN.H
// ---------------------------------------------------------------------------
// Copyright (c) 1999 Microsoft Corporation
//
// Migration DLL for Outlook Express and Windows Address Book moving from
// Win9X to NT5.  Modeled after source generated from the Migration Dll 
// AppWizard.
//
// ---------------------------------------------------------------------------
#pragma once
#include <wizdef.h>

// Version returned from QueryVersion
#define MIGDLL_VERSION 1

#ifndef ARRAYSIZE
#define ARRAYSIZE(_x_) (sizeof(_x_) / sizeof(_x_[0]))
#endif // ARRAYSIZE

// _declspec(dllexport) expressed through .def file
#define EXPORT_FUNCTION extern "C"

// VENDORINFO structure for use in QueryVersion
typedef struct 
{
    CHAR CompanyName[256];
    CHAR SupportNumber[256];
    CHAR SupportUrl[256];
    CHAR InstructionsToUser[1024];
} VENDORINFO, *PVENDORINFO;

int WINAPI DllMain (HINSTANCE hInstance, DWORD fdwReason, PVOID pvReserved);

// Functions in staticrt.lib
//STDAPI_(LPTSTR) PathAddBackslash(LPTSTR lpszPath);
//STDAPI_(LPTSTR) PathRemoveFileSpec(LPTSTR pszPath);

// 
// Required Exported Functions for MIGRATION DLL
//
EXPORT_FUNCTION LONG CALLBACK QueryVersion (OUT LPCSTR      *ProductID,
                                            OUT LPUINT      DllVersion,
                                            OUT LPINT       *CodePageArray, //Optional
                                            OUT LPCSTR      *ExeNamesBuf,   //Optional
                                            OUT PVENDORINFO *VendorInfo);

EXPORT_FUNCTION LONG CALLBACK Initialize9x (IN LPCSTR       WorkingDirectory,
                                            IN LPCSTR       SourceDirectories,
                                               LPVOID       Reserved);

EXPORT_FUNCTION LONG CALLBACK MigrateUser9x(IN HWND         ParentWnd,
                                            IN LPCSTR       AnswerFile,
                                            IN HKEY         UserRegKey,
                                            IN LPCSTR       UserName,
                                               LPVOID       Reserved);

EXPORT_FUNCTION LONG CALLBACK MigrateSystem9x(IN HWND       ParentWnd,
                                              IN LPCSTR     AnswerFile,
                                                 LPVOID     Reserved);

EXPORT_FUNCTION LONG CALLBACK InitializeNT (IN LPCWSTR      WorkingDirectory,
                                            IN LPCWSTR      SourceDirectories,
                                               LPVOID       Reserved);

EXPORT_FUNCTION LONG CALLBACK MigrateUserNT (IN HINF        AnswerFileHandle,
                                             IN HKEY        UserRegKey,
                                             IN LPCWSTR     UserName,
                                                LPVOID      Reserved);

EXPORT_FUNCTION LONG CALLBACK MigrateSystemNT (IN HINF      AnswerFileHandle,
                                                  LPVOID    Reserved);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\wizard\ids.h ===
#define CCHMAX_RES 255

// string resource IDs
#define IDS_APPNAME_OE                  1000
#define IDS_UNINSTALL_OUTLOOK_NEWS      1001
#define IDS_SYS_NO_MEET_REQUIREMENTS    1002
#define IDS_APPLICATION_DATA            1003
#define IDS_UNINSTALL_COMPLETE          1005
#define IDS_UNINSTALL_OE                1006
#define IDS_ATHENA                      1007
#define IDS_LAUNCH_ATHENA               1008
#define IDS_MAIL                        1009
#define IDS_NEWS                        1010
#define IDS_OLD_NEWS                    1011
#define IDS_OLD_MAIL                    1012
#define IDS_WAB                         1013
#define IDS_IE_SUITE                    1014
#define IDS_MAIL_RECIPIENT              1016
#define IDS_MAIL_SIG                    1017
#define IDS_NEWS_SIG                    1018
#define IDS_NO_ADMIN_PRIVILEGES         1019
#define IDS_NO_UNINSTALL                1020
#define IDS_RESTARTYESNO                1021
#define IDS_ERR_NOALLOC                 1023
#define IDS_ERR_INIT                    1024
#define IDS_ERR_ADVLOAD                 1025
#define IDS_ERR_ADVCORR                 1026
#define IDS_APPNAME_WAB                 1027
#define IDS_UNINSTALL_WAB               1028
//#define IDS_WARN_OVER5B1                1029
#define IDS_WARN_NOASETUPVER            1030
//#define IDS_MAINUSER                    1031
#define IDS_DIR_SERVICES                1032
#define IDS_DIR_STAT                    1033
#define IDS_DIR_HELP                    1034
#define IDS_DIR_SYSTEM                  1035
#define IDS_URLDLLMAILTONAME            1036
#define IDS_URLDLLNEWSNAME              1037
#define IDS_WARN_OL                     1206
#define IDS_OEDTOP_TIP                  1038
#define IDS_WARN_OLDIE                  1039
#define IDS_WARN_PHONE                  1040
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\win9xupg\util.cpp ===
// ---------------------------------------------------------------------------
// UTIL.CPP
// ---------------------------------------------------------------------------
// Copyright (c) 1999 Microsoft Corporation
//
// Helper functions
//
// ---------------------------------------------------------------------------
#include "util.h"
#include "strings.h"

/****************************************************************************

  NAME:       GoodEnough
  
    SYNOPSIS:   Returns true if pwVerGot is newer or equal to pwVerNeed
    
****************************************************************************/
BOOL GoodEnough(WORD *pwVerGot, WORD *pwVerNeed)
{
    BOOL fOK = FALSE;
    
    Assert(pwVerGot);
    Assert(pwVerNeed);
    
    if (pwVerGot[0] > pwVerNeed[0])
        fOK = TRUE;
    else if (pwVerGot[0] == pwVerNeed[0])
    {
        if (pwVerGot[1] > pwVerNeed[1])
            fOK = TRUE;
        else if (pwVerGot[1] == pwVerNeed[1])
        {
            if (pwVerGot[2] > pwVerNeed[2])
                fOK = TRUE;
            else if (pwVerGot[2] == pwVerNeed[2])
            {
                if (pwVerGot[3] >= pwVerNeed[3])
                    fOK = TRUE;
            }
        }
    }
    
    return fOK;
}


/*******************************************************************

  NAME:       ConvertVerToEnum
  
********************************************************************/
SETUPVER ConvertVerToEnum(WORD *pwVer)
{
    SETUPVER sv;
    Assert(pwVer);
    
    switch (pwVer[0])
    {
    case 0:
        sv = VER_NONE;
        break;
        
    case 1:
        if (0 == pwVer[1])
            sv = VER_1_0;
        else
            sv = VER_1_1;
        break;
        
    case 4:
        sv = VER_4_0;
        break;
        
    case 5:
        sv = VER_5_0;
        break;
        
    default:
        sv = VER_MAX;
    }
    
    return sv;
}


/*******************************************************************

  NAME:       ConvertStrToVer
  
********************************************************************/
void ConvertStrToVer(LPCSTR pszStr, WORD *pwVer)
{
    int i;
    
    Assert(pszStr);
    Assert(pwVer);
    
    ZeroMemory(pwVer, 4 * sizeof(WORD));
    
    for (i=0; i<4; i++)
    {
        while (*pszStr && (*pszStr != ',') && (*pszStr != '.'))
        {
            pwVer[i] *= 10;
            pwVer[i] += *pszStr - '0';
            pszStr++;
        }
        if (*pszStr)
            pszStr++;
    }
    
    return;
}


/*******************************************************************

  NAME:       GetVers
  
********************************************************************/
void GetVers(WORD *pwVerCurr, WORD *pwVerPrev)
{
    HKEY hkeyT;
    DWORD cb;
    CHAR szVer[VERLEN];
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, KEY_QUERY_VALUE, &hkeyT))
    {
        if (pwVerCurr)
        {
            cb = sizeof(szVer);
            RegQueryValueExA(hkeyT, c_szRegCurrVer, NULL, NULL, (LPBYTE)szVer, &cb);
            ConvertStrToVer(szVer, pwVerCurr);
        }
        
        if (pwVerPrev)
        {
            cb = sizeof(szVer);
            RegQueryValueExA(hkeyT, c_szRegPrevVer, NULL, NULL, (LPBYTE)szVer, &cb);
            ConvertStrToVer(szVer, pwVerPrev);
        }
        
        RegCloseKey(hkeyT);
    }
}


/*******************************************************************

  NAME:       GetVerInfo
  
********************************************************************/
void GetVerInfo(SETUPVER *psvCurr, SETUPVER *psvPrev)
{
    WORD wVerCurr[4];
    WORD wVerPrev[4];
    
    GetVers(wVerCurr, wVerPrev);
    
    if (psvCurr)
        *psvCurr = ConvertVerToEnum(wVerCurr);
    
    if (psvPrev)
        *psvPrev = ConvertVerToEnum(wVerPrev);
}


/*******************************************************************

  NAME:       InterimBuild
  
********************************************************************/
BOOL InterimBuild(SETUPVER *psv)
{
    HKEY hkeyT;
    DWORD cb;
    BOOL fInterim = FALSE;
    
    Assert(psv);
    ZeroMemory(psv, sizeof(SETUPVER));
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, KEY_QUERY_VALUE, &hkeyT))
    {
        cb = sizeof(SETUPVER);
        fInterim = (ERROR_SUCCESS == RegQueryValueExA(hkeyT, c_szRegInterimVer, NULL, NULL, (LPBYTE)psv, &cb));
        RegCloseKey(hkeyT);
    }
    
    return fInterim;
}


/*******************************************************************

  NAME:       GetASetupVer
  
********************************************************************/
BOOL GetASetupVer(LPCTSTR pszGUID, WORD *pwVer, LPTSTR pszVer, int cch)
{
    HKEY hkey;
    TCHAR szPath[MAX_PATH], szVer[64];
    BOOL fInstalled = FALSE;
    DWORD dwValue, cb;
    
    Assert(pszGUID);
    
    if (pszVer)
        pszVer[0] = 0;
    if (pwVer)
        ZeroMemory(pwVer, 4 * sizeof(WORD));
    
    wsprintf(szPath, c_szPathFileFmt, c_szRegASetup, pszGUID);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPath, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(dwValue);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szIsInstalled, 0, NULL, (LPBYTE)&dwValue, &cb))
        {
            if (1 == dwValue)
            {
                cb = sizeof(szVer);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szValueVersion, 0, NULL, (LPBYTE)szVer, &cb))
                {
                    if (pwVer)
                        ConvertStrToVer(szVer, pwVer);
                    if (pszVer)
                        lstrcpyn(pszVer, szVer, cch);
                    fInstalled = TRUE;
                }
            }
        }
        RegCloseKey(hkey);
    }
    
    return fInstalled;
}


/*******************************************************************

  NAME:       GetFileVer
  
********************************************************************/
HRESULT GetFileVer(LPCTSTR pszExePath, LPTSTR pszVer, DWORD cch)
{
    DWORD   dwVerInfoSize, dwVerHnd;
    HRESULT hr = S_OK;
    LPSTR   pszInfo = NULL;
    LPSTR   pszVersion;
    LPWORD  pwTrans;
    TCHAR   szGet[MAX_PATH];
    UINT    uLen;
    
    // Validate Parameters
    Assert(pszExePath);
    Assert(pszVer);
    Assert(cch);
    
    // Validate global state
    Assert(g_pMalloc);
    
    // Initialize out parameters
    pszVer[0] = TEXT('\0');
    
    // Allocate space for version info block
    if (0 == (dwVerInfoSize = GetFileVersionInfoSize(const_cast<LPTSTR> (pszExePath), &dwVerHnd)))
    {
        hr = E_FAIL;
        TraceResult(hr);
        goto exit;
    }
    IF_NULLEXIT(pszInfo = (LPTSTR)g_pMalloc->Alloc(dwVerInfoSize));
    ZeroMemory(pszInfo, dwVerInfoSize);
    
    // Get Version info block
    IF_FALSEEXIT(GetFileVersionInfo(const_cast<LPTSTR> (pszExePath), dwVerHnd, dwVerInfoSize, pszInfo), E_FAIL);
    
    // Figure out language for version info
    IF_FALSEEXIT(VerQueryValue(pszInfo, "\\VarFileInfo\\Translation", (LPVOID *)&pwTrans, &uLen) && uLen >= (2 * sizeof(WORD)), E_FAIL);
    
    // Set up buffer with correct language and get version
    wsprintf(szGet, "\\StringFileInfo\\%04X%04X\\FileVersion", pwTrans[0], pwTrans[1]);
    IF_FALSEEXIT(VerQueryValue(pszInfo, szGet, (LPVOID *)&pszVersion, &uLen) && uLen, E_FAIL);
    
    // Copy version out of version block, into out param
    Assert(pszVersion);
    lstrcpyn(pszVer, pszVersion, cch);
    
exit:
    if (pszInfo)
        g_pMalloc->Free(pszInfo);
    
    return hr;
}


/*******************************************************************

  NAME:       GetExeVer
  
********************************************************************/
HRESULT GetExeVer(LPCTSTR pszExeName, WORD *pwVer, LPTSTR pszVer, int cch)
{
    HRESULT hr = S_OK;
    TCHAR   szPath[MAX_PATH];
    TCHAR   szVer[64];
    
    // Validate params
    Assert(pszExeName);
    
    // Initialize out params
    if (pszVer)
    {
        Assert(cch);
        pszVer[0] = 0;
    }
    if (pwVer)
        // Version is an array of 4 words 
        ZeroMemory(pwVer, 4 * sizeof(WORD));
    
    // Find the exe
    IF_FALSEEXIT(GetExePath(pszExeName, szPath, ARRAYSIZE(szPath), FALSE), E_FAIL);
    
    // Get the string representation of the version
    IF_FAILEXIT(hr = GetFileVer(szPath, szVer, ARRAYSIZE(szVer)));
    
    // Fill in out params
    if (pwVer)
        ConvertStrToVer(szVer, pwVer);
    if (pszVer)
        lstrcpyn(pszVer, szVer, cch);
    
exit:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\wizard\makefile.inc ===
$(O)\regutil.cpp : $(ATHROOT)\mailnews\common\regutil.cpp
    copy $** $@

$(O)\memutil.cpp : $(ATHROOT)\staticrt\memutil.cpp
    copy $** $@

$(O)\_regutil.cpp : $(ATHROOT)\msoert\_regutil.cpp
    copy $** $@

$(O)\debug.c : $(ATHROOT)\msoert\debug.c
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\wizard\menu.cpp ===
#include "pch.hxx"
#include <regutil.h>
#include "strings.h"
#include "util.h"

void DisplayMenu()
    {

    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\wizard\init.cpp ===
#include "pch.hxx"
#include "strings.h"
#define DEFINE_UTIL
#include "util.h"

ASSERTDATA

HINSTANCE g_hInstance   = NULL;
LPMALLOC  g_pMalloc     = NULL;

#ifdef DEBUG
DWORD dwDOUTLevel = 0;
DWORD dwDOUTLMod = 0;
DWORD dwDOUTLModLevel = 0;
#endif

/****************************************************************************

    NAME:       GetTextToNextDelim

    SYNOPSIS:   Gets text up to next space, colon or end of string, places in
                output buffer

****************************************************************************/
LPSTR GetTextToNextDelim(LPSTR pszText, LPSTR pszOutBuf, UINT cbOutBuf)
    {
    Assert(pszText);
    Assert(pszOutBuf);
    Assert(*pszText);

    StrCpyN(pszOutBuf, c_szEmpty, cbOutBuf);
    
    // advance past whitespace
    while ((*pszText == ' ') || (*pszText == '\t') || (':' == *pszText))
        pszText++;

    // Copy parameter until we hit a delimiter
    while (*pszText && ((*pszText != ' ') && (*pszText != '\t') && (*pszText != ':')) && cbOutBuf>1)
        {
        *pszOutBuf = *pszText;      
        pszOutBuf ++;
        cbOutBuf --;
        pszText ++;
        }

    if (cbOutBuf)
        *pszOutBuf = '\0';  // null-terminate

    // advance past whitespace
    while ((*pszText == ' ') || (*pszText == '\t'))
        pszText++; 

    return pszText;
    }


/*******************************************************************

    NAME:       ParseCmdLine

********************************************************************/
void ParseCmdLine(LPSTR pszCmdLine)
    {
    LOG("Command Line:");
    LOG2(pszCmdLine);

    while (pszCmdLine && *pszCmdLine)
        {
        CHAR szCommand[64];

        pszCmdLine = GetTextToNextDelim(pszCmdLine, szCommand, sizeof(szCommand));

        if (!lstrcmpi(szCommand, c_szUninstallFlag))
            {
            si.smMode = MODE_UNINSTALL;
            }
        else if (!lstrcmpi(szCommand, c_szInstallFlag))
            {
            si.smMode = MODE_INSTALL;
            }
        else if (!lstrcmpi(szCommand, c_szUserFlag))
            {
            si.stTime = TIME_USER;
            }
        else if (!lstrcmpi(szCommand, c_szPromptFlag))
            {
            si.fPrompt = TRUE;
            }
        else if (!lstrcmpi(szCommand, c_szCallerFlag))
            {
            pszCmdLine = GetTextToNextDelim(pszCmdLine, szCommand, sizeof(szCommand));
            if (!lstrcmpi(szCommand, c_szWIN9X))
                si.caller = CALLER_WIN9X;
            else if (!lstrcmpi(szCommand, c_szWINNT))
                si.caller = CALLER_WINNT;
            }
        else if (!lstrcmpi(szCommand, c_szAppFlag))
            {
            pszCmdLine = GetTextToNextDelim(pszCmdLine, szCommand, sizeof(szCommand));
            if (!lstrcmpi(szCommand, c_szAppOE))
                si.saApp = APP_OE;
            else if (!lstrcmpi(szCommand, c_szAppWAB))
                si.saApp = APP_WAB;
            }
        else if (!lstrcmpi(szCommand, c_szINIFlag))
            {
            pszCmdLine = GetTextToNextDelim(pszCmdLine, si.szINI, sizeof(si.szINI));
            }
        else if (!lstrcmpi(szCommand, c_szIconsFlag))
            {
            pszCmdLine = GetTextToNextDelim(pszCmdLine, szCommand, sizeof(szCommand));
            si.smMode = MODE_ICONS;

            if (!lstrcmpi(szCommand, c_szOFF))
                si.fNoIcons = TRUE;
            }
        }
    }

void ParseINIFile()
    {
    

    }

/*******************************************************************

    NAME:       Initialize

********************************************************************/
HRESULT Initialize(LPSTR pszCmdLine)
    {
    UINT uLen, uAppID;
    HKEY hkey;
    HRESULT hr = S_OK;
    DWORD cb;
    // Needs to be static as it must outlive this func call
    static TCHAR s_szAltINF[MAX_PATH];

    si.osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&(si.osv)))
        {
        LOG("[ERROR] Couldn't get windows version info");
        goto generror;
        }


    // set up the win directory
    // We need the true system Windows directory, not the user's version
    if (!(uLen = GetSystemWindowsDirectoryWrap(si.szWinDir, ARRAYSIZE(si.szWinDir))))
        {
        LOG("[ERROR] Couldn't get Windows Directory");
        goto generror;
        }

    // Slash terminate
    if (*CharPrev(si.szWinDir, si.szWinDir+uLen) != '\\')
    {
        si.szWinDir[uLen++] = '\\';
        si.szWinDir[uLen] = 0;
    }

    // set up the inf directory
    StrCpyN(si.szInfDir, si.szWinDir, ARRAYSIZE(si.szInfDir));
    StrCpyN(&si.szInfDir[uLen], c_szINFSlash, ARRAYSIZE(si.szInfDir)-uLen);

    // Figure out the current directory
    if (!GetModuleFileName(NULL, si.szCurrentDir, ARRAYSIZE(si.szCurrentDir)) ||
        !PathRemoveFileSpec(si.szCurrentDir))
        {
        LOG("[ERROR] Couldn't get module's file name");
        goto generror;
        }

    if (!(uLen = GetSystemDirectory(si.szSysDir, MAX_PATH)))
        {
        LOG("[ERROR] Couldn't get System Directory");
        goto generror;
        }

    // Slash terminate
    if (*CharPrev(si.szSysDir, si.szSysDir+uLen) != '\\')
    {
        si.szSysDir[uLen++] = '\\';
        si.szSysDir[uLen] = 0;
    }

    // Load Advpack
    if (!(si.hInstAdvPack = LoadLibrary(c_szAdvPackDll)))
        {
        MsgBox(NULL, IDS_ERR_ADVLOAD, MB_ICONSTOP, MB_OK);
        hr = E_FAIL;
        goto exit;
        }

    // Thunk to short names on Win95 in case we use these paths in RepairBeta1
    if (VER_PLATFORM_WIN32_WINDOWS == si.osv.dwPlatformId)
    {
        GetShortPathName(si.szWinDir, si.szWinDir, ARRAYSIZE(si.szWinDir));
        GetShortPathName(si.szSysDir, si.szSysDir, ARRAYSIZE(si.szSysDir));
        GetShortPathName(si.szInfDir, si.szInfDir, ARRAYSIZE(si.szInfDir));
    }

    // Obtain Mandatory ADVPACK Entry points
    si.pfnRunSetup = (RUNSETUPCOMMAND)GetProcAddress(si.hInstAdvPack, achRUNSETUPCOMMANDFUNCTION);
    si.pfnLaunchEx = (LAUNCHINFSECTIONEX)GetProcAddress(si.hInstAdvPack, achLAUNCHINFSECTIONEX);
    si.pfnCopyFile = (ADVINSTALLFILE)GetProcAddress(si.hInstAdvPack, achADVINSTALLFILE);

    if (!si.pfnRunSetup || !si.pfnLaunchEx || !si.pfnCopyFile)
        {
        MsgBox(NULL, IDS_ERR_ADVCORR, MB_ICONSTOP, MB_OK);
        FreeLibrary(si.hInstAdvPack);
        hr = E_FAIL;
        goto exit;
        }

    // Obtain Optional ADVPACK Entry points used for repairing a Beta1 Install
    si.pfnAddDel = (ADDDELBACKUPENTRY)GetProcAddress(si.hInstAdvPack, "AddDelBackupEntry");
    si.pfnRegRestore = (REGSAVERESTORE)GetProcAddress(si.hInstAdvPack, "RegSaveRestore");
    
    // Get info from cmd line - like the app being installed
    ParseCmdLine(pszCmdLine);

    switch (si.saApp)
        {
        case APP_OE:
            si.pszInfFile = c_szMsimnInf;
            uAppID      = IDS_APPNAME_OE;
            si.pszVerInfo = c_szRegVerInfo;
            break;
        case APP_WAB:
            si.pszInfFile = c_szWABInf;
            uAppID      = IDS_APPNAME_WAB;
            si.pszVerInfo = c_szRegWABVerInfo;
            break;
        default:
            goto exit;
        }
    
    if (!LoadString(g_hInstance, uAppID, si.szAppName, ARRAYSIZE(si.szAppName)))
        {
        LOG("[ERROR] Setup50.exe is missing resources")
        goto generror;
        }

    // Allow reg override on INF file for non-IE installs
    // BUGBUG: Convert NT5 setup to Memphis methodology
    if ((CALLER_WIN9X == si.caller) && (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, KEY_QUERY_VALUE, &hkey)))
    {
        cb = sizeof(s_szAltINF);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szLatestINF, 0, NULL, (LPBYTE)s_szAltINF, &cb))
        {
            si.pszInfFile = s_szAltINF;
        }
        
        RegCloseKey(hkey);
    }
    
    // Allow INI file to override
    ParseINIFile();

    goto exit;

generror:
    MsgBox(NULL, IDS_ERR_INIT, MB_ICONSTOP, MB_OK);
    hr = E_FAIL;
exit:    
    return hr;
    }


/****************************************************************************

    NAME:       Process

****************************************************************************/
HRESULT Process()
    {
    HRESULT hr = S_OK;
    
    // If we weren't told which app, be helpful
    if (APP_UNKNOWN == si.saApp)
        si.smMode = MODE_UNKNOWN;

    LOG("MODE: ");
    switch (si.smMode)
        {
        case MODE_INSTALL:
            LOG2("Install   TIME: ");
            if (TIME_MACHINE == si.stTime)
                {
                LOG2("Machine");
                hr = InstallMachine();
                }
            else
                {
                LOG2("User");
                InstallUser();
                }
            break;

        case MODE_ICONS:
            LOG2("Icons");
            //HandleIcons();
            break;

        case MODE_UNINSTALL:
            LOG2("Uninstall   TIME: ");
            if (TIME_MACHINE == si.stTime)
                {
                LOG2("Machine");
                MsgBox(NULL, UnInstallMachine() ? IDS_UNINSTALL_COMPLETE : IDS_NO_UNINSTALL, MB_OK, MB_ICONINFORMATION);
                }
            else
                {
                LOG2("User");
                UnInstallUser();
                }
            break;

        case MODE_UNKNOWN:
            LOG2("Options");
            DisplayMenu();
            break;

        default:
            AssertSz(FALSE, "Setup MODE is undefined!");
        }

        return hr;

    }


/****************************************************************************

    NAME:       Shutdown

****************************************************************************/
void Shutdown()
    {
    if (si.hInstAdvPack)
        FreeLibrary(si.hInstAdvPack);
    }


/*******************************************************************

    NAME:       WinMain

    SYNOPSIS:   App entry point

********************************************************************/
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
    {
    HRESULT hr = S_OK;
    
    ZeroMemory(&si, sizeof(SETUPINFO));

    g_hInstance = hInstance; // save instance handle away

    CoInitialize(NULL);

    LOG_OPEN;

    // init global memory allocator
    // We will use it to free some Shell memory, so use SHGetMalloc
    SHGetMalloc(&g_pMalloc);
    if (NULL == g_pMalloc)
        {
        MsgBox(NULL, IDS_ERR_NOALLOC, MB_OK, MB_ICONSTOP);
        hr = E_OUTOFMEMORY;
        goto exit;
        }

    if (SUCCEEDED(hr = Initialize(lpCmdLine)))
        {
        hr = Process();
        Shutdown();
        }

    // release the global memory allocator
    g_pMalloc->Release();

exit:
    LOG_CLOSE;
    CoUninitialize();
    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\wizard\strings.cpp ===
#include "pch.hxx"
#define DEFINE_STRING_CONSTANTS
#include "strings.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\wizard\propmgr.cpp ===
#include "pch.hxx"
#include <regutil.h>
#include <initguid.h>
#include <shlguid.h>
#include "util.h"
#include "strings.h"
#include "msident.h"
#include <shellapi.h>

ASSERTDATA

const LPCTSTR c_szVers[] = { c_szVERnone, c_szVER1_0, c_szVER1_1, c_szVER4_0, c_szVER5B1 };
const LPCTSTR c_szBlds[] = { c_szBLDnone, c_szBLD1_0, c_szBLD1_1, c_szBLD4_0, c_szBLD5B1 };
#ifdef SETUP_LOG
const LPTSTR c_szLOGVERS[] = {"None", "1.0", "1.1", "4.0x", "5.0B1", "5.0x", "6.0x", "Unknown"};

C_ASSERT((sizeof(c_szLOGVERS)/sizeof(c_szLOGVERS[0]) == VER_MAX+1));

#endif


#define FORCE_DEL(_sz) { \
if ((dwAttr = GetFileAttributes(_sz)) != 0xFFFFFFFF) \
{ \
    SetFileAttributes(_sz, dwAttr & ~FILE_ATTRIBUTE_READONLY); \
    DeleteFile(_sz); \
} }

/*******************************************************************

  NAME:       CreateLink
  
********************************************************************/
//                         Target               Arguments        File for link         Description       File w/ Icon  Icn Index
HRESULT CreateLink(LPCTSTR lpszPathObj, LPCTSTR lpszArg, LPCTSTR lpszPathLink, LPCTSTR lpszDesc, LPCTSTR lpszIcon, int iIcon)
{ 
    HRESULT hres; 
    IShellLink* psl; 
    
    Assert(lpszPathObj != NULL);
    Assert(lpszPathLink != NULL);
    
    // Get a pointer to the IShellLink interface. 
    hres = CoCreateInstance(CLSID_ShellLink, NULL, 
        CLSCTX_INPROC_SERVER, IID_IShellLink, (void **)&psl); 
    if (SUCCEEDED(hres))
    { 
        IPersistFile* ppf; 
        TCHAR szTarget[MAX_PATH];
        
        // Use REG_EXPAND_SZ if possible
        AddEnvInPath(lpszPathObj, szTarget, ARRAYSIZE(szTarget));

        // Set the path to the shortcut target, and add the 
        // description. 
        if (SUCCEEDED(psl->SetPath(szTarget)) &&
            (lpszArg == NULL || SUCCEEDED(psl->SetArguments(lpszArg))) &&
            (NULL == lpszDesc || SUCCEEDED(psl->SetDescription(lpszDesc))) &&
            (lpszIcon == NULL || SUCCEEDED(psl->SetIconLocation(lpszIcon, iIcon))))
        {
            // Query IShellLink for the IPersistFile interface for saving the 
            // shortcut in persistent storage. 
            hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf); 
            if (SUCCEEDED(hres))
            { 
                WORD wsz[MAX_PATH]; 
                
                // Ensure that the string is ANSI. 
                MultiByteToWideChar(CP_ACP, 0, lpszPathLink, -1, wsz, MAX_PATH); 
                
                // Save the link by calling IPersistFile::Save. 
                hres = ppf->Save(wsz, TRUE); 
                ppf->Release();
            }
        } 
        
        psl->Release(); 
    }
    
    return hres; 
}


/*******************************************************************

  NAME:       FRedistMode
  
********************************************************************/
BOOL FRedistMode()
{
    HKEY hkey;
    DWORD cb;
    DWORD dwInstallMode=0;

    static BOOL s_fRedistInit = FALSE;
    static BOOL s_fRedistMode = FALSE;

    if (!s_fRedistInit)
    {
        s_fRedistInit = TRUE;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, KEY_READ, &hkey))
        {
            cb = sizeof(dwInstallMode);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szIEInstallMode, 0, NULL, (LPBYTE)&dwInstallMode, &cb))
            {
                s_fRedistMode = !!(dwInstallMode);
            }

            RegCloseKey(hkey);
        }
    }

    return s_fRedistMode;
}


/*******************************************************************

  NAME:       SetHandlers
  
********************************************************************/
void SetHandlers()
{
    switch (si.saApp)
    {
    case APP_OE:
        if (!FRedistMode())
        {
            ISetDefaultNewsHandler(c_szMOE, DEFAULT_DONTFORCE);
            ISetDefaultMailHandler(c_szMOE, DEFAULT_DONTFORCE | DEFAULT_SETUPMODE);    
        }
        break;
        
    case APP_WAB:
        break;
        
    default:
        break;
    }
}


/*******************************************************************

  NAME:       AddWABCustomStrings

  SYNOPSIS:   Adds machine-specific strings to WAB inf
  
********************************************************************/
void AddWABCustomStrings()
{
    HKEY hkey;
    TCHAR szTemp[MAX_PATH];
    TCHAR szINFFile[MAX_PATH];
    DWORD cb;
    BOOL  fOK = FALSE;

    // People don't want us creating a new Accessories group in our
    // install language if it differs from the system language
    // Soln: Advpack writes the name of the group for us, use that

    // Construct INF file name from dir and filename
    wnsprintf(szINFFile, ARRAYSIZE(szINFFile), c_szFileEntryFmt, si.szInfDir, si.pszInfFile);

    // We want to enclose the string in quotes
    szTemp[0] = '"';

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegWinCurrVer, 0, KEY_READ, &hkey))
    {
        cb = ARRAYSIZE(szTemp) - 1;
        fOK = (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szSMAccessories, 0, NULL, (LPBYTE)&szTemp[1], &cb));
        
        // We want cb to tell us where to put the closing quote.  RegQueryValueEx includes null in length, so we'd 
        // normally -1, but thanks to the opening quote in [0], the string is as long as cb
        //cb--;

        RegCloseKey(hkey);
    }

    if (fOK)
    {
        // Append closing quote
        szTemp[cb++] = '"';
        szTemp[cb] = 0;

        // Add string to INF so per-user stub will create right link
        WritePrivateProfileString(c_szStringSection, c_szAccessoriesString, szTemp, szINFFile);
    }

    // INF ships with a default value in case Advpack let us down
}


/*******************************************************************

  NAME:       RunPostSetup
  
********************************************************************/
void RunPostSetup()
{
    switch (si.saApp)
    {
    case APP_OE:
        RegisterExes(TRUE);
        break;
        
    case APP_WAB:
        AddWABCustomStrings();
        break;
        
    default:
        break;
    }
}


/*******************************************************************

  NAME:       OpenDirectory
  
    SYNOPSIS:   checks for existence of directory, if it doesn't exist
    it is created
    
********************************************************************/
HRESULT OpenDirectory(TCHAR *szDir)
{
    TCHAR *sz, ch;
    HRESULT hr;
    
    Assert(szDir != NULL);
    hr = S_OK;
    
    if (!CreateDirectory(szDir, NULL) && ERROR_ALREADY_EXISTS != GetLastError())
    {
        Assert(szDir[1] == _T(':'));
        Assert(szDir[2] == _T('\\'));
        
        sz = &szDir[3];
        
        while (TRUE)
        {
            while (*sz != 0)
            {
                if (!IsDBCSLeadByte(*sz))
                {
                    if (*sz == _T('\\'))
                        break;
                }
                sz = CharNext(sz);
            }
            ch = *sz;
            *sz = 0;
            if (!CreateDirectory(szDir, NULL))
            {
                if (GetLastError() != ERROR_ALREADY_EXISTS)
                {
                    hr = E_FAIL;
                    *sz = ch;
                    break;
                }
            }
            *sz = ch;
            if (*sz == 0)
                break;
            sz++;
        }
    }
    
    return(hr);
}


BOOL PathAddSlash(LPTSTR pszPath, DWORD *pcb)
{
    Assert(pszPath && pcb);

    DWORD cb = *pcb;
    LPTSTR pszEnd;
    
    *pcb = 0;
    if (!cb)
        cb = lstrlen(pszPath);

    pszEnd = CharPrev(pszPath, pszPath+cb);
    
    // Who knows why this is here... :-)
    if (';' == *pszEnd)
    {
        cb--;
        pszEnd--;
    }

    if (*pszEnd != '\\')
    {
        pszPath[cb++] = '\\';    
        pszPath[cb]   = 0;
    }

    *pcb = cb;
    return TRUE;
}


BOOL FGetSpecialFolder(int iFolder, LPTSTR pszPath)
{
    BOOL fOK = FALSE;
    LPITEMIDLIST pidl = NULL;

    pszPath[0] = 0;
    
    if (S_OK == SHGetSpecialFolderLocation(NULL, iFolder, &pidl) && SHGetPathFromIDList(pidl, pszPath))
        fOK = TRUE;

    SafeMemFree(pidl);
    return fOK;
}


/*******************************************************************

  NAME:       FGetOELinkInfo
  
********************************************************************/
BOOL FGetOELinkInfo(OEICON iIcon, BOOL fCreate, LPTSTR pszPath, LPTSTR pszTarget, LPTSTR pszDesc, DWORD *pdwInfo)
{
    BOOL fDir = FALSE;
    HKEY hkey;
    DWORD cb = 0;
    DWORD dwType;
    TCHAR szTemp[MAX_PATH];
    TCHAR szRes[CCHMAX_RES];
    
    Assert(pdwInfo);
    Assert(pszPath || pszTarget || pszDesc);

    *pdwInfo = 0;

    ZeroMemory(szTemp, ARRAYSIZE(szTemp));
    switch(iIcon)
    {
    
    // The MEMPHIS ICW erroneously creates an all-user desktop icon for OE
    case ICON_ICWBAD:
        
        // Find the location of the all-users desktop
        if (FGetSpecialFolder(CSIDL_COMMON_DESKTOPDIRECTORY, pszPath))
        {
            fDir = TRUE;
        }
        // Memphis doesn't support CSIDL_COMMON_DESKTOP
        else if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFolders, 0, KEY_QUERY_VALUE, &hkey))
        {
            cb = MAX_PATH * sizeof(TCHAR);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szValueCommonDTop, NULL, &dwType, (LPBYTE)pszPath, &cb))
            {
                if (REG_EXPAND_SZ == dwType)
                {
                    // ExpandEnvironmentStrings ret value doesn't seem to match the docs :-(
                    cb = ExpandEnvironmentStrings(pszPath, szTemp, ARRAYSIZE(szTemp));
                    if (fDir = cb != 0)
                    {
                        StrCpyN(pszPath, szTemp, MAX_PATH);
                        cb = lstrlen(pszPath);
                    }
                }
                else
                {
                    fDir = TRUE;
                    // RegQueryValueEx includes NULL in count
                    cb--;
                }
            }
            RegCloseKey(hkey);
        }

        if (fDir && PathAddSlash(pszPath, &cb) && SUCCEEDED(OpenDirectory(pszPath)))
        {
            // 1 for a null
            LoadString(g_hInstance, IDS_ATHENA, szRes, MAX_PATH - cb - 1 - c_szLinkFmt_LEN);
            wnsprintf(&pszPath[cb], MAX_PATH - cb, c_szLinkFmt, szRes);
            *pdwInfo |= LI_PATH;
        }
        break;

    case ICON_QLAUNCH:
    case ICON_QLAUNCH_OLD:
        if (FGetSpecialFolder(CSIDL_APPDATA, pszPath))
        {
            fDir = TRUE;
        }
        else if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegFolders, 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_WRITE | KEY_READ, NULL, &hkey, &dwType))
        {
            cb = MAX_PATH * sizeof(TCHAR);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szValueAppData, NULL, &dwType, (LPBYTE)pszPath, &cb))
            {
                if (REG_EXPAND_SZ == dwType)
                {
                    cb = ExpandEnvironmentStrings(pszPath, szTemp, ARRAYSIZE(szTemp));
                    if (fDir = 0 != cb)
                    {
                        StrCpyN(pszPath, szTemp, MAX_PATH);
                        cb = lstrlen(pszPath);
                    }
                }
                else
                {
                    // RegQueryValueEx includes NULL in their counts
                    cb--;
                    fDir = TRUE;
                }
            }
            else
            {
                StrCpyN(pszPath, si.szWinDir, MAX_PATH);
                cb = lstrlen(pszPath);
                cb += LoadString(g_hInstance, IDS_APPLICATION_DATA, &pszPath[cb], MAX_PATH - cb);
                // + 1 for NULL
                RegSetValueEx(hkey, c_szValueAppData, 0, REG_SZ, (LPBYTE)pszPath, (cb + 1) * sizeof(TCHAR));

                fDir = TRUE;
            }
        
            RegCloseKey(hkey);
        }

        if (fDir && PathAddSlash(pszPath, &cb))
        {
            StrCpyN(&pszPath[cb], c_szQuickLaunchDir, MAX_PATH - cb);
            cb += c_szQuickLaunchDir_LEN;

            if (SUCCEEDED(OpenDirectory(pszPath)))
            {
                // 5 = 1 for null + 4 for .lnk
                LoadString(g_hInstance, ICON_QLAUNCH == iIcon ? IDS_LAUNCH_ATHENA : IDS_MAIL, szRes, MAX_PATH - cb - 5);
                wnsprintf(&pszPath[cb], MAX_PATH - cb, c_szLinkFmt, szRes);
                *pdwInfo |= LI_PATH;

                // We need more details for ICON_QLAUNCH
                if (ICON_QLAUNCH == iIcon && fCreate)
                {
                    // Don't use Description because NT5 shows name and comment
                    //lstrcpy(pszDesc, szRes);
                    //*pdwInfo |= LI_DESC;

                    if (GetExePath(c_szMainExe, pszTarget, MAX_PATH, FALSE))
                        *pdwInfo |= LI_TARGET;
                }
            }
        }
        break;

    case ICON_MAPIRECIP:
        if (FGetSpecialFolder(CSIDL_SENDTO, pszPath) && PathAddSlash(pszPath, &cb) && SUCCEEDED(OpenDirectory(pszPath)))
        {
            // 10 = 1 for NULL + 9 for .MAPIMAIL
            LoadString(g_hInstance, IDS_MAIL_RECIPIENT, szRes, MAX_PATH - cb - 10);
            wnsprintf(&pszPath[cb], MAX_PATH - cb, c_szFmtMapiMailExt, szRes);
            *pdwInfo |= LI_PATH;
        }
        break;

    case ICON_DESKTOP:
        if (FGetSpecialFolder(CSIDL_DESKTOP, pszPath))
            fDir = TRUE;
        // HACK to workaround TW Memphis: Try the registry
        else if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegFolders, 0, KEY_READ, &hkey))
        {
            cb = MAX_PATH * sizeof(TCHAR);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szDesktop, 0, &dwType, (LPBYTE)pszPath, &cb))
            {
                // Handle REG_EXPAND_SZ
                if (REG_EXPAND_SZ == dwType)
                {
                    cb = ExpandEnvironmentStrings(pszPath, szTemp, ARRAYSIZE(szTemp));
                    if (fDir = cb != 0)
                    {
                        StrCpyN(pszPath, szTemp, MAX_PATH);
                        fDir = TRUE;
                    }
                }
                else
                {
                    // RegQueryValueEx includes NULL
                    cb--;
                    fDir = TRUE;
                }
            }

            RegCloseKey(hkey);
        }

        if (fDir && PathAddSlash(pszPath, &cb) && SUCCEEDED(OpenDirectory(pszPath)))
        {
            // 5 = 1 for NULL + 4 for .lnk
            LoadString(g_hInstance, IDS_ATHENA, szRes, MAX_PATH - cb - 5);
            wnsprintf(&pszPath[cb], MAX_PATH - cb, c_szLinkFmt, szRes);

            *pdwInfo |= LI_PATH;

            if (fCreate)
            {
                // Description for Desktop link
                LoadString(g_hInstance, IDS_OEDTOP_TIP, pszDesc, CCHMAX_RES);
                *pdwInfo |= LI_DESC;

                if (GetExePath(c_szMainExe, pszTarget, MAX_PATH, FALSE))
                    *pdwInfo |= LI_TARGET;
            }
        }
        break;

    }

    if (*pdwInfo)
        return TRUE;
    else
        return FALSE;

}


/*******************************************************************

  NAME:       FProcessOEIcon

  SYNOPSIS:   Should we manipulate this icon?
  
********************************************************************/
BOOL FProcessOEIcon(OEICON iIcon, BOOL fCreate)
{
    BOOL fProcess = TRUE;

    switch (iIcon)
    {
    case ICON_ICWBAD:
        // Don't delete the ICW's bad icon in redist mode or on NT5 as we won't create a replacement
        if (((VER_PLATFORM_WIN32_NT == si.osv.dwPlatformId) && (si.osv.dwMajorVersion >= 5)) || FRedistMode())
        {
            fProcess = FALSE;
        }
        break;

    case ICON_DESKTOP:
        // Don't create the desktop icon on NT5+, Win98 OSR+ or if we are in redist mode
        if (fCreate && ( ((VER_PLATFORM_WIN32_NT == si.osv.dwPlatformId) && (si.osv.dwMajorVersion >= 5)) ||
// Disabled this temporarily (through techbeta)
#if 0
                         ((VER_PLATFORM_WIN32_WINDOWS == si.osv.dwPlatformId) && 
                         (((4 == si.osv.dwMajorVersion) && (10 == si.osv.dwMinorVersion) && (LOWORD(si.osv.dwBuildNumber) > 1998)) || 
                          ((4 == si.osv.dwMajorVersion) && (si.osv.dwMinorVersion > 10)) ||
                          (si.osv.dwMajorVersion > 4)) ) ||
#endif
                         FRedistMode() ) )
            fProcess = FALSE;
        break;
    
    case ICON_QLAUNCH:
    case ICON_QLAUNCH_OLD:
            // No Quick Launch Icon on whistler
            if(fCreate && 
                VER_PLATFORM_WIN32_NT == si.osv.dwPlatformId &&
                (si.osv.dwMajorVersion > 5 || 
                (si.osv.dwMajorVersion == 5 && si.osv.dwMinorVersion > 0)))
            fProcess = FALSE;
        break;
    }

    return fProcess;
}


/*******************************************************************

  NAME:       HandleOEIcon

  SYNOPSIS:   Performs actual work on Icon
  
********************************************************************/
void HandleOEIcon(OEICON icn, BOOL fCreate, LPTSTR pszPath, LPTSTR pszTarget, LPTSTR pszDesc)
{
    DWORD dwAttr;
    HANDLE hFile;

    switch (icn)
    {
    case ICON_QLAUNCH_OLD:
    case ICON_ICWBAD:
        if (pszPath)
            FORCE_DEL(pszPath);
        break;

    case ICON_QLAUNCH:
    case ICON_DESKTOP:
        if (pszPath)
        {
            FORCE_DEL(pszPath);
            if (fCreate && pszTarget && !IsXPSP1OrLater())
            {
                CreateLink(pszTarget, NULL, pszPath, pszDesc, pszTarget, -2);
                SetFileAttributes(pszPath, FILE_ATTRIBUTE_READONLY);
            }
        }
        break;

    case ICON_MAPIRECIP:
        if (fCreate && pszPath)
        {
            hFile = CreateFile(pszPath, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, 
                               NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (hFile != INVALID_HANDLE_VALUE)
                CloseHandle(hFile);
        }
        break;
    }
}


/*******************************************************************

  NAME:       HandleOELinks
  
********************************************************************/
void HandleOELinks(BOOL fCreate)
{
    int i;
    TCHAR szPath[MAX_PATH];
    TCHAR szTarget[MAX_PATH];
    TCHAR szDescription[CCHMAX_RES];
    DWORD dwInfo;
    
    // Process each Icon in turn
    for (i = 0; i < ICON_LAST_ICON; i++)
    {
        if (FProcessOEIcon((OEICON)i, fCreate))
        {
            if(FGetOELinkInfo((OEICON)i, fCreate, szPath, szTarget, szDescription, &dwInfo))
            {
                HandleOEIcon((OEICON)i, fCreate, 
                            (dwInfo & LI_PATH)   ? szPath        : NULL,
                            (dwInfo & LI_TARGET) ? szTarget      : NULL,
                            (dwInfo & LI_DESC)   ? szDescription : NULL);
            }
        }

    }
}


/*******************************************************************

  NAME:       HandleLinks
  
********************************************************************/
void HandleLinks(BOOL fCreate)
{
    switch (si.saApp)
    {
    case APP_OE:
        HandleOELinks(fCreate);
        break;
        
    case APP_WAB:
        break;
        
    default:
        break;
    }
}


/*******************************************************************

  NAME:       TranslateVers
  
  SYNOPSIS:   Takes 5.0B1 versions and translates to bld numbers
    
********************************************************************/
BOOL TranslateVers(SETUPVER *psv, LPTSTR pszVer, int cch)
{
    BOOL fTranslated = FALSE;
    *psv = VER_NONE;
    
    // Special case builds 624-702
    if (!lstrcmp(pszVer, c_szVER5B1old))
    {
        StrCpyN(pszVer, c_szBlds[VER_5_0_B1], cch);
        *psv = VER_5_0_B1;
        fTranslated = TRUE;
    }   
    else
        for (int i = VER_NONE; i < VER_5_0; i++)
            if (!lstrcmp(c_szVers[i], pszVer))
            {
                // HACK!  Special case WAB 1_0 match - it could be 1_1...
                // Don't care on Win9X or NT as data is still stored in same place
                if (APP_WAB == si.saApp && VER_1_0 == i && CALLER_IE == si.caller)
                {
                    // Is Windows\WAB.exe backed up as part of OE?
                    TCHAR szTemp[MAX_PATH];
                    wnsprintf(szTemp, ARRAYSIZE(szTemp), c_szFileEntryFmt, si.szWinDir, "wab.exe");

                    if (OEFileBackedUp(szTemp, ARRAYSIZE(szTemp)))
                        i = VER_1_1;
                }
                StrCpyN(pszVer, c_szBlds[i], cch);
                *psv = (SETUPVER)i;
                fTranslated = TRUE;
                break;
            }
            
    return fTranslated;
}


/*******************************************************************

  NAME:       DetectPrevVer
  
    SYNOPSIS:   Called when there is no ver info for current app
    
********************************************************************/
SETUPVER DetectPrevVer(LPTSTR pszVer, int cch)
{
    SETUPVER sv;
    TCHAR szVer[VERLEN] = {0};
    WORD wVer[4];
    TCHAR szFile[MAX_PATH];
    TCHAR szFile2[MAX_PATH];
    UINT uLen;
    DWORD dwAttr;
    
    Assert(pszVer);
    StrCpyN(szFile, si.szSysDir, ARRAYSIZE(szFile));
    uLen = lstrlen(szFile);
    
    switch (si.saApp)
    {
    case APP_OE:
        LOG("Sniffing for OE...  Detected:");
        
        StrCpyN(&szFile[uLen], c_szMAILNEWS, ARRAYSIZE(szFile) - uLen);
        
        // See what version we've told IE Setup, is installed
        // Or what version msimn.exe is (to cover the case in which the 
        // ASetup info has been damaged - OE 5.01 80772)
        if (GetASetupVer(c_szOEGUID, wVer, szVer, ARRAYSIZE(szVer)) ||
            SUCCEEDED(GetExeVer(c_szOldMainExe, wVer, szVer, ARRAYSIZE(szVer))))
            sv = ConvertVerToEnum(wVer);
        else
        {
            // 1.0 or none
            
            // Does mailnews.dll exist?
            if(0xFFFFFFFF == GetFileAttributes(szFile))
                sv = VER_NONE;
            else
                sv = VER_1_0;
        }

        // If active setup, these will be rollably deleted
        if (CALLER_IE != si.caller)
            FORCE_DEL(szFile);

        LOG2(c_szLOGVERS[sv]);
        break;
        
    case APP_WAB:
        LOG("Sniffing for WAB...  Detected:");

        StrCpyN(&szFile[uLen], c_szWAB32, ARRAYSIZE(szFile) - uLen);
        StrCpyN(szFile2, si.szWinDir, ARRAYSIZE(szFile2));
        StrCatBuff(szFile2, c_szWABEXE, ARRAYSIZE(szFile2));

        if (GetASetupVer(c_szWABGUID, wVer, szVer, ARRAYSIZE(szVer)))
        {
            // 5.0 or later
            if (5 == wVer[0])
                sv = VER_5_0;
            else
                sv = VER_MAX;
        }
        else if (GetASetupVer(c_szOEGUID, wVer, szVer, ARRAYSIZE(szVer)) ||
                 SUCCEEDED(GetExeVer(c_szOldMainExe, wVer, szVer, ARRAYSIZE(szVer))))
        {
            // 4.0x or 5.0 Beta 1
            if (5 == wVer[0])
                sv = VER_5_0_B1;
            else if (4 == wVer[0])
                sv = VER_4_0;
            else
                sv = VER_MAX;
        }
        else
        {
            // 1.0, 1.1 or none
            
            // WAB32.dll around?
            if(0xFFFFFFFF == GetFileAttributes(szFile))
                sv = VER_NONE;
            else
            {
                // \Windows\Wab.exe around?
                if(0xFFFFFFFF == GetFileAttributes(szFile2))
                    sv = VER_1_0;
                else
                    sv = VER_1_1;
            }
        }
        
        // If active setup, these will be rollably deleted
        if (CALLER_IE != si.caller)
        {
            FORCE_DEL(szFile);
            FORCE_DEL(szFile2);
        }
        
        LOG2(c_szLOGVERS[sv]);
        break;
        
    default:
        sv = VER_NONE;
    }
    
    // Figure out the build number for this ver
    if (szVer[0])
        // Use real ver
        StrCpyN(pszVer, szVer, cch);
    else
        // Fake Ver
        StrCpyN(pszVer, sv > sizeof(c_szBlds)/sizeof(c_szBlds[0]) ? c_szBlds[0] : c_szBlds[sv], cch);
    
    
    return sv;
}


/*******************************************************************

  NAME:       HandleVersionInfo
  
********************************************************************/
void HandleVersionInfo(BOOL fAfterInstall) 
{
    HKEY hkeyT,hkey;
    DWORD cb, dwDisp;
    TCHAR szCurrVer[VERLEN]={0};
    TCHAR szPrevVer[VERLEN]={0};
    LPTSTR psz;
    SETUPVER svCurr = VER_MAX, svPrev = VER_MAX;
    WORD wVer[4];
    BOOL fReg=FALSE;
    
    Assert(si.pszVerInfo);
    
    // Are we dealing with the "current" entry?
    if (fAfterInstall)
    {
        LPCTSTR pszGUID;
        TCHAR szVer[VERLEN];
        
        switch (si.saApp)
        {
        case APP_OE:
            pszGUID = c_szOEGUID;
            break;
            
        case APP_WAB:
            pszGUID = c_szWABGUID;
            break;
            
        default:
            AssertSz(FALSE, "Unknown app is trying to be installed.  Abandon hope...");
            return;
        }
        
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_SET_VALUE, NULL, &hkeyT, &dwDisp))
        {
            if (!GetASetupVer(pszGUID, wVer, szVer, ARRAYSIZE(szVer)))
            {
                // Uh oh, couldn't find our ASetup key - this is not good!
                MsgBox(NULL, IDS_WARN_NOASETUPVER, MB_ICONEXCLAMATION, MB_OK);
                RegSetValueEx(hkeyT, c_szRegCurrVer, 0, REG_SZ, (LPBYTE)c_szBLDnew, (lstrlen(c_szBLDnew) + 1) * sizeof(TCHAR));
            }
            else
                RegSetValueEx(hkeyT, c_szRegCurrVer, 0, REG_SZ, (LPBYTE)szVer, (lstrlen(szVer) + 1) * sizeof(TCHAR));
            
            RegCloseKey(hkeyT);
        }
        return;
    }
    
    // Handling "Previous" entry...
    
    // Always try to use the version info
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, KEY_QUERY_VALUE, &hkeyT))
    {
        cb = sizeof(szPrevVer);
        RegQueryValueEx(hkeyT, c_szRegPrevVer, NULL, NULL, (LPBYTE)szPrevVer, &cb);
        // Change to a bld # if needed
        if (!TranslateVers(&svPrev, szPrevVer, ARRAYSIZE(szPrevVer)))
        {
            // Convert bld to enum
            ConvertStrToVer(szPrevVer, wVer);
            svPrev = ConvertVerToEnum(wVer);
        }
        
        // If version info shows that a ver info aware version was uninstalled, throw out the info
        // and redetect
        if (VER_NONE == svPrev)
            // Sniff the machine for current version
            svCurr = DetectPrevVer(szCurrVer, ARRAYSIZE(szCurrVer));
        else
        {
            // There was previous version reg goo - and it's legit
            fReg = TRUE;
            
            cb = sizeof(szCurrVer);
            RegQueryValueEx(hkeyT, c_szRegCurrVer, NULL, NULL, (LPBYTE)szCurrVer, &cb);
            // Change to a bld # if needed
            if (!TranslateVers(&svCurr, szCurrVer, ARRAYSIZE(szCurrVer)))
            {
                // Convert bld to enum
                ConvertStrToVer(szCurrVer, wVer);
                svCurr = ConvertVerToEnum(wVer);
            }
        }
        
        RegCloseKey(hkeyT);
    }
    else 
    {
        // Sniff the machine for current version
        svCurr = DetectPrevVer(szCurrVer, ARRAYSIZE(szCurrVer));
    }
    
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_SET_VALUE, NULL, &hkeyT, &dwDisp))
    {
        // Should we change the previous version entry?
        if (VER_6_0 != svCurr)
        {
            // Know this is B1 OE if we translated
            // Know this is B1 WAB if we detected it
            if (VER_5_0_B1 == svCurr)
            {
                RegSetValueEx(hkeyT, c_szRegInterimVer, 0, REG_DWORD, (LPBYTE)&svCurr, sizeof(SETUPVER));
                // Did we read a previous value?
                if (fReg)
                    // As there were reg entries, just translate the previous entry
                    psz = szPrevVer;
                else
                {
                    // We don't have a bld number and yet we are B1, better be the WAB
                    Assert(APP_WAB == si.saApp);
                    
                    // Peek at OE's ver info
                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegVerInfo, 0, KEY_QUERY_VALUE, &hkey))
                    {
                        cb = sizeof(szPrevVer);
                        // Read a build or a string
                        RegQueryValueExA(hkey, c_szRegPrevVer, NULL, NULL, (LPBYTE)szPrevVer, &cb);
                        // If it's a string, convert it to a build
                        TranslateVers(&svPrev, szPrevVer, ARRAYSIZE(szPrevVer));
                        
                        // We'll use the build (translated or direct)
                        psz = szPrevVer;
                        RegCloseKey(hkey);
                    }
                }
            }
            else
            {
                RegDeleteValue(hkeyT, c_szRegInterimVer);
                // Make the old current ver, the previous ver
                psz = szCurrVer;
            }
            
            RegSetValueEx(hkeyT, c_szRegPrevVer, 0, REG_SZ, (LPBYTE)psz, (lstrlen(psz) + 1) * sizeof(TCHAR));
        }
        
        RegCloseKey(hkeyT);
    }
}



/*******************************************************************

  NAME:       UpgradeOESettings
  
********************************************************************/
BOOL UpgradeOESettings(SETUPVER svPrev, HKEY hkeyDest)
{
    LPCTSTR pszSrc;
    HKEY hkeySrc;
    BOOL fMig;
    
    Assert(hkeyDest);

    // Figure out where the data is coming FROM...
    switch (svPrev)
    {
    default:
        // Nothing to do
        return TRUE;
        
    case VER_4_0:
        pszSrc = c_szRegFlat;
        break;
        
    case VER_5_0_B1:
        pszSrc = c_szRegRoot;
        break;
    }       
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, pszSrc, 0, KEY_READ, &hkeySrc))
    {
        CopyRegistry(hkeySrc, hkeyDest);
        RegCloseKey(hkeySrc);

        fMig = TRUE;
    }
    else
        fMig = FALSE;
    
    return fMig;
}


/*******************************************************************

  NAME:       UpgradeWABSettings
  
********************************************************************/
BOOL UpgradeWABSettings(SETUPVER svPrev, HKEY hkeyDest)
{
    LPCTSTR pszSrc;
    BOOL fMig;
    HKEY hkeySrc;

    Assert(hkeyDest);

    // Figure out where the data is coming FROM...
    switch (svPrev)
    {
    default:
        // Nothing to do
        return TRUE;
        
    case VER_4_0:
    case VER_5_0_B1:
        pszSrc = c_szInetAcctMgrRegKey;
        break;
    }       

    
    // IAM\Accounts
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, pszSrc, 0, KEY_READ, &hkeySrc))
    {
        CopyRegistry(hkeySrc, hkeyDest);
        RegCloseKey(hkeySrc);
        
        fMig = TRUE;
    }       
    else
        fMig = FALSE;
    
    return fMig;
}


/*******************************************************************

  NAME:       UpgradeOESettingsToMU
  
  SYNOPSIS:   Copies forward settings as needed and returns TRUE
              if we did migrate.
    
********************************************************************/
BOOL UpgradeOESettingsToMU()
{
    SETUPVER svMachinePrev = VER_NONE, svUserPrev = VER_NONE;
    HKEY hkeySrc, hkeyID;
    DWORD dwTemp;
    BOOL fUpgraded = FALSE, fAlreadyDone = FALSE;
    IUserIdentityManager *pManager=NULL;
    IUserIdentity *pIdentity=NULL;
    TCHAR szVer[VERLEN];
    HKEY    hkeySettings, hkeyT;
    DWORD   dwDisp;
    GUID    guid;
    int i;
    
    // Get an identity manager    
    if (SUCCEEDED(CoCreateInstance(CLSID_UserIdentityManager, NULL, CLSCTX_INPROC_SERVER, 
                                   IID_IUserIdentityManager, (void **)&pManager)))
    {
        Assert(pManager);
        
        // Get Default Identity
        if (SUCCEEDED(pManager->GetIdentityByCookie((GUID*)&UID_GIBC_DEFAULT_USER, &pIdentity)))
        {
            Assert(pIdentity);

            // Ensure that we have an identity and can get to its registry
            if (SUCCEEDED(pIdentity->OpenIdentityRegKey(KEY_WRITE, &hkeyID)))
            {
                // Create the place for their OE settings
                if (ERROR_SUCCESS == RegCreateKeyEx(hkeyID, c_szRegRoot, 0, NULL, REG_OPTION_NON_VOLATILE, 
                                                    KEY_WRITE, NULL, &hkeySettings, &dwDisp))
                {
                    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegSharedSetup, 0, NULL, 
                                                        REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hkeyT, &dwDisp))
                    {
                        // Is there already a migrated default user?
                        if (ERROR_SUCCESS != RegQueryValueEx(hkeyT, c_szSettingsToLWP, 0, &dwTemp, NULL, NULL))
                        {
                            // Record that we are about to do
                            ZeroMemory(&guid, sizeof(guid));
                            pIdentity->GetCookie(&guid);
                            RegSetValueEx(hkeyT, c_szSettingsToLWP, 0, REG_BINARY, (LPBYTE)&guid, sizeof(guid));
                            
                            // Note today's version
                            if (GetASetupVer(c_szOEGUID, NULL, szVer, ARRAYSIZE(szVer)))
                                RegSetValueEx(hkeyT, c_szSettingsToLWPVer, 0, REG_SZ, (LPBYTE)szVer, sizeof(szVer));

                            // Close the key now as it will be a while before we leave this block
                            RegCloseKey(hkeyT);

                            // Figure out which version's settings we will be looking for        
                            if (!InterimBuild(&svMachinePrev))
                               GetVerInfo(NULL, &svMachinePrev);

                            // Go backwards through list of versions, and look for user info
                            // the same age or older than the previous version on the machine
                            for (i = svMachinePrev; i >= VER_NONE; i--)
                            {
                                if (bVerInfoExists((SETUPVER)i))
                                {
                                    svUserPrev = (SETUPVER)i;
                                    break;
                                }
                            }
                        
                            // Begin with default values
                            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegDefaultSettings, 0, KEY_READ, &hkeySrc))
                            {
                                CopyRegistry(hkeySrc,  hkeySettings);
                                RegCloseKey(hkeySrc);
                            }

                            // Apply previous version settings if any                
                            fUpgraded = UpgradeOESettings(svUserPrev, hkeySettings);

                            // Tell msoe.dll's migration code that this is not a new user and migration should be done
                            dwDisp = 0;
                            RegSetValueEx(hkeySettings, c_szOEVerStamp, 0, REG_DWORD, (LPBYTE)&dwDisp, sizeof(dwDisp));
                        }
                        else
                        {
                            // Check for TechBeta Builds
                            if (REG_DWORD == dwTemp)
                            {
                                ZeroMemory(&guid, sizeof(guid));
                                pIdentity->GetCookie(&guid);
                                RegSetValueEx(hkeyT, c_szSettingsToLWP, 0, REG_BINARY, (LPBYTE)&guid, sizeof(guid));
                            }
                            fAlreadyDone = TRUE;
                            RegCloseKey(hkeyT);
                        }
                    }
                    RegCloseKey(hkeySettings);
                }
                RegCloseKey(hkeyID);
            }
            pIdentity->Release();
        }
        pManager->Release();
    }
    
    return fAlreadyDone ? FALSE : fUpgraded;
}


BOOL UpgradeSettings()
{
    switch (si.saApp)
    {
    case APP_OE:
        return UpgradeOESettingsToMU();

    case APP_WAB:
        return TRUE;

    default:
        return FALSE;
    }
}


/*******************************************************************

NAME:       bOEVerInfoExists

********************************************************************/
BOOL bOEVerInfoExists(SETUPVER sv)
{
    BOOL bExists = FALSE;
    HKEY hkey;
    
    switch (sv)
    {
    default:
        bExists = FALSE;
        break;
        
    case VER_1_0:
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegRoot_V1, 0 ,KEY_QUERY_VALUE,&hkey))
        {
            bExists = (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szRegStoreRootDir, NULL, NULL, NULL, NULL));
            RegCloseKey(hkey);
        }
        break;
        
    case VER_4_0:
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegFlat,0,KEY_QUERY_VALUE,&hkey))
        {
            bExists = (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szRegStoreRootDir, NULL, NULL, NULL, NULL));
            RegCloseKey(hkey);
        }
        break;
        
    case VER_5_0_B1:
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegRoot ,0 , KEY_QUERY_VALUE, &hkey))
        {
            bExists = TRUE;
            RegCloseKey(hkey);
        }
        break;
    }
    return bExists;
}


/*******************************************************************

  NAME:       bWABVerInfoExists
  
********************************************************************/
BOOL bWABVerInfoExists(SETUPVER sv)
{
    BOOL bExists = FALSE;
    HKEY hkey;
    
    switch (sv)
    {
    default:
        bExists = FALSE;
        break;
        
    case VER_1_1:
    case VER_1_0:
        bExists = bOEVerInfoExists(VER_1_0);
        break;
        
    case VER_4_0:
    case VER_5_0_B1:
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szInetAcctMgrRegKey, 0, KEY_QUERY_VALUE,&hkey))
        {
            bExists = TRUE;
            RegCloseKey(hkey);
        }
        break;
    }
    return bExists;
}


/*******************************************************************

  NAME:       bVerInfoExists
  
********************************************************************/
BOOL bVerInfoExists(SETUPVER sv)
{
    switch (si.saApp)
    {
    case APP_OE:
        return bOEVerInfoExists(sv);
        
    case APP_WAB:
        return bWABVerInfoExists(sv);
    default:
        return FALSE;
        
    }
}

/*******************************************************************

  NAME:       PreRollable
  
********************************************************************/
void PreRollable()
{
}


/*******************************************************************

  NAME:       ApplyActiveSetupVer()

  SYNOPS
  
********************************************************************/
void ApplyActiveSetupVer()
{
    TCHAR szVer[VERLEN];
    TCHAR szPath[MAX_PATH];
    LPCTSTR pszGuid;
    LPCTSTR pszVerString;
    int cLen;
    HKEY hkey;
    
    switch (si.saApp)
    {
    case APP_OE:
        pszGuid = c_szOEGUID;
        pszVerString = c_szVersionOE;
        break;

    case APP_WAB:
        pszGuid = c_szWABGUID;
        pszVerString = c_szValueVersion;
        break;

    default:
        AssertSz(FALSE, "Applying ActiveSetupVer for unknown APP!");
        return;
    }

    // Get the version out of the INF file
    wnsprintf(szPath, ARRAYSIZE(szPath), c_szFileEntryFmt, si.szInfDir, si.pszInfFile);
    cLen = GetPrivateProfileString(c_szStringSection, pszVerString, c_szBLDnew, szVer, ARRAYSIZE(szVer), szPath);

    // Write the version in the registry
    wnsprintf(szPath, ARRAYSIZE(szPath), c_szPathFileFmt, c_szRegASetup, pszGuid);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPath, 0, KEY_SET_VALUE, &hkey))
    {
        RegSetValueEx(hkey, c_szValueVersion, 0, REG_SZ, (LPBYTE)szVer, (cLen+1)*sizeof(TCHAR));
        RegCloseKey(hkey);

#ifdef _WIN64
        // !! HACKHACK !!
        // We put the same string in the Wow6432Node of the registry so that the 32-bit Outlook2000 running on ia64
        // will not complain that OE is not installed. 
        //
        // This should not be necessary, but currently (and it might stay this way) msoe50.inf is adding RunOnceEx entries
        // under the Wow6432Node and the are not being "reflected" to the normal HKLM branch. Thus, the below reg entry is
        // never added.

        wnsprintf(szPath, ARRAYSIZE(szPath), c_szPathFileFmt, TEXT("Software\\Wow6432Node\\Microsoft\\Active Setup\\Installed Components"), pszGuid);

        // call RegCreateKeyEx in case the 32-bit stuff hasen't run yet
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                            szPath,
                                            0,
                                            NULL,
                                            REG_OPTION_NON_VOLATILE,
                                            KEY_SET_VALUE,
                                            NULL,
                                            &hkey,
                                            NULL))
        {
            RegSetValueEx(hkey, c_szValueVersion, 0, REG_SZ, (LPBYTE)szVer, (cLen+1)*sizeof(TCHAR));
            RegCloseKey(hkey);
        }
#endif // _WIN64
    }
    else
    {
        LOG("[ERROR]: App's ASetup Key hasn't been created.");
    }

}


/*******************************************************************

  NAME:       GetDirNames

  SYNOPSIS:   Figures out commonly used dir names
              dwWant should have the nth bit set if you want the
              nth string argument set
  
********************************************************************/
DWORD GetDirNames(DWORD dwWant, LPTSTR pszOE, LPTSTR pszSystem, LPTSTR pszServices, LPTSTR pszStationery)
{
    HKEY hkeyT;
    DWORD cb;
    DWORD dwType;
    TCHAR szTemp[MAX_PATH];
    TCHAR szTemp2[MAX_PATH];
    DWORD dwReturned = 0;

    ZeroMemory(szTemp, ARRAYSIZE(szTemp));
    // Do they want the OE Install Directory?
    if (dwWant & 1)
    {
        Assert(pszOE);
        pszOE[0] = 0;

        // OE Install Dir
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_QUERY_VALUE, &hkeyT))
        {
            cb = MAX_PATH * sizeof(TCHAR);
            if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szInstallRoot, 0, &dwType, (LPBYTE)pszOE, &cb))
            {
                // Forget about the null in count
                cb--;

                if (*CharPrev(pszOE, pszOE+cb) != '\\')
                {
                    pszOE[cb++] = '\\';
                    pszOE[cb] = 0;
                }
            
                if (REG_EXPAND_SZ == dwType)
                {
                    ExpandEnvironmentStrings(pszOE, szTemp, ARRAYSIZE(szTemp));
                    StrCpyN(pszOE, szTemp, MAX_PATH);
                }

                dwReturned |= 1;
            }

            RegCloseKey(hkeyT);
        }
    }

    // Do they want the Common Files\System Directory?
    if (dwWant & 2)
    {
        Assert(pszSystem);
        pszSystem[0] = 0;
    }

    // Do they want the Common Files\Services Directory?
    if (dwWant & 4)
    {
        Assert(pszServices);
        pszServices[0] = 0;
    }

    // Do they want the Common Files\Microsoft Shared\Stationery Directory?
    if (dwWant & 8)
    {
        Assert(pszStationery);
        pszStationery[0] = 0;
    }

    // Program Files\Common Files\System  and \Services
    if (dwWant & (2 | 4 | 8))
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegWinCurrVer, 0, KEY_QUERY_VALUE, &hkeyT))
        {
            cb = sizeof(szTemp2);
            if (ERROR_SUCCESS == RegQueryValueEx(hkeyT, c_szCommonFilesDir, 0, &dwType, (LPBYTE)szTemp2, &cb))
            {
                // Forget about the null in count
                cb--;

                if (*CharPrev(szTemp2, szTemp2+cb) != '\\')
                {
                    szTemp2[cb++] = '\\';
                    szTemp2[cb]=0;
                }

                if (REG_EXPAND_SZ == dwType)
                {
                    ExpandEnvironmentStrings(szTemp2, szTemp, ARRAYSIZE(szTemp));
                    StrCpyN(szTemp2, szTemp, ARRAYSIZE(szTemp2));
                }

                cb = lstrlen(szTemp2);

                if (dwWant & 2)
                {
                    StrCpyN(pszSystem, szTemp2, MAX_PATH);
                    
                    // "System" could be localized 
                    LoadString(g_hInstance, IDS_DIR_SYSTEM, &pszSystem[cb], MAX_PATH-cb);

                    dwWant |= 2;
                }

                if (dwWant & 4)
                {
                    StrCpyN(pszServices, szTemp2, MAX_PATH);

                    // "Services" could be localized
                    LoadString(g_hInstance, IDS_DIR_SERVICES, &pszServices[cb],  MAX_PATH-cb);

                    dwWant |= 4;
                }

                if (dwWant & 8)
                {
                    StrCpyN(pszStationery, szTemp2, MAX_PATH);

                    // "Microsoft Shared\Stationery could be localized
                    LoadString(g_hInstance, IDS_DIR_STAT, &pszStationery[cb], MAX_PATH-cb);

                    dwWant |= 8;
                }
            }
            RegCloseKey(hkeyT);
        }
    }

    return dwWant;
}


/*******************************************************************

  NAME:       RepairBeta1Install

  SYNOPSIS:   See what happens when people make late design decisions!
  
********************************************************************/
typedef struct tagRepairInfo
{
    LPTSTR pszFile;
    LPTSTR pszDir;
} REPAIRINFO;

typedef struct tagRegInfo
{
   LPCTSTR pszRoot;
   LPTSTR pszSub;
   LPCTSTR pszValue;
} REGINFO;

void RepairBeta1Install()
{
    HKEY hkeyOE, hkeyWAB;
    TCHAR szOEUninstallFile [MAX_PATH];
    TCHAR szOEUninstallDir  [MAX_PATH];
    TCHAR szWABUninstallFile[MAX_PATH];
    TCHAR szWABUninstallDir [MAX_PATH];
    TCHAR szTemp            [MAX_PATH];
    DWORD cb, dwType, dwTemp;

    LOG("Attempting to repair Beta 1 Install...");

    ZeroMemory(szTemp, ARRAYSIZE(szTemp));
    switch (si.saApp)
    {
    case APP_WAB:
        // Do we have the needed Advpack functionality?
        if (NULL == si.pfnAddDel || NULL == si.pfnRegRestore)
        {
            LOG("[ERROR]: Extended Advpack functionality is needed but could not be found");
            break;
        }

        // Figure out where the OE backup is
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegAdvInfoOE, 0, KEY_READ, &hkeyOE))
        {
            // Make sure we can create the AddressBook Key
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szRegAdvInfoWAB, 0, NULL, REG_OPTION_NON_VOLATILE, 
                                                KEY_READ | KEY_WRITE, NULL, &hkeyWAB, &cb))
            {
                cb = sizeof(szOEUninstallFile);
                if (ERROR_SUCCESS == RegQueryValueEx(hkeyOE, c_szBackupFileName, 0, &dwType, (LPBYTE)szOEUninstallFile, &cb))
                {
                    UINT uLenWAB, uLenOE;
                    
                    if (REG_EXPAND_SZ == dwType)
                    {
                        ExpandEnvironmentStrings(szOEUninstallFile, szTemp, ARRAYSIZE(szTemp));
                        StrCpyN(szOEUninstallFile, szTemp, ARRAYSIZE(szOEUninstallFile));

                        // Figure out where to change the extension for OE (4 = .DAT)    
                        uLenOE = lstrlen(szOEUninstallFile) - 4;
                    }
                    else
                        // Figure out where to change the extension for OE (5 = .DAT + NULL from Query)
                        uLenOE = cb - 5;

                    // Can we get to it?
                    if (0xFFFFFFFF != GetFileAttributes(szOEUninstallFile))
                    {
                        LPTSTR pszSlash, pszCurrent;

                        cb = sizeof(szOEUninstallDir);
                        if (ERROR_SUCCESS == RegQueryValueEx(hkeyOE, c_szBackupPath, 0, &dwType, (LPBYTE)szOEUninstallDir, &cb))
                        {
                            if (REG_EXPAND_SZ == dwType)
                            {
                                ExpandEnvironmentStrings(szOEUninstallDir, szTemp, ARRAYSIZE(szTemp));
                                StrCpyN(szOEUninstallDir, szTemp, ARRAYSIZE(szOEUninstallDir));
                            }

                            // Figure out the destination for the file
                            StrCpyN(szWABUninstallDir, szOEUninstallDir, ARRAYSIZE(szWABUninstallDir));

                            pszCurrent = szWABUninstallDir;
                            pszSlash   = NULL;
                
                            // Parse the string looking for the last slash
                            while (*pszCurrent)
                            {
                                if (*pszCurrent == TEXT('\\'))
                                    pszSlash = CharNext(pszCurrent);

                                pszCurrent = CharNext(pszCurrent);
                            }

                            if (NULL != pszSlash)
                            {
                                TCHAR szOE       [MAX_PATH];
                                TCHAR szCommonSys[MAX_PATH];
                                TCHAR szHelp     [MAX_PATH];
                                TCHAR szStat     [MAX_PATH];
                                TCHAR szServices [MAX_PATH];
                                TCHAR szFiles[5 * MAX_PATH];

                                int i,j;

                                szOE[0]        = 0;
                                szCommonSys[0] = 0;
                                szHelp[0]      = 0;
                                szStat[0]      = 0;
                                szServices[0]  = 0;

#if 0
                                // Files to remove from OE and WAB - 0
                                const REPAIRINFO   BOTHDel[]= {};
#endif
                                
                                // Files to remove from OE - 19
                                const REPAIRINFO   OEDel[]  = {
    {"wab32.dll",    szCommonSys}, {"wab.hlp"   ,   szHelp},       {"wab.chm",      szHelp},      {"wab.exe",      szOE},
    {"wabmig.exe",   szOE},        {"wabimp.dll",   szOE},         {"wabfind.dll",  szOE},        {"msoeacct.dll", si.szSysDir},
    {"msoert2.dll",  si.szSysDir}, {"msoeacct.hlp", szHelp},       {"conn_oe.hlp",  szHelp},      {"conn_oe.cnt",  szHelp},
    {"wab.cnt",      szHelp},      {"wab32.dll",    si.szSysDir},  {"wabfind.dll",  si.szSysDir}, {"wabimp.dll",   si.szSysDir},
    {"wab.exe",      si.szWinDir}, {"wabmig.exe",   si.szWinDir}};

                                // Files to remove from WAB - 62
                                const REPAIRINFO   WABDel[] = {
    {"msoeres.dll",  szOE},        {"msoe.dll",     szOE},         {"msoe.hlp",     szHelp},      {"msoe.chm",     szHelp},
    {"msoe.txt",     szOE},        {"oeimport.dll", szOE},         {"inetcomm.dll", si.szSysDir}, {"inetres.dll",  si.szSysDir},
    {"msoemapi.dll", si.szSysDir}, {"msimn.exe",    szOE},         {"inetcomm.hlp", szHelp},      {"msimn.cnt",    szHelp},
    {"msimn.hlp",    szHelp},      {"msimn.chm",    szHelp},       {"msimn.gid",    szHelp},      {"_isetup.exe",  szOE},
    {"msimnui.dll",  szOE},        {"msimn.txt",    szOE},         {"mnlicens.txt", szOE},        {"msimnimp.dll", szOE},
    {"msimn.inf",    si.szInfDir}, {"msoert.dll",   si.szSysDir},
    {"bigfoot.bmp",  szServices},  {"verisign.bmp", szServices},   {"yahoo.bmp",    szServices},
    {"infospce.bmp", szServices},  {"infospbz.bmp", szServices},   {"swtchbrd.bmp", szServices},
    
                               
    {"Baby News.htm",                      szStat},                {"Balloon Party Invitation.htm", szStat}, 
    {"Chicken Soup.htm",                   szStat},                {"Formal Announcement.htm",      szStat}, 
    {"For Sale.htm",                       szStat},                {"Fun Bus.htm",                  szStat}, 
    {"Holiday Letter.htm",                 szStat},                {"Mabel.htm",                    szStat}, 
    {"Running Birthday.htm",               szStat},                {"Story Book.htm",               szStat}, 
    {"Tiki Lounge.htm",                    szStat},                {"Ivy.htm",                      szStat},
    {"One Green Balloon.gif",              szStat},                {"Baby News Bkgrd.gif",          szStat}, 
    {"Chess.gif",                          szStat},                {"Chicken Soup Bkgrd.gif",       szStat}, 
    {"Formal Announcement Bkgrd.gif",      szStat},                {"For Sale Bkgrd.gif",           szStat}, 
    {"FunBus.gif",                         szStat},                {"Holiday Letter Bkgrd.gif",     szStat}, 
    {"MabelT.gif",                         szStat},                {"MabelB.gif",                   szStat}, 
    {"Running.gif",                        szStat},                {"Santa Workshop.gif",           szStat}, 
    {"Soup Bowl.gif",                      szStat},                {"Squiggles.gif",                szStat}, 
    {"StoryBook.gif",                      szStat},                {"Tiki.gif",                     szStat}, 
    {"Christmas Trees.gif",                szStat},                {"Ivy.gif",                      szStat}, 
    {"Balloon Party Invitation Bkgrd.jpg", szStat},                {"Technical.htm",                szStat},
    {"Chess.htm",                          szStat},                {"Tech.gif",                     szStat}};

                                // Reg settings to remove from OE - 
                                const REGINFO OERegDel[] = {
    {c_szHKLM, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wab.exe", c_szEmpty},
    {c_szHKLM, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wab.exe", c_szRegPath},
    {c_szHKLM, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wabmig.exe", c_szEmpty},
    {c_szHKLM, "Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\wabmig.exe", c_szRegPath},
    {c_szHKLM, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\InternetMailNews", NULL}};
    //{c_szHKLM, "Software\\Microsoft\\Outlook Express", c_szInstallRoot}};

                                const REGINFO WABRegDel[] = {
    {c_szHKLM, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OptionalComponents\\OutlookExpress", "Installed"},
    {c_szHKLM, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\OutlookExpress", "DisplayName"},
    {c_szHKLM, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\OutlookExpress", "UninstallString"},
    {c_szHKLM, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\OutlookExpress", "QuietUninstallString"},
    {c_szHKLM, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\OutlookExpress", c_szRequiresIESys},
    {c_szHKLM, "Software\\Microsoft\\Outlook Express", "InstallRoot"},
    {c_szHKLM, "Software\\Microsoft\\Outlook Express\\Inetcomm", "DllPath"},
    {c_szHKLM, "Software\\Microsoft\\Outlook Express", "Beta"},
    {c_szHKLM, "Software\\Clients\\Mail\\Outlook Express", NULL},
    {c_szHKLM, "Software\\Clients\\News\\Outlook Express", NULL},
    {c_szHKLM, "Software\\Clients\\Mail\\Internet Mail and News", NULL},
    {c_szHKLM, "Software\\Clients\\News\\Internet Mail and News", NULL},
    {c_szHKLM, "Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\InternetMailNews", NULL}};
    //{c_szHKLM, "Software\\Microsoft\\Outlook Express", c_szInstallRoot}};


                                // Append the path to the addressbook dir
                                StrCpyN(pszSlash, c_szWABComponent, ARRAYSIZE(szWABUninstallDir) - (DWORD)(pszSlash - szWABUninstallDir));
                                
                                // Create a directory
                                CreateDirectoryEx(szOEUninstallDir, szWABUninstallDir, NULL);

                                // Copy Reg
                                CopyRegistry(hkeyOE, hkeyWAB);

                                // If running on 9X, copy the AINF file too
                                if (VER_PLATFORM_WIN32_WINDOWS == si.osv.dwPlatformId)
                                {
                                    cb = sizeof(szTemp);
                                    if (ERROR_SUCCESS == RegQueryValueEx(hkeyOE, c_szBackupRegPathName, 0, NULL, (LPBYTE)szTemp, &cb))
                                    {
                                        // Can't be REG_EXPAND_SZ, this is Win9X!

                                        // Strip all but the filename
                                        pszCurrent = szTemp;
                                        pszSlash   = NULL;
                
                                        // Parse the string looking for the last slash
                                        while (*pszCurrent)
                                        {
                                            if ('\\' == *pszCurrent)
                                                pszSlash = CharNext(pszCurrent);

                                            pszCurrent = CharNext(pszCurrent);
                                        }

                                        if (pszSlash)
                                        {
                                            TCHAR szWABShortDir[MAX_PATH]; 

                                            // Combine the WAB dir name and the name of the OE file
                                            wnsprintf(szWABShortDir, ARRAYSIZE(szWABShortDir), c_szPathFileFmt, szWABUninstallDir, pszSlash);
                                            
                                            // Shorten destination
                                            GetShortPathName(szWABShortDir, szWABShortDir, ARRAYSIZE(szWABShortDir));
                                            
                                            // Write it into the registry (+1 for the NULL)
                                            RegSetValueEx(hkeyWAB, c_szBackupRegPathName, 0, REG_SZ, (LPBYTE)szWABShortDir, (lstrlen(szWABShortDir)+1)*sizeof(TCHAR));

                                            // Copy the file
                                            CopyFile(szTemp, szWABShortDir, TRUE);
                                        }
                                    }
                                }

                                // Figure out the path the to wab INI and DAT
                                StrCpyN(szWABUninstallFile, szWABUninstallDir, ARRAYSIZE(szWABUninstallFile));

                                // Add Slash and component
                                StrCatBuff(szWABUninstallFile, c_szSlashWABComponent, ARRAYSIZE(szWABUninstallFile));

                                // Calculate the length for extension placement
                                uLenWAB = lstrlen(szWABUninstallFile);

                                // Do the DAT first                                
                                StrCpyN(&szWABUninstallFile[uLenWAB], c_szDotDAT, ARRAYSIZE(szWABUninstallFile) - uLenWAB);

                                // Patch the path names in the registry
                                cb = (lstrlen(szWABUninstallDir) + 1) * sizeof(TCHAR);
                                RegSetValueEx(hkeyWAB, c_szBackupPath, 0, REG_SZ, (LPBYTE)szWABUninstallDir, cb);
                                cb = (lstrlen(szWABUninstallFile) + 1) * sizeof(TCHAR);
                                RegSetValueEx(hkeyWAB, c_szBackupFileName, 0, REG_SZ, (LPBYTE)szWABUninstallFile, cb);

                                // ---- CALCULATE DIRECTORY NAMES
                                dwTemp = GetDirNames(1 | 2 | 4 | 8, szOE, szCommonSys, szServices, szStat);
                                
                                if (VER_PLATFORM_WIN32_WINDOWS == si.osv.dwPlatformId)
                                {
                                    if (dwTemp & 1)
                                        GetShortPathName(szOE, szOE, ARRAYSIZE(szOE));
                                    if (dwTemp & 2)
                                        GetShortPathName(szCommonSys, szCommonSys, ARRAYSIZE(szCommonSys));
                                    if (dwTemp & 4)
                                        GetShortPathName(szServices,  szServices,  ARRAYSIZE(szServices));
                                    if (dwTemp & 8)
                                        GetShortPathName(szStat,      szStat,      ARRAYSIZE(szStat));
                                }

                                // Help Dir
                                StrCpyN(szHelp, si.szWinDir, ARRAYSIZE(szHelp));
                                cb = lstrlen(szHelp);
                                LoadString(g_hInstance, IDS_DIR_HELP, &szHelp[cb], ARRAYSIZE(szHelp)-cb);
                                if (VER_PLATFORM_WIN32_WINDOWS == si.osv.dwPlatformId)
                                    GetShortPathName(szHelp, szHelp, ARRAYSIZE(szHelp));

                                // ---- MANIPULATE FILES
                                
                                // Copy the DAT file to AddressBook land
                                CopyFile(szOEUninstallFile, szWABUninstallFile, TRUE);

                                StrCpyN(&szOEUninstallFile[uLenOE], c_szDotINI, ARRAYSIZE(szOEUninstallFile) - uLenOE);
                                StrCpyN(&szWABUninstallFile[uLenWAB], c_szDotINI, ARRAYSIZE(szWABUninstallFile) - uLenWAB);

                                // Copy the INI file to AddressBook land
                                CopyFile(szOEUninstallFile, szWABUninstallFile, TRUE);

                                // Purge Files from OE - 5 at a time
                                for (i=0; i < ARRAYSIZE(OEDel);)
                                {
                                    for (j=i, cb=0; i < ARRAYSIZE(OEDel) && i-j < 5; i++)
                                        cb += wnsprintf(&szFiles[cb++], ARRAYSIZE(szFiles) - cb, 
                                                        c_szFileEntryFmt, OEDel[i].pszDir, OEDel[i].pszFile);
                                    szFiles[cb] = 0;

                                    (*si.pfnAddDel)(szFiles, szOEUninstallDir, c_szOEComponent, AADBE_DEL_ENTRY);
                                }

                                // Purge Files from WAB - 5 at a time
                                for (i=0; i<ARRAYSIZE(WABDel);)
                                {
                                    for (j=i, cb=0; i < ARRAYSIZE(WABDel) && i-j < 5; i++)
                                        cb += wnsprintf(&szFiles[cb++], ARRAYSIZE(szFiles) - cb, 
                                                        c_szFileEntryFmt, WABDel[i].pszDir, WABDel[i].pszFile);
                                    szFiles[cb] = 0;
 
                                    (*si.pfnAddDel)(szFiles, szWABUninstallDir, c_szWABComponent, AADBE_DEL_ENTRY);
                                }


                                // ---- REPAIR Registry
                                HKEY hkeyOEBak=NULL;
                                HKEY hkeyWABBak=NULL;

                                if (VER_PLATFORM_WIN32_WINDOWS != si.osv.dwPlatformId)
                                {
                                    // On non-Win95, we need to open a sub key of the backup info
                                    RegOpenKeyEx(hkeyOE, c_szRegBackup, 0, KEY_READ | KEY_WRITE, &hkeyOEBak);
                                    RegOpenKeyEx(hkeyWAB, c_szRegBackup, 0, KEY_READ | KEY_WRITE, &hkeyWABBak);
                                }
                                else
                                {
                                    hkeyOEBak = hkeyOE;
                                    hkeyWABBak = hkeyWAB;
                                }

                                if (NULL != hkeyOEBak)
                                {
                                    // Remove settings from OE that we want bundled with the WAB
                                    for (i=0; i<ARRAYSIZE(OERegDel); i++)
                                    {
                                        (*si.pfnRegRestore)(NULL, NULL, hkeyOEBak, OERegDel[i].pszRoot, OERegDel[i].pszSub, 
                                                            OERegDel[i].pszValue, ARSR_RESTORE | ARSR_REMOVREGBKDATA | ARSR_NOMESSAGES);
                                    }

                                    if (VER_PLATFORM_WIN32_WINDOWS != si.osv.dwPlatformId)
                                        RegCloseKey(hkeyOEBak);
                                }

                                if (NULL != hkeyWABBak)
                                {

                                    // Remove settings from WAB that we want bundled with OE
                                    for (i=0; i<ARRAYSIZE(WABRegDel); i++)
                                    {
                                        (*si.pfnRegRestore)(NULL, NULL, hkeyWABBak, WABRegDel[i].pszRoot, WABRegDel[i].pszSub, 
                                                            WABRegDel[i].pszValue, ARSR_RESTORE | ARSR_REMOVREGBKDATA | ARSR_NOMESSAGES);
                                    }

                                    if (VER_PLATFORM_WIN32_WINDOWS != si.osv.dwPlatformId)
                                        RegCloseKey(hkeyWABBak);
                                }

                                // If v1 or v1.1 preceded Beta1, restore reg settings that Beta1 deleted so we can roll them
                                SETUPVER svPrev;
                                GetVerInfo(NULL, &svPrev);
                                if (VER_1_0 == svPrev || VER_1_1 == svPrev)
                                {
                                    // Restore IMN reg
                                    wnsprintf(szTemp, ARRAYSIZE(szTemp), c_szFileEntryFmt, si.szInfDir, si.pszInfFile);
                                    (*si.pfnRunSetup)(NULL, szTemp, (VER_1_1 == svPrev ? c_szRestoreV1WithWAB : c_szRestoreV1),
                                      si.szInfDir, si.szAppName, NULL, RSC_FLAG_INF | RSC_FLAG_NGCONV | OE_QUIET, 0);
                                }
                            }
                        }
                    }
                }
                RegCloseKey(hkeyWAB);
            }
            RegCloseKey(hkeyOE);
        }
        break;

    default:
        break;
    }

    LOG("Repair attempt complete.");
    
}


/*******************************************************************

  NAME:       RespectRedistMode()

  SYNOPSIS:   Sees if IE is installing in redist mode, and persists
              state so per-user install stubs can respect it
  
********************************************************************/
void RespectRedistMode()
{
    HKEY hkey;
    BOOL fRedistMode = FALSE;
    DWORD dwDisp;
    DWORD dwInstallMode = 0;
    DWORD dwType;
    DWORD cb;

    // Is IE Setup running in redist mode, /x or /x:1?
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szIESetupKey, 0, KEY_READ, &hkey))
    {
        cb = sizeof(dwInstallMode);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szIEInstallMode, 0, &dwType, (LPBYTE)&dwInstallMode, &cb))
        {
            if (REG_DWORD == dwType)
                fRedistMode = ((REDIST_REMOVELINKS | REDIST_DONT_TAKE_ASSOCIATION) & dwInstallMode) > 0;
            else
                AssertSz(FALSE, "IE has changed the encoding of their redist mode flag, ignoring");
        }
        
        RegCloseKey(hkey);
    }

    // Let setup know which mode to run in
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dwDisp))
    {
        if (fRedistMode)
        {
            // Our setup only has one redist mode
            dwInstallMode = 1;
            RegSetValueEx(hkey, c_szIEInstallMode, 0, REG_DWORD, (LPBYTE)&dwInstallMode, sizeof(dwInstallMode));
        }
        else
        {
            RegDeleteValue(hkey, c_szIEInstallMode);
        }

        RegCloseKey(hkey);
    }
}


/*******************************************************************

  NAME:       FDependenciesPresent
  
********************************************************************/
BOOL FDependenciesPresent(BOOL fPerm)
{
    BOOL fPresent = FALSE;
    TCHAR szOE[MAX_PATH];
    TCHAR szCommonSys[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    REPAIRINFO *pRI;
    int n, i;
    HINSTANCE hInst;

    if (VER_PLATFORM_WIN32_NT == si.osv.dwPlatformId)
    {
        LOG("Avoiding run-time dependency check as we are on NT.  Reboot will be required.");
        return FALSE;
    }
    
    LOG("Verifying run-time dependencies...");
    
    // List of Dlls that we regsvr32 in OE
    const REPAIRINFO OEDlls[] = {
    {"inetcomm.dll", si.szSysDir}, {"msoe.dll", szOE},             {"oeimport.dll", szOE}};
    
    // List of Dlls that we regsvr32 in WAB
    const REPAIRINFO WABDlls[]  = {
    {"msoeacct.dll", si.szSysDir},  {"wab32.dll",    szCommonSys},  {"wabfind.dll",  szOE},        {"wabimp.dll",   szOE}};

    // List of Dlls that we regsvr32 permanently in OE
    const REPAIRINFO OEDllsPerm[] = {
    {"directdb.dll", szCommonSys},  {"oemiglib.dll", szOE}};

    // List of Dlls that we regsvr32 permanently in WAB
    //const REPAIRINFO WABDllsPerm[] = {};


    switch (si.saApp)
    {
    case APP_OE:
        if (fPerm)
        {
            // Need OE dir and common sys dir for OEDllsPerm
            if (3 == GetDirNames(1 | 2, szOE, szCommonSys, NULL, NULL))
            {
                pRI = (REPAIRINFO*)OEDllsPerm;
                n = ARRAYSIZE(OEDllsPerm);
            }
            else
                return FALSE;
        }
        else
        {
            // Only need OE dir for OEDlls
            if (1 == GetDirNames(1, szOE, NULL, NULL, NULL))
            {
                pRI = (REPAIRINFO*)OEDlls;
                n = ARRAYSIZE(OEDlls);
            }
            else
                return FALSE;
        }
        break;

    case APP_WAB:
        if (fPerm)
        {
            //pRI = (REPAIRINFO*)OEDllsPerm;
            //n = ARRAYSIZE(OEDllsPerm);
            return TRUE;
        }                
        else
        {
            if (3 == GetDirNames(1 | 2, szOE, szCommonSys, NULL, NULL))
            {
                pRI = (REPAIRINFO*)WABDlls;
                n = ARRAYSIZE(WABDlls);
            }
            else
                return FALSE;
        }
        break;

    default:
        Assert(FALSE);
        return FALSE;
    }

    fPresent = TRUE;

    for (i = 0; fPresent && (i < n); i++)
    {
        Assert(*(pRI[i].pszDir));
        Assert(*(pRI[i].pszFile));

        wnsprintf(szTemp, ARRAYSIZE(szTemp), c_szFileEntryFmt, pRI[i].pszDir, pRI[i].pszFile);
        if (hInst = LoadLibrary(szTemp))
            FreeLibrary(hInst);
        else
        {
            LOG("Unable to load ");
            LOG2(szTemp);
            LOG("Reboot required.");
            fPresent = FALSE;
        }
    }

    return fPresent;
}


/*******************************************************************

  NAME:       UpdateStubInfo
  
********************************************************************/
void UpdateStubInfo(BOOL fInstall)
{
    LPCTSTR pszGUID;
    HKEY hkeySrcRoot, hkeySrc, hkeyDestRoot, hkeyDest;
    DWORD cb, dwType;
    TCHAR szTemp[MAX_PATH];
    
    switch (si.saApp)
    {
    case APP_OE:
        pszGUID = c_szOEGUID;
        break;
    case APP_WAB:
        pszGUID = c_szWABGUID;
        break;
    default:
        return;
    }

    if (fInstall)
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegASetup, 0, KEY_READ, &hkeySrcRoot))
        {
            if (ERROR_SUCCESS == RegOpenKeyEx(hkeySrcRoot, pszGUID, 0, KEY_QUERY_VALUE, &hkeySrc))
            {
                if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegASetup, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyDestRoot, &dwType))
                {
                    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyDestRoot, pszGUID, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyDest, &dwType))
                    {
                        // Copy Version and Locale
                        // BUGBUG: Make this extensible via a registry list of values to copy
                        cb = sizeof(szTemp);
                        if (ERROR_SUCCESS == RegQueryValueEx(hkeySrc, c_szValueVersion, 0, &dwType, (LPBYTE)szTemp, &cb))
                            RegSetValueEx(hkeyDest, c_szValueVersion, 0, dwType, (LPBYTE)szTemp, cb);
                        cb = sizeof(szTemp);
                        if (ERROR_SUCCESS == RegQueryValueEx(hkeySrc, c_szLocale, 0, &dwType, (LPBYTE)szTemp, &cb))
                            RegSetValueEx(hkeyDest, c_szLocale, 0, dwType, (LPBYTE)szTemp, cb);

                        RegCloseKey(hkeyDest);
                    }
                    RegCloseKey(hkeyDestRoot);
                }
                RegCloseKey(hkeySrc);
            }
            RegCloseKey(hkeySrcRoot);
        }
    }
    else
    {
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegASetup, 0, KEY_WRITE | KEY_READ, &hkeyDestRoot))
        {
            RegDeleteKeyRecursive(hkeyDestRoot, pszGUID);    
            RegCloseKey(hkeyDestRoot);
        }
    }
}

/*******************************************************************

  NAME:       LaunchINFSectionExWorks

  SYNOPSIS:   IE 5.0 has a bug in which LaunchINFSectionEx does not
              work properly (it can return S_OK when files are in
              use).  IE backed out my fix as it broke the 12 lang
              packs.  This should be fixed soon though.  If we 
              ship 5.0 with OSR we can just tweak the INF to turn
              on the correct behaviour.
  
********************************************************************/
BOOL LaunchINFSectionExWorks()
{
    HKEY hkey;
    DWORD dw=0, cb;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, KEY_QUERY_VALUE, &hkey))
    {
        cb = sizeof(dw);
        RegQueryValueEx(hkey, c_szLaunchWorks, 0, NULL, (LPBYTE)&dw, &cb);
        RegCloseKey(hkey);
    }

    return !!dw;
}


/*******************************************************************

  NAME:       InstallMachine
  
********************************************************************/
HRESULT InstallMachine()
{
    TCHAR szInfFile[MAX_PATH], szArgs[MAX_PATH * 2];
    SETUPVER svPrevVer;
    BOOL fNeedReboot = FALSE;
    BOOL fLaunchEx;
    HRESULT hrT;
    
    // Update version info for previous ver
    HandleVersionInfo(FALSE);

    if (CALLER_IE == si.caller)
    {
        // See if IE is installing in redist mode
        // For more info see: http://ie/specs/secure/corpsetup/batchinstall.htm
        RespectRedistMode();

        // Bug 66967
        // LaunchINFSectionEx for IE 5.0 does not return accurate reboot info
        fLaunchEx = LaunchINFSectionExWorks();

        // Special case OE5 B1
        if (InterimBuild(&svPrevVer) && VER_5_0_B1 == svPrevVer)
            RepairBeta1Install();
        
        // Perform Permanent portion of setup (excluding DLL reg)
        wnsprintf(szInfFile, ARRAYSIZE(szInfFile), c_szPathFileFmt, si.szCurrentDir, si.pszInfFile);
        hrT = (*si.pfnRunSetup)(NULL, szInfFile, c_szMachineInstallSection, si.szCurrentDir, si.szAppName, NULL, RSC_FLAG_INF | RSC_FLAG_NGCONV | OE_QUIET, 0);

        // See if the file copies need a reboot
        if (!fLaunchEx || (ERROR_SUCCESS_REBOOT_REQUIRED == hrT))
            fNeedReboot = TRUE;
        else
            // See if we are going to need a reboot anyway because our perm dlls won't load
            fNeedReboot = !FDependenciesPresent(TRUE);
    
        // Register the Perm dlls keeping in mind whether we'll need a reboot
        (*si.pfnRunSetup)(NULL, szInfFile, c_szRegisterPermOCX, si.szCurrentDir, si.szAppName, NULL, RSC_FLAG_INF | RSC_FLAG_NGCONV | OE_QUIET | (fNeedReboot ? RSC_FLAG_DELAYREGISTEROCX : 0), 0);
    
        PreRollable();

        // Perform Rollable portion of setup (excluding DLL reg)
        wnsprintf(szArgs, ARRAYSIZE(szArgs), c_szLaunchFmt, szInfFile, c_szMachineInstallSectionEx, c_szEmpty, ALINF_BKINSTALL | ALINF_NGCONV | OE_QUIET | (fNeedReboot ? RSC_FLAG_DELAYREGISTEROCX : 0));
        hrT = (*si.pfnLaunchEx)(NULL, NULL, szArgs, 0);

        // If we've gotten away without needing a reboot so far...
        if (!fNeedReboot)
        {
            // See if the file copies need a reboot
            if (ERROR_SUCCESS_REBOOT_REQUIRED == hrT)
                fNeedReboot = TRUE;
            else
                // See if we are going to need a reboot anyway because our rollable dlls won't load
                fNeedReboot = !FDependenciesPresent(FALSE);
        }
    
        // Register OCXs
        (*si.pfnRunSetup)(NULL, szInfFile, c_szRegisterOCX, si.szCurrentDir, si.szAppName, NULL, RSC_FLAG_INF | RSC_FLAG_NGCONV | OE_QUIET | (fNeedReboot ? RSC_FLAG_DELAYREGISTEROCX : 0), 0);
    }
    else
        // We delayed writing the active setup ver so that HandleVersionInfo could sniff it, but must put it in now.
        ApplyActiveSetupVer();

    // Run any need post setup goo
    RunPostSetup();
    
    // Handle setting default handlers
    SetHandlers();
    
    // Update version info for current version
    HandleVersionInfo(TRUE);

    // Run the User stub if we can (don't run per-user goo at the end of NT GUI mode setup)
    if (!fNeedReboot && (CALLER_WINNT != si.caller))
    {
        InstallUser();
        // Ensure stub cleanup will run if they immediately uninstall
        UpdateStubInfo(TRUE);
        return S_OK;
    }
    
    return ERROR_SUCCESS_REBOOT_REQUIRED;
}


/*******************************************************************

  NAME:       InstallUser
  
********************************************************************/
void InstallUser()
{
    TCHAR szInfFile[MAX_PATH];
    
    // Move settings under this version's key in the registry
    UpgradeSettings();
    
    // Call the UserInstall section of the inf
    wnsprintf(szInfFile, ARRAYSIZE(szInfFile), c_szFileEntryFmt, si.szInfDir, si.pszInfFile);    

    const TCHAR *pszUserInstallSection;

    //  If it's OE and we're on XP SP1 or later, we will let the OEAccess component in shmgrate.exe
    //  take care of showing/hiding icons
    if ((0 == lstrcmpi(c_szMsimnInf, si.pszInfFile)) && IsXPSP1OrLater())
    {
        pszUserInstallSection = c_szUserInstallSectionOEOnXPSP1OrLater;
    }
    else
    {
        pszUserInstallSection = c_szUserInstallSection;
    }
    (*si.pfnRunSetup)(NULL, szInfFile, pszUserInstallSection, si.szInfDir, si.szAppName, NULL, RSC_FLAG_INF | OE_QUIET, 0);
    
    // Create Desktop, Quick launch and start menu icons
    HandleLinks(TRUE);

    if (IsXPSP1OrLater())
    {
        TCHAR szCmdLine[MAX_PATH];

        GetSystemDirectory(szCmdLine, ARRAYSIZE(szCmdLine));

        DWORD cb = 0;
        PathAddSlash(szCmdLine, &cb);

        int cch = lstrlen(szCmdLine);
        
        StrCpyN(szCmdLine + cch, ("shmgrate.exe"), ARRAYSIZE(szCmdLine) - cch);

        ShellExecute(NULL, NULL, szCmdLine, TEXT("OCInstallUserConfigOE"), NULL, SW_SHOWDEFAULT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\wizard\strings.h ===
#ifndef _STRINGS_H_
#define _STRINGS_H_

#include <strconst.h>
#include <ntverp.h>

// ********** R E G I S T R Y
#define STR_REG_ADV_INFO            "Software\\Microsoft\\Advanced INF Setup"
#define STR_FILE_WAB                "AddressBook"
#define STR_FILE_OE                 "OutlookExpress"


STR_GLOBAL(c_szOutlookNews,         "Software\\Microsoft\\Office\\8.0\\Outlook\\Newsreader");
    STR_GLOBAL(c_szNewsPath,        "NewsPath");

    STR_GLOBAL(c_szVERnone,         "None");
    STR_GLOBAL(c_szVER1_0,          "1.0");
    STR_GLOBAL(c_szVER1_1,          "1.1");
    STR_GLOBAL(c_szVER4_0,          "4.0x");
    STR_GLOBAL(c_szVER5B1,          "5.0");
    STR_GLOBAL(c_szVER5_0,          "5.x");
    STR_GLOBAL(c_szVER5B1old,       "5.0 B1");
    STR_GLOBAL(c_szBLDnone,         "0,00,0000,0");
    STR_GLOBAL(c_szBLD1_0,          "1,00,0000,0");
    STR_GLOBAL(c_szBLD1_1,          "1,01,0000,0");
    STR_GLOBAL(c_szBLD4_0,          "4,72,2106,8");
    STR_GLOBAL(c_szBLD5B1,          "5,00,518,0");
    // Only used in a pinch
    STR_GLOBAL(c_szBLDnew,          "5,00,0809,0100");
    STR_GLOBAL(c_szRegProfiles,     "Profiles");
    STR_GLOBAL(c_szReg50,           "5.0");
STR_GLOBAL(c_szRegMailPop3,         "Mail\\POP3");
STR_GLOBAL(c_szRegVerInfo,          STR_REG_PATH_FLAT "\\Version Info");
STR_GLOBAL(c_szRegSharedSetup,      STR_REG_PATH_ROOT "\\Shared Settings\\Setup");
STR_GLOBAL(c_szWABRegSharedSetup,   STR_REG_WAB_ROOT  "\\Shared Settings\\Setup");
STR_GLOBAL(c_szRegNoBakInfo,        "No Backup Info");
STR_GLOBAL(c_szRegCurrVerMinor,     "Current Minor");
STR_GLOBAL(c_szRegAcctMgr,          STR_REG_IAM_FLAT);
STR_GLOBAL(c_szRegAcctMgrAccts,     STR_REG_IAM_FLAT  "\\Accounts");
STR_GLOBAL(c_szRegWAB,              STR_REG_WAB_FLAT);
#define c_szQuickLaunchDir_LEN      41
STR_GLOBAL(c_szQuickLaunchDir,      "Microsoft\\Internet Explorer\\Quick Launch\\");
STR_GLOBAL(c_szUserName,            "UserName");
STR_GLOBAL(c_szRegASetup,           "Software\\Microsoft\\Active Setup\\Installed Components");
STR_GLOBAL(c_szBackupPath,          "BackupPath");
STR_GLOBAL(c_szDesktop,             "Desktop");
STR_GLOBAL(c_szValueCommonDTop,     "Common Desktop");
STR_GLOBAL(c_szIsInstalled,         "IsInstalled");
STR_GLOBAL(c_szRegUninstall,        STR_REG_WIN_ROOT "\\Uninstall");
STR_GLOBAL(c_szRegUninstallWAB,     "AddressBook");
STR_GLOBAL(c_szQuietUninstall,      "QuietUninstallString");
STR_GLOBAL(c_szSettingsToLWP,       "MigToLWP");
STR_GLOBAL(c_szSettingsToLWPVer,    "MigToLWPVer");
STR_GLOBAL(c_szRegAdvInfoWAB,       STR_REG_ADV_INFO "\\" STR_FILE_WAB);
STR_GLOBAL(c_szRegAdvInfoOE,        STR_REG_ADV_INFO "\\" STR_FILE_OE);
STR_GLOBAL(c_szBackupRegPathName,   "BackupRegPathName");
STR_GLOBAL(c_szBackupFileName,      "BackupFileName");
STR_GLOBAL(c_szBackupDir,           "BackupPath");
STR_GLOBAL(c_szCommonFilesDir,      "CommonFilesDir");
STR_GLOBAL(c_szHKLM,                "HKLM");
STR_GLOBAL(c_szHKCU,                "HKCU");
STR_GLOBAL(c_szRegBackup,           "RegBackup");
STR_GLOBAL(c_szRequiresIESys,       "RequiresIESysFile");
STR_GLOBAL(c_szRequiresOESys,       "RequiresOESysFile");
STR_GLOBAL(c_szRequiresWABSys,      "RequiresWABSysFile");
STR_GLOBAL(c_szSMAccessories,       "SM_AccessoriesName");
STR_GLOBAL(c_szIEKey,               STR_REG_PATH_IE);
STR_GLOBAL(c_szIESetupKey,          "Software\\Microsoft\\IE Setup\\SETUP");
STR_GLOBAL(c_szIEInstallMode,       "InstallMode");
STR_GLOBAL(c_szDisableOLCheck,      "DisableOL");
STR_GLOBAL(c_szDisablePhoneCheck,   "DisablePH");
STR_GLOBAL(c_szLaunchWorks,         "LaunchWorks");
STR_GLOBAL(c_szLatestINF,           "LatestINF");
STR_GLOBAL(c_szLocale,              "Locale");

// ********** S T R I N G S

// ++++ Command line Options
STR_GLOBAL(c_szUninstallFlag,       "/UNINSTALL");
STR_GLOBAL(c_szInstallFlag,         "/INSTALL");
STR_GLOBAL(c_szUserFlag,            "/USER");
STR_GLOBAL(c_szPromptFlag,          "/PROMPT");
STR_GLOBAL(c_szAppFlag,             "/APP");
STR_GLOBAL(c_szCallerFlag,          "/CALLER");
STR_GLOBAL(c_szINIFlag,             "/INI");
STR_GLOBAL(c_szIconsFlag,           "/ICONS");
STR_GLOBAL(c_szOFF,                 "OFF");
STR_GLOBAL(c_szAppOE,               "OE");
STR_GLOBAL(c_szAppWAB,              "WAB");
STR_GLOBAL(c_szIE50,                "IE50");
STR_GLOBAL(c_szWIN9X,               "WIN9X");
STR_GLOBAL(c_szWINNT,               "WINNT");

STR_GLOBAL(c_szArgTemplate,         "/root,\"%s\"");
STR_GLOBAL(c_szUnregFmt,            "\"%s\\%s\" /unreg");
STR_GLOBAL(c_szRegFmt,              "\"%s\\%s\" /reg");

STR_GLOBAL(c_szMigFmt,              "%s /type:%s /src:%s /dst:default");
STR_GLOBAL(c_szV1,                  "V5B1-V1");
STR_GLOBAL(c_szV4,                  "V5B1-V4");

// ++++ Filenames
STR_GLOBAL(c_szMsimnInf,            "msoe50.inf");
STR_GLOBAL(c_szWABInf,              "wab50.inf");
STR_GLOBAL(c_szExplorer,            "EXPLORER.EXE");
STR_GLOBAL(c_szWABFindDll,          "wabfind.dll");
STR_GLOBAL(c_szWABFindDllIe3,       "wabfind.ie3");
STR_GLOBAL(c_szOldMainExe,          "msimn.exe");
STR_GLOBAL(c_szInetcomm,            "inetcomm.dll");
STR_GLOBAL(c_szInetres,             "inetres.dll");
STR_GLOBAL(c_szMsoeacct,            "msoeacct.dll");
STR_GLOBAL(c_szMsoert2,             "msoert2.dll");
STR_GLOBAL(c_szFileLog,             "OEWABLog.txt");
STR_GLOBAL(c_szWAB32,               "wab32.dll");
STR_GLOBAL(c_szWABEXE,              "wab.exe");
STR_GLOBAL(c_szMAILNEWS,            "mailnews.dll");
STR_GLOBAL(c_szWABComponent,        STR_FILE_WAB);
STR_GLOBAL(c_szOEComponent,         STR_FILE_OE);
STR_GLOBAL(c_szSlashWABComponent,   "\\" STR_FILE_WAB);
STR_GLOBAL(c_szPhoneExe,            "msphone.exe");
STR_GLOBAL(c_szOutlookExe,          "outlook.exe");

// ++++ msoe50inf sections
STR_GLOBAL(c_szUserInstallSection,  "User.Install");
STR_GLOBAL(c_szUserInstallSectionOEOnXPSP1OrLater, "User.Install.WinXP.SP1OrLater");
STR_GLOBAL(c_szMachineInstallSectionEx,"DefaultInstall_EX");
STR_GLOBAL(c_szMachineInstallSection,"DefaultInstall");
STR_GLOBAL(c_szNewUserRegSection,   "New.User.Reg.Install");
STR_GLOBAL(c_szRestoreV1WithWAB,    "Restore.v1.InstallWithWAB");
STR_GLOBAL(c_szRestoreV1,           "Restore.v1.Install");
STR_GLOBAL(c_szRegisterPermOCX,     "DefaultInstall_PermRegister");
STR_GLOBAL(c_szRegisterOCX,         "DefaultInstall_Register");
STR_GLOBAL(c_szUnRegisterOCX,       "DefaultInstall_UnRegister");
STR_GLOBAL(c_szGenInstallSection,   "GenInstall");
STR_GLOBAL(c_szStringSection,       "Strings");

// ++++ Misc
STR_GLOBAL(c_szBackupSection,       "backup");
STR_GLOBAL(c_szINFSlash,            "INF\\");
STR_GLOBAL(c_szDotINI,              ".INI");
STR_GLOBAL(c_szStarIDX,             "*.IDX");
STR_GLOBAL(c_szDotDAT,              ".DAT");
#define c_szLinkFmt_LEN             4
STR_GLOBAL(c_szLinkFmt,             "%s.lnk");
STR_GLOBAL(c_szLaunchFmt,           "%s,%s,%s,%d");
STR_GLOBAL(c_szFmtMapiMailExt,      "%s.MAPIMail");
STR_GLOBAL(c_szLaunchExFmt,         "%s,%s,%s,%d");
STR_GLOBAL(c_szMachineRevertFmt,    "RevertTo_%s.Machine");
STR_GLOBAL(c_szUserRevertFmt,       "RevertTo_%s.User");
STR_GLOBAL(c_szFileEntryFmt,        "%s%s");
STR_GLOBAL(c_szIE4Dir,              "IE 4.0\\");
STR_GLOBAL(c_szMailGuid,            ".{89292102-4755-11cf-9DC2-00AA006C2B84}");
STR_GLOBAL(c_szNewsGuid,            ".{89292103-4755-11cf-9DC2-00AA006C2B84}");
STR_GLOBAL(c_szOEGUID,              "{44BBA840-CC51-11CF-AAFA-00AA00B6015C}");
STR_GLOBAL(c_szWABGUID,             "{7790769C-0471-11d2-AF11-00C04FA35D02}");
STR_GLOBAL(c_szOLNEWSGUID,          "{70F82C18-3D15-11d1-8596-00C04FB92601}");
STR_GLOBAL(c_szMailSlash,           "Mail\\");
STR_GLOBAL(c_szBackedup,            "20");
STR_GLOBAL(c_szNotBackedup,         "-1");
STR_GLOBAL(c_szVersionOE,           "VERSION_OE");
STR_GLOBAL(c_szAccessoriesString,   "STR_ACCESSORIES_GRP");

#endif // _STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\wizard\util.h ===
#pragma once

HRESULT GetExeVer(LPCTSTR pszExeName, WORD *pwVer, LPTSTR pszVer, int cch);
HRESULT GetFileVer(LPCTSTR pszExePath, LPTSTR pszVer, DWORD cch);
UINT GetSystemWindowsDirectoryWrap(LPTSTR pszBuffer, UINT uSize);
void GetVers(WORD *pwVerCurr,WORD *pwVerPrev);
BOOL GoodEnough(WORD *pwVerGot, WORD *pwVerNeed);
BOOL OEFileBackedUp(LPTSTR pszFullPath, int cch);
int MsgBox(HWND hWnd, UINT nMsgID, UINT uIcon, UINT uButtons);
void ConvertStrToVer(LPCSTR pszStr, WORD *pwVer);
SETUPVER ConvertVerToEnum(WORD *pwVer);
void GetVerInfo(SETUPVER *psvCurr, SETUPVER *psvPrev);
BOOL InterimBuild(SETUPVER *psv);
BOOL GetASetupVer(LPCTSTR pszGUID, WORD *pwVer, LPTSTR pszVer, int cch);
BOOL IsNTAdmin(void);
void RegisterExes(BOOL fReg);

BOOL IsXPSP1OrLater();
DWORD DeleteKeyRecursively(IN HKEY hkey, IN LPCSTR pszSubKey);


#ifdef DEFINE_UTIL
SETUPINFO si;
// Keep this in order with the enumeration SETUPVER in wizdef.h
//                           None         1.0         1.1         4.0         5.0 B1     5.0
#else
extern SETUPINFO si;
#endif

#ifdef SETUP_LOG
#ifdef DEFINE_UTIL
char szLogBuffer[256];
#else
extern char szLogBuffer[256];
#endif

void OpenLogFile();
void CloseLogFile();
void LogMessage(LPTSTR pszMsg, BOOL fNewLine);
void LogRegistry(HKEY hkeyMain, LPTSTR pszSub);
#define LOG_OPEN         OpenLogFile();
#define LOG_CLOSE        CloseLogFile();
#define LOG(_a)          LogMessage(_a, TRUE);       
#define LOG2(_a)         LogMessage(_a, FALSE);       
#define LOGREG(_a,_b)    LogRegistry(_a,_b);

#else

#define LOG_OPEN   
#define LOG_CLOSE  
#define LOG(_a)    
#define LOG2(_a) 
#define LOGREG(_a,_b) 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\wizard\wizard.h ===
#ifndef _WIZARD_H_
#define _WIZARD_H_

#define _MSOERT_
#define MSOERT_NO_STRPARSE
#define MSOERT_NO_BYTESTM
#define MSOERT_NO_ENUMFMT
#define MSOERT_NO_CLOGFILE
#define MSOERT_NO_LISTOBJS

#include <windows.h>
#include <windowsx.h>
#include <regstr.h>
#include <msoert.h>
#include <tchar.h>

#include <comctrlp.h>
#include <shlobj.h>
#ifdef NT_BUILD
#include <shlobjp.h>
#else
#include <shsemip.h>
#endif

#include "wizdef.h"
#include "ids.h"

// Globals

extern HINSTANCE    g_hInstance;     // global module instance handle

// Defines

// functions in PROPMGR.C
void InstallUser();
HRESULT InstallMachine();
void HandleV1Uninstall(BOOL fSetup);
void HandleLinks(BOOL fCreate);
BOOL MigrateSettings();
void CopySettings(HKEY hkey, SETUPVER sv, BOOL bUpgrade);
BOOL bVerInfoExists(SETUPVER sv);
HRESULT CreateLink(LPCTSTR lpszPathObj, LPCTSTR lpszArg, LPCTSTR lpszPathLink, LPCTSTR lpszDesc, LPCTSTR lpszIcon, int iIcon);
BOOL UninstallOEMapi();
void UpdateStubInfo(BOOL fInstall);

// functions in UNINSTALL.C
void UnInstallUser();
BOOL UnInstallMachine();
LONG RegDeleteKeyRecursive(HKEY hKey, LPCTSTR lpszSubKey);
void BackMigrateConnSettings();


// functions in MENU.CPP
void DisplayMenu();

#endif // _WIZARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\wizard\uninstal.cpp ===
#include "pch.hxx"
#include <regutil.h>
#include "msident.h"
#include <initguid.h>
#include <ourguid.h>
#include "strings.h"
#include "util.h"
#include "migerror.h"

// Sections of INF corresponding to versions
const LPCTSTR c_szSects[] = { c_szVERnone, c_szVER1_0, c_szVER1_1, c_szVER4_0, c_szVER5B1, c_szVER5_0, c_szVERnone, c_szVERnone, c_szVERnone };

void SetUrlDllDefault(BOOL fMailTo);

/****************************************************************************

  NAME:       NTReboot
  
****************************************************************************/
BOOL NTReboot()
{
    HANDLE hToken;
    TOKEN_PRIVILEGES tkp;
    
    // get a token from this process
    if (OpenProcessToken(GetCurrentProcess(),
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
    {
        // get the LUID for the shutdown privilege
        LookupPrivilegeValue( NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid );
        
        tkp.PrivilegeCount = 1;
        tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        
        //get the shutdown privilege for this proces
        if (AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0))
            
            // shutdown the system and force all applications to close
            if (!ExitWindowsEx( EWX_REBOOT, 0 ) )
                return TRUE;
            
    }
    
    return TRUE;
}


/****************************************************************************

  NAME:       Reboot
  
****************************************************************************/
// Based on Advpack code...
void Reboot(BOOL bAsk)
{
    UINT id;
    
    id = bAsk ? MsgBox(NULL, IDS_RESTARTYESNO, MB_ICONINFORMATION, MB_YESNO) : IDYES;
    
    if (IDYES == id) 
        if (VER_PLATFORM_WIN32_WINDOWS == si.osv.dwPlatformId)
            // By default (all platforms), we assume powerdown is possible
            ExitWindowsEx( EWX_REBOOT, 0 );
        else 
            NTReboot();
}


/****************************************************************************

  NAME:       OKDespiteDependencies
  
    SYNOPSIS:   Make sure the user is aware that uninstalling us will break
    apps that use us
    
****************************************************************************/
BOOL OKDespiteDependencies(void)
{
    WORD wVerGold[4] = {4,72,2106,0};
    WORD wVerSP1[4]  = {4,72,3110,0};
    BOOL fGold;
    BOOL fSP1;
    BOOL  fOK        = TRUE;
    WORD  wVerPrev[4];
    WORD  wVer[4];
    TCHAR szExe[MAX_PATH];
    HKEY  hkey;
    DWORD cb, dwDisable;
    
    int       iRet;
    
    LOG("Checking Product dependencies...");

    switch (si.saApp)
    {
    case APP_WAB:
        break;

    case APP_OE:
        if (si.fPrompt)
        {
            DWORD       dwVerInfoSize, dwVerHnd;
            LPSTR       lpInfo, lpVersion;
            LPWORD      lpwTrans;
            UINT        uLen;
            TCHAR       szGet[MAX_PATH];

            // What version would we return to?
            GetVers(NULL, wVerPrev);

            // Is that good enough for SP1?
            if (fSP1 = GoodEnough(wVerPrev, wVerSP1))
            {
                // Yep, must be good enough for 4.01 too
                fGold = TRUE;
            }
            else
                fGold = GoodEnough(wVerPrev, wVerGold);

            // Is OL Installed?
            if (GetExePath(c_szOutlookExe, szExe, ARRAYSIZE(szExe), FALSE))
            {
                // Reg entry exists, does the EXE it points to?
                if(0xFFFFFFFF != GetFileAttributes(szExe))
                {
                    LOG("Found Outlook...");

                    // Figure out the version
                    if (dwVerInfoSize = GetFileVersionInfoSize(szExe, &dwVerHnd))
                    {
                        if (lpInfo = (LPSTR)GlobalAlloc(GPTR, dwVerInfoSize))
                        {
                            if (GetFileVersionInfo(szExe, 0, dwVerInfoSize, lpInfo))
                            {
                                if (VerQueryValue(lpInfo, "\\VarFileInfo\\Translation", (LPVOID *)&lpwTrans, &uLen) &&
                                    uLen >= (2 * sizeof(WORD)))
                                {
                                    // set up buffer for calls to VerQueryValue()
                                    wnsprintf(szGet, ARRAYSIZE(szGet), "\\StringFileInfo\\%04X%04X\\FileVersion", lpwTrans[0], lpwTrans[1]);
                                    if (VerQueryValue(lpInfo, szGet, (LPVOID *)&lpVersion, &uLen) && uLen)
                                    {
                                        ConvertStrToVer(lpVersion, wVer);
                                        
                                        // Check for OL98
                                        if (8 == wVer[0] && 5 == wVer[1])
                                        {
                                            LOG2("98");
                                            fOK = fGold;
                                        }
                                        else if (wVer[0] >= 9)
                                        {
                                            LOG2("2000+");
                                            fOK = fSP1;
                                            
                                            // Allow for future OLs to disable this check
                                            if (!fOK && ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, KEY_QUERY_VALUE, &hkey))
                                            {
                                                dwDisable = 0;
                                                cb = sizeof(dwDisable);
                                                if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szDisableOLCheck, 0, NULL, (LPBYTE)&dwDisable, &cb))
                                                {
                                                    if (dwDisable > 0)
                                                    {
                                                        LOG2("...Disabled via reg");
                                                        fOK = TRUE;
                                                    }
                                                }

                                                RegCloseKey(hkey);
                                            }
                                        }
                                        else
                                        {
                                            LOG2("97");
                                        }

                                        if (fOK)
                                        {
                                           LOG2("...OK to uninstall");
                                        }
                                        else
                                        {
                                            LOG2("...Not safe to uninstall");

                                            // Potentially have a problem - ask user
                                            iRet = MsgBox(NULL, IDS_WARN_OL, MB_ICONEXCLAMATION, MB_YESNO | MB_DEFBUTTON2);
                                            if (IDYES == iRet)
                                                fOK = TRUE;
                                        }
                                    }
                                }
                            }
                            GlobalFree((HGLOBAL)lpInfo);
                        }
                    }
                }
            }
            
            // Is MS Phone Installed?
            if (fOK && GetExePath(c_szPhoneExe, szExe, ARRAYSIZE(szExe), FALSE))
            {
                // Reg entry exists, does the EXE it points to?
                if(0xFFFFFFFF != GetFileAttributes(szExe))
                {
                    LOG("Found MSPhone...");

                    fOK = fSP1;

                    // Allow for future Phones to disable this check
                    if (!fOK && ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, KEY_QUERY_VALUE, &hkey))
                    {
                        dwDisable = 0;
                        cb = sizeof(dwDisable);
                        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szDisablePhoneCheck, 0, NULL, (LPBYTE)&dwDisable, &cb))
                        {
                            if (dwDisable > 0)
                            {
                                LOG2("...Disabled via reg...");
                                fOK = TRUE;
                            }
                        }
                        RegCloseKey(hkey);
                    }

                    if (fOK)
                    {
                        LOG2("OK to uninstall");
                    }
                    else
                    {
                        LOG2("Not safe to uninstall");

                        // Potentially have a problem - ask user
                        iRet = MsgBox(NULL, IDS_WARN_PHONE, MB_ICONEXCLAMATION, MB_YESNO | MB_DEFBUTTON2);
                        if (IDYES == iRet)
                        {
                            fOK = TRUE;
                        }

                    }
                }
            }
        }
        break;

    default:
        break;
    }

    return fOK;
}


/*++

  Routine Description:
  
    There is a significant difference between the Win3.1 and Win32
    behavior of RegDeleteKey when the key in question has subkeys.
    The Win32 API does not allow you to delete a key with subkeys,
    while the Win3.1 API deletes a key and all its subkeys.
    
      This routine is a recursive worker that enumerates the subkeys
      of a given key, applies itself to each one, then deletes itself.
      
        It specifically does not attempt to deal rationally with the
        case where the caller may not have access to some of the subkeys
        of the key to be deleted.  In this case, all the subkeys which
        the caller can delete will be deleted, but the api will still
        return ERROR_ACCESS_DENIED.
        
          Arguments:
          
            hKey - Supplies a handle to an open registry key.
            
              lpszSubKey - Supplies the name of a subkey which is to be deleted
              along with all of its subkeys.
              
                Return Value:
                
                  ERROR_SUCCESS - entire subtree successfully deleted.
                  
                    ERROR_ACCESS_DENIED - given subkey could not be deleted.
                    
--*/

LONG RegDeleteKeyRecursive(HKEY hKey, LPCTSTR lpszSubKey)
{
    DWORD i;
    HKEY Key;
    LONG Status;
    DWORD ClassLength=0;
    DWORD SubKeys;
    DWORD MaxSubKey;
    DWORD MaxClass;
    DWORD Values;
    DWORD MaxValueName;
    DWORD MaxValueData;
    DWORD SecurityLength;
    FILETIME LastWriteTime;
    LPTSTR NameBuffer;
    
    //
    // First open the given key so we can enumerate its subkeys
    //
    Status = RegOpenKeyEx(hKey,
        lpszSubKey,
        0,
        KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE,
        &Key);
    if (Status != ERROR_SUCCESS)
    {
        //
        // possibly we have delete access, but not enumerate/query.
        // So go ahead and try the delete call, but don't worry about
        // any subkeys.  If we have any, the delete will fail anyway.
        //
        return(RegDeleteKey(hKey,lpszSubKey));
    }
    
    //
    // Use RegQueryInfoKey to determine how big to allocate the buffer
    // for the subkey names.
    //
    Status = RegQueryInfoKey(Key,
        NULL,
        &ClassLength,
        0,
        &SubKeys,
        &MaxSubKey,
        &MaxClass,
        &Values,
        &MaxValueName,
        &MaxValueData,
        &SecurityLength,
        &LastWriteTime);
    if ((Status != ERROR_SUCCESS) &&
        (Status != ERROR_MORE_DATA) &&
        (Status != ERROR_INSUFFICIENT_BUFFER))
    {
        RegCloseKey(Key);
        return(Status);
    }
    
    if (!MemAlloc((void **)&NameBuffer, sizeof(TCHAR) * (MaxSubKey + 1)))
    {
        RegCloseKey(Key);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    
    //
    // Enumerate subkeys and apply ourselves to each one.
    //
    i = 0;
    do {
        Status = RegEnumKey(Key,
            i,
            NameBuffer,
            MaxSubKey+1);
        if (Status == ERROR_SUCCESS)
        {
            Status = RegDeleteKeyRecursive(Key,NameBuffer);
        }
        
        if (Status != ERROR_SUCCESS)
        {
            //
            // Failed to delete the key at the specified index.  Increment
            // the index and keep going.  We could probably bail out here,
            // since the api is going to fail, but we might as well keep
            // going and delete everything we can.
            //
            ++i;
        }
    } while ( (Status != ERROR_NO_MORE_ITEMS) &&
        (i < SubKeys) );
    
    MemFree(NameBuffer);
    RegCloseKey(Key);
    
    return(RegDeleteKey(hKey,lpszSubKey));
}

// v1 store struct
typedef struct tagCACHEFILEHDR
    {
    DWORD dwMagic;
    DWORD ver;
    DWORD cMsg;
    DWORD cbValid;
    DWORD dwFlags;
    DWORD verBlob;
    DWORD dwReserved[14];
    } CACHEFILEHDR;


/*******************************************************************

  NAME:       HandleInterimOE
  
  SYNOPSIS:   Tries to unmangle a machine that has had an
              intermediate, non-gold version on it
    
********************************************************************/
void HandleInterimOE(SETUPVER sv, SETUPVER svReal)
{
    switch(sv)
    {
    case VER_5_0_B1:
        
        LPCTSTR pszRoot    = NULL;
        LPTSTR  pszStore;
        LPTSTR  pszCmd;
        LPCTSTR pszOption;

        TCHAR szStorePath    [MAX_PATH];
        TCHAR szStoreExpanded[MAX_PATH];
        TCHAR szExePath      [MAX_PATH];
        TCHAR szTemp         [2*MAX_PATH + 20];

        HKEY  hkeySrc, hkeyT;
        DWORD cb, dwType, dw;

        STARTUPINFO sti;
        PROCESS_INFORMATION pi;

        // Find the OE5 Beta1 store root

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegRoot, 0, KEY_QUERY_VALUE, &hkeySrc))
        {
            cb = sizeof(szStorePath);
            if (ERROR_SUCCESS == RegQueryValueEx(hkeySrc, c_szRegStoreRootDir, 0, &dwType, (LPBYTE)szStorePath, &cb))
            {
                ZeroMemory(szStoreExpanded, ARRAYSIZE(szStoreExpanded));
                ExpandEnvironmentStrings(szStorePath, szStoreExpanded, ARRAYSIZE(szStoreExpanded));
              
                switch (svReal)
                {
                case VER_1_0:
                case VER_1_1:
                    BOOL fContinue;
                    BOOL fRet;

                    dwType  = REG_SZ;
                    pszStore= szStoreExpanded;
                    pszRoot = c_szRegRoot_V1;
                    pszOption = c_szV1;

                    HANDLE hndl;
                    HANDLE hFile;
                    WIN32_FIND_DATA fd;
                    CACHEFILEHDR cfh;

                    // Downgrade .idx files
                    StrCpyN(szTemp, szStoreExpanded, ARRAYSIZE(szTemp));
                    cb = lstrlen(szTemp);
                    if ('\\' != *CharPrev(szTemp, szTemp+cb))
                        szTemp[cb++] = '\\';
                    StrCpyN(&szTemp[cb], c_szMailSlash, ARRAYSIZE(szTemp)-cb);
                    cb += 5; // lstrlen(c_szMailSlash)
                    StrCpyN(&szTemp[cb], c_szStarIDX, ARRAYSIZE(szTemp)-cb);
        
                    hndl = FindFirstFile(szTemp, &fd);
                    fContinue = (INVALID_HANDLE_VALUE != hndl);
                    if (fContinue)
                    {
                        while (fContinue)
                        {
                            // Skip directories
                            if (0 == (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                            {
                                // Append the filename to the path
                                StrCpyN(&szTemp[cb], fd.cFileName, ARRAYSIZE(szTemp)-cb);

                                // Open the file
                                hFile = CreateFile(szTemp, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

                                if (hFile != INVALID_HANDLE_VALUE)
                                {
                                    fRet = ReadFile(hFile, &cfh, sizeof(CACHEFILEHDR), &dw, NULL);

                                    Assert(dw == sizeof(CACHEFILEHDR));

                                    if (fRet)
                                    {
                                        // Reset the version to be low, so v1 will attempt to repair it
                                        cfh.verBlob = 1;

                                        dw = SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
                                        Assert(dw == 0);

                                        fRet = WriteFile(hFile, &cfh, sizeof(CACHEFILEHDR), &dw, NULL);
                                        Assert(fRet);
                                        Assert(dw == sizeof(CACHEFILEHDR));
                                    }

                           
                                    CloseHandle(hFile);
                                }
                            }
                            fContinue = FindNextFile(hndl, &fd);
                        }
                        FindClose(hndl);
                    }
                    break;

                case VER_4_0:
                    pszStore  = szStorePath;
                    pszRoot = c_szRegFlat;
                    pszOption = c_szV4;
                    break;
                }

                // If we are going to v1 or v4...
                if (pszRoot)
                {
                    dw= (DWORD)E_FAIL;

                    // Reverse migrate the store

                    // BUGBUG: 45426 - neilbren
                    // Should key off InstallRoot but can't seem to keep that setting around
                    
                    // Try to find the path to oemig50.exe
                    if (GetModuleFileName(NULL, szTemp, ARRAYSIZE(szTemp)))
                    {
                        // Strip exe name and slash
                        PathRemoveFileSpec(szTemp);

                        // Add slash and exe name
                        wnsprintf(szExePath, ARRAYSIZE(szExePath), c_szPathFileFmt, szTemp, c_szMigrationExe);

                        pszCmd = szExePath;
                    }
                    // Otherwise, just try local directory
                    else
                    {
                        pszCmd = (LPTSTR)c_szMigrationExe;
                    }

                    // Form the command
                    wnsprintf(szTemp, ARRAYSIZE(szTemp), c_szMigFmt, pszCmd, pszOption, pszStore);

                    // Zero startup info
                    ZeroMemory(&sti, sizeof(STARTUPINFO));
                    sti.cb = sizeof(STARTUPINFO);

                    // run oemig50.exe
                    if (CreateProcess(NULL, szTemp, NULL, NULL, FALSE, 0, NULL, NULL, &sti, &pi))
                    {
                        // Wait for the process to finish
                        WaitForSingleObject(pi.hProcess, INFINITE);

                        // Get the Exit Process Code
                        GetExitCodeProcess(pi.hProcess, &dw);

                        // Close the Thread
                        CloseHandle(pi.hThread);

                        // Close the Process
                        CloseHandle(pi.hProcess);
                    }

                    // Patch up the store root for version we are returning to
                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, pszRoot, 0, KEY_SET_VALUE, &hkeyT))
                    {
                        RegSetValueEx(hkeyT, c_szRegStoreRootDir, 0, dwType, (LPBYTE)pszStore, (lstrlen(pszStore) + 1) * sizeof(TCHAR));
                        RegCloseKey(hkeyT);
                    }
                }
            }
            RegCloseKey(hkeySrc);
        }
        break;
    }
}


/*******************************************************************

  NAME:       ConfigureOldVer
  
 SYNOPSIS:   Calls into INF to config older version
    
********************************************************************/
void ConfigureOldVer()
{
    TCHAR szSectionName[128];
    TCHAR szInfFile[MAX_PATH];
    BOOL bUser = (TIME_USER == si.stTime);
    SETUPVER sv, svInterim;
    
    GetVerInfo(&sv, NULL);
    
    // Patch up User or Machine
    if (sv < VER_MAX)
    {
        wnsprintf(szInfFile, ARRAYSIZE(szInfFile), c_szFileEntryFmt, si.szInfDir, si.pszInfFile);
        wnsprintf(szSectionName, ARRAYSIZE(szSectionName), bUser ? c_szUserRevertFmt : c_szMachineRevertFmt, c_szSects[sv]);
        (*si.pfnRunSetup)(NULL, szInfFile, szSectionName, si.szInfDir, si.szAppName, NULL, 
                          RSC_FLAG_INF | (bUser ? 0 : RSC_FLAG_NGCONV) | OE_QUIET, 0);
    }

    // Handle interim builds (user only)
    if (bUser && InterimBuild(&svInterim))
    {
        switch(si.saApp)
        {
        case APP_OE:
            HandleInterimOE(svInterim, sv);
            break;
        }
    }
}


/*******************************************************************

  NAME:       SelectNewClient
  
********************************************************************/
void SelectNewClient(LPCTSTR pszClient)
{
    BOOL fMail;
    BOOL fNone = TRUE;
    SETUPVER sv;
    PFN_ISETDEFCLIENT pfn;
    
    if (!lstrcmpi(pszClient, c_szNews))
    {
        pfn = ISetDefaultNewsHandler;
        fMail = FALSE;
    }
    else
    {
        pfn = ISetDefaultMailHandler;
        fMail = TRUE;
    }
    
    // If we went IMN to 5.0, we will show up as NOT_HANDLED as our subkeys are gone by now
    if ((HANDLED_CURR == DefaultClientSet(pszClient)) || (NOT_HANDLED == DefaultClientSet(pszClient)))
    {
        GetVerInfo(&sv, NULL);
        switch (sv)
        {
        case VER_4_0:
            // If prev ver was 4.0x, could have been Outlook News Reader
            if (FValidClient(pszClient, c_szMOE))
            {
                (*pfn)(c_szMOE, 0);
                fNone = FALSE;
            }
            else if (FValidClient(pszClient, c_szOutlook))
            {
                (*pfn)(c_szOutlook, 0);
                fNone = FALSE;
            }
            break;
            
        case VER_1_0:
            // If prev ver was 1.0, IMN may or may not be around (cool, eh?)
            if (FValidClient(pszClient, c_szIMN))
            {
                (*pfn)(c_szIMN, 0);
                fNone = FALSE;
            }
            break;
        }
    }

    if (fNone)
    {
        (*pfn)(_T(""), 0);
        SetUrlDllDefault(fMail);
    }

}


/*******************************************************************

  NAME:       SelectNewClients
  
********************************************************************/
void SelectNewClients()
{
    switch (si.saApp)
    {
    case APP_OE:
        SelectNewClient(c_szNews);
        SelectNewClient(c_szMail);
        break;
        
    case APP_WAB:
    default:
        break;
    }
}


/*******************************************************************

  NAME:       UpdateVersionInfo
  
********************************************************************/
void UpdateVersionInfo()
{
    HKEY hkeyT;
    DWORD dwType, cb;
    TCHAR szT[50]={0};
    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyT))
    {
        cb = sizeof(szT);
        if (CALLER_IE == si.caller)
        {
            RegQueryValueEx(hkeyT, c_szRegPrevVer, NULL, &dwType, (LPBYTE)szT, &cb);
            RegSetValueEx(hkeyT, c_szRegCurrVer, 0, REG_SZ, (LPBYTE)szT, (lstrlen(szT) + 1) * sizeof(TCHAR));
        }
        else
            // Special case OS installs that can uninstall OE
            // As there is no rollback, current version should become nothing
            RegSetValueEx(hkeyT, c_szRegCurrVer, 0, REG_SZ, (LPBYTE)c_szBLDnone, (lstrlen(c_szBLDnone) + 1) * sizeof(TCHAR));
        RegSetValueEx(hkeyT, c_szRegPrevVer, 0, REG_SZ, (LPBYTE)c_szBLDnone, (lstrlen(c_szBLDnone) + 1) * sizeof(TCHAR));
        RegCloseKey(hkeyT);
    }
}


/*******************************************************************

  NAME:       PreRollback
  
********************************************************************/
void PreRollback()
{
    switch (si.saApp)
    {
    case APP_OE:
        RegisterExes(FALSE);
        break;
    case APP_WAB:
    default:
        break;
    }
}


/*******************************************************************

  NAME:       CreateWinLinks
  
    SYNOPSIS:   Generates special files in Windows Directory
    
********************************************************************/
void CreateWinLinks()
{
    UINT uLen, cb;
    TCHAR szPath[MAX_PATH];
    TCHAR szDesc[CCHMAX_STRINGRES];
    HANDLE hFile;
    
    StrCpyN(szPath, si.szWinDir, ARRAYSIZE(szPath));
    uLen = lstrlen(szPath);
    
    // generate the link description
    cb = LoadString(g_hInstance, IDS_OLD_MAIL, szDesc, ARRAYSIZE(szDesc));
    
    // ---- MAIL
    StrCpyN(&szPath[uLen], szDesc, ARRAYSIZE(szPath)-uLen);
    cb += uLen;
    StrCpyN(&szPath[cb], c_szMailGuid, ARRAYSIZE(szPath)-cb);
    
    // create the link target
    hFile = CreateFile(szPath, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, 
        NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    
    // ---- NEWS
    cb = LoadString(g_hInstance, IDS_OLD_NEWS, szDesc, ARRAYSIZE(szDesc));
    
    // generate the path to the link target
    StrCpyN(&szPath[uLen], szDesc, ARRAYSIZE(szPath)-uLen);
    cb += uLen;
    StrCpyN(&szPath[cb], c_szNewsGuid, ARRAYSIZE(szPath)-cb);
    
    // create the link target
    hFile = CreateFile(szPath, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_WRITE, 
        NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
}


/*******************************************************************

  NAME:       PostRollback
  
********************************************************************/
void PostRollback()
{
    SETUPVER sv;    
    GetVerInfo(&sv, NULL);
    
    switch (si.saApp)
    {
    case APP_OE:
        if (VER_1_0 == sv)
            CreateWinLinks();
        break;
    case APP_WAB:
    default:
        break;
    }
}

#if 0
/*******************************************************************

  NAME:       RemoveJIT
  
********************************************************************/
void RemoveJIT()
{
    HKEY hkey;
    DWORD cb, dw;
    TCHAR szPath[MAX_PATH], szExpanded[MAX_PATH];
    LPTSTR pszPath;
    
    switch (si.saApp)
    {
    case APP_OE:
        // WAB
        wnsprintf(szPath, ARRAYSIZE(szPath), c_szPathFileFmt, c_szRegUninstall, c_szRegUninstallWAB);
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPath, 0, KEY_QUERY_VALUE, &hkey))
        {
            cb = sizeof(szPath);
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szQuietUninstall, 0, &dw, (LPBYTE)szPath, &cb))
            {
                STARTUPINFO sti;
                PROCESS_INFORMATION pi;
                
                if (REG_EXPAND_SZ == dw)
                {
                    ZeroMemory(szExpanded, ARRAYSIZE(szExpanded));
                    ExpandEnvironmentStrings(szPath, szExpanded, ARRAYSIZE(szExpanded));
                    pszPath = szExpanded;
                }
                else
                    pszPath = szPath;
                
                ZeroMemory(&sti, sizeof(STARTUPINFO));
                sti.cb = sizeof(STARTUPINFO);
                
                if (CreateProcess(NULL, pszPath, NULL, NULL, FALSE, 0, NULL, NULL, &sti, &pi))
                {
                    WaitForSingleObject(pi.hProcess, INFINITE);
                    GetExitCodeProcess(pi.hProcess, &dw);
                    CloseHandle(pi.hThread);
                    CloseHandle(pi.hProcess);
                }
            }
            
            RegCloseKey(hkey);
        }
        break;
        
    case APP_WAB:
    default:
        break;
    }
}
#endif

/*******************************************************************

  NAME:       RequiredIE
  
  SYNOPSIS:   Requires IE5 for uninstall
    
********************************************************************/
BOOL RequiredIE()
{
    HKEY hkey;
    TCHAR szVer[VERLEN];
    BOOL fOK = FALSE;
    DWORD cb;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szIEKey, 0, KEY_READ, &hkey))
    {
        cb = ARRAYSIZE(szVer);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szValueVersion, 0, NULL, (LPBYTE)szVer, &cb))
        {
            WORD wVer[4];
            WORD wVerOE[4] = {5,0,0,0};
            
            ConvertStrToVer(szVer, wVer);

            if (!(fOK = GoodEnough(wVer, wVerOE)))
                LOG("[WARNING]: Insufficient IE for uninstall");
        }
        RegCloseKey(hkey);
    }

    return fOK;
}


/*******************************************************************

  NAME:       UnInstallMachine
  
    SYNOPSIS:   Handles Application uninstallation
    
********************************************************************/
BOOL UnInstallMachine()
{
    HRESULT hr = E_FAIL;
    TCHAR szArgs[2 * MAX_PATH];
    TCHAR szInfFile[MAX_PATH];
    UINT uID;

    // Require at least IE 5 to uninstall
    if (!RequiredIE() && (si.fPrompt ? (IDNO == MsgBox(NULL, IDS_WARN_OLDIE, MB_ICONEXCLAMATION, MB_YESNO | MB_DEFBUTTON2)) : TRUE))
    {
        LOG("[ERROR] Setup canceled");
        return FALSE;
    }
    
    switch (si.saApp)
    {
    case APP_OE:
        uID = IDS_UNINSTALL_OE;
        break;
    case APP_WAB:
        uID = IDS_UNINSTALL_WAB;
        break;
    default:
        return FALSE;
    }
    
    // Make sure the user really wants to uninstall and there is nothing preventing it
    if (IDNO == MsgBox(NULL, uID, MB_YESNO, MB_ICONEXCLAMATION ) ||
        !OKDespiteDependencies())
    {
        LOG("[ERROR] Setup canceled");
            return FALSE;
    }
    
    // We'll need to move files around and write to HKLM, so require admin privs
    if (!IsNTAdmin())
    {
        LOG("[ERROR] User does not have administrative privileges")
            MsgBox(NULL, IDS_NO_ADMIN_PRIVILEGES, MB_ICONSTOP, MB_OK);
        return FALSE;
    }
    
    // Update version info in the reg
    UpdateVersionInfo();

    wnsprintf(szInfFile, ARRAYSIZE(szInfFile), c_szFileEntryFmt, si.szInfDir, si.pszInfFile);
    if (CALLER_IE == si.caller)
    {    
        // Do any housework before the uninstall
        PreRollback();
        
        // UnRegister OCXs (immediately)
        (*si.pfnRunSetup)(NULL, szInfFile, c_szUnRegisterOCX, si.szInfDir, si.szAppName, NULL, RSC_FLAG_INF | RSC_FLAG_NGCONV | OE_QUIET, 0);

        // Return files to original state    
        wnsprintf(szArgs, ARRAYSIZE(szArgs), c_szLaunchExFmt, szInfFile, c_szMachineInstallSectionEx, c_szEmpty, ALINF_ROLLBACK | ALINF_NGCONV | OE_QUIET);
        hr = (*si.pfnLaunchEx)(NULL, NULL, szArgs, 0);

        // Keys off current
        PostRollback();

        // Patch up Old version so that it runs (keys off current)
        ConfigureOldVer();
    }
    else
    {
        // Set up the per user stub
        (*si.pfnRunSetup)(NULL, szInfFile, c_szGenInstallSection, si.szInfDir, si.szAppName, NULL, RSC_FLAG_INF | RSC_FLAG_NGCONV | OE_QUIET, 0);
    }
   
    // Figure out who will be the default handlers now that app is gone
    SelectNewClients();
    
    // Uninstall JIT'd in items
    // RemoveJIT();
    
    // To simplify matters, we always want our stubs to run (not very ZAW like)
    if (si.fPrompt)
        Reboot(TRUE);

    // Special case Memphis uninstall - no bits to return to, so just remove the icons now
    if (CALLER_IE != si.caller)
    {
        UnInstallUser();
        // Destory uninstalling user's installed info in case they install an older version without
        // rebooting first
        UpdateStubInfo(FALSE);
    }
    
    return TRUE;
}


/*******************************************************************

  NAME:       CleanupPerUser
  
  SYNOPSIS:   Handles per user cleanup
    
********************************************************************/
void CleanupPerUser()
{
    switch (si.saApp)
    {
    case APP_WAB:
        // Backwards migrate the connection settings
        BackMigrateConnSettings();
        break;

    default:
        break;
    }
}


/*******************************************************************

  NAME:       UnInstallUser
  
    SYNOPSIS:   Handles User uninstallation (icons etc)
    
********************************************************************/
void UnInstallUser()
{
    // Remove desktop and quicklaunch links
    HandleLinks(FALSE);
    
    // Call into the correct per user stub
    if (CALLER_IE == si.caller)
        ConfigureOldVer();

    // Handle any per user uninstall cleanup
    CleanupPerUser();

    if (IsXPSP1OrLater())
    {
        DeleteKeyRecursively(HKEY_CURRENT_USER, "Software\\Microsoft\\Active Setup\\Installed Components\\>{881dd1c5-3dcf-431b-b061-f3f88e8be88a}");
    }
}

/*******************************************************************

  NAME:     BackMigrateConnSettings

    SYNOPSIS:   OE4.1 or the versions before that did not have the 
    connection setting type InternetConnectionSetting. So while 
    downgrading from OE5 to OE4.1 or prior, we migrate 
    InternetConnectionSetting to LAN for every account in every identity
*******************************************************************/

void BackMigrateConnSettings()
{
    HKEY    hKeyAccounts = NULL;
    DWORD   dwAcctSubKeys = 0;
    LONG    retval;
    DWORD   index = 0;
    LPTSTR  lpszAccountName = NULL;
    HKEY    hKeyAccountName = NULL;
    DWORD   memsize = 0;
    DWORD   dwValue;
    DWORD   cbData = sizeof(DWORD);
    DWORD   cbMaxAcctSubKeyLen;
    DWORD   DataType;
    DWORD   dwConnSettingsMigrated = 0;

    //This setting is in \\HKCU\Software\Microsoft\InternetAccountManager\Accounts
    
    retval = RegOpenKey(HKEY_CURRENT_USER, c_szIAMAccounts, &hKeyAccounts);
    if (ERROR_SUCCESS != retval)
        goto exit;

    retval = RegQueryValueEx(hKeyAccounts, c_szConnSettingsMigrated, NULL,  &DataType,
                            (LPBYTE)&dwConnSettingsMigrated, &cbData);
    
    if ((retval != ERROR_FILE_NOT_FOUND) && (retval != ERROR_SUCCESS || dwConnSettingsMigrated == 0))
        goto exit;

    retval = RegQueryInfoKey(hKeyAccounts, NULL, NULL, NULL, &dwAcctSubKeys, 
                         &cbMaxAcctSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL);

    if (ERROR_SUCCESS != retval)
        goto exit;

    memsize = sizeof(TCHAR) * cbMaxAcctSubKeyLen;

    if (!MemAlloc((LPVOID*)&lpszAccountName, memsize))
    {
        lpszAccountName = NULL;
        goto exit;
    }

    ZeroMemory(lpszAccountName, memsize);

    while (index < dwAcctSubKeys)
    {
        retval = RegEnumKey(hKeyAccounts, index, lpszAccountName, memsize);
        
        index++;

        if (ERROR_SUCCESS != retval)
            continue;

        retval = RegOpenKey(hKeyAccounts, lpszAccountName, &hKeyAccountName);
        if (ERROR_SUCCESS != retval)
            continue;

        cbData = sizeof(DWORD);
        retval = RegQueryValueEx(hKeyAccountName, c_szConnectionType, NULL, &DataType, (LPBYTE)&dwValue, &cbData);
        if (ERROR_SUCCESS != retval)
        {
            RegCloseKey(hKeyAccountName);
            continue;
        }

        if (dwValue == CONNECTION_TYPE_INETSETTINGS)
        {
            dwValue = CONNECTION_TYPE_LAN;
            retval = RegSetValueEx(hKeyAccountName, c_szConnectionType, 0, REG_DWORD, (const BYTE *)&dwValue, 
                                   sizeof(DWORD));
        }

        RegCloseKey(hKeyAccountName);
    }

    //Set this to zero so, when we upgrade when we do forward migration based on this key value
    dwConnSettingsMigrated = 0;
    RegSetValueEx(hKeyAccounts, c_szConnSettingsMigrated, 0, REG_DWORD, (const BYTE*)&dwConnSettingsMigrated, 
                  sizeof(DWORD));

exit:
    SafeMemFree(lpszAccountName);

    if (hKeyAccounts)
        RegCloseKey(hKeyAccounts);
}

const char c_szMailToHandler[]       = "rundll32.exe url.dll,MailToProtocolHandler %l";
const char c_szNewsHandler[]         = "rundll32.exe url.dll,NewsProtocolHandler %l";
 
const char c_szDefIcon[]             = "DefaultIcon";
const char c_szURLProtocol[]         = "URL Protocol";
const char c_szEditFlags[]           = "EditFlags";

const char c_szSysDirExpand[]        = "%SystemRoot%\\System32";
const char c_szUrlDllIconFmt[]       = "%s\\url.dll,%d";

void SetUrlDllDefault(BOOL fMailTo)
{
    char sz[MAX_PATH], szIcon[MAX_PATH];
    HKEY hkey, hkeyT;
    DWORD dw, type;
    int cch;

    if (si.osv.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        StrCpyN(sz, c_szSysDirExpand, ARRAYSIZE(sz));
        type = REG_EXPAND_SZ;
    }
    else
    {
        GetSystemDirectory(sz, ARRAYSIZE(sz));
        type = REG_SZ;
    }
    wnsprintf(szIcon, ARRAYSIZE(szIcon), c_szUrlDllIconFmt, sz, fMailTo ? 2 : 1);

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, fMailTo ? c_szURLMailTo : c_szURLNews, 0, NULL,
                            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkey, &dw))
    {
        cch = LoadString(g_hInstance, fMailTo ? IDS_URLDLLMAILTONAME : IDS_URLDLLNEWSNAME, sz, ARRAYSIZE(sz)) + 1;
        RegSetValueEx(hkey, NULL, 0, REG_SZ, (LPBYTE)sz, cch); 

        dw = 2;
        RegSetValueEx(hkey, c_szEditFlags, 0, REG_DWORD, (LPBYTE)&dw, sizeof(dw));

        RegSetValueEx(hkey, c_szURLProtocol, 0, REG_SZ, (LPBYTE)c_szEmpty, 1); 

        if (ERROR_SUCCESS == RegCreateKeyEx(hkey, c_szDefIcon, 0, NULL,
                                REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyT, &dw)) 
        {
            RegSetValueEx(hkeyT, NULL, 0, type, (LPBYTE)szIcon, lstrlen(szIcon) + 1);
            RegCloseKey(hkeyT);
        }

        // c_szRegOpen[1] to skip over slash needed elsewhere
        if (ERROR_SUCCESS == RegCreateKeyEx(hkey, &c_szRegOpen[1], 0, NULL,
                                REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyT, &dw)) 
        {
            if (fMailTo)
                RegSetValueEx(hkeyT, NULL, 0, REG_SZ, (LPBYTE)c_szMailToHandler, sizeof(c_szMailToHandler));
            else
                RegSetValueEx(hkeyT, NULL, 0, REG_SZ, (LPBYTE)c_szNewsHandler, sizeof(c_szNewsHandler));

            RegCloseKey(hkeyT);
        }

        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\shell\makefile.inc ===
$O\msimn.res : $(O)\selfreg.inf

selfreg.src : strings.src reg.src reg2.src

$(O)\selfreg.inx : selfreg.src
    cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\shell\msimnp.h ===
#ifndef __MSIMNP_H__
#define __MSIMNP_H__

#if !defined (ARRAYSIZE) || !defined (WIN16)
#define ARRAYSIZE(_rg)  (sizeof(_rg)/sizeof(_rg[0]))
#endif

#endif // __MSIMNP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\wizard\util.cpp ===
#include "pch.hxx"
#include "util.h"
#include "shared.h"
#include "strings.h"

//  Copied from nt\shell\shlwapi\reg.c
DWORD
DeleteKeyRecursively(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyExA(hkey, pszSubKey, 0, MAXIMUM_ALLOWED, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKeyA(hkSubKey, NULL, NULL, NULL,
                                 &dwIndex, // The # of subkeys -- all we need
                                 NULL, NULL, NULL, NULL, NULL, NULL, NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKeyA(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursively(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        if (pszSubKey)
        {
            dwRet = RegDeleteKeyA(hkey, pszSubKey);
        }
        else
        {
            //  we want to delete all the values by hand
            cchSubKeyName = ARRAYSIZE(szSubKeyName);
            while (ERROR_SUCCESS == RegEnumValueA(hkey, 0, szSubKeyName, &cchSubKeyName, NULL, NULL, NULL, NULL))
            {
                //  avoid looping infinitely when we cant delete the value
                if (RegDeleteValueA(hkey, szSubKeyName))
                    break;
                    
                cchSubKeyName = ARRAYSIZE(szSubKeyName);
            }
        }
    }

    return dwRet;
}

//--------------------------------------------------------------------------
// GetWindowsDirectoryWrap
//
// Returns the system's Windows directory
// Based on code from SHLWAPI's util.cpp by TNoonan
//--------------------------------------------------------------------------
typedef UINT (__stdcall * PFNGETSYSTEMWINDOWSDIRECTORYA)(LPSTR pszBuffer, UINT cchBuff);

UINT GetSystemWindowsDirectoryWrap(LPTSTR pszBuffer, UINT uSize)
{
    // On NT?
    if (VER_PLATFORM_WIN32_NT == si.osv.dwPlatformId)
    {
        static PFNGETSYSTEMWINDOWSDIRECTORYA s_pfn = (PFNGETSYSTEMWINDOWSDIRECTORYA)-1;

        if (((PFNGETSYSTEMWINDOWSDIRECTORYA)-1) == s_pfn)
        {
            HINSTANCE hinst = GetModuleHandle(TEXT("KERNEL32.DLL"));

            Assert(NULL != hinst);  //  YIKES!

            if (hinst)
                s_pfn = (PFNGETSYSTEMWINDOWSDIRECTORYA)GetProcAddress(hinst, "GetSystemWindowsDirectoryA");
            else
                s_pfn = NULL;
        }

        if (s_pfn)
        {
            // we use the new API so we dont get lied to by hydra
            return s_pfn(pszBuffer, uSize);
        }
        else
        {
            // Get System directory is not munged by Hydra
            GetSystemDirectory(pszBuffer, uSize);
            PathRemoveFileSpec(pszBuffer);
            return lstrlen(pszBuffer);
        }
    }
    else
    {
        // Okay to call GetWindowsDirectory as we are on 9x
        return GetWindowsDirectory(pszBuffer, uSize);
    }

}


/****************************************************************************

    NAME:       GoodEnough

    SYNOPSIS:   Returns true if pwVerGot is newer or equal to pwVerNeed

****************************************************************************/
BOOL GoodEnough(WORD *pwVerGot, WORD *pwVerNeed)
{
    BOOL fOK = FALSE;
    
    Assert(pwVerGot);
    Assert(pwVerNeed);

    if (pwVerGot[0] > pwVerNeed[0])
        fOK = TRUE;
    else if (pwVerGot[0] == pwVerNeed[0])
    {
        if (pwVerGot[1] > pwVerNeed[1])
            fOK = TRUE;
        else if (pwVerGot[1] == pwVerNeed[1])
        {
            if (pwVerGot[2] > pwVerNeed[2])
                fOK = TRUE;
            else if (pwVerGot[2] == pwVerNeed[2])
            {
                if (pwVerGot[3] >= pwVerNeed[3])
                    fOK = TRUE;
            }
        }
    }

    return fOK;
}


/****************************************************************************

    NAME:       OEFileBackedUp   - HACK

****************************************************************************/
BOOL OEFileBackedUp(LPTSTR pszFullPath, int cch)
{
    BOOL bFound = FALSE;
    HKEY hkeyOE;
    TCHAR szINI[MAX_PATH], szTemp[MAX_PATH];
    DWORD cb, dwType;

    Assert(pszFullPath);
    Assert(cch > 0);

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegAdvInfoOE, 0, KEY_READ, &hkeyOE))
    {
        cb = sizeof(szINI);
        if (ERROR_SUCCESS == RegQueryValueEx(hkeyOE, c_szBackupFileName, 0, &dwType, (LPBYTE)szINI, &cb))
        {
            if (REG_EXPAND_SZ == dwType)
            {
                ZeroMemory(szTemp, ARRAYSIZE(szTemp));
                ExpandEnvironmentStrings(szINI, szTemp, ARRAYSIZE(szTemp));
                StrCpyN(szINI, szTemp, ARRAYSIZE(szINI));
                
                // Get ready to change the extension to INI (4 = lstrlen(".DAT"))
                cb = lstrlen(szINI)-4;
            }
            else
                // 5 = 4 + 1 (RegQueryValue returns length including NULL)
                cb -= 5;

            StrCpyN(&szINI[cb], c_szDotINI, ARRAYSIZE(szINI) - cb);

            // On Win95, shorten the name
            if (VER_PLATFORM_WIN32_WINDOWS == si.osv.dwPlatformId)
                GetShortPathName(pszFullPath, pszFullPath, cch);

            // See if we can find it
            if (1 < GetPrivateProfileString(c_szBackupSection, pszFullPath, c_szEmpty, szTemp, ARRAYSIZE(szTemp), szINI))
            {
                // We are only interested in the first two characters
                szTemp[2] = 0;

                if (!lstrcmp(szTemp, c_szBackedup))
                    bFound = TRUE;
                else
                    AssertSz(!lstrcmp(szTemp, c_szNotBackedup), "SETUP: Advpack back up info has unknown status flag");
            }
        }
        
        RegCloseKey(hkeyOE);
    }

    return bFound;
}


/****************************************************************************

    NAME:       MsgBox

****************************************************************************/
int MsgBox(HWND hWnd, UINT nMsgID, UINT uIcon, UINT uButtons)
    {
    TCHAR szMsgBuf[CCHMAX_STRINGRES];

    if (!si.fPrompt)
        return 0;

    LoadString(g_hInstance, nMsgID, szMsgBuf, ARRAYSIZE(szMsgBuf));
    LOG("[MSGBOX] ");
    LOG2(szMsgBuf);

    return(MessageBox(hWnd, szMsgBuf, si.szAppName, uIcon | uButtons | MB_SETFOREGROUND));
    }


/*******************************************************************

    NAME:       ConvertVerToEnum

********************************************************************/
SETUPVER ConvertVerToEnum(WORD *pwVer)
    {
    SETUPVER sv;
    Assert(pwVer);

    switch (pwVer[0])
        {
        case 0:
            sv = VER_NONE;
            break;

        case 1:
            if (0 == pwVer[1])
                sv = VER_1_0;
            else
                sv = VER_1_1;
            break;

        case 4:
            sv = VER_4_0;
            break;

        case 5:
            sv = VER_5_0;
            break;

        case 6:
            sv = VER_6_0;
            break;

        default:
            sv = VER_MAX;
        }

    return sv;
    }

    
/*******************************************************************

    NAME:       ConvertStrToVer

********************************************************************/
void ConvertStrToVer(LPCSTR pszStr, WORD *pwVer)
    {
    int i;

    Assert(pszStr);
    Assert(pwVer);

    ZeroMemory(pwVer, 4 * sizeof(WORD));

    for (i=0; i<4; i++)
        {
        while (*pszStr && (*pszStr != ',') && (*pszStr != '.'))
            {
            pwVer[i] *= 10;
            pwVer[i] += *pszStr - '0';
            pszStr++;
            }
        if (*pszStr)
            pszStr++;
        }

    return;
    }


/*******************************************************************

    NAME:       GetVers

********************************************************************/
void GetVers(WORD *pwVerCurr, WORD *pwVerPrev)
    {
    HKEY hkeyT;
    DWORD cb;
    CHAR szVer[VERLEN];

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, KEY_QUERY_VALUE, &hkeyT))
        {
        if (pwVerCurr)
            {
            cb = sizeof(szVer);
            RegQueryValueExA(hkeyT, c_szRegCurrVer, NULL, NULL, (LPBYTE)szVer, &cb);
            ConvertStrToVer(szVer, pwVerCurr);
            }
        
        if (pwVerPrev)
            {
            cb = sizeof(szVer);
            RegQueryValueExA(hkeyT, c_szRegPrevVer, NULL, NULL, (LPBYTE)szVer, &cb);
            ConvertStrToVer(szVer, pwVerPrev);
            }

        RegCloseKey(hkeyT);
        }
    }


/*******************************************************************

    NAME:       GetVerInfo

********************************************************************/
void GetVerInfo(SETUPVER *psvCurr, SETUPVER *psvPrev)
{
    WORD wVerCurr[4];
    WORD wVerPrev[4];

    GetVers(wVerCurr, wVerPrev);

    if (psvCurr)
        *psvCurr = ConvertVerToEnum(wVerCurr);
        
    if (psvPrev)
        *psvPrev = ConvertVerToEnum(wVerPrev);
}
    

/*******************************************************************

    NAME:       InterimBuild

********************************************************************/
BOOL InterimBuild(SETUPVER *psv)
    {
    HKEY hkeyT;
    DWORD cb;
    BOOL fInterim = FALSE;

    Assert(psv);
    ZeroMemory(psv, sizeof(SETUPVER));

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, si.pszVerInfo, 0, KEY_QUERY_VALUE, &hkeyT))
        {
        cb = sizeof(SETUPVER);
        fInterim = (ERROR_SUCCESS == RegQueryValueExA(hkeyT, c_szRegInterimVer, NULL, NULL, (LPBYTE)psv, &cb));
        RegCloseKey(hkeyT);
        }

    return fInterim;
    }


/*******************************************************************

    NAME:       GetASetupVer

********************************************************************/
BOOL GetASetupVer(LPCTSTR pszGUID, WORD *pwVer, LPTSTR pszVer, int cch)
    {
    HKEY hkey;
    TCHAR szPath[MAX_PATH], szVer[64];
    BOOL fInstalled = FALSE;
    DWORD dwValue, cb;

    Assert(pszGUID);
    
    if (pszVer)
        pszVer[0] = 0;
    if (pwVer)
        ZeroMemory(pwVer, 4 * sizeof(WORD));

    wnsprintf(szPath, ARRAYSIZE(szPath), c_szPathFileFmt, c_szRegASetup, pszGUID);
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szPath, 0, KEY_QUERY_VALUE, &hkey))
        {
        cb = sizeof(dwValue);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szIsInstalled, 0, NULL, (LPBYTE)&dwValue, &cb))
            {
            if (1 == dwValue)
                {
                cb = sizeof(szVer);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szValueVersion, 0, NULL, (LPBYTE)szVer, &cb))
                    {
                    if (pwVer)
                        ConvertStrToVer(szVer, pwVer);
                    if (pszVer)
                        StrCpyN(pszVer, szVer, cch);
                    fInstalled = TRUE;
                    }
                }
            }
        RegCloseKey(hkey);
        }

    return fInstalled;
    }


/*******************************************************************

    NAME:       GetFileVer

********************************************************************/
HRESULT GetFileVer(LPCTSTR pszExePath, LPTSTR pszVer, DWORD cch)
{
    DWORD   dwVerInfoSize, dwVerHnd;
    HRESULT hr = S_OK;
    LPSTR   pszInfo = NULL;
    LPSTR   pszVersion;
    LPWORD  pwTrans;
    TCHAR   szGet[MAX_PATH];
    UINT    uLen;
    
    // Validate Parameters
    Assert(pszExePath);
    Assert(pszVer);
    Assert(cch);

    // Validate global state
    Assert(g_pMalloc);

    // Initialize out parameters
    pszVer[0] = TEXT('\0');
    
    // Allocate space for version info block
    if (0 == (dwVerInfoSize = GetFileVersionInfoSize(const_cast<LPTSTR> (pszExePath), &dwVerHnd)))
    {
        hr = E_FAIL;
        TraceResult(hr);
        goto exit;
    }
    IF_NULLEXIT(pszInfo = (LPTSTR)g_pMalloc->Alloc(dwVerInfoSize));
    ZeroMemory(pszInfo, dwVerInfoSize);
            
    // Get Version info block
    IF_FALSEEXIT(GetFileVersionInfo(const_cast<LPTSTR> (pszExePath), dwVerHnd, dwVerInfoSize, pszInfo), E_FAIL);
    
    // Figure out language for version info
    IF_FALSEEXIT(VerQueryValue(pszInfo, "\\VarFileInfo\\Translation", (LPVOID *)&pwTrans, &uLen) && uLen >= (2 * sizeof(WORD)), E_FAIL);
        
    // Set up buffer with correct language and get version
    wnsprintf(szGet, ARRAYSIZE(szGet), "\\StringFileInfo\\%04X%04X\\FileVersion", pwTrans[0], pwTrans[1]);
    IF_FALSEEXIT(VerQueryValue(pszInfo, szGet, (LPVOID *)&pszVersion, &uLen) && uLen, E_FAIL);

    // Copy version out of version block, into out param
    Assert(pszVersion);
    StrCpyN(pszVer, pszVersion, cch);

exit:
    if (pszInfo)
        g_pMalloc->Free(pszInfo);

    return hr;
}
    
/*******************************************************************

    NAME:       GetExeVer

********************************************************************/
HRESULT GetExeVer(LPCTSTR pszExeName, WORD *pwVer, LPTSTR pszVer, int cch)
{
    HRESULT hr = S_OK;
    TCHAR   szPath[MAX_PATH];
    TCHAR   szVer[64];
    
    // Validate params
    Assert(pszExeName);
    
    // Initialize out params
    if (pszVer)
    {
        Assert(cch);
        pszVer[0] = 0;
    }
    if (pwVer)
        // Version is an array of 4 words 
        ZeroMemory(pwVer, 4 * sizeof(WORD));
    
    // Find the exe
    IF_FALSEEXIT(GetExePath(pszExeName, szPath, ARRAYSIZE(szPath), FALSE), E_FAIL);

    // Get the string representation of the version
    IF_FAILEXIT(hr = GetFileVer(szPath, szVer, ARRAYSIZE(szVer)));
    
    // Fill in out params
    if (pwVer)
        ConvertStrToVer(szVer, pwVer);
    if (pszVer)
        StrCpyN(pszVer, szVer, cch);

exit:
    return hr;
}


/****************************************************************************

    NAME:       IsNTAdmin

****************************************************************************/
BOOL IsNTAdmin(void)
    {
    static int    fIsAdmin = 2;
    HANDLE        hAccessToken;
    PTOKEN_GROUPS ptgGroups;
    DWORD         dwReqSize;
    UINT          i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;
    BOOL bRet;

    //
    // If we have cached a value, return the cached value. Note I never
    // set the cached value to false as I want to retry each time in
    // case a previous failure was just a temp. problem (ie net access down)
    //

    bRet = FALSE;
    ptgGroups = NULL;

    if( fIsAdmin != 2 )
        return (BOOL)fIsAdmin;

    if (si.osv.dwPlatformId != VER_PLATFORM_WIN32_NT) 
        {
        fIsAdmin = TRUE;      // If we are not running under NT return TRUE.
        return (BOOL)fIsAdmin;
        }


    if(!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hAccessToken ) )
        return FALSE;

    // See how big of a buffer we need for the token information
    if(!GetTokenInformation( hAccessToken, TokenGroups, NULL, 0, &dwReqSize))
        {
        // GetTokenInfo should the buffer size we need - Alloc a buffer
        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            MemAlloc((void **)&ptgGroups, dwReqSize);
        }

    // ptgGroups could be NULL for a coupla reasons here:
    // 1. The alloc above failed
    // 2. GetTokenInformation actually managed to succeed the first time (possible?)
    // 3. GetTokenInfo failed for a reason other than insufficient buffer
    // Any of these seem justification for bailing.

    // So, make sure it isn't null, then get the token info
    if(ptgGroups && GetTokenInformation(hAccessToken, TokenGroups, ptgGroups, dwReqSize, &dwReqSize))
        {
        if(AllocateAndInitializeSid( &NtAuthority, 2, SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &AdministratorsGroup) )
            {

            // Search thru all the groups this process belongs to looking for the
            // Admistrators Group.

            for( i=0; i < ptgGroups->GroupCount; i++ )
                {
                if( EqualSid(ptgGroups->Groups[i].Sid, AdministratorsGroup) )
                    {
                    // Yea! This guy looks like an admin
                    fIsAdmin = TRUE;
                    bRet = TRUE;
                    break;
                    }
                }

            FreeSid(AdministratorsGroup);
            }
        }
    // BUGBUG: Close handle here? doc's aren't clear whether this is needed.
    CloseHandle(hAccessToken);

    if(ptgGroups)
        MemFree(ptgGroups);

    return bRet;
    }

const LPCTSTR c_rgszExes[] = { c_szMainExe };
/****************************************************************************

    NAME:       RegisterExes

****************************************************************************/
void RegisterExes(BOOL fReg)
    {
    int i;
    STARTUPINFO sti;
    DWORD dw,cb;
    PROCESS_INFORMATION pi;
    TCHAR szPath[MAX_PATH], szUnreg[MAX_PATH + 32], szExpanded[MAX_PATH];
    LPTSTR pszPath;
    HKEY hkey;

    LOG("Reg/Unreg Exes:   ");

    // Use InstallRoot as directory
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_QUERY_VALUE, &hkey))
        {
        cb = sizeof(szPath);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szInstallRoot, 0, &dw, (LPBYTE)szPath, &cb))
            {
            if (REG_EXPAND_SZ == dw)
                {
                ZeroMemory(szExpanded, ARRAYSIZE(szExpanded));
                ExpandEnvironmentStrings(szPath, szExpanded, ARRAYSIZE(szExpanded));
                pszPath = szExpanded;
                }
            else
                pszPath = szPath;

            for (i = 0; i < ARRAYSIZE(c_rgszExes); i++)
                {
                wnsprintf(szUnreg, ARRAYSIZE(szUnreg), fReg ? c_szRegFmt : c_szUnregFmt, pszPath, c_rgszExes[i]);

                ZeroMemory(&sti, sizeof(STARTUPINFO));
                sti.cb = sizeof(STARTUPINFO);

                LOG2(szUnreg);
                if (CreateProcess(NULL, szUnreg, NULL, NULL, FALSE, 0, NULL, NULL, &sti, &pi))
                    {
                    WaitForSingleObject(pi.hProcess, INFINITE);
                    GetExitCodeProcess(pi.hProcess, &dw);
                    CloseHandle(pi.hThread);
                    CloseHandle(pi.hProcess);
                    }
                }
            }

        RegCloseKey(hkey);
        }
    }


#ifdef SETUP_LOG

/****************************************************************************

    NAME:       OpenLogFile

****************************************************************************/
void OpenLogFile()
    {
    TCHAR szPath[MAX_PATH];
    BOOL fOK = FALSE;
    DWORD cb;

    SYSTEMTIME systime;

    // On Term server, this will be stored in user's windows dir - this is fine.
    cb = GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
    if (*CharPrev(szPath, szPath+cb) != '\\')
        szPath[cb++] = '\\';
    StrCpyN(&szPath[cb], c_szFileLog, ARRAYSIZE(szPath)-cb);
    
    si.hLogFile = CreateFile(szPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 
                             FILE_FLAG_SEQUENTIAL_SCAN | FILE_ATTRIBUTE_NORMAL, NULL);

    if (INVALID_HANDLE_VALUE == si.hLogFile)
        return;

    cb = GetFileSize(si.hLogFile, NULL);
    if (0xFFFFFFFF == cb)
        cb = 0;

    // If file is getting kind of large
    if (cb >=  102400)
    {
        // Seek to the end of the file...
        SetFilePointer(si.hLogFile, 0, NULL, FILE_BEGIN);
        
        // Set End Of File
        SetEndOfFile(si.hLogFile);
        
    }

    // Seek to the end of the file...
    SetFilePointer(si.hLogFile, 0, NULL, FILE_END);
    
    GetLocalTime(&systime);

    wnsprintf(szLogBuffer, ARRAYSIZE(szLogBuffer), "\r\n\r\n-----[START]:  OE / WAB Setup 5.0 started on %02d/%02d/%04d at %02d:%02d\r\n", 
             systime.wMonth, systime.wDay, systime.wYear, systime.wHour, systime.wMinute);

    LogMessage(szLogBuffer, TRUE);
    }


/****************************************************************************

    NAME:       CloseLogFile

****************************************************************************/
void CloseLogFile()
    {
    if (INVALID_HANDLE_VALUE != si.hLogFile)
        {
        LogMessage("\r\n-----[END]", TRUE);
        CloseHandle(si.hLogFile);
        }
    }   

/****************************************************************************

    NAME:       LogMessage

****************************************************************************/
void LogMessage(LPSTR pszMsg, BOOL fNewLine)
    {
    if (INVALID_HANDLE_VALUE != si.hLogFile)
        {
        DWORD cb;
        CHAR szBuffer[256];

        if (fNewLine)
            {
            szBuffer[0] = '\r';
            szBuffer[1] = '\n';
            cb = 2;
            }
        else
            cb = 0;

        StrCpyN(&szBuffer[cb], pszMsg, ARRAYSIZE(szBuffer)-cb);
        WriteFile(si.hLogFile, (LPCVOID)szBuffer, lstrlen(szBuffer)+1, &cb, NULL);
        }
    }


/****************************************************************************

    NAME:       LogRegistryKey

****************************************************************************/
void LogRegistryKey(HKEY hkeyMain, LPTSTR pszSub)
    {
    if (INVALID_HANDLE_VALUE != si.hLogFile)
        {
        LogMessage("Registry Dump:  ", TRUE);

        if (HKEY_LOCAL_MACHINE == hkeyMain)
            LogMessage("HKLM, ", FALSE);
        else if (HKEY_CURRENT_USER == hkeyMain)
            LogMessage("HKCU, ", FALSE);
        else if (HKEY_CLASSES_ROOT == hkeyMain)
            LogMessage("HKCR, ", FALSE);
        else
            LogMessage("????, ", FALSE);

        LogMessage(pszSub, TRUE);

        }
    }


/****************************************************************************

    NAME:       LogRegistry

****************************************************************************/
void LogRegistry(HKEY hkeyMain, LPTSTR pszSub)
    {
    if (INVALID_HANDLE_VALUE != si.hLogFile)
        {
        DWORD i;
        HKEY  hkey;
        LONG  lStatus;
        DWORD dwClassLength=0;
        DWORD dwSubKeys;
        DWORD dwMaxSubKey;
        DWORD dwMaxClass;
        DWORD dwValues;
        DWORD dwMaxValueName;
        DWORD dwMaxValueData;
        DWORD dwSecurityLength;
        FILETIME ftLastWrite;
        LPTSTR szNameBuffer;

        //
        // First open the given key so we can enumerate its subkeys
        //
        if (ERROR_SUCCESS != RegOpenKeyEx(hkeyMain, pszSub, 0, KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hkey))
            {
	        LogRegistryKey(hkeyMain, pszSub);
            }

        //
        // Use RegQueryInfoKey to determine how big to allocate the buffer
        // for the subkey names.
        //
        if (ERROR_SUCCESS != RegQueryInfoKey(hkey, NULL, &dwClassLength, 0, &dwSubKeys, &dwMaxSubKey, &dwMaxClass, &dwValues,
                                             &dwMaxValueName, &dwMaxValueData, &dwSecurityLength, &ftLastWrite))
            {
            RegCloseKey(hkey);
            return;
            }

        if (!MemAlloc((void **)&szNameBuffer, sizeof(TCHAR) * (dwMaxSubKey + 1)))
            {
            RegCloseKey(hkey);
            return;
            }

        //
        // Enumerate subkeys and apply ourselves to each one.
        //
        i = 0;
        do {
            if (ERROR_SUCCESS == (lStatus = RegEnumKey(hkey, i, szNameBuffer, dwMaxSubKey+1)))
	            LogRegistry(hkey, szNameBuffer);
            else
                ++i;
            
            } while ( (lStatus != ERROR_NO_MORE_ITEMS) && (i < dwSubKeys) );

        MemFree(szNameBuffer);
        RegCloseKey(hkey);

        LogRegistryKey(hkey, pszSub);
        }
    }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\setup\wizard\wizdef.h ===
#ifndef _WIZDEF_H_
#define _WIZDEF_H_

#include <advpub.h>

#define SETUP_LOG

// Data structures
typedef enum
    {
    VER_NONE = 0,
    VER_1_0,
    VER_1_1,
    VER_4_0,
    VER_5_0_B1,
    VER_5_0,
    VER_6_0,
    VER_MAX,
    } SETUPVER;

typedef enum 
    {
    MODE_UNKNOWN = 0,
    MODE_INSTALL,
    MODE_UNINSTALL,
    MODE_ICONS,
    } SETUPMODE;

typedef enum 
    {
    TIME_MACHINE = 0,
    TIME_USER,
    } SETUPTIME;

typedef enum 
    {
    APP_UNKNOWN = 0,
    APP_OE,
    APP_WAB,
    } SETUPAPP;

typedef enum
    {
    CALLER_IE = 0,
    CALLER_WIN9X,
    CALLER_WINNT,
    } CALLER;

typedef struct tagSETUPINFO
    {
    TCHAR           szSysDir[MAX_PATH];
    TCHAR           szWinDir[MAX_PATH];
    TCHAR           szAppName[MAX_PATH];
    TCHAR           szCurrentDir[MAX_PATH];
    TCHAR           szInfDir[MAX_PATH];
    TCHAR           szINI[MAX_PATH];
    LPCTSTR         pszVerInfo;
    LPCTSTR         pszInfFile;
    OSVERSIONINFO   osv;

    BOOL            fNoIcons:1;
    BOOL            fPrompt:1;
    CALLER          caller;

    SETUPMODE       smMode;
    SETUPTIME       stTime;
    SETUPAPP        saApp;

    HINSTANCE       hInstAdvPack;
    RUNSETUPCOMMAND pfnRunSetup;
    LAUNCHINFSECTIONEX pfnLaunchEx;
    ADVINSTALLFILE  pfnCopyFile;
    ADDDELBACKUPENTRY pfnAddDel;
    REGSAVERESTORE  pfnRegRestore;
#ifdef SETUP_LOG
    HANDLE           hLogFile;
#endif
    } SETUPINFO;

typedef HRESULT (*PFN_ISETDEFCLIENT)(LPCTSTR,DWORD);

#define OE_QUIET  RSC_FLAG_QUIET

#define VERLEN 20

// Taken from -s \\trango\slmadd, -p setup, active\ie4setup\ie4setup.h
#define REDIST_REMOVELINKS              1
#define REDIST_DONT_TAKE_ASSOCIATION    2

// Icons OE Setup might create or delete
typedef enum
{
    ICON_ICWBAD = 0,
    ICON_DESKTOP,
    ICON_QLAUNCH,
    ICON_MAPIRECIP,
    ICON_QLAUNCH_OLD,
    // Keep this one last!
    ICON_LAST_ICON,
} OEICON;

// Flags used by FGetLinkInfo
#define LI_PATH     1
#define LI_TARGET   2
#define LI_DESC     4

#endif // _WIZDEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\shell\msimn.c ===
// --------------------------------------------------------------------------------
// MSIMN.C
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.h"
#define DEFINE_STRCONST
#include <msoeapi.h>
#include "msimnp.h"
#include "res.h"
#include "../msoeres/resource.h"
#include "shared.h"
#include "msoert.h"
#include "shlwapi.h"
#include "shlwapip.h"
#include <mapicode.h>
#include "error.h"

// --------------------------------------------------------------------------------
// String Consts
// --------------------------------------------------------------------------------
static const WCHAR c_wszRegCmd[]      = L"/reg";
static const WCHAR c_wszUnRegCmd[]    = L"/unreg";
static const WCHAR c_wszEmpty[]       = L"";
static const char c_szLangDll[]     = "MSOERES.DLL";
static const char c_szOLNewsKey[]   = "Software\\Clients\\News\\Microsoft Outlook";
static const char c_szRegOLNews[]   = "OLNews";
static const char c_szRegFlat[]     = "Software\\Microsoft\\Outlook Express";
static const char c_szDontUpgradeOLNews[] = "NoUpgradeOLNews";

// --------------------------------------------------------------------------------
// Debug Strings
// --------------------------------------------------------------------------------
#ifdef DEBUG
static const TCHAR c_szDebug[]      = "mshtmdbg.dll";
static const TCHAR c_szDebugUI[]    = "DbgExDoTracePointsDialog";
static const TCHAR c_szRegSpy[]     = "DbgExGetMallocSpy";
static const WCHAR c_wszInvokeUI[]  = L"/d";
#endif

// --------------------------------------------------------------------------------
// MSHTMDBG.DLL Prototypes
// --------------------------------------------------------------------------------
#ifdef DEBUG
typedef void (STDAPICALLTYPE *PFNDEBUGUI)(BOOL);
typedef void *(STDAPICALLTYPE *PFNREGSPY)(void);
#endif

// --------------------------------------------------------------------------------
// Debug Prototypes
// --------------------------------------------------------------------------------
#ifdef DEBUG
void LoadMSHTMDBG(LPWSTR pwszCmdLine);
#endif

// --------------------------------------------------------------------------------
// Prototypes
// --------------------------------------------------------------------------------
int WinMainT(HINSTANCE hInst, HINSTANCE hInstPrev, LPWSTR pwszCmdLine, int nCmdShow);

// --------------------------------------------------------------------------------
// UpgradeOLNewsReader()
// --------------------------------------------------------------------------------
void UpgradeOLNewsReader(HINSTANCE hInst)
{
    HKEY hkey;
    BOOL fOK = TRUE;
    DWORD dwDont, cb;
    
    // Make sure this functionality hasn't been disabled
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegFlat, 0, KEY_READ, &hkey))
    {
        cb = sizeof(dwDont);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szDontUpgradeOLNews, 0, NULL, (LPBYTE)&dwDont, &cb))
            fOK = 0 == dwDont;

        RegCloseKey(hkey);
    }

    if (fOK && ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szOLNewsKey, 0, KEY_READ, &hkey))
    {
        RegCloseKey(hkey);

        CallRegInstall(hInst, hInst, c_szRegOLNews, (LPSTR)c_szOLNewsKey);
    }
}

// --------------------------------------------------------------------------------
// ModuleEntry - Stolen from the CRT, used to shirink our code
// --------------------------------------------------------------------------------
int _stdcall ModuleEntry(void)
{
    // Locals
    int             i;
    STARTUPINFOA    si;
    LPWSTR          pwszCmdLine;

    // Get the command line
    pwszCmdLine = GetCommandLineW();

    // We don't want the "No disk in drive X:" requesters, so we set the critical error mask such that calls will just silently fail
    SetErrorMode(SEM_FAILCRITICALERRORS);

    // Parse the command line
    if ( *pwszCmdLine == L'\"') 
    {
        // Scan, and skip over, subsequent characters until another double-quote or a null is encountered.
        while ( *++pwszCmdLine && (*pwszCmdLine != L'\"'))
            {};

        // If we stopped on a double-quote (usual case), skip over it.
        if (*pwszCmdLine == L'\"')
            pwszCmdLine++;
    }
    else 
    {
        while (*pwszCmdLine > L' ')
            pwszCmdLine++;
    }

    // Skip past any white space preceeding the second token.
    while (*pwszCmdLine && (*pwszCmdLine <= L' ')) 
        pwszCmdLine++;

    // Get startup information...
    si.dwFlags = 0;
    GetStartupInfoA(&si);

    // Call the real winmain
    i = WinMainT(GetModuleHandle(NULL), NULL, pwszCmdLine, (si.dwFlags & STARTF_USESHOWWINDOW) ? si.wShowWindow : SW_SHOWDEFAULT);

    // Since we now have a way for an extension to tell us when it is finished, we will terminate all processes when the main thread goes away.
    ExitProcess(i);

    // Done
    return i;
}

// --------------------------------------------------------------------------------
// WinMain
// --------------------------------------------------------------------------------
int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hInstPrev, LPSTR pszCmdLine, int nCmdShow)
{
    // Just call ModuleEntry
    return(ModuleEntry());
}

// --------------------------------------------------------------------------------
// WinMainT
// --------------------------------------------------------------------------------
int WinMainT(HINSTANCE hInst, HINSTANCE hInstPrev, LPWSTR pwszCmdLine, int nCmdShow)
{
    // Locals
    HANDLE      hMutex=NULL;
    HWND        hwnd;
    DWORD       dwWait, dwError;
    INT         nErrorIds=0;
    PFNSTART    pfnStart;
    HINSTANCE   hInstMSOEDLL=NULL;
    HRESULT     hrOE;
    HINSTANCE   hInstUSER=NULL;
    static BOOL fFirstID=TRUE;

    // Register
    if (0 == StrCmpIW(c_wszRegCmd, pwszCmdLine))
    {
        CallRegInstall(hInst, hInst, c_szReg, NULL);
        
        // It not great to do this here, but we've only just written the OEOL keys,
        // and it would be worst to hit the reg during startup
        UpgradeOLNewsReader(hInst);

        return(1);
    }

    // Unregister
    else if (0 == StrCmpIW(c_wszUnRegCmd, pwszCmdLine))
    {
        CallRegInstall(hInst, hInst, c_szUnReg, NULL);
        return(1);
    }

    // Create the start shared mutex
    hMutex = CreateMutex(NULL, FALSE, STR_MSOEAPI_INSTANCEMUTEX);
    if (NULL == hMutex)
    {
        nErrorIds = idsStartupCantCreateMutex;
        goto exit;
    }

    // Wait for any current startups/shutdowns to finish
    dwWait = WaitForSingleObject(hMutex, (1000 * 60));
    if (dwWait != WAIT_OBJECT_0)
    {
        nErrorIds = idsStartupCantWaitForMutex;
        goto exit;
    }

    // Look for a current instance of the application
    hwnd = FindWindowWrapW(STRW_MSOEAPI_INSTANCECLASS, NULL);

    // is there another instance running already?
    if (NULL != hwnd)
    {
        // Locals
        COPYDATASTRUCT cds;
        DWORD_PTR      dwResult;

        // Some friendly output
        IF_DEBUG(OutputDebugString("Another instance of Athena was found...\n\n");)

        // Initialize the Copy data structure
        cds.dwData = MSOEAPI_ACDM_CMDLINE;
        cds.cbData = pwszCmdLine ? (lstrlenW(pwszCmdLine)+1)*sizeof(*pwszCmdLine) : 0;
        cds.lpData = pwszCmdLine;

        // On NT5, we need to call this to allow our window in the other process to take the foreground
        hInstUSER = LoadLibrary("USER32.DLL");
        if (hInstUSER)
        {
            FARPROC pfn = GetProcAddress(hInstUSER, "AllowSetForegroundWindow");
            if (pfn)
            {
                DWORD dwProcessId;
                GetWindowThreadProcessId(hwnd, &dwProcessId);
                (*pfn)(dwProcessId);
            }

            FreeLibrary(hInstUSER);
        }

        // Show the window into the foreground
        SetForegroundWindow(hwnd);
        SendMessageTimeout(hwnd, WM_COPYDATA, (WPARAM)NULL, (LPARAM)&cds, SMTO_ABORTIFHUNG, 1500, &dwResult);
    }

    // Lets load msoe.dll
    else
    {
        // Load Debug DLL
        IF_DEBUG(LoadMSHTMDBG(pwszCmdLine);)

        // Get the proc address of MSOE.DLL
        hInstMSOEDLL = LoadLibrary(STR_MSOEAPI_DLLNAME);

        // Did we load the dll
        if (NULL == hInstMSOEDLL)
        {
            dwError = GetLastError();
            if (dwError == ERROR_MOD_NOT_FOUND)
            {
                if (0xffffffff == GetFileAttributes(STR_MSOEAPI_DLLNAME))
                    nErrorIds = idsStartupCantFindMSOEDLL;
                else
                    nErrorIds = idsStartupModNotFoundMSOEDLL;
            }
            else if (dwError == ERROR_DLL_INIT_FAILED)
            {
                if (0xffffffff == GetFileAttributes(c_szLangDll))
                    nErrorIds = idsStartupCantFindResMSOEDLL;
                else
                    nErrorIds = idsStartupDllInitFailedMSOEDLL;
            }
            else
            {
                nErrorIds = idsStartupCantLoadMSOEDLL;
            }

            goto exit;
        }

        // Unlikely that this will fail
        pfnStart = (PFNSTART)GetProcAddress(hInstMSOEDLL, STR_MSOEAPI_START);

        // Did that Fail
        if (NULL == pfnStart)
        {
            nErrorIds = idsStartupCantLoadMSOEDLL;
            goto exit;
        }

        hrOE = S_RESTART_OE;
        
        while (S_RESTART_OE == hrOE)
        {
            hrOE = pfnStart(MSOEAPI_START_APPLICATION, (fFirstID ? pwszCmdLine : c_wszEmpty), nCmdShow);
            fFirstID = FALSE;
        }

        // NB: pfnInit will not return until the main message pump terminates
        if (SUCCEEDED(hrOE))
        {
            CloseHandle(hMutex);
            hMutex = NULL;
        }

        // The dll couldn't be loaded, as long as it wasn't due to need for ICW, display error
        else if (hrOE != hrUserCancel && hrOE != MAPI_E_USER_CANCEL)
        {
            nErrorIds = idsStartupCantInitMSOEDLL;
            goto exit;
        }
    }

exit:
    // Cleanup
    if (hMutex)
    {
        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }

    // Free msoe.dll
    if (hInstMSOEDLL)
        FreeLibrary(hInstMSOEDLL);

    // Show an error ?
    if (0 != nErrorIds)
    {
        // Locals
        CHAR        szRes[255];
        CHAR        szTitle[100];

        // Load the 
        LoadString(hInst, idsOutlookExpress, szTitle, ARRAYSIZE(szTitle));

        // Load the 
        LoadString(hInst, nErrorIds, szRes, ARRAYSIZE(szRes));

        // Show the error message
        MessageBox(NULL, szRes, szTitle, MB_OK | MB_SETFOREGROUND | MB_ICONEXCLAMATION);
    }


    IF_DEBUG(CoRevokeMallocSpy());

    // Done
    return nErrorIds;
}

#ifdef DEBUG
// --------------------------------------------------------------------------------
// LoadMSHTMDBG
// --------------------------------------------------------------------------------
void LoadMSHTMDBG(LPWSTR pwszCmdLine)
{
    // Load mshtmdbg.dll
    HINSTANCE hInstDebug = LoadLibrary(c_szDebug);

    // Did it load ?
    if (NULL != hInstDebug)
    {
        // Locals
        PFNREGSPY  pfnRegSpy;

        // If the user passed /d on the command line, lets configure mshtmdbg.dll
        if (0 == StrCmpIW(pwszCmdLine, c_wszInvokeUI))
        {
            // Locals
            PFNDEBUGUI pfnDebugUI;

            // Get the proc address of the UI
            pfnDebugUI = (PFNDEBUGUI)GetProcAddress(hInstDebug, c_szDebugUI);
            if (NULL != pfnDebugUI)
            {
                (*pfnDebugUI)(TRUE);
                goto exit;
            }
        }

        // Get the process address of the registration
        pfnRegSpy = (PFNREGSPY)GetProcAddress(hInstDebug, c_szRegSpy);
        if (NULL != pfnRegSpy)
        {
            LPMALLOCSPY pSpy = (IMallocSpy *)(*pfnRegSpy)();
            SideAssert(SUCCEEDED(CoRegisterMallocSpy(pSpy)));
        }
    }

exit:
    // Done
    return;
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\shell\resource.h ===
#ifndef __RESOURCE_H
#define __RESOURCE_H

// string resources
#define idsOutlookExpress
#define idsStartupCantCreateMutex       100
#define idsStartupCantWaitForMutex      101
#define idsStartupCantLoadMSOEDLL       102
#define idsStartupCantInitMSOEDLL       103
#define idsStartupFailureUnknown        100

// icon resources
#define idiGenericMail  2
#define idiNews         3
#define idiMsgPropSent  4
#define idiArtPropPost  5
#define idiMail         6
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\shell\pch.h ===
#include <windows.h>
#include <windowsx.h>
#ifdef WIN16
#include "athena16.h"
#endif

#include <BadStrFunctions.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\shell\res.h ===
#ifndef __RES_H
#define __RES_H

// string resources
#define idsOutlookExpress               99
#define idsStartupCantCreateMutex       100
#define idsStartupCantWaitForMutex      101
#define idsStartupCantLoadMSOEDLL       102
#define idsStartupCantInitMSOEDLL       103
#define idsStartupFailureUnknown        104
#define idsStartupModNotFoundMSOEDLL    105
#define idsStartupDllInitFailedMSOEDLL  106
#define idsStartupCantFindMSOEDLL       107
#define idsStartupCantFindResMSOEDLL    108

#define idiMailEXE          2
#define idiNewsEXE          3
#define idiMsgPropSentEXE   4
#define idiArtPropPostEXE   5

#endif // __RES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\staticrt\bytestm.cpp ===
// --------------------------------------------------------------------------------
// Bytestm.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// Steven J. Bailey
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "bytestm.h"

// -------------------------------------------------------------------------
// CByteStream::CByteStream
// -------------------------------------------------------------------------
CByteStream::CByteStream(LPBYTE pb, ULONG cb)
{
    Assert(pb ? cb > 0 : TRUE);
    m_cRef = 1;
    m_cbData = cb;
    m_iData = 0;
    m_pbData = pb;
    m_cbAlloc = 0;
}

// -------------------------------------------------------------------------
// CByteStream::CByteStream
// -------------------------------------------------------------------------
CByteStream::~CByteStream(void)
{
    SafeMemFree(m_pbData);
}

// -------------------------------------------------------------------------
// CByteStream::QueryInterface
// -------------------------------------------------------------------------
STDMETHODIMP CByteStream::QueryInterface(REFIID riid, LPVOID *ppv)
{
    // check params
    if (ppv == NULL)
        return TrapError(E_INVALIDARG);
    
    // Init
    *ppv = NULL;
    
    // Find IID
    if (IID_IUnknown == riid)
        *ppv = (IUnknown *)this;
    else if (IID_IStream == riid)
        *ppv = (IStream *)this;
    else
    {
        *ppv = NULL;
        return TrapError(E_NOINTERFACE);
    }
    
    // AddRef It
    ((IUnknown *)*ppv)->AddRef();
    
    // Done
    return S_OK;
}

// -------------------------------------------------------------------------
// CByteStream::AddRef
// -------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CByteStream::AddRef(void)
{
    return ++m_cRef;
}

// -------------------------------------------------------------------------
// CByteStream::Release
// -------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CByteStream::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CByteStream::_HrGrowBuffer
// --------------------------------------------------------------------------------
HRESULT CByteStream::_HrGrowBuffer(ULONG cbNeeded, ULONG cbExtra)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbAlloc;
    LPBYTE      pbNew;

    // Realloc
    IF_WIN32( CHECKALLOC(pbNew = (LPBYTE)CoTaskMemRealloc(m_pbData, m_cbData + cbNeeded + cbExtra)); )
    IF_WIN16( CHECKALLOC(pbNew = (LPBYTE)g_pMalloc->Realloc(m_pbData, m_cbData + cbNeeded + cbExtra)); )
    
    // Set m_pbData
    m_pbData = pbNew;
    
    // Set Allocated Size
    m_cbAlloc = m_cbData + cbNeeded + cbExtra;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CByteStream::SetSize
// --------------------------------------------------------------------------------
STDMETHODIMP CByteStream::SetSize(ULARGE_INTEGER uliSize)
{
    // Locals
    HRESULT         hr=S_OK;
    ULONG           cbSize=uliSize.LowPart;

    // Invalid Arg
    Assert(0 == uliSize.HighPart);

    // Greater thena current size
    if (cbSize + 2 > m_cbAlloc)
    {
        // Grow It
        CHECKHR(hr = _HrGrowBuffer(cbSize, 256));
    }

    // Save New Size
    m_cbData = cbSize;

    // Adjust m_iData
    if (m_iData > m_cbData)
        m_iData = m_cbData;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CByteStream::Write
// --------------------------------------------------------------------------------
STDMETHODIMP CByteStream::Write(const void HUGEP_16 *pv, ULONG cb, ULONG *pcbWritten)
{
    // Locals
    HRESULT     hr=S_OK;
    
    // Grow the buffer - always leave space for two nulls
    if (m_cbData + cb + 2 > m_cbAlloc)
    {
        // Grow It
        CHECKHR(hr = _HrGrowBuffer(cb, 256));
    }
    
    // Write the data
    CopyMemory(m_pbData + m_iData, (LPBYTE)pv, cb);

    // Increment Index
    m_iData += cb;

    // Increment m_cbData ?
    if (m_iData > m_cbData)
        m_cbData = m_iData;
   
    // Return amount written
    if (pcbWritten)
        *pcbWritten = cb;
    
exit:
    // Done
    return hr;
}

// -------------------------------------------------------------------------
// CByteStream::Read
// -------------------------------------------------------------------------
#ifndef WIN16
STDMETHODIMP CByteStream::Read(LPVOID pv, ULONG cb, ULONG *pcbRead)
#else
STDMETHODIMP CByteStream::Read(VOID HUGEP *pv, ULONG cb, ULONG *pcbRead)
#endif // !WIN16
{
    // Locals
    ULONG cbRead=0;
    
    // Validate Args
    Assert(pv && m_iData <= m_cbData);
    
    // No Data
    if (m_cbData > 0)
    {
        // Determine how must to copy from current page...
        cbRead = min(cb - cbRead, m_cbData - m_iData);
        
        // Has this page been committed
        CopyMemory((LPBYTE)pv, (LPBYTE)(m_pbData + m_iData), cbRead);
        
        // Increment cbRead
        m_iData += cbRead;
    }
    
    // Return amount read
    if (pcbRead)
        *pcbRead = cbRead;
    
    // Done
    return S_OK;
}

// -------------------------------------------------------------------------
// CByteStream::Seek
// -------------------------------------------------------------------------
STDMETHODIMP CByteStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNew)
{
    // Locals
    HRESULT         hr=S_OK;
    LONG            lMove;
    ULONG           iNew;
    
    // No high part
    Assert(dlibMove.HighPart == 0);
    
    // Set lMove
#ifdef MAC
    lMove = dlibMove.LowPart;
#else   // !MAC
    lMove = (ULONG)dlibMove.QuadPart;
#endif  // MAC
    
    // Seek the file pointer
    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        if (lMove < 0)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
        iNew = lMove;
        break;
        
    case STREAM_SEEK_CUR:
        if (lMove < 0 && (ULONG)(abs(lMove)) > m_iData)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
        iNew = m_iData + lMove;
        break;
        
    case STREAM_SEEK_END:
        if (lMove < 0 || (ULONG)lMove > m_cbData)
        {
            hr = TrapError(E_FAIL);
            goto exit;
        }
        iNew = m_cbData - lMove;
        break;
        
    default:
        hr = TrapError(STG_E_INVALIDFUNCTION);
        goto exit;
    }
    
    // New offset greater than size...
    m_iData = min(iNew, m_cbData);
    
    // Return Position
    if (plibNew)
#ifdef MAC
        ULISet32(*plibNew, m_iData);
#else   // !MAC
    plibNew->QuadPart = (LONGLONG)m_iData;
#endif  // MAC
    
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CByteStream::Stat
// --------------------------------------------------------------------------------
STDMETHODIMP CByteStream::Stat(STATSTG *pStat, DWORD)
{
    // Parameters
    Assert(pStat);
    
    // If that failed, lets generate our own information (mainly, fill in size
    ZeroMemory(pStat, sizeof(STATSTG));
    pStat->type = STGTY_STREAM;
#ifdef MAC
    ULISet32(pStat->cbSize, m_cbData);
#else   // !MAC
    pStat->cbSize.QuadPart = m_cbData;
#endif  // MAC
    
    // Done
    return S_OK;
}

// --------------------------------------------------------------------------------
// CByteStream::ResetObject
// --------------------------------------------------------------------------------
void CByteStream::ResetObject(void)
{
    m_cbData = 0;
    m_iData = 0;
    m_pbData = NULL;
    m_cbAlloc = 0;
}

// --------------------------------------------------------------------------------
// CByteStream::AcquireBytes
// --------------------------------------------------------------------------------
void CByteStream::AcquireBytes(ULONG *pcb, LPBYTE *ppb, ACQUIRETYPE actype)
{
    // Return Bytes ?
    if (ppb)
    {
        // Give them by data
        *ppb = m_pbData;
        
        // Return the Size
        if (pcb)
            *pcb = m_cbData;
        
        // I don't own it anymore
        if (ACQ_DISPLACE == actype)
            ResetObject();
    }
    
    // Return Size ?
    else if (pcb)
        *pcb = m_cbData;
}

// --------------------------------------------------------------------------------
// CByteStream::HrAcquireStringA
// --------------------------------------------------------------------------------
HRESULT CByteStream::HrAcquireStringA(ULONG *pcch, LPSTR *ppszStringA, ACQUIRETYPE actype)
{
    // Locals
    HRESULT     hr=S_OK;

    // Return Bytes ?
    if (ppszStringA)
    {
        // Write a Null
        CHECKHR(hr = Write("", 1, NULL));
        
        // Give them by data
        *ppszStringA = (LPSTR)m_pbData;
        
        // Return the Size
        if (pcch)
            *pcch = m_cbData - 1;
        
        // I don't own it anymore
        if (ACQ_DISPLACE == actype)
            ResetObject();
    }
    
    // Return Size ?
    else if (pcch)
        *pcch = m_cbData;

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CByteStream::AcquireStringW
// --------------------------------------------------------------------------------
HRESULT CByteStream::HrAcquireStringW(ULONG *pcch, LPWSTR *ppszStringW, ACQUIRETYPE actype)
{
    // Locals
    HRESULT     hr=S_OK;

    // Return Bytes ?
    if (ppszStringW)
    {
        // Write a Null
        CHECKHR(hr = Write("", 1, NULL));
        CHECKHR(hr = Write("", 1, NULL));
        
        // Give them by data
        *ppszStringW = (LPWSTR)m_pbData;
        
        // Return the Size
        if (pcch)
            *pcch = ((m_cbData - 2) / sizeof(WCHAR));
        
        // I don't own it anymore
        if (ACQ_DISPLACE == actype)
            ResetObject();
    }
    
    // Return Size ?
    else if (pcch)
        *pcch = (m_cbData / sizeof(WCHAR));

exit:
    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\staticrt\lang.cpp ===
// Simple module for using MLLoadLibrary().
// This cannot be merged with shared.cpp, because it uses shlwapi.h. which conflict with 
// come constant in shared.h
// Created: 07/08/98 by YST


#include "pch.hxx"
#include <shlwapi.h>
#include <shlwapip.h>
#include "htmlhelp.h"
#include "shared.h"
#include "htmlhelp.h"
#include <demand.h>

typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
typedef int (STDAPICALLTYPE *PFNMLWINHELP)(HWND hWndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
typedef HWND (STDAPICALLTYPE *PFNMLHTMLHELP)(HWND hWndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);

static const char c_szShlwapiDll[] = "shlwapi.dll";
static const char c_szDllGetVersion[] = "DllGetVersion";

static PFNMLWINHELP     pfnWinHelp = NULL;
static PFNMLHTMLHELP    pfnHtmlHelp = NULL;
static BOOL fWinHelChecked = FALSE;
static BOOL fHtmlHelpChecked = FALSE;
static BOOL fNT5 = FALSE;

const OENONSTDCP OENonStdCPs[] = 
{
//  CodePage    Read        ReadMenu    Title       SendMenu   SmSend   Use SIO
    50001,      50001,      50001,      0,          0,          0,      0,  // General Autoselect
    50932,      50932,      50932,      0,          0,          50220,  0,  // Japanice Auto Select
    50949,      50949,      50949,      949,        0,          /*51*/949,  0,  // Korean Auto Select
//  50939,      50939,      50939,      0,          0,          0,      0,  // Chinese Auto Select
    51932,      51932,      51932,      0,          0,          50220,  0,  // Japanice EUC
    932,        932,        932,        0,          0,          50220,  0,  // Japanice Shift-JIS
    50225,      50225,      50225,      949,        0,          949,    0,  // Korean ISO-2022-KR
    50220,      50932,      0,          0,          50220,      50220,  0,  // Japanice JIS
    51949,      50949,      0,          949,        51949,      51949,  0,  // Korean
    949,        50949,      0,          0,          949,        949,    0,  // Korean Windows
    50221,      50932,      50932,      0,          0,          50220,  1,  // Esc(I ISO-2022-JP
    50222,      50932,      50932,      0,          0,          50220,  2,  // Esc(J ISO-2022-JP
    28598,      28598,      28598,      0,          0,          28598,  0,  // Hebrew visual
//  1255,       1255,       1255,       0,          0,          1255,   0,  // Hebrew Windows
    20127,      28591,      0,          0,          0,          28591,  0,  // US-ASCII
    862,        862,        862,        0,          0,          862,    0,  // Hebrew OEM (DOS)
    0, 0, 0, 0, 0, 0
};                                                  

HINSTANCE LoadLangDll(HINSTANCE hInstCaller, LPCSTR szDllName, BOOL fNT)
{
    char szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DLLGETVERSIONPROC pfnVersion;
    int iEnd;
    DLLVERSIONINFO info;
    HINSTANCE hInst = NULL;

    hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, MAKEINTRESOURCE(377));
                    if (pfn != NULL)
                        hInst = pfn(szDllName, hInstCaller, (ML_NO_CROSSCODEPAGE));
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if ((NULL == hInst) && (GetModuleFileName(hInstCaller, szPath, ARRAYSIZE(szPath))))
    {
        PathRemoveFileSpec(szPath);
        iEnd = lstrlen(szPath);
        szPath[iEnd++] = '\\';
        lstrcpyn(&szPath[iEnd], szDllName, ARRAYSIZE(szPath)-iEnd);
        hInst = LoadLibrary(szPath);
    }

    AssertSz(hInst, "Failed to LoadLibrary Lang Dll");

    return(hInst);
}


// Get system architecture and OS version
BOOL GetPCAndOSTypes(SYSTEM_INFO * pSysInf, OSVERSIONINFO * pOsInf)
{
	GetSystemInfo(pSysInf);
    pOsInf->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	return(GetVersionEx(pOsInf));
}

// PlugUI version of WinHelp
BOOL OEWinHelp(HWND hWndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData)
{
    if(!pfnWinHelp)
    {
        if(!fWinHelChecked)
        {
            HINSTANCE hinstShlwapi;
            PFNMLLOADLIBARY pfn;
            DLLGETVERSIONPROC pfnVersion;
            int iEnd;
            DLLVERSIONINFO info;
            HINSTANCE hInst = NULL;


            hinstShlwapi = DemandLoadShlWapi();

            // hinstShlwapi = LoadLibrary(c_szShlwapiDll);
            if (hinstShlwapi != NULL)
            {
                pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
                if (pfnVersion != NULL)
                {
                    info.cbSize = sizeof(DLLVERSIONINFO);
                    if (SUCCEEDED(pfnVersion(&info)))
                    {
                        if (info.dwMajorVersion >= 5)
                        {
                            // 395 is ordinal # fot MLWinHelp
                            pfnWinHelp = (PFNMLWINHELP)GetProcAddress(hinstShlwapi, MAKEINTRESOURCE(395));
                        }
                    }
                }
               //  FreeLibrary(hinstShlwapi);        
            }
            fWinHelChecked = TRUE;
        }
        if(pfnWinHelp)
            return(pfnWinHelp(hWndCaller, lpszHelp, uCommand, dwData));
        else
            return(WinHelp(hWndCaller, lpszHelp, uCommand, dwData));
    }
    else
        return(pfnWinHelp(hWndCaller, lpszHelp, uCommand, dwData));
}

// PlugUI version of HtmlHelp
HWND OEHtmlHelp(HWND hWndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData)
{
    if(!pfnHtmlHelp)
    {
        if(!fHtmlHelpChecked)
        {
            HINSTANCE hinstShlwapi;
            PFNMLLOADLIBARY pfn;
            DLLGETVERSIONPROC pfnVersion;
            int iEnd;
            DLLVERSIONINFO info;
            HINSTANCE hInst = NULL;

            hinstShlwapi = DemandLoadShlWapi();

            // hinstShlwapi = LoadLibrary(c_szShlwapiDll);
            if (hinstShlwapi != NULL)
            {
                pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
                if (pfnVersion != NULL)
                {
                    info.cbSize = sizeof(DLLVERSIONINFO);
                    if (SUCCEEDED(pfnVersion(&info)))
                    {
                        if (info.dwMajorVersion >= 5)
                        {
                            // 396 is ordinal # fot MLHTMLHelp
                            pfnHtmlHelp = (PFNMLHTMLHELP)GetProcAddress(hinstShlwapi, MAKEINTRESOURCE(396));

                            if(!fNT5)
                            {
                                OSVERSIONINFO OSInfo;
                                OSInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

                                GetVersionEx(&OSInfo);
                                if((OSInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (OSInfo.dwMajorVersion >= 5))
                                    fNT5 = TRUE;
                            }
                        }
                    }
                }
               //  FreeLibrary(hinstShlwapi);        
            }
            fHtmlHelpChecked = TRUE;
        }
        if(pfnHtmlHelp)
            return(pfnHtmlHelp(hWndCaller, pszFile, uCommand, dwData, fNT5 ? ML_CROSSCODEPAGE_NT : ML_NO_CROSSCODEPAGE));
        else
            return(HtmlHelp(hWndCaller, pszFile, uCommand, dwData));
    }
    else
        return(pfnHtmlHelp(hWndCaller, pszFile, uCommand, dwData, fNT5 ? ML_CROSSCODEPAGE_NT : ML_NO_CROSSCODEPAGE));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\staticrt\memutil.cpp ===
// --------------------------------------------------------------------------------
// Memutil.cpp
// This file is linked into other projects.
// --------------------------------------------------------------------------------
#include "pch.hxx"

// --------------------------------------------------------------------------------
// ZeroAllocate
// --------------------------------------------------------------------------------
LPVOID ZeroAllocate(DWORD cbSize)
{
    LPVOID pv = g_pMalloc->Alloc(cbSize);
    if (pv)
        ZeroMemory(pv, cbSize);
    return pv;
}

// --------------------------------------------------------------------------------
// MemAlloc
// --------------------------------------------------------------------------------
BOOL MemAlloc(LPVOID* ppv, ULONG cb) 
{
    Assert(ppv && cb);
    *ppv = g_pMalloc->Alloc(cb);
    if (NULL == *ppv)
        return FALSE;
    return TRUE;
}

// --------------------------------------------------------------------------------
// HrAlloc
// --------------------------------------------------------------------------------
HRESULT HrAlloc(LPVOID *ppv, ULONG cb) 
{
    Assert(ppv && cb);
    *ppv = g_pMalloc->Alloc(cb);
    if (NULL == *ppv)
        return TrapError(E_OUTOFMEMORY);
    return S_OK;
}

// --------------------------------------------------------------------------------
// MemRealloc
// --------------------------------------------------------------------------------
BOOL MemRealloc(LPVOID *ppv, ULONG cbNew) 
{
    Assert(ppv && cbNew);
    LPVOID pv = g_pMalloc->Realloc(*ppv, cbNew);
    if (NULL == pv)
        return FALSE;
    *ppv = pv;
    return TRUE;
}

// --------------------------------------------------------------------------------
// HrRealloc
// --------------------------------------------------------------------------------
HRESULT HrRealloc(LPVOID *ppv, ULONG cbNew) 
{
    Assert(ppv);
    LPVOID pv = g_pMalloc->Realloc(*ppv, cbNew);
    if (NULL == pv && 0 != cbNew)
        return TrapError(E_OUTOFMEMORY);
    *ppv = pv;
    return S_OK;
}

// "new" and "delete" come from libcmt.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\staticrt\debug.c ===
// --------------------------------------------------------------------------------
// Debug.c
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include <windows.h>
#include <stdarg.h>
#include <shlwapi.h>
#include "msoedbg.h"

ASSERTDATA

#ifdef DEBUG

#define E_PENDING          _HRESULT_TYPEDEF_(0x8000000AL)
#define FACILITY_INTERNET  12
#define MIME_E_NOT_FOUND   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_INTERNET, 0xCE05)

// --------------------------------------------------------------------------------
// DebugStrf
// --------------------------------------------------------------------------------
__cdecl DebugStrf(LPTSTR lpszFormat, ...)
{
    static TCHAR szDebugBuff[500];
    va_list arglist;

    va_start(arglist, lpszFormat);
    wvnsprintf(szDebugBuff, ARRAYSIZE(szDebugBuff), lpszFormat, arglist);
    va_end(arglist);

    OutputDebugString(szDebugBuff);
}

// --------------------------------------------------------------------------------
// HrTrace
// --------------------------------------------------------------------------------
HRESULT HrTrace(HRESULT hr, LPSTR lpszFile, INT nLine)
{
    if (FAILED(hr) && MIME_E_NOT_FOUND != hr && E_PENDING != hr && E_NOINTERFACE != hr)
        DebugTrace("%s(%d) - HRESULT - %0X\n", lpszFile, nLine, hr);
    return hr;
}

// --------------------------------------------------------------------------------
// AssertSzFn
// --------------------------------------------------------------------------------
void AssertSzFn(LPSTR szMsg, LPSTR szFile, int nLine)
{
    static const char rgch1[]     = "File %s, line %d:";
    static const char rgch2[]     = "Unknown file:";
    static const char szAssert[]  = "Assert Failure";
    static const char szInstructions[] = "\n\nPress Abort to stop execution and break into a debugger.\nPress Retry to break into the debugger.\nPress Ignore to continue running the program.";

    char    rgch[1024];
    char   *lpsz;
    int     ret, cch;
    HWND    hwndActive;
    DWORD   dwFlags = MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SYSTEMMODAL | MB_SETFOREGROUND;

    if (szFile)
        wnsprintf(rgch, ARRAYSIZE(rgch)-2, rgch1, szFile, nLine);
    else
        StrCpyN(rgch, rgch2, ARRAYSIZE(rgch)-2);

    StrCatBuff(rgch, szInstructions, ARRAYSIZE(rgch)-2);
    
    cch = lstrlen(rgch);
    Assert(lstrlen(szMsg)<(512-cch-3));
    lpsz = &rgch[cch];
    *lpsz++ = '\n';
    *lpsz++ = '\n';
    StrCpyN(lpsz, szMsg, ARRAYSIZE(rgch) - cch -2);

    // If the active window is NULL, and we are running on
    // WinNT, let's set the MB_SERVICE_NOTIFICATION flag.  That
    // way, if we are running as a service, the message box will
    // pop-up on the desktop.
    //
    // NOTE:  This might not work in the case where we are a
    // service, and the current thread has called CoInitializeEx
    // with COINIT_APARTMENTTHREADED - 'cause in that case,
    // GetActiveWindow might return non-NULL  (apartment model
    // threads have message queues).  But hey - life's not
    // perfect...
    hwndActive = GetActiveWindow();
    if (hwndActive == NULL)
    {
        OSVERSIONINFO osvi;

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        if (GetVersionEx(&osvi) && (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT))
        {
            // See the docs for MessageBox and the MB_SERVICE_NOTIFICATION flag
            // to see why we do this...
            if (osvi.dwMajorVersion < 4)
            {
                dwFlags |= MB_SERVICE_NOTIFICATION_NT3X;
            }
            else
            {
                dwFlags |= MB_SERVICE_NOTIFICATION;
            }
        }
    }

    ret = MessageBox(hwndActive, rgch, szAssert, dwFlags);

    if ((IDABORT == ret) || (IDRETRY== ret))
        DebugBreak();

    /* Force a hard exit w/ a GP-fault so that Dr. Watson generates a nice stack trace log. */
    if (ret == IDABORT)
        *(LPBYTE)0 = 1; // write to address 0 causes GP-fault
}

// --------------------------------------------------------------------------------
// NFAssertSzFn
// --------------------------------------------------------------------------------
void NFAssertSzFn(LPSTR szMsg, LPSTR szFile, int nLine)
{
    char rgch[512];
#ifdef MAC
    static const char rgch1[] = "Non-fatal assert:\n\tFile %s, line %u:\n\t%s\n";
#else   // !MAC
    static const char rgch1[] = "Non-fatal assert:\r\n\tFile %s, line %u:\r\n\t%s\r\n";
#endif  // MAC
    wnsprintf(rgch, ARRAYSIZE(rgch), rgch1, szFile, nLine, szMsg ? szMsg : "");
    OutputDebugString(rgch);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\staticrt\msoedbg.cpp ===
// --------------------------------------------------------------------------------
// Msoedbg.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"

#ifdef DEBUG

LPSTR PathClipFile(LPSTR pszSrc, LPSTR pszDest, DWORD cchSize)
{
    LPSTR   pszT=pszSrc;
    int     cDirs=0;

    if (pszSrc)
    {
        // compact path
        pszT = pszSrc + lstrlen(pszSrc)-1;
        while (pszT != pszSrc)
        {
            if (*pszT == '\\' && ++cDirs == 3)
                break;
        
            pszT--;
        }
        if (pszSrc != pszT)
        {
            // if we clipped the path, show a ~
            StrCpyNA(pszDest, "~", cchSize);
            StrCpyNA(pszDest+1, pszT+1, cchSize-1);
            return pszDest;
        }
    }
    return pszSrc;
}

// --------------------------------------------------------------------------------
// GetDebugTraceTagMask
// --------------------------------------------------------------------------------
DWORD GetDebugTraceTagMask(LPCSTR pszTag, SHOWTRACEMASK dwDefaultMask)
{
    // Locals
    HRESULT     hr=S_OK;
    DWORD       dwMask=dwDefaultMask;
    HKEY        hKeyOpen=NULL;
    DWORD       dwType;
    DWORD       cb;

    // Tracing
    TraceCall("GetDebugTraceTagMask");

    // Invalid Arg
    Assert(pszTag);

    // Open the Key
    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER, "Software\\Microsoft\\Outlook Express\\Tracing", NULL, NULL, NULL, KEY_ALL_ACCESS, NULL, &hKeyOpen, &cb))
    {
        TraceResult(E_FAIL);
        goto exit;
    }

    // Query
    cb = sizeof(DWORD);
    if (ERROR_SUCCESS == RegQueryValueEx(hKeyOpen, pszTag, NULL, &dwType, (LPBYTE)&dwMask, &cb))
        goto exit;

    // Set to default value
    if (ERROR_SUCCESS != RegSetValueEx(hKeyOpen, pszTag, 0, REG_DWORD, (LPBYTE)&dwDefaultMask, sizeof(DWORD)))
    {
        TraceResult(E_FAIL);
        goto exit;
    }

exit:
    // Cleanup
    if (hKeyOpen)
        RegCloseKey(hKeyOpen);

    // Done
    return dwMask;
}

// --------------------------------------------------------------------------------
// DebugTraceEx
// --------------------------------------------------------------------------------
HRESULT DebugTraceEx(SHOWTRACEMASK dwMask, TRACEMACROTYPE tracetype, LPTRACELOGINFO pLog,
    HRESULT hr, LPSTR pszFile, INT nLine, LPCSTR pszMsg, LPCSTR pszFunc)
{
    TCHAR   rgchClip[MAX_PATH];
 
    // If pLog, reset dwMask
    if (pLog)
        dwMask = pLog->dwMask;
    
    // TRACE_CALL
    if (TRACE_CALL == tracetype)
    {
        // Trace Calls
        if (ISFLAGSET(dwMask, SHOW_TRACE_CALL) && pszFunc)
        {
            // No Message
            if (NULL == pszMsg)
            {
                // Do a Debug Trace
                DebugTrace("0x%08X: Call: %s(%d) - %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip, ARRAYSIZE(rgchClip)), nLine, pszFunc);
            }

            // Do a message
            else
            {
                // Do a Debug Trace
                DebugTrace("0x%08X: Call: %s(%d) - %s - %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip, ARRAYSIZE(rgchClip)), nLine, pszFunc, pszMsg);
            }
        }
    }

    // TRACE_INFO
    else if (TRACE_INFO == tracetype)
    {
        // Should we log
        if (ISFLAGSET(dwMask, SHOW_TRACE_INFO))
        {
            // Do a Debug Trace
            if (pszFunc)
                DebugTrace("0x%08X: Info: %s(%d) - %s - %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip, ARRAYSIZE(rgchClip)), nLine, pszFunc, pszMsg);
            else
                DebugTrace("0x%08X: Info: %s(%d) - %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip, ARRAYSIZE(rgchClip)), nLine, pszMsg);
        }
    }

    // TRACE_RESULT
    else
    {
        // No Message
        if (NULL == pszMsg)
        {
            // Do a Debug Trace
            if (pszFunc)
                DebugTrace("0x%08X: Result: %s(%d) - HRESULT(0x%08X) - GetLastError() = %d in %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip, ARRAYSIZE(rgchClip)), nLine, hr, GetLastError(), pszFunc);
            else
                DebugTrace("0x%08X: Result: %s(%d) - HRESULT(0x%08X) - GetLastError() = %d\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip, ARRAYSIZE(rgchClip)), nLine, hr, GetLastError());
        }

        // Do a message
        else
        {
            // Do a Debug Trace
            if (pszFunc)
                DebugTrace("0x%08X: Result: %s(%d) - HRESULT(0x%08X) - GetLastError() = %d - %s in %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip, ARRAYSIZE(rgchClip)), nLine, hr, GetLastError(), pszMsg, pszFunc);
            else
                DebugTrace("0x%08X: Result: %s(%d) - HRESULT(0x%08X) - GetLastError() = %d - %s\r\n", GetCurrentThreadId(), PathClipFile(pszFile, rgchClip, ARRAYSIZE(rgchClip)), nLine, hr, GetLastError(), pszMsg);
        }
    }

    // Log File
    if (pLog && pLog->pLog)
        pLog->pLog->TraceLog(dwMask, tracetype, nLine, hr, pszMsg);

    // Done
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\staticrt\demand.cpp ===
// --------------------------------------------------------------------------------
// Demand.cpp
// Written By: jimsch, brimo, t-erikne (bastardized by sbailey)
// --------------------------------------------------------------------------------
// W4 stuff
#pragma warning(disable: 4201)  // nameless struct/union
#pragma warning(disable: 4514)  // unreferenced inline function removed

// --------------------------------------------------------------------------------
// Includes
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "shlwapi.h"
#include "shared.h"
#define IMPLEMENT_LOADER_FUNCTIONS
#include "demand.h"

// --------------------------------------------------------------------------------
// CRIT_GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define CRIT_GET_PROC_ADDR(h, fn, temp)             \
    temp = (TYP_##fn) GetProcAddress(h, #fn);   \
    if (temp)                                   \
        VAR_##fn = temp;                        \
    else                                        \
        {                                       \
        AssertSz(0, VAR_##fn" failed to load"); \
        goto error;                             \
        }

// --------------------------------------------------------------------------------
// RESET
// --------------------------------------------------------------------------------
#define RESET(fn) VAR_##fn = LOADER_##fn;

// --------------------------------------------------------------------------------
// GET_PROC_ADDR
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR(h, fn) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
    Assert(VAR_##fn != NULL); \
    if(NULL == VAR_##fn ) { \
        VAR_##fn  = LOADER_##fn; \
    }

// Use this for exports not available on all platforms
#define GET_PROC_ADDR_NOASSERT(h, fn) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, #fn);  \
    if(NULL == VAR_##fn ) { \
        VAR_##fn  = LOADER_##fn; \
    }


// --------------------------------------------------------------------------------
// GET_PROC_ADDR_ORDINAL
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR_ORDINAL(h, fn, ord) \
    VAR_##fn = (TYP_##fn) GetProcAddress(h, MAKEINTRESOURCE(ord));  \
    Assert(VAR_##fn != NULL);  \
    if(NULL == VAR_##fn ) { \
        VAR_##fn  = LOADER_##fn; \
    }


// --------------------------------------------------------------------------------
// GET_PROC_ADDR3
// --------------------------------------------------------------------------------
#define GET_PROC_ADDR3(h, fn, varname) \
    VAR_##varname = (TYP_##varname) GetProcAddress(h, #fn);  \
    Assert(VAR_##varname != NULL);

// --------------------------------------------------------------------------------
// Static Globals
// --------------------------------------------------------------------------------
static HMODULE s_hCrypt     = NULL;
static HMODULE s_hCryptDlg  = NULL;
static HMODULE s_hWinTrust  = NULL;
static HMODULE s_hWinINET   = NULL;
static HMODULE s_hShell32   = NULL;
static HMODULE s_hOleAut32  = NULL;
static HMODULE s_hComDlg32  = NULL;
static HMODULE s_hVersion   = NULL;
static HMODULE s_hUrlmon    = NULL;
static HMODULE s_hShDocVw   = NULL;
static HMODULE s_hInetCPL   = NULL;
static HMODULE s_hMSO9      = NULL;
static HMODULE s_hWinMM     = NULL;
static HMODULE s_hRichEdit  = NULL;
static HMODULE s_hMLANG     = NULL;
static HMODULE s_hWSOCK     = NULL;
static HMODULE s_hPstoreC   = NULL;
static HMODULE s_hRAS       = NULL;
static HMODULE s_hAdvApi    = NULL;
static HMODULE s_hCryptUI   = NULL;
static HMODULE s_ShlWapi    = NULL;
static HMODULE s_hMSI       = NULL;

static CRITICAL_SECTION g_csDefLoad = {0};

BOOL            g_FSupportV3 = FALSE;

IF_DEBUG(static BOOL s_fInit = FALSE;)

// --------------------------------------------------------------------------------
// InitDemandLoadedLibs
// --------------------------------------------------------------------------------
void InitDemandLoadedLibs(void)
{
    InitializeCriticalSection(&g_csDefLoad);
    IF_DEBUG(s_fInit = TRUE;)
}

// --------------------------------------------------------------------------------
// FreeDemandLoadedLibs
// --------------------------------------------------------------------------------
void FreeDemandLoadedLibs(void)
{
    EnterCriticalSection(&g_csDefLoad);
    SafeFreeLibrary(s_hCrypt);
    SafeFreeLibrary(s_hCryptDlg);
    SafeFreeLibrary(s_hWinTrust);
    SafeFreeLibrary(s_hWinINET);
    SafeFreeLibrary(s_hWSOCK);
    SafeFreeLibrary(s_hShell32);
    SafeFreeLibrary(s_hOleAut32);
    SafeFreeLibrary(s_hComDlg32);
    SafeFreeLibrary(s_hVersion);
    SafeFreeLibrary(s_hUrlmon);
    SafeFreeLibrary(s_hMLANG);
    SafeFreeLibrary(s_hShDocVw);
    SafeFreeLibrary(s_hInetCPL);
    SafeFreeLibrary(s_hMSO9);
    SafeFreeLibrary(s_hWinMM);
    SafeFreeLibrary(s_hRichEdit);
    SafeFreeLibrary(s_hPstoreC);
    SafeFreeLibrary(s_hRAS);
    SafeFreeLibrary(s_hAdvApi);
    SafeFreeLibrary(s_ShlWapi);
    SafeFreeLibrary(s_hMSI);

    IF_DEBUG(s_fInit = FALSE;)
    LeaveCriticalSection(&g_csDefLoad);
    DeleteCriticalSection(&g_csDefLoad);
}

#ifdef DEAD
// --------------------------------------------------------------------------------
// CorrectAcctManPath
// --------------------------------------------------------------------------------
BOOL CorrectAcctManPath(LPTSTR pszPath, DWORD cb, DWORD *pdwT)
{
    HKEY hKey = NULL;
    BOOL fRet = FALSE;

    // Tracing
    TraceCall("CorrectAcctManPath");
    
    // Tact 1: Look for msoeacct.dll in same dir as inetcomm.dll

    // Try to open the inetcomm regkey
    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegInetCommDll, 0, KEY_QUERY_VALUE, &hKey))
    {
        TraceResult(E_FAIL);
        goto exit;
    }

    // Query the Value
    if (ERROR_SUCCESS != RegQueryValueEx(hKey, c_szDllPath, 0, pdwT, (LPBYTE)pszPath, &cb))
    {
        TraceResult(E_FAIL);
        goto exit;
    }

    fRet = TRUE;

exit:
    // Cleanup
    if (hKey)
        RegCloseKey(hKey);

    return fRet;
}
#endif // DEAD

BOOL IsSMIME3Supported(void)
{
    if (0 == s_hCrypt)
        DemandLoadCrypt32();

    return(g_FSupportV3);
}

// --------------------------------------------------------------------------------
// DemandLoadCrypt32
// --------------------------------------------------------------------------------
BOOL DemandLoadCrypt32(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hCrypt)
        {
        s_hCrypt = LoadLibrary("CRYPT32.DLL");
        AssertSz((NULL != s_hCrypt), TEXT("LoadLibrary failed on CRYPT32.DLL"));

        if (0 == s_hCrypt)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCrypt, CertRDNValueToStrA);
            GET_PROC_ADDR(s_hCrypt, CertAddCertificateContextToStore)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCertificateToStore)
            GET_PROC_ADDR(s_hCrypt, CertGetIssuerCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt, CertEnumCertificatesInStore)
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertFindCertificateInStore)
            GET_PROC_ADDR(s_hCrypt, CertVerifyTimeValidity)
            GET_PROC_ADDR(s_hCrypt, CertCompareCertificate)
            GET_PROC_ADDR(s_hCrypt, CertCompareCertificateName)
            GET_PROC_ADDR(s_hCrypt, CertCompareIntegerBlob)
            GET_PROC_ADDR(s_hCrypt, CertOpenStore)
            GET_PROC_ADDR(s_hCrypt, CertDuplicateStore)
            GET_PROC_ADDR(s_hCrypt, CertCloseStore)
            GET_PROC_ADDR(s_hCrypt, CertControlStore)
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateContextProperty)
            GET_PROC_ADDR(s_hCrypt, CertGetSubjectCertificateFromStore)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptDecodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CertFindRDNAttr)
            GET_PROC_ADDR(s_hCrypt, CryptMsgOpenToEncode)
            GET_PROC_ADDR(s_hCrypt, CryptMsgOpenToDecode)
            GET_PROC_ADDR(s_hCrypt, CryptMsgControl)
            GET_PROC_ADDR(s_hCrypt, CryptMsgUpdate)
            GET_PROC_ADDR(s_hCrypt, CryptMsgGetParam)
            GET_PROC_ADDR(s_hCrypt, CryptMsgClose)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObject)
            GET_PROC_ADDR(s_hCrypt, CryptEncodeObjectEx)
            GET_PROC_ADDR(s_hCrypt, CertAddEncodedCRLToStore)
            GET_PROC_ADDR(s_hCrypt, CertEnumCRLsInStore)
            GET_PROC_ADDR(s_hCrypt, CertFindExtension)
            GET_PROC_ADDR(s_hCrypt, CertCreateCertificateContext)
            GET_PROC_ADDR(s_hCrypt, CertGetEnhancedKeyUsage);
            GET_PROC_ADDR(s_hCrypt, CertNameToStrA);
            GET_PROC_ADDR(s_hCrypt, CertAddStoreToCollection);
            GET_PROC_ADDR(s_hCrypt, CertVerifySubjectCertificateContext);
            GET_PROC_ADDR(s_hCrypt, CertSetCertificateContextProperty);
            GET_PROC_ADDR(s_hCrypt, CertFreeCertificateChain);
            GET_PROC_ADDR(s_hCrypt, CertGetCertificateChain);
            GET_PROC_ADDR(s_hCrypt, CertVerifyCertificateChainPolicy);


            //
            //  We need to make a determination if the dll supports the
            //  new APIs we need or not
            //

            if (GetProcAddress(s_hCrypt, "CryptMsgVerifyCountersignatureEncodedEx") != NULL) {
                g_FSupportV3 = TRUE;
            }
        }
    }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

#ifdef DEAD
// --------------------------------------------------------------------------------
// SmartLoadLibrary
// --------------------------------------------------------------------------------
HINSTANCE SmartLoadLibrary(HKEY hKeyRoot, LPCSTR pszRegRoot, LPCSTR pszRegValue,
    LPCSTR pszDllName)
{
    // Locals
    BOOL            fProblem=FALSE;
    HINSTANCE       hInst=NULL;
    HKEY            hKey=NULL, hKey2 = NULL;
    CHAR            szPath[MAX_PATH];
    DWORD           cb=ARRAYSIZE(szPath);
    DWORD           dwT;
    DWORD           iEnd;
    LPSTR           pszPath=szPath;
    CHAR            szT[MAX_PATH];

    // Tracing
    TraceCall("SmartLoadLibrary");
    
    // Try to open the regkey
    if (ERROR_SUCCESS != RegOpenKeyEx(hKeyRoot, pszRegRoot, 0, KEY_QUERY_VALUE, &hKey))
    {
        TraceResult(E_FAIL);
        goto exit;
    }

    // Query the Value
    if (ERROR_SUCCESS != RegQueryValueEx(hKey, pszRegValue, 0, &dwT, (LPBYTE)szPath, &cb))
    {
        TraceResult(E_FAIL);
        goto exit;
    }

    // Special case: msoeacct reg entry may have been hosed by OL98
    // Looking for outlacct.dll\0 which has 13 characters
    if (!lstrcmpi(&szPath[cb-sizeof(TCHAR)*13], c_szOutlAcctManDll))
    {
        if (!CorrectAcctManPath(szPath, ARRAYSIZE(szPath), &dwT))
            // We're in trouble, couldn't find Inetcomm's path
            goto desperate;

        fProblem = TRUE;
    }

    // Remove the file name from the path
    PathRemoveFileSpec(szPath);

    // Get the End
    iEnd = lstrlen(szPath);

    // Append a backslash
    szPath[iEnd++] = '\\';

    // Append the Dll Name
    lstrcpyn(&szPath[iEnd], pszDllName, MAX_PATH - iEnd);

    if (fProblem)
    {
        // Try to open the regkey to save ourself in future - will fail if we are not admin!
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegMsoeAcctDll, 0, KEY_SET_VALUE, &hKey2))
        {
            RegSetValueEx(hKey2, c_szDllPath, 0, dwT, (LPBYTE)szPath, (iEnd+lstrlen(pszDllName)+1)*sizeof(TCHAR));
            RegCloseKey(hKey2);
        }
    }

    // Expand Sz ?
    if (REG_EXPAND_SZ == dwT)
    {
        // Expand It
        cb = ExpandEnvironmentStrings(szPath, szT, ARRAYSIZE(szT));

        // Failure
        if (cb == 0 || cb > ARRAYSIZE(szT))
        {
            TraceResult(E_FAIL);
            goto exit;
        }

        // Change pszPath
        pszPath = szT;
    }


    // Try to Load Library the Dll
    hInst = LoadLibrary(pszPath);

desperate:

    // Failure ?
    if (NULL == hInst)
    {
        // If we are not going to try the GetModuleFName, just try the dll name
        hInst = LoadLibrary(pszDllName);

        // We really failed
        if (NULL == hInst)
        {
            TraceResult(E_FAIL);
            goto exit;
        }
    }

exit:
    // Cleanup
    if (hKey)
        RegCloseKey(hKey);

    // Done
    return hInst;
}
#endif // DEAD

// --------------------------------------------------------------------------------
// DemandLoadCryptDlg
// --------------------------------------------------------------------------------
BOOL DemandLoadCryptDlg(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hCryptDlg)
        {
        s_hCryptDlg = LoadLibrary("CRYPTDLG.DLL");
        AssertSz((NULL != s_hCryptDlg), TEXT("LoadLibrary failed on CRYPTDLG.DLL"));

        if (0 == s_hCryptDlg)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hCryptDlg, CertViewPropertiesA)
            GET_PROC_ADDR(s_hCryptDlg, GetFriendlyNameOfCertA)
            GET_PROC_ADDR(s_hCryptDlg, CertSelectCertificateA)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWinTrust
// --------------------------------------------------------------------------------
BOOL DemandLoadWinTrust(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWinTrust)
        {
        s_hWinTrust = LoadLibrary("WINTRUST.DLL");
        AssertSz((NULL != s_hWinTrust), TEXT("LoadLibrary failed on WINTRUST.DLL"));

        if (0 == s_hWinTrust)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinTrust, WinVerifyTrust)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWinINET
// --------------------------------------------------------------------------------
BOOL DemandLoadWinINET(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWinINET)
        {
        s_hWinINET = LoadLibrary("WININET.DLL");
        AssertSz((NULL != s_hWinINET), TEXT("LoadLibrary failed on WININET.DLL"));

        if (0 == s_hWinINET)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinINET, RetrieveUrlCacheEntryFileA)
            GET_PROC_ADDR(s_hWinINET, UnlockUrlCacheEntryFileA)
            GET_PROC_ADDR(s_hWinINET, InternetQueryOptionA)
            GET_PROC_ADDR(s_hWinINET, InternetSetOptionA)
            GET_PROC_ADDR(s_hWinINET, InternetDialA)
            GET_PROC_ADDR(s_hWinINET, InternetHangUp)
            GET_PROC_ADDR(s_hWinINET, InternetGetConnectedStateExA)
            GET_PROC_ADDR(s_hWinINET, InternetCombineUrlA)
            GET_PROC_ADDR(s_hWinINET, InternetCrackUrlA)
            GET_PROC_ADDR(s_hWinINET, InternetCloseHandle)
            GET_PROC_ADDR(s_hWinINET, InternetReadFile)
            GET_PROC_ADDR(s_hWinINET, InternetConnectA)
            GET_PROC_ADDR(s_hWinINET, InternetOpenA)
            GET_PROC_ADDR(s_hWinINET, InternetSetStatusCallbackA)
            GET_PROC_ADDR(s_hWinINET, HttpQueryInfoA)
            GET_PROC_ADDR(s_hWinINET, HttpOpenRequestA)
            GET_PROC_ADDR(s_hWinINET, HttpAddRequestHeadersA)
            GET_PROC_ADDR(s_hWinINET, HttpSendRequestA)
            GET_PROC_ADDR(s_hWinINET, InternetWriteFile)
            GET_PROC_ADDR(s_hWinINET, HttpEndRequestA)
            GET_PROC_ADDR(s_hWinINET, HttpSendRequestExA)
            GET_PROC_ADDR(s_hWinINET, CommitUrlCacheEntryA)
            GET_PROC_ADDR(s_hWinINET, CreateUrlCacheEntryA)
            GET_PROC_ADDR(s_hWinINET, DeleteUrlCacheEntryA)

            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWSOCK32
// --------------------------------------------------------------------------------
BOOL DemandLoadWSOCK32()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWSOCK)
        {
        s_hWSOCK = LoadLibrary("WSOCK32.DLL");
        AssertSz((NULL != s_hWSOCK), TEXT("LoadLibrary failed on WSOCK32.DLL"));

        if (0 == s_hWSOCK)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWSOCK, WSAStartup)
            GET_PROC_ADDR(s_hWSOCK, WSACleanup)
            GET_PROC_ADDR(s_hWSOCK, WSAGetLastError)
            GET_PROC_ADDR(s_hWSOCK, gethostname)
            GET_PROC_ADDR(s_hWSOCK, gethostbyname)
            GET_PROC_ADDR(s_hWSOCK, WSAAsyncGetHostByName)
            GET_PROC_ADDR(s_hWSOCK, inet_addr)
            GET_PROC_ADDR(s_hWSOCK, htons)
            GET_PROC_ADDR(s_hWSOCK, WSACancelAsyncRequest)
            GET_PROC_ADDR(s_hWSOCK, send)
            GET_PROC_ADDR(s_hWSOCK, connect)
            GET_PROC_ADDR(s_hWSOCK, WSAAsyncSelect)
            GET_PROC_ADDR(s_hWSOCK, socket)
            GET_PROC_ADDR(s_hWSOCK, inet_ntoa)
            GET_PROC_ADDR(s_hWSOCK, closesocket)
            GET_PROC_ADDR(s_hWSOCK, recv)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadSHELL32
// --------------------------------------------------------------------------------
BOOL DemandLoadSHELL32(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hShell32)
        {
        s_hShell32 = LoadLibrary("SHELL32.DLL");
        AssertSz((NULL != s_hShell32), TEXT("LoadLibrary failed on SHELL32.DLL"));

        if (0 == s_hShell32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hShell32, SHGetPathFromIDListA);
            GET_PROC_ADDR_NOASSERT(s_hShell32, SHGetPathFromIDListW);
            GET_PROC_ADDR(s_hShell32, SHGetSpecialFolderLocation);
            GET_PROC_ADDR_ORDINAL(s_hShell32, SHFree, 195);
            GET_PROC_ADDR(s_hShell32, SHBrowseForFolderA);
            GET_PROC_ADDR_NOASSERT(s_hShell32, SHBrowseForFolderW);
            GET_PROC_ADDR_NOASSERT(s_hShell32, SHSetUnreadMailCountW);
            GET_PROC_ADDR(s_hShell32, ShellExecuteA);
            GET_PROC_ADDR(s_hShell32, ShellExecuteExA);
            GET_PROC_ADDR(s_hShell32, DragQueryFileA);
            GET_PROC_ADDR(s_hShell32, SHGetFileInfoA);
            GET_PROC_ADDR(s_hShell32, Shell_NotifyIconA);
            GET_PROC_ADDR(s_hShell32, ExtractIconA);
            GET_PROC_ADDR(s_hShell32, SHFileOperationA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
         
#if 0
// --------------------------------------------------------------------------------
// DemandLoadOLEAUT32
// --------------------------------------------------------------------------------
BOOL DemandLoadOLEAUT32(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hOleAut32)
        {
        s_hOleAut32 = LoadLibrary("OLEAUT32.DLL");
        AssertSz((BOOL)s_hOleAut32, TEXT("LoadLibrary failed on OLEAUT32.DLL"));

        if (0 == s_hOleAut32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hOleAut32, SafeArrayCreate);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayPutElement);
            GET_PROC_ADDR(s_hOleAut32, DispInvoke);
            GET_PROC_ADDR(s_hOleAut32, DispGetIDsOfNames);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayDestroy);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayGetUBound);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayGetLBound);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayGetElement);
            GET_PROC_ADDR(s_hOleAut32, SysAllocStringByteLen);
            GET_PROC_ADDR(s_hOleAut32, SysReAllocString);
            GET_PROC_ADDR(s_hOleAut32, SysAllocStringLen);
            GET_PROC_ADDR(s_hOleAut32, SysAllocString);
            GET_PROC_ADDR(s_hOleAut32, SysFreeString);
            GET_PROC_ADDR(s_hOleAut32, SysStringLen);
            GET_PROC_ADDR(s_hOleAut32, VariantInit);
            GET_PROC_ADDR(s_hOleAut32, LoadTypeLib);
            GET_PROC_ADDR(s_hOleAut32, RegisterTypeLib);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayAccessData);
            GET_PROC_ADDR(s_hOleAut32, SafeArrayUnaccessData);
            GET_PROC_ADDR(s_hOleAut32, SysStringByteLen);
            GET_PROC_ADDR(s_hOleAut32, VariantClear);
            GET_PROC_ADDR(s_hOleAut32, VariantCopy);
            GET_PROC_ADDR(s_hOleAut32, SetErrorInfo);
            GET_PROC_ADDR(s_hOleAut32, CreateErrorInfo);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
#endif

// --------------------------------------------------------------------------------
// DemandLoadCOMDLG32
// --------------------------------------------------------------------------------
BOOL DemandLoadCOMDLG32(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hComDlg32)
        {
        s_hComDlg32 = LoadLibrary("COMDLG32.DLL");
        AssertSz((NULL != s_hComDlg32), TEXT("LoadLibrary failed on COMDLG32.DLL"));

        if (0 == s_hComDlg32)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hComDlg32, GetSaveFileNameA);
            GET_PROC_ADDR(s_hComDlg32, GetOpenFileNameA);
            GET_PROC_ADDR(s_hComDlg32, ChooseFontA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadVERSION
// --------------------------------------------------------------------------------
BOOL DemandLoadVERSION(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hVersion)
        {
        s_hVersion = LoadLibrary("VERSION.DLL");
        AssertSz((NULL != s_hVersion), TEXT("LoadLibrary failed on VERSION.DLL"));

        if (0 == s_hVersion)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hVersion, VerQueryValueA);
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoA);
            GET_PROC_ADDR(s_hVersion, GetFileVersionInfoSizeA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadURLMON
// --------------------------------------------------------------------------------
BOOL DemandLoadURLMON(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hUrlmon)
        {
        s_hUrlmon = LoadLibrary("URLMON.DLL");
        AssertSz((NULL != s_hUrlmon), TEXT("LoadLibrary failed on URLMON.DLL"));

        if (0 == s_hUrlmon)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hUrlmon, CreateURLMoniker);
            GET_PROC_ADDR(s_hUrlmon, URLOpenBlockingStreamA);
            GET_PROC_ADDR(s_hUrlmon, FindMimeFromData);
            GET_PROC_ADDR(s_hUrlmon, CoInternetCombineUrl);
            GET_PROC_ADDR(s_hUrlmon, RegisterBindStatusCallback);
            GET_PROC_ADDR(s_hUrlmon, RevokeBindStatusCallback);
            GET_PROC_ADDR(s_hUrlmon, FaultInIEFeature);
            GET_PROC_ADDR(s_hUrlmon, CoInternetGetSecurityUrl);
            GET_PROC_ADDR(s_hUrlmon, ObtainUserAgentString);
            GET_PROC_ADDR(s_hUrlmon, CoInternetCreateSecurityManager);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadMLANG
// --------------------------------------------------------------------------------
BOOL DemandLoadMLANG(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hMLANG)
        {
        s_hMLANG = LoadLibrary("MLANG.DLL");
        AssertSz((NULL != s_hMLANG), TEXT("LoadLibrary failed on MLANG.DLL"));

        if (0 == s_hMLANG)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hMLANG, IsConvertINetStringAvailable)
            GET_PROC_ADDR(s_hMLANG, ConvertINetString)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadSHDOCVW
// --------------------------------------------------------------------------------
BOOL DemandLoadSHDOCVW()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hShDocVw)
        {
        s_hShDocVw = LoadLibrary("SHDOCVW.DLL");
        AssertSz((NULL != s_hShDocVw), TEXT("LoadLibrary failed on SHDOCVW.DLL"));

        if (0 == s_hShDocVw)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hShDocVw, AddUrlToFavorites);
            GET_PROC_ADDR(s_hShDocVw, SetQueryNetSessionCount);
            GET_PROC_ADDR(s_hShDocVw, SetShellOfflineState);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadINETCPL
// --------------------------------------------------------------------------------
BOOL DemandLoadINETCPL()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hInetCPL)
        {
        s_hInetCPL = LoadLibrary("INETCPL.CPL");
        AssertSz((NULL != s_hInetCPL), TEXT("LoadLibrary failed on INETCPL.CPL"));

        if (0 == s_hInetCPL)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hInetCPL, OpenFontsDialog);
            GET_PROC_ADDR(s_hInetCPL, LaunchConnectionDialog);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadMSO9
// --------------------------------------------------------------------------------
BOOL DemandLoadMSO9(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hMSO9)
        {
#ifdef DEBUG
        s_hMSO9 = LoadLibrary("mso9d.DLL");
        if (!s_hMSO9)
            s_hMSO9 = LoadLibrary("mso9.DLL");
#else
        s_hMSO9 = LoadLibrary("mso9.DLL");
#endif
        AssertSz((NULL != s_hMSO9), TEXT("LoadLibrary failed on MSO9.DLL"));

        if (0 == s_hMSO9)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR3(s_hMSO9, _MsoFGetComponentManager@4, MsoFGetComponentManager);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadWinMM
// --------------------------------------------------------------------------------
BOOL DemandLoadWinMM(void)
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hWinMM)
        {
        s_hWinMM = LoadLibrary("winmm.dll");
        AssertSz((NULL != s_hWinMM), TEXT("LoadLibrary failed on WINMM.DLL"));

        if (0 == s_hWinMM)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hWinMM, sndPlaySoundA);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadRichEdit
// --------------------------------------------------------------------------------
BOOL DemandLoadRichEdit(void)
{
    if (!s_hRichEdit)
        {
        s_hRichEdit = LoadLibrary("RICHED32.DLL");
        if (!s_hRichEdit)
            return FALSE;
        }

    return TRUE;
}

// --------------------------------------------------------------------------------
// DemandLoadPStoreC
// --------------------------------------------------------------------------------
BOOL DemandLoadPStoreC()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hPstoreC)
        {
        s_hPstoreC = LoadLibrary("PSTOREC.DLL");
        AssertSz((NULL != s_hPstoreC), TEXT("LoadLibrary failed on PSTOREC.DLL"));

        if (0 == s_hPstoreC)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hPstoreC, PStoreCreateInstance);
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

// --------------------------------------------------------------------------------
// DemandLoadRAS
// --------------------------------------------------------------------------------
BOOL DemandLoadRAS()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hRAS)
        {
        s_hRAS = LoadLibrary("RASAPI32.DLL");
        AssertSz((NULL != s_hRAS), TEXT("LoadLibrary failed on RASAPI32.DLL"));

        if (0 == s_hRAS)
            fRet = FALSE;
        else
            {
            GET_PROC_ADDR(s_hRAS, RasEnumEntriesA)
            GET_PROC_ADDR(s_hRAS, RasEditPhonebookEntryA)
            GET_PROC_ADDR(s_hRAS, RasCreatePhonebookEntryA)
            }
        }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

BOOL IsWin95()
{
    OSVERSIONINFOA       ver;
    ver.dwOSVersionInfoSize = sizeof(ver);

    if (GetVersionExA(&ver))
        {
        return (VER_PLATFORM_WIN32_WINDOWS == ver.dwPlatformId);
        }
    return FALSE;
}

BOOL MyCryptAcquireContextW(HCRYPTPROV * phProv, LPCWSTR pszContainer,
                            LPCWSTR pszProvider, DWORD dwProvType, DWORD dwFlags)
{
    char        rgch1[256];
    char        rgch2[256];

    if (pszContainer != NULL)
        {
        WideCharToMultiByte(CP_ACP, 0, pszContainer, -1, rgch1, sizeof(rgch1),
                            NULL, NULL);
        pszContainer = (LPWSTR) rgch1;
        }

    if (pszProvider != NULL)
        {
        WideCharToMultiByte(CP_ACP, 0, pszProvider, -1, rgch2, sizeof(rgch2),
                            NULL, NULL);
        pszProvider = (LPWSTR) rgch2;
        }

    return CryptAcquireContextA(phProv, (LPCSTR) pszContainer,
                                (LPCSTR) pszProvider, dwProvType, dwFlags);
}

BOOL MY_CryptContextAddRef(HCRYPTPROV, DWORD * , DWORD )
{
#ifdef DEBUG
    return TRUE;
#else  // !DEBUG
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
#endif // DEBUG
}

BOOL MY_CryptDuplicateKey(HCRYPTKEY , DWORD * , DWORD , HCRYPTKEY * )
{
#ifdef DEBUG
    return TRUE;
#else // !DEBUG
    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
#endif // DEBUG
}

BOOL DemandLoadAdvApi32()
{
    BOOL                fRet = TRUE;
    OSVERSIONINFOA       ver;

    ver.dwOSVersionInfoSize = sizeof(ver);

    Assert(s_fInit);

    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hAdvApi)
        {
        if(!GetVersionExA(&ver))
            {
            fRet = FALSE;
            goto exit;
            }

        s_hAdvApi = LoadLibrary("ADVAPI32.DLL");
        AssertSz((NULL != s_hAdvApi), TEXT("LoadLibrary failed on ADVAPI32.DLL"));

        if (0 == s_hAdvApi)
            fRet = FALSE;
        else
            {
            if (VER_PLATFORM_WIN32_WINDOWS == ver.dwPlatformId) // Win95
                CryptAcquireContextW = MyCryptAcquireContextW;
            else
                GET_PROC_ADDR(s_hAdvApi, CryptAcquireContextW)

            VAR_CryptContextAddRef = LOADER_CryptContextAddRef;
            if((ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5))  //NT5
                {
                GET_PROC_ADDR(s_hAdvApi, CryptContextAddRef);
                GET_PROC_ADDR(s_hAdvApi, CryptDuplicateKey);
                }

            if (VAR_CryptContextAddRef == LOADER_CryptContextAddRef)
                VAR_CryptContextAddRef = MY_CryptContextAddRef;

            if (VAR_CryptDuplicateKey == LOADER_CryptDuplicateKey)
                VAR_CryptDuplicateKey = MY_CryptDuplicateKey;
            }
        }

exit:
    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}

HINSTANCE DemandLoadShlWapi()
{
    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);
    
    if (!s_ShlWapi)
    {
        s_ShlWapi = LoadLibrary("shlwapi.dll");
        AssertSz((NULL != s_ShlWapi), TEXT("LoadLibrary failed on ShlWAPI.DLL"));
        
    }
    
    LeaveCriticalSection(&g_csDefLoad);
    return((HINSTANCE) s_ShlWapi);
}

BOOL DemandLoadCryptUI()
{
    BOOL                fRet = TRUE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    if (0 == s_hCryptUI)
    {
        s_hCryptUI = LoadLibrary("CRYPTUI.DLL");
        AssertSz((NULL != s_hCryptUI), TEXT("LoadLibrary failed on CRYPTUI.DLL"));

        if (0 == s_hCryptUI)
            fRet = FALSE;
        else
        {
            GET_PROC_ADDR(s_hCryptUI, CryptUIDlgCertMgr)
        }
    }
    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}


// --------------------------------------------------------------------------------
// DemandLoadMSI
// --------------------------------------------------------------------------------
BOOL DemandLoadMSI(void)
{
    BOOL fRet = TRUE;
    static BOOL s_fMSIInited = FALSE;

    Assert(s_fInit);
    EnterCriticalSection(&g_csDefLoad);

    // Unlike other demand-loaded dlls, this dll may not exist and that's fine.  
    // In these cases s_hMSI will always be NULL, so we need another flag to tell
    // us whether we are inited.
    if (FALSE == s_fMSIInited)
    {
        s_fMSIInited = TRUE;

        s_hMSI = LoadLibrary("MSI.DLL");
        if (NULL == s_hMSI)
            fRet = FALSE;
        else
        {
            // It's okay to use the asserting macro here because while MSI is
            // optional, if present it must have these entry points
            GET_PROC_ADDR(s_hMSI, MsiEnumComponentQualifiersA);
            GET_PROC_ADDR(s_hMSI, MsiProvideQualifiedComponentA);
            GET_PROC_ADDR(s_hMSI, MsiLocateComponentA);
            GET_PROC_ADDR(s_hMSI, MsiSetInternalUI);
        }
    }

    LeaveCriticalSection(&g_csDefLoad);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\staticrt\shared.cpp ===
/*
*    shared.cpp
*    
*    History:
*      Feb '98: Created.
*    
*    Copyright (C) Microsoft Corp. 1998
*
*   Only place code in here that all dlls will have STATICALLY LINKED to them
*/

#include "pch.hxx"
#include <advpub.h>
#define DEFINE_SHARED_STRINGS
#include "shared.h"
#include <migerror.h>
#include <shlwapi.h>

BOOL GetProgramFilesDir(LPSTR pszPrgfDir, DWORD dwSize, DWORD dwVer)
{
    HKEY  hkey;
    DWORD dwType;

    *pszPrgfDir = 0;

    if (dwVer >= 5)
    {
        if ( GetEnvironmentVariable( TEXT("ProgramFiles"), pszPrgfDir, dwSize ) )
            return TRUE;
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegWinCurrVer, 0, KEY_QUERY_VALUE, &hkey))
    {
        if (dwVer >= 4)
            if (ERROR_SUCCESS == RegQueryValueEx(hkey, c_szProgFilesDir, 0, &dwType, (LPBYTE)pszPrgfDir, &dwSize))
            
            {
                char szSysDrv[5] = { 0 };

                // combine reg value and systemDrive to get the acurate ProgramFiles dir
                if ( GetEnvironmentVariable( TEXT("SystemDrive"), szSysDrv, ARRAYSIZE(szSysDrv) ) &&
                     szSysDrv[0] )
                    *pszPrgfDir = szSysDrv[0];
            }

        RegCloseKey(hkey);
        return TRUE;
    }
     
    return FALSE;
}

BOOL ReplaceSubString(LPSTR pszOutLine, DWORD cchSize, LPCSTR pszOldLine, LPCSTR pszSubStr, LPCSTR pszSubReplacement )
{
    LPSTR	lpszStart = NULL;
    LPSTR	lpszNewLine;
    LPCSTR	lpszCur;
    BOOL	bFound = FALSE;
    int		ilen;

    lpszCur = pszOldLine;
    lpszNewLine = pszOutLine;
    DWORD cchSizeNewLine = cchSize;
    while ( lpszStart = StrStrIA( lpszCur, pszSubStr ) )
    {
        // this module path has the systemroot            
        ilen = (int) (lpszStart - lpszCur);
        if ( ilen )
        {
            StrCpyN(lpszNewLine, lpszCur, min((ilen + 1), (int)cchSizeNewLine));
            lpszNewLine += ilen;
            cchSizeNewLine -= ilen;
        }
        StrCpyN(lpszNewLine, pszSubReplacement, cchSizeNewLine);

        lpszCur = lpszStart + lstrlen(pszSubStr);
        ilen = lstrlen(pszSubReplacement);
        lpszNewLine += ilen;
        cchSizeNewLine -= ilen;
        bFound = TRUE;
    }

    StrCpyN(lpszNewLine, lpszCur, cchSizeNewLine);

    return bFound;
}

//==========================================================================================
// AddEnvInPath - Ripped from Advpack
//==========================================================================================
BOOL AddEnvInPath(LPCSTR pszOldPath, LPSTR pszNew, DWORD cchSize)
{
    static OSVERSIONINFO verinfo;
    static BOOL          bNeedOSInfo=TRUE;

    CHAR szBuf[MAX_PATH], szEnvVar[MAX_PATH];
    CHAR szReplaceStr[100];    
    CHAR szSysDrv[5];
    BOOL bFound = FALSE;
    
    // Do we need to check the OS version or is it cached?
    if (bNeedOSInfo)
    {
        bNeedOSInfo = FALSE;
        verinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        if (GetVersionEx(&verinfo) == FALSE)
        {
            AssertSz(FALSE, "AddEnvInPath: Couldn't obtain OS ver info.");
            verinfo.dwPlatformId = VER_PLATFORM_WIN32_WINDOWS;
        }
    }
        
    // Variable substitution is only supported on NT
    if(VER_PLATFORM_WIN32_NT != verinfo.dwPlatformId)
        goto exit;

    // Try to replace USERPROFILE
    if ( GetEnvironmentVariable( "UserProfile", szEnvVar, ARRAYSIZE(szEnvVar) )  &&
         ReplaceSubString(szBuf, ARRAYSIZE(szBuf), pszOldPath, szEnvVar, "%UserProfile%" ) )
    {
        bFound = TRUE;
    }

    // Try to replace the Program Files Dir
    else if ( (verinfo.dwMajorVersion >= 5) && GetEnvironmentVariable( "ProgramFiles", szEnvVar, ARRAYSIZE(szEnvVar) ) &&
              ReplaceSubString(szBuf, ARRAYSIZE(szBuf), pszOldPath, szEnvVar, "%ProgramFiles%" ) )
    {
        bFound = TRUE;
    }

    // replace c:\winnt Windows folder
    else if ( GetEnvironmentVariable( "SystemRoot", szEnvVar, ARRAYSIZE(szEnvVar) ) &&
              ReplaceSubString(szBuf, ARRAYSIZE(szBuf), pszOldPath, szEnvVar, "%SystemRoot%" ) )
    {
        bFound = TRUE;
    }

    // Replace the c: System Drive letter
    else if ( GetEnvironmentVariable( "SystemDrive", szSysDrv, ARRAYSIZE(szSysDrv) ) && 
              ReplaceSubString(szBuf, ARRAYSIZE(szBuf), pszOldPath, szSysDrv, "%SystemDrive%" ) )
    {
        bFound = TRUE;
    }

exit:
    // this way, if caller pass the same location for both params, still OK.
    if ( bFound ||  ( pszNew != pszOldPath ) )
        StrCpyN(pszNew, bFound ? szBuf : pszOldPath, cchSize);

    return bFound;    
}


// --------------------------------------------------------------------------------
// CallRegInstall - Self-Registration Helper
// --------------------------------------------------------------------------------
HRESULT CallRegInstall(HINSTANCE hInstCaller, HINSTANCE hInstRes, LPCSTR pszSection, LPSTR pszExtra)
{
    AssertSz(hInstCaller, "[ARGS] CallRegInstall: NULL hInstCaller");
    AssertSz(hInstRes,    "[ARGS] CallRegInstall: NULL hInstRes");
    AssertSz(hInstRes,    "[ARGS] CallRegInstall: NULL pszSection");
    
    HRESULT     hr = E_FAIL;
    HINSTANCE   hAdvPack;
    REGINSTALL  pfnri;
    CHAR        szDll[MAX_PATH], szDir[MAX_PATH];
    int         cch;
    // 3 to allow for pszExtra
    STRENTRY    seReg[3];
    STRTABLE    stReg;

    hAdvPack = LoadLibraryA(c_szAdvPackDll);
    if (NULL == hAdvPack)
        goto exit;

    // Get our location
    GetModuleFileName(hInstCaller, szDll, ARRAYSIZE(szDll));

    // Get Proc Address for registration util
    pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
    if (NULL == pfnri)
        goto exit;

    AddEnvInPath(szDll, szDll, ARRAYSIZE(szDll));

    // Setup special registration stuff
    // Do this instead of relying on _SYS_MOD_PATH which loses spaces under '95
    stReg.cEntries = 0;
    seReg[stReg.cEntries].pszName = "SYS_MOD_PATH";
    seReg[stReg.cEntries].pszValue = szDll;
    stReg.cEntries++;    

    StrCpyN(szDir, szDll, ARRAYSIZE(szDir));
    PathRemoveFileSpec(szDir);

    seReg[stReg.cEntries].pszName = "SYS_MOD_PATH_DIR";
    seReg[stReg.cEntries].pszValue = szDir;
    stReg.cEntries++;
    
    // Allow for caller to give us another string to use in the INF
    if (pszExtra)
    {
        seReg[stReg.cEntries].pszName = "SYS_EXTRA";
        seReg[stReg.cEntries].pszValue = pszExtra;
        stReg.cEntries++;
    }
    
    stReg.pse = seReg;

    // Call the self-reg routine
    hr = pfnri(hInstRes, pszSection, &stReg);

exit:
    // Cleanup
    SafeFreeLibrary(hAdvPack);
    return(hr);
}


//--------------------------------------------------------------------------
// MakeFilePath
//--------------------------------------------------------------------------
HRESULT MakeFilePath(LPCSTR pszDirectory, LPCSTR pszFileName, 
    LPCSTR pszExtension, LPSTR pszFilePath, ULONG cchMaxFilePath)
{
    // Locals
    HRESULT         hr=S_OK;
    DWORD           cchDirectory=lstrlen(pszDirectory);

    // Trace
    TraceCall("MakeFilePath");

    // Invalid Args
    Assert(pszDirectory && pszFileName && pszExtension && pszFilePath && cchMaxFilePath >= MAX_PATH);
    Assert(pszExtension[0] == '\0' || pszExtension[0] == '.');

    // Remove for folders
    if (cchDirectory + 1 + lstrlen(pszFileName) + lstrlen(pszExtension) >= (INT)cchMaxFilePath)
    {
    	hr = TraceResult(E_FAIL);
    	goto exit;
    }

    // Do we need a backslash
    if ('\\' != *CharPrev(pszDirectory, pszDirectory + cchDirectory))
    {
        // Append backslash
        SideAssert(wnsprintf(pszFilePath, cchMaxFilePath, "%s\\%s%s", pszDirectory, pszFileName, pszExtension) < (INT)cchMaxFilePath);
    }

    // Otherwise
    else
    {
        // Append backslash
        SideAssert(wnsprintf(pszFilePath, cchMaxFilePath, "%s%s%s", pszDirectory, pszFileName, pszExtension) < (INT)cchMaxFilePath);
    }
    
exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CloseMemoryFile
// --------------------------------------------------------------------------------
HRESULT CloseMemoryFile(LPMEMORYFILE pFile)
{
    // Trace
    TraceCall("CloseMemoryFile");

    // Args
    Assert(pFile);

    // Close the View
    if (pFile->pView)
        UnmapViewOfFile(pFile->pView);

    // Close the Memory Map
    if (pFile->hMemoryMap)
        CloseHandle(pFile->hMemoryMap);

    // Close the File
    if (pFile->hFile)
        CloseHandle(pFile->hFile);

    // Zero
    ZeroMemory(pFile, sizeof(MEMORYFILE));

    // Done
    return S_OK;
}

//--------------------------------------------------------------------------
// OpenMemoryFile
//--------------------------------------------------------------------------
HRESULT OpenMemoryFile(LPCSTR pszFile, LPMEMORYFILE pFile)
{
    // Locals
    HRESULT     hr=S_OK;

    // Tracing
    TraceCall("OpenMemoryMappedFile");

    // Invalid Arg
    Assert(pszFile && pFile);

    // Init
    ZeroMemory(pFile, sizeof(MEMORYFILE));

    // Open the File
    pFile->hFile = CreateFile(pszFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, FILE_FLAG_RANDOM_ACCESS | FILE_ATTRIBUTE_NORMAL, NULL);

    // Failure
    if (INVALID_HANDLE_VALUE == pFile->hFile)
    {
        pFile->hFile = NULL;
        if (ERROR_SHARING_VIOLATION == GetLastError())
            hr = TraceResult(MIGRATE_E_SHARINGVIOLATION);
        else
            hr = TraceResult(MIGRATE_E_CANTOPENFILE);
        goto exit;
    }

    // Get the Size
    pFile->cbSize = ::GetFileSize(pFile->hFile, NULL);
    if (0xFFFFFFFF == pFile->cbSize)
    {
        hr = TraceResult(MIGRATE_E_CANTGETFILESIZE);
        goto exit;
    }

    // Create the file mapping
    pFile->hMemoryMap = CreateFileMapping(pFile->hFile, NULL, PAGE_READWRITE, 0, pFile->cbSize, NULL);

    // Failure ?
    if (NULL == pFile->hMemoryMap)
    {
        hr = TraceResult(MIGRATE_E_CANTCREATEFILEMAPPING);
        goto exit;
    }

    // Map a view of the entire file
    pFile->pView = MapViewOfFile(pFile->hMemoryMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);

    // Failure
    if (NULL == pFile->pView)
    {
        hr = TraceResult(MIGRATE_E_CANTMAPVIEWOFFILE);
        goto exit;
    }

exit:
    // Cleanup
    if (FAILED(hr))
        CloseMemoryFile(pFile);

    // Done
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\staticrt\privunk.cpp ===
// --------------------------------------------------------------------------------
// Privunk.h
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "privunk.h"
#include <shlobj.h>
#include <shlobjp.h>

// --------------------------------------------------------------------------------
// CPrivateUnknown::CPrivateUnknown
// --------------------------------------------------------------------------------
CPrivateUnknown::CPrivateUnknown(IUnknown *pUnkOuter) 
{
    m_pUnkOuter = pUnkOuter ? pUnkOuter : &m_cUnkInner;
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::SetOuter
// --------------------------------------------------------------------------------
void CPrivateUnknown::SetOuter(IUnknown *pUnkOuter)
{
    // Must have an outer, and should not have been aggregated yet...
    Assert(pUnkOuter && m_pUnkOuter == &m_cUnkInner);

    // Save pUnkOuter
    m_pUnkOuter = pUnkOuter;
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::CUnkInner::QueryInterface
// --------------------------------------------------------------------------------
HRESULT CPrivateUnknown::CUnkInner::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    // I can handle the unknown
    if (IsEqualIID(riid, IID_IUnknown))
    {
        // Return IUnknown
        *ppvObj = SAFECAST(this, IUnknown *);

        // Increment Ref Count
        InterlockedIncrement(&m_cRef);

        // Done
        return S_OK;
    }

    // Get my parent (computes the offset of the parent's base address)
    CPrivateUnknown *pParent = IToClass(CPrivateUnknown, m_cUnkInner, this);

    // Dispatch to PrivateQueryInterface
    return pParent->PrivateQueryInterface(riid, ppvObj);
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::CUnkInner::AddRef
// --------------------------------------------------------------------------------
ULONG CPrivateUnknown::CUnkInner::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

// --------------------------------------------------------------------------------
// CPrivateUnknown::CUnkInner::Release
// --------------------------------------------------------------------------------
ULONG CPrivateUnknown::CUnkInner::Release(void)
{
    // Decrement Internal Reference Count
    LONG cRef = InterlockedDecrement(&m_cRef);

    // No dead yet...
    if (cRef > 0)
        return (ULONG)cRef;

    // Some groovy, mystical, disco stuff
    // protect against cached pointers bumping us up then down
    m_cRef = 1000; 

    // Get the parent
    CPrivateUnknown* pParent = IToClass(CPrivateUnknown, m_cUnkInner, this);

    // Kill the parent
    delete pParent;

    // Done
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\statnery\makefile.inc ===
.SUFFIXES: .htx

.htx{$(O)}.htm:
        cleaninf -w -htm $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\common.inc ===
ATHROOT=$(R)\..
!include $(ATHROOT)\athena.inc
SOURCES_USED=$(SOURCES_USED) $(ATHROOT)\athena.inc

NOT_LEAN_AND_MEAN=1

!ifndef WIN16
INCLUDES=$(INCLUDES);$(R)\common\h;$(BASEDIR)\private\windows\inc;$(ATHROOT)\inc;$(R)\wab32res
!else
INCLUDES=$(INCLUDES);$(R)\common\h;$(ATHROOT)\inc
!endif

USE_MAPSYM=1

!ifndef WIN16
C_DEFINES=$(C_DEFINES) -DWIN4
!endif
!ifndef WIN64
WIN32_IE_VERSION=0x0300
!else
WIN32_IE_VERSION=0x0500
!endif

!IF 0
The following conditional includes are from mac and/or
win16... things we don't care about and don't have files for
!ENDIF

CONDITIONAL_INCLUDES=\
    $(CONDITIONAL_INCLUDES) \
    macname1.h \
    macname2.h \
    utilmac.h  \
    mapiprof.h \
    ole2ui.h   \
    gapidos.h  \
    macos\msvcmac.h    \
    macos\menus.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\staticrt\strparse.cpp ===
// --------------------------------------------------------------------------------
// Strparse.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "strparse.h"

// --------------------------------------------------------------------------------
// FGROWNEEDED - Determines if we need to call _HrGrowDestination
// --------------------------------------------------------------------------------
#define FGROWNEEDED(_cbWrite)       (m_cchDest + _cbWrite + 1 > m_cbDestMax)

// --------------------------------------------------------------------------------
// CStringParser::CStringParser
// --------------------------------------------------------------------------------
CStringParser::CStringParser(void)
{
    m_cRef = 1;
    m_codepage = CP_ACP;
    m_pszSource = NULL;
    m_cchSource = 0;
    m_iSource = 0;
    m_pszDest = NULL;
    m_cchDest = 0;
    m_cbDestMax = 0;
    m_dwFlags = 0;
    m_pszTokens = NULL;
    m_cCommentNest = 0;
    ZeroMemory(m_rgbTokTable, sizeof(m_rgbTokTable));
    ZeroMemory(&m_rLiteral, sizeof(m_rLiteral));
}

// --------------------------------------------------------------------------------
// CStringParser::~CStringParser
// --------------------------------------------------------------------------------
CStringParser::~CStringParser(void)
{
    if (m_pszDest && m_pszDest != m_szScratch)
        g_pMalloc->Free(m_pszDest);
}

// --------------------------------------------------------------------------------
// CStringParser::AddRef
// --------------------------------------------------------------------------------
ULONG CStringParser::AddRef(void)
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CStringParser::AddRef
// --------------------------------------------------------------------------------
ULONG CStringParser::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CStringParser::Init
// --------------------------------------------------------------------------------
void CStringParser::Init(LPCSTR pszParseMe, ULONG cchParseMe, DWORD dwFlags)
{
    // Invalid Args
    Assert(NULL == m_pszSource && NULL == m_pszDest && pszParseMe && '\0' == pszParseMe[cchParseMe]);

    // Save Parse Flags
    m_dwFlags = dwFlags;

    // Safe the String
    m_pszSource = pszParseMe;
    m_cchSource = cchParseMe;

    // Setup Dest
    m_pszDest = m_szScratch;
    m_cbDestMax = sizeof(m_szScratch);
}

// --------------------------------------------------------------------------------
// CStringParser::SetTokens
// --------------------------------------------------------------------------------
void CStringParser::SetTokens(LPCSTR pszTokens)
{
    // Locals
    LPSTR psz;

    // Enable the tokens in the table
    if (m_pszTokens)
        for (psz=(LPSTR)m_pszTokens; *psz != '\0'; psz++)
            m_rgbTokTable[(UCHAR)(*psz)] = 0x00;

    // New Tokens
    if (pszTokens)
        for (psz=(LPSTR)pszTokens; *psz != '\0'; psz++)
            m_rgbTokTable[(UCHAR)(*psz)] = 0xff;

    // Save new tokens
    m_pszTokens = pszTokens;
}

// --------------------------------------------------------------------------------
// CStringParser::_HrGrowDestination
// --------------------------------------------------------------------------------
HRESULT CStringParser::_HrGrowDestination(ULONG cbWrite)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbAlloc;

    // We should need to grow, should have called FGROWNEEDED
    Assert(FGROWNEEDED(cbWrite));

    // Is this the first realloc
    if (m_pszDest == m_szScratch)
    {
        // Validate Current Size
        Assert(m_cbDestMax == sizeof(m_szScratch));

        // Compute New Size
        cbAlloc = max(m_cchSource + 1, m_cchDest + 256 + cbWrite);

        // Init pszValue
        CHECKALLOC(m_pszDest = (LPSTR)g_pMalloc->Alloc(cbAlloc));

        // Copy Current Value
        CopyMemory(m_pszDest, m_szScratch, m_cchDest);

        // Set Max Val
        m_cbDestMax = cbAlloc;
    }

    // Otherwise, need to realloc
    else
    {
        // Locals
        LPBYTE pbTemp;

        // Should already be bigger than m_cchSource + 1
        Assert(m_cbDestMax >= m_cchSource + 1);

        // Compute New Size
        cbAlloc = m_cbDestMax + 256 + cbWrite;

        // Realloc
        CHECKALLOC(pbTemp = (LPBYTE)g_pMalloc->Realloc((LPBYTE)m_pszDest, cbAlloc));

        // Save new pointer
        m_pszDest = (LPSTR)pbTemp;

        // Save new Size
        m_cbDestMax = cbAlloc;
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CStringParser::FIsParseSpace
// --------------------------------------------------------------------------------
BOOL CStringParser::FIsParseSpace(CHAR ch, BOOL *pfCommentChar)
{
    // Locals
    WORD        wType;

    // Should not be DBCS
    Assert(ISFLAGSET(m_dwFlags, PSF_DBCS) ? !IsDBCSLeadByteEx(m_codepage, ch) : TRUE);

    // Comment Char
    *pfCommentChar = FALSE;

    // NoComments
    if (ISFLAGSET(m_dwFlags, PSF_NOCOMMENTS))    
    {
        // Comment Start ?
        if ('(' == ch)
        {
            // Increment Nested Count
            m_cCommentNest++;

            // Comment Char
            *pfCommentChar = TRUE;

            // Treat it as a space
            return TRUE;
        }

        // Comment End ?
        else if (')' == ch && m_cCommentNest)
        {
            // Decrement Nested Count
            m_cCommentNest--;

            // Comment Char
            *pfCommentChar = TRUE;

            // Treat it as a space
            return TRUE;
        }

        // Inside a Comment ?
        else if (m_cCommentNest)
        {
            // Comment Char
            *pfCommentChar = TRUE;

            // Treat it as a space
            return TRUE;
        }
    }

    // Get StringType
    if (' ' == ch || '\t' == ch || '\r' == ch || '\n' == ch)
        return(TRUE);

    // Not a space
    return(FALSE);

#if 0
    if (0 == GetStringTypeExA(LOCALE_USER_DEFAULT, CT_CTYPE1, &ch, 1, &wType))
        wType = 0;

    // Return IsSpace
    return(ISFLAGSET(wType, C1_SPACE));
#endif
}

// --------------------------------------------------------------------------------
// CStringParser::ChSkip - Returns TRUE if done parsing
// --------------------------------------------------------------------------------
CHAR CStringParser::ChSkipWhite(void)
{
    // Locals
    CHAR    ch=0;
    BOOL    fCommentChar;

    // Loop
    while (1)
    {
        // Get Current Character
        ch = *(m_pszSource + m_iSource);

        // Are we done
        if ('\0' == ch)
            break;

        // Better not be done
        Assert(m_iSource < m_cchSource);

        // Look for DBCS characters
        if (ISFLAGSET(m_dwFlags, PSF_DBCS) && IsDBCSLeadByteEx(m_codepage, ch))
            break;

        // Not a space
        if (!FIsParseSpace(ch, &fCommentChar))
            break;

        // Goto Next Char
        m_iSource++;
    }

    // Done
    return ch;
}

// --------------------------------------------------------------------------------
// CStringParser::ChSkip - Returns TRUE if done parsing
// --------------------------------------------------------------------------------
CHAR CStringParser::ChSkip(void)
{
    // Locals
    CHAR ch = 0;

    // Loop
    while (1)
    {
        // Get Current Character
        ch = *(m_pszSource + m_iSource);

        // Are we done
        if ('\0' == ch)
            break;

        // Better not be done
        Assert(m_iSource < m_cchSource);

        // Look for DBCS characters
        if (ISFLAGSET(m_dwFlags, PSF_DBCS) && IsDBCSLeadByteEx(m_codepage, ch))
           break;

        // Compare for a token
        if (0x00 == m_rgbTokTable[(UCHAR)ch])
            break;

        // Goto Next Char
        m_iSource++;
    }

    // Done
    return ch;
}

// --------------------------------------------------------------------------------
// CStringParser::ChPeekNext
// --------------------------------------------------------------------------------
CHAR CStringParser::ChPeekNext(ULONG cchFromCurrent)
{
    // Locals
    CHAR    ch=0;
    BOOL    fCommentChar;

    // Past the end of the source
    if (m_iSource + cchFromCurrent >= m_cchSource)
        return '\0';

    // Return the character
    return *(m_pszSource + m_iSource + cchFromCurrent);
}

// --------------------------------------------------------------------------------
// CStringParser::_HrDoubleByteIncrement
// --------------------------------------------------------------------------------
HRESULT CStringParser::_HrDoubleByteIncrement(BOOL fEscape)
{
    // Locals
    HRESULT hr=S_OK;

    // Can I copy two more bytes to pszValue
    if (FGROWNEEDED(2))
    {
        // Otherwise, grow the buffer
        CHECKHR(hr = _HrGrowDestination(2));
    }

    // If Not an Escape Character or the last character is an escape character, then step over it
    if (FALSE == fEscape || m_iSource + 1 > m_cchSource)
        m_pszDest[m_cchDest++] = m_pszSource[m_iSource];

    // Next Character
    m_iSource++;

    // Copy Next Character
    if (m_iSource < m_cchSource)
        m_pszDest[m_cchDest++] = m_pszSource[m_iSource++];

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CStringParser::ChParse
// --------------------------------------------------------------------------------
CHAR CStringParser::ChParse(LPCSTR pszTokens, DWORD dwFlags)
{
    // Save Flags
    DWORD dwCurrFlags=m_dwFlags;

    // Reset Flags
    m_dwFlags = dwFlags;

    // Set Parsing Tokens
    SetTokens(pszTokens);

    // Parse
    CHAR chToken = ChParse();

    // Set Flags
    m_dwFlags = dwCurrFlags;

    // Return the Token
    return chToken;
}

// --------------------------------------------------------------------------------
// CStringParser::ChParse
// --------------------------------------------------------------------------------
CHAR CStringParser::ChParse(CHAR chStart, CHAR chEnd, DWORD dwFlags)
{
    // We really should have finished the last literal
    Assert(FALSE == m_rLiteral.fInside);

    // Save Flags
    DWORD dwCurrFlags = m_dwFlags;

    // Reset Flags
    m_dwFlags = dwFlags;

    // Set Parsing Tokens
    SetTokens(NULL);

    // Save Literal Info
    m_rLiteral.fInside = TRUE;
    m_rLiteral.chStart = chStart;
    m_rLiteral.chEnd = chEnd;
    m_rLiteral.cNested = 0;

    // Quoted String
    Assert('\"' == chStart ? '\"' == chEnd : TRUE);

    // Parse
    CHAR chToken = ChParse();

    // Not in a literal
    m_rLiteral.fInside = FALSE;

    // Reset Flags
    m_dwFlags = dwCurrFlags;

    // Return the Token
    return chToken;
}

// --------------------------------------------------------------------------------
// CStringParser::HrAppendValue
// --------------------------------------------------------------------------------
HRESULT CStringParser::HrAppendValue(CHAR ch)
{
    // Locals
    HRESULT hr=S_OK;

    // Just copy this character
    if (FGROWNEEDED(1))
    {
        // Otherwise, grow the buffer
        CHECKHR(hr = _HrGrowDestination(1));
    }

    // Insert the Character
    m_pszDest[m_cchDest++] = ch;

    // There is always room for a Null, look at FGROWNEEDED and _HrGrowDestination
    m_pszDest[m_cchDest] = '\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CStringParser::ChParse
// --------------------------------------------------------------------------------
CHAR CStringParser::ChParse(void)
{
    // Locals
    HRESULT     hr=S_OK;
    CHAR        ch;
    ULONG       iStart=m_iSource;
    LONG        iLastSpace=-1;
    CHAR        chToken;
    BOOL        fCommentChar;
    BOOL        fIsSpace;
    
    // Invalid Arg
    Assert(m_iSource <= m_cchSource && m_pszDest);

    // Init chToken
    chToken = '\0';

    // No Reset
    if (!ISFLAGSET(m_dwFlags, PSF_NORESET))
    {
        m_pszDest[0] = '\0';
        m_cchDest = 0;
    }

    // Skip Forward Whitespace
    if (ISFLAGSET(m_dwFlags, PSF_NOFRONTWS) && FALSE == m_rLiteral.fInside && '\0' == ChSkipWhite())
        goto TokenFound;

    // Save Starting Position
    while(1)
    {
        // Get the Next Character
        ch = *(m_pszSource + m_iSource);

        // Done
        if ('\0' == ch)
        {
            chToken = '\0';
            goto TokenFound;
        }

        // Better not be done
        Assert(m_iSource < m_cchSource);

        // If this is a DBCS lead byte
        if ((ISFLAGSET(m_dwFlags, PSF_DBCS) && IsDBCSLeadByteEx(m_codepage, ch)))
        {
            // _HrDoubleByteIncrement
            CHECKHR(hr = _HrDoubleByteIncrement(FALSE));
            iLastSpace = -1;        // reset space counter 

            // Goto Next Character
            continue;
        }

        // Check for escaped characters
        if (ISFLAGSET(m_dwFlags, PSF_ESCAPED) && '\\' == ch)
        {
            // _HrDoubleByteIncrement
            CHECKHR(hr = _HrDoubleByteIncrement(TRUE));
            iLastSpace = -1;        // reset space counter 

            // Goto Next Character
            continue;
        }

        // If not inside of a comment
        if (0 == m_cCommentNest)
        {
            if (m_rLiteral.fInside)
            {
                // End of quoted string
                if (ch == m_rLiteral.chEnd)
                {
                    // No nested ?
                    if (0 == m_rLiteral.cNested)
                    {
                        // We found a token
                        chToken = ch;

                        // Walk over this item in the string
                        m_iSource++;

                        // Ya-hoo, we found a token
                        hr = S_OK;

                        // Done
                        goto TokenFound;
                    }

                    // Otherwise, decrement nest
                    else
                        m_rLiteral.cNested--;
                }

                // Otherwise, check for nesting
                else if (m_rLiteral.chStart != m_rLiteral.chEnd && ch == m_rLiteral.chStart)
                    m_rLiteral.cNested++;
            }

            // Compare for a token - m_cCommentNest is only set if PSF_NOCOMMENTS is set
            else if (0xff == m_rgbTokTable[(UCHAR)ch])
            {
                // We found a token
                chToken = ch;

                // Walk over this item in the string
                m_iSource++;

                // Ya-hoo, we found a token
                hr = S_OK;

                // Done
                goto TokenFound;
            }
        }

        // Always Call
        fIsSpace = FIsParseSpace(ch, &fCommentChar);

        // Detect Spaces...
        if (ISFLAGSET(m_dwFlags, PSF_NOTRAILWS))
        {
            // If not a space, then kill iLastSpace
            if (!fIsSpace)
                iLastSpace = -1;

            // Otherwise, if not a consecutive space
            else if (-1 == iLastSpace)
                iLastSpace = m_cchDest;
		}

        // Copy the next character
        if (!fCommentChar)
        {
            // Make sure we have space
            if (FGROWNEEDED(1))
            {
                // Otherwise, grow the buffer
                CHECKHR(hr = _HrGrowDestination(1));
            }

            // Copy the character
            m_pszDest[m_cchDest++] = ch;
        }

        // Goto next char
        m_iSource++;
    }
    
TokenFound:
    // Determine correct end of string
    if (S_OK == hr && ISFLAGSET(m_dwFlags, PSF_NOTRAILWS) && FALSE == m_rLiteral.fInside)
        m_cchDest = (-1 == iLastSpace) ? m_cchDest : iLastSpace;

    // Otherwise, just insert a null
    Assert(m_cchDest < m_cbDestMax);

    // There is always room for a Null, look at FGROWNEEDED and _HrGrowDestination
    m_pszDest[m_cchDest] = '\0';

exit:
    // Failure Resets the parse to initial state
    if (FAILED(hr))
    {
        m_iSource = iStart;
        chToken = '\0';
    }

    // Validate Paren Nesting
    // AssertSz(m_cCommentNest == 0, "A string was parsed that has an un-balanced paren nesting.");

    // Done
    return chToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\staticrt\wstrpar.cpp ===
// --------------------------------------------------------------------------------
// wstrpar.cpp
// Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved
// --------------------------------------------------------------------------------
#include "pch.hxx"
#include "wstrpar.h"

// --------------------------------------------------------------------------------
// FGROWNEEDED - Determines if we need to call _HrGrowDestination
// --------------------------------------------------------------------------------
#define FGROWNEEDED(_cchWrite) (m_cchDest + _cchWrite + sizeof(WCHAR) > m_cchDestMax)

// --------------------------------------------------------------------------------
// CStringParserW::CStringParserW
// --------------------------------------------------------------------------------
CStringParserW::CStringParserW(void)
{
    m_cRef = 1;
    m_pszSource = NULL;
    m_cchSource = 0;
    m_iSource = 0;
    m_pszDest = NULL;
    m_cchDest = 0;
    m_cchDestMax = 0;
    m_dwFlags = 0;
    m_pszTokens = NULL;
    m_cCommentNest = 0;
    ZeroMemory(&m_rLiteral, sizeof(m_rLiteral));
}

// --------------------------------------------------------------------------------
// CStringParserW::~CStringParserW
// --------------------------------------------------------------------------------
CStringParserW::~CStringParserW(void)
{
    if (m_pszDest && m_pszDest != m_szScratch)
        g_pMalloc->Free(m_pszDest);
}

// --------------------------------------------------------------------------------
// CStringParserW::AddRef
// --------------------------------------------------------------------------------
ULONG CStringParserW::AddRef(void)
{
    return ++m_cRef;
}

// --------------------------------------------------------------------------------
// CStringParserW::AddRef
// --------------------------------------------------------------------------------
ULONG CStringParserW::Release(void)
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

// --------------------------------------------------------------------------------
// CStringParserW::Init
// --------------------------------------------------------------------------------
void CStringParserW::Init(LPCWSTR pszParseMe, ULONG cchParseMe, DWORD dwFlags)
{
    // Invalid Args
    Assert(NULL == m_pszSource && NULL == m_pszDest && pszParseMe && L'\0' == pszParseMe[cchParseMe]);

    // Save Parse Flags
    m_dwFlags = dwFlags;

    // Safe the String
    m_pszSource = pszParseMe;
    m_cchSource = cchParseMe;

    // Setup Dest
    m_pszDest = m_szScratch;
    m_cchDestMax = ARRAYSIZE(m_szScratch);
}

// --------------------------------------------------------------------------------
// CStringParserW::SetTokens
// --------------------------------------------------------------------------------
void CStringParserW::SetTokens(LPCWSTR pszTokens)
{
    // Save Tokens
    m_pszTokens = pszTokens;
}

// --------------------------------------------------------------------------------
// CStringParserW::_HrGrowDestination
// --------------------------------------------------------------------------------
HRESULT CStringParserW::_HrGrowDestination(ULONG cchWrite)
{
    // Locals
    HRESULT     hr=S_OK;
    ULONG       cbAlloc;

    // We should need to grow, should have called FGROWNEEDED
    Assert(FGROWNEEDED(cchWrite));

    // Is this the first realloc
    if (m_pszDest == m_szScratch)
    {
        // Validate Current Size
        Assert(m_cchDestMax == ARRAYSIZE(m_szScratch));

        // Compute New Size
        cbAlloc = (max(m_cchSource + 1, m_cchDest + 256 + cchWrite) * sizeof(WCHAR));

        // Init pszValue
        CHECKALLOC(m_pszDest = (LPWSTR)g_pMalloc->Alloc(cbAlloc));

        // Copy Current Value
        CopyMemory((LPBYTE)m_pszDest, (LPBYTE)m_szScratch, (m_cchDest * sizeof(WCHAR)));

        // Set Max Val
        m_cchDestMax = (cbAlloc / sizeof(WCHAR));
    }

    // Otherwise, need to realloc
    else
    {
        // Locals
        LPBYTE pbTemp;

        // Should already be bigger than m_cchSource + 1
        Assert(m_cchDestMax >= m_cchSource + 1);

        // Compute New Size
        cbAlloc = ((m_cchDestMax + 256 + cchWrite) * sizeof(WCHAR));

        // Realloc
        CHECKALLOC(pbTemp = (LPBYTE)g_pMalloc->Realloc((LPBYTE)m_pszDest, cbAlloc));

        // Save new pointer
        m_pszDest = (LPWSTR)pbTemp;

        // Save new Size
        m_cchDestMax = (cbAlloc / sizeof(WCHAR));
    }

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CStringParserW::FIsParseSpace
// --------------------------------------------------------------------------------
BOOL CStringParserW::FIsParseSpace(WCHAR ch, BOOL *pfCommentChar)
{
    // Locals
    WORD        wType;

    // Comment Char
    *pfCommentChar = FALSE;

    // NoComments
    if (ISFLAGSET(m_dwFlags, PSF_NOCOMMENTS))    
    {
        // Comment Start ?
        if (L'(' == ch)
        {
            // Increment Nested Count
            m_cCommentNest++;

            // Comment Char
            *pfCommentChar = TRUE;

            // Treat it as a space
            return TRUE;
        }

        // Comment End ?
        else if (L')' == ch && m_cCommentNest)
        {
            // Decrement Nested Count
            m_cCommentNest--;

            // Comment Char
            *pfCommentChar = TRUE;

            // Treat it as a space
            return TRUE;
        }

        // Inside a Comment ?
        else if (m_cCommentNest)
        {
            // Comment Char
            *pfCommentChar = TRUE;

            // Treat it as a space
            return TRUE;
        }
    }

    // Get StringType
    if (L' ' == ch || L'\t' == ch || L'\r' == ch || L'\n' == ch)
        return(TRUE);

    // Not a space
    return(FALSE);
}

// --------------------------------------------------------------------------------
// CStringParserW::ChSkip - Returns TRUE if done parsing
// --------------------------------------------------------------------------------
WCHAR CStringParserW::ChSkipWhite(void)
{
    // Locals
    WCHAR   ch=0;
    BOOL    fCommentChar;

    // Loop
    while (1)
    {
        // Get Current Character
        ch = *(m_pszSource + m_iSource);

        // Are we done
        if (L'\0' == ch)
            break;

        // Better not be done
        Assert(m_iSource < m_cchSource);

        // Not a space
        if (!FIsParseSpace(ch, &fCommentChar))
            break;

        // Goto Next Char
        m_iSource++;
    }

    // Done
    return ch;
}

// --------------------------------------------------------------------------------
// CStringParserW::ChSkip - Returns TRUE if done parsing
// --------------------------------------------------------------------------------
WCHAR CStringParserW::ChSkip(void)
{
    // Locals
    WCHAR  ch=L'\0';
    LPWSTR pszT;

    // Loop
    while (1)
    {
        // Get Current Character
        ch = *(m_pszSource + m_iSource);

        // Are we done
        if (L'\0' == ch)
            break;

        // Better not be done
        Assert(m_iSource < m_cchSource);

        // Tokens ?
        if (m_pszTokens)
        {
            // Compare Against Tokens..
            for (pszT=(LPWSTR)m_pszTokens; *pszT != L'\0'; pszT++)
            {
                // Token Match ?
                if (ch == *pszT)
                    break;
            }

            // If we didn't match a token, then we are done
            if (L'\0' == *pszT)
                break;
        }

        // Goto Next Char
        m_iSource++;
    }

    // Done
    return ch;
}

// --------------------------------------------------------------------------------
// CStringParserW::ChPeekNext
// --------------------------------------------------------------------------------
WCHAR CStringParserW::ChPeekNext(ULONG cchFromCurrent)
{
    // Locals
    CHAR    ch=0;
    BOOL    fCommentChar;

    // Past the end of the source
    if (m_iSource + cchFromCurrent >= m_cchSource)
        return L'\0';

    // Return the character
    return *(m_pszSource + m_iSource + cchFromCurrent);
}

// --------------------------------------------------------------------------------
// CStringParserW::ChParse
// --------------------------------------------------------------------------------
WCHAR CStringParserW::ChParse(LPCWSTR pszTokens, DWORD dwFlags)
{
    // Save Flags
    DWORD dwCurrFlags=m_dwFlags;

    // Reset Flags
    m_dwFlags = dwFlags;

    // Set Parsing Tokens
    SetTokens(pszTokens);

    // Parse
    WCHAR chToken = ChParse();

    // Set Flags
    m_dwFlags = dwCurrFlags;

    // Return the Token
    return chToken;
}

// --------------------------------------------------------------------------------
// CStringParserW::ChParse
// --------------------------------------------------------------------------------
WCHAR CStringParserW::ChParse(WCHAR chStart, WCHAR chEnd, DWORD dwFlags)
{
    // We really should have finished the last literal
    Assert(FALSE == m_rLiteral.fInside);

    // Save Flags
    DWORD dwCurrFlags = m_dwFlags;

    // Reset Flags
    m_dwFlags = dwFlags;

    // Set Parsing Tokens
    SetTokens(NULL);

    // Save Literal Info
    m_rLiteral.fInside = TRUE;
    m_rLiteral.chStart = chStart;
    m_rLiteral.chEnd = chEnd;
    m_rLiteral.cNested = 0;

    // Quoted String
    Assert(L'\"' == chStart ? L'\"' == chEnd : TRUE);

    // Parse
    WCHAR chToken = ChParse();

    // Not in a literal
    m_rLiteral.fInside = FALSE;

    // Reset Flags
    m_dwFlags = dwCurrFlags;

    // Return the Token
    return chToken;
}

// --------------------------------------------------------------------------------
// CStringParserW::HrAppendValue
// --------------------------------------------------------------------------------
HRESULT CStringParserW::HrAppendValue(WCHAR ch)
{
    // Locals
    HRESULT hr=S_OK;

    // Just copy this character
    if (FGROWNEEDED(1))
    {
        // Otherwise, grow the buffer
        CHECKHR(hr = _HrGrowDestination(1));
    }

    // Insert the Character
    m_pszDest[m_cchDest++] = ch;

    // There is always room for a Null, look at FGROWNEEDED and _HrGrowDestination
    m_pszDest[m_cchDest] = L'\0';

exit:
    // Done
    return hr;
}

// --------------------------------------------------------------------------------
// CStringParserW::ChParse
// --------------------------------------------------------------------------------
WCHAR CStringParserW::ChParse(void)
{
    // Locals
    HRESULT     hr=S_OK;
    WCHAR       ch;
    ULONG       iStart=m_iSource;
    LONG        iLastSpace=-1;
    WCHAR       chToken;
    BOOL        fCommentChar;
    BOOL        fIsSpace;
    LPWSTR      pszT;
    
    // Invalid Arg
    Assert(m_iSource <= m_cchSource && m_pszDest);

    // Init chToken
    chToken = L'\0';

    // No Reset
    if (!ISFLAGSET(m_dwFlags, PSF_NORESET))
    {
        m_pszDest[0] = L'\0';
        m_cchDest = 0;
    }

    // Skip Forward Whitespace
    if (ISFLAGSET(m_dwFlags, PSF_NOFRONTWS) && FALSE == m_rLiteral.fInside && L'\0' == ChSkipWhite())
        goto TokenFound;

    // Save Starting Position
    while(1)
    {
        // Get the Next Character
        ch = *(m_pszSource + m_iSource);

        // Done
        if (L'\0' == ch)
        {
            chToken = L'\0';
            goto TokenFound;
        }

        // Better not be done
        Assert(m_iSource < m_cchSource);

        // Check for escaped characters
        if (ISFLAGSET(m_dwFlags, PSF_ESCAPED) && L'\\' == ch)
        {
            // Can I copy two more bytes to pszValue
            if (FGROWNEEDED(2))
            {
                // Otherwise, grow the buffer
                CHECKHR(hr = _HrGrowDestination(2));
            }

            // If Not an Escape Character or the last character is an escape character, then step over it
            if (m_iSource + 1 > m_cchSource)
                m_pszDest[m_cchDest++] = m_pszSource[m_iSource];

            // Next Character
            m_iSource++;

            // Copy Next Character
            if (m_iSource < m_cchSource)
                m_pszDest[m_cchDest++] = m_pszSource[m_iSource++];

            // Reset space counter
            iLastSpace = -1;

            // Goto Next Character
            continue;
        }

        // If not inside of a comment
        if (0 == m_cCommentNest)
        {
            if (m_rLiteral.fInside)
            {
                // End of quoted string
                if (ch == m_rLiteral.chEnd)
                {
                    // No nested ?
                    if (0 == m_rLiteral.cNested)
                    {
                        // We found a token
                        chToken = ch;

                        // Walk over this item in the string
                        m_iSource++;

                        // Ya-hoo, we found a token
                        hr = S_OK;

                        // Done
                        goto TokenFound;
                    }

                    // Otherwise, decrement nest
                    else
                        m_rLiteral.cNested--;
                }

                // Otherwise, check for nesting
                else if (m_rLiteral.chStart != m_rLiteral.chEnd && ch == m_rLiteral.chStart)
                    m_rLiteral.cNested++;
            }

            // Compare for a token - m_cCommentNest is only set if PSF_NOCOMMENTS is set
            else if (m_pszTokens)
            {
                // If this is a token
                for (pszT=(LPWSTR)m_pszTokens; *pszT != L'\0'; pszT++)
                {
                    // Is this a token ?
                    if (ch == *pszT)
                        break;
                }

                // Found a token ?
                if (*pszT != L'\0')
                {
                    // We found a token
                    chToken = ch;

                    // Walk over this item in the string
                    m_iSource++;

                    // Ya-hoo, we found a token
                    hr = S_OK;

                    // Done
                    goto TokenFound;
                }
            }
        }

        // Always Call
        fIsSpace = FIsParseSpace(ch, &fCommentChar);

        // Detect Spaces...
        if (ISFLAGSET(m_dwFlags, PSF_NOTRAILWS))
        {
            // If not a space, then kill iLastSpace
            if (!fIsSpace)
                iLastSpace = -1;

            // Otherwise, if not a consecutive space
            else if (-1 == iLastSpace)
                iLastSpace = m_cchDest;
		}

        // Copy the next character
        if (!fCommentChar)
        {
            // Make sure we have space
            if (FGROWNEEDED(1))
            {
                // Otherwise, grow the buffer
                CHECKHR(hr = _HrGrowDestination(1));
            }

            // Copy the character
            m_pszDest[m_cchDest++] = ch;
        }

        // Goto next char
        m_iSource++;
    }
    
TokenFound:
    // Determine correct end of string
    if (S_OK == hr && ISFLAGSET(m_dwFlags, PSF_NOTRAILWS) && FALSE == m_rLiteral.fInside)
        m_cchDest = (-1 == iLastSpace) ? m_cchDest : iLastSpace;

    // Otherwise, just insert a null
    Assert(m_cchDest < m_cchDestMax);

    // There is always room for a Null, look at FGROWNEEDED and _HrGrowDestination
    m_pszDest[m_cchDest] = L'\0';

exit:
    // Failure Resets the parse to initial state
    if (FAILED(hr))
    {
        m_iSource = iStart;
        chToken = L'\0';
    }

    // Validate Paren Nesting
    // AssertSz(m_cCommentNest == 0, "A string was parsed that has an un-balanced paren nesting.");

    // Done
    return chToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\common\h\debug.h ===
/*
 -  debug.h
 -
 *      Microsoft Internet Phone
 *		Debug functions prototypes and macros
 *
 *		Revision History:
 *
 *		When		Who					What
 *		--------	------------------  ---------------------------------------
 *		11.16.95	Yoram Yaacovi		Created
 *
 */

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif
/*
 *	Debug message types
 */
#define AVERROR				0
#define AVTRACE				1
#define AVTRACEMEM			2

#if defined(DEBUG) || defined(TEST)

/*
 *  MACRO: DebugTrap(void)
 *
 *  PURPOSE: Executes a debug break (like 'int 3' on x86)
 *
 *  PARAMETERS:
 *    none
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *
 */

#ifdef OLD_STUFF
#define DebugTrap	DebugTrapFn()
#endif

#define DEBUGCHK(e)  if(!(e)) DebugTrap

/*
 *  MACRO: DebugPrintError(LPTSTR)
 *
 *  PURPOSE: Prints an error string to the debug output terminal
 *
 *  PARAMETERS:
 *    lpszFormat - a printf-style format
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    This macro calls the generic debug print macro, specifying
 *    that this is an error message
 *
 */

#define DebugPrintError(x)	DebugPrintfError x

/*
 *  MACRO: DebugPrintTrace(LPTSTR)
 *
 *  PURPOSE: Prints a trace string to the debug output terminal
 *
 *  PARAMETERS:
 *    lpszFormat - a printf-style format
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    This macro calls the generic debug print macro, specifying
 *    that this is an error message
 *
 */

#define DebugPrintTrace(x)	DebugPrintfTrace x

/*
 *  MACRO: DebugPrintErrorFileLine(DWORD, LPTSTR)
 *
 *  PURPOSE: Pretty print an error to the debugging output.
 *
 *  PARAMETERS:
 *    dwError - Actual error code
 *    pszPrefix  - String to prepend to the printed message.
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    It will take the error, turn it into a human
 *    readable string, prepend pszPrefix (so you
 *    can tag your errors), append __FILE__ and __LINE__
 *    and print it to the debugging output.
 *
 *    This macro is just a wrapper around OutputDebugLineErrorFileLine
 *    that is necessary to get proper values for __FILE__ and __LINE__.
 *
 */

#define DebugPrintErrorFileLine(dwError, pszPrefix) \
	DebugPrintFileLine(dwError, pszPrefix,\
		__FILE__, __LINE__)

/*
 *  MACRO: DebugPrintTraceFileLine(DWORD, LPTSTR)
 *
 *  PURPOSE: Pretty print a trace message to the debugging output.
 *
 *  PARAMETERS:
 *    dwParam- A paramter to trace
 *    pszPrefix  - String to prepend to the printed message.
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    Takes a parameter, prepend pszPrefix (so you
 *    can tag your traces), append __FILE__ and __LINE__
 *    and print it to the debugging output.
 *
 *    This macro is just a wrapper around OutputDebugLineErrorFileLine
 *    that is necessary to get proper values for __FILE__ and __LINE__.
 *
 */

#define DebugPrintTraceFileLine(dwParam, pszPrefix) \
	DebugPrintFileLine(dwParam, pszPrefix,\
		__FILE__, __LINE__)

void DebugPrintFileLine(
    DWORD dwError, LPTSTR szPrefix, 
    LPTSTR szFileName, DWORD nLineNumber);

void __cdecl DebugPrintf(ULONG ulFlags, LPTSTR lpszFormat, ...);
void __cdecl DebugPrintfError(LPTSTR lpszFormat, ...);
void __cdecl DebugPrintfTrace(LPTSTR lpszFormat, ...);

#ifdef OLD_STUFF
void DebugTrapFn(void);
#endif

LPTSTR FormatError(DWORD dwError,
    LPTSTR szOutputBuffer, DWORD dwSizeofOutputBuffer);


#else	// not DEBUG or TEST

#define DebugTrap
#define DebugPrintError(x)
#define DebugPrintTrace(x)
#define DebugPrintTraceFileLine(dwParam, pszPrefix)
#define DEBUGCHK(e)

#endif

#ifdef MEMORY_TRACKING

/*
 *  MACRO: DebugPrintTraceMem(LPTSTR)
 *
 *  PURPOSE: Prints a memory tracking trace string to the debug
 *				output terminal
 *
 *  PARAMETERS:
 *    lpszFormat - a printf-style format
 *
 *  RETURN VALUE:
 *    none
 *
 *  COMMENTS:
 *    This macro calls the generic debug print macro, specifying
 *    that this is an error message
 *
 */

#define DebugPrintTraceMem(x)	DebugPrintf(AVTRACEMEM, x)

#else	// no MEMORY_TRACKING

#define DebugPrintTraceMem(x)

#endif

#ifdef __cplusplus
}
#endif

#endif	//#ifndef _DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\common\h\version.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 ****************************************************************************/

// Include Version headers
#include <winver.h>

/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#define VERSION                     "4.0.200.0"
#define VER_FILEVERSION_STR         "4.0.200.0\0"
#define VER_FILEVERSION             4,0,200,0
#define VER_PRODUCTVERSION_STR      "4.0.200.0\0"
#define VER_PRODUCTVERSION          4,0,200,0

// #define OFFICIAL
// #define FINAL

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK

/** OS type **/
#define VER_FILEOS                  VOS_DOS_WINDOWS32

/** Type of build flags **/
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

/** Company Name **/
#define VER_COMPANYNAME_STR			"Microsoft Corporation\0"

/** Product Name **/
#define VER_PRODUCTNAME_STR      "Address Book\0"

/** Copyrights and Trademarks **/
#define VER_LEGALCOPYRIGHT_STR  "Copyright Microsoft Corp. 1995,1996\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\common\h\wabguid.h ===
/*
 *	M A P I G U I D . H
 *
 *	Master definitions of all GUID's for MAPI.
 *
 *	When included without INITGUID defined, this header file
 *	defines symbols that reference IIDs elsewhere.
 *
 *	When included with INITGUID defined and a "USES_IID_I..."
 *	statement for each IID used by the subsystem, it generates the
 *	bytes for those actual IIDs into the associated object file.
 *
 *	This range of 256 GUIDs reserved by OLE for MAPI use October 5, 1992.
 *
 *  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
 */

/*
 *	List of GUIDS allocated by MAPI
 *	
 *	0x00020300	IID_IMAPISession
 *	0x00020301	IID_IMAPITable
 *	0x00020302	IID_IMAPIAdviseSink
 *	0x00020303	IID_IMAPIProp
 *	0x00020304	IID_IProfSect
 *	0x00020305	IID_IMAPIStatus
 *	0x00020306	IID_IMsgStore
 *	0x00020307	IID_IMessage
 *	0x00020308	IID_IAttachment
 *	0x00020309	IID_IAddrBook
 *	0x0002030A	IID_IMailUser
 *	0x0002030B	IID_IMAPIContainer
 *	0x0002030C	IID_IMAPIFolder
 *	0x0002030D	IID_IABContainer
 *	0x0002030E	IID_IDistList
 *	0x0002030F	IID_IMAPISup
 *	0x00020310	IID_IMSProvider
 *	0x00020311	IID_IABProvider
 *	0x00020312	IID_IXPProvider
 *	0x00020313	IID_IMSLogon
 *	0x00020314	IID_IABLogon
 *	0x00020315	IID_IXPLogon
 *	0x00020316	IID_IMAPITableData
 *	0x00020317	IID_IMAPISpoolerInit
 *	0x00020318	IID_IMAPISpoolerSession
 *	0x00020319	IID_ITNEF
 *	0x0002031A	IID_IMAPIPropData
 *	0x0002031B	IID_IMAPIControl
 *	0x0002031C	IID_IProfAdmin
 *	0x0002031D	IID_IMsgServiceAdmin
 *	0x0002031E	IID_IMAPISpoolerService
 *	0x0002031F	IID_IMAPIProgress
 *	0x00020320	IID_ISpoolerHook
 *	0x00020321	IID_IMAPIViewContext
 *	0x00020322	IID_IMAPIFormMgr
 *	0x00020323	IID_IEnumMAPIFormProp
 *	0x00020324	IID_IMAPIFormInfo
 *	0x00020325	IID_IProviderAdmin
 *	0x00020327	IID_IMAPIForm
 *	0x00020328	PS_MAPI
 *	0x00020329	PS_PUBLIC_STRINGS
 *	0x0002032A	IID_IPersistMessage
 *	0x0002032B	IID_IMAPIViewAdviseSink
 *	0x0002032C	IID_IStreamDocfile
 *	0x0002032D	IID_IMAPIFormProp
 *	0x0002032E	IID_IMAPIFormContainer
 *	0x0002032F	IID_IMAPIFormAdviseSink
 *	0x00020330	IID_IStreamTnef
 *	0x00020350	IID_IMAPIFormFactory
 *	0x00020370	IID_IMAPIMessageSite
 *	0x00020380	PS_ROUTING_EMAIL_ADDRESSES
 *	0x00020381	PS_ROUTING_ADDRTYPE
 *	0x00020382	PS_ROUTING_DISPLAY_NAME
 *	0x00020383	PS_ROUTING_ENTRYID
 *	0x00020384	PS_ROUTING_SEARCH_KEY
 *	0x00020385	MUID_PROFILE_INSTANCE
 *	
 *	The remaining GUIDs from 0x00020300 to 0x000203FF are reserved by
 *	MAPI for future use.  The current maximum used by MAPI is 0x00020385
 *
 */

#ifndef MAPIGUID_H
#ifdef  INITGUID
#define MAPIGUID_H
#endif

/* Derive from IUnknown */
#if !defined(INITGUID) || defined(USES_IID_IMAPISession)
DEFINE_OLEGUID(IID_IMAPISession,	0x00020300, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPITable)
DEFINE_OLEGUID(IID_IMAPITable,		0x00020301, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIAdviseSink)
DEFINE_OLEGUID(IID_IMAPIAdviseSink,	0x00020302, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIControl)
DEFINE_OLEGUID(IID_IMAPIControl,	0x0002031B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfAdmin)
DEFINE_OLEGUID(IID_IProfAdmin,		0x0002031C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgServiceAdmin)
DEFINE_OLEGUID(IID_IMsgServiceAdmin,0x0002031D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProviderAdmin)
DEFINE_OLEGUID(IID_IProviderAdmin,	0x00020325, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIProgress)
DEFINE_OLEGUID(IID_IMAPIProgress,	0x0002031F, 0, 0);
#endif

/* MAPIProp or derive from MAPIProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIProp)
DEFINE_OLEGUID(IID_IMAPIProp,		0x00020303, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfSect)
DEFINE_OLEGUID(IID_IProfSect,		0x00020304, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIStatus)
DEFINE_OLEGUID(IID_IMAPIStatus,			0x00020305, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgStore)
DEFINE_OLEGUID(IID_IMsgStore,		0x00020306, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMessage)
DEFINE_OLEGUID(IID_IMessage,		0x00020307, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAttachment)
DEFINE_OLEGUID(IID_IAttachment,		0x00020308, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAddrBook)
DEFINE_OLEGUID(IID_IAddrBook,		0x00020309, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMailUser)
DEFINE_OLEGUID(IID_IMailUser,		0x0002030A, 0, 0);
#endif

/* MAPIContainer or derive from MAPIContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIContainer)
DEFINE_OLEGUID(IID_IMAPIContainer,	0x0002030B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFolder)
DEFINE_OLEGUID(IID_IMAPIFolder,		0x0002030C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABContainer)
DEFINE_OLEGUID(IID_IABContainer,	0x0002030D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IDistList)
DEFINE_OLEGUID(IID_IDistList,		0x0002030E, 0, 0);
#endif

/* MAPI Support Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISup)
DEFINE_OLEGUID(IID_IMAPISup,		0x0002030F, 0, 0);
#endif

/* Provider INIT objects */
#if !defined(INITGUID) || defined(USES_IID_IMSProvider)
DEFINE_OLEGUID(IID_IMSProvider,		0x00020310, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABProvider)
DEFINE_OLEGUID(IID_IABProvider,		0x00020311, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPProvider)
DEFINE_OLEGUID(IID_IXPProvider,		0x00020312, 0, 0);
#endif

/* Provider LOGON Objects */
#if !defined(INITGUID) || defined(USES_IID_IMSLogon)
DEFINE_OLEGUID(IID_IMSLogon,		0x00020313, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABLogon)
DEFINE_OLEGUID(IID_IABLogon,		0x00020314, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPLogon)
DEFINE_OLEGUID(IID_IXPLogon,		0x00020315, 0, 0);
#endif

/* IMAPITable-in-memory Table Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPITableData)
DEFINE_OLEGUID(IID_IMAPITableData,	0x00020316, 0, 0);
#endif

/* MAPI Spooler Init Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerInit)
DEFINE_OLEGUID(IID_IMAPISpoolerInit,	0x00020317, 0, 0);
#endif

/* MAPI Spooler Session Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerSession)
DEFINE_OLEGUID(IID_IMAPISpoolerSession,	0x00020318, 0, 0);
#endif

/* MAPI TNEF Object Interface */
#if !defined(INITGUID) || defined(USES_IID_ITNEF)
DEFINE_OLEGUID(IID_ITNEF,			0x00020319, 0, 0);
#endif

/* IMAPIProp-in-memory Property Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPIPropData)
DEFINE_OLEGUID(IID_IMAPIPropData,	0x0002031A, 0, 0);
#endif

/* MAPI Spooler Hook Object */
#if !defined(INITGUID) || defined(USES_IID_ISpoolerHook)
DEFINE_OLEGUID(IID_ISpoolerHook,	0x00020320, 0, 0);
#endif

/* MAPI Spooler Service Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerService)
DEFINE_OLEGUID(IID_IMAPISpoolerService,	0x0002031E, 0, 0);
#endif

/* MAPI forms, form manager, etc. */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewContext)
DEFINE_OLEGUID(IID_IMAPIViewContext,	0x00020321, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormMgr)
DEFINE_OLEGUID(IID_IMAPIFormMgr,	0x00020322, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IEnumMAPIFormProp)
DEFINE_OLEGUID(IID_IEnumMAPIFormProp,	0x00020323, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormInfo)
DEFINE_OLEGUID(IID_IMAPIFormInfo,	0x00020324, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIForm)
DEFINE_OLEGUID(IID_IMAPIForm,	0x00020327, 0, 0);
#endif


/* Well known guids for name<->id mappings */

/*  The name of MAPI's property set  */
#if !defined(INITGUID) || defined(USES_PS_MAPI)
DEFINE_OLEGUID(PS_MAPI,	0x00020328, 0, 0);
#endif

/*  The name of the set of public strings  */
#if !defined(INITGUID) || defined(USES_PS_PUBLIC_STRINGS)
DEFINE_OLEGUID(PS_PUBLIC_STRINGS,	0x00020329, 0, 0);
#endif




/* MAPI forms, form manager, (cont) */
#if !defined(INITGUID) || defined(USES_IID_IPersistMessage)
DEFINE_OLEGUID(IID_IPersistMessage,	0x0002032A, 0, 0);
#endif

/* IMAPIViewAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewAdviseSink)
DEFINE_OLEGUID(IID_IMAPIViewAdviseSink,	0x0002032B, 0, 0);
#endif

/* Message Store OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamDocfile)
DEFINE_OLEGUID(IID_IStreamDocfile, 0x0002032C, 0, 0);
#endif

/* IMAPIFormProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormProp)
DEFINE_OLEGUID(IID_IMAPIFormProp,	0x0002032D, 0, 0);
#endif

/* IMAPIFormContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormContainer)
DEFINE_OLEGUID(IID_IMAPIFormContainer, 0x0002032E, 0, 0);
#endif

/* IMAPIFormAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormAdviseSink)
DEFINE_OLEGUID(IID_IMAPIFormAdviseSink, 0x0002032F, 0, 0);
#endif

/* TNEF OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamTnef)
DEFINE_OLEGUID(IID_IStreamTnef, 0x00020330, 0, 0);
#endif

/* IMAPIFormFactory */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormFactory)
DEFINE_OLEGUID(IID_IMAPIFormFactory, 0x00020350, 0, 0);
#endif

/* IMAPIMessageSite */
#if !defined(INITGUID) || defined(USES_IID_IMAPIMessageSite)
DEFINE_OLEGUID(IID_IMAPIMessageSite, 0x00020370, 0, 0);
#endif



/* Well known guids routing property sets.
   Usefull when writing applications that route documents
   (i.e. Workflow) across gateways.  Gateways that speak MAPI
   should convert the properties found in the follow property
   sets appropriately. */

/*  PS_ROUTING_EMAIL_ADDRESSES:  Addresses that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_EMAIL_ADDRESSES)
DEFINE_OLEGUID(PS_ROUTING_EMAIL_ADDRESSES,	0x00020380, 0, 0);
#endif

/*  PS_ROUTING_ADDRTYPE:  Address types that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_ADDRTYPE)
DEFINE_OLEGUID(PS_ROUTING_ADDRTYPE,	0x00020381, 0, 0);
#endif

/*  PS_ROUTING_DISPLAY_NAME:  Display Name that corresponds to the other props */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_DISPLAY_NAME)
DEFINE_OLEGUID(PS_ROUTING_DISPLAY_NAME,	0x00020382, 0, 0);
#endif

/*  PS_ROUTING_ENTRYID:  (optional) EntryIDs that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_ENTRYID)
DEFINE_OLEGUID(PS_ROUTING_ENTRYID,	0x00020383, 0, 0);
#endif

/*  PS_ROUTING_SEARCH_KEY:  (optional) search keys that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_SEARCH_KEY)
DEFINE_OLEGUID(PS_ROUTING_SEARCH_KEY,	0x00020384, 0, 0);
#endif

/*	MUID_PROFILE_INSTANCE
	Well known section in a profile which contains a property (PR_SEARCH_KEY) which is unique
	for any given profile.  Applications and providers can depend on this value as being
	different for each unique profile. */
#if !defined(INITGUID) || defined(USES_MUID_PROFILE_INSTANCE)
DEFINE_OLEGUID(MUID_PROFILE_INSTANCE, 0x00020385, 0, 0);
#endif

#if !defined(INITGUID) || defined(IID_IWABExtInit)
DEFINE_GUID(IID_IWABExtInit, 0xea22ebf0, 0x87a4, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);
#endif


#endif	/* MAPIGUID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\common\h\wabdbg.h ===
/*
 *  WABDBG.H
 *
 *  Debugging support for WAB service providers.
 *  Support functions are implemented in WABDBG.C.
 *
 *  History:
 *      03/04/96    brucek  Copied from MAPI's mapidbg.h
 *
 *  Copyright 1993-1995 Microsoft Corporation. All Rights Reserved.
 */

#ifndef __WABDBG_H_
#define __WABDBG_H_

/*
 * Debugging Macros -------------------------------------------------------
 *
 *      IFDBG(x)        Results in the expression x if DEBUG is defined, or
 *                      to nothing if DEBUG is not defined
 *
 *      IFNDBG(x)       Results in the expression x if DEBUG is not defined,
 *                      or to nothing if DEBUG is defined
 *
 *      Unreferenced(a) Causes a to be referenced so that the compiler
 *                      doesn't issue warnings about unused local variables
 *                      which exist but are reserved for future use (eg
 *                      ulFlags in many cases)
 */

#if defined(DEBUG)
#define IFDBG(x)            x
#define IFNDBG(x)
#define LEAK_TEST           TRUE    // allow memory leak dumps in debug build
#else
#define IFDBG(x)
#define IFNDBG(x)           x
// #define LEAK_TEST           TRUE    // define to allow memory leak dumps in retail build
#endif

#ifdef __cplusplus
#define EXTERN_C_BEGIN      extern "C" {
#define EXTERN_C_END        }
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif

#define dimensionof(a)      (sizeof(a)/sizeof(*(a)))

#define Unreferenced(a)     ((void)(a))

typedef long SCODE;
typedef unsigned long ULONG;
typedef unsigned long DWORD;

/*
 *   Assert Macros ---------------------------------------------------------
 *
 *      Assert(a)       Displays a message indicating the file and line number
 *                      of this Assert() if a == 0.  OK'ing an assert traps
 *                      into the debugger.
 *
 *      AssertSz(a,sz)  Works like an Assert(), but displays the string sz
 *                      along with the file and line number.
 *
 *      Side asserts    A side assert works like an Assert(), but evaluates
 *                      'a' even when asserts are not enabled.
 *
 *      NF asserts      A NF (Non-Fatal) assert works like an Assert(), but
 *                      continues instead of trapping into the debugger when
 *                      OK'ed.
 */

#if defined(DEBUG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)           x
#else
#define IFTRAP(x)           0
#endif

#define Trap()                                          IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,TEXT("Trap")))
#define TrapSz(psz)                                     IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz))
#define TrapSz1(psz,a1)                                 IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1))
#define TrapSz2(psz,a1,a2)                              IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2))
#define TrapSz3(psz,a1,a2,a3)                           IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3))
#define TrapSz4(psz,a1,a2,a3,a4)                        IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4))
#define TrapSz5(psz,a1,a2,a3,a4,a5)                     IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5))
#define TrapSz6(psz,a1,a2,a3,a4,a5,a6)                  IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6))
#define TrapSz7(psz,a1,a2,a3,a4,a5,a6,a7)               IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7))
#define TrapSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)            IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TrapSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)         IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

#define Assert(t)                                       IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,TEXT("Assertion Failure: ") TEXT(#t)),0))
#define AssertSz(t,psz)                                 IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz),0))
#define AssertSz1(t,psz,a1)                             IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1),0))
#define AssertSz2(t,psz,a1,a2)                          IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2),0))
#define AssertSz3(t,psz,a1,a2,a3)                       IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3),0))
#define AssertSz4(t,psz,a1,a2,a3,a4)                    IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4),0))
#define AssertSz5(t,psz,a1,a2,a3,a4,a5)                 IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5),0))
#define AssertSz6(t,psz,a1,a2,a3,a4,a5,a6)              IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define AssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)           IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define AssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)        IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define AssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)     IFTRAP(((t) ? 0 : DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define SideAssert(t)                                   ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,TEXT("Assertion Failure: ") TEXT(#t))),0)
#define SideAssertSz(t,psz)                             ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz)),0)
#define SideAssertSz1(t,psz,a1)                         ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1)),0)
#define SideAssertSz2(t,psz,a1,a2)                      ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2)),0)
#define SideAssertSz3(t,psz,a1,a2,a3)                   ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3)),0)
#define SideAssertSz4(t,psz,a1,a2,a3,a4)                ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4)),0)
#define SideAssertSz5(t,psz,a1,a2,a3,a4,a5)             ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define SideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)          ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define SideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)       ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define SideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)    ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define SideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9) ((t) ? 0 : IFTRAP(DebugTrapFn(1,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

#define NFAssert(t)                                     IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,TEXT("Assertion Failure: ") TEXT(#t)),0))
#define NFAssertSz(t,psz)                               IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz),0))
#define NFAssertSz1(t,psz,a1)                           IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1),0))
#define NFAssertSz2(t,psz,a1,a2)                        IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2),0))
#define NFAssertSz3(t,psz,a1,a2,a3)                     IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3),0))
#define NFAssertSz4(t,psz,a1,a2,a3,a4)                  IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4),0))
#define NFAssertSz5(t,psz,a1,a2,a3,a4,a5)               IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5),0))
#define NFAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)            IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define NFAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)         IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define NFAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)      IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define NFAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)   IFTRAP(((t) ? 0 : DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define NFSideAssert(t)                                 ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,("Assertion Failure: ") TEXT(#t))),0)
#define NFSideAssertSz(t,psz)                           ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz)),0)
#define NFSideAssertSz1(t,psz,a1)                       ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1)),0)
#define NFSideAssertSz2(t,psz,a1,a2)                    ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2)),0)
#define NFSideAssertSz3(t,psz,a1,a2,a3)                 ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3)),0)
#define NFSideAssertSz4(t,psz,a1,a2,a3,a4)              ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4)),0)
#define NFSideAssertSz5(t,psz,a1,a2,a3,a4,a5)           ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define NFSideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)        ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define NFSideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)     ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define NFSideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)  ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define NFSideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)   ((t) ? 0 : IFTRAP(DebugTrapFn(0,TEXT(__FILE__),__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

/*
 *   Trace Macros ------------------------------------------------------------
 *
 *      DebugTrace          Use for arbitrary formatted output. It
 *                          takes exactly the same arguments as the
 *                          Windows wsprintf() function.
 *      DebugTraceResult    Shorthand for error tracing with an
 *                          HRESULT. Arguments are the name of the
 *                          function (not quoted) and the HRESULT.
 *      DebugTraceSc        Shorthand for error tracing with an
 *                          SCODE. Arguments are the name of the
 *                          function (not quoted) and the SCODE.
 *      DebugTraceArg       Shorthand for invalid parameter
 *                          tracing. Arguments are the name of the
 *                          function (not quoted) and a quoted
 *                          string describing the bad parameter.
 */

#if defined(DEBUG) || defined(TRACES_ENABLED)
#define IFTRACE(x)          x
#define DebugTrace          DebugTraceFn
#else
#define IFTRACE(x)          0
#define DebugTrace          1?0:DebugTraceFn
#endif

#define DebugTraceResult(f,hr)                          IFTRACE(((hr) ? DebugTraceFn(TEXT(#f) TEXT(" returns 0x%08lX %s\n"), GetScode(hr), SzDecodeScode(GetScode(hr))) : 0))
#define DebugTraceSc(f,sc)                              IFTRACE(((sc) ? DebugTraceFn(TEXT(#f) TEXT(" returns 0x%08lX %s\n"), sc, SzDecodeScode(sc)) : 0))
#define DebugTraceArg(f,s)                              IFTRACE(DebugTraceFn(TEXT(#f) TEXT(": bad parameter: ") s TEXT("\n")))
#define DebugTraceLine()                                IFTRACE(DebugTraceFn(TEXT("File %s, Line %i  \n"),TEXT(__FILE__),__LINE__))
#define DebugTraceProblems(sz, rgprob)                  IFTRACE(DebugTraceProblemsFn(sz, rgprob))

#define TraceSz(psz)                                    IFTRACE(DebugTraceFn(TEXT("~") psz))
#define TraceSz1(psz,a1)                                IFTRACE(DebugTraceFn(TEXT("~") psz,a1))
#define TraceSz2(psz,a1,a2)                             IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2))
#define TraceSz3(psz,a1,a2,a3)                          IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3))
#define TraceSz4(psz,a1,a2,a3,a4)                       IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3,a4))
#define TraceSz5(psz,a1,a2,a3,a4,a5)                    IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3,a4,a5))
#define TraceSz6(psz,a1,a2,a3,a4,a5,a6)                 IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3,a4,a5,a6))
#define TraceSz7(psz,a1,a2,a3,a4,a5,a6,a7)              IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3,a4,a5,a6,a7))
#define TraceSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)           IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TraceSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)        IFTRACE(DebugTraceFn(TEXT("~") psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

/* Debugging Functions ---------------------------------------------------- */

EXTERN_C_BEGIN

#ifdef WIN16
#define EXPORTDBG   __export
#else
#define EXPORTDBG
#endif

int EXPORTDBG __cdecl       DebugTrapFn(int fFatal, TCHAR *pszFile, int iLine, TCHAR *pszFormat, ...);
int EXPORTDBG __cdecl       DebugTraceFn(TCHAR *pszFormat, ...);
void EXPORTDBG __cdecl      DebugTraceProblemsFn(TCHAR *sz, void *rgprob);
TCHAR * EXPORTDBG __cdecl    SzDecodeScodeFn(SCODE sc);
TCHAR * EXPORTDBG __cdecl    SzDecodeUlPropTypeFn(unsigned long ulPropType);
TCHAR * EXPORTDBG __cdecl    SzDecodeUlPropTagFn(unsigned long ulPropTag);
unsigned long EXPORTDBG __cdecl UlPropTagFromSzFn(TCHAR *psz);
SCODE EXPORTDBG __cdecl     ScodeFromSzFn(TCHAR *psz);
void * EXPORTDBG __cdecl    DBGMEM_EncapsulateFn(void * pmalloc, TCHAR *pszSubsys, int fCheckOften);
void EXPORTDBG __cdecl      DBGMEM_ShutdownFn(void * pmalloc);
void EXPORTDBG __cdecl      DBGMEM_CheckMemFn(void * pmalloc, int fReportOrphans);
#if defined(WIN32) && defined(_X86_) && defined(LEAK_TEST)
void EXPORTDBG __cdecl      DBGMEM_LeakHook(FARPROC pfn);
void EXPORTDBG __cdecl      GetCallStack(DWORD *, int, int);
#endif
void EXPORTDBG __cdecl      DBGMEM_NoLeakDetectFn(void * pmalloc, void *pv);
void EXPORTDBG __cdecl      DBGMEM_SetFailureAtFn(void * pmalloc, ULONG ulFailureAt);
SCODE EXPORTDBG __cdecl     ScCheckScFn(SCODE, SCODE *, TCHAR *, TCHAR *, int);
void * EXPORTDBG __cdecl    VMAlloc(ULONG);
void * EXPORTDBG __cdecl    VMAllocEx(ULONG, ULONG);
void * EXPORTDBG __cdecl    VMRealloc(void *, ULONG);
void * EXPORTDBG __cdecl    VMReallocEx(void *, ULONG, ULONG);
ULONG EXPORTDBG __cdecl     VMGetSize(void *);
ULONG EXPORTDBG __cdecl     VMGetSizeEx(void *, ULONG);
void EXPORTDBG __cdecl      VMFree(void *);
void EXPORTDBG __cdecl      VMFreeEx(void *, ULONG);

EXTERN_C_END

/*
 *  Debugging Macros -------------------------------------------------------
 *
 *      SzDecodeScode           Returns the string name of an SCODE
 *      SzDecodeUlPropTag       Returns the string name of a property
 *                              tag
 *      UlPropTagFromSz         Given a property tag's name, returns
 *                              its value
 *      ScodeFromSz             Given an SCODE's name, returns its
 *                              value
 *
 *      DBGMEM_Encapsulate      Given an IMalloc interface, adds heap-
 *                              checking functionality and returns a
 *                              wrapped interface
 *      DBGMEM_Shutdown         Undoes DBGMEM_Encapsulate, and prints
 *                              out information on any allocations made
 *                              since the interface was encapsulated
 *                              that have not yet been released.
 *      DBGMEM_CheckMem         Checks all memory allocated on the heap,
 *                              and optionally reports leaked blocks.
 *      DBGMEM_NoLeakDetect     Prevents a block from appearing on the leak
 *                              report.  Pass NULL for pv to inhibit leak
 *                              reports at all from this heap.
 */

#ifdef DEBUG

#define SzDecodeScode(_sc)              SzDecodeScodeFn(_sc)
#define SzDecodeUlPropType(_ulPropType) SzDecodeUlPropTypeFn(_ulPropType)
#define SzDecodeUlPropTag(_ulPropTag)   SzDecodeUlPropTagFn(_ulPropTag)
#define UlPropTagFromSz(_sz)            UlPropTagFromSzFn(_sz)
#define ScodeFromSz(_sz)                ScodeFromSzFn(_sz)
#define DBGMEM_Encapsulate(pm, psz, f)  DBGMEM_EncapsulateFn(pm, psz, f)
#define DBGMEM_Shutdown(pm)             DBGMEM_ShutdownFn(pm)
#define DBGMEM_CheckMem(pm, f)          DBGMEM_CheckMemFn(pm, f)
#define DBGMEM_NoLeakDetect(pm, pv)     DBGMEM_NoLeakDetectFn(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)     DBGMEM_SetFailureAtFn(pm, ul)

#else

#define SzDecodeScode(_sc)              (0)
#define SzDecodeUlPropType(_ulPropType) (0)
#define SzDecodeUlPropTag(_ulPropTag)   (0)
#define UlPropTagFromSz(_sz)            (0)
#define ScodeFromSz(_sz)                (0)

#if defined(__cplusplus) && !defined(CINTERFACE)
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
    ((pmalloc)->AddRef(), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
    ((pmalloc)->Release())
#else
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
    ((pmalloc)->lpVtbl->AddRef(pmalloc), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
    ((pmalloc)->lpVtbl->Release(pmalloc))
#endif
#define DBGMEM_CheckMem(pm, f)
#define DBGMEM_NoLeakDetect(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)

#endif

/*
 *  SCODE maps -------------------------------------------------------------
 *
 *      ScCheckSc       Given an SCODE and method name, verifies
 *                      that the SCODE can legally be returned from
 *                      thet method. Prints out a debug string if
 *                      it cannot.
 *      HrCheckHr       As ScCheckSc, for functions that return
 *                      HRESULT.
 */

#if defined(DEBUG) && !defined(DOS)
#define ScCheckSc(sc,fn)                ScCheckScFn(sc,fn##_Scodes,#fn,TEXT(__FILE__), __LINE__)
#define HrCheckHr(hr,fn)                HrCheckSc(GetScode(hr),fn)
#else
#define ScCheckSc(sc,fn)                (sc)
#define HrCheckHr(hr,fn)                (hr)
#endif

#define HrCheckSc(sc,fn)                ResultFromScode(ScCheckSc(sc,fn))

#if defined(DEBUG) && !defined(DOS)
extern SCODE Common_Scodes[];
extern SCODE WABAllocateBuffer_Scodes[];
extern SCODE WABAllocateMore_Scodes[];
extern SCODE WABFreeBuffer_Scodes[];

extern SCODE IUnknown_QueryInterface_Scodes[];
extern SCODE IUnknown_AddRef_Scodes[];
extern SCODE IUnknown_Release_Scodes[];
extern SCODE IUnknown_GetLastError_Scodes[];

extern SCODE IWABProp_CopyTo_Scodes[];
extern SCODE IWABProp_CopyProps_Scodes[];
extern SCODE IWABProp_DeleteProps_Scodes[];
extern SCODE IWABProp_GetIDsFromNames_Scodes[];
extern SCODE IWABProp_GetLastError_Scodes[];
extern SCODE IWABProp_GetNamesFromIDs_Scodes[];
extern SCODE IWABProp_GetPropList_Scodes[];
extern SCODE IWABProp_GetProps_Scodes[];
extern SCODE IWABProp_OpenProperty_Scodes[];
extern SCODE IWABProp_SetProps_Scodes[];
extern SCODE IWABProp_SaveChanges_Scodes[];

extern SCODE IStream_Read_Scodes[];
extern SCODE IStream_Write_Scodes[];
extern SCODE IStream_Seek_Scodes[];
extern SCODE IStream_SetSize_Scodes[];
extern SCODE IStream_Tell_Scodes[];
extern SCODE IStream_LockRegion_Scodes[];
extern SCODE IStream_UnlockRegion_Scodes[];
extern SCODE IStream_Clone_Scodes[];
extern SCODE IStream_CopyTo_Scodes[];
extern SCODE IStream_Revert_Scodes[];
extern SCODE IStream_Stat_Scodes[];
extern SCODE IStream_Commit_Scodes[];

extern SCODE IWABTable_GetLastError_Scodes[];
extern SCODE IWABTable_Advise_Scodes[];
extern SCODE IWABTable_Unadvise_Scodes[];
extern SCODE IWABTable_GetStatus_Scodes[];
extern SCODE IWABTable_SetColumns_Scodes[];
extern SCODE IWABTable_QueryColumns_Scodes[];
extern SCODE IWABTable_GetRowCount_Scodes[];
extern SCODE IWABTable_SeekRow_Scodes[];
extern SCODE IWABTable_SeekRowApprox_Scodes[];
extern SCODE IWABTable_QueryPosition_Scodes[];
extern SCODE IWABTable_FindRow_Scodes[];
extern SCODE IWABTable_Restrict_Scodes[];
extern SCODE IWABTable_CreateBookmark_Scodes[];
extern SCODE IWABTable_FreeBookmark_Scodes[];
extern SCODE IWABTable_SortTable_Scodes[];
extern SCODE IWABTable_QuerySortOrder_Scodes[];
extern SCODE IWABTable_QueryRows_Scodes[];
extern SCODE IWABTable_Abort_Scodes[];
extern SCODE IWABTable_ExpandRow_Scodes[];
extern SCODE IWABTable_CollapseRow_Scodes[];
extern SCODE IWABTable_WaitForCompletion_Scodes[];
extern SCODE IWABTable_GetCollapseState_Scodes[];
extern SCODE IWABTable_SetCollapseState_Scodes[];

extern SCODE IAddrBook_OpenEntry_Scodes[];
extern SCODE IAddrBook_CompareEntryIDs_Scodes[];
extern SCODE IAddrBook_CreateOneOff_Scodes[];
extern SCODE IAddrBook_ResolveName_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_Details_Scodes[];
extern SCODE IAddrBook_RecipOptions_Scodes[];
extern SCODE IAddrBook_QueryDefaultRecipOpt_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_ButtonPress_Scodes[];

extern SCODE IABContainer_GetContentsTable_Scodes[];
extern SCODE IABContainer_GetHierarchyTable_Scodes[];

extern SCODE INotifObj_ChangeEvMask_Scodes[];

#endif

/* ------------------------------------------------------------------------ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\common\h\wabmig.h ===
/*
 *  WABMIG.H
 *
 *  WAB Migration Interface
 *
 *  Note: Must follow inclusion of wab.h.
 *
 *  Copyright 1996,  Microsoft Corporation. All Rights Reserved.
 */

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

typedef struct _WAB_PROGRESS {
    DWORD numerator;       // Numerator for % done progress bar
    DWORD denominator;     // Denominator for % done progress bar
    LPTSTR lpText;         // Text to display in status area
} WAB_PROGRESS, FAR *LPWAB_PROGRESS;


typedef enum {
    WAB_REPLACE_ALWAYS,	
    WAB_REPLACE_NEVER,
    WAB_REPLACE_PROMPT
} WAB_REPLACE_OPTION, *LPWAB_REPLACE_OPTION;

typedef  struct _WAB_IMPORT_OPTIONS {
    WAB_REPLACE_OPTION ReplaceOption;   // On collision, Should import overwrite? Yes, no,  or prompt user.
    BOOL fNoErrors;                     // Don't display error pop-ups
} WAB_IMPORT_OPTIONS, *LPWAB_IMPORT_OPTIONS;


typedef WAB_IMPORT_OPTIONS WAB_EXPORT_OPTIONS;
typedef WAB_EXPORT_OPTIONS * LPWAB_EXPORT_OPTIONS;

typedef HRESULT (STDMETHODCALLTYPE WAB_PROGRESS_CALLBACK)(HWND hwnd,
                 LPWAB_PROGRESS lpProgress);
typedef WAB_PROGRESS_CALLBACK FAR * LPWAB_PROGRESS_CALLBACK;

typedef HRESULT (STDMETHODCALLTYPE WAB_IMPORT)(HWND hwnd,
                 LPADRBOOK lpAdrBook,
                 LPWABOBJECT lpWABObject,
                 LPWAB_PROGRESS_CALLBACK lpProgressCB,
                 LPWAB_IMPORT_OPTIONS lpOptions);
typedef WAB_IMPORT FAR * LPWAB_IMPORT;

typedef HRESULT (STDMETHODCALLTYPE WAB_EXPORT)(HWND hwnd,
                 LPADRBOOK lpAdrBook,
                 LPWABOBJECT lpWABObject,
                 LPWAB_PROGRESS_CALLBACK lpProgressCB,
                 LPWAB_EXPORT_OPTIONS lpOptions);
typedef WAB_EXPORT FAR * LPWAB_EXPORT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wabmig\wabguid.c ===
// This builds wabguid.obj, which can be linked into a DLL
// or EXE to provide the MAPI GUIDs. It contains all GUIDs
// defined by WAB.


#define USES_IID_IUnknown
#define USES_IID_IMAPIUnknown
#define USES_IID_IMAPITable
#define USES_IID_INotifObj
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIStatus
#define USES_IID_IAddrBook
#define USES_IID_IMailUser
#define USES_IID_IMAPIContainer
#define USES_IID_IABContainer
#define USES_IID_IDistList
#define USES_IID_IMAPITableData
#define USES_IID_IMAPIAdviseSink

#define USES_PS_PUBLIC_STRINGS

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#define INITGUID
#include <windows.h>
#include <wab.h>
#include <wabguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wabmig\dbgutil.h ===
/***********************************************************************
 *
 * DBGUTIL.H
 *
 * Debug Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

#ifdef DEBUG
VOID _DebugObjectProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label);
VOID _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject);
void _DebugMapiTable(BOOL fMAPI, LPMAPITABLE lpTable);
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle);
void _DebugNamedProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label);
VOID DebugBinary(UINT cb, LPBYTE lpb);

#define WABDebugObjectProps(lpObject, Label) _DebugObjectProps(FALSE, lpObject, Label)
#define WABDebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define WABDebugMapiTable(lpTable) _DebugMapiTable(FALSE, lpTable)
#define WABDebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)
#define WABDebugNamedProps(lpObject, Label) _DebugNamedProps(FALSE, lpObject, Label)

#define MAPIDebugObjectProps(lpObject, Label) _DebugObjectProps(TRUE, lpObject, Label)
#define MAPIDebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define MAPIDebugMapiTable(lpTable) _DebugMapiTable(TRUE, lpTable)
#define MAPIDebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)
#define MAPIDebugNamedProps(lpObject, Label) _DebugNamedProps(TRUE, lpObject, Label)
#define DebugBinaryData(cb, lpb) DebugBinary(cb, lpb)

// VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...);

#else

#define WABDebugObjectProps(lpObject, Label)
#define WABDebugProperties(lpProps, cProps, pszObject)
#define WABDebugMapiTable(lpTable)
#define WABDebugADRLIST(lpAdrList, lpszTitle)
#define WABDebugNamedProps(lpObject, Label)

#define MAPIDebugObjectProps(lpObject, Label)
#define MAPIDebugProperties(lpProps, cProps, pszObject)
#define MAPIDebugMapiTable(lpTable)
#define MAPIDebugADRLIST(lpAdrList, lpszTitle)
#define MAPIDebugNamedProps(lpObject, Label)
#define DebugBinaryData(cb, lpb)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wabmig\dbgutil.c ===
/***********************************************************************
 *
 * DBGUTIL.C
 *
 * Debug utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/
#ifdef DEBUG
#include <windows.h>
#include <mapix.h>
#include <wab.h>
#include <wabdbg.h>
#include <shlwapi.h>

#include "dbgutil.h"

#define _WAB_DBGUTIL_C

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

PUCHAR PropTagName(ULONG ulPropTag);
const TCHAR szNULL[] = "";

extern SCODE WABFreeBuffer(LPVOID lpBuffer);
VOID FAR CDECL _DebugTrace(LPSTR lpszFmt, ...);



/***************************************************************************

    Name      : FreeBufferAndNull

    Purpose   : Frees a MAPI buffer and NULLs the pointer

    Parameters: lppv = pointer to buffer pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall FreeBufferAndNull(BOOL fMAPI, LPVOID * lppv) {
    if (lppv) {
        if (*lppv) {
            SCODE sc;
            if (fMAPI) {
#ifdef OLD_STUFF
                if (sc = MAPIFreeBuffer(*lppv)) {
                    DebugTrace("MAPIFreeBuffer(%x) -> 0x%08x\n", *lppv, sc);
                }
#endif // OLD_STUFF
                DebugTrace("Doh!  FreeBufferAndNull with MAPI Flag set.  Can't do that!\n");
                sc = MAPI_E_INVALID_PARAMETER;
            } else {
                if (sc = WABFreeBuffer(*lppv)) {
                    DebugTrace("WABFreeBuffer(%x) -> 0x%08x\n", *lppv, sc);
                }
            }
            *lppv = NULL;
        }
    }
}


/***************************************************************************

    Name      : ReleaseAndNull

    Purpose   : Releases an object and NULLs the pointer

    Parameters: lppv = pointer to pointer to object to release

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall ReleaseAndNull(LPVOID * lppv) {
    LPUNKNOWN * lppunk = (LPUNKNOWN *)lppv;

    if (lppunk) {
        if (*lppunk) {
            HRESULT hResult;

            if (hResult = (*lppunk)->lpVtbl->Release(*lppunk)) {
                DebugTrace("Release(%x) -> 0x%08x\n", *lppunk, GetScode(hResult));
            }
            *lppunk = NULL;
        }
    }
}


/***************************************************************************

    Name      : PropTypeString

    Purpose   : Map a proptype to a string

    Parameters: ulPropType = property type to map

    Returns   : string pointer to name of prop type

    Comment   :

***************************************************************************/
LPTSTR PropTypeString(ULONG ulPropType) {
    switch (ulPropType) {
        case PT_UNSPECIFIED:
            return("PT_UNSPECIFIED");
        case PT_NULL:
            return("PT_NULL       ");
        case PT_I2:
            return("PT_I2         ");
        case PT_LONG:
            return("PT_LONG       ");
        case PT_R4:
            return("PT_R4         ");
        case PT_DOUBLE:
            return("PT_DOUBLE     ");
        case PT_CURRENCY:
            return("PT_CURRENCY   ");
        case PT_APPTIME:
            return("PT_APPTIME    ");
        case PT_ERROR:
            return("PT_ERROR      ");
        case PT_BOOLEAN:
            return("PT_BOOLEAN    ");
        case PT_OBJECT:
            return("PT_OBJECT     ");
        case PT_I8:
            return("PT_I8         ");
        case PT_STRING8:
            return("PT_STRING8    ");
        case PT_UNICODE:
            return("PT_UNICODE    ");
        case PT_SYSTIME:
            return("PT_SYSTIME    ");
        case PT_CLSID:
            return("PT_CLSID      ");
        case PT_BINARY:
            return("PT_BINARY     ");
        case PT_MV_I2:
            return("PT_MV_I2      ");
        case PT_MV_LONG:
            return("PT_MV_LONG    ");
        case PT_MV_R4:
            return("PT_MV_R4      ");
        case PT_MV_DOUBLE:
            return("PT_MV_DOUBLE  ");
        case PT_MV_CURRENCY:
            return("PT_MV_CURRENCY");
        case PT_MV_APPTIME:
            return("PT_MV_APPTIME ");
        case PT_MV_SYSTIME:
            return("PT_MV_SYSTIME ");
        case PT_MV_STRING8:
            return("PT_MV_STRING8 ");
        case PT_MV_BINARY:
            return("PT_MV_BINARY  ");
        case PT_MV_UNICODE:
            return("PT_MV_UNICODE ");
        case PT_MV_CLSID:
            return("PT_MV_CLSID   ");
        case PT_MV_I8:
            return("PT_MV_I8      ");
        default:
            return("   <unknown>  ");
    }
}


/***************************************************************************

    Name      : TraceMVPStrings

    Purpose   : Debug trace a multivalued string property value

    Parameters: lpszCaption = caption string
                PropValue = property value to dump

    Returns   : none

    Comment   :

***************************************************************************/
void _TraceMVPStrings(LPTSTR lpszCaption, SPropValue PropValue) {
    ULONG i;

    DebugTrace("-----------------------------------------------------\n");
    DebugTrace("%s", lpszCaption);
    switch (PROP_TYPE(PropValue.ulPropTag)) {

        case PT_ERROR:
            DebugTrace("Error value 0x%08x\n", PropValue.Value.err);
            break;

        case PT_MV_TSTRING:
            DebugTrace("%u values\n", PropValue.Value.MVSZ.cValues);

            if (PropValue.Value.MVSZ.cValues) {
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
                for (i = 0; i < PropValue.Value.MVSZ.cValues; i++) {
                    DebugTrace("%u: \"%s\"\n", i, PropValue.Value.MVSZ.LPPSZ[i]);
                }
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
            }
            break;

        default:
            DebugTrace("TraceMVPStrings got incorrect property type %u for tag %x\n",
              PROP_TYPE(PropValue.ulPropTag), PropValue.ulPropTag);
            break;
    }
}


/***************************************************************************

    Name      : DebugBinary

    Purpose   : Debug dump an array of bytes

    Parameters: cb = number of bytes to dump
                lpb -> bytes to dump

    Returns   : none

    Comment   :

***************************************************************************/
#define DEBUG_NUM_BINARY_LINES  8
VOID DebugBinary(UINT cb, LPBYTE lpb) {
    UINT cbLines = 0;

#if (DEBUG_NUM_BINARY_LINES != 0)
    UINT cbi;

    while (cb && cbLines < DEBUG_NUM_BINARY_LINES) {
        cbi = min(cb, 16);
        cb -= cbi;

        switch (cbi) {
            case 16:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14],
                  lpb[15]);
                break;
            case 1:
                DebugTrace("%02x\n", lpb[0]);
                break;
            case 2:
                DebugTrace("%02x %02x\n", lpb[0], lpb[1]);
                break;
            case 3:
                DebugTrace("%02x %02x %02x\n", lpb[0], lpb[1], lpb[2]);
                break;
            case 4:
                DebugTrace("%02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3]);
                break;
            case 5:
                DebugTrace("%02x %02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3],
                  lpb[4]);
                break;
            case 6:
                DebugTrace("%02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5]);
                break;
            case 7:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6]);
                break;
            case 8:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7]);
                break;
            case 9:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8]);
                break;
            case 10:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9]);
                break;
            case 11:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10]);
                break;
            case 12:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11]);
                break;
            case 13:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12]);
                break;
            case 14:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13]);
                break;
            case 15:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14]);
                break;
        }
        lpb += cbi;
        cbLines++;
    }
    if (cb) {
        DebugTrace("<etc.>");    //
    }
#endif
}


#define RETURN_PROP_CASE(pt) case PROP_ID(pt): return(#pt)

/***************************************************************************

    Name      : PropTagName

    Purpose   : Associate a name with a property tag

    Parameters: ulPropTag = property tag

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
PUCHAR PropTagName(ULONG ulPropTag) {
    static UCHAR szPropTag[35]; // see string on default

    switch (PROP_ID(ulPropTag)) {

        RETURN_PROP_CASE(PR_INITIALS);
        RETURN_PROP_CASE(PR_SURNAME);
        RETURN_PROP_CASE(PR_TITLE);
        RETURN_PROP_CASE(PR_TELEX_NUMBER);
        RETURN_PROP_CASE(PR_GIVEN_NAME);
        RETURN_PROP_CASE(PR_PRIMARY_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PRIMARY_FAX_NUMBER);
        RETURN_PROP_CASE(PR_POSTAL_CODE);
        RETURN_PROP_CASE(PR_POSTAL_ADDRESS);
        RETURN_PROP_CASE(PR_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_PAGER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_OTHER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ORGANIZATIONAL_ID_NUMBER);
        RETURN_PROP_CASE(PR_OFFICE_LOCATION);
        RETURN_PROP_CASE(PR_LOCATION);
        RETURN_PROP_CASE(PR_LOCALITY);
        RETURN_PROP_CASE(PR_ISDN_NUMBER);
        RETURN_PROP_CASE(PR_GOVERNMENT_ID_NUMBER);
        RETURN_PROP_CASE(PR_GENERATION);
        RETURN_PROP_CASE(PR_DEPARTMENT_NAME);
        RETURN_PROP_CASE(PR_COUNTRY);
        RETURN_PROP_CASE(PR_COMPANY_NAME);
        RETURN_PROP_CASE(PR_COMMENT);
        RETURN_PROP_CASE(PR_CELLULAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CALLBACK_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_FAX_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT);
        RETURN_PROP_CASE(PR_ACCOUNT);
        RETURN_PROP_CASE(PR_TEMPLATEID);
        RETURN_PROP_CASE(PR_DETAILS_TABLE);
        RETURN_PROP_CASE(PR_SEARCH_KEY);
        RETURN_PROP_CASE(PR_LAST_MODIFICATION_TIME);
        RETURN_PROP_CASE(PR_CREATION_TIME);
        RETURN_PROP_CASE(PR_ENTRYID);
        RETURN_PROP_CASE(PR_RECORD_KEY);
        RETURN_PROP_CASE(PR_MAPPING_SIGNATURE);
        RETURN_PROP_CASE(PR_OBJECT_TYPE);
        RETURN_PROP_CASE(PR_ROWID);
        RETURN_PROP_CASE(PR_ADDRTYPE);
        RETURN_PROP_CASE(PR_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_EMAIL_ADDRESS);
        RETURN_PROP_CASE(PR_DEPTH);
        RETURN_PROP_CASE(PR_ROW_TYPE);
        RETURN_PROP_CASE(PR_RADIO_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_HOME_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_INSTANCE_KEY);
        RETURN_PROP_CASE(PR_DISPLAY_TYPE);
        RETURN_PROP_CASE(PR_RECIPIENT_TYPE);
        RETURN_PROP_CASE(PR_CONTAINER_FLAGS);
        RETURN_PROP_CASE(PR_DEF_CREATE_DL);
        RETURN_PROP_CASE(PR_DEF_CREATE_MAILUSER);
        RETURN_PROP_CASE(PR_CONTACT_ADDRTYPES);
        RETURN_PROP_CASE(PR_CONTACT_DEFAULT_ADDRESS_INDEX);
        RETURN_PROP_CASE(PR_CONTACT_EMAIL_ADDRESSES);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_CITY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_COUNTRY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POSTAL_CODE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STREET);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_MIDDLE_NAME);
        RETURN_PROP_CASE(PR_NICKNAME);
        RETURN_PROP_CASE(PR_PERSONAL_HOME_PAGE);
        RETURN_PROP_CASE(PR_BUSINESS_HOME_PAGE);
        RETURN_PROP_CASE(PR_MHS_COMMON_NAME);
        RETURN_PROP_CASE(PR_SEND_RICH_INFO);
        RETURN_PROP_CASE(PR_TRANSMITABLE_DISPLAY_NAME);

        default:
            wnsprintf(szPropTag, ARRAYSIZE(szPropTag), "Unknown property tag 0x%x",
              PROP_ID(ulPropTag));
            return(szPropTag);
    }
}


/***************************************************************************

    Name      : DebugPropTagArray

    Purpose   : Displays MAPI property tags from a counted array

    Parameters: lpPropArray -> property array
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugPropTagArray(LPSPropTagArray lpPropArray, PUCHAR pszObject) {
    DWORD i;
    PUCHAR lpType;

    if (lpPropArray == NULL) {
        DebugTrace("Empty %s property tag array.\n", pszObject ? pszObject : szNULL);
        return;
    }

    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s property tags:\n", lpPropArray->cValues,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < lpPropArray->cValues ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpPropArray->aulPropTag[i],
          lpPropArray->aulPropTag[i] >> 16,
          lpPropArray->aulPropTag[i] & 0xffff);
#endif
        switch (lpPropArray->aulPropTag[i] & 0xffff) {
            case PT_STRING8:
                lpType = "STRING8";
                break;
            case PT_LONG:
                lpType = "LONG";
                break;
            case PT_I2:
                lpType = "I2";
                break;
            case PT_ERROR:
                lpType = "ERROR";
                break;
            case PT_BOOLEAN:
                lpType = "BOOLEAN";
                break;
            case PT_R4:
                lpType = "R4";
                break;
            case PT_DOUBLE:
                lpType = "DOUBLE";
                break;
            case PT_CURRENCY:
                lpType = "CURRENCY";
                break;
            case PT_APPTIME:
                lpType = "APPTIME";
                break;
            case PT_SYSTIME:
                lpType = "SYSTIME";
                break;
            case PT_UNICODE:
                lpType = "UNICODE";
                break;
            case PT_CLSID:
                lpType = "CLSID";
                break;
            case PT_BINARY:
                lpType = "BINARY";
                break;
            case PT_I8:
                lpType = "PT_I8";
                break;
            case PT_MV_I2:
                lpType = "MV_I2";
                break;
            case PT_MV_LONG:
                lpType = "MV_LONG";
                break;
            case PT_MV_R4:
                lpType = "MV_R4";
                break;
            case PT_MV_DOUBLE:
                lpType = "MV_DOUBLE";
                break;
            case PT_MV_CURRENCY:
                lpType = "MV_CURRENCY";
                break;
            case PT_MV_APPTIME:
                lpType = "MV_APPTIME";
                break;
            case PT_MV_SYSTIME:
                lpType = "MV_SYSTIME";
                break;
            case PT_MV_BINARY:
                lpType = "MV_BINARY";
                break;
            case PT_MV_STRING8:
                lpType = "MV_STRING8";
                break;
            case PT_MV_UNICODE:
                lpType = "MV_UNICODE";
                break;
            case PT_MV_CLSID:
                lpType = "MV_CLSID";
                break;
            case PT_MV_I8:
                lpType = "MV_I8";
                break;
            case PT_NULL:
                lpType = "NULL";
                break;
            case PT_OBJECT:
                lpType = "OBJECT";
                break;
            default:
                DebugTrace("<Unknown Property Type>");
                break;
        }
        DebugTrace("%s\t%s\n", PropTagName(lpPropArray->aulPropTag[i]), lpType);
    }
}


/***************************************************************************

    Name      : DebugProperties

    Purpose   : Displays MAPI properties in a property list

    Parameters: lpProps -> property list
                cProps = count of properties
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject) {
    DWORD i, j;


    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s properties:\n", cProps,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < cProps ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpProps[i].ulPropTag,
          lpProps[i].ulPropTag >> 16,
          lpProps[i].ulPropTag & 0xffff);
#endif
        DebugTrace("%s\n", PropTagName(lpProps[i].ulPropTag));

        switch (lpProps[i].ulPropTag & 0xffff) {
            case PT_STRING8:
                if (lstrlen(lpProps[i].Value.lpszA) < 1024) {
                    DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.lpszA);
                } else {
                    DebugTrace("STRING8 Value is too long to display\n");
                }
                break;
            case PT_LONG:
                DebugTrace("LONG Value:%u\n", lpProps[i].Value.l);
                break;
            case PT_I2:
                DebugTrace("I2 Value:%u\n", lpProps[i].Value.i);
                break;
            case PT_ERROR:
                DebugTrace("ERROR Value: 0x%08x\n", lpProps[i].Value.err);
                break;
            case PT_BOOLEAN:
                DebugTrace("BOOLEAN Value:%s\n", lpProps[i].Value.b ?
                  "TRUE" : "FALSE");
                break;
            case PT_R4:
                DebugTrace("R4 Value\n");
                break;
            case PT_DOUBLE:
                DebugTrace("DOUBLE Value\n");
                break;
            case PT_CURRENCY:
                DebugTrace("CURRENCY Value\n");
                break;
            case PT_APPTIME:
                DebugTrace("APPTIME Value\n");
                break;
            case PT_SYSTIME:
//                DebugTime(lpProps[i].Value.ft, "SYSTIME Value:%s\n");
                break;
            case PT_UNICODE:
                DebugTrace("UNICODE Value\n");
                break;
            case PT_CLSID:
                DebugTrace("CLSID Value\n");
                break;
            case PT_BINARY:
                DebugTrace("BINARY Value %u bytes:\n", lpProps[i].Value.bin.cb);
                DebugBinary(lpProps[i].Value.bin.cb, lpProps[i].Value.bin.lpb);
                break;
            case PT_I8:
                DebugTrace("LARGE_INTEGER Value\n");
                break;
            case PT_MV_I2:
                DebugTrace("MV_I2 Value\n");
                break;
            case PT_MV_LONG:
                DebugTrace("MV_LONG Value\n");
                break;
            case PT_MV_R4:
                DebugTrace("MV_R4 Value\n");
                break;
            case PT_MV_DOUBLE:
                DebugTrace("MV_DOUBLE Value\n");
                break;
            case PT_MV_CURRENCY:
                DebugTrace("MV_CURRENCY Value\n");
                break;
            case PT_MV_APPTIME:
                DebugTrace("MV_APPTIME Value\n");
                break;
            case PT_MV_SYSTIME:
                DebugTrace("MV_SYSTIME Value\n");
                break;
            case PT_MV_BINARY:
                DebugTrace("MV_BINARY with %u values\n", lpProps[i].Value.MVbin.cValues);
                for (j = 0; j < lpProps[i].Value.MVbin.cValues; j++) {
                    DebugTrace("BINARY Value %u: %u bytes\n", j, lpProps[i].Value.MVbin.lpbin[j].cb);
                    DebugBinary(lpProps[i].Value.MVbin.lpbin[j].cb, lpProps[i].Value.MVbin.lpbin[j].lpb);
                }
                break;
            case PT_MV_STRING8:
                DebugTrace("MV_STRING8 with %u values\n", lpProps[i].Value.MVszA.cValues);
                for (j = 0; j < lpProps[i].Value.MVszA.cValues; j++) {
                    if (lstrlen(lpProps[i].Value.MVszA.lppszA[j]) < 1024) {
                        DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.MVszA.lppszA[j]);
                    } else {
                        DebugTrace("STRING8 Value is too long to display\n");
                    }
                }
                break;
            case PT_MV_UNICODE:
                DebugTrace("MV_UNICODE Value\n");
                break;
            case PT_MV_CLSID:
                DebugTrace("MV_CLSID Value\n");
                break;
            case PT_MV_I8:
                DebugTrace("MV_I8 Value\n");
                break;
            case PT_NULL:
                DebugTrace("NULL Value\n");
                break;
            case PT_OBJECT:
                DebugTrace("OBJECT Value\n");
                break;
            default:
                DebugTrace("Unknown Property Type\n");
                break;
        }
    }
}


/***************************************************************************

    Name      : DebugADRLIST

    Purpose   : Displays structure of an ADRLIST including properties

    Parameters: lpAdrList -> ADRLSIT to show
                lpszTitle = string to identify this dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle) {
     ULONG i;
     TCHAR szTitle[250];

     for (i = 0; i < lpAdrList->cEntries; i++) {

         wnsprintf(szTitle, ARRAYSIZE(szTitle), "%s : Entry %u", lpszTitle, i);
         _DebugProperties(lpAdrList->aEntries[i].rgPropVals,
           lpAdrList->aEntries[i].cValues, szTitle);
     }
}


/***************************************************************************

    Name      : DebugObjectProps

    Purpose   : Displays MAPI properties of an object

    Parameters: fMAPI = TRUE if this is a MAPI object, FALSE if WAB
                lpObject -> object to dump
                Label = string to identify this prop dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugObjectProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label) {
    DWORD cProps = 0;
    LPSPropValue lpProps = NULL;
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;


    hr = lpObject->lpVtbl->GetProps(lpObject, NULL, 0, &cProps, &lpProps);
    switch (sc = GetScode(hr)) {
        case SUCCESS_SUCCESS:
            break;

        case MAPI_W_ERRORS_RETURNED:
            DebugTrace("GetProps -> Errors Returned\n");
            break;

        default:
            DebugTrace("GetProps -> Error 0x%x\n", sc);
            return;
    }

    _DebugProperties(lpProps, cProps, Label);

    FreeBufferAndNull(fMAPI, &lpProps);
}


/*
 *	Destroys an SRowSet structure.
 */
STDAPI_(void)
MyFreeProws(BOOL fMAPI, LPSRowSet prows)
{
	ULONG		irow;

	if (!prows)
		return;

	for (irow = 0; irow < prows->cRows; ++irow)
		FreeBufferAndNull(fMAPI, &(prows->aRow[irow].lpProps));
	FreeBufferAndNull(fMAPI, &prows);
}


/***************************************************************************

    Name      : DebugMapiTable

    Purpose   : Displays structure of a MAPITABLE including properties

    Parameters: fMAPI = TRUE if this is a MAPI object, FALSE if WAB
                lpTable -> MAPITABLE to display

    Returns   : none

    Comment   : Don't sort the columns or rows here.  This routine should
                not produce side effects in the table.

***************************************************************************/
void _DebugMapiTable(BOOL fMAPI, LPMAPITABLE lpTable) {
    UCHAR szTemp[30];   // plenty for "ROW %u"
    ULONG ulCount;
    WORD wIndex;
    LPSRowSet lpsRow = NULL;
    ULONG ulCurrentRow = (ULONG)-1;
    ULONG ulNum, ulDen, lRowsSeeked;

    DebugTrace("=======================================\n");
    DebugTrace("+  Dump of MAPITABLE at 0x%x:\n", lpTable);
    DebugTrace("---------------------------------------\n");

    // How big is the table?
    lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulCount);
    DebugTrace("Table contains %u rows\n", ulCount);

    // Save the current position in the table
    lpTable->lpVtbl->QueryPosition(lpTable, &ulCurrentRow, &ulNum, &ulDen);

    // Display the properties for each row in the table
    for (wIndex = 0; wIndex < ulCount; wIndex++) {
        // Get the next row
        lpTable->lpVtbl->QueryRows(lpTable, 1, 0, &lpsRow);

        if (lpsRow) {
//            Assert(lpsRow->cRows == 1); // should have exactly one row

            wnsprintf(szTemp, ARRAYSIZE(szTemp), "ROW %u", wIndex);

            _DebugProperties(lpsRow->aRow[0].lpProps,
              lpsRow->aRow[0].cValues, szTemp);

            MyFreeProws(fMAPI, lpsRow);
        }
    }

    // Restore the current position for the table
    if (ulCurrentRow != (ULONG)-1) {
        lpTable->lpVtbl->SeekRow(lpTable, BOOKMARK_BEGINNING, ulCurrentRow,
          &lRowsSeeked);
    }
}


void _DebugNamedProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label) {
    HRESULT             hResult;
    ULONG               cPropNames      = 0;
    LPMAPINAMEID  FAR * lppPropNames    = NULL;
    LPGUID              lpPropSetGuid   = NULL;
    LPSPropTagArray     lpPropTags      = NULL;
    ULONG i;
    LPMAPINAMEID lpmnidT;


    if( FAILED(hResult = lpObject->lpVtbl->GetNamesFromIDs(lpObject,
      &lpPropTags,
      lpPropSetGuid,
      0,
      &cPropNames,
      &lppPropNames))) {
        DebugTrace("GetNamesFromIDs -> %x\n", GetScode(hResult));
    } else {

        DebugTrace("Named Property Table for %s contains %d tags\n", Label, cPropNames);
        for (i = 0; i < cPropNames; i++) {
            lpmnidT = lppPropNames[i];

            if (lpmnidT->ulKind == MNID_STRING) {
                DebugTrace("%08x: %08x-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x  %ls\n", lpPropTags->aulPropTag[i],
                  lpmnidT->lpguid->Data1,
                  lpmnidT->lpguid->Data2,
                  lpmnidT->lpguid->Data3,
                  lpmnidT->lpguid->Data4[0],
                  lpmnidT->lpguid->Data4[1],
                  lpmnidT->lpguid->Data4[2],
                  lpmnidT->lpguid->Data4[3],
                  lpmnidT->lpguid->Data4[4],
                  lpmnidT->lpguid->Data4[5],
                  lpmnidT->lpguid->Data4[6],
                  lpmnidT->lpguid->Data4[7],
                  lpmnidT->Kind.lpwstrName);
            } else {
                DebugTrace("%08x: %08x-%04x-%04x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x  %08x\n", lpPropTags->aulPropTag[i],
                  lpmnidT->lpguid->Data1,
                  lpmnidT->lpguid->Data2,
                  lpmnidT->lpguid->Data3,
                  lpmnidT->lpguid->Data4[0],
                  lpmnidT->lpguid->Data4[1],
                  lpmnidT->lpguid->Data4[2],
                  lpmnidT->lpguid->Data4[3],
                  lpmnidT->lpguid->Data4[4],
                  lpmnidT->lpguid->Data4[5],
                  lpmnidT->lpguid->Data4[6],
                  lpmnidT->lpguid->Data4[7],
                  lpmnidT->Kind.lID);
            }
        }

        if (cPropNames != 0) {
            FreeBufferAndNull(fMAPI, &lpPropTags);
        }
        FreeBufferAndNull(fMAPI, lppPropNames);
    }
}

// If you want all debug output to go to a file, uncomment this.
// #define DEBUG_FILE  TRUE


/*
 * DebugTrace -- printf to the debugger console or debug output file
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
VOID FAR CDECL _DebugTrace(LPSTR lpszFmt, ...) {
    va_list marker;
    TCHAR String[1100];
#ifdef DEBUG_FILE
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbWritten;
#endif

    va_start(marker, lpszFmt);
    wvnsprintf(String, ARRAYSIZE(String), lpszFmt, marker);

#ifdef DEBUG_FILE
    if (INVALID_HANDLE_VALUE != (hFile = CreateFile("c:\\debug.out", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0, NULL))) {
        SetFilePointer(hFile, 0, 0, FILE_END);
        WriteFile(hFile, String, lstrlen(String), &cbWritten, NULL);
        CloseHandle(hFile);
    }
#else
    OutputDebugString(String);
#endif
}

int EXPORTDBG __cdecl DebugTraceFn(char *pszFormat, ...) {
    va_list marker;
    TCHAR String[1100];
#ifdef DEBUG_FILE
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD cbWritten;
#endif

    va_start(marker, pszFormat);
    wvnsprintf(String, ARRAYSIZE(String), pszFormat, marker);
#ifdef DEBUG_FILE
    if (INVALID_HANDLE_VALUE != (hFile = CreateFile("c:\\debug.out", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0, NULL))) {
        SetFilePointer(hFile, 0, 0, FILE_END);
        WriteFile(hFile, String, lstrlen(String), &cbWritten, NULL);
        CloseHandle(hFile);
    }
#else
        OutputDebugString(String);
#endif
    return(0);
}


/*
 * DebugAssert
 *
 * From MAPI 1.0 SDK sample code
 */
int __cdecl DebugAssert(int fFatal, char *pszFile, int iLine,
  char *pszFormat, ...) {
    char    sz[512];
    va_list vl;
    int     id;

    StrCpyN(sz, "++++ WAB Debug Trap (", ARRAYSIZE(sz));
    OutputDebugString(sz);

    va_start(vl, pszFormat);
    wvnsprintf(sz, ARRAYSIZE(sz), pszFormat, vl);
    va_end(vl);

    wnsprintf(sz + lstrlen(sz), ARRAYSIZE(sz) - lstrlen(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

    OutputDebugString(sz);

    // Hold down control key to prevent MessageBox
    if (GetAsyncKeyState(VK_CONTROL) >= 0) {
        id = MessageBox(NULL,
          sz,
          "Microsoft Windows Address Book Debug Trap",
          MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SYSTEMMODAL |
          (fFatal ? MB_DEFBUTTON1 : MB_DEFBUTTON3) );

        if (id == IDABORT)
            *((LPBYTE)NULL) = 0;
        else if (id == IDRETRY)
            DebugBreak();
    }

    return(0);
}


int EXPORTDBG __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...) {
    char    sz[512];
    va_list vl;
    int     id;

    StrCpyN(sz, "++++ WAB Debug Trap (", ARRAYSIZE(sz));
    OutputDebugString(sz);

    va_start(vl, pszFormat);
    wvnsprintf(sz, ARRAYSIZE(sz), pszFormat, vl);
    va_end(vl);

    wnsprintf(sz + lstrlen(sz), ARRAYSIZE(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

    OutputDebugString(sz);

    // Hold down control key to prevent MessageBox
    if (GetAsyncKeyState(VK_CONTROL) >= 0) {
        id = MessageBox(NULL,
          sz,
          "Microsoft Windows Address Book Debug Trap",
          MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SYSTEMMODAL |
          (fFatal ? MB_DEFBUTTON1 : MB_DEFBUTTON3) );

        if (id == IDABORT)
            *((LPBYTE)NULL) = 0;
        else if (id == IDRETRY)
            DebugBreak();
    }

    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wabmig\export.c ===
/*
 *  EXPORT.C
 *
 *  Migrate WAB to PAB
 *
 *  Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include <shlwapi.h>
#include "_wabmig.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"


BOOL HandleExportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName, LPTSTR lpEmailAddress);
LPWAB_EXPORT lpfnExport = NULL;


/***************************************************************************

    Name      : ExportFinish

    Purpose   : Clean up after the migration process

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Re-enable the Export button on the UI.

***************************************************************************/
void ExportFinish(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    TCHAR szBufferTitle[MAX_RESOURCE_STRING + 1];


    DebugTrace(">>> Export Finished\n");

    if (! fError) {     // Leave error state displayed
        if (LoadString(hInst, IDS_STATE_EXPORT_COMPLETE, szBuffer, sizeof(szBuffer))) {
            DebugTrace("Status Message: %s\n", szBuffer);
            SetDlgItemText(hwnd, IDC_Message, szBuffer);

            if (! LoadString(hInst, IDS_APP_TITLE, szBufferTitle, sizeof(szBufferTitle))) {
                StrCpyN(szBufferTitle, "", ARRAYSIZE(szBufferTitle));
            }

            // Display a dialog telling user it's over
            MessageBox(hwnd, szBuffer,
              szBufferTitle, MB_ICONINFORMATION | MB_OK);
        }
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);
    }
    fError = FALSE;

    fMigrating = FALSE;

    // Re-enable the Export button here.
    EnableWindow(GetDlgItem(hwnd, IDC_Export), TRUE);
    // Change the Cancel button to Close
    if (LoadString(hInst, IDS_BUTTON_CLOSE, szBuffer, sizeof(szBuffer))) {
        SetDlgItemText(hwnd, IDCANCEL, szBuffer);
    }
}


/***************************************************************************

    Name      : ExportError

    Purpose   : Report fatal error and cleanup.

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Report error and post STATE_EXPORT_FINISH.

***************************************************************************/
void ExportError(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace("Export Error\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_EXPORT_ERROR);

    ExportFinish(hwnd);
}


/***************************************************************************

    Name      : ExportCancel

    Purpose   : Report cancel error and cleanup.

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Report error and post STATE_EXPORT_FINISH.

***************************************************************************/
void ExportCancel(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace("Export Cancelled\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_EXPORT_CANCEL);

    ExportFinish(hwnd);
}


INT_PTR CALLBACK ExportDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    static HWND hwndLB = NULL;
    HRESULT hResult;

    Assert(fExport);

//    DebugTrace("Export MSG: 0x%04x, 0x%04x, 0x%08x\n", message, (WORD)wParam, lParam);
    switch (message) {
        case WM_INITDIALOG:
            {
                SetWindowLongPtr(hwnd, DWLP_USER, lParam);

                InitCommonControls();
                SetDialogMessage(hwnd, IDS_STATE_EXPORT_IDLE);

                // Fill in the Target List box
                hwndLB = GetDlgItem(hwnd, IDC_Target);
                PopulateTargetList(hwndLB, NULL);

                ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);

                return(TRUE);
            }

        case WM_COMMAND :
            switch (LOWORD(wParam)) {
                case IDCANCEL:
                case IDCLOSE:
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDM_EXIT :
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);

                case IDC_Export:
                    {
                        LPWAB_EXPORT lpfnWABExport = NULL;
                        HINSTANCE hinstExportDll = NULL;
                        DWORD ec;
                        TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

                        if (fMigrating) {
                            return(0);          // ignore if we're already migrating
                        }
                        fMigrating = TRUE;      // lock out

                        // reset options
                        ExportOptions.ReplaceOption = WAB_REPLACE_PROMPT;
                        ExportOptions.fNoErrors = FALSE;

                        // Gray out the button here.
                        EnableWindow(GetDlgItem(hwnd, IDC_Export), FALSE);
                        // Change the Close button to Cancel
                        if (LoadString(hInst, IDS_BUTTON_CANCEL, szBuffer, sizeof(szBuffer))) {
                            SetDlgItemText(hwnd, IDCANCEL, szBuffer);
                        }

                        if (lpExportDll && lpExportFn) {
                            if (! (hinstExportDll = LoadLibrary(lpExportDll))) {
                                DebugTrace("Couldn't load export dll [%s] -> %u\n", lpExportDll, GetLastError());
                                switch (GetLastError()) {
                                    case ERROR_FILE_NOT_FOUND:
                                        if (HandleExportError(hwnd,
                                          IDS_ERROR_DLL_NOT_FOUND,
                                          0,
                                          lpExportDll,
                                          NULL)) {
                                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                            ExportCancel(hwnd);
                                        } else {
                                            ExportError(hwnd);
                                        }
                                        break;

                                    default:
                                        if (HandleExportError(hwnd,
                                          IDS_ERROR_DLL_INVALID,
                                          0,
                                          lpExportDll,
                                          NULL)) {
                                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                            ExportCancel(hwnd);
                                        } else {
                                            ExportError(hwnd);
                                        }
                                        break;
                                }
                            } else {
                                if (! (lpfnWABExport = (LPWAB_EXPORT)GetProcAddress(hinstExportDll,
                                  lpExportFn))) {
                                    DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", lpExportFn, lpExportDll, GetLastError());
                                    switch (GetLastError()) {
                                        default:
                                            if (HandleExportError(hwnd,
                                              IDS_ERROR_DLL_INVALID,
                                              0,
                                              lpExportDll,
                                              NULL)) {
                                                hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                                ExportCancel(hwnd);
                                            } else {
                                                ExportError(hwnd);
                                            }
                                            break;
                                    }
                                } else {
                                    // Do it!
                                    __try
                                    {
                                        HRESULT hResult;
                                        BOOL fFinished = FALSE;
                                        WAB_PARAM wp = {0};
                                        LPWAB_PARAM lpwp = NULL;

                                        {
                                            LPWABMIGDLGPARAM lpwmdp = (LPWABMIGDLGPARAM) GetWindowLongPtr(hwnd, DWLP_USER);
                                            LPTSTR lpszFileName = lpwmdp->szFileName;
                                            wp.cbSize = sizeof(WAB_PARAM);
                                            wp.hwnd = hwnd;
                                            if(lstrlen(lpszFileName))
                                            {
                                                // we have a file name - use it to open the WAB
                                                wp.szFileName = lpszFileName;
                                                wp.ulFlags = 0;
                                            }
                                            else
                                            {
                                                wp.ulFlags = WAB_ENABLE_PROFILES;
                                            }
                                            lpwp = &wp;
                                        }

                                        hResult = lpfnWABOpen(&lpAdrBookWAB, &lpWABObject, lpwp, 0);
                                        if (SUCCEEDED(hResult))
                                        {
                                            if (hResult = lpfnWABExport(hwnd,
                                              lpAdrBookWAB,
                                              lpWABObject,
                                              (LPWAB_PROGRESS_CALLBACK)&ProgressCallback,
                                              &ExportOptions)) {

                                                switch (GetScode(hResult))
                                                {
                                                    case MAPI_E_USER_CANCEL:
                                                        ExportCancel(hwnd);
                                                        break;

                                                    default:
                                                        ExportError(hwnd);
                                                        DebugTrace("Exporter DLL returned %x\n", GetScode(hResult));
                                                        break;
                                                }

                                                fFinished = TRUE;
                                            }

                                            lpAdrBookWAB->lpVtbl->Release(lpAdrBookWAB);
                                            lpAdrBookWAB = NULL;
                                            lpWABObject->lpVtbl->Release(lpWABObject);
                                            lpWABObject = NULL;
                                            if (!fFinished)
                                            {
                                                // Make progress bar full.
                                                SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETRANGE, 0, MAKELPARAM(0, 100));
                                                SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETPOS, (WPARAM)100, 0);
                                                ExportFinish(hwnd);
                                            }
                                        }
                                        else
                                        {
                                            // Report fatal error
                                            TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
                                            TCHAR szBufferTitle[MAX_RESOURCE_STRING + 1];

                                            if (LoadString(hInst, IDS_STATE_EXPORT_ERROR, szBuffer, sizeof(szBuffer)))
                                            {
                                                SetDlgItemText(hwnd, IDC_Message, szBuffer);
                                                if (! LoadString(hInst, IDS_APP_TITLE, szBufferTitle, sizeof(szBufferTitle)))
                                                {
                                                    StrCpyN(szBufferTitle, "", ARRAYSIZE(szBufferTitle));
                                                }

                                                // Display a dialog telling user it's over
                                                MessageBox(hwnd, szBuffer,
                                                  szBufferTitle, MB_ICONINFORMATION | MB_OK);
                                            }

                                            fError = TRUE;
                                            ExportFinish(hwnd);
                                        }
                                    }
                                    __except (ec = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
                                    {
                                        DebugTrace("Exception 0x%08x in %s\n", ec, lpExportDll);
                                        if (HandleExportError(hwnd,
                                          IDS_ERROR_DLL_EXCEPTION,
                                          0,
                                          lpExportDll,
                                          NULL))
                                        {
                                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                            ExportCancel(hwnd);
                                        }
                                        else
                                        {
                                            ExportError(hwnd);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return(0);

                case IDC_Target:
                    switch (HIWORD(wParam)) {   // look for selection change
                        case LBN_SELCHANGE:
                            {
                                ULONG ulSelIndex, ulTableIndex;
                                TCHAR szCurSel[256];

                                // Enable the Export Button if it is disabled. The 'Export' Button is disabled initially.
                                HWND hButton = GetDlgItem(hwnd, IDC_Export);
                                if(hButton)
                                {
                                    if(!IsWindowEnabled(hButton))
                                        EnableWindow(hButton, TRUE);
                                }

                                //
                                // Get the text of the selected item in the listbox...
                                //
                                ulSelIndex = (ULONG) SendMessage((HWND)lParam, LB_GETCURSEL, 0, 0);
                                ulTableIndex = (ULONG) SendMessage((HWND)lParam, LB_GETITEMDATA, (WPARAM)ulSelIndex, 0);

                                SendMessage((HWND)lParam,
                                  LB_GETTEXT,
                                  (WPARAM)ulSelIndex,
                                  (LPARAM)szCurSel);
                                DebugTrace("Current selection is [%s]\n", szCurSel);

                                lpExportDll = rgTargetInfo[ulTableIndex].lpDll;
                                lpExportDesc = rgTargetInfo[ulTableIndex].lpDescription;
                                lpExportFn = rgTargetInfo[ulTableIndex].lpEntry;
                                lpExportName = rgTargetInfo[ulTableIndex].lpRegName;

                                SendMessage(hwnd, WM_SETREDRAW, TRUE, 0L);
                            }
                            break;

                        case LBN_DBLCLK:
                            PostMessage(hwnd, WM_COMMAND, (WPARAM)IDC_Export, 0);
                            break;
                    }
                    break;
                }
            break;

        case WM_CLOSE:
            if (fMigrating) {
                SendMessage(hwnd, WM_COMMAND, ID_STATE_EXPORT_FINISH, 0);
            }
            EndDialog(hwnd, FALSE);
            return(0);

        case WM_DESTROY:
            FreeLBItemData(hwndLB);
            return(DefWindowProc(hwnd, message, wParam, lParam));

        default:
            return(FALSE);
    }

    return(TRUE);
}


/***************************************************************************

    Name      : HandleExportError

    Purpose   : Decides if a dialog needs to be displayed to
                indicate the failure and does so.

    Parameters: hwnd = main dialog window
                ids = String ID (optional: calculated from hResult if 0)
                hResult = Result of action
                lpDisplayName = display name of object that failed
                lpEmailAddress = email address of object that failed (or NULL)

    Returns   : TRUE if user requests ABORT.

    Comment   : Abort is not yet implemented in the dialog, but if you
                ever want to, just make this routine return TRUE;

***************************************************************************/
BOOL HandleExportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName, LPTSTR lpEmailAddress) {
    BOOL fAbort = FALSE;
    ERROR_INFO EI;

    if ((ids || hResult) && ! ExportOptions.fNoErrors) {
        if (ids == 0) {
            switch (GetScode(hResult)) {
                case WAB_W_BAD_EMAIL:
                    ids = lpEmailAddress ? IDS_ERROR_EMAIL_ADDRESS_2 : IDS_ERROR_EMAIL_ADDRESS_1;
                    break;

                case MAPI_E_NO_SUPPORT:
                    // Propbably failed to open contents on a distribution list
                    ids = IDS_ERROR_NO_SUPPORT;
                    break;

                case MAPI_E_USER_CANCEL:
                    return(TRUE);

                default:
                    if (HR_FAILED(hResult)) {
                        DebugTrace("Error Box for Hresult: 0x%08x\n", GetScode(hResult));
                        Assert(FALSE);      // want to know about it.
                        ids = IDS_ERROR_GENERAL;
                    }
                    break;
            }
        }

        EI.lpszDisplayName = lpDisplayName;
        EI.lpszEmailAddress = lpEmailAddress;
        EI.ErrorResult = ERROR_OK;
        EI.ids = ids;

        DialogBoxParam(hInst,
          MAKEINTRESOURCE(IDD_ErrorExport),
          hwnd,
          ErrorDialogProc,
          (LPARAM)&EI);

        fAbort = EI.ErrorResult == ERROR_ABORT;
    }

    return(fAbort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wabmig\import.c ===
/*
 *  IMPORT.C
 *
 *  Migrate PAB to WAB
 *
 *  Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include "_wabmig.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"
#include <shlwapi.h>


BOOL HandleImportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName, LPTSTR lpEmailAddress);


/***************************************************************************

    Name      : ImportFinish

    Purpose   : Clean up after the migration process

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Re-enable the Import button on the UI.

***************************************************************************/
void ImportFinish(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    TCHAR szBufferTitle[MAX_RESOURCE_STRING + 1];

    DebugTrace(">>> Import Finished\n");

    if (! fError) {     // Leave error state displayed
        if (LoadString(hInst, IDS_STATE_IMPORT_COMPLETE, szBuffer, sizeof(szBuffer))) {
            DebugTrace("Status Message: %s\n", szBuffer);
            SetDlgItemText(hwnd, IDC_Message, szBuffer);

            if (! LoadString(hInst, IDS_APP_TITLE, szBufferTitle, sizeof(szBufferTitle))) {
                StrCpyN(szBufferTitle, "", ARRAYSIZE(szBufferTitle));
            }

            // Display a dialog telling user it's over
            MessageBox(hwnd, szBuffer,
              szBufferTitle, MB_ICONINFORMATION | MB_OK);
        }
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);
    }
    fError = FALSE;

    fMigrating = FALSE;

    // Re-enable the Import button here.
    EnableWindow(GetDlgItem(hwnd, IDC_Import), TRUE);
    // Change the Cancel button to Close
    if (LoadString(hInst, IDS_BUTTON_CLOSE, szBuffer, sizeof(szBuffer))) {
        SetDlgItemText(hwnd, IDCANCEL, szBuffer);
    }
}


/***************************************************************************

    Name      : ImportError

    Purpose   : Report fatal error and cleanup.

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Report error

***************************************************************************/
void ImportError(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace("Import ERROR\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_IMPORT_ERROR);

    ImportFinish(hwnd);
}


/***************************************************************************

    Name      : ImportCancel

    Purpose   : Report cancel error and cleanup.

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Report cancel error

***************************************************************************/
void ImportCancel(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace("Import Cancelled\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_IMPORT_CANCEL);

    ImportFinish(hwnd);
}

/***************************************************************************

    Name      : ImportFileBusyError

    Purpose   : Report File to Open is Busy

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Report File is Busy

***************************************************************************/
void ImportFileBusyError(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace("Import Cancelled\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_IMPORT_ERROR_FILEOPEN);

    ImportFinish(hwnd);
}



INT_PTR CALLBACK ImportDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    static HWND hwndLB = NULL;
    HRESULT hResult;

    Assert(! fExport);

    switch (message) {
        case WM_INITDIALOG:
            {
                SetWindowLongPtr(hwnd, DWLP_USER, lParam);

                InitCommonControls();
                SetDialogMessage(hwnd, IDS_STATE_IMPORT_IDLE);

                // Fill in the Target List box
                hwndLB = GetDlgItem(hwnd, IDC_Target);
                PopulateTargetList(hwndLB, NULL);

                ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);

                return(TRUE);
            }

        case WM_COMMAND :
            switch (LOWORD(wParam)) {
                case IDCANCEL:
                case IDCLOSE:
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDM_EXIT :
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);

                case IDC_Import:
                    {
                        LPWAB_IMPORT lpfnWABImport = NULL;
                        HINSTANCE hinstImportDll = NULL;
                        DWORD ec;
                        TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

                        if (fMigrating) {
                            return(0);          // ignore if we're already migrating
                        }
                        fMigrating = TRUE;      // lock out

                        // reset options
                        ImportOptions.ReplaceOption = WAB_REPLACE_PROMPT;
                        ImportOptions.fNoErrors = FALSE;

                        // Gray out the button here.
                        EnableWindow(GetDlgItem(hwnd, IDC_Import), FALSE);
                        // Change the Close button to Cancel
                        if (LoadString(hInst, IDS_BUTTON_CANCEL, szBuffer, sizeof(szBuffer))) {
                            SetDlgItemText(hwnd, IDCANCEL, szBuffer);
                        }

                        if (lpImportDll && lpImportFn) {
                            if (! (hinstImportDll = LoadLibrary(lpImportDll))) {
                                DebugTrace("Couldn't load import dll [%s] -> %u\n", lpImportDll, GetLastError());
                                switch (GetLastError()) {
                                    case ERROR_FILE_NOT_FOUND:
                                        if (HandleImportError(hwnd,
                                          IDS_ERROR_DLL_NOT_FOUND,
                                          0,
                                          lpImportDll,
                                          NULL)) {
                                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                            ImportCancel(hwnd);
                                        } else {
                                            ImportError(hwnd);
                                        }
                                        break;

                                    default:
                                        if (HandleImportError(hwnd,
                                          IDS_ERROR_DLL_INVALID,
                                          0,
                                          lpImportDll,
                                          NULL)) {
                                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                            ImportCancel(hwnd);
                                        } else {
                                            ImportError(hwnd);
                                        }
                                        break;
                                }
                            } else {
                                if (! (lpfnWABImport = (LPWAB_IMPORT)GetProcAddress(hinstImportDll,
                                  lpImportFn))) {
                                    DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", lpImportFn, lpImportDll, GetLastError());
                                    switch (GetLastError()) {
                                        default:
                                            if (HandleImportError(hwnd,
                                              IDS_ERROR_DLL_INVALID,
                                              0,
                                              lpImportDll,
                                              NULL)) {
                                                hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                                ImportCancel(hwnd);
                                            } else {
                                                ImportError(hwnd);
                                            }
                                            break;
                                    }
                                } else {
                                    // Do it!
                                    __try
                                    {
                                        HRESULT hResult;
                                        BOOL fFinished = FALSE;
                                        WAB_PARAM wp = {0};
                                        LPWAB_PARAM lpwp = NULL;

                                        {
                                            LPWABMIGDLGPARAM lpwmdp = (LPWABMIGDLGPARAM) GetWindowLongPtr(hwnd, DWLP_USER);
                                            LPTSTR lpszFileName = lpwmdp->szFileName;
                                            wp.cbSize = sizeof(WAB_PARAM);
                                            wp.hwnd = hwnd;
                                            if(lstrlen(lpszFileName))
                                            {
                                                // we have a file name - use it to open the WAB
                                                wp.szFileName = lpszFileName;
                                                wp.ulFlags = 0;
                                            }
                                            else
                                            {
                                                wp.ulFlags = WAB_ENABLE_PROFILES;
                                            }
                                            lpwp = &wp;
                                        }

                                        hResult = lpfnWABOpen(&lpAdrBookWAB, &lpWABObject, lpwp, 0);
                                        if (SUCCEEDED(hResult))
                                        {
                                            if (hResult = lpfnWABImport(hwnd,
                                              lpAdrBookWAB,
                                              lpWABObject,
                                              (LPWAB_PROGRESS_CALLBACK)&ProgressCallback,
                                              &ImportOptions))
                                            {                                            
                                                switch (GetScode(hResult)) 
                                                {
                                                    case MAPI_E_USER_CANCEL:
                                                        ImportCancel(hwnd);
                                                        break;

                                                    case MAPI_E_BUSY:
                                                        ImportFileBusyError(hwnd);
                                                        break;
                                                    default:
                                                        ImportError(hwnd);
                                                        DebugTrace("Importer DLL returned %x\n", GetScode(hResult));
                                                        break;
                                                }

                                                fFinished = TRUE;
                                            }

                                            lpAdrBookWAB->lpVtbl->Release(lpAdrBookWAB);
                                            lpAdrBookWAB = NULL;
                                            lpWABObject->lpVtbl->Release(lpWABObject);
                                            lpWABObject = NULL;
                                            if (! fFinished)
                                            {
                                                // Make progress bar full.
                                                SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETRANGE, 0, MAKELPARAM(0, 100));
                                                SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETPOS, (WPARAM)100, 0);
                                                ImportFinish(hwnd);
                                            }
                                        }
                                        else
                                        {
                                            // Report fatal error
                                            TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
                                            TCHAR szBufferTitle[MAX_RESOURCE_STRING + 1];

                                            if (LoadString(hInst, IDS_STATE_IMPORT_ERROR, szBuffer, sizeof(szBuffer)))
                                            {
                                                SetDlgItemText(hwnd, IDC_Message, szBuffer);
                                                if (! LoadString(hInst, IDS_APP_TITLE, szBufferTitle, sizeof(szBufferTitle)))
                                                {
                                                    StrCpyN(szBufferTitle, "", ARRAYSIZE(szBufferTitle));
                                                }

                                                // Display a dialog telling user it's over
                                                MessageBox(hwnd, szBuffer,
                                                  szBufferTitle, MB_ICONINFORMATION | MB_OK);
                                            }

                                            fError = TRUE;
                                            ImportFinish(hwnd);
                                        }
                                    }
                                    __except (ec = GetExceptionCode(), EXCEPTION_EXECUTE_HANDLER)
                                    {
                                        DebugTrace("Exception 0x%08x in %s\n", ec, lpImportDll);
                                        if (HandleImportError(hwnd,
                                          IDS_ERROR_DLL_EXCEPTION,
                                          0,
                                          lpImportDll,
                                          NULL))
                                        {
                                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                            ImportCancel(hwnd);
                                        }
                                        else
                                        {
                                            ImportError(hwnd);
                                        }
                                    }
                                }
                            }
                        } else {
                            ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_SHOW);
                            PostMessage(hwnd, WM_COMMAND, ID_STATE_IMPORT_MU, 0);
                        }
                        FreeLibrary(hinstImportDll);                    
                    }
                    return(0);

                case IDC_Target:
                    switch (HIWORD(wParam)) {   // look for selection change
                        case LBN_SELCHANGE:
                            {
                                ULONG ulSelIndex, ulTableIndex;
                                TCHAR szCurSel[256];

                                // Enable the Import Button if it is disabled. The 'Import' Button is disabled initially.
                                HWND hButton = GetDlgItem(hwnd, IDC_Import);
                                if(hButton)
                                {
                                    if(!IsWindowEnabled(hButton))
                                        EnableWindow(hButton, TRUE);
                                }

                                //
                                // Get the text of the selected item in the listbox...
                                //
                                ulSelIndex = (ULONG) SendMessage((HWND)lParam, LB_GETCURSEL, 0, 0);
                                ulTableIndex = (ULONG) SendMessage((HWND)lParam, LB_GETITEMDATA, (WPARAM)ulSelIndex, 0);

                                SendMessage((HWND)lParam,
                                  LB_GETTEXT,
                                  (WPARAM)ulSelIndex,
                                  (LPARAM)szCurSel);
                                DebugTrace("Current selection is [%s]\n", szCurSel);

                                lpImportDll = rgTargetInfo[ulTableIndex].lpDll;
                                lpImportDesc = rgTargetInfo[ulTableIndex].lpDescription;
                                lpImportFn = rgTargetInfo[ulTableIndex].lpEntry;
                                lpImportName = rgTargetInfo[ulTableIndex].lpRegName;

                                SendMessage(hwnd, WM_SETREDRAW, TRUE, 0L);
                            }
                            break;

                        case LBN_DBLCLK:
                            PostMessage(hwnd, WM_COMMAND, (WPARAM)IDC_Import, 0);
                            break;
                    }
                    break;
                }
            break;

        case WM_CLOSE:
#ifdef OLD_STUFF
            if (fMigrating) {
                SendMessage(hwnd, WM_COMMAND, ID_STATE_IMPORT_FINISH, 0);
            }
#endif // OLD_STUFF
            EndDialog(hwnd, FALSE);
            return(0);

        case WM_DESTROY:
            FreeLBItemData(hwndLB);
            return(DefWindowProc(hwnd, message, wParam, lParam));

        default:
            return(FALSE);
    }

    return(TRUE);
}


/***************************************************************************

    Name      : HandleImportError

    Purpose   : Decides if a dialog needs to be displayed to
                indicate the failure and does so.

    Parameters: hwnd = main dialog window
                ids = String ID (optional: calculated from hResult if 0)
                hResult = Result of action
                lpDisplayName = display name of object that failed
                lpEmailAddress = email address of object that failed or NULL

    Returns   : TRUE if user requests ABORT.

    Comment   : Abort is not yet implemented in the dialog, but if you
                ever want to, just make this routine return TRUE;

***************************************************************************/
BOOL HandleImportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName, LPTSTR lpEmailAddress) {
    BOOL fAbort = FALSE;
    ERROR_INFO EI;

    if ((ids || hResult) && ! ImportOptions.fNoErrors) {
        if (ids == 0) {
            switch (GetScode(hResult)) {
                case WAB_W_BAD_EMAIL:
                    ids = lpEmailAddress ? IDS_ERROR_EMAIL_ADDRESS_2 : IDS_ERROR_EMAIL_ADDRESS_1;
                    break;

                case MAPI_E_NO_SUPPORT:
                    // Propbably failed to open contents on a distribution list
                    ids = IDS_ERROR_NO_SUPPORT;
                    break;

                case MAPI_E_USER_CANCEL:
                    return(TRUE);

                default:
                    if (HR_FAILED(hResult)) {
                        DebugTrace("Error Box for Hresult: 0x%08x\n", GetScode(hResult));
                        Assert(FALSE);      // want to know about it.
                        ids = IDS_ERROR_GENERAL;
                    }
                    break;
            }
        }

        EI.lpszDisplayName = lpDisplayName;
        EI.lpszEmailAddress = lpEmailAddress;
        EI.ErrorResult = ERROR_OK;
        EI.ids = ids;

        DialogBoxParam(hInst,
          MAKEINTRESOURCE(IDD_ErrorImport),
          hwnd,
          ErrorDialogProc,
          (LPARAM)&EI);

        fAbort = EI.ErrorResult == ERROR_ABORT;
    }

    return(fAbort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wabmig\emsabtag.h ===
/*
** --emsabtag.h---------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
**  Copyright (c) Microsoft Corp. 1986-1996. All rights reserved.
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*    
 * Flags for ulInterfaceOptions on OpenProperty   
 */
#define AB_SHOW_PHANTOMS                      2
#define AB_SHOW_OTHERS                            4

/*    
 * Flags for ulFlag on ResolveNames               
 */
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/* 
 * Constructed, but externally visible. 
 */
#define PR_EMS_AB_SERVER                      PROP_TAG(PT_TSTRING,      0xFFFE)
#define PR_EMS_AB_SERVER_A                    PROP_TAG(PT_STRING8,      0xFFFE)
#define PR_EMS_AB_SERVER_W                    PROP_TAG(PT_UNICODE,      0xFFFE)
#define PR_EMS_AB_CONTAINERID                 PROP_TAG(PT_LONG,         0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                 PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID              PROP_TAG(PT_BINARY,       0xFFFC)
#define PR_EMS_AB_IS_MASTER                   PROP_TAG(PT_BOOLEAN,      0xFFFB)
#define PR_EMS_AB_OBJECT_OID                  PROP_TAG(PT_BINARY,       0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH              PROP_TAG(PT_TSTRING,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A            PROP_TAG(PT_STRING8,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W            PROP_TAG(PT_UNICODE,      0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF8

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

/* 
 * Prop tags defined in the schema. 
 */
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE,      0x39FF)

#define PR_EMS_AB_ACCESS_CATEGORY             PROP_TAG(PT_LONG,         0x8044)
#define PR_EMS_AB_ACTIVATION_SCHEDULE         PROP_TAG(PT_BINARY,       0x8045)
#define PR_EMS_AB_ACTIVATION_STYLE            PROP_TAG(PT_LONG,         0x8046)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE PROP_TAG(PT_BINARY,       0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS PROP_TAG(PT_BINARY, 0x8047)
#define PR_EMS_AB_ADDRESS_SYNTAX              PROP_TAG(PT_BINARY,       0x8018)
#define PR_EMS_AB_ADDRESS_TYPE                PROP_TAG(PT_TSTRING,      0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A              PROP_TAG(PT_STRING8,      0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W              PROP_TAG(PT_UNICODE,      0x8048)
#define PR_EMS_AB_ADMD                        PROP_TAG(PT_TSTRING,      0x8049)
#define PR_EMS_AB_ADMD_A                      PROP_TAG(PT_STRING8,      0x8049)
#define PR_EMS_AB_ADMD_W                      PROP_TAG(PT_UNICODE,      0x8049)
#define PR_EMS_AB_ADMIN_DESCRIPTION           PROP_TAG(PT_TSTRING,      0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A         PROP_TAG(PT_STRING8,      0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W         PROP_TAG(PT_UNICODE,      0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME          PROP_TAG(PT_TSTRING,      0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A        PROP_TAG(PT_STRING8,      0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W        PROP_TAG(PT_UNICODE,      0x804B)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL         PROP_TAG(PT_TSTRING,      0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_A       PROP_TAG(PT_STRING8,      0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_W       PROP_TAG(PT_UNICODE,      0x804C)
#define PR_EMS_AB_ALIASED_OBJECT_NAME         PROP_TAG(PT_TSTRING,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_A       PROP_TAG(PT_STRING8,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_W       PROP_TAG(PT_UNICODE,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_O       PROP_TAG(PT_OBJECT,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_T       PROP_TAG(PT_TSTRING,      0x804D)
#define PR_EMS_AB_ALT_RECIPIENT               PROP_TAG(PT_TSTRING,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_A             PROP_TAG(PT_STRING8,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_W             PROP_TAG(PT_UNICODE,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_O             PROP_TAG(PT_OBJECT,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_T             PROP_TAG(PT_TSTRING,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_BL            PROP_TAG(PT_MV_TSTRING,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_A          PROP_TAG(PT_MV_STRING8,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_W          PROP_TAG(PT_MV_UNICODE,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_O          PROP_TAG(PT_OBJECT,       0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_T          PROP_TAG(PT_MV_TSTRING,   0x804F)
#define PR_EMS_AB_ANCESTOR_ID                 PROP_TAG(PT_BINARY,       0x8050)
#define PR_EMS_AB_ASSOC_NT_ACCOUNT            PROP_TAG(PT_BINARY,       0x8027)
#define PR_EMS_AB_ASSOC_REMOTE_DXA            PROP_TAG(PT_MV_TSTRING,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_A          PROP_TAG(PT_MV_STRING8,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_W          PROP_TAG(PT_MV_UNICODE,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_O          PROP_TAG(PT_OBJECT,       0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_T          PROP_TAG(PT_MV_TSTRING,   0x8051)
#define PR_EMS_AB_ASSOCIATION_LIFETIME        PROP_TAG(PT_LONG,         0x8052)
#define PR_EMS_AB_AUTH_ORIG_BL                PROP_TAG(PT_MV_TSTRING,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_A              PROP_TAG(PT_MV_STRING8,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_W              PROP_TAG(PT_MV_UNICODE,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_O              PROP_TAG(PT_OBJECT,       0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_T              PROP_TAG(PT_MV_TSTRING,   0x8053)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST   PROP_TAG(PT_MV_BINARY,    0x8026)
#define PR_EMS_AB_AUTHORIZED_DOMAIN           PROP_TAG(PT_TSTRING,      0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_A         PROP_TAG(PT_STRING8,      0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_W         PROP_TAG(PT_UNICODE,      0x8054)
#define PR_EMS_AB_AUTHORIZED_PASSWORD         PROP_TAG(PT_BINARY,       0x8055)
#define PR_EMS_AB_AUTHORIZED_USER             PROP_TAG(PT_TSTRING,      0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_A           PROP_TAG(PT_STRING8,      0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_W           PROP_TAG(PT_UNICODE,      0x8056)
#define PR_EMS_AB_AUTOREPLY                   PROP_TAG(PT_BOOLEAN,      0x800B)
#define PR_EMS_AB_AUTOREPLY_MESSAGE           PROP_TAG(PT_TSTRING,      0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_A         PROP_TAG(PT_STRING8,      0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_W         PROP_TAG(PT_UNICODE,      0x800A)
#define PR_EMS_AB_AUTOREPLY_SUBJECT           PROP_TAG(PT_TSTRING,      0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_A         PROP_TAG(PT_STRING8,      0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_W         PROP_TAG(PT_UNICODE,      0x803E)
#define PR_EMS_AB_BUSINESS_CATEGORY           PROP_TAG(PT_MV_TSTRING,   0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A         PROP_TAG(PT_MV_STRING8,   0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W         PROP_TAG(PT_MV_UNICODE,   0x8057)
#define PR_EMS_AB_BUSINESS_ROLES              PROP_TAG(PT_BINARY,       0x8023)
#define PR_EMS_AB_CA_CERTIFICATE              PROP_TAG(PT_MV_BINARY,    0x8003)
#define PR_EMS_AB_CAN_CREATE_PF               PROP_TAG(PT_MV_TSTRING,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_A             PROP_TAG(PT_MV_STRING8,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_W             PROP_TAG(PT_MV_UNICODE,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_O             PROP_TAG(PT_OBJECT,       0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_T             PROP_TAG(PT_MV_TSTRING,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_BL            PROP_TAG(PT_MV_TSTRING,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_A          PROP_TAG(PT_MV_STRING8,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_W          PROP_TAG(PT_MV_UNICODE,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_O          PROP_TAG(PT_OBJECT,       0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_T          PROP_TAG(PT_MV_TSTRING,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_DL            PROP_TAG(PT_MV_TSTRING,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_A          PROP_TAG(PT_MV_STRING8,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_W          PROP_TAG(PT_MV_UNICODE,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_O          PROP_TAG(PT_OBJECT,       0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_T          PROP_TAG(PT_MV_TSTRING,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL         PROP_TAG(PT_MV_TSTRING,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_A       PROP_TAG(PT_MV_STRING8,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_W       PROP_TAG(PT_MV_UNICODE,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_O       PROP_TAG(PT_OBJECT,       0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_T       PROP_TAG(PT_MV_TSTRING,   0x805B)
#define PR_EMS_AB_CAN_NOT_CREATE_PF           PROP_TAG(PT_MV_TSTRING,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_A         PROP_TAG(PT_MV_STRING8,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_W         PROP_TAG(PT_MV_UNICODE,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_O         PROP_TAG(PT_OBJECT,       0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_T         PROP_TAG(PT_MV_TSTRING,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL        PROP_TAG(PT_MV_TSTRING,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_A      PROP_TAG(PT_MV_STRING8,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_W      PROP_TAG(PT_MV_UNICODE,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_O      PROP_TAG(PT_OBJECT,       0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_T      PROP_TAG(PT_MV_TSTRING,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL        PROP_TAG(PT_MV_TSTRING,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_A      PROP_TAG(PT_MV_STRING8,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_W      PROP_TAG(PT_MV_UNICODE,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_O      PROP_TAG(PT_OBJECT,       0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_T      PROP_TAG(PT_MV_TSTRING,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL     PROP_TAG(PT_MV_TSTRING,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_A   PROP_TAG(PT_MV_STRING8,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_W   PROP_TAG(PT_MV_UNICODE,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_O   PROP_TAG(PT_OBJECT,       0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_T   PROP_TAG(PT_MV_TSTRING,   0x805F)
#define PR_EMS_AB_CAN_PRESERVE_DNS            PROP_TAG(PT_BOOLEAN,      0x8060)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST PROP_TAG(PT_BINARY,       0x8016)
#define PR_EMS_AB_CLOCK_ALERT_OFFSET          PROP_TAG(PT_LONG,         0x8061)
#define PR_EMS_AB_CLOCK_ALERT_REPAIR          PROP_TAG(PT_BOOLEAN,      0x8062)
#define PR_EMS_AB_CLOCK_WARNING_OFFSET        PROP_TAG(PT_LONG,         0x8063)
#define PR_EMS_AB_CLOCK_WARNING_REPAIR        PROP_TAG(PT_BOOLEAN,      0x8064)
#define PR_EMS_AB_COMPUTER_NAME               PROP_TAG(PT_TSTRING,      0x8065)
#define PR_EMS_AB_COMPUTER_NAME_A             PROP_TAG(PT_STRING8,      0x8065)
#define PR_EMS_AB_COMPUTER_NAME_W             PROP_TAG(PT_UNICODE,      0x8065)
#define PR_EMS_AB_CONNECTED_DOMAINS           PROP_TAG(PT_MV_TSTRING,   0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_A         PROP_TAG(PT_MV_STRING8,   0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_W         PROP_TAG(PT_MV_UNICODE,   0x8066)
#define PR_EMS_AB_CONTAINER_INFO              PROP_TAG(PT_LONG,         0x8067)
#define PR_EMS_AB_COST                        PROP_TAG(PT_LONG,         0x8068)
#define PR_EMS_AB_COUNTRY_NAME                PROP_TAG(PT_TSTRING,      0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A              PROP_TAG(PT_STRING8,      0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W              PROP_TAG(PT_UNICODE,      0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR      PROP_TAG(PT_MV_BINARY,    0x8025)
#define PR_EMS_AB_DELIV_CONT_LENGTH           PROP_TAG(PT_LONG,         0x806A)
#define PR_EMS_AB_DELIV_EITS                  PROP_TAG(PT_MV_BINARY,    0x806B)
#define PR_EMS_AB_DELIV_EXT_CONT_TYPES        PROP_TAG(PT_MV_BINARY,    0x806C)
#define PR_EMS_AB_DELIVER_AND_REDIRECT        PROP_TAG(PT_BOOLEAN,      0x806D)
#define PR_EMS_AB_DELIVERY_MECHANISM          PROP_TAG(PT_LONG,         0x806E)
#define PR_EMS_AB_DESCRIPTION                 PROP_TAG(PT_MV_TSTRING,   0x806F)
#define PR_EMS_AB_DESCRIPTION_A               PROP_TAG(PT_MV_STRING8,   0x806F)
#define PR_EMS_AB_DESCRIPTION_W               PROP_TAG(PT_MV_UNICODE,   0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR       PROP_TAG(PT_MV_TSTRING,   0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A     PROP_TAG(PT_MV_STRING8,   0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W     PROP_TAG(PT_MV_UNICODE,   0x8070)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY          PROP_TAG(PT_TSTRING,      0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_A        PROP_TAG(PT_STRING8,      0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_W        PROP_TAG(PT_UNICODE,      0x8071)
#define PR_EMS_AB_DISPLAY_NAME_OVERRIDE       PROP_TAG(PT_BOOLEAN,      0x8001)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL      PROP_TAG(PT_MV_TSTRING,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_A    PROP_TAG(PT_MV_STRING8,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_W    PROP_TAG(PT_MV_UNICODE,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_O    PROP_TAG(PT_OBJECT,       0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_T    PROP_TAG(PT_MV_TSTRING,   0x8072)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL      PROP_TAG(PT_MV_TSTRING,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_A    PROP_TAG(PT_MV_STRING8,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_W    PROP_TAG(PT_MV_UNICODE,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_O    PROP_TAG(PT_OBJECT,       0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_T    PROP_TAG(PT_MV_TSTRING,   0x8073)
#define PR_EMS_AB_DL_MEMBER_RULE              PROP_TAG(PT_MV_BINARY,    0x8074)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP        PROP_TAG(PT_TSTRING,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_A      PROP_TAG(PT_STRING8,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_W      PROP_TAG(PT_UNICODE,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_O      PROP_TAG(PT_OBJECT,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_T      PROP_TAG(PT_TSTRING,      0x8075)
#define PR_EMS_AB_DOMAIN_NAME                 PROP_TAG(PT_TSTRING,      0x8076)
#define PR_EMS_AB_DOMAIN_NAME_A               PROP_TAG(PT_STRING8,      0x8076)
#define PR_EMS_AB_DOMAIN_NAME_W               PROP_TAG(PT_UNICODE,      0x8076)
#define PR_EMS_AB_DSA_SIGNATURE               PROP_TAG(PT_BINARY,       0x8077)
#define PR_EMS_AB_DXA_ADMIN_COPY              PROP_TAG(PT_BOOLEAN,      0x8078)
#define PR_EMS_AB_DXA_ADMIN_FORWARD           PROP_TAG(PT_BOOLEAN,      0x8079)
#define PR_EMS_AB_DXA_ADMIN_UPDATE            PROP_TAG(PT_LONG,         0x807A)
#define PR_EMS_AB_DXA_APPEND_REQCN            PROP_TAG(PT_BOOLEAN,      0x807B)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST     PROP_TAG(PT_MV_TSTRING,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_A   PROP_TAG(PT_MV_STRING8,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_W   PROP_TAG(PT_MV_UNICODE,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_O   PROP_TAG(PT_OBJECT,       0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_T   PROP_TAG(PT_MV_TSTRING,   0x807C)
#define PR_EMS_AB_DXA_CONF_REQ_TIME           PROP_TAG(PT_SYSTIME,      0x807D)
#define PR_EMS_AB_DXA_CONF_SEQ                PROP_TAG(PT_TSTRING,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_A              PROP_TAG(PT_STRING8,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_W              PROP_TAG(PT_UNICODE,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_USN            PROP_TAG(PT_LONG,         0x807F)
#define PR_EMS_AB_DXA_EXCHANGE_OPTIONS        PROP_TAG(PT_LONG,         0x8080)
#define PR_EMS_AB_DXA_EXPORT_NOW              PROP_TAG(PT_BOOLEAN,      0x8081)
#define PR_EMS_AB_DXA_FLAGS                   PROP_TAG(PT_LONG,         0x8082)
#define PR_EMS_AB_DXA_IMP_SEQ                 PROP_TAG(PT_TSTRING,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_A               PROP_TAG(PT_STRING8,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_W               PROP_TAG(PT_UNICODE,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x8084)
#define PR_EMS_AB_DXA_IMP_SEQ_USN             PROP_TAG(PT_LONG,         0x8085)
#define PR_EMS_AB_DXA_IMPORT_NOW              PROP_TAG(PT_BOOLEAN,      0x8086)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP         PROP_TAG(PT_MV_TSTRING,   0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_A       PROP_TAG(PT_MV_STRING8,   0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_W       PROP_TAG(PT_MV_UNICODE,   0x8087)
#define PR_EMS_AB_DXA_LOCAL_ADMIN             PROP_TAG(PT_TSTRING,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_A           PROP_TAG(PT_STRING8,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_W           PROP_TAG(PT_UNICODE,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_O           PROP_TAG(PT_OBJECT,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_T           PROP_TAG(PT_TSTRING,      0x8088)
#define PR_EMS_AB_DXA_LOGGING_LEVEL           PROP_TAG(PT_LONG,         0x8089)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE     PROP_TAG(PT_TSTRING,      0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_A   PROP_TAG(PT_STRING8,      0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_W   PROP_TAG(PT_UNICODE,      0x808A)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP        PROP_TAG(PT_MV_TSTRING,   0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_A      PROP_TAG(PT_MV_STRING8,   0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_W      PROP_TAG(PT_MV_UNICODE,   0x808B)
#define PR_EMS_AB_DXA_PASSWORD                PROP_TAG(PT_TSTRING,      0x808C)
#define PR_EMS_AB_DXA_PASSWORD_A              PROP_TAG(PT_STRING8,      0x808C)
#define PR_EMS_AB_DXA_PASSWORD_W              PROP_TAG(PT_UNICODE,      0x808C)
#define PR_EMS_AB_DXA_PREV_EXCHANGE_OPTIONS   PROP_TAG(PT_LONG,         0x808D)
#define PR_EMS_AB_DXA_PREV_EXPORT_NATIVE_ONLY PROP_TAG(PT_BOOLEAN,      0x808E)
#define PR_EMS_AB_DXA_PREV_IN_EXCHANGE_SENSITIVITY PROP_TAG(PT_LONG,    0x808F)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES     PROP_TAG(PT_TSTRING,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_A   PROP_TAG(PT_STRING8,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_W   PROP_TAG(PT_UNICODE,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_O   PROP_TAG(PT_OBJECT,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_T   PROP_TAG(PT_TSTRING,      0x8090)
#define PR_EMS_AB_DXA_PREV_REPLICATION_SENSITIVITY PROP_TAG(PT_LONG,    0x8091)
#define PR_EMS_AB_DXA_PREV_TEMPLATE_OPTIONS   PROP_TAG(PT_LONG,         0x8092)
#define PR_EMS_AB_DXA_PREV_TYPES              PROP_TAG(PT_LONG,         0x8093)
#define PR_EMS_AB_DXA_RECIPIENT_CP            PROP_TAG(PT_TSTRING,      0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_A          PROP_TAG(PT_STRING8,      0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_W          PROP_TAG(PT_UNICODE,      0x8094)
#define PR_EMS_AB_DXA_REMOTE_CLIENT           PROP_TAG(PT_TSTRING,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_A         PROP_TAG(PT_STRING8,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_W         PROP_TAG(PT_UNICODE,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_O         PROP_TAG(PT_OBJECT,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_T         PROP_TAG(PT_TSTRING,      0x8095)
#define PR_EMS_AB_DXA_REQ_SEQ                 PROP_TAG(PT_TSTRING,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_A               PROP_TAG(PT_STRING8,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_W               PROP_TAG(PT_UNICODE,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x8097)
#define PR_EMS_AB_DXA_REQ_SEQ_USN             PROP_TAG(PT_LONG,         0x8098)
#define PR_EMS_AB_DXA_REQNAME                 PROP_TAG(PT_TSTRING,      0x8099)
#define PR_EMS_AB_DXA_REQNAME_A               PROP_TAG(PT_STRING8,      0x8099)
#define PR_EMS_AB_DXA_REQNAME_W               PROP_TAG(PT_UNICODE,      0x8099)
#define PR_EMS_AB_DXA_SVR_SEQ                 PROP_TAG(PT_TSTRING,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_A               PROP_TAG(PT_STRING8,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_W               PROP_TAG(PT_UNICODE,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x809B)
#define PR_EMS_AB_DXA_SVR_SEQ_USN             PROP_TAG(PT_LONG,         0x809C)
#define PR_EMS_AB_DXA_TASK                    PROP_TAG(PT_LONG,         0x809D)
#define PR_EMS_AB_DXA_TEMPLATE_OPTIONS        PROP_TAG(PT_LONG,         0x809E)
#define PR_EMS_AB_DXA_TEMPLATE_TIMESTAMP      PROP_TAG(PT_SYSTIME,      0x809F)
#define PR_EMS_AB_DXA_TYPES                   PROP_TAG(PT_LONG,         0x80A0)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST   PROP_TAG(PT_MV_TSTRING,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_A PROP_TAG(PT_MV_STRING8,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_W PROP_TAG(PT_MV_UNICODE,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_O PROP_TAG(PT_OBJECT,       0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_T PROP_TAG(PT_MV_TSTRING,   0x80A1)
#define PR_EMS_AB_ENCAPSULATION_METHOD        PROP_TAG(PT_LONG,         0x80A2)
#define PR_EMS_AB_ENCRYPT                     PROP_TAG(PT_BOOLEAN,      0x80A3)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA         PROP_TAG(PT_MV_TSTRING,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_A       PROP_TAG(PT_MV_STRING8,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_W       PROP_TAG(PT_MV_UNICODE,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER      PROP_TAG(PT_MV_TSTRING,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_A    PROP_TAG(PT_MV_STRING8,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_W    PROP_TAG(PT_MV_UNICODE,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA     PROP_TAG(PT_TSTRING,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_A   PROP_TAG(PT_STRING8,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_W   PROP_TAG(PT_UNICODE,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER  PROP_TAG(PT_TSTRING,      0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_A PROP_TAG(PT_STRING8,     0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_W PROP_TAG(PT_UNICODE,     0x803D)
#define PR_EMS_AB_EXPAND_DLS_LOCALLY          PROP_TAG(PT_BOOLEAN,      0x80A4)
#define PR_EMS_AB_EXPIRATION_TIME             PROP_TAG(PT_SYSTIME,      0x8028)
#define PR_EMS_AB_EXPORT_CONTAINERS           PROP_TAG(PT_MV_TSTRING,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_A         PROP_TAG(PT_MV_STRING8,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_W         PROP_TAG(PT_MV_UNICODE,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_O         PROP_TAG(PT_OBJECT,       0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_T         PROP_TAG(PT_MV_TSTRING,   0x80A5)
#define PR_EMS_AB_EXPORT_CUSTOM_RECIPIENTS    PROP_TAG(PT_BOOLEAN,      0x80A6)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED      PROP_TAG(PT_BOOLEAN,      0x80A7)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1       PROP_TAG(PT_TSTRING,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_A     PROP_TAG(PT_STRING8,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_W     PROP_TAG(PT_UNICODE,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10      PROP_TAG(PT_TSTRING,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_A    PROP_TAG(PT_STRING8,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_W    PROP_TAG(PT_UNICODE,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2       PROP_TAG(PT_TSTRING,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_A     PROP_TAG(PT_STRING8,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_W     PROP_TAG(PT_UNICODE,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3       PROP_TAG(PT_TSTRING,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_A     PROP_TAG(PT_STRING8,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_W     PROP_TAG(PT_UNICODE,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4       PROP_TAG(PT_TSTRING,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_A     PROP_TAG(PT_STRING8,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_W     PROP_TAG(PT_UNICODE,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5       PROP_TAG(PT_TSTRING,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_A     PROP_TAG(PT_STRING8,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_W     PROP_TAG(PT_UNICODE,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6       PROP_TAG(PT_TSTRING,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_A     PROP_TAG(PT_STRING8,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_W     PROP_TAG(PT_UNICODE,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7       PROP_TAG(PT_TSTRING,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_A     PROP_TAG(PT_STRING8,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_W     PROP_TAG(PT_UNICODE,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8       PROP_TAG(PT_TSTRING,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_A     PROP_TAG(PT_STRING8,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_W     PROP_TAG(PT_UNICODE,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9       PROP_TAG(PT_TSTRING,      0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_A     PROP_TAG(PT_STRING8,      0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_W     PROP_TAG(PT_UNICODE,      0x8035)
#define PR_EMS_AB_EXTENSION_DATA              PROP_TAG(PT_MV_BINARY,    0x80A8)
#define PR_EMS_AB_EXTENSION_NAME              PROP_TAG(PT_MV_TSTRING,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A            PROP_TAG(PT_MV_STRING8,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W            PROP_TAG(PT_MV_UNICODE,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED    PROP_TAG(PT_MV_TSTRING,   0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_A  PROP_TAG(PT_MV_STRING8,   0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_W  PROP_TAG(PT_MV_UNICODE,   0x80AA)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER  PROP_TAG(PT_MV_BINARY,    0x80AB)
#define PR_EMS_AB_FILE_VERSION                PROP_TAG(PT_BINARY,       0x80AC)
#define PR_EMS_AB_FILTER_LOCAL_ADDRESSES      PROP_TAG(PT_BOOLEAN,      0x80AD)
#define PR_EMS_AB_FOLDER_PATHNAME             PROP_TAG(PT_TSTRING,      0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_A           PROP_TAG(PT_STRING8,      0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_W           PROP_TAG(PT_UNICODE,      0x8004)
#define PR_EMS_AB_FOLDERS_CONTAINER           PROP_TAG(PT_TSTRING,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_A         PROP_TAG(PT_STRING8,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_W         PROP_TAG(PT_UNICODE,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_O         PROP_TAG(PT_OBJECT,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_T         PROP_TAG(PT_TSTRING,      0x80AE)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD         PROP_TAG(PT_LONG,         0x80AF)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED          PROP_TAG(PT_TSTRING,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_A        PROP_TAG(PT_STRING8,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_W        PROP_TAG(PT_UNICODE,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG         PROP_TAG(PT_TSTRING,      0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_A       PROP_TAG(PT_STRING8,      0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_W       PROP_TAG(PT_UNICODE,      0x80B1)
#define PR_EMS_AB_GATEWAY_PROXY               PROP_TAG(PT_MV_TSTRING,   0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_A             PROP_TAG(PT_MV_STRING8,   0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_W             PROP_TAG(PT_MV_UNICODE,   0x80B2)
#define PR_EMS_AB_GATEWAY_ROUTING_TREE        PROP_TAG(PT_BINARY,       0x80B3)
#define PR_EMS_AB_GWART_LAST_MODIFIED         PROP_TAG(PT_SYSTIME,      0x80B4)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS        PROP_TAG(PT_MV_TSTRING,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_A      PROP_TAG(PT_MV_STRING8,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_W      PROP_TAG(PT_MV_UNICODE,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_O      PROP_TAG(PT_OBJECT,       0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_T      PROP_TAG(PT_MV_TSTRING,   0x80B5)
#define PR_EMS_AB_HAS_MASTER_NCS              PROP_TAG(PT_MV_TSTRING,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A            PROP_TAG(PT_MV_STRING8,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W            PROP_TAG(PT_MV_UNICODE,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O            PROP_TAG(PT_OBJECT,       0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T            PROP_TAG(PT_MV_TSTRING,   0x80B6)
#define PR_EMS_AB_HELP_DATA16                 PROP_TAG(PT_BINARY,       0x803A)
#define PR_EMS_AB_HELP_DATA32                 PROP_TAG(PT_BINARY,       0x8010)
#define PR_EMS_AB_HELP_FILE_NAME              PROP_TAG(PT_TSTRING,      0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A            PROP_TAG(PT_STRING8,      0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W            PROP_TAG(PT_UNICODE,      0x803B)
#define PR_EMS_AB_HEURISTICS                  PROP_TAG(PT_LONG,         0x80B7)
#define PR_EMS_AB_HIDE_DL_MEMBERSHIP          PROP_TAG(PT_BOOLEAN,      0x80B8)
#define PR_EMS_AB_HIDE_FROM_ADDRESS_BOOK      PROP_TAG(PT_BOOLEAN,      0x80B9)
#define PR_EMS_AB_HOME_MDB                    PROP_TAG(PT_TSTRING,      0x8006)
#define PR_EMS_AB_HOME_MDB_A                  PROP_TAG(PT_STRING8,      0x8006)
#define PR_EMS_AB_HOME_MDB_W                  PROP_TAG(PT_UNICODE,      0x8006)
#define PR_EMS_AB_HOME_MDB_O                  PROP_TAG(PT_OBJECT,       0x8006)
#define PR_EMS_AB_HOME_MDB_T                  PROP_TAG(PT_TSTRING,      0x8006)
#define PR_EMS_AB_HOME_MDB_BL                 PROP_TAG(PT_MV_TSTRING,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_A               PROP_TAG(PT_MV_STRING8,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_W               PROP_TAG(PT_MV_UNICODE,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_O               PROP_TAG(PT_OBJECT,       0x8014)
#define PR_EMS_AB_HOME_MDB_BL_T               PROP_TAG(PT_MV_TSTRING,   0x8014)
#define PR_EMS_AB_HOME_MTA                    PROP_TAG(PT_TSTRING,      0x8007)
#define PR_EMS_AB_HOME_MTA_A                  PROP_TAG(PT_STRING8,      0x8007)
#define PR_EMS_AB_HOME_MTA_W                  PROP_TAG(PT_UNICODE,      0x8007)
#define PR_EMS_AB_HOME_MTA_O                  PROP_TAG(PT_OBJECT,       0x8007)
#define PR_EMS_AB_HOME_MTA_T                  PROP_TAG(PT_TSTRING,      0x8007)
#define PR_EMS_AB_HOME_PUBLIC_SERVER          PROP_TAG(PT_TSTRING,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_A        PROP_TAG(PT_STRING8,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_W        PROP_TAG(PT_UNICODE,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_O        PROP_TAG(PT_OBJECT,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_T        PROP_TAG(PT_TSTRING,      0x803F)
#define PR_EMS_AB_IMPORT_CONTAINER            PROP_TAG(PT_TSTRING,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_A          PROP_TAG(PT_STRING8,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_W          PROP_TAG(PT_UNICODE,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_O          PROP_TAG(PT_OBJECT,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_T          PROP_TAG(PT_TSTRING,      0x80BA)
#define PR_EMS_AB_IMPORT_SENSITIVITY          PROP_TAG(PT_LONG,         0x80BB)
#define PR_EMS_AB_IMPORTED_FROM               PROP_TAG(PT_TSTRING,      0x8042)
#define PR_EMS_AB_IMPORTED_FROM_A             PROP_TAG(PT_STRING8,      0x8042)
#define PR_EMS_AB_IMPORTED_FROM_W             PROP_TAG(PT_UNICODE,      0x8042)
#define PR_EMS_AB_INBOUND_SITES               PROP_TAG(PT_MV_TSTRING,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_A             PROP_TAG(PT_MV_STRING8,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_W             PROP_TAG(PT_MV_UNICODE,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_O             PROP_TAG(PT_OBJECT,       0x80BC)
#define PR_EMS_AB_INBOUND_SITES_T             PROP_TAG(PT_MV_TSTRING,   0x80BC)
#define PR_EMS_AB_INSTANCE_TYPE               PROP_TAG(PT_LONG,         0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER   PROP_TAG(PT_MV_TSTRING,   0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A PROP_TAG(PT_MV_STRING8,   0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W PROP_TAG(PT_MV_UNICODE,   0x80BE)
#define PR_EMS_AB_INVOCATION_ID               PROP_TAG(PT_BINARY,       0x80BF)
#define PR_EMS_AB_IS_DELETED                  PROP_TAG(PT_BOOLEAN,      0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL             PROP_TAG(PT_OBJECT,       0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A           PROP_TAG(PT_MV_STRING8,   0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W           PROP_TAG(PT_MV_UNICODE,   0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O           PROP_TAG(PT_OBJECT,       0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T           PROP_TAG(PT_MV_TSTRING,   0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED            PROP_TAG(PT_BOOLEAN,      0x80C1)
#define PR_EMS_AB_KCC_STATUS                  PROP_TAG(PT_MV_BINARY,    0x80C2)
#define PR_EMS_AB_KM_SERVER                   PROP_TAG(PT_TSTRING,      0x800D)
#define PR_EMS_AB_KM_SERVER_A                 PROP_TAG(PT_STRING8,      0x800D)
#define PR_EMS_AB_KM_SERVER_W                 PROP_TAG(PT_UNICODE,      0x800D)
#define PR_EMS_AB_KM_SERVER_O                 PROP_TAG(PT_OBJECT,       0x800D)
#define PR_EMS_AB_KM_SERVER_T                 PROP_TAG(PT_TSTRING,      0x800D)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION       PROP_TAG(PT_MV_TSTRING,   0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A     PROP_TAG(PT_MV_STRING8,   0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W     PROP_TAG(PT_MV_UNICODE,   0x80C3)
#define PR_EMS_AB_LINE_WRAP                   PROP_TAG(PT_LONG,         0x80C4)
#define PR_EMS_AB_LINK_ID                     PROP_TAG(PT_LONG,         0x80C5)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD           PROP_TAG(PT_TSTRING,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_A         PROP_TAG(PT_STRING8,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_W         PROP_TAG(PT_UNICODE,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS   PROP_TAG(PT_TSTRING,      0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_A PROP_TAG(PT_STRING8,      0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_W PROP_TAG(PT_UNICODE,      0x80C7)
#define PR_EMS_AB_LOCAL_INITIAL_TURN          PROP_TAG(PT_BOOLEAN,      0x80C8)
#define PR_EMS_AB_LOCAL_SCOPE                 PROP_TAG(PT_MV_TSTRING,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_A               PROP_TAG(PT_MV_STRING8,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_W               PROP_TAG(PT_MV_UNICODE,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_O               PROP_TAG(PT_OBJECT,       0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_T               PROP_TAG(PT_MV_TSTRING,   0x80C9)
#define PR_EMS_AB_LOG_FILENAME                PROP_TAG(PT_TSTRING,      0x80CA)
#define PR_EMS_AB_LOG_FILENAME_A              PROP_TAG(PT_STRING8,      0x80CA)
#define PR_EMS_AB_LOG_FILENAME_W              PROP_TAG(PT_UNICODE,      0x80CA)
#define PR_EMS_AB_LOG_ROLLOVER_INTERVAL       PROP_TAG(PT_LONG,         0x80CB)
#define PR_EMS_AB_MAINTAIN_AUTOREPLY_HISTORY  PROP_TAG(PT_BOOLEAN,      0x80CC)
#define PR_EMS_AB_MANAGER                     PROP_TAG(PT_OBJECT,       0x8005)
#define PR_EMS_AB_MANAGER_A                   PROP_TAG(PT_STRING8,      0x8005)
#define PR_EMS_AB_MANAGER_W                   PROP_TAG(PT_UNICODE,      0x8005)
#define PR_EMS_AB_MANAGER_O                   PROP_TAG(PT_OBJECT,       0x8005)
#define PR_EMS_AB_MANAGER_T                   PROP_TAG(PT_TSTRING,      0x8005)
#define PR_EMS_AB_MAPI_DISPLAY_TYPE           PROP_TAG(PT_LONG,         0x80CD)
#define PR_EMS_AB_MAPI_ID                     PROP_TAG(PT_LONG,         0x80CE)
#define PR_EMS_AB_MAXIMUM_OBJECT_ID           PROP_TAG(PT_BINARY,       0x8169)
#define PR_EMS_AB_MDB_BACKOFF_INTERVAL        PROP_TAG(PT_LONG,         0x80CF)
#define PR_EMS_AB_MDB_MSG_TIME_OUT_PERIOD     PROP_TAG(PT_LONG,         0x80D0)
#define PR_EMS_AB_MDB_OVER_QUOTA_LIMIT        PROP_TAG(PT_LONG,         0x80D1)
#define PR_EMS_AB_MDB_STORAGE_QUOTA           PROP_TAG(PT_LONG,         0x80D2)
#define PR_EMS_AB_MDB_UNREAD_LIMIT            PROP_TAG(PT_LONG,         0x80D3)
#define PR_EMS_AB_MDB_USE_DEFAULTS            PROP_TAG(PT_BOOLEAN,      0x80D4)
#define PR_EMS_AB_MEMBER                      PROP_TAG(PT_OBJECT,       0x8009)
#define PR_EMS_AB_MEMBER_A                    PROP_TAG(PT_MV_STRING8,   0x8009)
#define PR_EMS_AB_MEMBER_W                    PROP_TAG(PT_MV_UNICODE,   0x8009)
#define PR_EMS_AB_MEMBER_O                    PROP_TAG(PT_OBJECT,       0x8009)
#define PR_EMS_AB_MEMBER_T                    PROP_TAG(PT_MV_TSTRING,   0x8009)
#define PR_EMS_AB_MESSAGE_TRACKING_ENABLED    PROP_TAG(PT_BOOLEAN,      0x80D5)
#define PR_EMS_AB_MONITOR_CLOCK               PROP_TAG(PT_BOOLEAN,      0x80D6)
#define PR_EMS_AB_MONITOR_SERVERS             PROP_TAG(PT_BOOLEAN,      0x80D7)
#define PR_EMS_AB_MONITOR_SERVICES            PROP_TAG(PT_BOOLEAN,      0x80D8)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS    PROP_TAG(PT_MV_TSTRING,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_A  PROP_TAG(PT_MV_STRING8,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_W  PROP_TAG(PT_MV_UNICODE,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_O  PROP_TAG(PT_OBJECT,       0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_T  PROP_TAG(PT_MV_TSTRING,   0x80D9)
#define PR_EMS_AB_MONITORED_SERVERS           PROP_TAG(PT_MV_TSTRING,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_A         PROP_TAG(PT_MV_STRING8,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_W         PROP_TAG(PT_MV_UNICODE,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_O         PROP_TAG(PT_OBJECT,       0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_T         PROP_TAG(PT_MV_TSTRING,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVICES          PROP_TAG(PT_MV_TSTRING,   0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_A        PROP_TAG(PT_MV_STRING8,   0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_W        PROP_TAG(PT_MV_UNICODE,   0x80DB)
#define PR_EMS_AB_MONITORING_ALERT_DELAY      PROP_TAG(PT_LONG,         0x80DC)
#define PR_EMS_AB_MONITORING_ALERT_UNITS      PROP_TAG(PT_LONG,         0x80DD)
#define PR_EMS_AB_MONITORING_AVAILABILITY_STYLE PROP_TAG(PT_LONG,       0x80DE)
#define PR_EMS_AB_MONITORING_AVAILABILITY_WINDOW PROP_TAG(PT_BINARY,    0x80DF)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL  PROP_TAG(PT_MV_TSTRING,   0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_A PROP_TAG(PT_MV_STRING8,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_W PROP_TAG(PT_MV_UNICODE,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_O PROP_TAG(PT_OBJECT,      0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_T PROP_TAG(PT_MV_TSTRING,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC   PROP_TAG(PT_MV_TSTRING,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_A PROP_TAG(PT_MV_STRING8,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_W PROP_TAG(PT_MV_UNICODE,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_O PROP_TAG(PT_OBJECT,       0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_T PROP_TAG(PT_MV_TSTRING,   0x80E1)
#define PR_EMS_AB_MONITORING_ESCALATION_PROCEDURE PROP_TAG(PT_MV_BINARY,0x80E2)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_INTERVAL PROP_TAG(PT_LONG,    0x80E3)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_UNITS PROP_TAG(PT_LONG,       0x80E4)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_INTERVAL PROP_TAG(PT_LONG,     0x80E5)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_UNITS PROP_TAG(PT_LONG,        0x80E6)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_INTERVAL PROP_TAG(PT_LONG,     0x80E7)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_UNITS PROP_TAG(PT_LONG,        0x80E8)
#define PR_EMS_AB_MONITORING_RECIPIENTS       PROP_TAG(PT_MV_TSTRING,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_A     PROP_TAG(PT_MV_STRING8,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_W     PROP_TAG(PT_MV_UNICODE,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_O     PROP_TAG(PT_OBJECT,       0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_T     PROP_TAG(PT_MV_TSTRING,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR   PROP_TAG(PT_MV_TSTRING,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_A PROP_TAG(PT_MV_STRING8,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_W PROP_TAG(PT_MV_UNICODE,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_O PROP_TAG(PT_OBJECT,       0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_T PROP_TAG(PT_MV_TSTRING,   0x80EA)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_INTERVAL PROP_TAG(PT_LONG,      0x80EB)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_UNITS PROP_TAG(PT_LONG,         0x80EC)
#define PR_EMS_AB_MONITORING_WARNING_DELAY    PROP_TAG(PT_LONG,         0x80ED)
#define PR_EMS_AB_MONITORING_WARNING_UNITS    PROP_TAG(PT_LONG,         0x80EE)
#define PR_EMS_AB_MTA_LOCAL_CRED              PROP_TAG(PT_TSTRING,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_A            PROP_TAG(PT_STRING8,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_W            PROP_TAG(PT_UNICODE,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_DESIG             PROP_TAG(PT_TSTRING,      0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_A           PROP_TAG(PT_STRING8,      0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_W           PROP_TAG(PT_UNICODE,      0x80F0)
#define PR_EMS_AB_N_ADDRESS                   PROP_TAG(PT_BINARY,       0x80F1)
#define PR_EMS_AB_N_ADDRESS_TYPE              PROP_TAG(PT_LONG,         0x80F2)
#define PR_EMS_AB_NETWORK_ADDRESS             PROP_TAG(PT_MV_TSTRING,   0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A           PROP_TAG(PT_MV_STRING8,   0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W           PROP_TAG(PT_MV_UNICODE,   0x8170)
#define PR_EMS_AB_NT_MACHINE_NAME             PROP_TAG(PT_TSTRING,      0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_A           PROP_TAG(PT_STRING8,      0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_W           PROP_TAG(PT_UNICODE,      0x80F3)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR      PROP_TAG(PT_BINARY,       0x8013)
#define PR_EMS_AB_NUM_OF_OPEN_RETRIES         PROP_TAG(PT_LONG,         0x80F4)
#define PR_EMS_AB_NUM_OF_TRANSFER_RETRIES     PROP_TAG(PT_LONG,         0x80F5)
#define PR_EMS_AB_OBJ_DIST_NAME               PROP_TAG(PT_TSTRING,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A             PROP_TAG(PT_STRING8,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W             PROP_TAG(PT_UNICODE,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O             PROP_TAG(PT_OBJECT,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T             PROP_TAG(PT_TSTRING,      0x803C)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY       PROP_TAG(PT_LONG,         0x80F6)
#define PR_EMS_AB_OBJECT_VERSION              PROP_TAG(PT_LONG,         0x80F7)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS      PROP_TAG(PT_MV_TSTRING,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_A    PROP_TAG(PT_MV_STRING8,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_W    PROP_TAG(PT_MV_UNICODE,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_O    PROP_TAG(PT_OBJECT,       0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_T    PROP_TAG(PT_MV_TSTRING,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_SCHEDULE        PROP_TAG(PT_BINARY,       0x80F9)
#define PR_EMS_AB_OFF_LINE_AB_SERVER          PROP_TAG(PT_TSTRING,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_A        PROP_TAG(PT_STRING8,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_W        PROP_TAG(PT_UNICODE,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_O        PROP_TAG(PT_OBJECT,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_T        PROP_TAG(PT_TSTRING,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_STYLE           PROP_TAG(PT_LONG,         0x80FB)
#define PR_EMS_AB_OID_TYPE                    PROP_TAG(PT_LONG,         0x80FC)
#define PR_EMS_AB_OM_OBJECT_CLASS             PROP_TAG(PT_BINARY,       0x80FD)
#define PR_EMS_AB_OM_SYNTAX                   PROP_TAG(PT_LONG,         0x80FE)
#define PR_EMS_AB_OOF_REPLY_TO_ORIGINATOR     PROP_TAG(PT_BOOLEAN,      0x80FF)
#define PR_EMS_AB_OPEN_RETRY_INTERVAL         PROP_TAG(PT_LONG,         0x8100)
#define PR_EMS_AB_ORGANIZATION_NAME           PROP_TAG(PT_MV_TSTRING,   0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A         PROP_TAG(PT_MV_STRING8,   0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W         PROP_TAG(PT_MV_UNICODE,   0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME    PROP_TAG(PT_MV_TSTRING,   0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A  PROP_TAG(PT_MV_STRING8,   0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W  PROP_TAG(PT_MV_UNICODE,   0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE      PROP_TAG(PT_BINARY,       0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS PROP_TAG(PT_BINARY,      0x8104)
#define PR_EMS_AB_OUTBOUND_SITES              PROP_TAG(PT_MV_TSTRING,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_A            PROP_TAG(PT_MV_STRING8,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_W            PROP_TAG(PT_MV_UNICODE,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_O            PROP_TAG(PT_OBJECT,       0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_T            PROP_TAG(PT_MV_TSTRING,   0x8105)
#define PR_EMS_AB_OWNER                       PROP_TAG(PT_TSTRING,      0x800C)
#define PR_EMS_AB_OWNER_A                     PROP_TAG(PT_STRING8,      0x800C)
#define PR_EMS_AB_OWNER_W                     PROP_TAG(PT_UNICODE,      0x800C)
#define PR_EMS_AB_OWNER_O                     PROP_TAG(PT_OBJECT,       0x800C)
#define PR_EMS_AB_OWNER_T                     PROP_TAG(PT_TSTRING,      0x800C)
#define PR_EMS_AB_OWNER_BL                    PROP_TAG(PT_TSTRING,      0x8024)
#define PR_EMS_AB_OWNER_BL_A                  PROP_TAG(PT_STRING8,      0x8024)
#define PR_EMS_AB_OWNER_BL_W                  PROP_TAG(PT_UNICODE,      0x8024)
#define PR_EMS_AB_OWNER_BL_O                  PROP_TAG(PT_OBJECT,       0x8024)
#define PR_EMS_AB_OWNER_BL_T                  PROP_TAG(PT_TSTRING,      0x8024)
#define PR_EMS_AB_P_SELECTOR                  PROP_TAG(PT_BINARY,       0x8106)
#define PR_EMS_AB_P_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x8107)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE PROP_TAG(PT_BINARY,      0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE PROP_TAG(PT_BINARY,    0x8109)
#define PR_EMS_AB_PERIOD_REP_SYNC_TIMES       PROP_TAG(PT_BINARY,       0x810A)
#define PR_EMS_AB_PERIOD_REPL_STAGGER         PROP_TAG(PT_LONG,         0x810B)
#define PR_EMS_AB_PF_CONTACTS                 PROP_TAG(PT_MV_TSTRING,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_A               PROP_TAG(PT_MV_STRING8,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_W               PROP_TAG(PT_MV_UNICODE,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_O               PROP_TAG(PT_OBJECT,       0x8038)
#define PR_EMS_AB_PF_CONTACTS_T               PROP_TAG(PT_MV_TSTRING,   0x8038)
#define PR_EMS_AB_POSTAL_ADDRESS              PROP_TAG(PT_MV_BINARY,    0x810C)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD   PROP_TAG(PT_MV_LONG,      0x810D)
#define PR_EMS_AB_PRMD                        PROP_TAG(PT_TSTRING,      0x810E)
#define PR_EMS_AB_PRMD_A                      PROP_TAG(PT_STRING8,      0x810E)
#define PR_EMS_AB_PRMD_W                      PROP_TAG(PT_UNICODE,      0x810E)
#define PR_EMS_AB_PROXY_ADDRESSES             PROP_TAG(PT_MV_TSTRING,   0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A           PROP_TAG(PT_MV_STRING8,   0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W           PROP_TAG(PT_MV_UNICODE,   0x800F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL         PROP_TAG(PT_TSTRING,      0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_A       PROP_TAG(PT_STRING8,      0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_W       PROP_TAG(PT_UNICODE,      0x810F)
#define PR_EMS_AB_PUBLIC_DELEGATES            PROP_TAG(PT_OBJECT,       0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_A          PROP_TAG(PT_MV_STRING8,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_W          PROP_TAG(PT_MV_UNICODE,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_O          PROP_TAG(PT_OBJECT,       0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_T          PROP_TAG(PT_MV_TSTRING,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL         PROP_TAG(PT_MV_TSTRING,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_A       PROP_TAG(PT_MV_STRING8,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_W       PROP_TAG(PT_MV_UNICODE,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_O       PROP_TAG(PT_OBJECT,       0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_T       PROP_TAG(PT_MV_TSTRING,   0x8110)
#define PR_EMS_AB_QUOTA_NOTIFICATION_SCHEDULE PROP_TAG(PT_BINARY,       0x8111)
#define PR_EMS_AB_QUOTA_NOTIFICATION_STYLE    PROP_TAG(PT_LONG,         0x8112)
#define PR_EMS_AB_RANGE_LOWER                 PROP_TAG(PT_LONG,         0x8113)
#define PR_EMS_AB_RANGE_UPPER                 PROP_TAG(PT_LONG,         0x8114)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER         PROP_TAG(PT_TSTRING,      0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_A       PROP_TAG(PT_STRING8,      0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_W       PROP_TAG(PT_UNICODE,      0x8115)
#define PR_EMS_AB_RAS_PHONE_NUMBER            PROP_TAG(PT_TSTRING,      0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_A          PROP_TAG(PT_STRING8,      0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_W          PROP_TAG(PT_UNICODE,      0x8116)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME    PROP_TAG(PT_TSTRING,      0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_A  PROP_TAG(PT_STRING8,      0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_W  PROP_TAG(PT_UNICODE,      0x8117)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME        PROP_TAG(PT_TSTRING,      0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_A      PROP_TAG(PT_STRING8,      0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_W      PROP_TAG(PT_UNICODE,      0x8118)
#define PR_EMS_AB_REGISTERED_ADDRESS          PROP_TAG(PT_MV_BINARY,    0x8119)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD          PROP_TAG(PT_TSTRING,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_A        PROP_TAG(PT_STRING8,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_W        PROP_TAG(PT_UNICODE,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS  PROP_TAG(PT_TSTRING,      0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_A PROP_TAG(PT_STRING8,     0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_W PROP_TAG(PT_UNICODE,     0x811B)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER        PROP_TAG(PT_TSTRING,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_A      PROP_TAG(PT_STRING8,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_W      PROP_TAG(PT_UNICODE,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_O      PROP_TAG(PT_OBJECT,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_T      PROP_TAG(PT_TSTRING,      0x811C)
#define PR_EMS_AB_REMOTE_SITE                 PROP_TAG(PT_TSTRING,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_A               PROP_TAG(PT_STRING8,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_W               PROP_TAG(PT_UNICODE,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_O               PROP_TAG(PT_OBJECT,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_T               PROP_TAG(PT_TSTRING,      0x811D)
#define PR_EMS_AB_REPLICATION_MAIL_MSG_SIZE   PROP_TAG(PT_LONG,         0x8168)
#define PR_EMS_AB_REPLICATION_SENSITIVITY     PROP_TAG(PT_LONG,         0x811E)
#define PR_EMS_AB_REPLICATION_STAGGER         PROP_TAG(PT_LONG,         0x811F)
#define PR_EMS_AB_REPORT_TO_ORIGINATOR        PROP_TAG(PT_BOOLEAN,      0x8120)
#define PR_EMS_AB_REPORT_TO_OWNER             PROP_TAG(PT_BOOLEAN,      0x8121)
#define PR_EMS_AB_REPORTS                     PROP_TAG(PT_OBJECT,       0x800E)
#define PR_EMS_AB_REPORTS_A                   PROP_TAG(PT_MV_STRING8,   0x800E)
#define PR_EMS_AB_REPORTS_W                   PROP_TAG(PT_MV_UNICODE,   0x800E)
#define PR_EMS_AB_REPORTS_O                   PROP_TAG(PT_OBJECT,       0x800E)
#define PR_EMS_AB_REPORTS_T                   PROP_TAG(PT_MV_TSTRING,   0x800E)
#define PR_EMS_AB_REQ_SEQ                     PROP_TAG(PT_LONG,         0x8122)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA       PROP_TAG(PT_TSTRING,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_A     PROP_TAG(PT_STRING8,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_W     PROP_TAG(PT_UNICODE,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_O     PROP_TAG(PT_OBJECT,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_T     PROP_TAG(PT_TSTRING,      0x8123)
#define PR_EMS_AB_RID_SERVER                  PROP_TAG(PT_TSTRING,      0x8124)
#define PR_EMS_AB_RID_SERVER_A                PROP_TAG(PT_STRING8,      0x8124)
#define PR_EMS_AB_RID_SERVER_W                PROP_TAG(PT_UNICODE,      0x8124)
#define PR_EMS_AB_RID_SERVER_O                PROP_TAG(PT_OBJECT,       0x8124)
#define PR_EMS_AB_RID_SERVER_T                PROP_TAG(PT_TSTRING,      0x8124)
#define PR_EMS_AB_ROLE_OCCUPANT               PROP_TAG(PT_MV_TSTRING,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A             PROP_TAG(PT_MV_STRING8,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W             PROP_TAG(PT_MV_UNICODE,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O             PROP_TAG(PT_OBJECT,       0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T             PROP_TAG(PT_MV_TSTRING,   0x8125)
#define PR_EMS_AB_ROUTING_LIST                PROP_TAG(PT_MV_TSTRING,   0x8126)
#define PR_EMS_AB_ROUTING_LIST_A              PROP_TAG(PT_MV_STRING8,   0x8126)
#define PR_EMS_AB_ROUTING_LIST_W              PROP_TAG(PT_MV_UNICODE,   0x8126)
#define PR_EMS_AB_RTS_CHECKPOINT_SIZE         PROP_TAG(PT_LONG,         0x8127)
#define PR_EMS_AB_RTS_RECOVERY_TIMEOUT        PROP_TAG(PT_LONG,         0x8128)
#define PR_EMS_AB_RTS_WINDOW_SIZE             PROP_TAG(PT_LONG,         0x8129)
#define PR_EMS_AB_RUNS_ON                     PROP_TAG(PT_MV_TSTRING,   0x812A)
#define PR_EMS_AB_RUNS_ON_A                   PROP_TAG(PT_MV_STRING8,   0x812A)
#define PR_EMS_AB_RUNS_ON_W                   PROP_TAG(PT_MV_UNICODE,   0x812A)
#define PR_EMS_AB_RUNS_ON_O                   PROP_TAG(PT_OBJECT,       0x812A)
#define PR_EMS_AB_RUNS_ON_T                   PROP_TAG(PT_MV_TSTRING,   0x812A)
#define PR_EMS_AB_S_SELECTOR                  PROP_TAG(PT_BINARY,       0x812B)
#define PR_EMS_AB_S_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x812C)
#define PR_EMS_AB_SEARCH_FLAGS                PROP_TAG(PT_LONG,         0x812D)
#define PR_EMS_AB_SEARCH_GUIDE                PROP_TAG(PT_MV_BINARY,    0x812E)
#define PR_EMS_AB_SECURITY_PROTOCOL           PROP_TAG(PT_MV_BINARY,    0x8037)
#define PR_EMS_AB_SEE_ALSO                    PROP_TAG(PT_MV_TSTRING,   0x812F)
#define PR_EMS_AB_SEE_ALSO_A                  PROP_TAG(PT_MV_STRING8,   0x812F)
#define PR_EMS_AB_SEE_ALSO_W                  PROP_TAG(PT_MV_UNICODE,   0x812F)
#define PR_EMS_AB_SEE_ALSO_O                  PROP_TAG(PT_OBJECT,       0x812F)
#define PR_EMS_AB_SEE_ALSO_T                  PROP_TAG(PT_MV_TSTRING,   0x812F)
#define PR_EMS_AB_SERIAL_NUMBER               PROP_TAG(PT_MV_TSTRING,   0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A             PROP_TAG(PT_MV_STRING8,   0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W             PROP_TAG(PT_MV_UNICODE,   0x8130)
#define PR_EMS_AB_SERVICE_ACTION_FIRST        PROP_TAG(PT_LONG,         0x8131)
#define PR_EMS_AB_SERVICE_ACTION_OTHER        PROP_TAG(PT_LONG,         0x8132)
#define PR_EMS_AB_SERVICE_ACTION_SECOND       PROP_TAG(PT_LONG,         0x8133)
#define PR_EMS_AB_SERVICE_RESTART_DELAY       PROP_TAG(PT_LONG,         0x8134)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE     PROP_TAG(PT_TSTRING,      0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_A   PROP_TAG(PT_STRING8,      0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_W   PROP_TAG(PT_UNICODE,      0x8135)
#define PR_EMS_AB_SESSION_DISCONNECT_TIMER    PROP_TAG(PT_LONG,         0x8136)
#define PR_EMS_AB_SITE_AFFINITY               PROP_TAG(PT_MV_TSTRING,   0x8137)
#define PR_EMS_AB_SITE_AFFINITY_A             PROP_TAG(PT_MV_STRING8,   0x8137)
#define PR_EMS_AB_SITE_AFFINITY_W             PROP_TAG(PT_MV_UNICODE,   0x8137)
#define PR_EMS_AB_SITE_FOLDER_GUID            PROP_TAG(PT_BINARY,       0x8166)
#define PR_EMS_AB_SITE_FOLDER_SERVER          PROP_TAG(PT_TSTRING,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_A        PROP_TAG(PT_STRING8,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_W        PROP_TAG(PT_UNICODE,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_O        PROP_TAG(PT_OBJECT,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_T        PROP_TAG(PT_TSTRING,      0x8167)
#define PR_EMS_AB_SITE_PROXY_SPACE            PROP_TAG(PT_MV_TSTRING,   0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_A          PROP_TAG(PT_MV_STRING8,   0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_W          PROP_TAG(PT_MV_UNICODE,   0x8138)
#define PR_EMS_AB_SPACE_LAST_COMPUTED         PROP_TAG(PT_SYSTIME,      0x8139)
#define PR_EMS_AB_STREET_ADDRESS              PROP_TAG(PT_TSTRING,      0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A            PROP_TAG(PT_STRING8,      0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W            PROP_TAG(PT_UNICODE,      0x813A)
#define PR_EMS_AB_SUB_REFS                    PROP_TAG(PT_MV_TSTRING,   0x813B)
#define PR_EMS_AB_SUB_REFS_A                  PROP_TAG(PT_MV_STRING8,   0x813B)
#define PR_EMS_AB_SUB_REFS_W                  PROP_TAG(PT_MV_UNICODE,   0x813B)
#define PR_EMS_AB_SUB_REFS_O                  PROP_TAG(PT_OBJECT,       0x813B)
#define PR_EMS_AB_SUB_REFS_T                  PROP_TAG(PT_MV_TSTRING,   0x813B)
#define PR_EMS_AB_SUBMISSION_CONT_LENGTH      PROP_TAG(PT_LONG,         0x813C)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT PROP_TAG(PT_MV_BINARY,  0x813D)
#define PR_EMS_AB_SUPPORTING_STACK            PROP_TAG(PT_MV_TSTRING,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_A          PROP_TAG(PT_MV_STRING8,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_W          PROP_TAG(PT_MV_UNICODE,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_O          PROP_TAG(PT_OBJECT,       0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_T          PROP_TAG(PT_MV_TSTRING,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_BL         PROP_TAG(PT_MV_TSTRING,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_A       PROP_TAG(PT_MV_STRING8,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_W       PROP_TAG(PT_MV_UNICODE,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_O       PROP_TAG(PT_OBJECT,       0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_T       PROP_TAG(PT_MV_TSTRING,   0x813F)
#define PR_EMS_AB_T_SELECTOR                  PROP_TAG(PT_BINARY,       0x8140)
#define PR_EMS_AB_T_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x8141)
#define PR_EMS_AB_TARGET_ADDRESS              PROP_TAG(PT_TSTRING,      0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_A            PROP_TAG(PT_STRING8,      0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_W            PROP_TAG(PT_UNICODE,      0x8011)
#define PR_EMS_AB_TARGET_MTAS                 PROP_TAG(PT_MV_TSTRING,   0x8142)
#define PR_EMS_AB_TARGET_MTAS_A               PROP_TAG(PT_MV_STRING8,   0x8142)
#define PR_EMS_AB_TARGET_MTAS_W               PROP_TAG(PT_MV_UNICODE,   0x8142)
#define PR_EMS_AB_TELEPHONE_NUMBER            PROP_TAG(PT_MV_TSTRING,   0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_A          PROP_TAG(PT_MV_STRING8,   0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_W          PROP_TAG(PT_MV_UNICODE,   0x8012)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER PROP_TAG(PT_MV_BINARY,    0x8143)
#define PR_EMS_AB_TEMP_ASSOC_THRESHOLD        PROP_TAG(PT_LONG,         0x8144)
#define PR_EMS_AB_TOMBSTONE_LIFETIME          PROP_TAG(PT_LONG,         0x8145)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME      PROP_TAG(PT_TSTRING,      0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_A    PROP_TAG(PT_STRING8,      0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_W    PROP_TAG(PT_UNICODE,      0x8146)
#define PR_EMS_AB_TRANS_RETRY_MINS            PROP_TAG(PT_LONG,         0x8147)
#define PR_EMS_AB_TRANS_TIMEOUT_MINS          PROP_TAG(PT_LONG,         0x8148)
#define PR_EMS_AB_TRANSFER_RETRY_INTERVAL     PROP_TAG(PT_LONG,         0x8149)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NON_URGENT PROP_TAG(PT_LONG,         0x814A)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NORMAL     PROP_TAG(PT_LONG,         0x814B)
#define PR_EMS_AB_TRANSFER_TIMEOUT_URGENT     PROP_TAG(PT_LONG,         0x814C)
#define PR_EMS_AB_TRANSLATION_TABLE_USED      PROP_TAG(PT_LONG,         0x814D)
#define PR_EMS_AB_TRANSPORT_EXPEDITED_DATA    PROP_TAG(PT_BOOLEAN,      0x814E)
#define PR_EMS_AB_TRUST_LEVEL                 PROP_TAG(PT_LONG,         0x814F)
#define PR_EMS_AB_TURN_REQUEST_THRESHOLD      PROP_TAG(PT_LONG,         0x8150)
#define PR_EMS_AB_TWO_WAY_ALTERNATE_FACILITY  PROP_TAG(PT_BOOLEAN,      0x8151)
#define PR_EMS_AB_UNAUTH_ORIG_BL              PROP_TAG(PT_MV_TSTRING,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_A            PROP_TAG(PT_MV_STRING8,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_W            PROP_TAG(PT_MV_UNICODE,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_O            PROP_TAG(PT_OBJECT,       0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_T            PROP_TAG(PT_MV_TSTRING,   0x8152)
#define PR_EMS_AB_USER_PASSWORD               PROP_TAG(PT_MV_BINARY,    0x8153)
#define PR_EMS_AB_USN_CHANGED                 PROP_TAG(PT_LONG,         0x8029)
#define PR_EMS_AB_USN_CREATED                 PROP_TAG(PT_LONG,         0x8154)
#define PR_EMS_AB_USN_DSA_LAST_OBJ_REMOVED    PROP_TAG(PT_LONG,         0x8155)
#define PR_EMS_AB_USN_LAST_OBJ_REM            PROP_TAG(PT_LONG,         0x8156)
#define PR_EMS_AB_USN_SOURCE                  PROP_TAG(PT_LONG,         0x8157)
#define PR_EMS_AB_X121_ADDRESS                PROP_TAG(PT_MV_TSTRING,   0x8158)
#define PR_EMS_AB_X121_ADDRESS_A              PROP_TAG(PT_MV_STRING8,   0x8158)
#define PR_EMS_AB_X121_ADDRESS_W              PROP_TAG(PT_MV_UNICODE,   0x8158)
#define PR_EMS_AB_X25_CALL_USER_DATA_INCOMING PROP_TAG(PT_BINARY,       0x8159)
#define PR_EMS_AB_X25_CALL_USER_DATA_OUTGOING PROP_TAG(PT_BINARY,       0x815A)
#define PR_EMS_AB_X25_FACILITIES_DATA_INCOMING PROP_TAG(PT_BINARY,      0x815B)
#define PR_EMS_AB_X25_FACILITIES_DATA_OUTGOING PROP_TAG(PT_BINARY,      0x815C)
#define PR_EMS_AB_X25_LEASED_LINE_PORT        PROP_TAG(PT_BINARY,       0x815D)
#define PR_EMS_AB_X25_LEASED_OR_SWITCHED      PROP_TAG(PT_BOOLEAN,      0x815E)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE        PROP_TAG(PT_TSTRING,      0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_A      PROP_TAG(PT_STRING8,      0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_W      PROP_TAG(PT_UNICODE,      0x815F)
#define PR_EMS_AB_X400_ATTACHMENT_TYPE        PROP_TAG(PT_BINARY,       0x8160)
#define PR_EMS_AB_X400_SELECTOR_SYNTAX        PROP_TAG(PT_LONG,         0x8161)
#define PR_EMS_AB_X500_ACCESS_CONTROL_LIST    PROP_TAG(PT_BINARY,       0x8162)
#define PR_EMS_AB_XMIT_TIMEOUT_NON_URGENT     PROP_TAG(PT_LONG,         0x8163)
#define PR_EMS_AB_XMIT_TIMEOUT_NORMAL         PROP_TAG(PT_LONG,         0x8164)
#define PR_EMS_AB_XMIT_TIMEOUT_URGENT         PROP_TAG(PT_LONG,         0x8165)

#endif /* _EMSABTAG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wabmig\_comctl.h ===
/*

	_comctl.h

*/

// This commctrl flag enables us to be compiled with the new commctrl headers
// yet work with the old commctrl dlls
#ifdef _WIN32_IE
#undef _WIN32_IE
#endif
#define _WIN32_IE 0x0300
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wabmig\wabmig.c ===
/*
 *  WABMIG.C
 *
 *  Migrate PAB to WAB
 *
 *  Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#define _WABMIG_C   TRUE
#include "_wabmig.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"
#include <shlwapi.h>

#define WinMainT WinMain

const TCHAR szDescription[] = "description";
const TCHAR szDll[] = "dll";
const TCHAR szEntry[] = "entry";
const TCHAR szEXPORT[] = "EXPORT";
const TCHAR szIMPORT[] = "IMPORT";
const TCHAR szPROFILEID[] = "PID:";
const TCHAR szFILE[] = "File:";
const TCHAR szEmpty[] = "";


// Globals
WAB_IMPORT_OPTIONS ImportOptions = {WAB_REPLACE_PROMPT,   // replace option
                                    FALSE};               // No more errors

WAB_EXPORT_OPTIONS ExportOptions = {WAB_REPLACE_PROMPT,   // replace option
                                    FALSE};               // No more errors

const LPTSTR szWABKey = "Software\\Microsoft\\WAB";
LPTARGET_INFO rgTargetInfo = NULL;


HINSTANCE hInst;
HINSTANCE hInstApp;

BOOL fMigrating = FALSE;
BOOL fError = FALSE;
BOOL fExport = FALSE;

LPADRBOOK lpAdrBookWAB = NULL;
LPWABOBJECT lpWABObject = NULL;

LPTSTR lpImportDll = NULL;
LPTSTR lpImportFn = NULL;
LPTSTR lpImportDesc = NULL;
LPTSTR lpImportName = NULL;
LPTSTR lpExportDll = NULL;
LPTSTR lpExportFn = NULL;
LPTSTR lpExportDesc = NULL;
LPTSTR lpExportName = NULL;


//
//  Global WAB Allocator access functions
//
typedef struct _WAB_ALLOCATORS {
    LPWABOBJECT lpWABObject;
    LPWABALLOCATEBUFFER lpAllocateBuffer;
    LPWABALLOCATEMORE lpAllocateMore;
    LPWABFREEBUFFER lpFreeBuffer;
} WAB_ALLOCATORS, *LPWAB_ALLOCATORS;

WAB_ALLOCATORS WABAllocators = {0};


/***************************************************************************

    Name      : SetGlobalBufferFunctions

    Purpose   : Set the global buffer functions based on methods from
                the WAB object.

    Parameters: lpWABObject = the open wab object

    Returns   : none

    Comment   :

***************************************************************************/
void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject) {
    if (lpWABObject && ! WABAllocators.lpWABObject) {
        WABAllocators.lpAllocateBuffer = lpWABObject->lpVtbl->AllocateBuffer;
        WABAllocators.lpAllocateMore = lpWABObject->lpVtbl->AllocateMore;
        WABAllocators.lpFreeBuffer = lpWABObject->lpVtbl->FreeBuffer;
        WABAllocators.lpWABObject = lpWABObject;
    }
}


/***************************************************************************

    Name      : WABAllocateBuffer

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateBuffer) {
        return(WABAllocators.lpAllocateBuffer(WABAllocators.lpWABObject, cbSize, lppBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
        DebugTrace("WAB Allocators not set up!\n");
        Assert(FALSE);
    }
}


/***************************************************************************

    Name      : WABAllocateMore

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lpObject = existing allocation
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateMore) {
        return(WABAllocators.lpAllocateMore(WABAllocators.lpWABObject, cbSize, lpObject, lppBuffer));
    } else {
        DebugTrace("WAB Allocators not set up!\n");
        Assert(FALSE);
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : WABFreeBuffer

    Purpose   : Use the WAB Allocator

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABFreeBuffer(LPVOID lpBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpFreeBuffer) {
        return(WABAllocators.lpFreeBuffer(WABAllocators.lpWABObject, lpBuffer));
    } else {
        DebugTrace("WAB Allocators not set up!\n");
        Assert(FALSE);
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : StrICmpN

    Purpose   : Compare strings, ignore case, stop at N characters

    Parameters: szString1 = first string
                szString2 = second string
                N = number of characters to compare

    Returns   : 0 if first N characters of strings are equivalent.

    Comment   :

***************************************************************************/
int StrICmpN(LPTSTR szString1, LPTSTR szString2, ULONG N) {
    int Result = 0;

    if (szString1 && szString2) {
        while (*szString1 && *szString2 && N) 
        {
            N--;

            if (toupper(*szString1) != toupper(*szString2)) {
                Result = 1;
                break;
            }
            szString1++;
            szString2++;
        }
    } else {
        Result = -1;    // arbitrarily non-equal result
    }

    return(Result);
}


/***************************************************************************

    Name      : AllocRegValue

    Purpose   : Allocate space for and query the registry value

    Parameters: hKey = registry key to query
                lpValueName = name of value to query
                lppString -> returned buffer string (caller must LocalFree)

    Returns   : TRUE on success, FALSE on error

    Comment   :

***************************************************************************/
BOOL AllocRegValue(HKEY hKey, LPTSTR lpValueName, LPTSTR * lppString) {
    TCHAR szTemp[1];
    ULONG ulSize = 1;             // Expect ERROR_MORE_DATA
    DWORD dwErr;
    DWORD dwType;

    if (dwErr = RegQueryValueEx(hKey,
      (LPTSTR)lpValueName,    // name of value
      NULL,
      &dwType,
      szTemp,
      &ulSize)) {
        if (dwErr == ERROR_MORE_DATA) {
            if (! (*lppString = LocalAlloc(LPTR, ulSize))) {
                DebugTrace("AllocRegValue can't allocate string -> %u\n", GetLastError());
            } else {
                // Try again with sufficient buffer
                if (! RegQueryValueEx(hKey,
                  lpValueName,
                  NULL,
                  &dwType,
                  *lppString,
                  &ulSize)) {
                    if (dwType != REG_SZ) {
                        LocalFree(*lppString);
                        *lppString = NULL;
                    } else {
                        return(TRUE);
                    }
                }
            }
        }
    }
    return(FALSE);
}


HRESULT ProgressCallback(HWND hwnd, LPWAB_PROGRESS lpProgress) {
    MSG msg;

    if (lpProgress->lpText) {
        DebugTrace("Status Message: %s\n", lpProgress->lpText);
        SetDlgItemText(hwnd, IDC_Message, lpProgress->lpText);
    }

    if (lpProgress->denominator) {
        if (lpProgress->numerator == 0) {
            ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_SHOW);
        }

        SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETRANGE, 0, MAKELPARAM(0, min(lpProgress->denominator, 32767)));
        SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETSTEP, (WPARAM)1, 0);
        SendMessage(GetDlgItem(hwnd, IDC_Progress), PBM_SETPOS, (WPARAM)min(lpProgress->numerator, lpProgress->denominator), 0);
    }

    // msgpump to process user moving window, or pressing cancel... :)
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return(hrSuccess);
}


/***************************************************************************

    Name      : SetDialogMessage

    Purpose   : Sets the message text for the dialog box item IDC_Message

    Parameters: hwnd = window handle of dialog
                ids = stringid of message resource

    Returns   : none

***************************************************************************/
void SetDialogMessage(HWND hwnd, int ids) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

    if (LoadString(hInst, ids, szBuffer, sizeof(szBuffer))) {
        DebugTrace("Status Message: %s\n", szBuffer);
        if (! SetDlgItemText(hwnd, IDC_Message, szBuffer)) {
            DebugTrace("SetDlgItemText -> %u\n", GetLastError());
        }
    } else {
        DebugTrace("Cannot load resource string %u\n", ids);
        Assert(FALSE);
    }
}


/////////////////////////////////////////////////////////////////////////
// GetWABDllPath - loads the WAB DLL path from the registry
// szPath	- ptr to buffer
// cb		- sizeof buffer
//
void GetWABDllPath(LPTSTR szPath, ULONG cb)
{
    DWORD  dwType = 0;
    HKEY hKey = NULL;
    TCHAR szPathT[MAX_PATH];
    ULONG  cbData = sizeof(szPathT);
    if(szPath)
    {
        *szPath = '\0';
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
        {
            if(ERROR_SUCCESS == RegQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szPathT, &cbData))
            {
                if (dwType == REG_EXPAND_SZ)
                    cbData = ExpandEnvironmentStrings(szPathT, szPath, cb / sizeof(TCHAR));
                else
                {
                    if(GetFileAttributes(szPathT) != 0xFFFFFFFF)
                        StrCpyN(szPath, szPathT, cb/sizeof(TCHAR));
                }
            }
        }
    }
    if(hKey) RegCloseKey(hKey);
	return;
}

///////////////////////////////////////////////////////////////////////////
// LoadLibrary_WABDll() - Load the WAB library based on the WAB DLL path
//
HINSTANCE LoadLibrary_WABDll()
{
    TCHAR  szWABDllPath[MAX_PATH];
    HINSTANCE hinst = NULL;

    GetWABDllPath(szWABDllPath, sizeof(szWABDllPath));

    return(hinst = LoadLibrary( (lstrlen(szWABDllPath)) ? szWABDllPath : WAB_DLL_NAME));
}

/*
-
-   bSearchCmdLine - searches for given arg in given line and returns
*   data after the arg
*/
BOOL bSearchCmdLine(LPTSTR lpCmdLine, LPTSTR szArg, LPTSTR szData, DWORD cchSize)
{
    LPTSTR lpCmd = NULL, lp = NULL, lpTemp = NULL;
    BOOL fRet = FALSE;
    DWORD cchSizeCmd = 0;

    if(!lpCmdLine || !lstrlen(lpCmdLine) || !szArg || !lstrlen(szArg))
        return FALSE;

    cchSizeCmd = lstrlen(lpCmdLine)+1;
    if(!(lpCmd = LocalAlloc(LMEM_ZEROINIT, cchSizeCmd)))
        return FALSE;

    StrCpyN(lpCmd, lpCmdLine, cchSizeCmd);
    
    lpTemp = lpCmd;
    while(lpTemp && *lpTemp)
    {
        if (! StrICmpN(lpTemp, (LPTSTR)szArg, lstrlen(szArg))) 
        {
            fRet = TRUE;
            lpTemp += lstrlen(szArg);     // move past the switch
            if(szData)
            {
                lp = lpTemp;
                while(lp && *lp && *lp!='\0' && *lp!='+') //delimiter is a '+' so we dont mess up long file names
                    lp++;
                *lp = '\0';
                if(lstrlen(lpTemp))
                    StrCpyN(szData, lpTemp, cchSize);
            }
            break;
        }
        lpTemp++;
    }

    LocalFree(lpCmd);
    return fRet;
}

typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCTSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);

static const TCHAR c_szShlwapiDll[] = TEXT("shlwapi.dll");
static const char c_szDllGetVersion[] = "DllGetVersion";
static const TCHAR c_szWABResourceDLL[] = TEXT("wab32res.dll");
static const TCHAR c_szWABDLL[] = TEXT("wab32.dll");

HINSTANCE LoadWABResourceDLL(HINSTANCE hInstWAB32)
{
    TCHAR szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DLLGETVERSIONPROC pfnVersion;
    int iEnd;
    DLLVERSIONINFO info;
    HINSTANCE hInst = NULL;

    hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
#ifdef UNICODE
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)378);
#else
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)377);
#endif // UNICODE
                    if (pfn != NULL)
                        hInst = pfn(c_szWABResourceDLL, hInstWAB32, 0);
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if (NULL == hInst)
    {
        GetWABDllPath(szPath, sizeof(szPath));
        iEnd = lstrlen(szPath);
        if (iEnd > 0)
        {
            iEnd = iEnd - lstrlen(c_szWABDLL);
            StrCpyN(&szPath[iEnd], c_szWABResourceDLL, sizeof(szPath)/sizeof(TCHAR)-iEnd);
            hInst = LoadLibrary(szPath);
        }
    }

    AssertSz(hInst, TEXT("Failed to LoadLibrary Lang Dll"));

    return(hInst);
}

/***************************************************************************

    Name      : WinMain

    Purpose   :

    Parameters: Command line parameters
                "" - defaults to import for default wab
                "filename" - defaults to import
                "/import [filename]" - default wab or specified wab
                "/export [filename]" - default wab or specified wab


    Returns   :

***************************************************************************/
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow) {
    MSG msg ;
    int nRetVal;
    LPSTR lpTemp = lpszCmdLine;
    HINSTANCE hinstWAB;

    WABMIGDLGPARAM wmdp = {0};

    hInstApp = hInstance;
    hInst = LoadWABResourceDLL(hInstApp);

    DebugTrace("WABMIG cmdline = %s\n", lpszCmdLine);

    fExport = bSearchCmdLine(lpszCmdLine, (LPTSTR)szEXPORT, NULL, 0);
    bSearchCmdLine(lpszCmdLine, (LPTSTR)szPROFILEID, wmdp.szProfileID, ARRAYSIZE(wmdp.szProfileID));
    bSearchCmdLine(lpszCmdLine, (LPTSTR)szFILE, wmdp.szFileName, ARRAYSIZE(wmdp.szFileName));

    DebugTrace("%s: id=%s file=%s\n", fExport?szEXPORT:szIMPORT, wmdp.szProfileID, wmdp.szFileName);

    // Load the WABDll and getprocaddress for WABOpen
    hinstWAB = LoadLibrary_WABDll();
    if(hinstWAB)
        lpfnWABOpen = (LPWABOPEN) GetProcAddress(hinstWAB, TEXT("WABOpen"));

    DebugTrace("WABMig got filename: %s\n", wmdp.szFileName);

    if(lpfnWABOpen)
    {
        nRetVal = (int) DialogBoxParam(hInst,
         MAKEINTRESOURCE(fExport ? IDD_ExportDialog : IDD_ImportDialog),
          NULL,
          fExport ? ExportDialogProc : ImportDialogProc,
          (LPARAM) &wmdp);
        switch(nRetVal) {
            case -1: //some error occured
                DebugTrace("Couldn't create import dialog -> %u\n", GetLastError());
            default:
                break;
        }
    }
    else
    {
        TCHAR sz[MAX_PATH];
        TCHAR szTitle[MAX_PATH];
        *szTitle = *sz = '\0';
        LoadString(hInst, IDS_MESSAGE_TITLE, szTitle, sizeof(szTitle));
        LoadString(hInst, IDS_NO_WAB, sz, sizeof(sz));
        MessageBox(NULL, sz, szTitle, MB_OK | MB_ICONSTOP);
    }

    if(hinstWAB)
        FreeLibrary(hinstWAB);
    if(hInst)
        FreeLibrary(hInst);

    return(nRetVal == -1);
}

INT_PTR CALLBACK ErrorDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    LPERROR_INFO lpEI = (LPERROR_INFO)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (message) {
        case WM_INITDIALOG:
            {
                TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
                LPTSTR lpszMessage;

                SetWindowLongPtr(hwnd, DWLP_USER, lParam);  //Save this for future reference
                lpEI = (LPERROR_INFO)lParam;


                if (LoadString(hInst,
                  lpEI->ids,
                  szBuffer, sizeof(szBuffer))) {
                    LPTSTR lpszArg[2] = {lpEI->lpszDisplayName, lpEI->lpszEmailAddress};

                    if (! FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      szBuffer,
                      0, 0, //ignored
                      (LPTSTR)&lpszMessage,
                      0,
                      (va_list *)lpszArg)) {
                        DebugTrace("FormatMessage -> %u\n", GetLastError());
                    } else {
                        DebugTrace("Status Message: %s\n", lpszMessage);
                        if (! SetDlgItemText(hwnd, IDC_ErrorMessage, lpszMessage)) {
                            DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                        }
                        LocalFree(lpszMessage);
                    }
                }
                return(TRUE);
            }

        case WM_COMMAND :
            switch (wParam) {
                case IDCANCEL:
                    lpEI->ErrorResult = ERROR_ABORT;
                    // fall through to close.

                case IDCLOSE:
                    // Ignore the contents of the radio button
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDOK:
                    // Get the contents of the radio button
                    ImportOptions.fNoErrors = (IsDlgButtonChecked(hwnd, IDC_NoMoreError) == 1);
                    ExportOptions.fNoErrors = (IsDlgButtonChecked(hwnd, IDC_NoMoreError) == 1);
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);

                case IDM_EXIT:
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);
                }
            break ;

        case IDCANCEL:
            // treat it like a close
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            return(0);

        default:
            return(FALSE);
    }

    return(TRUE);
}

/***************************************************************************

    bOutlookUsingWAB

    if Outlook is installed on the machine and is setup to use the WAB 
    then there is no PAB on this machine - the PAB is the WAB and the 
    WAB import imports to itself ...
    So we look for this case and if it is true, we drop the PAB importer
    from the UI

****************************************************************************/
BOOL bOutlookUsingWAB()
{
    HKEY hKey = NULL;
    LPTSTR lpReg = "Software\\Microsoft\\Office\\8.0\\Outlook\\Setup";
    LPTSTR lpOMI = "MailSupport";
    BOOL bUsingWAB = FALSE;

    if(ERROR_SUCCESS == RegOpenKeyEx(   HKEY_LOCAL_MACHINE, 
                                        lpReg, 0, KEY_READ, &hKey))
    {
        DWORD dwType = 0, dwSize = sizeof(DWORD), dwData = 0;
        if(ERROR_SUCCESS == RegQueryValueEx(hKey, lpOMI, NULL,
                                            &dwType, (LPBYTE)&dwData, &dwSize))
        {
            if(dwType == REG_DWORD && dwData == 0) // the value must be one ..
                bUsingWAB = TRUE;
        }
    }

    if(hKey)
        RegCloseKey(hKey);

    return bUsingWAB;
}


/***************************************************************************

    Name      : PopulateTargetList

    Purpose   : Fills in the list box with the import/exporters from the
                registry.

    Parameters: hwndLB = handle of Listbox
                lpszSelection = NULL or name to set as default selection

    Returns   : HRESULT

    Comment   : This routine is a MESS!  Should break it up when we get time.

***************************************************************************/
HRESULT PopulateTargetList(HWND hWndLB,
  LPTSTR lpszSelection)
{
    ULONG       ulObjectType = 0;
    ULONG       i=0, j=0;
    TCHAR       szBuf[MAX_PATH];
    ULONG       ulItemCount = 0;
    HRESULT     hr = hrSuccess;
    DWORD       dwErr, cbBuf;
    HKEY        hKeyWAB = NULL;
    HKEY        hKeyImport = NULL;
    HKEY        hKey = NULL;
    ULONG       ulIndex;
    ULONG       ulNumImporters = 0;
    ULONG       ulExternals = 0;
    BOOL        bHidePAB = FALSE;

    //
    // We need to clear out the list list box if it has any entries ...
    //
    FreeLBItemData(hWndLB);

    // If outlook is using the WAB as the PAB then we want to hide
    // the PAB entry from the importer and exporter
    //
    bHidePAB = bOutlookUsingWAB();

    // How big a target list do I need?

    // Load all the entries from the registry
    // Open WAB Import Key
    if (! (dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, //HKEY_CURRENT_USER,
      szWABKey,
      0,
      KEY_READ,
      &hKeyWAB))) {

        // Yes, WAB Key open, get Import or Export Key
        if (! (dwErr = RegOpenKeyEx(hKeyWAB,
          fExport ? "Export" : "Import",
          0,
          KEY_READ,
          &hKeyImport))) {
            // Enumerate Importer/Exporter keys
            // How many keys are there?
            if (! (dwErr = RegQueryInfoKey(hKeyImport,
              NULL, NULL, NULL,
              &ulExternals,  // how many importer/exporter keys are there?
              NULL, NULL, NULL, NULL, NULL, NULL, NULL))) {
            }
        }
    }

    ulNumImporters = ulExternals + ulItemCount;

    if ((rgTargetInfo = LocalAlloc(LPTR, ulNumImporters * sizeof(TARGET_INFO)))) {
        ulIndex = 0;
        cbBuf= sizeof(szBuf);
    } else {
        DebugTrace("LocalAlloc of TargetInfoArray -> %u\n", GetLastError());
        hr = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }


    if (ulExternals) {
        // Add external importers/exporters to the list
        while (ulIndex < ulExternals && ! (dwErr = RegEnumKeyEx(hKeyImport,
          ulIndex,
          szBuf,
          &cbBuf,
          NULL, NULL, NULL, NULL))) {
            // Got another one,
            DebugTrace("Found Importer: [%s]\n", szBuf);

            // if we want to hide the pab and this is the pab then
            // skip else add
            //
            if(!(bHidePAB && !lstrcmpi(szBuf, TEXT("PAB"))))
            {
                // Add it to the list
                if (rgTargetInfo[ulItemCount].lpRegName = LocalAlloc(LPTR,
                  lstrlen(szBuf) + 1)) {
                    StrCpyN(rgTargetInfo[ulItemCount].lpRegName, szBuf, lstrlen(szBuf) + 1);

                    // Open the key
                    if (! (dwErr = RegOpenKeyEx(hKeyImport,
                      szBuf,
                      0,
                      KEY_READ,
                      &hKey))) {

                        AllocRegValue(hKey, (LPTSTR)szDescription, &rgTargetInfo[ulItemCount].lpDescription);
                        AllocRegValue(hKey, (LPTSTR)szDll, &rgTargetInfo[ulItemCount].lpDll);
                        AllocRegValue(hKey, (LPTSTR)szEntry, &rgTargetInfo[ulItemCount].lpEntry);

                        RegCloseKey(hKey);

                        if (! rgTargetInfo[ulItemCount].lpDescription) {
                            // No Description, use reg name
                            if (rgTargetInfo[ulItemCount].lpDescription = LocalAlloc(LPTR,
                              lstrlen(szBuf) + 1)) {
                                StrCpyN(rgTargetInfo[ulItemCount].lpDescription, szBuf, strlen(szBuf) + 1);
                            }
                        }

                        // Add to the list
                        SendMessage(hWndLB, LB_SETITEMDATA, (WPARAM)
                          SendMessage(hWndLB, LB_ADDSTRING, (WPARAM)0,
                          (LPARAM)rgTargetInfo[ulItemCount].lpDescription),
                          (LPARAM)ulItemCount);

                        if (lpszSelection && !lstrcmpi(rgTargetInfo[ulItemCount].lpDescription, lpszSelection)) {
                            // Set the default selection to Windows Address Book
                            SendMessage(hWndLB, LB_SETCURSEL, (WPARAM)ulIndex, (LPARAM)0);
                        }
                        ulItemCount++;
                    }
                } else {
                    DebugTrace("LocalAlloc of Importer Name -> %u\n", GetLastError());
                }
            }
            cbBuf = sizeof(szBuf);
            ulIndex++;
        }
    }
exit:
    if (hKeyImport) {
        RegCloseKey(hKeyImport);
    }
    if (hKeyWAB) {
        RegCloseKey(hKeyWAB);
    }

    return(hr);
}


/***************************************************************************

    Name      : FreeLBItemData

    Purpose   : Frees the structures associated with the Target List box.

    Parameters: hwndLB = handle of Listbox

    Returns   : none

    Comment

***************************************************************************/
void FreeLBItemData(HWND hWndLB)
{
    ULONG i = 0;
	ULONG ulItemCount = 0;
    LPTARGET_INFO lpTargetInfo = rgTargetInfo;

    if (! hWndLB) {
        return;
    }

    ulItemCount = (ULONG) SendMessage(hWndLB, LB_GETCOUNT, 0, 0);

    if (lpTargetInfo != NULL) {
        if (ulItemCount != 0) {
            for(i = 0; i < ulItemCount; i++) {
                if(lpTargetInfo->lpRegName) {
                    LocalFree(lpTargetInfo->lpRegName);
                }
                if (lpTargetInfo->lpDescription) {
                    LocalFree(lpTargetInfo->lpDescription);
                }
                if (lpTargetInfo->lpDll) {
                    LocalFree(lpTargetInfo->lpDll);
                }
                if (lpTargetInfo->lpEntry) {
                    LocalFree(lpTargetInfo->lpEntry);
                }
                lpTargetInfo++;
            }

            SendMessage(hWndLB, LB_RESETCONTENT, 0, 0);
        }

        // Free global array
        LocalFree(rgTargetInfo);
        rgTargetInfo = NULL;
    }
}


/***************************************************************************

    Name      : ShowMessageBoxParam

    Purpose   : Generic MessageBox displayer

    Parameters: hWndParent - Handle of message box parent
                MsgID      - resource id of message string
                ulFlags    - MessageBox flags
                ...        - format parameters

    Returns   : MessageBox return code

***************************************************************************/
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...)
{
    TCHAR szBuf[MAX_RESOURCE_STRING + 1] = "";
    TCHAR szCaption[MAX_PATH] = "";
    LPTSTR lpszBuffer = NULL;
    int iRet = 0;
    va_list     vl;

    va_start(vl, ulFlags);

    LoadString(hInst, MsgId, szBuf, sizeof(szBuf));
    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
      szBuf,
      0,0,              // ignored
      (LPTSTR)&lpszBuffer,
      sizeof(szBuf),      // MAX_UI_STR
      (va_list *)&vl)) {
        TCHAR szCaption[MAX_PATH];
        GetWindowText(hWndParent, szCaption, sizeof(szCaption));
        if (! lstrlen(szCaption)) { // if no caption get the parents caption - this is necessary for property sheets
            GetWindowText(GetParent(hWndParent), szCaption, sizeof(szCaption));
            if (! lstrlen(szCaption)) //if still not caption, use empty title
                szCaption[0] = (TCHAR)'\0';
        }
        iRet = MessageBox(hWndParent, lpszBuffer, szCaption, ulFlags);
        LocalFree(lpszBuffer);
    }
    va_end(vl);
    return(iRet);
}


//$$//////////////////////////////////////////////////////////////////////
//
//  LoadAllocString - Loads a string resource and allocates enough
//                    memory to hold it.
//
//  StringID - String identifier to load
//
//  returns the LocalAlloc'd, null terminated string.  Caller is responsible
//  for LocalFree'ing this buffer.  If the string can't be loaded or memory
//  can't be allocated, returns NULL.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR LoadAllocString(int StringID) {
    ULONG ulSize = 0;
    LPTSTR lpBuffer = NULL;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

    ulSize = LoadString(hInst, StringID, szBuffer, sizeof(szBuffer));

    if (ulSize && (lpBuffer = LocalAlloc(LPTR, ulSize + 1))) {
        StrCpyN(lpBuffer, szBuffer, ulSize + 1);
    }

    return(lpBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\csv.c ===
/*
 *  CSV.C
 *
 *  Migrate CSV <-> WAB
 *
 *  Copyright 1997 Microsoft Corporation.  All Rights Reserved.
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include <shlwapi.h>
#include "wabimp.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"


BOOL HandleImportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_IMPORT_OPTIONS lpImportOptions);
BOOL HandleExportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_EXPORT_OPTIONS lpExportOptions);

/***************************************************************************

    Name      : IsDomainName

    Purpose   : Is this domain correctly formatted for an Internet address?

    Parameters: lpDomain -> Domain name to check

    Returns   : TRUE if the domain is a correct format for an Internet
                address.

    Comment   : Valid domain names have this form:
                    bar[.bar]*
                    where bar must have non-empty contents
                    no high bits are allowed on any characters
                    no '@' allowed

***************************************************************************/
BOOL IsDomainName(LPTSTR lpDomain) {
    BOOL fBar = FALSE;

    if (lpDomain) {
        if (*lpDomain == '\0' || *lpDomain == '.') {
            // domain name must have contents and can't start with '.'
            return(FALSE);
        }

        while (*lpDomain) {
            // Internet addresses only allow pure ASCII.  No high bits!
            if (*lpDomain & 0x80 || *lpDomain == '@') {
                return(FALSE);
            }

            if (*lpDomain == '.') {
                // Recursively check this part of the domain name
                return(IsDomainName(CharNext(lpDomain)));
            }
            lpDomain = CharNext(lpDomain);
        }
        return(TRUE);
    }

    return(FALSE);
}


/***************************************************************************

    Name      : IsInternetAddress

    Purpose   : Is this address correctly formatted for an Internet address

    Parameters: lpAddress -> Address to check

    Returns   : TRUE if the address is a correct format for an Internet
                address.

    Comment   : Valid addresses have this form:
                    foo@bar[.bar]*
                    where foo and bar must have non-empty contents


***************************************************************************/
BOOL IsInternetAddress(LPTSTR lpAddress) {
    BOOL fDomain = FALSE;

    // Step through the address looking for '@'.  If there's an at sign in the middle
    // of a string, this is close enough to being an internet address for me.


    if (lpAddress) {
        // Can't start with '@'
        if (*lpAddress == '@') {
            return(FALSE);
        }
        while (*lpAddress) {
            // Internet addresses only allow pure ASCII.  No high bits!
            if (*lpAddress & 0x80) {
                return(FALSE);
            }

            if (*lpAddress == '@') {
                // Found the at sign.  Is there anything following?
                // (Must NOT be another '@')
                return(IsDomainName(CharNext(lpAddress)));
            }
            lpAddress = CharNext(lpAddress);
        }
    }

    return(FALSE);
}


/***************************************************************************

    Name      : OpenCSVFile

    Purpose   : Opens a CSV file for import

    Parameters: hwnd = main dialog window
                lpFileName = filename to create
                lphFile -> returned file handle

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT OpenCSVFile(HWND hwnd, LPTSTR lpFileName, LPHANDLE lphFile) {
    LPTSTR lpFilter;
    TCHAR szFileName[MAX_PATH + 1] = "";
    OPENFILENAME ofn;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HRESULT hResult = hrSuccess;
    DWORD ec;


    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(lpFileName,
      GENERIC_READ,
      0,    // sharing
      NULL,
      CREATE_NEW,
      FILE_FLAG_SEQUENTIAL_SCAN,
      NULL))) {
        ec = GetLastError();
        DebugTrace("CreateFile(%s) -> %u\n", lpFileName, ec);
        switch (ec) {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
            default:
                ShowMessageBoxParam(hwnd, IDE_CSV_EXPORT_FILE_ERROR, MB_ICONERROR, lpFileName);
                hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                break;
        }
    }

    if (! hResult) {
        *lphFile = hFile;
    }
    return(hResult);
}


/***************************************************************************

    Name      : CountCSVRows

    Purpose   : Counts the rows in the CSV file

    Parameters: hFile = open CSV file
                szSep = list separator
                lpulcEntries -> returned count of rows

    Returns   : HRESULT

    Comment   : File pointer should be positioned past the header row prior
                to calling this function.  This function leaves the file
                pointer where it found it.

***************************************************************************/
HRESULT CountCSVRows(HANDLE hFile, LPTSTR szSep, LPULONG lpulcEntries) {
    HRESULT hResult = hrSuccess;
    PUCHAR * rgItems = NULL;
    ULONG ulStart;
    ULONG cProps, i;

    *lpulcEntries = 0;

    Assert(hFile != INVALID_HANDLE_VALUE);

    if (0xFFFFFFFF == (ulStart = SetFilePointer(hFile, 0, NULL, FILE_CURRENT))) {
        DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
        return(ResultFromScode(MAPI_E_CALL_FAILED));
    }


    while (hResult == hrSuccess) {
        // Read the line
        if (ReadCSVLine(hFile, szSep, &cProps, &rgItems)) {
            // End of file
            break;
        }

        (*lpulcEntries)++;

        if (rgItems) {
            for (i = 0; i < cProps; i++) {
                if (rgItems[i]) {
                    LocalFree(rgItems[i]);
                }
            }
            LocalFree(rgItems);
            rgItems = NULL;
        }
    }
    if (0xFFFFFFFF == SetFilePointer(hFile, ulStart, NULL, FILE_BEGIN)) {
        DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
    }

    return(hResult);
}


BOOL TestCSVName(ULONG index,
  LPPROP_NAME lpImportMapping,
  ULONG ulcFields,
  PUCHAR * rgItems,
  ULONG cProps,
  BOOL fTryUnchosen) {

    return((index != NOT_FOUND) &&
      index < ulcFields &&
      index < cProps &&
      (fTryUnchosen || lpImportMapping[index].fChosen) &&
      rgItems[index] &&
      rgItems[index][0]);
}


/***************************************************************************

    Name      : MakeDisplayName

    Purpose   : Forms a display name based on the values of various props.

    Parameters: lppDisplayName -> Returned display name.  This should only
                  be used for certain purposes.  It can be used for error
                  dialogs, but if it was generated from first/middle/last,
                  it should not be used for PR_DISPLAY_NAME!
                lpImportMapping = import mapping table
                ulcFields = size of import mapping table
                rgItems = fields for this CSV item
                cProps = number of fields in rgItems
                iDisplayName = indicies of name related props
                iNickname
                iSurname
                iGivenName
                iMiddleName
                iEmailAddress
                iCompanyName

    Returns   : index of attribute forming the display name, or
                if FML, return INDEX_FIRST_MIDDLE_LAST.

    Comment   : Form the display name based on these rules:
                1. If there's already a display name and it's chosen,
                   use it.
                2. if there's a chosen first, middle or last name, add them
                   together and use them.
                3. if there's a chosen nickname, use it
                4. if there's a chosen email-address, use it.
                5. if there's a chosen company name, use it.
                6. look again without regard to whether it was chosen or not.

***************************************************************************/
ULONG MakeDisplayName(LPTSTR * lppDisplayName,
  LPPROP_NAME lpImportMapping,
  ULONG ulcFields,
  PUCHAR * rgItems,
  ULONG cProps,
  ULONG iDisplayName,
  ULONG iNickname,
  ULONG iSurname,
  ULONG iGivenName,
  ULONG iMiddleName,
  ULONG iEmailAddress,
  ULONG iCompanyName) {
    BOOL fTryUnchosen = FALSE;
    BOOL fSurname = FALSE;
    BOOL fGivenName = FALSE;
    BOOL fMiddleName = FALSE;
    ULONG index = NOT_FOUND;
    ULONG ulSize = 0;
    LPTSTR lpDisplayName = NULL;

try_again:

    if (TestCSVName(iDisplayName, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
        index = iDisplayName;
        goto found;
    }

    if (TestCSVName(iSurname, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen) ||
      TestCSVName(iGivenName, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen) ||
      TestCSVName(iMiddleName, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
        index = INDEX_FIRST_MIDDLE_LAST;
        goto found;
    }

    if (TestCSVName(iNickname, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
        index = iNickname;
        goto found;
    }

    if (TestCSVName(iEmailAddress, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
        index = iEmailAddress;
        goto found;
    }

    if (TestCSVName(iCompanyName, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
        index = iCompanyName;
        goto found;
    }
    if (! fTryUnchosen) {
        fTryUnchosen = TRUE;
        goto try_again;
    }

found:
    *lppDisplayName = NULL;
    switch (index) {
        case NOT_FOUND:
            break;

        case INDEX_FIRST_MIDDLE_LAST:
            if (fSurname = TestCSVName(iSurname, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
                ulSize += (lstrlen(rgItems[iSurname]) + 1);
            }
            if (fGivenName = TestCSVName(iGivenName, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
                ulSize += (lstrlen(rgItems[iGivenName]) + 1);
            }
            if (fMiddleName = TestCSVName(iMiddleName, lpImportMapping, ulcFields, rgItems, cProps, fTryUnchosen)) {
                ulSize += (lstrlen(rgItems[iMiddleName]) + 1);
            }
            Assert(ulSize);

            if (lpDisplayName = *lppDisplayName = LocalAlloc(LPTR, ulSize)) {
                // BUGBUG: This does not localize.  The effect is that in the collision/error
                // dialogs, we will get the order of names wrong.  It should not effect the properties
                // actually stored on the object since we won't set PR_DISPLAY_NAME if it was
                // generated by First/Middle/Last.  I can live with this, but we'll see if the
                // testers find it. BruceK
                if (fGivenName) {
                    StrCatBuff(lpDisplayName, rgItems[iGivenName], ulSize);
                }
                if (fMiddleName) {
                    if (*lpDisplayName) {
                        StrCatBuff(lpDisplayName, " ", ulSize);
                    }
                    StrCatBuff(lpDisplayName, rgItems[iMiddleName], ulSize);
                }
                if (fSurname) {
                    if (*lpDisplayName) {
                        StrCatBuff(lpDisplayName, " ", ulSize);
                    }
                    StrCatBuff(lpDisplayName, rgItems[iSurname], ulSize);
                }
            }
            break;

        default:
            ulSize = lstrlen(rgItems[index]) + 1;
            if (*lppDisplayName = LocalAlloc(LPTR, ulSize)) {
                StrCpyN(*lppDisplayName, rgItems[index], ulSize);
            }
            break;
    }

    return(index);
}


#define MAX_SEP 20
void GetListSeparator(LPTSTR szBuf)
{
    // Buffer is assumed to be MAX_SEP chars long
    if (!GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SLIST, szBuf, MAX_SEP))
    {
        szBuf[0] = TEXT(',');
		szBuf[1] = 0;
    }
}


HRESULT CSVImport(HWND hWnd,
  LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_EXPORT_OPTIONS lpOptions) {
    HRESULT hResult = hrSuccess;
    register ULONG i;
    ULONG cbWABEID, ulObjType;
    ULONG index;
    ULONG ulLastChosenProp = 0;
    ULONG ulcFields = 0;
    ULONG cProps;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    WAB_PROGRESS Progress;
    LPABCONT lpContainer = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    TCHAR rgFileName[MAX_PATH + 1] = "";
    PUCHAR * rgItems = NULL;
    REPLACE_INFO RI;
    LPMAPIPROP lpMailUserWAB = NULL;
    SPropValue sPropVal;
    BOOL fSkipSetProps;
    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    ULONG iEmailAddress = NOT_FOUND, iDisplayName = NOT_FOUND, iSurname = NOT_FOUND,
      iGivenName = NOT_FOUND, iCompanyName = NOT_FOUND, iMiddleName = NOT_FOUND,
      iNickname = NOT_FOUND, iDisplay = NOT_FOUND;
    TCHAR szSep[MAX_SEP];

    SetGlobalBufferFunctions(lpWABObject);

    // Read in the Property Name strings to the PropNames array
    for (i = 0; i < NUM_EXPORT_PROPS; i++) {
        rgPropNames[i].lpszName = LoadAllocString(rgPropNames[i].ids);
        Assert(rgPropNames[i].lpszName);
        DebugTrace("Property 0x%08x name: %s\n", rgPropNames[i].ulPropTag, rgPropNames[i].lpszName);
    }

    GetListSeparator(szSep);

    // Present UI Wizard
    if (hResult = ImportWizard(hWnd, rgFileName, ARRAYSIZE(rgFileName), rgPropNames, szSep, &lpImportMapping, &ulcFields, &hFile)) {
        goto exit;
    }

    Assert(hFile != INVALID_HANDLE_VALUE);

    // Find name props and last chosen property
    for (i = 0; i < ulcFields; i++) {
        if (lpImportMapping[i].fChosen) {
            ulLastChosenProp = i;
        }

        switch (lpImportMapping[i].ulPropTag) {
            case PR_EMAIL_ADDRESS:
                iEmailAddress = i;
                break;

            case PR_DISPLAY_NAME:
                iDisplayName = i;
                break;

            case PR_SURNAME:
                iSurname = i;
                break;

            case PR_GIVEN_NAME:
                iGivenName = i;
                break;

            case PR_COMPANY_NAME:
                iCompanyName = i;
                break;

            case PR_MIDDLE_NAME:
                iMiddleName = i;
                break;

            case PR_NICKNAME:
                iNickname = i;
                break;
        }
    }

    //
    // Open the WAB's PAB container: fills global lpCreateEIDsWAB
    //
    if (hResult = LoadWABEIDs(lpAdrBook, &lpContainer)) {
        goto exit;
    }

    //
    // All set... now loop through the file lines, adding each to the WAB
    //

    // How many lines are there?
    if (hResult = CountCSVRows(hFile, szSep, &ulcEntries)) {
        goto exit;
    }
    DebugTrace("CSV file contains %u entries\n", ulcEntries);

    // Initialize the Progress Bar
    Progress.denominator = max(ulcEntries, 1);
    Progress.numerator = 0;
    if (LoadString(hInst, IDS_STATE_IMPORT_MU, szBuffer, sizeof(szBuffer))) {
        DebugTrace("Status Message: %s\n", szBuffer);
        Progress.lpText = szBuffer;
    } else {
        DebugTrace("Cannot load resource string %u\n", IDS_STATE_IMPORT_MU);
        Progress.lpText = NULL;
    }
    lpProgressCB(hWnd, &Progress);


    while (hResult == hrSuccess) {
        // Read the CSV attributes
        if (hResult = ReadCSVLine(hFile, szSep, &cProps, &rgItems)) {
            DebugTrace("ReadCSVLine -> %x\n", GetScode(hResult));
            if (GetScode(hResult) == MAPI_E_NOT_FOUND) {
                // EOF
                hResult = hrSuccess;
            }
            break;      // nothing more to read
        }

        iDisplay = iDisplayName;

        if (TestCSVName(iEmailAddress,
          lpImportMapping,
          ulcFields,
          rgItems,
          cProps,
          TRUE)) {
            lpEmailAddress = rgItems[iEmailAddress];
        }

        switch (index = MakeDisplayName(&lpDisplayName,
          lpImportMapping,
          ulcFields,
          rgItems,
          cProps,
          iDisplayName,
          iNickname,
          iSurname,
          iGivenName,
          iMiddleName,
          iEmailAddress,
          iCompanyName)) {
            case NOT_FOUND:

                // No name props
                // BUGBUG: Should give special error?
                break;

            case INDEX_FIRST_MIDDLE_LAST:

                break;

            default:
                iDisplay = index;
                break;
        }


        // Should be the same number of fields in every entry, but if not,
        // we'll handle it below.
        // Assert(cProps == ulcFields); // Outlook does this!

        ulCreateFlags = CREATE_CHECK_DUP_STRICT;
        if (lpOptions->ReplaceOption ==  WAB_REPLACE_ALWAYS) {
            ulCreateFlags |= CREATE_REPLACE;
        }
retry:

        // Create a new wab mailuser
        if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(lpContainer,
          lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
          (LPENTRYID)lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
          ulCreateFlags,
          &lpMailUserWAB))) {
            DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
            goto exit;
        }


        for (i = 0; i <= min(ulLastChosenProp, cProps); i++)
        {
            if (lpImportMapping[i].fChosen && lpImportMapping[i].lpszName)
            {
                if (rgItems[i] && *rgItems[i]) {
                    // Look it up in the WAB property names table

                    DebugTrace("Prop %u: <%s> %s\n", i, lpImportMapping[i].lpszName, rgItems[i]);

                    sPropVal.ulPropTag = lpImportMapping[i].ulPropTag;

                    Assert(PROP_TYPE(lpImportMapping[i].ulPropTag) == PT_TSTRING);
                    sPropVal.Value.LPSZ = rgItems[i];

                    fSkipSetProps = FALSE;
                    if (sPropVal.ulPropTag == PR_EMAIL_ADDRESS)
                    {
                        if (! IsInternetAddress(sPropVal.Value.LPSZ))
                        {
                            DebugTrace("Found non-SMTP address %s\n", sPropVal.Value.LPSZ);

                            if (HandleImportError(hWnd,
                              0,
                              WAB_W_BAD_EMAIL,
                              lpDisplayName,
                              lpEmailAddress,
                              lpOptions))
                            {
                                hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                goto exit;
                            }

                            lpEmailAddress = NULL;
                            fSkipSetProps = TRUE;
                        }
                    }

                    if (! fSkipSetProps)
                    {
                        // Set the property on the WAB entry
                        if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
                          1,                        // cValues
                          &sPropVal,                // property array
                          NULL)))
                        {                 // problems array
                            DebugTrace("ImportEntry:SetProps(WAB) -> %x\n", GetScode(hResult));
                            goto exit;
                        }

                        // [PaulHi] 3/4/99  Raid 73637
                        // If we have a valid email address then we need to also add the
                        // PR_ADDRTYPE property set to "SMTP".
                        if (sPropVal.ulPropTag == PR_EMAIL_ADDRESS)
                        {
                            sPropVal.ulPropTag = PR_ADDRTYPE;
                            sPropVal.Value.LPSZ = (LPTSTR)szSMTP;
                            hResult = lpMailUserWAB->lpVtbl->SetProps(
                                                lpMailUserWAB,
                                                1,
                                                &sPropVal,
                                                NULL);
                            if (HR_FAILED(hResult))
                            {
                                DebugTrace("CSV ImportEntry:SetProps(WAB) for PR_ADDRTYPE -> %x\n", GetScode(hResult));
                                goto exit;
                            }

                        }

                    }
                }
            }
        }

        if (index != iDisplayName && index != NOT_FOUND && index != INDEX_FIRST_MIDDLE_LAST) {
            // Set the PR_DISPLAY_NAME
            sPropVal.ulPropTag = PR_DISPLAY_NAME;
            sPropVal.Value.LPSZ = rgItems[index];

            // Set the property on the WAB entry
            if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
              1,                        // cValues
              &sPropVal,                // property array
              NULL))) {                 // problems array
                DebugTrace("ImportEntry:SetProps(WAB) -> %x\n", GetScode(hResult));
                goto exit;
            }
        }


        // Save the new wab mailuser or distlist
        if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
          KEEP_OPEN_READONLY | FORCE_SAVE))) {

            if (GetScode(hResult) == MAPI_E_COLLISION) {
                /*
                // Find the display name
                Assert(lpDisplayName);
                if (! lpDisplayName) {
                    DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                    goto exit;
                }
                */ // WAB replaces no Display Names with Unknown

                // Do we need to prompt?
                if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
                    // Prompt user with dialog.  If they say YES, we should try again


                    RI.lpszDisplayName = lpDisplayName ? lpDisplayName : "";
                    RI.lpszEmailAddress = lpEmailAddress;
                    RI.ConfirmResult = CONFIRM_ERROR;
                    RI.lpImportOptions = lpOptions;

                    DialogBoxParam(hInst,
                      MAKEINTRESOURCE(IDD_ImportReplace),
                      hWnd,
                      ReplaceDialogProc,
                      (LPARAM)&RI);

                    switch (RI.ConfirmResult) {
                        case CONFIRM_YES:
                        case CONFIRM_YES_TO_ALL:
                            // YES
                            // NOTE: recursive Migrate will fill in the SeenList entry
                            // go try again!
                            lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                            lpMailUserWAB = NULL;

                            ulCreateFlags |= CREATE_REPLACE;
                            goto retry;
                            break;

                        case CONFIRM_ABORT:
                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                            goto exit;

                        default:
                            // NO
                            break;
                    }
                }
                hResult = hrSuccess;

            } else {
                DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
            }
        }

        // Clean up
        if (rgItems) {
            for (i = 0; i < cProps; i++) {
                if (rgItems[i]) {
                    LocalFree(rgItems[i]);
                }
            }
            LocalFree(rgItems);
            rgItems = NULL;
        }

        // Update progress bar
        Progress.numerator++;
        // TEST CODE!
        if (Progress.numerator == Progress.denominator) {
            // Done?  Do I need to do anything?
        }

        lpProgressCB(hWnd, &Progress);
        if (lpMailUserWAB) {
            lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
            lpMailUserWAB = NULL;
        }

        if (lpDisplayName) {
            LocalFree(lpDisplayName);
            lpDisplayName = NULL;
        }


//        if (hResult) {
//            if (HandleExportError(hWnd, 0, hResult, lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ)) {
//                hResult = ResultFromScode(MAPI_E_USER_CANCEL);
//            } else {
//                hResult = hrSuccess;
//            }
//        }

    }

exit:
    if (hFile) {
        CloseHandle(hFile);
    }

    if (lpDisplayName) {
        LocalFree(lpDisplayName);
    }

    // Don't free lpEmailAddress!  It's part of the rgItems below.


    // Free the WAB objects
    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
    }
    if (lpContainer) {
        lpContainer->lpVtbl->Release(lpContainer);
    }

    // Free the prop name strings
    for (i = 0; i < NUM_EXPORT_PROPS; i++) {
        if (rgPropNames[i].lpszName) {
            LocalFree(rgPropNames[i].lpszName);
        }
    }

    // Free any CSV attributes left
    if (rgItems) {
        for (i = 0; i < cProps; i++) {
            if (rgItems[i]) {
                LocalFree(rgItems[i]);
            }
        }
        LocalFree(rgItems);
    }

    if (lpCreateEIDsWAB) {
        WABFreeBuffer(lpCreateEIDsWAB);
        lpCreateEIDsWAB = NULL;
    }


    return(hResult);
}



/***************************************************************************

    Name      : CreateCSVFile

    Purpose   : Creates a CSV file for export

    Parameters: hwnd = main dialog window
                lpFileName = filename to create
                lphFile -> returned file handle

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT CreateCSVFile(HWND hwnd, LPTSTR lpFileName, LPHANDLE lphFile) {
    LPTSTR lpFilter;
    TCHAR szFileName[MAX_PATH + 1] = "";
    OPENFILENAME ofn;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HRESULT hResult = hrSuccess;


    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(lpFileName,
      GENERIC_WRITE,	
      0,    // sharing
      NULL,
      CREATE_NEW,
      FILE_FLAG_SEQUENTIAL_SCAN,	
      NULL))) {
        if (GetLastError() == ERROR_FILE_EXISTS) {
            // Ask user if they want to overwrite
            switch (ShowMessageBoxParam(hwnd, IDE_CSV_EXPORT_FILE_EXISTS, MB_ICONEXCLAMATION | MB_YESNO | MB_SETFOREGROUND, lpFileName)) {
                case IDYES:
                    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(lpFileName,
                      GENERIC_WRITE,	
                      0,    // sharing
                      NULL,
                      CREATE_ALWAYS,
                      FILE_FLAG_SEQUENTIAL_SCAN,	
                      NULL))) {
                        ShowMessageBoxParam(hwnd, IDE_CSV_EXPORT_FILE_ERROR, MB_ICONERROR, lpFileName);
                        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                    }
                    break;

                default:
                    DebugTrace("ShowMessageBoxParam gave unknown return\n");

                case IDNO:
                    // nothing to do here
                    hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    break;
            }
        } else {
            ShowMessageBoxParam(hwnd, IDE_CSV_EXPORT_FILE_ERROR, MB_ICONERROR, lpFileName);
            hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        }
    }

    if (! hResult) {
        *lphFile = hFile;
    }
    return(hResult);
}


/***************************************************************************

    Name      : WriteCSV

    Purpose   : Writes a string to a CSV file with fixups for special characters

    Parameters: hFile = file handle
                fFixup = TRUE if we should check for special characters
                lpString = nul-terminated string to write
                szSep = list separator (only needed if fFixup is TRUE)

    Returns   : HRESULT

    Comment   : CSV special characters are szSep, CR and LF.  If they occur in
                the string, we should wrap the entire string in quotes.

***************************************************************************/
HRESULT WriteCSV(HANDLE hFile, BOOL fFixup, const UCHAR * lpString, LPTSTR szSep) {
    HRESULT hResult = hrSuccess;
    ULONG cWrite = lstrlen((LPTSTR)lpString);
    ULONG cbWritten;
    BOOL fQuote = FALSE;
    register ULONG i;
    ULONG ec;
    LPTSTR szSepT;

    // Is there a szSep, a CR or a LF in the string?
    // If so, enclose the string in quotes.
    if (fFixup) {
        szSepT = szSep;
        for (i = 0; i < cWrite && ! fQuote; i++) {
            if (lpString[i] == (UCHAR)(*szSepT)) {
                szSepT++;
                if (*szSepT == '\0')
                    fQuote = TRUE;
            } else {
                szSepT = szSep;
                if ((lpString[i] == '\n') || (lpString[i] == '\r'))
                    fQuote = TRUE;
            }
        }
    }

    if (fQuote) {
        if (! WriteFile(hFile,
          szQuote,
          1,
          &cbWritten,
          NULL)) {
            ec = GetLastError();

            DebugTrace("WriteCSV:WriteFile -> %u\n", ec);
            if (ec == ERROR_HANDLE_DISK_FULL ||
                ec == ERROR_DISK_FULL) {
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_DISK);
            } else {
                hResult = ResultFromScode(MAPI_E_DISK_ERROR);
            }
            goto exit;
        }
    }

    if (! WriteFile(hFile,
      lpString,
      cWrite,
      &cbWritten,
      NULL)) {
        ec = GetLastError();

        DebugTrace("WriteCSV:WriteFile -> %u\n", ec);
        if (ec == ERROR_HANDLE_DISK_FULL ||
            ec == ERROR_DISK_FULL) {
            hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_DISK);
        } else {
            hResult = ResultFromScode(MAPI_E_DISK_ERROR);
        }
        goto exit;
    }

    if (fQuote) {
        if (! WriteFile(hFile,
          szQuote,
          1,
          &cbWritten,
          NULL)) {
            ec = GetLastError();

            DebugTrace("WriteCSV:WriteFile -> %u\n", ec);
            if (ec == ERROR_HANDLE_DISK_FULL ||
                ec == ERROR_DISK_FULL) {
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_DISK);
            } else {
                hResult = ResultFromScode(MAPI_E_DISK_ERROR);
            }
            goto exit;
        }
    }
exit:
    return(hResult);
}


HRESULT ExportCSVMailUser(HANDLE hFile,
  ULONG ulPropNames,
  ULONG ulLastProp,
  LPPROP_NAME lpPropNames,
  LPSPropTagArray lppta,
  LPTSTR szSep,
  LPADRBOOK lpAdrBook,
  ULONG cbEntryID,
  LPENTRYID lpEntryID) {
    HRESULT hResult = hrSuccess;
    LPMAILUSER lpMailUser = NULL;
    ULONG ulObjType;
    ULONG cProps;
    LPSPropValue lpspv = NULL;
    ULONG i;
    const UCHAR szCRLF[] = "\r\n";
    UCHAR szBuffer[11] = "";


    if (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
       cbEntryID,
       lpEntryID,
       NULL,
       0,
       &ulObjType,
       (LPUNKNOWN *)&lpMailUser)) {
        DebugTrace("WAB OpenEntry(mailuser) -> %x\n", GetScode(hResult));
        goto exit;
    }

    if ((HR_FAILED(hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
      lppta,
      0,
      &cProps,
      &lpspv)))) {
        DebugTrace("ExportCSVMailUser: GetProps() -> %x\n", GetScode(hResult));
        goto exit;
    }

    for (i = 0; i < ulPropNames; i++) {

        if (rgPropNames[i].fChosen) {
            // Output the value
            switch (PROP_TYPE(lpspv[i].ulPropTag)) {
                case PT_TSTRING:
                    if (hResult = WriteCSV(hFile, TRUE, lpspv[i].Value.LPSZ, szSep)) {
                        goto exit;
                    }
                    break;

                case PT_LONG:
                    wnsprintf(szBuffer, ARRAYSIZE(szBuffer), "%u", lpspv[i].Value.l);
                    if (hResult = WriteCSV(hFile, TRUE, szBuffer, szSep)) {
                        goto exit;
                    }
                    break;

                default:
                    DebugTrace("CSV export: unsupported property 0x%08x\n", lpspv[i].ulPropTag);
                    Assert(FALSE);
                    // fall through to skip
                case PT_ERROR:
                    // skip it.
                    break;
            }

            if (i != ulLastProp) {
                // Output the seperator
                if (hResult = WriteCSV(hFile, FALSE, szSep, NULL)) {
                    goto exit;
                }
            }
        }
    }

    if (hResult = WriteCSV(hFile, FALSE, szCRLF, NULL)) {
        goto exit;
    }


exit:
    if (lpspv) {
        WABFreeBuffer(lpspv);
    }

    if (lpMailUser) {
        lpMailUser->lpVtbl->Release(lpMailUser);
    }

    return(hResult);
}


HRESULT CSVExport(HWND hWnd,
  LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_EXPORT_OPTIONS lpOptions) {
    HRESULT hResult = hrSuccess;
    register ULONG i;
    ULONG cbWABEID, ulObjType;
    ULONG ulLastChosenProp = 0;
    WAB_PROGRESS Progress;
    ULONG cRows = 0;
    LPSRowSet lpRow = NULL;
    ULONG ulCount = 0;
    SRestriction restrictObjectType;
    SPropValue spvObjectType;
    LPENTRYID lpWABEID = NULL;
    LPABCONT lpContainer = NULL;
    LPMAPITABLE lpContentsTable = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPSPropTagArray lppta = NULL;
    const UCHAR szCRLF[] = "\r\n";
    TCHAR szSep[MAX_SEP];
    TCHAR rgFileName[MAX_PATH + 1] = "";

    SetGlobalBufferFunctions(lpWABObject);

    // Read in the Property Name strings
    for (i = 0; i < NUM_EXPORT_PROPS; i++) {
        rgPropNames[i].lpszName = LoadAllocString(rgPropNames[i].ids);
        Assert(rgPropNames[i].lpszName);
        DebugTrace("Property 0x%08x name: %s\n", rgPropNames[i].ulPropTag, rgPropNames[i].lpszName);
    }

    // Present UI Wizard
    if (hResult = ExportWizard(hWnd, rgFileName, ARRAYSIZE(rgFileName), rgPropNames)) {
        goto exit;
    }

    // Find the last prop name chosen
    for (i = NUM_EXPORT_PROPS - 1; i > 0; i--) {
        if (rgPropNames[i].fChosen) {
            ulLastChosenProp = i;
            break;
        }
    }

    //
    // Open the WAB's PAB container
    //
    if (hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook,
      &cbWABEID,
      &lpWABEID)) {
        DebugTrace("WAB GetPAB -> %x\n", GetScode(hResult));
        goto exit;
    } else {
        if (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
          cbWABEID,     // size of EntryID to open
          lpWABEID,     // EntryID to open
          NULL,         // interface
          0,            // flags
          &ulObjType,
          (LPUNKNOWN *)&lpContainer)) {
            DebugTrace("WAB OpenEntry(PAB) -> %x\n", GetScode(hResult));
            goto exit;
        }
    }


    //
    // All set... now loop through the WAB's entries, exporting each one
    //
    if (HR_FAILED(hResult = lpContainer->lpVtbl->GetContentsTable(lpContainer,
      0,    // ulFlags
      &lpContentsTable))) {
        DebugTrace("WAB GetContentsTable(PAB Table) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Set the columns to those we're interested in
    if (hResult = lpContentsTable->lpVtbl->SetColumns(lpContentsTable,
      (LPSPropTagArray)&ptaColumns,
      0)) {
        DebugTrace("WAB SetColumns(PAB Table) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Restrict the table to MAPI_MAILUSERs
    spvObjectType.ulPropTag = PR_OBJECT_TYPE;
    spvObjectType.Value.l = MAPI_MAILUSER;

    restrictObjectType.rt = RES_PROPERTY;
    restrictObjectType.res.resProperty.relop = RELOP_EQ;
    restrictObjectType.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
    restrictObjectType.res.resProperty.lpProp = &spvObjectType;

    if (HR_FAILED(hResult = lpContentsTable->lpVtbl->Restrict(lpContentsTable,
      &restrictObjectType,
      0))) {
        DebugTrace("WAB Restrict (MAPI_MAILUSER) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // How many MailUser entries are there?
    ulcEntries = CountRows(lpContentsTable, FALSE);
    DebugTrace("WAB contains %u MailUser entries\n", ulcEntries);

    if (ulcEntries == 0) {
        DebugTrace("WAB has no entries, nothing to export.\n");
        goto exit;
    }

    // Initialize the Progress Bar
    Progress.denominator = max(ulcEntries, 1);
    Progress.numerator = 0;
    Progress.lpText = NULL;
    lpProgressCB(hWnd, &Progress);


    // Write out the property names
    GetListSeparator(szSep);

    // Create the file (and handle error UI)
    if (hResult = CreateCSVFile(hWnd, rgFileName, &hFile)) {
        goto exit;
    }

    for (i = 0; i < NUM_EXPORT_PROPS; i++) {
        // Output the name
        if (rgPropNames[i].fChosen) {
            if (hResult = WriteCSV(hFile, TRUE, rgPropNames[i].lpszName, szSep)) {
                goto exit;
            }

            if (i != ulLastChosenProp) {
                // Output the seperator
                if (hResult = WriteCSV(hFile, FALSE, szSep, NULL)) {
                    goto exit;
                }
            }
        }
    }
    if (hResult = WriteCSV(hFile, FALSE, szCRLF, NULL)) {
        goto exit;
    }


    // Map the prop name array to a SPropTagArray.
    lppta = LocalAlloc(LPTR, CbNewSPropTagArray(NUM_EXPORT_PROPS));
    lppta->cValues = NUM_EXPORT_PROPS;
    for (i = 0; i < lppta->cValues; i++) {
        lppta->aulPropTag[i] = rgPropNames[i].ulPropTag;
    }


    cRows = 1;

    while (cRows && hResult == hrSuccess) {

        // Get the next WAB entry
        if (hResult = lpContentsTable->lpVtbl->QueryRows(lpContentsTable,
          1,    // one row at a time
          0,    // ulFlags
          &lpRow)) {
            DebugTrace("QueryRows -> %x\n", GetScode(hResult));
            goto exit;
        }

        if (lpRow) {
            if (cRows = lpRow->cRows) { // Yes, single '='
                Assert(lpRow->cRows == 1);
                Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
                Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
                Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

                if (cRows = lpRow->cRows) { // yes, single '='

                    // Export mailuser
                    if (hResult = ExportCSVMailUser(hFile,
                      NUM_EXPORT_PROPS,
                      ulLastChosenProp,
                      rgPropNames,
                      lppta,
                      szSep,
                      lpAdrBook,
                      lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                      (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb)) {

                        goto exit;
                    }


                    // Update progress bar
                    Progress.numerator++;
                    lpProgressCB(hWnd, &Progress);

                    if (hResult) {
                        if (HandleExportError(hWnd,
                          0,
                          hResult,
                          lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                          PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                          lpOptions)) {
                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        } else {
                            hResult = hrSuccess;
                        }
                    }
                } // else, drop out of loop, we're done.
            }
            WABFreeProws(lpRow);
        }
    }

exit:
    if (hFile) {
        CloseHandle(hFile);
    }


    if (lppta) {
        LocalFree(lppta);
    }

    // Free the WAB objects
    WABFreeBuffer(lpWABEID);
    lpWABEID = NULL;
    if (lpContainer) {
        lpContainer->lpVtbl->Release(lpContainer);
        lpContainer = NULL;
    }
    if (lpContentsTable) {
        lpContentsTable->lpVtbl->Release(lpContentsTable);
        lpContentsTable = NULL;
    }


    // Free the prop name strings
    for (i = 0; i < NUM_EXPORT_PROPS; i++) {
        if (rgPropNames[i].lpszName) {
            LocalFree(rgPropNames[i].lpszName);
        }
    }

    return(hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\csvparse.c ===
/*
 *  CSVParse.C
 *
 *  CSV Parsing functions
 *
 *  Copyright 1997 Microsoft Corporation.  All Rights Reserved.
 */
#include <windows.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include "dbgutil.h"
#include <shlwapi.h>

#define CR_CHAR 0x0d
#define LF_CHAR 0x0a
#define CCH_READ_BUFFER 256
#define NUM_ITEM_SLOTS  32

/***************************************************************************

    Name      : ReadCSVChar

    Purpose   : Reads a single char from a file

    Parameters: hFile = file handle
                pcbBuffer = pointer to size of buffer
                lppBuffer = pointer to pointer to buffer
                lppRead = pointer to pointer to next location to use

    Returns   : -1 = Out of memory
                0 = End of file
                1 = Char successfully read

    Comment   : Dynamically grows *lppBuffer as necessary

***************************************************************************/
int ReadCSVChar(HANDLE hFile, int *pcbBuffer, PUCHAR *lppBuffer, PUCHAR *lppRead)
{
    int cbOffset;
	ULONG cbReadFile;
    PUCHAR lpBuffer;

    cbOffset = (int) (*lppRead - *lppBuffer);
    if (cbOffset >= *pcbBuffer)
    {
        // Buffer is too small.  Reallocate!
        *pcbBuffer += CCH_READ_BUFFER;
        
        if (! (lpBuffer = LocalReAlloc(*lppBuffer, *pcbBuffer, LMEM_MOVEABLE | LMEM_ZEROINIT))) 
        {
            DebugTrace("LocalReAlloc(%u) -> %u\n", *pcbBuffer, GetLastError());
            return(-1);
        }
        *lppBuffer = lpBuffer;
        *lppRead = *lppBuffer + cbOffset;
    }

    // 1 character at a time
    if (ReadFile(hFile, *lppRead, 1, &cbReadFile, NULL) && cbReadFile)
        return(1);
	return(0);
}

/***************************************************************************

    Name      : ReadCSVItem

    Purpose   : Reads an item from a CSV file

    Parameters: hFile = file handle
                pcbBuffer = pointer to size of buffer
                lppBuffer = pointer to pointer to buffer
                szSep = current separator string

    Returns   : -1 = Out of memory
                0 = Item read in, and none left
                1 = Item read in, more items left

    Comment   : CSV special characters are '"', szSep, CR and LF.

                Rules for quotes:
                1. If an item starts with a '"', then the item is quoted
                   and must end with a '"'.
                2. Any '"' characters found in a non-quoted string will not
                   be treated specially.  Technically, there should not be
                   quotes in a non-quoted string, but we have to do
                   something if we find one.
                3. A quoted item ends with:
                   a) quote szSep
                   b) quote newline
                   or, c) quote <EOF>
                4. Two quotes together in a quoted string are translated
                   into a single quote.

***************************************************************************/
int ReadCSVItem(HANDLE hFile, int *pcbBuffer, PUCHAR *lppBuffer, LPTSTR szSep)
{
    BOOL fQuoted, fDone, fFoundSepCh;
    int cbReadFile;
    PUCHAR lpRead, szSepT;

    // This function is always called with one character already read
    lpRead = *lppBuffer;
    if (*lpRead == '"')
    {
        fQuoted = TRUE;
        cbReadFile = ReadCSVChar(hFile, pcbBuffer, lppBuffer, &lpRead);
    }
    else
    {
        fQuoted = FALSE;
        cbReadFile = 1;
    }
    szSepT = szSep;
    fDone = FALSE;
    do
    {
        if (cbReadFile <= 0)
        {
            // End of file means end of item
            if (cbReadFile == 0)
                *lpRead = '\0';
            break;
        }
        fFoundSepCh = FALSE;
        switch (*lpRead)
        {
            case CR_CHAR:
            case LF_CHAR:
                if (!fQuoted)
                {
                    // End of line and item
                    *lpRead = '\0';
                    cbReadFile = 0;
                    fDone = TRUE;
                }
                break;
            case '"':
                if (fQuoted)
                {
                    // See if the next character is a quote, CR, or LF
                    lpRead++;
                    cbReadFile = ReadCSVChar(hFile, pcbBuffer, lppBuffer, &lpRead);
                    if ((cbReadFile <= 0) || (*lpRead == '"') || (*lpRead == CR_CHAR) || (*lpRead == LF_CHAR))
                    {
                        if ((cbReadFile <= 0) || (*lpRead != '"'))
                        {
                            if (cbReadFile >= 0)
                            {
                                // End of file, or CR or LF
                                *(lpRead - 1) = '\0';
                                cbReadFile = 0;
                            }
                            // else out of memory
                            fDone = TRUE;
                        }
                        else
                        {
                            // Embedded quote - get rid of one
                            lpRead--;
                        }
                        break;
                    }
                    // We have read another character, and it is not a quote, CR, or LF
                    // Two possibilities:
                    // 1) Separator
                    // 2) Something else - this is an error condition
                    szSepT = szSep;
                    while ((cbReadFile > 0) && (*szSepT != '\0') && (*lpRead == *szSepT))
                    {
                        szSepT++;
                        if (*szSepT != '\0')
                        {
                            lpRead++;
                            cbReadFile = ReadCSVChar(hFile, pcbBuffer, lppBuffer, &lpRead);
                        }
                    }
                    if ((cbReadFile <= 0) || (*szSepT == '\0'))
                    {
                        if (cbReadFile >= 0)
                        {
                            // If cbReadFile is zero, we hit the end of file
                            // before finding the complete separator.  In this
                            // case, we simply take every character we have
                            // read, including the second quote, and use that
                            // as the item.
                            //
                            // Otherwise, we found the complete separator.
                            if (cbReadFile > 0)
                                lpRead -= lstrlen(szSep);
                            *lpRead = '\0';
                        }
                        fDone = TRUE;
                    }
                    else
                    {
                        // We found a second quote, but it was not followed by a
                        // separator.  In this case, we keep reading as if we are
                        // in an unquoted string.
                        fQuoted = FALSE;
                    }
                }
                break;
            default:
                if (!fQuoted)
                {
                    if (*lpRead == *szSepT)
                    {
                        szSepT++;
                        if (*szSepT == '\0')
                        {
                            // End of separator, thus end of item
                            lpRead -= (lstrlen(szSep) - 1);
                            *lpRead = '\0';
                            fDone = TRUE;
                        }
                        else
                            fFoundSepCh = TRUE;
                    }
                }
                break;
        }
        if (!fDone)
        {
            if (!fFoundSepCh)
                szSepT = szSep;
            lpRead++;
            cbReadFile = ReadCSVChar(hFile, pcbBuffer, lppBuffer, &lpRead);
        }
    }
    while (!fDone);
    return(cbReadFile);
}

/***************************************************************************

    Name      : InsertItem

    Purpose   : Takes an item read from the file and inserts it into the array

    Parameters: iItem = array index to insert
                pcItemSlots = number of currently allocated elements
                cGrow = number of items to grow the array by, if necessary
                prgItemSlots = pointer to the actual array
                lpBuffer = string to insert

    Returns   : TRUE = item successfully inserted
                FALSE = out of memory

***************************************************************************/
BOOL InsertItem(int iItem, int *pcItemSlots, int cGrow, PUCHAR **prgItemSlots, PUCHAR lpBuffer)
{
    PUCHAR *rgItemSlotsNew, lpItem;

    // Make sure there's room, first
    if (iItem >= *pcItemSlots) 
    {
        // Array is too small.  Reallocate!
        *pcItemSlots += cGrow;
        rgItemSlotsNew = LocalReAlloc(*prgItemSlots, *pcItemSlots * sizeof(PUCHAR), LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (!rgItemSlotsNew)
        {
            DebugTrace("LocalReAlloc(%u) -> %u\n", *pcItemSlots * sizeof(PUCHAR), GetLastError());
            return(FALSE);
        }
        *prgItemSlots = rgItemSlotsNew;
    }

    lpItem = LocalAlloc(LPTR, lstrlen(lpBuffer) + 1);
    if (!lpItem)
    {
        DebugTrace("LocalAlloc(%u) -> %u\n", lstrlen(lpBuffer) + 1, GetLastError());
        return(FALSE);
    }

    StrCpyN(lpItem, lpBuffer, lstrlen(lpBuffer) + 1);
    (*prgItemSlots)[iItem] = lpItem;

    return(TRUE);
}

/***************************************************************************

    Name      : ReadCSVLine                      x

    Purpose   : Reads a line from a CSV file with fixups for special characters

    Parameters: hFile = file handle
                szSep = list separator of the current regional settings
                lpcItems -> Returned number of items
                lprgItems -> Returned array of item strings.  Caller is
                  responsible for LocalFree'ing each string pointer and
                  this array pointer.

    Returns   : HRESULT

    Comment   : Calls the above helper functions to do most of the work.

***************************************************************************/
HRESULT ReadCSVLine(HANDLE hFile, LPTSTR szSep, ULONG * lpcItems, PUCHAR ** lpprgItems) {
    HRESULT hResult = hrSuccess;
    register ULONG i;
    PUCHAR lpBuffer  = NULL, lpRead, lpItem;
    ULONG cbBuffer = 0;
    int cbReadFile = -1;
    UCHAR chLastChar;
    ULONG iItem = 0;
    ULONG cItemSlots = 0;
    PUCHAR * rgItemSlots = NULL;
    LPTSTR szSepT;


    // Start out with 1024 character buffer.  Realloc as necesary.
    cbBuffer = CCH_READ_BUFFER;
    if (! (lpRead = lpBuffer = LocalAlloc(LPTR, cbBuffer))) {
        DebugTrace("LocalAlloc(%u) -> %u\n", cbBuffer, GetLastError());
        goto exit;
    }

    // Start out with 32 item slots.  Realloc as necesary.
    cItemSlots = NUM_ITEM_SLOTS;
    if (! (rgItemSlots = LocalAlloc(LPTR, cItemSlots * sizeof(PUCHAR)))) {
        DebugTrace("LocalAlloc(%u) -> %u\n", cItemSlots * sizeof(PUCHAR), GetLastError());
        goto exit;
    }

    // Skip past leading CR/LF characters
    do
        cbReadFile = ReadCSVChar(hFile, &cbBuffer, &lpBuffer, &lpRead);
    while((cbReadFile > 0) && ((*lpBuffer == CR_CHAR) || (*lpBuffer == LF_CHAR)));
 
    if (cbReadFile == 0)
    {
        // Nothing to return
        DebugTrace("ReadFile -> EOF\n");
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
    }

    // Read items until end of line or EOF
    while (cbReadFile > 0) 
    {
        cbReadFile = ReadCSVItem(hFile, &cbBuffer, &lpBuffer, szSep);
        if (cbReadFile >= 0)
        {
            // Dup the item into the next array slot.
            if (!InsertItem(iItem, &cItemSlots, cbReadFile ? NUM_ITEM_SLOTS : 1, &rgItemSlots, lpBuffer))
                cbReadFile = -1;
            else
                iItem++;

            if (cbReadFile > 0)
            {
                // More data to be read                
                lpRead = lpBuffer;
                cbReadFile = ReadCSVChar(hFile, &cbBuffer, &lpBuffer, &lpRead);
            }
        }
    }

exit:
    if (cbReadFile < 0)
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);

    if (lpBuffer) 
    {
        LocalFree(lpBuffer);
    }

    if (hResult) 
    {
        // Clean up
        if (rgItemSlots) 
        {
            for (i = 0; i < iItem; i++) 
            {
                if (rgItemSlots[i]) 
                {
                    LocalFree(rgItemSlots[i]);
                }
            }
            LocalFree(rgItemSlots);
        }
        *lpcItems = 0;
        *lpprgItems = NULL;
    } 
    else 
    {
        *lpcItems = iItem;  // One based
        *lpprgItems = rgItemSlots;
    }
    return(hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\csvpick.c ===
/*                                  r
 *  CSVPick.C
 *
 *  Picker wizard for CSV import/export
 *
 *  Copyright 1997 Microsoft Corporation.  All Rights Reserved.
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include "wabimp.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"
#include <shlwapi.h>

const TCHAR szCSVFilter[] = "*.csv";
const TCHAR szCSVExt[] = "csv";

#define CHECK_BITMAP_WIDTH  16
typedef struct {
    LPPROP_NAME rgPropNames;
    LPPROP_NAME * lppImportMapping;
    LPHANDLE lphFile;
    LPULONG lpcFields;
    LPTSTR szSep;
} PROPSHEET_DATA, * LPPROPSHEET_DATA;


TCHAR szCSVFileName[MAX_PATH + 1] = "";


INT_PTR CALLBACK ExportPickFieldsPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ExportFilePageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ImportFilePageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ImportMapFieldsPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ChangeMappingDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);


/***************************************************************************

    Name      : FillInPropertyPage

    Purpose   : Fills in the given PROPSHEETPAGE structure

    Parameters: psp -> property sheet page structure
                idDlg = dialog id
                pszProc = title for page
                pfnDlgProc -> Dialog procedure
                lParam = application specified data

    Returns   : none

    Comment   : This function fills in a PROPSHEETPAGE structure with the
                information the system needs to create the page.

***************************************************************************/
void FillInPropertyPage(PROPSHEETPAGE* psp, int idDlg, LPSTR pszProc,
  DLGPROC pfnDlgProc, LPARAM lParam) {
    psp->dwSize = sizeof(PROPSHEETPAGE);
    psp->dwFlags = 0;
    psp->hInstance = hInst;
    psp->pszTemplate = MAKEINTRESOURCE(idDlg);
    psp->pszIcon = NULL;
    psp->pfnDlgProc = pfnDlgProc;
    psp->pszTitle = pszProc;
    psp->lParam = lParam;
}


/***************************************************************************

    Name      : HandleCheckMark

    Purpose   : Deals with setting the checkmark for a particular item in
                the listview.

    Parameters: hwndLV = ListView handle
                iItem = index of item to set
                rgTable = PROP_NAME table

    Returns   : none

    Comment   :

***************************************************************************/
void HandleCheckMark(HWND hWndLV, ULONG iItem, LPPROP_NAME rgTable) {
    // Locals
    LV_ITEM lvi;

    // Clear it
    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;
    ListView_GetItem(hWndLV, &lvi);
    rgTable[lvi.iItem].fChosen =
      ! rgTable[lvi.iItem].fChosen;

    ZeroMemory(&lvi, sizeof(LV_ITEM));
    lvi.mask = LVIF_STATE;
    lvi.iItem = iItem;
    lvi.state = rgTable[iItem].fChosen ?
      INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1) :
      INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);

    lvi.stateMask = LVIS_STATEIMAGEMASK;
    ListView_SetItem(hWndLV, &lvi);
}


/***************************************************************************

    Name      : HandleMultipleCheckMarks

    Purpose   : Deals with setting the checkmark for a bunch of selected
                items in the list view - basically sets every selected item
                to the toggled state of the first item in the selection

    Parameters: hwndLV = ListView handle
                rgTable = LPPROP_NAME table

    Returns   : none

    Comment   :

***************************************************************************/
void HandleMultipleCheckMarks(HWND hWndLV, LPPROP_NAME rgTable)
{
    // Locals
    LV_ITEM lvi;
    int nIndex = 0;
    BOOL fState = FALSE;

    // get the index of the first item
    nIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED);

    // toggle this item
    HandleCheckMark(hWndLV, nIndex, rgTable);

    fState = rgTable[nIndex].fChosen;

    while((nIndex = ListView_GetNextItem(hWndLV, nIndex, LVNI_SELECTED)) >= 0)
    {
        // Set all the other selected items to the same state

        rgTable[nIndex].fChosen = fState;

        ZeroMemory(&lvi, sizeof(LV_ITEM));
        lvi.mask = LVIF_STATE;
        lvi.iItem = nIndex;
        lvi.state = rgTable[nIndex].fChosen ?
          INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1) :
          INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);

        lvi.stateMask = LVIS_STATEIMAGEMASK;
        ListView_SetItem(hWndLV, &lvi);
    }
    return;
}


/***************************************************************************

    Name      : ExportWizard

    Purpose   : Present the Export Wizard

    Parameters: hwnd = parent window handle
                szFileName -> filename buffer (MAX_PATH + 1, please)
                rgPropNames -> property name list

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT ExportWizard(HWND hWnd, LPTSTR szFileName, ULONG cchSize, LPPROP_NAME rgPropNames) {
    HRESULT hResult = hrSuccess;
    PROPSHEETPAGE psp[NUM_EXPORT_WIZARD_PAGES];
    PROPSHEETHEADER psh;

    FillInPropertyPage(&psp[0], IDD_CSV_EXPORT_WIZARD_FILE, NULL, ExportFilePageProc, 0);
    FillInPropertyPage(&psp[1], IDD_CSV_EXPORT_WIZARD_PICK, NULL, ExportPickFieldsPageProc, 0);

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW | PSH_USEICONID;
    psh.hwndParent = hWnd;
    psh.pszCaption = NULL;
    psh.pszIcon = MAKEINTRESOURCE(IDI_WabMig);
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    psh.hIcon = NULL;
    psh.hInstance = hInst;
    psh.nStartPage = 0;
    psh.pStartPage = NULL;


    switch (PropertySheet(&psh)) {
        case -1:
            hResult = ResultFromScode(MAPI_E_CALL_FAILED);
            DebugTrace("PropertySheet failed -> %u\n", GetLastError());
            Assert(FALSE);
            break;
        case 0:
            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
            DebugTrace("PropertySheet cancelled by user\n");
            break;
        default:
            StrCpyN(szFileName, szCSVFileName, cchSize);
            break;
    }

    return(hResult);
}


/***************************************************************************

    Name      : ImportWizard

    Purpose   : Present the CSV Import Wizard

    Parameters: hwnd = parent window handle
                szFileName -> filename buffer (MAX_PATH + 1, please)
                rgPropNames -> property name list
                szSep -> list separator
                lppImportMapping -> returned property mapping table
                lpcFields -> returned size of property mapping table
                lphFile -> returned file handle to CSV file with header
                  row already parsed out.

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT ImportWizard(HWND hWnd, LPTSTR szFileName, ULONG cchSize, LPPROP_NAME rgPropNames,
  LPTSTR szSep, LPPROP_NAME * lppImportMapping, LPULONG lpcFields, LPHANDLE lphFile) {
    HRESULT hResult = hrSuccess;
    PROPSHEETPAGE psp[NUM_IMPORT_WIZARD_PAGES];
    PROPSHEETHEADER psh;
    PROPSHEET_DATA pd;

    pd.rgPropNames = rgPropNames;
    pd.lppImportMapping = lppImportMapping;
    pd.lphFile = lphFile;
    pd.lpcFields = lpcFields;
    pd.szSep = szSep;

    FillInPropertyPage(&psp[0], IDD_CSV_IMPORT_WIZARD_FILE, NULL, ImportFilePageProc, (LPARAM)&pd);
    FillInPropertyPage(&psp[1], IDD_CSV_IMPORT_WIZARD_MAP, NULL, ImportMapFieldsPageProc, (LPARAM)&pd);

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_WIZARD | PSH_NOAPPLYNOW | PSH_USEICONID;
    psh.hwndParent = hWnd;
    psh.pszCaption = NULL;
    psh.pszIcon = MAKEINTRESOURCE(IDI_WabMig);
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    psh.hIcon = NULL;
    psh.hInstance = hInst;
    psh.nStartPage = 0;
    psh.pStartPage = NULL;

    switch (PropertySheet(&psh)) {
        case -1:
            hResult = ResultFromScode(MAPI_E_CALL_FAILED);
            DebugTrace("PropertySheet failed -> %u\n", GetLastError());
            Assert(FALSE);
            break;
        case 0:
            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
            DebugTrace("PropertySheet cancelled by user\n");
            break;
        default:
            StrCpyN(szFileName, szCSVFileName, cchSize);
            break;
    }

    return(hResult);
}


/***************************************************************************

    Name      : ExportFilePageProc

    Purpose   : Process messages for "Export Filename" page

    Parameters: standard window proc parameters

    Returns   : standard window proc return

    Messages  : WM_INITDIALOG - intializes the page
                WM_NOTIFY - processes the notifications sent to the page

    Comment   :

***************************************************************************/
INT_PTR CALLBACK ExportFilePageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    static TCHAR szTempFileName[MAX_PATH + 1] = "";

    switch (message) {
        case WM_INITDIALOG:
            StrCpyN(szTempFileName, szCSVFileName, ARRAYSIZE(szTempFileName));
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                    case IDC_BROWSE:
                        SendDlgItemMessage(hDlg, IDE_CSV_EXPORT_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTempFileName);
                        SaveFileDialog(hDlg,
                          szTempFileName,
                          szCSVFilter,
                          IDS_CSV_FILE_SPEC,
                          szTextFilter,
                          IDS_TEXT_FILE_SPEC,
                          szAllFilter,
                          IDS_ALL_FILE_SPEC,
                          szCSVExt,
                          OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
                          hInst,
                          0,        // idsTitle
                          0);       // idsSaveButton
                        PropSheet_SetWizButtons(GetParent(hDlg), szTempFileName[0] ? PSWIZB_NEXT : 0);
                        SendMessage(GetDlgItem(hDlg, IDE_CSV_EXPORT_NAME), WM_SETTEXT, 0, (LPARAM)szTempFileName);
                    break;

                case IDE_CSV_EXPORT_NAME:
                    switch (HIWORD(wParam)) {   // notification code
                        case EN_CHANGE:
                            SendDlgItemMessage(hDlg, IDE_CSV_EXPORT_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTempFileName);
                            if ((ULONG)LOWORD(wParam) == IDE_CSV_EXPORT_NAME) {
                                PropSheet_SetWizButtons(GetParent(hDlg), szTempFileName[0] ? PSWIZB_NEXT : 0);
                            }
                            break;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code) {
                case PSN_KILLACTIVE:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return(1);

                case PSN_RESET:
                    // reset to the original values
                    StrCpyN(szTempFileName, szCSVFileName, ARRAYSIZE(szTempFileName));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), szTempFileName[0] ? PSWIZB_NEXT : 0);
                    SendMessage(GetDlgItem(hDlg, IDE_CSV_EXPORT_NAME), WM_SETTEXT, 0, (LPARAM)szTempFileName);
                    break;

                case PSN_WIZNEXT:
                    // the Next button was pressed
                    SendDlgItemMessage(hDlg, IDE_CSV_EXPORT_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTempFileName);
                    StrCpyN(szCSVFileName, szTempFileName, ARRAYSIZE(szCSVFileName));
                    break;

                default:
                    return(FALSE);
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}


/***************************************************************************

    Name      : ExportPickFieldsPageProc

    Purpose   : Process messages for "Pick Fields" page

    Parameters: standard window proc parameters

    Returns   : standard window proc return

    Messages  : WM_INITDIALOG - intializes the page
                WM_NOTIFY - processes the notifications sent to the page

    Comment   :

***************************************************************************/
INT_PTR CALLBACK ExportPickFieldsPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    HWND hWndLV;
    HIMAGELIST himl;
    LV_ITEM lvi;
    LV_COLUMN lvm;
    LV_HITTESTINFO lvh;
    POINT point;
    ULONG i, nIndex;
    NMHDR * pnmhdr;
    RECT rect;

    switch (message) {
        case WM_INITDIALOG:
            // Ensure that the common control DLL is loaded.
            InitCommonControls();

            // List view hwnd
            hWndLV = GetDlgItem(hDlg, IDLV_PICKER);

            // Load Image List for list view
            if (himl = ImageList_LoadBitmap(hInst,
              MAKEINTRESOURCE(IDB_CHECKS),
              16,
              0,
              RGB(128, 0, 128))) {
                ListView_SetImageList(hWndLV, himl, LVSIL_STATE);
            }

            // Fill the listview
            ZeroMemory(&lvi, sizeof(LV_ITEM));
            lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;

            for (i = 0; i < NUM_EXPORT_PROPS; i++) {
                lvi.iItem = i;
                lvi.pszText = rgPropNames[i].lpszName;
                lvi.cchTextMax = lstrlen(lvi.pszText);
                lvi.lParam = (LPARAM)&rgPropNames[i];
                lvi.state = rgPropNames[i].fChosen ?
                  INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1) :
                  INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);
                lvi.stateMask = LVIS_STATEIMAGEMASK;

                if (ListView_InsertItem(hWndLV, &lvi) == -1) {
                    DebugTrace("ListView_InsertItem -> %u\n", GetLastError());
                    Assert(FALSE);
                }
            }

            // Insert a column for the text
            // We don't have a header, so we don't need to set the text.
            ZeroMemory(&lvm, sizeof(LV_COLUMN));
            lvm.mask = LVCF_WIDTH;
            // set the column width to the size of our listbox.
            GetClientRect(hWndLV, &rect);
            lvm.cx = rect.right;
            ListView_InsertColumn(hWndLV, 0, &lvm);

            // Full row selection on listview
            ListView_SetExtendedListViewStyle(hWndLV, LVS_EX_FULLROWSELECT);

            // Select the first item in the list
            ListView_SetItemState(  hWndLV,
                                    0,
                                    LVIS_FOCUSED | LVIS_SELECTED,
                                    LVIS_FOCUSED | LVIS_SELECTED);

            return(1);

        case WM_COMMAND:
            return(TRUE);
            break;

        case WM_NOTIFY:
            pnmhdr = (LPNMHDR)lParam;

            switch (((NMHDR FAR *)lParam)->code) {
                case NM_CLICK:
                case NM_DBLCLK:
                    hWndLV = GetDlgItem(hDlg, IDLV_PICKER);

                    i = GetMessagePos();
                    point.x = LOWORD(i);
                    point.y = HIWORD(i);
                    ScreenToClient(hWndLV, &point);
                    lvh.pt = point;
                    nIndex = ListView_HitTest(hWndLV, &lvh);
                    // if single click on icon or double click anywhere, toggle the checkmark.
                    if (((NMHDR FAR *)lParam)->code == NM_DBLCLK ||
                      ( (lvh.flags & LVHT_ONITEMSTATEICON) && !(lvh.flags & LVHT_ONITEMLABEL))) {
                        HandleCheckMark(hWndLV, nIndex, rgPropNames);
                    }
                    break;

                case LVN_KEYDOWN:
                    hWndLV = GetDlgItem(hDlg, IDLV_PICKER);

                    // toggle checkmark if SPACE key is pressed
                    if (pnmhdr->hwndFrom == hWndLV) {
                        LV_KEYDOWN *pnkd = (LV_KEYDOWN *)lParam;
                        // BUG 25097 allow multiple select
                        if (pnkd->wVKey == VK_SPACE)
                        {
                            nIndex = ListView_GetSelectedCount(hWndLV);
                            if(nIndex == 1)
                            {
                                nIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED | LVNI_ALL);
                                //if (nIndex >= 0) {
                                    HandleCheckMark(hWndLV, nIndex, rgPropNames);
                                //}
                            }
                            else if(nIndex > 1)
                            {
                                //multiple select case ...
                                // Toggle all the selected items to the same state as the
                                // first item ...
                                HandleMultipleCheckMarks(hWndLV, rgPropNames);
                            }
                        }
                    }
                    break;

                case PSN_KILLACTIVE:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return(1);
                    break;

                case PSN_RESET:
                    // rest to the original values
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
                    break;

                case PSN_WIZBACK:
                    break;

                case PSN_WIZFINISH:
                    // Here's where we do the export
                    break;

                default:
                    return(FALSE);
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}

//$$/////////////////////////////////////////////////////////////////////////////
//
// my_atoi - personal version of atoi function
//
//  lpsz - string to parse into numbers - non numeral characters are ignored
//
/////////////////////////////////////////////////////////////////////////////////
int my_atoi(LPTSTR lpsz)
{
    int i=0;
    int nValue = 0;

    if(lpsz)
    {
        if (lstrlen(lpsz))
        {
            nValue = 0;
            while((lpsz[i]!='\0')&&(i<=lstrlen(lpsz)))
            {
                int tmp = lpsz[i]-'0';
                if(tmp <= 9)
                    nValue = nValue*10 + tmp;
                i++;
            }
        }
    }

    return nValue;
}


typedef struct {
    LPTSTR lpszName;
    ULONG iPropNamesTable;  // index in rgProp
} SYNONYM, *LPSYNONYM;

/***************************************************************************

    Name      : FindPropName

    Purpose   : Finds a property name in the prop name table

    Parameters: lpName = name to find or NULL to free the static synonym table
                rgPropNames = property name table
                ulcPropNames = size of property name table

    Returns   : index into table or INDEX_NOT_FOUND

    Comment   :

***************************************************************************/
#define INDEX_NOT_FOUND 0xFFFFFFFF
ULONG FindPropName(PUCHAR lpName, LPPROP_NAME rgPropNames, ULONG ulcPropNames) {
    ULONG i;
    static LPSYNONYM lpSynonymTable = NULL;
    static ULONG ulSynonymsSave = 0;
    ULONG ulSynonyms = ulSynonymsSave;      // Keep local copy for compiler bug
    ULONG ulSynonymStrings = 0;

    if (lpName == NULL) {
        goto clean_table;
    }

    for (i = 0; i < ulcPropNames; i++) {
        if (! rgPropNames[i].fChosen) { // Don't re-use props!
            if (! lstrcmpi(lpName, rgPropNames[i].lpszName)) {
                return(i);
            }
        }
    }


    // If it wasn't found, look it up in the synonym table resource
    // First, make sure we have a synonym table loaded
    if (! lpSynonymTable) {
        TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
        LPTSTR lpSynonym, lpName;
        ULONG j;

        // Load the synonym table
        if (LoadString(hInst,
          idsSynonymCount,
          szBuffer, sizeof(szBuffer))) {
            DebugTrace("Loading synonym table, %s synonyms\n", szBuffer);
            ulSynonymStrings = my_atoi(szBuffer);

            if (ulSynonymStrings) {
                // Allocate the synonym table
                if (! (lpSynonymTable = LocalAlloc(LPTR, ulSynonymStrings * sizeof(SYNONYM)))) {
                    DebugTrace("LocalAlloc synonym table -> %u\n", GetLastError());
                    goto clean_table;
                }

                for (i = 0; i < ulSynonymStrings; i++) {
                    if (LoadString(hInst,
                      idsSynonym001 + i,        // ids of synonym string
                      szBuffer,
                      sizeof(szBuffer))) {
                        // Split the string at the '=' character
                        lpSynonym = lpName = szBuffer;
                        while (*lpName) {
                            if (*lpName == '=') {
                                // found equal sign, break the string here
                                *(lpName++) = '\0';
                                break;
                            }
                            lpName = CharNext(lpName);
                        }

                        // Find the name specified
                        for (j = 0; j < ulcPropNames; j++) {
                            if (! lstrcmpi(lpName, rgPropNames[j].lpszName)) {
                                // Found it
                                // Allocate a buffer for the synonym string
                                Assert(ulSynonyms < ulSynonymStrings);
                                if (! (lpSynonymTable[ulSynonyms].lpszName = LocalAlloc(LPTR, lstrlen(lpSynonym) + 1))) {
                                    DebugTrace("LocalAlloc in synonym table -> %u\n", GetLastError());
                                    goto clean_table;
                                }
                                StrCpyN(lpSynonymTable[ulSynonyms].lpszName, lpSynonym, lstrlen(lpSynonym) + 1);
                                lpSynonymTable[ulSynonyms].iPropNamesTable = j;
                                ulSynonyms++;
                                break;
                            }
                        }
                    }
                }
            }
        }
        ulSynonymsSave = ulSynonyms;
    }

    if (lpSynonymTable) {
        // Find it
        for (i = 0; i < ulSynonyms; i++) {
            if (! lstrcmpi(lpName, lpSynonymTable[i].lpszName)) {
                // Found the name.  Is it already used?
                if (rgPropNames[lpSynonymTable[i].iPropNamesTable].fChosen) {
                    break;  // Found, but already used
                }

                return(lpSynonymTable[i].iPropNamesTable);
            }
        }
    }

exit:
    return(INDEX_NOT_FOUND);

clean_table:
    if (lpSynonymTable) {
        for (i = 0; i < ulSynonyms; i++) {
            if (lpSynonymTable[i].lpszName) {
                LocalFree(lpSynonymTable[i].lpszName);
            }
        }
        LocalFree(lpSynonymTable);
        lpSynonymTable = NULL;
        ulSynonymsSave = 0;
    }
    goto exit;
}


/***************************************************************************

    Name      : BuildCSVTable

    Purpose   : Builds the initial CSV mapping table from the file header.

    Parameters: lpFileName = filename to test
                rgPropnames = property name table
                szSep = separator character
                lppImportMapping -> returned mapping table
                lpcFields -> returned size of import mapping table
                lphFile -> returned file handle for CSV file.  File pointer
                  will be set past the header row.

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT BuildCSVTable(LPTSTR lpFileName, LPPROP_NAME rgPropNames, LPTSTR szSep,
  LPPROP_NAME * lppImportMapping, LPULONG lpcFields, LPHANDLE lphFile) {
    PUCHAR * rgItems = NULL;
    ULONG i, ulcItems = 0;
    LPPROP_NAME rgImportMapping = NULL;
    HRESULT hResult;
    ULONG ulPropIndex;


    // Open the file
    if ((*lphFile = CreateFile(lpFileName,
      GENERIC_READ,
      FILE_SHARE_READ | FILE_SHARE_WRITE,
      NULL,
      OPEN_EXISTING,
      FILE_FLAG_SEQUENTIAL_SCAN,
      NULL)) == INVALID_HANDLE_VALUE) {
        DebugTrace("Couldn't open file %s -> %u\n", lpFileName, GetLastError());
        return(ResultFromScode(MAPI_E_NOT_FOUND));
    }

    // Parse the first row
    if (hResult = ReadCSVLine(*lphFile, szSep, &ulcItems, &rgItems)) {
        DebugTrace("Couldn't read the CSV header\n");
        goto exit;
    }

    // Allocate the table
    if (! (*lppImportMapping = rgImportMapping = LocalAlloc(LPTR, ulcItems * sizeof(PROP_NAME)))) {
        DebugTrace("Allocation of import mapping table -> %u\n", GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Reset flags on WAB property table
    for (i = 0; i < NUM_EXPORT_PROPS; i++) {
        rgPropNames[i].fChosen = FALSE;
    }

    // Fill in the CSV fields
    for (i = 0; i < ulcItems; i++) {
        Assert(rgItems[i]);

        if (rgItems[i] && *rgItems[i]) {
            rgImportMapping[i].lpszCSVName = rgItems[i];

            // Look it up in the WAB property names table
            if (INDEX_NOT_FOUND != (ulPropIndex =  FindPropName(rgItems[i], rgPropNames, NUM_EXPORT_PROPS))) {
                // Found a match
                rgImportMapping[i].lpszName = rgPropNames[ulPropIndex].lpszName;
                rgImportMapping[i].ids = rgPropNames[ulPropIndex].ids;
                rgImportMapping[i].fChosen = TRUE;
                rgImportMapping[i].ulPropTag = rgPropNames[ulPropIndex].ulPropTag;
                rgPropNames[ulPropIndex].fChosen = TRUE;
                DebugTrace("Match   %u: %s\n", i, rgItems[i]);
            } else {
                DebugTrace("Unknown %u: %s\n", i, rgItems[i]);
            }
        } else {
            DebugTrace("Empty   %u: %s\n", i, rgItems[i]);
        }
    }

    *lpcFields = ulcItems;

exit:
    if (hResult) {
        if (*lphFile != INVALID_HANDLE_VALUE) {
            CloseHandle(*lphFile);
            *lphFile = INVALID_HANDLE_VALUE;
        }

        if (rgItems) {
            for (i = 0; i < ulcItems; i++) {
                if (rgItems[i]) {
                    LocalFree(rgItems[i]);
                }
            }
        }

        if (rgImportMapping) {
            LocalFree(rgImportMapping);
            *lppImportMapping = NULL;
        }
    }

    // If no error, leave the item strings since they are part of the mapping table.
    if (rgItems) {
        LocalFree(rgItems);
    }

    // Free the static memory for the synonym table.
    FindPropName(NULL, rgPropNames, NUM_EXPORT_PROPS);
    return(hResult);
}


/***************************************************************************

    Name      : FileExists

    Purpose   : Tests for existence of a file

    Parameters: lpFileName = filename to test

    Returns   : TRUE if the file exists

    Comment   :

***************************************************************************/
BOOL FileExists(LPTSTR lpFileName) {
    DWORD dwRet;

    if ((dwRet = GetFileAttributes(lpFileName)) == 0xFFFFFFFF) {
        return(FALSE);
    } else {
        return(! (dwRet & FILE_ATTRIBUTE_DIRECTORY));   // file was found
    }
}


/***************************************************************************

    Name      : ImportFilePageProc

    Purpose   : Process messages for "Import Filename" page

    Parameters: standard window proc parameters

    Returns   : standard window proc return

    Messages  : WM_INITDIALOG - intializes the page
                WM_NOTIFY - processes the notifications sent to the page

    Comment   :

***************************************************************************/
INT_PTR CALLBACK ImportFilePageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    static TCHAR szTempFileName[MAX_PATH + 1] = "";
    static LPPROPSHEET_DATA lppd = NULL;
    LPPROPSHEETPAGE lppsp;

    switch (message) {
        case WM_INITDIALOG:
            StrCpyN(szTempFileName, szCSVFileName, ARRAYSIZE(szTempFileName));
            lppsp = (LPPROPSHEETPAGE)lParam;
            lppd = (LPPROPSHEET_DATA)lppsp->lParam;
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_BROWSE:
                    SendDlgItemMessage(hDlg, IDE_CSV_IMPORT_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTempFileName);
                    OpenFileDialog(hDlg,
                      szTempFileName,
                      szCSVFilter,
                      IDS_CSV_FILE_SPEC,
                      szTextFilter,
                      IDS_TEXT_FILE_SPEC,
                      szAllFilter,
                      IDS_ALL_FILE_SPEC,
                      szCSVExt,
                      OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST,
                      hInst,
                      0,        //idsTitle
                      0);       // idsSaveButton
                    PropSheet_SetWizButtons(GetParent(hDlg), FileExists(szTempFileName) ? PSWIZB_NEXT : 0);
                    SendMessage(GetDlgItem(hDlg, IDE_CSV_IMPORT_NAME), WM_SETTEXT, 0, (LPARAM)szTempFileName);
                    break;

                case IDE_CSV_IMPORT_NAME:
                    switch (HIWORD(wParam)) {   // notification code
                        case EN_CHANGE:
                            SendDlgItemMessage(hDlg, IDE_CSV_IMPORT_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTempFileName);
                            if ((ULONG)LOWORD(wParam) == IDE_CSV_IMPORT_NAME) {
                                PropSheet_SetWizButtons(GetParent(hDlg), FileExists(szTempFileName) ? PSWIZB_NEXT : 0);
                            }
                            break;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *) lParam)->code) {
                case PSN_KILLACTIVE:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return(1);

                case PSN_RESET:
                    // reset to the original values
                    StrCpyN(szTempFileName, szCSVFileName, ARRAYSIZE(szTempFileName));
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), szTempFileName[0] ? PSWIZB_NEXT : 0);
                    SendMessage(GetDlgItem(hDlg, IDE_CSV_IMPORT_NAME), WM_SETTEXT, 0, (LPARAM)szTempFileName);
                    break;

                case PSN_WIZNEXT:
                    // the Next button was pressed
                    SendDlgItemMessage(hDlg, IDE_CSV_IMPORT_NAME, WM_GETTEXT, (WPARAM)MAX_PATH, (LPARAM)szTempFileName);
                    StrCpyN(szCSVFileName, szTempFileName, ARRAYSIZE(szCSVFileName));
                    break;

                default:
                    return(FALSE);
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}


typedef struct {
    LPPROP_NAME lpMapping;
    LPPROP_NAME rgPropNames;
    ULONG ulcPropNames;
    ULONG ulColumn;
} CHANGE_MAPPING_INFO, * LPCHANGE_MAPPING_INFO;


void HandleChangeMapping(HWND hDlg, LPPROPSHEET_DATA lppd) {
    HWND hWndLV = GetDlgItem(hDlg, IDLV_MAPPER);
    ULONG nIndex;
    CHANGE_MAPPING_INFO cmi;
    LV_ITEM lvi;
    ULONG ulPropTagOld, i;
    LPPROP_NAME lpMappingTable;
    ULONG ulcMapping;

    if ((nIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED)) == 0xFFFFFFFF) {
        nIndex = 0;
        ListView_SetItemState(hWndLV, nIndex, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
    }

    lpMappingTable = *(lppd->lppImportMapping);

    cmi.lpMapping = &(lpMappingTable[nIndex]);
    cmi.rgPropNames = lppd->rgPropNames;
    cmi.ulcPropNames = NUM_EXPORT_PROPS;
    cmi.ulColumn = nIndex;

    ulPropTagOld = cmi.lpMapping->ulPropTag;

    DialogBoxParam(hInst,
      MAKEINTRESOURCE(IDD_CSV_CHANGE_MAPPING),
      hDlg,
      ChangeMappingDialogProc,
      (LPARAM)&cmi);

    // Fix the entry in the listbox
    ZeroMemory(&lvi, sizeof(LV_ITEM));

    // If there is no mapping, ensure that the field is unchosen
    if (cmi.lpMapping->ulPropTag == PR_NULL || cmi.lpMapping->ulPropTag == 0 ) {
        cmi.lpMapping->fChosen = FALSE;
    }

    lvi.iItem = nIndex;
    lvi.lParam = (LPARAM)NULL;

    lvi.mask = LVIF_STATE;
    lvi.iSubItem = 0;   // Checkbox is in first column
    lvi.state = cmi.lpMapping->fChosen ?
      INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1) :
      INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    if (ListView_SetItem(hWndLV, &lvi) == -1) {
        DebugTrace("ListView_SetItem -> %u\n", GetLastError());
        Assert(FALSE);
    }

    lvi.mask = LVIF_TEXT;
    lvi.iSubItem = 1;   // WAB Field
    lvi.pszText = cmi.lpMapping->lpszName ? cmi.lpMapping->lpszName : (LPTSTR)szEmpty;   // new wab field text
    if (ListView_SetItem(hWndLV, &lvi) == -1) {
        DebugTrace("ListView_SetItem -> %u\n", GetLastError());
        Assert(FALSE);
    }

    // if we changed the mapping, make sure there's not a duplicate proptag mapped.
    if (ulPropTagOld != cmi.lpMapping->ulPropTag) {
        ulcMapping = *(lppd->lpcFields);

        for (i = 0; i < ulcMapping; i++) {
            if ((i != nIndex) && cmi.lpMapping->ulPropTag == lpMappingTable[i].ulPropTag) {
                // Found a duplicate, nuke it.
                lpMappingTable[i].ulPropTag = PR_NULL;
                lpMappingTable[i].lpszName = (LPTSTR)szEmpty;
                lpMappingTable[i].ids = 0;
                lpMappingTable[i].fChosen = FALSE;

                // Now, redraw that row in the listview
                lvi.iItem = i;
                lvi.lParam = (LPARAM)NULL;

                // uncheck the box first
                lvi.mask = LVIF_STATE;
                lvi.iSubItem = 0;   // Checkbox is in first column
                lvi.state = INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);
                lvi.stateMask = LVIS_STATEIMAGEMASK;
                if (ListView_SetItem(hWndLV, &lvi) == -1) {
                    DebugTrace("ListView_SetItem -> %u\n", GetLastError());
                    Assert(FALSE);
                }

                // Now, change the name mapping
                lvi.mask = LVIF_TEXT;
                lvi.iSubItem = 1;   // WAB Field
                lvi.pszText = (LPTSTR)szEmpty;   // new wab field text
                if (ListView_SetItem(hWndLV, &lvi) == -1) {
                    DebugTrace("ListView_SetItem -> %u\n", GetLastError());
                    Assert(FALSE);
                }
            }
        }
    }
}


/***************************************************************************

    Name      : FieldOrColumnName

    Purpose   : If the field name is empty, generate one for it.

    Parameters: lpField -> Field name pointer (may be null)
                index = index of this column
                szBuffer = buffer in which to create new string if
                  needed
                cbBuffer = size of szBuffer

    Returns   : pointer to correct field name

    Comment   :

***************************************************************************/
LPTSTR FieldOrColumnName(LPTSTR lpField, ULONG index, LPTSTR szBuffer, ULONG cbBuffer) {
    LPTSTR lpReturn = (LPTSTR)szEmpty;

    if (lpField && *lpField) {
        return(lpField);
    } else {
        TCHAR szFormat[MAX_RESOURCE_STRING + 1];
        TCHAR szNumber[11];
        LPTSTR lpszArg[1] = {szNumber};

        // Format a "Column 23" type of label
        wnsprintf(szNumber, ARRAYSIZE(szNumber), "%u", index);

        if (LoadString(hInst,
          IDS_CSV_COLUMN,
          szFormat,
          sizeof(szFormat))) {

            if (! FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
              szFormat,
              0, 0, //ignored
              szBuffer,
              cbBuffer,
              (va_list *)lpszArg)) {
                DebugTrace("FormatMessage -> %u\n", GetLastError());
            } else {
                lpReturn = szBuffer;
            }
        }
    }
    return(lpReturn);
}


/***************************************************************************

    Name      : ImportMapFieldsPageProc

    Purpose   : Process messages for "Mapi Fields" page

    Parameters: standard window proc parameters

    Returns   : standard window proc return

    Messages  : WM_INITDIALOG - intializes the page
                WM_NOTIFY - processes the notifications sent to the page

    Comment   :

***************************************************************************/
INT_PTR CALLBACK ImportMapFieldsPageProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) {
    HWND hWndLV;
    HIMAGELIST himl;
    LV_ITEM lvi;
    LV_COLUMN lvm;
    LV_HITTESTINFO lvh;
    POINT point;
    ULONG i, nIndex, nOldIndex;
    NMHDR * pnmhdr;
    RECT rect;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1 + 10];
    ULONG cxTextWidth;
    static LPPROPSHEET_DATA lppd = NULL;
    LPPROPSHEETPAGE lppsp;
    HRESULT hResult;
    CHANGE_MAPPING_INFO cmi;
    LPPROP_NAME lpImportMapping;


    switch (message) {
        case WM_INITDIALOG:
            lppsp = (LPPROPSHEETPAGE)lParam;
            lppd = (LPPROPSHEET_DATA)lppsp->lParam;

            // Ensure that the common control DLL is loaded.
            InitCommonControls();

            // List view hwnd
            hWndLV = GetDlgItem(hDlg, IDLV_MAPPER);

            // How big should the text columns be?
            GetClientRect(hWndLV, &rect);
            cxTextWidth = (rect.right - CHECK_BITMAP_WIDTH) / 2;
            cxTextWidth -= cxTextWidth % 2;

            // Insert a column for the CSV Field Names
            ZeroMemory(&lvm, sizeof(LV_COLUMN));
            lvm.mask = LVCF_TEXT | LVCF_WIDTH;
            lvm.cx = cxTextWidth + 9;       // a touch more room for the bitmap

            // Get the string for the header
            if (LoadString(hInst, IDS_CSV_IMPORT_HEADER_CSV, szBuffer, sizeof(szBuffer))) {
                lvm.pszText = szBuffer;
            } else {
                DebugTrace("Cannot load resource string %u\n", IDS_CSV_IMPORT_HEADER_CSV);
                lvm.pszText = NULL;
                Assert(FALSE);
            }

            ListView_InsertColumn(hWndLV, 0, &lvm);

            // Insert a column for the WAB Field Names
            lvm.mask = LVCF_TEXT | LVCF_WIDTH;
            lvm.cx = cxTextWidth - 4;       // room for second column text

            // Get the string for the header
            if (LoadString(hInst, IDS_CSV_IMPORT_HEADER_WAB, szBuffer, sizeof(szBuffer))) {
                lvm.pszText = szBuffer;
            } else {
                DebugTrace("Cannot load resource string %u\n", IDS_CSV_IMPORT_HEADER_WAB);
                lvm.pszText = NULL;
                Assert(FALSE);
            }

            ListView_InsertColumn(hWndLV, 1, &lvm);

            // Full row selection on listview
            ListView_SetExtendedListViewStyle(hWndLV, LVS_EX_FULLROWSELECT);

            // Load Image List for list view
            if (himl = ImageList_LoadBitmap(hInst,
              MAKEINTRESOURCE(IDB_CHECKS),
              CHECK_BITMAP_WIDTH,
              0,
              RGB(128, 0, 128))) {
                ListView_SetImageList(hWndLV, himl, LVSIL_STATE);
            }

            // Fill the listview
            ZeroMemory(&lvi, sizeof(LV_ITEM));

            // Open the file and parse out the headers line
            if ((! (hResult = BuildCSVTable(szCSVFileName, lppd->rgPropNames,
              lppd->szSep, lppd->lppImportMapping, lppd->lpcFields, lppd->lphFile))) && ((*lppd->lpcFields) > 0)) {
                for (i = 0; i < *lppd->lpcFields; i++) {
                    ULONG index;
                    TCHAR szBuffer[MAX_RESOURCE_STRING + 1 + 10];

                    lpImportMapping = *lppd->lppImportMapping;

                    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
                    lvi.iItem = i;
                    lvi.iSubItem = 0;
                    lvi.pszText = FieldOrColumnName(lpImportMapping[i].lpszCSVName,
                      i,
                      szBuffer,
                      sizeof(szBuffer));
                    lvi.cchTextMax = lstrlen(lvi.pszText);
                    lvi.lParam = (LPARAM)&lpImportMapping[i];
                    lvi.state = lpImportMapping[i].fChosen ?
                      INDEXTOSTATEIMAGEMASK(iiconStateChecked + 1) :
                      INDEXTOSTATEIMAGEMASK(iiconStateUnchecked + 1);
                    lvi.stateMask = LVIS_STATEIMAGEMASK;

                    if (index = ListView_InsertItem(hWndLV, &lvi) == -1) {
                        DebugTrace("ListView_InsertItem -> %u\n", GetLastError());
                        Assert(FALSE);
                    }


                    lvi.mask = LVIF_TEXT;
                    // lvi.iItem = index;
                    lvi.iSubItem = 1;   // WAB Field
                    lvi.pszText = lpImportMapping[i].lpszName ? lpImportMapping[i].lpszName : (LPTSTR)szEmpty;   // new wab field text
                    lvi.lParam = (LPARAM)NULL;

                    if (ListView_SetItem(hWndLV, &lvi) == -1) {
                        DebugTrace("ListView_SetItem -> %u\n", GetLastError());
                        Assert(FALSE);
                    }
                }
            }
            else
                EnableWindow(GetDlgItem(hDlg,IDC_CHANGE_MAPPING),FALSE);

            // Select the first item in the list
            ListView_SetItemState(  hWndLV,
                                    0,
                                    LVIS_FOCUSED | LVIS_SELECTED,
                                    LVIS_FOCUSED | LVIS_SELECTED);
            return(1);

        case WM_NOTIFY:
            pnmhdr = (LPNMHDR)lParam;

            switch (((NMHDR FAR *)lParam)->code) {
                case NM_CLICK:
                    hWndLV = GetDlgItem(hDlg, IDLV_MAPPER);

                    i = GetMessagePos();
                    point.x = LOWORD(i);
                    point.y = HIWORD(i);
                    ScreenToClient(hWndLV, &point);
                    lvh.pt = point;
                    nIndex = ListView_HitTest(hWndLV, &lvh);
                    // if single click on icon or double click anywhere, toggle the checkmark.
                    if (((NMHDR FAR *)lParam)->code == NM_DBLCLK ||
                      ( (lvh.flags & LVHT_ONITEMSTATEICON) && !(lvh.flags & LVHT_ONITEMLABEL))) {
                        HandleCheckMark(hWndLV, nIndex, *lppd->lppImportMapping);

                        // if the box is now clicked, but there is no mapping, bring up the
                        // mapping dialog
                        if ((*(lppd->lppImportMapping))[nIndex].fChosen &&
                          (! (*(lppd->lppImportMapping))[nIndex].lpszName ||
                           lstrlen((*(lppd->lppImportMapping))[nIndex].lpszName) == 0)) {
                            // Select the row
                            ListView_SetItemState(hWndLV, nIndex, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                            HandleChangeMapping(hDlg, lppd);
                        }
                    }
                    break;


                case NM_DBLCLK:
                    hWndLV = GetDlgItem(hDlg, IDLV_MAPPER);
                    i = GetMessagePos();
                    point.x = LOWORD(i);
                    point.y = HIWORD(i);
                    ScreenToClient(hWndLV, &point);
                    lvh.pt = point;
                    nIndex = ListView_HitTest(hWndLV, &lvh);
                    ListView_SetItemState(hWndLV, nIndex, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                    HandleChangeMapping(hDlg, lppd);
                    break;

                case LVN_KEYDOWN:
                    hWndLV = GetDlgItem(hDlg, IDLV_MAPPER);

                    // toggle checkmark if SPACE key is pressed
                    if (pnmhdr->hwndFrom == hWndLV) {
                        LV_KEYDOWN *pnkd = (LV_KEYDOWN *)lParam;
                        if (pnkd->wVKey == VK_SPACE) {
                            nIndex = ListView_GetNextItem(hWndLV, -1, LVNI_SELECTED | LVNI_ALL);
                            //if (nIndex >= 0) 
                            {
                                HandleCheckMark(hWndLV, nIndex, *lppd->lppImportMapping);

                                // if the box is now clicked, but there is no mapping, bring up the
                                // mapping dialog
                                if ((*(lppd->lppImportMapping))[nIndex].fChosen &&
                                    (! (*(lppd->lppImportMapping))[nIndex].lpszName ||
                                     lstrlen((*(lppd->lppImportMapping))[nIndex].lpszName) == 0)) {
                                    // Select the row
                                    ListView_SetItemState(hWndLV, nIndex, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                                    HandleChangeMapping(hDlg, lppd);
                                }
                            }
                        }
                    }
                    break;

                case PSN_KILLACTIVE:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return(1);
                    break;

                case PSN_RESET:
                    // rest to the original values


                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    break;

                case PSN_SETACTIVE:
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
                    break;

                case PSN_WIZBACK:
                    break;

                case PSN_WIZFINISH:
                    // Validate the properties selected to make sure we have
                    // name fields of some kind.
                    lpImportMapping = *lppd->lppImportMapping;

                    for (i = 0; i < *lppd->lpcFields; i++) {
                        ULONG ulPropTag = lpImportMapping[i].ulPropTag;
                        if (lpImportMapping[i].fChosen && (
                          ulPropTag == PR_DISPLAY_NAME ||
                          ulPropTag == PR_SURNAME ||
                          ulPropTag == PR_GIVEN_NAME ||
                          ulPropTag == PR_NICKNAME ||
                          ulPropTag == PR_COMPANY_NAME ||
                          ulPropTag == PR_EMAIL_ADDRESS ||
                          ulPropTag == PR_MIDDLE_NAME)) {
                            return(TRUE);    // OK to go do the import
                        }
                    }

                    ShowMessageBoxParam(hDlg, IDE_CSV_NO_COLUMNS, 0);
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    break;

                default:
                    return(FALSE);
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDC_CHANGE_MAPPING:
                    HandleChangeMapping(hDlg, lppd);
                    break;
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}


INT_PTR CALLBACK ChangeMappingDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    LPCHANGE_MAPPING_INFO lpcmi = (LPCHANGE_MAPPING_INFO)GetWindowLongPtr(hwnd, DWLP_USER);
    static BOOL fChosenSave = FALSE;
    ULONG iItem;


    switch (message) {
        case WM_INITDIALOG:
            {
                TCHAR szFormat[MAX_RESOURCE_STRING + 1];
                TCHAR szBuffer[MAX_RESOURCE_STRING + 1 + 10];
                LPTSTR lpszMessage = NULL;
                ULONG ids, i, iDefault = 0xFFFFFFFF;
                HWND hwndComboBox = GetDlgItem(hwnd, IDC_CSV_MAPPING_COMBO);

                SetWindowLongPtr(hwnd, DWLP_USER, lParam);  //Save this for future reference
                lpcmi = (LPCHANGE_MAPPING_INFO)lParam;

                fChosenSave = lpcmi->lpMapping->fChosen;

                if (LoadString(hInst,
                  IDS_CSV_CHANGE_MAPPING_TEXT_FIELD,
                  szFormat, sizeof(szFormat))) {
                    LPTSTR lpszArg[1] = {FieldOrColumnName(lpcmi->lpMapping->lpszCSVName,
                      lpcmi->ulColumn,
                      szBuffer,
                      sizeof(szBuffer))};

                    if (! FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      szFormat,
                      0, 0, //ignored
                      (LPTSTR)&lpszMessage,
                      0,
                      (va_list *)lpszArg)) {
                        DebugTrace("FormatMessage -> %u\n", GetLastError());
                    } else {
                        if (! SetDlgItemText(hwnd, IDC_CSV_CHANGE_MAPPING_TEXT_FIELD, lpszMessage)) {
                            DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                        }
                        LocalFree(lpszMessage);
                    }
                }

                // Fill in the combo box
                for (i = 0; i < lpcmi->ulcPropNames; i++) {
                    SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)lpcmi->rgPropNames[i].lpszName);
                    if (lpcmi->lpMapping->ids == lpcmi->rgPropNames[i].ids) {
                        SendMessage(hwndComboBox, CB_SETCURSEL, (WPARAM)i, 0);
                    }
                }

                // Add blank line
                SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)szEmpty);
                if (lpcmi->lpMapping->ids == 0) {
                    SendMessage(hwndComboBox, CB_SETCURSEL, (WPARAM)(i + 1), 0);
                }

                // Init the checkbox
                CheckDlgButton(hwnd, IDC_CSV_MAPPING_SELECT, fChosenSave ? BST_CHECKED : BST_UNCHECKED);
                return(TRUE);
            }

        case WM_COMMAND :
            switch (LOWORD(wParam)) {
                case IDCANCEL:
                    lpcmi->lpMapping->fChosen = fChosenSave;
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDCLOSE:
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDOK:
                    // Set the state of the parameter
                    // Get the mapping
                    if ((iItem = (ULONG) SendMessage(GetDlgItem(hwnd, IDC_CSV_MAPPING_COMBO), CB_GETCURSEL, 0, 0)) != CB_ERR) {
                        if (iItem >= lpcmi->ulcPropNames) {
                            lpcmi->lpMapping->lpszName = (LPTSTR)szEmpty;
                            lpcmi->lpMapping->ids = 0;
                            lpcmi->lpMapping->ulPropTag = PR_NULL;
                            lpcmi->lpMapping->fChosen = FALSE;
                        } else {
                            lpcmi->lpMapping->lpszName = rgPropNames[iItem].lpszName;
                            lpcmi->lpMapping->ids = rgPropNames[iItem].ids;
                            lpcmi->lpMapping->ulPropTag = rgPropNames[iItem].ulPropTag;
                        }
                    }
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);

                case IDM_EXIT:
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);

                case IDC_CSV_MAPPING_SELECT:
                    switch (HIWORD(wParam)) {
                        case BN_CLICKED:
                            if ((int)LOWORD(wParam) == IDC_CSV_MAPPING_SELECT) {
                                // toggle the checkbox
                                lpcmi->lpMapping->fChosen = ! lpcmi->lpMapping->fChosen;
                                CheckDlgButton(hwnd, IDC_CSV_MAPPING_SELECT, lpcmi->lpMapping->fChosen ? BST_CHECKED : BST_UNCHECKED);
                            }
                            break;
                    }
                    break;
                }
            break;


        case IDCANCEL:
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            return(0);

        default:
            return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wabmig\_wabmig.h ===
/*
 *  _WABMIG.H
 *
 *  Internal header for wabmig.exe
 *
 *  Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
 */

// Test for PT_ERROR property tag
#define PROP_ERROR(prop) (prop.ulPropTag == PROP_TAG(PT_ERROR, PROP_ID(prop.ulPropTag)))


// Property Tags:
// MSN Address properties
#define PR_MSNINET_ADDRESS                          PROP_TAG(PT_TSTRING,    0x6001)
#define PR_MSNINET_DOMAIN                           PROP_TAG(PT_TSTRING,    0x6002)


// Misc defines
#define MAX_SCHEMA_PROPID   0x3FFF
#define MIN_NAMED_PROPID    0x8000
#define WAB_W_BAD_EMAIL     MAKE_MAPI_S(0x1000)
#define NOT_FOUND           ((ULONG)-1)
#define INDEX_FIRST_MIDDLE_LAST ((ULONG)-2)
#define NUM_EXPORT_WIZARD_PAGES 2
#define NUM_IMPORT_WIZARD_PAGES 2


// Index of icons in the bitmap
enum {
    iiconStateUnchecked,
    iiconStateChecked,
    iiconStMax
};

extern const UCHAR szQuote[];

extern const TCHAR szMSN[];
extern const TCHAR szMSNINET[];
extern const TCHAR szCOMPUSERVE[];
extern const TCHAR szFAX[];
extern const TCHAR szSMTP[];
extern const TCHAR szMS[];
extern const TCHAR szEX[];
extern const TCHAR szX400[];
extern const TCHAR szMSA[];
extern const TCHAR szMAPIPDL[];
extern const TCHAR szEmpty[];
extern const TCHAR szAtSign[];

#define cbAtSign        (2 * sizeof(TCHAR))

extern const TCHAR szMSNpostfix[];
#define cbMSNpostfix    (9 * sizeof(TCHAR))

extern const TCHAR szCOMPUSERVEpostfix[];
#define cbCOMPUSERVEpostfix     (16 * sizeof(TCHAR))


typedef enum {
    INDEX_EXPORT_PAB = 0,
    INDEX_EXPORT_CSV
} INDEX_EXPORT, *LPINDEX_EXPORT;


typedef enum {
    CONFIRM_YES,
    CONFIRM_NO,
    CONFIRM_YES_TO_ALL,
    CONFIRM_NO_TO_ALL,
    CONFIRM_ERROR,
    CONFIRM_ABORT
} CONFIRM_RESULT, *LPCONFIRM_RESULT;


typedef struct _ReplaceInfo {
    LPTSTR lpszDisplayName;         // Conflicting display name
    LPTSTR lpszEmailAddress;        // Conflicting email address
    CONFIRM_RESULT ConfirmResult;   // Results from dialog
} REPLACE_INFO, * LPREPLACE_INFO;

typedef enum {
    ERROR_OK,
    ERROR_ABORT
} ERROR_RESULT, *LPERROR_RESULT;

typedef struct _ErrorInfo {
    LPTSTR lpszDisplayName;         // Problem display name
    LPTSTR lpszEmailAddress;        // Problem email address
    ERROR_RESULT ErrorResult;       // Results from dialog
    ULONG ids;                      // string resource identifier for error message
} ERROR_INFO, * LPERROR_INFO;


typedef struct _EntrySeen {
    SBinary sbinPAB;                // MAPI entry
    SBinary sbinWAB;                // WAB entry
} ENTRY_SEEN, * LPENTRY_SEEN;

typedef struct _TargetInfo {
    LPTSTR lpRegName;
    LPTSTR lpDescription;
    LPTSTR lpDll;
    LPTSTR lpEntry;
    union {
        LPWAB_EXPORT lpfnExport;
        LPWAB_IMPORT lpfnImport;
    };
} TARGET_INFO, *LPTARGET_INFO;

typedef struct _DlgParam
{
    TCHAR szFileName[MAX_PATH];
    TCHAR szProfileID[MAX_PATH];
} WABMIGDLGPARAM, * LPWABMIGDLGPARAM;

enum {
    iconPR_DEF_CREATE_MAILUSER = 0,
    iconPR_DEF_CREATE_DL,
    iconMax
};

enum {
    ieidPR_ENTRYID = 0,
    ieidMax
};

enum {
    iptaColumnsPR_OBJECT_TYPE = 0,
    iptaColumnsPR_ENTRYID,
    iptaColumnsPR_DISPLAY_NAME,
    iptaColumnsPR_EMAIL_ADDRESS,
    iptaColumnsMax
};

typedef struct _PropNames {
    ULONG ulPropTag;        // property tag
    BOOL fChosen;           // use this property tag
    ULONG ids;              // string id
    LPTSTR lpszName;        // string (read in from resources)
    LPTSTR lpszCSVName;     // name of CSV field (from import file)
} PROP_NAME, *LPPROP_NAME;

extern PROP_NAME rgPropNames[];
extern LPPROP_NAME lpImportMapping;

#ifndef _WABMIG_C
#define ExternSizedSPropTagArray(_ctag, _name) \
extern const struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name

ExternSizedSPropTagArray(iptaColumnsMax, ptaColumns);
ExternSizedSPropTagArray(ieidMax, ptaEid);
ExternSizedSPropTagArray(iconMax, ptaCon);


#endif


extern WAB_IMPORT_OPTIONS ImportOptions;
extern WAB_EXPORT_OPTIONS ExportOptions;
extern LPENTRY_SEEN lpEntriesSeen;
extern ULONG ulEntriesSeen;
extern ULONG ulMaxEntries;
extern const LPTSTR szWABKey;
extern LPTARGET_INFO rgTargetInfo;
extern HINSTANCE hInst;
extern HINSTANCE hInstApp;
extern BOOL fMigrating;
extern BOOL fError;
extern BOOL fExport;
extern LPWABOBJECT lpWABObject;
extern LPMAPISESSION lpMAPISession;
extern LPADRBOOK lpAdrBookWAB;
extern LPADRBOOK lpAdrBookMAPI;
extern LPABCONT lpContainerMAPI;
extern LPABCONT lpContainerWAB;
extern LPMAPITABLE lpContentsTableMAPI;
extern LPMAPITABLE lpContentsTableWAB;
extern LPSPropValue lpCreateEIDsWAB;
extern LPSPropValue lpCreateEIDsMAPI;
extern ULONG ulcEntries;
extern LPTSTR lpImportDll;
extern LPTSTR lpImportFn;
extern LPTSTR lpImportDesc;
extern LPTSTR lpImportName;
extern LPTSTR lpExportDll;
extern LPTSTR lpExportFn;
extern LPTSTR lpExportDesc;
extern LPTSTR lpExportName;


//
// Functions in wabmig.c
//
extern INT_PTR CALLBACK ImportDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
extern INT_PTR CALLBACK ExportDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
#ifdef OLD_STUFF
extern long FAR PASCAL OptionsDialogProc(HWND hwnd, UINT message, UINT wParam, LONG lParam);
#endif // OLD_STUFF
extern INT_PTR CALLBACK ErrorDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
extern INT_PTR CALLBACK ReplaceDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
extern HRESULT PopulateTargetList(HWND hWndLB,
  LPTSTR lpszSelection);
extern void FreeLBItemData(HWND hWndLB);
extern HRESULT ProgressCallback(HWND hwnd, LPWAB_PROGRESS lpProgress);
extern ULONG CountRows(LPMAPITABLE lpTable, BOOL fMAPI);
extern BOOL AllocRegValue(HKEY hKey, LPTSTR lpValueName, LPTSTR * lppString);
extern LPTSTR GetEMSSMTPAddress(LPMAPIPROP lpObject, LPVOID lpBase);
extern int StrICmpN(LPTSTR szString1, LPTSTR szString2, ULONG N);
extern LPTSTR FindStringInProps(LPSPropValue lpspv, ULONG ulcProps, ULONG ulPropTag);
extern LPSBinary FindAdrEntryID(LPADRLIST lpAdrList, ULONG index);
extern void WABFreePadrlist(LPADRLIST lpAdrList);
extern SCODE WABFreeBuffer(LPVOID lpBuffer);
extern SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer);
extern SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer);
extern void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject);
extern void FreeSeenList(void);
ULONG FindProperty(ULONG cProps, LPSPropValue lpProps, ULONG ulPropTag);
void FreeSeenList(void);
void SetDialogMessage(HWND hwnd, int ids);
void WABFreeProws(LPSRowSet prows);
HRESULT ExportCSV(HWND hwnd,
  LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_EXPORT_OPTIONS lpOptions);
HRESULT ImportCSV(HWND hwnd,
  LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_IMPORT_OPTIONS lpOptions);
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...);
LPTSTR LoadAllocString(int StringID);
LPTSTR FormatAllocFilter(int StringID, const LPTSTR lpFilter);
HRESULT SaveFileDialog(HWND hWnd, LPTSTR szFileName, LPTSTR lpFilter, LPTSTR lpDefExt,
  ULONG ulFlags, HINSTANCE hInst, ULONG idsTitle, ULONG idsFileType, ULONG idsSaveButton);
HRESULT OpenFileDialog(HWND hWnd, LPTSTR szFileName, LPTSTR lpFilter, LPTSTR lpDefExt,
  ULONG ulFlags, HINSTANCE hInst, ULONG idsTitle, ULONG idsFileType, ULONG idsOpenButton);
LPTSTR LoadAllocString(int StringID);
LPTSTR PropStringOrNULL(LPSPropValue lpspv);

//
// Functions in csvpick.c
//
int APIENTRY PickExportProps(LPPROP_NAME rgPropNames);
HRESULT ExportWizard(HWND hWnd, LPTSTR szFileName, LPPROP_NAME rgPropNames);
HRESULT ImportWizard(HWND hWnd, LPTSTR szFileName, LPPROP_NAME rgPropNames,
  LPPROP_NAME * lppImportMapping, LPULONG lpcFields, LPHANDLE lphFile);

//
// Functions in csvparse.c
//
HRESULT ReadCSVLine(HANDLE hFile, ULONG * lpcItems, PUCHAR ** lpprgItems);


LPWABOPEN lpfnWABOpen;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\dbgutil.c ===
/***********************************************************************
 *
 * DBGUTIL.C
 *
 * Debug utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/
#ifdef DEBUG
#include <windows.h>
//#include <mapix.h>
#include <wab.h>
#include <wabdbg.h>
#include <shlwapi.h>

#include "dbgutil.h"

#define _WAB_DBGUTIL_C

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif

PUCHAR PropTagName(ULONG ulPropTag);
const TCHAR szNULL[] = "";

extern SCODE WABFreeBuffer(LPVOID lpBuffer);
VOID FAR CDECL _DebugTrace(LPSTR lpszFmt, ...);



/***************************************************************************

    Name      : FreeBufferAndNull

    Purpose   : Frees a MAPI buffer and NULLs the pointer

    Parameters: lppv = pointer to buffer pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall FreeBufferAndNull(BOOL fMAPI, LPVOID * lppv) {
    if (lppv) {
        if (*lppv) {
            SCODE sc;
            if (fMAPI) {
#ifdef OLD_STUFF
                if (sc = MAPIFreeBuffer(*lppv)) {
                    DebugTrace("MAPIFreeBuffer(%x) -> 0x%08x\n", *lppv, sc);
                }
#endif // OLD_STUFF
            } else {
                if (sc = WABFreeBuffer(*lppv)) {
                    DebugTrace("WABFreeBuffer(%x) -> 0x%08x\n", *lppv, sc);
                }
            }
            *lppv = NULL;
        }
    }
}


/***************************************************************************

    Name      : ReleaseAndNull

    Purpose   : Releases an object and NULLs the pointer

    Parameters: lppv = pointer to pointer to object to release

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall ReleaseAndNull(LPVOID * lppv) {
    LPUNKNOWN * lppunk = (LPUNKNOWN *)lppv;

    if (lppunk) {
        if (*lppunk) {
            HRESULT hResult;

            if (hResult = (*lppunk)->lpVtbl->Release(*lppunk)) {
                DebugTrace("Release(%x) -> 0x%08x\n", *lppunk, GetScode(hResult));
            }
            *lppunk = NULL;
        }
    }
}


/***************************************************************************

    Name      : PropTypeString

    Purpose   : Map a proptype to a string

    Parameters: ulPropType = property type to map

    Returns   : string pointer to name of prop type

    Comment   :

***************************************************************************/
LPTSTR PropTypeString(ULONG ulPropType) {
    switch (ulPropType) {
        case PT_UNSPECIFIED:
            return("PT_UNSPECIFIED");
        case PT_NULL:
            return("PT_NULL       ");
        case PT_I2:
            return("PT_I2         ");
        case PT_LONG:
            return("PT_LONG       ");
        case PT_R4:
            return("PT_R4         ");
        case PT_DOUBLE:
            return("PT_DOUBLE     ");
        case PT_CURRENCY:
            return("PT_CURRENCY   ");
        case PT_APPTIME:
            return("PT_APPTIME    ");
        case PT_ERROR:
            return("PT_ERROR      ");
        case PT_BOOLEAN:
            return("PT_BOOLEAN    ");
        case PT_OBJECT:
            return("PT_OBJECT     ");
        case PT_I8:
            return("PT_I8         ");
        case PT_STRING8:
            return("PT_STRING8    ");
        case PT_UNICODE:
            return("PT_UNICODE    ");
        case PT_SYSTIME:
            return("PT_SYSTIME    ");
        case PT_CLSID:
            return("PT_CLSID      ");
        case PT_BINARY:
            return("PT_BINARY     ");
        case PT_MV_I2:
            return("PT_MV_I2      ");
        case PT_MV_LONG:
            return("PT_MV_LONG    ");
        case PT_MV_R4:
            return("PT_MV_R4      ");
        case PT_MV_DOUBLE:
            return("PT_MV_DOUBLE  ");
        case PT_MV_CURRENCY:
            return("PT_MV_CURRENCY");
        case PT_MV_APPTIME:
            return("PT_MV_APPTIME ");
        case PT_MV_SYSTIME:
            return("PT_MV_SYSTIME ");
        case PT_MV_STRING8:
            return("PT_MV_STRING8 ");
        case PT_MV_BINARY:
            return("PT_MV_BINARY  ");
        case PT_MV_UNICODE:
            return("PT_MV_UNICODE ");
        case PT_MV_CLSID:
            return("PT_MV_CLSID   ");
        case PT_MV_I8:
            return("PT_MV_I8      ");
        default:
            return("   <unknown>  ");
    }
}


/***************************************************************************

    Name      : TraceMVPStrings

    Purpose   : Debug trace a multivalued string property value

    Parameters: lpszCaption = caption string
                PropValue = property value to dump

    Returns   : none

    Comment   :

***************************************************************************/
void _TraceMVPStrings(LPTSTR lpszCaption, SPropValue PropValue) {
    ULONG i;

    DebugTrace("-----------------------------------------------------\n");
    DebugTrace("%s", lpszCaption);
    switch (PROP_TYPE(PropValue.ulPropTag)) {

        case PT_ERROR:
            DebugTrace("Error value 0x%08x\n", PropValue.Value.err);
            break;

        case PT_MV_TSTRING:
            DebugTrace("%u values\n", PropValue.Value.MVSZ.cValues);

            if (PropValue.Value.MVSZ.cValues) {
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
                for (i = 0; i < PropValue.Value.MVSZ.cValues; i++) {
                    DebugTrace("%u: \"%s\"\n", i, PropValue.Value.MVSZ.LPPSZ[i]);
                }
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
            }
            break;

        default:
            DebugTrace("TraceMVPStrings got incorrect property type %u for tag %x\n",
              PROP_TYPE(PropValue.ulPropTag), PropValue.ulPropTag);
            break;
    }
}


/***************************************************************************

    Name      : DebugBinary

    Purpose   : Debug dump an array of bytes

    Parameters: cb = number of bytes to dump
                lpb -> bytes to dump

    Returns   : none

    Comment   :

***************************************************************************/
#define DEBUG_NUM_BINARY_LINES  2
VOID DebugBinary(UINT cb, LPBYTE lpb) {
    UINT cbLines = 0;

#if (DEBUG_NUM_BINARY_LINES != 0)
    UINT cbi;

    while (cb && cbLines < DEBUG_NUM_BINARY_LINES) {
        cbi = min(cb, 16);
        cb -= cbi;

        switch (cbi) {
            case 16:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14],
                  lpb[15]);
                break;
            case 1:
                DebugTrace("%02x\n", lpb[0]);
                break;
            case 2:
                DebugTrace("%02x %02x\n", lpb[0], lpb[1]);
                break;
            case 3:
                DebugTrace("%02x %02x %02x\n", lpb[0], lpb[1], lpb[2]);
                break;
            case 4:
                DebugTrace("%02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3]);
                break;
            case 5:
                DebugTrace("%02x %02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3],
                  lpb[4]);
                break;
            case 6:
                DebugTrace("%02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5]);
                break;
            case 7:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6]);
                break;
            case 8:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7]);
                break;
            case 9:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8]);
                break;
            case 10:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9]);
                break;
            case 11:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10]);
                break;
            case 12:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11]);
                break;
            case 13:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12]);
                break;
            case 14:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13]);
                break;
            case 15:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14]);
                break;
        }
        lpb += cbi;
        cbLines++;
    }
    if (cb) {
        DebugTrace("<etc.>");    //
    }
#endif
}


#define RETURN_PROP_CASE(pt) case PROP_ID(pt): return(#pt)

/***************************************************************************

    Name      : PropTagName

    Purpose   : Associate a name with a property tag

    Parameters: ulPropTag = property tag

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
PUCHAR PropTagName(ULONG ulPropTag) {
    static UCHAR szPropTag[35]; // see string on default

    switch (PROP_ID(ulPropTag)) {

        RETURN_PROP_CASE(PR_INITIALS);
        RETURN_PROP_CASE(PR_SURNAME);
        RETURN_PROP_CASE(PR_TITLE);
        RETURN_PROP_CASE(PR_TELEX_NUMBER);
        RETURN_PROP_CASE(PR_GIVEN_NAME);
        RETURN_PROP_CASE(PR_PRIMARY_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PRIMARY_FAX_NUMBER);
        RETURN_PROP_CASE(PR_POSTAL_CODE);
        RETURN_PROP_CASE(PR_POSTAL_ADDRESS);
        RETURN_PROP_CASE(PR_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_PAGER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_OTHER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ORGANIZATIONAL_ID_NUMBER);
        RETURN_PROP_CASE(PR_OFFICE_LOCATION);
        RETURN_PROP_CASE(PR_LOCATION);
        RETURN_PROP_CASE(PR_LOCALITY);
        RETURN_PROP_CASE(PR_ISDN_NUMBER);
        RETURN_PROP_CASE(PR_GOVERNMENT_ID_NUMBER);
        RETURN_PROP_CASE(PR_GENERATION);
        RETURN_PROP_CASE(PR_DEPARTMENT_NAME);
        RETURN_PROP_CASE(PR_COUNTRY);
        RETURN_PROP_CASE(PR_COMPANY_NAME);
        RETURN_PROP_CASE(PR_COMMENT);
        RETURN_PROP_CASE(PR_CELLULAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CALLBACK_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_FAX_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT);
        RETURN_PROP_CASE(PR_ACCOUNT);
        RETURN_PROP_CASE(PR_TEMPLATEID);
        RETURN_PROP_CASE(PR_DETAILS_TABLE);
        RETURN_PROP_CASE(PR_SEARCH_KEY);
        RETURN_PROP_CASE(PR_LAST_MODIFICATION_TIME);
        RETURN_PROP_CASE(PR_CREATION_TIME);
        RETURN_PROP_CASE(PR_ENTRYID);
        RETURN_PROP_CASE(PR_RECORD_KEY);
        RETURN_PROP_CASE(PR_MAPPING_SIGNATURE);
        RETURN_PROP_CASE(PR_OBJECT_TYPE);
        RETURN_PROP_CASE(PR_ROWID);
        RETURN_PROP_CASE(PR_ADDRTYPE);
        RETURN_PROP_CASE(PR_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_EMAIL_ADDRESS);
        RETURN_PROP_CASE(PR_DEPTH);
        RETURN_PROP_CASE(PR_ROW_TYPE);
        RETURN_PROP_CASE(PR_RADIO_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_HOME_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_INSTANCE_KEY);
        RETURN_PROP_CASE(PR_DISPLAY_TYPE);
        RETURN_PROP_CASE(PR_RECIPIENT_TYPE);
        RETURN_PROP_CASE(PR_CONTAINER_FLAGS);
        RETURN_PROP_CASE(PR_DEF_CREATE_DL);
        RETURN_PROP_CASE(PR_DEF_CREATE_MAILUSER);
        RETURN_PROP_CASE(PR_CONTACT_ADDRTYPES);
        RETURN_PROP_CASE(PR_CONTACT_DEFAULT_ADDRESS_INDEX);
        RETURN_PROP_CASE(PR_CONTACT_EMAIL_ADDRESSES);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_CITY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_COUNTRY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POSTAL_CODE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STREET);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_MIDDLE_NAME);
        RETURN_PROP_CASE(PR_NICKNAME);
        RETURN_PROP_CASE(PR_PERSONAL_HOME_PAGE);
        RETURN_PROP_CASE(PR_BUSINESS_HOME_PAGE);
        RETURN_PROP_CASE(PR_MHS_COMMON_NAME);
        RETURN_PROP_CASE(PR_SEND_RICH_INFO);
        RETURN_PROP_CASE(PR_TRANSMITABLE_DISPLAY_NAME);

        default:
            wnsprintf(szPropTag, ARRAYSIZE(szPropTag), "Unknown property tag 0x%x",
              PROP_ID(ulPropTag));
            return(szPropTag);
    }
}


/***************************************************************************

    Name      : DebugPropTagArray

    Purpose   : Displays MAPI property tags from a counted array

    Parameters: lpPropArray -> property array
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugPropTagArray(LPSPropTagArray lpPropArray, PUCHAR pszObject) {
    DWORD i;
    PUCHAR lpType;

    if (lpPropArray == NULL) {
        DebugTrace("Empty %s property tag array.\n", pszObject ? pszObject : szNULL);
        return;
    }

    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s property tags:\n", lpPropArray->cValues,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < lpPropArray->cValues ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpPropArray->aulPropTag[i],
          lpPropArray->aulPropTag[i] >> 16,
          lpPropArray->aulPropTag[i] & 0xffff);
#endif
        switch (lpPropArray->aulPropTag[i] & 0xffff) {
            case PT_STRING8:
                lpType = "STRING8";
                break;
            case PT_LONG:
                lpType = "LONG";
                break;
            case PT_I2:
                lpType = "I2";
                break;
            case PT_ERROR:
                lpType = "ERROR";
                break;
            case PT_BOOLEAN:
                lpType = "BOOLEAN";
                break;
            case PT_R4:
                lpType = "R4";
                break;
            case PT_DOUBLE:
                lpType = "DOUBLE";
                break;
            case PT_CURRENCY:
                lpType = "CURRENCY";
                break;
            case PT_APPTIME:
                lpType = "APPTIME";
                break;
            case PT_SYSTIME:
                lpType = "SYSTIME";
                break;
            case PT_UNICODE:
                lpType = "UNICODE";
                break;
            case PT_CLSID:
                lpType = "CLSID";
                break;
            case PT_BINARY:
                lpType = "BINARY";
                break;
            case PT_I8:
                lpType = "PT_I8";
                break;
            case PT_MV_I2:
                lpType = "MV_I2";
                break;
            case PT_MV_LONG:
                lpType = "MV_LONG";
                break;
            case PT_MV_R4:
                lpType = "MV_R4";
                break;
            case PT_MV_DOUBLE:
                lpType = "MV_DOUBLE";
                break;
            case PT_MV_CURRENCY:
                lpType = "MV_CURRENCY";
                break;
            case PT_MV_APPTIME:
                lpType = "MV_APPTIME";
                break;
            case PT_MV_SYSTIME:
                lpType = "MV_SYSTIME";
                break;
            case PT_MV_BINARY:
                lpType = "MV_BINARY";
                break;
            case PT_MV_STRING8:
                lpType = "MV_STRING8";
                break;
            case PT_MV_UNICODE:
                lpType = "MV_UNICODE";
                break;
            case PT_MV_CLSID:
                lpType = "MV_CLSID";
                break;
            case PT_MV_I8:
                lpType = "MV_I8";
                break;
            case PT_NULL:
                lpType = "NULL";
                break;
            case PT_OBJECT:
                lpType = "OBJECT";
                break;
            default:
                DebugTrace("<Unknown Property Type>");
                break;
        }
        DebugTrace("%s\t%s\n", PropTagName(lpPropArray->aulPropTag[i]), lpType);
    }
}


/***************************************************************************

    Name      : DebugProperties

    Purpose   : Displays MAPI properties in a property list

    Parameters: lpProps -> property list
                cProps = count of properties
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject) {
    DWORD i, j;


    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s properties:\n", cProps,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < cProps ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpProps[i].ulPropTag,
          lpProps[i].ulPropTag >> 16,
          lpProps[i].ulPropTag & 0xffff);
#endif
        DebugTrace("%s\n", PropTagName(lpProps[i].ulPropTag));

        switch (lpProps[i].ulPropTag & 0xffff) {
            case PT_STRING8:
                if (lstrlen(lpProps[i].Value.lpszA) < 1024) {
                    DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.lpszA);
                } else {
                    DebugTrace("STRING8 Value is too long to display\n");
                }
                break;
            case PT_LONG:
                DebugTrace("LONG Value:%u\n", lpProps[i].Value.l);
                break;
            case PT_I2:
                DebugTrace("I2 Value:%u\n", lpProps[i].Value.i);
                break;
            case PT_ERROR:
                DebugTrace("ERROR Value: 0x%08x\n", lpProps[i].Value.err);
                break;
            case PT_BOOLEAN:
                DebugTrace("BOOLEAN Value:%s\n", lpProps[i].Value.b ?
                  "TRUE" : "FALSE");
                break;
            case PT_R4:
                DebugTrace("R4 Value\n");
                break;
            case PT_DOUBLE:
                DebugTrace("DOUBLE Value\n");
                break;
            case PT_CURRENCY:
                DebugTrace("CURRENCY Value\n");
                break;
            case PT_APPTIME:
                DebugTrace("APPTIME Value\n");
                break;
            case PT_SYSTIME:
//                DebugTime(lpProps[i].Value.ft, "SYSTIME Value:%s\n");
                break;
            case PT_UNICODE:
                DebugTrace("UNICODE Value\n");
                break;
            case PT_CLSID:
                DebugTrace("CLSID Value\n");
                break;
            case PT_BINARY:
                DebugTrace("BINARY Value %u bytes:\n", lpProps[i].Value.bin.cb);
                DebugBinary(lpProps[i].Value.bin.cb, lpProps[i].Value.bin.lpb);
                break;
            case PT_I8:
                DebugTrace("LARGE_INTEGER Value\n");
                break;
            case PT_MV_I2:
                DebugTrace("MV_I2 Value\n");
                break;
            case PT_MV_LONG:
                DebugTrace("MV_LONG Value\n");
                break;
            case PT_MV_R4:
                DebugTrace("MV_R4 Value\n");
                break;
            case PT_MV_DOUBLE:
                DebugTrace("MV_DOUBLE Value\n");
                break;
            case PT_MV_CURRENCY:
                DebugTrace("MV_CURRENCY Value\n");
                break;
            case PT_MV_APPTIME:
                DebugTrace("MV_APPTIME Value\n");
                break;
            case PT_MV_SYSTIME:
                DebugTrace("MV_SYSTIME Value\n");
                break;
            case PT_MV_BINARY:
                DebugTrace("MV_BINARY with %u values\n", lpProps[i].Value.MVbin.cValues);
                for (j = 0; j < lpProps[i].Value.MVbin.cValues; j++) {
                    DebugTrace("BINARY Value %u: %u bytes\n", j, lpProps[i].Value.MVbin.lpbin[j].cb);
                    DebugBinary(lpProps[i].Value.MVbin.lpbin[j].cb, lpProps[i].Value.MVbin.lpbin[j].lpb);
                }
                break;
            case PT_MV_STRING8:
                DebugTrace("MV_STRING8 with %u values\n", lpProps[i].Value.MVszA.cValues);
                for (j = 0; j < lpProps[i].Value.MVszA.cValues; j++) {
                    if (lstrlen(lpProps[i].Value.MVszA.lppszA[j]) < 1024) {
                        DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.MVszA.lppszA[j]);
                    } else {
                        DebugTrace("STRING8 Value is too long to display\n");
                    }
                }
                break;
            case PT_MV_UNICODE:
                DebugTrace("MV_UNICODE Value\n");
                break;
            case PT_MV_CLSID:
                DebugTrace("MV_CLSID Value\n");
                break;
            case PT_MV_I8:
                DebugTrace("MV_I8 Value\n");
                break;
            case PT_NULL:
                DebugTrace("NULL Value\n");
                break;
            case PT_OBJECT:
                DebugTrace("OBJECT Value\n");
                break;
            default:
                DebugTrace("Unknown Property Type\n");
                break;
        }
    }
}


/***************************************************************************

    Name      : DebugADRLIST

    Purpose   : Displays structure of an ADRLIST including properties

    Parameters: lpAdrList -> ADRLSIT to show
                lpszTitle = string to identify this dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle) {
     ULONG i;
     TCHAR szTitle[250];

     for (i = 0; i < lpAdrList->cEntries; i++) {

         wnsprintf(szTitle, ARRAYSIZE(szTitle), "%s : Entry %u", lpszTitle, i);
         _DebugProperties(lpAdrList->aEntries[i].rgPropVals,
           lpAdrList->aEntries[i].cValues, szTitle);
     }
}


/***************************************************************************

    Name      : DebugObjectProps

    Purpose   : Displays MAPI properties of an object

    Parameters: fMAPI = TRUE if this is a MAPI object, FALSE if WAB
                lpObject -> object to dump
                Label = string to identify this prop dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugObjectProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label) {
    DWORD cProps = 0;
    LPSPropValue lpProps = NULL;
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;


    hr = lpObject->lpVtbl->GetProps(lpObject, NULL, 0, &cProps, &lpProps);
    switch (sc = GetScode(hr)) {
        case SUCCESS_SUCCESS:
            break;

        case MAPI_W_ERRORS_RETURNED:
            DebugTrace("GetProps -> Errors Returned\n");
            break;

        default:
            DebugTrace("GetProps -> Error 0x%x\n", sc);
            return;
    }

    _DebugProperties(lpProps, cProps, Label);

    FreeBufferAndNull(fMAPI, &lpProps);
}


/*
 *	Destroys an SRowSet structure.
 */
STDAPI_(void)
MyFreeProws(BOOL fMAPI, LPSRowSet prows)
{
	ULONG		irow;

	if (!prows)
		return;

	for (irow = 0; irow < prows->cRows; ++irow)
		FreeBufferAndNull(fMAPI, &(prows->aRow[irow].lpProps));
	FreeBufferAndNull(fMAPI, &prows);
}


/***************************************************************************

    Name      : DebugMapiTable

    Purpose   : Displays structure of a MAPITABLE including properties

    Parameters: fMAPI = TRUE if this is a MAPI object, FALSE if WAB
                lpTable -> MAPITABLE to display

    Returns   : none

    Comment   : Don't sort the columns or rows here.  This routine should
                not produce side effects in the table.

***************************************************************************/
void _DebugMapiTable(BOOL fMAPI, LPMAPITABLE lpTable) {
    UCHAR szTemp[30];   // plenty for "ROW %u"
    ULONG ulCount;
    WORD wIndex;
    LPSRowSet lpsRow = NULL;
    ULONG ulCurrentRow = (ULONG)-1;
    ULONG ulNum, ulDen, lRowsSeeked;

    DebugTrace("=======================================\n");
    DebugTrace("+  Dump of MAPITABLE at 0x%x:\n", lpTable);
    DebugTrace("---------------------------------------\n");

    // How big is the table?
    lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulCount);
    DebugTrace("Table contains %u rows\n", ulCount);

    // Save the current position in the table
    lpTable->lpVtbl->QueryPosition(lpTable, &ulCurrentRow, &ulNum, &ulDen);

    // Display the properties for each row in the table
    for (wIndex = 0; wIndex < ulCount; wIndex++) {
        // Get the next row
        lpTable->lpVtbl->QueryRows(lpTable, 1, 0, &lpsRow);

        if (lpsRow) {
//            Assert(lpsRow->cRows == 1); // should have exactly one row

            wnsprintf(szTemp, ARRAYSIZE(szTemp), "ROW %u", wIndex);

            _DebugProperties(lpsRow->aRow[0].lpProps,
              lpsRow->aRow[0].cValues, szTemp);

            MyFreeProws(fMAPI, lpsRow);
        }
    }

    // Restore the current position for the table
    if (ulCurrentRow != (ULONG)-1) {
        lpTable->lpVtbl->SeekRow(lpTable, BOOKMARK_BEGINNING, ulCurrentRow,
          &lRowsSeeked);
    }
}


/*
 * DebugTrace -- printf to the debugger console or debug output file
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
VOID FAR CDECL _DebugTrace(LPSTR lpszFmt, ...) {
    va_list marker;
    TCHAR String[1100];

    va_start(marker, lpszFmt);
    wvnsprintf(String, ARRAYSIZE(String), lpszFmt, marker);
    OutputDebugString(String);
}

int EXPORTDBG __cdecl DebugTraceFn(char *pszFormat, ...) {
    va_list marker;
    TCHAR String[1100];

    va_start(marker, pszFormat);
    wvnsprintf(String, ARRAYSIZE(String), pszFormat, marker);
    OutputDebugString(String);
    return(0);
}


/*
 * DebugAssert
 *
 * From MAPI 1.0 SDK sample code
 */
int __cdecl DebugAssert(int fFatal, char *pszFile, int iLine,
  char *pszFormat, ...) {
    char    sz[512];
    va_list vl;
    int     id;

    StrCpyN(sz, "++++ WAB Debug Trap (", ARRAYSIZE(sz));
    OutputDebugString(sz);

    va_start(vl, pszFormat);
    wvnsprintf(sz, ARRAYSIZE(sz), pszFormat, vl);
    va_end(vl);

    wsprintf(sz + lstrlen(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

    OutputDebugString(sz);

    // Hold down control key to prevent MessageBox
    if (GetAsyncKeyState(VK_CONTROL) >= 0) {
        id = MessageBox(NULL,
          sz,
          "Microsoft Windows Address Book Debug Trap",
          MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SYSTEMMODAL |
          (fFatal ? MB_DEFBUTTON1 : MB_DEFBUTTON3) );

        if (id == IDABORT)
            *((LPBYTE)NULL) = 0;
        else if (id == IDRETRY)
            DebugBreak();
    }

    return(0);
}


int EXPORTDBG __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...) {
    char    sz[512];
    va_list vl;
    int     id;

    lstrcpy(sz, "++++ WAB Debug Trap (");
    OutputDebugString(sz);

    va_start(vl, pszFormat);
    wvsprintf(sz, pszFormat, vl);
    va_end(vl);

    wsprintf(sz + lstrlen(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

    OutputDebugString(sz);

    // Hold down control key to prevent MessageBox
    if (GetAsyncKeyState(VK_CONTROL) >= 0) {
        id = MessageBox(NULL,
          sz,
          "Microsoft Windows Address Book Debug Trap",
          MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SYSTEMMODAL |
          (fFatal ? MB_DEFBUTTON1 : MB_DEFBUTTON3) );

        if (id == IDABORT)
            *((LPBYTE)NULL) = 0;
        else if (id == IDRETRY)
            DebugBreak();
    }

    return(0);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\dbgutil.h ===
/***********************************************************************
 *
 * DBGUTIL.H
 *
 * Debug Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

#ifdef DEBUG
VOID _DebugObjectProps(BOOL fMAPI, LPMAPIPROP lpObject, LPTSTR Label);
VOID _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject);
void _DebugMapiTable(BOOL fMAPI, LPMAPITABLE lpTable);
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle);

#define WABDebugObjectProps(lpObject, Label) _DebugObjectProps(FALSE, lpObject, Label)
#define WABDebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define WABDebugMapiTable(lpTable) _DebugMapiTable(FALSE, lpTable)
#define WABDebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)

#define MAPIDebugObjectProps(lpObject, Label) _DebugObjectProps(TRUE, lpObject, Label)
#define MAPIDebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define MAPIDebugMapiTable(lpTable) _DebugMapiTable(TRUE, lpTable)
#define MAPIDebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)

#else

#define WABDebugObjectProps(lpObject, Label)
#define WABDebugProperties(lpProps, cProps, pszObject)
#define WABDebugMapiTable(lpTable)
#define WABDebugADRLIST(lpAdrList, lpszTitle)

#define MAPIDebugObjectProps(lpObject, Label)
#define MAPIDebugProperties(lpProps, cProps, pszObject)
#define MAPIDebugMapiTable(lpTable)
#define MAPIDebugADRLIST(lpAdrList, lpszTitle)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\ldif.c ===
/*
 *  LDIF.C
 *
 *  Migrate LDIF <-> WAB
 *
 *  Copyright 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  To Do:
 *      ObjectClass recognition
 *      Attribute mapping
 *      Groups
 *      Base64
 *      URLs
 *      Reject Change List LDIF
 *
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include "wabimp.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"
#include "initguid.h"
#include <shlwapi.h>

#define CR_CHAR 0x0d
#define LF_CHAR 0x0a
#define CCH_READ_BUFFER 1024
#define NUM_ITEM_SLOTS  32

BOOL decodeBase64(char * bufcoded, char * pbuffdecoded, DWORD  * pcbDecoded);

// for conferencing stuff
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType) \
                        (((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)

HRESULT HrLoadPrivateWABProps(LPADRBOOK );
/*
- The following IDs and tags are for the conferencing named properties
-
-   The GUID for these props is PS_Conferencing
*/

DEFINE_OLEGUID(PS_Conferencing, 0x00062004, 0, 0);

enum _ConferencingTags
{
    prWABConfServers = 0,
    prWABConfMax
};

#define CONF_SERVERS        0x8056

#define OLK_NAMEDPROPS_START CONF_SERVERS

ULONG PR_SERVERS;

SizedSPropTagArray(prWABConfMax, ptaUIDetlsPropsConferencing);
// end conferencing duplication

// Index into LDIF_ATTR_TABLE
//
// IMPORTANT: This is an intentionally ordered list!
// Within synonyms, the earlier attributes listed take precedence over those that follow.  For
// example, if the record contains both "co" and "o" attributes, the value in the "co" attribute
// will be used for PR_COMPANY_NAME.
typedef enum _LDIF_ATTRIBUTES {
    // PR_OBJECT_TYPE
    ela_objectclass = 0,                        // object class (required)

    // PR_COUNTRY
    ela_c,                                      // country
    ela_countryname,

    // PR_DISPLAY_NAME
    ela_display_name,                           // (Microsoft servers use this)
    ela_cn,                                     // common name (display name)
    ela_commonName,                             // (display name)

    // PR_COMPANY_NAME
    ela_co,                                     // company
    ela_organizationName,                       // (company)
    ela_o,                                      // organization (company)

    // PR_MIDDLE_NAME
    ela_initials,

    // PR_SURNAME
    ela_sn,                                     // surname
    ela_surname,

    // PR_GIVEN_NAME
    ela_givenname,
    ela_uid,                                    // (given name) ?

    // PR_DEPARTMENT_NAME
    ela_department,
    ela_ou,                                     // organizational unit (department)
    ela_organizationalUnitName,                 // (department)

    // PR_COMMENT
    ela_comment,
    ela_description,                            // description
    ela_info,                                   // info

    // PR_LOCALITY
    ela_l,                                      // locality (city)
    ela_locality,                               // locality (city)

    // no mapping
    ela_dn,                                     // distinguished name

    // PR_NICKNAME
    ela_xmozillanickname,                       // Netscape nickname

    // no mapping
    ela_conferenceInformation,                  // conference server
    ela_xmozillaconference,                     // Netscape conference server

    // PR_HOME_FAX_NUMBER
    ela_facsimiletelephonenumber,               // home fax number

    // PR_BUSINESS_FAX_NUMBER
    ela_OfficeFax,

    // PR_BUSINESS_TELEPHONE_NUMBER
    ela_telephonenumber,

    // PR_HOME_TELEPHONE_NUMBER
    ela_homephonenumber,

    // PR_MOBILE_TELEPHONE_NUMBER
    ela_mobile,                                 // cellular phone number

    // PR_PAGER_TELEPHONE_NUMBER
    ela_OfficePager,
    ela_pager,

    // PR_OFFICE_LOCATION
    ela_physicalDeliveryOfficeName,             // office location

    // PR_HOME_ADDRESS_STREET
    ela_homePostalAddress,

    // PR_STREET_ADDRESS
    ela_streetAddress,                          // business street address
    ela_street,                                 // business street address
    ela_postalAddress,                          // business street address

    // PR_STATE_OR_PROVINCE
    ela_st,                                     // business address state

    // PR_POST_OFFICE_BOX
    ela_postOfficeBox,                          // business PO Box

    // PR_POSTAL_CODE
    ela_postalcode,                             // business address zip code

    // PR_PERSONAL_HOME_PAGE
    ela_homepage,                               // personal home page

    // PR_BUSINESS_HOME_PAGE
    ela_URL,                                    // business home page

    // PR_EMAIL_ADDRESS
    ela_mail,                                   // email address

    // PR_CONTACT_EMAIL_ADDRESSES
    ela_otherMailbox,                           // secondary email addresses

    // PR_TITLE
    ela_title,                                  // title

    // no mapping
    ela_member,                                 // DL member

    // no mapping
    ela_userCertificate,                        // certificate

    // no mapping
    ela_labeledURI,                             // labelled URI URL

    // no mapping
    ela_xmozillauseconferenceserver,            // Netscape conference info

    // no mapping
    ela_xmozillausehtmlmail,                    // Netscape HTML mail flag

    ela_Max,
} LDIF_ATTRIBUTES, *LPLDIF_ATTRIBUTES;

typedef struct _LDIF_ATTR_TABLE {
    const BYTE * lpName;                        // LDIF attribute name
    ULONG index;                                // attribute index within LDIF record
    ULONG ulPropTag;                            // prop tag mapping
    ULONG ulPropIndex;                          // index in prop array
} LDIF_ATTR_TABLE, *LPLDIF_ATTR_TABLE;


typedef enum _LDIF_PROPERTIES {
    elp_OBJECT_TYPE,
    elp_DISPLAY_NAME,
    elp_EMAIL_ADDRESS,
    elp_SURNAME,
    elp_GIVEN_NAME,
    elp_TITLE,
    elp_COMPANY_NAME,
    elp_OFFICE_LOCATION,
    elp_HOME_ADDRESS_STREET,
    elp_STREET_ADDRESS,
    elp_STATE_OR_PROVINCE,
    elp_POST_OFFICE_BOX,
    elp_POSTAL_CODE,
    elp_LOCALITY,
    elp_COUNTRY,
    elp_MIDDLE_NAME,
    elp_DEPARTMENT_NAME,
    elp_COMMENT,
    elp_NICKNAME,
    elp_HOME_FAX_NUMBER,
    elp_BUSINESS_FAX_NUMBER,
    elp_BUSINESS_TELEPHONE_NUMBER,
    elp_HOME_TELEPHONE_NUMBER,
    elp_MOBILE_TELEPHONE_NUMBER,
    elp_PAGER_TELEPHONE_NUMBER,
    elp_PERSONAL_HOME_PAGE,
    elp_BUSINESS_HOME_PAGE,
    elp_CONTACT_EMAIL_ADDRESSES,
    elp_CONFERENCE_SERVERS,
    elp_Max
} LDIF_ATTRIBUTES, *LPLDIF_ATTRIBUTES;


// Must have
//  PR_DISPLAY_NAME

#define NUM_MUST_HAVE_PROPS 1

typedef enum _LDIF_DATA_TYPE {
    LDIF_ASCII,
    LDIF_BASE64,
    LDIF_URL
} LDIF_DATA_TYPE, *LPLDIF_DATA_TYPE;

typedef struct _LDIF_RECORD_ATTRIBUTE {
    LPBYTE lpName;
    LPBYTE lpData;
    ULONG cbData;
    LDIF_DATA_TYPE Type;
} LDIF_RECORD_ATTRIBUTE, * LPLDIF_RECORD_ATTRIBUTE;

const TCHAR szLDIFFilter[] =                    "*.ldf;*.ldif";
const TCHAR szLDIFExt[] =                       "ldf";


// LDAP attribute names
const BYTE sz_c[] =                             "c";
const BYTE sz_cn[] =                            "cn";
const BYTE sz_co[] =                            "co";
const BYTE sz_comment[] =                       "comment";
const BYTE sz_commonName[] =                    "commonName";
const BYTE sz_conferenceInformation[] =         "conferenceInformation";
const BYTE sz_countryname[] =                   "countryname";
const BYTE sz_department[] =                    "department";
const BYTE sz_description[] =                   "description";
const BYTE sz_display_name[] =                  "display-name";
const BYTE sz_dn[] =                            "dn";
const BYTE sz_facsimiletelephonenumber[] =      "facsimiletelephonenumber";
const BYTE sz_givenname[] =                     "givenname";
const BYTE sz_homePostalAddress[] =             "homePostalAddress";
const BYTE sz_homepage[] =                      "homepage";
const BYTE sz_info[] =                          "info";
const BYTE sz_initials[] =                      "initials";
const BYTE sz_l[] =                             "l";
const BYTE sz_labeledURI[] =                    "labeledURI";
const BYTE sz_locality[] =                      "locality";
const BYTE sz_mail[] =                          "mail";
const BYTE sz_member[] =                        "member";
const BYTE sz_mobile[] =                        "mobile";
const BYTE sz_o[] =                             "o";
const BYTE sz_objectclass[] =                   "objectclass";
const BYTE sz_OfficeFax[] =                     "OfficeFax";
const BYTE sz_OfficePager[] =                   "OfficePager";
const BYTE sz_organizationName[] =              "organizationName";
const BYTE sz_organizationalUnitName[] =        "organizationalUnitName";
const BYTE sz_otherMailbox[] =                  "otherMailbox";
const BYTE sz_ou[] =                            "ou";
const BYTE sz_pager[] =                         "pager";
const BYTE sz_physicalDeliveryOfficeName[] =    "physicalDeliveryOfficeName";
const BYTE sz_postOfficeBox[] =                 "postOfficeBox";
const BYTE sz_postalAddress[] =                 "postalAddress";
const BYTE sz_postalcode[] =                    "postalcode";
const BYTE sz_sn[] =                            "sn";
const BYTE sz_st[] =                            "st";
const BYTE sz_streetAddress[] =                 "streetAddress";
const BYTE sz_street[] =                        "street";
const BYTE sz_surname[] =                       "surname";
const BYTE sz_telephonenumber[] =               "telephonenumber";
const BYTE sz_homephonenumber[] =               "homephone";
const BYTE sz_title[] =                         "title";
const BYTE sz_uid[] =                           "uid";
const BYTE sz_URL[] =                           "URL";
const BYTE sz_userCertificate[] =               "userCertificate";
const BYTE sz_xmozillaconference[] =            "xmozillaconference";
const BYTE sz_xmozillanickname[] =              "xmozillanickname";
const BYTE sz_xmozillauseconferenceserver[] =   "xmozillauseconferenceserver";
const BYTE sz_xmozillausehtmlmail[] =           "xmozillausehtmlmail";


// LDAP objectclass values
const BYTE sz_groupOfNames[] =                  "groupOfNames";
const BYTE sz_person[] =                        "person";
const BYTE sz_organizationalPerson[] =          "organizationalPerson";

// since defs aren't shared -- these are also defined in ui_detls.c
const LPTSTR szCallto = TEXT("callto://"); 
const LPTSTR szFwdSlash = "/";

BOOL HandleImportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_IMPORT_OPTIONS lpImportOptions);
BOOL HandleExportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_EXPORT_OPTIONS lpExportOptions);



/***************************************************************************

    Name      : FreeLDIFRecord

    Purpose   : Frees an LDIF record structure

    Parameters: lpLDIFRecord -> record to clean up
                ulAttributes = number of attributes in lpLDIFRecord

    Returns   : none

    Comment   :

***************************************************************************/
void FreeLDIFRecord(LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord, ULONG ulAttributes) {
    ULONG i;

    if (lpLDIFRecord) {
        for (i = 0; i < ulAttributes; i++) {
            if (lpLDIFRecord[i].lpName) {
                LocalFree(lpLDIFRecord[i].lpName);
                lpLDIFRecord[i].lpName = NULL;
            }
            if (lpLDIFRecord[i].lpData) {
                LocalFree(lpLDIFRecord[i].lpData);
                lpLDIFRecord[i].lpData = NULL;
            }
        }
        LocalFree(lpLDIFRecord);
    }
}


/***************************************************************************

    Name      : OpenLDIFFile

    Purpose   : Opens a LDIF file for import

    Parameters: hwnd = main dialog window
                lpFileName = filename to create
                lphFile -> returned file handle

    Returns   : HRESULT

    Comment   :

***************************************************************************/
HRESULT OpenLDIFFile(HWND hwnd, LPTSTR lpFileName, LPHANDLE lphFile) {
    LPTSTR lpFilter;
    TCHAR szFileName[MAX_PATH + 1] = "";
    OPENFILENAME ofn;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HRESULT hResult = hrSuccess;
    DWORD ec;


    if (INVALID_HANDLE_VALUE == (hFile = CreateFile(lpFileName,
      GENERIC_READ,
      0,    // sharing
      NULL,
      CREATE_NEW,
      FILE_FLAG_SEQUENTIAL_SCAN,
      NULL))) {
        ec = GetLastError();
        DebugTrace("CreateFile(%s) -> %u\n", lpFileName, ec);
        switch (ec) {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
            default:
                ShowMessageBoxParam(hwnd, IDE_LDIF_IMPORT_FILE_ERROR, MB_ICONERROR, lpFileName);
                hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                break;
        }
    }

    if (! hResult) {
        *lphFile = hFile;
    }
    return(hResult);
}


/***************************************************************************

    Name      : ReadLDIFLine

    Purpose   : Reads a line from and LDIF file

    Parameters: hFile = File handle
                lppBuffer -> In/Out start of read buffer (return line data here)
                lpcbBuffer = In/Out size of buffer

    Returns   : number of bytes read from file

    Comment   :

***************************************************************************/
ULONG ReadLDIFLine(HANDLE hFile, LPBYTE * lppBuffer, LPULONG lpcbBuffer) {
    ULONG cbRead = 0;
    ULONG cbReadFile = 0;
    BOOL fDone = FALSE;
    BOOL fColumn1 = TRUE;
    BOOL fComment = FALSE;
    BOOL fComent = FALSE;
    ULONG ulSavePosition = 0;
    LPBYTE lpRead = *lppBuffer;     // current read pointer
    LPBYTE lpT;

    while (! fDone) {
        if (cbRead >= (*lpcbBuffer - 1)) {     // leave room for null
            ULONG cbOffset = (ULONG) (lpRead - *lppBuffer);

            // Buffer is too small.  Reallocate!
            *lpcbBuffer += CCH_READ_BUFFER;
            if (! (lpT = LocalReAlloc(*lppBuffer, *lpcbBuffer, LMEM_MOVEABLE | LMEM_ZEROINIT))) {
                DebugTrace("LocalReAlloc(%u) -> %u\n", *lpcbBuffer, GetLastError());
                break;
            }
            *lppBuffer = lpT;
            lpRead = *lppBuffer + cbOffset;
        }

        if ((! ReadFile(hFile,
          lpRead,
          1,        // 1 character at a time
          &cbReadFile,
          NULL)) || cbReadFile == 0) {
            DebugTrace("ReadFile -> EOF\n");
            fDone = TRUE;
        } else {
            cbReadFile++;

            // Got a character
            // Is it interesting?
            switch (*lpRead) {
                case '#':   // Comment line
                    if (fColumn1) {
                        // This is a comment line.  Dump the whole line
                        fComment = TRUE;
                    } else {
                        cbRead++;
                        lpRead++;
                    }
                    fColumn1 = FALSE;
                    break;

                case ' ':
                    if (fColumn1 || fComment) {
                        // This is a continuation or a comment, eat this space.
                    } else {
                        cbRead++;
                        lpRead++;
                    }
                    fColumn1 = FALSE;
                    break;

                case '\n':      // LDIF SEP character
                    if (fColumn1) {
                        // This is not a continuation, we've gone too far.  Back up!
                        if (ulSavePosition) {
                            if (0xFFFFFFFF == (SetFilePointer(hFile, ulSavePosition, NULL, FILE_BEGIN))) {
                                DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
                                return(ResultFromScode(MAPI_E_CALL_FAILED));
                            }
                        }
                        fDone = TRUE;
                    } else {
                        fColumn1 = TRUE;
                        fComment = FALSE;
                        // Should check if next line starts with continuation character (space)
                        // Save the current position in case it isn't.
                        if (0xFFFFFFFF == (ulSavePosition = SetFilePointer(hFile, 0, NULL, FILE_CURRENT))) {
                            DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
                        }
                    }
                    break;

                case '\r':      // Eat the Carriage Return character
                    break;

                default:
                    if (! fComment) {
                        if (cbRead && fColumn1) {
                            // This is not a continuation, we've gone too far.  Back up!
                            Assert(ulSavePosition);
                            if (ulSavePosition) {
                                if (0xFFFFFFFF == (SetFilePointer(hFile, ulSavePosition, NULL, FILE_BEGIN))) {
                                    DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
                                    return(ResultFromScode(MAPI_E_CALL_FAILED));
                                }
                            }
                            fDone = TRUE;
                        } else {
                            cbRead++;
                            lpRead++;
                        }
                    }
                    fColumn1 = FALSE;
                    break;
            }
        }
    }

    *lpRead = '\0';    // Terminate the string
    //DebugTrace("LDIF Line: %s\n", *lppBuffer);
    return(cbReadFile);
}


/***************************************************************************

    Name      : ParseLDIFLine

    Purpose   : Parse the LDIF input line into Name and Data

    Parameters: lpBuffer -> input buffer
                lppName -> returned name pointer (pointer into lpBuffer)
                lppData -> returned data pointer (pointer into lpBuffer)
                lpcbData -> returned data size
                lpType -> returned LDIF data type

    Returns   : HRESULT

    Comment   : Caller should not free the *lppName and *lppData pointers
                since they are just pointers into the input buffer.

                Assume that lpBuffer is NULL terminated.

                LDIF attrval is formed like this:
                attrname ((":") / (":" *SPACE value) /
                  ("::" *SPACE base64-value) /
                  (":<" *SPACE url))

***************************************************************************/
HRESULT ParseLDIFLine(LPBYTE lpBuffer, PUCHAR * lppName, PUCHAR * lppData,
  LPULONG lpcbData, LPLDIF_DATA_TYPE lpType) {
    HRESULT hResult = hrSuccess;
    LPBYTE lpTemp = lpBuffer;

    // Strip of leading white space
    while (*lpTemp == ' ' || *lpTemp == '\r' || *lpTemp == '\n') {
        lpTemp++;
    }

    if (*lpTemp) {
        *lppName = lpTemp;

        // Look for the end of the name
        while (lpTemp && *lpTemp && *lpTemp != ':') {
            lpTemp++;
        }

        if (*lpTemp != ':') {
            // Hmm, this isn't very good LDIF.  Error out.
            hResult = ResultFromScode(MAPI_E_BAD_VALUE);
            goto exit;
        }

        // now pointing to the ':', put a NULL there to terminate the name
        *lpTemp = '\0';

        // What type of encoding is it?
        lpTemp++;

        switch (*lpTemp) {
            case ':':
                *lpType = LDIF_BASE64;
                lpTemp++;
                break;

            case '<':
                *lpType = LDIF_URL;
                lpTemp++;
                break;

            case '\0':
                // No data.  This is legitimate.
                // Fall through to default.

            default:    // anything else implies ASCII value
                *lpType = LDIF_ASCII;
                break;
        }

        // Strip of spaces leading the data
        while (*lpTemp == ' ') {
            lpTemp++;
        }

        // Now pointing at data
        *lppData = lpTemp;

        // Count bytes of data
        *lpcbData = lstrlen(lpTemp) + 1;
    }

exit:
    return(hResult);
}


/***************************************************************************

    Name      : ReadLDIFRecord

    Purpose   : Reads a record from an LDIF file with fixups for special characters

    Parameters: hFile = file handle
                lpcItems -> Returned number of items
                lprgItems -> Returned array of item strings.  Caller is
                  responsible for LocalFree'ing each string pointer and
                  this array pointer.

    Returns   : HRESULT

    Comment   : LDIF special characters are '#', ' ', CR and LF.
                Rules:
                    1) A line which starts with '#' is a comment
                    2) A line which starts with a ' ' is a continuation

***************************************************************************/
HRESULT ReadLDIFRecord(HANDLE hFile, ULONG * lpcItems, LPLDIF_RECORD_ATTRIBUTE * lppLDIFRecord) {
    HRESULT hResult = hrSuccess;
    PUCHAR lpBuffer  = NULL;
    ULONG cbBuffer = 0;
    ULONG cbReadFile = 1;
    ULONG iItem = 0;
    ULONG cAttributes = 0;
    BOOL fEOR = FALSE;
    LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord = NULL;
    LDIF_DATA_TYPE Type;
    LPBYTE lpData = NULL;
    LPTSTR lpName = NULL;
    ULONG cbData = 0;
    TCHAR szTemp[2048]; // 2k limit
    LPLDIF_RECORD_ATTRIBUTE lpLDIFRecordT;



    // Start out with 1024 character buffer.  Realloc as necesary.
    cbBuffer = CCH_READ_BUFFER;
    if (! (lpBuffer = LocalAlloc(LPTR, cbBuffer))) {
        DebugTrace("LocalAlloc(%u) -> %u\n", cbBuffer, GetLastError());
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Start out with 32 item slots.  Realloc as necesary.
    cAttributes = NUM_ITEM_SLOTS;
    if (! (lpLDIFRecord = LocalAlloc(LPTR, cAttributes * sizeof(LDIF_RECORD_ATTRIBUTE)))) {
        DebugTrace("LocalAlloc(%u) -> %u\n", cAttributes * sizeof(PUCHAR), GetLastError());
        LocalFree(lpBuffer);
        hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
        goto exit;
    }

    // Read attributes lines until you get end of record or EOF
    while (! fEOR) {
        // Read the next line (merges continuation)
        if (cbReadFile = ReadLDIFLine(hFile, &lpBuffer, &cbBuffer)) 
        {
            ULONG cchSize  = 0;

            // Got another attribute, parse it
            if (hResult = ParseLDIFLine(lpBuffer, &lpName, &lpData, &cbData, &Type)) {
                goto exit;
            }

            // End of record?
            if (! lpName || ! lstrlen(lpName)) {
                fEOR = TRUE;
                break;
            }

            // Make sure there's room in the returned table for this attribute
            if (iItem >= cAttributes) {
                // Array is too small.  Reallocate!
                cAttributes += 1;   // NUM_ITEM_SLOTS;      // Allocate another batch
                if (! (lpLDIFRecordT = LocalReAlloc(lpLDIFRecord, cAttributes * sizeof(LDIF_RECORD_ATTRIBUTE), LMEM_MOVEABLE | LMEM_ZEROINIT))) 
                {
                    DebugTrace("LocalReAlloc(%u) -> %u\n", cAttributes * sizeof(PUCHAR), GetLastError());
                    hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                    goto exit;
                }
                lpLDIFRecord = lpLDIFRecordT;
            }

            // Fill in the attribute in the structure

            // BUGBUG: Here's where we should decode BASE64

            if(Type == LDIF_BASE64)
            {
                ULONG cb = sizeof(szTemp);
                *szTemp = '\0';
                decodeBase64(  lpData, szTemp, &cb);
                if(szTemp && lstrlen(szTemp))
                {
                    lpData = szTemp;
                    cbData = cb;
                    szTemp[cb] = '\0';
                }
            }

            lpLDIFRecord[iItem].Type = Type;
            lpLDIFRecord[iItem].cbData = cbData;

            if (! (lpLDIFRecord[iItem].lpData = LocalAlloc(LPTR, cbData))) 
            {
                DebugTrace("LocalAlloc(%u) -> %u\n", cbData, GetLastError());
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            memcpy(lpLDIFRecord[iItem].lpData, lpData, cbData);

			cchSize = lstrlen(lpName) + 1;
            if (! (lpLDIFRecord[iItem].lpName = LocalAlloc(LPTR, cchSize))) 
            {
                DebugTrace("LocalAlloc(%u) -> %u\n", cchSize, GetLastError());
                hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                goto exit;
            }
            StrCpyN(lpLDIFRecord[iItem].lpName, lpName, cchSize);
        } else {
            fEOR = TRUE;
            hResult = ResultFromScode(WAB_W_END_OF_FILE);
        }

        iItem++;
    }

exit:
    if (lpBuffer) {
        LocalFree(lpBuffer);
    }

    if (hResult) {
        if (lpLDIFRecord) {
            FreeLDIFRecord(lpLDIFRecord, iItem);
            lpLDIFRecord = NULL;
        }
    }

    *lppLDIFRecord = lpLDIFRecord;
    *lpcItems = iItem;

    return(hResult);
}


/***************************************************************************

    Name      : CountLDIFRows

    Purpose   : Counts the rows in the LDIF file

    Parameters: hFile = open LDIF file
                lpulcEntries -> returned count of rows

    Returns   : HRESULT

    Comment   : File pointer should be positioned past the version string prior
                to calling this function.  This function leaves the file
                pointer where it found it.

***************************************************************************/
HRESULT CountLDIFRecords(HANDLE hFile, LPULONG lpulcEntries) {
    HRESULT hResult = hrSuccess;
    PUCHAR * rgItems = NULL;
    ULONG ulStart;
    ULONG cProps, i;
    LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord = NULL;

    *lpulcEntries = 0;

    Assert(hFile != INVALID_HANDLE_VALUE);

    if (0xFFFFFFFF == (ulStart = SetFilePointer(hFile, 0, NULL, FILE_CURRENT))) {
        DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
        return(ResultFromScode(MAPI_E_CALL_FAILED));
    }


    while (hResult == hrSuccess) {
        // Read the line
        if (ReadLDIFRecord(hFile, &cProps, &lpLDIFRecord)) {
            // End of file
            break;
        }

        (*lpulcEntries)++;

        if (lpLDIFRecord) {
            FreeLDIFRecord(lpLDIFRecord, cProps);
            lpLDIFRecord = NULL;
        }
    }
    if (0xFFFFFFFF == SetFilePointer(hFile, ulStart, NULL, FILE_BEGIN)) {
        DebugTrace("CountCSVRows SetFilePointer -> %u\n", GetLastError());
    }

    DebugTrace("LDIF file contains %u entries\n", ulcEntries);
    return(hResult);
}


/***************************************************************************

    Name      : InitLDIFAttrTable

    Purpose   : Initialize the LDIF attribute table

    Parameters: LDIFAttrTable = table of attribute mappings

    Returns   : none

***************************************************************************/
void InitLDIFAttrTable(LPLDIF_ATTR_TABLE LDIFAttrTable) {
    ULONG i;

    for (i = 0; i < ela_Max; i++) {
        LDIFAttrTable[i].index = NOT_FOUND;
        LDIFAttrTable[i].ulPropTag = PR_NULL;
    }
    LDIFAttrTable[ela_c].lpName = sz_c;
    LDIFAttrTable[ela_cn].lpName = sz_cn;
    LDIFAttrTable[ela_co].lpName = sz_co;
    LDIFAttrTable[ela_comment].lpName = sz_comment;
    LDIFAttrTable[ela_commonName].lpName = sz_commonName;
    LDIFAttrTable[ela_conferenceInformation].lpName = sz_conferenceInformation;
    LDIFAttrTable[ela_countryname].lpName = sz_countryname;
    LDIFAttrTable[ela_department].lpName = sz_department;
    LDIFAttrTable[ela_description].lpName = sz_description;
    LDIFAttrTable[ela_display_name].lpName = sz_display_name;
    LDIFAttrTable[ela_dn].lpName = sz_dn;
    LDIFAttrTable[ela_facsimiletelephonenumber].lpName = sz_facsimiletelephonenumber;
    LDIFAttrTable[ela_givenname].lpName = sz_givenname;
    LDIFAttrTable[ela_homePostalAddress].lpName = sz_homePostalAddress;
    LDIFAttrTable[ela_homepage].lpName = sz_homepage;
    LDIFAttrTable[ela_info].lpName = sz_info;
    LDIFAttrTable[ela_initials].lpName = sz_initials;
    LDIFAttrTable[ela_l].lpName = sz_l;
    LDIFAttrTable[ela_labeledURI].lpName = sz_labeledURI;
    LDIFAttrTable[ela_locality].lpName = sz_locality;
    LDIFAttrTable[ela_mail].lpName = sz_mail;
    LDIFAttrTable[ela_member].lpName = sz_member;
    LDIFAttrTable[ela_mobile].lpName = sz_mobile;
    LDIFAttrTable[ela_o].lpName = sz_o;
    LDIFAttrTable[ela_objectclass].lpName = sz_objectclass;
    LDIFAttrTable[ela_OfficeFax].lpName = sz_OfficeFax;
    LDIFAttrTable[ela_OfficePager].lpName = sz_OfficePager;
    LDIFAttrTable[ela_organizationName].lpName = sz_organizationName;
    LDIFAttrTable[ela_organizationalUnitName].lpName = sz_organizationalUnitName;
    LDIFAttrTable[ela_otherMailbox].lpName = sz_otherMailbox;
    LDIFAttrTable[ela_ou].lpName = sz_ou;
    LDIFAttrTable[ela_pager].lpName = sz_pager;
    LDIFAttrTable[ela_physicalDeliveryOfficeName].lpName = sz_physicalDeliveryOfficeName;
    LDIFAttrTable[ela_postOfficeBox].lpName = sz_postOfficeBox;
    LDIFAttrTable[ela_postalAddress].lpName = sz_postalAddress;
    LDIFAttrTable[ela_postalcode].lpName = sz_postalcode;
    LDIFAttrTable[ela_sn].lpName = sz_sn;
    LDIFAttrTable[ela_st].lpName = sz_st;
    LDIFAttrTable[ela_streetAddress].lpName = sz_streetAddress;
    LDIFAttrTable[ela_street].lpName = sz_street;
    LDIFAttrTable[ela_surname].lpName = sz_surname;
    LDIFAttrTable[ela_telephonenumber].lpName = sz_telephonenumber;
    LDIFAttrTable[ela_homephonenumber].lpName = sz_homephonenumber;
    LDIFAttrTable[ela_title].lpName = sz_title;
    LDIFAttrTable[ela_uid].lpName = sz_uid;
    LDIFAttrTable[ela_URL].lpName = sz_URL;
    LDIFAttrTable[ela_userCertificate].lpName = sz_userCertificate;
    LDIFAttrTable[ela_xmozillaconference].lpName = sz_xmozillaconference;
    LDIFAttrTable[ela_xmozillanickname].lpName = sz_xmozillanickname;
    LDIFAttrTable[ela_xmozillauseconferenceserver].lpName = sz_xmozillauseconferenceserver;
    LDIFAttrTable[ela_xmozillausehtmlmail].lpName = sz_xmozillausehtmlmail;


    LDIFAttrTable[ela_c].ulPropTag = PR_COUNTRY;
    LDIFAttrTable[ela_c].ulPropIndex = elp_COUNTRY;
    LDIFAttrTable[ela_cn].ulPropTag = PR_DISPLAY_NAME;
    LDIFAttrTable[ela_cn].ulPropIndex = elp_DISPLAY_NAME;
    LDIFAttrTable[ela_co].ulPropTag = PR_COMPANY_NAME;
    LDIFAttrTable[ela_co].ulPropIndex = elp_COMPANY_NAME;
    LDIFAttrTable[ela_comment].ulPropTag = PR_COMMENT;
    LDIFAttrTable[ela_comment].ulPropIndex = elp_COMMENT;
    LDIFAttrTable[ela_commonName].ulPropTag = PR_DISPLAY_NAME;
    LDIFAttrTable[ela_commonName].ulPropIndex = elp_DISPLAY_NAME;
    LDIFAttrTable[ela_conferenceInformation].ulPropTag = PR_NULL; // bugbug?
    LDIFAttrTable[ela_conferenceInformation].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_countryname].ulPropTag = PR_COUNTRY;
    LDIFAttrTable[ela_countryname].ulPropIndex = elp_COUNTRY;
    LDIFAttrTable[ela_department].ulPropTag = PR_DEPARTMENT_NAME;
    LDIFAttrTable[ela_department].ulPropIndex = elp_DEPARTMENT_NAME;
    LDIFAttrTable[ela_description].ulPropTag = PR_COMMENT;
    LDIFAttrTable[ela_description].ulPropIndex = elp_COMMENT;
    LDIFAttrTable[ela_display_name].ulPropTag = PR_DISPLAY_NAME;
    LDIFAttrTable[ela_display_name].ulPropIndex = elp_DISPLAY_NAME;
    LDIFAttrTable[ela_dn].ulPropTag = PR_DISPLAY_NAME;
    LDIFAttrTable[ela_dn].ulPropIndex = elp_DISPLAY_NAME;
    LDIFAttrTable[ela_facsimiletelephonenumber].ulPropTag = PR_HOME_FAX_NUMBER;
    LDIFAttrTable[ela_facsimiletelephonenumber].ulPropIndex = elp_HOME_FAX_NUMBER;
    LDIFAttrTable[ela_givenname].ulPropTag = PR_GIVEN_NAME;
    LDIFAttrTable[ela_givenname].ulPropIndex = elp_GIVEN_NAME;
    LDIFAttrTable[ela_homePostalAddress].ulPropTag = PR_HOME_ADDRESS_STREET;
    LDIFAttrTable[ela_homePostalAddress].ulPropIndex = elp_HOME_ADDRESS_STREET;
    LDIFAttrTable[ela_homepage].ulPropTag = PR_PERSONAL_HOME_PAGE;
    LDIFAttrTable[ela_homepage].ulPropIndex = elp_PERSONAL_HOME_PAGE;
    LDIFAttrTable[ela_info].ulPropTag = PR_COMMENT;
    LDIFAttrTable[ela_info].ulPropIndex = elp_COMMENT;
    LDIFAttrTable[ela_initials].ulPropTag = PR_MIDDLE_NAME;
    LDIFAttrTable[ela_initials].ulPropIndex = elp_MIDDLE_NAME;
    LDIFAttrTable[ela_l].ulPropTag = PR_LOCALITY;
    LDIFAttrTable[ela_l].ulPropIndex = elp_LOCALITY;
    LDIFAttrTable[ela_labeledURI].ulPropTag = PR_NULL;                      // Labeled URI.  Don't save now.
    LDIFAttrTable[ela_labeledURI].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_locality].ulPropTag = PR_LOCALITY;
    LDIFAttrTable[ela_locality].ulPropIndex = elp_LOCALITY;
    LDIFAttrTable[ela_mail].ulPropTag = PR_EMAIL_ADDRESS;
    LDIFAttrTable[ela_mail].ulPropIndex = elp_EMAIL_ADDRESS;
    LDIFAttrTable[ela_member].ulPropTag = PR_NULL;                          // member of DL
    LDIFAttrTable[ela_member].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_mobile].ulPropTag = PR_MOBILE_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_mobile].ulPropIndex = elp_MOBILE_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_o].ulPropTag = PR_COMPANY_NAME;
    LDIFAttrTable[ela_o].ulPropIndex = elp_COMPANY_NAME;
    LDIFAttrTable[ela_objectclass].ulPropTag = PR_NULL;                     // special case object class
    LDIFAttrTable[ela_objectclass].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_OfficeFax].ulPropTag = PR_BUSINESS_FAX_NUMBER;
    LDIFAttrTable[ela_OfficeFax].ulPropIndex = elp_BUSINESS_FAX_NUMBER;
    LDIFAttrTable[ela_OfficePager].ulPropTag = PR_PAGER_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_OfficePager].ulPropIndex = elp_PAGER_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_organizationName].ulPropTag = PR_COMPANY_NAME;
    LDIFAttrTable[ela_organizationName].ulPropIndex = elp_COMPANY_NAME;
    LDIFAttrTable[ela_organizationalUnitName].ulPropTag = PR_DEPARTMENT_NAME;
    LDIFAttrTable[ela_organizationalUnitName].ulPropIndex = elp_DEPARTMENT_NAME;
    LDIFAttrTable[ela_otherMailbox].ulPropTag = PR_NULL;                    // BUGBUG
    LDIFAttrTable[ela_otherMailbox].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_ou].ulPropTag = PR_DEPARTMENT_NAME;
    LDIFAttrTable[ela_ou].ulPropIndex = elp_DEPARTMENT_NAME;
    LDIFAttrTable[ela_pager].ulPropTag = PR_PAGER_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_pager].ulPropIndex = elp_PAGER_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_physicalDeliveryOfficeName].ulPropTag = PR_OFFICE_LOCATION;
    LDIFAttrTable[ela_physicalDeliveryOfficeName].ulPropIndex = elp_OFFICE_LOCATION;
    LDIFAttrTable[ela_postOfficeBox].ulPropTag = PR_POST_OFFICE_BOX;
    LDIFAttrTable[ela_postOfficeBox].ulPropIndex = elp_POST_OFFICE_BOX;
    LDIFAttrTable[ela_postalAddress].ulPropTag = PR_STREET_ADDRESS;
    LDIFAttrTable[ela_postalAddress].ulPropIndex = elp_STREET_ADDRESS;
    LDIFAttrTable[ela_postalcode].ulPropTag = PR_POSTAL_CODE;
    LDIFAttrTable[ela_postalcode].ulPropIndex = elp_POSTAL_CODE;
    LDIFAttrTable[ela_sn].ulPropTag = PR_SURNAME;
    LDIFAttrTable[ela_sn].ulPropIndex = elp_SURNAME;
    LDIFAttrTable[ela_st].ulPropTag = PR_STATE_OR_PROVINCE;
    LDIFAttrTable[ela_st].ulPropIndex = elp_STATE_OR_PROVINCE;
    LDIFAttrTable[ela_streetAddress].ulPropTag = PR_STREET_ADDRESS;
    LDIFAttrTable[ela_streetAddress].ulPropIndex = elp_STREET_ADDRESS;
    LDIFAttrTable[ela_street].ulPropTag = PR_STREET_ADDRESS;
    LDIFAttrTable[ela_street].ulPropIndex = elp_STREET_ADDRESS;
    LDIFAttrTable[ela_surname].ulPropTag = PR_SURNAME;
    LDIFAttrTable[ela_surname].ulPropIndex = elp_SURNAME;
    LDIFAttrTable[ela_telephonenumber].ulPropTag = PR_BUSINESS_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_telephonenumber].ulPropIndex = elp_BUSINESS_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_homephonenumber].ulPropTag = PR_HOME_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_homephonenumber].ulPropIndex = elp_HOME_TELEPHONE_NUMBER;
    LDIFAttrTable[ela_title].ulPropTag = PR_TITLE;
    LDIFAttrTable[ela_title].ulPropIndex = elp_TITLE;
    LDIFAttrTable[ela_uid].ulPropTag = PR_GIVEN_NAME;                         // ?? Matches in LDIF spec
    LDIFAttrTable[ela_uid].ulPropIndex = elp_GIVEN_NAME;
    LDIFAttrTable[ela_URL].ulPropTag = PR_BUSINESS_HOME_PAGE;
    LDIFAttrTable[ela_URL].ulPropIndex = elp_BUSINESS_HOME_PAGE;
    LDIFAttrTable[ela_userCertificate].ulPropTag = PR_NULL;                 // BUGBUG
    LDIFAttrTable[ela_userCertificate].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_xmozillaconference].ulPropTag =  PR_SERVERS; //PR_NULL;              // BUGBUG?
    LDIFAttrTable[ela_xmozillaconference].ulPropIndex = elp_CONFERENCE_SERVERS;
    LDIFAttrTable[ela_xmozillanickname].ulPropTag = PR_NICKNAME;
    LDIFAttrTable[ela_xmozillanickname].ulPropIndex = elp_NICKNAME;
    LDIFAttrTable[ela_xmozillauseconferenceserver].ulPropTag = PR_NULL;     // BUGBUG
    LDIFAttrTable[ela_xmozillauseconferenceserver].ulPropIndex = NOT_FOUND;
    LDIFAttrTable[ela_xmozillausehtmlmail].ulPropTag = PR_NULL;             // BUGBUG
    LDIFAttrTable[ela_xmozillausehtmlmail].ulPropIndex = NOT_FOUND;
}


/***************************************************************************

    Name      : FindAttributeName

    Purpose   : Find the attribute mapping in the LDIF attribute table

    Parameters: lpName = name of attribute to find
                LDIFAttrTable = table of LDIF attribute mappings

    Returns   : index in LDIFAttrTable (or NOT_FOUND)

    Comment   : Could perhaps benefit from a binary search algorithm.

***************************************************************************/
ULONG FindAttributeName(LPBYTE lpName, LPLDIF_ATTR_TABLE LDIFAttrTable) {
    ULONG i;
    ULONG ulIndex = NOT_FOUND;

    for (i = 0; i < ela_Max; i++) {
        if (lpName && LDIFAttrTable[i].lpName && ! lstrcmpi(lpName, LDIFAttrTable[i].lpName)) {
            ulIndex = i;
            break;
        }
    }

    return(ulIndex);
}


/***************************************************************************

    Name      : MapLDIFtoProps

    Purpose   : Map the LDIF record attributes to WAB properties

    Parameters: lpLDIFRecord -> LDIF record
                cAttributes = number of attributes in LDIF record
                lpspv -> prop value array (pre-allocated)
                lpcProps -> returned number of properties
                lppDisplayName -> returned display name
                lppEmailAddress -> returned email address (or NULL)

    Returns   : HRESULT

***************************************************************************/
HRESULT MapLDIFtoProps(LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord, ULONG cAttributes,
  LPSPropValue * lppspv, LPULONG lpcProps, LPTSTR * lppDisplayName, LPTSTR *lppEmailAddress,
  ULONG * lpulObjType) {
    HRESULT hResult = hrSuccess;
    ULONG cPropVals = cPropVals = cAttributes + NUM_MUST_HAVE_PROPS;
    ULONG iProp = 0;
    ULONG i;
    LDIF_ATTR_TABLE LDIFAttrTable[ela_Max];
    ULONG iTable;
    ULONG cProps = elp_Max;
    SCODE sc;
    LONG iEmailAddr = -1;
    LONG iServers   = -1;
    LPSPropValue lpspv = NULL;
    ULONG ulIndex = 0;

    *lpulObjType = MAPI_MAILUSER;

    // Allocate prop value array
    if (hResult = ResultFromScode(WABAllocateBuffer(cProps * sizeof(SPropValue), &lpspv))) {
        DebugTrace("WABAllocateBuffer -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Fill with PR_NULL
    for (i = 0; i < cProps; i++) {
        lpspv[i].ulPropTag = PR_NULL;
    }

    InitLDIFAttrTable(LDIFAttrTable);

    // Loop through attributes, looking for interesting stuff
    for (i = 0; i < cAttributes; i++) {
        iTable = NOT_FOUND;
        if ((iTable = FindAttributeName(lpLDIFRecord[i].lpName, LDIFAttrTable)) != NOT_FOUND) {
            // Found the attribute name
            // mark the data index in the table
            LDIFAttrTable[iTable].index = i;
        }

        // Some special cases need to be examined now.
        switch (iTable) {
            case ela_cn:
            case ela_dn:
                // if we have both cn and dn, cn takes precedence
                if(LDIFAttrTable[ela_cn].index != NOT_FOUND && LDIFAttrTable[ela_dn].index != NOT_FOUND)
                    LDIFAttrTable[ela_dn].index = NOT_FOUND;
                break;

            case ela_objectclass:
                // objectclass may appear multiple times.  It is up to us to decide which
                // one is meaningful.
                // We recognize several different types:
                // objectclass: person
                // objectclass: organizationalPerson
                // objectclass: groupofnames
                // What objectclass is it?
                if(lpLDIFRecord[i].lpData)
                {
                    if (! lstrcmpi(lpLDIFRecord[i].lpData, sz_person) ||
                       ! lstrcmpi(lpLDIFRecord[i].lpData, sz_organizationalPerson)) {
                        *lpulObjType = MAPI_MAILUSER;
                    } else if (! lstrcmpi(lpLDIFRecord[i].lpData, sz_groupOfNames)) {
                        *lpulObjType = MAPI_DISTLIST;
                    } else {
                        // Ignore this objectclass
                    }
                }
                break;

            case ela_member:    // DL member name or address
                Assert(*lpulObjType == MAPI_DISTLIST);
                // BUGBUG: NYI
                break;
        }
    }

    // look through the attr table for props to use
    for (i = 0; i < ela_Max; i++) 
    {
        if (LDIFAttrTable[i].ulPropTag != PR_NULL &&
            lpspv[ulIndex].ulPropTag == PR_NULL &&
            LDIFAttrTable[i].index != NOT_FOUND) 
        {
            
            if( LDIFAttrTable[i].ulPropTag == PR_SERVERS )
            {
                ULONG cchData;
                ULONG cStrToAdd = 2;
                LPTSTR * lppszServers;
                ULONG index = (iServers >= 0 ? iServers : ulIndex); //LDIFAttrTable[i].ulPropIndex;
                LONG cCurrentStrs = (iServers >= 0 ? lpspv[index].Value.MVSZ.cValues : 0);
                LPTSTR lpEmailAddress = NULL;
                lpspv[index].ulPropTag = PR_SERVERS;

                if( cCurrentStrs >= (LONG)cStrToAdd )
                {
                    // will not handle more than 2 netmtgs addresses
                    lpspv[index].ulPropTag = PR_NULL;
                }
                else 
                {                                       
                    if( cCurrentStrs <= 0 )
                    {
                        sc = WABAllocateMore(sizeof(LPTSTR), lpspv, 
                                            (LPVOID *)&(lpspv[index].Value.MVSZ.LPPSZ));
                        
                        if (sc)
                        {
                            hResult = ResultFromScode(sc);
                            goto exit;
                        }
                        
                        cCurrentStrs = 0;
                    }
                    cchData = 2 + lstrlen(szCallto) + lstrlen( lpLDIFRecord[LDIFAttrTable[i].index].lpData );
                    if ( iEmailAddr >= 0 ){
                        lpEmailAddress = lpspv[iEmailAddr].Value.LPSZ;
                        cchData += lstrlen( lpEmailAddress) + 2;
                    }
                            
                    // allocate enough space for two Server names
                    lppszServers = lpspv[index].Value.MVSZ.LPPSZ;
                    
                    //  Allocate more space for the email address and copy it.
                    sc = WABAllocateMore( sizeof(TCHAR) * cchData, lpspv,
                                        (LPVOID *)&(lppszServers[cCurrentStrs]));
                    if( sc  )
                    {
                        hResult = ResultFromScode(sc);
                        goto exit;
                    }
                    StrCpyN(lppszServers[cCurrentStrs], szCallto, cchData);
                    StrCatBuff(lppszServers[cCurrentStrs], lpLDIFRecord[LDIFAttrTable[i].index].lpData, cchData);

                    // now we need to check if email address has already been set
                    if ( iEmailAddr >= 0 )
                    {
                        StrCatBuff(lppszServers[cCurrentStrs], szFwdSlash, cchData);
                        StrCatBuff(lppszServers[cCurrentStrs], lpEmailAddress, cchData);
                    }
                    else
                        iServers = index;
                    
                    lpspv[index].Value.MVSZ.cValues = ++cCurrentStrs;
                }
            }
            else
            {
                int index = LDIFAttrTable[i].index;
                LPTSTR lp = lpLDIFRecord[index].lpData;
                if(lp && lstrlen(lp))
                {
                    lpspv[ulIndex].ulPropTag = LDIFAttrTable[i].ulPropTag;
                    // BUGBUG: assumes string data            
                        //  Allocate more space for the email address and copy it.
                    sc = WABAllocateMore( sizeof(TCHAR)*(lstrlen(lp)+1), lpspv, (LPVOID *)&(lpspv[ulIndex].Value.LPSZ));
                    if( sc  )
                    {
                        hResult = ResultFromScode(sc);
                        goto exit;
                    }
                    StrCpyN(lpspv[ulIndex].Value.LPSZ, lp, lstrlen(lp)+1);
                }
            }
            // Get the special display strings to return
            switch (LDIFAttrTable[i].ulPropTag) {
                case PR_DISPLAY_NAME:
                    *lppDisplayName = lpspv[ulIndex].Value.LPSZ;
                    break;
                case PR_EMAIL_ADDRESS:
                    {
                        LPTSTR * lppszServerStr, lpszOldServerStr;
                        LONG     cNumStrs;
                        ULONG cchData;
                        *lppEmailAddress = lpspv[ulIndex].Value.LPSZ;
                        // if servers has has already been set, append email address
                        if ( iServers >= 0 )
                        {
                            if( lpspv[iServers].ulPropTag != PR_SERVERS )
                                break;

                            cNumStrs = lpspv[iServers].Value.MVSZ.cValues - 1;
                    
                            if( cNumStrs >= 0 && cNumStrs < 3)
                            {
                                lppszServerStr = lpspv[iServers].Value.MVSZ.LPPSZ;
                                lpszOldServerStr = lppszServerStr[cNumStrs];
                                cchData = lstrlen(*lppszServerStr) + lstrlen(*lppEmailAddress) + 2;
                                sc = WABAllocateMore( sizeof(TCHAR) * cchData, lpspv,
                                    (LPVOID *)&(lppszServerStr[cNumStrs]));
                                
                                if( sc  )
                                {
                                    hResult = ResultFromScode(sc);
                                    goto exit;
                                }
                                StrCpyN(lppszServerStr[cNumStrs],lpszOldServerStr, cchData); 
                                StrCatBuff(lppszServerStr[cNumStrs], szFwdSlash, cchData);
                                StrCatBuff(lppszServerStr[cNumStrs], *lppEmailAddress, cchData);
                            }
                        }
                        else
                            iEmailAddr = ulIndex;
                    }
                    break;
            }
            ulIndex++;
        }
    }
/*
    // Get rid of PR_NULL props
    for (i = 0; i < cProps; i++) {
        if (lpspv[i].ulPropTag == PR_NULL) {
            // Slide the props down.
            if (i + 1 < cProps) {       // Are there any higher props to copy?
                CopyMemory(&(lpspv[i]),
                 &(lpspv[i + 1]),
                 ((cProps - i) - 1) * sizeof(*lppspv[i]));
            }
            // decrement count
            cProps--;
            i--;    // You overwrote the current propval.  Look at it again.
        }
    }
*/
    *lpcProps = ulIndex;
    *lppspv = lpspv;
exit:
    return(hResult);
}


/*********************************************************
    
    HraddLDIFMailUser - adds a mailuser to the WAB

**********************************************************/
HRESULT HrAddLDIFMailUser(HWND hWnd,
                        LPABCONT lpContainer, 
                        LPTSTR lpDisplayName, 
                        LPTSTR lpEmailAddress,
                        ULONG cProps,
                        LPSPropValue lpspv,
                        LPWAB_PROGRESS_CALLBACK lpProgressCB,
                        LPWAB_EXPORT_OPTIONS lpOptions) 
{
    HRESULT hResult = S_OK;
    LPMAPIPROP lpMailUserWAB = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    REPLACE_INFO RI;

    if (lpOptions->ReplaceOption ==  WAB_REPLACE_ALWAYS) 
    {
        ulCreateFlags |= CREATE_REPLACE;
    }


retry:

    // Create a new wab mailuser
    if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(   
                        lpContainer,
                        lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
                        (LPENTRYID) lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
                        ulCreateFlags,
                        &lpMailUserWAB))) 
    {
        DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
        goto exit;
    }

    {
        ULONG i,k;
        for(i=0;i<cProps;i++)
        {
            if(PROP_TYPE(lpspv[i].ulPropTag)==PT_MV_TSTRING)
            {
                DebugTrace("\t0x%.8x = %d\n",lpspv[i].ulPropTag, lpspv[i].Value.MVSZ.cValues);
                for(k=0;k<lpspv[i].Value.MVSZ.cValues;k++)
                    DebugTrace("\t%s\n",lpspv[i].Value.MVSZ.LPPSZ[k]);
            }
            else
                DebugTrace("0x%.8x = %s\n",lpspv[i].ulPropTag,lpspv[i].Value.LPSZ);
        }
    }
    // Set the properties on the new WAB entry
    if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SetProps(    lpMailUserWAB,
                                                                cProps,                   // cValues
                                                                lpspv,                    // property array
                                                                NULL)))                   // problems array
    {
        DebugTrace("LDIFImport:SetProps(WAB) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Save the new wab mailuser or distlist
    if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
                                                              KEEP_OPEN_READONLY | FORCE_SAVE))) 
    {
        if (GetScode(hResult) == MAPI_E_COLLISION) 
        {
            // Find the display name
            Assert(lpDisplayName);

            if (! lpDisplayName) 
            {
                DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                goto exit;
            }

            // Do we need to prompt?
            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) 
            {
                // Prompt user with dialog.  If they say YES, we should try again


                RI.lpszDisplayName = lpDisplayName;
                RI.lpszEmailAddress = lpEmailAddress;
                RI.ConfirmResult = CONFIRM_ERROR;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hInst,
                  MAKEINTRESOURCE(IDD_ImportReplace),
                  hWnd,
                  ReplaceDialogProc,
                  (LPARAM)&RI);

                switch (RI.ConfirmResult) 
                {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        // YES
                        // NOTE: recursive Migrate will fill in the SeenList entry
                        // go try again!
                        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                        lpMailUserWAB = NULL;

                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    case CONFIRM_ABORT:
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        goto exit;

                    default:
                        // NO
                        break;
                }
            }
            hResult = hrSuccess;

        } else 
        {
            DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
        }
    }

exit:
    if(lpMailUserWAB)
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);

    return hResult;
}






/*****************************************************************
    
    HrCreateAdrListFromLDIFRecord
    
    Scans an LDIF record and turns all the "members" into an 
    unresolved AdrList

******************************************************************/
HRESULT HrCreateAdrListFromLDIFRecord(ULONG cAttributes,
                                      LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord, 
                                      LPADRLIST * lppAdrList)
{
    HRESULT hr = S_OK;
    ULONG nMembers = 0, i;
    LPADRLIST lpAdrList = NULL;

    *lppAdrList = NULL;

    // Count the members in this group
    for(i=0;i<cAttributes;i++)
    {
        if(lpLDIFRecord[i].cbData && lpLDIFRecord[i].lpName && !lstrcmpi(lpLDIFRecord[i].lpName, sz_member))
        {
            nMembers++;
        }
    }

    if(!nMembers)
        goto exit;

    // Now create a adrlist from these members

    // Allocate prop value array
    if (hr = ResultFromScode(WABAllocateBuffer(sizeof(ADRLIST) + nMembers * sizeof(ADRENTRY), &lpAdrList))) 
        goto exit;

    lpAdrList->cEntries = nMembers;

    nMembers = 0;
    for(i=0;i<cAttributes;i++)
    {
        if(lpLDIFRecord[i].cbData && lpLDIFRecord[i].lpData 
            && !lstrcmpi(lpLDIFRecord[i].lpName, sz_member))
        {
            // This is a member .. break out its lpData into
            // Name and Email
            LPTSTR lpName = NULL;
            LPTSTR lpEmail = NULL;
            
            lpName = LocalAlloc(LMEM_ZEROINIT, sizeof(TCHAR)*(lpLDIFRecord[i].cbData + 1));
            lpEmail = LocalAlloc(LMEM_ZEROINIT,  sizeof(TCHAR)*(lpLDIFRecord[i].cbData + 1));
            if(lpName && lpEmail)
            {
                LPTSTR lp = NULL;
                StrCpyN(lpName, lpLDIFRecord[i].lpData, lpLDIFRecord[i].cbData + 1);
                StrCpyN(lpEmail, lpName, lpLDIFRecord[i].cbData + 1);

                lp = lpName;

                // BUGBUG - we are looking for two pieces of data Name and Email
                // this code is assuming it will get 'cn=' first and then 'mail='
                // second .. this is all a poor hack assuming too many things

                if(*lp == 'c' && *(lp+1) == 'n' && *(lp+2) == '=')
                    lp += 3;
                StrCpyN(lpName, lp,  lpLDIFRecord[i].cbData + 1);
                
                while (lp && *lp && *lp!=',')
                    lp++;

                if(!*lp) // there is a comma, sometimes there isnt
                {
                    LocalFree(lpEmail);
                    lpEmail = NULL;
                }
                else
                {
                    *lp = '\0';
                    lp++;
                    StrCpyN(lpEmail, lp,  lpLDIFRecord[i].cbData + 1);

                    lp = lpEmail;
                    if(*lp == 'm' && *(lp+1) == 'a' && *(lp+2) == 'i' && *(lp+3) == 'l' && *(lp+4) == '=')
                        lp += 5;
                    StrCpyN(lpEmail, lp,  lpLDIFRecord[i].cbData + 1);
                    while (lp && *lp && *lp!=',')
                        lp++;
                    if(*lp)
                    {
                        // terminate on this 
                        *lp = '\0';
                    }
                }                
                
                if(lpName)// && lpEmail)
                {
                    LPSPropValue lpProp = NULL;
                    ULONG ulcProps = 2;
        
                    if (hr = ResultFromScode(WABAllocateBuffer(2 * sizeof(SPropValue), &lpProp))) 
                        goto exit;

                    lpProp[0].ulPropTag = PR_DISPLAY_NAME;

                    if (hr = ResultFromScode(WABAllocateMore(lstrlen(lpName)+1, lpProp, &(lpProp[0].Value.lpszA)))) 
                        goto exit;

                    StrCpyN(lpProp[0].Value.lpszA, lpName, lstrlen(lpName)+1);

                    if(lpEmail)
                    {
                        lpProp[1].ulPropTag = PR_EMAIL_ADDRESS;

                        if (hr = ResultFromScode(WABAllocateMore(lstrlen(lpEmail)+1, lpProp, &(lpProp[1].Value.lpszA)))) 
                            goto exit;

                        StrCpyN(lpProp[1].Value.lpszA, lpEmail, lstrlen(lpEmail)+1);
                    }
                    lpAdrList->aEntries[nMembers].cValues = (lpEmail ? 2 : 1);
                    lpAdrList->aEntries[nMembers].rgPropVals = lpProp;
                    nMembers++;

                }

                if(lpName)
                    LocalFree(lpName);
                if(lpEmail)
                    LocalFree(lpEmail);
                    
            }


        }
    }

    *lppAdrList = lpAdrList;

exit:

    if(HR_FAILED(hr) && lpAdrList)
        WABFreePadrlist(lpAdrList);

    return hr;
}


/*****************************************************************
    
    HraddLDIFDistList - adds a distlist and its members to the WAB

    Sequence of events will be:

    - Create a DistList object
    - Set the properties on the DistList object
    - Scan the list of members for the given dist list object
    - Add each member to the wab .. if member already exists,
        prompt to replace etc ...if it doesnt exist, create new
        

******************************************************************/
HRESULT HrAddLDIFDistList(HWND hWnd,
                        LPABCONT lpContainer, 
                        ULONG cAttributes,
                        LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord,
                        LPTSTR lpDisplayName, 
                        LPTSTR lpEmailAddress,
                        ULONG cProps,
                        LPSPropValue lpspv,
                        LPWAB_PROGRESS_CALLBACK lpProgressCB,
                        LPWAB_EXPORT_OPTIONS lpOptions) 
{
    HRESULT hResult = S_OK;
    LPMAPIPROP lpDistListWAB = NULL;
    LPDISTLIST lpDLWAB = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    REPLACE_INFO RI;
    LPADRLIST lpAdrList = NULL;
    LPFlagList lpfl = NULL;
    ULONG ulcValues = 0;
    LPSPropValue lpPropEID = NULL;
    ULONG i, cbEIDNew;
    LPENTRYID lpEIDNew;
    ULONG ulObjectTypeOpen;


    if (lpOptions->ReplaceOption ==  WAB_REPLACE_ALWAYS) 
    {
        ulCreateFlags |= CREATE_REPLACE;
    }


retry:
    // Create a new wab distlist
    if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(   
                    lpContainer,
                    lpCreateEIDsWAB[iconPR_DEF_CREATE_DL].Value.bin.cb,
                    (LPENTRYID) lpCreateEIDsWAB[iconPR_DEF_CREATE_DL].Value.bin.lpb,
                    ulCreateFlags,
                    (LPMAPIPROP *) &lpDistListWAB))) 
    {
        DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Set the properties on the new WAB entry
    if (HR_FAILED(hResult = lpDistListWAB->lpVtbl->SetProps(    lpDistListWAB,
                                                                cProps,                   // cValues
                                                                lpspv,                    // property array
                                                                NULL)))                   // problems array
    {
        DebugTrace("LDIFImport:SetProps(WAB) -> %x\n", GetScode(hResult));
        goto exit;
    }


    // Save the new wab mailuser or distlist
    if (HR_FAILED(hResult = lpDistListWAB->lpVtbl->SaveChanges(lpDistListWAB,
                                                              KEEP_OPEN_READWRITE | FORCE_SAVE))) 
    {
        if (GetScode(hResult) == MAPI_E_COLLISION) 
        {
            // Find the display name
            Assert(lpDisplayName);

            if (! lpDisplayName) 
            {
                DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                goto exit;
            }

            // Do we need to prompt?
            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) 
            {
                // Prompt user with dialog.  If they say YES, we should try again


                RI.lpszDisplayName = lpDisplayName;
                RI.lpszEmailAddress = NULL; //lpEmailAddress;
                RI.ConfirmResult = CONFIRM_ERROR;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hInst,
                  MAKEINTRESOURCE(IDD_ImportReplace),
                  hWnd,
                  ReplaceDialogProc,
                  (LPARAM)&RI);

                switch (RI.ConfirmResult) 
                {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        // YES
                        // NOTE: recursive Migrate will fill in the SeenList entry
                        // go try again!
                        lpDistListWAB->lpVtbl->Release(lpDistListWAB);
                        lpDistListWAB = NULL;

                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    case CONFIRM_ABORT:
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        goto exit;

                    default:
                        // NO
                        break;
                }
            }
            hResult = hrSuccess;

        } else 
        {
            DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
        }
    }


    // Now we've created the Distribution List object .. we need to add members to it ..
    //
    // What is the ENTRYID of our new entry?
    if ((hResult = lpDistListWAB->lpVtbl->GetProps(lpDistListWAB,
                                                  (LPSPropTagArray)&ptaEid,
                                                  0,
                                                  &ulcValues,
                                                  &lpPropEID))) 
    {
        goto exit;
    }

    cbEIDNew = lpPropEID->Value.bin.cb;
    lpEIDNew = (LPENTRYID) lpPropEID->Value.bin.lpb;

    if(!cbEIDNew || !lpEIDNew)
        goto exit;

     // Open the new WAB DL as a DISTLIST object
    if (HR_FAILED(hResult = lpContainer->lpVtbl->OpenEntry(lpContainer,
                                                          cbEIDNew,
                                                          lpEIDNew,
                                                          (LPIID)&IID_IDistList,
                                                          MAPI_MODIFY,
                                                          &ulObjectTypeOpen,
                                                          (LPUNKNOWN*)&lpDLWAB))) 
    {
        goto exit;
    }



    // First we create a lpAdrList with all the members of this dist list and try to resolve
    // the members against the container .. entries that already exist in the WAB will come
    // back as resolved .. entries that dont exist in the container will come back as unresolved
    // We can then add the unresolved entries as fresh entries to the wab (since they are 
    // unresolved, there will be no collision) .. and then we can do another resolvenames to
    // resolve everything and get a lpAdrList full of EntryIDs .. we can then take this list of
    // entryids and call CreateEntry or CopyEntry on the DistList object to copy the entryid into
    // the distlist ...

    hResult = HrCreateAdrListFromLDIFRecord(cAttributes, lpLDIFRecord, &lpAdrList);

    if(HR_FAILED(hResult))
        goto exit;

    if(!lpAdrList || !(lpAdrList->cEntries))
        goto exit;

    // Create a corresponding flaglist
    lpfl = LocalAlloc(LMEM_ZEROINIT, sizeof(FlagList) + (lpAdrList->cEntries)*sizeof(ULONG));
    if(!lpfl)
    {
        hResult = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpfl->cFlags = lpAdrList->cEntries;

    // set all the flags to unresolved
    for(i=0;i<lpAdrList->cEntries;i++)
        lpfl->ulFlag[i] = MAPI_UNRESOLVED;

    hResult = lpContainer->lpVtbl->ResolveNames(lpContainer, NULL, 0, lpAdrList, lpfl);

    if(HR_FAILED(hResult))
        goto exit;

    // All the entries in the list that are resolved, already exist in the address book.

    // The ones that are not resolved need to be added silently to the address book ..
    for(i=0;i<lpAdrList->cEntries;i++)
    {
        if(lpfl->ulFlag[i] == MAPI_UNRESOLVED)
        {
            LPMAPIPROP lpMailUser = NULL;

            if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(   
                                lpContainer,
                                lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
                                (LPENTRYID) lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
                                0,
                                &lpMailUser))) 
            {
                continue;
                //goto exit;
            }

            if(lpMailUser)
            {
                // Set the properties on the new WAB entry
                if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
                                                                    lpAdrList->aEntries[i].cValues,
                                                                    lpAdrList->aEntries[i].rgPropVals,
                                                                    NULL)))                   
                {
                    goto exit;
                }

                // Save the new wab mailuser or distlist
                if (HR_FAILED(hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser,
                                                                        KEEP_OPEN_READONLY | FORCE_SAVE))) 
                {
                    goto exit;
                }

                lpMailUser->lpVtbl->Release(lpMailUser);
            }
        }
    }


    // now that we've added all the unresolved members to the WAB, we call ResolveNames
    // again .. as a result, every member in this list will be resolved and we will
    // have entryids for all of them 
    // We will then take these entryids and add them to the DistList object

    hResult = lpContainer->lpVtbl->ResolveNames(lpContainer, NULL, 0, lpAdrList, lpfl);

    if(HR_FAILED(hResult))
        goto exit;

    for(i=0;i<lpAdrList->cEntries;i++)
    {
        if(lpfl->ulFlag[i] == MAPI_RESOLVED)
        {
            ULONG j = 0;
            LPSPropValue lpProp = lpAdrList->aEntries[i].rgPropVals;
            
            for(j=0; j<lpAdrList->aEntries[i].cValues; j++)
            {
                if(lpProp[j].ulPropTag == PR_ENTRYID)
                {
                    LPMAPIPROP lpMapiProp = NULL;

                    //ignore errors
                    lpDLWAB->lpVtbl->CreateEntry(lpDLWAB,
                                                lpProp[j].Value.bin.cb,
                                                (LPENTRYID) lpProp[j].Value.bin.lpb,
                                                0, 
                                                &lpMapiProp);

                    if(lpMapiProp)
                    {
                        lpMapiProp->lpVtbl->SaveChanges(lpMapiProp, KEEP_OPEN_READWRITE | FORCE_SAVE);
                        lpMapiProp->lpVtbl->Release(lpMapiProp);
                    }

                    break;

                }
            }
        }
    }

exit:

    if (lpPropEID)
        WABFreeBuffer(lpPropEID);

    if (lpDLWAB)
        lpDLWAB->lpVtbl->Release(lpDLWAB);

    if(lpDistListWAB)
        lpDistListWAB->lpVtbl->Release(lpDistListWAB);

    if(lpAdrList)
        WABFreePadrlist(lpAdrList);

    if(lpfl)
        LocalFree(lpfl);

    return hResult;
}

HRESULT LDIFImport(HWND hWnd,
    LPADRBOOK lpAdrBook,
    LPWABOBJECT lpWABObject,
    LPWAB_PROGRESS_CALLBACK lpProgressCB,
    LPWAB_EXPORT_OPTIONS lpOptions) {
    HRESULT hResult = hrSuccess;
    TCHAR szFileName[MAX_PATH + 1] = "";
    register ULONG i;
    ULONG ulObjType;
    ULONG index;
    ULONG ulLastChosenProp = 0;
    ULONG ulcFields = 0;
    ULONG cAttributes = 0;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    WAB_PROGRESS Progress;
    LPABCONT lpContainer = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPLDIF_RECORD_ATTRIBUTE lpLDIFRecord = NULL;
    LPSPropValue lpspv = NULL;
    ULONG cProps;
    BOOL fSkipSetProps;
    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    BOOL fDoDistLists = FALSE;

    SetGlobalBufferFunctions(lpWABObject);

    // Get LDIF file name
    OpenFileDialog(hWnd,
      szFileName,
      szLDIFFilter,
      IDS_LDIF_FILE_SPEC,
      szAllFilter,
      IDS_ALL_FILE_SPEC,
      NULL,
      0,
      szLDIFExt,
      OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST,
      hInst,
      0,        //idsTitle
      0);       // idsSaveButton

    // Open the file
    if ((hFile = CreateFile(szFileName,
      GENERIC_READ,
      FILE_SHARE_READ | FILE_SHARE_WRITE,
      NULL,
      OPEN_EXISTING,
      FILE_FLAG_SEQUENTIAL_SCAN,
      NULL)) == INVALID_HANDLE_VALUE) {
        DebugTrace("Couldn't open file %s -> %u\n", szFileName, GetLastError());
        return(ResultFromScode(MAPI_E_NOT_FOUND));
    }

    Assert(hFile != INVALID_HANDLE_VALUE);

    // Read in the LDIF version if there is one
    // BUGBUG: NYI



    //
    // Open the WAB's PAB container: fills global lpCreateEIDsWAB
    //
    if (hResult = LoadWABEIDs(lpAdrBook, &lpContainer)) {
        goto exit;
    }

    if( HR_FAILED(hResult = HrLoadPrivateWABProps(lpAdrBook) ))
    {
        goto exit;
    }

    //
    // All set... now loop through the records, adding each to the WAB
    //

    // How many records are there?
    if (hResult = CountLDIFRecords(hFile, &ulcEntries)) {
        goto exit;
    }

    // Initialize the Progress Bar
    Progress.denominator = max(ulcEntries, 1);
    Progress.numerator = 0;
    if (LoadString(hInst, IDS_STATE_IMPORT_MU, szBuffer, sizeof(szBuffer))) {
        DebugTrace("Status Message: %s\n", szBuffer);
        Progress.lpText = szBuffer;
    } else {
        DebugTrace("Cannot load resource string %u\n", IDS_STATE_IMPORT_MU);
        Progress.lpText = NULL;
    }
    lpProgressCB(hWnd, &Progress);

    
    // We will make 2 passes over the file - in the first pass we will import all the
    // contacts. In the second pass we will import all the distribution lists .. the
    // advantage of doing 2 passes is that when importing contacts, we will prompt on
    // conflict and then when importing distlists, we will assume all contacts in the 
    // WAB are correct and just point to the relevant ones

    fDoDistLists = FALSE;

DoDistLists:

    SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

    while (HR_SUCCEEDED(hResult)) 
    {
        lpDisplayName = NULL;
        lpEmailAddress = NULL;
        lpspv = NULL;
        cAttributes = cProps = 0;
        lpLDIFRecord = NULL;

        // Read the LDIF attributes
        if (hResult = ReadLDIFRecord(hFile, &cAttributes, &lpLDIFRecord)) {
            DebugTrace("ReadLDIFRecord -> %x\n", GetScode(hResult));
            if (GetScode(hResult) == MAPI_E_NOT_FOUND) {
                // EOF
                hResult = hrSuccess;
            }
            break;      // nothing more to read
        }

        // Map the LDIF attributes to WAB properties
        if (hResult = MapLDIFtoProps(lpLDIFRecord, cAttributes, &lpspv, &cProps,
          &lpDisplayName, &lpEmailAddress, &ulObjType)) {
            goto exit;
        }

        DebugTrace("..Importing..%s..%s..\n",lpDisplayName?lpDisplayName:"",lpEmailAddress?lpEmailAddress:"");

        if(ulObjType == MAPI_MAILUSER && !fDoDistLists)
        {
            hResult = HrAddLDIFMailUser(hWnd, lpContainer, 
                        lpDisplayName, lpEmailAddress,
                        cProps, lpspv,
                        lpProgressCB, lpOptions);
            // Update progress bar
            Progress.numerator++;
        }
        else if(ulObjType == MAPI_DISTLIST && fDoDistLists)
        {
            hResult = HrAddLDIFDistList(hWnd, lpContainer, 
                        cAttributes, lpLDIFRecord,
                        lpDisplayName, lpEmailAddress,
                        cProps, lpspv,
                        lpProgressCB, lpOptions);
            // Update progress bar
            Progress.numerator++;
        }

        if(HR_FAILED(hResult))
            goto exit;

        // Clean up
        if (lpLDIFRecord) 
        {
            FreeLDIFRecord(lpLDIFRecord, cAttributes);
            lpLDIFRecord = NULL;
        }

        Assert(Progress.numerator <= Progress.denominator);

        if (lpspv) 
        {
            WABFreeBuffer(lpspv);
            lpspv = NULL;
        }

        lpProgressCB(hWnd, &Progress);
    }

    if(!fDoDistLists)
    {
        // Make a second pass doing only distlists this time
        fDoDistLists = TRUE;
        goto DoDistLists;
    }

    if (! HR_FAILED(hResult)) {
        hResult = hrSuccess;
    }

exit:
    if (hFile) {
        CloseHandle(hFile);
    }

    if (lpspv) {
        WABFreeBuffer(lpspv);
        lpspv = NULL;
    }

    if (lpLDIFRecord) {
        FreeLDIFRecord(lpLDIFRecord, cAttributes);
        lpLDIFRecord = NULL;
    }

    if (lpContainer) {
        lpContainer->lpVtbl->Release(lpContainer);
        lpContainer = NULL;
    }

    if (lpCreateEIDsWAB) {
        WABFreeBuffer(lpCreateEIDsWAB);
        lpCreateEIDsWAB = NULL;
    }


    return(hResult);
}



const int base642six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

//-------------------------------------------------------------------------------------------
// Function:  decode()
//-------------------------------------------------------------------------------------------
BOOL decodeBase64(  char   * bufcoded,       // in
                    char   * pbuffdecoded,   // out
                    DWORD  * pcbDecoded)     // in out
{
    int            nbytesdecoded;
    char          *bufin;
    unsigned char *bufout;
    int            nprbytes;
    const int     *rgiDict = base642six;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(rgiDict[*(bufin++)] <= 63);
    nprbytes = (int) (bufin - bufcoded - 1);
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    bufout = (unsigned char *)pbuffdecoded;

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (rgiDict[*bufin] << 2 | rgiDict[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (rgiDict[bufin[1]] << 4 | rgiDict[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (rgiDict[bufin[2]] << 6 | rgiDict[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(rgiDict[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)pbuffdecoded)[nbytesdecoded] = '\0';

    return TRUE;
}



/*
 - HrLoadPrivateWABProps
 -
*    Private function to load Conferencing Named properties
*    as globals up front
*
*
*/
HRESULT HrLoadPrivateWABProps(LPADRBOOK lpIAB)
{
    HRESULT hr = E_FAIL;
    LPSPropTagArray lpta = NULL;
    SCODE sc = 0;
    ULONG i, uMax = prWABConfMax, nStartIndex = OLK_NAMEDPROPS_START;
    LPMAPINAMEID  *lppConfPropNames = NULL;

    sc = WABAllocateBuffer(sizeof(LPMAPINAMEID) * uMax, (LPVOID *) &lppConfPropNames);
    //sc = WABAllocateBuffer(sizeof(LPMAPINAMEID) * uMax, (LPVOID *) &lppConfPropNames);
    if( (HR_FAILED(hr = ResultFromScode(sc))) )
        goto err;    

    for(i=0;i< uMax;i++)
    {
        //sc = WABAllocateMore(sizeof(MAPINAMEID), lppConfPropNames, &(lppConfPropNames[i]));
        sc = WABAllocateMore(  sizeof(MAPINAMEID), lppConfPropNames, &(lppConfPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppConfPropNames[i]->lpguid = (LPGUID) &PS_Conferencing;
        lppConfPropNames[i]->ulKind = MNID_ID;
        lppConfPropNames[i]->Kind.lID = nStartIndex + i;
    }
    // Load the set of conferencing named props
    //
    if( HR_FAILED(hr = (lpIAB)->lpVtbl->GetIDsFromNames(lpIAB, uMax, lppConfPropNames,
        MAPI_CREATE, &lpta) ))
        goto err;
    
    if(lpta)
        // Set the property types on the returned props
        PR_SERVERS                  = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABConfServers],        PT_MV_TSTRING);
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].ulPropTag = PR_SERVERS;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].fChosen   = FALSE;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].ids       = ids_ExportConfServer;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].lpszName  = NULL;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].lpszCSVName = NULL;

err:
    if(lpta)
        WABFreeBuffer( lpta );
    if( lppConfPropNames )
        WABFreeBuffer( lppConfPropNames );
        //WABFreeBuffer(lpta);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\messengr.c ===
/*
 *  Messengr.C
 *
 *  Migrate Communicator Messenger NAB <-> WAB
 *
 *  Copyright 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  To Do:
 *      ObjectClass recognition
 *      Attribute mapping
 *      Groups
 *      Base64
 *      URLs
 *      Reject Change List MESS
 *
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include "wabimp.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"
#include <shlwapi.h>

#define CR_CHAR 0x0d
#define LF_CHAR 0x0a
#define CCH_READ_BUFFER 1024
#define NUM_ITEM_SLOTS  32

/* Messenger address header
8-Display Name.
8-Nickname.
2-?
8-First Name.
8-?
8-last Name
8-Organization
8- City
8-State
8-e-mail
8- Notes
1- FF
8-Title
8-Address1
8-Zip
8-Work Phone
8-Fax
8- House phone.
18-?
8-Address
8-Country.
*/

typedef enum _MESS_ATTRIBUTES {
    // PR_DISPLAY_NAME
    m_DisplayName,
    // PR_NICKNAME
    m_Nickname,                       // Netscape nickname
    //PR_GIVEN_NAME
    m_FirstName,
    //PR_SURNAME
    m_LastName,
    //PR_COMPANY_NAME
    m_Organization,
    // PR_LOCALITY
    m_City,                               // locality (city)
    // PR_STATE_OR_PROVINCE
    m_State,                                     // business address state
    // PR_EMAIL_ADDRESS
    m_Email,                                   // email address
    // PR_COMMENT
    m_Notes,
    //PR_TITLE,
    m_Title,
    // PR_STREET_ADDRESS
    m_StreetAddress2, 
    // PR_POSTAL_CODE
    m_Zip,                             // business address zip code
    // PR_BUSINESS_TELEPHONE_NUMBER
    m_WorkPhone,
    // PR_BUSINESS_FAX_NUMBER
    m_Fax,
    // PR_HOME_TELEPHONE_NUMBER
    m_HomePhone,
    // PR_STREET_ADDRESS
    m_StreetAddress1, 
    // PR_COUNTRY
    m_Country,                                      // country
    m_Max,
} MESS_ATTRIBUTES, *LPMESS_ATTRIBUTES;

ULONG ulDefPropTags[] =
{
    PR_DISPLAY_NAME,
    PR_NICKNAME,
    PR_GIVEN_NAME,
    PR_SURNAME,
    PR_COMPANY_NAME,
    PR_LOCALITY,
    PR_STATE_OR_PROVINCE,
    PR_EMAIL_ADDRESS,
    PR_COMMENT,
    PR_TITLE,
    PR_STREET_ADDRESS,
    PR_POSTAL_CODE,
    PR_BUSINESS_TELEPHONE_NUMBER,
    PR_BUSINESS_FAX_NUMBER,
    PR_HOME_TELEPHONE_NUMBER,
    PR_STREET_ADDRESS,
    PR_COUNTRY,
};

// All props are string props
typedef struct _MESS_RECORD {
    LPTSTR lpData[m_Max];
    ULONG  ulObjectType;
} MESS_RECORD, *LPMESS_RECORD;

typedef struct _MESS_HEADER_ATTRIBUTES {
    ULONG ulOffSet;
    ULONG ulSize;
} MH_ATTR, * LPMH_ATTR;

typedef struct _MESS_BASIC_PROPS {
    LPTSTR lpName;
    LPTSTR lpEmail;
    LPTSTR lpComment;
} MP_BASIC, * LPMP_BASIC;

typedef struct _MESS_STUFF {
    ULONG ulOffSet;
    ULONG ulNum;
    MP_BASIC bp;
} MH_STUFF, * LPMH_STUFF;

typedef struct _MESS_ADDRESS_HEADER {
    MH_ATTR prop[m_Max];
} MESS_HEADER, * LPMESS_HEADER;

// Must have
//  PR_DISPLAY_NAME
#define NUM_MUST_HAVE_PROPS 1

const TCHAR szMESSFilter[] = "*.nab";
const TCHAR szMESSExt[] =    "nab";



/*****************************************************************
    
    HrCreateAdrListFromMESSRecord
    
    Scans an MESS record and turns all the "members" into an 
    unresolved AdrList

******************************************************************/
HRESULT HrCreateAdrListFromMESSRecord(ULONG nMembers,
                                      LPMP_BASIC lpmp, 
                                      LPADRLIST * lppAdrList)
{
    HRESULT hr = S_OK;
    ULONG i;
    LPADRLIST lpAdrList = NULL;
    ULONG ulCount = 0;

    *lppAdrList = NULL;

    if(!nMembers)
        goto exit;

    // Now create a adrlist from these members

    // Allocate prop value array
    if (hr = ResultFromScode(WABAllocateBuffer(sizeof(ADRLIST) + nMembers * sizeof(ADRENTRY), &lpAdrList))) 
        goto exit;

    ulCount = nMembers;

    nMembers = 0;
    
    for(i=0;i<ulCount;i++)
    {
        LPTSTR lpName = lpmp[i].lpName;
        LPTSTR lpEmail = lpmp[i].lpEmail;

        if(lpName)
        {
            LPSPropValue lpProp = NULL;
            ULONG ulcProps = 2;

            if (hr = ResultFromScode(WABAllocateBuffer(2 * sizeof(SPropValue), &lpProp))) 
                goto exit;

            lpProp[0].ulPropTag = PR_DISPLAY_NAME;

            if (hr = ResultFromScode(WABAllocateMore(lstrlen(lpName)+1, lpProp, &(lpProp[0].Value.lpszA)))) 
                goto exit;

            StrCpyN(lpProp[0].Value.lpszA, lpName, lstrlen(lpName)+1);

            if(lpEmail)
            {
                lpProp[1].ulPropTag = PR_EMAIL_ADDRESS;

                if (hr = ResultFromScode(WABAllocateMore(lstrlen(lpEmail)+1, lpProp, &(lpProp[1].Value.lpszA)))) 
                    goto exit;

                StrCpyN(lpProp[1].Value.lpszA, lpEmail, lstrlen(lpEmail)+1);
            }
            lpAdrList->aEntries[nMembers].cValues = (lpEmail ? 2 : 1);
            lpAdrList->aEntries[nMembers].rgPropVals = lpProp;
            nMembers++;

        }

    }

    lpAdrList->cEntries = nMembers;

    *lppAdrList = lpAdrList;

exit:

    if(HR_FAILED(hr) && lpAdrList)
        WABFreePadrlist(lpAdrList);
    return hr;
}



/*****************************************************************
    
    HraddMESSDistList - adds a distlist and its members to the WAB

    Sequence of events will be:

    - Create a DistList object
    - Set the properties on the DistList object
    - Scan the list of members for the given dist list object
    - Add each member to the wab .. if member already exists,
        prompt to replace etc ...if it doesnt exist, create new
        

******************************************************************/
HRESULT HrAddMESSDistList(HWND hWnd,
                        LPABCONT lpContainer, 
                        MH_STUFF HeadDL,
                        ULONG ulcNumDLMembers, 
                        LPMP_BASIC lpmp,
                        LPWAB_PROGRESS_CALLBACK lpProgressCB,
                        LPWAB_EXPORT_OPTIONS lpOptions) 
{
    HRESULT hResult = S_OK;
    LPMAPIPROP lpDistListWAB = NULL;
    LPDISTLIST lpDLWAB = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    REPLACE_INFO RI;
    LPADRLIST lpAdrList = NULL;
    LPFlagList lpfl = NULL;
    ULONG ulcValues = 0;
    LPSPropValue lpPropEID = NULL;
    ULONG i, cbEIDNew;
    LPENTRYID lpEIDNew;
    ULONG ulObjectTypeOpen;
    SPropValue Prop[3];
    ULONG cProps = 0;
    LPTSTR lpDisplayName = HeadDL.bp.lpName;

    Prop[cProps].ulPropTag = PR_DISPLAY_NAME;
    Prop[cProps].Value.LPSZ = HeadDL.bp.lpName;

    if(!HeadDL.bp.lpName)
        return MAPI_E_INVALID_PARAMETER;

    cProps++;

    Prop[cProps].ulPropTag = PR_OBJECT_TYPE;
    Prop[cProps].Value.l = MAPI_DISTLIST;

    cProps++;

    if(HeadDL.bp.lpComment)
    {
        Prop[cProps].ulPropTag = PR_COMMENT;
        Prop[cProps].Value.LPSZ = HeadDL.bp.lpComment;
        cProps++;
    }

    //if (lpOptions->ReplaceOption ==  WAB_REPLACE_ALWAYS) 
    // Force a replace - collision will only be for groups and we dont care really
    {
        ulCreateFlags |= CREATE_REPLACE;
    }

retry:
    // Create a new wab distlist
    if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(   
                    lpContainer,
                    lpCreateEIDsWAB[iconPR_DEF_CREATE_DL].Value.bin.cb,
                    (LPENTRYID) lpCreateEIDsWAB[iconPR_DEF_CREATE_DL].Value.bin.lpb,
                    ulCreateFlags,
                    (LPMAPIPROP *) &lpDistListWAB))) 
    {
        DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Set the properties on the new WAB entry
    if (HR_FAILED(hResult = lpDistListWAB->lpVtbl->SetProps(    lpDistListWAB,
                                                                cProps,                   // cValues
                                                                (LPSPropValue) &Prop,                    // property array
                                                                NULL)))                   // problems array
    {
        goto exit;
    }


    // Save the new wab mailuser or distlist
    if (HR_FAILED(hResult = lpDistListWAB->lpVtbl->SaveChanges(lpDistListWAB,
                                                              KEEP_OPEN_READWRITE | FORCE_SAVE))) 
    {
        if (GetScode(hResult) == MAPI_E_COLLISION) 
        {
            // Find the display name
            Assert(lpDisplayName);

            if (! lpDisplayName) 
            {
                DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                goto exit;
            }

            // Do we need to prompt?
            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) 
            {
                // Prompt user with dialog.  If they say YES, we should try again


                RI.lpszDisplayName = lpDisplayName;
                RI.lpszEmailAddress = NULL; //lpEmailAddress;
                RI.ConfirmResult = CONFIRM_ERROR;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hInst,
                  MAKEINTRESOURCE(IDD_ImportReplace),
                  hWnd,
                  ReplaceDialogProc,
                  (LPARAM)&RI);

                switch (RI.ConfirmResult) 
                {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        // YES
                        // NOTE: recursive Migrate will fill in the SeenList entry
                        // go try again!
                        lpDistListWAB->lpVtbl->Release(lpDistListWAB);
                        lpDistListWAB = NULL;

                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    case CONFIRM_ABORT:
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        goto exit;

                    default:
                        // NO
                        break;
                }
            }
            hResult = hrSuccess;

        } else 
        {
            DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
        }
    }


    // Now we've created the Distribution List object .. we need to add members to it ..
    //
    // What is the ENTRYID of our new entry?
    if ((hResult = lpDistListWAB->lpVtbl->GetProps(lpDistListWAB,
                                                  (LPSPropTagArray)&ptaEid,
                                                  0,
                                                  &ulcValues,
                                                  &lpPropEID))) 
    {
        goto exit;
    }

    cbEIDNew = lpPropEID->Value.bin.cb;
    lpEIDNew = (LPENTRYID) lpPropEID->Value.bin.lpb;

    if(!cbEIDNew || !lpEIDNew)
        goto exit;

     // Open the new WAB DL as a DISTLIST object
    if (HR_FAILED(hResult = lpContainer->lpVtbl->OpenEntry(lpContainer,
                                                          cbEIDNew,
                                                          lpEIDNew,
                                                          (LPIID)&IID_IDistList,
                                                          MAPI_MODIFY,
                                                          &ulObjectTypeOpen,
                                                          (LPUNKNOWN*)&lpDLWAB))) 
    {
        goto exit;
    }


    if(!ulcNumDLMembers)
    {
        hResult = S_OK;
        goto exit;
    }

    // First we create a lpAdrList with all the members of this dist list and try to resolve
    // the members against the container .. entries that already exist in the WAB will come
    // back as resolved .. entries that dont exist in the container will come back as unresolved
    // We can then add the unresolved entries as fresh entries to the wab (since they are 
    // unresolved, there will be no collision) .. and then we can do another resolvenames to
    // resolve everything and get a lpAdrList full of EntryIDs .. we can then take this list of
    // entryids and call CreateEntry or CopyEntry on the DistList object to copy the entryid into
    // the distlist ...

    hResult = HrCreateAdrListFromMESSRecord(ulcNumDLMembers, lpmp, &lpAdrList);

    if(HR_FAILED(hResult))
        goto exit;

    if(!lpAdrList || !(lpAdrList->cEntries))
        goto exit;

    // Create a corresponding flaglist
    lpfl = LocalAlloc(LMEM_ZEROINIT, sizeof(FlagList) + (lpAdrList->cEntries)*sizeof(ULONG));
    if(!lpfl)
    {
        hResult = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpfl->cFlags = lpAdrList->cEntries;

    // set all the flags to unresolved
    for(i=0;i<lpAdrList->cEntries;i++)
        lpfl->ulFlag[i] = MAPI_UNRESOLVED;

    hResult = lpContainer->lpVtbl->ResolveNames(lpContainer, NULL, 0, lpAdrList, lpfl);

    if(HR_FAILED(hResult))
        goto exit;

    // All the entries in the list that are resolved, already exist in the address book.

    // The ones that are not resolved need to be added silently to the address book ..
    for(i=0;i<lpAdrList->cEntries;i++)
    {
        if(lpfl->ulFlag[i] == MAPI_UNRESOLVED)
        {
            LPMAPIPROP lpMailUser = NULL;

            if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(   
                                lpContainer,
                                lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
                                (LPENTRYID) lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
                                0,
                                &lpMailUser))) 
            {
                continue;
                //goto exit;
            }

            if(lpMailUser)
            {
                // Set the properties on the new WAB entry
                if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,
                                                                    lpAdrList->aEntries[i].cValues,
                                                                    lpAdrList->aEntries[i].rgPropVals,
                                                                    NULL)))                   
                {
                    goto exit;
                }

                // Save the new wab mailuser or distlist
                if (HR_FAILED(hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser,
                                                                        KEEP_OPEN_READONLY | FORCE_SAVE))) 
                {
                    goto exit;
                }

                lpMailUser->lpVtbl->Release(lpMailUser);
            }
        }
    }


    // now that we've added all the unresolved members to the WAB, we call ResolveNames
    // again .. as a result, every member in this list will be resolved and we will
    // have entryids for all of them 
    // We will then take these entryids and add them to the DistList object

    hResult = lpContainer->lpVtbl->ResolveNames(lpContainer, NULL, 0, lpAdrList, lpfl);

    if(hResult==MAPI_E_AMBIGUOUS_RECIP)
        hResult = S_OK;

    if(HR_FAILED(hResult))
        goto exit;

    for(i=0;i<lpAdrList->cEntries;i++)
    {
        if(lpfl->ulFlag[i] == MAPI_RESOLVED)
        {
            ULONG j = 0;
            LPSPropValue lpProp = lpAdrList->aEntries[i].rgPropVals;
            
            for(j=0; j<lpAdrList->aEntries[i].cValues; j++)
            {
                if(lpProp[j].ulPropTag == PR_ENTRYID)
                {
                    LPMAPIPROP lpMapiProp = NULL;

                    //ignore errors
                    lpDLWAB->lpVtbl->CreateEntry(lpDLWAB,
                                                lpProp[j].Value.bin.cb,
                                                (LPENTRYID) lpProp[j].Value.bin.lpb,
                                                0, 
                                                &lpMapiProp);

                    if(lpMapiProp)
                    {
                        lpMapiProp->lpVtbl->SaveChanges(lpMapiProp, KEEP_OPEN_READWRITE | FORCE_SAVE);
                        lpMapiProp->lpVtbl->Release(lpMapiProp);
                    }

                    break;
                }
            }
        }
    }

exit:

    if (lpPropEID)
        WABFreeBuffer(lpPropEID);

    if (lpDLWAB)
        lpDLWAB->lpVtbl->Release(lpDLWAB);

    if(lpDistListWAB)
        lpDistListWAB->lpVtbl->Release(lpDistListWAB);

    if(lpAdrList)
        WABFreePadrlist(lpAdrList);

    if(lpfl)
        LocalFree(lpfl);

    return hResult;
}



/*********************************************************
    
    HraddMESSMailUser - adds a mailuser to the WAB

**********************************************************/
HRESULT HrAddMESSMailUser(HWND hWnd,
                        LPABCONT lpContainer, 
                        LPTSTR lpDisplayName, 
                        LPTSTR lpEmailAddress,
                        ULONG cProps,
                        LPSPropValue lpspv,
                        LPWAB_PROGRESS_CALLBACK lpProgressCB,
                        LPWAB_EXPORT_OPTIONS lpOptions) 
{
    HRESULT hResult = S_OK;
    LPMAPIPROP lpMailUserWAB = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    REPLACE_INFO RI;


    if (lpOptions->ReplaceOption ==  WAB_REPLACE_ALWAYS) 
    {
        ulCreateFlags |= CREATE_REPLACE;
    }


retry:
    // Create a new wab mailuser
    if (HR_FAILED(hResult = lpContainer->lpVtbl->CreateEntry(   
                        lpContainer,
                        lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
                        (LPENTRYID) lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
                        ulCreateFlags,
                        &lpMailUserWAB))) 
    {
        DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Set the properties on the new WAB entry
    if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SetProps(    lpMailUserWAB,
                                                                cProps,                   // cValues
                                                                lpspv,                    // property array
                                                                NULL)))                   // problems array
    {
        goto exit;
    }


    // Save the new wab mailuser or distlist
    if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
                                                              KEEP_OPEN_READONLY | FORCE_SAVE))) 
    {
        if (GetScode(hResult) == MAPI_E_COLLISION) 
        {
            // Find the display name
            Assert(lpDisplayName);

            if (! lpDisplayName) 
            {
                DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                goto exit;
            }

            // Do we need to prompt?
            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) 
            {
                // Prompt user with dialog.  If they say YES, we should try again


                RI.lpszDisplayName = lpDisplayName;
                RI.lpszEmailAddress = lpEmailAddress;
                RI.ConfirmResult = CONFIRM_ERROR;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hInst,
                  MAKEINTRESOURCE(IDD_ImportReplace),
                  hWnd,
                  ReplaceDialogProc,
                  (LPARAM)&RI);

                switch (RI.ConfirmResult) 
                {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        // YES
                        // NOTE: recursive Migrate will fill in the SeenList entry
                        // go try again!
                        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                        lpMailUserWAB = NULL;

                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    case CONFIRM_ABORT:
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        goto exit;

                    default:
                        // NO
                        break;
                }
            }
            hResult = hrSuccess;

        } else 
        {
            DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
        }
    }

exit:
    if(lpMailUserWAB)
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);


    return hResult;
}







/***************************************************************************

    Name      : MapMESSRecordtoProps

    Purpose   : Map the MESS record attributes to WAB properties

    Parameters: lpMESSRecord -> MESS record
                lpspv -> prop value array (pre-allocated)
                lpcProps -> returned number of properties
                lppDisplayName -> returned display name
                lppEmailAddress -> returned email address (or NULL)

    Returns   : HRESULT

***************************************************************************/
HRESULT MapMESSRecordtoProps( LPMESS_RECORD lpMESSRecord, 
                        LPSPropValue * lppspv, LPULONG lpcProps, 
                        LPTSTR * lppDisplayName, LPTSTR *lppEmailAddress) 
{
    HRESULT hResult = hrSuccess;
    ULONG cPropVals = m_Max + 1; // PR_OBJECT_TYPE
    ULONG iProp = 0;
    ULONG i;
    ULONG iTable;
    ULONG cProps = cPropVals;
    
    // Allocate prop value array
    if (hResult = ResultFromScode(WABAllocateBuffer(cProps * sizeof(SPropValue), lppspv))) {
        DebugTrace("WABAllocateBuffer -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Fill with PR_NULL
    for (i = 0; i < cProps; i++) {
        (*lppspv)[i].ulPropTag = PR_NULL;
    }

    iProp = 0;

    for(i=0; i<m_Max; i++)
    {
        if(lpMESSRecord->lpData[i] && lstrlen(lpMESSRecord->lpData[i]))
        {
            (*lppspv)[iProp].ulPropTag = ulDefPropTags[i];
            (*lppspv)[iProp].Value.LPSZ = lpMESSRecord->lpData[i];
            switch((*lppspv)[iProp].ulPropTag)
            {
            case PR_DISPLAY_NAME:
                *lppDisplayName = (*lppspv)[iProp].Value.LPSZ;
                break;
            case PR_EMAIL_ADDRESS:
                *lppEmailAddress = (*lppspv)[iProp].Value.LPSZ;
                break;
            }
            iProp++;
        }
    }
    (*lppspv)[iProp].ulPropTag = PR_OBJECT_TYPE;
    (*lppspv)[iProp].Value.l = lpMESSRecord->ulObjectType;

    *lpcProps = iProp;

exit:
    return(hResult);
}

/***************************************************************************

    Name      : FreeMESSRecord

    Purpose   : Frees an MESS record structure

    Parameters: lpMESSRecord -> record to clean up
                ulAttributes = number of attributes in lpMESSRecord

    Returns   : none

    Comment   :

***************************************************************************/
void FreeMESSRecord(LPMESS_RECORD lpMESSRecord) 
{
    ULONG i;

    if (lpMESSRecord) 
    {
        for (i = 0; i < m_Max; i++) 
        {
            if (lpMESSRecord->lpData[i]) 
                LocalFree(lpMESSRecord->lpData[i]);
        }
        LocalFree(lpMESSRecord);
    }
}

/***************************************************************************

	FunctionName:  GetOffSet
    Purpose		:  Gets 4 bytes from the offset specified.
    Parameters	:  hFile -pointer to the file
				   Offset-Offset of the 
				   OffSetValue -the returned 4 bytes.
    Returns		: 
    Note		:
***************************************************************************/
BOOL GetOffSet(HANDLE hFile, DWORD Offset, ULONG* lpOffSetValue)
{
	BYTE Value[4];

    DWORD dwRead = 0;

    SetFilePointer(hFile, Offset, NULL, FILE_BEGIN);

    ReadFile(hFile, Value, 4, &dwRead, NULL);

	*(lpOffSetValue)=	(ULONG)Value[0]*16777216 + (ULONG)Value[1]*65536 + (ULONG)Value[2]*256 + (ULONG)Value[3];

	return TRUE;
}




/******************************************************************************
 *  FUNCTION NAME:GetMESSFileName
 *
 *  PURPOSE:    Gets the Messenger Address book file name
 *
 *  PARAMETERS: szFileName = buffer containing the installation path
// Messenger abook is generally abook.nab
// Location can be found under
// HKLM\Software\Netscape\Netscape Navigator\Users\defaultuser
//  Look for "DirRoot"
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT GetNABPath(LPTSTR szFileName, DWORD cbFileName)
{
    HKEY phkResult = NULL;
    LONG Registry;
    BOOL bResult;
    TCHAR *lpData = NULL, *RegPath = NULL, *path = NULL;
    DWORD dwSize = cbFileName;
    
    LPTSTR lpRegMess = TEXT("Software\\Netscape\\Netscape Navigator\\Users");
    LPTSTR lpRegUser = TEXT("CurrentUser");
    LPTSTR lpRegKey = TEXT("DirRoot");
    LPTSTR lpNABFile = TEXT("\\abook.nab");

    HRESULT hResult = S_OK;
    TCHAR szUser[MAX_PATH];
    TCHAR szUserPath[2*MAX_PATH];

    *szFileName = '\0';
    *szUser ='\0';

    // Open the Netscape..Users key
    Registry = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpRegMess, 0, KEY_QUERY_VALUE, &phkResult);
    if (Registry != ERROR_SUCCESS) 
    {
        hResult = E_FAIL;
        goto error;
    }

    // Look for the CurrentUser
    dwSize = sizeof(szUser);
    Registry = RegQueryValueEx(phkResult, lpRegUser, NULL, NULL, (LPBYTE)szUser, &dwSize);
    if (Registry != ERROR_SUCCESS) 
    {
        hResult = E_FAIL;
        goto error;
    }

    if(!lstrlen(szUser))
    {
        hResult = E_FAIL;
        goto error;
    }

    if (phkResult) {
        RegCloseKey(phkResult);
    }

    //Now concatenate the currentuser to the end of the Netscape key and reopen
    StrCpyN(szUserPath, lpRegMess, ARRAYSIZE(szUserPath));
    StrCatBuff(szUserPath, TEXT("\\"), ARRAYSIZE(szUserPath));
    StrCatBuff(szUserPath, szUser, ARRAYSIZE(szUserPath));

    // Open the Netscape..Users key
    Registry = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szUserPath, 0, KEY_QUERY_VALUE, &phkResult);
    if (Registry != ERROR_SUCCESS) 
    {
        hResult = E_FAIL;
        goto error;
    }

    dwSize = cbFileName;
    Registry = RegQueryValueEx(phkResult, lpRegKey, NULL, NULL, (LPBYTE)szFileName, &dwSize);
    if (Registry != ERROR_SUCCESS) 
    {
        hResult = E_FAIL;
        goto error;
    }

    // concatenate the file name to this directory path
    StrCatBuff(szFileName,lpNABFile, cbFileName/sizeof(szFileName[0]));

error:

    if (phkResult) {
        RegCloseKey(phkResult);
    }

    return(hResult);

}

HRESULT ReadMESSHeader(HANDLE hFile, LPMESS_HEADER lpmh, ULONG ulOffSet)
{
    ULONG ulMagicNumber = 0;
    HRESULT hr = E_FAIL;
    DWORD dwRead;
    ULONG i = 0;

    // Skip 2 bytes
    SetFilePointer(hFile, 2, NULL, FILE_CURRENT);
    ulOffSet += 2;

    GetOffSet(hFile, ulOffSet, &ulMagicNumber);

    if(ulMagicNumber != 0x00000001 ) 
        goto exit;

    ulOffSet += 4;

    for(i=0;i<m_Max;i++)
    {
        switch(i)
        {
        case m_FirstName:
            ulOffSet += 2;
            break;
        case m_LastName:
            ulOffSet += 8;
            break;
        case m_Title:
            ulOffSet += 1;
            break;
        case m_StreetAddress1:
            ulOffSet += 18;
            break;
        }

        GetOffSet(hFile, ulOffSet, &(lpmh->prop[i].ulOffSet));
        ulOffSet += 4;
        GetOffSet(hFile, ulOffSet, &(lpmh->prop[i].ulSize));
        ulOffSet += 4;
    }

    hr = S_OK;

exit:
    return hr;
}

		
/***************************************************************************

	FunctionName:  GetHeaders

    Purpose		:Reads the binary trees ( address binary tree or Dls binary tree) into an array.

    Parameters	:  nLayer= Number of layers in the binary tree.
				   Offset= Primary offset of the binary tree.
				   pHeaders= Array in which the Address entry header offsets and their numbers are to be stored.
				   bflag = 1 should be passed when this recursive function is called for the first time.
	Returns		: 

    Note		: //This function is a recursive function which reads the binary tree and stores the Offset values 
                    and the address numbers in a  Array.

***************************************************************************/
BOOL GetHeaders(HANDLE pFile, int nLayer, ULONG Offset, LPMH_STUFF pHeaders, BOOL bflag)
{
	static ULONG ulCount =0; //keeps trecat of the number of element 
	ULONG	nLoops =0;
	ULONG	ulNewOffset =0;
    ULONG ulElement = 0;

	if(bflag==1)
		ulCount =0;

    //get the number of elements in this header
	if(Offset==0)
		nLoops=32;
	else
	{
		GetOffSet( pFile, Offset+4,&nLoops);
		nLoops &=  0x0000FFFF;
	}


	for(ulElement = 0; ulElement < nLoops; ulElement++)
	{
		if(nLayer > 0)
		{
			ulNewOffset=0;
			if(Offset!=0)
			{
				GetOffSet(pFile, Offset+8+(ulElement*4), &ulNewOffset);
                {
	                ULONG ulMagicNumber=0;
	                GetOffSet(pFile,ulNewOffset+2,&ulMagicNumber);
	                if(ulMagicNumber != 1)
                        ulNewOffset = 0;
                }
			}
				 
			//call this function recursively
			GetHeaders( pFile, nLayer-1, ulNewOffset, pHeaders, 0);
			
		}
		else
		{
			//fill the array here (offset)
			pHeaders[ulCount].ulOffSet=pHeaders[ulCount].ulNum=0;

			if(Offset!=0)
			{
				GetOffSet(pFile, Offset+8+(ulElement*8),& (pHeaders[ulCount].ulOffSet));

				//fill the array element here (address number in case of addresses and size in case of messages)
				if(!GetOffSet(pFile, Offset+12+(ulElement*8), &(pHeaders[ulCount].ulNum)))
				{
					pHeaders[ulCount].ulNum=0;
				}
			}

			ulCount++; //increment the count
	
		}
	}

    return TRUE;
}

/***************************************************************************

    Name      : ReadMESSRecord

    Purpose   : Reads a record from an MESS file with fixups for special characters

    Parameters: hFile = file handle

    Returns   : HRESULT

***************************************************************************/
HRESULT ReadMESSRecord(HANDLE hFile, LPMESS_RECORD * lppMESSRecord, ULONG ulContactOffset) 
{
    HRESULT hResult = hrSuccess;
    PUCHAR lpBuffer  = NULL;
    ULONG cbBuffer = 0;
    ULONG cbReadFile = 1;
    ULONG iItem = 0;
    ULONG cAttributes = 0;
    BOOL fEOR = FALSE;
    LPMESS_RECORD lpMESSRecord = NULL;
    LPBYTE lpData = NULL;
    LPTSTR lpName = NULL;
    ULONG cbData;
    TCHAR szTemp[2048]; // 2k limit
    ULONG i = 0;
    DWORD dwRead = 0;
    ULONG cchSize = 0;

    MESS_HEADER mh = {0};

    // The Contact Offset gives us the offset of the header for this record - the
    // header contains the offset and the size of each property for that address
    if(hResult = ReadMESSHeader(hFile, &mh, ulContactOffset))
        goto exit;
 
    lpMESSRecord = LocalAlloc(LMEM_ZEROINIT, sizeof(MESS_RECORD));
    if(!lpMESSRecord)
    {
        hResult = MAPI_E_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    lpMESSRecord->ulObjectType = MAPI_MAILUSER;

    for(i=0;i<m_Max;i++)
    {
        if(mh.prop[i].ulSize)
        {
            if(i == m_StreetAddress1)
			{
				cchSize = mh.prop[i].ulSize + mh.prop[m_StreetAddress2].ulSize + 8;

                lpMESSRecord->lpData[i] = LocalAlloc(LMEM_ZEROINIT, cchSize);
			}
            else
                lpMESSRecord->lpData[i] = LocalAlloc(LMEM_ZEROINIT, mh.prop[i].ulSize);
            if(lpMESSRecord->lpData[i])
            {
                SetFilePointer(hFile, mh.prop[i].ulOffSet, NULL, FILE_BEGIN);
                ReadFile(hFile, (LPVOID) lpMESSRecord->lpData[i], mh.prop[i].ulSize, &dwRead, NULL);
                lpMESSRecord->lpData[i][mh.prop[i].ulSize-1] = '\0';
            }
        }
    }

    //Fix the fact that the street address is split into street1 and street2
    if(lpMESSRecord->lpData[m_StreetAddress1] && lpMESSRecord->lpData[m_StreetAddress2] &&
       lstrlen(lpMESSRecord->lpData[m_StreetAddress1]) && lstrlen(lpMESSRecord->lpData[m_StreetAddress2]))
    {
        StrCatBuff(lpMESSRecord->lpData[m_StreetAddress1], TEXT("\r\n"), cchSize);
        StrCatBuff(lpMESSRecord->lpData[m_StreetAddress1], lpMESSRecord->lpData[m_StreetAddress2], cchSize);
        LocalFree(lpMESSRecord->lpData[m_StreetAddress2]);
        lpMESSRecord->lpData[m_StreetAddress2] = NULL;
    }

    *lppMESSRecord = lpMESSRecord;
exit:


    return(hResult);
}



/***************************************************************************
    GetAllDLNames
    
    Purpose		: Gets the Names of all the DLs.

    Note		: 

***************************************************************************/
BOOL GetAllDLNames(HANDLE pFile, ULONG nDLs, LPMH_STUFF pHeadersDL)
{

    ULONG i = 0;

    for(i=0;i<nDLs;i++)
    {
	    ULONG ulDLDispNameOffset=0;
	    ULONG ulDLDispNameSize=0;
        ULONG ulDLCommentOffSet = 0;
        ULONG ulDLCommentSize = 0;

        DWORD dwRead = 0;
        LPTSTR szComment = 0;
        LPTSTR szSubject = NULL;

        ULONG ulDLOffset = pHeadersDL[i].ulOffSet;

	    //get the diplay name of the DL.
	    if(FALSE==GetOffSet(pFile, ulDLOffset+6,&ulDLDispNameOffset))
		    return FALSE;

	    if(FALSE==GetOffSet(pFile,ulDLOffset+10,&ulDLDispNameSize))
		    return FALSE;

        if(ulDLDispNameSize)
        {
	        if((szSubject= LocalAlloc(LMEM_ZEROINIT, ulDLDispNameSize))==NULL)
		        return FALSE;

            SetFilePointer(pFile, ulDLDispNameOffset, NULL, FILE_BEGIN);

            ReadFile(pFile, (LPVOID) szSubject, ulDLDispNameSize, &dwRead, NULL); 

            szSubject[ulDLDispNameSize-1] = '\0';

            pHeadersDL[i].bp.lpName = szSubject;
        }

        // Get the Comment for the DL
       if(FALSE==GetOffSet(pFile,ulDLOffset+44,&ulDLCommentOffSet))
            return FALSE;
        if(FALSE==GetOffSet(pFile,ulDLOffset+48,&ulDLCommentSize))
            return FALSE;

        if(ulDLCommentSize)
        {
            if((szComment= LocalAlloc(LMEM_ZEROINIT, ulDLCommentSize))==NULL)
		        return FALSE;

            SetFilePointer(pFile, ulDLCommentOffSet, NULL, FILE_BEGIN);

            ReadFile(pFile, (LPVOID) szComment, ulDLCommentSize, &dwRead, NULL); 

            szComment[ulDLCommentSize-1] = '\0';

            pHeadersDL[i].bp.lpComment = szComment;
        }
 
    }

    return TRUE;
}


/***************************************************************************

  GetDLEntryNumbers - reads the DL member numbers (ids) from the binary tree
    in the NAB file

/***************************************************************************/
BOOL GetDLEntryNumbers(HANDLE pFile, int nLayer, ULONG POffset,ULONG* ulNumOfEntries,ULONG *pEntryNumbers,BOOL bflag)
{
	static ULONG ulCount =0; //keeps trecat of the number of element 
	ULONG	nLoops =0;
	ULONG	ulNewOffset =0;
    ULONG ulElement = 0;

	if(bflag==1)
		ulCount =0;

	if(POffset==0)
		nLoops=32;
	else
	{
		GetOffSet(pFile,POffset+4,&nLoops);
		nLoops &=  0x0000FFFF;
	}


	for(ulElement = 0; ulElement < nLoops; ulElement++)
	{
		if(nLayer > 0)
		{
			ulNewOffset=0;
			if(POffset!=0)
				GetOffSet(pFile, POffset+8+(ulElement*4), &ulNewOffset);
				 
			//call this function recursively
			GetDLEntryNumbers(pFile,nLayer-1, ulNewOffset,ulNumOfEntries,pEntryNumbers,0);					
		}
		else
		{
			//fill the array here (offset)
			pEntryNumbers[ulCount]=0;

			if(POffset!=0)
				GetOffSet(pFile, POffset+8+(ulElement*4),&(pEntryNumbers[ulCount]));

			ulCount++; //increment the count
			if(ulCount>(*ulNumOfEntries))
			{
				*ulNumOfEntries=ulCount;
				return TRUE;
			}
		}
	}
	return TRUE;
}

/***************************************************************************

	FunctionName:  GetDLEntries

    Purpose		: Gets the entries of a DL.

    Note		: 

***************************************************************************/
BOOL GetDLEntries(HANDLE pFile, 
                  LPMH_STUFF pHeadAdd,  ULONG ulAddCount, 
                  LPMH_STUFF pHeadDL,   ULONG ulDLCount, 
                  ULONG ulDLOffset, ULONG nIndex,
                  ULONG * lpulDLNum, LPMP_BASIC * lppmp)
{
	ULONG ulDLEntHeaderOffSet=0;//offset of the header of DL entries(Header which has the entry numbers
	ULONG ulDLEntriesCount=0;

	ULONG ulDLEntryOffSet=0;  //offset of the Dl entry              
	ULONG ulDLEntryNumber=0;  //Number of DL entry
	ULONG ulDLEntryNameOffSet=0; 
	ULONG ulDLEntryNameSize=0;

    ULONG * lpulDLEntryNumbers = NULL;
	int nLevelCount=0;
	int utemp=32;

    DWORD dwRead = 0;
    ULONG i, j;

    LPMP_BASIC lpmp = NULL; 

	if(FALSE==GetOffSet(pFile,ulDLOffset+24,&ulDLEntriesCount))
		return FALSE;

    if(!ulDLEntriesCount) // no members
        return TRUE;

	*lpulDLNum = ulDLEntriesCount;

	//alocate the array of string pointers which hold the names of the DL entries.
	lpmp = LocalAlloc(LMEM_ZEROINIT, sizeof(MP_BASIC) * ulDLEntriesCount);

	//get the entries here
	//first get the offset of the header which has the DL entry numbers.

	if(FALSE==GetOffSet(pFile,ulDLOffset+28,&ulDLEntHeaderOffSet))
		return FALSE;

    lpulDLEntryNumbers = LocalAlloc(LMEM_ZEROINIT, sizeof(ULONG) * ulDLEntriesCount);
    if(!lpulDLEntryNumbers)
        return FALSE;

	nLevelCount=0;
	utemp=32;

	while(utemp <(int) ulDLEntriesCount)
	{
		utemp *= 32;
		nLevelCount++;
	}

	if(!(GetDLEntryNumbers(pFile, nLevelCount, ulDLEntHeaderOffSet, &ulDLEntriesCount, lpulDLEntryNumbers, 1)))
	{
		return FALSE;
	}

	for(i=0;i<ulDLEntriesCount;i++)
	{	
		ULONG j=0;
        LPTSTR lp = NULL;
        LPTSTR lpE = NULL;

		ulDLEntryOffSet=0;
		lpmp[i].lpName=NULL;
		lpmp[i].lpEmail=NULL;
    	lpmp[i].lpComment=NULL;

		//get the entry number ulDLentryNumber
        ulDLEntryNumber = lpulDLEntryNumbers[i];
	
		//search out address array to get the display name....
		for(j=0;j<ulAddCount;j++)
		{
			if(pHeadAdd[j].ulNum == ulDLEntryNumber)
			{
				lpmp[i].lpName = pHeadAdd[j].bp.lpName;
                lpmp[i].lpEmail = pHeadAdd[j].bp.lpEmail;
				break;
			}
		}

		//search the DL array now...
		if(!lpmp[i].lpName)
		{
            ULONG k;
			for(k=0;k<ulDLCount;k++)
			{
				if(pHeadDL[k].ulNum == ulDLEntryNumber)
				{
				    lpmp[i].lpName = pHeadDL[k].bp.lpName;
                    lpmp[i].lpEmail = NULL; // DLs dont have emails
					break;
				}
			}
		}
	}

    *lppmp = lpmp;

	return TRUE;
}




/****************************************************************
*
*
*
*****************************************************************/
HRESULT MessengerImport( HWND hWnd,
                    LPADRBOOK lpAdrBook,
                    LPWABOBJECT lpWABObject,
                    LPWAB_PROGRESS_CALLBACK lpProgressCB,
                    LPWAB_EXPORT_OPTIONS lpOptions) 
{
    HRESULT hResult = hrSuccess;
    TCHAR szFileName[MAX_PATH + 1];
    register ULONG i;
    ULONG ulObjType, j;
    ULONG index;
    ULONG ulLastChosenProp = 0;
    ULONG ulcFields = 0;
    ULONG cAttributes = 0;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    WAB_PROGRESS Progress;
    LPABCONT lpContainer = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    LPMESS_RECORD lpMESSRecord = NULL;
    LPSPropValue lpspv = NULL;
    ULONG cProps;
    BOOL fSkipSetProps;
    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    BOOL fDoDistLists = FALSE;

    ULONG nEntries = 0;
    ULONG nDLs = 0;
    ULONG nContactOffset = 0;
    ULONG nDLOffset = 0;

    int utemp=32;
    LPMH_STUFF pHeadersAdd = NULL;
    LPMH_STUFF pHeadersDL = NULL;

	int nLevelCountAdd=0;

    SetGlobalBufferFunctions(lpWABObject);

    *szFileName = '\0';

    hResult = GetNABPath(szFileName, sizeof(szFileName));

    if( hResult != S_OK || !lstrlen(szFileName) ||
        GetFileAttributes(szFileName) == 0xFFFFFFFF)
    {
        // The file was not correctly detected
        // Prompt to find it manually ...
        StrCpyN(szFileName, LoadStringToGlobalBuffer(IDS_STRING_SELECTPATH), ARRAYSIZE(szFileName));
        if (IDNO == MessageBox( hWnd,
                        szFileName, //temporarily overloaded
                        LoadStringToGlobalBuffer(IDS_MESSAGE),
                        MB_YESNO)) 
        {
            return(ResultFromScode(MAPI_E_USER_CANCEL));
        }
        else
        {
            *szFileName = '\0';
            // Get MESS file name
            OpenFileDialog(hWnd,
                          szFileName,
                          szMESSFilter,
                          IDS_MESS_FILE_SPEC,
                          szAllFilter,
                          IDS_ALL_FILE_SPEC,
                          NULL,
                          0,
                          szMESSExt,
                          OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST,
                          hInst,
                          0,        //idsTitle
                          0);       // idsSaveButton
            if(!lstrlen(szFileName))
                return(ResultFromScode(E_FAIL));
        }
    }


    // Open the file
    if ((hFile = CreateFile(szFileName,
                              GENERIC_READ,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL)) == INVALID_HANDLE_VALUE) 
    {
        DWORD err =  GetLastError();
        DebugTrace("Couldn't open file %s -> %u\n", szFileName, err);
        // BEGIN DELTA for BUG 1804
        // if the file is locked (e.g. netscape AB in use)
        if( err == ERROR_SHARING_VIOLATION )
            return(ResultFromScode(MAPI_E_BUSY));
        // else return a generic error for generic msg            
        return(ResultFromScode(MAPI_E_NOT_FOUND));        
        // END   DELTA for BUG 1804
    }

    Assert(hFile != INVALID_HANDLE_VALUE);

    //
    // Open the WAB's PAB container: fills global lpCreateEIDsWAB
    //
    if (hResult = LoadWABEIDs(lpAdrBook, &lpContainer)) {
        goto exit;
    }

    //
    // All set... now loop through the records, adding each to the WAB
    //

	GetOffSet(hFile,0x185,&nEntries);
    GetOffSet(hFile,0x1d8,&nDLs);
    GetOffSet(hFile,0x195,&nContactOffset);
    GetOffSet(hFile,0x1e8,&nDLOffset);

    ulcEntries = nEntries + nDLs;

    if(!ulcEntries)
    {
        hResult = S_OK;
        goto exit;
    }

    // Initialize the Progress Bar
    Progress.denominator = max(ulcEntries, 1);
    Progress.numerator = 0;

    if (LoadString(hInst, IDS_STATE_IMPORT_MU, szBuffer, sizeof(szBuffer))) {
        DebugTrace("Status Message: %s\n", szBuffer);
        Progress.lpText = szBuffer;
    } else {
        DebugTrace("Cannot load resource string %u\n", IDS_STATE_IMPORT_MU);
        Progress.lpText = NULL;
    }
    lpProgressCB(hWnd, &Progress);

    
    // We will make 2 passes over the file - in the first pass we will import all the
    // contacts. In the second pass we will import all the distribution lists .. the
    // advantage of doing 2 passes is that when importing contacts, we will prompt on
    // conflict and then when importing distlists, we will assume all contacts in the 
    // WAB are correct and just point to the relevant ones


    if(nEntries)
    {
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

        pHeadersAdd = LocalAlloc(LMEM_ZEROINIT, nEntries * sizeof(MH_STUFF));
        if(!pHeadersAdd)
        {
            hResult = MAPI_E_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        utemp = 32;
        nLevelCountAdd = 0;
        while(utemp <(int) nEntries)
        {
	        utemp *= 32;
	        nLevelCountAdd++;
        }

        if(!GetHeaders(hFile ,nLevelCountAdd, nContactOffset, pHeadersAdd, 1))
        {
	        goto exit;
        }

        for(i=0;i<nEntries;i++)
        {
            if (hResult = ReadMESSRecord(hFile, &lpMESSRecord, pHeadersAdd[i].ulOffSet)) 
            {
                DebugTrace("ReadMESSRecord -> %x\n", GetScode(hResult));
                continue;
            }

            if (hResult = MapMESSRecordtoProps(   lpMESSRecord, 
                                            &lpspv, &cProps,
                                            &lpDisplayName, &lpEmailAddress)) 
            {
                DebugTrace("MapMESSRecordtoProps -> %x\n", GetScode(hResult));
                continue;
            }

            hResult = HrAddMESSMailUser(hWnd, 
                                        lpContainer, 
                                        lpDisplayName, 
                                        lpEmailAddress,
                                        cProps, lpspv,
                                        lpProgressCB, lpOptions);
            //if(HR_FAILED(hResult))
            if(hResult == MAPI_E_USER_CANCEL)
                goto exit;

            // Update progress bar
            Progress.numerator++;

            Assert(Progress.numerator <= Progress.denominator);

            if(lpDisplayName && lstrlen(lpDisplayName))
            {
                pHeadersAdd[i].bp.lpName = LocalAlloc(LMEM_ZEROINIT, lstrlen(lpDisplayName)+1);
                if(pHeadersAdd[i].bp.lpName)
                    StrCpyN(pHeadersAdd[i].bp.lpName, lpDisplayName, lstrlen(lpDisplayName)+1);
            }

            if(lpEmailAddress && lstrlen(lpEmailAddress))
            {
                pHeadersAdd[i].bp.lpEmail = LocalAlloc(LMEM_ZEROINIT, lstrlen(lpEmailAddress)+1);
                if(pHeadersAdd[i].bp.lpEmail)
                    StrCpyN(pHeadersAdd[i].bp.lpEmail, lpEmailAddress, lstrlen(lpEmailAddress)+1);
            }

            if (lpMESSRecord) 
            {
                FreeMESSRecord(lpMESSRecord);
                lpMESSRecord = NULL;
            }

            if (lpspv) 
            {
                int j;
                for(j=0;j<m_Max;j++)
                {
                    lpspv[j].ulPropTag = PR_NULL;
                    lpspv[j].Value.LPSZ = NULL;
                }
                WABFreeBuffer(lpspv);
                lpspv = NULL;
            }

            lpProgressCB(hWnd, &Progress);

        }
    }



    // NOW do the DISTLISTS

    if(nDLs)
    {
        SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

        pHeadersDL = LocalAlloc(LMEM_ZEROINIT, nDLs * sizeof(MH_STUFF));
        if(!pHeadersDL)
        {
            hResult = MAPI_E_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        utemp = 32;
        nLevelCountAdd = 0;
	    while(utemp <(int) nDLs)
	    {
		    utemp *= 32;
		    nLevelCountAdd++;
	    }

	    if(!GetHeaders(hFile ,nLevelCountAdd, nDLOffset, pHeadersDL, 1))
	    {
		    goto exit;
	    }

        // read all the names of the DLs upfront ... this makes it easier to 
        // associate member DLs with the DL
        if(!GetAllDLNames(hFile, nDLs, pHeadersDL))
        {
            goto exit;
        }

        // 54263: Theres some kind of bug in the NAB file where we get nDLs == 1 even when there are no DLs
        // Need to skip over that case
        if(nDLs == 1 && !pHeadersDL[0].bp.lpName)
        {
            hResult = S_OK;
            goto exit;
        }

        for(i=0;i<nDLs;i++)
        {
            ULONG ulcNumDLEntries = 0;
            LPMP_BASIC lpmp = NULL;

            GetDLEntries(hFile, 
                        pHeadersAdd, nEntries, 
                        pHeadersDL, nDLs,
                        pHeadersDL[i].ulOffSet, i,
                        &ulcNumDLEntries, &lpmp);

            hResult = HrAddMESSDistList(hWnd, lpContainer, 
                                        pHeadersDL[i],
                                        ulcNumDLEntries, lpmp,
                                        lpProgressCB, lpOptions);

            //if(HR_FAILED(hResult))
            //    goto exit;

            // Update progress bar
            Progress.numerator++;

            Assert(Progress.numerator <= Progress.denominator);

            lpProgressCB(hWnd, &Progress);

            // Dont need to free lpmp since it only contains pointers and not allocated memory
            if(lpmp)
                LocalFree(lpmp);
        }
    }


    if (! HR_FAILED(hResult)) 
        hResult = hrSuccess;
 
exit:

    if(pHeadersAdd)
    {
        for(i=0;i<nEntries;i++)
        {
            if(pHeadersAdd[i].bp.lpName)
                LocalFree(pHeadersAdd[i].bp.lpName);
            if(pHeadersAdd[i].bp.lpEmail)
                LocalFree(pHeadersAdd[i].bp.lpEmail);
        }
        LocalFree(pHeadersAdd);
    }

    
    if(pHeadersDL)
    {
        for(i=0;i<nDLs;i++)
        {
            if(pHeadersDL[i].bp.lpName)
                LocalFree(pHeadersDL[i].bp.lpName);
            if(pHeadersDL[i].bp.lpComment)
                LocalFree(pHeadersDL[i].bp.lpComment);
        }
        LocalFree(pHeadersDL);
    }

    if (hFile) {
        CloseHandle(hFile);
    }

    if (lpspv) {
        WABFreeBuffer(lpspv);
        lpspv = NULL;
    }

    if (lpMESSRecord) {
        FreeMESSRecord(lpMESSRecord);
        lpMESSRecord = NULL;
    }

    if (lpContainer) {
        lpContainer->lpVtbl->Release(lpContainer);
        lpContainer = NULL;
    }

    if (lpCreateEIDsWAB) {
        WABFreeBuffer(lpCreateEIDsWAB);
        lpCreateEIDsWAB = NULL;
    }


    return(hResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\wabguid.c ===
// This builds wabguid.obj, which can be linked into a DLL
// or EXE to provide the MAPI GUIDs. It contains all GUIDs
// defined by WAB.


#define USES_IID_IUnknown
#define USES_IID_IMAPIUnknown
#define USES_IID_IMAPITable
#define USES_IID_INotifObj
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIStatus
#define USES_IID_IAddrBook
#define USES_IID_IMailUser
#define USES_IID_IMAPIContainer
#define USES_IID_IABContainer
#define USES_IID_IDistList
#define USES_IID_IMAPITableData
#define USES_IID_IMAPIAdviseSink


#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#define INITGUID
#include <windows.h>
#include <wab.h>
#include <wabguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\emsabtag.h ===
/*
** --emsabtag.h---------------------------------------------------------------
**
**  Property tag definitions for standard properties of Exchange Address
**  Book objects.
**
**  Note: These proptags are only valid when talking directly to the
**  Exchange Server Address Book. They are specifically NOT valid when
**  trying to read properties from an object copied into another address
**  book provider (the Personal Address Book, for example).
**
**  Copyright (c) Microsoft Corp. 1986-1996. All rights reserved.
** ---------------------------------------------------------------------------
*/

#ifndef _EMSABTAG_H
#define _EMSABTAG_H

/*    
 * Flags for ulInterfaceOptions on OpenProperty   
 */
#define AB_SHOW_PHANTOMS                      2
#define AB_SHOW_OTHERS                            4

/*    
 * Flags for ulFlag on ResolveNames               
 */
#define EMS_AB_ADDRESS_LOOKUP                 0x01

/* 
 * Constructed, but externally visible. 
 */
#define PR_EMS_AB_SERVER                      PROP_TAG(PT_TSTRING,      0xFFFE)
#define PR_EMS_AB_SERVER_A                    PROP_TAG(PT_STRING8,      0xFFFE)
#define PR_EMS_AB_SERVER_W                    PROP_TAG(PT_UNICODE,      0xFFFE)
#define PR_EMS_AB_CONTAINERID                 PROP_TAG(PT_LONG,         0xFFFD)
#define PR_EMS_AB_DOS_ENTRYID                 PR_EMS_AB_CONTAINERID
#define PR_EMS_AB_PARENT_ENTRYID              PROP_TAG(PT_BINARY,       0xFFFC)
#define PR_EMS_AB_IS_MASTER                   PROP_TAG(PT_BOOLEAN,      0xFFFB)
#define PR_EMS_AB_OBJECT_OID                  PROP_TAG(PT_BINARY,       0xFFFA)
#define PR_EMS_AB_HIERARCHY_PATH              PROP_TAG(PT_TSTRING,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_A            PROP_TAG(PT_STRING8,      0xFFF9)
#define PR_EMS_AB_HIERARCHY_PATH_W            PROP_TAG(PT_UNICODE,      0xFFF9)
#define PR_EMS_AB_CHILD_RDNS                  PROP_TAG(PT_MV_STRING8,   0xFFF8)

#define MIN_EMS_AB_CONSTRUCTED_PROP_ID        0xFFF8

#define PR_EMS_AB_OTHER_RECIPS                PROP_TAG(PT_OBJECT,       0xF000)

/* 
 * Prop tags defined in the schema. 
 */
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE      PROP_TAG(PT_TSTRING,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_A    PROP_TAG(PT_STRING8,      0x39FF)
#define PR_EMS_AB_DISPLAY_NAME_PRINTABLE_W    PROP_TAG(PT_UNICODE,      0x39FF)

#define PR_EMS_AB_ACCESS_CATEGORY             PROP_TAG(PT_LONG,         0x8044)
#define PR_EMS_AB_ACTIVATION_SCHEDULE         PROP_TAG(PT_BINARY,       0x8045)
#define PR_EMS_AB_ACTIVATION_STYLE            PROP_TAG(PT_LONG,         0x8046)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE PROP_TAG(PT_BINARY,       0x8017)
#define PR_EMS_AB_ADDRESS_ENTRY_DISPLAY_TABLE_MSDOS PROP_TAG(PT_BINARY, 0x8047)
#define PR_EMS_AB_ADDRESS_SYNTAX              PROP_TAG(PT_BINARY,       0x8018)
#define PR_EMS_AB_ADDRESS_TYPE                PROP_TAG(PT_TSTRING,      0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_A              PROP_TAG(PT_STRING8,      0x8048)
#define PR_EMS_AB_ADDRESS_TYPE_W              PROP_TAG(PT_UNICODE,      0x8048)
#define PR_EMS_AB_ADMD                        PROP_TAG(PT_TSTRING,      0x8049)
#define PR_EMS_AB_ADMD_A                      PROP_TAG(PT_STRING8,      0x8049)
#define PR_EMS_AB_ADMD_W                      PROP_TAG(PT_UNICODE,      0x8049)
#define PR_EMS_AB_ADMIN_DESCRIPTION           PROP_TAG(PT_TSTRING,      0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_A         PROP_TAG(PT_STRING8,      0x804A)
#define PR_EMS_AB_ADMIN_DESCRIPTION_W         PROP_TAG(PT_UNICODE,      0x804A)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME          PROP_TAG(PT_TSTRING,      0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_A        PROP_TAG(PT_STRING8,      0x804B)
#define PR_EMS_AB_ADMIN_DISPLAY_NAME_W        PROP_TAG(PT_UNICODE,      0x804B)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL         PROP_TAG(PT_TSTRING,      0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_A       PROP_TAG(PT_STRING8,      0x804C)
#define PR_EMS_AB_ADMIN_EXTENSION_DLL_W       PROP_TAG(PT_UNICODE,      0x804C)
#define PR_EMS_AB_ALIASED_OBJECT_NAME         PROP_TAG(PT_TSTRING,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_A       PROP_TAG(PT_STRING8,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_W       PROP_TAG(PT_UNICODE,      0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_O       PROP_TAG(PT_OBJECT,       0x804D)
#define PR_EMS_AB_ALIASED_OBJECT_NAME_T       PROP_TAG(PT_TSTRING,      0x804D)
#define PR_EMS_AB_ALT_RECIPIENT               PROP_TAG(PT_TSTRING,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_A             PROP_TAG(PT_STRING8,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_W             PROP_TAG(PT_UNICODE,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_O             PROP_TAG(PT_OBJECT,       0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_T             PROP_TAG(PT_TSTRING,      0x804E)
#define PR_EMS_AB_ALT_RECIPIENT_BL            PROP_TAG(PT_MV_TSTRING,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_A          PROP_TAG(PT_MV_STRING8,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_W          PROP_TAG(PT_MV_UNICODE,   0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_O          PROP_TAG(PT_OBJECT,       0x804F)
#define PR_EMS_AB_ALT_RECIPIENT_BL_T          PROP_TAG(PT_MV_TSTRING,   0x804F)
#define PR_EMS_AB_ANCESTOR_ID                 PROP_TAG(PT_BINARY,       0x8050)
#define PR_EMS_AB_ASSOC_NT_ACCOUNT            PROP_TAG(PT_BINARY,       0x8027)
#define PR_EMS_AB_ASSOC_REMOTE_DXA            PROP_TAG(PT_MV_TSTRING,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_A          PROP_TAG(PT_MV_STRING8,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_W          PROP_TAG(PT_MV_UNICODE,   0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_O          PROP_TAG(PT_OBJECT,       0x8051)
#define PR_EMS_AB_ASSOC_REMOTE_DXA_T          PROP_TAG(PT_MV_TSTRING,   0x8051)
#define PR_EMS_AB_ASSOCIATION_LIFETIME        PROP_TAG(PT_LONG,         0x8052)
#define PR_EMS_AB_AUTH_ORIG_BL                PROP_TAG(PT_MV_TSTRING,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_A              PROP_TAG(PT_MV_STRING8,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_W              PROP_TAG(PT_MV_UNICODE,   0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_O              PROP_TAG(PT_OBJECT,       0x8053)
#define PR_EMS_AB_AUTH_ORIG_BL_T              PROP_TAG(PT_MV_TSTRING,   0x8053)
#define PR_EMS_AB_AUTHORITY_REVOCATION_LIST   PROP_TAG(PT_MV_BINARY,    0x8026)
#define PR_EMS_AB_AUTHORIZED_DOMAIN           PROP_TAG(PT_TSTRING,      0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_A         PROP_TAG(PT_STRING8,      0x8054)
#define PR_EMS_AB_AUTHORIZED_DOMAIN_W         PROP_TAG(PT_UNICODE,      0x8054)
#define PR_EMS_AB_AUTHORIZED_PASSWORD         PROP_TAG(PT_BINARY,       0x8055)
#define PR_EMS_AB_AUTHORIZED_USER             PROP_TAG(PT_TSTRING,      0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_A           PROP_TAG(PT_STRING8,      0x8056)
#define PR_EMS_AB_AUTHORIZED_USER_W           PROP_TAG(PT_UNICODE,      0x8056)
#define PR_EMS_AB_AUTOREPLY                   PROP_TAG(PT_BOOLEAN,      0x800B)
#define PR_EMS_AB_AUTOREPLY_MESSAGE           PROP_TAG(PT_TSTRING,      0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_A         PROP_TAG(PT_STRING8,      0x800A)
#define PR_EMS_AB_AUTOREPLY_MESSAGE_W         PROP_TAG(PT_UNICODE,      0x800A)
#define PR_EMS_AB_AUTOREPLY_SUBJECT           PROP_TAG(PT_TSTRING,      0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_A         PROP_TAG(PT_STRING8,      0x803E)
#define PR_EMS_AB_AUTOREPLY_SUBJECT_W         PROP_TAG(PT_UNICODE,      0x803E)
#define PR_EMS_AB_BUSINESS_CATEGORY           PROP_TAG(PT_MV_TSTRING,   0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_A         PROP_TAG(PT_MV_STRING8,   0x8057)
#define PR_EMS_AB_BUSINESS_CATEGORY_W         PROP_TAG(PT_MV_UNICODE,   0x8057)
#define PR_EMS_AB_BUSINESS_ROLES              PROP_TAG(PT_BINARY,       0x8023)
#define PR_EMS_AB_CA_CERTIFICATE              PROP_TAG(PT_MV_BINARY,    0x8003)
#define PR_EMS_AB_CAN_CREATE_PF               PROP_TAG(PT_MV_TSTRING,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_A             PROP_TAG(PT_MV_STRING8,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_W             PROP_TAG(PT_MV_UNICODE,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_O             PROP_TAG(PT_OBJECT,       0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_T             PROP_TAG(PT_MV_TSTRING,   0x8058)
#define PR_EMS_AB_CAN_CREATE_PF_BL            PROP_TAG(PT_MV_TSTRING,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_A          PROP_TAG(PT_MV_STRING8,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_W          PROP_TAG(PT_MV_UNICODE,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_O          PROP_TAG(PT_OBJECT,       0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_BL_T          PROP_TAG(PT_MV_TSTRING,   0x8059)
#define PR_EMS_AB_CAN_CREATE_PF_DL            PROP_TAG(PT_MV_TSTRING,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_A          PROP_TAG(PT_MV_STRING8,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_W          PROP_TAG(PT_MV_UNICODE,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_O          PROP_TAG(PT_OBJECT,       0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_T          PROP_TAG(PT_MV_TSTRING,   0x805A)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL         PROP_TAG(PT_MV_TSTRING,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_A       PROP_TAG(PT_MV_STRING8,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_W       PROP_TAG(PT_MV_UNICODE,   0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_O       PROP_TAG(PT_OBJECT,       0x805B)
#define PR_EMS_AB_CAN_CREATE_PF_DL_BL_T       PROP_TAG(PT_MV_TSTRING,   0x805B)
#define PR_EMS_AB_CAN_NOT_CREATE_PF           PROP_TAG(PT_MV_TSTRING,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_A         PROP_TAG(PT_MV_STRING8,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_W         PROP_TAG(PT_MV_UNICODE,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_O         PROP_TAG(PT_OBJECT,       0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_T         PROP_TAG(PT_MV_TSTRING,   0x805C)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL        PROP_TAG(PT_MV_TSTRING,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_A      PROP_TAG(PT_MV_STRING8,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_W      PROP_TAG(PT_MV_UNICODE,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_O      PROP_TAG(PT_OBJECT,       0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_BL_T      PROP_TAG(PT_MV_TSTRING,   0x805D)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL        PROP_TAG(PT_MV_TSTRING,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_A      PROP_TAG(PT_MV_STRING8,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_W      PROP_TAG(PT_MV_UNICODE,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_O      PROP_TAG(PT_OBJECT,       0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_T      PROP_TAG(PT_MV_TSTRING,   0x805E)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL     PROP_TAG(PT_MV_TSTRING,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_A   PROP_TAG(PT_MV_STRING8,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_W   PROP_TAG(PT_MV_UNICODE,   0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_O   PROP_TAG(PT_OBJECT,       0x805F)
#define PR_EMS_AB_CAN_NOT_CREATE_PF_DL_BL_T   PROP_TAG(PT_MV_TSTRING,   0x805F)
#define PR_EMS_AB_CAN_PRESERVE_DNS            PROP_TAG(PT_BOOLEAN,      0x8060)
#define PR_EMS_AB_CERTIFICATE_REVOCATION_LIST PROP_TAG(PT_BINARY,       0x8016)
#define PR_EMS_AB_CLOCK_ALERT_OFFSET          PROP_TAG(PT_LONG,         0x8061)
#define PR_EMS_AB_CLOCK_ALERT_REPAIR          PROP_TAG(PT_BOOLEAN,      0x8062)
#define PR_EMS_AB_CLOCK_WARNING_OFFSET        PROP_TAG(PT_LONG,         0x8063)
#define PR_EMS_AB_CLOCK_WARNING_REPAIR        PROP_TAG(PT_BOOLEAN,      0x8064)
#define PR_EMS_AB_COMPUTER_NAME               PROP_TAG(PT_TSTRING,      0x8065)
#define PR_EMS_AB_COMPUTER_NAME_A             PROP_TAG(PT_STRING8,      0x8065)
#define PR_EMS_AB_COMPUTER_NAME_W             PROP_TAG(PT_UNICODE,      0x8065)
#define PR_EMS_AB_CONNECTED_DOMAINS           PROP_TAG(PT_MV_TSTRING,   0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_A         PROP_TAG(PT_MV_STRING8,   0x8066)
#define PR_EMS_AB_CONNECTED_DOMAINS_W         PROP_TAG(PT_MV_UNICODE,   0x8066)
#define PR_EMS_AB_CONTAINER_INFO              PROP_TAG(PT_LONG,         0x8067)
#define PR_EMS_AB_COST                        PROP_TAG(PT_LONG,         0x8068)
#define PR_EMS_AB_COUNTRY_NAME                PROP_TAG(PT_TSTRING,      0x8069)
#define PR_EMS_AB_COUNTRY_NAME_A              PROP_TAG(PT_STRING8,      0x8069)
#define PR_EMS_AB_COUNTRY_NAME_W              PROP_TAG(PT_UNICODE,      0x8069)
#define PR_EMS_AB_CROSS_CERTIFICATE_PAIR      PROP_TAG(PT_MV_BINARY,    0x8025)
#define PR_EMS_AB_DELIV_CONT_LENGTH           PROP_TAG(PT_LONG,         0x806A)
#define PR_EMS_AB_DELIV_EITS                  PROP_TAG(PT_MV_BINARY,    0x806B)
#define PR_EMS_AB_DELIV_EXT_CONT_TYPES        PROP_TAG(PT_MV_BINARY,    0x806C)
#define PR_EMS_AB_DELIVER_AND_REDIRECT        PROP_TAG(PT_BOOLEAN,      0x806D)
#define PR_EMS_AB_DELIVERY_MECHANISM          PROP_TAG(PT_LONG,         0x806E)
#define PR_EMS_AB_DESCRIPTION                 PROP_TAG(PT_MV_TSTRING,   0x806F)
#define PR_EMS_AB_DESCRIPTION_A               PROP_TAG(PT_MV_STRING8,   0x806F)
#define PR_EMS_AB_DESCRIPTION_W               PROP_TAG(PT_MV_UNICODE,   0x806F)
#define PR_EMS_AB_DESTINATION_INDICATOR       PROP_TAG(PT_MV_TSTRING,   0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_A     PROP_TAG(PT_MV_STRING8,   0x8070)
#define PR_EMS_AB_DESTINATION_INDICATOR_W     PROP_TAG(PT_MV_UNICODE,   0x8070)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY          PROP_TAG(PT_TSTRING,      0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_A        PROP_TAG(PT_STRING8,      0x8071)
#define PR_EMS_AB_DIAGNOSTIC_REG_KEY_W        PROP_TAG(PT_UNICODE,      0x8071)
#define PR_EMS_AB_DISPLAY_NAME_OVERRIDE       PROP_TAG(PT_BOOLEAN,      0x8001)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL      PROP_TAG(PT_MV_TSTRING,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_A    PROP_TAG(PT_MV_STRING8,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_W    PROP_TAG(PT_MV_UNICODE,   0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_O    PROP_TAG(PT_OBJECT,       0x8072)
#define PR_EMS_AB_DL_MEM_REJECT_PERMS_BL_T    PROP_TAG(PT_MV_TSTRING,   0x8072)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL      PROP_TAG(PT_MV_TSTRING,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_A    PROP_TAG(PT_MV_STRING8,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_W    PROP_TAG(PT_MV_UNICODE,   0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_O    PROP_TAG(PT_OBJECT,       0x8073)
#define PR_EMS_AB_DL_MEM_SUBMIT_PERMS_BL_T    PROP_TAG(PT_MV_TSTRING,   0x8073)
#define PR_EMS_AB_DL_MEMBER_RULE              PROP_TAG(PT_MV_BINARY,    0x8074)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP        PROP_TAG(PT_TSTRING,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_A      PROP_TAG(PT_STRING8,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_W      PROP_TAG(PT_UNICODE,      0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_O      PROP_TAG(PT_OBJECT,       0x8075)
#define PR_EMS_AB_DOMAIN_DEF_ALT_RECIP_T      PROP_TAG(PT_TSTRING,      0x8075)
#define PR_EMS_AB_DOMAIN_NAME                 PROP_TAG(PT_TSTRING,      0x8076)
#define PR_EMS_AB_DOMAIN_NAME_A               PROP_TAG(PT_STRING8,      0x8076)
#define PR_EMS_AB_DOMAIN_NAME_W               PROP_TAG(PT_UNICODE,      0x8076)
#define PR_EMS_AB_DSA_SIGNATURE               PROP_TAG(PT_BINARY,       0x8077)
#define PR_EMS_AB_DXA_ADMIN_COPY              PROP_TAG(PT_BOOLEAN,      0x8078)
#define PR_EMS_AB_DXA_ADMIN_FORWARD           PROP_TAG(PT_BOOLEAN,      0x8079)
#define PR_EMS_AB_DXA_ADMIN_UPDATE            PROP_TAG(PT_LONG,         0x807A)
#define PR_EMS_AB_DXA_APPEND_REQCN            PROP_TAG(PT_BOOLEAN,      0x807B)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST     PROP_TAG(PT_MV_TSTRING,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_A   PROP_TAG(PT_MV_STRING8,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_W   PROP_TAG(PT_MV_UNICODE,   0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_O   PROP_TAG(PT_OBJECT,       0x807C)
#define PR_EMS_AB_DXA_CONF_CONTAINER_LIST_T   PROP_TAG(PT_MV_TSTRING,   0x807C)
#define PR_EMS_AB_DXA_CONF_REQ_TIME           PROP_TAG(PT_SYSTIME,      0x807D)
#define PR_EMS_AB_DXA_CONF_SEQ                PROP_TAG(PT_TSTRING,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_A              PROP_TAG(PT_STRING8,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_W              PROP_TAG(PT_UNICODE,      0x807E)
#define PR_EMS_AB_DXA_CONF_SEQ_USN            PROP_TAG(PT_LONG,         0x807F)
#define PR_EMS_AB_DXA_EXCHANGE_OPTIONS        PROP_TAG(PT_LONG,         0x8080)
#define PR_EMS_AB_DXA_EXPORT_NOW              PROP_TAG(PT_BOOLEAN,      0x8081)
#define PR_EMS_AB_DXA_FLAGS                   PROP_TAG(PT_LONG,         0x8082)
#define PR_EMS_AB_DXA_IMP_SEQ                 PROP_TAG(PT_TSTRING,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_A               PROP_TAG(PT_STRING8,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_W               PROP_TAG(PT_UNICODE,      0x8083)
#define PR_EMS_AB_DXA_IMP_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x8084)
#define PR_EMS_AB_DXA_IMP_SEQ_USN             PROP_TAG(PT_LONG,         0x8085)
#define PR_EMS_AB_DXA_IMPORT_NOW              PROP_TAG(PT_BOOLEAN,      0x8086)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP         PROP_TAG(PT_MV_TSTRING,   0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_A       PROP_TAG(PT_MV_STRING8,   0x8087)
#define PR_EMS_AB_DXA_IN_TEMPLATE_MAP_W       PROP_TAG(PT_MV_UNICODE,   0x8087)
#define PR_EMS_AB_DXA_LOCAL_ADMIN             PROP_TAG(PT_TSTRING,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_A           PROP_TAG(PT_STRING8,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_W           PROP_TAG(PT_UNICODE,      0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_O           PROP_TAG(PT_OBJECT,       0x8088)
#define PR_EMS_AB_DXA_LOCAL_ADMIN_T           PROP_TAG(PT_TSTRING,      0x8088)
#define PR_EMS_AB_DXA_LOGGING_LEVEL           PROP_TAG(PT_LONG,         0x8089)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE     PROP_TAG(PT_TSTRING,      0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_A   PROP_TAG(PT_STRING8,      0x808A)
#define PR_EMS_AB_DXA_NATIVE_ADDRESS_TYPE_W   PROP_TAG(PT_UNICODE,      0x808A)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP        PROP_TAG(PT_MV_TSTRING,   0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_A      PROP_TAG(PT_MV_STRING8,   0x808B)
#define PR_EMS_AB_DXA_OUT_TEMPLATE_MAP_W      PROP_TAG(PT_MV_UNICODE,   0x808B)
#define PR_EMS_AB_DXA_PASSWORD                PROP_TAG(PT_TSTRING,      0x808C)
#define PR_EMS_AB_DXA_PASSWORD_A              PROP_TAG(PT_STRING8,      0x808C)
#define PR_EMS_AB_DXA_PASSWORD_W              PROP_TAG(PT_UNICODE,      0x808C)
#define PR_EMS_AB_DXA_PREV_EXCHANGE_OPTIONS   PROP_TAG(PT_LONG,         0x808D)
#define PR_EMS_AB_DXA_PREV_EXPORT_NATIVE_ONLY PROP_TAG(PT_BOOLEAN,      0x808E)
#define PR_EMS_AB_DXA_PREV_IN_EXCHANGE_SENSITIVITY PROP_TAG(PT_LONG,    0x808F)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES     PROP_TAG(PT_TSTRING,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_A   PROP_TAG(PT_STRING8,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_W   PROP_TAG(PT_UNICODE,      0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_O   PROP_TAG(PT_OBJECT,       0x8090)
#define PR_EMS_AB_DXA_PREV_REMOTE_ENTRIES_T   PROP_TAG(PT_TSTRING,      0x8090)
#define PR_EMS_AB_DXA_PREV_REPLICATION_SENSITIVITY PROP_TAG(PT_LONG,    0x8091)
#define PR_EMS_AB_DXA_PREV_TEMPLATE_OPTIONS   PROP_TAG(PT_LONG,         0x8092)
#define PR_EMS_AB_DXA_PREV_TYPES              PROP_TAG(PT_LONG,         0x8093)
#define PR_EMS_AB_DXA_RECIPIENT_CP            PROP_TAG(PT_TSTRING,      0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_A          PROP_TAG(PT_STRING8,      0x8094)
#define PR_EMS_AB_DXA_RECIPIENT_CP_W          PROP_TAG(PT_UNICODE,      0x8094)
#define PR_EMS_AB_DXA_REMOTE_CLIENT           PROP_TAG(PT_TSTRING,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_A         PROP_TAG(PT_STRING8,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_W         PROP_TAG(PT_UNICODE,      0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_O         PROP_TAG(PT_OBJECT,       0x8095)
#define PR_EMS_AB_DXA_REMOTE_CLIENT_T         PROP_TAG(PT_TSTRING,      0x8095)
#define PR_EMS_AB_DXA_REQ_SEQ                 PROP_TAG(PT_TSTRING,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_A               PROP_TAG(PT_STRING8,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_W               PROP_TAG(PT_UNICODE,      0x8096)
#define PR_EMS_AB_DXA_REQ_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x8097)
#define PR_EMS_AB_DXA_REQ_SEQ_USN             PROP_TAG(PT_LONG,         0x8098)
#define PR_EMS_AB_DXA_REQNAME                 PROP_TAG(PT_TSTRING,      0x8099)
#define PR_EMS_AB_DXA_REQNAME_A               PROP_TAG(PT_STRING8,      0x8099)
#define PR_EMS_AB_DXA_REQNAME_W               PROP_TAG(PT_UNICODE,      0x8099)
#define PR_EMS_AB_DXA_SVR_SEQ                 PROP_TAG(PT_TSTRING,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_A               PROP_TAG(PT_STRING8,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_W               PROP_TAG(PT_UNICODE,      0x809A)
#define PR_EMS_AB_DXA_SVR_SEQ_TIME            PROP_TAG(PT_SYSTIME,      0x809B)
#define PR_EMS_AB_DXA_SVR_SEQ_USN             PROP_TAG(PT_LONG,         0x809C)
#define PR_EMS_AB_DXA_TASK                    PROP_TAG(PT_LONG,         0x809D)
#define PR_EMS_AB_DXA_TEMPLATE_OPTIONS        PROP_TAG(PT_LONG,         0x809E)
#define PR_EMS_AB_DXA_TEMPLATE_TIMESTAMP      PROP_TAG(PT_SYSTIME,      0x809F)
#define PR_EMS_AB_DXA_TYPES                   PROP_TAG(PT_LONG,         0x80A0)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST   PROP_TAG(PT_MV_TSTRING,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_A PROP_TAG(PT_MV_STRING8,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_W PROP_TAG(PT_MV_UNICODE,   0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_O PROP_TAG(PT_OBJECT,       0x80A1)
#define PR_EMS_AB_DXA_UNCONF_CONTAINER_LIST_T PROP_TAG(PT_MV_TSTRING,   0x80A1)
#define PR_EMS_AB_ENCAPSULATION_METHOD        PROP_TAG(PT_LONG,         0x80A2)
#define PR_EMS_AB_ENCRYPT                     PROP_TAG(PT_BOOLEAN,      0x80A3)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA         PROP_TAG(PT_MV_TSTRING,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_A       PROP_TAG(PT_MV_STRING8,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_NA_W       PROP_TAG(PT_MV_UNICODE,   0x8040)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER      PROP_TAG(PT_MV_TSTRING,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_A    PROP_TAG(PT_MV_STRING8,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_LIST_OTHER_W    PROP_TAG(PT_MV_UNICODE,   0x8041)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA     PROP_TAG(PT_TSTRING,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_A   PROP_TAG(PT_STRING8,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_NA_W   PROP_TAG(PT_UNICODE,      0x8043)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER  PROP_TAG(PT_TSTRING,      0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_A PROP_TAG(PT_STRING8,     0x803D)
#define PR_EMS_AB_ENCRYPT_ALG_SELECTED_OTHER_W PROP_TAG(PT_UNICODE,     0x803D)
#define PR_EMS_AB_EXPAND_DLS_LOCALLY          PROP_TAG(PT_BOOLEAN,      0x80A4)
#define PR_EMS_AB_EXPIRATION_TIME             PROP_TAG(PT_SYSTIME,      0x8028)
#define PR_EMS_AB_EXPORT_CONTAINERS           PROP_TAG(PT_MV_TSTRING,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_A         PROP_TAG(PT_MV_STRING8,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_W         PROP_TAG(PT_MV_UNICODE,   0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_O         PROP_TAG(PT_OBJECT,       0x80A5)
#define PR_EMS_AB_EXPORT_CONTAINERS_T         PROP_TAG(PT_MV_TSTRING,   0x80A5)
#define PR_EMS_AB_EXPORT_CUSTOM_RECIPIENTS    PROP_TAG(PT_BOOLEAN,      0x80A6)
#define PR_EMS_AB_EXTENDED_CHARS_ALLOWED      PROP_TAG(PT_BOOLEAN,      0x80A7)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1       PROP_TAG(PT_TSTRING,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_A     PROP_TAG(PT_STRING8,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_1_W     PROP_TAG(PT_UNICODE,      0x802D)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10      PROP_TAG(PT_TSTRING,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_A    PROP_TAG(PT_STRING8,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_10_W    PROP_TAG(PT_UNICODE,      0x8036)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2       PROP_TAG(PT_TSTRING,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_A     PROP_TAG(PT_STRING8,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_2_W     PROP_TAG(PT_UNICODE,      0x802E)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3       PROP_TAG(PT_TSTRING,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_A     PROP_TAG(PT_STRING8,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_3_W     PROP_TAG(PT_UNICODE,      0x802F)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4       PROP_TAG(PT_TSTRING,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_A     PROP_TAG(PT_STRING8,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_4_W     PROP_TAG(PT_UNICODE,      0x8030)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5       PROP_TAG(PT_TSTRING,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_A     PROP_TAG(PT_STRING8,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_5_W     PROP_TAG(PT_UNICODE,      0x8031)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6       PROP_TAG(PT_TSTRING,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_A     PROP_TAG(PT_STRING8,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_6_W     PROP_TAG(PT_UNICODE,      0x8032)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7       PROP_TAG(PT_TSTRING,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_A     PROP_TAG(PT_STRING8,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_7_W     PROP_TAG(PT_UNICODE,      0x8033)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8       PROP_TAG(PT_TSTRING,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_A     PROP_TAG(PT_STRING8,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_8_W     PROP_TAG(PT_UNICODE,      0x8034)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9       PROP_TAG(PT_TSTRING,      0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_A     PROP_TAG(PT_STRING8,      0x8035)
#define PR_EMS_AB_EXTENSION_ATTRIBUTE_9_W     PROP_TAG(PT_UNICODE,      0x8035)
#define PR_EMS_AB_EXTENSION_DATA              PROP_TAG(PT_MV_BINARY,    0x80A8)
#define PR_EMS_AB_EXTENSION_NAME              PROP_TAG(PT_MV_TSTRING,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_A            PROP_TAG(PT_MV_STRING8,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_W            PROP_TAG(PT_MV_UNICODE,   0x80A9)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED    PROP_TAG(PT_MV_TSTRING,   0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_A  PROP_TAG(PT_MV_STRING8,   0x80AA)
#define PR_EMS_AB_EXTENSION_NAME_INHERITED_W  PROP_TAG(PT_MV_UNICODE,   0x80AA)
#define PR_EMS_AB_FACSIMILE_TELEPHONE_NUMBER  PROP_TAG(PT_MV_BINARY,    0x80AB)
#define PR_EMS_AB_FILE_VERSION                PROP_TAG(PT_BINARY,       0x80AC)
#define PR_EMS_AB_FILTER_LOCAL_ADDRESSES      PROP_TAG(PT_BOOLEAN,      0x80AD)
#define PR_EMS_AB_FOLDER_PATHNAME             PROP_TAG(PT_TSTRING,      0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_A           PROP_TAG(PT_STRING8,      0x8004)
#define PR_EMS_AB_FOLDER_PATHNAME_W           PROP_TAG(PT_UNICODE,      0x8004)
#define PR_EMS_AB_FOLDERS_CONTAINER           PROP_TAG(PT_TSTRING,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_A         PROP_TAG(PT_STRING8,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_W         PROP_TAG(PT_UNICODE,      0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_O         PROP_TAG(PT_OBJECT,       0x80AE)
#define PR_EMS_AB_FOLDERS_CONTAINER_T         PROP_TAG(PT_TSTRING,      0x80AE)
#define PR_EMS_AB_GARBAGE_COLL_PERIOD         PROP_TAG(PT_LONG,         0x80AF)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED          PROP_TAG(PT_TSTRING,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_A        PROP_TAG(PT_STRING8,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_CRED_W        PROP_TAG(PT_UNICODE,      0x80B0)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG         PROP_TAG(PT_TSTRING,      0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_A       PROP_TAG(PT_STRING8,      0x80B1)
#define PR_EMS_AB_GATEWAY_LOCAL_DESIG_W       PROP_TAG(PT_UNICODE,      0x80B1)
#define PR_EMS_AB_GATEWAY_PROXY               PROP_TAG(PT_MV_TSTRING,   0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_A             PROP_TAG(PT_MV_STRING8,   0x80B2)
#define PR_EMS_AB_GATEWAY_PROXY_W             PROP_TAG(PT_MV_UNICODE,   0x80B2)
#define PR_EMS_AB_GATEWAY_ROUTING_TREE        PROP_TAG(PT_BINARY,       0x80B3)
#define PR_EMS_AB_GWART_LAST_MODIFIED         PROP_TAG(PT_SYSTIME,      0x80B4)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS        PROP_TAG(PT_MV_TSTRING,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_A      PROP_TAG(PT_MV_STRING8,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_W      PROP_TAG(PT_MV_UNICODE,   0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_O      PROP_TAG(PT_OBJECT,       0x80B5)
#define PR_EMS_AB_HAS_FULL_REPLICA_NCS_T      PROP_TAG(PT_MV_TSTRING,   0x80B5)
#define PR_EMS_AB_HAS_MASTER_NCS              PROP_TAG(PT_MV_TSTRING,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_A            PROP_TAG(PT_MV_STRING8,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_W            PROP_TAG(PT_MV_UNICODE,   0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_O            PROP_TAG(PT_OBJECT,       0x80B6)
#define PR_EMS_AB_HAS_MASTER_NCS_T            PROP_TAG(PT_MV_TSTRING,   0x80B6)
#define PR_EMS_AB_HELP_DATA16                 PROP_TAG(PT_BINARY,       0x803A)
#define PR_EMS_AB_HELP_DATA32                 PROP_TAG(PT_BINARY,       0x8010)
#define PR_EMS_AB_HELP_FILE_NAME              PROP_TAG(PT_TSTRING,      0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_A            PROP_TAG(PT_STRING8,      0x803B)
#define PR_EMS_AB_HELP_FILE_NAME_W            PROP_TAG(PT_UNICODE,      0x803B)
#define PR_EMS_AB_HEURISTICS                  PROP_TAG(PT_LONG,         0x80B7)
#define PR_EMS_AB_HIDE_DL_MEMBERSHIP          PROP_TAG(PT_BOOLEAN,      0x80B8)
#define PR_EMS_AB_HIDE_FROM_ADDRESS_BOOK      PROP_TAG(PT_BOOLEAN,      0x80B9)
#define PR_EMS_AB_HOME_MDB                    PROP_TAG(PT_TSTRING,      0x8006)
#define PR_EMS_AB_HOME_MDB_A                  PROP_TAG(PT_STRING8,      0x8006)
#define PR_EMS_AB_HOME_MDB_W                  PROP_TAG(PT_UNICODE,      0x8006)
#define PR_EMS_AB_HOME_MDB_O                  PROP_TAG(PT_OBJECT,       0x8006)
#define PR_EMS_AB_HOME_MDB_T                  PROP_TAG(PT_TSTRING,      0x8006)
#define PR_EMS_AB_HOME_MDB_BL                 PROP_TAG(PT_MV_TSTRING,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_A               PROP_TAG(PT_MV_STRING8,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_W               PROP_TAG(PT_MV_UNICODE,   0x8014)
#define PR_EMS_AB_HOME_MDB_BL_O               PROP_TAG(PT_OBJECT,       0x8014)
#define PR_EMS_AB_HOME_MDB_BL_T               PROP_TAG(PT_MV_TSTRING,   0x8014)
#define PR_EMS_AB_HOME_MTA                    PROP_TAG(PT_TSTRING,      0x8007)
#define PR_EMS_AB_HOME_MTA_A                  PROP_TAG(PT_STRING8,      0x8007)
#define PR_EMS_AB_HOME_MTA_W                  PROP_TAG(PT_UNICODE,      0x8007)
#define PR_EMS_AB_HOME_MTA_O                  PROP_TAG(PT_OBJECT,       0x8007)
#define PR_EMS_AB_HOME_MTA_T                  PROP_TAG(PT_TSTRING,      0x8007)
#define PR_EMS_AB_HOME_PUBLIC_SERVER          PROP_TAG(PT_TSTRING,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_A        PROP_TAG(PT_STRING8,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_W        PROP_TAG(PT_UNICODE,      0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_O        PROP_TAG(PT_OBJECT,       0x803F)
#define PR_EMS_AB_HOME_PUBLIC_SERVER_T        PROP_TAG(PT_TSTRING,      0x803F)
#define PR_EMS_AB_IMPORT_CONTAINER            PROP_TAG(PT_TSTRING,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_A          PROP_TAG(PT_STRING8,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_W          PROP_TAG(PT_UNICODE,      0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_O          PROP_TAG(PT_OBJECT,       0x80BA)
#define PR_EMS_AB_IMPORT_CONTAINER_T          PROP_TAG(PT_TSTRING,      0x80BA)
#define PR_EMS_AB_IMPORT_SENSITIVITY          PROP_TAG(PT_LONG,         0x80BB)
#define PR_EMS_AB_IMPORTED_FROM               PROP_TAG(PT_TSTRING,      0x8042)
#define PR_EMS_AB_IMPORTED_FROM_A             PROP_TAG(PT_STRING8,      0x8042)
#define PR_EMS_AB_IMPORTED_FROM_W             PROP_TAG(PT_UNICODE,      0x8042)
#define PR_EMS_AB_INBOUND_SITES               PROP_TAG(PT_MV_TSTRING,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_A             PROP_TAG(PT_MV_STRING8,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_W             PROP_TAG(PT_MV_UNICODE,   0x80BC)
#define PR_EMS_AB_INBOUND_SITES_O             PROP_TAG(PT_OBJECT,       0x80BC)
#define PR_EMS_AB_INBOUND_SITES_T             PROP_TAG(PT_MV_TSTRING,   0x80BC)
#define PR_EMS_AB_INSTANCE_TYPE               PROP_TAG(PT_LONG,         0x80BD)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER   PROP_TAG(PT_MV_TSTRING,   0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_A PROP_TAG(PT_MV_STRING8,   0x80BE)
#define PR_EMS_AB_INTERNATIONAL_ISDN_NUMBER_W PROP_TAG(PT_MV_UNICODE,   0x80BE)
#define PR_EMS_AB_INVOCATION_ID               PROP_TAG(PT_BINARY,       0x80BF)
#define PR_EMS_AB_IS_DELETED                  PROP_TAG(PT_BOOLEAN,      0x80C0)
#define PR_EMS_AB_IS_MEMBER_OF_DL             PROP_TAG(PT_OBJECT,       0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_A           PROP_TAG(PT_MV_STRING8,   0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_W           PROP_TAG(PT_MV_UNICODE,   0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_O           PROP_TAG(PT_OBJECT,       0x8008)
#define PR_EMS_AB_IS_MEMBER_OF_DL_T           PROP_TAG(PT_MV_TSTRING,   0x8008)
#define PR_EMS_AB_IS_SINGLE_VALUED            PROP_TAG(PT_BOOLEAN,      0x80C1)
#define PR_EMS_AB_KCC_STATUS                  PROP_TAG(PT_MV_BINARY,    0x80C2)
#define PR_EMS_AB_KM_SERVER                   PROP_TAG(PT_TSTRING,      0x800D)
#define PR_EMS_AB_KM_SERVER_A                 PROP_TAG(PT_STRING8,      0x800D)
#define PR_EMS_AB_KM_SERVER_W                 PROP_TAG(PT_UNICODE,      0x800D)
#define PR_EMS_AB_KM_SERVER_O                 PROP_TAG(PT_OBJECT,       0x800D)
#define PR_EMS_AB_KM_SERVER_T                 PROP_TAG(PT_TSTRING,      0x800D)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION       PROP_TAG(PT_MV_TSTRING,   0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_A     PROP_TAG(PT_MV_STRING8,   0x80C3)
#define PR_EMS_AB_KNOWLEDGE_INFORMATION_W     PROP_TAG(PT_MV_UNICODE,   0x80C3)
#define PR_EMS_AB_LINE_WRAP                   PROP_TAG(PT_LONG,         0x80C4)
#define PR_EMS_AB_LINK_ID                     PROP_TAG(PT_LONG,         0x80C5)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD           PROP_TAG(PT_TSTRING,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_A         PROP_TAG(PT_STRING8,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_W         PROP_TAG(PT_UNICODE,      0x80C6)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS   PROP_TAG(PT_TSTRING,      0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_A PROP_TAG(PT_STRING8,      0x80C7)
#define PR_EMS_AB_LOCAL_BRIDGE_HEAD_ADDRESS_W PROP_TAG(PT_UNICODE,      0x80C7)
#define PR_EMS_AB_LOCAL_INITIAL_TURN          PROP_TAG(PT_BOOLEAN,      0x80C8)
#define PR_EMS_AB_LOCAL_SCOPE                 PROP_TAG(PT_MV_TSTRING,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_A               PROP_TAG(PT_MV_STRING8,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_W               PROP_TAG(PT_MV_UNICODE,   0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_O               PROP_TAG(PT_OBJECT,       0x80C9)
#define PR_EMS_AB_LOCAL_SCOPE_T               PROP_TAG(PT_MV_TSTRING,   0x80C9)
#define PR_EMS_AB_LOG_FILENAME                PROP_TAG(PT_TSTRING,      0x80CA)
#define PR_EMS_AB_LOG_FILENAME_A              PROP_TAG(PT_STRING8,      0x80CA)
#define PR_EMS_AB_LOG_FILENAME_W              PROP_TAG(PT_UNICODE,      0x80CA)
#define PR_EMS_AB_LOG_ROLLOVER_INTERVAL       PROP_TAG(PT_LONG,         0x80CB)
#define PR_EMS_AB_MAINTAIN_AUTOREPLY_HISTORY  PROP_TAG(PT_BOOLEAN,      0x80CC)
#define PR_EMS_AB_MANAGER                     PROP_TAG(PT_OBJECT,       0x8005)
#define PR_EMS_AB_MANAGER_A                   PROP_TAG(PT_STRING8,      0x8005)
#define PR_EMS_AB_MANAGER_W                   PROP_TAG(PT_UNICODE,      0x8005)
#define PR_EMS_AB_MANAGER_O                   PROP_TAG(PT_OBJECT,       0x8005)
#define PR_EMS_AB_MANAGER_T                   PROP_TAG(PT_TSTRING,      0x8005)
#define PR_EMS_AB_MAPI_DISPLAY_TYPE           PROP_TAG(PT_LONG,         0x80CD)
#define PR_EMS_AB_MAPI_ID                     PROP_TAG(PT_LONG,         0x80CE)
#define PR_EMS_AB_MAXIMUM_OBJECT_ID           PROP_TAG(PT_BINARY,       0x8169)
#define PR_EMS_AB_MDB_BACKOFF_INTERVAL        PROP_TAG(PT_LONG,         0x80CF)
#define PR_EMS_AB_MDB_MSG_TIME_OUT_PERIOD     PROP_TAG(PT_LONG,         0x80D0)
#define PR_EMS_AB_MDB_OVER_QUOTA_LIMIT        PROP_TAG(PT_LONG,         0x80D1)
#define PR_EMS_AB_MDB_STORAGE_QUOTA           PROP_TAG(PT_LONG,         0x80D2)
#define PR_EMS_AB_MDB_UNREAD_LIMIT            PROP_TAG(PT_LONG,         0x80D3)
#define PR_EMS_AB_MDB_USE_DEFAULTS            PROP_TAG(PT_BOOLEAN,      0x80D4)
#define PR_EMS_AB_MEMBER                      PROP_TAG(PT_OBJECT,       0x8009)
#define PR_EMS_AB_MEMBER_A                    PROP_TAG(PT_MV_STRING8,   0x8009)
#define PR_EMS_AB_MEMBER_W                    PROP_TAG(PT_MV_UNICODE,   0x8009)
#define PR_EMS_AB_MEMBER_O                    PROP_TAG(PT_OBJECT,       0x8009)
#define PR_EMS_AB_MEMBER_T                    PROP_TAG(PT_MV_TSTRING,   0x8009)
#define PR_EMS_AB_MESSAGE_TRACKING_ENABLED    PROP_TAG(PT_BOOLEAN,      0x80D5)
#define PR_EMS_AB_MONITOR_CLOCK               PROP_TAG(PT_BOOLEAN,      0x80D6)
#define PR_EMS_AB_MONITOR_SERVERS             PROP_TAG(PT_BOOLEAN,      0x80D7)
#define PR_EMS_AB_MONITOR_SERVICES            PROP_TAG(PT_BOOLEAN,      0x80D8)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS    PROP_TAG(PT_MV_TSTRING,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_A  PROP_TAG(PT_MV_STRING8,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_W  PROP_TAG(PT_MV_UNICODE,   0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_O  PROP_TAG(PT_OBJECT,       0x80D9)
#define PR_EMS_AB_MONITORED_CONFIGURATIONS_T  PROP_TAG(PT_MV_TSTRING,   0x80D9)
#define PR_EMS_AB_MONITORED_SERVERS           PROP_TAG(PT_MV_TSTRING,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_A         PROP_TAG(PT_MV_STRING8,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_W         PROP_TAG(PT_MV_UNICODE,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_O         PROP_TAG(PT_OBJECT,       0x80DA)
#define PR_EMS_AB_MONITORED_SERVERS_T         PROP_TAG(PT_MV_TSTRING,   0x80DA)
#define PR_EMS_AB_MONITORED_SERVICES          PROP_TAG(PT_MV_TSTRING,   0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_A        PROP_TAG(PT_MV_STRING8,   0x80DB)
#define PR_EMS_AB_MONITORED_SERVICES_W        PROP_TAG(PT_MV_UNICODE,   0x80DB)
#define PR_EMS_AB_MONITORING_ALERT_DELAY      PROP_TAG(PT_LONG,         0x80DC)
#define PR_EMS_AB_MONITORING_ALERT_UNITS      PROP_TAG(PT_LONG,         0x80DD)
#define PR_EMS_AB_MONITORING_AVAILABILITY_STYLE PROP_TAG(PT_LONG,       0x80DE)
#define PR_EMS_AB_MONITORING_AVAILABILITY_WINDOW PROP_TAG(PT_BINARY,    0x80DF)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL  PROP_TAG(PT_MV_TSTRING,   0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_A PROP_TAG(PT_MV_STRING8,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_W PROP_TAG(PT_MV_UNICODE,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_O PROP_TAG(PT_OBJECT,      0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_MAIL_T PROP_TAG(PT_MV_TSTRING,  0x80E0)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC   PROP_TAG(PT_MV_TSTRING,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_A PROP_TAG(PT_MV_STRING8,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_W PROP_TAG(PT_MV_UNICODE,   0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_O PROP_TAG(PT_OBJECT,       0x80E1)
#define PR_EMS_AB_MONITORING_CACHED_VIA_RPC_T PROP_TAG(PT_MV_TSTRING,   0x80E1)
#define PR_EMS_AB_MONITORING_ESCALATION_PROCEDURE PROP_TAG(PT_MV_BINARY,0x80E2)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_INTERVAL PROP_TAG(PT_LONG,    0x80E3)
#define PR_EMS_AB_MONITORING_HOTSITE_POLL_UNITS PROP_TAG(PT_LONG,       0x80E4)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_INTERVAL PROP_TAG(PT_LONG,     0x80E5)
#define PR_EMS_AB_MONITORING_MAIL_UPDATE_UNITS PROP_TAG(PT_LONG,        0x80E6)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_INTERVAL PROP_TAG(PT_LONG,     0x80E7)
#define PR_EMS_AB_MONITORING_NORMAL_POLL_UNITS PROP_TAG(PT_LONG,        0x80E8)
#define PR_EMS_AB_MONITORING_RECIPIENTS       PROP_TAG(PT_MV_TSTRING,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_A     PROP_TAG(PT_MV_STRING8,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_W     PROP_TAG(PT_MV_UNICODE,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_O     PROP_TAG(PT_OBJECT,       0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_T     PROP_TAG(PT_MV_TSTRING,   0x80E9)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR   PROP_TAG(PT_MV_TSTRING,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_A PROP_TAG(PT_MV_STRING8,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_W PROP_TAG(PT_MV_UNICODE,   0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_O PROP_TAG(PT_OBJECT,       0x80EA)
#define PR_EMS_AB_MONITORING_RECIPIENTS_NDR_T PROP_TAG(PT_MV_TSTRING,   0x80EA)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_INTERVAL PROP_TAG(PT_LONG,      0x80EB)
#define PR_EMS_AB_MONITORING_RPC_UPDATE_UNITS PROP_TAG(PT_LONG,         0x80EC)
#define PR_EMS_AB_MONITORING_WARNING_DELAY    PROP_TAG(PT_LONG,         0x80ED)
#define PR_EMS_AB_MONITORING_WARNING_UNITS    PROP_TAG(PT_LONG,         0x80EE)
#define PR_EMS_AB_MTA_LOCAL_CRED              PROP_TAG(PT_TSTRING,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_A            PROP_TAG(PT_STRING8,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_CRED_W            PROP_TAG(PT_UNICODE,      0x80EF)
#define PR_EMS_AB_MTA_LOCAL_DESIG             PROP_TAG(PT_TSTRING,      0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_A           PROP_TAG(PT_STRING8,      0x80F0)
#define PR_EMS_AB_MTA_LOCAL_DESIG_W           PROP_TAG(PT_UNICODE,      0x80F0)
#define PR_EMS_AB_N_ADDRESS                   PROP_TAG(PT_BINARY,       0x80F1)
#define PR_EMS_AB_N_ADDRESS_TYPE              PROP_TAG(PT_LONG,         0x80F2)
#define PR_EMS_AB_NETWORK_ADDRESS             PROP_TAG(PT_MV_TSTRING,   0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_A           PROP_TAG(PT_MV_STRING8,   0x8170)
#define PR_EMS_AB_NETWORK_ADDRESS_W           PROP_TAG(PT_MV_UNICODE,   0x8170)
#define PR_EMS_AB_NT_MACHINE_NAME             PROP_TAG(PT_TSTRING,      0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_A           PROP_TAG(PT_STRING8,      0x80F3)
#define PR_EMS_AB_NT_MACHINE_NAME_W           PROP_TAG(PT_UNICODE,      0x80F3)
#define PR_EMS_AB_NT_SECURITY_DESCRIPTOR      PROP_TAG(PT_BINARY,       0x8013)
#define PR_EMS_AB_NUM_OF_OPEN_RETRIES         PROP_TAG(PT_LONG,         0x80F4)
#define PR_EMS_AB_NUM_OF_TRANSFER_RETRIES     PROP_TAG(PT_LONG,         0x80F5)
#define PR_EMS_AB_OBJ_DIST_NAME               PROP_TAG(PT_TSTRING,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_A             PROP_TAG(PT_STRING8,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_W             PROP_TAG(PT_UNICODE,      0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_O             PROP_TAG(PT_OBJECT,       0x803C)
#define PR_EMS_AB_OBJ_DIST_NAME_T             PROP_TAG(PT_TSTRING,      0x803C)
#define PR_EMS_AB_OBJECT_CLASS_CATEGORY       PROP_TAG(PT_LONG,         0x80F6)
#define PR_EMS_AB_OBJECT_VERSION              PROP_TAG(PT_LONG,         0x80F7)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS      PROP_TAG(PT_MV_TSTRING,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_A    PROP_TAG(PT_MV_STRING8,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_W    PROP_TAG(PT_MV_UNICODE,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_O    PROP_TAG(PT_OBJECT,       0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_CONTAINERS_T    PROP_TAG(PT_MV_TSTRING,   0x80F8)
#define PR_EMS_AB_OFF_LINE_AB_SCHEDULE        PROP_TAG(PT_BINARY,       0x80F9)
#define PR_EMS_AB_OFF_LINE_AB_SERVER          PROP_TAG(PT_TSTRING,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_A        PROP_TAG(PT_STRING8,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_W        PROP_TAG(PT_UNICODE,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_O        PROP_TAG(PT_OBJECT,       0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_SERVER_T        PROP_TAG(PT_TSTRING,      0x80FA)
#define PR_EMS_AB_OFF_LINE_AB_STYLE           PROP_TAG(PT_LONG,         0x80FB)
#define PR_EMS_AB_OID_TYPE                    PROP_TAG(PT_LONG,         0x80FC)
#define PR_EMS_AB_OM_OBJECT_CLASS             PROP_TAG(PT_BINARY,       0x80FD)
#define PR_EMS_AB_OM_SYNTAX                   PROP_TAG(PT_LONG,         0x80FE)
#define PR_EMS_AB_OOF_REPLY_TO_ORIGINATOR     PROP_TAG(PT_BOOLEAN,      0x80FF)
#define PR_EMS_AB_OPEN_RETRY_INTERVAL         PROP_TAG(PT_LONG,         0x8100)
#define PR_EMS_AB_ORGANIZATION_NAME           PROP_TAG(PT_MV_TSTRING,   0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_A         PROP_TAG(PT_MV_STRING8,   0x8101)
#define PR_EMS_AB_ORGANIZATION_NAME_W         PROP_TAG(PT_MV_UNICODE,   0x8101)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME    PROP_TAG(PT_MV_TSTRING,   0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_A  PROP_TAG(PT_MV_STRING8,   0x8102)
#define PR_EMS_AB_ORGANIZATIONAL_UNIT_NAME_W  PROP_TAG(PT_MV_UNICODE,   0x8102)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE      PROP_TAG(PT_BINARY,       0x8103)
#define PR_EMS_AB_ORIGINAL_DISPLAY_TABLE_MSDOS PROP_TAG(PT_BINARY,      0x8104)
#define PR_EMS_AB_OUTBOUND_SITES              PROP_TAG(PT_MV_TSTRING,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_A            PROP_TAG(PT_MV_STRING8,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_W            PROP_TAG(PT_MV_UNICODE,   0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_O            PROP_TAG(PT_OBJECT,       0x8105)
#define PR_EMS_AB_OUTBOUND_SITES_T            PROP_TAG(PT_MV_TSTRING,   0x8105)
#define PR_EMS_AB_OWNER                       PROP_TAG(PT_TSTRING,      0x800C)
#define PR_EMS_AB_OWNER_A                     PROP_TAG(PT_STRING8,      0x800C)
#define PR_EMS_AB_OWNER_W                     PROP_TAG(PT_UNICODE,      0x800C)
#define PR_EMS_AB_OWNER_O                     PROP_TAG(PT_OBJECT,       0x800C)
#define PR_EMS_AB_OWNER_T                     PROP_TAG(PT_TSTRING,      0x800C)
#define PR_EMS_AB_OWNER_BL                    PROP_TAG(PT_TSTRING,      0x8024)
#define PR_EMS_AB_OWNER_BL_A                  PROP_TAG(PT_STRING8,      0x8024)
#define PR_EMS_AB_OWNER_BL_W                  PROP_TAG(PT_UNICODE,      0x8024)
#define PR_EMS_AB_OWNER_BL_O                  PROP_TAG(PT_OBJECT,       0x8024)
#define PR_EMS_AB_OWNER_BL_T                  PROP_TAG(PT_TSTRING,      0x8024)
#define PR_EMS_AB_P_SELECTOR                  PROP_TAG(PT_BINARY,       0x8106)
#define PR_EMS_AB_P_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x8107)
#define PR_EMS_AB_PER_MSG_DIALOG_DISPLAY_TABLE PROP_TAG(PT_BINARY,      0x8108)
#define PR_EMS_AB_PER_RECIP_DIALOG_DISPLAY_TABLE PROP_TAG(PT_BINARY,    0x8109)
#define PR_EMS_AB_PERIOD_REP_SYNC_TIMES       PROP_TAG(PT_BINARY,       0x810A)
#define PR_EMS_AB_PERIOD_REPL_STAGGER         PROP_TAG(PT_LONG,         0x810B)
#define PR_EMS_AB_PF_CONTACTS                 PROP_TAG(PT_MV_TSTRING,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_A               PROP_TAG(PT_MV_STRING8,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_W               PROP_TAG(PT_MV_UNICODE,   0x8038)
#define PR_EMS_AB_PF_CONTACTS_O               PROP_TAG(PT_OBJECT,       0x8038)
#define PR_EMS_AB_PF_CONTACTS_T               PROP_TAG(PT_MV_TSTRING,   0x8038)
#define PR_EMS_AB_POSTAL_ADDRESS              PROP_TAG(PT_MV_BINARY,    0x810C)
#define PR_EMS_AB_PREFERRED_DELIVERY_METHOD   PROP_TAG(PT_MV_LONG,      0x810D)
#define PR_EMS_AB_PRMD                        PROP_TAG(PT_TSTRING,      0x810E)
#define PR_EMS_AB_PRMD_A                      PROP_TAG(PT_STRING8,      0x810E)
#define PR_EMS_AB_PRMD_W                      PROP_TAG(PT_UNICODE,      0x810E)
#define PR_EMS_AB_PROXY_ADDRESSES             PROP_TAG(PT_MV_TSTRING,   0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_A           PROP_TAG(PT_MV_STRING8,   0x800F)
#define PR_EMS_AB_PROXY_ADDRESSES_W           PROP_TAG(PT_MV_UNICODE,   0x800F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL         PROP_TAG(PT_TSTRING,      0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_A       PROP_TAG(PT_STRING8,      0x810F)
#define PR_EMS_AB_PROXY_GENERATOR_DLL_W       PROP_TAG(PT_UNICODE,      0x810F)
#define PR_EMS_AB_PUBLIC_DELEGATES            PROP_TAG(PT_OBJECT,       0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_A          PROP_TAG(PT_MV_STRING8,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_W          PROP_TAG(PT_MV_UNICODE,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_O          PROP_TAG(PT_OBJECT,       0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_T          PROP_TAG(PT_MV_TSTRING,   0x8015)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL         PROP_TAG(PT_MV_TSTRING,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_A       PROP_TAG(PT_MV_STRING8,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_W       PROP_TAG(PT_MV_UNICODE,   0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_O       PROP_TAG(PT_OBJECT,       0x8110)
#define PR_EMS_AB_PUBLIC_DELEGATES_BL_T       PROP_TAG(PT_MV_TSTRING,   0x8110)
#define PR_EMS_AB_QUOTA_NOTIFICATION_SCHEDULE PROP_TAG(PT_BINARY,       0x8111)
#define PR_EMS_AB_QUOTA_NOTIFICATION_STYLE    PROP_TAG(PT_LONG,         0x8112)
#define PR_EMS_AB_RANGE_LOWER                 PROP_TAG(PT_LONG,         0x8113)
#define PR_EMS_AB_RANGE_UPPER                 PROP_TAG(PT_LONG,         0x8114)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER         PROP_TAG(PT_TSTRING,      0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_A       PROP_TAG(PT_STRING8,      0x8115)
#define PR_EMS_AB_RAS_CALLBACK_NUMBER_W       PROP_TAG(PT_UNICODE,      0x8115)
#define PR_EMS_AB_RAS_PHONE_NUMBER            PROP_TAG(PT_TSTRING,      0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_A          PROP_TAG(PT_STRING8,      0x8116)
#define PR_EMS_AB_RAS_PHONE_NUMBER_W          PROP_TAG(PT_UNICODE,      0x8116)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME    PROP_TAG(PT_TSTRING,      0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_A  PROP_TAG(PT_STRING8,      0x8117)
#define PR_EMS_AB_RAS_PHONEBOOK_ENTRY_NAME_W  PROP_TAG(PT_UNICODE,      0x8117)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME        PROP_TAG(PT_TSTRING,      0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_A      PROP_TAG(PT_STRING8,      0x8118)
#define PR_EMS_AB_RAS_REMOTE_SRVR_NAME_W      PROP_TAG(PT_UNICODE,      0x8118)
#define PR_EMS_AB_REGISTERED_ADDRESS          PROP_TAG(PT_MV_BINARY,    0x8119)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD          PROP_TAG(PT_TSTRING,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_A        PROP_TAG(PT_STRING8,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_W        PROP_TAG(PT_UNICODE,      0x811A)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS  PROP_TAG(PT_TSTRING,      0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_A PROP_TAG(PT_STRING8,     0x811B)
#define PR_EMS_AB_REMOTE_BRIDGE_HEAD_ADDRESS_W PROP_TAG(PT_UNICODE,     0x811B)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER        PROP_TAG(PT_TSTRING,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_A      PROP_TAG(PT_STRING8,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_W      PROP_TAG(PT_UNICODE,      0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_O      PROP_TAG(PT_OBJECT,       0x811C)
#define PR_EMS_AB_REMOTE_OUT_BH_SERVER_T      PROP_TAG(PT_TSTRING,      0x811C)
#define PR_EMS_AB_REMOTE_SITE                 PROP_TAG(PT_TSTRING,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_A               PROP_TAG(PT_STRING8,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_W               PROP_TAG(PT_UNICODE,      0x811D)
#define PR_EMS_AB_REMOTE_SITE_O               PROP_TAG(PT_OBJECT,       0x811D)
#define PR_EMS_AB_REMOTE_SITE_T               PROP_TAG(PT_TSTRING,      0x811D)
#define PR_EMS_AB_REPLICATION_MAIL_MSG_SIZE   PROP_TAG(PT_LONG,         0x8168)
#define PR_EMS_AB_REPLICATION_SENSITIVITY     PROP_TAG(PT_LONG,         0x811E)
#define PR_EMS_AB_REPLICATION_STAGGER         PROP_TAG(PT_LONG,         0x811F)
#define PR_EMS_AB_REPORT_TO_ORIGINATOR        PROP_TAG(PT_BOOLEAN,      0x8120)
#define PR_EMS_AB_REPORT_TO_OWNER             PROP_TAG(PT_BOOLEAN,      0x8121)
#define PR_EMS_AB_REPORTS                     PROP_TAG(PT_OBJECT,       0x800E)
#define PR_EMS_AB_REPORTS_A                   PROP_TAG(PT_MV_STRING8,   0x800E)
#define PR_EMS_AB_REPORTS_W                   PROP_TAG(PT_MV_UNICODE,   0x800E)
#define PR_EMS_AB_REPORTS_O                   PROP_TAG(PT_OBJECT,       0x800E)
#define PR_EMS_AB_REPORTS_T                   PROP_TAG(PT_MV_TSTRING,   0x800E)
#define PR_EMS_AB_REQ_SEQ                     PROP_TAG(PT_LONG,         0x8122)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA       PROP_TAG(PT_TSTRING,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_A     PROP_TAG(PT_STRING8,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_W     PROP_TAG(PT_UNICODE,      0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_O     PROP_TAG(PT_OBJECT,       0x8123)
#define PR_EMS_AB_RESPONSIBLE_LOCAL_DXA_T     PROP_TAG(PT_TSTRING,      0x8123)
#define PR_EMS_AB_RID_SERVER                  PROP_TAG(PT_TSTRING,      0x8124)
#define PR_EMS_AB_RID_SERVER_A                PROP_TAG(PT_STRING8,      0x8124)
#define PR_EMS_AB_RID_SERVER_W                PROP_TAG(PT_UNICODE,      0x8124)
#define PR_EMS_AB_RID_SERVER_O                PROP_TAG(PT_OBJECT,       0x8124)
#define PR_EMS_AB_RID_SERVER_T                PROP_TAG(PT_TSTRING,      0x8124)
#define PR_EMS_AB_ROLE_OCCUPANT               PROP_TAG(PT_MV_TSTRING,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_A             PROP_TAG(PT_MV_STRING8,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_W             PROP_TAG(PT_MV_UNICODE,   0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_O             PROP_TAG(PT_OBJECT,       0x8125)
#define PR_EMS_AB_ROLE_OCCUPANT_T             PROP_TAG(PT_MV_TSTRING,   0x8125)
#define PR_EMS_AB_ROUTING_LIST                PROP_TAG(PT_MV_TSTRING,   0x8126)
#define PR_EMS_AB_ROUTING_LIST_A              PROP_TAG(PT_MV_STRING8,   0x8126)
#define PR_EMS_AB_ROUTING_LIST_W              PROP_TAG(PT_MV_UNICODE,   0x8126)
#define PR_EMS_AB_RTS_CHECKPOINT_SIZE         PROP_TAG(PT_LONG,         0x8127)
#define PR_EMS_AB_RTS_RECOVERY_TIMEOUT        PROP_TAG(PT_LONG,         0x8128)
#define PR_EMS_AB_RTS_WINDOW_SIZE             PROP_TAG(PT_LONG,         0x8129)
#define PR_EMS_AB_RUNS_ON                     PROP_TAG(PT_MV_TSTRING,   0x812A)
#define PR_EMS_AB_RUNS_ON_A                   PROP_TAG(PT_MV_STRING8,   0x812A)
#define PR_EMS_AB_RUNS_ON_W                   PROP_TAG(PT_MV_UNICODE,   0x812A)
#define PR_EMS_AB_RUNS_ON_O                   PROP_TAG(PT_OBJECT,       0x812A)
#define PR_EMS_AB_RUNS_ON_T                   PROP_TAG(PT_MV_TSTRING,   0x812A)
#define PR_EMS_AB_S_SELECTOR                  PROP_TAG(PT_BINARY,       0x812B)
#define PR_EMS_AB_S_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x812C)
#define PR_EMS_AB_SEARCH_FLAGS                PROP_TAG(PT_LONG,         0x812D)
#define PR_EMS_AB_SEARCH_GUIDE                PROP_TAG(PT_MV_BINARY,    0x812E)
#define PR_EMS_AB_SECURITY_PROTOCOL           PROP_TAG(PT_MV_BINARY,    0x8037)
#define PR_EMS_AB_SEE_ALSO                    PROP_TAG(PT_MV_TSTRING,   0x812F)
#define PR_EMS_AB_SEE_ALSO_A                  PROP_TAG(PT_MV_STRING8,   0x812F)
#define PR_EMS_AB_SEE_ALSO_W                  PROP_TAG(PT_MV_UNICODE,   0x812F)
#define PR_EMS_AB_SEE_ALSO_O                  PROP_TAG(PT_OBJECT,       0x812F)
#define PR_EMS_AB_SEE_ALSO_T                  PROP_TAG(PT_MV_TSTRING,   0x812F)
#define PR_EMS_AB_SERIAL_NUMBER               PROP_TAG(PT_MV_TSTRING,   0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_A             PROP_TAG(PT_MV_STRING8,   0x8130)
#define PR_EMS_AB_SERIAL_NUMBER_W             PROP_TAG(PT_MV_UNICODE,   0x8130)
#define PR_EMS_AB_SERVICE_ACTION_FIRST        PROP_TAG(PT_LONG,         0x8131)
#define PR_EMS_AB_SERVICE_ACTION_OTHER        PROP_TAG(PT_LONG,         0x8132)
#define PR_EMS_AB_SERVICE_ACTION_SECOND       PROP_TAG(PT_LONG,         0x8133)
#define PR_EMS_AB_SERVICE_RESTART_DELAY       PROP_TAG(PT_LONG,         0x8134)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE     PROP_TAG(PT_TSTRING,      0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_A   PROP_TAG(PT_STRING8,      0x8135)
#define PR_EMS_AB_SERVICE_RESTART_MESSAGE_W   PROP_TAG(PT_UNICODE,      0x8135)
#define PR_EMS_AB_SESSION_DISCONNECT_TIMER    PROP_TAG(PT_LONG,         0x8136)
#define PR_EMS_AB_SITE_AFFINITY               PROP_TAG(PT_MV_TSTRING,   0x8137)
#define PR_EMS_AB_SITE_AFFINITY_A             PROP_TAG(PT_MV_STRING8,   0x8137)
#define PR_EMS_AB_SITE_AFFINITY_W             PROP_TAG(PT_MV_UNICODE,   0x8137)
#define PR_EMS_AB_SITE_FOLDER_GUID            PROP_TAG(PT_BINARY,       0x8166)
#define PR_EMS_AB_SITE_FOLDER_SERVER          PROP_TAG(PT_TSTRING,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_A        PROP_TAG(PT_STRING8,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_W        PROP_TAG(PT_UNICODE,      0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_O        PROP_TAG(PT_OBJECT,       0x8167)
#define PR_EMS_AB_SITE_FOLDER_SERVER_T        PROP_TAG(PT_TSTRING,      0x8167)
#define PR_EMS_AB_SITE_PROXY_SPACE            PROP_TAG(PT_MV_TSTRING,   0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_A          PROP_TAG(PT_MV_STRING8,   0x8138)
#define PR_EMS_AB_SITE_PROXY_SPACE_W          PROP_TAG(PT_MV_UNICODE,   0x8138)
#define PR_EMS_AB_SPACE_LAST_COMPUTED         PROP_TAG(PT_SYSTIME,      0x8139)
#define PR_EMS_AB_STREET_ADDRESS              PROP_TAG(PT_TSTRING,      0x813A)
#define PR_EMS_AB_STREET_ADDRESS_A            PROP_TAG(PT_STRING8,      0x813A)
#define PR_EMS_AB_STREET_ADDRESS_W            PROP_TAG(PT_UNICODE,      0x813A)
#define PR_EMS_AB_SUB_REFS                    PROP_TAG(PT_MV_TSTRING,   0x813B)
#define PR_EMS_AB_SUB_REFS_A                  PROP_TAG(PT_MV_STRING8,   0x813B)
#define PR_EMS_AB_SUB_REFS_W                  PROP_TAG(PT_MV_UNICODE,   0x813B)
#define PR_EMS_AB_SUB_REFS_O                  PROP_TAG(PT_OBJECT,       0x813B)
#define PR_EMS_AB_SUB_REFS_T                  PROP_TAG(PT_MV_TSTRING,   0x813B)
#define PR_EMS_AB_SUBMISSION_CONT_LENGTH      PROP_TAG(PT_LONG,         0x813C)
#define PR_EMS_AB_SUPPORTED_APPLICATION_CONTEXT PROP_TAG(PT_MV_BINARY,  0x813D)
#define PR_EMS_AB_SUPPORTING_STACK            PROP_TAG(PT_MV_TSTRING,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_A          PROP_TAG(PT_MV_STRING8,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_W          PROP_TAG(PT_MV_UNICODE,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_O          PROP_TAG(PT_OBJECT,       0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_T          PROP_TAG(PT_MV_TSTRING,   0x813E)
#define PR_EMS_AB_SUPPORTING_STACK_BL         PROP_TAG(PT_MV_TSTRING,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_A       PROP_TAG(PT_MV_STRING8,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_W       PROP_TAG(PT_MV_UNICODE,   0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_O       PROP_TAG(PT_OBJECT,       0x813F)
#define PR_EMS_AB_SUPPORTING_STACK_BL_T       PROP_TAG(PT_MV_TSTRING,   0x813F)
#define PR_EMS_AB_T_SELECTOR                  PROP_TAG(PT_BINARY,       0x8140)
#define PR_EMS_AB_T_SELECTOR_INBOUND          PROP_TAG(PT_BINARY,       0x8141)
#define PR_EMS_AB_TARGET_ADDRESS              PROP_TAG(PT_TSTRING,      0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_A            PROP_TAG(PT_STRING8,      0x8011)
#define PR_EMS_AB_TARGET_ADDRESS_W            PROP_TAG(PT_UNICODE,      0x8011)
#define PR_EMS_AB_TARGET_MTAS                 PROP_TAG(PT_MV_TSTRING,   0x8142)
#define PR_EMS_AB_TARGET_MTAS_A               PROP_TAG(PT_MV_STRING8,   0x8142)
#define PR_EMS_AB_TARGET_MTAS_W               PROP_TAG(PT_MV_UNICODE,   0x8142)
#define PR_EMS_AB_TELEPHONE_NUMBER            PROP_TAG(PT_MV_TSTRING,   0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_A          PROP_TAG(PT_MV_STRING8,   0x8012)
#define PR_EMS_AB_TELEPHONE_NUMBER_W          PROP_TAG(PT_MV_UNICODE,   0x8012)
#define PR_EMS_AB_TELETEX_TERMINAL_IDENTIFIER PROP_TAG(PT_MV_BINARY,    0x8143)
#define PR_EMS_AB_TEMP_ASSOC_THRESHOLD        PROP_TAG(PT_LONG,         0x8144)
#define PR_EMS_AB_TOMBSTONE_LIFETIME          PROP_TAG(PT_LONG,         0x8145)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME      PROP_TAG(PT_TSTRING,      0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_A    PROP_TAG(PT_STRING8,      0x8146)
#define PR_EMS_AB_TRACKING_LOG_PATH_NAME_W    PROP_TAG(PT_UNICODE,      0x8146)
#define PR_EMS_AB_TRANS_RETRY_MINS            PROP_TAG(PT_LONG,         0x8147)
#define PR_EMS_AB_TRANS_TIMEOUT_MINS          PROP_TAG(PT_LONG,         0x8148)
#define PR_EMS_AB_TRANSFER_RETRY_INTERVAL     PROP_TAG(PT_LONG,         0x8149)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NON_URGENT PROP_TAG(PT_LONG,         0x814A)
#define PR_EMS_AB_TRANSFER_TIMEOUT_NORMAL     PROP_TAG(PT_LONG,         0x814B)
#define PR_EMS_AB_TRANSFER_TIMEOUT_URGENT     PROP_TAG(PT_LONG,         0x814C)
#define PR_EMS_AB_TRANSLATION_TABLE_USED      PROP_TAG(PT_LONG,         0x814D)
#define PR_EMS_AB_TRANSPORT_EXPEDITED_DATA    PROP_TAG(PT_BOOLEAN,      0x814E)
#define PR_EMS_AB_TRUST_LEVEL                 PROP_TAG(PT_LONG,         0x814F)
#define PR_EMS_AB_TURN_REQUEST_THRESHOLD      PROP_TAG(PT_LONG,         0x8150)
#define PR_EMS_AB_TWO_WAY_ALTERNATE_FACILITY  PROP_TAG(PT_BOOLEAN,      0x8151)
#define PR_EMS_AB_UNAUTH_ORIG_BL              PROP_TAG(PT_MV_TSTRING,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_A            PROP_TAG(PT_MV_STRING8,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_W            PROP_TAG(PT_MV_UNICODE,   0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_O            PROP_TAG(PT_OBJECT,       0x8152)
#define PR_EMS_AB_UNAUTH_ORIG_BL_T            PROP_TAG(PT_MV_TSTRING,   0x8152)
#define PR_EMS_AB_USER_PASSWORD               PROP_TAG(PT_MV_BINARY,    0x8153)
#define PR_EMS_AB_USN_CHANGED                 PROP_TAG(PT_LONG,         0x8029)
#define PR_EMS_AB_USN_CREATED                 PROP_TAG(PT_LONG,         0x8154)
#define PR_EMS_AB_USN_DSA_LAST_OBJ_REMOVED    PROP_TAG(PT_LONG,         0x8155)
#define PR_EMS_AB_USN_LAST_OBJ_REM            PROP_TAG(PT_LONG,         0x8156)
#define PR_EMS_AB_USN_SOURCE                  PROP_TAG(PT_LONG,         0x8157)
#define PR_EMS_AB_X121_ADDRESS                PROP_TAG(PT_MV_TSTRING,   0x8158)
#define PR_EMS_AB_X121_ADDRESS_A              PROP_TAG(PT_MV_STRING8,   0x8158)
#define PR_EMS_AB_X121_ADDRESS_W              PROP_TAG(PT_MV_UNICODE,   0x8158)
#define PR_EMS_AB_X25_CALL_USER_DATA_INCOMING PROP_TAG(PT_BINARY,       0x8159)
#define PR_EMS_AB_X25_CALL_USER_DATA_OUTGOING PROP_TAG(PT_BINARY,       0x815A)
#define PR_EMS_AB_X25_FACILITIES_DATA_INCOMING PROP_TAG(PT_BINARY,      0x815B)
#define PR_EMS_AB_X25_FACILITIES_DATA_OUTGOING PROP_TAG(PT_BINARY,      0x815C)
#define PR_EMS_AB_X25_LEASED_LINE_PORT        PROP_TAG(PT_BINARY,       0x815D)
#define PR_EMS_AB_X25_LEASED_OR_SWITCHED      PROP_TAG(PT_BOOLEAN,      0x815E)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE        PROP_TAG(PT_TSTRING,      0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_A      PROP_TAG(PT_STRING8,      0x815F)
#define PR_EMS_AB_X25_REMOTE_MTA_PHONE_W      PROP_TAG(PT_UNICODE,      0x815F)
#define PR_EMS_AB_X400_ATTACHMENT_TYPE        PROP_TAG(PT_BINARY,       0x8160)
#define PR_EMS_AB_X400_SELECTOR_SYNTAX        PROP_TAG(PT_LONG,         0x8161)
#define PR_EMS_AB_X500_ACCESS_CONTROL_LIST    PROP_TAG(PT_BINARY,       0x8162)
#define PR_EMS_AB_XMIT_TIMEOUT_NON_URGENT     PROP_TAG(PT_LONG,         0x8163)
#define PR_EMS_AB_XMIT_TIMEOUT_NORMAL         PROP_TAG(PT_LONG,         0x8164)
#define PR_EMS_AB_XMIT_TIMEOUT_URGENT         PROP_TAG(PT_LONG,         0x8165)

#endif /* _EMSABTAG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\_comctl.h ===
/*

	_comctl.h

*/

// This commctrl flag enables us to be compiled with the new commctrl headers
// yet work with the old commctrl dlls
#ifdef _WIN32_IE
#undef _WIN32_IE
#endif
#define _WIN32_IE 0x0300
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\makefile.inc ===
$O\globals.obj : globals.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\globals.c
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP

$O\wabguid.obj : wabguid.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(USECXX_FLAG) $(MAKEDIR)\wabguid.c
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP

$(O)\wabimp.res : $(O)\selfreg.inf

selfreg.src : reg.src strings.src

$(O)\selfreg.inx : selfreg.src
	cl /EP /Tc $** > $@

$(O)\selfreg.inf : $(O)\selfreg.inx
        $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\pab.c ===
/*
 *  PAB.C
 *
 *  Migrate PAB <-> WAB
 *
 *  Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include <emsabtag.h>
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"
#include "wabimp.h"
#include <shlwapi.h>


void StateImportNextMU(HWND hwnd);
void StateImportDL(HWND hwnd);
void StateImportNextDL(HWND hwnd);
void StateImportFinish(HWND hwnd);
//void StateImportMU(HWND hwnd);
void StateImportMU(HWND hwnd);
void StateImportError(HWND hwnd);
void StateImportCancel(HWND hwnd);
BOOL HandleImportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_IMPORT_OPTIONS lpImportOptions);

HRESULT ImportEntry(HWND hwnd,
  LPADRBOOK lpAdrBookMAPI,
  LPABCONT lpContainerWAB,
  LPSPropValue lpCreateEIDsWAB,
  ULONG ulObjectType,
  LPENTRYID lpEID,
  ULONG cbEID,
  LPENTRYID * lppEIDWAB,
  LPULONG lpcbEIDWAB,
  BOOL fInDL,
  BOOL fForceReplace);

const UCHAR szQuote[] = "\"";
LPPROP_NAME lpImportMapping = NULL;

BOOL fError = FALSE;
LPWABOBJECT lpWABObject = NULL;
LPMAPISESSION lpMAPISession = NULL;
LPADRBOOK lpAdrBookWAB = NULL, lpAdrBookMAPI = NULL;
LPSPropValue lpCreateEIDsWAB = NULL, lpCreateEIDsMAPI = NULL;
LPABCONT  lpContainerWAB = NULL, lpContainerMAPI = NULL;
LPMAPITABLE lpContentsTableWAB = NULL, lpContentsTableMAPI = NULL;
ULONG ulcEntries = 0, ulcDone = 0;


PAB_STATE State = STATE_IMPORT_FINISH;
LPTSTR lpszWABFileName = NULL;
LPWAB_PROGRESS_CALLBACK lpfnProgressCB = NULL;
LPWAB_IMPORT_OPTIONS lpImportOptions = NULL;
LPWAB_EXPORT_OPTIONS lpExportOptions = NULL;



/*
- The following IDs and tags are for the conferencing named properties
-
-   The GUID for these props is PS_Conferencing
*/

DEFINE_OLEGUID(PS_Conferencing, 0x00062004, 0, 0);

#define CONF_SERVERS        0x8056

#define OLK_NAMEDPROPS_START CONF_SERVERS

ULONG PR_SERVERS;

enum _ConferencingTags
{
    prWABConfServers = 0,
    prWABConfMax
};
SizedSPropTagArray(prWABConfMax, ptaUIDetlsPropsConferencing);

HRESULT HrLoadPrivateWABPropsForCSV(LPADRBOOK );
// end conferencing duplication

/***************************************************************************

    Name      : NewState

    Purpose   :

    Parameters: hwnd = window handle of Dialog (currently unused)
                NewState = new state to set

    Returns   : none

    Comment   :

***************************************************************************/
 __inline void NewState(HWND hwnd, PAB_STATE NewState) {
    // Old version
    // PostMessage(hwnd, WM_COMMAND, NewState, 0);
    State = NewState;
    UNREFERENCED_PARAMETER(hwnd);
}


/***************************************************************************

    Name      : SetDialogMessage

    Purpose   : Sets the message text for the dialog box item IDC_Message

    Parameters: hwnd = window handle of dialog
                ids = stringid of message resource

    Returns   : none

***************************************************************************/
void SetDialogMessage(HWND hwnd, int ids) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    WAB_PROGRESS Progress = {0};

    Assert(lpfnProgressCB);

    if (lpfnProgressCB && LoadString(hInst, ids, szBuffer, ARRAYSIZE(szBuffer))) {
        DebugTrace("Status Message: %s\n", szBuffer);

        Progress.lpText = szBuffer;
        lpfnProgressCB(hwnd, &Progress);
    } else {
        DebugTrace("Cannot load resource string %u\n", ids);
        Assert(FALSE);
    }
}


/***************************************************************************

    Name      : SetDialogProgress

    Purpose   : Sets progress bar

    Parameters: hwnd = window handle of dialog
                ulTotal = total entries
                ulDone = finished entries

    Returns   : none

***************************************************************************/
void SetDialogProgress(HWND hwnd, ULONG ulTotal, ULONG ulDone) {
    WAB_PROGRESS Progress = {0};

    Assert(lpfnProgressCB);

    if (lpfnProgressCB) {
        Progress.denominator = ulTotal;
        Progress.numerator = ulDone;
        lpfnProgressCB(hwnd, &Progress);
    }
}


/***************************************************************************

    Name      : AddEntryToImportList

    Purpose   : Checks this entry against our "seen" list and adds it.

    Parameters: cbEID = size of lpEID
                lpEID -> EntryID of entry
                lplIndex -> returned list index (or -1 on error)

    Returns   : TRUE if entry already exists

    Comment   : Caller must mark the WAB entry!

***************************************************************************/
#define GROW_SIZE   10
BOOL AddEntryToImportList(ULONG cbEID, LPENTRYID lpEID, LPLONG lplIndex) {
    ULONG i;
    LPENTRY_SEEN lpEntrySeen;

    if (cbEID && lpEID) {
        for (i = 0; i < ulEntriesSeen; i++) {
            if (cbEID == lpEntriesSeen[i].sbinPAB.cb  && (! memcmp(lpEID, lpEntriesSeen[i].sbinPAB.lpb, cbEID))) {
                // This one's in the list
                *lplIndex = i;
                // If cb 0, we must have recursed and are replacing, so this one is not a dup.
                return(lpEntriesSeen[i].sbinWAB.cb != 0);
            }
        }

        // Add to the end of the list
        if (++ulEntriesSeen > ulMaxEntries) {
            // Grow the array.

            ulMaxEntries += GROW_SIZE;

            if (lpEntriesSeen) {
                if (! (lpEntrySeen = LocalReAlloc(lpEntriesSeen, ulMaxEntries * sizeof(ENTRY_SEEN), LMEM_MOVEABLE | LMEM_ZEROINIT))) {
                    DebugTrace("LocalReAlloc(%u) -> %u\n", ulMaxEntries * sizeof(ENTRY_SEEN), GetLastError());
                    goto error;
                }
                lpEntriesSeen = lpEntrySeen;
            } else {
                if (! (lpEntriesSeen = LocalAlloc(LPTR, ulMaxEntries * sizeof(ENTRY_SEEN)))) {
                    DebugTrace("LocalAlloc(%u) -> %u\n", ulMaxEntries * sizeof(ENTRY_SEEN), GetLastError());
                    goto error;
                }
            }
        }

        lpEntrySeen = &lpEntriesSeen[ulEntriesSeen - 1];

        // Allocate space for data
        lpEntrySeen->sbinPAB.cb = cbEID;
        if (! (lpEntrySeen->sbinPAB.lpb = LocalAlloc(LPTR, cbEID))) {
            DebugTrace("LocalAlloc(%u) -> %u\n", cbEID, GetLastError());
            goto error;
        }

        // Mark as unknown WAB entry
        lpEntrySeen->sbinWAB.cb = 0;
        lpEntrySeen->sbinWAB.lpb = 0;

        // Copy in the data
        CopyMemory(lpEntrySeen->sbinPAB.lpb, lpEID, cbEID);
        *lplIndex = i;
    }

    return(FALSE);

error:
    // undo the damage...
    --ulEntriesSeen;
    ulMaxEntries -= GROW_SIZE;
    *lplIndex = -1;     // error
    if (! lpEntriesSeen) {
        ulEntriesSeen = 0;  // pointer is null now, back to square one.
        ulMaxEntries = 0;
    }
    return(FALSE);
}


/***************************************************************************

    Name      : MarkWABEntryInList

    Purpose   : Marks the WAB entry fields in the list node

    Parameters: cbEID = size of lpEID
                lpEID -> EntryID of entry
                lIndex = list index (or -1 on error)

    Returns   : none

    Comment   :

***************************************************************************/
void MarkWABEntryInList(ULONG cbEID, LPENTRYID lpEID, LONG lIndex) {
    if (lIndex != -1 && cbEID) {
       if (! (lpEntriesSeen[lIndex].sbinWAB.lpb = LocalAlloc(LPTR, cbEID))) {
           DebugTrace("LocalAlloc(%u) -> %u\n", cbEID, GetLastError());
           // leave it null
       } else {
           lpEntriesSeen[lIndex].sbinWAB.cb = cbEID;

           // Copy in the data
           CopyMemory(lpEntriesSeen[lIndex].sbinWAB.lpb, lpEID, cbEID);
       }
    }
}


/***************************************************************************

    Name      : StateImportMU

    Purpose   : Start the migration of MailUsers

    Parameters: hwnd = window handle of Import Dialog
                lpszFileName - FileName of WAB File to open

    Returns   : none

    Comment   : Login to MAPI
                Open the WAB
                Open the MAPI AB
                Open the WAB container
                Get the MAPI PAB contents table
                Restrict it to PR_OBJECTTYPE == MAPI_MAILUSER
                Post new state(STATE_NEXT_MU)

***************************************************************************/
void StateImportMU(HWND hwnd) {
    HRESULT hResult;
    ULONG ulFlags;
    ULONG cbPABEID, cbWABEID;
    LPENTRYID lpPABEID = NULL;
    ULONG ulObjType;
    ULONG_PTR ulUIParam = (ULONG_PTR)(void *)hwnd;
    SRestriction restrictObjectType;
    SPropValue spvObjectType;
    ULONG cProps;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

    WAB_PARAM wp = {0};
    LPWAB_PARAM lpwp = NULL;


    //
    // Logon to MAPI and open the MAPI Address book, if one exists
    //
    DebugTrace(">>> STATE_IMPORT_MU\n");

    SetDialogMessage(hwnd, IDS_STATE_LOGGING_IN);

    if (FAILED(hResult = MAPIInitialize(NULL))) {
        DebugTrace("MAPIInitialize -> %x\n", GetScode(hResult));
        switch (GetScode(hResult)) {
            case MAPI_E_NOT_ENOUGH_MEMORY:
                SetDialogMessage(hwnd, IDS_ERROR_NOT_ENOUGH_MEMORY);
                break;
            case MAPI_E_NOT_ENOUGH_DISK:
                SetDialogMessage(hwnd, IDS_ERROR_NOT_ENOUGH_DISK);
                break;

            default:
            case MAPI_E_NOT_FOUND:
            case MAPI_E_NOT_INITIALIZED:
                SetDialogMessage(hwnd, IDS_ERROR_MAPI_DLL_NOT_FOUND);
                break;
        }
#ifdef OLD_STUFF
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);    // hide progress bar
#endif // OLD_STUFF
        fError = TRUE;
        hResult = hrSuccess;
        goto exit;
    }

    ulFlags = MAPI_LOGON_UI | MAPI_NO_MAIL | MAPI_EXTENDED;

    if (FAILED(hResult = MAPILogonEx(ulUIParam,
      NULL,
      NULL,
      ulFlags,
      (LPMAPISESSION FAR *)&lpMAPISession))) {
        DebugTrace("MAPILogonEx -> %x\n", GetScode(hResult));
        switch (GetScode(hResult)) {
            case MAPI_E_USER_CANCEL:
                SetDialogMessage(hwnd, IDS_STATE_IMPORT_IDLE);
                break;
            case MAPI_E_NOT_INITIALIZED:
                SetDialogMessage(hwnd, IDS_ERROR_MAPI_DLL_NOT_FOUND);
                break;
            default:
                SetDialogMessage(hwnd, IDS_ERROR_MAPI_LOGON);
                break;
        }
#ifdef OLD_STUFF
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);    // hide progress bar
#endif // OLD_STUFF
        fError = TRUE;
        hResult = hrSuccess;
        goto exit;
    }

    if (hResult = lpMAPISession->lpVtbl->OpenAddressBook(lpMAPISession, (ULONG_PTR)(void *)hwnd,
      NULL,
      0,
      &lpAdrBookMAPI)) {
        DebugTrace("OpenAddressBook(MAPI) -> %x", GetScode(hResult));
        if(FAILED(hResult)) {
            goto exit;
        }
    }

    if (! lpAdrBookMAPI) {
        DebugTrace("MAPILogonEx didn't return a valid AdrBook object\n");
        goto exit;
    }

    //
    // Open the MAPI PAB container
    //
    // [PaulHi] Raid #63578 1/7/98
    // Correctly check return code and provide user error message if
    // Exchange PAB cannot be opened.
    //
    hResult = lpAdrBookMAPI->lpVtbl->GetPAB(lpAdrBookMAPI,
      &cbPABEID,
      &lpPABEID);
    if (HR_FAILED(hResult))
    {
        DebugTrace("MAPI GetPAB -> %x\n", GetScode(hResult));
        goto exit;
    }
    hResult = lpAdrBookMAPI->lpVtbl->OpenEntry(lpAdrBookMAPI,
        cbPABEID,     // size of EntryID to open
        lpPABEID,     // EntryID to open
        NULL,         // interface
        0,            // flags
        &ulObjType,
        (LPUNKNOWN *)&lpContainerMAPI);
    if (HR_FAILED(hResult))
    {
        DebugTrace("MAPI OpenEntry(PAB) -> %x\n", GetScode(hResult));
        goto exit;
    }

    Assert(lpAdrBookWAB);

    //
    // Open the WAB's PAB container: fills global lpCreateEIDsWAB
    //
    if (hResult = LoadWABEIDs(lpAdrBookWAB, &lpContainerWAB)) {
        goto exit;
    }
    HrLoadPrivateWABPropsForCSV(lpAdrBookWAB);

    //
    // All set... now loop through the PAB's entries, copying them to WAB
    //
    if (HR_FAILED(hResult = lpContainerMAPI->lpVtbl->GetContentsTable(lpContainerMAPI,
      0,    // ulFlags
      &lpContentsTableMAPI))) {
        DebugTrace("MAPI GetContentsTable(PAB Table) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Set the columns to those we're interested in
    if (hResult = lpContentsTableMAPI->lpVtbl->SetColumns(lpContentsTableMAPI,
      (LPSPropTagArray)&ptaColumns,
      0)) {
        DebugTrace("MAPI SetColumns(PAB Table) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Restrict the table to MAPI_MAILUSERs
    // If the convenient depth flag was not specified we restrict on
    // PR_DEPTH == 1.
    spvObjectType.ulPropTag = PR_OBJECT_TYPE;
    spvObjectType.Value.l = MAPI_MAILUSER;

    restrictObjectType.rt = RES_PROPERTY;
    restrictObjectType.res.resProperty.relop = RELOP_EQ;
    restrictObjectType.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
    restrictObjectType.res.resProperty.lpProp = &spvObjectType;

    if (HR_FAILED(hResult = lpContentsTableMAPI->lpVtbl->Restrict(lpContentsTableMAPI,
      &restrictObjectType,
      0))) {
        DebugTrace("MAPI Restrict (MAPI_MAILUSER) -> %x\n", GetScode(hResult));
        goto exit;
    }
    SetDialogMessage(hwnd, IDS_STATE_IMPORT_MU);


    // Initialize the Progress Bar
    // How many MailUser entries are there?
    ulcEntries = CountRows(lpContentsTableMAPI, TRUE);
    ulcDone = 0;

    DebugTrace("PAB contains %u MailUser entries\n", ulcEntries);

    SetDialogProgress(hwnd, ulcEntries, 0);

exit:
    if (lpPABEID) {
        MAPIFreeBuffer(lpPABEID);
    }

    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult))
    {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL)
        {
            NewState(hwnd, STATE_IMPORT_CANCEL);
        }
        else
        {
            // [PaulHi] 1/7/98  Error reporting is hosed
            // Display error message here to the user to ensure they
            // get it.
            {
                TCHAR   tszBuffer[MAX_RESOURCE_STRING];
                TCHAR   tszBufferTitle[MAX_RESOURCE_STRING];

                if ( !LoadString(hInst, IDS_STATE_IMPORT_ERROR_NOPAB, tszBuffer, MAX_RESOURCE_STRING-1) )
                {
                    Assert(0);
                    tszBuffer[0] = '\0';
                }

                if ( !LoadString(hInst, IDS_APP_TITLE, tszBufferTitle, MAX_RESOURCE_STRING-1) )
                {
                    Assert(0);
                    tszBufferTitle[0] = '\0';
                }
                MessageBox(hwnd, tszBuffer, tszBufferTitle, MB_ICONEXCLAMATION | MB_OK);
            }
            
            NewState(hwnd, STATE_IMPORT_ERROR);
        }
    }
    else if (fError)
    {
        NewState(hwnd, STATE_IMPORT_FINISH);      // must be logon error
    }
    else
    {
        NewState(hwnd, STATE_IMPORT_NEXT_MU);
    }
}


/***************************************************************************

    Name      : StateImportNextMU

    Purpose   : Migrate the next MailUser object

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : QueryRows on the global MAPI contents table
                if there was a row
                    Migrate the entry to the WAB
                    Re-post STATE_NEXT_MU
                else
                    Post STATE_IMPORT_DL

***************************************************************************/
void StateImportNextMU(HWND hwnd) {
    ULONG cRows = 0;
    HRESULT hResult;
    LPSRowSet lpRow = NULL;


    DebugTrace(">>> STATE_NEXT_MU\n");

    // Get the next PAB entry
    if (hResult = lpContentsTableMAPI->lpVtbl->QueryRows(lpContentsTableMAPI,
      1,    // one row at a time
      0,    // ulFlags
      &lpRow)) {
        DebugTrace("QueryRows -> %x\n", GetScode(hResult));
        goto exit;
    }

    if (lpRow) {
        if (cRows = lpRow->cRows) { // Yes, single '='
            Assert(lpRow->cRows == 1);
            Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

            if (cRows = lpRow->cRows) { // yes, single '='
                hResult = ImportEntry(hwnd,
                  lpAdrBookMAPI,
                  lpContainerWAB,
                  lpCreateEIDsWAB,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].Value.l,
                  (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                  NULL,
                  NULL,
                  FALSE,
                  FALSE);
                // Update Progress Bar
                // ignore errors!

                SetDialogProgress(hwnd, ulcEntries, ++ulcDone);

                if (hResult) {
                    if (HandleImportError(hwnd,
                      0,
                      hResult,
                      lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                      PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                      lpImportOptions)) {
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    } else {
                        hResult = hrSuccess;
                    }
                }
            } // else, drop out of loop, we're done.
        }
        FreeProws(lpRow);
    }

exit:
    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult)) {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL) {
            NewState(hwnd, STATE_IMPORT_CANCEL);
        } else {
            NewState(hwnd, STATE_IMPORT_ERROR);
        }
    } else {
        if (cRows) {
            NewState(hwnd, STATE_IMPORT_NEXT_MU);
        } else {
            NewState(hwnd, STATE_IMPORT_DL);
        }
    }
}


/***************************************************************************

    Name      : StateImportDL

    Purpose   : Start migration of DISTLIST objects

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Set a new restriction on the contents table, selecting
                DISTLIST objects only.
                Post STATE_NEXT_DL

***************************************************************************/
void StateImportDL(HWND hwnd) {
    HRESULT hResult;
    SRestriction restrictObjectType;
    SPropValue spvObjectType;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];


    DebugTrace(">>> STATE_IMPORT_DL\n");

    // Restrict the table to MAPI_MAILUSERs
    // If the convenient depth flag was not specified we restrict on
    // PR_DEPTH == 1.
    spvObjectType.ulPropTag = PR_OBJECT_TYPE;
    spvObjectType.Value.l = MAPI_DISTLIST;

    restrictObjectType.rt = RES_PROPERTY;
    restrictObjectType.res.resProperty.relop = RELOP_EQ;
    restrictObjectType.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
    restrictObjectType.res.resProperty.lpProp = &spvObjectType;

    if (HR_FAILED(hResult = lpContentsTableMAPI->lpVtbl->Restrict(lpContentsTableMAPI,
      &restrictObjectType,
      0))) {
        DebugTrace("MAPI Restrict (MAPI_DISTLIST) -> %x\n", GetScode(hResult));
        goto exit;
    }
    // Restrict resets the current position to the beginning of the table, by definition.

    SetDialogMessage(hwnd, IDS_STATE_IMPORT_DL);

    // Initialize the Progress Bar
    // How many entries are there?

    ulcEntries = CountRows(lpContentsTableMAPI, TRUE);
    ulcDone = 0;

    DebugTrace("PAB contains %u Distribution List entries\n", ulcEntries);
    if (ulcEntries) {
        SetDialogProgress(hwnd, ulcEntries, 0);
    }
exit:
    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult)) {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL) {
            NewState(hwnd, STATE_IMPORT_CANCEL);
        } else {
            NewState(hwnd, STATE_IMPORT_ERROR);
        }
    } else {
        NewState(hwnd, STATE_IMPORT_NEXT_DL);
    }
}


/***************************************************************************

    Name      : StateImportNextDL

    Purpose   : Migrate the next DISTLIST object

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : QueryRows on the global MAPI contents table
                if there was a row
                    Migrate the DistList to the WAB
                    Re-post STATE_NEXT_DL
                else
                    Post STATE_FINISH

***************************************************************************/
void StateImportNextDL(HWND hwnd) {
    ULONG cRows = 0;
    HRESULT hResult;
    LPSRowSet lpRow = NULL;


    DebugTrace(">>> STATE_NEXT_DL\n");

    // Get the next PAB entry
    if (hResult = lpContentsTableMAPI->lpVtbl->QueryRows(lpContentsTableMAPI,
      1,    // one row at a time
      0,    // ulFlags
      &lpRow)) {
        DebugTrace("QueryRows -> %x\n", GetScode(hResult));
        goto exit;
    }

    if (lpRow) {
        if (cRows = lpRow->cRows) { // Yes, single '='
            Assert(lpRow->cRows == 1);
            Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

            if (cRows = lpRow->cRows) { // yes, single '='
                hResult = ImportEntry(hwnd,
                  lpAdrBookMAPI,
                  lpContainerWAB,
                  lpCreateEIDsWAB,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].Value.l,
                  (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                  NULL,
                  NULL,
                  FALSE,
                  FALSE);

                // Update Progress Bar
                SetDialogProgress(hwnd, ulcEntries, ++ulcDone);

                if (hResult) {
                    if (HandleImportError(hwnd,
                      0,
                      hResult,
                      lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                      PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                      lpImportOptions)) {
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    } else {
                        hResult = hrSuccess;
                    }
                }
            } // else, drop out of loop, we're done.
        }
        FreeProws(lpRow);
    }

exit:
    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult)) {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL) {
            NewState(hwnd, STATE_IMPORT_CANCEL);
        } else {
            NewState(hwnd, STATE_IMPORT_ERROR);
        }
    } else {
        if (cRows) {
            NewState(hwnd, STATE_IMPORT_NEXT_DL);
        } else {
            // Update Progress Bar to indicate completion
            SetDialogProgress(hwnd, ulcEntries, ulcEntries);
            NewState(hwnd, STATE_IMPORT_FINISH);
        }
    }
}


/***************************************************************************

    Name      : StateImportFinish

    Purpose   : Clean up after the migration process

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Clean up the global MAPI objects and buffers
                Clean up the global WAB objects and buffers.
                Re-enable the Import button on the UI.

***************************************************************************/
void StateImportFinish(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    TCHAR szBufferTitle[MAX_RESOURCE_STRING + 1];


    DebugTrace(">>> STATE_FINISH\n");

    //
    // Cleanup MAPI
    //
    if (lpContentsTableMAPI) {
        lpContentsTableMAPI->lpVtbl->Release(lpContentsTableMAPI);
        lpContentsTableMAPI = NULL;
    }

    if (lpContainerMAPI) {
        lpContainerMAPI->lpVtbl->Release(lpContainerMAPI);
        lpContainerMAPI = NULL;
    }

    if (lpAdrBookMAPI) {
        lpAdrBookMAPI->lpVtbl->Release(lpAdrBookMAPI);
        lpAdrBookMAPI = NULL;
    }

    if(lpMAPISession){
        lpMAPISession->lpVtbl->Logoff(lpMAPISession, (ULONG_PTR)(void *)hwnd,
          MAPI_LOGOFF_UI,
          0);

        lpMAPISession->lpVtbl->Release(lpMAPISession);
        lpMAPISession = NULL;
    }

    //
    // Cleanup the WAB
    //
    if (lpCreateEIDsWAB) {
        WABFreeBuffer(lpCreateEIDsWAB);
        lpCreateEIDsWAB = NULL;
    }

    if (lpContainerWAB) {
        lpContainerWAB->lpVtbl->Release(lpContainerWAB);
        lpContainerWAB = NULL;
    }

#ifdef OLD_STUFF        // Don't release the WABObject or AdrBook object.  They
                        // were passed in.
    if (lpAdrBookWAB) {
        lpAdrBookWAB->lpVtbl->Release(lpAdrBookWAB);
        lpAdrBookWAB = NULL;
    }

    if (lpWABObject) {
        lpWABObject->lpVtbl->Release(lpWABObject);
        lpWABObject = NULL;
    }
#endif // OLD_STUFF

    // Cleanup the cache
    FreeSeenList();

    if (! fError) {     // Leave error state displayed
        if (LoadString(hInst, IDS_STATE_IMPORT_COMPLETE, szBuffer, ARRAYSIZE(szBuffer))) {
            DebugTrace("Status Message: %s\n", szBuffer);
            SetDlgItemText(hwnd, IDC_Message, szBuffer);

            if (! LoadString(hInst, IDS_APP_TITLE, szBufferTitle, ARRAYSIZE(szBufferTitle))) {
                StrCpyN(szBufferTitle, "", ARRAYSIZE(szBufferTitle));
            }

#ifdef OLD_STUFF
            // Display a dialog telling user it's over
            MessageBox(hwnd, szBuffer,
              szBufferTitle, MB_ICONINFORMATION | MB_OK);
#endif // OLD_STUFF
        }
#ifdef OLD_STUFF
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);
#endif // OLD_STUFF
    }
    fError = FALSE;

    // Re-enable the Import button here.
    EnableWindow(GetDlgItem(hwnd, IDC_Import), TRUE);
    // Change the Cancel button to Close
    if (LoadString(hInst, IDS_BUTTON_CLOSE, szBuffer, ARRAYSIZE(szBuffer))) {
        SetDlgItemText(hwnd, IDCANCEL, szBuffer);
    }
}


/***************************************************************************

    Name      : StateImportError

    Purpose   : Report fatal error and cleanup.

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Report error and post STATE_FINISH.

***************************************************************************/
void StateImportError(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace(">>> STATE_ERROR\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_IMPORT_ERROR);

    NewState(hwnd, STATE_IMPORT_FINISH);
}


/***************************************************************************

    Name      : StateImportCancel

    Purpose   : Report cancel error and cleanup.

    Parameters: hwnd = window handle of Import Dialog

    Returns   : none

    Comment   : Report error and post STATE_FINISH.

***************************************************************************/
void StateImportCancel(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace(">>> STATE_CANCEL\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_IMPORT_CANCEL);

    NewState(hwnd, STATE_IMPORT_FINISH);
}


/***************************************************************************

    Name      : HrFilterImportMailUserProps

    Purpose   : Filters out undesirable properties from the property array.
                Converts known email address types to SMTP.
                Moves FAX address to PR_BUSINESS_FAX_NUMBER.

    Parameters: lpcProps -> IN: Input number of properties
                            OUT: Output number of properties
                lppProps -> IN: Input property array (MAPI allocation)
                            OUT: Output property array (WAB allocation)
                lpObjectMAPI -> MAPI object (used to get extra props)
                lpfDL -> flag to set FALSE if we change a DL to a MAILUSER
                         (ie, for an EXchange DL)

    Returns   : HRESULT

    Comment   : Setting the property tag in the array to PR_NULL effectively
                nulls this property out.  We can re-use these in the second
                pass.

                Caller should use WABFreeBuffer to free *lppProps.
                This routine will free the input value of *lppProps.

***************************************************************************/
HRESULT HrFilterImportMailUserProps(LPULONG lpcProps, LPSPropValue * lppProps,
  LPMAPIPROP lpObjectMAPI, LPBOOL lpfDL) {
    HRESULT hResult = hrSuccess;
    ULONG i;
    LPSPropValue lpPropsMAPI = *lppProps, lpPropsWAB = NULL;
    ULONG cbProps;
    SCODE sc;
    ULONG cProps = *lpcProps;
    ULONG iPR_ADDRTYPE = NOT_FOUND;
    ULONG iPR_EMAIL_ADDRESS = NOT_FOUND;
    ULONG iPR_PRIMARY_FAX_NUMBER = NOT_FOUND;
    ULONG iPR_BUSINESS_FAX_NUMBER = NOT_FOUND;
    ULONG iPR_MSNINET_DOMAIN = NOT_FOUND;
    ULONG iPR_MSNINET_ADDRESS = NOT_FOUND;
    ULONG iPR_DISPLAY_NAME = NOT_FOUND;
    ULONG iPR_OBJECT_TYPE = NOT_FOUND;
    LPSBinary lpEntryID = NULL;
    LPTSTR lpTemp;
    BOOL fBadAddress = FALSE;
    ULONG cbDisplayName;
    LPTSTR lpDisplayName = NULL;


//    MAPIDebugProperties(lpPropsMAPI, *lpcProps, "MailUser BEFORE");

    // First pass: Remove the junk
    for (i = 0; i < cProps; i++) {
        // Error value
        if (PROP_ERROR(lpPropsMAPI[i])) {
            lpPropsMAPI[i].ulPropTag = PR_NULL;
            continue;
        }

        // Named property
        if (PROP_ID(lpPropsMAPI[i].ulPropTag) >= MIN_NAMED_PROPID) {
            lpPropsMAPI[i].ulPropTag = PR_NULL;
            continue;
        }

        // Object property
        if (PROP_TYPE(lpPropsMAPI[i].ulPropTag) == PT_OBJECT) {
            lpPropsMAPI[i].ulPropTag = PR_NULL;
            continue;
        }
        switch (lpPropsMAPI[i].ulPropTag) {
            case PR_ENTRYID:
                lpEntryID = &lpPropsMAPI[i].Value.bin;
                // fall through

            case PR_PRIMARY_CAPABILITY:
            case PR_TEMPLATEID:
            case PR_SEARCH_KEY:
            case PR_INITIAL_DETAILS_PANE:
            case PR_RECORD_KEY:
            case PR_MAPPING_SIGNATURE:
                lpPropsMAPI[i].ulPropTag = PR_NULL;
                break;

            case PR_COMMENT:
                // Don't save PR_COMMENT if it is empty
                if (lstrlen(lpPropsMAPI[i].Value.LPSZ) == 0) {
                    lpPropsMAPI[i].ulPropTag = PR_NULL;
                }
                break;

            // Keep track of the position of these for later
            case PR_ADDRTYPE:
                iPR_ADDRTYPE = i;
                break;
            case PR_OBJECT_TYPE:
                iPR_OBJECT_TYPE = i;
                break;
            case PR_EMAIL_ADDRESS:
                iPR_EMAIL_ADDRESS = i;
                break;
            case PR_PRIMARY_FAX_NUMBER:
                iPR_PRIMARY_FAX_NUMBER = i;
                break;
            case PR_BUSINESS_FAX_NUMBER:
                iPR_BUSINESS_FAX_NUMBER = i;
                break;
            case PR_MSNINET_ADDRESS:
                iPR_MSNINET_ADDRESS = i;
                break;
            case PR_MSNINET_DOMAIN:
                iPR_MSNINET_DOMAIN = i;
                break;
            case PR_DISPLAY_NAME:
                iPR_DISPLAY_NAME = i;

                // Make sure it isn't quoted.
                lpDisplayName = lpPropsMAPI[i].Value.LPSZ;
                if (lpDisplayName[0] == '\'') {
                    cbDisplayName = lstrlen(lpDisplayName);
                    if ((cbDisplayName > 1) && lpDisplayName[cbDisplayName - 1] == '\'') {
                        // String is surrounded by apostrophes.  Strip them.
                        lpDisplayName[cbDisplayName - 1] = '\0';
                        lpDisplayName++;
                        lpPropsMAPI[i].Value.LPSZ = lpDisplayName;
                    }
                } else {
                    if (lpDisplayName[0] == '"') {
                        cbDisplayName = lstrlen(lpDisplayName);
                        if ((cbDisplayName > 1) && lpDisplayName[cbDisplayName - 1] == '"') {
                            // String is surrounded by quotes.  Strip them.
                            lpDisplayName[cbDisplayName - 1] = '\0';
                            lpDisplayName++;
                            lpPropsMAPI[i].Value.LPSZ = lpDisplayName;
                        }
                    }
                }
                break;
        }

        // Put this after the switch since we do want to track a few props which fall in
        // the 0x6000 range but don't want to transfer them to the wab.
        if (PROP_ID(lpPropsMAPI[i].ulPropTag) >= MAX_SCHEMA_PROPID) {
            lpPropsMAPI[i].ulPropTag = PR_NULL;
            continue;
        }
    }


    // Second pass: Fix up the addresses
    if (iPR_ADDRTYPE != NOT_FOUND) {
        if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szFAX)) {
            DebugTrace("FAX address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);

            //
            // Handle MS-FAX Address conversion
            //
            if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                // Rename the PR_EMAIL_ADDRESS to PR_BUSINESS_FAX_NUMBER
                lpPropsMAPI[iPR_EMAIL_ADDRESS].ulPropTag = PR_BUSINESS_FAX_NUMBER;

                // Get rid of any existing PR_BUSINESS_FAX_NUMBER
                if (iPR_BUSINESS_FAX_NUMBER != NOT_FOUND) {
                    lpPropsMAPI[iPR_BUSINESS_FAX_NUMBER].ulPropTag = PR_NULL;
                    iPR_BUSINESS_FAX_NUMBER = NOT_FOUND;
                }
            }
            // Nuke ADDRTYPE
            lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szMSN)) {
			ULONG cchSize = lstrlen(lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ) + 1 + cbMSNpostfix ;       
            DebugTrace("MSN address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            //
            // Handle MSN Address conversion
            //
            if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                // Allocate a new, longer string
                if (FAILED(sc = MAPIAllocateMore(
                  sizeof(TCHAR) * cchSize,
                  lpPropsMAPI,
                  &lpTemp))) {

                    DebugTrace("HrFilterImportMailUserProps:MAPIAllocateMore -> %x\n", sc);
                    hResult = ResultFromScode(sc);
                    goto exit;
                }

                // append the msn site
                StrCpyN(lpTemp, lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ, cchSize);
                StrCatBuff(lpTemp, szMSNpostfix, cchSize);
                lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ = lpTemp;

                // Convert MSN addrtype to SMTP
                lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ = (LPTSTR)szSMTP;

            } else {
                // No address, nuke ADDRTYPE
                lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;
            }

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szCOMPUSERVE)) {
			ULONG cchSize = lstrlen(lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ) + 1 + cbCOMPUSERVEpostfix;
            DebugTrace("COMPUSERVE address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            //
            // Handle COMPUSERVE Address conversion
            //
            if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                // Allocate a new, longer string
                if (FAILED(sc = MAPIAllocateMore(
                  sizeof(TCHAR)*cchSize,
                  lpPropsMAPI,
                  &lpTemp))) {

                    DebugTrace("HrFilterImportMailUserProps:MAPIAllocateMore -> %x\n", sc);
                    hResult = ResultFromScode(sc);
                    goto exit;
                }

                // append the Compuserve site
                StrCpyN(lpTemp, lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ, cchSize);
                StrCatBuff(lpTemp, szCOMPUSERVEpostfix, cchSize);
                lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ = lpTemp;

                // I need to convert the ',' to a '.'
                while (*lpTemp) {
                    if (*lpTemp == ',') {
                        *lpTemp = '.';
                        break;          // should only be one comma
                    }
                    lpTemp = CharNext(lpTemp);
                }

                // Convert COMPUSERVE addrtype to SMTP
                lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ = (LPTSTR)szSMTP;

            } else {
                // No address, nuke ADDRTYPE
                lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;
            }

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szMSNINET)) {
			ULONG cchSize = 
                lstrlen(lpPropsMAPI[iPR_MSNINET_ADDRESS].Value.LPSZ) + cbAtSign +
                lstrlen(lpPropsMAPI[iPR_MSNINET_DOMAIN].Value.LPSZ) + 1;
            DebugTrace("MSINET address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            //
            // Handle MSN Internet address conversion.  These are weird.
            // They often don't fill in the PR_EMAIL_ADDRESS at all, but do fill
            // in some private properties: 6001 and 6002 with the name and domain,
            // respectively.  We should take these and append them with the '@' to
            // get our PR_EMAIL_ADDRESS.  We will toss out any existing
            // PR_EMAIL_ADDRESS in favor of these values.
            //
            // Allocate a new string
            //
            if ((iPR_MSNINET_ADDRESS  != NOT_FOUND) && (iPR_MSNINET_DOMAIN != NOT_FOUND)) {
                if (FAILED(sc = MAPIAllocateMore(sizeof(TCHAR)*cchSize,
                  lpPropsMAPI,
                  &lpTemp))) {
                    DebugTrace("HrFilterImportMailUserProps:MAPIAllocateMore -> %x\n", sc);
                    hResult = ResultFromScode(sc);
                    goto exit;
                }

                // Build the address
                StrCpyN(lpTemp, lpPropsMAPI[iPR_MSNINET_ADDRESS].Value.LPSZ, cchSize);
                StrCatBuff(lpTemp, szAtSign, cchSize);
                StrCatBuff(lpTemp, lpPropsMAPI[iPR_MSNINET_DOMAIN].Value.LPSZ, cchSize);
                lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ = lpTemp;

                // Convert addrtype to SMTP
                lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ = (LPTSTR)szSMTP;
            } else if (iPR_EMAIL_ADDRESS && lstrlen(lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ)) {
                // keep existing PR_EMAIL_ADDRES and assume it's ok
                lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ = (LPTSTR)szSMTP;
            } else {
                // No address, nuke ADDRTYPE
                lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;
            }

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szMS)) {
            DebugTrace("MS address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            // No SMTP form of a MSMail address.  destroy it.
            if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                lpPropsMAPI[iPR_EMAIL_ADDRESS].ulPropTag = PR_NULL;
                fBadAddress = TRUE;
            }
            lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szX400)) {
            DebugTrace("X400 address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            // No SMTP form of a X400 address.  destroy it.
            if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                lpPropsMAPI[iPR_EMAIL_ADDRESS].ulPropTag = PR_NULL;
                fBadAddress = TRUE;
            }
            lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szMSA)) {
            DebugTrace("MacMail address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            //  No SMTP form of a MacMail address. destroy it.
            if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                lpPropsMAPI[iPR_EMAIL_ADDRESS].ulPropTag = PR_NULL;
                fBadAddress = TRUE;
            }
            lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;

        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szEX)) {
            DebugTrace("EX address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);

            if (lpTemp = GetEMSSMTPAddress(lpObjectMAPI, lpPropsMAPI)) {

                lpPropsMAPI[iPR_EMAIL_ADDRESS].Value.LPSZ = lpTemp;

                // Convert addrtype to SMTP
                lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ = (LPTSTR)szSMTP;

                // Make sure that caller doesn't think this is a Personal DL.
                *lpfDL = FALSE;
                if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                    lpPropsMAPI[iPR_OBJECT_TYPE].ulPropTag = PR_OBJECT_TYPE;
                    lpPropsMAPI[iPR_OBJECT_TYPE].Value.l = MAPI_MAILUSER;
                }

            } else {
                if (iPR_EMAIL_ADDRESS != NOT_FOUND) {
                    lpPropsMAPI[iPR_EMAIL_ADDRESS].ulPropTag = PR_NULL;
                    fBadAddress = TRUE;
                }
                lpPropsMAPI[iPR_ADDRTYPE].ulPropTag = PR_NULL;
            }


        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szSMTP)) {
            DebugTrace("SMTP address for %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
        } else if (! lstrcmpi(lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ, szMAPIPDL)) {
            DebugTrace("MAPIPDL %s\n", lpPropsMAPI[iPR_DISPLAY_NAME].Value.LPSZ);
            // Distribution list, ignore it.
        } else {
            MAPIDebugProperties(lpPropsMAPI, cProps, "Unknown address type");
            DebugTrace("Found unknown PR_ADDRTYPE: %s\n", lpPropsMAPI[iPR_ADDRTYPE].Value.LPSZ);
            Assert(FALSE);
        }
    }


    // PR_BUSINESS_FAX_NUMBER?
    // The PAB puts the Fax number in PR_PRIMARY_FAX_NUMBER, but the WAB UI splits it
    // into PR_BUSINESS_FAX_NUMBER and PR_HOME_FAX_NUMBER.  We always assume that the
    // Primary fax number is business.
    if ((iPR_PRIMARY_FAX_NUMBER != NOT_FOUND) && (iPR_BUSINESS_FAX_NUMBER == NOT_FOUND)) {
        // We need to also have a PR_BUSINESS_FAX_NUMBER
        // Find the next PR_NULL spot.
        iPR_BUSINESS_FAX_NUMBER = iPR_PRIMARY_FAX_NUMBER;   // overwrite this one if there isn't
                                                            // an available slot in the prop array.
        for (i = 0; i < cProps; i++) {
            if (lpPropsMAPI[i].ulPropTag == PR_NULL) {
                iPR_BUSINESS_FAX_NUMBER = i;
                lpPropsMAPI[iPR_BUSINESS_FAX_NUMBER].Value.LPSZ =
                  lpPropsMAPI[iPR_PRIMARY_FAX_NUMBER].Value.LPSZ;
                break;
            }
        }

        lpPropsMAPI[iPR_BUSINESS_FAX_NUMBER].ulPropTag = PR_BUSINESS_FAX_NUMBER;
    }


    // Get rid of PR_NULL props
    for (i = 0; i < cProps; i++) {
        if (lpPropsMAPI[i].ulPropTag == PR_NULL) {
            // Slide the props down.
            if (i + 1 < cProps) {       // Are there any higher props to copy?
                CopyMemory(&lpPropsMAPI[i], &lpPropsMAPI[i + 1], ((cProps - i) - 1) * sizeof(lpPropsMAPI[i]));
            }
            // decrement count
            cProps--;
            i--;    // You overwrote the current propval.  Look at it again.
        }
    }


    // Reallocate as WAB memory.
    if (sc = ScCountProps(cProps, lpPropsMAPI, &cbProps)) {
        hResult = ResultFromScode(sc);
        DebugTrace("ScCountProps -> %x\n", sc);
        goto exit;
    }

    if (sc = WABAllocateBuffer(cbProps, &lpPropsWAB)) {
        hResult = ResultFromScode(sc);
        DebugTrace("WABAllocateBuffer -> %x\n", sc);
        goto exit;
    }

    if (sc = ScCopyProps(cProps,
      lpPropsMAPI,
      lpPropsWAB,
      NULL)) {
        hResult = ResultFromScode(sc);
        DebugTrace("ScCopyProps -> %x\n", sc);
        goto exit;
    }

exit:
    if (lpPropsMAPI) {
        MAPIFreeBuffer(lpPropsMAPI);
    }

    if (HR_FAILED(hResult)) {
        if (lpPropsWAB) {
            WABFreeBuffer(lpPropsWAB);
            lpPropsWAB = NULL;
        }
        cProps = 0;
    } else if (fBadAddress) {
        hResult = ResultFromScode(WAB_W_BAD_EMAIL);
    }

    *lppProps = lpPropsWAB;
    *lpcProps = cProps;

    return(hResult);
}


/***************************************************************************

    Name      : HandleImportError

    Purpose   : Decides if a dialog needs to be displayed to
                indicate the failure and does so.

    Parameters: hwnd = main dialog window
                ids = String ID (optional: calculated from hResult if 0)
                hResult = Result of action
                lpDisplayName = display name of object that failed
                lpEmailAddress = email address of object that failed or NULL
                lpImportOptions -> import options structure

    Returns   : TRUE if user requests ABORT.

    Comment   : Abort is not yet implemented in the dialog, but if you
                ever want to, just make this routine return TRUE;

***************************************************************************/
BOOL HandleImportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_IMPORT_OPTIONS lpImportOptions) {
    BOOL fAbort = FALSE;
    ERROR_INFO EI;

    if ((ids || hResult) && ! lpImportOptions->fNoErrors) {
        if (ids == 0) {
            switch (GetScode(hResult)) {
                case WAB_W_BAD_EMAIL:
                    ids = lpEmailAddress ? IDS_ERROR_EMAIL_ADDRESS_2 : IDS_ERROR_EMAIL_ADDRESS_1;
                    break;

                case MAPI_E_NO_SUPPORT:
                    // Propbably failed to open contents on a distribution list
                    ids = IDS_ERROR_NO_SUPPORT;
                    break;

                case MAPI_E_USER_CANCEL:
                    return(TRUE);

                default:
                    if (HR_FAILED(hResult)) {
                        DebugTrace("Error Box for Hresult: 0x%08x\n", GetScode(hResult));
                        Assert(FALSE);      // want to know about it.
                        ids = IDS_ERROR_GENERAL;
                    }
                    break;
            }
        }

        EI.lpszDisplayName = lpDisplayName;
        EI.lpszEmailAddress = lpEmailAddress;
        EI.ErrorResult = ERROR_OK;
        EI.ids = ids;
        EI.fExport = FALSE;
        EI.lpImportOptions = lpImportOptions;

        DialogBoxParam(hInst,
          MAKEINTRESOURCE(IDD_ErrorImport),
          hwnd,
          ErrorDialogProc,
          (LPARAM)&EI);

        fAbort = EI.ErrorResult == ERROR_ABORT;
    }

    return(fAbort);
}


/***************************************************************************

    Name      : FindExistingWABEntry

    Purpose   : Finds an existing entry in the WAB

    Parameters: lpProps -> PropArray of MAPI entry
                cProps = number of props in lpProps
                lpContainerWAB -> WAB Container object
                lppEIDWAB -> returned EntryID (caller must WABFreeBuffer)
                lpcbEIDWAB -> returned size of lppEID

    Returns   : HRESULT

    Comment   : At this point, we expect to find a match since
                SaveChanges said we had a duplicate.

***************************************************************************/
HRESULT FindExistingWABEntry(LPSPropValue lpProps,
  ULONG cProps,
  LPABCONT lpContainerWAB,
  LPENTRYID * lppEIDWAB,
  LPULONG lpcbEIDWAB) {
    ULONG rgFlagList[2];
    LPFlagList lpFlagList = (LPFlagList)rgFlagList;
    LPADRLIST lpAdrListWAB = NULL;
    SCODE sc;
    HRESULT hResult = hrSuccess;
    LPSBinary lpsbEntryID = NULL;
    ULONG cbEID = 0;


    *lpcbEIDWAB = 0;
    *lppEIDWAB = NULL;


    // find the existing WAB entry.
    // Setup for ResolveNames on the WAB container.
    if (sc = WABAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), &lpAdrListWAB)) {
        DebugTrace("WAB Allocation(ADRLIST) failed -> %x\n", sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }
    lpAdrListWAB->cEntries = 1;
    lpAdrListWAB->aEntries[0].ulReserved1 = 0;
    lpAdrListWAB->aEntries[0].cValues = 1;

    if (sc = WABAllocateBuffer(sizeof(SPropValue), &lpAdrListWAB->aEntries[0].rgPropVals)) {
        DebugTrace("WAB Allocation(ADRENTRY propval) failed -> %x\n", sc);
        hResult = ResultFromScode(sc);
        goto exit;
    }
    lpAdrListWAB->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
    if (! (lpAdrListWAB->aEntries[0].rgPropVals[0].Value.LPSZ =
      FindStringInProps(lpProps, cProps, PR_DISPLAY_NAME))) {
        DebugTrace("Can't find PR_DISPLAY_NAME in entry\n");
        // pretty weird if this caused a collision...
        goto exit;
    }

    lpFlagList->cFlags = 1;
    lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

    if (HR_FAILED(hResult = lpContainerWAB->lpVtbl->ResolveNames(lpContainerWAB,
      NULL,            // tag set
      0,               // ulFlags
      lpAdrListWAB,
      lpFlagList))) {
        DebugTrace("WAB ResolveNames -> %x\n", GetScode(hResult));
        goto exit;
    }

    switch (lpFlagList->ulFlag[0]) {
        case MAPI_UNRESOLVED:
            DebugTrace("WAB ResolveNames didn't find the entry\n");
            hResult = ResultFromScode(MAPI_E_NOT_FOUND);
            goto exit;
        case MAPI_AMBIGUOUS:
#ifdef NEW_STUFF
            // Do it the hard way.  Open a table, restrict, take the first match.
            lpContainerWAB->lpVtbl->GetContentsTable(lpContainerWAB,

            if (HR_FAILED(hResult = lpContainerWAB->lpVtbl->GetContentsTable(lpContainerWAB,
              0,    // ulFlags
              &lpTableWAB))) {
                DebugTrace("ImportEntry:GetContentsTable(WAB) -> %x\n", GetScode(hResult));
                goto exit;
            }

            lpTableWAB->lpVtbl->Restrict....... // just the ones that match our entry...

            cRows = 1;
            while (cRows) {
                // Get the next DL entry
                if (hResult = lpTableWAB->lpVtbl->QueryRows(lpTableWAB,
                  1,    // one row at a time
                  0,    // ulFlags
                  &lpRow)) {
                    DebugTrace("DL: QueryRows -> %x\n", GetScode(hResult));
                    goto exit;
                }

                if (lpRow && lpRow->cRows) {
                    Assert(lpRow->cRows == 1);
                    Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
                    Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
                    Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

                } else {
                    break;  // done
                }
            }
#endif // NEW_STUFF
            break;
    }

    // Find the PR_ENTRYID
    if (! (lpsbEntryID = FindAdrEntryID(lpAdrListWAB, 0))) {
        DebugTrace("WAB ResolveNames didn't give us an EntryID\n");
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }

    *lpcbEIDWAB = lpsbEntryID->cb;

    if (FAILED(sc = WABAllocateBuffer(*lpcbEIDWAB, lppEIDWAB))) {
        DebugTrace("ImportEntry: WABAllocateBuffer(WAB ENTRYID) -> %x\n", sc);
        hResult = ResultFromScode(sc);
        *lpcbEIDWAB = 0;
        goto exit;
    }

    // Copy the new EntryID into the buffer
    CopyMemory(*lppEIDWAB, lpsbEntryID->lpb, *lpcbEIDWAB);
exit:
    if (lpAdrListWAB) {
        WABFreePadrlist(lpAdrListWAB);
    }

    return(hResult);
}


/****************************************************************************
*
* CheckReversedDisplayName(lpDisplayName);
*
* PAB and outlook display names are "LastName, FirstName"
* We need to reverse this for the WAB to handle it correctly ...
*
*
*****************************************************************************/
void CheckReversedDisplayName(LPTSTR lpDisplayName)
{
    TCHAR szTemp[MAX_PATH * 3];
    LPTSTR lp1=NULL, lp2=NULL;
	ULONG cchSize = lstrlen(lpDisplayName);

    if(!lpDisplayName)
        return;

    lp1 = lp2 = lpDisplayName;

    while(lp1 && *lp1)
    {
        if(*lp1 == ',')
        {
            // A comma means this is Last, First
            // We will make an assumption here that "L, F" or "L,F" is longer than or equal to "F L" and so
            // we can reverse the name in place without any problems
            //
            lp2 = CharNext(lp1);
            //skip spaces
            while (IsSpace(lp2)) {
                lp2 = CharNext(lp2);
            }
            *lp1 = '\0';
            StrCpyN(szTemp, lpDisplayName, ARRAYSIZE(szTemp));
            StrCpyN(lpDisplayName, lp2, cchSize);
            StrCatBuff(lpDisplayName, TEXT(" "), cchSize);
            StrCatBuff(lpDisplayName, szTemp, cchSize);
            break;
        }
        lp1 = CharNext(lp1);
    }
    return;
}


/***************************************************************************

    Name      : ImportEntry

    Purpose   : Migrates the entry from the PAB to the WAB

    Parameters: hwnd = main dialog window
                lpAdrBookMAPI -> MAPI AdrBook object
                lpContainerWAB -> WAB PAB container
                lpCreateEIDsWAB -> SPropValue of default object creation EIDs
                ulObjectType = {MAPI_MAILUSER, MAPI_DISTLIST}
                lpEID -> ENTYRID of the PAB entry
                cbEID = sizeof lpEID
                lppEIDWAB -> returned WAB ENTRYID: Caller must WABFreeBuffer.
                  May be NULL.
                lpcbEIDWAB -> returned size of lppEIDWAB (ignored if lppEIDWAB
                  is NULL.
                fInDL = TRUE if this entry is for creation in a Distribution List
                fForceReplace = TRUE if this entry should replace any duplicate.

    Returns   : HRESULT

    Comment   : This routine is a MESS!  Should break it up when we get time.

***************************************************************************/
HRESULT ImportEntry(HWND hwnd,
  LPADRBOOK lpAdrBookMAPI,
  LPABCONT lpContainerWAB,
  LPSPropValue lpCreateEIDsWAB,
  ULONG ulObjectType,
  LPENTRYID lpEID,
  ULONG cbEID,
  LPENTRYID * lppEIDWAB,
  LPULONG lpcbEIDWAB,
  BOOL fInDL,
  BOOL fForceReplace) {
    HRESULT hResult = hrSuccess;
    SCODE sc;
    BOOL fDistList = FALSE;
    BOOL fDuplicate = FALSE;
    BOOL fDuplicateEID;
    BOOL fReturnEID = FALSE;
    ULONG ulObjectTypeOpen;
    LPDISTLIST lpDistListMAPI = NULL, lpDistListWAB = NULL;
    LPMAPIPROP lpMailUserMAPI = NULL, lpMailUserWAB = NULL;
    LPSPropValue lpProps = NULL;
    ULONG cProps, cEIDPropWAB;
    LPMAPITABLE lpDLTableMAPI = NULL;
    ULONG cRows;
    LPSRowSet lpRow = NULL;
    LPENTRYID lpeidDLWAB = NULL;
    ULONG cbeidDLWAB;
    LPSPropValue lpEIDPropWAB = NULL;
    LPMAPIPROP lpEntryWAB = NULL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    REPLACE_INFO RI;
    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    static TCHAR szBufferDLMessage[MAX_RESOURCE_STRING + 1] = "";
    LPTSTR lpszMessage;
    LONG lListIndex = -1;
    LPENTRYID lpEIDNew = NULL;
    DWORD cbEIDNew = 0;
    LPIID lpIIDOpen;
    ULONG iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;


    // Check the entry against our "seen" list
    fDuplicateEID = AddEntryToImportList(cbEID, lpEID, &lListIndex);

    if (! fDuplicateEID) {
        if ((fForceReplace || (lpImportOptions->ReplaceOption == WAB_REPLACE_ALWAYS)) && ! fInDL) {
            ulCreateFlags |= CREATE_REPLACE;
        }

        // Set up some object type specific variables
        switch (ulObjectType) {
            default:
                DebugTrace("ImportEntry got unknown object type %u, assuming MailUser\n", ulObjectType);
                Assert(FALSE);

            case MAPI_MAILUSER:
                iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
                lpIIDOpen = NULL;
                fDistList = FALSE;
                break;

            case MAPI_DISTLIST:
                iCreateTemplate = iconPR_DEF_CREATE_DL;
                lpIIDOpen = (LPIID)&IID_IDistList;
                fDistList = TRUE;

                break;
        }


        // Open the entry
        if (HR_FAILED(hResult = lpAdrBookMAPI->lpVtbl->OpenEntry(lpAdrBookMAPI,
          cbEID,
          lpEID,
          lpIIDOpen,
          0,
          &ulObjectTypeOpen,
          (LPUNKNOWN *)&lpMailUserMAPI))) {
            DebugTrace("OpenEntry(MAPI MailUser) -> %x\n", GetScode(hResult));
            goto exit;
        }
        // If DISTLIST, assume we got lpMailUser until we need lpDistList.

        Assert(lpMailUserMAPI);
        Assert(ulObjectType == ulObjectTypeOpen);

        // Get the properties from this entry
        if (HR_FAILED(hResult = lpMailUserMAPI->lpVtbl->GetProps(lpMailUserMAPI,
          NULL,
          0,
          &cProps,
          &lpProps))) {
            DebugTrace("ImportEntry:GetProps(MAPI) -> %x\n", GetScode(hResult));
            goto exit;
        }

        //
        // NOTE: Must not fail between here and HrFilterImportMailUserProps because
        // we will end up freeing lpProps with WABFreeBuffer.
        //

        // Filter the property array here
        if (hResult = HrFilterImportMailUserProps(&cProps, &lpProps, lpMailUserMAPI, &fDistList)) {
            lpDisplayName = FindStringInProps(lpProps, cProps, PR_DISPLAY_NAME);
            lpEmailAddress = FindStringInProps(lpProps, cProps, PR_EMAIL_ADDRESS);

            if (HandleImportError(hwnd,
              0,
              hResult,
              lpDisplayName,
              lpEmailAddress,
              lpImportOptions)) {
                hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                goto exit;
            }
        }
        lpDisplayName = FindStringInProps(lpProps, cProps, PR_DISPLAY_NAME);
        lpEmailAddress = FindStringInProps(lpProps, cProps, PR_EMAIL_ADDRESS);

        CheckReversedDisplayName(lpDisplayName);

        if (ulObjectType == MAPI_DISTLIST && ! fDistList) {
            // Filter must have changed this to a mailuser.
            ulObjectType = MAPI_MAILUSER;
            iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
            lpIIDOpen = NULL;
        }

        //
        // NOTE: lpProps after this point is WAB Allocated rather than MAPI allocated.
        //

        if (HR_FAILED(hResult = lpContainerWAB->lpVtbl->CreateEntry(lpContainerWAB,
          lpCreateEIDsWAB[iCreateTemplate].Value.bin.cb,
          (LPENTRYID)lpCreateEIDsWAB[iCreateTemplate].Value.bin.lpb,
          ulCreateFlags,
          &lpMailUserWAB))) {
            DebugTrace("CreateEntry(WAB MailUser) -> %x\n", GetScode(hResult));
            goto exit;
        }

        if (fDistList) {
            // Update status message
            if (*szBufferDLMessage == '\0') {   // only load once, then keep it.
                LoadString(hInst, IDS_MESSAGE_IMPORTING_DL, szBufferDLMessage, ARRAYSIZE(szBufferDLMessage));
            }
            if (lpDisplayName) {
				ULONG cchSize = lstrlen(szBufferDLMessage) + 1 + lstrlen(lpDisplayName);
                if (lpszMessage = LocalAlloc(LMEM_FIXED, sizeof(TCHAR)*cchSize)) {
                    wnsprintf(lpszMessage, cchSize, szBufferDLMessage, lpDisplayName);
                    DebugTrace("Status Message: %s\n", lpszMessage);
                    if (! SetDlgItemText(hwnd, IDC_Message, lpszMessage)) {
                        DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                    }
                    LocalFree(lpszMessage);
                }
            }
        }


        // Set the properties on the WAB entry
        if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
          cProps,                   // cValues
          lpProps,                  // property array
          NULL))) {                 // problems array
            DebugTrace("ImportEntry:SetProps(WAB) -> %x\n", GetScode(hResult));
            goto exit;
        }


        // Save the new wab mailuser or distlist
        if (HR_FAILED(hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
          KEEP_OPEN_READONLY | FORCE_SAVE))) {

            if (GetScode(hResult) == MAPI_E_COLLISION) {
                // Find the display name
                if (! lpDisplayName) {
                    DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                    goto exit;
                }

                // Do we need to prompt?
//                if (! fInDL && lpImportOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
                if (lpImportOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
                    // Prompt user with dialog.  If they say YES, we should
                    // recurse with the FORCE flag set.

                    RI.lpszDisplayName = lpDisplayName;
                    RI.lpszEmailAddress = lpEmailAddress;
                    RI.ConfirmResult = CONFIRM_ERROR;
                    RI.fExport = FALSE;
                    RI.lpImportOptions = lpImportOptions;

                    DialogBoxParam(hInst,
                      MAKEINTRESOURCE(IDD_ImportReplace),
                      hwnd,
                      ReplaceDialogProc,
                      (LPARAM)&RI);

                    switch(RI.ConfirmResult) {
                        case CONFIRM_YES:
                        case CONFIRM_YES_TO_ALL:
                            // YES
                            // NOTE: recursive Migrate will fill in the SeenList entry
                            hResult = ImportEntry(hwnd,
                              lpAdrBookMAPI,
                              lpContainerWAB,
                              lpCreateEIDsWAB,
                              ulObjectType,
                              lpEID,
                              cbEID,
                              &lpEIDNew,    // Need this for later
                              &cbEIDNew,
                              FALSE,
                              TRUE);
                            if (hResult) {
                                if (HandleImportError(hwnd,
                                  0,
                                  hResult,
                                  lpDisplayName,
                                  lpEmailAddress,
                                  lpImportOptions)) {
                                    hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                } else {
                                    hResult = hrSuccess;
                                }
                            }
                            break;

                        case CONFIRM_ABORT:
                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                            goto exit;

                        default:
                            // NO
                            fDuplicate = TRUE;
                            break;
                    }
                } else {
                        fDuplicate = TRUE;
                }

                hResult = hrSuccess;

            } else {
                DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
            }
        } else {
            // What is the ENTRYID of our new entry?
            if ((hResult = lpMailUserWAB->lpVtbl->GetProps(lpMailUserWAB,
              (LPSPropTagArray)&ptaEid,
              0,
              &cEIDPropWAB,
              &lpEIDPropWAB))) {
                DebugTrace("ImportEntry: GetProps(WAB ENTRYID) -> %x\n", GetScode(hResult));
                goto exit;
            }

            Assert(cEIDPropWAB);
            Assert(lpEIDPropWAB[ieidPR_ENTRYID].ulPropTag == PR_ENTRYID);

            cbEIDNew = lpEIDPropWAB[0].Value.bin.cb;

            if (FAILED(sc = WABAllocateBuffer(cbEIDNew, &lpEIDNew))) {
                DebugTrace("ImportEntry: WABAllocateBuffer(WAB ENTRYID) -> %x\n", sc);
                hResult = ResultFromScode(sc);
                goto exit;
            }

            // Copy the new EntryID into the buffer
            CopyMemory(lpEIDNew, lpEIDPropWAB[0].Value.bin.lpb, cbEIDNew);
        }


        //
        // If this is a DISTLIST, fill it in.
        //
        if (fDistList && ! fDuplicate && cbEIDNew) {
            lpDistListMAPI = (LPDISTLIST)lpMailUserMAPI;    // This is REALLY a DISTLIST object
            // DO NOT Release this!

            // Open the new WAB DL as a DISTLIST object
            if (HR_FAILED(hResult = lpContainerWAB->lpVtbl->OpenEntry(lpContainerWAB,
              cbEIDNew,
              lpEIDNew,
              (LPIID)&IID_IDistList,
              MAPI_MODIFY,
              &ulObjectTypeOpen,
              (LPUNKNOWN*)&lpDistListWAB))) {
                DebugTrace("ImportEntry: WAB OpenEntry(IID_DistList) -> %x\n", GetScode(hResult));
                goto exit;
            }
            Assert(lpDistListWAB);


            // For each entry in the DL:
            //  Migrate the entry (MailUser or DL) recursively
            //  Add new entryid to DL contents
            if (HR_FAILED(hResult = lpDistListMAPI->lpVtbl->GetContentsTable(lpDistListMAPI,
              0,    // ulFlags
              &lpDLTableMAPI ))) {
                DebugTrace("ImportEntry:GetContentsTable(MAPI) -> %x\n", GetScode(hResult));
                goto exit;
            }


            // Set the columns to those we're interested in
            if (hResult = lpDLTableMAPI->lpVtbl->SetColumns(lpDLTableMAPI,
              (LPSPropTagArray)&ptaColumns,
              0)) {
                DebugTrace("MAPI SetColumns(DL Table) -> %x\n", GetScode(hResult));
                goto exit;
            }

            cRows = 1;
            while (cRows) {
                // Get the next DL entry
                if (hResult = lpDLTableMAPI->lpVtbl->QueryRows(lpDLTableMAPI,
                  1,    // one row at a time
                  0,    // ulFlags
                  &lpRow)) {
                    DebugTrace("DL: QueryRows -> %x\n", GetScode(hResult));
                    goto exit;
                }

                if (lpRow && lpRow->cRows) {
                    Assert(lpRow->cRows == 1);
                    Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
                    Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
                    Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

                    if (lpRow) {
                        if (cRows = lpRow->cRows) { // yes, single '='
                            hResult = ImportEntry(hwnd,
                              lpAdrBookMAPI,
                              lpContainerWAB,
                              lpCreateEIDsWAB,
                              lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].Value.l,
                              (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                              lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                              &lpeidDLWAB,        // returned new or existing entry
                              &cbeidDLWAB,
                              TRUE,
                              FALSE);
                            if (hResult) {
                                if (HandleImportError(hwnd,
                                  0,
                                  hResult,
                                  lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                                  PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                                  lpImportOptions)) {
                                    hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                    break;  // out of loop
                                } else {
                                    hResult = hrSuccess;
                                }
                            }
                        } // else, drop out of loop, we're done.
                        FreeProws(lpRow);
                        lpRow = NULL;

                        if (HR_FAILED(hResult)) {
                            // This entry couldn't be created.  Ignore it.
                            DebugTrace("Coudln't create DL entry -> %x\n", GetScode(hResult));
                            hResult = hrSuccess;
                            continue;
                        }

                        // Add the Entry to the DL using the new entry's EntryID
                        if (cbeidDLWAB && lpeidDLWAB) {
                            // BUGBUG: Don't bother with this one if this is a duplicate entry.
                            if (HR_FAILED(hResult = lpDistListWAB->lpVtbl->CreateEntry(lpDistListWAB,
                              cbeidDLWAB,
                              lpeidDLWAB,
                              0,                // allow duplicates here
                              &lpEntryWAB))) {
                                DebugTrace("Couldn't create new entry in DL -> %x\n", GetScode(hResult));
                                break;
                            }

                            hResult = lpEntryWAB->lpVtbl->SaveChanges(lpEntryWAB, FORCE_SAVE);

                            if (lpEntryWAB) {
                                lpEntryWAB->lpVtbl->Release(lpEntryWAB);
                                lpEntryWAB = NULL;
                            }
                        }

                        if (lpeidDLWAB) {
                            WABFreeBuffer(lpeidDLWAB);
                            lpeidDLWAB = NULL;
                        }
                    }
                } else {
                    break;  // done
                }
            }
        }
    } else {
        DebugTrace("Found a duplicate EntryID\n");
    }

    //
    // Save the entryid to the list and return a buffer with it
    //
    if (cbEIDNew && lpEIDNew) {                         // We created one?
        // created one
    } else if (fDuplicateEID && lListIndex != -1) {     // Was it in the list?
        cbEIDNew  = lpEntriesSeen[lListIndex].sbinWAB.cb;
        if (FAILED(sc = WABAllocateBuffer(cbEIDNew, &lpEIDNew))) {
            DebugTrace("ImportEntry: WABAllocateBuffer(WAB ENTRYID) -> %x\n", sc);
            // ignore
            cbEIDNew = 0;
        } else {
            // Copy the EntryID from the list into the buffer
            CopyMemory(lpEIDNew, lpEntriesSeen[lListIndex].sbinWAB.lpb, cbEIDNew);
        }

    } else if (fDuplicate) {                            // Was it a duplicate
        FindExistingWABEntry(lpProps, cProps, lpContainerWAB, &lpEIDNew, &cbEIDNew);
        // ignore errors since the lpEIDNew and cbEIDNew will be nulled out
    }

    // Update the seen list
    if (! fDuplicateEID) {
        MarkWABEntryInList(cbEIDNew, lpEIDNew, lListIndex);
    }

    // If caller requested the entryid's, return them
    if (lpcbEIDWAB && lppEIDWAB) {
        *lpcbEIDWAB = cbEIDNew;
        *lppEIDWAB = lpEIDNew;
        fReturnEID = TRUE;          // don't free it
    }

exit:
    //
    // Cleanup WAB stuff
    //
    if (lpProps) {
        WABFreeBuffer(lpProps);
    }

    if (lpEIDPropWAB) {
        WABFreeBuffer(lpEIDPropWAB);
    }

    if (lpEIDNew && ! fReturnEID) {
        WABFreeBuffer(lpEIDNew);
    }

    if (lpeidDLWAB) {
        WABFreeBuffer(lpeidDLWAB);
    }

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
    }

    if (lpDistListWAB) {
        lpDistListWAB->lpVtbl->Release(lpDistListWAB);
    }

    //
    // Cleanup MAPI stuff
    //
    if (lpRow) {
        FreeProws(lpRow);
    }

    if (lpDLTableMAPI) {
        lpDLTableMAPI->lpVtbl->Release(lpDLTableMAPI);
    }

    if (lpMailUserMAPI) {
        lpMailUserMAPI->lpVtbl->Release(lpMailUserMAPI);
    }

// Do not release this... It is the same object as lpMailUserMAPI!
//    if (lpDistListMAPI) {
//        lpDistListMAPI->lpVtbl->Release(lpDistListMAPI);
//    }

    if (! HR_FAILED(hResult)) {
        hResult = hrSuccess;
    }

    return(hResult);
}


/*
 *  PAB EXPORT
 *
 *  Migrate WAB to PAB
 */

BOOL HandleExportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_EXPORT_OPTIONS lpExportOptions);
void StateExportNextMU(HWND hwnd);
void StateExportDL(HWND hwnd);
void StateExportNextDL(HWND hwnd);
void StateExportFinish(HWND hwnd);
void StateExportMU(HWND hwnd);
void StateExportError(HWND hwnd);
void StateExportCancel(HWND hwnd);
HRESULT ExportEntry(HWND hwnd,
  LPADRBOOK lpAdrBookMAPI,
  LPABCONT lpContainerWAB,
  LPSPropValue lpCreateEIDsWAB,
  ULONG ulObjectType,
  LPENTRYID lpEID,
  ULONG cbEID,
  LPENTRYID * lppEIDWAB,
  LPULONG lpcbEIDWAB,
  BOOL fInDL,
  BOOL fForceReplace);

LPSPropTagArray lpspta = NULL;  // List of tags to export
LPTSTR * lppNames = NULL;       // List of names of tags


//
// Map property tags to strings
//

PROP_NAME rgPropNames[NUM_MORE_EXPORT_PROPS] = {
    //  ulPropTag,                          fChosen, ids,                                       lpszName    lpszName
    // Personal Pane
    PR_GIVEN_NAME,                          FALSE,  ids_ExportGivenName,                        NULL,       NULL,
    PR_SURNAME,                             FALSE,  ids_ExportSurname,                          NULL,       NULL,
    PR_MIDDLE_NAME,                         FALSE,  ids_ExportMiddleName,                       NULL,       NULL,
    PR_DISPLAY_NAME,                        TRUE,   ids_ExportDisplayName,                      NULL,       NULL,
    PR_NICKNAME,                            FALSE,  ids_ExportNickname,                         NULL,       NULL,
    PR_EMAIL_ADDRESS,                       TRUE,   ids_ExportEmailAddress,                     NULL,       NULL,

    // Home Pane
    PR_HOME_ADDRESS_STREET,                 TRUE,   ids_ExportHomeAddressStreet,                NULL,       NULL,
    PR_HOME_ADDRESS_CITY,                   TRUE,   ids_ExportHomeAddressCity,                  NULL,       NULL,
    PR_HOME_ADDRESS_POSTAL_CODE,            TRUE,   ids_ExportHomeAddressPostalCode,            NULL,       NULL,
    PR_HOME_ADDRESS_STATE_OR_PROVINCE,      TRUE,   ids_ExportHomeAddressState,                 NULL,       NULL,
    PR_HOME_ADDRESS_COUNTRY,                TRUE,   ids_ExportHomeAddressCountry,               NULL,       NULL,
    PR_HOME_TELEPHONE_NUMBER,               TRUE,   ids_ExportHomeTelephoneNumber,              NULL,       NULL,
    PR_HOME_FAX_NUMBER,                     FALSE,  ids_ExportHomeFaxNumber,                    NULL,       NULL,
    PR_CELLULAR_TELEPHONE_NUMBER,           FALSE,  ids_ExportCellularTelephoneNumber,          NULL,       NULL,
    PR_PERSONAL_HOME_PAGE,                  FALSE,  ids_ExportPersonalHomePage,                 NULL,       NULL,

    // Business Pane
    PR_BUSINESS_ADDRESS_STREET,             TRUE,   ids_ExportBusinessAddressStreet,            NULL,       NULL,
    PR_BUSINESS_ADDRESS_CITY,               TRUE,   ids_ExportBusinessAddressCity,              NULL,       NULL,
    PR_BUSINESS_ADDRESS_POSTAL_CODE,        TRUE,   ids_ExportBusinessAddressPostalCode,        NULL,       NULL,
    PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,  TRUE,   ids_ExportBusinessAddressStateOrProvince,   NULL,       NULL,
    PR_BUSINESS_ADDRESS_COUNTRY,            TRUE,   ids_ExportBusinessAddressCountry,           NULL,       NULL,
    PR_BUSINESS_HOME_PAGE,                  FALSE,  ids_ExportBusinessHomePage,                 NULL,       NULL,
    PR_BUSINESS_TELEPHONE_NUMBER,           TRUE,   ids_ExportBusinessTelephoneNumber,          NULL,       NULL,
    PR_BUSINESS_FAX_NUMBER,                 FALSE,  ids_ExportBusinessFaxNumber,                NULL,       NULL,
    PR_PAGER_TELEPHONE_NUMBER,              FALSE,  ids_ExportPagerTelephoneNumber,             NULL,       NULL,
    PR_COMPANY_NAME,                        TRUE,   ids_ExportCompanyName,                      NULL,       NULL,
    PR_TITLE,                               TRUE,   ids_ExportTitle,                            NULL,       NULL,
    PR_DEPARTMENT_NAME,                     FALSE,  ids_ExportDepartmentName,                   NULL,       NULL,
    PR_OFFICE_LOCATION,                     FALSE,  ids_ExportOfficeLocation,                   NULL,       NULL,

    // Notes Pane
    PR_COMMENT,                             FALSE,  ids_ExportComment,                          NULL,       NULL,
};


/***************************************************************************

    Name      : StateExportMU

    Purpose   : Start the migration of MailUsers

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Login to MAPI
                Open the WAB
                Open the MAPI AB
                Open the WAB container
                Get the WAB contents table
                Restrict it to PR_OBJECTTYPE == MAPI_MAILUSER
                Post new state(STATE_NEXT_MU)

***************************************************************************/
void StateExportMU(HWND hwnd) {
    HRESULT hResult;
    ULONG ulFlags;
    ULONG cbPABEID, cbWABEID;
    LPENTRYID lpPABEID = NULL, lpWABEID = NULL;
    ULONG ulObjType;
    ULONG_PTR ulUIParam = (ULONG_PTR)(void *)hwnd;
    SRestriction restrictObjectType;
    SPropValue spvObjectType;
    ULONG cProps;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    WAB_PARAM wp = {0};
    LPWAB_PARAM lpwp = NULL;

    //
    // Logon to MAPI and open the MAPI Address book, if one exists
    //
    DebugTrace(">>> STATE_EXPORT_MU\n");

    SetDialogMessage(hwnd, IDS_STATE_LOGGING_IN);

    if (FAILED(hResult = MAPIInitialize(NULL))) {
        DebugTrace("MAPIInitialize -> %x\n", GetScode(hResult));
        switch (GetScode(hResult)) {
            case MAPI_E_NOT_ENOUGH_MEMORY:
                SetDialogMessage(hwnd, IDS_ERROR_NOT_ENOUGH_MEMORY);
                break;
            case MAPI_E_NOT_ENOUGH_DISK:
                SetDialogMessage(hwnd, IDS_ERROR_NOT_ENOUGH_DISK);
                break;

            default:
            case MAPI_E_NOT_FOUND:
            case MAPI_E_NOT_INITIALIZED:
                SetDialogMessage(hwnd, IDS_ERROR_MAPI_DLL_NOT_FOUND);
                break;
        }
#ifdef OLD_STUFF
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);    // hide progress bar
#endif // OLD_STUFF
        fError = TRUE;
        hResult = hrSuccess;
        goto exit;
    }


    ulFlags = MAPI_LOGON_UI | MAPI_NO_MAIL | MAPI_EXTENDED;

    if (FAILED(hResult = MAPILogonEx(ulUIParam,
      NULL,
      NULL,
      ulFlags,
      (LPMAPISESSION FAR *)&lpMAPISession))) {
        DebugTrace("MAPILogonEx -> %x\n", GetScode(hResult));
        switch (GetScode(hResult)) {
            case MAPI_E_USER_CANCEL:
                SetDialogMessage(hwnd, IDS_STATE_EXPORT_IDLE);
                break;
            case MAPI_E_NOT_INITIALIZED:
                SetDialogMessage(hwnd, IDS_ERROR_MAPI_DLL_NOT_FOUND);
                break;
            default:
                SetDialogMessage(hwnd, IDS_ERROR_MAPI_LOGON);
                break;
        }
#ifdef OLD_STUFF
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);    // hide progress bar
#endif // OLD_STUFF
        fError = TRUE;
        hResult = hrSuccess;
        goto exit;
    }

    if (hResult = lpMAPISession->lpVtbl->OpenAddressBook(lpMAPISession, (ULONG_PTR)(void *)hwnd,
      NULL,
      0,
      &lpAdrBookMAPI)) {
        DebugTrace("OpenAddressBook(MAPI) -> %x", GetScode(hResult));
        if(FAILED(hResult)) {
            goto exit;
        }
    }

    if (! lpAdrBookMAPI) {
        DebugTrace("MAPILogonEx didn't return a valid AdrBook object\n");
        goto exit;
    }

    //
    // Open the MAPI PAB container
    //
    // [PaulHi] Raid #63578 1/7/98
    // Correctly check return code and provide user error message if
    // Exchange PAB cannot be opened.
    //
    hResult = lpAdrBookMAPI->lpVtbl->GetPAB(lpAdrBookMAPI,
        &cbPABEID,
        &lpPABEID);
    if (HR_FAILED(hResult))
    {
        DebugTrace("MAPI GetPAB -> %x\n", GetScode(hResult));
        goto exit;
    }
    else
    {
        hResult = lpAdrBookMAPI->lpVtbl->OpenEntry(lpAdrBookMAPI,
            cbPABEID,     // size of EntryID to open
            lpPABEID,     // EntryID to open
            NULL,         // interface
            MAPI_MODIFY,  // flags
            &ulObjType,
            (LPUNKNOWN *)&lpContainerMAPI);
        if (HR_FAILED(hResult))
        {
            DebugTrace("MAPI OpenEntry(PAB) -> %x\n", GetScode(hResult));
            goto exit;
        }
    }

    Assert(lpAdrBookWAB);

    //
    // Open the WAB's PAB container
    //
    if (hResult = lpAdrBookWAB->lpVtbl->GetPAB(lpAdrBookWAB,
      &cbWABEID,
      &lpWABEID)) {
        DebugTrace("WAB GetPAB -> %x\n", GetScode(hResult));
        goto exit;
    } else {
        if (hResult = lpAdrBookWAB->lpVtbl->OpenEntry(lpAdrBookWAB,
          cbWABEID,     // size of EntryID to open
          lpWABEID,     // EntryID to open
          NULL,         // interface
          0,            // flags
          &ulObjType,
          (LPUNKNOWN *)&lpContainerWAB)) {
            DebugTrace("WAB OpenEntry(PAB) -> %x\n", GetScode(hResult));
            goto exit;
        }
    }


    // Get the PAB's creation entryids
    hResult = lpContainerMAPI->lpVtbl->GetProps(lpContainerMAPI,
        (LPSPropTagArray)&ptaCon,
        0,
        &cProps,
        &lpCreateEIDsMAPI);
    if (HR_FAILED(hResult))
    {
        DebugTrace("Can't get container properties for PAB\n");
        // Bad stuff here!
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }

    // Validate the properites
    if (lpCreateEIDsMAPI[iconPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
      lpCreateEIDsMAPI[iconPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL)
    {
        DebugTrace("MAPI: Container property errors\n");
        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        goto exit;
    }


    //
    // All set... now loop through the WAB's entries, copying them to PAB
    //
    if (HR_FAILED(hResult = lpContainerWAB->lpVtbl->GetContentsTable(lpContainerWAB,
      0,    // ulFlags
      &lpContentsTableWAB))) {
        DebugTrace("WAB GetContentsTable(PAB Table) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Set the columns to those we're interested in
    if (hResult = lpContentsTableWAB->lpVtbl->SetColumns(lpContentsTableWAB,
      (LPSPropTagArray)&ptaColumns,
      0)) {
        DebugTrace("WAB SetColumns(PAB Table) -> %x\n", GetScode(hResult));
        goto exit;
    }

    // Restrict the table to MAPI_MAILUSERs
    // If the convenient depth flag was not specified we restrict on
    // PR_DEPTH == 1.
    spvObjectType.ulPropTag = PR_OBJECT_TYPE;
    spvObjectType.Value.l = MAPI_MAILUSER;

    restrictObjectType.rt = RES_PROPERTY;
    restrictObjectType.res.resProperty.relop = RELOP_EQ;
    restrictObjectType.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
    restrictObjectType.res.resProperty.lpProp = &spvObjectType;

    if (HR_FAILED(hResult = lpContentsTableWAB->lpVtbl->Restrict(lpContentsTableWAB,
      &restrictObjectType,
      0))) {
        DebugTrace("WAB Restrict (MAPI_MAILUSER) -> %x\n", GetScode(hResult));
        goto exit;
    }
    SetDialogMessage(hwnd, IDS_STATE_EXPORT_MU);


    // Initialize the Progress Bar
    // How many MailUser entries are there?
    ulcEntries = CountRows(lpContentsTableWAB, FALSE);

    DebugTrace("WAB contains %u MailUser entries\n", ulcEntries);

    SetDialogProgress(hwnd, ulcEntries, 0);
exit:
    if (lpWABEID) {
        WABFreeBuffer(lpWABEID);
    }

    if (lpPABEID) {
        MAPIFreeBuffer(lpPABEID);
    }

    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult))
    {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL)
        {
            NewState(hwnd, STATE_EXPORT_CANCEL);
        }
        else
        {
            // [PaulHi] 1/7/98  Error reporting is hosed
            // Display error message here to the user to ensure they
            // get it.
            {
                TCHAR   tszBuffer[MAX_RESOURCE_STRING];
                TCHAR   tszBufferTitle[MAX_RESOURCE_STRING];

                if ( !LoadString(hInst, IDS_STATE_EXPORT_ERROR_NOPAB, tszBuffer, MAX_RESOURCE_STRING-1) )
                {
                    Assert(0);
                    tszBuffer[0] = '\0';
                }

                if ( !LoadString(hInst, IDS_APP_TITLE, tszBufferTitle, MAX_RESOURCE_STRING-1) )
                {
                    Assert(0);
                    tszBufferTitle[0] = '\0';
                }
                MessageBox(hwnd, tszBuffer, tszBufferTitle, MB_ICONEXCLAMATION | MB_OK);
            }

            NewState(hwnd, STATE_EXPORT_ERROR);
        }
    }
    else if (fError)
    {
        NewState(hwnd, STATE_EXPORT_FINISH);      // must be logon error
    }
    else
    {
        NewState(hwnd, STATE_EXPORT_NEXT_MU);
    }
}


/***************************************************************************

    Name      : StateExportNextMU

    Purpose   : Migrate the next MailUser object

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : QueryRows on the global WAB contents table
                if there was a row
                    Migrate the entry to the PAB
                    Re-post STATE_EXPORT_NEXT_MU
                else
                    Post STATE_EXPORT_DL

***************************************************************************/
void StateExportNextMU(HWND hwnd) {
    ULONG cRows = 0;
    HRESULT hResult;
    LPSRowSet lpRow = NULL;


    DebugTrace(">>> STATE_EXPORT_NEXT_MU\n");
    Assert(lpContentsTableWAB);

    // Get the next WAB entry
    if (hResult = lpContentsTableWAB->lpVtbl->QueryRows(lpContentsTableWAB,
      1,    // one row at a time
      0,    // ulFlags
      &lpRow)) {
        DebugTrace("QueryRows -> %x\n", GetScode(hResult));
        goto exit;
    }

    if (lpRow) {
        if (cRows = lpRow->cRows) { // Yes, single '='
            Assert(lpRow->cRows == 1);
            Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

            if (cRows = lpRow->cRows) { // yes, single '='
                hResult = ExportEntry(hwnd,
                  lpAdrBookWAB,
                  lpContainerMAPI,
                  lpCreateEIDsMAPI,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].Value.l,
                  (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                  NULL,
                  NULL,
                  FALSE,
                  FALSE);
                // Update Progress Bar
                // ignore errors!

                SetDialogProgress(hwnd, ulcEntries, ++ulcDone);

                if (hResult) {
                    if (HandleExportError(hwnd,
                      0,
                      hResult,
                      lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                      PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                      lpExportOptions)) {
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    } else {
                        hResult = hrSuccess;
                    }
                }
            } // else, drop out of loop, we're done.
        }
        WABFreeProws(lpRow);
    }

exit:
    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult)) {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL) {
            NewState(hwnd, STATE_EXPORT_CANCEL);
        } else {
            NewState(hwnd, STATE_EXPORT_ERROR);
        }
    } else {
        if (cRows) {
            NewState(hwnd, STATE_EXPORT_NEXT_MU);
        } else {
            NewState(hwnd, STATE_EXPORT_DL);
        }
    }
}


/***************************************************************************

    Name      : StateExportDL

    Purpose   : Start migration of DISTLIST objects

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Set a new restriction on the contents table, selecting
                DISTLIST objects only.
                Post STATE_EXPORT_NEXT_DL

***************************************************************************/
void StateExportDL(HWND hwnd) {
    HRESULT hResult;
    SRestriction restrictObjectType;
    SPropValue spvObjectType;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];


    DebugTrace(">>> STATE_EXPORT_DL\n");

    // Restrict the table to MAPI_MAILUSERs
    // If the convenient depth flag was not specified we restrict on
    // PR_DEPTH == 1.
    spvObjectType.ulPropTag = PR_OBJECT_TYPE;
    spvObjectType.Value.l = MAPI_DISTLIST;

    restrictObjectType.rt = RES_PROPERTY;
    restrictObjectType.res.resProperty.relop = RELOP_EQ;
    restrictObjectType.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
    restrictObjectType.res.resProperty.lpProp = &spvObjectType;

    if (HR_FAILED(hResult = lpContentsTableWAB->lpVtbl->Restrict(lpContentsTableWAB,
      &restrictObjectType,
      0))) {
        DebugTrace("WAB Restrict (MAPI_DISTLIST) -> %x\n", GetScode(hResult));
        goto exit;
    }
    // Restrict resets the current position to the beginning of the table, by definition.

    SetDialogMessage(hwnd, IDS_STATE_EXPORT_DL);

    // Initialize the Progress Bar
    // How many entries are there?

    ulcEntries = CountRows(lpContentsTableWAB, FALSE);

    DebugTrace("WAB contains %u Distribution List entries\n", ulcEntries);
    if (ulcEntries) {
        SetDialogProgress(hwnd, ulcEntries, 0);
    }
exit:
    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult)) {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL) {
            NewState(hwnd, STATE_EXPORT_CANCEL);
        } else {
            NewState(hwnd, STATE_EXPORT_ERROR);
        }
    } else {
        NewState(hwnd, STATE_EXPORT_NEXT_DL);
    }
}


/***************************************************************************

    Name      : StateExportNextDL

    Purpose   : Migrate the next DISTLIST object

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : QueryRows on the global WAB contents table
                if there was a row
                    Migrate the DistList to the PAB
                    Re-post STATE_EXPORT_NEXT_DL
                else
                    Post STATE_EXPORT_FINISH

***************************************************************************/
void StateExportNextDL(HWND hwnd) {
    ULONG cRows = 0;
    HRESULT hResult;
    LPSRowSet lpRow = NULL;


    DebugTrace(">>> STATE_EXPORT_NEXT_DL\n");

    // Get the next WAB entry
    if (hResult = lpContentsTableWAB->lpVtbl->QueryRows(lpContentsTableWAB,
      1,    // one row at a time
      0,    // ulFlags
      &lpRow)) {
        DebugTrace("QueryRows -> %x\n", GetScode(hResult));
        goto exit;
    }

    if (lpRow) {
        if (cRows = lpRow->cRows) { // Yes, single '='
            Assert(lpRow->cRows == 1);
            Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
            Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

            if (cRows = lpRow->cRows) { // yes, single '='
                hResult = ExportEntry(hwnd,
                  lpAdrBookWAB,
                  lpContainerMAPI,
                  lpCreateEIDsMAPI,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].Value.l,
                  (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                  lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                  NULL,
                  NULL,
                  FALSE,
                  FALSE);

                // Update Progress Bar
                SetDialogProgress(hwnd, ulcEntries, ++ulcDone);

                if (hResult) {
                    if (HandleExportError(hwnd,
                      0,
                      hResult,
                      lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                      PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                      lpExportOptions)) {
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    } else {
                        hResult = hrSuccess;
                    }
                }
            } // else, drop out of loop, we're done.
        }
        WABFreeProws(lpRow);
    }

exit:
    // On error, set the state to STATE_ERROR
    if (HR_FAILED(hResult)) {
        if (GetScode(hResult) == MAPI_E_USER_CANCEL) {
            NewState(hwnd, STATE_EXPORT_CANCEL);
        } else {
            NewState(hwnd, STATE_EXPORT_ERROR);
        }
    } else {
        if (cRows) {
            NewState(hwnd, STATE_EXPORT_NEXT_DL);
        } else {
            // Update Progress Bar to indicate completion
            SetDialogProgress(hwnd, ulcEntries, ulcEntries);
            NewState(hwnd, STATE_EXPORT_FINISH);
        }
    }
}


/***************************************************************************

    Name      : StateExportFinish

    Purpose   : Clean up after the migration process

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Clean up the global MAPI objects and buffers
                Clean up the global WAB objects and buffers.
                Re-enable the Export button on the UI.

***************************************************************************/
void StateExportFinish(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    TCHAR szBufferTitle[MAX_RESOURCE_STRING + 1];


    DebugTrace(">>> STATE_EXPORT_FINISH\n");

    //
    // Cleanup MAPI
    //
    if (lpContainerMAPI) {
        lpContainerMAPI->lpVtbl->Release(lpContainerMAPI);
        lpContainerMAPI = NULL;
    }

    if (lpAdrBookMAPI) {
        lpAdrBookMAPI->lpVtbl->Release(lpAdrBookMAPI);
        lpAdrBookMAPI = NULL;
    }
    if(lpMAPISession){
        lpMAPISession->lpVtbl->Logoff(lpMAPISession, (ULONG_PTR)(void *)hwnd,
          MAPI_LOGOFF_UI,
          0);

        lpMAPISession->lpVtbl->Release(lpMAPISession);
        lpMAPISession = NULL;
    }

    //
    // Cleanup the WAB
    //
    if (lpContentsTableWAB) {
        lpContentsTableWAB->lpVtbl->Release(lpContentsTableWAB);
        lpContentsTableWAB = NULL;
    }

    if (lpCreateEIDsWAB) {
        WABFreeBuffer(lpCreateEIDsWAB);
        lpCreateEIDsWAB = NULL;
    }

    if (lpContainerWAB) {
        lpContainerWAB->lpVtbl->Release(lpContainerWAB);
        lpContainerWAB = NULL;
    }

#ifdef OLD_STUFF        // Don't release AdrBookWAB or WABObject
    if (lpAdrBookWAB) {
        lpAdrBookWAB->lpVtbl->Release(lpAdrBookWAB);
        lpAdrBookWAB = NULL;
    }

    if (lpWABObject) {
        lpWABObject->lpVtbl->Release(lpWABObject);
        lpWABObject = NULL;
    }
#endif // OLD_STUFF

    // Cleanup the cache
    FreeSeenList();

    if (! fError) {     // Leave error state displayed
        if (LoadString(hInst, IDS_STATE_EXPORT_COMPLETE, szBuffer, ARRAYSIZE(szBuffer))) {
            DebugTrace("Status Message: %s\n", szBuffer);
            SetDlgItemText(hwnd, IDC_Message, szBuffer);

            if (! LoadString(hInst, IDS_APP_TITLE, szBufferTitle, ARRAYSIZE(szBufferTitle))) {
                StrCpyN(szBufferTitle, "", ARRAYSIZE(szBufferTitle));
            }

#ifdef OLD_STUFF
            // Display a dialog telling user it's over
            MessageBox(hwnd, szBuffer,
              szBufferTitle, MB_ICONINFORMATION | MB_OK);
#endif // OLD_STUFF
        }
#ifdef OLD_STUFF
        ShowWindow(GetDlgItem(hwnd, IDC_Progress), SW_HIDE);
#endif // OLD_STUFF
    }
    fError = FALSE;

    // Re-enable the Export button here.
    EnableWindow(GetDlgItem(hwnd, IDC_Export), TRUE);
    // Change the Cancel button to Close
    if (LoadString(hInst, IDS_BUTTON_CLOSE, szBuffer, ARRAYSIZE(szBuffer))) {
        SetDlgItemText(hwnd, IDCANCEL, szBuffer);
    }
}


/***************************************************************************

    Name      : StateExportError

    Purpose   : Report fatal error and cleanup.

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Report error and post STATE_EXPORT_FINISH.

***************************************************************************/
void StateExportError(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace(">>> STATE_EXPORT_ERROR\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_EXPORT_ERROR);

    NewState(hwnd, STATE_EXPORT_FINISH);
}


/***************************************************************************

    Name      : StateExportCancel

    Purpose   : Report cancel error and cleanup.

    Parameters: hwnd = window handle of Export Dialog

    Returns   : none

    Comment   : Report error and post STATE_EXPORT_FINISH.

***************************************************************************/
void StateExportCancel(HWND hwnd) {
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
    // Set some global flag and set state to finish

    DebugTrace(">>> STATE_EXPORT_CANCEL\n");
    fError = TRUE;

    SetDialogMessage(hwnd, IDS_STATE_EXPORT_CANCEL);

    NewState(hwnd, STATE_EXPORT_FINISH);
}


/***************************************************************************

    Name      : HrFilterExportMailUserProps

    Purpose   : Filters out undesirable properties from the property array.
                Converts known email address types to SMTP.
                Moves FAX address to PR_BUSINESS_FAX_NUMBER.

    Parameters: lpcProps -> IN: Input number of properties
                            OUT: Output number of properties
                lppProps -> IN: Input property array (MAPI allocation)
                            OUT: Output property array (WAB allocation)
                lpObjectWAB -> WAB object (used to get extra props)
                lpfDL -> flag to set FALSE if we change a DL to a MAILUSER
                         (ie, for an EXchange DL)

    Returns   : HRESULT

    Comment   : Setting the property tag in the array to PR_NULL effectively
                nulls this property out.  We can re-use these in the second
                pass.

                Caller should use MAPIFreeBuffer to free *lppProps.
                This routine will free the input value of *lppProps.

                WARNING: This routine will add dummy properties to the
                input WAB object, so don't go doing SaveChanges on it!

***************************************************************************/
#define MAX_ADD_PROPS   2
#define PR_DUMMY_1      PROP_TAG(PT_LONG,      0xF000)
#define PR_DUMMY_2      PROP_TAG(PT_LONG,      0xF001)

HRESULT HrFilterExportMailUserProps(LPULONG lpcProps, LPSPropValue * lppProps,
  LPMAPIPROP lpObjectWAB, LPBOOL lpfDL) {
    HRESULT hResult = hrSuccess;
    ULONG i;
    LPSPropValue lpPropsWAB, lpPropsMAPI = NULL;
    ULONG cbProps;
    SCODE sc;
    ULONG cProps;
    ULONG iPR_ADDRTYPE = NOT_FOUND;
    ULONG iPR_EMAIL_ADDRESS = NOT_FOUND;
    ULONG iPR_PRIMARY_FAX_NUMBER = NOT_FOUND;
    ULONG iPR_BUSINESS_FAX_NUMBER = NOT_FOUND;
    ULONG iPR_MSNINET_DOMAIN = NOT_FOUND;
    ULONG iPR_MSNINET_ADDRESS = NOT_FOUND;
    ULONG iPR_DISPLAY_NAME = NOT_FOUND;
    ULONG iPR_OBJECT_TYPE = NOT_FOUND;
    ULONG iPR_SEND_RICH_INFO = NOT_FOUND;
    LPSBinary lpEntryID = NULL;
    LPTSTR lpTemp;
    BOOL fBadAddress = FALSE;
    SPropValue rgPropsDummy[MAX_ADD_PROPS] = {
        PR_DUMMY_1, 0, 1,
        PR_DUMMY_2, 0, 2,
    };


    // Set extra bogus props on the object in case we need to add more props
    // to the array later.  These will be PR_NULL'ed out by the first pass.
    if (HR_FAILED(hResult = lpObjectWAB->lpVtbl->SetProps(lpObjectWAB,
      MAX_ADD_PROPS,
      rgPropsDummy,
      NULL))) {
        DebugTrace("HrFilterExportMailUserProps:SetProps dummy props -> %x\n", GetScode(hResult));
        // ignore the error
    }


    // Get the properties from this entry
    if (HR_FAILED(hResult = lpObjectWAB->lpVtbl->GetProps(lpObjectWAB,
      NULL,
      0,
      &cProps,
      &lpPropsWAB))) {
        DebugTrace("HrFilterExportMailUserProps:GetProps(WAB) -> %x\n", GetScode(hResult));
        return(hResult);
    }

//    WABDebugProperties(lpPropsWAB, *lpcProps, "MailUser BEFORE");


    // First pass: Remove the junk
    for (i = 0; i < cProps; i++) {
        // Error value
        if (PROP_ERROR(lpPropsWAB[i])) {
            lpPropsWAB[i].ulPropTag = PR_NULL;
            continue;
        }

        // Named property
        if (PROP_ID(lpPropsWAB[i].ulPropTag) >= MIN_NAMED_PROPID) {
            lpPropsWAB[i].ulPropTag = PR_NULL;
            continue;
        }

        // Object property
        if (PROP_TYPE(lpPropsWAB[i].ulPropTag) == PT_OBJECT) {
            lpPropsWAB[i].ulPropTag = PR_NULL;
            continue;
        }
        switch (lpPropsWAB[i].ulPropTag) {
            case PR_ENTRYID:
                lpEntryID = &lpPropsWAB[i].Value.bin;
                // fall through

            case PR_PRIMARY_CAPABILITY:
            case PR_TEMPLATEID:
            case PR_SEARCH_KEY:
            case PR_INITIAL_DETAILS_PANE:
            case PR_RECORD_KEY:
            case PR_MAPPING_SIGNATURE:
                lpPropsWAB[i].ulPropTag = PR_NULL;
                break;

            case PR_COMMENT:
                // Don't save PR_COMMENT if it is empty
                if (lstrlen(lpPropsWAB[i].Value.LPSZ) == 0) {
                    lpPropsWAB[i].ulPropTag = PR_NULL;
                }
                break;

            // Keep track of the position of these for later
            case PR_ADDRTYPE:
                iPR_ADDRTYPE = i;
                break;
            case PR_OBJECT_TYPE:
                iPR_OBJECT_TYPE = i;
                break;
            case PR_EMAIL_ADDRESS:
                iPR_EMAIL_ADDRESS = i;
                break;
            case PR_PRIMARY_FAX_NUMBER:
                iPR_PRIMARY_FAX_NUMBER = i;
                break;
            case PR_BUSINESS_FAX_NUMBER:
                iPR_BUSINESS_FAX_NUMBER = i;
                break;
            case PR_MSNINET_ADDRESS:
                iPR_MSNINET_ADDRESS = i;
                break;
            case PR_MSNINET_DOMAIN:
                iPR_MSNINET_DOMAIN = i;
                break;
            case PR_DISPLAY_NAME:
                iPR_DISPLAY_NAME = i;
                break;
            case PR_SEND_RICH_INFO:
                iPR_SEND_RICH_INFO = i;
                break;
        }

        // Put this after the switch since we do want to track a few props which fall in
        // the 0x6000 range but don't want to transfer them to the wab.
        if (PROP_ID(lpPropsWAB[i].ulPropTag) >= MAX_SCHEMA_PROPID) {
            lpPropsWAB[i].ulPropTag = PR_NULL;
            continue;
        }
    }


    // Second pass: Fix up the addresses
    if (iPR_ADDRTYPE != NOT_FOUND) {
        if (! lstrcmpi(lpPropsWAB[iPR_ADDRTYPE].Value.LPSZ, szSMTP)) {
            DebugTrace("SMTP address for %s\n", lpPropsWAB[iPR_DISPLAY_NAME].Value.LPSZ);
        } else if (! lstrcmpi(lpPropsWAB[iPR_ADDRTYPE].Value.LPSZ, szMAPIPDL)) {
            DebugTrace("MAPIPDL %s\n", lpPropsWAB[iPR_DISPLAY_NAME].Value.LPSZ);
            // Distribution list, ignore it.
        } else {
            WABDebugProperties(lpPropsWAB, cProps, "Unknown address type");
            DebugTrace("Found unknown PR_ADDRTYPE: %s\n", lpPropsWAB[iPR_ADDRTYPE].Value.LPSZ);
            Assert(FALSE);
        }
    }

    // PR_BUSINESS_FAX_NUMBER?
    // The PAB puts the Fax number in PR_PRIMARY_FAX_NUMBER, but the WAB UI splits it
    // into PR_BUSINESS_FAX_NUMBER and PR_HOME_FAX_NUMBER.  We always map business to
    // Primary fax number and ignore home fax number.
    if ((iPR_BUSINESS_FAX_NUMBER != NOT_FOUND) && (iPR_PRIMARY_FAX_NUMBER == NOT_FOUND)) {
        // We need to also have a PR_PRIMARY_FAX_NUMBER
        // Find the next PR_NULL spot.
        iPR_PRIMARY_FAX_NUMBER = iPR_BUSINESS_FAX_NUMBER;   // overwrite this one if there isn't
                                                             // an available slot in the prop array.
        for (i = 0; i < cProps; i++) {
            if (lpPropsWAB[i].ulPropTag == PR_NULL) {
                iPR_PRIMARY_FAX_NUMBER = i;
                lpPropsWAB[iPR_PRIMARY_FAX_NUMBER].Value.LPSZ =
                  lpPropsWAB[iPR_BUSINESS_FAX_NUMBER].Value.LPSZ;
                break;
            }
        }

        lpPropsWAB[iPR_PRIMARY_FAX_NUMBER].ulPropTag = PR_PRIMARY_FAX_NUMBER;
    }

    // If there is no PR_SEND_RICH_INFO, make one and set it FALSE
    if (iPR_SEND_RICH_INFO == NOT_FOUND) {
        // Find the next PR_NULL and put it there.
        for (i = 0; i < cProps; i++) {
            if (lpPropsWAB[i].ulPropTag == PR_NULL) {
                iPR_SEND_RICH_INFO = i;
                lpPropsWAB[iPR_SEND_RICH_INFO].Value.b = FALSE;
                lpPropsWAB[iPR_SEND_RICH_INFO].ulPropTag = PR_SEND_RICH_INFO;
                break;
            }
        }
        Assert(iPR_SEND_RICH_INFO != NOT_FOUND);
    }

    // Get rid of PR_NULL props
    for (i = 0; i < cProps; i++) {
        if (lpPropsWAB[i].ulPropTag == PR_NULL) {
            // Slide the props down.
            if (i + 1 < cProps) {       // Are there any higher props to copy?
                CopyMemory(&lpPropsWAB[i], &lpPropsWAB[i + 1], ((cProps - i) - 1) * sizeof(lpPropsWAB[i]));
            }
            // decrement count
            cProps--;
            i--;    // You overwrote the current propval.  Look at it again.
        }
    }

    // Reallocate as MAPI memory.

    if (sc = ScCountProps(cProps, lpPropsWAB, &cbProps)) {
        hResult = ResultFromScode(sc);
        DebugTrace("ScCountProps -> %x\n", sc);
        goto exit;
    }

    if (sc = MAPIAllocateBuffer(cbProps, &lpPropsMAPI)) {
        hResult = ResultFromScode(sc);
        DebugTrace("WABAllocateBuffer -> %x\n", sc);
        goto exit;
    }

    if (sc = ScCopyProps(cProps,
      lpPropsWAB,
      lpPropsMAPI,
      NULL)) {
        hResult = ResultFromScode(sc);
        DebugTrace("ScCopyProps -> %x\n", sc);
        goto exit;
    }

exit:
    if (lpPropsWAB) {
        WABFreeBuffer(lpPropsWAB);
    }

    if (HR_FAILED(hResult)) {
        if (lpPropsMAPI) {
            MAPIFreeBuffer(lpPropsMAPI);
            lpPropsMAPI = NULL;
        }
        cProps = 0;
    } else if (fBadAddress) {
        hResult = ResultFromScode(WAB_W_BAD_EMAIL);
    }

    *lppProps = lpPropsMAPI;
    *lpcProps = cProps;

    return(hResult);
}


/***************************************************************************

    Name      : HandleExportError

    Purpose   : Decides if a dialog needs to be displayed to
                indicate the failure and does so.

    Parameters: hwnd = main dialog window
                ids = String ID (optional: calculated from hResult if 0)
                hResult = Result of action
                lpDisplayName = display name of object that failed
                lpEmailAddress = email address of object that failed (or NULL)

    Returns   : TRUE if user requests ABORT.

    Comment   : Abort is not yet implemented in the dialog, but if you
                ever want to, just make this routine return TRUE;

***************************************************************************/
BOOL HandleExportError(HWND hwnd, ULONG ids, HRESULT hResult, LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress, LPWAB_EXPORT_OPTIONS lpExportOptions) {
    BOOL fAbort = FALSE;
    ERROR_INFO EI;

    if ((ids || hResult) && ! lpExportOptions->fNoErrors) {
        if (ids == 0) {
            switch (GetScode(hResult)) {
                case WAB_W_BAD_EMAIL:
                    ids = lpEmailAddress ? IDS_ERROR_EMAIL_ADDRESS_2 : IDS_ERROR_EMAIL_ADDRESS_1;
                    break;

                case MAPI_E_NO_SUPPORT:
                    // Propbably failed to open contents on a distribution list
                    ids = IDS_ERROR_NO_SUPPORT;
                    break;

                case MAPI_E_USER_CANCEL:
                    return(TRUE);

                default:
                    if (HR_FAILED(hResult)) {
                        DebugTrace("Error Box for Hresult: 0x%08x\n", GetScode(hResult));
                        Assert(FALSE);      // want to know about it.
                        ids = IDS_ERROR_GENERAL;
                    }
                    break;
            }
        }

        EI.lpszDisplayName = lpDisplayName;
        EI.lpszEmailAddress = lpEmailAddress;
        EI.ErrorResult = ERROR_OK;
        EI.ids = ids;
        EI.fExport = TRUE;
        EI.lpImportOptions = lpExportOptions;

        DialogBoxParam(hInst,
          MAKEINTRESOURCE(IDD_ErrorExport),
          hwnd,
          ErrorDialogProc,
          (LPARAM)&EI);

        fAbort = EI.ErrorResult == ERROR_ABORT;
    }

    return(fAbort);
}


/***************************************************************************

    Name      : AddEntryToExportList

    Purpose   : Checks this entry against our "seen" list and adds it.

    Parameters: cbEID = size of lpEID
                lpEID -> EntryID of entry
                lplIndex -> returned list index (or -1 on error)

    Returns   : TRUE if entry already exists

    Comment   : Caller must mark the WAB entry!

***************************************************************************/
#define GROW_SIZE   10
BOOL AddEntryToExportList(ULONG cbEID, LPENTRYID lpEID, LPLONG lplIndex) {
    ULONG i;
    LPENTRY_SEEN lpEntrySeen;

    if (cbEID && lpEID) {
        for (i = 0; i < ulEntriesSeen; i++) {
            if (cbEID == lpEntriesSeen[i].sbinPAB.cb  && (! memcmp(lpEID, lpEntriesSeen[i].sbinPAB.lpb, cbEID))) {
                // This one's in the list
                *lplIndex = i;
                // If cb 0, we must have recursed and are replacing, so this one is not a dup.
                return(lpEntriesSeen[i].sbinWAB.cb != 0);
            }
        }

        // Add to the end of the list
        if (++ulEntriesSeen > ulMaxEntries) {
            // Grow the array.

            ulMaxEntries += GROW_SIZE;

            if (lpEntriesSeen) {
                if (! (lpEntrySeen = LocalReAlloc(lpEntriesSeen, ulMaxEntries * sizeof(ENTRY_SEEN), LMEM_MOVEABLE | LMEM_ZEROINIT))) {
                    DebugTrace("LocalReAlloc(%u) -> %u\n", ulMaxEntries * sizeof(ENTRY_SEEN), GetLastError());
                    goto error;
                }
                lpEntriesSeen = lpEntrySeen;
            } else {
                if (! (lpEntriesSeen = LocalAlloc(LPTR, ulMaxEntries * sizeof(ENTRY_SEEN)))) {
                    DebugTrace("LocalAlloc(%u) -> %u\n", ulMaxEntries * sizeof(ENTRY_SEEN), GetLastError());
                    goto error;
                }
            }
        }

        lpEntrySeen = &lpEntriesSeen[ulEntriesSeen - 1];

        // Allocate space for data
        lpEntrySeen->sbinPAB.cb = cbEID;
        if (! (lpEntrySeen->sbinPAB.lpb = LocalAlloc(LPTR, cbEID))) {
            DebugTrace("LocalAlloc(%u) -> %u\n", cbEID, GetLastError());
            goto error;
        }

        // Mark as unknown WAB entry
        lpEntrySeen->sbinWAB.cb = 0;
        lpEntrySeen->sbinWAB.lpb = 0;

        // Copy in the data
        CopyMemory(lpEntrySeen->sbinPAB.lpb, lpEID, cbEID);
        *lplIndex = i;
    }

    return(FALSE);

error:
    // undo the damage...
    --ulEntriesSeen;
    ulMaxEntries -= GROW_SIZE;
    *lplIndex = -1;     // error
    if (! lpEntriesSeen) {
        ulEntriesSeen = 0;  // pointer is null now, back to square one.
        ulMaxEntries = 0;
    }
    return(FALSE);
}


/***************************************************************************

    Name      : MarkPABEntryInList

    Purpose   : Marks the PAB entry fields in the list node

    Parameters: cbEID = size of lpEID
                lpEID -> EntryID of entry
                lIndex = list index (or -1 on error)

    Returns   : none

    Comment   :

***************************************************************************/
void MarkPABEntryInList(ULONG cbEID, LPENTRYID lpEID, LONG lIndex) {
    if (lIndex != -1 && cbEID) {
       if (! (lpEntriesSeen[lIndex].sbinWAB.lpb = LocalAlloc(LPTR, cbEID))) {
           DebugTrace("LocalAlloc(%u) -> %u\n", cbEID, GetLastError());
           // leave it null
       } else {
           lpEntriesSeen[lIndex].sbinWAB.cb = cbEID;

           // Copy in the data
           CopyMemory(lpEntriesSeen[lIndex].sbinWAB.lpb, lpEID, cbEID);
       }
    }
}


//
// Properties to get from the PAB Entry
//
enum {
    ifePR_OBJECT_TYPE = 0,
    ifePR_ENTRYID,
    ifePR_DISPLAY_NAME,
    ifePR_EMAIL_ADDRESS,
    ifeMax
};
static const SizedSPropTagArray(ifeMax, ptaFind) =
{
    ifeMax,
    {
        PR_OBJECT_TYPE,
        PR_ENTRYID,
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS
    }
};
/***************************************************************************

    Name      : FindPABEntry

    Purpose   : Finds the named entry in the PAB

    Parameters: lpContainerPAB -> MAPI PAB container
                ulObjectType = {MAPI_MAILUSER, MAPI_DISTLIST}
                lpDisplayName = name of entry
                lpEmailAddress = email address or NULL if none
                lppEIDMAPI -> returned MAPI ENTRYID: Caller must MAPIFreeBuffer.
                lpcbEIDMAPI -> returned size of lppEIDMAPI

    Returns   : HRESULT

    Comment   : At this point, we expect to find a match since
                SaveChanges said we had a duplicate.

***************************************************************************/
HRESULT FindPABEntry(LPABCONT lpContainerPAB,
  ULONG ulObjectType,
  LPTSTR lpDisplayName,
  LPTSTR lpEmailAddress,
  LPULONG lpcbEIDDup,
  LPENTRYID * lppEIDDup) {
    HRESULT hResult = hrSuccess;
    SCODE sc;
    SRestriction resAnd[3]; // 0 = object type, 1 = displayname, 2 = emailaddress
    SRestriction resFind;
    SPropValue spvObjectType, spvDisplayName, spvEmailAddress;
    LPSRowSet lpRow = NULL;
    LPMAPITABLE lpTable = NULL;
    ULONG rgFlagList[2];
    LPFlagList lpFlagList = (LPFlagList)rgFlagList;
    LPADRLIST lpAdrListMAPI = NULL;
    LPSBinary lpsbEntryID;
    ULONG i;


    // init return values
    *lppEIDDup = NULL;
    *lpcbEIDDup = 0;


    // find the existing PAB entry.
    // Setup for ResolveNames on the PAB container.
    if (sc = MAPIAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), &lpAdrListMAPI)) {
        DebugTrace("MAPI Allocation(ADRLIST) failed -> %x\n", sc);
        hResult = ResultFromScode(sc);
        goto restrict;
    }
    lpAdrListMAPI->cEntries = 1;
    lpAdrListMAPI->aEntries[0].ulReserved1 = 0;
    lpAdrListMAPI->aEntries[0].cValues = 1;

    if (sc = MAPIAllocateBuffer(sizeof(SPropValue), &lpAdrListMAPI->aEntries[0].rgPropVals)) {
        DebugTrace("MAPI Allocation(ADRENTRY propval) failed -> %x\n", sc);
        hResult = ResultFromScode(sc);
        goto restrict;
    }

    lpFlagList->cFlags = 1;

    for (i = 0; i <= 1; i++) {
        switch (i) {
            case 0:     // pass 0
                lpAdrListMAPI->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
                lpAdrListMAPI->aEntries[0].rgPropVals[0].Value.LPSZ = lpDisplayName;
                break;
            case 1:
                if (lpEmailAddress) {
                    lpAdrListMAPI->aEntries[0].rgPropVals[0].ulPropTag = PR_EMAIL_ADDRESS;
                    lpAdrListMAPI->aEntries[0].rgPropVals[0].Value.LPSZ = lpEmailAddress;
                } else {
                    continue;   // no email address, don't bother with second pass
                }
                break;
            default:
                Assert(FALSE);
        }
        lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

        if (HR_FAILED(hResult = lpContainerPAB->lpVtbl->ResolveNames(lpContainerPAB,
          NULL,            // tag set
          0,               // ulFlags
          lpAdrListMAPI,
          lpFlagList))) {
            DebugTrace("MAPI ResolveNames -> %x\n", GetScode(hResult));
            continue;
        }

        switch (lpFlagList->ulFlag[0]) {
            case MAPI_UNRESOLVED:
                DebugTrace("WAB ResolveNames didn't find the entry %s\n", lpDisplayName);
                continue;
            case MAPI_AMBIGUOUS:
                DebugTrace("WAB ResolveNames find ambiguous entry %s\n", lpDisplayName);
                continue;
            case MAPI_RESOLVED:
                i = 2;  // Found it, exit the loop
        }
    }

    if (lpFlagList->ulFlag[0] == MAPI_RESOLVED) {
        // Found one, find its PR_ENTRYID
        if (! (lpsbEntryID = FindAdrEntryID(lpAdrListMAPI, 0))) {
            DebugTrace("MAPI ResolveNames didn't give us an EntryID\n");
            Assert(lpsbEntryID);
            goto restrict;
        }

        *lpcbEIDDup = lpsbEntryID->cb;
        if (FAILED(sc = MAPIAllocateBuffer(*lpcbEIDDup, lppEIDDup))) {
            hResult = ResultFromScode(sc);
            DebugTrace("FindPABEntry couldn't allocate duplicate entryid %x\n", sc);
            goto exit;
        }
        memcpy(*lppEIDDup, lpsbEntryID->lpb, *lpcbEIDDup);
    }


restrict:
    if (! *lppEIDDup) {
        //
        // Last ditch effort... use a table restriction to try to find this entry.
        //

        // Get the contents table
        if (HR_FAILED(hResult = lpContainerPAB->lpVtbl->GetContentsTable(lpContainerPAB,
          0,    // ulFlags
          &lpTable))) {
            DebugTrace("PAB GetContentsTable -> %x\n", GetScode(hResult));
            goto exit;
        }

        // Set the columns
        if (HR_FAILED(hResult = lpTable->lpVtbl->SetColumns(lpTable,
          (LPSPropTagArray)&ptaFind,
          0))) {
            DebugTrace("PAB SetColumns-> %x\n", GetScode(hResult));
            goto exit;
        }

        // Restrict to the object we care about
        resAnd[0].rt = RES_PROPERTY;    // Restriction type Property
        resAnd[0].res.resProperty.relop = RELOP_EQ;
        resAnd[0].res.resProperty.ulPropTag = PR_OBJECT_TYPE;
        resAnd[0].res.resProperty.lpProp = &spvObjectType;
        spvObjectType.ulPropTag = PR_OBJECT_TYPE;
        spvObjectType.Value.ul = ulObjectType;

        // Restrict to get correct display name
        resAnd[1].rt = RES_PROPERTY;    // Restriction type Property
        resAnd[1].res.resProperty.relop = RELOP_EQ;
        resAnd[1].res.resProperty.ulPropTag = PR_DISPLAY_NAME;
        resAnd[1].res.resProperty.lpProp = &spvDisplayName;
        spvDisplayName.ulPropTag = PR_DISPLAY_NAME;
        spvDisplayName.Value.LPSZ = lpDisplayName;

        if (lpEmailAddress) {
            // Restrict to get correct email address
            resAnd[2].rt = RES_PROPERTY;    // Restriction type Property
            resAnd[2].res.resProperty.relop = RELOP_EQ;
            resAnd[2].res.resProperty.ulPropTag = PR_EMAIL_ADDRESS;
            resAnd[2].res.resProperty.lpProp = &spvEmailAddress;
            spvEmailAddress.ulPropTag = PR_EMAIL_ADDRESS;
            spvEmailAddress.Value.LPSZ = lpEmailAddress;
        }

        resFind.rt = RES_AND;
        resFind.res.resAnd.cRes = lpEmailAddress ? 3 : 2;
        resFind.res.resAnd.lpRes = resAnd;

        if (HR_FAILED(hResult = lpTable->lpVtbl->Restrict(lpTable,
          &resFind,
          0))) {
            DebugTrace("FindPABEntry: Restrict -> %x", hResult);
            goto exit;
        }

        if (hResult = lpTable->lpVtbl->QueryRows(lpTable,
          1,    // First row only
          0,    // ulFlags
          &lpRow)) {
            DebugTrace("FindPABEntry: QueryRows -> %x\n", GetScode(hResult));
        } else {
            // Found it, copy entryid to new allocation
            if (lpRow->cRows) {
                *lpcbEIDDup = lpRow->aRow[0].lpProps[ifePR_ENTRYID].Value.bin.cb;
                if (FAILED(sc = MAPIAllocateBuffer(*lpcbEIDDup, lppEIDDup))) {
                    hResult = ResultFromScode(sc);
                    DebugTrace("FindPABEntry couldn't allocate duplicate entryid %x\n", sc);
                    goto exit;
                }
                memcpy(*lppEIDDup, lpRow->aRow[0].lpProps[ifePR_ENTRYID].Value.bin.lpb, *lpcbEIDDup);
            } else {
                hResult = ResultFromScode(MAPI_E_NOT_FOUND);
            }
        }

        // Still not found?!!  Maybe the PAB has a different idea of what the Display name is.
        // Search just by email address.
        if (hResult && lpEmailAddress) {
            resAnd[1] = resAnd[2];  // copy the email address res over the display name res.
            resFind.res.resAnd.cRes = 2;

            if (HR_FAILED(hResult = lpTable->lpVtbl->Restrict(lpTable,
              &resFind,
              0))) {
                DebugTrace("FindPABEntry: Restrict -> %x", hResult);
                goto exit;
            }

            if (hResult = lpTable->lpVtbl->QueryRows(lpTable,
              1,    // First row only
              0,    // ulFlags
              &lpRow)) {
                DebugTrace("FindPABEntry: QueryRows -> %x\n", GetScode(hResult));
            } else {
                // Found it, copy entryid to new allocation
                if (lpRow->cRows) {
                    *lpcbEIDDup = lpRow->aRow[0].lpProps[ifePR_ENTRYID].Value.bin.cb;
                    if (FAILED(sc = MAPIAllocateBuffer(*lpcbEIDDup, lppEIDDup))) {
                        hResult = ResultFromScode(sc);
                        DebugTrace("FindPABEntry couldn't allocate duplicate entryid %x\n", sc);
                        goto exit;
                    }
                    memcpy(*lppEIDDup, lpRow->aRow[0].lpProps[ifePR_ENTRYID].Value.bin.lpb, *lpcbEIDDup);
                } else {
                    hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                    DebugTrace("FindPABEntry coudln't find %s %s <%s>\n",
                      ulObjectType == MAPI_MAILUSER ? "Mail User" : "Distribution List",
                      lpDisplayName,
                      lpEmailAddress ? lpEmailAddress : "");
                }
            }
        }
    }

exit:
    if (lpAdrListMAPI) {
        FreePadrlist(lpAdrListMAPI);
    }
    if (lpRow) {
        FreeProws(lpRow);
    }
    if (lpTable) {
        lpTable->lpVtbl->Release(lpTable);
    }
    if (HR_FAILED(hResult) && *lppEIDDup) {
        MAPIFreeBuffer(*lppEIDDup);
        *lpcbEIDDup = 0;
        *lppEIDDup = NULL;
    }
    if (hResult) {
        DebugTrace("FindPABEntry coudln't find %s %s <%s>\n",
          ulObjectType == MAPI_MAILUSER ? "Mail User" : "Distribution List",
          lpDisplayName,
          lpEmailAddress ? lpEmailAddress : "");
    }

    return(hResult);
}


// enum for setting the created properties
enum {
    irnPR_DISPLAY_NAME = 0,
    irnPR_RECIPIENT_TYPE,
    irnPR_ENTRYID,
    irnPR_EMAIL_ADDRESS,
    irnMax
};

/***************************************************************************

    Name      : ExportEntry

    Purpose   : Migrates the entry from the WAB to the PAB

    Parameters: hwnd = main dialog window
                lpAdrBookWAB -> WAB AdrBook object
                lpContainerMAPI -> MAPI PAB container
                lpCreateEIDsMAPI -> SPropValue of default object creation EIDs
                ulObjectType = {MAPI_MAILUSER, MAPI_DISTLIST}
                lpEID -> ENTYRID of the WAB entry
                cbEID = sizeof lpEID
                lppEIDMAPI -> returned MAPI ENTRYID: Caller must MAPIFreeBuffer.
                  May be NULL.
                lpcbEIDMAPI -> returned size of lppEIDMAPI (ignored if lppEIDMAPI
                  is NULL.
                fInDL = TRUE if this entry is for creation in a Distribution List
                fForceReplace = TRUE if this entry should replace any duplicate.

    Returns   : HRESULT

    Comment   : This routine is a MESS!  Should break it up when we get time.

***************************************************************************/
HRESULT ExportEntry(HWND hwnd,
  LPADRBOOK lpAdrBookWAB,
  LPABCONT lpContainerMAPI,
  LPSPropValue lpCreateEIDsMAPI,
  ULONG ulObjectType,
  LPENTRYID lpEID,
  ULONG cbEID,
  LPENTRYID * lppEIDMAPI,
  LPULONG lpcbEIDMAPI,
  BOOL fInDL,
  BOOL fForceReplace) {
    HRESULT hResult = hrSuccess;
    SCODE sc;
    BOOL fDistList = FALSE;
    BOOL fDuplicate = FALSE;
    BOOL fDuplicateEID;
    BOOL fReturnEID = FALSE;
    ULONG ulObjectTypeOpen;
    LPDISTLIST lpDistListMAPI = NULL, lpDistListWAB = NULL;
    LPMAPIPROP lpMailUserMAPI = NULL, lpMailUserWAB = NULL;
    LPSPropValue lpProps = NULL;
    ULONG cProps, cEIDPropMAPI;
    LPMAPITABLE lpDLTableWAB = NULL;
    ULONG cRows;
    LPSRowSet lpRow = NULL;
    LPENTRYID lpeidDLMAPI = NULL;
    ULONG cbeidDLMAPI;
    LPSPropValue lpEIDPropMAPI = NULL;
    LPMAPIPROP lpEntryMAPI = NULL;
    ULONG ulCreateFlags;
    REPLACE_INFO RI;
    LPTSTR lpDisplayName = NULL, lpEmailAddress = NULL;
    static TCHAR szBufferDLMessage[MAX_RESOURCE_STRING + 1] = "";
    LPTSTR lpszMessage;
    LONG lListIndex = -1;
    LPENTRYID lpEIDNew = NULL;
    DWORD cbEIDNew = 0;
    LPIID lpIIDOpen;
    ULONG iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
    BOOL fCreatedNew = FALSE;
    LPENTRYID lpEIDDup = NULL;
    ULONG cbEIDDup;


    // Check the entry against our "seen" list
    fDuplicateEID = AddEntryToExportList(cbEID, lpEID, &lListIndex);

    if (! fDuplicateEID) {
        // Set up some object type specific variables
        switch (ulObjectType) {
            default:
                DebugTrace("ExportEntry got unknown object type %u, assuming MailUser\n", ulObjectType);
                Assert(FALSE);

            case MAPI_MAILUSER:
                iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
                lpIIDOpen = NULL;
                fDistList = FALSE;
                break;

            case MAPI_DISTLIST:
                iCreateTemplate = iconPR_DEF_CREATE_DL;
                lpIIDOpen = (LPIID)&IID_IDistList;
                fDistList = TRUE;

                break;
        }


        // Open the entry
        if (HR_FAILED(hResult = lpAdrBookWAB->lpVtbl->OpenEntry(lpAdrBookWAB,
          cbEID,
          lpEID,
          lpIIDOpen,
          MAPI_MODIFY,      // need to do SetProps inside Filter routine, but won't save them.
          &ulObjectTypeOpen,
          (LPUNKNOWN *)&lpMailUserWAB))) {
            DebugTrace("OpenEntry(WAB MailUser) -> %x\n", GetScode(hResult));
            goto exit;
        }
        // If DISTLIST, assume we got lpMailUser until we need lpDistList.

        Assert(lpMailUserWAB);
        Assert(ulObjectType == ulObjectTypeOpen);

        //
        // NOTE: Must not fail between here and HrFilterExportMailUserProps because
        // we will end up freeing lpProps with MAPIFreeBuffer.
        //
        // Get and filter the property array here
        if (hResult = HrFilterExportMailUserProps(&cProps, &lpProps, lpMailUserWAB, &fDistList)) {
            lpDisplayName = FindStringInProps(lpProps, cProps, PR_DISPLAY_NAME);
            lpEmailAddress = FindStringInProps(lpProps, cProps, PR_EMAIL_ADDRESS);

            if (HandleExportError(hwnd,
              0,
              hResult,
              lpDisplayName,
              lpEmailAddress,
              lpExportOptions)) {
                hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                goto exit;
            }
        }

        // Find some interesting property values here
        lpDisplayName = FindStringInProps(lpProps, cProps, PR_DISPLAY_NAME);
        lpEmailAddress = FindStringInProps(lpProps, cProps, PR_EMAIL_ADDRESS);


        if (ulObjectType == MAPI_DISTLIST && ! fDistList) {
            // Filter must have changed this to a mailuser.
            ulObjectType = MAPI_MAILUSER;
            iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
            lpIIDOpen = NULL;
        }

        if (fDistList) {
            ulCreateFlags = CREATE_CHECK_DUP_LOOSE;

            // PAB can't detect collisions on DL SaveChanges.
            // See if this is a duplicate:
            if (! HR_FAILED(hResult = FindPABEntry(lpContainerMAPI,
              MAPI_DISTLIST,
              lpDisplayName,
              NULL,
              &cbEIDDup,
              &lpEIDDup))) {

                // Found a duplicate.  Keep track of it!
            }
        } else {
            ulCreateFlags = CREATE_CHECK_DUP_STRICT;
        }

        //
        // NOTE: lpProps after this point is MAPI Allocated rather than WAB allocated.
        //

        if (HR_FAILED(hResult = lpContainerMAPI->lpVtbl->CreateEntry(lpContainerMAPI,
          lpCreateEIDsMAPI[iCreateTemplate].Value.bin.cb,
          (LPENTRYID)lpCreateEIDsMAPI[iCreateTemplate].Value.bin.lpb,
          ulCreateFlags,
          &lpMailUserMAPI))) {
            DebugTrace("CreateEntry(MAPI MailUser) -> %x\n", GetScode(hResult));
            goto exit;
        }

        if (fDistList) {
            // Update status message
            if (*szBufferDLMessage == '\0') {   // only load once, then keep it.
                LoadString(hInst, IDS_MESSAGE_EXPORTING_DL, szBufferDLMessage, ARRAYSIZE(szBufferDLMessage));
            }
            if (lpDisplayName) {
				ULONG cchSize =lstrlen(szBufferDLMessage) + 1 + lstrlen(lpDisplayName);
                if (lpszMessage = LocalAlloc(LMEM_FIXED, sizeof(TCHAR)*cchSize)) {
                    wnsprintf(lpszMessage, cchSize, szBufferDLMessage, lpDisplayName);
                    DebugTrace("Status Message: %s\n", lpszMessage);
                    if (! SetDlgItemText(hwnd, IDC_Message, lpszMessage)) {
                        DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                    }
                    LocalFree(lpszMessage);
                }
            }
        }

        if (! lpEIDDup) {
            // If this was a DL which we know already exists, don't even bother writing it,
            // just fall through to the collision pass.  Otherwise, try to set the props
            // and save it... if it fails, we'll get an hResult=MAPI_E_COLLISION.

            // Set the properties on the PAB entry
            if (HR_FAILED(hResult = lpMailUserMAPI->lpVtbl->SetProps(lpMailUserMAPI,
              cProps,                   // cValues
              lpProps,                  // property array
              NULL))) {                 // problems array
                DebugTrace("ExportEntry:SetProps(MAPI) -> %x\n", GetScode(hResult));
                goto exit;
            }


            // Save the new wab mailuser or distlist
            if (HR_FAILED(hResult = lpMailUserMAPI->lpVtbl->SaveChanges(lpMailUserMAPI,
              KEEP_OPEN_READONLY | FORCE_SAVE))) {
                DebugTrace("SaveChanges -> %x\n", GetScode(hResult));
            } else {
                fCreatedNew = TRUE;
            }
        }

        //
        // Handle Collisions
        //
        if (lpEIDDup || GetScode(hResult) == MAPI_E_COLLISION) {
            // Find the display name
            if (! lpDisplayName) {
                DebugTrace("Collision, but can't find PR_DISPLAY_NAME in entry\n");
                goto exit;
            }

            // Do we need to prompt?
            switch (lpExportOptions->ReplaceOption) {
                case WAB_REPLACE_PROMPT:
                    // Prompt user with dialog.  If they say YES, we should
                    // recurse with the FORCE flag set.

                    RI.lpszDisplayName = lpDisplayName;
                    RI.lpszEmailAddress = lpEmailAddress;
                    RI.ConfirmResult = CONFIRM_ERROR;
                    RI.fExport = TRUE;
                    RI.lpImportOptions = lpExportOptions;

                    DialogBoxParam(hInst,
                      MAKEINTRESOURCE(IDD_ExportReplace),
                      hwnd,
                      ReplaceDialogProc,
                      (LPARAM)&RI);

                    switch (RI.ConfirmResult) {
                        case CONFIRM_YES:
                        case CONFIRM_YES_TO_ALL:
                            fForceReplace = TRUE;
                            break;

                        case CONFIRM_ABORT:
                            hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                            goto exit;

                        default:
                            // NO
                            break;
                    }
                    break;

                case WAB_REPLACE_ALWAYS:
                    fForceReplace = TRUE;
                    break;
            }

            if (fForceReplace) {
                SBinary sbEntry;
                ENTRYLIST EntryList = {1, &sbEntry};

                // Find the existing PAB entry and delete it.
                if (! lpDisplayName) {
                    lpDisplayName = (LPTSTR)szEmpty;
                }

                if (! lpEIDDup) {
                    if (HR_FAILED(hResult = FindPABEntry(lpContainerMAPI,
                      ulObjectType,
                      lpDisplayName,
                      lpEmailAddress,
                      &cbEIDDup,
                      &lpEIDDup))) {
                        // Hey, couldn't find it.  Just pretend it isn't there,
                        // go on and create the new one anyway.
                    }
                }
                if (lpEIDDup) {
                    // Delete this entry.
                    sbEntry.cb = cbEIDDup;
                    sbEntry.lpb = (LPBYTE)lpEIDDup;

                    if (HR_FAILED(hResult = lpContainerMAPI->lpVtbl->DeleteEntries(lpContainerMAPI,
                      &EntryList,
                      0))) {
                        DebugTrace("PAB DeleteEntries(%s) -> %x\n", lpDisplayName);
                    }

                    if (lpEIDDup) {
                        MAPIFreeBuffer(lpEIDDup);
                    }
                }

                lpMailUserMAPI->lpVtbl->Release(lpMailUserMAPI);
                lpMailUserMAPI = NULL;

                // Create a new entry without the collision flags
                if (HR_FAILED(hResult = lpContainerMAPI->lpVtbl->CreateEntry(lpContainerMAPI,
                  lpCreateEIDsMAPI[iCreateTemplate].Value.bin.cb,
                  (LPENTRYID)lpCreateEIDsMAPI[iCreateTemplate].Value.bin.lpb,
                  0,
                  &lpMailUserMAPI))) {
                    DebugTrace("CreateEntry(MAPI MailUser) -> %x\n", GetScode(hResult));
                    goto exit;
                }

                // Set the properties on the PAB entry
                if (HR_FAILED(hResult = lpMailUserMAPI->lpVtbl->SetProps(lpMailUserMAPI,
                  cProps,                   // cValues
                  lpProps,                  // property array
                  NULL))) {                 // problems array
                    DebugTrace("ExportEntry:SetProps(MAPI) -> %x\n", GetScode(hResult));
                    goto exit;
                }

                // Save the new wab mailuser or distlist
                if (HR_FAILED(hResult = lpMailUserMAPI->lpVtbl->SaveChanges(lpMailUserMAPI,
                  KEEP_OPEN_READONLY | FORCE_SAVE))) {
                    DebugTrace("SaveChanges(WAB MailUser) -> %x\n", GetScode(hResult));
                } else {
                    fCreatedNew = TRUE;
                }
            } else {
                fDuplicate = TRUE;
            }

            hResult = hrSuccess;
        }

        if (fCreatedNew) {
            // What is the ENTRYID of our new entry?
            if ((hResult = lpMailUserMAPI->lpVtbl->GetProps(lpMailUserMAPI,
              (LPSPropTagArray)&ptaEid,
              0,
              &cEIDPropMAPI,
              &lpEIDPropMAPI))) {
                DebugTrace("ExportEntry: GetProps(MAPI ENTRYID) -> %x\n", GetScode(hResult));
                goto exit;
            }

            Assert(cEIDPropMAPI);
            Assert(lpEIDPropMAPI[ieidPR_ENTRYID].ulPropTag == PR_ENTRYID);

            cbEIDNew = lpEIDPropMAPI[0].Value.bin.cb;

            if (FAILED(sc = MAPIAllocateBuffer(cbEIDNew, &lpEIDNew))) {
                DebugTrace("ExportEntry: MAPIAllocateBuffer(MAPI ENTRYID) -> %x\n", sc);
                hResult = ResultFromScode(sc);
                goto exit;
            }

            // Copy the new EntryID into the buffer
            CopyMemory(lpEIDNew, lpEIDPropMAPI[0].Value.bin.lpb, cbEIDNew);
        }


        //
        // If this is a DISTLIST, fill it in.
        //
        if (fDistList && ! fDuplicate && cbEIDNew) {
            lpDistListWAB = (LPDISTLIST)lpMailUserWAB;    // This is REALLY a DISTLIST object
            // DO NOT Release this!

            // Open the new WAB DL as a DISTLIST object
            if (HR_FAILED(hResult = lpContainerMAPI->lpVtbl->OpenEntry(lpContainerMAPI,
              cbEIDNew,
              lpEIDNew,
              (LPIID)&IID_IDistList,
              MAPI_MODIFY,
              &ulObjectTypeOpen,
              (LPUNKNOWN*)&lpDistListMAPI))) {
                DebugTrace("ExportEntry: MAPI OpenEntry(IID_DistList) -> %x\n", GetScode(hResult));
                goto exit;
            }
            Assert(lpDistListMAPI);


            // For each entry in the DL:
            //  Migrate the entry (MailUser or DL) recursively
            //  Add new entryid to DL contents
            if (HR_FAILED(hResult = lpDistListWAB->lpVtbl->GetContentsTable(lpDistListWAB,
              0,    // ulFlags
              &lpDLTableWAB))) {
                DebugTrace("ExportEntry:GetContentsTable(WAB) -> %x\n", GetScode(hResult));
                goto exit;
            }


            // Set the columns to those we're interested in
            if (hResult = lpDLTableWAB->lpVtbl->SetColumns(lpDLTableWAB,
              (LPSPropTagArray)&ptaColumns,
              0)) {
                DebugTrace("WAB SetColumns(DL Table) -> %x\n", GetScode(hResult));
                goto exit;
            }

            cRows = 1;
            while (cRows) {
                // Get the next DL entry
                if (hResult = lpDLTableWAB->lpVtbl->QueryRows(lpDLTableWAB,
                  1,    // one row at a time
                  0,    // ulFlags
                  &lpRow)) {
                    DebugTrace("DL: QueryRows -> %x\n", GetScode(hResult));
                    goto exit;
                }

                if (lpRow && lpRow->cRows) {
                    Assert(lpRow->cRows == 1);
                    Assert(lpRow->aRow[0].cValues == iptaColumnsMax);
                    Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].ulPropTag == PR_ENTRYID);
                    Assert(lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].ulPropTag == PR_OBJECT_TYPE);

                    if (lpRow) {
                        if (cRows = lpRow->cRows) { // yes, single '='
                            hResult = ExportEntry(hwnd,
                              lpAdrBookWAB,
                              lpContainerMAPI,
                              lpCreateEIDsMAPI,
                              lpRow->aRow[0].lpProps[iptaColumnsPR_OBJECT_TYPE].Value.l,
                              (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                              lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                              &lpeidDLMAPI,        // returned new or existing entry
                              &cbeidDLMAPI,
                              TRUE,
                              FALSE);
                            if (hResult) {
                                if (HandleExportError(hwnd,
                                  0,
                                  hResult,
                                  lpRow->aRow[0].lpProps[iptaColumnsPR_DISPLAY_NAME].Value.LPSZ,
                                  PropStringOrNULL(&lpRow->aRow[0].lpProps[iptaColumnsPR_EMAIL_ADDRESS]),
                                  lpExportOptions)) {
                                    hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                                    break;  // out of loop
                                } else {
                                    hResult = hrSuccess;
                                }
                            }
                        } // else, drop out of loop, we're done.
                        WABFreeProws(lpRow);
                        lpRow = NULL;

                        if (HR_FAILED(hResult)) {
                            // This entry couldn't be created.  Ignore it.
                            DebugTrace("Coudln't create DL entry -> %x\n", GetScode(hResult));
                            hResult = hrSuccess;
                            continue;
                        }

                        // Add the Entry to the DL using the new entry's EntryID
                        if (cbeidDLMAPI && lpeidDLMAPI) {
                            // BUGBUG: Don't bother with this one if this is a duplicate entry.
                            if (HR_FAILED(hResult = lpDistListMAPI->lpVtbl->CreateEntry(lpDistListMAPI,
                              cbeidDLMAPI,
                              lpeidDLMAPI,
                              0,                // allow duplicates here
                              &lpEntryMAPI))) {
                                DebugTrace("Couldn't create new entry in DL -> %x\n", GetScode(hResult));
                                break;
                            }

                            hResult = lpEntryMAPI->lpVtbl->SaveChanges(lpEntryMAPI, FORCE_SAVE);

                            if (lpEntryMAPI) {
                                lpEntryMAPI->lpVtbl->Release(lpEntryMAPI);
                                lpEntryMAPI = NULL;
                            }
                        }

                        if (lpeidDLMAPI) {
                            MAPIFreeBuffer(lpeidDLMAPI);
                            lpeidDLMAPI = NULL;
                        }
                    }
                } else {
                    break;  // done
                }
            }
        }
    } else {
        DebugTrace("Found a duplicate EntryID\n");
    }

    //
    // Save the entryid to the list and return a buffer with it
    //
    if (cbEIDNew && lpEIDNew) {                         // We created one?
        // created one
    } else if (fDuplicateEID && lListIndex != -1) {     // Was it in the list?
        cbEIDNew  = lpEntriesSeen[lListIndex].sbinWAB.cb;
        if (FAILED(sc = MAPIAllocateBuffer(cbEIDNew, &lpEIDNew))) {
            DebugTrace("ExportEntry: WABAllocateBuffer(WAB ENTRYID) -> %x\n", sc);
            // ignore
            cbEIDNew = 0;
        } else {
            // Copy the EntryID from the list into the buffer
            CopyMemory(lpEIDNew, lpEntriesSeen[lListIndex].sbinWAB.lpb, cbEIDNew);
        }

    } else if (fDuplicate) {                            // Was it a duplicate
        FindPABEntry(lpContainerMAPI,
          ulObjectType,
          lpDisplayName,
          lpEmailAddress,
          &cbEIDNew,
          &lpEIDNew);

#ifdef OLD_STUFF
        FindExistingPABEntry(lpProps, cProps, lpContainerMAPI, &lpEIDNew, &cbEIDNew);
#endif // OLD_STUFF
        // ignore errors since the lpEIDNew and cbEIDNew will be nulled out
    }

    // Update the seen list
    if (! fDuplicateEID) {
        MarkPABEntryInList(cbEIDNew, lpEIDNew, lListIndex);
    }

    // If caller requested the entryid's, return them
    if (lpcbEIDMAPI && lppEIDMAPI) {
        *lpcbEIDMAPI = cbEIDNew;
        *lppEIDMAPI = lpEIDNew;
        fReturnEID = TRUE;          // don't free it
    }

exit:
    //
    // Cleanup MAPI stuff
    //
    if (lpProps) {
        MAPIFreeBuffer(lpProps);
    }

    if (lpEIDPropMAPI) {
        MAPIFreeBuffer(lpEIDPropMAPI);
    }

    if (lpEIDNew && ! fReturnEID) {
        MAPIFreeBuffer(lpEIDNew);
    }

    if (lpeidDLMAPI) {
        MAPIFreeBuffer(lpeidDLMAPI);
    }

    if (lpMailUserMAPI) {
        lpMailUserMAPI->lpVtbl->Release(lpMailUserMAPI);
    }

    if (lpDistListMAPI) {
        lpDistListMAPI->lpVtbl->Release(lpDistListMAPI);
    }

    //
    // Cleanup WAB stuff
    //
    if (lpRow) {
        WABFreeProws(lpRow);
    }

    if (lpDLTableWAB) {
        lpDLTableWAB->lpVtbl->Release(lpDLTableWAB);
    }

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
    }

// Do not release this... It is the same object as lpMailUserWAB!
//    if (lpDistListWAB) {
//        lpDistListWAB->lpVtbl->Release(lpDistListWAB);
//    }

    if (! HR_FAILED(hResult)) {
        hResult = hrSuccess;
    }

    return(hResult);
}


HRESULT PABExport(HWND hWnd,
  LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_EXPORT_OPTIONS lpOptions) {
    BOOL fDone = FALSE;
    HRESULT hResult = hrSuccess;

    lpAdrBookWAB = lpAdrBook;
    lpfnProgressCB = lpProgressCB;
   lpExportOptions = lpOptions;

    // Setup memory allocators
    SetGlobalBufferFunctions(lpWABObject);


    // Prime the state machine
    State = STATE_EXPORT_MU;


    while (! fDone) {
        switch (State) {
            case STATE_EXPORT_MU:
                StateExportMU(hWnd);
                break;

            case STATE_EXPORT_NEXT_MU:
                StateExportNextMU(hWnd);
                break;

            case STATE_EXPORT_DL:
                StateExportDL(hWnd);
                break;

            case STATE_EXPORT_NEXT_DL:
                StateExportNextDL(hWnd);
                break;

            case STATE_EXPORT_FINISH:
                StateExportFinish(hWnd);
                fDone = TRUE;
                break;

            case STATE_EXPORT_ERROR:
                StateExportError(hWnd);
                // BUGBUG: Should set hResult to something
                break;

            case STATE_EXPORT_CANCEL:
                StateExportCancel(hWnd);
                break;

            default:
                DebugTrace("Unknown state %u in PABExport\n", State);
                Assert(FALSE);
                break;
        }
    }

    return(hResult);
}


HRESULT PABImport(HWND hWnd,
  LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_IMPORT_OPTIONS lpOptions) {

    BOOL fDone = FALSE;
    HRESULT hResult = hrSuccess;

    lpAdrBookWAB = lpAdrBook;
    lpfnProgressCB = lpProgressCB;
    lpImportOptions = lpOptions;

    // Setup memory allocators
    SetGlobalBufferFunctions(lpWABObject);


    // Prime the state machine
    State = STATE_IMPORT_MU;


    while (! fDone) {
        switch (State) {
            case STATE_IMPORT_MU:
                StateImportMU(hWnd);
                break;

            case STATE_IMPORT_NEXT_MU:
                StateImportNextMU(hWnd);
                break;

            case STATE_IMPORT_DL:
                StateImportDL(hWnd);
                break;

            case STATE_IMPORT_NEXT_DL:
                StateImportNextDL(hWnd);
                break;

            case STATE_IMPORT_FINISH:
                StateImportFinish(hWnd);
                fDone = TRUE;
                break;

            case STATE_IMPORT_ERROR:
                StateImportError(hWnd);
                // BUGBUG: Should set hResult to something
                break;

            case STATE_IMPORT_CANCEL:
                StateImportCancel(hWnd);
                break;

            default:
                DebugTrace("Unknown state %u in PABImport\n", State);
                Assert(FALSE);
                break;
        }
    }

    return(hResult);
}

/*
 - HrLoadPrivateWABProps
 -
*    Private function to load Conferencing Named properties
*    as globals up front
*
*
*/
HRESULT HrLoadPrivateWABPropsForCSV(LPADRBOOK lpIAB)
{
    HRESULT hr = E_FAIL;
    LPSPropTagArray lpta = NULL;
    SCODE sc = 0;
    ULONG i, uMax = prWABConfMax, nStartIndex = OLK_NAMEDPROPS_START;
    LPMAPINAMEID  *lppConfPropNames = NULL;
    sc = WABAllocateBuffer(sizeof(LPMAPINAMEID) * uMax, (LPVOID *) &lppConfPropNames);
    //sc = WABAllocateBuffer(sizeof(LPMAPINAMEID) * uMax, (LPVOID *) &lppConfPropNames);
    if( (HR_FAILED(hr = ResultFromScode(sc))) )
        goto err;    

    for(i=0;i< uMax;i++)
    {
        //sc = WABAllocateMore(sizeof(MAPINAMEID), lppConfPropNames, &(lppConfPropNames[i]));
        sc = WABAllocateMore(  sizeof(MAPINAMEID), lppConfPropNames, &(lppConfPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppConfPropNames[i]->lpguid = (LPGUID) &PS_Conferencing;
        lppConfPropNames[i]->ulKind = MNID_ID;
        lppConfPropNames[i]->Kind.lID = nStartIndex + i;
    }
    // Load the set of conferencing named props
    //
    if( HR_FAILED(hr = (lpIAB)->lpVtbl->GetIDsFromNames(lpIAB, uMax, lppConfPropNames,
        MAPI_CREATE, &lpta) ))
        goto err;
    
    if(lpta)
    {
        // Set the property types on the returned props
        PR_SERVERS                  = CHANGE_PROP_TYPE(lpta->aulPropTag[prWABConfServers],        PT_MV_TSTRING);
    }
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].ulPropTag = PR_SERVERS;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].fChosen   = FALSE;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].ids       = ids_ExportConfServer;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].lpszName  = NULL;
    rgPropNames[NUM_MORE_EXPORT_PROPS-1].lpszCSVName = NULL;

err:
    if(lpta)
        WABFreeBuffer( lpta );
    if( lppConfPropNames )
        WABFreeBuffer( lppConfPropNames );
        //WABFreeBuffer(lpta);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\mapilayr.c ===
/*
 * MAPILAYR.C
 *
 * Layer on top of MAPI calls
 *
 * Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * History:
 *      11/14/96    BruceK  First version to allow wab migration without mapi32.dll
 */

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <wabmig.h>
#include "wabimp.h"
#include "..\..\wab32res\resrc2.h"
#include "dbgutil.h"


typedef SCODE (STDMETHODCALLTYPE FREEPROWS)(
    LPSRowSet lpRows
);
typedef FREEPROWS *LPFREEPROWS;

typedef SCODE (STDMETHODCALLTYPE FREEPADRLIST)(
    LPADRLIST lpAdrList
);
typedef FREEPADRLIST *LPFREEPADRLIST;

typedef SCODE (STDMETHODCALLTYPE SCCOPYPROPS)(
    int cValues,
    LPSPropValue lpPropArray,
    LPVOID lpvDst,
    ULONG FAR *lpcb	
);
typedef SCCOPYPROPS *LPSCCOPYPROPS;

typedef SCODE (STDMETHODCALLTYPE SCCOUNTPROPS)(
    int cValues,
    LPSPropValue lpPropArray,
    ULONG FAR *lpcb
);
typedef SCCOUNTPROPS *LPSCCOUNTPROPS;


static LPMAPIINITIALIZE lpfnMAPIInitialize = NULL;
static LPMAPILOGONEX lpfnMAPILogonEx = NULL;
static LPMAPIALLOCATEBUFFER lpfnMAPIAllocateBuffer = NULL;
static LPMAPIALLOCATEMORE lpfnMAPIAllocateMore = NULL;
static LPMAPIFREEBUFFER lpfnMAPIFreeBuffer = NULL;
static LPFREEPROWS lpfnFreeProws = NULL;
static LPFREEPADRLIST lpfnFreePadrlist = NULL;
static LPSCCOPYPROPS lpfnScCopyProps = NULL;
static LPSCCOUNTPROPS lpfnScCountProps = NULL;


static HINSTANCE hinstMAPIDll = NULL;

// Constant strings
const TCHAR szMapiDll[] = TEXT("MAPI32.DLL");
const TCHAR szMAPIAllocateBuffer[] = TEXT("MAPIAllocateBuffer");
const TCHAR szMAPIAllocateMore[] = TEXT("MAPIAllocateMore");
const TCHAR szMAPIFreeBuffer[] = TEXT("MAPIFreeBuffer");
const TCHAR szMAPIInitialize[] = TEXT("MAPIInitialize");
const TCHAR szMAPILogonEx[] = TEXT("MAPILogonEx");

#if defined (_ALPHA_) || defined (ALPHA) // Bug:63053
const TCHAR szFreeProws[] = TEXT("FreeProws");
const TCHAR szFreePadrlist[] = TEXT("FreePadrlist");
const TCHAR szScCopyProps[] = TEXT("ScCopyProps");
const TCHAR szScCountProps[] = TEXT("ScCountProps");
#else
const TCHAR szFreeProws[] = TEXT("FreeProws@4");
const TCHAR szFreePadrlist[] = TEXT("FreePadrlist@4");
const TCHAR szScCopyProps[] = TEXT("ScCopyProps@16");
const TCHAR szScCountProps[] = TEXT("ScCountProps@12");
#endif


HRESULT MAPIInitialize(LPVOID lpMapiInit) {
    HRESULT hResult = hrSuccess;

    // If MAPI DLL is not loaded, do so now.
    if (! hinstMAPIDll) {

        if (! (hinstMAPIDll = LoadLibrary(szMapiDll))) {
            DWORD dwErr = GetLastError();
            DebugTrace("Couldn't load MAPI dll [%s] -> %u\n", szMapiDll, dwErr);
            switch (dwErr) {
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_OUTOFMEMORY:
                    hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                    break;

                case ERROR_HANDLE_DISK_FULL:
                case ERROR_DISK_FULL:
                    hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_DISK);
                    break;

                default:
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                    break;
            }
            goto exit;
        } else {
            // Get the function pointers
            if (! (lpfnMAPIInitialize = (LPMAPIINITIALIZE)GetProcAddress(hinstMAPIDll,
              szMAPIInitialize))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIInitialize, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPILogonEx = (LPMAPILOGONEX)GetProcAddress(hinstMAPIDll,
              szMAPILogonEx))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPILogonEx, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPIAllocateBuffer = (LPMAPIALLOCATEBUFFER)GetProcAddress(hinstMAPIDll,
              szMAPIAllocateBuffer))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIAllocateBuffer, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPIAllocateMore= (LPMAPIALLOCATEMORE)GetProcAddress(hinstMAPIDll,
              szMAPIAllocateMore))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIAllocateMore, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPIFreeBuffer = (LPMAPIFREEBUFFER)GetProcAddress(hinstMAPIDll,
              szMAPIFreeBuffer))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIFreeBuffer, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnFreeProws= (LPFREEPROWS)GetProcAddress(hinstMAPIDll,
              szFreeProws))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szFreeProws, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnFreePadrlist= (LPFREEPADRLIST)GetProcAddress(hinstMAPIDll,
              szFreePadrlist))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szFreePadrlist, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnScCopyProps= (LPSCCOPYPROPS)GetProcAddress(hinstMAPIDll,
              szScCopyProps))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szScCopyProps, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnScCountProps = (LPSCCOUNTPROPS)GetProcAddress(hinstMAPIDll,
              szScCountProps))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szScCountProps, szMapiDll, GetLastError());
                goto exit;
            }
        }
    }

exit:
    if (! lpfnMAPIInitialize ||
      ! lpfnMAPILogonEx ||
      ! lpfnMAPIAllocateMore ||
      ! lpfnMAPIAllocateBuffer ||
      ! lpfnMAPIFreeBuffer ||
      ! lpfnFreeProws ||
      ! lpfnFreePadrlist ||
      ! lpfnScCopyProps ||
      ! lpfnScCountProps) {
        // Bad news.  Clean up and fail.
        if (hinstMAPIDll) {
            // unload the dll
            FreeLibrary(hinstMAPIDll);
            hinstMAPIDll = NULL;
            lpfnMAPIInitialize = NULL;
            lpfnMAPILogonEx = NULL;
            lpfnMAPIAllocateMore = NULL;
            lpfnMAPIAllocateBuffer = NULL;
            lpfnMAPIFreeBuffer = NULL;
            lpfnFreeProws = NULL;
            lpfnFreePadrlist = NULL;
            lpfnScCopyProps = NULL;
            lpfnScCountProps = NULL;
        }
        if (hResult == hrSuccess) {
            hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        }

        return(hResult);
    }

    return(lpfnMAPIInitialize(lpMapiInit));
}


HRESULT MAPILogonEx(
  ULONG_PTR ulUIParam,
  LPTSTR lpszProfileName,
  LPTSTR lpszPassword,
  ULONG ulFlags,
  LPMAPISESSION FAR * lppSession
) {
    Assert(lpfnMAPILogonEx);
    if (lpfnMAPILogonEx) {
        return(lpfnMAPILogonEx(ulUIParam,
          lpszProfileName,
          lpszPassword,
          ulFlags,
          lppSession));
    } else {
        return(ResultFromScode(MAPI_E_NOT_INITIALIZED));
    }
}

SCODE MAPIAllocateBuffer(
  ULONG cbSize,
  LPVOID FAR * lppBuffer
) {
    Assert(lpfnMAPIAllocateBuffer);
    if (lpfnMAPIAllocateBuffer) {
        return(lpfnMAPIAllocateBuffer(cbSize,
          lppBuffer));
    } else {
        return(MAPI_E_NOT_INITIALIZED);
    }
}

SCODE MAPIAllocateMore(
  ULONG cbSize,
  LPVOID lpObject,
  LPVOID FAR * lppBuffer
) {
    Assert(lpfnMAPIAllocateMore);
    if (lpfnMAPIAllocateMore) {
        return(lpfnMAPIAllocateMore(cbSize,
          lpObject,
          lppBuffer));
    } else {
        return(MAPI_E_NOT_INITIALIZED);
    }
}

ULONG MAPIFreeBuffer(LPVOID lpBuffer) {
    Assert(lpfnMAPIFreeBuffer);
    if (lpfnMAPIFreeBuffer) {
        return(lpfnMAPIFreeBuffer(lpBuffer));
    } else {
        return((ULONG)MAPI_E_NOT_INITIALIZED);
    }
}

STDAPI_(SCODE)ScCountProps(int cValues, LPSPropValue lpPropArray, ULONG FAR *lpcb) {
    Assert(lpfnScCountProps);
    if (lpfnScCountProps) {
        return(lpfnScCountProps(cValues, lpPropArray, lpcb));
    } else {
        return((ULONG)MAPI_E_NOT_INITIALIZED);
    }
}

STDAPI_(SCODE)ScCopyProps(int cValues, LPSPropValue lpPropArray, LPVOID lpvDst,
  ULONG FAR *lpcb) {
    Assert(lpfnScCopyProps);
    if (lpfnScCopyProps) {
        return(lpfnScCopyProps(cValues, lpPropArray, lpvDst, lpcb));
    } else {
        return((ULONG)MAPI_E_NOT_INITIALIZED);
    }

}

STDAPI_(void)FreeProws(LPSRowSet lpRows) {
    Assert(lpfnFreeProws);
    if (lpfnFreeProws) {
        lpfnFreeProws(lpRows);
    }
}

STDAPI_(void)FreePadrlist(LPADRLIST lpadrlist) {
    Assert(lpfnFreePadrlist);
    if (lpfnFreePadrlist) {
        lpfnFreePadrlist(lpadrlist);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\wabimp.c ===
/******************************************************************************
    FILENAME:       wabimp.c
    MODULE:         DLL for PAB, CSV, NetScape, Eudora and Athena16 address book
                    conversions.
    PURPOSE:        Contains modules which will implement importing
                    MAPI PAB, CSV, NetScape, Eudora and Athena16
                    address book to Athena32 (WAB).

    EXPORTED FUNCTIONS: STDMETHODIMP NetscapeImport(HWND hwnd, LPADRBOOK lpAdrBook,
                            LPWABOBJECT lpWABObject,
                            LPWAB_PROGRESS_CALLBACK lpProgressCB,
                            LPWAB_IMPORT_OPTIONS lpOptions)
                        STDMETHODIMP Athena16Import(HWND hwnd,LPADRBOOK lpAdrBook,
                            LPWABOBJECT lpWABObject,
                            LPWAB_PROGRESS_CALLBACK lpProgressCB,
                            LPWAB_IMPORT_OPTIONS lpOptions)
                        STDMETHODIMP EudoraImport(HWND hwnd,LPADRBOOK lpAdrBook,
                            LPWABOBJECT lpWABObject,
                            LPWAB_PROGRESS_CALLBACK lpProgressCB,
                            LPWAB_IMPORT_OPTIONS lpOptions)

    Programmer(s): Arathi (NetQuest)
                   Radhika (NetQuest)
                   Krishnamoorthy SeethaRaman(NetQuest)


    Revision History:

    4/7/97 - vikramm    Fix Bugs: Netscape Display Names not being imported.
                        "Replace Import" dialog has no parent.
    4/8/97 - vikramm    Fix Bugs: Handle Leak.
                        Add code to look for additional Eudora address books
                          that may be in subdirectories ...
    4/9/97 - vikramm    Change the Eudora registry search path ...
                        Fix Bugs: Looking in wrong reg Key for Netscape on NT
                          and wrongly assuming key exists for pre netscape 3.0
                        Change dialog messages.
*******************************************************************************/

//Includes
#define _WABIMP_C

#include "_comctl.h"
#include <windows.h>
#include <commctrl.h>
#include <mapix.h>
#include <wab.h>
#include <wabmig.h>
#include <wabguid.h>
#include <wabdbg.h>
#include <dbgutil.h>
#include "..\..\wab32res\resrc2.h"
#include <wabimp.h>
#include <string.h>
#include <advpub.h>
#include <shlwapi.h>

// Per-process Globals
TCHAR szGlobalAlloc[MAX_MESSAGE];                  // Buffer used for LoadString
TCHAR szGlobalTempAlloc[MAX_MESSAGE];

const TCHAR szTextFilter[] = "*.txt";
const TCHAR szAllFilter[] = "*.*";

const TCHAR szMSN[] = "MSN";
const TCHAR szMSNINET[] = "MSNINET";
const TCHAR szCOMPUSERVE[] = "COMPUSERVE";
const TCHAR szFAX[] = "FAX";
const TCHAR szSMTP[] = "SMTP";
const TCHAR szMS[] = "MS";
const TCHAR szEX[] = "EX";
const TCHAR szX400[] = "X400";
const TCHAR szMSA[] = "MSA";
const TCHAR szMAPIPDL[] = "MAPIPDL";
const TCHAR szEmpty[] = "";
const TCHAR szDescription[] = "description";
const TCHAR szDll[] = "dll";
const TCHAR szEntry[] = "entry";
const TCHAR szEXPORT[] = "EXPORT";
const TCHAR szIMPORT[] = "IMPORT";

const TCHAR szAtSign[] = "@";
const TCHAR szMSNpostfix[] = "@msn.com";
const TCHAR szCOMPUSERVEpostfix[] = "@compuserve.com";
LPENTRY_SEEN lpEntriesSeen = NULL;
ULONG ulEntriesSeen = 0;
ULONG ulMaxEntries = 0;
const LPTSTR szWABKey = "Software\\Microsoft\\WAB";
LPTARGET_INFO rgTargetInfo = NULL;


HINSTANCE hInst = NULL;
HINSTANCE hInstApp = NULL;

//
// Properties to get for each row of the contents table
//
const SizedSPropTagArray(iptaColumnsMax, ptaColumns) =
{
    iptaColumnsMax,
    {
        PR_OBJECT_TYPE,
        PR_ENTRYID,
        PR_DISPLAY_NAME,
        PR_EMAIL_ADDRESS,
    }
};


const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_ENTRYID,
    }
};

const SizedSPropTagArray(iconMax, ptaCon)=
{
    iconMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};



//  Global WAB Allocator access functions
//

typedef struct _WAB_ALLOCATORS {
    LPWABOBJECT lpWABObject;
    LPWABALLOCATEBUFFER lpAllocateBuffer;
    LPWABALLOCATEMORE lpAllocateMore;
    LPWABFREEBUFFER lpFreeBuffer;
} WAB_ALLOCATORS, *LPWAB_ALLOCATORS;

WAB_ALLOCATORS WABAllocators = {0};


/******************************************************************************

    Name      : SetGlobalBufferFunctions

    Purpose   : Set the global buffer functions based on methods from
                the WAB object.

    Parameters: lpWABObject = the open wab object

    Returns   : none

    Comment   :

******************************************************************************/
void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject)
{
    if (lpWABObject && ! WABAllocators.lpWABObject) {
        WABAllocators.lpAllocateBuffer = lpWABObject->lpVtbl->AllocateBuffer;
        WABAllocators.lpAllocateMore = lpWABObject->lpVtbl->AllocateMore;
        WABAllocators.lpFreeBuffer = lpWABObject->lpVtbl->FreeBuffer;
        WABAllocators.lpWABObject = lpWABObject;
    }
}


/******************************************************************************

    Name      : WABAllocateBuffer

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

*******************************************************************************/
SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer)
{
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateBuffer) {
        return(WABAllocators.lpAllocateBuffer(WABAllocators. lpWABObject, cbSize,
          lppBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/******************************************************************************

    Name      : WABAllocateMore

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lpObject = existing allocation
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

*******************************************************************************/
SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer)
{
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateMore) {
        return(WABAllocators.lpAllocateMore(WABAllocators. lpWABObject, cbSize,
          lpObject, lppBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/******************************************************************************

    Name      : WABFreeBuffer

    Purpose   : Use the WAB Allocator

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

*******************************************************************************/
SCODE WABFreeBuffer(LPVOID lpBuffer)
{
    if (WABAllocators.lpWABObject && WABAllocators.lpFreeBuffer) {
        return(WABAllocators.lpFreeBuffer(WABAllocators.lpWABObject, lpBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : IsSpace

    Purpose   : Does the single or DBCS character represent a space?

    Parameters: lpChar -> SBCS or DBCS character

    Returns   : TRUE if this character is a space

    Comment   :

***************************************************************************/
BOOL IsSpace(LPTSTR lpChar) {
    Assert(lpChar);
    if (*lpChar) {
        if (IsDBCSLeadByte(*lpChar)) {
            WORD CharType[2] = {0};

            GetStringTypeA(LOCALE_USER_DEFAULT,
              CT_CTYPE1,
              lpChar,
              2,    // Double-Byte
              CharType);
            return(CharType[0] & C1_SPACE);
        } else {
            return(*lpChar == ' ');
        }
    } else {
        return(FALSE);  // end of string
    }
}


/******************************************************************************

    Name      : NetscapeImport

    Purpose   : Entry Point for NetScape Addressbook import

    Parameters: hwnd = Handle to the parent Window
                lpAdrBook = pointer to the IADRBOOK interface
                lpWABObject = pointer to IWABOBJECT interface
                lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
                lpOptions = pointer to WAB_IMPORT_OPTIONS structure

    Returns   :

    Comment   :

/******************************************************************************/
STDMETHODIMP NetscapeImport(HWND hwnd, LPADRBOOK lpAdrBook,
  LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPWAB_IMPORT_OPTIONS lpOptions)
{
    HRESULT hResult = S_OK;

    SetGlobalBufferFunctions(lpWABObject);

    hResult = MigrateUser(hwnd, lpOptions, lpProgressCB, lpAdrBook);
    if (hResult == hrMemory) {
        StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MEMORY), ARRAYSIZE(szGlobalTempAlloc));
        MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),MB_OK);
    }

    return(hResult);
}


/******************************************************************************

    Name      : Athena16Import

    Purpose   : Entry Point for Athena 16 Addressbook import

    Parameters: hwnd = Handle to the parent Window
                lpAdrBook = pointer to the IADRBOOK interface
                lpWABObject = poiinter to IWABOBJECT interface
                lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
                lpOptions = pointer to WAB_IMPORT_OPTIONS structure

    Returns   :

    Comment   :

/******************************************************************************/
STDMETHODIMP Athena16Import(HWND hwnd, LPADRBOOK lpAdrBook, LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPWAB_IMPORT_OPTIONS lpOptions)
{
    HRESULT hResult = S_OK;

    SetGlobalBufferFunctions(lpWABObject);

    hResult = MigrateAthUser(hwnd, lpOptions, lpProgressCB,lpAdrBook);

    return(hResult);
}


/******************************************************************************

    Name      : EudoraImport

    Purpose   : Entry Point for Eudora Addressbook import

    Parameters: hwnd = Handle to the parent Window
                lpAdrBook = pointer to the IADRBOOK interface
                lpWABObject = poiinter to IWABOBJECT interface
                lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
                lpOptions = pointer to WAB_IMPORT_OPTIONS structure

    Returns   :

    Comment   :

/******************************************************************************/
STDMETHODIMP EudoraImport(HWND hwnd,LPADRBOOK lpAdrBook, LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPWAB_IMPORT_OPTIONS lpOptions)
{

    LPABCONT lpWabContainer = NULL;
    HRESULT hResult = S_OK;

    SetGlobalBufferFunctions(lpWABObject);

    if (FAILED(hResult = OpenWabContainer(&lpWabContainer, lpAdrBook))) {
        goto Error;
    }

    hResult = MigrateEudoraUser(hwnd,lpWabContainer,lpOptions,lpProgressCB,lpAdrBook);

    if (hResult == hrMemory) {
        StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MEMORY), ARRAYSIZE(szGlobalTempAlloc));
        MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),MB_OK);
    }

    if (lpWabContainer) {
        lpWabContainer->lpVtbl->Release(lpWabContainer);
    }

Error:
    return(hResult);
}


STDMETHODIMP NetscapeExport(HWND hwnd, LPADRBOOK lpAdrBook, LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPWAB_IMPORT_OPTIONS lpOptions)
{
    SCODE sc = SUCCESS_SUCCESS;
    HRESULT hResult = hrSuccess;

    SetGlobalBufferFunctions(lpWABObject);

    return(hResult);
}


STDMETHODIMP Athena16Export(HWND hwnd, LPADRBOOK lpAdrBook, LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPWAB_IMPORT_OPTIONS lpOptions)
{
    SCODE sc = SUCCESS_SUCCESS;
    HRESULT hResult = hrSuccess;

    SetGlobalBufferFunctions(lpWABObject);

    return(hResult);
}


STDMETHODIMP EudoraExport(HWND hwnd, LPADRBOOK lpAdrBook, LPWABOBJECT lpWABObject,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPWAB_IMPORT_OPTIONS lpOptions)
{
    SCODE sc = SUCCESS_SUCCESS;
    HRESULT hResult = hrSuccess;

    SetGlobalBufferFunctions(lpWABObject);

    return(hResult);
}


/******************************************************************************
 *********************NetScape Functions***************************************
 ******************************************************************************
 *  FUNCTION NAME:MigrateUser
 *
 *  PURPOSE:    Get the installation path of the address book and starts processing
 *              the NetScape address book
 *
 *  PARAMETERS: hwnd = Handle to the parent Window
 *              lpAdrBook = pointer to the IADRBOOK interface
 *              lpWABObject = poiinter to IWABOBJECT interface
 *              lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT MigrateUser(HWND hwnd, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{
    TCHAR szFileName[MAX_FILE_NAME];
    HRESULT hResult;
    HANDLE h1 = NULL;
    WIN32_FIND_DATA    lpFindFileData;


    if (0 != (hResult= GetRegistryPath(szFileName, ARRAYSIZE(szFileName), NETSCAPE))) {
        StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_STRING_SELECTPATH), ARRAYSIZE(szGlobalTempAlloc));
        if (IDNO ==MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),MB_YESNO)) {
            return(ResultFromScode(MAPI_E_USER_CANCEL));
        }

        if (FALSE ==GetFileToImport(hwnd, szFileName, ARRAYSIZE(szFileName), NETSCAPE)) {
            return(ResultFromScode(MAPI_E_USER_CANCEL));
        }
    } else {
        StrCatBuff(szFileName, LoadStringToGlobalBuffer(IDS_NETSCAPE_ADDRESSBOOK), ARRAYSIZE(szFileName));
        h1 =FindFirstFile(szFileName,&lpFindFileData);
        if (h1 == INVALID_HANDLE_VALUE) {
            StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ADDRESS_HTM), ARRAYSIZE(szGlobalTempAlloc));
            if (IDNO==MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR),MB_YESNO)) {
                h1=NULL;
                return(ResultFromScode(MAPI_E_USER_CANCEL));

            }
            if (FALSE ==GetFileToImport(hwnd, szFileName, ARRAYSIZE(szFileName), NETSCAPE)) {
                h1=NULL;
                return(ResultFromScode(MAPI_E_USER_CANCEL));
            }
        }
        FindClose(h1);
    }

    hResult = ParseAddressBook(hwnd,szFileName,lpOptions,lpProgressCB,lpAdrBook);
    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:ParseAddressBook
 *
 *  PURPOSE:    Open the address book file ,put the data in a buffer and call
 *              the ParseAddress function to do the parsing
 *
 *  PARAMETERS: hwnd = Handle to the parent Window
 *              lpAdrBook = pointer to the IADRBOOK interface
 *              lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *              szFileName = Filename of the address book
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT ParseAddressBook(HWND hwnd, LPTSTR szFileName, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{
    ULONG ulRead = 0;
    HANDLE hFile = NULL;
    ULONG ulFileSize = 0;
    LPTSTR szBuffer = NULL;
    HRESULT hResult;

    hFile = CreateFile(szFileName,
      GENERIC_READ,
      FILE_SHARE_READ,
      NULL,
      OPEN_EXISTING,
      FILE_FLAG_SEQUENTIAL_SCAN,
      NULL);

    if (INVALID_HANDLE_VALUE == hFile) {
        return(ResultFromScode(MAPI_E_NOT_FOUND));
    }

    ulFileSize = GetFileSize(hFile,NULL);

    szBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulFileSize+1));

    if (!szBuffer) {
        hResult = hrMemory;
        goto Error;
    }

    if (! ReadFile(hFile, szBuffer, ulFileSize, &ulRead, NULL)) {
        goto Error;
    }

    hResult = ParseAddress(hwnd,szBuffer,lpOptions,lpProgressCB,lpAdrBook);

Error:
    if (szBuffer) {
        LocalFree((HLOCAL)szBuffer);
    }
    if (hFile) {
        CloseHandle(hFile);
    }

    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:ParseAddress
 *
 *  PURPOSE: Gets the address portion of the address book in a buffer and calls
 *           ProcessAdrBuffer for further processing
 *
 *  PARAMETERS: hwnd = Handle to the parent Window
 *              lpAdrBook = pointer to the IADRBOOK interface
 *              lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *              szBuffer = Address book in a buffer
 *
 *  RETURNS: HRESULT
 ******************************************************************************/

HRESULT ParseAddress(HWND hwnd, LPTSTR szBuffer, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{
    LPTSTR AdrBuffer = NULL;        //address starting <DL> to ending </DL>
    HRESULT hResult = S_OK;

    hResult = GetAdrBuffer(&szBuffer, &AdrBuffer);
    if (hrMemory == hResult)
        goto Error;
    if (hrINVALIDFILE == hResult) {
        StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_INVALID_FILE), ARRAYSIZE(szGlobalTempAlloc));
        MessageBox(hwnd,szGlobalTempAlloc,LoadStringToGlobalBuffer(IDS_ERROR), MB_OK);
        hResult = ResultFromScode(MAPI_E_CALL_FAILED);
        goto Error;
    }

    hResult = ProcessAdrBuffer(hwnd,AdrBuffer,lpOptions,lpProgressCB,lpAdrBook);

Error:
    if (AdrBuffer)
        LocalFree((HLOCAL)AdrBuffer);
    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME: GetAdrBuffer
 *
 *  PURPOSE: Gets the address portion of the address book in a buffer
 *
 *  PARAMETERS: szBuffer = points to the complete address book
 *              szAdrBuffer = output buffer which gets filled up
 *
 *  RETURNS: HRESULT
 ******************************************************************************/
HRESULT GetAdrBuffer(LPTSTR *szBuffer, LPTSTR *szAdrBuffer)
{
    LPTSTR szAdrStart = NULL, szAdrBufStart = NULL, szAdrBufEnd = NULL;
    ULONG ulSize = 0;


    // Get Adr Start
    szAdrBufStart = GetAdrStart((*szBuffer));

    szAdrBufEnd = GetAdrEnd((*szBuffer));

    if (NULL == szAdrBufStart || NULL == szAdrBufEnd) {
        return(hrINVALIDFILE);
    }

    if (szAdrBufEnd - szAdrBufStart) {
        ulSize = (ULONG) (szAdrBufEnd - szAdrBufStart);
    }

    if (ulSize) {

        *szAdrBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulSize+1));

        if (!*szAdrBuffer) {
            return(hrMemory);
        }
        StrCpyN(*szAdrBuffer, szAdrBufStart, ulSize+1);
        *szBuffer= szAdrBufEnd;
    }

    return(S_OK);

}

/******************************************************************************
 *  FUNCTION NAME:ProcessAdrBuffer
 *
 *  PURPOSE:    Gets the individual address and then fills up the WAB by calling
                appropriate functions.
 *
 *  PARAMETERS: hwnd = Handle to the parent Window
 *              lpAdrBook = pointer to the IADRBOOK interface
 *              lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *              AdrBuffer = all the addresses in a buffer
 *
 *  RETURNS: HRESULT
 ******************************************************************************/
HRESULT ProcessAdrBuffer(HWND hwnd, LPTSTR AdrBuffer, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{
    LPTSTR szL = NULL, szDesc = NULL, szLine = NULL, szDescription = NULL;
    ULONG ulCount = 0;
    NSADRBOOK nsAdrBook;
    ULONG cCurrent = 0;
    LPSBinary lpsbinary = NULL;
    LPABCONT lpWabContainer = NULL;
    ULONG cProps;
    HRESULT hResult = S_OK;
    static LPSPropValue sProp = NULL;
    WAB_PROGRESS Progress;
    ULONG ul = 0;


    ul = GetAddressCount(AdrBuffer);
    if (0 == ul) {
        StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_NO_ENTRY), ARRAYSIZE(szGlobalTempAlloc));
        MessageBox(hwnd,szGlobalTempAlloc,LoadStringToGlobalBuffer(IDS_MESSAGE),MB_OK);
        return(S_OK);
    }

    ulCount=GetAddrCount((AdrBuffer));

    if (ulCount) {
        lpsbinary = (LPSBinary)LocalAlloc(LMEM_FIXED,((ulCount+1)*sizeof(SBinary)));
        if (! lpsbinary) {
            return(hrMemory);
        }
        memset(lpsbinary,0,((ulCount+1) * sizeof(SBinary)));
    }

    if (0 != (hResult = OpenWabContainer(&lpWabContainer, lpAdrBook))) {
        return(hResult);
    }
    if (0 != (hResult = lpWabContainer->lpVtbl->GetProps(lpWabContainer,
      (LPSPropTagArray)&ptaCon, 0, &cProps, (LPSPropValue *)&sProp))) {
        if (hResult == MAPI_W_ERRORS_RETURNED) {
            WABFreeBuffer(sProp);
            sProp = NULL;
        }
        goto Error;
    }
    Progress.denominator = ul;
    Progress.numerator = 0;
    Progress.lpText = NULL;
    ul = 0;
    while (GetAdrLine(&AdrBuffer, &szL, &szDesc)) {
        szLine = szL;
        szDescription = szDesc;

        Progress.numerator = ul++;
        lpProgressCB(hwnd,&Progress);


        if (0 == (hResult = ProcessLn(&szLine, &szDescription,&nsAdrBook,&AdrBuffer))) {
            if (nsAdrBook.DistList) {
                hResult=FillDistList(hwnd, lpWabContainer,sProp,lpOptions,&nsAdrBook,
                  lpsbinary,lpAdrBook);
            } else {
                hResult = FillMailUser(hwnd, lpWabContainer,sProp, lpOptions,(void *)&nsAdrBook,
                  lpsbinary,0,NETSCAPE);
            }
        }


        if (szL) {
            LocalFree((HLOCAL)szL);
            szL = NULL;
        }
        if (szDesc) {
            LocalFree(szDesc);
            szDesc = NULL;
        }
        if (nsAdrBook.Description) {
            LocalFree((HLOCAL)nsAdrBook.Description);
        }
        nsAdrBook.Description = NULL;
        if (nsAdrBook.NickName) {
            LocalFree((HLOCAL)nsAdrBook.NickName);
        }
        nsAdrBook.NickName = NULL;
        if (nsAdrBook.Address) {
            LocalFree((HLOCAL)nsAdrBook.Address);
        }
        nsAdrBook.Address = NULL;
        if (nsAdrBook.Entry) {
            LocalFree((HLOCAL)nsAdrBook.Entry);
        }
        nsAdrBook.Entry = NULL;
        if (hrMemory == hResult) {
            break;
        }


    }

    if (sProp) {
        WABFreeBuffer(sProp);
        sProp = NULL;
    }

Error:
    if (NULL != lpsbinary) {
        for (ul=0; ul < ulCount + 1; ul++) {
            if (lpsbinary[ul].lpb) {
                LocalFree((HLOCAL)lpsbinary[ul].lpb);
                lpsbinary[ul].lpb=NULL;
            }
        }

        LocalFree((HLOCAL)lpsbinary);
        lpsbinary = NULL;
    }
    if (lpWabContainer) {
        lpWabContainer->lpVtbl->Release(lpWabContainer);
        lpWabContainer = NULL;
    }
    return(S_OK);
}


/******************************************************************************
 *  FUNCTION NAME:GetAdrLine
 *
 *  PURPOSE:    To get an address line and description of the address in a buffer
 *              from NetScape address book.
 *
 *  PARAMETERS: szCurPointer = pointer to the buffer containing the entire
 *                addresses.
 *              szBuffer = pointer to the address line buffer
 *              szDesc = pointer to the description buffeer.
 *
 *  RETURNS:    BOOL
 ******************************************************************************/
BOOL GetAdrLine(LPTSTR *szCurPointer, LPTSTR *szBuffer, LPTSTR *szDesc)
{
    static TCHAR szAdrStart[] = "<DT>";
    static TCHAR szAdrEnd[] = "</A>";
    static TCHAR szDescStart[] = "<DD>";
    static TCHAR szDistListEnd[] = "</H3>";
    LPTSTR  temp = NULL;
    BOOL flag = TRUE;

    ULONG ulSize = 0;
    LPTSTR szS = NULL, szE = NULL, szD = NULL, szDE = NULL ,szH = NULL;

    szS = strstr(*szCurPointer, szAdrStart);
    szE = strstr(*szCurPointer, szAdrEnd);
    szH = strstr(*szCurPointer, szDistListEnd);


    if (szS) {
        szS += lstrlen(szAdrStart);
    } else {
        return(FALSE);
    }

    if (szE != NULL) {
        if (szH != NULL  && szE <szH) {
            ulSize = (ULONG) (szE - szS + 1);
            flag = TRUE;
        } else {
            if (szH != NULL) {
                ulSize = (ULONG) (szH - szS + 1);
                flag = FALSE;
            } else {
                ulSize = (ULONG) (szE - szS + 1);
                flag = TRUE;
            }
        }
    } else {
        if (szH != NULL) {
            ulSize = (ULONG) (szH - szS + 1);
            flag = FALSE;
        }
    }

    if (ulSize) {
        *szBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulSize + 1));
        if (! *szBuffer) {
            StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MEMORY), ARRAYSIZE(szGlobalTempAlloc));
            MessageBox(NULL,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),MB_OK);
            return(FALSE);
        }

        StrCpyN(*szBuffer, szS,ulSize);
    }

    szD = strstr(*szCurPointer, szDescStart);

    // check if DT flag comes before DD. that means DD is not for this address

    temp = strstr((szS + 4), "<DT>");
    if ((temp != NULL && temp < szD) || (szD == NULL)) {
        *szDesc = NULL;
        if (flag) {
            *szCurPointer = szE + lstrlen(szAdrEnd);
        } else {
            *szCurPointer = szH + lstrlen(szDistListEnd);
        }
        return(TRUE);
    }
    temp = NULL;

    // Description will be uptil next \r\n

    if (szD) {
        szD += lstrlen(szDescStart);
        szDE = strstr(szD, LoadStringToGlobalBuffer(IDS_EOL));

        if (szDE) {
            szDE -= 1;
        }

        ulSize = (ULONG) (szDE - szD + 1);
    }

    if (ulSize) {
        *szDesc = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulSize+1));
        if (! *szDesc) {
            StrCpyN(szGlobalTempAlloc,LoadStringToGlobalBuffer(IDS_MEMORY), ARRAYSIZE(szGlobalTempAlloc));
            MessageBox(NULL,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),MB_OK);
            return(FALSE);
        }

        StrCpyN(*szDesc, szD, ulSize);
        *szCurPointer = szDE + 2;
    } else {
        *szDesc = NULL;
        *szCurPointer  = szDE + 2;
    }

    return(TRUE);
}

/******************************************************************************
 *  FUNCTION NAME:ProcessLn
 *
 *  PURPOSE:    Process an address line and fill the NSADRBOOK structure.
 *
 *  PARAMETERS: szL = pointer to the address line buffer
 *              szDesc = pointer to the description buffer
 *              nsAdrBook = pointer to the NSADRBOOK structure.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT ProcessLn(LPTSTR *szL, LPTSTR *szDesc, NSADRBOOK *nsAdrBook, LPTSTR *szBuffer)
{
    LPTSTR szPrmStart = NULL, szPrmEnd = NULL;
    TCHAR cMailto[MAX_STRING_SIZE];
    TCHAR cAliasId[MAX_STRING_SIZE];
    TCHAR cNickname[MAX_STRING_SIZE];
    BOOL flag = FALSE;              //To check for distribution list
    LPNSDISTLIST present=NULL, previous=NULL;
    TCHAR *tmpStr = NULL;
    ULONG ulSize = 0;
    LPTSTR szDistStart = NULL, szDistEnd = NULL, szDistBuffer = NULL, szName = NULL;

    LPTSTR temp = NULL;
    BOOL NoNickName = FALSE;
    HRESULT hResult = S_OK;

    StrCpyN(cMailto, LoadStringToGlobalBuffer(IDS_MAILTO), ARRAYSIZE(cMailto));
    StrCpyN(cAliasId, LoadStringToGlobalBuffer(IDS_ALIAS_ID), ARRAYSIZE(cAliasId));
    StrCpyN(cNickname, LoadStringToGlobalBuffer(IDS_NICKNAME), ARRAYSIZE(cNickname));

    memset(nsAdrBook,0, sizeof(NSADRBOOK));
    nsAdrBook->DistList = TRUE;
    /* Get Mailto entry */
    szPrmStart = strstr(*szL, cMailto);
    if (! szPrmStart) {
        flag = TRUE;
        nsAdrBook->DistList = TRUE;
        szName = strchr(*szL,'>');
        goto AliasID;
    }

    nsAdrBook->DistList = FALSE;
    szPrmStart += lstrlen(cMailto);

    // search for quotes

    szPrmEnd = szPrmStart;
    if (! szPrmEnd) {
        goto AliasID;
    }

    while (*szPrmEnd != 34) {
        szPrmEnd = szPrmEnd + 1;  // What if there is no end quote

        if (szPrmEnd > (*szL + lstrlen(*szL))) {
            goto Down;
        }
    }
    ulSize = (ULONG) (szPrmEnd - szPrmStart);
    if (ulSize) {
        nsAdrBook->Address = (TCHAR *)LocalAlloc(LMEM_FIXED, (ulSize + 1));
        if (!nsAdrBook->Address) {
            return(hrMemory);
        }
        StrCpyN(nsAdrBook->Address, szPrmStart, ulSize+1);
    }

    *szL = szPrmEnd + 1;

    /* Get the AliasID */
    if (szPrmEnd) {
        szName = strchr(szPrmEnd, '>');
    }
AliasID:
    szPrmStart = strstr(*szL, cAliasId);
    if (!szPrmStart) {
        nsAdrBook->Sbinary=FALSE;
        goto Nickname;
    }
    nsAdrBook->Sbinary=TRUE;
    szPrmStart += lstrlen(cAliasId);
    szPrmEnd = szPrmStart;


    while (*szPrmEnd != 34) {
        szPrmEnd++;

        if (szPrmEnd > (*szL + strlen(*szL))) {
            goto Down;
        }
    }
    ulSize = (ULONG) (szPrmEnd - szPrmStart + 1);
    tmpStr = (TCHAR *)LocalAlloc(LMEM_FIXED,ulSize);
    if (!tmpStr) {
        return(hrMemory);
    }
    StrCpyN(tmpStr, szPrmStart, ulSize);

    nsAdrBook->AliasID = atoi(tmpStr);
    if (tmpStr) {
        LocalFree((HLOCAL)tmpStr);
    }

    *szL = szPrmEnd + 1;


Nickname:
    szPrmStart = strstr(*szL, cNickname);
    if (!szPrmStart) {
        NoNickName = TRUE;
        goto Entry;
    }
    if (szName && szName < szPrmStart) {
        NoNickName = TRUE;
        goto Entry;
    }
    szPrmStart += lstrlen(cNickname);
    szPrmStart += 1;
    szPrmEnd = szPrmStart;
    while (*szPrmEnd != 34) {
        szPrmEnd++;
        if (szPrmEnd > (*szL + strlen(*szL))) {
            goto Down;
        }
    }
    ulSize = (ULONG) (szPrmEnd - szPrmStart);
    if (0 == ulSize) {
        NoNickName = TRUE;
    } else {
        NoNickName = FALSE;
        nsAdrBook->NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, (ulSize + 1));
        if (!nsAdrBook->NickName) {
            return(hrMemory);
        }
        StrCpyN(nsAdrBook->NickName, szPrmStart, ulSize + 1);
    }

    *szL = szPrmEnd +1;

Entry:
    szPrmStart = szName;
    if (szPrmStart) {
        szPrmStart++;
        ulSize = (ULONG) ((*szL + lstrlen(*szL)) - szPrmStart);
        if (ulSize) {
            nsAdrBook->Entry = (TCHAR *)LocalAlloc(LMEM_FIXED, (ulSize + 1));
            if (!nsAdrBook->Entry) {
                return(hrMemory);
            }
            StrCpyN(nsAdrBook->Entry, szPrmStart, ulSize + 1);
        }
        if (/*NoNickName && */!nsAdrBook->Entry && nsAdrBook->Address) {
            ulSize = lstrlen(nsAdrBook->Address) + 1;
            nsAdrBook->Entry = (TCHAR *)LocalAlloc(LMEM_FIXED,ulSize);
            if (!nsAdrBook->Entry) {
                return(hrMemory);
            }
            StrCpyN(nsAdrBook->Entry, nsAdrBook->Address, ulSize);
        }
    }

    if (*szDesc) {
        ulSize = lstrlen(*szDesc) + 1;
        nsAdrBook->Description = (TCHAR *)LocalAlloc(LMEM_FIXED, ulSize);
        if (! nsAdrBook->Description) {
            return(hrMemory);
        }
        StrCpyN(nsAdrBook->Description, *szDesc,ulSize);
    } else {
        nsAdrBook->Description = NULL;
    }

    if (flag == TRUE) {
        ulSize = 0;
        szDistStart = GetAdrStart(*szBuffer);
        szDistEnd = GetDLNext(*szBuffer);

        if (szDistEnd - szDistStart) {
            ulSize = (ULONG) (szDistEnd-szDistStart);
        }
        if (ulSize) {
            szDistBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulSize + 1));
            if (!szDistBuffer) {
                return(hrMemory);
            }
            StrCpyN(szDistBuffer, szDistStart, ulSize + 1);
            *szBuffer=szDistEnd;
        } else {
            return(S_OK);
        }
        szPrmStart=szDistBuffer;

        if ((temp = strstr(szPrmStart, LoadStringToGlobalBuffer(IDS_ALIASOF))) == NULL) {
            if (szDistBuffer) {
                LocalFree((HLOCAL)szDistBuffer);
            }
            return(S_OK);
        }

        while ((szPrmEnd=strstr(szPrmStart, LoadStringToGlobalBuffer(IDS_ALIASOF)))!=NULL) {

            present = (LPNSDISTLIST)LocalAlloc(LMEM_FIXED,sizeof(NSDISTLIST));
            if (! present) {
                if (szDistBuffer) {
                    LocalFree((HLOCAL)szDistBuffer);
                }
                return(hrMemory);
            }
            szPrmEnd += strlen(LoadStringToGlobalBuffer(IDS_ALIASOF));
            szPrmStart = strchr(szPrmEnd,'"');

            ulSize = (ULONG) (szPrmStart - szPrmEnd + 1);
            tmpStr = (TCHAR *)LocalAlloc(LMEM_FIXED,ulSize);
            if (! tmpStr) {
                return(hrMemory);
            }
            StrCpyN(tmpStr, szPrmEnd, ulSize);

            present->AliasID = atoi(tmpStr);
            if (tmpStr) {
                LocalFree((HLOCAL)tmpStr);
            }

            if (previous != NULL) {
                previous->lpDist = present;
            } else {
                nsAdrBook->lpDist = present;
            }
            previous=present;

        }
        present->lpDist=NULL;

        if (szDistBuffer) {
            LocalFree((HLOCAL)szDistBuffer);
        }

    } else {
        nsAdrBook->lpDist=NULL;
    }

Down:
    return(S_OK);
}


/******************************************************************************
 *  FUNCTION NAME:GetAddressCount
 *
 *  PURPOSE:    To get the count of number of <DT> in the buffer containing the
 *              addresses.
 *
 *  PARAMETERS: AdrBuffer = Buffer containing the addresses.
 *
 *  RETURNS:ULONG , count of <DT>
 ******************************************************************************/
ULONG GetAddressCount(LPTSTR AdrBuffer)
{
    TCHAR szToken[] = "<DT>";
    LPTSTR szTemp = AdrBuffer;
    LPTSTR szP = NULL;
    ULONG ulCount = 0;

    while ((szP = strstr(szTemp, szToken)) != NULL) {
        ulCount++;
        szTemp = szP + lstrlen(szToken);
    }

    return(ulCount);
}


/******************************************************************************
 *  FUNCTION NAME:GetAdrStart
 *
 *  PURPOSE:    To get a pointer to the starting of addresses in the NetScape
 *              address book.
 *
 *  PARAMETERS: szBuffer = pointer to the buffer containing the address book.
 *
 *  RETURNS:    LPTSTR, pointer to the starting of addresses (<DL><p>).
 ******************************************************************************/
LPTSTR  GetAdrStart(LPTSTR szBuffer)
{
    TCHAR szAdrStart[] = "<DL><p>";
    LPTSTR szS=NULL;

    szS = strstr(szBuffer, szAdrStart);
    if (szS) {
        szS += lstrlen(szAdrStart);
    }

    return(szS);
}


/******************************************************************************
 *  FUNCTION NAME:GetDLNext
 *
 *  PURPOSE:    To get a pointer to the </DL><p> in the address buffer.
 *
 *  PARAMETERS: szBuffer = address buffer
 *
 *  RETURNS:    LPTSTR, pointer to the </DL><p>
 ******************************************************************************/
LPTSTR GetDLNext(LPTSTR szBuffer)
{
    TCHAR szAdrStart[] = "</DL><p>";
    LPTSTR szS = NULL;

    szS = strstr(szBuffer, szAdrStart);
    if (szS) {
        szS += lstrlen(szAdrStart) + 1;
    }
    return(szS);
}


/******************************************************************************
 *  FUNCTION NAME:GetAdrEnd
 *
 *  PURPOSE:    To get a pointer to the last occurance of </DL><p> in the address
 *              buffer.
 *
 *  PARAMETERS: szBuffer = address buffer
 *
 *  RETURNS:    LPTSTR, pointer to the last </DL><p>
 ******************************************************************************/
LPTSTR  GetAdrEnd(LPTSTR szBuffer)
{
    TCHAR szAdrEnd[] = "</DL><p>";
    LPTSTR szE = NULL, szT = NULL;
    LPTSTR szTemp = szBuffer;

    while ((szE = strstr(szTemp, szAdrEnd)) != NULL) {
        szT=szE;
        szTemp = szE + lstrlen(szAdrEnd);
    }

    szE = szT;

    if (szE) {
        szE += lstrlen(szAdrEnd);
    }

    return(szE);
}


/******************************************************************************
 *  FUNCTION NAME:GetAddrCount
 *
 *  PURPOSE:    To get a count of number of ALIASID in the address buffer.
 *
 *  PARAMETERS: AdrBuffer = address buffer
 *
 *  RETURNS:    ULONG, count of total ALIASID in the address buffer
 ******************************************************************************/
ULONG GetAddrCount(LPTSTR AdrBuffer)
{
    TCHAR szToken[MAX_STRING_SIZE];
    LPTSTR szTemp=AdrBuffer;
    LPTSTR szP=NULL;
    ULONG ulCount=0;

    StrCpyN(szToken, LoadStringToGlobalBuffer(IDS_ALIAS_ID), ARRAYSIZE(szToken));

    while ((szP=strstr(szTemp,szToken))!=NULL) {
        ulCount++;
        szTemp =szP+lstrlen(szToken);
    }

    return(ulCount);
}


/******************************************************************************
 *  FUNCTION NAME:FillDistList
 *
 *  PURPOSE:    To create a Distribution list in the WAB.
 *
 *  PARAMETERS: hwnd - hwnd of parent
 *              lpWabContainer = pointer to the IABCONT interface
 *              sProp = pointer to SPropValue
 *              lpAdrBook = pointer to the IADRBOOK interface
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *              lpsbinary = pointer to the SBinary array.
 *              lpnAdrBook = pointer to the NSADRBOOK structure
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT FillDistList(HWND hwnd, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions, LPNSADRBOOK lpnAdrBook,
  LPSBinary lpsbinary, LPADRBOOK lpAdrBook)
{

    LPNSDISTLIST lptemp=lpnAdrBook->lpDist;
    LPSPropValue lpNewDLProps = NULL;
    LPDISTLIST lpDistList = NULL;
    ULONG cProps;
    ULONG  ulObjType;
    int i;
    HRESULT hResult;
    static LPMAPIPROP lpMailUserWAB =NULL;
    SPropValue rgProps[4];
    LPMAPIPROP lpDlWAB = NULL;
    ULONG iCreateTemplatedl = iconPR_DEF_CREATE_DL;

    BOOL flag = FALSE;
    REPLACE_INFO RI = {0};
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;

retry:

    if (lpnAdrBook->Sbinary == FALSE) {
        if (0 != (hResult=CreateDistEntry(lpWabContainer,sProp,ulCreateFlags,
          &lpMailUserWAB))) {
            goto error1;
        }
    } else {
        if (lpsbinary[lpnAdrBook->AliasID].lpb == NULL) {
            if (0 != (hResult=CreateDistEntry(lpWabContainer,sProp,ulCreateFlags,
              &lpMailUserWAB))) {
                goto error1;
            }
        } else {
            if (0 != (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
              lpsbinary[lpnAdrBook->AliasID].cb,
              (LPENTRYID)lpsbinary[lpnAdrBook->AliasID].lpb,
              (LPIID)&IID_IMAPIProp,
              MAPI_DEFERRED_ERRORS|MAPI_MODIFY,
              &ulObjType,
              (LPUNKNOWN *)&lpMailUserWAB))) {
                goto error1;
            }
            flag = TRUE;
        }
    }


    if (lpnAdrBook->Entry) {
        rgProps[0].Value.lpszA = lpnAdrBook->Entry;
        rgProps[0].ulPropTag = PR_DISPLAY_NAME;
    } else if (lpnAdrBook->NickName) {
        rgProps[0].Value.lpszA = lpnAdrBook->NickName;
        rgProps[0].ulPropTag = PR_DISPLAY_NAME;
    } else {
        rgProps[0].Value.lpszA = NULL;
        rgProps[0].ulPropTag = PR_NULL;
    }

    rgProps[1].Value.lpszA = lpnAdrBook->Description;
    if (lpnAdrBook->Description) {
        rgProps[1].ulPropTag = PR_COMMENT;
    } else {
        rgProps[1].ulPropTag = PR_NULL;
    }



    if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
      2, rgProps, NULL))) {
        goto error1;
    }

    if (0 != (hResult=lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
      FORCE_SAVE|KEEP_OPEN_READWRITE))) {
        if (GetScode(hResult) == MAPI_E_COLLISION) {
            if (lpOptions->ReplaceOption == WAB_REPLACE_ALWAYS) {
                if (lpMailUserWAB) {
                    lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                }
                lpMailUserWAB = NULL;
                ulCreateFlags |= CREATE_REPLACE;
                goto retry;
            }

            if (lpOptions->ReplaceOption == WAB_REPLACE_NEVER) {
                hResult = S_OK;
                goto error1;
            }

            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
                if (lpnAdrBook->Entry) {
                    RI.lpszDisplayName = lpnAdrBook->Entry;
                    RI.lpszEmailAddress = lpnAdrBook->Address;
                } else if (lpnAdrBook->NickName) {
                    RI.lpszDisplayName = lpnAdrBook->NickName;
                    RI.lpszEmailAddress = lpnAdrBook->Address;
                } else if (lpnAdrBook->Address) {
                    RI.lpszDisplayName = lpnAdrBook->Address;
                    RI.lpszEmailAddress = NULL;
                } else if (lpnAdrBook->Description) {
                    RI.lpszDisplayName = lpnAdrBook->Description;
                    RI.lpszEmailAddress = NULL;
                } else {
                    RI.lpszDisplayName = "";
                    RI.lpszEmailAddress = NULL;
                }
                RI.ConfirmResult = CONFIRM_ERROR;
                RI.fExport = FALSE;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ImportReplace), hwnd,
                  ReplaceDialogProc, (LPARAM)&RI);

                switch (RI.ConfirmResult) {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                        lpMailUserWAB = NULL;
                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    case CONFIRM_NO:
                        if (lpnAdrBook->Sbinary == TRUE) {
                            hResult = GetExistEntry(lpWabContainer,lpsbinary,
                                                    lpnAdrBook->AliasID,
                                                    lpnAdrBook->Entry,
                                                    lpnAdrBook->NickName);
                        }
                        goto error1;

                    case CONFIRM_ABORT:
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        goto error1;

                    default:

                        break;
                }
            }
        }
    }

    if (0 != (hResult = lpMailUserWAB->lpVtbl->GetProps(lpMailUserWAB,
      (LPSPropTagArray)&ptaEid, 0, &cProps, (LPSPropValue *)&lpNewDLProps))) {
        if (hResult == MAPI_W_ERRORS_RETURNED) {
            WABFreeBuffer(lpNewDLProps);
            lpNewDLProps = NULL;
        }
        goto error1;
    }

    if (lpnAdrBook->Sbinary == TRUE) {
        if (flag == FALSE) {
            lpsbinary[lpnAdrBook->AliasID].lpb=(LPBYTE)LocalAlloc(LMEM_FIXED,
              lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
            if (! lpsbinary[lpnAdrBook->AliasID].lpb) {
                hResult = hrMemory;
                goto error1;
            }
            CopyMemory(lpsbinary[lpnAdrBook->AliasID].lpb,
              (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,
              lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
            lpsbinary[lpnAdrBook->AliasID].cb=lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb;
        }
    }


    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
        lpMailUserWAB = NULL;
    }


    if (0 != (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
      lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb,
      (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,
      (LPIID)&IID_IDistList,
      MAPI_DEFERRED_ERRORS|MAPI_MODIFY,
      &ulObjType,
      (LPUNKNOWN *)&lpDistList))) {
        goto error1;
    }

    if (lpNewDLProps) {
        WABFreeBuffer(lpNewDLProps);
        lpNewDLProps = NULL;
    }
    if (NULL == lpnAdrBook->lpDist) {
        goto error1;
    }
    do {
        i = lpnAdrBook->lpDist->AliasID;

        if ((LPENTRYID)lpsbinary[i].lpb == NULL) {
            if (0 != (hResult=CreateDistEntry(lpWabContainer,sProp,ulCreateFlags,
              &lpMailUserWAB))) {
                goto error2;
            }

            rgProps[0].ulPropTag = PR_DISPLAY_NAME;
            rgProps[0].Value.lpszA = LoadStringToGlobalBuffer(IDS_DUMMY);

            if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
              1, rgProps, NULL))) {
                goto error2;
            }
            if (0 != (hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
              FORCE_SAVE|KEEP_OPEN_READONLY))) {
                goto error2;
            }

            if (0 != (hResult = lpMailUserWAB->lpVtbl->GetProps(lpMailUserWAB,
              (LPSPropTagArray)&ptaEid, 0, &cProps, (LPSPropValue *)&lpNewDLProps))) {
                if (hResult == MAPI_W_ERRORS_RETURNED) {
                    WABFreeBuffer(lpNewDLProps);
                    lpNewDLProps = NULL;
                }
                goto error2;
            }

            lpsbinary[i].lpb=(LPBYTE)LocalAlloc(LMEM_FIXED,lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
            if (!lpsbinary[i].lpb) {
                hResult = hrMemory;
                goto error1;
            }
            CopyMemory(lpsbinary[i].lpb,
              (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
            lpsbinary[i].cb=lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb;

            if (lpNewDLProps) {
                WABFreeBuffer(lpNewDLProps);
                lpNewDLProps = NULL;
            }
error2:

            if (lpMailUserWAB) {
                lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                lpMailUserWAB = NULL;
            }
        }

        if (0 != (hResult = lpDistList->lpVtbl->CreateEntry(lpDistList,
          lpsbinary[i].cb,
          (LPENTRYID)lpsbinary[i].lpb,
          CREATE_CHECK_DUP_STRICT|CREATE_REPLACE,
          &lpDlWAB))) {
            goto error3;
        }

        if (0 != (hResult = lpDlWAB->lpVtbl->SaveChanges(lpDlWAB, FORCE_SAVE))) {
            if (MAPI_E_FOLDER_CYCLE ==hResult) {
                StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_LOOPING), ARRAYSIZE(szGlobalTempAlloc));
                MessageBox(NULL,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ENTRY_NOIMPORT),MB_OK);
            }
            hResult = S_OK;
            goto error3;
        }
error3:
        if (lpDlWAB) {
            lpDlWAB->lpVtbl->Release(lpDlWAB);
            lpDlWAB = NULL;
        }

        lpnAdrBook->lpDist = FreeNSdistlist(lpnAdrBook->lpDist);
    } while (lpnAdrBook->lpDist!=NULL);

error1:

    if (lpDistList) {
        lpDistList->lpVtbl->Release(lpDistList);
        lpDistList = NULL;
    }

    if (lpDlWAB) {
        lpDlWAB->lpVtbl->Release(lpDlWAB);
        lpDlWAB = NULL;
    }

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
        lpMailUserWAB = NULL;
    }
    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:  FillWABStruct
 *
 *  PURPOSE:    To fill the SpropValue array.
 *
 *  PARAMETERS: nsAdrBook = pointer to the NSADRBOOK structure.
 *              rgProps = pointer to the SpropValue array.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT FillWABStruct(LPSPropValue rgProps, NSADRBOOK *nsAdrBook)
{
    HRESULT hr = S_OK;

    rgProps[1].ulPropTag = PR_DISPLAY_NAME;
    if (nsAdrBook->Entry) {
        rgProps[1].Value.lpszA = nsAdrBook->Entry;
    } else if (nsAdrBook->NickName) {
        rgProps[1].Value.lpszA = nsAdrBook->NickName;
    } else {
        StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_NONAME), ARRAYSIZE(szGlobalTempAlloc));
        rgProps[1].Value.lpszA  = szGlobalTempAlloc;
    }

    rgProps[0].Value.lpszA = nsAdrBook->Address;
    if (nsAdrBook->Address) {
        rgProps[0].ulPropTag = PR_EMAIL_ADDRESS;
        rgProps[2].ulPropTag = PR_ADDRTYPE;
        rgProps[2].Value.lpszA = LoadStringToGlobalBuffer(IDS_SMTP);
    } else {
        rgProps[0].ulPropTag = PR_NULL;
        rgProps[2].ulPropTag = PR_NULL;
        rgProps[2].Value.lpszA = NULL;
    }

    rgProps[3].Value.lpszA = nsAdrBook->Description;
    if (nsAdrBook->Description) {
        rgProps[3].ulPropTag = PR_COMMENT;
    } else {
        rgProps[3].ulPropTag = PR_NULL;
    }

    rgProps[4].Value.lpszA = nsAdrBook->NickName;
    if (nsAdrBook->NickName) {
        rgProps[4].ulPropTag = PR_NICKNAME;
    } else {
        rgProps[4].ulPropTag = PR_NULL;
    }

    return(hr);
}


/******************************************************************************
 *  FUNCTION NAME:CreateDistEntry
 *
 *  PURPOSE:    To create an entry in the WAB for a Distribution List
 *
 *  PARAMETERS: lpWabContainer = pointer to the WAB container.
 *              sProp = pointer to SPropValue
 *              ulCreateFlags = Flags
 *              lppMailUserWab = pointer to the IMAPIPROP interface
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT CreateDistEntry(LPABCONT lpWabContainer,LPSPropValue sProp,
  ULONG ulCreateFlags,LPMAPIPROP *lppMailUserWab)
{
    HRESULT hResult;
    ULONG iCreateTemplatedl = iconPR_DEF_CREATE_DL;


    hResult = lpWabContainer->lpVtbl->CreateEntry(lpWabContainer,
      sProp[iCreateTemplatedl].Value.bin.cb,
      (LPENTRYID)sProp[iCreateTemplatedl].Value.bin.lpb,
      ulCreateFlags,
      lppMailUserWab);
    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:FreeNSdistlist
 *
 *  PURPOSE:    To free one node from NSDISTLIST(linked list)
 *
 *  PARAMETERS: lpDist = pointer to the NSDISTLIST structure.
 *
 *  RETURNS:    LPNSDISTLIST , pointer to the next link.
 ******************************************************************************/
LPNSDISTLIST FreeNSdistlist(LPNSDISTLIST lpDist)
{
    LPNSDISTLIST lpTemp = NULL;

    if (lpDist==NULL) {
        return(NULL);
    }

    lpTemp = lpDist->lpDist;
    LocalFree((HLOCAL)lpDist);
    lpDist = NULL;
    return(lpTemp);
}


/******************************************************************************
  *********************Eudora Functions*****************************************/


HRESULT ImportEudoraAddressBookFile(HWND hwnd, LPTSTR szFileName, LPABCONT lpWabContainer,
  LPWAB_IMPORT_OPTIONS lpOptions, LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{
    HRESULT hResult = E_FAIL;
    ULONG cProps;
    LPEUDADRBOOK lpeudAdrBook = NULL;
    ULONG ulCount = 0, uCounter = 0;
    LPSPropValue sProp = NULL;

    if (! (ulCount = ParseEudAddress(szFileName,&lpeudAdrBook))) {
        goto Error;
    }

    if (0 != (hResult = lpWabContainer->lpVtbl->GetProps(lpWabContainer,
      (LPSPropTagArray)&ptaCon, 0, &cProps, (LPSPropValue *)&sProp))) {
        if (hResult == MAPI_W_ERRORS_RETURNED) {
            WABFreeBuffer(sProp);
            sProp = NULL;
        }
        goto Error;
    }

    hResult = ImportEudUsers(hwnd, szFileName, lpWabContainer, sProp, lpeudAdrBook,ulCount,
      lpOptions,lpProgressCB,lpAdrBook);
    if (sProp) {
        WABFreeBuffer(sProp);
    }
Error:
    if (lpeudAdrBook) {

        for (; uCounter < ulCount ; uCounter++) {
            if (lpeudAdrBook[uCounter].Description) {
                LocalFree((HLOCAL)lpeudAdrBook[uCounter].Description);
            }
            lpeudAdrBook[uCounter].Description = NULL;
            if (lpeudAdrBook[uCounter].NickName) {
                LocalFree((HLOCAL)lpeudAdrBook[uCounter].NickName);
            }
            lpeudAdrBook[uCounter].NickName = NULL;
            if (lpeudAdrBook[uCounter].Address) {
                LocalFree((HLOCAL)lpeudAdrBook[uCounter].Address);
            }
            lpeudAdrBook[uCounter].Address = NULL;
        }
        LocalFree((HLOCAL)lpeudAdrBook);
        lpeudAdrBook=NULL;
    }

    return(hResult);
}


/******************************************************************************
*  FUNCTION NAME:MigrateEudoraUser
*
*  PURPOSE:     Get the installation path of the address book and starts processing
*               the Eudora address book
*
*  PARAMETERS:  hwnd = Handle to the parent Window
*               lpAdrBook = pointer to the IADRBOOK interface
*               lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
*               lpOptions = pointer to WAB_IMPORT_OPTIONS structure
*               lpWabContainer = pointer to the IABCONT interface
*
*  RETURNS:     HRESULT
******************************************************************************/
HRESULT MigrateEudoraUser(HWND hwnd,  LPABCONT lpWabContainer,
  LPWAB_IMPORT_OPTIONS lpOptions, LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPADRBOOK lpAdrBook)
{

    TCHAR szFileName[MAX_FILE_NAME];
    TCHAR szFilePath[MAX_FILE_NAME];
    TCHAR szFileSubPath[MAX_FILE_NAME];
    HRESULT hResult = S_OK;
    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = NULL;


    szFilePath[0] = szFileName[0] = '\0';

    hResult= GetRegistryPath(szFileName, ARRAYSIZE(szFileName), EUDORA);
    if (hResult == hrMemory) {
        return(hrMemory);
    }

    if (0 != hResult) {
        // Didnt find the registry setting .. look for "c:\eudora"
        StrCpyN(szFileName, LoadStringToGlobalBuffer(IDS_EUDORA_DEFAULT_INSTALL), ARRAYSIZE(szFileName));

        if (0xFFFFFFFF != GetFileAttributes(szFileName)) {
            // This directory exists .. reset the error value
            hResult = S_OK;
        }
    }

    if (0 != hResult) {
        StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_STRING_SELECTPATH), ARRAYSIZE(szGlobalTempAlloc));
        if (IDNO ==MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),
          MB_YESNO)) {
            return(ResultFromScode(MAPI_E_USER_CANCEL));
        }
        if (!GetFileToImport(hwnd, szFileName, ARRAYSIZE(szFileName), EUDORA)) {
            return(ResultFromScode(MAPI_E_USER_CANCEL));
        }
    } else {
        StrCatBuff(szFileName, LoadStringToGlobalBuffer(IDS_EUDORA_ADDRESS), ARRAYSIZE(szFileName));
        hFile = FindFirstFile(szFileName,&FindFileData);
        if (INVALID_HANDLE_VALUE == hFile) {
            StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ADDRESS_HTM), ARRAYSIZE(szGlobalTempAlloc));
            if (IDNO == MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR),MB_YESNO)) {
                return(ResultFromScode(MAPI_E_USER_CANCEL));
            }
            if (FALSE ==GetFileToImport(hwnd, szFileName, ARRAYSIZE(szFileName), EUDORA)) {
                return(ResultFromScode(MAPI_E_USER_CANCEL));
            }

        } else {
            FindClose(hFile);
        }
    }

    // Extract the file directory from the file name
    if (lstrlen(szFileName) && !lstrlen(szFilePath)) {
        LPTSTR lp1 = NULL, lp2 = NULL;
        StrCpyN(szFilePath,szFileName, ARRAYSIZE(szFilePath));
        lp1 = szFilePath;
        // Find the last '\' and terminate the path at that char
        while (lp1 && *lp1) {
            if (*lp1 == '\\') {
                lp2 = lp1;
            }
            lp1 = CharNext(lp1);
        }
        if (lp2 && (*lp2 == '\\')) {
            *lp2 = '\0';
        }
    }

    // import the basic file ...
    //
    hResult = ImportEudoraAddressBookFile(hwnd,
      szFileName, lpWabContainer, lpOptions, lpProgressCB, lpAdrBook);

    szFileName[0]='\0';

    // Now look for files in the nicknames subdirectory
    //
    StrCatBuff(szFilePath, LoadStringToGlobalBuffer(IDS_EUDORA_SUBDIR_NAME), ARRAYSIZE(szFilePath));

    if (0xFFFFFFFF != GetFileAttributes(szFilePath)) {
        BOOL bRet = TRUE;

        // Yes this directory exists ...
        // Now scan all the *.txt files in this subdir and try to import them
        StrCpyN(szFileSubPath, szFilePath, ARRAYSIZE(szFileSubPath));
        StrCatBuff(szFileSubPath, LoadStringToGlobalBuffer(IDS_EUDORA_GENERIC_SUFFIX), ARRAYSIZE(szFileSubPath));

        hFile = FindFirstFile(szFileSubPath, &FindFileData);

        while (bRet && hFile != INVALID_HANDLE_VALUE) {
            StrCpyN(szFileName, szFilePath, ARRAYSIZE(szFileName));
            StrCatBuff(szFileName, TEXT("\\"), ARRAYSIZE(szFileName));
            StrCatBuff(szFileName, FindFileData.cFileName, ARRAYSIZE(szFileName));
            hResult = ImportEudoraAddressBookFile(hwnd,
              szFileName, lpWabContainer, lpOptions, lpProgressCB, lpAdrBook);
            hResult = S_OK;

            // Dont report errors .. just continue ...
            bRet = FindNextFile(hFile, &FindFileData);
        }

        if (hFile) {
            FindClose(hFile);
        }
    }

    return(hResult);
}

/******************************************************************************
*  FUNCTION NAME:ParseEudAddress
*
*  PURPOSE:     To open the nndbase.txt and toc files and starts processing the
*               address book.
*
*  PARAMETERS:  szFileName = contains the path of the address book.
*               lppeudAdrBook = pointer to the EUDADRBOOK structure.
*
*  RETURNS:     ULONG, number of addresses in the address book.
******************************************************************************/
ULONG ParseEudAddress(LPTSTR szFileName, LPEUDADRBOOK *lppeudAdrBook)
{
    HANDLE htoc,htxt;
    TCHAR cNndbasetoc[_MAX_PATH];
    ULONG ucount=0;
    ULONG ulAdrcount=0;
    UINT i,j;
    LPTSTR szBuffer=NULL;
    LPTSTR szAdrBuffer=NULL;
    LPTSTR *szAliaspt=NULL;
    ULONG ulRead=0;
    ULONG ulFileSize,ulTxtSize;
    LPEUDADRBOOK lpeudAdrBook;


    StrCpyN(cNndbasetoc,szFileName, ARRAYSIZE(cNndbasetoc));
    cNndbasetoc[strlen(cNndbasetoc)-3] = '\0';
    StrCatBuff(cNndbasetoc, LoadStringToGlobalBuffer(IDS_EUDORA_TOC), ARRAYSIZE(cNndbasetoc));

    /* Eudora address book has two files,nndbase.txt and nndbase.toc.
    nndbase.toc format:
    Nicknames start from byte 3. Every Nickname will be delimited by /r/n.
    After this there will 4 byte address offset,4 byte address size,
    4 byte description offset and 4 byte description size. The address offset
    and size constitute all the addresses in the NickName.(A NickName can
    be a distribution list or a single mail user */

    htoc = CreateFile(cNndbasetoc, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
      FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (INVALID_HANDLE_VALUE == htoc) {
        goto Error;
    }

    htxt = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
      FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (INVALID_HANDLE_VALUE == htxt) {
        goto Error;
    }

    //get toc file in a buffer
    ulFileSize = GetFileSize(htoc, NULL);
    szBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulFileSize+1));

    if (! szBuffer) {
        goto NoMemory;
    }
    if (! ReadFile(htoc, szBuffer, ulFileSize, &ulRead, NULL)) {
        goto Error;
    }

    szBuffer[ulFileSize] = '\0';

    //get address file in a buffer

    ulTxtSize = GetFileSize(htxt, NULL);

    szAdrBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulTxtSize+1));

    if (!szAdrBuffer) {
        goto NoMemory;
    }

    if (! ReadFile(htxt, szAdrBuffer, ulTxtSize, &ulRead, NULL)) {
        goto Error;
    }
    szAdrBuffer[ulTxtSize] = '\0';
            
    // BUG 2120: to deal with only LF's and not CR/LF's 
    for (i = 2; i < (UINT)ulFileSize; i++) {
        if (! (/*szBuffer[i] == '\r' && */szBuffer[i+1] == '\n') ) {
            continue;
        }
        ulAdrcount++ ; //to get count of number of address
    }

    if (ulAdrcount) {
        lpeudAdrBook = (LPEUDADRBOOK)LocalAlloc(LMEM_FIXED,
          ((ulAdrcount) * sizeof(EUDADRBOOK)));
        if (!lpeudAdrBook) {
            goto NoMemory;
        }

        memset(lpeudAdrBook,0,((ulAdrcount) * sizeof(EUDADRBOOK)));

        szAliaspt = (LPTSTR *)LocalAlloc(LMEM_FIXED,(sizeof(LPTSTR))*(ulAdrcount+1));
        if (! szAliaspt) {
            goto NoMemory;
        }

        for (i = 0; i < ulAdrcount; i++) {
            szAliaspt[i] = (LPTSTR)LocalAlloc(LMEM_FIXED,256);
            if (!szAliaspt[i]) {
                goto NoMemory;
            }
        }

        szAliaspt[i]=NULL; //to know it is the end.

        j=0;

        for (i = 2; i < (UINT)ulFileSize; i++) {
            // BUG 2120: to deal with only LF's and not CR/LF's 
            if ((/*szBuffer[i] == '\r' &&*/ szBuffer[i+1] == '\n')) {
                i += (EUDORA_STRUCT + 1);
                //16 bytes structure +1 for 10
                szAliaspt[ucount][j] = '\0';
                ucount++;
                j=0;
                continue;
            }
            szAliaspt[ucount][j++]=szBuffer[i];
        }

        if (hrMemory == ParseAddressTokens(szBuffer,szAdrBuffer,ulAdrcount,szAliaspt,lpeudAdrBook)) {
            goto NoMemory;
        }
        *lppeudAdrBook = lpeudAdrBook;
    }

Error:
    if (szBuffer) {
        LocalFree((HLOCAL)szBuffer);
    }
    if (szAdrBuffer) {
        LocalFree((HLOCAL)szAdrBuffer);
    }
    if (htxt) {
        CloseHandle(htxt);
    }
    if (htoc) {
        CloseHandle(htoc);
    }
    if (szAliaspt) {
        for (i = 0; i < ulAdrcount; i++) {
            if (szAliaspt[i]) {
                LocalFree((HLOCAL)szAliaspt[i]);
            }
            szAliaspt[i] = NULL;
        }
        LocalFree((HLOCAL)szAliaspt);
        szAliaspt = NULL;
    }

    return(ulAdrcount);

NoMemory:
    StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MEMORY), ARRAYSIZE(szGlobalTempAlloc));
    MessageBox(NULL,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE),MB_OK);
    if (szBuffer) {
        LocalFree((HLOCAL)szBuffer);
    }
    if (szAdrBuffer) {
        LocalFree((HLOCAL)szAdrBuffer);
    }
    if (htxt) {
        CloseHandle(htxt);
    }
    if (htoc) {
        CloseHandle(htoc);
    }
    if (szAliaspt) {
        for (i = 0; i < ulAdrcount; i++) {
            if (szAliaspt[i]) {
                LocalFree((HLOCAL)szAliaspt[i]);
            }
            szAliaspt[i] = NULL;
        }
        LocalFree((HLOCAL)szAliaspt);
        szAliaspt = NULL;
    }
    return(0);
}


/******************************************************************************
 *  FUNCTION NAME:ParseAddressTokens
 *
 *  PURPOSE:    To fill the EUDADRBOOK array structure after processing all the
 *              addresses from Eudora address book.
 *
 *  PARAMETERS: szBuffer = buffer containing the nndbase.toc file.
 *              szAdrBuffer = buffer containing the nndbase.txt file.
 *              ulCount = number of addresses in the eudora address book.
 *              szAliaspt = pointer to a two dimensional array containing
 *                all the nicknames.
 *              EudAdrBook = pointer to the EUDADRBOOK structure.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT ParseAddressTokens(LPTSTR szBuffer,LPTSTR szAdrBuffer,UINT ulCount,
  LPTSTR *szAliaspt,EUDADRBOOK *EudAdrBook)
{

    ULONG ulAdrSize = 0, ulAdrOffset = 0, i = 0, uDescription = 0, uOffset = 0;
    int iCounter =0;
    LPTSTR szAdrLine = NULL, szAdrEnd = NULL, szAdrStart=NULL, szAdrCur=NULL;

    HRESULT hr = S_OK;

    szAdrStart=&szBuffer[2];

    do {
        if (szAliaspt[i] == NULL) {
            break;
        }
        szAdrCur = Getstr(szAdrStart, szAliaspt[i]);
        if (szAdrCur == NULL) {
            hr = hrMemory;
            goto Error;
        }
        szAdrCur+=strlen(szAliaspt[i])+2;
        ulAdrOffset = ShiftAdd(0,szAdrCur);
        ulAdrSize = ShiftAdd(4,szAdrCur);

        szAdrStart=szAdrCur+16;
        EudAdrBook[i].lpDist=NULL;
        if (hrMemory == (hr = CreateAdrLineBuffer(&szAdrLine,szAdrBuffer,ulAdrOffset,ulAdrSize))) {
            goto Error;
        }
        if (hrMemory == (hr = ParseAdrLineBuffer(szAdrLine,szAliaspt,i,EudAdrBook))) {
            goto Error;
        }
        ulAdrOffset = ShiftAdd(8,szAdrCur);
        ulAdrSize = ShiftAdd(12,szAdrCur);

        if (! (ulAdrSize == 0xFFFFFFFF && ulAdrOffset == 0xFFFFFFFF)) {
            EudAdrBook[i].Description = (TCHAR *)LocalAlloc(LMEM_FIXED, (ulAdrSize+1));
            if (! EudAdrBook[i].Description) {
                hr = hrMemory;
                goto Error;
            }
            for (uDescription = 0, uOffset = 0; uDescription < ulAdrSize; uDescription++,uOffset++) {
                if (szAdrBuffer[ulAdrOffset + uOffset] != 03) { //delimitor for next line in nndbase.txt file
                    EudAdrBook[i].Description[uDescription] = szAdrBuffer[ulAdrOffset + uOffset];
                } else {
                    EudAdrBook[i].Description[uDescription++] = '\r';
                    EudAdrBook[i].Description[uDescription] = '\n';
                }
            }
            // Bug 29803 - this line is not being terminated - has garrbage at end ...
            EudAdrBook[i].Description[uDescription] = '\0';
        } else {
            EudAdrBook[i].Description = NULL;
        }

        i++;
        if (szAdrLine) {
            LocalFree((HLOCAL)szAdrLine);
        }
        szAdrLine = NULL;


    } while (szAdrStart[0]!='\0');

Error:
    if (szAdrLine) {
        LocalFree((HLOCAL)szAdrLine);
    }
    szAdrLine = NULL;

    return(hr);
}


/*******************************************************************************
 *  FUNCTION NAME:CreateAdrLineBuffer
 *
 *  PURPOSE:    To get an address line in a buufer from the buffer conatining
 *              the addressbook.
 *
 *  PARAMETERS: szAdrline = pointer to the address line buffer.
 *              szAdrBuffer = pointer to the buffer containing the address book.
 *              ulAdrOffset = offset of the address line in the szAdrBuffer
 *              ulAdrSize = size of the address line in the szAdrBuffer
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT CreateAdrLineBuffer(LPTSTR *szAdrline, LPTSTR szAdrBuffer, ULONG ulAdrOffset,
  ULONG ulAdrSize)
{
    LPTSTR Temp = NULL;
    ULONG ucount;
    Temp = &szAdrBuffer[ulAdrOffset];

    *szAdrline = (LPTSTR)LocalAlloc(LMEM_FIXED, (ulAdrSize + 2));

    if (! (*szAdrline)) {
        return(hrMemory);
    }
            
    // BUG 2120: to deal with only LF's and not CR/LF's 
    for (ucount = 0; ucount < ulAdrSize + 2; ucount++) {
        // want to stop when get to LF and will check later if
        // it was preceded by a CR
        if (/*Temp[ucount] == '\r' && */Temp[ucount/*+1*/] == '\n') {
            break;
        }
        (*szAdrline)[ucount] = Temp[ucount];
    }
// if there was a CR before the LF remove it
    if( (*szAdrline)[ucount-1] == '\r' )
        (*szAdrline)[ucount-1] = '\0';
    
    (*szAdrline)[ucount] = '\0';

    return(S_OK);
}


/******************************************************************************
 *  FUNCTION NAME:ParseAdrLineBuffer
 *
 *  PURPOSE:    To parse each address line and fill the EUDADRBOOK structure.
 *
 *  PARAMETERS: szAdrLine = pointer to the buffer containing an address line.
 *              szAliaspt = pointer to a two dimensional array containing
 *                all the nicknames.
 *              uToken = position of this address in the address book.
 *              EudAdrBook = pointer to the EUDADRBOOK structure.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT ParseAdrLineBuffer(LPTSTR szAdrLine,LPTSTR *szAliasptr,ULONG uToken,
  EUDADRBOOK *EudAdrBook)
{
    LPTSTR szAdrEnd = NULL, szAdrStart = NULL, szAdrDummy = NULL;
    LPTSTR szAdrCur = NULL;
    INT uCount = 0;
    LPEUDDISTLIST present = NULL, previous = NULL;
    BOOL flag = TRUE;
    UINT Parse = 0;
    HRESULT hResult = S_OK;
    szAdrStart = szAdrLine;

    // Bug 44576 - this code below is assuming that a ',' in a string implies a group
    // However, there can be "...text, text..." as one item in the input in which case
    // this code really barfs ...
    // The code also assumes that <spaces> are delimiters which also wont work with 
    // the strings as above ..
    // 
    // Try changing ',' inside quoted strings to ';' so this code wont trip on them
    // Looks like this code is also throwing away the info in quotes if the string is of
    // the form alias XXX "YYY" zz@zz .. the part in ".." is discarded ??? Fix that as a
    // seperate bug ...
    {
        LPTSTR lp = szAdrStart;
        BOOL bWithinQuotes = FALSE;
        while(lp && *lp)
        {
            if(*lp == '"')
                bWithinQuotes = !bWithinQuotes;
            if(*lp == ',' && bWithinQuotes)
                *lp = ';';
            lp = CharNext(lp);
        }
    }

    //To check whether it is a dl or a simple address??

    if ((szAdrDummy=strstr(szAdrStart,","))==NULL)  {
        flag=FALSE;
    } else {
        if ('\0'==szAdrDummy[1]) {
            flag=FALSE;
        }
    }


    szAdrCur=strtok(szAdrStart,", ");
    if (NULL == szAdrCur) {
        EudAdrBook[uToken].NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAliasptr[uToken])+1);
        if (! EudAdrBook[uToken].NickName) {
            hResult = hrMemory;
            goto Error;
        }
        StrCpyN(EudAdrBook[uToken].NickName,szAliasptr[uToken],lstrlen(szAliasptr[uToken])+1);
        EudAdrBook[uToken].lpDist=NULL;
        EudAdrBook[uToken].Address = NULL;
        return(S_OK);
    }
    while (szAdrCur!=NULL) {
        if (SearchAdrName(szAdrCur)) {
            if (flag) {
                present = (LPEUDDISTLIST)LocalAlloc(LMEM_FIXED, sizeof(EUDDISTLIST));
                if (! present) {
                    return(hrMemory);
                }
                memset(present,0,sizeof(EUDDISTLIST));
                if (previous == NULL) {
                    EudAdrBook[uToken].NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAliasptr[uToken])+1);
                    if (! EudAdrBook[uToken].NickName) {
                        hResult = hrMemory;
                        goto Error;
                    }
                    StrCpyN(EudAdrBook[uToken].NickName,szAliasptr[uToken], lstrlen(szAliasptr[uToken])+1);
                    EudAdrBook[uToken].Address = NULL;
                }
                present->AliasID=uCount;
                present->flag=TRUE;
                present->Address = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAdrCur)+1);
                if (! present->Address) {
                    hResult = hrMemory;
                    goto Error;
                }
                StrCpyN(present->Address,szAdrCur, lstrlen(szAdrCur)+1);

                present->NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAdrCur)+1);
                if (! present->NickName) {
                    hResult = hrMemory;
                    goto Error;
                }
                StrCpyN(present->NickName,szAdrCur, lstrlen(szAdrCur)+1);
                if (previous!=NULL) {
                    previous->lpDist=present;
                } else {
                    EudAdrBook[uToken].lpDist = present;
                }
                previous=present;
            } else {
                EudAdrBook[uToken].Address = (TCHAR *)LocalAlloc(LMEM_FIXED,
                  lstrlen(szAdrCur)+1);
                if (! EudAdrBook[uToken].Address) {
                    hResult = hrMemory;
                    goto Error;
                }
                StrCpyN(EudAdrBook[uToken].Address,szAdrCur, lstrlen(szAdrCur)+1);
                EudAdrBook[uToken].NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAliasptr[uToken])+1);
                if (! EudAdrBook[uToken].NickName) {
                    hResult = hrMemory;
                    goto Error;
                }
                StrCpyN(EudAdrBook[uToken].NickName,szAliasptr[uToken], strlen(szAliasptr[uToken])+1);
                EudAdrBook[uToken].lpDist=NULL;
            }

        } else {
            if ((uCount=SearchName(szAliasptr,szAdrCur))>=0) {
                if (flag) {
                    present = (LPEUDDISTLIST)LocalAlloc(LMEM_FIXED, sizeof(EUDDISTLIST));
                    if (! present) {
                        return(hrMemory);
                    }
                    memset(present,0,sizeof(EUDDISTLIST));

                    if (previous == NULL) {
                        EudAdrBook[uToken].NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAliasptr[uToken])+1);
                        if (!EudAdrBook[uToken].NickName) {
                            hResult = hrMemory;
                            goto Error;
                        }
                        StrCpyN(EudAdrBook[uToken].NickName, szAliasptr[uToken], lstrlen(szAliasptr[uToken])+1);
                        EudAdrBook[uToken].Address = NULL;
                    }
                    present->AliasID=uCount;
                    present->flag=FALSE;
                    if (previous!=NULL) {
                        previous->lpDist=present;
                    } else {
                        EudAdrBook[uToken].lpDist = present;
                    }
                    previous=present;
                } else {
                    EudAdrBook[uToken].lpDist = (LPEUDDISTLIST)LocalAlloc(LMEM_FIXED,
                      sizeof(EUDDISTLIST));
                    if (! EudAdrBook[uToken].lpDist) {
                        return(hrMemory);
                    }
                    //memset(present,0,sizeof(EUDDISTLIST));
                    EudAdrBook[uToken].NickName = (TCHAR *)LocalAlloc(LMEM_FIXED,
                      lstrlen(szAliasptr[uToken])+1);
                    if (! EudAdrBook[uToken].NickName) {
                        hResult = hrMemory;
                        goto Error;
                    }
                    StrCpyN(EudAdrBook[uToken].NickName, szAliasptr[uToken], lstrlen(szAliasptr[uToken])+1);
                    EudAdrBook[uToken].Address = NULL;
                    EudAdrBook[uToken].lpDist->AliasID=uCount;
                    EudAdrBook[uToken].lpDist->flag=FALSE;
                    EudAdrBook[uToken].lpDist->lpDist=NULL;
                }
            } else {
                //not a valid email address or a valid nickname
                if (FALSE==flag) {
                    if (! EudAdrBook[uToken].Address && SearchAdrName(szAdrCur)) {
                        EudAdrBook[uToken].Address = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAdrCur)+1);
                        if (! EudAdrBook[uToken].Address) {
                            hResult = hrMemory;
                            goto Error;
                        }
                        StrCpyN(EudAdrBook[uToken].Address, szAdrCur, lstrlen(szAdrCur)+1);
                    }
                    if (! EudAdrBook[uToken].NickName) {
                        EudAdrBook[uToken].NickName = (TCHAR *)LocalAlloc(LMEM_FIXED, lstrlen(szAliasptr[uToken])+1);
                        if (! EudAdrBook[uToken].NickName) {
                            hResult = hrMemory;
                            goto Error;
                        }
                        StrCpyN(EudAdrBook[uToken].NickName, szAliasptr[uToken], lstrlen(szAliasptr[uToken])+1);
                    }
                    EudAdrBook[uToken].lpDist=NULL;
                }
            }



        }
        szAdrCur=strtok(NULL,", ");
    }

    if (present!=NULL) {
        present->lpDist=NULL;
    }
    return(hResult);

Error:
    while (EudAdrBook[uToken].lpDist != NULL) {
        EudAdrBook[uToken].lpDist = FreeEuddistlist(EudAdrBook[uToken].lpDist);
    }
    return(hResult);


}


/******************************************************************************
 *  FUNCTION NAME:SearchAdrName
 *
 *  PURPOSE:    To search if the token is an address or a name(whether it contains
 *              a @ or not).
 *
 *  PARAMETERS: szAdrCur = pointer to the token.
 *
 *  RETURNS:    BOOL, TRUE if it contains @
 ******************************************************************************/
BOOL SearchAdrName(LPTSTR szAdrCur)
{
    if (strchr(szAdrCur, '@') == NULL) {
        return(FALSE);
    }

    return(TRUE);
}


/******************************************************************************
 *  FUNCTION NAME:SearchName
 *
 *  PURPOSE:    To search for the token in the szAliasptr which conatins all
 *              the nick names.
 *
 *  PARAMETERS: szAdrCur = pointer to the token to be searched.
 *              szAliaspt = pointer to a two dimensional array containing
 *                all the nicknames.
 *
 *  RETURNS:    INT, position of the token in the szAliaspt
 ******************************************************************************/
INT SearchName(LPTSTR *szAliasptr, LPTSTR szAdrCur)
{
    INT uCount=0;

    while (szAliasptr[uCount]!=NULL) {
        if (lstrcmpi(szAliasptr[uCount],szAdrCur) == 0) {
            return(uCount);
        }
        uCount++;
    }
    return(-1);
}


/******************************************************************************
*  FUNCTION NAME:ImportEudUsers
*
*  PURPOSE:
*
*  PARAMETERS:  hwnd = Handle to the parent Window
*               lpAdrBook = pointer to the IADRBOOK interface
*               lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
*               lpOptions = pointer to WAB_IMPORT_OPTIONS structure
*               lpWabContainer = pointer to the IABCONT interface
*               lpeudAdrBook = pointer to the EUDADRBOOK structure
*               ulCount = counter value which holds the position of this address
*                 in the Eudora address book.
*               sProp = pointer to SPropValue
*
*  RETURNS:     hresult
******************************************************************************/
HRESULT ImportEudUsers(HWND hwnd, LPTSTR szFileName, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPEUDADRBOOK lpeudAdrBook, ULONG ulCount, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{

    HRESULT hResult = S_OK;
    ULONG ul;
    LPSBinary lpsbinary;
    WAB_PROGRESS Progress;


    lpsbinary = (LPSBinary)LocalAlloc(LMEM_FIXED, ((ulCount+1) * sizeof(SBinary)));
    if (! lpsbinary) {
        hResult = hrMemory;
        goto Error;
    }
    memset(lpsbinary, 0, ((ulCount + 1) * sizeof(SBinary)));

    Progress.denominator = ulCount;
    Progress.numerator = 0;
    Progress.lpText = szFileName; //NULL;

    lpOptions->ReplaceOption = WAB_REPLACE_PROMPT;

    for (ul = 0; ul < ulCount; ul++) {
        if (lpeudAdrBook[ul].NickName == NULL) {
            continue;
        }

        Progress.numerator = ul;
        lpProgressCB(hwnd,&Progress);
        if (lpeudAdrBook[ul].lpDist !=NULL) {
            hResult = FillEudDistList(hwnd, lpWabContainer, sProp, lpOptions, lpeudAdrBook,
              lpsbinary, lpAdrBook, ul);
            switch (GetScode(hResult)) {
                case MAPI_E_USER_CANCEL:
                case MAPI_E_NOT_ENOUGH_MEMORY:
                    goto Error;
            }
        } else {
            hResult = FillMailUser(hwnd, lpWabContainer, sProp, lpOptions,
              (void *)lpeudAdrBook, lpsbinary, ul,EUDORA);
            switch (GetScode(hResult)) {
                case MAPI_E_USER_CANCEL:
                case MAPI_E_NOT_ENOUGH_MEMORY:
                    goto Error;
            }
        }
    }

Error:
    if (lpsbinary) {
        for (ul = 0; ul < ulCount; ul++) {
            if (lpsbinary[ul].lpb) {
                LocalFree((HLOCAL)lpsbinary[ul].lpb);
                lpsbinary[ul].lpb = NULL;
            }
        }

        LocalFree((HLOCAL)lpsbinary);
        lpsbinary = NULL;
    }

    return(hResult);
}



/******************************************************************************
 *  FUNCTION NAME:FillEudDistList
 *
 *  PURPOSE: To create a distribution list in the WAB.
 *
 *  PARAMETERS: hWnd - hWnd of parent
 *              pAdrBook = pointer to the IADRBOOK interface
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *              lpWabContainer = pointer to the IABCONT interface
 *              lpeudAdrBook = pointer to the EUDADRBOOK structure
 *              ul = counter value which holds the position of this address
 *                in the Eudora address book.
 *              sProp = pointer to SPropValue
 *              lpsbinary = pointer to the SBinary array.
 *
 *  RETURNS: HRESULT
 ******************************************************************************/
HRESULT FillEudDistList(HWND hwnd, LPABCONT lpWabContainer,LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions,
  LPEUDADRBOOK lpeudAdrBook,LPSBinary lpsbinary,
  LPADRBOOK lpAdrBook,ULONG ul)
{
    LPSPropValue lpNewDLProps = NULL;
    LPDISTLIST lpDistList = NULL;
    ULONG cProps, ulObjType;
    ULONG iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
    ULONG iCreateTemplatedl = iconPR_DEF_CREATE_DL;
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    int i;
    HRESULT hResult;
    static LPMAPIPROP lpMailUserWAB = NULL;
    SPropValue rgProps[4];
    LPMAPIPROP lpDlWAB = NULL;
    LPSBinary lpsbEntry;
    SBinary sbTemp;

    BOOL flag = FALSE;
    REPLACE_INFO RI = {0};
    LPEUDDISTLIST lpTemp = lpeudAdrBook[ul].lpDist;

retry:
    if (lpsbinary[ul].lpb == NULL) {
        hResult = CreateDistEntry(lpWabContainer,sProp,ulCreateFlags,&lpMailUserWAB);
        if (hResult != S_OK) {
            goto error1;
        }
    }

    else {
        hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
          lpsbinary[ul].cb, (LPENTRYID)lpsbinary[ul].lpb, (LPIID)&IID_IMAPIProp,
           MAPI_DEFERRED_ERRORS|MAPI_MODIFY, &ulObjType, (LPUNKNOWN *)&lpMailUserWAB);
        if (hResult != S_OK) {
            goto error1;
        }
    }

    rgProps[0].ulPropTag = PR_DISPLAY_NAME;
    rgProps[0].Value.lpszA = lpeudAdrBook[ul].NickName;
    rgProps[1].Value.lpszA = lpeudAdrBook[ul].Description;
    if (lpeudAdrBook[ul].Description) {
        rgProps[1].ulPropTag = PR_COMMENT;
    } else {
        rgProps[1].ulPropTag = PR_NULL;
    }

    if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
      2, rgProps, NULL))) {
        goto error1;
    }

    if (0 != (hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
       FORCE_SAVE|KEEP_OPEN_READWRITE)))

        if (GetScode(hResult) == MAPI_E_COLLISION) {
            if (lpOptions->ReplaceOption == WAB_REPLACE_ALWAYS) {
                if (lpMailUserWAB) {
                    lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                }
                lpMailUserWAB = NULL;
                ulCreateFlags |= CREATE_REPLACE;
                goto retry;

            }
            if (lpOptions->ReplaceOption == WAB_REPLACE_NEVER) {
                hResult = S_OK;
                goto error1;
            }

            RI.lpszEmailAddress = NULL;
            if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
                if (lpeudAdrBook[ul].NickName) {
                    RI.lpszDisplayName = lpeudAdrBook[ul].NickName;
                    RI.lpszEmailAddress = lpeudAdrBook[ul].Address;
                } else if (lpeudAdrBook[ul].Address) {
                    RI.lpszDisplayName = lpeudAdrBook[ul].Address;
                } else if (lpeudAdrBook[ul].Description) {
                    RI.lpszDisplayName = lpeudAdrBook[ul].Description;
                } else {
                    RI.lpszDisplayName = "";
                }

                RI.ConfirmResult = CONFIRM_ERROR;
                RI.fExport = FALSE;
                RI.lpImportOptions = lpOptions;

                DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ImportReplace), hwnd,
                  ReplaceDialogProc, (LPARAM)&RI);

                switch (RI.ConfirmResult) {
                    case CONFIRM_YES:
                    case CONFIRM_YES_TO_ALL:
                        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                        lpMailUserWAB = NULL;
                        ulCreateFlags |= CREATE_REPLACE;
                        goto retry;
                        break;

                    case CONFIRM_NO:
                        hResult = GetExistEntry(lpWabContainer,lpsbinary, ul,
                          lpeudAdrBook[ul].NickName,
                          NULL);
                        goto error1;


                    case CONFIRM_ABORT:
                        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                        goto error1;

                    default:
                        break;
                }
            }
        }

    if (0!= (hResult = lpMailUserWAB->lpVtbl->GetProps(lpMailUserWAB,
      (LPSPropTagArray)&ptaEid,
      0,
      &cProps,
      (LPSPropValue *)&lpNewDLProps))) {
        if (hResult == MAPI_W_ERRORS_RETURNED) {
            WABFreeBuffer(lpNewDLProps);
            lpNewDLProps = NULL;
        }
        goto error1;
    }

    lpsbinary[ul].lpb = (LPBYTE)LocalAlloc(LMEM_FIXED,
      lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
    if (! lpsbinary[ul].lpb) {
        hResult = hrMemory;
        goto error1;
    }

    CopyMemory(lpsbinary[ul].lpb,
      (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,
      lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
    lpsbinary[ul].cb=lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb;

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
        lpMailUserWAB = NULL;
    }

    hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
      lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb,
      (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,
      (LPIID)&IID_IDistList,
      MAPI_DEFERRED_ERRORS|MAPI_MODIFY,
      &ulObjType,
      (LPUNKNOWN *)&lpDistList);

    if (hResult != S_OK) {
        goto error1;
    }

    if (lpNewDLProps) {
        WABFreeBuffer(lpNewDLProps);
        lpNewDLProps = NULL;
    }

    do {
        i = lpeudAdrBook[ul].lpDist->AliasID;
        if (lpeudAdrBook[ul].lpDist->flag == TRUE) {

            hResult = lpWabContainer->lpVtbl->CreateEntry(lpWabContainer,
              sProp[iCreateTemplate].Value.bin.cb,
              (LPENTRYID)sProp[iCreateTemplate].Value.bin.lpb,
              ulCreateFlags,
              &lpMailUserWAB);

            if (FAILED(hResult)) {
                goto error1;
            }

            FillEudDiststruct(rgProps,&lpeudAdrBook[ul]);

            if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB,
              3, rgProps, NULL))) {
                goto error1;
            }

            if (hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
              KEEP_OPEN_READONLY | FORCE_SAVE)) {

                if (GetScode(hResult) == MAPI_E_COLLISION) {
                    if (hResult = GetExistEntry(lpWabContainer,
                      &sbTemp,
                      0,
                      lpeudAdrBook[ul].lpDist->NickName,
                      NULL)) {
                        goto error1;
                    } else {
                        lpsbEntry = &sbTemp;
                    }
                } else {
                    goto error1;
                }
            } else {
                if (0 != (hResult = lpMailUserWAB->lpVtbl->GetProps(lpMailUserWAB,
                  (LPSPropTagArray)&ptaEid, 0, &cProps, (LPSPropValue *)&lpNewDLProps))) {
                    if (hResult == MAPI_W_ERRORS_RETURNED) {
                        WABFreeBuffer(lpNewDLProps);
                        lpNewDLProps = NULL;
                    }
                    goto error1;
                } else {
                    lpsbEntry = &(lpNewDLProps[ieidPR_ENTRYID].Value.bin);
                }
            }

            if (lpMailUserWAB) {
                // Done with this one
                lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                lpMailUserWAB = NULL;
            }

            if (0 != (hResult = lpDistList->lpVtbl->CreateEntry(lpDistList,
              lpsbEntry->cb,
              (LPENTRYID)lpsbEntry->lpb,
              CREATE_CHECK_DUP_STRICT,
              &lpDlWAB))) {
                goto error1;
            }

            hResult = lpDlWAB->lpVtbl->SaveChanges(lpDlWAB, FORCE_SAVE);
            goto disc;
        }

        if ((LPENTRYID)lpsbinary[i].lpb == NULL && lpeudAdrBook[i].lpDist!=NULL) {
            FillEudDistList(hwnd, lpWabContainer, sProp, lpOptions, lpeudAdrBook,
              lpsbinary, lpAdrBook, i);
        } else {
            FillMailUser(hwnd, lpWabContainer, sProp, lpOptions,
             (void *)lpeudAdrBook, lpsbinary, i, EUDORA);
        }

        if (0 != (hResult = lpDistList->lpVtbl->CreateEntry(lpDistList,
          lpsbinary[i].cb, (LPENTRYID)lpsbinary[i].lpb, CREATE_CHECK_DUP_STRICT,
          &lpDlWAB))) {
            goto error1;
        }

        if (0 != (hResult = lpDlWAB->lpVtbl->SaveChanges(lpDlWAB, FORCE_SAVE))) {
            if (MAPI_E_FOLDER_CYCLE ==hResult) {
                StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_LOOPING), ARRAYSIZE(szGlobalTempAlloc));
                MessageBox(NULL,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ENTRY_NOIMPORT),MB_OK);
            }
            hResult = S_OK;
            goto error1;
        }

disc:
        if (lpNewDLProps) {
            WABFreeBuffer(lpNewDLProps);
            lpNewDLProps = NULL;
        }

        if (lpDlWAB) {
            lpDlWAB->lpVtbl->Release(lpDlWAB);
            lpDlWAB = NULL;
        }

        lpeudAdrBook[ul].lpDist=FreeEuddistlist(lpeudAdrBook[ul].lpDist);
    } while (lpeudAdrBook[ul].lpDist != NULL);

error1:
    if (lpNewDLProps) {
        WABFreeBuffer(lpNewDLProps);
    }
    if (lpDistList) {
        lpDistList->lpVtbl->Release(lpDistList);
        lpDistList = NULL;
    }

    if (lpDlWAB) {
        lpDlWAB->lpVtbl->Release(lpDlWAB);
        lpDlWAB = NULL;
    }

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
        lpMailUserWAB = NULL;
    }

    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:FillEudWABStruct
 *
 *  PURPOSE:    To fill the SpropValue array.
 *
 *  PARAMETERS: eudAdrBook = pointer to the EUDADRBOOK structure.
 *              rgProps = pointer to the SpropValue array.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT FillEudWABStruct(LPSPropValue rgProps, EUDADRBOOK *eudAdrBook)
{
    HRESULT hr = S_OK;

    rgProps[1].Value.lpszA = eudAdrBook->NickName;

    if (eudAdrBook->NickName) {
        rgProps[1].ulPropTag = PR_DISPLAY_NAME;
    } else {
        rgProps[1].ulPropTag = PR_NULL;
    }

    rgProps[0].Value.lpszA = eudAdrBook->Address;
    if (eudAdrBook->Address) {
        rgProps[0].ulPropTag = PR_EMAIL_ADDRESS;
        rgProps[2].ulPropTag = PR_ADDRTYPE;
        rgProps[2].Value.lpszA = LoadStringToGlobalBuffer(IDS_SMTP);
    } else {
        rgProps[0].ulPropTag = PR_NULL;
        rgProps[2].ulPropTag = PR_NULL;
        rgProps[2].Value.lpszA = NULL;
    }

    rgProps[3].Value.lpszA = eudAdrBook->Description;
    if (eudAdrBook->Description) {
        rgProps[3].ulPropTag = PR_COMMENT;
    } else {
        rgProps[3].ulPropTag = PR_NULL;
    }

    rgProps[4].Value.lpszA = eudAdrBook->NickName;
    if (eudAdrBook->NickName) {
        rgProps[4].ulPropTag = PR_NICKNAME;
    } else {
        rgProps[4].ulPropTag = PR_NULL;
    }

    return(hr);
}


/******************************************************************************
 *  FUNCTION NAME:FillEudDiststruct
 *
 *  PURPOSE:    To fill the SpropValue array.
 *
 *  PARAMETERS: eudAdrBook = pointer to the EUDADRBOOK structure.
 *              rgProps = pointer to the SpropValue array.
 *
 *  RETURNS:    none
 ******************************************************************************/
void FillEudDiststruct(LPSPropValue rgProps, EUDADRBOOK *eudAdrBook)
{
    rgProps[1].Value.lpszA = eudAdrBook->lpDist->NickName;

    if (eudAdrBook->lpDist->NickName) {
        rgProps[1].ulPropTag = PR_DISPLAY_NAME;
    } else {
        rgProps[1].ulPropTag = PR_NULL;
    }

    rgProps[0].Value.lpszA = eudAdrBook->lpDist->Address;
    if (eudAdrBook->lpDist->Address) {
        rgProps[0].ulPropTag = PR_EMAIL_ADDRESS;
        rgProps[2].ulPropTag = PR_ADDRTYPE;
        rgProps[2].Value.lpszA = LoadStringToGlobalBuffer(IDS_SMTP);
    } else {
        rgProps[0].ulPropTag = PR_NULL;
        rgProps[2].ulPropTag = PR_NULL;
        rgProps[2].Value.lpszA = NULL;
    }
}


/******************************************************************************
 *  FUNCTION NAME:FreeEuddistlist
 *
 *  PURPOSE:    To free one node from EUDDISTLIST(linked list)
 *
 *  PARAMETERS: lpDist = pointer to the EUDDISTLIST structure.
 *
 *  RETURNS:    LPEUDDISTLIST , pointer to the next link.
 ******************************************************************************/
LPEUDDISTLIST FreeEuddistlist(LPEUDDISTLIST lpDist)
{
    LPEUDDISTLIST lpTemp = NULL;

    if (lpDist == NULL) {
        return(NULL);
    }

    lpTemp = lpDist->lpDist;

    if (lpDist->NickName) {
        LocalFree((HLOCAL)lpDist->NickName);
    }
    lpDist->NickName = NULL;

    if (lpDist->Description) {
        LocalFree((HLOCAL)lpDist->Description);
    }
    lpDist->Description = NULL;

    if (lpDist->Address) {
        LocalFree((HLOCAL)lpDist->Address);
    }
    lpDist->Address = NULL;

    LocalFree((HLOCAL)lpDist);
    lpDist = NULL;
    return(lpTemp);
}


/******************************************************************************
 *  FUNCTION NAME:Getstr
 *
 *  PURPOSE:    Case insensitive equivalent of strstr
 *
 *  PARAMETERS: szSource = string to search
 *              szToken = string to search for
 *
 *  RETURNS:    pointer to the first occurrence of szToken in szSource
 ******************************************************************************/
TCHAR* Getstr(TCHAR* szSource, TCHAR* szToken)
{

    int i,
    nLength;
    LPTSTR szdummy = NULL;

    szdummy = (LPTSTR)LocalAlloc(LMEM_FIXED, (strlen(szToken)+1));
    if (!szdummy)
        return(NULL);
    StrCpyN(szdummy, szToken, strlen(szToken)+1);
    _strupr(szdummy) ;
    nLength = lstrlen (szdummy) ;

    while (*szSource && *(szSource + nLength-1)) {
        for (i = 0 ;i < nLength ; i++) {
            TCHAR k = ToUpper(szSource[i]) ;
            if (szdummy[i] != k)
                break ;
            if (i == (nLength - 1)) {
                LocalFree(szdummy);
                return(szSource);
            }
        }
        szSource ++ ;
    }

    LocalFree(szdummy);
    return(NULL);
}

/******************************************************************************
*  FUNCTION NAME:ShiftAdd
*
*  PURPOSE:     To get the address size from a binary file by reading four bytes.
*               This function reads four consecutive bytes from a buffer and
*               converts it to a ULONG value.
*
*  PARAMETERS:  offset = position in the buffer from where to read
*               szBuffer = buffer
*
*  RETURNS:     ULONG, size
******************************************************************************/
ULONG ShiftAdd(int offset, TCHAR *szBuffer)
{
    ULONG ulSize = 0;
    int iCounter = 0;

    for (iCounter = 3; iCounter > 0; iCounter--) {
        ulSize |= (unsigned long)((unsigned char)szBuffer[iCounter + offset]);
        ulSize <<= 8;
    }
    ulSize |= (unsigned long)((unsigned char)szBuffer[iCounter + offset]);

    return(ulSize);
}


/******************************************************************************
 *********************Athena Functions*****************************************
 ******************************************************************************
 *  FUNCTION NAME:MigrateAthUser
 *
 *  PURPOSE:    To get the installation path of the address book and starts
 *              processing the Athena address book
 *
 *  PARAMETERS: hwnd = Handle to the parent Window
 *              lpAdrBook = pointer to the IADRBOOK interface
 *              lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT MigrateAthUser(HWND hwnd, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook)
{
    TCHAR szFileName[MAX_FILE_NAME];
    HRESULT hResult;

    if (FALSE == GetFileToImport(hwnd, szFileName, ARRAYSIZE(szFileName), ATHENA16)) {
        return(ResultFromScode(MAPI_E_USER_CANCEL));
    }

    hResult = ParseAthAddressBook(hwnd, szFileName, lpOptions, lpProgressCB,
      lpAdrBook);

    return(hResult);
}


/*****************************************************************************
*  FUNCTION NAME:ParseAthAddressBook
*
*  PURPOSE:     To get the address book in a file, process addresses and fill WAB.
*
*  PARAMETERS:  hwnd = Handle to the parent Window
*               szFileName = path of the address book.
*               lpProgressCB = pointer to the WAB_PROGRESS_CALLBACK function.
*               lpOptions = pointer to WAB_IMPORT_OPTIONS structure
*               lpAdrBook = pointer to the IADRBOOK interface
*
*  RETURNS:     HRESULT
******************************************************************************/
HRESULT  ParseAthAddressBook(HWND hwnd,LPTSTR szFileName,
  LPWAB_IMPORT_OPTIONS lpOptions, LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPADRBOOK lpAdrBook)
{
    ULONG ulCount=0, ulRead=0, ulFileSize, i, cProps, cError=0;
    HANDLE hFile = NULL;
    ABCREC abcrec;
    TCHAR Buffer[ATHENASTRUCTURE];
    LPABCONT lpWabContainer = NULL;
    HRESULT hResult;
    static LPSPropValue sProp;
    WAB_PROGRESS Progress;

    lpOptions->ReplaceOption = WAB_REPLACE_PROMPT;

    /* Description of athena16 addressbook
       Size of each recipient list - 190 bytes
         Display Name : 81 bytes
         Address      : 81 bytes
         starting from 28 bytes.
    */

    hFile = CreateFile(szFileName, GENERIC_READ, FILE_SHARE_READ, NULL,
      OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL);

    if (INVALID_HANDLE_VALUE == hFile) {
        return(ResultFromScode(MAPI_E_NOT_FOUND));
    }

    ulFileSize = GetFileSize(hFile, NULL);

    if ((ulFileSize % ATHENASTRUCTURE) != 0) {
        StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR_ADDRESSBOOK), ARRAYSIZE(szGlobalTempAlloc));
        MessageBox(hwnd, szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR), MB_OK);
        goto Error;
    }


    if (! ulFileSize) {
        StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_NO_ENTRY), ARRAYSIZE(szGlobalTempAlloc));
        MessageBox(hwnd, szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_MESSAGE), MB_OK);
        return(ResultFromScode(MAPI_E_CALL_FAILED));
    }


    ulCount = ulFileSize / ATHENASTRUCTURE;
    Progress.denominator = ulCount;
    Progress.numerator = 0;
    Progress.lpText = NULL;


    if (0 != (hResult = OpenWabContainer(&lpWabContainer, lpAdrBook))) {
        StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_WAB_ERROR), ARRAYSIZE(szGlobalTempAlloc));
        MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR),MB_OK);
        return(hResult);
    }

    if (0 != (hResult = lpWabContainer->lpVtbl->GetProps(lpWabContainer,
      (LPSPropTagArray)&ptaCon, 0, &cProps, (LPSPropValue *)&sProp))) {
        if (hResult == MAPI_W_ERRORS_RETURNED) {
            WABFreeBuffer(sProp);
            sProp = NULL;
        }
        StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_WAB_ERROR), ARRAYSIZE(szGlobalTempAlloc));
        MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR),MB_OK);
        return(hResult);
    }

    for (i = 0; i < ulFileSize / ATHENASTRUCTURE; i++) {
        Progress.numerator = i;
        lpProgressCB(hwnd, &Progress);
        if (! ReadFile(hFile, Buffer, ATHENASTRUCTURE, &ulRead, NULL)) {
            goto Error;
        }
        if (NULL == StrCpyN(abcrec.DisplayName, Buffer + ATHENAADROFFSET,
          MAX_NAME_SIZE + 1)) {
            goto Error;
        }
        if (NULL == StrCpyN(abcrec.EmailAddress,
          Buffer + ATHENAADROFFSET + MAX_NAME_SIZE + 1, MAX_EMA_SIZE + 1)) {
            goto Error;
        }
        if (strlen(abcrec.DisplayName) == 0 || lstrlen(abcrec.EmailAddress) == 0) {
            continue;
        }
        if (0 != FillAthenaUser(hwnd, lpWabContainer,sProp,lpOptions,&abcrec)) {
            cError++;
        }

    }


Error:
    if (sProp) {
        WABFreeBuffer(sProp);
        sProp = NULL;
    }
    if (lpWabContainer) {
        lpWabContainer->lpVtbl->Release(lpWabContainer);
        lpWabContainer = NULL;
    }
    if (hFile) {
        CloseHandle(hFile);
    }

    if (cError) {
        StrCpyN(szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_GERNERIC_ERROR), ARRAYSIZE(szGlobalTempAlloc));
        MessageBox(hwnd,szGlobalTempAlloc, LoadStringToGlobalBuffer(IDS_ERROR),MB_OK);
    }
    return(hResult);
}


/*****************************************************************************
*  FUNCTION NAME:FillAthenaUser
*
*  PURPOSE:     To create an entry for the athena16 mail user in the wab.
*
*  PARAMETERS:  hwnd - hwnd of parent
*               lpWabContainer = pointer to the IABCONT interface
*               sProp = pointer to SPropValue
*               lpOptions = pointer to WAB_IMPORT_OPTIONS structure
*               lpabcrec = pointer to the ABCREC structure.
*
*  RETURNS:     HRESULT
******************************************************************************/
HRESULT FillAthenaUser(HWND hwnd, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions, LPABCREC lpabcrec)
{
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    ULONG iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
    LPMAPIPROP lpMailUserWAB = NULL;
    HRESULT hResult;
    REPLACE_INFO RI = {0};
    SPropValue rgProps[3];

retry:
    hResult = lpWabContainer->lpVtbl->CreateEntry(lpWabContainer,
      sProp[   iCreateTemplate].Value.bin.cb,
      (LPENTRYID)sProp[iCreateTemplate].Value.bin.lpb,
      ulCreateFlags,
      &lpMailUserWAB);
    if (FAILED(hResult)) {
        goto Error;
    }

    rgProps[1].ulPropTag = PR_DISPLAY_NAME;
    rgProps[1].Value.lpszA = lpabcrec->DisplayName;

    rgProps[0].Value.lpszA = lpabcrec->EmailAddress;
    if (lpabcrec->EmailAddress) {
        rgProps[0].ulPropTag = PR_EMAIL_ADDRESS;
        rgProps[2].ulPropTag = PR_ADDRTYPE;
        rgProps[2].Value.lpszA = LoadStringToGlobalBuffer(IDS_SMTP);
    } else {
        rgProps[0].ulPropTag = PR_NULL;
        rgProps[2].ulPropTag = PR_NULL;
        rgProps[2].Value.lpszA = NULL;
    }

    if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB, 3,
        rgProps, NULL))) {
        goto Error;
    }

    hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
      KEEP_OPEN_READONLY | FORCE_SAVE);


    if (GetScode(hResult) == MAPI_E_COLLISION) {
        if (lpOptions->ReplaceOption == WAB_REPLACE_ALWAYS) {
            if (lpMailUserWAB) {
                lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
            }
            lpMailUserWAB = NULL;
            ulCreateFlags |= CREATE_REPLACE;
            goto retry;
        }

        if (lpOptions->ReplaceOption == WAB_REPLACE_NEVER) {
            hResult = S_OK;
            goto Error;
        }

        if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
            RI.lpszDisplayName = lpabcrec->DisplayName;
            RI.lpszEmailAddress = lpabcrec->EmailAddress;
            RI.ConfirmResult = CONFIRM_ERROR;
            RI.fExport = FALSE;
            RI.lpImportOptions = lpOptions;

            DialogBoxParam(hInst,MAKEINTRESOURCE(IDD_ImportReplace), hwnd,
              ReplaceDialogProc, (LPARAM)&RI);

            switch (RI.ConfirmResult) {
                case CONFIRM_YES:
                case CONFIRM_YES_TO_ALL:
                    lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                    lpMailUserWAB = NULL;
                    ulCreateFlags |= CREATE_REPLACE;
                    goto retry;
                    break;

                case CONFIRM_NO_TO_ALL:
                case CONFIRM_NO:
                    hResult = hrSuccess;
                    break;

                case CONFIRM_ABORT:
                    hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    goto Error;

                default:
                    break;
            }
        }
    }

Error:

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
        lpMailUserWAB = NULL;
    }

    return(hResult);
}


/******************************************************************************
*********************Common Functions*****************************************
******************************************************************************
*  FUNCTION NAME:OpenWabContainer
*
*  PURPOSE:     To get the pointer to the IABCCONT interface using the
*               IADRBOOK interface.
*
*  PARAMETERS:  lpAdrBook = pointer to the IADRBOOK interface.
*               lppWabContainer = pointer to the IABCONT interface.
*
*
*  RETURNS:     HRESULT
******************************************************************************/
HRESULT OpenWabContainer(LPABCONT *lppWabContainer, LPADRBOOK lpAdrBook)
{
    LPENTRYID lpEntryID = NULL;
    ULONG     cbEntryID;
    ULONG     ulObjType;
    HRESULT hResult;

    hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook, &cbEntryID, &lpEntryID);

    if (FAILED(hResult)) {
        goto Err;
    }

    hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook, cbEntryID, lpEntryID,
      NULL, 0, &ulObjType, (LPUNKNOWN *)lppWabContainer);

Err:
    if (lpEntryID) {
        WABFreeBuffer(lpEntryID);
    }
    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:GetFileToImport
 *
 *  PURPOSE:    To get the path of the address book file using the GetOpenFileName
 *
 *  PARAMETERS: hwnd = Handle to the parent Window
 *              szFileName = path of the address book
 *              type =  containing the value indicating whether it is a EUDORA or
 *                NETSCAPE or ATHENA16
 *
 *  RETURNS:    BOOL
 ******************************************************************************/
BOOL GetFileToImport(HWND hwnd, LPTSTR szFileName, DWORD cchFileName, int type)
{
    OPENFILENAME ofn;
    BOOL ret;
    TCHAR szFile[MAX_FILE_NAME];
    TCHAR szFilter[MAX_FILE_NAME];
    ULONG ulSize = 0;

    switch (type) {
        case NETSCAPE:
            StrCpyN(szFile, LoadStringToGlobalBuffer(IDS_NETSCAPE_PATH), ARRAYSIZE(szFile));
            ulSize = SizeLoadStringToGlobalBuffer(IDS_NETSCAPE_FILE);
            CopyMemory(szFilter, szGlobalAlloc, ulSize);
            szFilter[ulSize]=szFilter[ulSize+1]='\0';

            ofn.lpstrTitle = LoadStringToGlobalBuffer(IDS_NETSCAPE_TITLE);
            break;

        case ATHENA16:
            StrCpyN(szFile, LoadStringToGlobalBuffer(IDS_ATHENA16_PATH), ARRAYSIZE(szFile));
            ulSize = SizeLoadStringToGlobalBuffer(IDS_ATHENA16_FILE);
            CopyMemory(szFilter, szGlobalAlloc, ulSize);
            szFilter[ulSize]=szFilter[ulSize+1]='\0';

            ofn.lpstrTitle = LoadStringToGlobalBuffer(IDS_ATHENA16_TITLE);
            break;

        case EUDORA:
            StrCpyN(szFile, LoadStringToGlobalBuffer(IDS_EUDORA_PATH), ARRAYSIZE(szFile));
            ulSize = SizeLoadStringToGlobalBuffer(IDS_EUDORA_FILE);
            CopyMemory(szFilter, szGlobalAlloc, ulSize);
            szFilter[ulSize]=szFilter[ulSize+1]='\0';

            ofn.lpstrTitle = LoadStringToGlobalBuffer(IDS_EUDORA_TITLE);
            break;
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = sizeof(szFile);
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_EXPLORER | OFN_ENABLEHOOK | OFN_HIDEREADONLY;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = NULL;
    ofn.lCustData = 0;
    ofn.lpfnHook = ComDlg32DlgProc;
    ofn.lpTemplateName = NULL;

    ret = GetOpenFileName(&ofn);

    if (ret) {
        StrCpyN(szFileName, szFile, cchFileName);
    }

    return(ret);
}


INT_PTR CALLBACK ReplaceDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    LPREPLACE_INFO lpRI = (LPREPLACE_INFO)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (message) {
        case WM_INITDIALOG:
            {
                TCHAR szFormat[MAX_RESOURCE_STRING + 1];
                LPTSTR lpszMessage = NULL;
                ULONG ids;

                SetWindowLongPtr(hwnd, DWLP_USER, lParam);  //Save this for future reference
                lpRI = (LPREPLACE_INFO)lParam;

                if (lpRI->fExport) {
                    ids = lpRI->lpszEmailAddress ?
                      IDS_REPLACE_MESSAGE_EXPORT_2 : IDS_REPLACE_MESSAGE_EXPORT_1;
                } else {
                    ids = lpRI->lpszEmailAddress ?
                      IDS_REPLACE_MESSAGE_IMPORT_2 : IDS_REPLACE_MESSAGE_IMPORT_1;
                }

                if (LoadString(hInst,
                  ids,
                  szFormat, sizeof(szFormat))) {
                    LPTSTR lpszArg[2] = {lpRI->lpszDisplayName, lpRI->lpszEmailAddress};

                    if (! FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      szFormat,
                      0, 0, //ignored
                      (LPTSTR)&lpszMessage,
                      0,
                      (va_list *)lpszArg)) {
                        DebugTrace("FormatMessage -> %u\n", GetLastError());
                    } else {
                        DebugTrace("Status Message: %s\n", lpszMessage);
                        if (! SetDlgItemText(hwnd, IDC_Replace_Message, lpszMessage)) {
                            DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                        }
                        LocalFree(lpszMessage);
                    }
                }
                return(TRUE);
            }

        case WM_COMMAND :
            switch (wParam) {
                case IDCANCEL:
                    lpRI->ConfirmResult = CONFIRM_ABORT;
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDCLOSE:
                case IDNO:
                    lpRI->ConfirmResult = CONFIRM_NO;
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDOK:
                case IDYES:
                    // Set the state of the parameter
                    lpRI->ConfirmResult = CONFIRM_YES;
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);


                case IDC_NoToAll:
                    lpRI->ConfirmResult = CONFIRM_NO_TO_ALL;
                    if (lpRI->fExport) {
                        lpRI->lpExportOptions->ReplaceOption = WAB_REPLACE_NEVER;
                    } else {
                        lpRI->lpImportOptions->ReplaceOption = WAB_REPLACE_NEVER;
                    }
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);

                case IDC_YesToAll:
                    lpRI->ConfirmResult = CONFIRM_YES_TO_ALL;
                    if (lpRI->fExport) {
                        lpRI->lpImportOptions->ReplaceOption = WAB_REPLACE_ALWAYS;
                    } else {
                        lpRI->lpExportOptions->ReplaceOption = WAB_REPLACE_ALWAYS;
                    }
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);

                case IDM_EXIT:
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);
                }
            break ;

        case IDCANCEL:
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            return(0);

        default:
            return(FALSE);
    }

    return(TRUE);
}


INT_PTR CALLBACK ErrorDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
    LPERROR_INFO lpEI = (LPERROR_INFO)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (message) {
        case WM_INITDIALOG:
            {
                TCHAR szBuffer[MAX_RESOURCE_STRING + 1];
                LPTSTR lpszMessage;

                SetWindowLongPtr(hwnd, DWLP_USER, lParam);  // Save this for future reference
                lpEI = (LPERROR_INFO)lParam;

                if (LoadString(hInst,
                  lpEI->ids,
                  szBuffer, sizeof(szBuffer))) {
                    LPTSTR lpszArg[2] = {lpEI->lpszDisplayName, lpEI->lpszEmailAddress};

                    if (! FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      szBuffer,
                      0, 0, //ignored
                      (LPTSTR)&lpszMessage,
                      0,
                      (va_list *)lpszArg)) {
                        DebugTrace("FormatMessage -> %u\n", GetLastError());
                    } else {
                        DebugTrace("Status Message: %s\n", lpszMessage);
                        if (! SetDlgItemText(hwnd, IDC_ErrorMessage, lpszMessage)) {
                            DebugTrace("SetDlgItemText -> %u\n", GetLastError());
                        }
                        LocalFree(lpszMessage);
                    }
                }
                return(TRUE);
            }

        case WM_COMMAND :
            switch (wParam) {
                case IDCANCEL:
                    lpEI->ErrorResult = ERROR_ABORT;
                    // fall through to close.

                case IDCLOSE:
                    // Ignore the contents of the radio button
                    SendMessage(hwnd, WM_CLOSE, 0, 0L);
                    return(0);

                case IDOK:
                    // Get the contents of the radio button
                    lpEI->lpImportOptions->fNoErrors = (IsDlgButtonChecked(hwnd, IDC_NoMoreError) == 1);
                    lpEI->lpExportOptions->fNoErrors = (IsDlgButtonChecked(hwnd, IDC_NoMoreError) == 1);
                    SendMessage(hwnd, WM_CLOSE, 0, 0);
                    return(0);

                case IDM_EXIT:
                    SendMessage(hwnd, WM_DESTROY, 0, 0L);
                    return(0);
                }
            break ;

        case IDCANCEL:
            // treat it like a close
            SendMessage(hwnd, WM_CLOSE, 0, 0);
            break;

        case WM_CLOSE:
            EndDialog(hwnd, FALSE);
            return(0);

        default:
            return(FALSE);
    }

    return(TRUE);
}


/******************************************************************************
 *  FUNCTION NAME:GetRegistryPath
 *
 *  PURPOSE:    To Get path for eudora and netscape installation
 *
 *  PARAMETERS: szFileName = buffer containing the installation path
 *              type =  containing the value indicating whether it is a EUDORA or
 *                NETSCAPE.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT GetRegistryPath(LPTSTR szFileName, ULONG cchSize, int type)
{
    HKEY phkResult = NULL;
    LONG Registry;
    BOOL bResult;
    LPOSVERSIONINFO lpVersionInformation ;
    TCHAR *lpData = NULL, *RegPath = NULL, *path = NULL;
    unsigned long  size = MAX_FILE_NAME;
    HKEY hKey = (type == NETSCAPE ? HKEY_LOCAL_MACHINE : HKEY_CURRENT_USER);
    HRESULT hResult = S_OK;


    lpData = (TCHAR *)LocalAlloc(LMEM_FIXED, 3*MAX_FILE_NAME);
    if (!lpData) {
        hResult = hrMemory;
        goto error;
    }

    RegPath = (TCHAR *)LocalAlloc(LMEM_FIXED, MAX_FILE_NAME);
    if (! RegPath) {
        hResult = hrMemory;
        goto error;
    }

    path = (TCHAR *)LocalAlloc(LMEM_FIXED, MAX_STRING_SIZE);
    if (! path) {
        hResult = hrMemory;
        goto error;
    }

    switch (type) {
        case(NETSCAPE):
            StrCpyN(RegPath, LoadStringToGlobalBuffer(IDS_NETSCAPE_REGKEY), MAX_FILE_NAME);
            StrCpyN(path, LoadStringToGlobalBuffer(IDS_NETSCAPE_ADDRESS_PATH), MAX_STRING_SIZE);
            break;

        case(EUDORA):
            StrCpyN(RegPath, LoadStringToGlobalBuffer(IDS_EUDORA_32_REGKEY), MAX_FILE_NAME);
            StrCpyN(path, LoadStringToGlobalBuffer(IDS_EUDORA_ADDRESS_PATH), MAX_STRING_SIZE);
            break;
    }

    lpVersionInformation = (LPOSVERSIONINFO)LocalAlloc(LMEM_FIXED, sizeof(OSVERSIONINFO));

    if (!lpVersionInformation) {
        hResult = hrMemory;
        goto error;
    }

    lpVersionInformation->dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if ((bResult = GetVersionEx(lpVersionInformation)) == FALSE) {
        hResult = E_FAIL;
        goto error;
    }

    switch (lpVersionInformation->dwPlatformId) {

        case (VER_PLATFORM_WIN32s):
            hResult = E_FAIL;
            goto error;
            break;

        case (VER_PLATFORM_WIN32_WINDOWS):
        case  (VER_PLATFORM_WIN32_NT):
            Registry = RegOpenKeyEx(hKey,RegPath, 0, KEY_QUERY_VALUE, &phkResult);
            // bug 35949 - not finding the correct key under HKLM for Netscape
            // Try again under HKCU
            if (type == NETSCAPE && Registry != ERROR_SUCCESS) {
                Registry = RegOpenKeyEx(HKEY_CURRENT_USER, RegPath, 0, KEY_QUERY_VALUE,
                  &phkResult);
            }
            if (Registry != ERROR_SUCCESS) {
                hResult = E_FAIL;
                goto error;
            }
            break;
    }


    Registry = RegQueryValueEx(phkResult, path, NULL, NULL, (LPBYTE)lpData, &size);
    if (Registry != ERROR_SUCCESS) {
        hResult = E_FAIL;
        goto error;
    }

    StrCpyN(szFileName,lpData, cchSize);

    if (type == EUDORA) {
        // this key value contains three items:
        // Path-to-Eudora,exe<space>Path-to-Eudora-Dir<space>Path-to-ini-file
        // We want the middle entry only
        LPTSTR lp = szFileName;
        while (*lp && ! IsSpace(lp)) {
            lp = CharNext(lp);
        }
        if (IsSpace(lp)) {
            // overwrite everything upto the first space
            lp = CharNext(lp);
            StrCpyN(szFileName, lp, cchSize);

            // Find the next space and terminate the filename string there
            lp = szFileName;
            while (*lp && ! IsSpace(lp)) {
                lp = CharNext(lp);
            }
            if (IsSpace(lp)) {
                *lp = '\0';
            }
        }
    }

error:
    if (phkResult) {
        RegCloseKey(phkResult);
    }
    if (hKey) {
        RegCloseKey(hKey);
    }
    if (lpVersionInformation) {
        LocalFree((HLOCAL)lpVersionInformation);
    }
    if (lpData) {
        LocalFree((HLOCAL)lpData);
    }
    if (RegPath) {
        LocalFree((HLOCAL)RegPath);
    }
    if (path) {
        LocalFree((HLOCAL)path);
    }

    return(hResult);

}


/******************************************************************************
 *  FUNCTION NAME:GetExistEntry
 *
 *  PURPOSE:    To fill the Sbinary array for an already existig entry in the WAB
 *              for which user has selected NO as replace option.
 *
 *  PARAMETERS: lpWabContainer = pointer to the IABCONT interface.
 *              lpsbinary = pointer to SBinary array.
 *              ucount = position in the SBinary array where the ENTRY_ID has
 *                to be filled.
 *              szDisplayName = display nmae of the user that has to be searched.
 *              szNickName = if no DisplayName, use NickName
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT GetExistEntry(LPABCONT lpWabContainer, LPSBinary lpsbinary, ULONG ucount,
  LPTSTR szDisplayName, LPTSTR szNickName)
{
    HRESULT hResult;
    LPMAPITABLE lpMapiTable = NULL;
    SRestriction Restriction;
    SPropValue pProp;
    LPSRowSet lpsrowset=NULL;
    SPropertyRestriction PropertyRestriction;
    BOOKMARK bkmark;

    bkmark = BOOKMARK_BEGINNING;
    pProp.ulPropTag = PR_DISPLAY_NAME;
    if (szDisplayName && lstrlen(szDisplayName)) {
        pProp.Value.lpszA = szDisplayName;
    } else if (szNickName && lstrlen(szNickName)) {
        pProp.Value.lpszA = szNickName;
    }

    PropertyRestriction.relop=RELOP_EQ;
    PropertyRestriction.ulPropTag=PR_DISPLAY_NAME;
    PropertyRestriction.lpProp=&pProp;

    Restriction.rt=RES_PROPERTY;
    Restriction.res.resProperty=PropertyRestriction;

    if (0 != (hResult = lpWabContainer->lpVtbl->GetContentsTable(lpWabContainer,
      MAPI_DEFERRED_ERRORS, &lpMapiTable))) {
        goto error;
    }

    if (0 != (hResult = lpMapiTable->lpVtbl->FindRow(lpMapiTable, &Restriction, bkmark, 0))) {
        goto error;
    }

    if (0 != (hResult = lpMapiTable->lpVtbl->SetColumns(lpMapiTable,
      (LPSPropTagArray)&ptaEid, 0))) {
        goto error;
    }

    if (0 != (hResult = lpMapiTable->lpVtbl->QueryRows(lpMapiTable, 1, 0, &lpsrowset))) {
        goto error;
    }

    if (! (lpsbinary[ucount].lpb = (LPBYTE)LocalAlloc(LMEM_FIXED,
      lpsrowset->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb))) {
        hResult = hrMemory;
        goto error;
    }
    CopyMemory(lpsbinary[ucount].lpb, lpsrowset->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb,
      lpsrowset->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb);
    lpsbinary[ucount].cb = lpsrowset->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;

error:
    if (lpsrowset) {
        FreeRowSet(lpsrowset);
    }
    if (lpMapiTable) {
        lpMapiTable->lpVtbl->Release(lpMapiTable);
        lpMapiTable = NULL;
    }

    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:FreeRowSet
 *
 *  PURPOSE:    To free the srowset structure.
 *
 *  RETURNS:    none.
 ******************************************************************************/
void FreeRowSet(LPSRowSet lpRows)
{
    ULONG cRows;

    if (! lpRows) {
        return;
    }

    for (cRows = 0; cRows < lpRows->cRows; ++cRows) {
        WABFreeBuffer(lpRows->aRow[cRows].lpProps);
    }

    WABFreeBuffer(lpRows);
}


/******************************************************************************
*  FUNCTION NAME:SizeLoadStringToGlobalBuffer
*
*  PURPOSE:     Loads a string resource into the globall alloc buffer
*               and returns the size, not the string
*
*  PARAMETERS:  StringID - String identifier to load
*
*  RETURNS:     ULONG number of characters loaded
*
*  created:     Vikramm 02/04/97
*               Bug: 17928 - trash in OpenFileDialog dropdown
*               caused because StrCpyN cant copy strings with
*               \0 in them. Need to do a copy memory
******************************************************************************/
ULONG SizeLoadStringToGlobalBuffer(int StringID)
{
    ULONG ulSize = 0;
    ulSize = LoadString(hInst, StringID, szGlobalAlloc, sizeof(szGlobalAlloc));
    return(ulSize);
}


/******************************************************************************
*  FUNCTION NAME:LoadStringToGlobalBuffer
*
*  PURPOSE:     Loads a string resource
*
*  PARAMETERS:  StringID - String identifier to load
*
*  RETURNS:     LPTSTR, string that is loaded.
******************************************************************************/
LPTSTR LoadStringToGlobalBuffer(int StringID)
{
    ULONG ulSize = 0;

    ulSize = LoadString(hInst, StringID, szGlobalAlloc, sizeof(szGlobalAlloc));
    return(szGlobalAlloc);
}


/******************************************************************************
 *  FUNCTION NAME:FillMailUser
 *
 *  PURPOSE:    To create a mail user in the WAB for NetScape/Eudora .
 *
 *  PARAMETERS: hwnd - hwnd of parent
 *              lpWabContainer = pointer to the IABCONT interface.
 *              sProp = pointer to SPropValue which contains ENTRY_ID.
 *              lpOptions = pointer to WAB_IMPORT_OPTIONS structure
 *              lpadrbook = pointer to NSADRBOOK/EUDADRBOOK typecasted to void*
 *              lpsbinary = pointer to an array of SBinary structure.
 *              type =  containing the value indicating whether it is a EUDORA or
 *                NETSCAPE.
 *              ul = offset for Eudora in EUDADRBOOK array.
 *
 *  RETURNS:    HRESULT
 ******************************************************************************/
HRESULT FillMailUser(HWND hwnd, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions, void *lpadrbook, LPSBinary lpsbinary, ULONG ul, int type)
{
    ULONG ulCreateFlags = CREATE_CHECK_DUP_STRICT;
    ULONG iCreateTemplate = iconPR_DEF_CREATE_MAILUSER;
    LPSPropValue lpNewDLProps = NULL;
    LPMAPIPROP lpMailUserWAB = NULL;
    ULONG cProps;
    HRESULT hResult;
    REPLACE_INFO RI;
    SPropValue rgProps[5];
    LPEUDADRBOOK lpEudAdrBook = NULL;
    LPNSADRBOOK lpNsAdrBook = NULL;


    if (NETSCAPE == type) {
        lpNsAdrBook = (LPNSADRBOOK)lpadrbook;
    } else {
        lpEudAdrBook = (LPEUDADRBOOK)lpadrbook;
    }

retry:
    if (EUDORA == type) {
        if (lpsbinary[ul].lpb != NULL) {
            return(S_OK);
        }
    }

    hResult = lpWabContainer->lpVtbl->CreateEntry(lpWabContainer,
      sProp[iCreateTemplate].Value.bin.cb,
      (LPENTRYID)sProp[iCreateTemplate].Value.bin.lpb,
      ulCreateFlags,
      &lpMailUserWAB);

    if (FAILED(hResult)) {
        goto Error;
    }

    if (NETSCAPE == type) {
        FillWABStruct(rgProps,lpNsAdrBook);
        if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB, 5,
          rgProps, NULL)))
            goto Error;
    } else {
        FillEudWABStruct(rgProps,&lpEudAdrBook[ul]);
        if (0 != (hResult = lpMailUserWAB->lpVtbl->SetProps(lpMailUserWAB, 4,
          rgProps, NULL)))
            goto Error;
    }

    hResult = lpMailUserWAB->lpVtbl->SaveChanges(lpMailUserWAB,
      KEEP_OPEN_READONLY | FORCE_SAVE);


    if (GetScode(hResult) == MAPI_E_COLLISION) {
        if (lpOptions->ReplaceOption == WAB_REPLACE_ALWAYS) {
            if (lpMailUserWAB) {
                lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
            }
            lpMailUserWAB = NULL;
            ulCreateFlags |= CREATE_REPLACE;
            goto retry;
        }

        if (lpOptions->ReplaceOption == WAB_REPLACE_NEVER) {
            hResult = S_OK;
            goto Error;
        }

        if (lpOptions->ReplaceOption == WAB_REPLACE_PROMPT) {
            RI.lpszEmailAddress = NULL;
            if (NETSCAPE == type) {
                if (lpNsAdrBook->Entry) {
                    RI.lpszDisplayName = lpNsAdrBook->Entry;
                    RI.lpszEmailAddress = lpNsAdrBook->Address;
                } else if (lpNsAdrBook->NickName) {
                    RI.lpszDisplayName = lpNsAdrBook->NickName;
                    RI.lpszEmailAddress = lpNsAdrBook->Address;
                } else if (lpNsAdrBook->Address) {
                    RI.lpszDisplayName = lpNsAdrBook->Address;
                } else if (lpNsAdrBook->Description) {
                    RI.lpszDisplayName = lpNsAdrBook->Description;
                } else {
                    RI.lpszDisplayName = "";
                }
            } else {
                RI.lpszDisplayName = lpEudAdrBook[ul].NickName;
                RI.lpszEmailAddress = lpEudAdrBook[ul].Address;
            }
            RI.ConfirmResult = CONFIRM_ERROR;
            RI.lpImportOptions = lpOptions;

            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_ImportReplace), hwnd,
              ReplaceDialogProc, (LPARAM)&RI);

            switch (RI.ConfirmResult) {
                case CONFIRM_YES:
                case CONFIRM_YES_TO_ALL:
                    lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
                    lpMailUserWAB = NULL;
                    ulCreateFlags |= CREATE_REPLACE;
                    goto retry;
                    break;

                case CONFIRM_ABORT:
                    hResult = ResultFromScode(MAPI_E_USER_CANCEL);
                    goto Error;

                case CONFIRM_NO:
                    if (NETSCAPE == type) {
                        if (lpNsAdrBook->Sbinary == TRUE)
                            GetExistEntry(lpWabContainer,
                              lpsbinary,
                              lpNsAdrBook->AliasID,
                              lpNsAdrBook->Entry,
                              lpNsAdrBook->NickName);
                    } else
                        hResult = GetExistEntry(lpWabContainer,lpsbinary,ul,
                          lpEudAdrBook[ul].NickName,
                          NULL);
                    goto Error;

                default:
                    break;
            }
        }
    }

    if (0 != (hResult = lpMailUserWAB->lpVtbl->GetProps(lpMailUserWAB,
      (LPSPropTagArray)&ptaEid,
      0,
      &cProps,
      (LPSPropValue *)&lpNewDLProps))) {
        if (hResult == MAPI_W_ERRORS_RETURNED) {
            WABFreeBuffer(lpNewDLProps);
            lpNewDLProps = NULL;
        }
        goto Error;
    }

    if (NETSCAPE == type) {
        if (lpNsAdrBook->Sbinary == TRUE) {
            lpsbinary[lpNsAdrBook->AliasID].lpb=(LPBYTE)LocalAlloc(LMEM_FIXED,lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
            if (!lpsbinary[lpNsAdrBook->AliasID].lpb) {
                hResult = hrMemory;
                goto Error;
            }
            CopyMemory(lpsbinary[lpNsAdrBook->AliasID].lpb,
                       (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
            lpsbinary[lpNsAdrBook->AliasID].cb=lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb;
        }
    } else {
        lpsbinary[ul].lpb=(LPBYTE)LocalAlloc(LMEM_FIXED,lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
        if (!lpsbinary[ul].lpb) {
            hResult = hrMemory;
            goto Error;
        }
        CopyMemory(lpsbinary[ul].lpb,(LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb);
        lpsbinary[ul].cb=lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb;
    }


Error:

    if (lpNewDLProps) {
        WABFreeBuffer(lpNewDLProps);
        lpNewDLProps = NULL;
    }

    if (lpMailUserWAB) {
        lpMailUserWAB->lpVtbl->Release(lpMailUserWAB);
        lpMailUserWAB = NULL;
    }

    return(hResult);
}


/******************************************************************************
 *  FUNCTION NAME:ComDlg32DlgProc
 *
 *  PURPOSE:    Change the title of open button to Import.
 *
 *  PARAMETERS:
 *
 *  RETURNS:    BOOL
 ******************************************************************************/
INT_PTR CALLBACK ComDlg32DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
        case WM_INITDIALOG:
            {
                TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

                if (LoadString(hInst, IDS_IMPORT_BUTTON, szBuffer, sizeof(szBuffer))) {
                    SetDlgItemText(GetParent(hDlg), 1, szBuffer);
                }
                break;
            }

        default:
            return(FALSE);
    }
    return(TRUE);
}


const static char c_szReg[] = "Reg";
const static char c_szUnReg[] = "UnReg";
const static char c_szAdvPackDll[] = "ADVPACK.DLL";

static char c_szWABIMP[] = "WABIMP";

HRESULT CallRegInstall(LPCSTR szSection)
{
    HRESULT     hr;
    HINSTANCE   hAdvPack;
    REGINSTALL  pfnri;
    char        szWabimpDll[MAX_PATH];
    STRENTRY    seReg;
    STRTABLE    stReg;

    hr = E_FAIL;

    hAdvPack = LoadLibraryA(c_szAdvPackDll);
    if (hAdvPack != NULL) {
        // Get Proc Address for registration util
        pfnri = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
        if (pfnri != NULL) {

            GetModuleFileName(hInstApp, szWabimpDll, sizeof(szWabimpDll));
            seReg.pszName = c_szWABIMP;
            seReg.pszValue = szWabimpDll;
            stReg.cEntries = 1;
            stReg.pse = &seReg;

            // Call the self-reg routine
            hr = pfnri(hInstApp, szSection, &stReg);
        }

        FreeLibrary(hAdvPack);
    }

    return(hr);
}


STDAPI DllRegisterServer(void)
{
    return(CallRegInstall(c_szReg));
}


STDAPI DllUnregisterServer(void)
{
    return(CallRegInstall(c_szUnReg));
}


/***************************************************************************

    Name      : ShowMessageBoxParam

    Purpose   : Generic MessageBox displayer

    Parameters: hWndParent - Handle of message box parent
                MsgID      - resource id of message string
                ulFlags    - MessageBox flags
                ...        - format parameters

    Returns   : MessageBox return code

***************************************************************************/
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...)
{
    TCHAR szBuf[MAX_RESOURCE_STRING + 1] = "";
    TCHAR szCaption[MAX_PATH] = "";
    LPTSTR lpszBuffer = NULL;
    int iRet = 0;
    va_list     vl;

    va_start(vl, ulFlags);

    LoadString(hInst, MsgId, szBuf, sizeof(szBuf));
    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
      szBuf,
      0,0,              // ignored
      (LPTSTR)&lpszBuffer,
      sizeof(szBuf),      // MAX_UI_STR
      (va_list *)&vl)) {
        TCHAR szCaption[MAX_PATH];

        GetWindowText(hWndParent, szCaption, sizeof(szCaption));
        if (! lstrlen(szCaption)) { // if no caption get the parents caption - this is necessary for property sheets
            GetWindowText(GetParent(hWndParent), szCaption, sizeof(szCaption));
            if (! lstrlen(szCaption)) //if still not caption, use empty title
                szCaption[0] = (TCHAR)'\0';
        }
        iRet = MessageBox(hWndParent, lpszBuffer, szCaption, ulFlags);
        LocalFree(lpszBuffer);
    }
    va_end(vl);
    return(iRet);
}


//$$//////////////////////////////////////////////////////////////////////
//
//  LoadAllocString - Loads a string resource and allocates enough
//                    memory to hold it.
//
//  StringID - String identifier to load
//
//  returns the LocalAlloc'd, null terminated string.  Caller is responsible
//  for LocalFree'ing this buffer.  If the string can't be loaded or memory
//  can't be allocated, returns NULL.
//
//////////////////////////////////////////////////////////////////////////
LPTSTR LoadAllocString(int StringID) {
    ULONG ulSize = 0;
    LPTSTR lpBuffer = NULL;
    TCHAR szBuffer[MAX_RESOURCE_STRING + 1];

    ulSize = LoadString(hInst, StringID, szBuffer, sizeof(szBuffer));

    if (ulSize && (lpBuffer = LocalAlloc(LPTR, ulSize + 1))) {
        StrCpyN(lpBuffer, szBuffer, ulSize + 1);
    }

    return(lpBuffer);
}


/***************************************************************************

    Name      : FormatAllocFilter

    Purpose   : Loads file filter name string resources and
                formats them with their file extension filters

    Parameters: StringID1 - String identifier to load       (required)
                szFilter1 - file name filter, ie, "*.vcf"   (required)
                StringID2 - String identifier               (optional)
                szFilter2 - file name filter                (optional)
                StringID3 - String identifier               (optional)
                szFilter3 - file name filter                (optional)

    Returns   : LocalAlloc'd, Double null terminated string.  Caller is
                responsible for LocalFree'ing this buffer.  If the string
                can't be loaded or memory can't be allocated, returns NULL.

***************************************************************************/
LPTSTR FormatAllocFilter(int StringID1, LPCTSTR lpFilter1,
  int StringID2, LPCTSTR lpFilter2,
  int StringID3, LPCTSTR lpFilter3) {
    LPTSTR lpFileType1 = NULL, lpFileType2 = NULL, lpFileType3 = NULL;
    LPTSTR lpTemp;
    LPTSTR lpBuffer = NULL;
    // All string sizes include null
    ULONG cbFileType1 = 0, cbFileType2 = 0, cbFileType3 = 0;
    ULONG cbFilter1 = 0, cbFilter2 = 0, cbFilter3 = 0;
    ULONG cbBuffer;

    cbBuffer = cbFilter1 = lstrlen(lpFilter1) + 1;
    if (! (lpFileType1 = LoadAllocString(StringID1))) {
        DebugTrace("LoadAllocString(%u) failed\n", StringID1);
        return(NULL);
    }
    cbBuffer += (cbFileType1 = lstrlen(lpFileType1) + 1);
    if (lpFilter2 && StringID2) {
        cbBuffer += (cbFilter2 = lstrlen(lpFilter2) + 1);
        if (! (lpFileType2 = LoadAllocString(StringID2))) {
            DebugTrace("LoadAllocString(%u) failed\n", StringID2);
        } else {
            cbBuffer += (cbFileType2 = lstrlen(lpFileType2) + 1);
        }
    }
    if (lpFilter3 && StringID3) {
        cbBuffer += (cbFilter3 = lstrlen(lpFilter3) + 1);
        if (! (lpFileType3 = LoadAllocString(StringID3))) {
            DebugTrace("LoadAllocString(%u) failed\n", StringID3);
        } else {
            cbBuffer += (cbFileType3 = lstrlen(lpFileType3) + 1);
        }
    }
    cbBuffer++;

    Assert(cbBuffer == cbFilter1 + cbFilter2 + cbFilter3 + cbFileType1 + cbFileType2 + cbFileType3 + 1);

    if (lpBuffer = LocalAlloc(LPTR, cbBuffer * sizeof(TCHAR))) {
        lpTemp = lpBuffer;
        StrCpyN(lpTemp, lpFileType1, cbBuffer);
        lpTemp += cbFileType1;
        cbBuffer -= cbFileType1;
        StrCpyN(lpTemp, lpFilter1, cbBuffer);
        lpTemp += cbFilter1;
        cbBuffer -= cbFilter1;
        LocalFree(lpFileType1);
        if (cbFileType2 && cbFilter2) {
            StrCpyN(lpTemp, lpFileType2, cbBuffer);
            lpTemp += cbFileType2;
            cbBuffer -= cbFileType2;
            StrCpyN(lpTemp, lpFilter2, cbBuffer);
            lpTemp += cbFilter2;
            cbBuffer -= cbFilter2;
            LocalFree(lpFileType2);
        }
        if (cbFileType3 && cbFilter3) {
            StrCpyN(lpTemp, lpFileType3, cbBuffer);
            lpTemp += cbFileType3;
            cbBuffer -= cbFileType3;
            StrCpyN(lpTemp, lpFilter3, cbBuffer);
            lpTemp += cbFilter3;
            cbBuffer -= cbFilter3;
            LocalFree(lpFileType3);
        }

        *lpTemp = '\0';
    }


    return(lpBuffer);
}


/***************************************************************************

    Name      : SaveFileDialog

    Purpose   : Presents a Save filename dialog

    Parameters: hWnd = parent window handle
                szFileName = in/out filename buffer (must be MAX_PATH + 1)
                lpFilter1 = First filename filter string
                idsFileType1 = First filename type string id
                lpFilter2 = Second filename filter string (or NULL)
                idsFileType2 = Second filename type string id
                lpFilter3 = Third filename filter string (or NULL)
                idsFileType3 = Third filename type string id
                lpDefExt = default extension string
                ulFlags = GetSaveFileName flags
                hInst = instance handle
                idsTitle = dialog title string id
                idsSaveButton = Save button string id (0 = default)

    Returns   : HRESULT

***************************************************************************/
HRESULT SaveFileDialog(HWND hWnd,
  LPTSTR szFileName,
  LPCTSTR lpFilter1,
  ULONG idsFileType1,
  LPCTSTR lpFilter2,
  ULONG idsFileType2,
  LPCTSTR lpFilter3,
  ULONG idsFileType3,
  LPCTSTR lpDefExt,
  ULONG ulFlags,
  HINSTANCE hInst,
  ULONG idsTitle,
  ULONG idsSaveButton) {
    LPTSTR lpFilterName;
    OPENFILENAME ofn;
    HRESULT hResult = hrSuccess;


    if (! (lpFilterName = FormatAllocFilter(idsFileType1, lpFilter1,
        idsFileType2, lpFilter2, idsFileType3, lpFilter3))) {
        return(ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY));
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = hInst;
    ofn.lpstrFilter = lpFilterName;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = NULL;              // lpTitle;
    ofn.Flags = ulFlags;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = lpDefExt;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    if (! GetSaveFileName(&ofn)) {
        DebugTrace("GetSaveFileName cancelled\n");
        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
    }

    if(lpFilterName)
        LocalFree(lpFilterName);

    return(hResult);
}


/***************************************************************************

    Name      : OpenFileDialog

    Purpose   : Presents a open filename dialog

    Parameters: hWnd = parent window handle
                szFileName = in/out filename buffer (must be MAX_PATH + 1)
                lpFilter1 = First filename filter string
                idsFileType1 = First filename type string id
                lpFilter2 = Second filename filter string (or NULL)
                idsFileType2 = Second filename type string id
                lpFilter3 = Third filename filter string (or NULL)
                idsFileType3 = Third filename type string id
                lpDefExt = default extension string
                ulFlags = GetOpenFileName flags
                hInst = instance handle
                idsTitle = dialog title string id
                idsSaveButton = Save button string id (0 = default)

    Returns   : HRESULT

***************************************************************************/
HRESULT OpenFileDialog(HWND hWnd,
  LPTSTR szFileName,
  LPCTSTR lpFilter1,
  ULONG idsFileType1,
  LPCTSTR lpFilter2,
  ULONG idsFileType2,
  LPCTSTR lpFilter3,
  ULONG idsFileType3,
  LPCTSTR lpDefExt,
  ULONG ulFlags,
  HINSTANCE hInst,
  ULONG idsTitle,
  ULONG idsOpenButton) {
    LPTSTR lpFilterName;
    OPENFILENAME ofn;
    HRESULT hResult = hrSuccess;


    if (! (lpFilterName = FormatAllocFilter(idsFileType1, lpFilter1,
        idsFileType2, lpFilter2, idsFileType3, lpFilter3))) {
        return(ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY));
    }

    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hWnd;
    ofn.hInstance = hInst;
    ofn.lpstrFilter = lpFilterName;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter = 0;
    ofn.nFilterIndex = 0;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.lpstrTitle = NULL;              // lpTitle;
    ofn.Flags = ulFlags;
    ofn.nFileOffset = 0;
    ofn.nFileExtension = 0;
    ofn.lpstrDefExt = lpDefExt;
    ofn.lCustData = 0;
    ofn.lpfnHook = NULL;
    ofn.lpTemplateName = NULL;

    if (! GetOpenFileName(&ofn)) {
        DebugTrace("GetOpenFileName cancelled\n");
        hResult = ResultFromScode(MAPI_E_USER_CANCEL);
    }

    if(lpFilterName)
        LocalFree(lpFilterName);

    return(hResult);
}



/***************************************************************************

    Name      : CountRows

    Purpose   : Count the rows in a table (restriction aware)

    Parameters: lpTable = table object
                fMAPI = TRUE if MAPI table, FALSE if WAB table

    Returns   : returns number of rows in the restricted table

    Comment   : Leaves the table pointer at the beginning.
                I'd use GetRowCount, but it is not aware of restrictions.

***************************************************************************/
#define COUNT_BATCH 50
ULONG CountRows(LPMAPITABLE lpTable, BOOL fMAPI) {
    ULONG cRows;
    ULONG cTotal = 0;
    HRESULT hResult;
    LPSRowSet lpRow = NULL;

#ifdef DEBUG
    DWORD dwTickCount = GetTickCount();
    DebugTrace(">>>>> Counting Table Rows...\n");
#endif // DEBUG

    cRows = 1;
    while (cRows) {
        if (hResult = lpTable->lpVtbl->QueryRows(lpTable,
          COUNT_BATCH,          // 50 row's at a time
          0,                    // ulFlags
          &lpRow)) {
            DebugTrace("CountRows:QueryRows -> %x\n", GetScode(hResult));
            break;
        }

        if (lpRow) {
            if (cRows = lpRow->cRows) { // yes, single '='
                cTotal += cRows;
            } // else, drop out of loop, we're done.
            if (fMAPI) {
                FreeProws(lpRow);
            } else {
                WABFreeProws(lpRow);
            }
            lpRow = NULL;
        } else {
            cRows = 0;      // done
        }
    }

    if (HR_FAILED(hResult = lpTable->lpVtbl->SeekRow(lpTable,
                                                     BOOKMARK_BEGINNING,
                                                     0,
                                                     NULL))) {
        DebugTrace("CountRows:SeekRow -> %x\n", GetScode(hResult));
    }

#ifdef DEBUG
    DebugTrace(">>>>> Done Counting Table Rows... %u milliseconds\n", GetTickCount() - dwTickCount);
#endif
    return(cTotal);
}


/***************************************************************************

    Name      : WABFreePadrlist

    Purpose   : Free an adrlist and it's property arrays

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

***************************************************************************/
void WABFreePadrlist(LPADRLIST lpAdrList) {
    ULONG           iEntry;

    if (lpAdrList) {
        for (iEntry = 0; iEntry < lpAdrList->cEntries; ++iEntry) {
            if (lpAdrList->aEntries[iEntry].rgPropVals) {
                WABFreeBuffer(lpAdrList->aEntries[iEntry].rgPropVals);
            }
        }
        WABFreeBuffer(lpAdrList);
    }
}


/***************************************************************************

    Name      : WABFreeProws

    Purpose   : Destroys an SRowSet structure.

    Parameters: prows -> SRowSet to free

    Returns   : none

    Comment   :

***************************************************************************/
void WABFreeProws(LPSRowSet prows) {
    register ULONG irow;

    if (! prows) {
        return;
    }

    for (irow = 0; irow < prows->cRows; ++irow) {
        WABFreeBuffer(prows->aRow[irow].lpProps);
    }
    WABFreeBuffer(prows);
}


/***************************************************************************

    Name      : FindAdrEntryID

    Purpose   : Find the PR_ENTRYID in the Nth ADRENTRY of an ADRLIST

    Parameters: lpAdrList -> AdrList
                index = which ADRENTRY to look at

    Returns   : return pointer to the SBinary structure of the ENTRYID value

    Comment   :

***************************************************************************/
LPSBinary FindAdrEntryID(LPADRLIST lpAdrList, ULONG index) {
    LPADRENTRY lpAdrEntry;
    ULONG i;

    if (lpAdrList && index < lpAdrList->cEntries) {

        lpAdrEntry = &(lpAdrList->aEntries[index]);

        for (i = 0; i < lpAdrEntry->cValues; i++) {
            if (lpAdrEntry->rgPropVals[i].ulPropTag == PR_ENTRYID) {
                return((LPSBinary)&lpAdrEntry->rgPropVals[i].Value);
            }
        }
    }
    return(NULL);
}


/***************************************************************************

    Name      : FindProperty

    Purpose   : Finds a property in a proparray

    Parameters: cProps = number of props in the array
                lpProps = proparray
                ulPropTag = property tag to look for

    Returns   : array index of property or NOT_FOUND

    Comment   :

***************************************************************************/
ULONG FindProperty(ULONG cProps, LPSPropValue lpProps, ULONG ulPropTag) {
    register ULONG i;

    for (i = 0; i < cProps; i++) {
        if (lpProps[i].ulPropTag == ulPropTag) {
            return(i);
        }
    }

    return(NOT_FOUND);
}


/***************************************************************************

    Name      : FindStringInProps

    Purpose   : Find the string property in the property value array

    Parameters: lpspv -> property value array
                ulcProps = size of array
                ulPropTag

    Returns   : return pointer to the string pointer in the array.  If
                the property doesn't exist or has error value, return NULL.

    Comment   :

***************************************************************************/
LPTSTR FindStringInProps(LPSPropValue lpspv, ULONG ulcProps, ULONG ulPropTag) {
    ULONG i;

    if (lpspv) {
        for (i = 0; i < ulcProps; i++) {
            if (lpspv[i].ulPropTag == ulPropTag) {
                return(lpspv[i].Value.LPSZ);
            }
        }
    }
    return(NULL);
}


/***************************************************************************

    Name      : PropStringOrNULL

    Purpose   : Returns the value of a property or NULL if it is an error

    Parameters: lpspv -> property value to check and return

    Returns   : pointer to value string or NULL

***************************************************************************/
LPTSTR PropStringOrNULL(LPSPropValue lpspv) {
    return(PROP_ERROR((*lpspv)) ? NULL : lpspv->Value.LPSZ);
}


/***************************************************************************

    Name      : FreeSeenList

    Purpose   : Frees the SeenList

    Parameters: none

    Returns   : none

    Comment   :

***************************************************************************/
void FreeSeenList(void) {
    ULONG i;

    Assert((lpEntriesSeen && ulEntriesSeen) || (! lpEntriesSeen && ! ulEntriesSeen));

    for (i = 0; i < ulEntriesSeen; i++) {
        if (lpEntriesSeen[i].sbinPAB.lpb) {
            LocalFree(lpEntriesSeen[i].sbinPAB.lpb);
        }
        if (lpEntriesSeen[i].sbinWAB.lpb) {
            LocalFree(lpEntriesSeen[i].sbinWAB.lpb);
        }
    }

    if (lpEntriesSeen) {
        LocalFree(lpEntriesSeen);
    }
    lpEntriesSeen = NULL;
    ulEntriesSeen = 0;
    ulMaxEntries = 0;
}


/***************************************************************************

    Name      : GetEMSSMTPAddress

    Purpose   : Get the Exchange SMTP address for this object

    Parameters: lpObject -> Object

    Returns   : lpSMTP -> returned buffer containing SMTP address (must be MAPIFree'd
                    by caller.)
                lpBase = base allocation to alloc more onto

    Comment   : What a mess!  EMS changed their name id's and guids between 4.0 and 4.5.
                They also added a fixed ID property containing just the SMTP address in 4.5.

***************************************************************************/
const GUID guidEMS_AB_40 = {   // GUID for EMS 4.0 addresses
    0x48862a09,
    0xf786,
    0x0114,
    {0x02, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
};
const GUID guidEMS_AB_45 = {   // GUID for EMS 4.5 addresses
    0x48862a08,
    0xf786,
    0x0114,
    {0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
};
#define ID_EMS_AB_PROXY_ADDRESSES_40   0x10052
#define ID_EMS_AB_PROXY_ADDRESSES_45   0x25281
// New MAPI property, found on EX 4.5 and later
#define PR_PRIMARY_SMTP_ADDRESS        PROP_TAG(PT_TSTRING, 0x39FE)

LPTSTR GetEMSSMTPAddress(LPMAPIPROP lpObject, LPVOID lpBase) {
    ULONG ulPropTag40 = 0, ulPropTag45 = 0;
    MAPINAMEID mnidT[2];
    LPMAPINAMEID lpmnid = (LPMAPINAMEID)&mnidT;
    LPSPropTagArray lptaga = NULL;
    HRESULT hResult;
    LPTSTR lpSMTP = NULL, lpAddr;
    LPSPropValue lpspv = NULL;
    ULONG i, i40 = 0, i45 = 0;
    SLPSTRArray MVString;
    SizedSPropTagArray(3, spta);
    ULONG cValues;
    SCODE sc;


#ifdef TEST_STUFF
    MAPIDebugNamedProps(lpObject, "Exchange Address");
#endif

    mnidT[0].lpguid = (LPGUID)&guidEMS_AB_40;
    mnidT[0].ulKind = MNID_ID;
    mnidT[0].Kind.lID = ID_EMS_AB_PROXY_ADDRESSES_40;


    if (HR_FAILED(hResult = lpObject->lpVtbl->GetIDsFromNames(lpObject,
      1,            // Just one name
      &lpmnid,      // &-of because this is an array
      0,            // This is where MAPI_CREATE might go
      &lptaga))) {
        DebugTrace("GetEMSNamedPropTag:GetIDsFromNames -> %x", GetScode(hResult));
    }

    if (lptaga) {
        if (lptaga->cValues >= 1 && (PROP_TYPE(lptaga->aulPropTag[0]) != PT_ERROR)) {
            ulPropTag40 = lptaga->aulPropTag[0];
        }
        MAPIFreeBuffer(lptaga);
    }

    // Yes, I should be doing them both at once, but the PAB fails if you call
    // GetIDsFromNames with ulCount > 1!
    mnidT[0].lpguid = (LPGUID)&guidEMS_AB_45;
    mnidT[0].ulKind = MNID_ID;
    mnidT[0].Kind.lID = ID_EMS_AB_PROXY_ADDRESSES_45;

    if (HR_FAILED(hResult = lpObject->lpVtbl->GetIDsFromNames(lpObject,
      1,            // Just one name
      &lpmnid,      // &-of because this is an array
      0,            // This is where MAPI_CREATE might go
      &lptaga))) {
        DebugTrace("GetEMSNamedPropTag:GetIDsFromNames -> %x", GetScode(hResult));
    }

    if (lptaga) {
        if (lptaga->cValues >= 1 && (PROP_TYPE(lptaga->aulPropTag[0]) != PT_ERROR)) {
            ulPropTag45 = lptaga->aulPropTag[0];
        }
        MAPIFreeBuffer(lptaga);
    }


    spta.aulPropTag[0] = PR_PRIMARY_SMTP_ADDRESS;
    i = 1;
    if (ulPropTag40) {
        i40 = i++;
        spta.aulPropTag[i40] = CHANGE_PROP_TYPE(ulPropTag40, PT_MV_TSTRING);
    }
    if (ulPropTag45) {
        i45 = i++;
        spta.aulPropTag[i45] = CHANGE_PROP_TYPE(ulPropTag45, PT_MV_TSTRING);
    }
    spta.cValues = i;

    // Now, get the props from the object
    if (! HR_FAILED(hResult = lpObject->lpVtbl->GetProps(lpObject,
      (LPSPropTagArray)&spta, 0, &cValues, &lpspv))) {
        // Found one or more of the properties.  Look up the SMTP address.

        if (! PROP_ERROR(lpspv[0])) {
            if (sc = MAPIAllocateMore((lstrlen(lpspv[0].Value.LPSZ) + 1)* sizeof(TCHAR), lpBase, &lpSMTP)) {
                DebugTrace("GetEMSSMTPAddress:MAPIAllocateMore -> %x\n", sc);
                hResult = ResultFromScode(sc);
                goto done;
            }
            StrCpyN(lpSMTP, lpspv[0].Value.LPSZ, lstrlen(lpspv[0].Value.LPSZ) + 1);
            goto done;
        } else if (i40 && ! PROP_ERROR(lpspv[i40])) {    // 4.0 version
            MVString = lpspv[i40].Value.MVSZ;
        } else if (i45 && ! PROP_ERROR(lpspv[i45])) {    // 4.5 version
            MVString = lpspv[i45].Value.MVSZ;
        } else {
            goto done;
        }

        for (i = 0; i < MVString.cValues; i++) {
            lpAddr = MVString.LPPSZ[i];
            if ((lpAddr[0] == 'S') &&
                (lpAddr[1] == 'M') &&
                (lpAddr[2] == 'T') &&
                (lpAddr[3] == 'P') &&
                (lpAddr[4] == ':')) {
                // This is IT!
                lpAddr += 5;    // point to the string

                // Allocate string
                if (FAILED(sc = MAPIAllocateMore((lstrlen(lpAddr) + 1) * sizeof(TCHAR), lpBase, (&lpSMTP)))) {
                    DebugTrace("GetEMSSMTPAddress:MAPIAllocateMore -> %x\n", sc);
                    hResult = ResultFromScode(sc);
                    goto done;
                }

                StrCpyN(lpSMTP, lpAddr, lstrlen(lpAddr) + 1);
                break;
            }
        }
done:
        if (lpspv) {
            MAPIFreeBuffer(lpspv);
        }
    }
    return(lpSMTP);
}


/***************************************************************************

    Name      : LoadWABEIDs

    Purpose   : Load the WAB's PAB create EIDs

    Parameters: lpAdrBook -> lpAdrBook object
                lppContainer -> returned PAB container, caller must Release

    Returns   : HRESULT

    Comment   : Allocates global lpCreateEIDsWAB.  Caller should WABFreeBuffer.

***************************************************************************/
HRESULT LoadWABEIDs(LPADRBOOK lpAdrBook, LPABCONT * lppContainer) {
    LPENTRYID lpWABEID = NULL;
    ULONG cbWABEID;
    HRESULT hResult;
    ULONG ulObjType;
    ULONG cProps;

    if (hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook,
      &cbWABEID,
      &lpWABEID)) {
        DebugTrace("WAB GetPAB -> %x\n", GetScode(hResult));
        goto exit;
    } else {
        if (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
          cbWABEID,     // size of EntryID to open
          lpWABEID,     // EntryID to open
          NULL,         // interface
          0,            // flags
          &ulObjType,
          (LPUNKNOWN *)lppContainer)) {
            DebugTrace("WAB OpenEntry(PAB) -> %x\n", GetScode(hResult));
            goto exit;
        }
    }

    // Get the WAB's creation entryids
    if ((hResult = (*lppContainer)->lpVtbl->GetProps(*lppContainer,
      (LPSPropTagArray)&ptaCon,
      0,
      &cProps,
      &lpCreateEIDsWAB))) {
        DebugTrace("Can't get container properties for WAB\n");
        // Bad stuff here!
        goto exit;
    }

    // Validate the properites
    if (lpCreateEIDsWAB[iconPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
      lpCreateEIDsWAB[iconPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL) {
        DebugTrace("WAB: Container property errors\n");
        goto exit;
    }

exit:
    if (hResult) {
        if (lpCreateEIDsWAB) {
            WABFreeBuffer(lpCreateEIDsWAB);
            lpCreateEIDsWAB = NULL;
        }
    }
    if (lpWABEID) {
        WABFreeBuffer(lpWABEID);  // bad object?
    }
    return(hResult);
}

/////////////////////////////////////////////////////////////////////////
// GetWABDllPath - loads the WAB DLL path from the registry
// szPath	- ptr to buffer
// cb		- sizeof buffer
//
void GetWABDllPath(LPTSTR szPath, ULONG cb)
{
    DWORD  dwType = 0;
    HKEY hKey = NULL;
    TCHAR szPathT[MAX_PATH];
    ULONG  cbData = sizeof(szPathT);
    if(szPath)
    {
        *szPath = '\0';
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
        {
            if(ERROR_SUCCESS == RegQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szPathT, &cbData))
            {
                if (dwType == REG_EXPAND_SZ)
                    cbData = ExpandEnvironmentStrings(szPathT, szPath, cb / sizeof(TCHAR));
                else
                {
                    if(GetFileAttributes(szPathT) != 0xFFFFFFFF)
                        StrCpyN(szPath, szPathT, cb);
                }
            }
        }
    }
    if(hKey) RegCloseKey(hKey);
	return;
}

typedef HINSTANCE (STDAPICALLTYPE *PFNMLLOADLIBARY)(LPCTSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);

static const TCHAR c_szShlwapiDll[] = TEXT("shlwapi.dll");
static const char c_szDllGetVersion[] = "DllGetVersion";
static const TCHAR c_szWABResourceDLL[] = TEXT("wab32res.dll");
static const TCHAR c_szWABDLL[] = TEXT("wab32.dll");

HINSTANCE LoadWABResourceDLL(HINSTANCE hInstWAB32)
{
    TCHAR szPath[MAX_PATH];
    HINSTANCE hinstShlwapi;
    PFNMLLOADLIBARY pfn;
    DLLGETVERSIONPROC pfnVersion;
    int iEnd;
    DLLVERSIONINFO info;
    HINSTANCE hInst = NULL;

    hinstShlwapi = LoadLibrary(c_szShlwapiDll);
    if (hinstShlwapi != NULL)
    {
        pfnVersion = (DLLGETVERSIONPROC)GetProcAddress(hinstShlwapi, c_szDllGetVersion);
        if (pfnVersion != NULL)
        {
            info.cbSize = sizeof(DLLVERSIONINFO);
            if (SUCCEEDED(pfnVersion(&info)))
            {
                if (info.dwMajorVersion >= 5)
                {
#ifdef UNICODE
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)378);
#else
                    pfn = (PFNMLLOADLIBARY)GetProcAddress(hinstShlwapi, (LPCSTR)377);
#endif // UNICODE
                    if (pfn != NULL)
                        hInst = pfn(c_szWABResourceDLL, hInstWAB32, 0);
                }
            }
        }

        FreeLibrary(hinstShlwapi);        
    }

    if (NULL == hInst)
    {
        GetWABDllPath(szPath, sizeof(szPath));
        iEnd = lstrlen(szPath);
        if (iEnd > lstrlen(c_szWABDLL))
        {
            iEnd = iEnd - lstrlen(c_szWABDLL);
            StrCpyN(&szPath[iEnd], c_szWABResourceDLL, sizeof(szPath)/sizeof(TCHAR)-iEnd);
            hInst = LoadLibrary(szPath);
        }
    }

    AssertSz(hInst, TEXT("Failed to LoadLibrary Lang Dll"));

    return(hInst);
}

/*
 *  DLL entry point for Win32
 */
BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved) {

    switch ((short)dwReason) {

        case DLL_PROCESS_ATTACH:
            hInstApp = hInstance;  // set global DLL instance
            hInst = LoadWABResourceDLL(hInstApp);

            //  We don't need these, so tell the OS to stop 'em
            DisableThreadLibraryCalls(hInstApp);
            break;

        case DLL_PROCESS_DETACH:
            if( hInst )
                FreeLibrary(hInst);
            hInst = NULL;

            break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\cldbg.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Normandy client debug code
//
//	History:
//		davidsan	05/01/96	Created
//
//--------------------------------------------------------------------------------------------

#ifdef DEBUG

#include <windows.h>
#include <cldbg.h>

void
AssertProc(LPCSTR szMsg, LPCSTR szFile, UINT iLine, DWORD grf)
{
    char szAssert[MAX_PATH * 2];
	char *szFormatGLE = NULL;
	char szGLE[MAX_PATH];
	LONG lErr;
	DWORD dwRet;

	wnsprintf(szAssert, ARRAYSIZE(szAssert), "Assert failed: %s\n%s line %d.", szMsg, szFile, iLine);

	if (grf & ASSERT_GLE)
		{
		lErr = GetLastError();
		if (0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, 
							   NULL, lErr, 0, (PSTR) &szFormatGLE, 0, NULL))
			{
			wnsprintf(szGLE, ARRAYSIZE(szGLE), "\nLast error: %d", lErr);
			}
		else
			{
			wnsprintf(szGLE, ARRAYSIZE(szGLE), "\nLast error: '%s'", szFormatGLE);
			LocalFree((HLOCAL)szFormatGLE);
			}
		StrCatBUff(szAssert, szGLE, ARRAYSIZE(szAssert));
		}
	dwRet = MessageBox(NULL, szAssert, "Assertion failure", MB_ABORTRETRYIGNORE);

	switch (dwRet)
		{
		case IDRETRY:
			DebugBreak();
			break;

		case IDIGNORE:
			break;

		case IDABORT:
			ExitProcess(0);
			break;
		}
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\at.cpp ===
/*--------------------------------------------------------------------------
	at.cpp
	
		ldap add/modify/etc test

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

	Authors:
		davidsan	Dave Sanderman

	History:
		04/25/96	davidsan	Created.
  --------------------------------------------------------------------------*/

#include "at.h"

PLCLI g_plcli = NULL;

BOOL
FInit()
{
	return TRUE;
}

BOOL
FConnect(char *szServer)
{
	HRESULT hr;
	XID xid;
	
	hr = HrCreateLdapClient(LDAP_VER_CURRENT, INTERFACE_VER_CURRENT, &g_plcli);
	if (FAILED(hr))
		{
		printf("HrCreateLdapClient returned %08X\n", hr);
		return FALSE;
		}
	hr = g_plcli->HrConnect(szServer);
	if (FAILED(hr))
		{
		printf("HrConnect returned %08X\n", hr);
		return FALSE;
		}

	//$ figure out bind name
	hr = g_plcli->HrBindSimple("cn=davidsan2@microsoft.com, c=us", NULL, &xid);
	if (FAILED(hr))
		{
		printf("HrBindSimple returned %08X\n", hr);
		return FALSE;
		}
	hr = g_plcli->HrGetBindResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrBindSimple returned %08X\n", hr);
		return FALSE;
		}
	return TRUE;	
}

char *g_rgszAttrib[] = {"title", "cn", "sn", "objectClass"};

BOOL
FSearch()
{
	HRESULT hr;
	XID xid;
	POBJ pobj;
	POBJ pobjT;
	PATTR pattr;
	PVAL pval;
	SP sp;
	FILTER filter;
	FILTER filterS1;
	FILTER filterS2;
	FILTER filterSS1;
	FILTER filterSS2;
	FILTER filterSS3;

#ifdef OLDSEARCH	
	filter.type = LDAP_FILTER_AND;
	filter.pfilterSub = &filterS1;

		filterS1.type = LDAP_FILTER_OR;
		filterS1.pfilterSub = &filterSS1;
		filterS1.pfilterNext = &filterS2;
	
			filterSS1.type = LDAP_FILTER_EQUALITY;
			filterSS1.ava.szAttrib = "cn";
			filterSS1.ava.szValue = "sander";
			filterSS1.pfilterNext = &filterSS2;

			filterSS2.type = LDAP_FILTER_EQUALITY;
			filterSS2.ava.szAttrib = "sn";
			filterSS2.ava.szValue = "sander";
			filterSS2.pfilterNext = &filterSS3;

			filterSS3.type = LDAP_FILTER_EQUALITY;
			filterSS3.ava.szAttrib = "uid";
			filterSS3.ava.szValue = "sander";
			filterSS3.pfilterNext = NULL;

		filterS2.type = LDAP_FILTER_EQUALITY;
		filterS2.ava.szAttrib = "objectClass";
		filterS2.ava.szValue = "Person";
		filterS2.pfilterNext = NULL;
	
#else
//	filter.type = LDAP_FILTER_SUBSTRINGS;
//	filter.sub.szAttrib = "cn";
//	filter.sub.szInitial = NULL;
//	filter.sub.szAny = "alex";
//	filter.sub.szFinal = NULL;

	filter.type = LDAP_FILTER_EQUALITY;
	filter.ava.szAttrib = "cn";
	filter.ava.szValue = "davidsan2";
#endif

	sp.szDNBase = "c=US";
	sp.scope = LDAP_SCOPE_WHOLESUBTREE;
	sp.deref = LDAP_DEREF_ALWAYS;
	sp.cRecordsMax = 0;
	sp.cSecondsMax = 0;
	sp.fAttrsOnly = FALSE;
	sp.pfilter = &filter;
	sp.cAttrib = 4;
	sp.rgszAttrib = g_rgszAttrib;
	hr = g_plcli->HrSearch(&sp, &xid);
	if (FAILED(hr))
		{
		printf("HrSearch returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetSearchResponse(xid, INFINITE, &pobj);
	if (FAILED(hr))
		{
		printf("HrGetSearchResponse returned %08X\n", hr);
		return FALSE;
		}
	pobjT = pobj;
	while (pobjT)
		{
		printf("OBJ: %s\n", pobjT->szDN);
		pattr = pobjT->pattrFirst;
		while (pattr)
			{
			printf("  ATTR: %s\n", pattr->szAttrib);
			pval = pattr->pvalFirst;
			while (pval)
				{
				printf("    VAL: %s\n", pval->szVal);
				pval = pval->pvalNext;
				}
			pattr = pattr->pattrNext;
			}
		pobjT = pobjT->pobjNext;
		}
	g_plcli->HrFreePobjList(pobj);
		
	return TRUE;
}

void
SetPattr(PATTR pattr, PATTR pattrNext, char *szAttrib, PVAL pval)
{
	pattr->pattrNext = pattrNext;
	pattr->szAttrib = szAttrib;
	pattr->pvalFirst = pval;
}

void
SetPval(PVAL pval, PVAL pvalNext, char *szVal)
{
	pval->pvalNext = pvalNext;
	pval->szVal = szVal;
}

BOOL
FTestOtherStuff()
{
	HRESULT hr;
	XID xid;

#ifdef TEST_MODIFY
	MOD mod;
	ATTR attr;
	VAL val;
	
	mod.pmodNext = NULL;
	mod.modop = LDAP_MODIFY_REPLACE;
	mod.pattrFirst = &attr;
	
	attr.pattrNext = NULL;
	attr.szAttrib = "URL";
	attr.pvalFirst = &val;
	
	val.pvalNext = NULL;
	val.szVal = "http://bite.me.com/";
	
	hr = g_plcli->HrModify("c=us, cn=davidsan2@microsoft.com", &mod, &xid);
	if (FAILED(hr))
		{
		printf("HrModify returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetModifyResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetModifyResponse returned %08X\n", hr);
		}
#endif // TEST_MODIFY

#define TEST_ADD
#ifdef TEST_ADD
	
	ATTR attr1;
	ATTR attr2;
	ATTR attr3;
	ATTR attr4;
	ATTR attr5;
	VAL val1;
	VAL val2;
	VAL val3;
	VAL val4;
	VAL val5;
	attr1.pattrNext = &attr2;
	attr1.szAttrib = "c";
	attr1.pvalFirst = &val1;

	attr2.pattrNext = &attr3;
	attr2.szAttrib = "sn";
	attr2.pvalFirst = &val2;

	attr3.pattrNext = &attr4;
	attr3.szAttrib = "givenName";
	attr3.pvalFirst = &val3;

	attr4.pattrNext = &attr5;
	attr4.szAttrib = "rfc822Mailbox";
	attr4.pvalFirst = &val4;

	attr5.pattrNext = NULL;
	attr5.szAttrib = "objectClass";
	attr5.pvalFirst = &val5;
		
	val1.pvalNext = NULL;
	val1.szVal = "us";
	
	val2.pvalNext = NULL;
	val2.szVal = "sanderman";
	
	val3.pvalNext = NULL;
	val3.szVal = "david";
	
	val4.pvalNext = NULL;
	val4.szVal = "davidsan3@microsoft.com";
	
	val5.pvalNext = NULL;
	val5.szVal = "Person";
	
	hr = g_plcli->HrAdd("c=us, cn=davidsan3@microsoft.com", &attr1, &xid);
	if (FAILED(hr))
		{
		printf("HrAdd returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetAddResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetAddResponse returned %08X\n", hr);
		}
#endif
	return TRUE;		
}

BOOL
FTerm()
{
	if (g_plcli)
		{
		g_plcli->HrUnbind();
		if (g_plcli->HrIsConnected() == NOERROR)
			g_plcli->HrDisconnect();
		g_plcli->Release();
		}
	return TRUE;
}

void
usage()
{
	printf("usage:	lt <server>\n");
	exit(1);
}

void __cdecl
main(int argc, char **argv)
{
	if (argc < 2)
		usage();

	if (!FInit())
		exit(1);

	if (!FConnect(argv[1]))
		exit(1);

	FSearch();
		
	FTestOtherStuff();

	FTerm();
	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\cldbg.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Normandy client debug defines
//
//	History:
//		davidsan	05/01/96	Created
//
//--------------------------------------------------------------------------------------------

#ifndef _CLDBG_H
#define _CLDBG_H

#ifdef DEBUG

#define ASSERT_GLE 0x00000001

extern void AssertProc(LPCSTR szMsg, LPCSTR szFile, UINT iLine, DWORD grf);

#define Assert(f) (void)((f) || (AssertProc(#f, __FILE__, __LINE__, 0), 0))
#define AssertGLE(f) (void)((f) || (AssertProc(#f, __FILE__, __LINE__, ASSERT_GLE), 0))
#define AssertSz(f,sz) (void)((f) || (AssertProc(sz, __FILE__, __LINE__, 0), 0))

#else

#define Assert(f)
#define AssertGLE(f)
#define AssertSz(f,sz)

#endif

#endif  // _CLDBG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\convert\wmnets\wabimp.h ===
/*
 *  wabimp.h
 *
 *  Internal header for wabimp.dll
 *
 *  Copyright 1996-1997 Microsoft Corporation.  All Rights Reserved.
 */

//
// MACROS
//

// Test for PT_ERROR property tag
#define PROP_ERROR(prop) (prop.ulPropTag == PROP_TAG(PT_ERROR, PROP_ID(prop.ulPropTag)))
#define ToUpper(c) (c >= 'a' && c <= 'z') ? ('A' + c - 'a') : c

//
// Property Tags:
//

#define MAX_SCHEMA_PROPID           0x3FFF
#define MIN_NAMED_PROPID            0x8000

// MSN Address properties
#define PR_MSNINET_ADDRESS          PROP_TAG(PT_TSTRING,    0x6001)
#define PR_MSNINET_DOMAIN           PROP_TAG(PT_TSTRING,    0x6002)

//
// Error values
//
#define WAB_W_BAD_EMAIL             MAKE_MAPI_S(0x1000)
#define WAB_W_END_OF_FILE           MAKE_MAPI_S(0x1001)

// Misc defines
#define NOT_FOUND                   ((ULONG)-1)
#define INDEX_FIRST_MIDDLE_LAST     ((ULONG)-2)
#define NUM_EXPORT_WIZARD_PAGES     2
#define NUM_IMPORT_WIZARD_PAGES     2

// Netscape, Eudora, Athena16 importer defines
#define NETSCAPE                    500
#define EUDORA                      501
#define ATHENA16                    502
#define MAX_FILE_NAME               500         // BUGBUG: Should be MAX_PATH?
#define MAX_STRING_SIZE             30          // BUGBUG: Should be larger?
#define MAX_MESSAGE                 500
#define ATHENASTRUCTURE             190
#define ATHENAADROFFSET             28
#define EUDORA_STRUCT               16

// Athena
#define MAX_NAME_SIZE               80
#define MAX_EMA_SIZE                80

#define hrINVALIDFILE               600         // BUGBUG: Should use MAKE_MAPI_E
#define hrMemory	                 601         // BUGBUG: Should use MAPI_E_NOT_ENOUGH_MEMORY



//
// Types
//

// Index of icons in the bitmap
enum {
    iiconStateUnchecked,
    iiconStateChecked,
    iiconStMax
};

typedef enum {
    INDEX_EXPORT_PAB = 0,
    INDEX_EXPORT_CSV
} INDEX_EXPORT, *LPINDEX_EXPORT;


typedef enum {
    CONFIRM_YES,
    CONFIRM_NO,
    CONFIRM_YES_TO_ALL,
    CONFIRM_NO_TO_ALL,
    CONFIRM_ERROR,
    CONFIRM_ABORT
} CONFIRM_RESULT, *LPCONFIRM_RESULT;


typedef struct _ReplaceInfo {
    LPTSTR lpszDisplayName;         // Conflicting display name
    LPTSTR lpszEmailAddress;        // Conflicting email address
    CONFIRM_RESULT ConfirmResult;   // Results from dialog
    BOOL fExport;                   // TRUE if this is an export operation
    union {
        LPWAB_IMPORT_OPTIONS lpImportOptions;
        LPWAB_EXPORT_OPTIONS lpExportOptions;
    };
} REPLACE_INFO, * LPREPLACE_INFO;

typedef enum {
    ERROR_OK,
    ERROR_ABORT
} ERROR_RESULT, *LPERROR_RESULT;

typedef struct _ErrorInfo {
    LPTSTR lpszDisplayName;         // Problem display name
    LPTSTR lpszEmailAddress;        // Problem email address
    ERROR_RESULT ErrorResult;       // Results from dialog
    ULONG ids;                      // string resource identifier for error message
    BOOL fExport;                   // TRUE if this is an export operation
    union {
        LPWAB_IMPORT_OPTIONS lpImportOptions;
        LPWAB_EXPORT_OPTIONS lpExportOptions;
    };
} ERROR_INFO, * LPERROR_INFO;


typedef struct _EntrySeen {
    SBinary sbinPAB;                // MAPI entry
    SBinary sbinWAB;                // WAB entry
} ENTRY_SEEN, * LPENTRY_SEEN;

typedef struct _TargetInfo {
    LPTSTR lpRegName;
    LPTSTR lpDescription;
    LPTSTR lpDll;
    LPTSTR lpEntry;
    union {
        LPWAB_EXPORT lpfnExport;
        LPWAB_IMPORT lpfnImport;
    };
} TARGET_INFO, *LPTARGET_INFO;


enum {
    iconPR_DEF_CREATE_MAILUSER = 0,
    iconPR_DEF_CREATE_DL,
    iconMax
};

enum {
    ieidPR_ENTRYID = 0,
    ieidMax
};

enum {
    iptaColumnsPR_OBJECT_TYPE = 0,
    iptaColumnsPR_ENTRYID,
    iptaColumnsPR_DISPLAY_NAME,
    iptaColumnsPR_EMAIL_ADDRESS,
    iptaColumnsMax
};

typedef struct _PropNames {
    ULONG ulPropTag;        // property tag
    BOOL fChosen;           // use this property tag
    ULONG ids;              // string id
    LPTSTR lpszName;        // string (read in from resources)
    LPTSTR lpszCSVName;     // name of CSV field (from import file)
} PROP_NAME, *LPPROP_NAME;


// PAB

// State Identifiers
typedef enum {
    STATE_IMPORT_MU,
    STATE_IMPORT_NEXT_MU,
    STATE_IMPORT_DL,
    STATE_IMPORT_NEXT_DL,
    STATE_IMPORT_FINISH,
    STATE_IMPORT_ERROR,
    STATE_IMPORT_CANCEL,
    STATE_EXPORT_MU,
    STATE_EXPORT_NEXT_MU,
    STATE_EXPORT_DL,
    STATE_EXPORT_NEXT_DL,
    STATE_EXPORT_FINISH,
    STATE_EXPORT_ERROR,
    STATE_EXPORT_CANCEL
} PAB_STATE, *LPPAB_STATE;


// NetScape
typedef struct tagDistList {
    int AliasID;
    struct tagDistList *lpDist;
} NSDistList, NSDISTLIST, *LPNSDISTLIST;


typedef struct tagAdrBook {
    ULONG   AliasID;            // The AliasID value
    BOOL    Sbinary;
    BOOL    DistList;
    TCHAR   *Address;
    TCHAR   *NickName;
    TCHAR   *Entry;
    TCHAR   *Description;
    LPNSDISTLIST  lpDist;
} NSAdrBook, NSADRBOOK, *LPNSADRBOOK;

// Eudora
typedef struct tagEudDistList {
    BOOL    flag;			     // To check whether it is a alias or a simple address
    TCHAR   *NickName;
    TCHAR   *Address;
    TCHAR   *Description;
    int     AliasID;            // ID of the member if it is a simple address
    struct tagEudDistList *lpDist;  //pointer to the next entry of DL.
} EudDistList, EUDDISTLIST, *LPEUDDISTLIST;

typedef struct tagEUDAdrBook {
    TCHAR *Address;
    TCHAR *NickName;
    TCHAR *Description;
    LPEUDDISTLIST lpDist;
} EudAdrBook, EUDADRBOOK, *LPEUDADRBOOK;


// Athena16
typedef struct tagABCREC {
    TCHAR DisplayName[MAX_NAME_SIZE + 1];
    TCHAR EmailAddress[MAX_EMA_SIZE + 1];
} ABCREC, *LPABCREC;

#define CBABCREC sizeof(ABCREC)


extern const TCHAR szTextFilter[];
extern const TCHAR szAllFilter[];

extern const UCHAR szQuote[];
extern const TCHAR szMSN[];
extern const TCHAR szMSNINET[];
extern const TCHAR szCOMPUSERVE[];
extern const TCHAR szFAX[];
extern const TCHAR szSMTP[];
extern const TCHAR szMS[];
extern const TCHAR szEX[];
extern const TCHAR szX400[];
extern const TCHAR szMSA[];
extern const TCHAR szMAPIPDL[];
extern const TCHAR szEmpty[];
extern const TCHAR szAtSign[];
#define cbAtSign        (2 * sizeof(TCHAR))

extern const TCHAR szMSNpostfix[];
#define cbMSNpostfix    (9 * sizeof(TCHAR))

extern const TCHAR szCOMPUSERVEpostfix[];
#define cbCOMPUSERVEpostfix     (16 * sizeof(TCHAR))

extern PROP_NAME rgPropNames[];
extern LPPROP_NAME lpImportMapping;
extern HINSTANCE hInst;
extern HINSTANCE hInstApp;

extern LPENTRY_SEEN lpEntriesSeen;
extern ULONG ulEntriesSeen;
extern ULONG ulMaxEntries;

extern LPSPropValue lpCreateEIDsWAB;
extern LPSPropValue lpCreateEIDsMAPI;

extern ULONG ulcEntries;

#ifndef _WABIMP_C
#define ExternSizedSPropTagArray(_ctag, _name) \
extern const struct _SPropTagArray_ ## _name \
{ \
    ULONG   cValues; \
    ULONG   aulPropTag[_ctag]; \
} _name

ExternSizedSPropTagArray(iptaColumnsMax, ptaColumns);
ExternSizedSPropTagArray(ieidMax, ptaEid);
ExternSizedSPropTagArray(iconMax, ptaCon);


#endif


//
// WABIMP.C
//
HRESULT OpenWabContainer(LPABCONT *lppWabContainer, LPADRBOOK lpAdrBook);
BOOL GetFileToImport(HWND hwnd, LPTSTR szFileName, DWORD cchFileName, int type);
INT_PTR CALLBACK ReplaceDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ErrorDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
HRESULT GetRegistryPath(LPTSTR szFileName, ULONG cchSize, int type);
HRESULT GetExistEntry(LPABCONT lpWabContainer, LPSBinary lpsbinary, ULONG ucount,
  LPTSTR szDisplayName, LPTSTR szNickName);
void FreeRowSet(LPSRowSet lpRows);
LPTSTR LoadAllocString(int StringID);
LPTSTR LoadStringToGlobalBuffer(int StringID);
ULONG SizeLoadStringToGlobalBuffer(int StringID);
HRESULT FillMailUser(HWND hwnd, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions, void *lpeudAdrBook, LPSBinary lpsbinary,
  ULONG ul,int type);
INT_PTR CALLBACK ComDlg32DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void WABFreeProws(LPSRowSet prows);
LPTSTR PropStringOrNULL(LPSPropValue lpspv);
LPTSTR GetEMSSMTPAddress(LPMAPIPROP lpObject, LPVOID lpBase);
void FreeSeenList(void);
extern ULONG CountRows(LPMAPITABLE lpTable, BOOL fMAPI);
extern void WABFreePadrlist(LPADRLIST lpAdrList);
extern SCODE WABFreeBuffer(LPVOID lpBuffer);
extern SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer);
extern SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer);
extern INT_PTR CALLBACK ErrorDialogProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);
extern LPTSTR FindStringInProps(LPSPropValue lpspv, ULONG ulcProps, ULONG ulPropTag);
extern LPSBinary FindAdrEntryID(LPADRLIST lpAdrList, ULONG index);
extern void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject);
BOOL IsSpace(LPTSTR lpChar);
HRESULT SaveFileDialog(HWND hWnd,
  LPTSTR szFileName,
  LPCTSTR lpFilter1,
  ULONG idsFileType1,
  LPCTSTR lpFilter2,
  ULONG idsFileType2,
  LPCTSTR lpFilter3,
  ULONG idsFileType3,
  LPCTSTR lpDefExt,
  ULONG ulFlags,
  HINSTANCE hInst,
  ULONG idsTitle,
  ULONG idsSaveButton);
HRESULT OpenFileDialog(HWND hWnd,
  LPTSTR szFileName,
  LPCTSTR lpFilter1,
  ULONG idsFileType1,
  LPCTSTR lpFilter2,
  ULONG idsFileType2,
  LPCTSTR lpFilter3,
  ULONG idsFileType3,
  LPCTSTR lpDefExt,
  ULONG ulFlags,
  HINSTANCE hInst,
  ULONG idsTitle,
  ULONG idsOpenButton);
int __cdecl ShowMessageBoxParam(HWND hWndParent, int MsgId, int ulFlags, ...);
extern void WABFreePadrlist(LPADRLIST lpAdrList);
extern SCODE WABFreeBuffer(LPVOID lpBuffer);
extern SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer);
extern SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer);
extern void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject);
HRESULT LoadWABEIDs(LPADRBOOK lpAdrBook, LPABCONT * lppContainer);


//
// NetScape
//
HRESULT MigrateUser(HWND hwnd,  LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook);
HRESULT  ParseAddressBook(HWND hwnd, LPTSTR szFileName, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook);
HRESULT ParseAddress(HWND hwnd, LPTSTR szBuffer, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook);
HRESULT GetAdrBuffer(LPTSTR *szBuffer, LPTSTR *szAdrBuffer);
HRESULT ProcessAdrBuffer(HWND hwnd,LPTSTR AdrBuffer, LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook);
BOOL GetAdrLine(LPTSTR *szCurPointer, LPTSTR *szBuffer, LPTSTR *szDesc);
HRESULT ProcessLn(LPTSTR *szL, LPTSTR *szDesc, NSADRBOOK *nsAdrBook, LPTSTR *szBuffer);
ULONG GetAddressCount(LPTSTR AdrBuffer);
LPTSTR  GetAdrStart(LPTSTR szBuffer);
LPTSTR GetDLNext(LPTSTR szBuffer);
LPTSTR  GetAdrEnd(LPTSTR szBuffer);
ULONG GetAddrCount(LPTSTR AdrBuffer);
HRESULT FillDistList(HWND hwnd, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions, LPNSADRBOOK lpnAdrBook, LPSBinary lpsbinary,
  LPADRBOOK lpAdrBook);
HRESULT FillWABStruct(LPSPropValue rgProps, NSADRBOOK *nsAdrBook);
HRESULT CreateDistEntry(LPABCONT lpWabContainer, LPSPropValue sProp,
  ULONG ulCreateEntries, LPMAPIPROP *lppMailUserWab);
LPNSDISTLIST FreeNSdistlist(LPNSDISTLIST lpDist);

//
// Eudora
//
HRESULT MigrateEudoraUser(HWND hwnd, LPABCONT lpWabContainer,
  LPWAB_IMPORT_OPTIONS lpOptions, LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPADRBOOK lpAdrBook);
ULONG ParseEudAddress(LPTSTR szFileName,LPEUDADRBOOK *lpeudAdrBook);
HRESULT ParseAddressTokens(LPTSTR szBuffer,LPTSTR szAdrBuffer, UINT ulCount,
  LPTSTR *szAliaspt, EUDADRBOOK *EudAdrBook);
HRESULT CreateAdrLineBuffer(LPTSTR *szAdrline, LPTSTR szAdrBuffer, ULONG ulAdrOffset,
  ULONG ulAdrSize);
HRESULT ParseAdrLineBuffer(LPTSTR szAdrLine, LPTSTR *szAliasptr, ULONG uToken,
  EUDADRBOOK *EudAdrBook);
BOOL SearchAdrName(LPTSTR szAdrCur);
INT SearchName(LPTSTR *szAliasptr, LPTSTR szAdrCur);
HRESULT ImportEudUsers(HWND hwnd,LPTSTR szFileName, LPABCONT lpWabContainer,
  LPSPropValue sProp, LPEUDADRBOOK lpeudAdrBook, ULONG ulCount,
  LPWAB_IMPORT_OPTIONS lpOptions, LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPADRBOOK lpAdrBook);
HRESULT FillEudDistList(HWND hWnd, LPABCONT lpWabContainer, LPSPropValue sProp,
   LPWAB_IMPORT_OPTIONS lpOptions, LPEUDADRBOOK lpeudAdrBook, LPSBinary lpsbinary,
   LPADRBOOK lpAdrBook, ULONG ul);
HRESULT FillEudWABStruct(LPSPropValue rgProps, EUDADRBOOK *eudAdrBook);
void FillEudDiststruct(LPSPropValue rgProps, EUDADRBOOK *eudAdrBook);
LPEUDDISTLIST FreeEuddistlist(LPEUDDISTLIST lpDist);
char* Getstr(char* szSource, char* szToken);
ULONG ShiftAdd(int offset, TCHAR *szBuffer);

//
// Athena16
//
HRESULT MigrateAthUser(HWND hwnd,  LPWAB_IMPORT_OPTIONS lpOptions,
  LPWAB_PROGRESS_CALLBACK lpProgressCB, LPADRBOOK lpAdrBook) ;
HRESULT  ParseAthAddressBook(HWND hwnd, LPTSTR szFileName,
  LPWAB_IMPORT_OPTIONS lpOptions, LPWAB_PROGRESS_CALLBACK lpProgressCB,
  LPADRBOOK lpAdrBook);
HRESULT FillAthenaUser(HWND hwnd, LPABCONT lpWabContainer, LPSPropValue sProp,
  LPWAB_IMPORT_OPTIONS lpOptions, LPABCREC lpabcrec);

//
// Functions in csvpick.c
//
int APIENTRY PickExportProps(LPPROP_NAME rgPropNames);
HRESULT ExportWizard(HWND hWnd, LPTSTR szFileName, ULONG cchSize, LPPROP_NAME rgPropNames);
HRESULT ImportWizard(HWND hWnd, LPTSTR szFileName, ULONG cchSize, LPPROP_NAME rgPropNames,
  LPTSTR szSep, LPPROP_NAME * lppImportMapping, LPULONG lpcFields, LPHANDLE lphFile);

//
// Functions in csvparse.c
//
HRESULT ReadCSVLine(HANDLE hFile, LPTSTR szSep, ULONG * lpcItems, PUCHAR ** lpprgItems);

// Functions in pab.c
HRESULT HrLoadPrivateWABPropsForCSV(LPADRBOOK );

LPWABOPEN lpfnWABOpen;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\lclilist.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client Xaction List.
//
//	History:
//		davidsan	04/26/96	Created
//
//--------------------------------------------------------------------------------------------

#ifndef _LCLILIST_H
#define _LCLILIST_H

extern XL g_xl;

// just use a simple linked-list, since there won't ever be more than a few of
// these in any one process.
class CXactionList
{
public:
	CXactionList();
	~CXactionList();
	
	PXD					PxdNewXaction(DWORD xtype);
	PXD					PxdForXid(XID xid);
	void				RemovePxd(PXD pxd);
	void				AddPxdToList(PXD pxd);
	
private:
	CRITICAL_SECTION	m_cs;
	PXD					m_pxdHead;
	
	void				DeletePxdChain(PXD pxd);
};

#endif // _LCLILIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\lclilist.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client Xaction List
//
//
//	History
//		davidsan	04-26-96	Created
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// INCLUDES
//
//--------------------------------------------------------------------------------------------
#include "ldappch.h"
#include "lclilist.h"
#include "lclixd.h"

//--------------------------------------------------------------------------------------------
//
// PROTOTYPES
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// GLOBALS
//
//--------------------------------------------------------------------------------------------
XID g_xid = 1;

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// CLASSES
//
//--------------------------------------------------------------------------------------------

CXactionList::CXactionList()
{
	::InitializeCriticalSection(&m_cs);
	m_pxdHead = NULL;
}

CXactionList::~CXactionList()
{
	this->DeletePxdChain(m_pxdHead);
	::DeleteCriticalSection(&m_cs);
}

PXD
CXactionList::PxdNewXaction(DWORD xtype)
{
	PXD pxd;
	XID xid;
	
	pxd = new XD;
	if (!pxd)
		return NULL;

	::EnterCriticalSection(&m_cs);
	xid = g_xid++;
	::LeaveCriticalSection(&m_cs);
	
	if (!pxd->FInit(xid, xtype))
		{
		delete pxd;
		return NULL;
		}
	
	this->AddPxdToList(pxd);
	return pxd;
}

PXD
CXactionList::PxdForXid(XID xid)
{
	PXD pxd;
	
	::EnterCriticalSection(&m_cs);
	pxd = m_pxdHead;
	while (pxd)
		{
		if (pxd->Xid() == xid)
			break;
			
		pxd = pxd->PxdNext();
		}
	::LeaveCriticalSection(&m_cs);
	return pxd;
}

// destroys pxd
void
CXactionList::RemovePxd(PXD pxd)
{
	PXD pxdT;

	::EnterCriticalSection(&m_cs);
	
	if (pxd == m_pxdHead)
		m_pxdHead = pxd->PxdNext();
	else
		{
		pxdT = m_pxdHead;
		while (pxdT->PxdNext())
			{
			if (pxdT->PxdNext() == pxd)
				{
				pxdT->SetPxdNext(pxd->PxdNext());
				break;
				}
			pxdT = pxdT->PxdNext();
			}
		}
	::LeaveCriticalSection(&m_cs);
	delete pxd;
}

void
CXactionList::AddPxdToList(PXD pxd)
{
	Assert(!pxd->PxdNext());

	::EnterCriticalSection(&m_cs);
	pxd->SetPxdNext(m_pxdHead);
	m_pxdHead = pxd;
	::LeaveCriticalSection(&m_cs);
}

void
CXactionList::DeletePxdChain(PXD pxd)
{
	PXD pxdT;
	
	while (pxd)
		{
		pxdT = pxd->PxdNext();
		delete pxd;
		pxd = pxdT;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\lclityp.h ===
/*--------------------------------------------------------------------------
    lclityp.h
        
        Hungarian type definitions specific to the LDAP client.

		NOTE:  All the WP libraries and DLLs have a corresponding xxxxxTYP.H
		file that defines the hungarian abbreviations of the types/classes 
		defined in the LIB or DLL.  

    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        robertc     Rob Carney

    History:
        04-17-96    robertc     Created.
  --------------------------------------------------------------------------*/
#ifndef _LCLITYP_H
#define _LCLITYP_H

//
//  Simple types.
//
class		CLdapBer;
interface	ILdapClient;
class		CLdapWinsock;
class		CXactionList;
class		CXactionData;

typedef CLdapBer			LBER, *PLBER;
typedef ILdapClient			LCLI, *PLCLI;
typedef CLdapWinsock		SOCK, *PSOCK;
typedef CXactionList		XL,   *PXL;
typedef CXactionData		XD,   *PXD;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\ldapber.cpp ===
/*--------------------------------------------------------------------------
    ldapber.cpp

        Client build of the LDAP Basic Encoding Rules class (CLdapBer).

    Copyright (C) 1993 Microsoft Corporation
    All rights reserved.

    Authors:
        robertc     Rob Carney

    History:
        04-17-96	robertc     Created.
  --------------------------------------------------------------------------*/
#include "ldappch.h"
#include "ldapber.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\lcli1823.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client RFC 1823 API
//
//
//	History
//		davidsan	06/17/96	Created
//
//--------------------------------------------------------------------------------------------

// note: this is ugly code.  all i'm doing is mapping things to my API in as painless a way
// as i can.

//--------------------------------------------------------------------------------------------
//
// INCLUDES
//
//--------------------------------------------------------------------------------------------
#include "ldappch.h"

//--------------------------------------------------------------------------------------------
//
// PROTOTYPES
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// GLOBALS
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------

int
LdapResFromHr(HRESULT hr)
{
	switch (hr)
		{
		default:
			return LDAP_LOCAL_ERROR;

		case NOERROR:
			return LDAP_SUCCESS;
			
		case LDAP_E_OPERATIONS:
			return LDAP_OPERATIONS_ERROR;
			
		case LDAP_E_PROTOCOL:
			return LDAP_PROTOCOL_ERROR;
			
		case LDAP_S_TIMEEXCEEDED:
			return LDAP_TIMELIMIT_EXCEEDED;
			
		case LDAP_S_SIZEEXCEEDED:
			return LDAP_SIZELIMIT_EXCEEDED;

		case S_FALSE:
			return LDAP_COMPARE_FALSE;

		case LDAP_E_AUTHMETHOD:
			return LDAP_AUTH_METHOD_NOT_SUPPORTED;
			
		case LDAP_E_STRONGAUTHREQUIRED:
			return LDAP_STRONG_AUTH_REQUIRED;
			
		case LDAP_E_NOSUCHATTRIBUTE:
			return LDAP_NO_SUCH_ATTRIBUTE;
			
		case LDAP_E_UNDEFINEDTYPE:
			return LDAP_UNDEFINED_TYPE;
		
		case LDAP_E_MATCHING:
			return LDAP_INAPPROPRIATE_MATCHING;
			
		case LDAP_E_CONSTRAINT:
			return LDAP_CONSTRAINT_VIOLATION;
			
		case LDAP_E_ATTRIBORVALEXISTS:
			return LDAP_ATTRIBUTE_OR_VALUE_EXISTS;
		
		case LDAP_E_SYNTAX:
			return LDAP_INVALID_SYNTAX;
		
		case LDAP_E_NOSUCHOBJECT:
			return LDAP_NO_SUCH_OBJECT;
		
		case LDAP_E_ALIAS:
			return LDAP_ALIAS_PROBLEM;
		
		case LDAP_E_DNSYNTAX:
			return LDAP_INVALID_DN_SYNTAX;

		case LDAP_E_ISLEAF:
			return LDAP_IS_LEAF;
			
		case LDAP_E_ALIASDEREF:
			return LDAP_ALIAS_DEREF_PROBLEM;
		
		case LDAP_E_AUTH:
			return LDAP_INAPPROPRIATE_AUTH;

		case LDAP_E_CREDENTIALS:
			return LDAP_INVALID_CREDENTIALS;
		
		case LDAP_E_RIGHTS:
			return LDAP_INSUFFICIENT_RIGHTS;
			
		case LDAP_E_BUSY:
			return LDAP_BUSY;
			
		case LDAP_E_UNAVAILABLE:
			return LDAP_UNAVAILABLE;
			
		case LDAP_E_UNWILLING:
			return LDAP_UNWILLING_TO_PERFORM;
			
		case LDAP_E_LOOP:
			return LDAP_LOOP_DETECT;
			
		case LDAP_E_NAMING:
			return LDAP_NAMING_VIOLATION;
			
		case LDAP_E_OBJECTCLASS:
			return LDAP_OBJECT_CLASS_VIOLATION;
			
		case LDAP_E_NOTALLOWEDONNONLEAF:
			return LDAP_NOT_ALLOWED_ON_NONLEAF;
			
		case LDAP_E_NOTALLOWEDONRDN:
			return LDAP_NOT_ALLOWED_ON_RDN;
			
		case LDAP_E_ALREADYEXISTS:
			return LDAP_ALREADY_EXISTS;
			
		case LDAP_E_NOOBJECTCLASSMODS:
			return LDAP_NO_OBJECT_CLASS_MODS;
			
		case LDAP_E_RESULTSTOOLARGE:
			return LDAP_RESULTS_TOO_LARGE;
		
		case LDAP_E_OTHER:
			return LDAP_OTHER;
		
		case LDAP_E_SERVERDOWN:
			return LDAP_SERVER_DOWN;
			
		case LDAP_E_LOCAL:
			return LDAP_LOCAL_ERROR;
			
		case LDAP_E_ENCODING:
			return LDAP_ENCODING_ERROR;
			
		case LDAP_E_DECODING:
			return LDAP_DECODING_ERROR;

		case LDAP_E_TIMEOUT:
			return LDAP_TIMEOUT;
			
		case LDAP_E_AUTHUNKNOWN:
			return LDAP_AUTH_UNKNOWN;
			
		case LDAP_E_FILTER:
			return LDAP_FILTER_ERROR;
			
		case LDAP_E_USERCANCELLED:
			return LDAP_USER_CANCELLED;

		case E_INVALIDARG:
			return LDAP_PARAM_ERROR;

		case E_OUTOFMEMORY:
			return LDAP_NO_MEMORY;
		}
}

DWORD
TimeoutFromTimeval(struct timeval *ptv)
{
	if (!ptv->tv_usec && !ptv->tv_sec)
		return INFINITE;
	return (ptv->tv_usec / 1000) + (ptv->tv_sec * 1000);
}

char *
SzMatchingParen(char *sz)
{
	int cLev = 0;

	if (sz[0] != '(')
		return NULL;
	
	while (*sz)
		{
		if (*sz == '(')
			cLev++;
		else if (*sz == ')')
			{
			cLev--;
			if (!cLev)
				return sz;
			}
		sz++;
		}
	return NULL;
}

char *
SzFT(char *sz, DWORD *ptype)
{
	while (*sz)
		{
		if (*sz == '=')
			{
			if (*(sz-1) == '~')
				{
				*ptype = LDAP_FILTER_APPROX;
				*(sz-1) = 0;
				return sz;
				}
			else if (*(sz - 1) == '<')
				{
				*ptype = LDAP_FILTER_LE;
				*(sz-1) = 0;
				return sz;
				}
			else if (*(sz - 1) == '<')
				{
				*ptype = LDAP_FILTER_GE;
				*(sz-1) = 0;
				return sz;
				}
			if (*(sz + 1) == '*')
				{
				*ptype = LDAP_FILTER_PRESENT;
				*sz = 0;
				return sz+1;
				}
			*ptype = 0;
			return sz;
			}
		sz++;
		}
	return NULL;
}

char *
SzStar(char *sz)
{
	while (*sz)
		{
		if (*sz == '*')
			return sz;
		sz++;
		}
	return NULL;
}

void
Unquote(char *sz)
{
	char *pchSrc = sz, *pchDest = sz;
	BOOL fQuoted = FALSE;
	
	while (*pchSrc)
		{
		if (fQuoted)
			{
			goto LCopy;
			}
		else
			{
			if (*pchSrc == '\\')
				fQuoted = TRUE;
			else
				{
LCopy:
				*pchDest++ = *pchSrc;
				fQuoted = FALSE;
				}
			}
		pchSrc++;
		}
}

void
FreePfilter(PFILTER pfilter)
{
	PFILTER pfilterNext;

	while (pfilter)
		{
		if (pfilter->type == LDAP_FILTER_AND ||
			pfilter->type == LDAP_FILTER_OR ||
			pfilter->type == LDAP_FILTER_NOT)
			FreePfilter(pfilter->pfilterSub);
		pfilterNext = pfilter->pfilterNext;
		
		delete pfilter;
		
		pfilter = pfilterNext;		
		}
}

PFILTER
PfilterFromString(char *sz)
{
	PFILTER pfilter = NULL;
	char *szMatchingParen;
	char *szSubMatchingParen;
	PFILTER pfilterSub = NULL;
	PFILTER pfilterPrev = NULL;
	char *szFT;
	char *szStar;
	char *szOldStar;
	
	if (sz[0] != '(')
		return NULL;
	szMatchingParen = SzMatchingParen(sz);
	if (!szMatchingParen)
		return NULL;
		
	pfilter = new FILTER;
	if (!pfilter)
		return NULL;
	FillMemory(pfilter, sizeof(FILTER), 0);
	
	switch (sz[1])
		{
		case '&':
		case '|':
			if (sz[1] == '&')
				pfilter->type = LDAP_FILTER_AND;
			else
				pfilter->type = LDAP_FILTER_OR;
				
			sz++;
			sz++;

			// sz now points to what should be first paren of first subfilter
			while (sz < szMatchingParen)
				{
				szSubMatchingParen = SzMatchingParen(sz);
				if (!szSubMatchingParen || szSubMatchingParen >= szMatchingParen)
					goto LFail;
				pfilterSub = PfilterFromString(sz);
				if (!pfilter->pfilterSub)
					pfilter->pfilterSub = pfilterSub;
				if (pfilterPrev)
					pfilterPrev->pfilterNext = pfilterSub;
				pfilterPrev = pfilterSub;
				sz = szSubMatchingParen + 1;
				}

			break;
			
		case '!':
			pfilter->type = LDAP_FILTER_NOT;
			sz++;
			sz++;
			szSubMatchingParen = SzMatchingParen(sz);
			if (!szSubMatchingParen || szSubMatchingParen >= szMatchingParen)
				goto LFail;
			pfilterSub = PfilterFromString(sz);
			pfilter->pfilterSub = pfilterSub;
			break;
			
		default:
			// it's not an and/or/not, so it must be an attribute-related filter.
			sz++;
			szFT = SzFT(sz, &pfilter->type);
			if (!szFT)
				goto LFail;
			*szFT++ = 0;
			*szMatchingParen = 0;
			Unquote(sz);
			
			// so now sz points to the attribute and szFT points to the value.
			if (pfilter->type == LDAP_FILTER_PRESENT)
				{
				pfilter->szAttrib = sz;
				}
			else
				{
				pfilter->ava.szAttrib = sz;
				pfilter->ava.szValue = szFT;
				}

			if (!pfilter->type)
				{
				// if a type wasn't filled in, it means it's either eq or substring;
				// we need to grind through the string and look for *s.  note that we
				// use a less general format of substring commands than the LDAP
				// api and spec.
				szStar = SzStar(szFT);
				if (!szStar)
					{
					pfilter->type = LDAP_FILTER_EQUALITY;
					}
				else
					{
					pfilter->type = LDAP_FILTER_SUBSTRINGS;
					pfilter->sub.szAttrib = sz;
					pfilter->sub.szInitial = szFT;
					Unquote(szFT);
					*szStar++ = 0;
					szOldStar = szStar;
					szStar = SzStar(szOldStar);
					if (szStar)
						{
						*szStar++ = 0;
						pfilter->sub.szAny = szOldStar;
						Unquote(szOldStar);
						szOldStar = szStar;
						szStar = SzStar(szOldStar);
						if (szStar)
							{
							*szStar++ = 0;
							pfilter->sub.szFinal = szOldStar;
							Unquote(szOldStar);
							}
						}
					}
				}
			break;
		}
		
	return pfilter;
	
LFail:
	if (pfilter)
		{
		FreePfilter(pfilter);
		}
	return NULL;
}

int
CAttrib(char **rgsz)
{
	int c = 0;
	while (*rgsz)
		{
		c++;
		rgsz++;
		}
	return c;
}

int
Cval(PATTR pattr)
{
	PVAL pval = pattr->pvalFirst;

	int c = 0;
	while (pval)
		{
		c++;
		pval = pval->pvalNext;
		}
	return c;
}

extern "C" DLLEXPORT LDAP * __cdecl
ldap_open(char *hostname, int portno)
{
	PLCLI plcli = NULL;
	LDAP *pldap = NULL;
	
	pldap = new LDAP;
	if (!pldap)
		return NULL;
		
	FillMemory(pldap, sizeof(LDAP), 0);
	
	if (FAILED(HrCreateLdapClient(LDAP_VER_CURRENT, INTERFACE_VER_CURRENT, &plcli)))
		{
		delete pldap;
		return NULL;
		}

	if (FAILED(plcli->HrConnect(hostname, portno)))
		{
		delete pldap;
		plcli->Release();
		return NULL;
		}
		
	pldap->plcli = plcli;
		
	return pldap;
}

extern "C" DLLEXPORT int __cdecl
ldap_bind_s(LDAP *ld, char *dn, char *cred, int method)
{
	HRESULT hr;
	XID xid;

	if (!ld->plcli)
		return LDAP_PARAM_ERROR;

	if (method != LDAP_AUTH_SIMPLE)
		return LDAP_AUTH_METHOD_NOT_SUPPORTED;

	if (!cred)
		cred = "";

	if (!dn)
		dn = "";
		
	hr = ld->plcli->HrBindSimple(dn, cred, &xid);
	if (FAILED(hr))
		return LdapResFromHr(hr);
	
	hr = ld->plcli->HrGetBindResponse(xid, INFINITE);
	return LdapResFromHr(hr);
}

extern "C" DLLEXPORT int __cdecl
ldap_unbind(LDAP *ld)
{
	if (!ld->plcli)
		return LDAP_PARAM_ERROR;
		
	ld->plcli->HrUnbind();
	ld->plcli->HrDisconnect();
	ld->plcli->Release();

	// just in case someone tries to use the ld after this...
	ld->plcli = NULL;
	
	delete ld;
	return LDAP_SUCCESS;
}
	
extern "C" DLLEXPORT int __cdecl
ldap_search_s(LDAP *ld, char *base, int scope, char *filter, char *attrs[], int attrsonly, LDAPMessage **res)
{
	struct timeval time;

	timerclear(&time);
	return ldap_search_st(ld, base, scope, filter, attrs, attrsonly, &time, res);
}

char *attrsNull[] = {NULL};

extern "C" DLLEXPORT int __cdecl
ldap_search_st(LDAP *ld, char *base, int scope, char *filter, char *attrs[], int attrsonly, struct timeval *timeout, LDAPMessage **res)
{	
	HRESULT hr;
	POBJ pobj;
	XID xid;
	SP sp;
	char szFilter[1024];

	*res = NULL;

	if (!attrs)
		attrs = attrsNull;
	
	// make local copy so we can munge this in place
	if (lstrlen(filter) > 1023)
		return LDAP_PARAM_ERROR;
	StrCpyN(szFilter, filter, ARRAYSIZE(szFilter));

	if (!ld->plcli)
		return LDAP_PARAM_ERROR;

	sp.szDNBase = base;
	sp.scope = scope;
	sp.deref = ld->ld_deref;
	sp.cRecordsMax = ld->ld_sizelimit;
	sp.cSecondsMax = ld->ld_timelimit;
	sp.fAttrsOnly = attrsonly;
	sp.pfilter = PfilterFromString(szFilter);
	if (!sp.pfilter)
		return LDAP_PARAM_ERROR;
	sp.cAttrib = CAttrib(attrs);
	sp.rgszAttrib = attrs;
		
	hr = ld->plcli->HrSearch(&sp, &xid);
	FreePfilter(sp.pfilter);
	if (FAILED(hr))
		return LdapResFromHr(hr);
		
	hr = ld->plcli->HrGetSearchResponse(xid, TimeoutFromTimeval(timeout), &pobj);
	if (FAILED(hr))
		return LdapResFromHr(hr);
		
	*res = pobj;
	return LdapResFromHr(hr);
}

extern "C" DLLEXPORT int __cdecl
ldap_msgfree(LDAPMessage *res)
{
	POBJ pobj = res;
	
	return LdapResFromHr(HrFreePobjList(pobj));
}

extern "C" DLLEXPORT LDAPMessage * __cdecl
ldap_first_entry(LDAP *ld, LDAPMessage *res)
{
	ld->ld_errno = 0;
	return res;
}

extern "C" DLLEXPORT LDAPMessage * __cdecl
ldap_next_entry(LDAP *ld, LDAPMessage *entry)
{
	ld->ld_errno = 0;
	return (LDAPMessage *)((POBJ)entry->pobjNext);
}

extern "C" DLLEXPORT int __cdecl
ldap_count_entries(LDAP *ld, LDAPMessage *res)
{
	POBJ pobj = (POBJ)res;
	int i = 0;
	
	ld->ld_errno = 0;
	while (pobj)
		{
		i++;
		pobj = pobj->pobjNext;
		}
	return i;
}

extern "C" DLLEXPORT char * __cdecl
ldap_first_attribute(LDAP *ld, LDAPMessage *entry, void **ptr)
{
	POBJ pobj = (POBJ)entry;

	*ptr = (void *)(pobj->pattrFirst);
	ld->ld_errno = 0;
	return pobj->pattrFirst->szAttrib;
}

// NOTE!  minor change from rfc1823 API: the **ptr field below is just *ptr
// in rfc1823,but thats not a good idea, so i'm using **ptr here
// instead.
extern "C" DLLEXPORT char * __cdecl
ldap_next_attribute(LDAP *ld, LDAPMessage *entry, void **ptr)
{
	ld->ld_errno = 0;
	if (!(*ptr))
		return NULL;

	PATTR pattr = ((PATTR)*ptr)->pattrNext;
	*ptr = (void *)pattr;
	if (pattr)
		return pattr->szAttrib;
	else
		return NULL;
}

PATTR
PattrForAttr(POBJ pobj, char *szAttr)
{
	PATTR pattr = pobj->pattrFirst;

	while (pattr)
		{
		if (!lstrcmpi(pattr->szAttrib, szAttr))
			return pattr;
		pattr = pattr->pattrNext;
		}
		
	return NULL;
}

extern "C" DLLEXPORT char ** __cdecl
ldap_get_values(LDAP *ld, LDAPMessage *entry, char *attr)
{
	POBJ pobj = (POBJ)entry;
	PATTR pattr;
	int cval;
	char **rgsz;
	int isz = 0;
	PVAL pval;
	
	ld->ld_errno = 0;
	pattr = PattrForAttr(pobj, attr);
	if (!pattr)
		return NULL;

	cval = Cval(pattr);
	rgsz = new char *[cval + 1];
	if (!rgsz)
		return NULL;
	pval = pattr->pvalFirst;
	while (pval)
		{
		rgsz[isz++] = pval->szVal;
		pval = pval->pvalNext;
		}
	rgsz[isz] = NULL;

	return rgsz;
}

extern "C" DLLEXPORT struct berval ** __cdecl
ldap_get_values_len(LDAP *ld, LDAPMessage *entry, char *attr)
{
	POBJ pobj = (POBJ)entry;
	PATTR pattr;
	int cval;
	BERVAL **rgpberval;
	int iberval = 0;
	PVAL pval;
	
	ld->ld_errno = 0;
	pattr = PattrForAttr(pobj, attr);
	if (!pattr)
		return NULL;

	cval = Cval(pattr);
	rgpberval = new BERVAL *[cval + 1];
	if (!rgpberval)
		return NULL;
		
	pval = pattr->pvalFirst;
	while (pval)
		{
		rgpberval[iberval] = new BERVAL;
		if (!rgpberval[iberval])
			{
			while (--iberval >= 0)
				delete rgpberval[iberval];
			
			delete [] rgpberval;
			return NULL;
			}

		rgpberval[iberval]->bv_len = lstrlen(pval->szVal) + 1;
		rgpberval[iberval]->bv_val = pval->szVal;
		
		iberval++;
		pval = pval->pvalNext;
		}
	rgpberval[iberval] = NULL;

	return rgpberval;
}

extern "C" DLLEXPORT int __cdecl
ldap_count_values(char **vals)
{
	// mmm, reuse of poorly-named code
	return CAttrib(vals);
}

extern "C" DLLEXPORT int __cdecl
ldap_count_values_len(struct berval **vals)
{
	// mmm, reuse of poorly-named code
	return CAttrib((char **)vals);
}

extern "C" DLLEXPORT int __cdecl
ldap_value_free(char **vals)
{
	delete [] vals;
	return LDAP_SUCCESS;
}

extern "C" DLLEXPORT int __cdecl
ldap_value_free_len(struct berval **rgpberval)
{
	BERVAL **ppberval = rgpberval;

	while (*ppberval)
		{
		delete *ppberval;
		ppberval++;
		}
	delete [] rgpberval;
	return LDAP_SUCCESS;
}

extern "C" DLLEXPORT char * __cdecl
ldap_get_dn(LDAP *ld, LDAPMessage *entry)
{
	POBJ pobj = (POBJ)entry;
	char *szDN;
	
	ld->ld_errno = 0;
	szDN = new char[lstrlen(pobj->szDN) + 1];
	if (!szDN)
		{
		ld->ld_errno = LDAP_NO_MEMORY;
		return NULL;
		}

	StrCpyN(szDN, pobj->szDN, lstrlen(pobj->szDN) + 1);
	return szDN;
}

extern "C" DLLEXPORT void __cdecl
ldap_free_dn(char *dn)
{
	delete [] dn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\lclixd.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client Xaction Data class.
//
//	History:
//		davidsan	04/29/96	Created
//
//--------------------------------------------------------------------------------------------

#ifndef _LCLIXD_H
#define _LCLIXD_H

typedef struct _xactionbuffer
{
	struct _xactionbuffer	*pxbNext;
	BYTE					*pbData;
	int						cbData;
} XB, *PXB;

// transaction data
class CXactionData
{
public:
	CXactionData();
	~CXactionData();
	
	BOOL				FInit(XID xid, DWORD xtype);
	
	BOOL				FGetBuffer(BYTE **ppb, int *pcb);
	BOOL				FAddBuffer(BYTE *pb, int cb);

	BOOL				FHasData();

	// accessors:
	XID					Xid()						{return m_xid;};
	PXD					PxdNext()					{return m_pxdNext;};
	HANDLE				HsemSignal()				{return m_hsemSignal;};
	DWORD				Xtype()						{return m_xtype;};
	BOOL				FCancelled()				{return m_fCancelled;};
	BOOL				FOOM()						{return m_fOOM;};
	
	void				SetPxdNext(PXD pxdNext)		{m_pxdNext = pxdNext;};
	void				SetFOOM(BOOL fOOM)			{m_fOOM = fOOM;};
	void				SetFCancelled(BOOL fCan)	{m_fCancelled = fCan;};

private:
	void				DeletePxbChain(PXB pxb);

	CRITICAL_SECTION	m_cs;
	XID					m_xid;
	PXD					m_pxdNext;

	HANDLE				m_hsemSignal;
	DWORD				m_xtype;
	BOOL				m_fCancelled;
	BOOL				m_fOOM;
	PXB					m_pxb;
};

#endif // _LCLIXD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\ldapber.cxx ===
/*--------------------------------------------------------------------------
    ldapber.cxx

        This module contains the implementation for the LDAP Basic Encoding
		Rules (BER) class.  It is intended to be built for both client and
		server.

    Copyright (C) 1993 Microsoft Corporation
    All rights reserved.

    Authors:
        robertc     Rob Carney

    History:
        04-17-96	robertc     Created.
  --------------------------------------------------------------------------*/
#include "ldappch.h"

#ifdef CLIENT
#define ALLOCATE(cb) LocalAlloc(LMEM_FIXED, cb)
#define FREE LocalFree
#else
//CPool  CLdapBer::m_cpool(CLIENT_CONNECTION_SIGNATURE_VALID);
//#define Assert(x)	_ASSERT(x)
#define ALLOCATE(cb) malloc(cb)
#define FREE free
#endif


//
// CLdapBer Implementation
//
CLdapBer::CLdapBer()
{
	m_cbData	 = 0;
	m_cbDataMax	 = 0;
	m_pbData	 = NULL;
	m_iCurrPos	 = 0;
	m_cbSeq		 = 0;
	m_iSeqStart  = 0;
	m_fLocalCopy = TRUE;

	m_iCurrSeqStack = 0;
}


CLdapBer::~CLdapBer()
{
	Reset();

	if (m_pbData && m_fLocalCopy)
		FREE(m_pbData);
	m_cbDataMax	= 0;
}


/*!-------------------------------------------------------------------------
	CLdapBer::Reset
		Resets the class.
  ------------------------------------------------------------------------*/
void CLdapBer::Reset()
{
	m_cbData	= 0;
	m_iCurrPos	= 0;
	m_cbSeq		= 0;
	m_iSeqStart = 0;

	m_iCurrSeqStack = 0;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrLoadBer
		This routine loads the BER class from an input source data buffer
		that was received from the server.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrLoadBer(BYTE *pbSrc, ULONG cbSrc, BOOL fLocalCopy/*=TRUE*/)
{
	BYTE	*pbEnd;
	ULONG	iCurr, cbT;
	HRESULT	hr;

	Reset();

	if (!fLocalCopy)
	{
		// Just keep a reference so free any memory we once had.
		if (m_pbData && m_fLocalCopy)
		{
			FREE(m_pbData);
			m_pbData = NULL;
			m_cbDataMax	= 0;
		}

		m_pbData = pbSrc;
		m_fLocalCopy = FALSE;
	}
	else
	{
		m_fLocalCopy = TRUE;
	
		hr = HrEnsureBuffer(cbSrc, TRUE);
		if (FAILED(hr))
			return hr;
		
		CopyMemory(m_pbData, pbSrc, cbSrc);
	}

	m_cbData = cbSrc;

	//
	// Get at the sequence length and make sure we have all the data.
	HrSkipTag();
	GetCbLength(m_pbData + m_iCurrPos, &cbT);
	HrPeekLength(&m_cbSeq);
	if (m_cbSeq > (m_cbData - m_iCurrPos - cbT))
		return E_FAIL;

	HrUnSkipTag();

	m_cbSeq	= m_cbData;

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::FCheckSequenceLength
		This is a static function that checks to see if the input buffer
		contains the full length field.  If so, the length of the sequence
		is returned along with the position of the first value in the list.
  ------------------------------------------------------------------------*/
BOOL CLdapBer::FCheckSequenceLength(BYTE *pbInput, ULONG cbInput, ULONG *pcbSeq, ULONG *piValuePos)
{
	ULONG cbLen;

	// Assume Tag is 1 byte and length is at least 1 byte.
	if (cbInput >= 2)
	{
		GetCbLength(pbInput+1, &cbLen);
		if (cbInput >= (1 + cbLen))
		{
			*piValuePos = 1;
			if (SUCCEEDED(HrGetLength(pbInput, pcbSeq, piValuePos)))
				return TRUE;
		}
	}
	return FALSE;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrStartReadSequence
		Start a sequence for reading.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrStartReadSequence(ULONG ulTag/*=BER_SEQUENCE*/)
{
	HRESULT hr;
	ULONG	iPos, cbLength;

	if ((ULONG)m_pbData[m_iCurrPos] != ulTag)
	{
		return E_INVALIDARG;
	}
	m_iCurrPos++;			// Skip over the tag.

	GetCbLength(m_pbData + m_iCurrPos, &cbLength);	// Get the # bytes in the length field.

	hr = HrPushSeqStack(m_iCurrPos, cbLength, m_iSeqStart, m_cbSeq);

	if (SUCCEEDED(hr))
	{
		// Get the length of the sequence.
		hr = HrGetLength(&m_cbSeq);
		if (FAILED(hr))
			HrPopSeqStack(&iPos, &cbLength, &m_iSeqStart, &m_cbSeq);
		else
			m_iSeqStart = m_iCurrPos;	// Set to the first position in the sequence.
	}

	if (m_iCurrPos > m_cbData)
	{
		Assert(m_iCurrPos <= m_cbData);
		hr = E_INVALIDARG;
	}
	
	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrEndReadSequence
		Ends a read sequence and restores the current sequence counters.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrEndReadSequence()
{
	ULONG		cbSeq;
	ULONG		iPos, iPosSave, cbLength;
	SEQ_STACK	seqstack;
	HRESULT		hr;

	hr = HrPopSeqStack(&m_iCurrPos, &cbLength, &m_iSeqStart, &m_cbSeq);

	// Now position the current position to the end of the sequence.
	// m_iCurrPos is now pointing to the length field of the sequence.
	iPos = m_iCurrPos;

	if (SUCCEEDED(hr))
		{
		hr = HrGetLength(&cbSeq);
		if (SUCCEEDED(hr))
			{
			// Set the current position to the end of the sequence.
			m_iCurrPos = iPos + cbSeq + cbLength;	
			if (m_iCurrPos > m_cbData)
				hr = E_INVALIDARG;
			}
		}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrStartWriteSequence
		Start a sequence for writing.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrStartWriteSequence(ULONG ulTag/*=BER_SEQUENCE*/)
{
	HRESULT	hr;
	ULONG	cbLength = 3;	// BUGBUG: Defaults to 2 byte lengths

	if (FAILED(hr = HrEnsureBuffer(cbLength + 1)))
		return hr;

	m_pbData[m_iCurrPos++] = (BYTE)ulTag;

	hr = HrPushSeqStack(m_iCurrPos, cbLength, m_iSeqStart, m_cbSeq);

	m_iCurrPos += cbLength;	// Skip over length
	m_cbData = m_iCurrPos;

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrEndWriteSequence
		Ends a write sequence, by putting the sequence length field in.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrEndWriteSequence()
{
	HRESULT		hr;
	ULONG		cbSeq;
	ULONG		iPos, iPosSave, cbLength;
	SEQ_STACK	seqstack;

	hr = HrPopSeqStack(&iPos, &cbLength, &m_iSeqStart, &m_cbSeq);

	if (SUCCEEDED(hr))
	{
		// Get the length of the current sequence.
		cbSeq = m_iCurrPos - iPos - cbLength;
		
		// Save & set the current position.
		iPosSave = m_iCurrPos;
		m_iCurrPos = iPos;

		hr = HrSetLength(cbSeq, cbLength);
		m_iCurrPos = iPosSave;
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrPushSeqStack
		Pushes the current value on the sequence stack.  
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrPushSeqStack(ULONG iPos, ULONG cbLength, ULONG iParentSeqStart, ULONG cbParentSeq)
{
	ULONG	cb;

	Assert(m_iCurrSeqStack < MAX_BER_STACK);
	if (m_iCurrSeqStack >= MAX_BER_STACK)
		return E_OUTOFMEMORY;

	m_rgiSeqStack[m_iCurrSeqStack].iPos     = iPos;
	m_rgiSeqStack[m_iCurrSeqStack].cbLength = cbLength;
	m_rgiSeqStack[m_iCurrSeqStack].iParentSeqStart = iParentSeqStart;
	m_rgiSeqStack[m_iCurrSeqStack].cbParentSeq     = cbParentSeq;
	m_iCurrSeqStack++;

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrPopSeqStack
		Ends a read sequence.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrPopSeqStack(ULONG *piPos, ULONG *pcbLength, ULONG *piParentSeqStart, ULONG *pcbParentSeq)
{
	if (m_iCurrSeqStack == 0)
	{
		Assert(m_iCurrSeqStack != 0);
		return E_INVALIDARG;
	}

	--m_iCurrSeqStack;
	*piPos     = m_rgiSeqStack[m_iCurrSeqStack].iPos;
	*pcbLength = m_rgiSeqStack[m_iCurrSeqStack].cbLength;
	*piParentSeqStart = m_rgiSeqStack[m_iCurrSeqStack].iParentSeqStart;
	*pcbParentSeq     = m_rgiSeqStack[m_iCurrSeqStack].cbParentSeq;

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::FSetCurrPos
		Sets the current position to the input position index.
  ------------------------------------------------------------------------*/
HRESULT	CLdapBer::FSetCurrPos(ULONG iCurrPos)
{	
	if (iCurrPos >= m_cbData) 
		return E_FAIL;

	m_iCurrPos = iCurrPos;
	return NOERROR; 
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrSkipValue
		This routine skips over the current BER value.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrSkipValue()
{
	return E_NOTIMPL;
}

/*!-------------------------------------------------------------------------
	CLdapBer::HrSkipTag
		Skips over the current tag.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrSkipTag()
{
	m_iCurrPos++;

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrUnSkipTag
		Goes back to the tag given that we're currently at the length
		field.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrUnSkipTag()
{
	m_iCurrPos--;

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrPeekTag
		This routine gets the current tag, but doesn't increment the
		current position.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrPeekTag(ULONG *pulTag)
{
	ULONG	iPos;

	iPos = m_iCurrPos;

	*pulTag = (ULONG)m_pbData[iPos];

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrGetValue
		This routine gets an integer value from the current BER entry.  The
		default tag is an integer, but can Tagged with a different value
		via ulTag.  
		Returns: NOERROR, E_INVALIDARG, E_OUTOFMEMORY
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrGetValue(LONG *pi, ULONG ulTag/*=BER_INTEGER*/)
{
	HRESULT hr;
	ULONG	cb;
	ULONG	ul;

	ul = (ULONG)m_pbData[m_iCurrPos++];	// TAG

	if (ul != ulTag)
	{
		Assert(ul == ulTag);
		return E_INVALIDARG;
	}

	hr = HrGetLength(&cb);

	if (SUCCEEDED(hr) && (m_iCurrPos < m_cbData))
	{		 
		GetInt(m_pbData + m_iCurrPos, cb, pi);
		m_iCurrPos += cb;
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrGetValue
		This routine gets a string value from the current BER entry.  If
		the current BER entry isn't an integer type, then E_INVALIDARG is
		returned.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrGetValue(TCHAR *szValue, ULONG cbValue, ULONG ulTag/*=BER_OCTETSTRING*/)
{
	HRESULT	hr;
	ULONG	cb, ul;

	ul = (ULONG)m_pbData[m_iCurrPos++];	// TAG

	if (ul != ulTag)
	{
		Assert(ul == ulTag);
		return E_INVALIDARG;
	}

	hr = HrGetLength(&cb);

	szValue[0] = '\0';

	if (SUCCEEDED(hr) && (m_iCurrPos < m_cbData))
	{		 
		if (cb >= cbValue)
		{
			Assert(cb < cbValue);
			hr = E_INVALIDARG;
		}
		else
		{
			// Get the string.
			CopyMemory(szValue, m_pbData + m_iCurrPos, cb);
			szValue[cb] = '\0';
			m_iCurrPos += cb;
		}
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrGetBinaryValue
		This routine gets a binary value from the current BER entry.  If
		the current BER entry isn't the right type, then E_INVALIDARG is
		returned.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrGetBinaryValue(BYTE *pbBuf, ULONG cbBuf, ULONG ulTag/*=BER_OCTETSTRING*/)
{
	HRESULT	hr;
	ULONG	cb, ul;

	ul = (ULONG)m_pbData[m_iCurrPos++];	// TAG

	if (ul != ulTag)
	{
		Assert(ul == ulTag);
		return E_INVALIDARG;
	}

	hr = HrGetLength(&cb);

	if (SUCCEEDED(hr) && (m_iCurrPos < m_cbData))
	{		 
		if (cb >= cbBuf)
		{
			Assert(cb < cbBuf);
			hr = E_INVALIDARG;
		}
		else
		{
			// Get the string.
			CopyMemory(pbBuf, m_pbData + m_iCurrPos, cb);
			m_iCurrPos += cb;
		}
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrGetEnumValue
		This routine gets an enumerated value from the current BER entry.  If
		the current BER entry isn't an enumerated type, then E_INVALIDARG is
		returned.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrGetEnumValue(LONG *pi)
{
	HRESULT	hr;
	ULONG	cb;
	ULONG	cbLength;
	ULONG	ul;

	ul = (ULONG)m_pbData[m_iCurrPos++];	// TAG

	if (ul != BER_ENUMERATED)
	{
		Assert(ul == BER_ENUMERATED);
		return E_INVALIDARG;
	}

	hr = HrGetLength(&cb);

	if (SUCCEEDED(hr) && (m_iCurrPos < m_cbData))
	{		 
		GetInt(m_pbData + m_iCurrPos, cb, pi);
		m_iCurrPos += cb;
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrGetStringLength
		This routine gets the length of the current BER entry, which is
		assumed to be a string.  If the current BER entry's tag doesn't
		match ulTag, E_INVALIDARG is returned
  ------------------------------------------------------------------------*/
HRESULT
CLdapBer::HrGetStringLength(int *pcbValue, ULONG ulTag)
{
	ULONG	ul;
	ULONG	cbLength;
	int 	iCurrPosSave = m_iCurrPos;
	HRESULT	hr;

	ul = (ULONG)m_pbData[m_iCurrPos++];	// TAG

	if (ul != ulTag)
	{
		Assert(ul == ulTag);
		return E_INVALIDARG;
	}

	hr = HrGetLength((ULONG *)pcbValue);
	m_iCurrPos = iCurrPosSave;
	return hr;
}

/*!-------------------------------------------------------------------------
	CLdapBer::HrAddValue
		This routine puts an integer value in the BER buffer.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrAddValue(LONG i, ULONG ulTag/*=BER_INTEGER*/)
{
	HRESULT hr;
	LONG	iValue;
	ULONG	cbInt;
	DWORD	dwMask = 0xff000000;
	DWORD	dwHiBitMask = 0x80000000;
	
	if (i == 0)
	{
		cbInt = 1;
	}
	else
	{
		cbInt = sizeof(LONG);
		while (dwMask && !(i & dwMask))
		{
			dwHiBitMask >>= 8;
			dwMask >>= 8;
			cbInt--;
		}
		if (!(i & 0x80000000))
		{
			// It was a positive number so make sure we allow for upper most bit being set.
			// Make sure we send an extra byte since it's not a negative #.
			if (i & dwHiBitMask)
				cbInt++;
		}
	}

	hr = HrEnsureBuffer(1 + 3 + cbInt); // 1 for tag, 3 for length
	if (FAILED(hr))
		return hr;

	m_pbData[m_iCurrPos++] = (BYTE)ulTag;

	hr = HrSetLength(cbInt);
	if (SUCCEEDED(hr))
	{
		AddInt(m_pbData + m_iCurrPos, cbInt, i);

		m_iCurrPos += cbInt;

		m_cbData = m_iCurrPos;
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrAddValue
		Puts a string into the BER buffer.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrAddValue(const TCHAR *szValue, ULONG ulTag)
{
	HRESULT	hr;
	ULONG	cbValue = strlen(szValue);

	hr = HrEnsureBuffer(1 + 3 + cbValue); // 1 for tag, 3 for len
	if (FAILED(hr))
		return hr;

	m_pbData[m_iCurrPos++] = (BYTE)ulTag;

	hr = HrSetLength(cbValue);
	if (SUCCEEDED(hr))
	{
		CopyMemory(m_pbData + m_iCurrPos, szValue, cbValue);

		m_iCurrPos += cbValue;

		m_cbData = m_iCurrPos;
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrAddBinaryValue
		Puts a binary value into the BER buffer.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrAddBinaryValue(BYTE *pbValue, ULONG cbValue, ULONG ulTag)
{
	HRESULT	hr;

	hr = HrEnsureBuffer(1 + 3 + cbValue); // 1 for tag, 3 for len
	if (FAILED(hr))
		return hr;

	m_pbData[m_iCurrPos++] = (BYTE)ulTag;

	hr = HrSetLength(cbValue);
	if (SUCCEEDED(hr))
	{
		CopyMemory(m_pbData + m_iCurrPos, pbValue, cbValue);

		m_iCurrPos += cbValue;

		m_cbData = m_iCurrPos;
	}

	return hr;
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrSetLength
		Sets the length of cb to the current position in the BER buffer.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrSetLength(ULONG cb, ULONG cbLength/*=0xffffffff*/)
{
	// Short or long version of length ?
	if (((cb <= 0x7f) && (cbLength == 0xffffffff)) || (cbLength == 1))
	{
		m_pbData[m_iCurrPos++] = (BYTE)cb;
	}
	else if (((cb <= 0x7fff) && (cbLength == 0xffffffff)) || (cbLength == 3))
	{
		// Two byte length
		m_pbData[m_iCurrPos++] = 0x82;
		m_pbData[m_iCurrPos++] = (BYTE)((cb>>8) & 0x00ff);
		m_pbData[m_iCurrPos++] = (BYTE)(cb & 0x00ff);
	}
	else if (((cb < 0x7fffffff) && (cbLength == 0xffffffff)) || (cbLength == 5))
	{
		// Don't bother with 3 byte length, go directly to 4 byte.
		m_pbData[m_iCurrPos++] = 0x84;
		m_pbData[m_iCurrPos++] = (BYTE)((cb>>24) & 0x00ff);
		m_pbData[m_iCurrPos++] = (BYTE)((cb>>16) & 0x00ff);
		m_pbData[m_iCurrPos++] = (BYTE)((cb>>8) & 0x00ff);
		m_pbData[m_iCurrPos++] = (BYTE)(cb & 0x00ff);
	}
	else
	{
		Assert(cb < 0x7fffffff);
		return E_INVALIDARG;
	}

	return NOERROR;
}


/*!-------------------------------------------------------------------------
	CLdapBer::GetCbLength
		Gets the # of bytes required for the length field in the current
		position in the BER buffer.
  ------------------------------------------------------------------------*/
void CLdapBer::GetCbLength(BYTE *pbData, ULONG *pcbLength)
{
	ULONG	cbLength;
	ULONG	i, cb;

	// Short or long version of the length ?
	if (*pbData & 0x80)
	{
		*pcbLength = 1;
		*pcbLength += *pbData & 0x7f;
	}
	else 
	{
		// Short version of the length.
		*pcbLength = 1;
	}
}



/*!-------------------------------------------------------------------------
	CLdapBer::HrGetLength
		Gets the length from the current position in the BER buffer.  Only
		definite lengths are supported.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrGetLength(ULONG *pcb)
{
	return HrGetLength(m_pbData, pcb, &m_iCurrPos);
}



/*!-------------------------------------------------------------------------
	CLdapBer::HrPeekLength
		Gets the length from the current position in the BER buffer without
		incrementing the current pointer.
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrPeekLength(ULONG *pcb)
{
	ULONG iPos = m_iCurrPos;

	return HrGetLength(m_pbData, pcb, &iPos);
}



/*!-------------------------------------------------------------------------
	CLdapBer::HrGetLength
		This is a private function that gets the length given a current 
		input position. 
  ------------------------------------------------------------------------*/
HRESULT CLdapBer::HrGetLength(BYTE *pbData, ULONG *pcb, ULONG *piPos)
{
	ULONG	cbLength;
	ULONG	i, cb, iPos;

	iPos = *piPos;

	GetCbLength(pbData + iPos, &cbLength);

	// Short or long version of the length ?
	if (cbLength == 1)
	{
		cb = pbData[iPos++] & 0x7f;
	}
	else if (cbLength <= 5)
	{
		// Account for the overhead byte.cbLength field.
		cbLength--;	
		iPos++;

		cb = pbData[iPos++];
		for (i=1; i < cbLength; i++)
		{
			cb <<= 8;
			cb |= pbData[iPos++];
		}
	}
	else
	{
		// We don't support lengths > 2^32.
		Assert(cbLength <= 5);
		return E_INVALIDARG;
	}

	*piPos = iPos;
	*pcb   = cb;

	return NOERROR;
}



/*!-------------------------------------------------------------------------
	CLdapBer::GetInt
		Gets an integer from a BER buffer. 
  ------------------------------------------------------------------------*/
void CLdapBer::GetInt(BYTE *pbData, ULONG cbValue, LONG *plValue)
{
	ULONG	ulVal=0, ulTmp=0;
	ULONG	cbDiff;
	BOOL	fSign = FALSE;

	// We assume the tag & length have already been taken off and we're
	// at the value part.

	cbDiff = sizeof(LONG) - cbValue;
	// See if we need to sign extend;
	if ((cbDiff > 0) && (*pbData & 0x80))
		fSign = TRUE;

	while (cbValue > 0)
	{
		ulVal <<= 8;
		ulVal |= (ULONG)*pbData++;
		cbValue--;
	}

	// Sign extend if necessary.
	if (fSign)
	{
		*plValue = 0x80000000;
		*plValue >>= cbDiff * 8;
	}
	else
		*plValue = (LONG) ulVal;
}


/*!-------------------------------------------------------------------------
	CLdapBer::AddInt
		Adds an integer to the input pbData buffer.
  ------------------------------------------------------------------------*/
void CLdapBer::AddInt(BYTE *pbData, ULONG cbValue, LONG lValue)
{
	ULONG i;

	for (i=cbValue; i > 0; i--)
	{
		*pbData++ = (BYTE)(lValue >> ((i - 1) * 8)) & 0xff;
	}
}


/*!-------------------------------------------------------------------------
	CLdapBer::HrEnsureBuffer
		Ensures that we've got room to put cbNeeded more bytes into the buffer.
  ------------------------------------------------------------------------*/
HRESULT
CLdapBer::HrEnsureBuffer(ULONG cbNeeded, BOOL fExact)
{
	ULONG cbNew;
	BYTE *pbT;

	if (cbNeeded + m_cbData < m_cbDataMax)
		return NOERROR;

	Assert(m_fLocalCopy == TRUE);
	if (!m_fLocalCopy)
		return E_INVALIDARG;

	if (fExact)
		{
		cbNew = cbNeeded + m_cbData;
		}		
	else
		{
		if (cbNeeded > CB_DATA_GROW)
			cbNew = m_cbDataMax + cbNeeded;
		else
			cbNew = m_cbDataMax + CB_DATA_GROW;
		}
	pbT = (BYTE *)ALLOCATE(cbNew);
	if (!pbT)
		return E_OUTOFMEMORY;
	if (m_pbData)
		{
		CopyMemory(pbT, m_pbData, m_cbData);
		FREE(m_pbData);
		}
	m_pbData = pbT;
	m_cbDataMax = cbNew;
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\lclixd.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client Xaction Data class
//
//
//	History
//		davidsan	04-29-96	Created
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// INCLUDES
//
//--------------------------------------------------------------------------------------------
#include "ldappch.h"
#include "lclilist.h"
#include "lclixd.h"

//--------------------------------------------------------------------------------------------
//
// PROTOTYPES
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// GLOBALS
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// CLASSES
//
//--------------------------------------------------------------------------------------------

CXactionData::CXactionData()
{
	::InitializeCriticalSection(&m_cs);

	m_hsemSignal = NULL;
	m_pxb = NULL;
	m_xid = 0;
	m_xtype = xtypeNil;
	m_fCancelled = FALSE;
	m_fOOM = FALSE;
	m_pxdNext = NULL;
}

CXactionData::~CXactionData()
{
	::DeleteCriticalSection(&m_cs);

	if (m_hsemSignal)
		CloseHandle(m_hsemSignal);

	if (m_pxb)
		this->DeletePxbChain(m_pxb);
}

void
CXactionData::DeletePxbChain(PXB pxb)
{
	PXB pxbNext;

	while (pxb)
		{
		pxbNext = pxb->pxbNext;
		delete [] pxb->pbData;
		delete pxb;
		
		pxb = pxbNext;
		}
}

BOOL
CXactionData::FInit(XID xid, DWORD xtype)
{
	::EnterCriticalSection(&m_cs);
	m_xid = xid;
	m_xtype = xtype;
	m_hsemSignal = CreateSemaphore(NULL, 0, 64000, NULL);
	m_pxb = NULL;
	m_pxdNext = NULL;
	m_fCancelled = FALSE;
	m_fOOM = FALSE;
	
	::LeaveCriticalSection(&m_cs);
	return TRUE;
}

BOOL
CXactionData::FAddBuffer(BYTE *pb, int cb)
{
	BOOL fRet = FALSE;
	PXB pxb;
	PXB pxbPrev;

	::EnterCriticalSection(&m_cs);
	pxb = new XB;
	if (!pxb)
		goto LBail;
	pxb->pbData = new BYTE[cb];
	if (!pxb->pbData)
		{
		delete pxb;
		goto LBail;
		}
	pxb->cbData = cb;
	CopyMemory(pxb->pbData, pb, cb);
	pxb->pxbNext = NULL;
	fRet = TRUE;

	if (m_pxb)
		{
		pxbPrev = m_pxb;
		while (pxbPrev->pxbNext)
			pxbPrev = pxbPrev->pxbNext;
		pxbPrev->pxbNext = pxb;
		}
	else
		{
		m_pxb = pxb;
		}
LBail:
	::LeaveCriticalSection(&m_cs);
	return fRet;
}

BOOL
CXactionData::FGetBuffer(BYTE **ppb, int *pcb)
{
	BOOL fRet = FALSE;
	PXB pxb;
	
	::EnterCriticalSection(&m_cs);

	if (!m_pxb)
		{
		goto LBail;
		}

	if (!m_pxb->pbData)
		{
		goto LBail;
		}
	
	pxb = m_pxb;
	m_pxb = m_pxb->pxbNext;
	*ppb = pxb->pbData;
	*pcb = pxb->cbData;
	delete pxb;
	
	fRet = TRUE;
LBail:
	::LeaveCriticalSection(&m_cs);
	return fRet;
}

BOOL
CXactionData::FHasData()
{
	BOOL fRet;
	
	::EnterCriticalSection(&m_cs);
	fRet = m_pxb && m_pxb->pbData;
	::LeaveCriticalSection(&m_cs);
	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\ldap.h ===
/*--------------------------------------------------------------------------
    ldap.h
        
        Base LDAP protocol typedefs & defines.  
		Some basic comments:
			All tags are CCFTTTTT
				where	CC - Tag class (00=Universal, 01=Application wide, 
										10=Context-specific, 11=private use).
						F  - The form (0=Primitive, 1=Constructed)
					TTTTT  - The tag #.


    Copyright (C) 1994 Microsoft Corporation
    All rights reserved.

    Authors:
        robertc     Rob Carney

    History:
        04-02-96	robertc     Created.
  --------------------------------------------------------------------------*/
#ifndef _LDAP_H
#define _LDAP_H

#define	LDAP_VERSION		2

#define IPPORT_LDAP			389
#define IPPORT_LDAP_SECURE	390

// LDAP commands.  All tags are CCFTTTTT where
#define LDAP_BIND_CMD			0x60	// application + constructed.
#define LDAP_UNBIND_CMD			0x42	// application + primitive.
#define LDAP_SEARCH_CMD			0x63	// application + constructed.
#define	LDAP_MODIFY_CMD			0x66	// application + constructed.
#define LDAP_ADD_CMD			0x68	// application + constructed.
#define	LDAP_DELETE_CMD			0x4a	// application + primitive.
#define LDAP_MODRDN_CMD			0x6c	// application + constructed.
#define	LDAP_COMPARE_CMD		0x6e	// application + constructed.
#define	LDAP_ABANDON_CMD		0x50	// application + primitive.
#define LDAP_INVALID_CMD		0xff	

// Reponses/Results.
#define LDAP_BIND_RES			0x61	// application + constructed.
#define LDAP_SEARCH_ENTRY		0x64	// application + constructed.	Used if there were hits.
#define LDAP_SEARCH_RESULTCODE	0x65	// application + constructed.	Result sent if there were no hits.
#define LDAP_MODIFY_RES			0x67	// application + constructed.
#define LDAP_ADD_RES			0x69	// application + constructed.
#define LDAP_DELETE_RES			0x6b	// application + constructed.
#define LDAP_MODRDN_RES			0x6d	// application + constructed.
#define LDAP_COMPARE_RES		0x6f	// application + constructed.
#define LDAP_INVALID_RES		0xff	// application + constructed.

// Result Codes.
typedef enum {	
	LDAP_SUCCESS=0x00,				LDAP_OPERATIONS_ERROR=0x01,			LDAP_PROTOCOL_ERROR=0x02, 
	LDAP_TIMELIMIT_EXCEEDED=0x03,	LDAP_SIZELIMIT_EXCEEDED=0x04,		LDAP_COMPARE_FALSE=0x05,
	LDAP_COMPARE_TRUE=0x06,			LDAP_AUTH_METHOD_NOT_SUPPORTED=0x07,LDAP_STRONG_AUTH_REQUIRED=0x08,
	LDAP_NO_SUCH_ATTRIBUTE=0x10,	LDAP_UNDEFINED_TYPE=0x11,			LDAP_INAPPROPRIATE_MATCHING=0x12,
	LDAP_CONSTRAINT_VIOLATION=0x13,	LDAP_ATTRIBUTE_OR_VALUE_EXISTS=0x14,LDAP_INVALID_SYNTAX=0x15,
	LDAP_NO_SUCH_OBJECT=0x20,		LDAP_ALIAS_PROBLEM=0x21,			LDAP_INVALID_DN_SYNTAX=0x22,
	LDAP_IS_LEAF=0x23,				LDAP_ALIAS_DEREF_PROBLEM=0x24,		LDAP_INAPPROPRIATE_AUTH=0x30,
	LDAP_INVALID_CREDENTIALS=0x31,	LDAP_INSUFFICIENT_RIGHTS=0x32,		LDAP_BUSY=0x33,
	LDAP_UNAVAILABLE=0x34,			LDAP_UNWILLING_TO_PERFORM=0x35,		LDAP_LOOP_DETECT=0x36,
	LDAP_NAMING_VIOLATION=0x40,		LDAP_OBJECT_CLASS_VIOLATION=0x41,	LDAP_NOT_ALLOWED_ON_NONLEAF=0x42,
	LDAP_NOT_ALLOWED_ON_RDN=0x43,	LDAP_ALREADY_EXISTS=0x44,			LDAP_NO_OBJECT_CLASS_MODS=0x45,
	LDAP_RESULTS_TOO_LARGE=0x46,	LDAP_OTHER=0x50,					LDAP_SERVER_DOWN=0x51,
	LDAP_LOCAL_ERROR=0x52,			LDAP_ENCODING_ERROR=0x53,			LDAP_DECODING_ERROR=0x54,
	LDAP_TIMEOUT=0x55,				LDAP_AUTH_UNKNOWN=0x56,				LDAP_FILTER_ERROR=0x57,
	LDAP_USER_CANCELLED=0x58,		LDAP_PARAM_ERROR=0x59,				LDAP_NO_MEMORY=0x5a
} RETCODE;

// Bind request authorization types.
#define	BIND_NONE		0x00
#define BIND_SIMPLE		0x80		// context specific + primitive.
#define BIND_SIMPLE_C	0xa0		// context specific + contructed
#define BIND_KRBV41		0x81		// context specific + primitive.
#define BIND_KRBV42		0x82		// context specific + primitive.
#define BIND_SSPI_NEGOTIATE	0x8a	// context specific + primitive
#define BIND_SSPI_RESPONSE	0x8b	// context specific + primitive
#define BIND_KRBV4		0xff

//
// Filter types.
#define LDAP_FILTER_AND			0xa0	// context specific + constructed -	SET OF Filters.
#define LDAP_FILTER_OR			0xa1	// context specific + constructed -	SET OF Filters.
#define LDAP_FILTER_NOT			0xa2	// context specific + constructed - Filter
#define LDAP_FILTER_EQUALITY	0xa3	// context specific + constructed - AttributeValueAssertion.
#define LDAP_FILTER_SUBSTRINGS	0xa4	// context specific + constructed - SubstringFilter
#define LDAP_FILTER_GE			0xa5	// context specific + constructed - AttributeValueAssertion.
#define LDAP_FILTER_LE			0xa6	// context specific + constructed - AttributeValueAssertion.
#define LDAP_FILTER_PRESENT		0x87	// context specific + primitive   -	AttributeType.
#define LDAP_FILTER_APPROX		0xa8	// context specific + constructed -	AttributeValueAssertion.

//
// Scope of search.
#define LDAP_SCOPE_BASE			0x00
#define LDAP_SCOPE_ONELEVEL		0x01
#define LDAP_SCOPE_SUBTREE		0x02

//
// Alias dereferencing in searches.
#define LDAP_DEREF_NEVER		0x00
#define LDAP_DEREF_SEARCHING	0x01
#define LDAP_DEREF_FINDING		0x02
#define LDAP_DEREF_ALWAYS		0x03

//
// Substring filter choices
#define LDAP_SUBSTRING_INITIAL	0x80	// context specific + primitive   
#define LDAP_SUBSTRING_ANY		0x81	// context specific + primitive   
#define LDAP_SUBSTRING_FINAL	0x82	// context specific + primitive   

//
// Modify operations
#define LDAP_MODIFY_ADD			0x00
#define LDAP_MODIFY_DELETE		0x01
#define LDAP_MODIFY_REPLACE		0x02

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\ldapcli.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft LDAP Sockets implementation.
//		
//	Authors:
//
//		Umesh Madan
//		RobertC	4/17/96	Modified from CHATSOCK for LDAPCLI
//		davidsan	04-25-96	hacked to pieces and started over
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// INCLUDES
//
//--------------------------------------------------------------------------------------------
#include "ldappch.h"
#include "lclilist.h"
#include "lclixd.h"

//--------------------------------------------------------------------------------------------
//
// GLOBALS
//
//--------------------------------------------------------------------------------------------
XL g_xl; // transaction list.  limit one per process.

//--------------------------------------------------------------------------------------------
//
// PROTOTYPES
//
//--------------------------------------------------------------------------------------------
void ReceiveData(PVOID pvCookie, PVOID pv, int cb, int *pcbReceived);

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------

__declspec(dllexport) HRESULT
HrCreateLdapClient(int iVerLdap, int iVerInterface, PLCLI *pplcli)
{
	if (iVerLdap != LDAP_VER_CURRENT || iVerInterface != INTERFACE_VER_CURRENT)
		return LDAP_E_VERSION;

	*pplcli = new CLdapClient(iVerLdap);
	if (!*pplcli)
		return E_OUTOFMEMORY;

	return NOERROR;
}

__declspec(dllexport) HRESULT
HrFreePobjList(POBJ pobjList)
{
	PATTR pattr;
	PVAL pval;

	while (pobjList)
		{
		delete [] pobjList->szDN;
		pattr = pobjList->pattrFirst;
		while (pattr)
			{
			delete [] pattr->szAttrib;
			pval = pattr->pvalFirst;
			while (pval)
				{
				delete [] pval->szVal;
				pval = pval->pvalNext;
				}
			pattr = pattr->pattrNext;
			}
		
		pobjList = pobjList->pobjNext;
		}
	return NOERROR;
}

typedef struct _genericstruct
{
	struct _genericstruct *pgenNext;
} GEN, *PGEN;

void AddElemToList(void *pelem, void **ppelemList)
{
	PGEN pgen = (PGEN)pelem;
	PGEN *ppgenList = (PGEN *)ppelemList;
	PGEN pgenT;
	
	if (!*ppgenList)
		{
		*ppgenList = pgen;
		}
	else
		{
	 	pgenT = *ppgenList;
		while (pgenT->pgenNext)
			{
			pgenT = pgenT->pgenNext;
			}
		pgenT->pgenNext = pgen;
		}
}

//--------------------------------------------------------------------------------------------
//
// CLASSES
//
//--------------------------------------------------------------------------------------------

CLdapClient::CLdapClient(int iVerLdap)
{
	InitializeCriticalSection(&m_cs);
	InitializeCriticalSection(&m_csRef);

	m_cRef = 1;
	m_iVerLdap = iVerLdap;
	m_psock = NULL;
	m_fConnected = FALSE;
	
	m_fHasCred = FALSE;
	m_fHasCtxt = FALSE;
	
	// some idle asserts that i'll put here cuz i don't have any better
	// place:
	Assert(&(((PVAL)0)->pvalNext) == (PVAL)0);
	Assert(&(((PATTR)0)->pattrNext) == (PATTR)0);
	Assert(&(((POBJ)0)->pobjNext) == (POBJ)0);
}

CLdapClient::~CLdapClient(void)
{
	Assert(m_cRef == 0);

	delete m_psock;
	DeleteCriticalSection(&m_cs);
	DeleteCriticalSection(&m_csRef);
}

STDMETHODIMP
CLdapClient::QueryInterface(REFIID riid,LPVOID FAR *ppvObj)
{
	return E_NOTIMPL;
}

ULONG
CLdapClient::AddRef()
{
	ULONG cRefNew;

	::EnterCriticalSection(&m_csRef);
	cRefNew = ++m_cRef;
	::LeaveCriticalSection(&m_csRef);
	
	return cRefNew;
}

ULONG
CLdapClient::Release()
{
	ULONG cRefNew;

	::EnterCriticalSection(&m_csRef);
	cRefNew = --m_cRef;
	::LeaveCriticalSection(&m_csRef);
	
	if (!cRefNew)
		delete this;
	return cRefNew;
}

STDMETHODIMP
CLdapClient::HrConnect(char *szServer, USHORT usPort)
{
	HRESULT hr;

	StrCpyN(m_szServer, szServer, ARRAYSIZE(m_szServer));

	if (m_fConnected)
		return LDAP_E_ALREADYCONNECTED;

	::EnterCriticalSection(&m_cs);
	if (!m_psock)
		{
		m_psock = new SOCK;
		if (!m_psock)
			{
			hr = E_OUTOFMEMORY;
			goto LBail;
			}
		}
	hr = m_psock->HrConnect(::ReceiveData, (PVOID)this, szServer, usPort);
	if (FAILED(hr))
		goto LBail;

	m_fConnected = TRUE;
LBail:
	::LeaveCriticalSection(&m_cs);
	return hr;
}

// constructs and returns an int from the next cb bytes of pb.
DWORD
DwBer(BYTE *pb, int cb)
{
	int i;
	DWORD cbRet;

	cbRet = 0;
	for (i = 0; i < cb; i++)
		{
		cbRet <<= 8;
		cbRet |= pb[i];
		}
	return cbRet;
}

// decodes the length field at *pb, returning the length and setting *pcbLengthField.
HRESULT
HrCbBer(BYTE *pbData, int cbData, int *pcb, int *pcbLengthField)
{
	if (cbData < 1)
		return LDAP_E_NOTENOUGHDATA;
	if (*pbData & 0x80)
		{
		// bottom 7 bits of *pb are # of bytes to turn into a size.  let's us
		// just assume that we'll never have more than a 32-bit size indicator, mkey?
		*pcbLengthField = *pbData & 0x7f;
		if (cbData < *pcbLengthField + 1)
			return LDAP_E_NOTENOUGHDATA;
		*pcb = DwBer(&pbData[1], *pcbLengthField);
		(*pcbLengthField)++; // for the first byte
		}
	else
		{
		*pcbLengthField = 1;
		*pcb = (int)(DWORD)*pbData;
		}
	if (!*pcb)
		return LDAP_E_UNEXPECTEDDATA;
	return NOERROR;
}

// We can take advantage of certain features of LDAP to make assumptions
// about the data that we receive.  The main feature that's important for
// this is the fact that any data block we receive is nested at the outermost
// level with a SEQUENCE structure.  This means that any block we get in
// this routine should start with 0x30 followed by an encoded length field.
// We use this encoded length field to decide if we've received the entire
// data block or not.
void
CLdapClient::ReceiveData(PVOID pv, int cb, int *pcbReceived)
{
	BYTE *pb = (BYTE *)pv;
	int cbSeq;
	int cbMsgId;
	int cbLengthField;
	int i;
	int ibCur;
	XID xid;
	PXD pxd;

	Assert(cb > 0);

	Assert(BER_SEQUENCE == 0x30);
	Assert(BER_INTEGER == 0x02);
	if (pb[0] != BER_SEQUENCE)
		{
		// what should we be doing with this?  we've apparently
		// either received bogus data or gotten lost!  //$ TODO: remove the assert someday
		Assert(FALSE);
		*pcbReceived = 0;
		return;
		}

	if (FAILED(HrCbBer(&pb[1], cb, &cbSeq, &cbLengthField)))
		{
		*pcbReceived = 0;
		return;
		}
	if (cbSeq + cbLengthField + 1 > cb)
		{
		*pcbReceived = 0;
		return;
		}
	*pcbReceived = cbSeq + cbLengthField + 1;

	// process pb[2+cbLengthField..*pcbReceived].  first element of the overall
	// structure is a message id.  let's hope it's there...
	ibCur = 1 + cbLengthField;
	if (pb[ibCur++] != BER_INTEGER)
		{
		Assert(FALSE); //$ TODO: should remove this assert someday
		return;
		}
	// now a length
	if (FAILED(HrCbBer(&pb[ibCur], cb - ibCur, &cbMsgId, &cbLengthField)))
		return;

	ibCur += cbLengthField;

	// msg id is next bytes
	if (cbMsgId + ibCur >= cb)
		return;

	xid = DwBer(&pb[ibCur], cbMsgId);
	ibCur += cbMsgId;
	pxd = g_xl.PxdForXid(xid);
	
	// if we don't have an entry for this, assume it was cancelled or
	// something and just ignore this packet.
	if (!pxd)
		return;

	if (!pxd->FAddBuffer(&pb[ibCur], *pcbReceived - ibCur))
		{
		pxd->SetFOOM(TRUE);
		return;
		}

	ReleaseSemaphore(pxd->HsemSignal(), 1, NULL);
}

void
ReceiveData(PVOID pvCookie, PVOID pv, int cb, int *pcbReceived)
{
	CLdapClient *plcli = (CLdapClient *)pvCookie;
	
	plcli->ReceiveData(pv, cb, pcbReceived);
}

STDMETHODIMP
CLdapClient::HrDisconnect()
{
	if (!m_fConnected)
		{
		return LDAP_E_NOTCONNECTED;
		}
	m_fConnected = FALSE;
	return m_psock->HrDisconnect();
}

STDMETHODIMP
CLdapClient::HrIsConnected()
{
	return m_fConnected ? NOERROR : S_FALSE;
}

HRESULT
CLdapClient::HrSendBindMsg(XID xid, char *szDN, int iAuth, void *pv, int cb)
{
	LBER lber;
	HRESULT hr;
	
	// a BIND request looks like:
	//	[APPLICATION 0] (IMPLICIT) SEQUENCE {
	//		version (INTEGER)
	//		szDN (LDAPDN)
	//		authentication CHOICE {
	//			simple	[0] OCTET STRING
	//			[... other choices ...]
	//			}
	//		}
	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)xid));

	  VERIFY(lber.HrStartWriteSequence(LDAP_BIND_CMD));

		VERIFY(lber.HrAddValue((LONG)m_iVerLdap));
		VERIFY(lber.HrAddValue((const TCHAR *)szDN));

		VERIFY(lber.HrAddBinaryValue((BYTE *)pv, cb, iAuth));

	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());

LBail:
	return hr;
}

STDMETHODIMP
CLdapClient::HrBindSimple(char *szDN, char *szPass, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	
	pxd = g_xl.PxdNewXaction(xtypeBind);
	if (!pxd)
		return E_OUTOFMEMORY;

	hr = this->HrSendBindMsg(pxd->Xid(), szDN, BIND_SIMPLE, szPass, lstrlen(szPass));

	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

HRESULT
CLdapClient::HrWaitForPxd(PXD pxd, DWORD timeout, BOOL *pfDel)
{
	DWORD dwWait;
	HRESULT hr;
	
	*pfDel = FALSE;
	dwWait = WaitForSingleObject(pxd->HsemSignal(), timeout);
	switch (dwWait)
		{
		default:
			Assert(FALSE);
			// fall through
		case WAIT_FAILED:
			hr = LDAP_E_INVALIDXID;
			break;

		case WAIT_TIMEOUT:
			hr = LDAP_E_TIMEOUT;
			break;

		case WAIT_OBJECT_0:
			*pfDel = TRUE;
			if (pxd->FCancelled())
				{
				hr = LDAP_E_CANCELLED;
				}
			else if (pxd->FOOM())
				{
				hr = E_OUTOFMEMORY;
				}
			else
				{
				hr = NOERROR;
				}
			break;
		}
	return hr;
}

HRESULT
CLdapClient::HrGetSimpleResponse(XID xid, DWORD xtype, ULONG ulTagResult, DWORD timeout)
{
	PXD pxd;
	BYTE *pbData;
	int cbData;
	HRESULT hr = LDAP_E_UNEXPECTEDDATA;
	BOOL fDel;
	int cb;
	int cbSub;
	int cbLengthField;
	int ibCur;
	long lResult;
	ULONG ulTag;
	LBER lber;
	
	pxd = g_xl.PxdForXid(xid);
	if (!pxd)
		return LDAP_E_INVALIDXID;
	if (pxd->Xtype() != xtype)
		return LDAP_E_INVALIDXTYPE;
	if (pxd->FCancelled())
		return LDAP_E_CANCELLED;
	if (pxd->FOOM())
		return E_OUTOFMEMORY;

	if (pxd->FHasData())
		{
		fDel = TRUE;
		}
	else
		{
		hr = this->HrWaitForPxd(pxd, timeout, &fDel);
		if (FAILED(hr))
			goto LBail;
		}

	if (!pxd->FGetBuffer(&pbData, &cbData))
		{
		//$ what's the right error here?
		hr = LDAP_E_UNEXPECTEDDATA;
		goto LBail;
		}
	VERIFY(lber.HrLoadBer(pbData, cbData));

	VERIFY(lber.HrStartReadSequence(ulTagResult));
	  VERIFY(lber.HrPeekTag(&ulTag));
	  if (ulTag == BER_SEQUENCE)
		{
		Assert(FALSE); // i want to see if any server returns explicit sequences
		VERIFY(lber.HrStartReadSequence());
		}
	  VERIFY(lber.HrGetEnumValue(&lResult));
	  if (ulTag == BER_SEQUENCE)
	    {
	    VERIFY(lber.HrEndReadSequence());
		}
	VERIFY(lber.HrEndReadSequence());

	hr = this->HrFromLdapResult(lResult);

LBail:
	if (fDel)
		g_xl.RemovePxd(pxd);

	return hr;
}

STDMETHODIMP
CLdapClient::HrGetBindResponse(XID xid, DWORD timeout)
{
	return this->HrGetSimpleResponse(xid, xtypeBind, LDAP_BIND_RES, timeout);
}

STDMETHODIMP
CLdapClient::HrUnbind()
{
	PXD pxd;
	XID xid;
	HRESULT hr;
	LBER lber;

	pxd = g_xl.PxdNewXaction(xtypeUnbind);
	if (!pxd)
		return E_OUTOFMEMORY;
	xid = pxd->Xid();
	g_xl.RemovePxd(pxd); // don't need this, since there's no response

	// unbind:
	//	[APPLICATION 2] NULL
	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)xid));
	  VERIFY(lber.HrStartWriteSequence(LDAP_UNBIND_CMD));
		VERIFY(lber.HrAddValue((const TCHAR *)"", BER_NULL));
	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());

LBail:
	return hr;
}

HRESULT
CLdapClient::HrEncodeFilter(LBER *plber, PFILTER pfilter)
{
	HRESULT hr = E_OUTOFMEMORY;
	HRESULT hrSub;
	PFILTER pfilterT;

	switch (pfilter->type)
		{
		case LDAP_FILTER_AND:
		case LDAP_FILTER_OR:
			VERIFY(plber->HrStartWriteSequence(pfilter->type));
			  pfilterT = pfilter->pfilterSub;
			  while (pfilterT)
				{
				VERIFY(this->HrEncodeFilter(plber, pfilterT));
				pfilterT = pfilterT->pfilterNext;
				}
			VERIFY(plber->HrEndWriteSequence());
			break;

		case LDAP_FILTER_NOT:
			VERIFY(plber->HrStartWriteSequence(LDAP_FILTER_NOT));
			  VERIFY(this->HrEncodeFilter(plber, pfilter->pfilterSub));
			VERIFY(plber->HrEndWriteSequence());
			break;
			
		case LDAP_FILTER_GE:
		case LDAP_FILTER_LE:
		case LDAP_FILTER_APPROX:
		case LDAP_FILTER_EQUALITY:
			VERIFY(plber->HrStartWriteSequence(pfilter->type));
			  VERIFY(plber->HrAddValue(pfilter->ava.szAttrib));
			  VERIFY(plber->HrAddValue(pfilter->ava.szValue));
			VERIFY(plber->HrEndWriteSequence());
			break;
			
		case LDAP_FILTER_SUBSTRINGS:
			VERIFY(plber->HrStartWriteSequence(LDAP_FILTER_SUBSTRINGS));
			  VERIFY(plber->HrAddValue(pfilter->sub.szAttrib));
			  VERIFY(plber->HrStartWriteSequence());
				if (pfilter->sub.szInitial)
				  {
				  VERIFY(plber->HrAddValue(pfilter->sub.szInitial, 0 | BER_CLASS_CONTEXT_SPECIFIC));
				  }
				if (pfilter->sub.szAny)
				  {
				  VERIFY(plber->HrAddValue(pfilter->sub.szAny, 1 | BER_CLASS_CONTEXT_SPECIFIC));
				  }
				if (pfilter->sub.szFinal)
				  {
				  VERIFY(plber->HrAddValue(pfilter->sub.szFinal, 2 | BER_CLASS_CONTEXT_SPECIFIC));
				  }
			  VERIFY(plber->HrEndWriteSequence());
			VERIFY(plber->HrEndWriteSequence());
			break;
	
		case LDAP_FILTER_PRESENT:
			VERIFY(plber->HrAddValue(pfilter->szAttrib, LDAP_FILTER_PRESENT));
			break;
		}

	hr = NOERROR;
LBail:
	return hr;
}

STDMETHODIMP
CLdapClient::HrSearch(PSP psp, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	int i;
	
	pxd = g_xl.PxdNewXaction(xtypeSearch);
	if (!pxd)
		return E_OUTOFMEMORY;

	// a SEARCH request looks like:
	//	[APPLICATION 3] SEQUENCE {
	//		szDNBase (LDAPDN)
	//		scope {enum base==0, singlelevel==1, subtree=2}
	//		deref {enum never=0, derefsearch==1, derefbase==2, derefall==3}
	//		sizelimit (integer)
	//		timelimit (integer)
	//		attrsOnly (BOOLEAN)
	//		filter (complex type)
	//		sequence of attrtype

	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)pxd->Xid()));
	  VERIFY(lber.HrStartWriteSequence(LDAP_SEARCH_CMD));
		VERIFY(lber.HrAddValue((const TCHAR *)psp->szDNBase));
		VERIFY(lber.HrAddValue(psp->scope, BER_ENUMERATED));
		VERIFY(lber.HrAddValue(psp->deref, BER_ENUMERATED));
		VERIFY(lber.HrAddValue((LONG)psp->cRecordsMax));
		VERIFY(lber.HrAddValue((LONG)psp->cSecondsMax));
		VERIFY(lber.HrAddValue(psp->fAttrsOnly, BER_BOOLEAN));

		VERIFY(this->HrEncodeFilter(&lber, psp->pfilter));

		// attributes to return
		VERIFY(lber.HrStartWriteSequence());
		for (i = 0; i < psp->cAttrib; i++)
		  {
		  VERIFY(lber.HrAddValue((const TCHAR *)psp->rgszAttrib[i]));
		  }
		VERIFY(lber.HrEndWriteSequence());

	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());

	hr = m_psock->HrSend(lber.PbData(), lber.CbData());
LBail:
	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

STDMETHODIMP
CLdapClient::HrGetSearchResponse(XID xid, DWORD timeout, POBJ *ppobj)
{
	PXD pxd;
	BYTE *pbData;
	int cbData;
	HRESULT hr = LDAP_E_UNEXPECTEDDATA;
	BOOL fDel;
	int cb;
	int cbString;
	int cbSub;
	int cbLengthField;
	int ibCur;
	ULONG ulTag;
	long lResult;
	LBER lber;
	BOOL fGotAllData = FALSE;
	POBJ pobj;
	PATTR pattr;
	PVAL pval;
	
	*ppobj = NULL;
	pxd = g_xl.PxdForXid(xid);
	if (!pxd)
		return LDAP_E_INVALIDXID;
	if (pxd->Xtype() != xtypeSearch)
		return LDAP_E_INVALIDXTYPE;

	while (!fGotAllData)
		{
		if (pxd->FCancelled())
			return LDAP_E_CANCELLED;
		if (pxd->FOOM())
			return E_OUTOFMEMORY;

		hr = this->HrWaitForPxd(pxd, timeout, &fDel);
		if (FAILED(hr))
			goto LBail;

		if (!pxd->FGetBuffer(&pbData, &cbData))
			{
			//$ what's the right error here?
			hr = LDAP_E_UNEXPECTEDDATA;
			Assert(FALSE);
			goto LBail;
			}
		VERIFY(lber.HrLoadBer(pbData, cbData));
	
		hr = LDAP_E_UNEXPECTEDDATA;
		VERIFY(lber.HrPeekTag(&ulTag));
		if (ulTag == (LDAP_SEARCH_ENTRY | BER_FORM_CONSTRUCTED | BER_CLASS_APPLICATION))
			{
			VERIFY(lber.HrStartReadSequence(LDAP_SEARCH_ENTRY | BER_FORM_CONSTRUCTED | BER_CLASS_APPLICATION));
			  pobj = new OBJ;
			  pobj->pobjNext = NULL;
			  pobj->pattrFirst = NULL;
			  if (!pobj)
				{
				hr = E_OUTOFMEMORY;
				goto LBail;
				}
			  AddElemToList(pobj, (void **)ppobj);
			  
			  VERIFY(lber.HrGetStringLength(&cbString));
			  pobj->szDN = new char[cbString + 1];
			  if (!pobj->szDN)
				{
				hr = E_OUTOFMEMORY;
				goto LBail;
				}
			  VERIFY(lber.HrGetValue(pobj->szDN, cbString + 1));
			  VERIFY(lber.HrStartReadSequence());
			  while (!lber.FEndOfSequence())
				{
				VERIFY(lber.HrStartReadSequence());
				while (!lber.FEndOfSequence())
				  {
				  pattr = new ATTR;
				  pattr->pattrNext = NULL;
				  pattr->pvalFirst = NULL;
				  AddElemToList(pattr, (void **)&(pobj->pattrFirst));
				  VERIFY(lber.HrGetStringLength(&cbString));
				  pattr->szAttrib = new char[cbString + 1];
				  if (!pattr->szAttrib)
				  	{
					hr = E_OUTOFMEMORY;
					goto LBail;
					}
				  VERIFY(lber.HrGetValue(pattr->szAttrib, cbString + 1));
				  VERIFY(lber.HrStartReadSequence(BER_SET));
				  while (!lber.FEndOfSequence())
					{
					pval = new VAL;
					pval->pvalNext = NULL;
					AddElemToList(pval, (void **)&(pattr->pvalFirst));
					VERIFY(lber.HrGetStringLength(&cbString));
					pval->szVal = new char[cbString + 1];
					if (!pval->szVal)
					  {
					  hr = E_OUTOFMEMORY;
					  goto LBail;
					  }
					VERIFY(lber.HrGetValue(pval->szVal, cbString + 1));
					}
				  VERIFY(lber.HrEndReadSequence());
				  }
				VERIFY(lber.HrEndReadSequence());
				}
			  VERIFY(lber.HrEndReadSequence());
			VERIFY(lber.HrEndReadSequence());
			}
		else if (ulTag == (LDAP_SEARCH_RESULTCODE | BER_FORM_CONSTRUCTED | BER_CLASS_APPLICATION))
			{
			fGotAllData = TRUE;
			VERIFY(lber.HrStartReadSequence(LDAP_SEARCH_RESULTCODE | BER_FORM_CONSTRUCTED | BER_CLASS_APPLICATION));
			  VERIFY(lber.HrGetEnumValue(&lResult));
			VERIFY(lber.HrEndReadSequence());
			hr = this->HrFromLdapResult(lResult);
			}
		else
			{
			goto LBail;
			}
		} // while !fGotAllData
LBail:
	if (fDel)
		g_xl.RemovePxd(pxd);

	return hr;
}

// seq { type set {values}}
HRESULT
CLdapClient::HrEncodePattr(LBER *plber, PATTR pattr)
{
	HRESULT hr;
	PVAL pval;
	
	VERIFY(plber->HrStartWriteSequence());
	  VERIFY(plber->HrAddValue((TCHAR *)pattr->szAttrib));
	  VERIFY(plber->HrStartWriteSequence(BER_SET));
		pval = pattr->pvalFirst;
		while (pval)
		  {
		  VERIFY(plber->HrAddValue((TCHAR *)pval->szVal));
		  pval = pval->pvalNext;
		  }
	  VERIFY(plber->HrEndWriteSequence());
	VERIFY(plber->HrEndWriteSequence());
LBail:
	return hr;
}

// pmod is SEQ { op seq { type set {values}}}
HRESULT
CLdapClient::HrEncodePmod(LBER *plber, PMOD pmod)
{
	HRESULT hr;
	PATTR pattr;
	
	VERIFY(plber->HrStartWriteSequence());
	  VERIFY(plber->HrAddValue((long)pmod->modop, BER_ENUMERATED));
	  pattr = pmod->pattrFirst;
	  while (pattr)
		{
		VERIFY(this->HrEncodePattr(plber, pattr));
		pattr = pattr->pattrNext;
		}
	VERIFY(plber->HrEndWriteSequence());
LBail:
	return hr;
}

STDMETHODIMP
CLdapClient::HrModify(char *szDN, PMOD pmod, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	
	pxd = g_xl.PxdNewXaction(xtypeModify);
	if (!pxd)
		return E_OUTOFMEMORY;

	// a MODIFY request looks like:
	//	[APPLICATION 6] SEQUENCE {
	//		object (LDAPDN)
	//		SEQUENCE OF SEQUENCE {
	//			operation
	//			SEQUENCE {
	//				type
	//				SET OF values
	//			}
	//		}
	//	}

	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)pxd->Xid()));
	  VERIFY(lber.HrStartWriteSequence(LDAP_MODIFY_CMD));
		VERIFY(lber.HrAddValue((const TCHAR *)szDN));
		VERIFY(lber.HrStartWriteSequence());
		while (pmod)
		  {
		  VERIFY(this->HrEncodePmod(&lber, pmod));
		  pmod = pmod->pmodNext;
		  }
		VERIFY(lber.HrEndWriteSequence());
	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());
LBail:
	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

STDMETHODIMP
CLdapClient::HrGetModifyResponse(XID xid, DWORD timeout)
{
	return this->HrGetSimpleResponse(xid, xtypeModify, LDAP_MODIFY_RES, timeout);
}

STDMETHODIMP
CLdapClient::HrAdd(char *szDN, PATTR pattr, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	
	pxd = g_xl.PxdNewXaction(xtypeAdd);
	if (!pxd)
		return E_OUTOFMEMORY;

	// an ADD request looks like:
	//	[APPLICATION 8] SEQUENCE {
	//		object (LDAPDN)
	//		SEQUENCE OF SEQUENCE {
	//			type
	//			SET OF values
	//		}
	//	}

	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)pxd->Xid()));
	  VERIFY(lber.HrStartWriteSequence(LDAP_ADD_CMD));
		VERIFY(lber.HrAddValue((const TCHAR *)szDN));
		VERIFY(lber.HrStartWriteSequence());
		while (pattr)
		  {
		  VERIFY(this->HrEncodePattr(&lber, pattr));
		  pattr = pattr->pattrNext;
		  }
		VERIFY(lber.HrEndWriteSequence());
	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());
LBail:
	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

STDMETHODIMP
CLdapClient::HrGetAddResponse(XID xid, DWORD timeout)
{
	return this->HrGetSimpleResponse(xid, xtypeAdd, LDAP_ADD_RES, timeout);
}
	
STDMETHODIMP
CLdapClient::HrDelete(char *szDN, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	
	pxd = g_xl.PxdNewXaction(xtypeDelete);
	if (!pxd)
		return E_OUTOFMEMORY;

	// a DELETE request looks like:
	//	[APPLICATION 10] LDAPDN

	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)pxd->Xid()));
	  VERIFY(lber.HrAddValue((const TCHAR *)szDN, LDAP_DELETE_CMD));
	VERIFY(lber.HrEndWriteSequence());
	
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());
LBail:
	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

STDMETHODIMP
CLdapClient::HrGetDeleteResponse(XID xid, DWORD timeout)
{
	return this->HrGetSimpleResponse(xid, xtypeDelete, LDAP_DELETE_RES, timeout);
}

STDMETHODIMP
CLdapClient::HrModifyRDN(char *szDN, char *szNewRDN, BOOL fDeleteOldRDN, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	
	pxd = g_xl.PxdNewXaction(xtypeModifyRDN);
	if (!pxd)
		return E_OUTOFMEMORY;

	// a MODIFYRDN request looks like:
	//	[APPLICATION 12] SEQUENCE {
	//		object (LDAPDN)
	//		newrdn (RELATIVE LDAPDN)
	//		deleteoldrdn (BOOL)
	//	}

	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)pxd->Xid()));
	  VERIFY(lber.HrStartWriteSequence(LDAP_MODRDN_CMD));
		VERIFY(lber.HrAddValue((const TCHAR *)szDN));
		VERIFY(lber.HrAddValue((const TCHAR *)szNewRDN));
		VERIFY(lber.HrAddValue(fDeleteOldRDN, BER_BOOLEAN));
	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());
LBail:
	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

STDMETHODIMP
CLdapClient::HrGetModifyRDNResponse(XID xid, DWORD timeout)
{
	return this->HrGetSimpleResponse(xid, xtypeModifyRDN, LDAP_MODRDN_RES, timeout);
}

STDMETHODIMP
CLdapClient::HrCompare(char *szDN, char *szAttrib, char *szValue, PXID pxid)
{
	LBER lber;
	HRESULT hr;
	PXD pxd;
	
	pxd = g_xl.PxdNewXaction(xtypeCompare);
	if (!pxd)
		return E_OUTOFMEMORY;

	// a COMPARE request looks like:
	//	[APPLICATION 14] SEQUENCE {
	//		object (LDAPDN)
	//		AVA ava
	//	}

	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)pxd->Xid()));
	  VERIFY(lber.HrStartWriteSequence(LDAP_COMPARE_CMD));
		VERIFY(lber.HrAddValue((const TCHAR *)szDN));
		VERIFY(lber.HrStartWriteSequence());
		  VERIFY(lber.HrAddValue((const TCHAR *)szAttrib));
		  VERIFY(lber.HrAddValue((const TCHAR *)szValue));
		VERIFY(lber.HrEndWriteSequence());
	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());
LBail:
	if (FAILED(hr))
		return hr;

	*pxid = pxd->Xid();
	return NOERROR;
}

STDMETHODIMP
CLdapClient::HrGetCompareResponse(XID xid, DWORD timeout)
{
	return this->HrGetSimpleResponse(xid, xtypeCompare, LDAP_COMPARE_RES, timeout);
}

STDMETHODIMP
CLdapClient::HrCancelXid(XID xid)
{
	PXD pxd = g_xl.PxdForXid(xid);
	PXD pxdNew;
	XID xidNew;
	HRESULT hr;
	LBER lber;

	if (!pxd)
		return LDAP_E_INVALIDXID;
	pxdNew = g_xl.PxdNewXaction(xtypeAbandon);
	if (!pxdNew)
		return E_OUTOFMEMORY;
	xidNew = pxdNew->Xid();
	g_xl.RemovePxd(pxdNew); // don't need to keep this around

	// abandon:
	//	[APPLICATION 16] message id
	VERIFY(lber.HrStartWriteSequence());
	  VERIFY(lber.HrAddValue((LONG)xidNew));
	  VERIFY(lber.HrStartWriteSequence(LDAP_ABANDON_CMD));
		VERIFY(lber.HrAddValue((LONG)xid));
	  VERIFY(lber.HrEndWriteSequence());
	VERIFY(lber.HrEndWriteSequence());
	hr = m_psock->HrSend(lber.PbData(), lber.CbData());

LBail:
	pxd->SetFCancelled(TRUE);
	return hr;
}

//$ TODO: Map all LDAP results to HRESULTs
HRESULT
CLdapClient::HrFromLdapResult(int iResult)
{
	HRESULT hr;

	switch (iResult)
		{
		default:
			return E_FAIL;

		case LDAP_OPERATIONS_ERROR:
			return LDAP_E_OPERATIONS;
			
		case LDAP_PROTOCOL_ERROR:
			return LDAP_E_PROTOCOL;
			
		case LDAP_TIMELIMIT_EXCEEDED:
			return LDAP_S_TIMEEXCEEDED;
			
		case LDAP_SIZELIMIT_EXCEEDED:
			return LDAP_S_SIZEEXCEEDED;

		case LDAP_COMPARE_FALSE:
			return S_FALSE;

		case LDAP_COMPARE_TRUE:
			return NOERROR;
			
		case LDAP_AUTH_METHOD_NOT_SUPPORTED:
			return LDAP_E_AUTHMETHOD;
			
		case LDAP_STRONG_AUTH_REQUIRED:
			return LDAP_E_STRONGAUTHREQUIRED;
			
		case LDAP_NO_SUCH_ATTRIBUTE:
			return LDAP_E_NOSUCHATTRIBUTE;
			
		case LDAP_UNDEFINED_TYPE:
			return LDAP_E_UNDEFINEDTYPE;
		
		case LDAP_INAPPROPRIATE_MATCHING:
			return LDAP_E_MATCHING;
			
		case LDAP_CONSTRAINT_VIOLATION:
			return LDAP_E_CONSTRAINT;
			
		case LDAP_ATTRIBUTE_OR_VALUE_EXISTS:
			return LDAP_E_ATTRIBORVALEXISTS;
		
		case LDAP_INVALID_SYNTAX:
			return LDAP_E_SYNTAX;
		
		case LDAP_NO_SUCH_OBJECT:
			return LDAP_E_NOSUCHOBJECT;
		
		case LDAP_ALIAS_PROBLEM:
			return LDAP_E_ALIAS;
		
		case LDAP_INVALID_DN_SYNTAX:
			return LDAP_E_DNSYNTAX;

		case LDAP_IS_LEAF:
			return LDAP_E_ISLEAF;
			
		case LDAP_ALIAS_DEREF_PROBLEM:
			return LDAP_E_ALIASDEREF;
		
		case LDAP_INAPPROPRIATE_AUTH:
			return LDAP_E_AUTH;

		case LDAP_INVALID_CREDENTIALS:
			return LDAP_E_CREDENTIALS;
		
		case LDAP_INSUFFICIENT_RIGHTS:
			return LDAP_E_RIGHTS;
			
		case LDAP_BUSY:
			return LDAP_E_BUSY;
			
		case LDAP_UNAVAILABLE:
			return LDAP_E_UNAVAILABLE;
			
		case LDAP_UNWILLING_TO_PERFORM:
			return LDAP_E_UNWILLING;
			
		case LDAP_LOOP_DETECT:
			return LDAP_E_LOOP;
			
		case LDAP_NAMING_VIOLATION:
			return LDAP_E_NAMING;
			
		case LDAP_OBJECT_CLASS_VIOLATION:
			return LDAP_E_OBJECTCLASS;
			
		case LDAP_NOT_ALLOWED_ON_NONLEAF:
			return LDAP_E_NOTALLOWEDONNONLEAF;
			
		case LDAP_NOT_ALLOWED_ON_RDN:
			return LDAP_E_NOTALLOWEDONRDN;
			
		case LDAP_ALREADY_EXISTS:
			return LDAP_E_ALREADYEXISTS;
			
		case LDAP_NO_OBJECT_CLASS_MODS:
			return LDAP_E_NOOBJECTCLASSMODS;
			
		case LDAP_RESULTS_TOO_LARGE:
			return LDAP_E_RESULTSTOOLARGE;
		
		case LDAP_OTHER:
			return LDAP_E_OTHER;
		
		case LDAP_SERVER_DOWN:
			return LDAP_E_SERVERDOWN;
			
		case LDAP_LOCAL_ERROR:
			return LDAP_E_LOCAL;
			
		case LDAP_ENCODING_ERROR:
			return LDAP_E_ENCODING;
			
		case LDAP_DECODING_ERROR:
			return LDAP_E_DECODING;

		case LDAP_TIMEOUT:
			return LDAP_E_TIMEOUT;
			
		case LDAP_AUTH_UNKNOWN:
			return LDAP_E_AUTHUNKNOWN;
			
		case LDAP_FILTER_ERROR:
			return LDAP_E_FILTER;
			
		case LDAP_USER_CANCELLED:
			return LDAP_E_USERCANCELLED;

		case LDAP_PARAM_ERROR:
			return E_INVALIDARG;

		case LDAP_NO_MEMORY:
			return E_OUTOFMEMORY;

		case LDAP_SUCCESS:
			return NOERROR;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\ldapber.h ===
/*--------------------------------------------------------------------------
    ldapber.h
        
        CLdapBer Class:
            This class handles Basic Encode Rules (BER) processing for LDAP.
			The following BER restrictions are assumed.  
				1)  Definite form of length encoding only.
				2)  Primitive forms only are used.


  Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

    Authors:
        robertc     Rob Carney

    History:
        04-11-96    robertc     Created.
  --------------------------------------------------------------------------*/

#ifndef _LDAPBER_H
#define _LDAPBER_H

#if defined(DEBUG) && defined(INLINE)
#undef THIS_FILE
static char BASED_CODE_MODULE[] = "ldapber.h";
#define THIS_FILE LDAPBER_H
#endif

// Identifier masks.
#define	BER_TAG_MASK		0x1f
#define	BER_FORM_MASK		0x20
#define BER_CLASS_MASK		0xc0
#define GetBerTag(x)	(x & BER_TAG_MASK)
#define GetBerForm(x)	(x & BER_FORM_MASK)
#define GetBerClass(x)	(x & BER_CLASS_MASK)

// id classes
#define BER_FORM_CONSTRUCTED		0x20
#define BER_CLASS_APPLICATION		0x40	
#define BER_CLASS_CONTEXT_SPECIFIC	0x80
//
// Standard BER types.
#define BER_INVALID_TAG		0x00
#define BER_BOOLEAN			0x01
#define BER_INTEGER			0x02
#define	BER_BITSTRING		0x03
#define BER_OCTETSTRING		0x04
#define BER_NULL			0x05
#define	BER_ENUMERATED		0x0a
#define BER_SEQUENCE		0x30
#define BER_SET				0x31

#define CB_DATA_GROW		1024
#define MAX_BER_STACK		50		// max # of elements we can have in stack.

#define	MAX_ATTRIB_TYPE		40		// Max size of a AttributeType.

// The SEQ_STACK entry is used to keep state info when building up a sequence.
typedef struct
{
	ULONG	iPos;		// Current position in the BER buffer where the 
						// sequence length should go.
	ULONG	cbLength;	// # of bytes used for the length field.
	ULONG	iParentSeqStart;	// Starting position of the parent sequence.
	ULONG	cbParentSeq;		// # of bytes in the parent sequence.
} SEQ_STACK;


class CLdapBer;

typedef CLdapBer LBER;

class CLdapBer
{
    // FRIENDS ------------------------------------------------
private:    
    // INTERFACES ---------------------------------------------
    // DECLARE OBJECT TYPE (SERIAL/DYNAMIC/DYNACREATE) --------
public:
    // PUBLIC CONSTRUCTOR DESTRUCTOR --------------------------
	CLdapBer();
	~CLdapBer();

    // PUBLIC ACCESSORS ---------------------------------------
	BYTE	*PbData()	{ return m_pbData; }
	ULONG	CbData()	{ return m_cbData; }

	ULONG	CbSequence()	{ return m_cbSeq; }

    // PUBLIC FUNCTIONS ---------------------------------------
//#ifndef CLIENT
//	VOID *operator new (size_t cSize)		{ return m_cpool.Alloc(); }
//	VOID operator delete (VOID *pInstance)	{ m_cpool.Free(pInstance); }
//#endif

	void	Reset();

	// Loads the BER class from a buffer.
	HRESULT	HrLoadBer(BYTE *pbSrc, ULONG cbSrc, BOOL fLocalCopy=TRUE);

	// Function to make sure the input buffer has the full length field.
	static BOOL FCheckSequenceLength(BYTE *pbInput, ULONG cbInput, ULONG *pcbSeq, ULONG *piValuePos);

	// Read & Write sequence routines.
	HRESULT	HrStartReadSequence(ULONG ulTag=BER_SEQUENCE);
	HRESULT	HrEndReadSequence();
	HRESULT HrStartWriteSequence(ULONG ulTag=BER_SEQUENCE);
	HRESULT	HrEndWriteSequence();

	BOOL	FEndOfSequence()
				{	if ((m_iCurrPos - m_iSeqStart) >= m_cbSeq) return TRUE;
					 else return FALSE; }

	void	GetCurrPos(ULONG *piCurrPos)	{ *piCurrPos = m_iCurrPos; }
	HRESULT	FSetCurrPos(ULONG iCurrPos);

	HRESULT	HrSkipValue();
	HRESULT	HrSkipTag();
	HRESULT HrUnSkipTag();
	HRESULT	HrPeekTag(ULONG *pulTag);
	HRESULT	HrPeekLength(ULONG *pcb);
				  
	HRESULT	HrGetTag(ULONG *pulTag, ULONG ulTag=BER_INTEGER)
				{ return HrGetValue((LONG *)pulTag, ulTag); }
	HRESULT	HrGetValue(LONG *pi, ULONG ulTag=BER_INTEGER);
	HRESULT	HrGetValue(TCHAR *szValue, ULONG cbValue, ULONG ulTag=BER_OCTETSTRING);
	HRESULT	HrGetEnumValue(LONG *pi);
	HRESULT	HrGetStringLength(int *pcbValue, ULONG ulTag = BER_OCTETSTRING);
	HRESULT HrGetBinaryValue(BYTE *pbBuf, ULONG cbBuf, ULONG ulTag = BER_OCTETSTRING);

	HRESULT	HrAddValue(LONG i, ULONG ulTag=BER_INTEGER);
	HRESULT	HrAddValue(const TCHAR *szValue, ULONG ulTag = BER_OCTETSTRING);
	HRESULT	HrAddBinaryValue(BYTE *pbValue, ULONG cbValue, ULONG ulTag = BER_OCTETSTRING);

    // PUBLIC OVERRIDEABLES -----------------------------------
    // PUBLIC VARIABLES ---------------------------------------
//#ifndef CLIENT
//	static  CPool	m_cpool;
//#endif

    // PUBLIC DEBUG -------------------------------------------
protected:
    // PROTECTED CONSTRUCTOR DESTRUCTOR -----------------------
    // PROTECTED ACCESSORS ------------------------------------
    // PROTECTED FUNCTIONS ------------------------------------
    // PROTECTED OVERRIDEABLES --------------------------------
    // PROTECTED VARIABLES ------------------------------------
    // PROTECTED DEBUG ----------------------------------------
private:    
    // PRIVATE ACCESSORS --------------------------------------
    // PRIVATE FUNCTIONS --------------------------------------
	HRESULT		HrPushSeqStack(ULONG iPos, ULONG cbLength, 
								ULONG iParentSeqStart, ULONG cbParentSeq);
	HRESULT		HrPopSeqStack(ULONG *piPos, ULONG *pcbLength, 
								ULONG *piParentSeqStart, ULONG *pcbParentSeq);

	static void		GetCbLength(BYTE *pbData, ULONG *pcbLength);
	HRESULT		HrGetLength(ULONG *pcb);
	static HRESULT	HrGetLength(BYTE *pbData, ULONG *pcb, ULONG *piPos);

	void		GetInt(BYTE *pbData, ULONG cbValue, LONG *plValue);

	void		AddInt(BYTE *pbData, ULONG cbValue, LONG iValue);

	HRESULT		HrSetLength(ULONG cb, ULONG cbLength=0xffffffff);
	
	// if fExact is true, cbNeeded is exactly the amount of data we need.
	HRESULT		HrEnsureBuffer(ULONG cbNeeded, BOOL fExact = FALSE);
    // PRIVATE OVERRIDEABLES ----------------------------------
    // PRIVATE VARIABLES --------------------------------------
	ULONG		m_iCurrPos;		// Current position within the data buffer.
	ULONG		m_cbData;

	BOOL		m_fLocalCopy;	// TRUE to alloc space for a local copy, FALSE keeps a reference.
	ULONG		m_cbDataMax;	// Current total size of buffer
	BYTE		*m_pbData;

	ULONG		m_iCurrSeqStack;	// Curr position in the sequence stack.
	SEQ_STACK	m_rgiSeqStack[MAX_BER_STACK]; // Stack used for keeping track of sequences.

	ULONG		m_cbSeq;		// # of bytes in the current sequence.
	ULONG		m_iSeqStart;	// Starting position of the current sequence.
	union {
		BOOL	f;
		LONG	l;
		BYTE	*pb;
	} m_Value;

    // PRIVATE DEBUG ------------------------------------------
    // MESSAGE MAPS -------------------------------------------
};

#ifdef  INLINE
#endif // INLINE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\ldapclip.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client private header
//
//	History:
//		davidsan	05/08/96	Created
//
//--------------------------------------------------------------------------------------------

#ifndef _LDAPCLIP_H
#define _LDAPCLIP_H

// transaction type
const DWORD xtypeNil				= 0;
const DWORD xtypeBind				= 1;
const DWORD xtypeSearch				= 2;
const DWORD xtypeUnbind				= 3;
const DWORD xtypeAbandon			= 4;
const DWORD xtypeBindSSPINegotiate	= 5;
const DWORD xtypeBindSSPIResponse	= 6;
const DWORD xtypeModify				= 7;
const DWORD xtypeAdd				= 8;
const DWORD xtypeModifyRDN			= 9;
const DWORD xtypeCompare			= 10;
const DWORD xtypeDelete				= 11;

class CLdapClient : public ILdapClient
{
public:
	CLdapClient(int iVerLdap);
	~CLdapClient();
	
	STDMETHODIMP			QueryInterface(REFIID riid, LPVOID FAR *ppvObj);
	STDMETHODIMP_(ULONG)	AddRef(void);
	STDMETHODIMP_(ULONG)	Release(void);
	
	STDMETHODIMP			HrConnect(char *szServer, USHORT usPort);
	STDMETHODIMP			HrDisconnect(void);
	STDMETHODIMP			HrIsConnected(void);

	STDMETHODIMP			HrBindSimple(char *szDN, char *szPass, PXID pxid);
	STDMETHODIMP			HrGetBindResponse(XID xid, DWORD timeout);
	STDMETHODIMP			HrUnbind(void);

	STDMETHODIMP			HrBindSSPI(char *szDN, char *szUser, char *szPass, BOOL fPrompt, DWORD timeout);
	STDMETHODIMP			HrSendSSPINegotiate(char *szDN, char *szUser, char *szPass, BOOL fPrompt, PXID pxid);
	STDMETHODIMP			HrGetSSPIChallenge(XID xid, BYTE *pbBuf, int cbBuf, int *pcbChallenge, DWORD timeout);
	STDMETHODIMP			HrSendSSPIResponse(BYTE *pbChallenge, int cbChallenge, PXID pxid);

	STDMETHODIMP			HrSearch(PSP psp, PXID pxid);
	STDMETHODIMP			HrGetSearchResponse(XID xid, DWORD timeout, POBJ *ppobj);
	STDMETHODIMP			HrFreePobjList(POBJ pobj);
	
	STDMETHODIMP			HrModify(char *szDN, PMOD pmod, PXID pxid);
	STDMETHODIMP			HrGetModifyResponse(XID xid, DWORD timeout);
	
	STDMETHODIMP			HrAdd(char *szDN, PATTR pattr, PXID pxid);
	STDMETHODIMP			HrGetAddResponse(XID xid, DWORD timeout);
	
	STDMETHODIMP			HrDelete(char *szDN, PXID pxid);
	STDMETHODIMP			HrGetDeleteResponse(XID xid, DWORD timeout);

	STDMETHODIMP			HrModifyRDN(char *szDN, char *szNewRDN, BOOL fDeleteOldRDN, PXID pxid);
	STDMETHODIMP			HrGetModifyRDNResponse(XID xid, DWORD timeout);

	STDMETHODIMP			HrCompare(char *szDN, char *szAttrib, char *szValue, PXID pxid);
	STDMETHODIMP			HrGetCompareResponse(XID xid, DWORD timeout);

	STDMETHODIMP			HrCancelXid(XID xid);
	
protected:
	friend void ReceiveData(PVOID, PVOID, int, int *);
	void					ReceiveData(PVOID pv, int cb, int *pcbReceived);
	
private:
	HRESULT					HrEncodeFilter(LBER *plber, PFILTER pfilter);
	HRESULT					HrEncodePattr(LBER *plber, PATTR pattr);
	HRESULT					HrEncodePmod(LBER *plber, PMOD pmod);

	HRESULT					HrWaitForPxd(PXD pxd, DWORD timeout, BOOL *pfDel);
	
	HRESULT					HrGetSimpleResponse(XID xid, DWORD xtype, ULONG ulTagResult, DWORD timeout);
	HRESULT					HrFromLdapResult(int iResult);
	
	CRITICAL_SECTION		m_cs;
	CRITICAL_SECTION		m_csRef;
	
	PSOCK					m_psock;
	BOOL					m_fConnected;
	
	ULONG					m_cRef;
	int						m_iVerLdap;
	char					m_szServer[MAX_PATH];
	
	// SSPI stuff
	HRESULT					HrGetCredentials(char *szUser, char *szPass);
	HRESULT					HrSendBindMsg(XID xid, char *szDN, int iAuth, void *pv, int cb);
	CredHandle				m_hCred;
	CtxtHandle				m_hCtxt;
	BOOL					m_fHasCred;
	BOOL					m_fHasCtxt;
};

#define VERIFY(fncall)				\
	if (FAILED(hr = fncall))		\
		{							\
		Assert(FALSE);				\
		goto LBail;					\
		}				

#endif // _LDAPCLIP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\ldapcli.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft LDAP Client.
//
//		All Interfaces that are exposed to a CLIENT.
//
//	History
//
//		davidsan	04-24-96	Created.
//
//--------------------------------------------------------------------------------------------

// OVERVIEW:
// The LDAP Client DLL defines an interface, ILdapClient, and a set of structure types
// listed below.  The ILdapClient interface provides a set of methods for communicating
// with an LDAP-based directory service.  The general approach taken is that calling an
// ILdapClient method such as HrSearch() will return a transaction ID, or XID.  This XID
// can then be used in subsequent calls to wait for and retrieve the server's response;
// an example would be the HrGetSearchResponse() method, which takes an XID and returns
// the server's response to that search transaction.  The HrGet*Response() functions can
// also be used to check if the response is present by providing a timeout value of 0, which
// will return immediately with LDAP_E_TIMEOUT if the data is not yet present.

#ifndef _LDAPCLI_H
#define _LDAPCLI_H

//--------------------------------------------------------------------------------------------
//
// INCLUDES.
//
//--------------------------------------------------------------------------------------------
#include <windows.h>
#include <objbase.h>

#include <ldaperr.h>
#include <ldap.h>

//--------------------------------------------------------------------------------------------
//
// DECLARATIONS.
//
//--------------------------------------------------------------------------------------------

#define		LDAP_VER_CURRENT		2
#define		INTERFACE_VER_CURRENT	1

//--------------------------------------------------------------------------------------------
//
// TYPE DEFINITIONS.
//
//--------------------------------------------------------------------------------------------

// NOTE!  Make the 'Next' pointer be the first thing in all these linked-list structures!

// Attribute value.
typedef struct _attrval
{
	struct _attrval		*pvalNext;
	char				*szVal;
} VAL, *PVAL;

// Attribute.  Contains an attribute name (also called attribute type) followed by a set
// of attribute values.
typedef struct _attribute
{
	struct _attribute	*pattrNext;
	char				*szAttrib;
	PVAL				pvalFirst;
} ATTR, *PATTR;

// Database Object.  Consists of a DN which identifies the object, followed by a set of
// attributes.
typedef struct _object
{
	struct _object		*pobjNext;
	char				*szDN;
	PATTR				pattrFirst;
} OBJ, *POBJ;

// attribute value assertion
typedef struct _ava
{
	char	*szAttrib;
	char	*szValue;
} AVA, *PAVA;

// substrings filter.   this is less general than the ldap spec.  cope.
typedef struct _substrings
{
	char	*szAttrib;
	char	*szInitial;
	char	*szAny;
	char	*szFinal;
} SUB, *PSUB;

// search filter
typedef struct _filter
{
	struct _filter		*pfilterNext;	// for chaining in sets
	DWORD				type;
	union
		{
		struct _filter	*pfilterSub;
		AVA				ava;
		SUB				sub;
		char			*szAttrib;
		};
} FILTER, *PFILTER;

// search params
typedef struct _searchparms
{
	char		*szDNBase;
	DWORD	  	scope;
	DWORD		deref;
	int			cRecordsMax;
	int			cSecondsMax;
	BOOL		fAttrsOnly;
	PFILTER		pfilter;
	int			cAttrib;
	char		**rgszAttrib;
} SP, *PSP;

// modify params
typedef struct _modparms
{
	struct _modparms	*pmodNext;
	int					modop;
	PATTR				pattrFirst;
} MOD, *PMOD;

typedef DWORD XID, *PXID; // transaction ID

interface ILdapClient;
typedef interface ILdapClient LCLI, *PLCLI;

interface ICLdapClient;
typedef interface ICLdapClient CLCLI, *PCLCLI;

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS.
//
//--------------------------------------------------------------------------------------------
//
// To get an LDAP client interface call this.
//
#ifdef __cplusplus
extern "C" {
#endif

__declspec(dllexport) HRESULT __cdecl HrCreateLdapClient(int iVerLdap, int iVerInterface, PLCLI *pplcli);
__declspec(dllexport) HRESULT __cdecl HrCreateCLdapClient(int iVerLdap, int iVerInterface, PCLCLI *ppclcli);
__declspec(dllexport) HRESULT __cdecl HrFreePobjList(POBJ pobj);

#ifdef __cplusplus
}
#endif

//--------------------------------------------------------------------------------------------
//
// INTERFACES: Definitions.
//
//--------------------------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE ILdapClient

DECLARE_INTERFACE_(ILdapClient, IUnknown)
{
	// IUnknown:
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID FAR *ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG, Release)			(THIS) PURE;

	// ILdapClient	

	STDMETHOD(HrConnect)				(THIS_ CHAR *szServer, USHORT usPort) PURE;
	STDMETHOD(HrDisconnect)				(THIS) PURE;
	STDMETHOD(HrIsConnected)			(THIS) PURE;

	STDMETHOD(HrBindSimple)				(THIS_ char *szDN, char *szPass, PXID pxid) PURE;
	STDMETHOD(HrGetBindResponse)		(THIS_ XID xid, DWORD timeout) PURE;
	STDMETHOD(HrUnbind)					(THIS) PURE; // this doesn't return an XID because there's no response

	// this function is a synchronous wrapper around the SSPI bind gunk
	//$ TODO: Pass in SSPI Package name (or support NTLM some other way)
	STDMETHOD(HrBindSSPI)				(THIS_ char *szDN, char *szUser, char *szPass, BOOL fPrompt, DWORD timeout) PURE;
	STDMETHOD(HrSendSSPINegotiate)		(THIS_ char *szDN, char *szUser, char *szPass, BOOL fPrompt, PXID pxid) PURE;
	STDMETHOD(HrGetSSPIChallenge)		(THIS_ XID xid, BYTE *pbBuf, int cbBuf, int *pcbChallenge, DWORD timeout) PURE;
	STDMETHOD(HrSendSSPIResponse)		(THIS_ BYTE *pbChallenge, int cbChallenge, PXID pxid) PURE;

	STDMETHOD(HrSearch)					(THIS_ PSP psp, PXID pxid) PURE;
	STDMETHOD(HrGetSearchResponse)		(THIS_ XID xid, DWORD timeout, POBJ *ppobj) PURE;

	STDMETHOD(HrModify)					(THIS_ char *szDN, PMOD pmod, PXID pxid) PURE;
	STDMETHOD(HrGetModifyResponse)		(THIS_ XID xid, DWORD timeout) PURE;
	
	STDMETHOD(HrAdd)					(THIS_ char *szDN, PATTR pattr, PXID pxid) PURE;
	STDMETHOD(HrGetAddResponse)			(THIS_ XID xid, DWORD timeout) PURE;
	
	STDMETHOD(HrDelete)					(THIS_ char *szDN, PXID pxid) PURE;
	STDMETHOD(HrGetDeleteResponse)		(THIS_ XID xid, DWORD timeout) PURE;

	STDMETHOD(HrModifyRDN)				(THIS_ char *szDN, char *szNewRDN, BOOL fDeleteOldRDN, PXID pxid) PURE;
	STDMETHOD(HrGetModifyRDNResponse)	(THIS_ XID xid, DWORD timeout) PURE;

	STDMETHOD(HrCompare)				(THIS_ char *szDN, char *szAttrib, char *szValue, PXID pxid) PURE;
	STDMETHOD(HrGetCompareResponse)		(THIS_ XID xid, DWORD timeout) PURE;

	STDMETHOD(HrCancelXid)				(THIS_ XID xid) PURE;
};

#undef INTERFACE
#define INTERFACE ICLdapClient

DECLARE_INTERFACE_(ICLdapClient, IUnknown)
{
	// IUnknown:
	STDMETHOD(QueryInterface)			(THIS_ REFIID riid, LPVOID FAR *ppvObj) PURE;
	STDMETHOD_(ULONG, AddRef)			(THIS) PURE;
	STDMETHOD_(ULONG, Release)			(THIS) PURE;
	
	STDMETHOD(HrSetServerName)			(THIS_ char *szServer, USHORT usPort) PURE;
	STDMETHOD(HrSetServerIPAddr)		(THIS_ SOCKADDR_IN *psin) PURE;
	
	STDMETHOD(HrSearch)					(THIS_ PSP psp, PXID pxid) PURE;
	STDMETHOD(HrGetSearchResponse)		(THIS_ XID xid, DWORD timeout, POBJ *ppobj) PURE;
	STDMETHOD(HrCancelXid)				(THIS_ XID xid) PURE;
};

// RFC1823 stuff
typedef struct ldap
{
	// these are publically accessible fields.  this is how you control the parameters
	// of your search calls.
	int				ld_deref;
	int				ld_timelimit;
	int				ld_sizelimit;
	int				ld_errno;
	
	// these are not publically accessible fields.  pretend you didn't see them.
	ILdapClient		*plcli;
} LDAP;

typedef struct berval
{
	unsigned long	bv_len;
	char			*bv_val;
} BERVAL;

#define LDAP_AUTH_NONE		0
#define LDAP_AUTH_SIMPLE	1
#define LDAP_AUTH_KRBV41	2
#define LDAP_AUTH_KRBV42	3

typedef OBJ LDAPMessage;

#define DLLEXPORT __declspec(dllexport)

#ifdef __cplusplus
extern "C" {
#endif

DLLEXPORT LDAP * __cdecl ldap_open(char *hostname, int portno);
DLLEXPORT int __cdecl ldap_bind_s(LDAP *ld, char *dn, char *cred, int method);
DLLEXPORT int __cdecl ldap_unbind(LDAP *ld);
DLLEXPORT int __cdecl ldap_search_s(LDAP *ld, char *base, int scope, char *filter, char *attrs[], int attrsonly, LDAPMessage **res);
DLLEXPORT int __cdecl ldap_search_st(LDAP *ld, char *base, int scope, char *filter, char *attrs[], int attrsonly, struct timeval *timeout, LDAPMessage **res);
DLLEXPORT int __cdecl ldap_msgfree(LDAPMessage *res);

// result parsing stuff
DLLEXPORT LDAPMessage * __cdecl ldap_first_entry(LDAP *ld, LDAPMessage *res);
DLLEXPORT LDAPMessage * __cdecl ldap_next_entry(LDAP *ld, LDAPMessage *entry);
DLLEXPORT int __cdecl ldap_count_entries(LDAP *ld, LDAPMessage *res);

DLLEXPORT char * __cdecl ldap_first_attribute(LDAP *ld, LDAPMessage *entry, void **ptr);
DLLEXPORT char * __cdecl ldap_next_attribute(LDAP *ld, LDAPMessage *entry, void **ptr);

DLLEXPORT char ** __cdecl ldap_get_values(LDAP *ld, LDAPMessage *entry, char *attr);
DLLEXPORT struct berval ** __cdecl ldap_get_values_len(LDAP *ld, LDAPMessage *entry, char *attr);
DLLEXPORT int __cdecl ldap_count_values(char **vals);
DLLEXPORT int __cdecl ldap_count_values_len(struct berval **vals);
DLLEXPORT int __cdecl ldap_value_free(char **vals);
DLLEXPORT int __cdecl ldap_value_free_len(struct berval **vals);

DLLEXPORT char * __cdecl ldap_get_dn(LDAP *ld, LDAPMessage *entry);
DLLEXPORT void __cdecl ldap_free_dn(char *dn);

#ifdef __cplusplus
}
#endif

#endif // _LDAPCLI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\ldaperr.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft LDAP Client.
//		
//		Client error codes.
//
//	Authors:
//
//		Robert Carney
//		davidsan	04/23/96	converted to real HRESULTS
//
//--------------------------------------------------------------------------------------------

#ifndef _LDAPERR_H
#define _LDAPERR_H

//--------------------------------------------------------------------------------------------
//
// New HRESULTS for use with LDAP.  We use FACILITY_ITF rather than obtaining our own
// facility for the time being; this might change, but it probably won't.
//
//--------------------------------------------------------------------------------------------

#define LDAP_E_VERSION				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8000)
#define LDAP_E_NOTCONNECTED			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8001)
#define LDAP_E_SOCKETCLOSED			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8002)
#define LDAP_E_HOSTNOTFOUND			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8003)
#define LDAP_E_INVALIDSOCKET		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8004)
#define LDAP_E_CANTCONNECT			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8005)
#define LDAP_E_HOSTDROPPED			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8006)
#define LDAP_E_NODATA				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8007)
#define LDAP_E_CANTSEND				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8008)
#define LDAP_E_NOTLOGGEDON			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8009)
#define LDAP_E_NETWORKDOWN			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x800a)
#define LDAP_E_LOSTCONNECTION		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x800b)
#define LDAP_E_ALREADYCONNECTED		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x800c)
#define LDAP_E_INVALIDXID			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x800d)
#define LDAP_E_INVALIDXTYPE			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x800e)
#define LDAP_E_TIMEOUT				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x800f)
#define LDAP_E_CANCELLED			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8010)
#define LDAP_E_UNEXPECTEDDATA		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8011)
#define LDAP_E_NOTENOUGHDATA		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8012)
#define LDAP_E_AUTHNOTAVAIL			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8013)
#define LDAP_E_BUFFERTOOSMALL		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8014)
#define LDAP_E_OUTOFSEQUENCE		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8015)

#define LDAP_S_TIMEEXCEEDED			MAKE_SCODE(SEVERITY_SUCCESS,	FACILITY_ITF, 0x8016)
#define LDAP_S_SIZEEXCEEDED			MAKE_SCODE(SEVERITY_SUCCESS,	FACILITY_ITF, 0x8017)

#define LDAP_E_OPERATIONS			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8020)
#define LDAP_E_PROTOCOL				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8021)
#define LDAP_E_AUTHMETHOD			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8022)
#define LDAP_E_STRONGAUTHREQUIRED	MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8023)
#define LDAP_E_NOSUCHATTRIBUTE		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8024)
#define LDAP_E_UNDEFINEDTYPE		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8025)
#define LDAP_E_MATCHING				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8026)
#define LDAP_E_CONSTRAINT			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8027)
#define LDAP_E_ATTRIBORVALEXISTS	MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8028)
#define LDAP_E_SYNTAX				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8029)
#define LDAP_E_NOSUCHOBJECT			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x802a)
#define LDAP_E_ALIAS				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x802b)
#define LDAP_E_DNSYNTAX				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x802c)
#define LDAP_E_ISLEAF				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x802d)
#define LDAP_E_ALIASDEREF			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x802e)
#define LDAP_E_AUTH					MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x802f)
#define LDAP_E_CREDENTIALS			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8030)
#define LDAP_E_RIGHTS				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8031)
#define LDAP_E_BUSY					MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8032)
#define LDAP_E_UNAVAILABLE			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8033)
#define LDAP_E_UNWILLING			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8034)
#define LDAP_E_LOOP					MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8035)
#define LDAP_E_NAMING				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8036)
#define LDAP_E_OBJECTCLASS			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8037)
#define LDAP_E_NOTALLOWEDONNONLEAF	MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8038)
#define LDAP_E_NOTALLOWEDONRDN		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8039)
#define LDAP_E_ALREADYEXISTS		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x803a)
#define LDAP_E_NOOBJECTCLASSMODS	MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x803b)
#define LDAP_E_RESULTSTOOLARGE		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x803c)
#define LDAP_E_OTHER				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x803d)
#define LDAP_E_SERVERDOWN			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x803e)
#define LDAP_E_LOCAL				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x803f)
#define LDAP_E_ENCODING				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8040)
#define LDAP_E_DECODING				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8041)
#define LDAP_E_AUTHUNKNOWN			MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8042)
#define LDAP_E_FILTER				MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8043)
#define LDAP_E_USERCANCELLED		MAKE_SCODE(SEVERITY_ERROR, 		FACILITY_ITF, 0x8044)

#endif // _LDAPERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\ldapsspi.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft LDAP SSPI Support
//		
//	Authors:
//
//		davidsan	05/08/96	hacked to pieces and started over
//
//--------------------------------------------------------------------------------------------

#include "ldappch.h"
#include "ldapsspi.h"
#include "lclilist.h"
#include "lclixd.h"

HRESULT g_hrInitSSPI;
HINSTANCE g_hinstSecDll = NULL;
PSecurityFunctionTable g_ptblpfnSec;

//$ TODO: Possibly return more descriptive errors so clients know why SSPI
//$ isn't working
HRESULT
HrInitializeSSPI()
{
	char *szDll;
	OSVERSIONINFO ovi;
	INIT_SECURITY_INTERFACE pfnISI = NULL;
	
	if (g_ptblpfnSec)
		return NOERROR;

	Assert(!g_hinstSecDll);

	ovi.dwOSVersionInfoSize = sizeof(ovi);
	if (!GetVersionEx(&ovi))
		return E_FAIL;

	if (ovi.dwPlatformId == VER_PLATFORM_WIN32_NT)
		szDll = "security.dll";
	else if (ovi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
		szDll = "secur32.dll";
	else
		return E_FAIL;
		
	g_hinstSecDll = LoadLibrary(szDll);

	pfnISI = (INIT_SECURITY_INTERFACE)GetProcAddress(g_hinstSecDll, SECURITY_ENTRYPOINT);
	if (!pfnISI)
		{
LBail:
		FreeLibrary(g_hinstSecDll);
		g_hinstSecDll = NULL;
		return LDAP_E_AUTHNOTAVAIL;
		}
	g_ptblpfnSec = (*pfnISI)();
	if (!g_ptblpfnSec)
		goto LBail;
	return NOERROR;
}

HRESULT
HrTerminateSSPI()
{
	g_ptblpfnSec = NULL;
	if (g_hinstSecDll)
		FreeLibrary(g_hinstSecDll);
	g_hinstSecDll = NULL;

	return NOERROR;
}

HRESULT
CLdapClient::HrGetCredentials(char *szUser, char *szPass)
{
	HRESULT hr;
	SECURITY_STATUS stat;
	TimeStamp tsLifetime;
	SEC_WINNT_AUTH_IDENTITY authdata;
	
	if (FAILED(g_hrInitSSPI))
		return g_hrInitSSPI;

	Assert(g_ptblpfnSec);
	if (!g_ptblpfnSec)
		return LDAP_E_AUTHNOTAVAIL;

	::EnterCriticalSection(&m_cs);
	if (m_fHasCred)
		{
		::LeaveCriticalSection(&m_cs);
		return NOERROR;
		}

	if (szUser && szPass)
		{
		authdata.User = (BYTE *)szUser;
		authdata.UserLength = lstrlen(szUser);
		authdata.Password = (BYTE *)szPass;
		authdata.PasswordLength = lstrlen(szPass);
		authdata.Domain = (BYTE *)"";
		authdata.DomainLength = 0;
		authdata.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
		}

	stat =
		(*g_ptblpfnSec->AcquireCredentialsHandle)
			(NULL,
			 "MSN", //$ does this ever change?
			 SECPKG_CRED_OUTBOUND,
			 NULL,
			 ((szUser && szPass) ? &authdata : NULL),
			 NULL,
			 NULL,
			 &m_hCred,
			 &tsLifetime);
	if (stat == SEC_E_OK)
		{
		m_fHasCred = TRUE;
		hr = NOERROR;
		}
	else
		hr = LDAP_E_AUTHNOTAVAIL;

	::LeaveCriticalSection(&m_cs);
	return hr;
}

STDMETHODIMP
CLdapClient::HrSendSSPINegotiate(char *szDN, char *szUser, char *szPass, BOOL fPrompt, PXID pxid)
{
	HRESULT hr;
	SECURITY_STATUS stat;
	DWORD fContextAttrib;
	TimeStamp tsExpireTime;
	SecBufferDesc outSecDesc;
	SecBuffer outSecBuffer;
	DWORD grfReq = ISC_REQ_CONFIDENTIALITY | ISC_REQ_USE_SESSION_KEY;
	PXD pxd;
	BYTE rgb[512];

	pxd = g_xl.PxdNewXaction(xtypeBindSSPINegotiate);
	if (!pxd)
		return E_OUTOFMEMORY;

	if (FAILED(hr = this->HrGetCredentials(szUser, szPass)))
		return hr;

	outSecDesc.ulVersion = 0;
	outSecDesc.cBuffers = 1;
	outSecDesc.pBuffers = &outSecBuffer;
	outSecBuffer.cbBuffer = sizeof(rgb);
	outSecBuffer.BufferType = SECBUFFER_TOKEN;
	outSecBuffer.pvBuffer = rgb;
	
	if (szUser && szPass)
		grfReq |= ISC_REQ_USE_SUPPLIED_CREDS;
	else
		grfReq |= ISC_REQ_PROMPT_FOR_CREDS;

	stat =
		(*g_ptblpfnSec->InitializeSecurityContext)
			(&m_hCred,
			 NULL, // phCurrContext
			 NULL, // pszTargetName
			 grfReq,
			 0L,
			 SECURITY_NATIVE_DREP,
			 NULL,
			 0L,
			 &m_hCtxt,
			 &outSecDesc,
			 &fContextAttrib,
			 &tsExpireTime);

	if (FAILED(stat))
		{
		//$ TODO: determine what errors InitializeSecurityContext can return and
		//$ return appropriate errors to client
		return E_FAIL;
		}

	m_fHasCtxt = TRUE;
	hr = HrSendBindMsg(
						pxd->Xid(),
						szDN,
						BIND_SSPI_NEGOTIATE,
						outSecBuffer.pvBuffer,
						outSecBuffer.cbBuffer
					  );
	if (SUCCEEDED(hr))
		*pxid = pxd->Xid();
	return hr;
}

STDMETHODIMP
CLdapClient::HrGetSSPIChallenge(XID xid, BYTE *pbBuf, int cbBuf, int *pcbChallenge, DWORD timeout)
{
	PXD pxd;
	BOOL fDel;
	HRESULT hr = NOERROR;
	BYTE *pbData;
	int cbData;
	LBER lber;
	ULONG ulTag;
	LONG lResult;

	pxd = g_xl.PxdForXid(xid);
	if (!pxd)
		return LDAP_E_INVALIDXID;
	if (pxd->Xtype() != xtypeBindSSPINegotiate)
		return LDAP_E_INVALIDXTYPE;
	if (pxd->FCancelled())
		return LDAP_E_CANCELLED;
	if (pxd->FOOM())
		return E_OUTOFMEMORY;

	if (pxd->FHasData())
		fDel = TRUE;
	else
		{
		if (FAILED(hr = this->HrWaitForPxd(pxd, timeout, &fDel)))
			goto LBail;
		}
	if (!pxd->FGetBuffer(&pbData, &cbData))
		{
		//$ what's the right error here?
		hr = LDAP_E_UNEXPECTEDDATA;
		goto LBail;
		}
	VERIFY(lber.HrLoadBer(pbData, cbData));

	VERIFY(lber.HrStartReadSequence(LDAP_BIND_RES | BER_FORM_CONSTRUCTED | BER_CLASS_APPLICATION));
	  VERIFY(lber.HrPeekTag(&ulTag));
	  if (ulTag == BER_SEQUENCE)
		{
		Assert(FALSE); // i want to see if any server returns explicit sequences
		VERIFY(lber.HrStartReadSequence());
		}
	  VERIFY(lber.HrGetEnumValue(&lResult));
	  if (!lResult)
	  	{
		// we have 0 for success--the matchedDN field is the server's challenge.
		VERIFY(lber.HrGetStringLength(pcbChallenge));
		if (*pcbChallenge > cbBuf)
		  {
		  hr = LDAP_E_BUFFERTOOSMALL;
		  goto LBail;
		  }
		VERIFY(lber.HrGetBinaryValue(pbBuf, cbBuf));
		}
	  if (ulTag == BER_SEQUENCE)
	    {
	    VERIFY(lber.HrEndReadSequence());
		}
	VERIFY(lber.HrEndReadSequence());

	hr = this->HrFromLdapResult(lResult);

LBail:
	if (fDel)
		g_xl.RemovePxd(pxd);

	return hr;
}

STDMETHODIMP
CLdapClient::HrSendSSPIResponse(BYTE *pbChallenge, int cbChallenge, PXID pxid)
{
	HRESULT hr;
	SECURITY_STATUS stat;
	DWORD fContextAttrib;
	TimeStamp tsExpireTime;
	SecBufferDesc inSecDesc, outSecDesc;
	SecBuffer inSecBuffer, outSecBuffer;
	DWORD grfReq = ISC_REQ_CONFIDENTIALITY | ISC_REQ_USE_SESSION_KEY;
	PXD pxd;
	BYTE rgb[512];

	if (!m_fHasCtxt || !m_fHasCred)
		return LDAP_E_OUTOFSEQUENCE;

	pxd = g_xl.PxdNewXaction(xtypeBind);
	if (!pxd)
		return E_OUTOFMEMORY;

	inSecDesc.ulVersion = 0;
	inSecDesc.cBuffers = 1;
	inSecDesc.pBuffers = &inSecBuffer;
	
	inSecBuffer.cbBuffer = cbChallenge;
	inSecBuffer.BufferType = SECBUFFER_TOKEN;
	inSecBuffer.pvBuffer = (PVOID)pbChallenge;
	
	outSecDesc.ulVersion = 0;
	outSecDesc.cBuffers = 1;
	outSecDesc.pBuffers = &outSecBuffer;
	outSecBuffer.cbBuffer = sizeof(rgb);
	outSecBuffer.BufferType = SECBUFFER_TOKEN;
	outSecBuffer.pvBuffer = rgb;
	
	stat =
		(*g_ptblpfnSec->InitializeSecurityContext)
			(&m_hCred,
			 &m_hCtxt,
			 NULL, // pszTargetName
			 ISC_REQ_CONFIDENTIALITY | ISC_REQ_USE_SESSION_KEY,
			 0L,
			 SECURITY_NATIVE_DREP,
			 &inSecDesc,
			 0L,
			 &m_hCtxt,
			 &outSecDesc,
			 &fContextAttrib,
			 &tsExpireTime);

	if (FAILED(stat))
		{
		//$ TODO: determine what errors InitializeSecurityContext can return and
		//$ return appropriate errors to client
		return E_FAIL;
		}

	m_fHasCtxt = TRUE;
	hr = HrSendBindMsg(
						pxd->Xid(),
						"",
						BIND_SSPI_RESPONSE,
						outSecBuffer.pvBuffer,
						outSecBuffer.cbBuffer
					  );
	if (SUCCEEDED(hr))
		*pxid = pxd->Xid();
	return hr;
}

STDMETHODIMP
CLdapClient::HrBindSSPI(char *szDN, char *szUser, char *szPass, BOOL fPrompt, DWORD timeout)
{
	XID xid;
	HRESULT hr;
	BYTE rgb[512];
	int cbChallenge;
	
	if (FAILED(hr = this->HrSendSSPINegotiate(szDN, szUser, szPass, fPrompt, &xid)))
		return hr;
	if (FAILED(hr = this->HrGetSSPIChallenge(xid, rgb, sizeof(rgb), &cbChallenge, timeout)))
		return hr;
	if (FAILED(hr = this->HrSendSSPIResponse(rgb, cbChallenge, &xid)))
		return hr;
	
	return this->HrGetBindResponse(xid, timeout);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\ldapmain.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996-97
//
//	Description:
//
//		Microsoft Internet LDAP Client DLL.
//
//	Authors:
//
//		Umesh Madan 
//		RobertC	4/17/96	Modified for LDAPCLI
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// INCLUDES
//
//--------------------------------------------------------------------------------------------
#include "ldappch.h"
#include "ldapsspi.h"

//--------------------------------------------------------------------------------------------
//
// GLOBALS
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// PROTOTYPES
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------

extern "C" BOOL WINAPI DllMain(HINSTANCE hInstDLL, DWORD dwReason, LPVOID lpReserved)
{
	switch (dwReason)
	{
		case DLL_PROCESS_ATTACH:
			{
			if (!FInitSocketDLL())
				{
				return FALSE;
				}
			g_hrInitSSPI = HrInitializeSSPI();
			} break;
			
		case DLL_PROCESS_DETACH:
			FreeSocketDLL();
			HrTerminateSSPI();
			break;
			
		default:
			break;	
	}
		
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\ldapsspi.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client SSPI support
//
//	History:
//		davidsan	05/08/96	Created
//
//--------------------------------------------------------------------------------------------

#ifndef _LDAPSSPI_H
#define _LDAPSSPI_H

extern HRESULT g_hrInitSSPI;
extern HRESULT HrInitializeSSPI();
extern HRESULT HrTerminateSSPI();

#endif // _LDAPSSPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\lt.cpp ===
/*--------------------------------------------------------------------------
	lt.cpp
	
		ldap test

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

	Authors:
		davidsan	Dave Sanderman

	History:
		04/25/96	davidsan	Created.
  --------------------------------------------------------------------------*/

#include "lt.h"

PLCLI g_plcli = NULL;

BOOL
FInit()
{
	return TRUE;
}

BOOL
FConnect(char *szServer)
{
	HRESULT hr;
	XID xid;
	
	hr = HrCreateLdapClient(LDAP_VER_CURRENT, INTERFACE_VER_CURRENT, &g_plcli);
	if (FAILED(hr))
		{
		printf("HrCreateLdapClient returned %08X\n", hr);
		return FALSE;
		}
	hr = g_plcli->HrConnect(szServer, IPPORT_LDAP);
	if (FAILED(hr))
		{
		printf("HrConnect returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrBindSimple("cn=alex weinart, c=us", NULL, &xid);
	if (FAILED(hr))
		{
		printf("HrBindSimple returned %08X\n", hr);
		return FALSE;
		}
	hr = g_plcli->HrGetBindResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrBindSimple returned %08X\n", hr);
		return FALSE;
		}
	return TRUE;	
}

char *g_rgszAttrib[] = {"title", "sn", "objectClass", "krbName"};

BOOL
FSearch()
{
	HRESULT hr;
	XID xid;
	POBJ pobj;
	POBJ pobjT;
	PATTR pattr;
	PVAL pval;
	SP sp;
	FILTER filter;
	FILTER filterS1;
	FILTER filterS2;
	FILTER filterSS1;
	FILTER filterSS2;
	FILTER filterSS3;

#ifdef OLDSEARCH	
	filter.type = LDAP_FILTER_AND;
	filter.pfilterSub = &filterS1;

		filterS1.type = LDAP_FILTER_OR;
		filterS1.pfilterSub = &filterSS1;
		filterS1.pfilterNext = &filterS2;
	
			filterSS1.type = LDAP_FILTER_EQUALITY;
			filterSS1.ava.szAttrib = "cn";
			filterSS1.ava.szValue = "sander";
			filterSS1.pfilterNext = &filterSS2;

			filterSS2.type = LDAP_FILTER_EQUALITY;
			filterSS2.ava.szAttrib = "sn";
			filterSS2.ava.szValue = "sander";
			filterSS2.pfilterNext = &filterSS3;

			filterSS3.type = LDAP_FILTER_EQUALITY;
			filterSS3.ava.szAttrib = "uid";
			filterSS3.ava.szValue = "sander";
			filterSS3.pfilterNext = NULL;

		filterS2.type = LDAP_FILTER_EQUALITY;
		filterS2.ava.szAttrib = "objectClass";
		filterS2.ava.szValue = "Person";
		filterS2.pfilterNext = NULL;
	
#else
	filter.type = LDAP_FILTER_SUBSTRINGS;
	filter.sub.szAttrib = "cn";
	filter.sub.szInitial = "davidsan";
	filter.sub.szAny = NULL;
	filter.sub.szFinal = NULL;

//	filter.type = LDAP_FILTER_EQUALITY;
//	filter.ava.szAttrib = "cn";
//	filter.ava.szValue = "davidsan4";
#endif

	sp.szDNBase = "c=US";
	sp.scope = LDAP_SCOPE_SUBTREE;
	sp.deref = LDAP_DEREF_ALWAYS;
	sp.cRecordsMax = 0;
	sp.cSecondsMax = 0;
	sp.fAttrsOnly = FALSE;
	sp.pfilter = &filter;
	sp.cAttrib = 4;
	sp.rgszAttrib = g_rgszAttrib;
	hr = g_plcli->HrSearch(&sp, &xid);
	if (FAILED(hr))
		{
		printf("HrSearch returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetSearchResponse(xid, INFINITE, &pobj);
	if (FAILED(hr))
		{
		printf("HrGetSearchResponse returned %08X\n", hr);
		return FALSE;
		}
	pobjT = pobj;
	while (pobjT)
		{
		printf("OBJ: %s\n", pobjT->szDN);
		pattr = pobjT->pattrFirst;
		while (pattr)
			{
			printf("  ATTR: %s\n", pattr->szAttrib);
			pval = pattr->pvalFirst;
			while (pval)
				{
				printf("    VAL: %s\n", pval->szVal);
				pval = pval->pvalNext;
				}
			pattr = pattr->pattrNext;
			}
		pobjT = pobjT->pobjNext;
		}
	HrFreePobjList(pobj);
		
	return TRUE;
}

void
SetPattr(PATTR pattr, PATTR pattrNext, char *szAttrib, PVAL pval)
{
	pattr->pattrNext = pattrNext;
	pattr->szAttrib = szAttrib;
	pattr->pvalFirst = pval;
}

void
SetPval(PVAL pval, PVAL pvalNext, char *szVal)
{
	pval->pvalNext = pvalNext;
	pval->szVal = szVal;
}

BOOL
FTestOtherStuff()
{
	HRESULT hr;
	XID xid;
	
	hr = g_plcli->HrDelete("c=us, o=my pants, cn=davidsan", &xid);
	if (FAILED(hr))
		{
		printf("HrDelete returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetDeleteResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetDeleteResponse returned %08X\n", hr);
		}
		
	hr = g_plcli->HrDelete("alex", &xid);
	if (FAILED(hr))
		{
		printf("HrDelete returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetDeleteResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetDeleteResponse returned %08X\n", hr);
		}
		
	hr = g_plcli->HrCompare("c=us, cn=davidsan@microsoft.com", "URL", "ftp://ftp.netcom.com/pub/sa/sandmann", &xid);
	if (FAILED(hr))
		{
		printf("HrCompare returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetCompareResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetCompareResponse returned %08X\n", hr);
		}
		
	hr = g_plcli->HrModifyRDN("foo", "bar", TRUE, &xid);
	if (FAILED(hr))
		{
		printf("HrModifyRDN returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetModifyRDNResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetModifyRDNResponse returned %08X\n", hr);
		}

	hr = g_plcli->HrModifyRDN("c=us, cn=alex weinart", "bar", TRUE, &xid);
	if (FAILED(hr))
		{
		printf("HrModifyRDN returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetModifyRDNResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetModifyRDNResponse returned %08X\n", hr);
		}
		
	// test add:  add an obj with dn "c=us, cn=davidsan" and some other props
	ATTR attr1;
	VAL val1;
	ATTR attr2;
	VAL val2;
	ATTR attr3;
	VAL val3;
	
	SetPattr(&attr1, &attr2, "uid", &val1);
	SetPval(&val1, NULL, "davidsan");
	
	SetPattr(&attr2, &attr3, "sn", &val2);
	SetPval(&val2, NULL, "sanderman");
	
	SetPattr(&attr3, NULL, "st", &val3);
	SetPval(&val3, NULL, "wa");

	hr = g_plcli->HrAdd("c=us, cn=davidsan", &attr1, &xid);
	if (FAILED(hr))
		{
		printf("HrAdd returned %08X\n", hr);
		return FALSE;
		}

	hr = g_plcli->HrGetAddResponse(xid, INFINITE);
	if (FAILED(hr))
		{
		printf("HrGetAddResponse returned %08X\n", hr);
		}

	return TRUE;		
}

BOOL
FTerm()
{
	if (g_plcli)
		{
		g_plcli->HrUnbind();
		if (g_plcli->HrIsConnected() == NOERROR)
			g_plcli->HrDisconnect();
		g_plcli->Release();
		}
	return TRUE;
}

void
usage()
{
	printf("usage:	lt <server>\n");
	exit(1);
}

void __cdecl
main(int argc, char **argv)
{
	if (argc < 2)
		usage();

	if (!FInit())
		exit(1);

	if (!FConnect(argv[1]))
		exit(1);

	if (!FSearch())
		exit(1);
		
// 	FTestOtherStuff();

	FTerm();
	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\lt18.cpp ===
/*--------------------------------------------------------------------------
	lt18.cpp
	
		ldap rfc1823 test

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

	Authors:
		davidsan	Dave Sanderman

	History:
		06/17/96	davidsan	Created.
  --------------------------------------------------------------------------*/

#include "lt18.h"

LDAP *g_pldap = NULL;

BOOL
FInit()
{
	return TRUE;
}

BOOL
FConnect(char *szServer)
{
	int iRet;

	g_pldap = ldap_open(szServer, IPPORT_LDAP);
	if (!g_pldap)
		{
		printf("Couldn't ldap_open\n");
		return FALSE;
		}
	
	iRet = ldap_bind_s(g_pldap, "cn=alexwe@microsoft.com", "test", LDAP_AUTH_SIMPLE);
	if (iRet != LDAP_SUCCESS)
		{
		printf("Couldn't ldap_bind: %d\n", iRet);
		return FALSE;
		}

	return TRUE;	
}

char *g_rgszAttrib[] = {"title", "sn", "objectClass", "krbName", NULL};

BOOL
FSearch(char *szSearch)
{
	int iRet;
	struct timeval timeout;
	LDAPMessage *res;
	LDAPMessage *entry;
	void *pv;
	char **rgsz;
	char **psz;
	BERVAL **rgpberval;
	BERVAL **ppberval;

	g_pldap->ld_deref = LDAP_DEREF_ALWAYS;
	g_pldap->ld_sizelimit = 100;
	g_pldap->ld_timelimit = 0;
	
	timeout.tv_usec = 0;
	timeout.tv_sec = 60 * 60;
	
	iRet = ldap_search_st(g_pldap,
						  "c=us",
						  LDAP_SCOPE_SUBTREE,
						  szSearch,
						  g_rgszAttrib,
						  FALSE,
						  &timeout,
						  &res);
	if (iRet != LDAP_SUCCESS)
		{
		printf("Couldn't ldap_search_st: %d\n", iRet);
    	ldap_msgfree(res);
		return FALSE;
		}
		
	entry = ldap_first_entry(g_pldap, res);
	if (!entry)
		{
		printf("No first entry.\n");
    	ldap_msgfree(res);
		return FALSE;
		}
	while (entry)
		{
		char *szDN = ldap_get_dn(g_pldap, entry);
		printf("DN: %s\n", szDN);
		ldap_free_dn(szDN);
		
		char *szAttr = ldap_first_attribute(g_pldap, entry, &pv);
		while (szAttr)
			{
			printf("attr: %s\n", szAttr);
			
			rgsz = ldap_get_values(g_pldap, entry, szAttr);
			if (!rgsz)
				{
				printf("  no values!\n");
				}
			else
				{
				printf("  %d values:\n", ldap_count_values(rgsz));
				psz = rgsz;
				while (*psz)
					{
					printf("    val: %s\n", *psz);
					psz++;
					}
				ldap_value_free(rgsz);
				}
			
			rgpberval = ldap_get_values_len(g_pldap, entry, szAttr);
			if (!rgpberval)
				{
				printf("  no values_len!\n");
				}
			else
				{
				printf("  %d values_len:\n", ldap_count_values_len(rgpberval));
				ppberval = rgpberval;
				while (*ppberval)
					{
					printf("    val: %s (len %d)\n", (*ppberval)->bv_val, (*ppberval)->bv_len);
					ppberval++;
					}
				ldap_value_free_len(rgpberval);
				}

			szAttr = ldap_next_attribute(g_pldap, entry, &pv);
			}
		
		entry = ldap_next_entry(g_pldap, entry);
		}
		
	ldap_msgfree(res);

	return TRUE;
}

BOOL
FTerm()
{
	if (g_pldap)
		ldap_unbind(g_pldap);
	g_pldap = NULL;

	return TRUE;
}

void
usage()
{
	printf("usage:	lt18 <server> <search string>\n");
	exit(1);
}

void __cdecl
main(int argc, char **argv)
{
	if (argc < 3)
		usage();

	if (!FInit())
		exit(1);

	if (!FConnect(argv[1]))
		exit(1);

	if (!FSearch(argv[2]))
		exit(1);
		
	FTerm();
	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\lt18.h ===
/*--------------------------------------------------------------------------
	lt18.h

		Main header for lt18

    Copyright (C) 1996 Microsoft Corporation
    All rights reserved.

	Authors:
		davidsan	Dave Sanderman

	History:
		06/17/96	davidsan	Created.
  --------------------------------------------------------------------------*/

#include <windows.h>
#include <stdio.h>
#include <ldapcli.h>
#include <lclityp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\lwinsock.cpp ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client 
//
//
//	Authors:
//
//		Umesh Madan
//		Robert Carney	4/17/96	Created from ChatSock library.
//		davidsan	04-25-96	hacked into tiny bits for my own devious purposes
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// INCLUDES
//
//--------------------------------------------------------------------------------------------
#include "ldappch.h"

//--------------------------------------------------------------------------------------------
//
// PROTOTYPES
//
//--------------------------------------------------------------------------------------------
DWORD __stdcall DwReadThread(PVOID pvData);

//--------------------------------------------------------------------------------------------
//
// GLOBALS
//
//--------------------------------------------------------------------------------------------
BOOL g_fInitedWinsock = FALSE;

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------
BOOL FInitSocketDLL()
{
	WORD	wVer; 
	WSADATA wsaData; 
	int		err; 
	
	wVer = MAKEWORD(1, 1);	// use Winsock 1.1 
	if (WSAStartup(wVer, &wsaData))
		return FALSE;

    return TRUE; 
}

void FreeSocketDLL()
{
	WSACleanup();
}

//--------------------------------------------------------------------------------------------
//
// CLASSES
//
//--------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------
//
// CLdapWinsock
// 
// Wrapper that implements a socket based connection.
//
//--------------------------------------------------------------------------------------------

CLdapWinsock::CLdapWinsock()
{
	m_sc			= INVALID_SOCKET;
	m_pfnReceive	= NULL;
	m_pvCookie		= NULL;
	m_pbBuf			= NULL;
	m_cbBuf			= 0;
	m_cbBufMax		= 0;
	m_fConnected	= FALSE;
	m_hthread		= NULL;

	InitializeCriticalSection(&m_cs);
}

CLdapWinsock::~CLdapWinsock(void)
{
	if (m_pbBuf)
		delete [] m_pbBuf;
	DeleteCriticalSection(&m_cs);
}

//
// Open a connection the named server, and connect to the port 'usPort' (host byte order)
// Can block
//
STDMETHODIMP
CLdapWinsock::HrConnect(PFNRECEIVEDATA pfnReceive, PVOID pvCookie, CHAR *szServer, USHORT usPort)
{
	SOCKADDR_IN		sin;
	struct hostent	*phe;
	HRESULT			hr;
	
	if (!pfnReceive || !szServer || !usPort)
		return E_INVALIDARG;

	Assert(!m_pbBuf);
	if (!m_pbBuf)
		{
		m_cbBufMax = CBBUFFERGROW;
		m_pbBuf = new BYTE[m_cbBufMax];
		m_cbBuf = 0;
		if (!m_pbBuf)
			return E_OUTOFMEMORY;
		}
	FillMemory(&sin, 0, sizeof(sin));
	sin.sin_family = AF_INET;
	sin.sin_port = htons(usPort);
	
	if (szServer[0] >= '1' && szServer[0] <= '9')
		{
		sin.sin_addr.s_addr = inet_addr(szServer);
		if (sin.sin_addr.s_addr == INADDR_NONE)
			{
			delete [] m_pbBuf;
			m_pbBuf = NULL;
			return LDAP_E_HOSTNOTFOUND;
			}
		}
	else
		{
		phe = gethostbyname(szServer);
		if (!phe)
			{
			delete [] m_pbBuf;
			m_pbBuf = NULL;
			return LDAP_E_HOSTNOTFOUND;
			}
		CopyMemory(&sin.sin_addr, phe->h_addr, phe->h_length);
		}

	::EnterCriticalSection(&m_cs);
	if (m_fConnected)
		this->HrDisconnect();

	m_sc = socket(PF_INET, SOCK_STREAM, 0);
	if (m_sc < 0)
		{
		delete [] m_pbBuf;
		m_pbBuf = NULL;
		::LeaveCriticalSection(&m_cs);
		return LDAP_E_INVALIDSOCKET;
		}
	if (connect(m_sc, (struct sockaddr *)&sin, sizeof(sin)) < 0)
		{
		delete [] m_pbBuf;
		m_pbBuf = NULL;
		::LeaveCriticalSection(&m_cs);
		return LDAP_E_CANTCONNECT;
		}

	hr = this->HrCreateReadThread();
	if (SUCCEEDED(hr))
		m_fConnected = TRUE;
	else
		{
		delete [] m_pbBuf;
		m_pbBuf = NULL;
		}
	::LeaveCriticalSection(&m_cs);
	m_pfnReceive = pfnReceive;
	m_pvCookie = pvCookie;
	return hr;
}

STDMETHODIMP
CLdapWinsock::HrDisconnect()
{
	HRESULT hr = NOERROR;

	if (!m_fConnected)
		return NOERROR;

	::EnterCriticalSection(&m_cs);
	m_fConnected = FALSE;
	closesocket(m_sc);
	::LeaveCriticalSection(&m_cs);
	
	WaitForSingleObject(m_hthread, INFINITE);
	
	::EnterCriticalSection(&m_cs);
	delete [] m_pbBuf;
	m_cbBuf = 0;
	m_cbBufMax = 0;
	m_pbBuf = NULL;
	::LeaveCriticalSection(&m_cs);
	return hr;
}

HRESULT
CLdapWinsock::HrCreateReadThread()
{
	HRESULT	hr = NOERROR;

	::EnterCriticalSection(&m_cs);

	m_hthread =	::CreateThread(
							NULL,
							0,
							::DwReadThread,
							(LPVOID)this,
							0,
							&m_dwTid
							);
	if (!m_hthread)
		hr = E_OUTOFMEMORY;
	::LeaveCriticalSection(&m_cs);
	return hr;
}

//
// Write pvData out to the current socket/connection.
// can block
//
HRESULT
CLdapWinsock::HrSend(PVOID pv, int cb)
{
	HRESULT hr = NOERROR;

	if (!pv || cb <= 0)
		return E_INVALIDARG;

	if (send(m_sc, (const char *)pv, cb, 0) == SOCKET_ERROR)
		hr = this->HrLastWinsockError();

	return hr;
}

HRESULT
CLdapWinsock::HrGrowBuffer()
{
	BYTE *pb;
	Assert(m_cbBufMax == m_cbBuf);
	
	pb = new BYTE[m_cbBufMax + CBBUFFERGROW];
	if (!pb)
		return E_OUTOFMEMORY;
	CopyMemory(pb, m_pbBuf, m_cbBuf);
	delete [] m_pbBuf;
	m_pbBuf = pb;
	m_cbBufMax += CBBUFFERGROW;
	return NOERROR;
}

void
CLdapWinsock::Receive(PVOID pv, int cb, int *pcbReceived)
{
	if (m_pfnReceive)
		m_pfnReceive(m_pvCookie, pv, cb, pcbReceived);
}

//$ TODO: Find a way to pass memory errors back to the API
DWORD
CLdapWinsock::DwReadThread()
{
	int cbRead;
	int cbLeft;
	int cbReceived;

	while (1)
		{
		// at the beginning of this loop: any unprocessed data is in m_pbBuf[0..m_cbBuf].
		Assert(m_cbBuf <= m_cbBufMax);
		if (m_cbBuf == m_cbBufMax)
			{
			if (FAILED(this->HrGrowBuffer()))
				return 0xFFFFFFFF;
			}
		cbLeft = m_cbBufMax - m_cbBuf;
		
		cbRead = recv(m_sc, (LPSTR)&(m_pbBuf[m_cbBuf]), cbLeft, 0);
		if (cbRead == 0 || cbRead == SOCKET_ERROR)
			return 0;
			
		// note: i don't know why this is happening, but it is...
		if (cbRead < 0)
			return 0;
			
		m_cbBuf += cbRead;
		do
			{
			this->Receive(m_pbBuf, m_cbBuf, &cbReceived);
			if (cbReceived)
				{
				m_cbBuf -= cbReceived;
				CopyMemory(m_pbBuf, &m_pbBuf[cbReceived], m_cbBuf);
				}
			}
		while (cbReceived && m_cbBuf);
		}
}

HRESULT
CLdapWinsock::HrIsConnected(void)
{
	return m_fConnected ? NOERROR : S_FALSE;
}

//$ TODO: Are there other errors that i need to handle here?
HRESULT
CLdapWinsock::HrLastWinsockError()
{
	int		idErr;
	HRESULT	hr = E_FAIL;

	idErr = WSAGetLastError();
	switch (idErr)
		{
		default:
			break;
		
		case WSANOTINITIALISED:
			AssertSz(0,"socket not initialized!");
			hr = E_FAIL;
			break;
		
		case WSAENETDOWN:
			hr = LDAP_E_NETWORKDOWN;
			break;
		
		case WSAENETRESET:
			hr = LDAP_E_LOSTCONNECTION;
			break;

		case WSAENOTCONN:
			AssertSz(0,"Not connected!");
			hr = E_FAIL;
			break;

		case WSAESHUTDOWN:
			hr = LDAP_E_SOCKETCLOSED;
			break;
		
		case WSAECONNRESET:
			hr = LDAP_E_HOSTDROPPED;
			break;
		}
	
	return hr;
}

DWORD __stdcall DwReadThread(PVOID pvData)
{
	PSOCK psock = (PSOCK)pvData;
	
	Assert(pvData);

	return psock->DwReadThread();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cs.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\apitest\apitest.h ===
#define IDM_NEW                     1
#define IDM_OPEN                    2
#define IDM_SAVE                    3
#define IDM_SAVEAS                  4
#define IDM_EXIT                    5

#define IDM_UNDO                    10
#define IDM_CUT                     11
#define IDM_COPY                    12
#define IDM_PASTE                   13
#define IDM_DEL                     14

#define IDM_WHITE                   20
#define IDM_LTGRAY                  21
#define IDM_GRAY                    22
#define IDM_DKGRAY                  23
#define IDM_BLACK                   24

#define IDM_START                   30
#define IDM_STOP                    31

#define IDM_HELP                    40
#define IDM_ABOUT                   41

#define IDM_ALLOCATE                1001
#define IDM_IPROP                   1002
#define IDM_WABOPEN                 1003
#define IDM_CREATE_ENTRY            1004
#define IDM_RESOLVE_NAME            1005
#define IDM_ADDRESS                 1006
#define IDM_ADDRESS_PICK_USER       1007
#define IDM_CONTENTS_TABLE          1008
#define IDM_DELETE_ENTRIES          1009
#define IDM_ADDRESS_BROWSE_ONLY     1010
#define IDM_RESOLVE_NAMES           1011
#define IDM_DETAILS                 1012
#define IDM_DETAILS_ONE_OFF         1013
#define IDM_ADDRESS_WELLS0          1014
#define IDM_ADDRESS_WELLS1          1015
#define IDM_ADDRESS_WELLS2          1016
#define IDM_ADDRESS_WELLS3          1017
#define IDM_ADDRESS_DEFAULT         1018
#define IDM_CREATE_DL               1019
#define IDM_ADDRESS_BROWSE_MODAL_ONLY 1020
#define IDM_ROOT_CONTAINER          1023
#define IDM_NOTIFICATIONS           1024
#define IDM_GETSEARCHPATH           1025
#define IDM_GETME                   1035
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\apitest\instring.c ===
#include <windows.h>
#include "instring.h"


typedef struct _STRING_BUFFER {
    ULONG cbBuffer;
    LPTSTR lpBuffer;
    LPTSTR lpPrompt;
    LPTSTR lpTitle;
} STRING_BUFFER, *LPSTRING_BUFFER;

INT_PTR CALLBACK InputStringDlgProc(HWND hDlg, WORD message, WORD wParam, LONG lParam) {
    static LPSTRING_BUFFER lpBuffer = NULL;
    USHORT cchString;

    switch (message) {
        case WM_INITDIALOG:
            // DialogBoxParam passes in pointer to buffer description.
            lpBuffer = (LPSTRING_BUFFER)lParam;

            if (lpBuffer->lpPrompt) {
                SetDlgItemText(hDlg, IDD_INPUT_STRING_PROMPT, lpBuffer->lpPrompt);
            }

            if (lpBuffer->lpTitle) {
                SetWindowText(hDlg, lpBuffer->lpTitle);
            }

            SendDlgItemMessage(hDlg,
              IDD_INPUT_STRING,
              EM_LIMITTEXT,
              (WPARAM)(lpBuffer->cbBuffer - 1), // text length, in characters (leave room for null)
              0);                               // not used; must be zero

            return(TRUE);

        case WM_COMMAND:
            switch (wParam) {
                case IDOK:
                    // Get number of characters.
                    cchString = (WORD)SendDlgItemMessage(hDlg,
                      IDD_INPUT_STRING,
                      EM_LINELENGTH,
                      (WPARAM) 0,
                      (LPARAM) 0);

                    if (cchString == 0) {
                        *(lpBuffer->lpBuffer) = '\0';
                        EndDialog(hDlg, TRUE);
                        lpBuffer->cbBuffer = 0;
                        return FALSE;
                    }

                    // Put the number of characters into first word
                    // of buffer.
                    *((USHORT*)lpBuffer->lpBuffer) = cchString;
                    lpBuffer->cbBuffer = cchString;

                    // Get the characters.
                    SendDlgItemMessage(hDlg,
                      IDD_INPUT_STRING,
                      EM_GETLINE,
                      (WPARAM)0,        // line 0
                      (LPARAM)lpBuffer->lpBuffer);

                    // Null-terminate the string.
                    lpBuffer->lpBuffer[cchString] = 0;
                    lpBuffer = NULL;    // prevent reuse of buffer
                    EndDialog(hDlg, 0);
                    return(TRUE);
            }
            break;

        default:
            return(FALSE);
    }
    return(TRUE);
}

/***************************************************************************

    Name      : InputString

    Purpose   : Brings up a dialog requesting string input

    Parameters: hInstance = hInstance of app
                hwnd = hwnd of parent window
                lpszTitle = Dialog box title
                lpszPrompt = Text in dialog box
                lpBuffer = buffer to fill
                cchBuffer = size of buffer

    Returns   : return ULONG number of characters entered (not including terminating
                NULL)

    Comment   :

***************************************************************************/
ULONG InputString(HINSTANCE hInstance, HWND hwnd, const LPTSTR lpszTitle,
  const LPTSTR lpszPrompt, LPTSTR lpBuffer, ULONG cchBuffer) {
    STRING_BUFFER StringBuffer;

    StringBuffer.lpPrompt = lpszPrompt;
    StringBuffer.lpTitle = lpszTitle;
    StringBuffer.cbBuffer = cchBuffer;
    StringBuffer.lpBuffer = lpBuffer;

    DialogBoxParam(hInstance, (LPCTSTR)"InputString", hwnd, InputStringDlgProc,
      (LPARAM)&StringBuffer);

    return(StringBuffer.cbBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\apitest\dbgutil.c ===
/***********************************************************************
 *
 * DBGUTIL.C
 *
 * Debug utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/

#include <windows.h>
#include <wab.h>

#include "apitest.h"
#include "dbgutil.h"

#define _WAB_DBGUTIL_C

PUCHAR PropTagName(ULONG ulPropTag);
const TCHAR szNULL[] = "";

extern SCODE WABFreeBuffer(LPVOID lpBuffer);
VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...);



/***************************************************************************

    Name      : FreeBufferAndNull

    Purpose   : Frees a MAPI buffer and NULLs the pointer

    Parameters: lppv = pointer to buffer pointer to free

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall FreeBufferAndNull(LPVOID * lppv) {
    if (lppv) {
        if (*lppv) {
            SCODE sc;
            if (sc = WABFreeBuffer(*lppv)) {
                DebugTrace("WABFreeBuffer(%x) -> 0x%08x\n", *lppv, sc);
            }
            *lppv = NULL;
        }
    }
}


/***************************************************************************

    Name      : ReleaseAndNull

    Purpose   : Releases an object and NULLs the pointer

    Parameters: lppv = pointer to pointer to object to release

    Returns   : void

    Comment   : Remember to pass in the pointer to the pointer.  The
                compiler is not smart enough to tell if you are doing this
                right or not, but you will know at runtime!

    BUGBUG: Make this fastcall!

***************************************************************************/
void __fastcall ReleaseAndNull(LPVOID * lppv) {
    LPUNKNOWN * lppunk = (LPUNKNOWN *)lppv;

    if (lppunk) {
        if (*lppunk) {
            HRESULT hResult;

            if (hResult = (*lppunk)->lpVtbl->Release(*lppunk)) {
                DebugTrace("Release(%x) -> 0x%08x\n", *lppunk, GetScode(hResult));
            }
            *lppunk = NULL;
        }
    }
}


/***************************************************************************

    Name      : PropTypeString

    Purpose   : Map a proptype to a string

    Parameters: ulPropType = property type to map

    Returns   : string pointer to name of prop type

    Comment   :

***************************************************************************/
LPTSTR PropTypeString(ULONG ulPropType) {
    switch (ulPropType) {
        case PT_UNSPECIFIED:
            return("PT_UNSPECIFIED");
        case PT_NULL:
            return("PT_NULL       ");
        case PT_I2:
            return("PT_I2         ");
        case PT_LONG:
            return("PT_LONG       ");
        case PT_R4:
            return("PT_R4         ");
        case PT_DOUBLE:
            return("PT_DOUBLE     ");
        case PT_CURRENCY:
            return("PT_CURRENCY   ");
        case PT_APPTIME:
            return("PT_APPTIME    ");
        case PT_ERROR:
            return("PT_ERROR      ");
        case PT_BOOLEAN:
            return("PT_BOOLEAN    ");
        case PT_OBJECT:
            return("PT_OBJECT     ");
        case PT_I8:
            return("PT_I8         ");
        case PT_STRING8:
            return("PT_STRING8    ");
        case PT_UNICODE:
            return("PT_UNICODE    ");
        case PT_SYSTIME:
            return("PT_SYSTIME    ");
        case PT_CLSID:
            return("PT_CLSID      ");
        case PT_BINARY:
            return("PT_BINARY     ");
        case PT_MV_I2:
            return("PT_MV_I2      ");
        case PT_MV_LONG:
            return("PT_MV_LONG    ");
        case PT_MV_R4:
            return("PT_MV_R4      ");
        case PT_MV_DOUBLE:
            return("PT_MV_DOUBLE  ");
        case PT_MV_CURRENCY:
            return("PT_MV_CURRENCY");
        case PT_MV_APPTIME:
            return("PT_MV_APPTIME ");
        case PT_MV_SYSTIME:
            return("PT_MV_SYSTIME ");
        case PT_MV_STRING8:
            return("PT_MV_STRING8 ");
        case PT_MV_BINARY:
            return("PT_MV_BINARY  ");
        case PT_MV_UNICODE:
            return("PT_MV_UNICODE ");
        case PT_MV_CLSID:
            return("PT_MV_CLSID   ");
        case PT_MV_I8:
            return("PT_MV_I8      ");
        default:
            return("   <unknown>  ");
    }
}


/***************************************************************************

    Name      : TraceMVPStrings

    Purpose   : Debug trace a multivalued string property value

    Parameters: lpszCaption = caption string
                PropValue = property value to dump

    Returns   : none

    Comment   :

***************************************************************************/
void _TraceMVPStrings(LPTSTR lpszCaption, SPropValue PropValue) {
    ULONG i;

    DebugTrace("-----------------------------------------------------\n");
    DebugTrace("%s", lpszCaption);
    switch (PROP_TYPE(PropValue.ulPropTag)) {

        case PT_ERROR:
            DebugTrace("Error value 0x%08x\n", PropValue.Value.err);
            break;

        case PT_MV_TSTRING:
            DebugTrace("%u values\n", PropValue.Value.MVSZ.cValues);

            if (PropValue.Value.MVSZ.cValues) {
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
                for (i = 0; i < PropValue.Value.MVSZ.cValues; i++) {
                    DebugTrace("%u: \"%s\"\n", i, PropValue.Value.MVSZ.LPPSZ[i]);
                }
                DebugTrace("- - - - - - - - - - - - - - - - - - - - - - - - - - -\n");
            }
            break;

        default:
            DebugTrace("TraceMVPStrings got incorrect property type %u for tag %x\n",
              PROP_TYPE(PropValue.ulPropTag), PropValue.ulPropTag);
            break;
    }
}


/***************************************************************************

    Name      : DebugBinary

    Purpose   : Debug dump an array of bytes

    Parameters: cb = number of bytes to dump
                lpb -> bytes to dump

    Returns   : none

    Comment   :

***************************************************************************/
#define DEBUG_NUM_BINARY_LINES  2
VOID DebugBinary(UINT cb, LPBYTE lpb) {
    UINT cbLines = 0;

#if (DEBUG_NUM_BINARY_LINES != 0)
    UINT cbi;

    while (cb && cbLines < DEBUG_NUM_BINARY_LINES) {
        cbi = min(cb, 16);
        cb -= cbi;

        switch (cbi) {
            case 16:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14],
                  lpb[15]);
                break;
            case 1:
                DebugTrace("%02x\n", lpb[0]);
                break;
            case 2:
                DebugTrace("%02x %02x\n", lpb[0], lpb[1]);
                break;
            case 3:
                DebugTrace("%02x %02x %02x\n", lpb[0], lpb[1], lpb[2]);
                break;
            case 4:
                DebugTrace("%02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3]);
                break;
            case 5:
                DebugTrace("%02x %02x %02x %02x %02x\n", lpb[0], lpb[1], lpb[2], lpb[3],
                  lpb[4]);
                break;
            case 6:
                DebugTrace("%02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5]);
                break;
            case 7:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6]);
                break;
            case 8:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7]);
                break;
            case 9:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8]);
                break;
            case 10:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9]);
                break;
            case 11:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10]);
                break;
            case 12:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11]);
                break;
            case 13:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12]);
                break;
            case 14:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13]);
                break;
            case 15:
                DebugTrace("%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
                  lpb[0], lpb[1], lpb[2], lpb[3], lpb[4], lpb[5], lpb[6], lpb[7],
                  lpb[8], lpb[9], lpb[10], lpb[11], lpb[12], lpb[13], lpb[14]);
                break;
        }
        lpb += cbi;
        cbLines++;
    }
    if (cb) {
        DebugTrace("<etc.>");    //
    }
#endif
}


#define MAX_TIME_DATE_STRING    64
/***************************************************************************

    Name      : FormatTime

    Purpose   : Format a time string for the locale

    Parameters: lpst -> system time/date
                lptstr -> output buffer
                cchstr = size in chars of lpstr

    Returns   : number of characters used/needed (including null)

    Comment   : If cchstr < the return value, nothing will be written
                to lptstr.

***************************************************************************/
UINT FormatTime(LPSYSTEMTIME lpst, LPTSTR lptstr, UINT cchstr) {
    return((UINT)GetTimeFormat(LOCALE_USER_DEFAULT,
      0, lpst, NULL, lptstr, cchstr));
}


/***************************************************************************

    Name      : FormatDate

    Purpose   : Format a date string for the locale

    Parameters: lpst -> system time/date
                lptstr -> output buffer
                cchstr = size in chars of lpstr

    Returns   : number of characters used/needed (including null)

    Comment   : If cchstr < the return value, nothing will be written
                to lptstr.

***************************************************************************/
UINT FormatDate(LPSYSTEMTIME lpst, LPTSTR lptstr, UINT cchstr) {
    return((UINT)GetDateFormat(LOCALE_USER_DEFAULT,
      0, lpst, NULL, lptstr, cchstr));
}


/***************************************************************************

    Name      : BuildDate

    Purpose   : Put together a formated local date/time string from a MAPI
                style time/date value.

    Parameters: lptstr -> buffer to fill.
                cchstr = size of buffer (or zero if we want to know how
                  big we need)
                DateTime = MAPI date/time value

    Returns   : count of bytes in date/time string (including null)

    Comment   : All MAPI times and Win32 FILETIMEs are in Universal Time and
                need to be converted to local time before being placed in the
                local date/time string.

***************************************************************************/
UINT BuildDate(LPTSTR lptstr, UINT cchstr, FILETIME DateTime) {
    SYSTEMTIME st;
    FILETIME ftLocal;
    UINT cbRet = 0;

    if (! FileTimeToLocalFileTime((LPFILETIME)&DateTime, &ftLocal)) {
        DebugTrace("BuildDate: Invalid Date/Time\n");
        if (cchstr > (18 * sizeof(TCHAR))) {
            lstrcpy(lptstr, TEXT("Invalid Date/Time"));
        }
    } else {
        if (FileTimeToSystemTime(&ftLocal, &st)) {
            // Do the date first.
            cbRet = FormatDate(&st, lptstr, cchstr);
            // Do the time.  Start at the null after
            // the date, but remember that we've used part
            // of the buffer, so the buffer is shorter now.

            if (cchstr) {
                lstrcat(lptstr, "  ");   // seperate date and time
            }
            cbRet+=1;

            cbRet += FormatTime(&st, lptstr + cbRet,
              cchstr ? cchstr - cbRet : 0);
        } else {
            DebugTrace("BuildDate: Invalid Date/Time\n");
            if (cchstr > (18 * sizeof(TCHAR))) {
               lstrcpy(lptstr, TEXT("Invalid Date/Time"));
            }
        }
    }
    return(cbRet);
}


/*
 * DebugTime
 *
 * Debug output of UTC filetime or MAPI time.
 *
 * All MAPI times and Win32 FILETIMEs are in Universal Time.
 *
 */
void DebugTime(FILETIME Date, PUCHAR lpszFormat) {
    UCHAR lpszSubmitDate[MAX_TIME_DATE_STRING];

    BuildDate(lpszSubmitDate, sizeof(lpszSubmitDate), Date);

    DebugTrace(lpszFormat, lpszSubmitDate);
}

#define RETURN_PROP_CASE(pt) case PROP_ID(pt): return(#pt)

/***************************************************************************

    Name      : PropTagName

    Purpose   : Associate a name with a property tag

    Parameters: ulPropTag = property tag

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
PUCHAR PropTagName(ULONG ulPropTag) {
    static UCHAR szPropTag[35]; // see string on default

    switch (PROP_ID(ulPropTag)) {

        RETURN_PROP_CASE(PR_INITIALS);
        RETURN_PROP_CASE(PR_SURNAME);
        RETURN_PROP_CASE(PR_TITLE);
        RETURN_PROP_CASE(PR_TELEX_NUMBER);
        RETURN_PROP_CASE(PR_GIVEN_NAME);
        RETURN_PROP_CASE(PR_PRIMARY_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_PRIMARY_FAX_NUMBER);
        RETURN_PROP_CASE(PR_POSTAL_CODE);
        RETURN_PROP_CASE(PR_POSTAL_ADDRESS);
        RETURN_PROP_CASE(PR_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_PAGER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_OTHER_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ORGANIZATIONAL_ID_NUMBER);
        RETURN_PROP_CASE(PR_OFFICE_LOCATION);
        RETURN_PROP_CASE(PR_LOCATION);
        RETURN_PROP_CASE(PR_LOCALITY);
        RETURN_PROP_CASE(PR_ISDN_NUMBER);
        RETURN_PROP_CASE(PR_GOVERNMENT_ID_NUMBER);
        RETURN_PROP_CASE(PR_GENERATION);
        RETURN_PROP_CASE(PR_DEPARTMENT_NAME);
        RETURN_PROP_CASE(PR_COUNTRY);
        RETURN_PROP_CASE(PR_COMPANY_NAME);
        RETURN_PROP_CASE(PR_COMMENT);
        RETURN_PROP_CASE(PR_CELLULAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CAR_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_CALLBACK_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS2_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_BUSINESS_FAX_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_ASSISTANT);
        RETURN_PROP_CASE(PR_ACCOUNT);
        RETURN_PROP_CASE(PR_TEMPLATEID);
        RETURN_PROP_CASE(PR_DETAILS_TABLE);
        RETURN_PROP_CASE(PR_SEARCH_KEY);
        RETURN_PROP_CASE(PR_LAST_MODIFICATION_TIME);
        RETURN_PROP_CASE(PR_CREATION_TIME);
        RETURN_PROP_CASE(PR_ENTRYID);
        RETURN_PROP_CASE(PR_RECORD_KEY);
        RETURN_PROP_CASE(PR_MAPPING_SIGNATURE);
        RETURN_PROP_CASE(PR_OBJECT_TYPE);
        RETURN_PROP_CASE(PR_ROWID);
        RETURN_PROP_CASE(PR_ADDRTYPE);
        RETURN_PROP_CASE(PR_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_EMAIL_ADDRESS);
        RETURN_PROP_CASE(PR_DEPTH);
        RETURN_PROP_CASE(PR_ROW_TYPE);
        RETURN_PROP_CASE(PR_RADIO_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_HOME_TELEPHONE_NUMBER);
        RETURN_PROP_CASE(PR_INSTANCE_KEY);
        RETURN_PROP_CASE(PR_DISPLAY_TYPE);
        RETURN_PROP_CASE(PR_RECIPIENT_TYPE);
        RETURN_PROP_CASE(PR_CONTAINER_FLAGS);
        RETURN_PROP_CASE(PR_DEF_CREATE_DL);
        RETURN_PROP_CASE(PR_DEF_CREATE_MAILUSER);
        RETURN_PROP_CASE(PR_CONTACT_ADDRTYPES);
        RETURN_PROP_CASE(PR_CONTACT_DEFAULT_ADDRESS_INDEX);
        RETURN_PROP_CASE(PR_CONTACT_EMAIL_ADDRESSES);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_CITY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_COUNTRY);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POSTAL_CODE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_STREET);
        RETURN_PROP_CASE(PR_HOME_ADDRESS_POST_OFFICE_BOX);
        RETURN_PROP_CASE(PR_MIDDLE_NAME);
        RETURN_PROP_CASE(PR_NICKNAME);
        RETURN_PROP_CASE(PR_PERSONAL_HOME_PAGE);
        RETURN_PROP_CASE(PR_BUSINESS_HOME_PAGE);
        RETURN_PROP_CASE(PR_MHS_COMMON_NAME);
        RETURN_PROP_CASE(PR_SEND_RICH_INFO);
        RETURN_PROP_CASE(PR_TRANSMITABLE_DISPLAY_NAME);
        RETURN_PROP_CASE(PR_STATE_OR_PROVINCE);
        RETURN_PROP_CASE(PR_STREET_ADDRESS);

        default:
            wsprintf(szPropTag, "Unknown property tag 0x%x",
              PROP_ID(ulPropTag));
            return(szPropTag);
    }
}


/***************************************************************************

    Name      : DebugPropTagArray

    Purpose   : Displays MAPI property tags from a counted array

    Parameters: lpPropArray -> property array
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugPropTagArray(LPSPropTagArray lpPropArray, PUCHAR pszObject) {
    DWORD i;
    PUCHAR lpType;

    if (lpPropArray == NULL) {
        DebugTrace("Empty %s property tag array.\n", pszObject ? pszObject : szNULL);
        return;
    }

    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s property tags:\n", lpPropArray->cValues,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < lpPropArray->cValues ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpPropArray->aulPropTag[i],
          lpPropArray->aulPropTag[i] >> 16,
          lpPropArray->aulPropTag[i] & 0xffff);
#endif
        switch (lpPropArray->aulPropTag[i] & 0xffff) {
            case PT_STRING8:
                lpType = "STRING8";
                break;
            case PT_LONG:
                lpType = "LONG";
                break;
            case PT_I2:
                lpType = "I2";
                break;
            case PT_ERROR:
                lpType = "ERROR";
                break;
            case PT_BOOLEAN:
                lpType = "BOOLEAN";
                break;
            case PT_R4:
                lpType = "R4";
                break;
            case PT_DOUBLE:
                lpType = "DOUBLE";
                break;
            case PT_CURRENCY:
                lpType = "CURRENCY";
                break;
            case PT_APPTIME:
                lpType = "APPTIME";
                break;
            case PT_SYSTIME:
                lpType = "SYSTIME";
                break;
            case PT_UNICODE:
                lpType = "UNICODE";
                break;
            case PT_CLSID:
                lpType = "CLSID";
                break;
            case PT_BINARY:
                lpType = "BINARY";
                break;
            case PT_I8:
                lpType = "PT_I8";
                break;
            case PT_MV_I2:
                lpType = "MV_I2";
                break;
            case PT_MV_LONG:
                lpType = "MV_LONG";
                break;
            case PT_MV_R4:
                lpType = "MV_R4";
                break;
            case PT_MV_DOUBLE:
                lpType = "MV_DOUBLE";
                break;
            case PT_MV_CURRENCY:
                lpType = "MV_CURRENCY";
                break;
            case PT_MV_APPTIME:
                lpType = "MV_APPTIME";
                break;
            case PT_MV_SYSTIME:
                lpType = "MV_SYSTIME";
                break;
            case PT_MV_BINARY:
                lpType = "MV_BINARY";
                break;
            case PT_MV_STRING8:
                lpType = "MV_STRING8";
                break;
            case PT_MV_UNICODE:
                lpType = "MV_UNICODE";
                break;
            case PT_MV_CLSID:
                lpType = "MV_CLSID";
                break;
            case PT_MV_I8:
                lpType = "MV_I8";
                break;
            case PT_NULL:
                lpType = "NULL";
                break;
            case PT_OBJECT:
                lpType = "OBJECT";
                break;
            default:
                DebugTrace("<Unknown Property Type>");
                break;
        }
        DebugTrace("%s\t%s\n", PropTagName(lpPropArray->aulPropTag[i]), lpType);
    }
}


/***************************************************************************

    Name      : DebugProperties

    Purpose   : Displays MAPI properties in a property list

    Parameters: lpProps -> property list
                cProps = count of properties
                pszObject -> object string (ie "Message", "Recipient", etc)

    Returns   : none

    Comment   : Add new Property ID's as they become known

***************************************************************************/
void _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject) {
    DWORD i, j;


    DebugTrace("=======================================\n");
    DebugTrace("+  Enumerating %u %s properties:\n", cProps,
      pszObject ? pszObject : szNULL);

    for (i = 0; i < cProps ; i++) {
        DebugTrace("---------------------------------------\n");
#if FALSE
        DebugTrace("PropTag:0x%08x, ID:0x%04x, PT:0x%04x\n",
          lpProps[i].ulPropTag,
          lpProps[i].ulPropTag >> 16,
          lpProps[i].ulPropTag & 0xffff);
#endif
        DebugTrace("%s\n", PropTagName(lpProps[i].ulPropTag));

        switch (lpProps[i].ulPropTag & 0xffff) {
            case PT_STRING8:
                if (lstrlen(lpProps[i].Value.lpszA) < 1024) {
                    DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.lpszA);
                } else {
                    DebugTrace("STRING8 Value is too long to display\n");
                }
                break;
            case PT_LONG:
                DebugTrace("LONG Value:%u\n", lpProps[i].Value.l);
                break;
            case PT_I2:
                DebugTrace("I2 Value:%u\n", lpProps[i].Value.i);
                break;
            case PT_ERROR:
                DebugTrace("ERROR Value: 0x%08x\n", lpProps[i].Value.err);
                break;
            case PT_BOOLEAN:
                DebugTrace("BOOLEAN Value:%s\n", lpProps[i].Value.b ?
                  "TRUE" : "FALSE");
                break;
            case PT_R4:
                DebugTrace("R4 Value\n");
                break;
            case PT_DOUBLE:
                DebugTrace("DOUBLE Value\n");
                break;
            case PT_CURRENCY:
                DebugTrace("CURRENCY Value\n");
                break;
            case PT_APPTIME:
                DebugTrace("APPTIME Value\n");
                break;
            case PT_SYSTIME:
                DebugTime(lpProps[i].Value.ft, "SYSTIME Value:%s\n");
                break;
            case PT_UNICODE:
                DebugTrace("UNICODE Value\n");
                break;
            case PT_CLSID:
                DebugTrace("CLSID Value\n");
                break;
            case PT_BINARY:
                DebugTrace("BINARY Value %u bytes:\n", lpProps[i].Value.bin.cb);
                DebugBinary(lpProps[i].Value.bin.cb, lpProps[i].Value.bin.lpb);
                break;
            case PT_I8:
                DebugTrace("LARGE_INTEGER Value\n");
                break;
            case PT_MV_I2:
                DebugTrace("MV_I2 Value\n");
                break;
            case PT_MV_LONG:
                DebugTrace("MV_LONG Value\n");
                break;
            case PT_MV_R4:
                DebugTrace("MV_R4 Value\n");
                break;
            case PT_MV_DOUBLE:
                DebugTrace("MV_DOUBLE Value\n");
                break;
            case PT_MV_CURRENCY:
                DebugTrace("MV_CURRENCY Value\n");
                break;
            case PT_MV_APPTIME:
                DebugTrace("MV_APPTIME Value\n");
                break;
            case PT_MV_SYSTIME:
                DebugTrace("MV_SYSTIME Value\n");
                break;
            case PT_MV_BINARY:
                DebugTrace("MV_BINARY with %u values\n", lpProps[i].Value.MVbin.cValues);
                for (j = 0; j < lpProps[i].Value.MVbin.cValues; j++) {
                    DebugTrace("BINARY Value %u: %u bytes\n", j, lpProps[i].Value.MVbin.lpbin[j].cb);
                    DebugBinary(lpProps[i].Value.MVbin.lpbin[j].cb, lpProps[i].Value.MVbin.lpbin[j].lpb);
                }
                break;
            case PT_MV_STRING8:
                DebugTrace("MV_STRING8 with %u values\n", lpProps[i].Value.MVszA.cValues);
                for (j = 0; j < lpProps[i].Value.MVszA.cValues; j++) {
                    if (lstrlen(lpProps[i].Value.MVszA.lppszA[j]) < 1024) {
                        DebugTrace("STRING8 Value:\"%s\"\n", lpProps[i].Value.MVszA.lppszA[j]);
                    } else {
                        DebugTrace("STRING8 Value is too long to display\n");
                    }
                }
                break;
            case PT_MV_UNICODE:
                DebugTrace("MV_UNICODE Value\n");
                break;
            case PT_MV_CLSID:
                DebugTrace("MV_CLSID Value\n");
                break;
            case PT_MV_I8:
                DebugTrace("MV_I8 Value\n");
                break;
            case PT_NULL:
                DebugTrace("NULL Value\n");
                break;
            case PT_OBJECT:
                DebugTrace("OBJECT Value\n");
                break;
            default:
                DebugTrace("Unknown Property Type\n");
                break;
        }
    }
}


/***************************************************************************

    Name      : DebugADRLIST

    Purpose   : Displays structure of an ADRLIST including properties

    Parameters: lpAdrList -> ADRLSIT to show
                lpszTitle = string to identify this dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle) {
     ULONG i;
     TCHAR szTitle[250];

     for (i = 0; i < lpAdrList->cEntries; i++) {

         wsprintf(szTitle, "%s : Entry %u", lpszTitle, i);
         _DebugProperties(lpAdrList->aEntries[i].rgPropVals,
           lpAdrList->aEntries[i].cValues, szTitle);
     }
}


/***************************************************************************

    Name      : DebugObjectProps

    Purpose   : Displays MAPI properties of an object

    Parameters: lpObject -> object to dump
                Label = string to identify this prop dump

    Returns   : none

    Comment   :

***************************************************************************/
void _DebugObjectProps(LPMAPIPROP lpObject, LPTSTR Label) {
    DWORD cProps = 0;
    LPSPropValue lpProps = NULL;
    HRESULT hr = hrSuccess;
    SCODE sc = SUCCESS_SUCCESS;


    hr = lpObject->lpVtbl->GetProps(lpObject, NULL, 0, &cProps, &lpProps);
    switch (sc = GetScode(hr)) {
        case SUCCESS_SUCCESS:
            break;

        case MAPI_W_ERRORS_RETURNED:
            DebugTrace("GetProps -> Errors Returned\n");
            break;

        default:
            DebugTrace("GetProps -> Error 0x%x\n", sc);
            return;
    }

    _DebugProperties(lpProps, cProps, Label);

    FreeBufferAndNull(&lpProps);
}


/*
 *	Destroys an SRowSet structure.
 */
STDAPI_(void)
FreeProws(LPSRowSet prows)
{
	ULONG		irow;

	if (!prows)
		return;

	for (irow = 0; irow < prows->cRows; ++irow)
		WABFreeBuffer(prows->aRow[irow].lpProps);
	WABFreeBuffer(prows);
}


/***************************************************************************

    Name      : DebugMapiTable

    Purpose   : Displays structure of a MAPITABLE including properties

    Parameters: lpTable -> MAPITABLE to display

    Returns   : none

    Comment   : Don't sort the columns or rows here.  This routine should
                not produce side effects in the table.

***************************************************************************/
void _DebugMapiTable(LPMAPITABLE lpTable) {
    UCHAR szTemp[30];   // plenty for "ROW %u"
    ULONG ulCount;
    WORD wIndex;
    LPSRowSet lpsRow = NULL;
    ULONG ulCurrentRow = (ULONG)-1;
    ULONG ulNum, ulDen, lRowsSeeked;

    DebugTrace("=======================================\n");
    DebugTrace("+  Dump of MAPITABLE at 0x%x:\n", lpTable);
    DebugTrace("---------------------------------------\n");

    // How big is the table?
    lpTable->lpVtbl->GetRowCount(lpTable, 0, &ulCount);
    DebugTrace("Table contains %u rows\n", ulCount);

    // Save the current position in the table
    lpTable->lpVtbl->QueryPosition(lpTable, &ulCurrentRow, &ulNum, &ulDen);

    // Display the properties for each row in the table
    for (wIndex = 0; wIndex < ulCount; wIndex++) {
        // Get the next row
        lpTable->lpVtbl->QueryRows(lpTable, 1, 0, &lpsRow);

        if (lpsRow) {
//            Assert(lpsRow->cRows == 1); // should have exactly one row

            wsprintf(szTemp, "ROW %u", wIndex);

            DebugProperties(lpsRow->aRow[0].lpProps,
              lpsRow->aRow[0].cValues, szTemp);

            FreeProws(lpsRow);
        }
    }

    // Restore the current position for the table
    if (ulCurrentRow != (ULONG)-1) {
        lpTable->lpVtbl->SeekRow(lpTable, BOOKMARK_BEGINNING, ulCurrentRow,
          &lRowsSeeked);
    }
}


/*
 * DebugTrace -- printf to the debugger console or debug output file
 * Takes printf style arguments.
 * Expects newline characters at the end of the string.
 */
VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...) {
    va_list marker;
    TCHAR String[1100];


    va_start(marker, lpszFmt);
    wvsprintf(String, lpszFmt, marker);
        OutputDebugString(String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\ldapcli\lwinsock.h ===
//--------------------------------------------------------------------------------------------
//
//	Copyright (c) Microsoft Corporation, 1996
//
//	Description:
//
//		Microsoft Internet LDAP Client.
//
//		Classes that manage connections with an LDAP server.
//
//	Authors:
//
//		RobertC		04/18/96
//
//--------------------------------------------------------------------------------------------

// NOTE: this class is responsible for buffering all data until complete top-level structures
// are received.

#ifndef _LSWINSOC_H
#define _LSWINSOC_H

//--------------------------------------------------------------------------------------------
//
// DEFINITIONS
//
//--------------------------------------------------------------------------------------------
typedef void (*PFNRECEIVEDATA)(PVOID pvCookie, PVOID pv, int cb, int *pcbReceived);

//--------------------------------------------------------------------------------------------
//
// CONSTANTS
//
//--------------------------------------------------------------------------------------------
const int CBBUFFERGROW	= 4096;

//--------------------------------------------------------------------------------------------
//
// FUNCTIONS
//
//--------------------------------------------------------------------------------------------
extern BOOL FInitSocketDLL();
extern void FreeSocketDLL();

//--------------------------------------------------------------------------------------------
//
// CLASSES
//
//--------------------------------------------------------------------------------------------

class CLdapWinsock
{

//
// Interfaces
//

public:
	CLdapWinsock();
	~CLdapWinsock(void);
	
	STDMETHODIMP			HrConnect(PFNRECEIVEDATA pfnReceive, PVOID pvCookie, char *szServer, USHORT usPort = IPPORT_LDAP);
	STDMETHODIMP			HrDisconnect(void);
	STDMETHODIMP			HrIsConnected(void);

	STDMETHODIMP			HrSend(PVOID pv, int cb);

protected:
	friend DWORD __stdcall DwReadThread(PVOID pvData);
	DWORD					DwReadThread(void);
	
private:
	void					Receive(PVOID pv, int cb, int *pcbReceived);
	
	HRESULT					HrCreateReadThread(void);
	
	HRESULT					HrLastWinsockError(void);

	CRITICAL_SECTION		m_cs;

	SOCKET					m_sc;
	BOOL					m_fConnected;
	HANDLE					m_hthread;
	DWORD					m_dwTid;
	PFNRECEIVEDATA			m_pfnReceive;
	PVOID					m_pvCookie;

	// read buffer
	HRESULT					HrGrowBuffer();
	BYTE					*m_pbBuf;		// buffer for socket to read into
	int						m_cbBuf;		// current amount of data in the buffer
	int						m_cbBufMax;		// total size of buffer
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\setup\makefile.inc ===
$O\wabver.bat : wabver.tmp $(BASEDIR)\public\sdk\inc\ntverp.h $(BASEDIR)\public\sdk\inc\ieverp.h
    cl /EP /I$(BASEDIR)\public\sdk\inc /DNASHVILLE /Tc wabver.tmp > $@

$O\wab.srx : wab.src $O\wabver.bat
    $O\wabver wab.src $@

$O\wab9x50.inx : $O\wab.srx $O\msoeacct.reg $O\msoeacct.str $O\wab32.reg $O\wab32.str $O\wabimp.reg $O\wabimp.str $O\wabfind.reg 
    cl /EP $(COPYPDB) $(DEFINEX86) /DWIN9X /Tc $O\wab.srx > $O\wab9x50.tmp
    copy $O\wab9x50.tmp /B +$O\msoeacct.str /B +$O\wab32.str /B +$O\wabimp.str /B $@
    del $O\wab9x50.tmp

$O\wab50.inx.nt : $O\wab.srx
    cl /EP $(COPYPDB) $(DEFINEX86) /Tc $** > $@

$O\wab50.inx.exe : $O\wab.srx
    cl /EP $(COPYPDB) $(DEFINEX86) /DIE5 /DOESETUP_EXE /Tc $** > $@

$O\wab50.inx.cab : $O\wab.srx
    cl /EP $(COPYPDB) $(DEFINEX86) /DIE5 /Tc $** > $@

$O\wab9x50.inf : $O\wab9x50.inx
    $(CLEANINF) $** $@
    del $**

$O\wab50.inf.nt : $O\wab50.inx.nt
    $(CLEANINF) $** $@
    del $**

$O\wab50.inf : $O\wab50.inf.nt
    copy $** $@

$O\wab50.inf.exe : $O\wab50.inx.exe
    $(CLEANINF) $** $@
    del $**

$O\wab50.inf.cab : $O\wab50.inx.cab
    $(CLEANINF) $** $@
    del $**

$O\wabcab.sed  : wabcab.src
    cl /EP $(COPYPDB) $(DEFINEX86) /DOESETUP_DEV /Tc $** > $@

$O\wabexe.se2 : wabcab.src
    cl /EP $(COPYPDB) $(DEFINEX86) /DOESETUP_DEV /DOESETUP_EXE /Tc $** > $@

$O\wabexe.sed : $O\wabexe.se2 $O\wabver.bat
    $O\wabver $O\wabexe.se2 $@
    del $O\wabexe.se2

$O\wabcabl.sed : wabcab.src
    cl /EP /Tc $** > $@

$O\wabexel.se2 : wabcab.src
    cl /EP /DOESETUP_EXE /Tc $** > $@

$O\wabexel.sed : $O\wabexel.se2 $O\wabver.bat
    $O\wabver $O\wabexel.se2 $@
    del $O\wabexel.se2

$O\msoeacct.reg : $(ATHROOT)\msoeacct\reg.src
    copy $** $@

$O\msoeacct.str : $(ATHROOT)\msoeacct\strings.src
    copy $** $@

$O\wab32.reg : $(WABROOT)\wabapi\reg.src $(WABROOT)\wabapi\reg2.src
    copy $(WABROOT)\wabapi\reg.src /B + $(WABROOT)\wabapi\reg2.src /B $@

$O\wab32.str : $(WABROOT)\wabapi\strings.src
    copy $** $@

$O\wabimp.reg : $(WABROOT)\convert\wmnets\reg.src
    copy $** $@

$O\wabimp.str : $(WABROOT)\convert\wmnets\strings.src
    copy $** $@

$O\wabfind.reg : $(WABROOT)\wabfind\reg.src $(WABROOT)\wabfind\reg2.src
    copy $(WABROOT)\wabfind\reg.src /B + $(WABROOT)\wabfind\reg2.src /B $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\apitest\apitest.c ===
/*-----------------------------------------
   APITEST.C -- Function Test of WABAPI.DLL
  -----------------------------------------*/

#include <windows.h>
#include <wab.h>
#include <wabguid.h>
#include "apitest.h"
#include "instring.h"
#include "dbgutil.h"

#define WinMainT WinMain
long FAR PASCAL WndProc (HWND, UINT, UINT, LONG) ;

#define MAX_INPUT_STRING    200

char szAppName [] = "APITest" ;
HINSTANCE hInst;

enum _AddressTestFlags
{
    ADDRESS_CONTENTS = 0,
    ADDRESS_CONTENTS_BROWSE,
    ADDRESS_CONTENTS_BROWSE_MODAL,
    ADDRESS_WELLS,
    ADDRESS_WELLS_DEFAULT,
};

void AllocTest(void);
void IPropTest(void);
void WABOpenTest(void);
void CreateEntryTest(HWND hwnd, BOOL fDL);
void GetContentsTableTest(void);
void GetSearchPathTest(void);
void ResolveNameTest(HWND hwnd);
void ResolveNamesTest(HWND hwnd);
void DeleteEntriesTest(HWND hwnd);
void WABAddressTest(HWND hWnd, int iFlag, int cDestWells);
void AddrBookDetailsTest(HWND hwnd);
void AddrBookDetailsOneOffTest(HWND hwnd);
void RootContainerTest(void);
void NotificationsTest(HWND hwnd);
void GetMeTest(HWND hWnd);

#define DATABASE_KEY    HKEY_CURRENT_USER
#define CCH_MAX_REGISTRY_DATA   256
const TCHAR szMainSectionName[] = TEXT("APITest");       // Test settings in here
const TCHAR szIniSectionName[] = TEXT("Software\\Microsoft\\WAB\\Test");  // Look here for settings
const TCHAR szContactNumberKey[] = TEXT("Next Contact Number");
const TCHAR szContainerNumberKey[] = TEXT("Container Number");



//
//  Global WAB Allocator access functions
//
typedef struct _WAB_ALLOCATORS {
    LPWABOBJECT lpWABObject;
    LPWABALLOCATEBUFFER lpAllocateBuffer;
    LPWABALLOCATEMORE lpAllocateMore;
    LPWABFREEBUFFER lpFreeBuffer;
} WAB_ALLOCATORS, *LPWAB_ALLOCATORS;

ULONG ulContainerNumber = 0;
WAB_ALLOCATORS WABAllocators = {0};

/***************************************************************************

    Name      : SetGlobalBufferFunctions

    Purpose   : Set the global buffer functions based on methods from
                the WAB object.

    Parameters: lpWABObject = the open wab object

    Returns   : none

    Comment   :

***************************************************************************/
void SetGlobalBufferFunctions(LPWABOBJECT lpWABObject) {
    if (lpWABObject && WABAllocators.lpWABObject != lpWABObject) {
        WABAllocators.lpAllocateBuffer = lpWABObject->lpVtbl->AllocateBuffer;
        WABAllocators.lpAllocateMore = lpWABObject->lpVtbl->AllocateMore;
        WABAllocators.lpFreeBuffer = lpWABObject->lpVtbl->FreeBuffer;
        WABAllocators.lpWABObject = lpWABObject;
    }
}


/***************************************************************************

    Name      : WABAllocateBuffer

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABAllocateBuffer(ULONG cbSize, LPVOID FAR * lppBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateBuffer) {
        return(WABAllocators.lpAllocateBuffer(WABAllocators.lpWABObject, cbSize, lppBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : WABAllocateMore

    Purpose   : Use the WAB Allocator

    Parameters: cbSize = size to allocate
                lpObject = existing allocation
                lppBuffer = returned buffer

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABAllocateMore(ULONG cbSize, LPVOID lpObject, LPVOID FAR * lppBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpAllocateMore) {
        return(WABAllocators.lpAllocateMore(WABAllocators.lpWABObject, cbSize, lpObject, lppBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : WABFreeBuffer

    Purpose   : Use the WAB Allocator

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

***************************************************************************/
SCODE WABFreeBuffer(LPVOID lpBuffer) {
    if (WABAllocators.lpWABObject && WABAllocators.lpFreeBuffer) {
        return(WABAllocators.lpFreeBuffer(WABAllocators.lpWABObject, lpBuffer));
    } else {
        return(MAPI_E_INVALID_OBJECT);
    }
}


/***************************************************************************

    Name      : WABFreePadrlist

    Purpose   : Free an adrlist and it's property arrays

    Parameters: lpBuffer = buffer to free

    Returns   : SCODE

    Comment   :

***************************************************************************/
void WABFreePadrlist(LPADRLIST lpAdrList) {
        ULONG           iEntry;

        if (lpAdrList) {
                for (iEntry = 0; iEntry < lpAdrList->cEntries; ++iEntry) {
           if (lpAdrList->aEntries[iEntry].rgPropVals) {
                             WABFreeBuffer(lpAdrList->aEntries[iEntry].rgPropVals);
           }
                }
                WABFreeBuffer(lpAdrList);
        }
}


/***************************************************************************

    Name      : StrInteger

    Purpose   : Replace atoi().  Base 10 string to integer.

    Parameters: lpszString = string pointer (null terminated)

    Returns   : integer value found in lpszString

    Comment   : Reads characters from lpszString until a non-digit is found.

***************************************************************************/
int __fastcall StrInteger(LPCTSTR lpszString) {
    register DWORD dwInt = 0;
    register LPTSTR lpsz = (LPTSTR)lpszString;

    if (lpsz) {
        while (*lpsz > '0' && *lpsz < '9') {
            dwInt = dwInt * 10 + (*lpsz - '0');
            lpsz++;
        }
    }

    return(dwInt);
}

/***************************************************************************

    Name      : GetInitializerInt

    Purpose   : Gets an integer value from the initializer data

    Parameters: lpszSection = section name
                lpszKey = key name
                dwDefault = default value if key not found
                lpszFile = inifile/keyname

    Returns   : UINT value from the initializer database (registry)

    Comment   : Same interface as GetPrivateProfileInt: If the key is not
                found, the return value is the specified default value.
                If value of the key is less than zero, the return value
                is zero.

                The registry key to get here is:
                  lpszFile\lpszSection
                The value name is lpszKey.

***************************************************************************/
UINT GetInitializerInt(LPCTSTR lpszSection, LPCTSTR lpszKey, INT dwDefault,
  LPCTSTR lpszFile) {

    LPTSTR lpszKeyName = NULL;
    HKEY hKey = NULL;
    INT iReturn = 0;
    DWORD dwType;
    DWORD cbData = CCH_MAX_REGISTRY_DATA;
    BYTE  lpData[CCH_MAX_REGISTRY_DATA];
    DWORD cchKey;
    DWORD dwErr;

    if (lpszFile == NULL || lpszSection == NULL || lpszKey == NULL) {
        return(dwDefault);
    }

    cchKey = lstrlen(lpszFile) + lstrlen(lpszSection) + 2;

    if ((lpszKeyName = LocalAlloc(LPTR, cchKey)) == NULL) {
        DebugTrace("GetInitializerInt: LocalAlloc(%u) failed\n", cchKey);
        return(0);
    }

    // Create keyname string
    lstrcpy(lpszKeyName, lpszFile);
    lstrcat(lpszKeyName, "\\");
    lstrcat(lpszKeyName, lpszSection);

    if (dwErr = RegOpenKeyEx(DATABASE_KEY, lpszKeyName, 0, KEY_READ, &hKey)) {
        DebugTrace("GetInitializerInt: RegOpenKeyEx(%s) --> %u, using default.\n",
          lpszKeyName, dwErr);
        iReturn = dwDefault;    // default
        goto Exit;
    }

    if (dwErr = RegQueryValueEx(hKey, (LPTSTR)lpszKey, 0, &dwType, lpData, &cbData)) {
        iReturn = dwDefault;
        goto Exit;
    }

    switch (dwType) {
        case REG_SZ:
            iReturn = StrInteger((char *)lpData);
            if (iReturn < 0) {
                iReturn = 0;    // match spec of GetPrivateProfileInt.
            }
            break;

        case REG_DWORD:
            if ((iReturn = (INT)(*(DWORD *)lpData)) < 0) {
                iReturn = 0;    // match spec of GetPrivateProfileInt.
            }

            break;
        default:
            DebugTrace("GetInitializerInt: RegQueryValueEx(%s) -> UNKNOWN dwType = %u\n",
              lpszKey, dwType);
            iReturn = dwDefault;
            break;
    }

Exit:
    if (hKey) {
        RegCloseKey(hKey);
    }
    LocalFree(lpszKeyName);
    return(iReturn);
}


/***************************************************************************

    Name      : WriteRegistryString

    Purpose   : Sets the string value in the registry

    Parameters: hKeyRoot = root key
                lpszSection = section name
                lpszKey = key name
                lpszString = string value to add
                lpszFile = inifile/keyname

    Returns   : TRUE on success

***************************************************************************/
BOOL WriteRegistryString(HKEY hKeyRoot, LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPCTSTR lpszString, LPCTSTR lpszFile) {

    DWORD cchKey;
    LPTSTR lpszKeyName = NULL;
    HKEY hKey = NULL;
    BOOL fReturn = FALSE;
    DWORD dwDisposition;
    DWORD dwErr;

    if (lpszFile == NULL || lpszSection == NULL || lpszKey == NULL) {
        return(FALSE);
    }

    cchKey = lstrlen(lpszFile) + lstrlen(lpszSection) + 2;

    if ((lpszKeyName = LocalAlloc(LPTR, cchKey)) == NULL) {
        DebugTrace("WriteInitializerString: LocalAlloc(%u) failed\n", cchKey);
        return(0);
    }

    // Create keyname string
    lstrcpy(lpszKeyName, lpszFile);
    lstrcat(lpszKeyName, "\\");
    lstrcat(lpszKeyName, lpszSection);

    if (dwErr = RegCreateKeyEx(hKeyRoot, lpszKeyName, 0, NULL,
        REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, NULL, &hKey, &dwDisposition)) {
        DebugTrace("WriteInitializerString: RegCreateKeyEx(%s) --> %u.\n",
          lpszKeyName, dwErr);
        goto Exit;
    }

    if (dwErr = RegSetValueEx(hKey, lpszKey, 0, REG_SZ,
      (CONST LPBYTE)lpszString, lstrlen(lpszString) + 1)) {
        DebugTrace("WriteInitializerString: RegSetValueEx(%s) --> %u.\n",
          lpszKey, dwErr);
        goto Exit;
    }
    fReturn = TRUE; // must have succeeded

Exit:
    if (hKey) {
        RegCloseKey(hKey);
    }

    LocalFree(lpszKeyName);

    return(fReturn);
}


/***************************************************************************

    Name      : WriteInitializerString

    Purpose   : Sets the string value in the initializer data

    Parameters: lpszSection = section name
                lpszKey = key name
                lpszString = string value to add
                lpszFile = inifile/keyname

    Returns   : TRUE on success

    Comment   : Same interface as WritePrivateProfileString.

                The registry key to get here is:
                  lpszFile\lpszSection
                The value name is lpszKey.

***************************************************************************/
BOOL WriteInitializerString(LPCTSTR lpszSection, LPCTSTR lpszKey,
  LPCTSTR lpszString, LPCTSTR lpszFile) {

    return(WriteRegistryString(DATABASE_KEY, lpszSection, lpszKey,
      lpszString, lpszFile));
}


/***************************************************************************

    Name      : WriteInitializerInt

    Purpose   : Sets the integer value in the initializer data

    Parameters: lpszSection = section name
                lpszKey = key name
                i = int value to add
                lpszFile = inifile/keyname

    Returns   : TRUE on success

    Comment   : Same interface as WritePrivateProfileInt would be if
                there were one.

                The registry key to get here is:
                  lpszFile\lpszSection
                The value name is lpszKey.

***************************************************************************/
BOOL WriteInitializerInt(LPCTSTR lpszSection, LPCTSTR lpszKey,
  DWORD i, LPCTSTR lpszFile) {

    TCHAR szIntString[12];  //  put string representation of int here.

    wsprintf(szIntString, "%u", i);

    return(WriteInitializerString(lpszSection, lpszKey,
      szIntString, lpszFile));
}


/***************************************************************************

    Name      : GetNewMessageReference

    Purpose   : Generate a unique messag reference value

    Parameters: none

    Returns   : return ULONG message reference value.

    Comment   : Look in registry for the next available message reference
                value and update the registry.  We will increment the number
                to keep track of the number of faxes sent or received.  Since
                the number is a DWORD, it should be sufficient for the life
                of the product.  ie, if we could send 1 fax every second,
                it would last over 137 years.
                We will maintain the number as a count of messages handled,
                and will use the current number before incrementing as the
                ulMessageRef.

                This number will increment for all attempts to send and
                receive, not just successes.

                WARNING: This code is not reentrant!

***************************************************************************/
ULONG GetNewMessageReference(void) {
    ULONG ulNum;

    if ((ulNum = GetInitializerInt(szMainSectionName, szContactNumberKey,
      0xFFFFFFFF, szIniSectionName)) == 0xFFFFFFFF) {
        // Start with a one.
        ulNum = 1;
    }

    WriteInitializerInt(szMainSectionName, szContactNumberKey, ulNum + 1,
      szIniSectionName);

    return(ulNum);
}


/***************************************************************************

    Name      : FindProperty

    Purpose   : Finds a property in a proparray

    Parameters: cProps = number of props in the array
                lpProps = proparray
                ulPropTag = property tag to look for

    Returns   : array index of property or NOT_FOUND

    Comment   :

***************************************************************************/
ULONG FindProperty(ULONG cProps, LPSPropValue lpProps, ULONG ulPropTag) {
    register ULONG i;

    for (i = 0; i < cProps; i++) {
        if (lpProps[i].ulPropTag == ulPropTag) {
            return(i);
        }
    }

    return((ULONG)-1);
}


/***************************************************************************

    Name      : FindAdrEntryID

    Purpose   : Find the PR_ENTRYID in the Nth ADRENTRY of an ADRLIST

    Parameters: lpAdrList -> AdrList
                index = which ADRENTRY to look at

    Returns   : return pointer to the SBinary structure of the ENTRYID value

    Comment   :

***************************************************************************/
LPSBinary FindAdrEntryID(LPADRLIST lpAdrList, ULONG index) {
    LPADRENTRY lpAdrEntry;
    ULONG i;

    if (lpAdrList && index < lpAdrList->cEntries) {

        lpAdrEntry = &(lpAdrList->aEntries[index]);

        for (i = 0; i < lpAdrEntry->cValues; i++) {
            if (lpAdrEntry->rgPropVals[i].ulPropTag == PR_ENTRYID) {
                return((LPSBinary)&lpAdrEntry->rgPropVals[i].Value);
            }
        }
    }
    return(NULL);
}



//
// Properties to get from the contents table
//
enum {
    ircPR_OBJECT_TYPE = 0,
    ircPR_ENTRYID,
    ircPR_DISPLAY_NAME,
    ircMax
};
static const SizedSPropTagArray(ircMax, ptaRoot) =
{
    ircMax,
    {
        PR_OBJECT_TYPE,
        PR_ENTRYID,
        PR_DISPLAY_NAME,
    }
};

HRESULT GetContainerEID(LPADRBOOK lpAdrBook, LPULONG lpcbEID, LPENTRYID * lppEID) {
    HRESULT hResult;
    ULONG ulObjType;
    LPABCONT lpRoot = NULL;
    LPMAPITABLE lpRootTable = NULL;
    LPSRowSet lpRow = NULL;

    if (ulContainerNumber) {
        // Get the root contents table
        if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
          0,
          NULL,
          NULL,
          0,
          &ulObjType,
          (LPUNKNOWN *)&lpRoot))) {
            if (! (hResult = lpRoot->lpVtbl->GetContentsTable(lpRoot,
              0,
              &lpRootTable))) {
                // Set the columns
                lpRootTable->lpVtbl->SetColumns(lpRootTable,
                  (LPSPropTagArray)&ptaRoot,
                  0);

                lpRootTable->lpVtbl->SeekRow(lpRootTable,
                  BOOKMARK_BEGINNING,
                  ulContainerNumber,
                  NULL);

                if (hResult = lpRootTable->lpVtbl->QueryRows(lpRootTable,
                  1,    // one row at a time
                  0,    // ulFlags
                  &lpRow)) {
                    DebugTrace("GetContainerEID: QueryRows -> %x\n", GetScode(hResult));
                } else {
                    // Found it, copy entryid to new allocation
                    if (lpRow->cRows) {
                        *lpcbEID = lpRow->aRow[0].lpProps[ircPR_ENTRYID].Value.bin.cb;
                        WABAllocateBuffer(*lpcbEID, lppEID);
                        memcpy(*lppEID, lpRow->aRow[0].lpProps[ircPR_ENTRYID].Value.bin.lpb, *lpcbEID);
                    } else {
                        hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                        DebugTrace("GetContainerEID couldn't find -> container %u\n", ulContainerNumber);
                    }

                    FreeProws(lpRow);
                }
                lpRootTable->lpVtbl->Release(lpRootTable);
            }
            lpRoot->lpVtbl->Release(lpRoot);
        }
    } else {
        hResult = lpAdrBook->lpVtbl->GetPAB(lpAdrBook,
          lpcbEID,
          lppEID);
    }
    return(hResult);
}


int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow) {
    HWND     hwnd ;
    MSG      msg ;
    WNDCLASS wndclass ;

    if (!hPrevInstance) {
        hInst = hInstance;

        wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
        wndclass.lpfnWndProc   = WndProc ;
        wndclass.cbClsExtra    = 0 ;
        wndclass.cbWndExtra    = 0 ;
        wndclass.hInstance     = hInstance ;
        wndclass.hIcon         = LoadIcon(NULL, IDI_APPLICATION) ;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW) ;
        wndclass.hbrBackground = GetStockObject(WHITE_BRUSH) ;
        wndclass.lpszMenuName  = szAppName ;
        wndclass.lpszClassName = szAppName ;

        RegisterClass (&wndclass) ;
    }


    hwnd = CreateWindow (szAppName, "WAB API Test",
      WS_OVERLAPPEDWINDOW,
      0,        // CW_USEDEFAULT,
      0,        // CW_USEDEFAULT,
      300,      // CW_USEDEFAULT,
      200,      // CW_USEDEFAULT,
      NULL,
      NULL,
      hInstance,
      NULL) ;

    ShowWindow (hwnd, nCmdShow) ;
    UpdateWindow (hwnd) ;
    while (GetMessage(&msg, NULL, 0, 0)) {
        TranslateMessage (&msg) ;
        DispatchMessage (&msg) ;
    }
    return msg.wParam ;
}

long FAR PASCAL WndProc (HWND hwnd, UINT message, UINT wParam, LONG lParam) {
    switch (message) {
        case WM_CREATE:
            if ((ulContainerNumber = GetInitializerInt(szMainSectionName, szContainerNumberKey,
              0xFFFFFFFF, szIniSectionName)) == 0xFFFFFFFF) {
                // None
                ulContainerNumber = 0;
            }
            break;

        case WM_COMMAND :
            switch (wParam) {
                case IDM_EXIT :
                    SendMessage (hwnd, WM_CLOSE, 0, 0L) ;
                    return 0 ;

                case IDM_GETME:
                    GetMeTest(hwnd);
                    return(0);

                case IDM_ALLOCATE:
                    AllocTest();
                    return(0);

                case IDM_IPROP:
                    IPropTest();
                    return(0);

                case IDM_GETSEARCHPATH:
                    GetSearchPathTest();
                    return(0);

                case IDM_CONTENTS_TABLE:
                    GetContentsTableTest();
                    return(0);

                case IDM_WABOPEN:
                    WABOpenTest();
                    return(0);

                case IDM_CREATE_ENTRY:
                    CreateEntryTest(hwnd, FALSE);
                    return(0);

                case IDM_CREATE_DL:
                    CreateEntryTest(hwnd, TRUE);
                    break;

                case IDM_RESOLVE_NAME:
                    ResolveNameTest(hwnd);
                    return(0);

                case IDM_DETAILS:
                    AddrBookDetailsTest(hwnd);
                    return(0);

                case IDM_DETAILS_ONE_OFF:
                    AddrBookDetailsOneOffTest(hwnd);
                    return(0);

                case IDM_RESOLVE_NAMES:
                    ResolveNamesTest(hwnd);
                    return(0);

                case IDM_DELETE_ENTRIES:
                    DeleteEntriesTest(hwnd);
                    return(0);

                case IDM_ADDRESS_WELLS0:
                    WABAddressTest(hwnd,ADDRESS_WELLS,0);
                    return(0);

                case IDM_ADDRESS_WELLS1:
                    WABAddressTest(hwnd,ADDRESS_WELLS,1);
                    return(0);

                case IDM_ADDRESS_WELLS2:
                    WABAddressTest(hwnd,ADDRESS_WELLS,2);
                    return(0);

                case IDM_ADDRESS_DEFAULT:
                    WABAddressTest(hwnd,ADDRESS_WELLS_DEFAULT,3);
                    return(0);

                case IDM_ADDRESS_WELLS3:
                    WABAddressTest(hwnd,ADDRESS_WELLS,3);
                    return(0);

                case IDM_ADDRESS_PICK_USER:
                    WABAddressTest(hwnd,ADDRESS_CONTENTS,0);
                    return(0);

                case IDM_ADDRESS_BROWSE_ONLY:
                    WABAddressTest(hwnd,ADDRESS_CONTENTS_BROWSE,0);
                    return(0);

                case IDM_ADDRESS_BROWSE_MODAL_ONLY:
                    WABAddressTest(hwnd,ADDRESS_CONTENTS_BROWSE_MODAL,0);
                    return(0);

                case IDM_ROOT_CONTAINER:
                    RootContainerTest();
                    return(0);

                case IDM_NOTIFICATIONS:
                    NotificationsTest(hwnd);
                    return(0);

                case IDM_ABOUT:
                    MessageBox (hwnd, "WAB API Function Test.",
                    szAppName, MB_ICONINFORMATION | MB_OK);
                    return(0);
                }
            break ;

        case WM_DESTROY:
            PostQuitMessage(0);
            return(0);
        }
    return(DefWindowProc (hwnd, message, wParam, lParam));
}


#define MAX_INPUT_STRING    200

void AllocTest(void) {
    LPTSTR lpBuffer = NULL;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;

    WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    WABAllocateBuffer(1234, &lpBuffer);
    WABFreeBuffer(lpBuffer);

    lpAdrBook->lpVtbl->Release(lpAdrBook);
    lpWABObject->lpVtbl->Release(lpWABObject);
}


// enum for setting the created properties
enum {
    imuPR_DISPLAY_NAME = 0,     // must be first so DL's can use same enum
    imuPR_SURNAME,
    imuPR_GIVEN_NAME,
    imuPR_EMAIL_ADDRESS,
    imuPR_ADDRTYPE,
    imuMax
};
static const SizedSPropTagArray(imuMax, ptag)=
{
    imuMax,
    {
        PR_DISPLAY_NAME,
        PR_SURNAME,
        PR_GIVEN_NAME,
        PR_EMAIL_ADDRESS,
        PR_ADDRTYPE,
    }
};

void IPropTest(void) {
    LPPROPDATA lpPropData = NULL;
    SPropValue spv[imuMax];
    LPTSTR lpszDisplayName = "Bruce Kelley xxxxx";
    LPTSTR lpszEmailName = "brucek_xxxxx@microsoft.com";
    HRESULT hResult = hrSuccess;

    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;

    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    WABCreateIProp(NULL,
        (LPALLOCATEBUFFER)WABAllocateBuffer,
        (LPALLOCATEMORE)WABAllocateMore,
        (LPFREEBUFFER)WABFreeBuffer,
        NULL,
        &lpPropData);


    if (lpPropData) {

        spv[imuPR_EMAIL_ADDRESS].ulPropTag      = PR_EMAIL_ADDRESS;
        spv[imuPR_EMAIL_ADDRESS].Value.lpszA    = lpszEmailName;

        spv[imuPR_ADDRTYPE].ulPropTag           = PR_ADDRTYPE;
        spv[imuPR_ADDRTYPE].Value.lpszA         = "SMTP";

        spv[imuPR_DISPLAY_NAME].ulPropTag       = PR_DISPLAY_NAME;
        spv[imuPR_DISPLAY_NAME].Value.lpszA     = lpszDisplayName;

        spv[imuPR_SURNAME].ulPropTag            = PR_SURNAME;
        spv[imuPR_SURNAME].Value.lpszA          = "Kelley";

        spv[imuPR_GIVEN_NAME].ulPropTag         = PR_GIVEN_NAME;
        spv[imuPR_GIVEN_NAME].Value.lpszA       = "Bruce";

        if (HR_FAILED(hResult = lpPropData->lpVtbl->SetProps(lpPropData,   // this
          imuMax,                   // cValues
          spv,                      // property array
          NULL))) {                 // problems array
        }

        hResult = lpPropData->lpVtbl->SaveChanges(lpPropData,               // this
          0);                       // ulFlags


        lpPropData->lpVtbl->Release(lpPropData);
    }

    lpAdrBook->lpVtbl->Release(lpAdrBook);
    lpWABObject->lpVtbl->Release(lpWABObject);
}

#define WORKS_STUFF TRUE


#ifdef WORKS_STUFF
#define PR_WKS_CONTACT_CHECKED	 PROP_TAG( PT_LONG, 0x8020)
const SizedSPropTagArray(4 , ipta) = {
    4,                             // count of entries
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_OBJECT_TYPE,
        PR_WKS_CONTACT_CHECKED,
    }
};
#else
const SizedSPropTagArray(3 , ipta) = {
      3,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_OBJECT_TYPE,
    }
};
#endif



#ifdef WORKS_STUFF
#define nStatusCheck 1

HRESULT RestrictToContactAndCheck(LPMAPITABLE pWabTable)
{
    SRestriction resAnd[2];
    SRestriction resResolve;
    SPropValue propRestrict0, propRestrict1;
    HRESULT hr;

    // Restrict to get checked status
    resAnd[0].rt = RES_PROPERTY; // Restriction type Property
    resAnd[0].res.resProperty.relop = RELOP_EQ;
    resAnd[0].res.resProperty.ulPropTag = PR_WKS_CONTACT_CHECKED;
    resAnd[0].res.resProperty.lpProp = &propRestrict0;
    propRestrict0.ulPropTag = PR_WKS_CONTACT_CHECKED;
    propRestrict0.Value.ul = nStatusCheck; // this is actually a #define with value of 1


    // Restrict to get contact (MailUsers)
    resAnd[1].rt = RES_PROPERTY; // Restriction type Property
    resAnd[1].res.resProperty.relop = RELOP_EQ;
    resAnd[1].res.resProperty.ulPropTag = PR_OBJECT_TYPE;
    resAnd[1].res.resProperty.lpProp = &propRestrict1;
    propRestrict1.ulPropTag = PR_OBJECT_TYPE;
    propRestrict1.Value.ul = MAPI_MAILUSER;

    resResolve.rt = RES_AND;
    resResolve.res.resAnd.cRes = 2;
    resResolve.res.resAnd.lpRes = resAnd;

    hr = pWabTable->lpVtbl->Restrict(pWabTable, &resResolve, 0);
    return(hr);
}
#endif



#ifdef PHONE_STUFF

#define WAB_PHONE_TYPE_COUNT 2
ULONG WABPHONEPROPLIST[WAB_PHONE_TYPE_COUNT] = {
    PR_BUSINESS_TELEPHONE_NUMBER,
    PR_HOME_TELEPHONE_NUMBER
};

/*----------------------------------------------------------------------------

Purpose:  Given a phone number returns the Name in the WAB if exists.

Paramaters:
    LPCTSTR lpcstrInputNumber:    Input Number string
#ifdef OLD_STUFF
    LPTSTR  lptstrOutputName:     Output Name string
#endif // OLD_STUFF


History
02/10/97      a-ericwa  Created
----------------------------------------------------------------------------*/
HRESULT WABNumberToName(LPADRBOOK m_pAdrBook, LPCTSTR lpcstrInputNumber) {
    HRESULT hRes = NOERROR;
    LPENTRYID lpEntryID = NULL;
    LPABCONT lpContainer = NULL;
    LPMAPITABLE lpMapiTable = NULL;
    UINT  cColumn = 0;
    LPSPropValue lpPropValue = NULL;
    LPSRowSet lpRow = NULL;
    ULONG ulObjType = 0;
    ULONG ulCounter = 0;
    ULONG ulRowCount = 0;
    ULONG ulEntryIDSize = 0;
    LPSTR lpszTempOutput = NULL;
    BOOL bFound = FALSE;

    SRestriction srOr, srPhoneNumType[WAB_PHONE_TYPE_COUNT]; //for the restriction
    SPropValue spvPhoneNumType[WAB_PHONE_TYPE_COUNT];         // d dd ddd ditto

    SizedSPropTagArray(21, OUR_PROPTAG_ARRAY) = {
        21, {
            PR_OBJECT_TYPE,
            PR_ENTRYID,
            PR_DISPLAY_NAME,
            PR_CALLBACK_TELEPHONE_NUMBER,
            PR_BUSINESS_TELEPHONE_NUMBER,
            PR_OFFICE_TELEPHONE_NUMBER,
            PR_HOME_TELEPHONE_NUMBER,
            PR_PRIMARY_TELEPHONE_NUMBER,
            PR_BUSINESS2_TELEPHONE_NUMBER,
            PR_OFFICE2_TELEPHONE_NUMBER,
            PR_MOBILE_TELEPHONE_NUMBER,
            PR_CELLULAR_TELEPHONE_NUMBER,
            PR_RADIO_TELEPHONE_NUMBER,
            PR_CAR_TELEPHONE_NUMBER,
            PR_OTHER_TELEPHONE_NUMBER,
            PR_PAGER_TELEPHONE_NUMBER,
            PR_BEEPER_TELEPHONE_NUMBER,
            PR_ASSISTANT_TELEPHONE_NUMBER,
            PR_HOME2_TELEPHONE_NUMBER,
            PR_PRIMARY_FAX_NUMBER,
            PR_HOME_FAX_NUMBER,
        }
    };

    //validate input
    if (!lpcstrInputNumber) {
        goto WABNTN_Exit;
    }

    //Get the PAB
    hRes = m_pAdrBook->lpVtbl->GetPAB(m_pAdrBook,
      &ulEntryIDSize,     //size
      &lpEntryID);        //EntryId
    if (FAILED(hRes)) {
        goto WABNTN_Exit;
    }

    //Open the root container
    hRes = m_pAdrBook->lpVtbl->OpenEntry(m_pAdrBook,
      ulEntryIDSize,  // size of EntryID to open
      lpEntryID,      // EntryID to open
      NULL,           // interface
      0,              // flags  (default is Read Only)
      &ulObjType,     //object type
      (LPUNKNOWN *)&lpContainer); //returned object
    if (FAILED(hRes) || (ulObjType != MAPI_ABCONT)) {
        goto WABNTN_Exit;
    }


    //Get the contents
    hRes = lpContainer->lpVtbl->GetContentsTable(lpContainer,
      0,    //FLAGS
      &lpMapiTable);  //returned Table Object
    if (FAILED(hRes)) {
        goto WABNTN_Exit;
    }

    // Set desired columns
    hRes = lpMapiTable->lpVtbl->SetColumns(lpMapiTable,
      (LPSPropTagArray)&OUR_PROPTAG_ARRAY,   // SPropTagArray of desired rows
      0);                                    //  reserved Must be zero for the WAB
    if (FAILED(hRes)) {
        goto WABNTN_Exit;
    }

    //Seek to the beginning
    hRes = lpMapiTable->lpVtbl->SeekRow(lpMapiTable, BOOKMARK_BEGINNING, 0, NULL);
    if (FAILED(hRes)) {
        goto WABNTN_Exit;
    }

    //Create the restriction
    srOr.rt = RES_OR;
    srOr.res.resOr.cRes = WAB_PHONE_TYPE_COUNT;
    srOr.res.resOr.lpRes = srPhoneNumType;
    for (ulCounter = 0; ulCounter < WAB_PHONE_TYPE_COUNT; ulCounter++) {
        spvPhoneNumType[ulCounter].ulPropTag = WABPHONEPROPLIST[ulCounter];
        spvPhoneNumType[ulCounter].Value.lpszA = (LPSTR) lpcstrInputNumber;
        spvPhoneNumType[ulCounter].dwAlignPad = 0;

        srPhoneNumType[ulCounter].rt = RES_CONTENT;
        srPhoneNumType[ulCounter].res.resContent.ulFuzzyLevel = FL_SUBSTRING;   //Fuzzy level
        srPhoneNumType[ulCounter].res.resContent.ulPropTag = WABPHONEPROPLIST[ulCounter];
        srPhoneNumType[ulCounter].res.resContent.lpProp = &(spvPhoneNumType[ulCounter]);
    }

    //Set the restriction
    if (hRes = lpMapiTable->lpVtbl->Restrict(lpMapiTable, &srOr, 0)) {
        DebugTrace("Restrict -> %x\n", GetScode(hRes));
    }

    DebugMapiTable(lpMapiTable);

    //Did any match?
    hRes = lpMapiTable->lpVtbl->GetRowCount(lpMapiTable, 0, &ulRowCount);
    if (FAILED(hRes) || (!ulRowCount)) {
        goto WABNTN_Exit;
    }


    //Get the name of the first match
    for (ulCounter = 0; ulCounter < ulRowCount; ulCounter++) {
        //Found at least one row
        hRes = lpMapiTable->lpVtbl->QueryRows(lpMapiTable, 1, // one row at a time
          0, // ulFlags
          &lpRow);
        if (FAILED(hRes) || (!lpRow->cRows)) {
            goto WABNTN_Exit;
        }

        //Get the Dispay Name Data
        lpPropValue = lpRow->aRow[0].lpProps;
        for(cColumn = 0; cColumn < lpRow->aRow[0].cValues; cColumn++) {
            if (lpPropValue->ulPropTag == PR_DISPLAY_NAME) {

                bFound = TRUE;
                break;
            }
            lpPropValue++;
        }   // cColumn loop

        if (lpRow) {
            WABFreeBuffer(lpRow); lpRow = NULL;
        }
        if (bFound) {
            break;
        }

    } //ulCounter loop

WABNTN_Exit:
    if (lpMapiTable) {
        lpMapiTable->lpVtbl->Release(lpMapiTable);
    }
    if (lpContainer) {
        lpContainer->lpVtbl->Release(lpContainer);
    }
    if (lpEntryID) {
        WABFreeBuffer(lpEntryID);
    }

    return(hRes);
}
#endif


void GetSearchPathTest(void)
{
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;

    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    if (lpAdrBook) 
    {
        ULONG i = 0, j=0;
        LPTSTR lpsz = NULL;
        LPSRowSet lpsrs = NULL;
        hResult = lpAdrBook->lpVtbl->GetSearchPath( lpAdrBook,
                                                    0,
                                                    &lpsrs);
        if(lpsrs && lpsrs->cRows)
        {
            ULONG nLen = 0;
            for(i=0;i<lpsrs->cRows;i++)
            {
                for(j=0;j<lpsrs->aRow[i].cValues;j++)
                {
                    if(lpsrs->aRow[i].lpProps[j].ulPropTag == PR_DISPLAY_NAME)
                    {
                        nLen += lstrlen(lpsrs->aRow[i].lpProps[j].Value.LPSZ) + lstrlen("\r\n") + 1;
                        break;
                    }
                }
            }
            lpsz = LocalAlloc(LMEM_ZEROINIT, nLen);
            if(lpsz)
            {
                *lpsz = '\0';
                for(i=0;i<lpsrs->cRows;i++)
                {
                    for(j=0;j<lpsrs->aRow[i].cValues;j++)
                    {
                        if(lpsrs->aRow[i].lpProps[j].ulPropTag == PR_DISPLAY_NAME)
                        {
                            lstrcat(lpsz,lpsrs->aRow[i].lpProps[j].Value.LPSZ);
                            lstrcat(lpsz,"\r\n");
                            break;
                        }
                    }
                }
                MessageBox(NULL, lpsz, "List of ResolveName containers", MB_OK);
            }

            if(lpsz)
                LocalFree(lpsz);
            for(i=0;i<lpsrs->cRows;i++)
                WABFreeBuffer(lpsrs->aRow[i].lpProps);
            WABFreeBuffer(lpsrs);
        }

        lpAdrBook->lpVtbl->Release(lpAdrBook);
    }

    if (lpWABObject) 
    {
        lpWABObject->lpVtbl->Release(lpWABObject);
    }


}

void GetContentsTableTest(void) {
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPABCONT lpContainer = NULL;
    LPMAPITABLE lpContentsTable = NULL;
    ULONG ulObjType;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;


    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    if (lpAdrBook) {

#ifdef PHONE_STUFF
        WABNumberToName(lpAdrBook, "869-8347");
#endif

        if (! (hResult = GetContainerEID(lpAdrBook, &cbWABEID, &lpWABEID))) {
            if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
              cbWABEID,     // size of EntryID to open
              lpWABEID,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjType, (LPUNKNOWN *)&lpContainer))) {
                // Opened PAB container OK
                // Call GetContentsTable on it.

                if (! (hResult = lpContainer->lpVtbl->GetContentsTable(lpContainer,
                  0,    // ulFlags
                  &lpContentsTable))) {
                    SRestriction res;
                    SPropValue propRestrict;
                    SizedSSortOrderSet(1, sos) = {
                        1,
                        0,
                        0,
                        {
                            PR_DISPLAY_NAME,
                            TABLE_SORT_DESCEND
                        }
                    };

                    res.rt = RES_PROPERTY;
                    res.res.resProperty.relop = RELOP_EQ;
                    res.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
                    res.res.resProperty.lpProp = &propRestrict;
                    propRestrict.ulPropTag = PR_OBJECT_TYPE;
                    propRestrict.Value.ul = MAPI_DISTLIST; // MAPI_MAILUSER for Contact


                    hResult = lpContentsTable->lpVtbl->Restrict(lpContentsTable, &res, 0);


                    lpContentsTable->lpVtbl->SetColumns(lpContentsTable,
                      (LPSPropTagArray)&ipta, 0);

                    DebugMapiTable(lpContentsTable);

                    hResult = lpContentsTable->lpVtbl->SortTable(lpContentsTable,
                      (LPSSortOrderSet)&sos, 0);

//                    RestrictToContactAndCheck(lpContentsTable);

                    DebugMapiTable(lpContentsTable);

                    lpContentsTable->lpVtbl->Release(lpContentsTable);
                }

                lpContainer->lpVtbl->Release(lpContainer);
            }
            WABFreeBuffer(lpWABEID);
        }

        lpAdrBook->lpVtbl->Release(lpAdrBook);
    }
    if (lpWABObject) {
        lpWABObject->lpVtbl->Release(lpWABObject);
    }
}


extern LPALLOCATEBUFFER lpfnMAPIAllocateBuffer;
extern LPALLOCATEMORE lpfnMAPIAllocateMore;
extern LPFREEBUFFER lpfnMAPIFreeBuffer;
extern HRESULT MAPIInitialize(LPVOID lpMapiInit);


void WABOpenTest(void) {
    LPWABOBJECT lpWABObject1 = NULL, lpWABObject2 = NULL;
    LPADRBOOK lpAdrBook1 = NULL, lpAdrBook2 = NULL;
    LPABCONT lpContainer = NULL;
    HRESULT hResult = hrSuccess;
    LPTSTR lpBuffer1 = NULL;
    LPTSTR lpBuffer2 = NULL;
    ULONG ulObjType;
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;


    hResult = WABOpen(&lpAdrBook1, &lpWABObject1, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject1);


    if (!hResult) {
        if (! (hResult = WABOpen(&lpAdrBook2, &lpWABObject2, NULL, 0))) {
            lpWABObject2->lpVtbl->Release(lpWABObject2);
            lpAdrBook2->lpVtbl->Release(lpAdrBook2);
            lpAdrBook2 = NULL;
        }
    }

    if (lpAdrBook1) {
        if (! (hResult = GetContainerEID(lpAdrBook1, &cbWABEID, &lpWABEID))) {

            if (! (hResult = lpAdrBook1->lpVtbl->OpenEntry(lpAdrBook1,
              cbWABEID,     // size of EntryID to open
              lpWABEID,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjType, (LPUNKNOWN *)&lpContainer))) {
            // Opened container OK

            lpContainer->lpVtbl->Release(lpContainer);
            }
            WABFreeBuffer(lpWABEID);
        }


        lpAdrBook1->lpVtbl->Release(lpAdrBook1);
        lpAdrBook1 = NULL;
    }
    if (lpWABObject1) {

        lpWABObject1->lpVtbl->AllocateBuffer(lpWABObject1, 1234, &lpBuffer1);
        lpWABObject1->lpVtbl->AllocateMore(lpWABObject1, 4321, lpBuffer1, &lpBuffer2);
        lpWABObject1->lpVtbl->FreeBuffer(lpWABObject1, lpBuffer1);

        lpWABObject1->lpVtbl->Release(lpWABObject1);
        lpWABObject1 = NULL;
    }


    // Try WABOpenEx

    MAPIInitialize(NULL);

    WABOpenEx(&lpAdrBook1, &lpWABObject1, NULL, 0,
      lpfnMAPIAllocateBuffer,
      lpfnMAPIAllocateMore,
      lpfnMAPIFreeBuffer);
    SetGlobalBufferFunctions(lpWABObject1);

    if (lpAdrBook1) {
        if (! (hResult = GetContainerEID(lpAdrBook1, &cbWABEID, &lpWABEID))) {

            if (! (hResult = lpAdrBook1->lpVtbl->OpenEntry(lpAdrBook1,
              cbWABEID,     // size of EntryID to open
              lpWABEID,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjType, (LPUNKNOWN *)&lpContainer))) {
                // Opened container OK
                LPMAPITABLE lpContentsTable = NULL;

                if (! (hResult = lpContainer->lpVtbl->GetContentsTable(lpContainer,
                  0,    // ulFlags
                  &lpContentsTable))) {
                    SRestriction res;
                    SPropValue propRestrict;
                    SizedSSortOrderSet(1, sos) = {
                        1,
                        0,
                        0,
                        {
                            PR_DISPLAY_NAME,
                            TABLE_SORT_DESCEND
                        }
                    };

                    res.rt = RES_PROPERTY;
                    res.res.resProperty.relop = RELOP_EQ;
                    res.res.resProperty.ulPropTag = PR_OBJECT_TYPE;
                    res.res.resProperty.lpProp = &propRestrict;
                    propRestrict.ulPropTag = PR_OBJECT_TYPE;
                    propRestrict.Value.ul = MAPI_DISTLIST; // MAPI_MAILUSER for Contact


                    hResult = lpContentsTable->lpVtbl->Restrict(lpContentsTable, &res, 0);


                    lpContentsTable->lpVtbl->SetColumns(lpContentsTable,
                      (LPSPropTagArray)&ipta, 0);

                    DebugMapiTable(lpContentsTable);

                    hResult = lpContentsTable->lpVtbl->SortTable(lpContentsTable,
                      (LPSSortOrderSet)&sos, 0);

//                    RestrictToContactAndCheck(lpContentsTable);

                    DebugMapiTable(lpContentsTable);

                    lpContentsTable->lpVtbl->Release(lpContentsTable);
                }

                lpContainer->lpVtbl->Release(lpContainer);
            }
            WABFreeBuffer(lpWABEID);
        }


        lpAdrBook1->lpVtbl->Release(lpAdrBook1);
        lpAdrBook1 = NULL;
    }
    if (lpWABObject1) {

        lpWABObject1->lpVtbl->AllocateBuffer(lpWABObject1, 1234, &lpBuffer1);
        lpWABObject1->lpVtbl->AllocateMore(lpWABObject1, 4321, lpBuffer1, &lpBuffer2);
        lpWABObject1->lpVtbl->FreeBuffer(lpWABObject1, lpBuffer1);

        lpWABObject1->lpVtbl->Release(lpWABObject1);
        lpWABObject1 = NULL;
    }
}




//
// BUGBUG: Notifications are NOT YET IMPLEMENTED in WAB!
//
#undef	INTERFACE
#define	INTERFACE	struct _ADVS

#undef MAPIMETHOD_
#define MAPIMETHOD_(type, method)	MAPIMETHOD_DECLARE(type, method, ADVS_)
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIADVISESINK_METHODS(IMPL)
#undef	MAPIMETHOD_
#define MAPIMETHOD_(type, method)	STDMETHOD_(type, method)

DECLARE_MAPI_INTERFACE(ADVS_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIADVISESINK_METHODS(IMPL)
};


typedef struct _ADVS FAR *LPADVS;

typedef struct _ADVS
{
	ADVS_Vtbl *		lpVtbl;
	UINT			cRef;
	LPMALLOC		pmalloc;
	LPVOID			lpvContext;
  LPNOTIFCALLBACK	lpfnCallback;
} ADVS;


ADVS_Vtbl vtblADVS =
{
	ADVS_QueryInterface,
	ADVS_AddRef,
	ADVS_Release,
	ADVS_OnNotify
};


STDMETHODIMP
ADVS_QueryInterface(LPADVS padvs, REFIID lpiid, LPVOID *ppvObj)
{
	HRESULT	hr;

	if (IsEqualMAPIUID((LPMAPIUID)lpiid, (LPMAPIUID)&IID_IUnknown) ||
		IsEqualMAPIUID((LPMAPIUID)lpiid, (LPMAPIUID)&IID_IMAPIAdviseSink))
	{
		++padvs->cRef;
		*ppvObj = padvs;
		hr = hrSuccess;
	} else {
		*ppvObj = NULL;
		hr = ResultFromScode(E_NOINTERFACE);
	}
	return hr;
}

STDMETHODIMP_(ULONG)
ADVS_AddRef(LPADVS padvs)
{
	return((ULONG)(++padvs->cRef));
}

STDMETHODIMP_(ULONG)
ADVS_Release(LPADVS padvs)
{
	if (--(padvs->cRef) == 0)
	{
		WABFreeBuffer(padvs);
		return 0L;
	}

	return (ULONG)padvs->cRef;
}

STDMETHODIMP_(ULONG)
ADVS_OnNotify(LPADVS padvs, ULONG cNotif, LPNOTIFICATION lpNotif)
{
	return (*(padvs->lpfnCallback))(padvs->lpvContext, cNotif, lpNotif);
}



void NotificationsTest(HWND hwnd) {
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPABCONT lpContainer = NULL;
    HRESULT hResult = hrSuccess;
    ULONG ulObjType;
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;
    ULONG ulConnection = 0;
    LPMAPIADVISESINK lpAdvs = NULL;


    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);


    if (lpAdrBook) {
        if (! (hResult = GetContainerEID(lpAdrBook, &cbWABEID, &lpWABEID))) {

            if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
              cbWABEID,     // size of EntryID to open
              lpWABEID,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjType, (LPUNKNOWN *)&lpContainer))) {
                // Opened container OK

                // Create the Advise Sink Object
                WABAllocateBuffer(sizeof(ADVS), &lpAdvs);
                ZeroMemory(lpAdvs, sizeof(ADVS));
                lpAdvs->lpVtbl = (struct IMAPIAdviseSinkVtbl *)&vtblADVS;
                lpAdvs->lpVtbl->AddRef(lpAdvs);


                // Call Advise on address book object
                if (! (hResult = lpAdrBook->lpVtbl->Advise(lpAdrBook,
                  cbWABEID,
                  lpWABEID,
                  fnevObjectCreated | fnevObjectDeleted | fnevObjectModified,
                  lpAdvs,
                  &ulConnection))) {

                    // Advise succeeded.
                    // Do something to fire a notification
                    WABAddressTest(hwnd, ADDRESS_CONTENTS_BROWSE_MODAL, 0);

                    if (! (hResult = lpAdrBook->lpVtbl->Unadvise(lpAdrBook,
                      ulConnection))) {

                    }
                }

                lpAdvs->lpVtbl->Release(lpAdvs);

                lpContainer->lpVtbl->Release(lpContainer);
            }
            WABFreeBuffer(lpWABEID);
        }


        lpAdrBook->lpVtbl->Release(lpAdrBook);
    }
    if (lpWABObject) {
        lpWABObject->lpVtbl->Release(lpWABObject);
    }
}


void ResolveNamesTest(HWND hwnd) {
#define MAX_INPUT_STRING    200
    TCHAR lpszInput[MAX_INPUT_STRING + 1] = "";
    LPADRLIST lpAdrList = NULL;
    ULONG rgFlagList[2];
    LPFlagList lpFlagList = (LPFlagList)rgFlagList;
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPABCONT lpContainer = NULL;
    ULONG ulObjType;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;


    if (InputString(hInst, hwnd, szAppName, "Resolve Name", lpszInput, MAX_INPUT_STRING)) {

        hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        SetGlobalBufferFunctions(lpWABObject);

        if (lpAdrBook) {
            if (! (hResult = GetContainerEID(lpAdrBook, &cbWABEID, &lpWABEID))) {

                if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                  cbWABEID,     // size of EntryID to open
                  lpWABEID,     // EntryID to open
                  NULL,         // interface
                  0,            // flags
                  &ulObjType, (LPUNKNOWN *)&lpContainer))) {
                    // Opened container OK
                    // Call ResolveNames on it.

                    if (! (sc = WABAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), &lpAdrList))) {
                        lpAdrList->cEntries = 1;
                        lpAdrList->aEntries[0].ulReserved1 = 0;
                        lpAdrList->aEntries[0].cValues = 1;
                        if (! (sc = WABAllocateBuffer(sizeof(SPropValue), &lpAdrList->aEntries[0].rgPropVals))) {

                            lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
                            lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput;

                            lpFlagList->cFlags = 1;
                            lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

                            if (! (hResult = lpContainer->lpVtbl->ResolveNames(lpContainer,
                              NULL,            // tag set
                              0,               // ulFlags
                              lpAdrList,
                              lpFlagList))) {
                                DebugADRLIST(lpAdrList, "Resolved ADRLIST");
                            }
                        }

                        WABFreePadrlist(lpAdrList);
                    }

                    lpContainer->lpVtbl->Release(lpContainer);
                }
                WABFreeBuffer(lpWABEID);
            }

            lpAdrBook->lpVtbl->Release(lpAdrBook);
        }
        if (lpWABObject) {
            lpWABObject->lpVtbl->Release(lpWABObject);
        }
    }
}


// enum for setting the created properties
enum {
    irnPR_DISPLAY_NAME = 0,
    irnPR_RECIPIENT_TYPE,
    irnPR_ENTRYID,
    irnPR_EMAIL_ADDRESS,
    irnMax
};

void ResolveNameTest(HWND hwnd) {
    TCHAR lpszInput1[MAX_INPUT_STRING + 1] = "";
    TCHAR lpszInput2[MAX_INPUT_STRING + 1] = "";
    LPADRLIST lpAdrList = NULL;
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG ulObjectType;
    LPMAILUSER lpMailUser = NULL;
    ULONG i = 0;


    if (InputString(hInst, hwnd, szAppName, "Resolve Name", lpszInput1, MAX_INPUT_STRING)) {

        hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        SetGlobalBufferFunctions(lpWABObject);

        if (lpAdrBook) {
            if (! (sc = WABAllocateBuffer(sizeof(ADRLIST) + 5 * sizeof(ADRENTRY), &lpAdrList))) {
                lpAdrList->cEntries = 5;
                for (i = 0; i < lpAdrList->cEntries; i++) {
                    lpAdrList->aEntries[i].cValues = 0;
                    lpAdrList->aEntries[i].rgPropVals = NULL;
                }


                lpAdrList->aEntries[0].ulReserved1 = 0;
                lpAdrList->aEntries[0].cValues = irnMax - 1;    // No PR_EMAIL_ADDRESS;
                if (! (sc = WABAllocateBuffer(lpAdrList->aEntries[0].cValues * sizeof(SPropValue),
                   &lpAdrList->aEntries[0].rgPropVals))) {

                    lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
                    lpAdrList->aEntries[0].rgPropVals[irnPR_DISPLAY_NAME].Value.LPSZ = lpszInput1;

                    lpAdrList->aEntries[0].rgPropVals[irnPR_RECIPIENT_TYPE].ulPropTag = PR_RECIPIENT_TYPE;
                    lpAdrList->aEntries[0].rgPropVals[irnPR_RECIPIENT_TYPE].Value.l = MAPI_TO;

                    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].ulPropTag = PR_ENTRYID;
                    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.cb = 0;
                    lpAdrList->aEntries[0].rgPropVals[irnPR_ENTRYID].Value.bin.lpb = NULL;


                    hResult = lpAdrBook->lpVtbl->ResolveName(lpAdrBook,
                      (ULONG)hwnd,            // ulUIParam
                      MAPI_DIALOG,            // ulFlags
                      "APITest ResolveName",  // lpszNewEntryTitle
                      lpAdrList);

                    DebugTrace("ResolveName [%s] -> %x\n", lpszInput1, GetScode(hResult));

                    if (! HR_FAILED(hResult)) {
                        // Open the entry and dump it's properties

                        // Should have PR_ENTRYID in rgPropVals[2]
                        if (lpAdrList->aEntries[0].rgPropVals[2].ulPropTag == PR_ENTRYID) {

                            if (! (HR_FAILED(hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                      lpAdrList->aEntries[0].rgPropVals[2].Value.bin.cb,
                                                      (LPENTRYID)lpAdrList->aEntries[0].rgPropVals[2].Value.bin.lpb,
                                                      NULL,
                                                      0,
                                                      &ulObjectType,
                                                      (LPUNKNOWN *)&(lpMailUser))))) {
                                DebugObjectProps((LPMAPIPROP)lpMailUser, "Resolved Entry Properties");
                                lpMailUser->lpVtbl->Release(lpMailUser);
                            }
                        } else {
                            DebugTrace("Hey!  What happened to my PR_ENTRYID?\n");
                        }
                    }
                }
            }

            WABFreePadrlist(lpAdrList);

            lpAdrBook->lpVtbl->Release(lpAdrBook);
        }
        if (lpWABObject) {
            lpWABObject->lpVtbl->Release(lpWABObject);
        }
    }
}


// enum for getting the entryid of an entry
enum {
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
    ieidMax
};
static const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
    }
};

enum {
    iconPR_DEF_CREATE_MAILUSER = 0,
    iconPR_DEF_CREATE_DL,
    iconMax
};
static const SizedSPropTagArray(iconMax, ptaCon)=
{
    iconMax,
    {
        PR_DEF_CREATE_MAILUSER,
        PR_DEF_CREATE_DL,
    }
};

void DeleteEntriesTest(HWND hwnd) {
    TCHAR lpszInput[MAX_INPUT_STRING + 1] = "";
    LPADRLIST lpAdrList = NULL;
    ULONG rgFlagList[2];
    LPFlagList lpFlagList = (LPFlagList)rgFlagList;
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPABCONT lpContainer = NULL;
    ULONG ulObjType;
    SCODE sc = SUCCESS_SUCCESS;
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;
    ENTRYLIST EntryList;


    if (InputString(hInst, hwnd, szAppName, "Resolve Name", lpszInput, MAX_INPUT_STRING)) {

        hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        SetGlobalBufferFunctions(lpWABObject);

        if (lpAdrBook) {
            if (! (hResult = GetContainerEID(lpAdrBook, &cbWABEID, &lpWABEID))) {

                if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                  cbWABEID,     // size of EntryID to open
                  lpWABEID,     // EntryID to open
                  NULL,         // interface
                  0,            // flags
                  &ulObjType, (LPUNKNOWN *)&lpContainer))) {
                    // Opened container OK
                    // Call ResolveNames on it.

                    if (! (sc = WABAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), &lpAdrList))) {
                        lpAdrList->cEntries = 1;
                        lpAdrList->aEntries[0].ulReserved1 = 0;
                        lpAdrList->aEntries[0].cValues = 1;
                        if (! (sc = WABAllocateBuffer(ieidMax * sizeof(SPropValue),
                          &lpAdrList->aEntries[0].rgPropVals))) {

                            lpAdrList->aEntries[0].rgPropVals[ieidPR_DISPLAY_NAME].ulPropTag = PR_DISPLAY_NAME;
                            lpAdrList->aEntries[0].rgPropVals[ieidPR_DISPLAY_NAME].Value.LPSZ = lpszInput;

                            lpAdrList->aEntries[0].rgPropVals[ieidPR_ENTRYID].ulPropTag = PR_ENTRYID;
                            lpAdrList->aEntries[0].rgPropVals[ieidPR_ENTRYID].Value.bin.cb = 0;
                            lpAdrList->aEntries[0].rgPropVals[ieidPR_ENTRYID].Value.bin.lpb = NULL;

                            lpFlagList->cFlags = 1;
                            lpFlagList->ulFlag[0] = MAPI_UNRESOLVED;

                            lpContainer->lpVtbl->ResolveNames(lpContainer,
                              (LPSPropTagArray)&ptaEid,         // tag set
                              0,               // ulFlags
                              lpAdrList,
                              lpFlagList);

                            if (lpFlagList->ulFlag[0] != MAPI_RESOLVED) {
                                DebugTrace("Couldn't resolve name %s\n", lpszInput);
                            } else {
                                // Create a list of entryid's to delete
                                EntryList.cValues = 1;
                                EntryList.lpbin = &(lpAdrList->aEntries[0].rgPropVals[ieidPR_ENTRYID].Value.bin);


                                // Now, delete the entry found.
                                if (hResult = lpContainer->lpVtbl->DeleteEntries(lpContainer,
                                  &EntryList,
                                  0)) {
                                    DebugTrace("DeleteEntries -> %x", hResult);
                                }
                            }
                        }

                        WABFreePadrlist(lpAdrList);
                    }

                    lpContainer->lpVtbl->Release(lpContainer);
                }
                WABFreeBuffer(lpWABEID);
            }

            lpAdrBook->lpVtbl->Release(lpAdrBook);
        }
        if (lpWABObject) {
            lpWABObject->lpVtbl->Release(lpWABObject);
        }
    }
}


void TestNamedProps(LPMAILUSER lpEntry) {
    MAPINAMEID mnidT1;
    LPMAPINAMEID lpmnidT1;
    HRESULT hr;
    GUID guidT1 = { /* 13fbb976-15a2-11d0-9b9f-00c04fd90294 */
      0x13fbb976,
      0x15a2,
      0x11d0,
      {0x9b, 0x9f, 0x00, 0xc0, 0x4f, 0xd9, 0x02, 0x94}
    };


    LPSPropTagArray lptaga = NULL;
    SPropValue spv;
    MAPINAMEID mnidT2;
    LPMAPINAMEID lpmnidT2;
    GUID guidT2 = { /* 39f110d8-15a2-11d0-9b9f-00c04fd90294 */
      0x39f110d8,
      0x15a2,
      0x11d0,
      {0x9b, 0x9f, 0x00, 0xc0, 0x4f, 0xd9, 0x02, 0x94}
    };

    //
    //  We just made up that GUID.  On NT try uuidgen -s to get your own
    //

    mnidT1.lpguid = &guidT1;
    mnidT1.ulKind = MNID_ID;        //  This means union will contain a long...
    mnidT1.Kind.lID = 0x00000001;   // numeric property 1

    lpmnidT1 = &mnidT1;

    hr = lpEntry->lpVtbl->GetIDsFromNames(lpEntry,
      1, // Just one name
      &lpmnidT1, // &-of because this is an array
      MAPI_CREATE, // This is where MAPI_CREATE might go
      &lptaga);
    if (hr) {
        //
        //  I'd really be suprised if I got S_OK for this...
        //
        if (GetScode(hr) != MAPI_W_ERRORS_RETURNED) {
            //  Real error here
            goto out;
        }

        //  Basically, this means you don't have anything by this name and you
        //  didn't ask the object to create it.

        //$ no biggie
    }

    //  Free the lptaga, as it was allocated by the object and returned to the calling
    //  app.
    WABFreeBuffer(lptaga);


    //
    //  And here's how to successfully add a named property to an object.  In this case
    //  we'll slap on in and I'll demonstrate how to use this new property.
    //
    //
    //  We just made up that GUID.  On NT try uuidgen -s to get your own
    //

    mnidT2.lpguid = &guidT2;
    mnidT2.ulKind = MNID_STRING;    //  This means union will contain a UNICODE string...
    mnidT2.Kind.lpwstrName = L"Check out this cool property!";

    lpmnidT2 = &mnidT2;

    hr = lpEntry->lpVtbl->GetIDsFromNames(lpEntry,
      1, // Just one name
      &lpmnidT2, // &-of because this is an array
      MAPI_CREATE,
      &lptaga);
    if (hr) {
        //
        //  I'd really be suprised if I got S_OK for this...
        //
        if (GetScode(hr) != MAPI_W_ERRORS_RETURNED) {
            //  Real error here
            goto out;
        }

        //  Basically, this means you don't have anything by this name and you
        //  didn't ask the object to create it.

        //$ no biggie
    }

    //
    //  Ok, so what can I do with this ptaga?  Well, we can set a value for it by doing:
    //
    spv.ulPropTag = CHANGE_PROP_TYPE(lptaga->aulPropTag[0],PT_STRING8);
    spv.Value.lpszA = "This property brought to you by the letter M";

    hr = lpEntry->lpVtbl->SetProps(lpEntry,
      1,
      &spv,
      NULL);
    if (HR_FAILED(hr)) {
        goto out;
    }

    lpEntry->lpVtbl->SaveChanges(lpEntry,               // this
      KEEP_OPEN_READONLY);      // ulFlags

    DebugObjectProps((LPMAPIPROP)lpEntry, "");


    lpEntry->lpVtbl->DeleteProps(lpEntry, lptaga, NULL);


    DebugObjectProps((LPMAPIPROP)lpEntry, "");

    //  Free the lptaga, as it was allocated by the object and returned to the calling
    //  app.
    WABFreeBuffer(lptaga);
out:
    return;
}


void CreateEntryTest(HWND hwnd, BOOL fDL) {
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPABCONT lpContainer = NULL;
    HRESULT hResult = hrSuccess;
    LPTSTR lpBuffer1 = NULL;
    LPTSTR lpBuffer2 = NULL;
    ULONG ulObjType;
    LPMAPIPROP lpMailUser = NULL;
    SPropValue spv[imuMax];
    TCHAR lpszDisplayName[MAX_INPUT_STRING + 1] = "";
    TCHAR lpszEmailName[MAX_INPUT_STRING + 1] = "brucek_xxxxx@microsoft.com";
    ULONG ulContactNumber;
    ULONG cbWABEID;
    LPENTRYID lpWABEID = NULL;
    LPSPropValue lpCreateEIDs = NULL;
    LPSPropValue lpNewDLProps = NULL;
    ULONG cProps;
    ULONG ulObjectType;
    LPDISTLIST lpDistList = NULL;
    LPBYTE lpBuffer;


    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    if (lpAdrBook) {
        if (! (hResult = GetContainerEID(lpAdrBook, &cbWABEID, &lpWABEID))) {

            if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
              cbWABEID,     // size of EntryID to open
              lpWABEID,     // EntryID to open
              NULL,         // interface
              0,            // flags
              &ulObjType, (LPUNKNOWN *)&lpContainer))) {
                // Opened PAB container OK
                DebugObjectProps((LPMAPIPROP)lpContainer, "WAB Container");

                ulContactNumber = GetNewMessageReference();
                if (! InputString(hInst, hwnd, szAppName, "Create Entry Name", lpszDisplayName, sizeof(lpszDisplayName))) {
                    wsprintf(lpszDisplayName, "Bruce Kelley %05u", ulContactNumber);
                }

                wsprintf(lpszEmailName, "brucek_%05u@microsoft.com", ulContactNumber);

                // Get us the creation entryids
                if ((hResult = lpContainer->lpVtbl->GetProps(lpContainer, (LPSPropTagArray)&ptaCon, 0, &cProps, &lpCreateEIDs))) {
                    DebugTrace("Can't get container properties for PAB\n");
                    // Bad stuff here!
                    return;
                }

                // Validate the properites
                if (lpCreateEIDs[iconPR_DEF_CREATE_MAILUSER].ulPropTag != PR_DEF_CREATE_MAILUSER ||
                  lpCreateEIDs[iconPR_DEF_CREATE_DL].ulPropTag != PR_DEF_CREATE_DL) {
                    DebugTrace("Container property errors\n");
                    return;
                }

                if (fDL) {
                    LPDISTLIST lpNewObj = NULL;

                    // Create the default DL
                    if (! (hResult = lpContainer->lpVtbl->CreateEntry(lpContainer,
                      lpCreateEIDs[iconPR_DEF_CREATE_DL].Value.bin.cb,
                      (LPENTRYID)lpCreateEIDs[iconPR_DEF_CREATE_DL].Value.bin.lpb,
                      CREATE_CHECK_DUP_STRICT,
                      &lpMailUser))) {


                        // Set the display name
                        spv[imuPR_DISPLAY_NAME].ulPropTag       = PR_DISPLAY_NAME;
                        spv[imuPR_DISPLAY_NAME].Value.lpszA     = lpszDisplayName;

                        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,   // this
                          1,                        // cValues
                          spv,                      // property array
                          NULL))) {                 // problems array
                        }

                        hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser,               // this
                          KEEP_OPEN_READONLY);      // ulFlags

                        DebugObjectProps((LPMAPIPROP)lpMailUser, "New Distribution List");


                        lpNewObj = NULL;
                        lpMailUser->lpVtbl->QueryInterface(lpMailUser,
                          &IID_IDistList,
                          &lpNewObj);

                        if (lpNewObj) {
                            (lpNewObj)->lpVtbl->Release(lpNewObj);
                        }


                        // Get the EntryID so we can open it...
                        if ((hResult = lpMailUser->lpVtbl->GetProps(lpMailUser,
                          (LPSPropTagArray)&ptaEid,
                          0,
                          &cProps,
                          &lpNewDLProps))) {
                            DebugTrace("Can't get DL properties\n");
                            // Bad stuff here!
                            return;
                        }

                        lpMailUser->lpVtbl->Release(lpMailUser);

                        // Now, open the new entry as a DL
                        hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                          lpNewDLProps[ieidPR_ENTRYID].Value.bin.cb,
                          (LPENTRYID)lpNewDLProps[ieidPR_ENTRYID].Value.bin.lpb,
                          (LPIID)&IID_IDistList,
                          MAPI_MODIFY,
                          &ulObjectType,
                          (LPUNKNOWN*)&lpDistList);
                        if (lpDistList) {
                            ADRPARM AdrParms = {0};
                            LPADRLIST lpAdrList = NULL;
                            ULONG i;
                            LPSBinary lpsbEntryID;
                            LPMAPIPROP lpEntry = NULL;
                            LPMAPITABLE lpContentsTable = NULL;

                            // Do something with the DL object
                            // Add an entry to the DL

                            // Get entries to add.
                            AdrParms.ulFlags = DIALOG_MODAL;
                            AdrParms.lpszCaption = "Choose entries for this Distribution List";
                            AdrParms.cDestFields = 1;

                            hResult = lpAdrBook->lpVtbl->Address(lpAdrBook,
                              (LPULONG)&hwnd,
                              &AdrParms,
                              &lpAdrList);

                            if (! hResult && lpAdrList) {
                                for (i = 0; i < lpAdrList->cEntries; i++) {
                                    if (lpsbEntryID = FindAdrEntryID(lpAdrList, i)) {
                                        if (hResult = lpDistList->lpVtbl->CreateEntry(lpDistList,
                                          lpsbEntryID->cb,
                                          (LPENTRYID)lpsbEntryID->lpb,
                                          CREATE_CHECK_DUP_STRICT,
                                          &lpEntry)) {

                                            break;
                                        }

                                        hResult = lpEntry->lpVtbl->SaveChanges(lpEntry, FORCE_SAVE);

                                        if (lpEntry) {
                                            lpEntry->lpVtbl->Release(lpEntry);
                                            lpEntry = NULL;
                                        }
                                    }
                                }

                                DebugObjectProps((LPMAPIPROP)lpDistList, "Distribution List");

                                // Open the table object on the DL

                                if (! (hResult = lpDistList->lpVtbl->GetContentsTable(lpDistList,
                                  0,
                                  &lpContentsTable))) {
                                    ULONG ulRowCount;

                                    if (hResult = lpContentsTable->lpVtbl->GetRowCount(lpContentsTable,
                                      0,
                                      &ulRowCount)) {
                                        DebugTrace("GetRowCount -> %x\n", hResult);
                                    } else {
                                        DebugTrace("GetRowCount found %u rows\n", ulRowCount);
                                    }

                                    DebugTrace("Distribution list contents:\n");
                                    DebugMapiTable(lpContentsTable);

                                    lpContentsTable->lpVtbl->Release(lpContentsTable);
                                }

                                // Delete the entry from the DL
                                {
                                    ENTRYLIST el;


                                    el.cValues = 1;
                                    el.lpbin = lpsbEntryID;

                                    if (hResult = lpDistList->lpVtbl->DeleteEntries(lpDistList,
                                      &el,
                                      0)) {
                                        DebugTrace("DISTLIST_DeleteEntries -> %x\n", GetScode(hResult));
                                    }
                                }


                            }
                            if (lpAdrList) {
                                WABFreePadrlist(lpAdrList);
                            }

                            lpDistList->lpVtbl->Release(lpDistList);
                        }

                        if (lpNewDLProps) {
                            WABFreeBuffer(lpNewDLProps);
                        }
                    }
                } else {
                    if (! (hResult = lpContainer->lpVtbl->CreateEntry(lpContainer,
                      lpCreateEIDs[iconPR_DEF_CREATE_MAILUSER].Value.bin.cb,
                      (LPENTRYID)lpCreateEIDs[iconPR_DEF_CREATE_MAILUSER].Value.bin.lpb,
                      CREATE_CHECK_DUP_STRICT,
                      &lpMailUser))) {
                        // Successful creation of entry.  Do something with it.

#ifdef OLD_STUFF
                        // Try saving with no props.  Should fail.
                        hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser,               // this
                          KEEP_OPEN_READONLY);      // ulFlags


                        // Try just setting PR_COMPANY_NAME
                        spv[0].ulPropTag      = PR_COMPANY_NAME;
                        spv[0].Value.lpszA    = "Somebody's Company";
                        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,   // this
                          1,                        // cValues
                          spv,                      // property array
                          NULL))) {                 // problems array
                        }

                        hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser,               // this
                          KEEP_OPEN_READONLY);      // ulFlags

                        DebugObjectProps((LPMAPIPROP)lpMailUser, "New MailUser");

#endif // OLD_STUFF

                        spv[imuPR_EMAIL_ADDRESS].ulPropTag      = PR_EMAIL_ADDRESS;
                        spv[imuPR_EMAIL_ADDRESS].Value.lpszA    = lpszEmailName;

                        spv[imuPR_ADDRTYPE].ulPropTag           = PR_ADDRTYPE;
                        spv[imuPR_ADDRTYPE].Value.lpszA         = "SMTP";
                        spv[imuPR_DISPLAY_NAME].ulPropTag       = PR_DISPLAY_NAME;
                        spv[imuPR_DISPLAY_NAME].Value.lpszA     = lpszDisplayName;

                        spv[imuPR_SURNAME].ulPropTag = PR_NULL;
                        spv[imuPR_GIVEN_NAME].ulPropTag = PR_NULL;

#ifdef OLD_STUFF
// This case exercises the display name regeneration
                        spv[imuPR_DISPLAY_NAME].ulPropTag       = PR_DISPLAY_NAME;
                        spv[imuPR_DISPLAY_NAME].Value.lpszA     = "Stan Freck";

                        spv[imuPR_SURNAME].ulPropTag            = PR_SURNAME;
                        spv[imuPR_SURNAME].Value.lpszA          = "Freck";

                        spv[imuPR_GIVEN_NAME].ulPropTag         = PR_GIVEN_NAME;
                        spv[imuPR_GIVEN_NAME].Value.lpszA       = "Stanley";
#endif


                        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,   // this
                          imuMax,                   // cValues
                          spv,                      // property array
                          NULL))) {                 // problems array
                        }


#define ICON_SIZE   100000
                        WABAllocateBuffer(ICON_SIZE, &lpBuffer);
                        FillMemory(lpBuffer, ICON_SIZE, 'B');

                        spv[0].ulPropTag = PR_ICON;
                        spv[0].Value.bin.cb = ICON_SIZE;
                        spv[0].Value.bin.lpb = lpBuffer;

                        if (HR_FAILED(hResult = lpMailUser->lpVtbl->SetProps(lpMailUser,   // this
                          1,                   // cValues
                          spv,                      // property array
                          NULL))) {                 // problems array
                        }

                        WABFreeBuffer(lpBuffer);

                        TestNamedProps((LPMAILUSER)lpMailUser);

                        hResult = lpMailUser->lpVtbl->SaveChanges(lpMailUser,               // this
                          KEEP_OPEN_READONLY);      // ulFlags


                        DebugObjectProps((LPMAPIPROP)lpMailUser, "New MailUser");

                        lpMailUser->lpVtbl->Release(lpMailUser);
                    }
                }

                WABFreeBuffer(lpCreateEIDs);

                lpContainer->lpVtbl->Release(lpContainer);

            }
            WABFreeBuffer(lpWABEID);
        }


        lpAdrBook->lpVtbl->Release(lpAdrBook);
    }
    if (lpWABObject) {
        lpWABObject->lpVtbl->Release(lpWABObject);
    }
}

void STDMETHODCALLTYPE TestDismissFunction(ULONG ulUIParam, LPVOID lpvContext)
{
    LPDWORD lpdw = (LPDWORD) lpvContext;
    DebugTrace("TestDismissFunction [5x]:[%d]\n",ulUIParam,*lpdw);
    return;
}

DWORD dwContext = 77;

void WABAddressTest(HWND hWnd, int iFlag, int cDestWells)
{
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPADRLIST lpAdrList = NULL;
    HRESULT hResult = hrSuccess;
    LPSPropValue rgProps;
    SCODE sc;
    ADRPARM AdrParms = {0};
    ULONG i=0;
    DWORD dwEntryID1=22;
    LPTSTR lpszDestFieldsTitles[]={ TEXT("Title # 1"),
                                    TEXT("2nd Title"),
                                    TEXT("Third in line")
                                    };

    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    if (lpAdrBook)
    {
        if(iFlag!=ADDRESS_CONTENTS)
        {
            sc = WABAllocateBuffer(sizeof(ADRLIST)+sizeof(ADRENTRY), &lpAdrList);
            lpAdrList->cEntries = 1;
            lpAdrList->aEntries[0].cValues = 7;
            sc = WABAllocateBuffer(7 * sizeof(SPropValue),&rgProps);
            lpAdrList->aEntries[0].rgPropVals = rgProps;
            lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
            lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = TEXT("Charlie Chaplin");
            lpAdrList->aEntries[0].rgPropVals[1].ulPropTag = PR_EMAIL_ADDRESS;
            lpAdrList->aEntries[0].rgPropVals[1].Value.LPSZ = TEXT("test@test1.com");
            lpAdrList->aEntries[0].rgPropVals[2].ulPropTag = PR_ADDRTYPE;
            lpAdrList->aEntries[0].rgPropVals[2].Value.LPSZ = TEXT("SMTP");
            lpAdrList->aEntries[0].rgPropVals[3].ulPropTag = PR_SURNAME;
            lpAdrList->aEntries[0].rgPropVals[3].Value.LPSZ = TEXT("Chaplin");
            lpAdrList->aEntries[0].rgPropVals[4].ulPropTag = PR_GIVEN_NAME;
            lpAdrList->aEntries[0].rgPropVals[4].Value.LPSZ = TEXT("Charlie");
            lpAdrList->aEntries[0].rgPropVals[5].ulPropTag = PR_RECIPIENT_TYPE;
            lpAdrList->aEntries[0].rgPropVals[5].Value.l = MAPI_TO;
            lpAdrList->aEntries[0].rgPropVals[6].ulPropTag = PR_ENTRYID;
            dwEntryID1 = 22;
            lpAdrList->aEntries[0].rgPropVals[6].Value.bin.lpb = NULL;
            lpAdrList->aEntries[0].rgPropVals[6].Value.bin.cb = 0;
        }
        switch(iFlag)
        {
        case(ADDRESS_CONTENTS_BROWSE_MODAL):
            AdrParms.cDestFields = 0;
            AdrParms.ulFlags = DIALOG_MODAL;
            break;
        case(ADDRESS_CONTENTS_BROWSE):
            AdrParms.cDestFields = 0;
            AdrParms.ulFlags = DIALOG_SDI;
            AdrParms.lpvDismissContext = &dwContext;
            AdrParms.lpfnDismiss = &TestDismissFunction;
            AdrParms.lpfnABSDI = NULL;
            break;
        case(ADDRESS_CONTENTS):
            AdrParms.cDestFields = 0;
            AdrParms.ulFlags = DIALOG_MODAL | ADDRESS_ONE;
            lpAdrList = NULL;
            break;
        case(ADDRESS_WELLS):
            AdrParms.cDestFields = cDestWells;
            AdrParms.ulFlags = DIALOG_MODAL;
            AdrParms.lppszDestTitles=lpszDestFieldsTitles;
            break;
        case(ADDRESS_WELLS_DEFAULT):
            AdrParms.cDestFields = cDestWells;
            AdrParms.ulFlags = DIALOG_MODAL;
            AdrParms.lppszDestTitles=NULL;
            break;
        }
        AdrParms.lpszCaption = "ApiTest Address Book Test";

        AdrParms.nDestFieldFocus = AdrParms.cDestFields-1;

        hResult = lpAdrBook->lpVtbl->Address(  lpAdrBook,
                                                (ULONG *) &hWnd,
                                                &AdrParms,
                                                &lpAdrList);

        if (AdrParms.lpfnABSDI)
        {
            (*(AdrParms.lpfnABSDI))((ULONG) hWnd, (LPVOID) NULL);
        }

        if (lpAdrList)
        {
            for(i=0;i<lpAdrList->aEntries[0].cValues;i++)
            {
                if(lpAdrList->aEntries[0].rgPropVals[i].ulPropTag == PR_ENTRYID)
                {
                    lpAdrBook->lpVtbl->Details(lpAdrBook,
                                                (LPULONG)&hWnd,
                                                NULL,
                                                NULL,
                                                lpAdrList->aEntries[0].rgPropVals[i].Value.bin.cb,
                                                (LPENTRYID) lpAdrList->aEntries[0].rgPropVals[i].Value.bin.lpb,
                                                NULL,
                                                NULL,
                                                NULL,
                                                0);
                }
            }
            WABFreePadrlist(lpAdrList);
        }

        lpAdrBook->lpVtbl->Release(lpAdrBook);
    }

    if (lpWABObject) {

        lpWABObject->lpVtbl->Release(lpWABObject);
    }
}



int _stdcall WinMainCRTStartup (void)
{
        int i;
        STARTUPINFOA si;
        PTSTR pszCmdLine = GetCommandLine();

        SetErrorMode(SEM_FAILCRITICALERRORS);

        if (*pszCmdLine == TEXT ('\"'))
        {
                // Scan, and skip over, subsequent characters until
                // another double-quote or a null is encountered.
                while (*++pszCmdLine && (*pszCmdLine != TEXT ('\"')));

                // If we stopped on a double-quote (usual case), skip over it.
                if (*pszCmdLine == TEXT ('\"')) pszCmdLine++;
        }
        else
        {
                while (*pszCmdLine > TEXT (' ')) pszCmdLine++;
        }

        // Skip past any white space preceeding the second token.
        while (*pszCmdLine && (*pszCmdLine <= TEXT (' '))) pszCmdLine++;

        si.dwFlags = 0;
        GetStartupInfo (&si);

        i = WinMainT(GetModuleHandle (NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

        ExitProcess(i);

        return i;
}


void AddrBookDetailsTest(HWND hWnd)
{

    TCHAR lpszInput[MAX_INPUT_STRING + 1] = "";
    DWORD dwEntryID;
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    SCODE sc = SUCCESS_SUCCESS;
    LPMAILUSER lpMailUser = NULL;
    int i = 0,nLen=0;



    if (nLen = InputString(hInst, hWnd, szAppName, "Enter EntryID", lpszInput, MAX_INPUT_STRING))
    {

        dwEntryID=0;
        for(i=0;i<nLen;i++)
        {
            char a = lpszInput[i];
            if ((a <= '9') && (a >= '0'))
                dwEntryID = dwEntryID*10 + a - '0';
        }
        hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        SetGlobalBufferFunctions(lpWABObject);

        if (lpAdrBook)
        {

            hResult = lpAdrBook->lpVtbl->Details(lpAdrBook,
                                                  (LPULONG) &hWnd,            // ulUIParam
                                                  NULL,
                                                  NULL,
                                                  sizeof(DWORD),
                                                  (LPENTRYID) &dwEntryID,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  0);

            lpAdrBook->lpVtbl->Release(lpAdrBook);
        }
        if (lpWABObject) {
            lpWABObject->lpVtbl->Release(lpWABObject);
        }
    }

}

void AddrBookDetailsOneOffTest(HWND hWnd)
{

    TCHAR lpszInput[MAX_INPUT_STRING + 1] = "";
    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    SCODE sc = SUCCESS_SUCCESS;
    LPMAILUSER lpMailUser = NULL;
    ULONG i = 0,nLen=0;
    LPENTRYID lpEntryID = NULL;
    ULONG cbEntryID = 0;
    ULONG ulObjectType = 0;
    LPADRLIST lpAdrList = NULL;


    if (nLen = InputString(hInst, hWnd, szAppName, "Enter One-Off Address", lpszInput, MAX_INPUT_STRING))
    {

        hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        SetGlobalBufferFunctions(lpWABObject);


        if (lpAdrBook)
        {
                // generate a one off entry-id by calling resolvenames on the input one-off address

            if (! (sc = WABAllocateBuffer(sizeof(ADRLIST) + sizeof(ADRENTRY), &lpAdrList)))
            {
                lpAdrList->cEntries = 1;
                lpAdrList->aEntries[0].ulReserved1 = 0;
                lpAdrList->aEntries[0].cValues = 1;

                if (! (sc = WABAllocateBuffer(lpAdrList->aEntries[0].cValues * sizeof(SPropValue),
                                                &lpAdrList->aEntries[0].rgPropVals)))
                {

                    lpAdrList->aEntries[0].rgPropVals[0].ulPropTag = PR_DISPLAY_NAME;
                    lpAdrList->aEntries[0].rgPropVals[0].Value.LPSZ = lpszInput;

                    hResult = lpAdrBook->lpVtbl->ResolveName(lpAdrBook,
                                                              (ULONG)hWnd,            // ulUIParam
                                                              0,            // ulFlags
                                                              "APITest ResolveName",  // lpszNewEntryTitle
                                                              lpAdrList);

                    DebugTrace("ResolveName [%s] -> %x\n", lpszInput, GetScode(hResult));

                    if (! HR_FAILED(hResult))
                    {
                        // Open the entry and dump it's properties

                        for(i=0;i<lpAdrList->aEntries[0].cValues;i++)
                        {
                            if (lpAdrList->aEntries[0].rgPropVals[i].ulPropTag == PR_ENTRYID)
                            {

                                cbEntryID = lpAdrList->aEntries[0].rgPropVals[i].Value.bin.cb;
                                lpEntryID = (LPENTRYID)lpAdrList->aEntries[0].rgPropVals[i].Value.bin.lpb;

                                if (! (HR_FAILED(hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                                                          cbEntryID,
                                                          lpEntryID,
                                                          NULL,
                                                          0,
                                                          &ulObjectType,
                                                          (LPUNKNOWN *)&(lpMailUser)))))
                                {
                                    DebugObjectProps((LPMAPIPROP)lpMailUser, "Resolved Entry Properties");
                                    lpMailUser->lpVtbl->Release(lpMailUser);
                                }

                                hResult = lpAdrBook->lpVtbl->Details(lpAdrBook,
                                                          (LPULONG) &hWnd,            // ulUIParam
                                                          NULL,
                                                          NULL,
                                                          cbEntryID,
                                                          lpEntryID,
                                                          NULL,
                                                          NULL,
                                                          NULL,
                                                          0);
                          }
                        }

                    }

                }


                WABFreePadrlist(lpAdrList);
            }

            lpAdrBook->lpVtbl->Release(lpAdrBook);

        }


        if (lpWABObject)
        {
           lpWABObject->lpVtbl->Release(lpWABObject);
        }
    }


    return;
}


//
// Properties to get for each row of the contents table
//
enum {
    iptaColumnsPR_OBJECT_TYPE = 0,
    iptaColumnsPR_ENTRYID,
    iptaColumnsPR_DISPLAY_NAME,
    iptaColumnsMax
};
static const SizedSPropTagArray(iptaColumnsMax, ptaColumns) =
{
    iptaColumnsMax,
    {
        PR_OBJECT_TYPE,
        PR_ENTRYID,
        PR_DISPLAY_NAME,
    }
};

void RootContainerTest(void) {
    LPMAPITABLE lpRootTable = NULL;
    HRESULT hResult;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    LPABCONT lpRoot = NULL;
    ULONG ulObjType;
    ULONG cRows = 0;
    LPSRowSet lpRow = NULL;
    LPABCONT lpContainer = NULL;



    hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
    SetGlobalBufferFunctions(lpWABObject);

    // Check out the ROOT container
    if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
      0,
      NULL,
      NULL,
      0,
      &ulObjType,
      (LPUNKNOWN *)&lpRoot))) {
        DebugObjectProps((LPMAPIPROP)lpRoot, "WAB Root Container");

        if (! (hResult = lpRoot->lpVtbl->GetContentsTable(lpRoot,
          0,
          &lpRootTable))) {

            DebugTrace("Root container contents:\n");
            DebugMapiTable(lpRootTable);


            // Set the columns
            lpRootTable->lpVtbl->SetColumns(lpRootTable,
              (LPSPropTagArray)&ptaColumns,
              0);


            // Open each container object
            cRows = 1;
            while (cRows) {
                if (hResult = lpRootTable->lpVtbl->QueryRows(lpRootTable,
                  1,    // one row at a time
                  0,    // ulFlags
                  &lpRow)) {
                    DebugTrace("QueryRows -> %x\n", GetScode(hResult));
                } else if (lpRow) {
                    if (cRows = lpRow->cRows) { // Yes, single '='
                        // Open the entry

                        if (! (hResult = lpAdrBook->lpVtbl->OpenEntry(lpAdrBook,
                          lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.cb,
                          (LPENTRYID)lpRow->aRow[0].lpProps[iptaColumnsPR_ENTRYID].Value.bin.lpb,
                          NULL,
                          0,
                          &ulObjType,
                          (LPUNKNOWN *)&lpContainer))) {
                            DebugObjectProps((LPMAPIPROP)lpContainer, "Container");
                            lpContainer->lpVtbl->Release(lpContainer);
                        }
                    }
                    FreeProws(lpRow);
                }
            }

            lpRootTable->lpVtbl->Release(lpRootTable);
        }
        lpRoot->lpVtbl->Release(lpRoot);
    }

    lpAdrBook->lpVtbl->Release(lpAdrBook);
    lpWABObject->lpVtbl->Release(lpWABObject);
}




void GetMeTest(HWND hWnd)
{

    HRESULT hResult = hrSuccess;
    LPWABOBJECT lpWABObject = NULL;
    LPADRBOOK lpAdrBook = NULL;
    SCODE sc = SUCCESS_SUCCESS;
    LPMAILUSER lpMailUser = NULL;
    int i = 0,nLen=0;
    SBinary sbEID;

    {
        hResult = WABOpen(&lpAdrBook, &lpWABObject, NULL, 0);
        SetGlobalBufferFunctions(lpWABObject);

        if(lpWABObject)
        {
            DWORD dwAction;
            lpWABObject->lpVtbl->GetMe(lpWABObject, lpAdrBook,
                                        0, &dwAction,
                                        &sbEID, 0);
        }

        if (lpAdrBook)
        {

            hResult = lpAdrBook->lpVtbl->Details(lpAdrBook,
                                                  (LPULONG) &hWnd,            // ulUIParam
                                                  NULL,
                                                  NULL,
                                                  sbEID.cb,
                                                  (LPENTRYID) sbEID.lpb,
                                                  NULL,
                                                  NULL,
                                                  NULL,
                                                  0);
            lpAdrBook->lpVtbl->Release(lpAdrBook);
        }
        if (lpWABObject) {
            lpWABObject->lpVtbl->Release(lpWABObject);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\apitest\dbgutil.h ===
/***********************************************************************
 *
 * DBGUTIL.H
 *
 * Debug Utility functions
 *
 * Copyright 1992 - 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * Revision History:
 *
 * When         Who                 What
 * --------     ------------------  ---------------------------------------
 * 11.13.95     Bruce Kelley        Created
 *
 ***********************************************************************/
#ifdef __cplusplus
extern "C" {
#endif


VOID _DebugObjectProps(LPMAPIPROP lpObject, LPTSTR Label);
VOID _DebugProperties(LPSPropValue lpProps, DWORD cProps, PUCHAR pszObject);
void _DebugMapiTable(LPMAPITABLE lpTable);
void _DebugADRLIST(LPADRLIST lpAdrList, LPTSTR lpszTitle);

#define DebugObjectProps(lpObject, Label) _DebugObjectProps(lpObject, Label)
#define DebugProperties(lpProps, cProps, pszObject) _DebugProperties(lpProps, cProps, pszObject)
#define DebugMapiTable(lpTable) _DebugMapiTable(lpTable)
#define DebugADRLIST(lpAdrList, lpszTitle) _DebugADRLIST(lpAdrList, lpszTitle)

VOID FAR CDECL DebugTrace(LPSTR lpszFmt, ...);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\apitest\instring.h ===
#define IDD_INPUT_STRING 2001
#define IDD_INPUT_STRING_PROMPT 2002

ULONG InputString(HINSTANCE hInstance, HWND hwnd, const LPTSTR lpszTitle,
  const LPTSTR lpszPrompt, LPTSTR lpBuffer, ULONG cchBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\apitest\wabguid.c ===
// This builds wabguid.obj, which can be linked into a DLL
// or EXE to provide the MAPI GUIDs. It contains all GUIDs
// defined by WAB.


#define USES_IID_IUnknown
#define USES_IID_IMAPIUnknown
#define USES_IID_IMAPITable
#define USES_IID_INotifObj
#define USES_IID_IMAPIProp
#define USES_IID_IMAPIPropData
#define USES_IID_IMAPIStatus
#define USES_IID_IAddrBook
#define USES_IID_IMailUser
#define USES_IID_IMAPIContainer
#define USES_IID_IABContainer
#define USES_IID_IDistList
#define USES_IID_IMAPITableData
#define USES_IID_IMAPIAdviseSink


#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif


#define INITGUID
#include <windows.h>
#include <wab.h>
#include <wabguid.h>
#include "_layguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\luieng.dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Luieng.rc
//
#define ID_OK                           1
#define ID_CANCEL                       2
#define IDD_LOGGING                     101
#define IDD_LOG                         101
#define IDC_LOG                         1000
#define IDC_LOGGING                     1000
#define IDC_EDIT1                       1001
#define IDC_LOGNAME                     1001
#define IDC_LOGLEVEL                    1002

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\apitest\mapi.c ===
/*
 * MAPI.C
 *
 * Layer on top of MAPI calls
 *
 * Copyright 1996 Microsoft Corporation.  All Rights Reserved.
 *
 * History:
 *      11/14/96    BruceK  First version to allow wab migration without mapi32.dll
 */

#include <windows.h>
#include <mapix.h>
#include <wab.h>
#include <wabguid.h>
#include "apitest.h"
#include "instring.h"
#include "dbgutil.h"



LPMAPIINITIALIZE lpfnMAPIInitialize = NULL;
LPMAPILOGONEX lpfnMAPILogonEx = NULL;
LPMAPIALLOCATEBUFFER lpfnMAPIAllocateBuffer = NULL;
LPMAPIALLOCATEMORE lpfnMAPIAllocateMore = NULL;
LPMAPIFREEBUFFER lpfnMAPIFreeBuffer = NULL;

static HINSTANCE hinstMAPIDll = NULL;

// Constant strings
const TCHAR szMapiDll[] = TEXT("MAPI32.DLL");
const TCHAR szMAPIAllocateBuffer[] = TEXT("MAPIAllocateBuffer");
const TCHAR szMAPIAllocateMore[] = TEXT("MAPIAllocateMore");
const TCHAR szMAPIFreeBuffer[] = TEXT("MAPIFreeBuffer");
const TCHAR szMAPIInitialize[] = TEXT("MAPIInitialize");
const TCHAR szMAPILogonEx[] = TEXT("MAPILogonEx");


HRESULT MAPIInitialize(LPVOID lpMapiInit) {
    HRESULT hResult = hrSuccess;

    // If MAPI DLL is not loaded, do so now.
    if (! hinstMAPIDll) {

        if (! (hinstMAPIDll = LoadLibrary(szMapiDll))) {
            DWORD dwErr = GetLastError();
            DebugTrace("Couldn't load MAPI dll [%s] -> %u\n", szMapiDll, dwErr);
            switch (dwErr) {
                case ERROR_NOT_ENOUGH_MEMORY:
                case ERROR_OUTOFMEMORY:
                    hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_MEMORY);
                    break;

                case ERROR_HANDLE_DISK_FULL:
                case ERROR_DISK_FULL:
                    hResult = ResultFromScode(MAPI_E_NOT_ENOUGH_DISK);
                    break;

                default:
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    hResult = ResultFromScode(MAPI_E_NOT_FOUND);
                    break;
            }
            goto exit;
        } else {
            // Get the function pointers
            if (! (lpfnMAPIInitialize = (LPMAPIINITIALIZE)GetProcAddress(hinstMAPIDll,
              szMAPIInitialize))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIInitialize, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPILogonEx = (LPMAPILOGONEX)GetProcAddress(hinstMAPIDll,
              szMAPILogonEx))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPILogonEx, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPIAllocateBuffer = (LPMAPIALLOCATEBUFFER)GetProcAddress(hinstMAPIDll,
              szMAPIAllocateBuffer))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIAllocateBuffer, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPIAllocateMore= (LPMAPIALLOCATEMORE)GetProcAddress(hinstMAPIDll,
              szMAPIAllocateMore))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIAllocateMore, szMapiDll, GetLastError());
                goto exit;
            }
            if (! (lpfnMAPIFreeBuffer = (LPMAPIFREEBUFFER)GetProcAddress(hinstMAPIDll,
              szMAPIFreeBuffer))) {
                DebugTrace("Couldn't get Fn addr %s from %s -> %u\n", szMAPIFreeBuffer, szMapiDll, GetLastError());
                goto exit;
            }
        }
    }

exit:
    if (! lpfnMAPIInitialize ||
      ! lpfnMAPILogonEx ||
      ! lpfnMAPIAllocateMore ||
      ! lpfnMAPIAllocateBuffer ||
      ! lpfnMAPIFreeBuffer) {
        // Bad news.  Clean up and fail.
        if (hinstMAPIDll) {
            // unload the dll
            FreeLibrary(hinstMAPIDll);
            hinstMAPIDll = NULL;
            lpfnMAPIInitialize = NULL;
            lpfnMAPILogonEx = NULL;
            lpfnMAPIAllocateMore = NULL;
            lpfnMAPIAllocateBuffer = NULL;
            lpfnMAPIFreeBuffer = NULL;
        }
        if (hResult == hrSuccess) {
            hResult = ResultFromScode(MAPI_E_NOT_FOUND);
        }

        return(hResult);
    }

    return(lpfnMAPIInitialize(lpMapiInit));
}


HRESULT MAPILogonEx(
  ULONG ulUIParam,
  LPTSTR lpszProfileName,
  LPTSTR lpszPassword,
  ULONG ulFlags,
  LPMAPISESSION FAR * lppSession
) {
    if (lpfnMAPILogonEx) {
        return(lpfnMAPILogonEx(ulUIParam,
          lpszProfileName,
          lpszPassword,
          ulFlags,
          lppSession));
    } else {
        return(ResultFromScode(MAPI_E_NOT_INITIALIZED));
    }
}

SCODE MAPIAllocateBuffer(
  ULONG cbSize,
  LPVOID FAR * lppBuffer
) {
    if (lpfnMAPIAllocateBuffer) {
        return(lpfnMAPIAllocateBuffer(cbSize,
          lppBuffer));
    } else {
        return(MAPI_E_NOT_INITIALIZED);
    }
}

SCODE MAPIAllocateMore(
  ULONG cbSize,
  LPVOID lpObject,
  LPVOID FAR * lppBuffer
) {
    if (lpfnMAPIAllocateMore) {
        return(lpfnMAPIAllocateMore(cbSize,
          lpObject,
          lppBuffer));
    } else {
        return(MAPI_E_NOT_INITIALIZED);
    }
}

ULONG MAPIFreeBuffer(LPVOID lpBuffer) {
    if (lpfnMAPIFreeBuffer) {
        return(lpfnMAPIFreeBuffer(lpBuffer));
    } else {
        return((ULONG)MAPI_E_NOT_INITIALIZED);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\apitest\_layguid.h ===
/*
 *	_LAYGUID.H
 *
 *	Lays down actual, 16-byte GUIDs for use in an EXE or DLL.
 *	Should be included in only one module (a .C file) of said EXE or DLL.
 *	Before including, define the tags for all the GUIDs you
 *	plan to use, e.g.
 *
 *		#define USES_IID_IUnknown
 *		#define USES_IID_IStream
 *		#define USES_IID_IMAPIProp
 *		#include <_layguid.h>
 */



#ifdef USES_GUID_NULL
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
#endif

#ifdef USES_IID_IUnknown
DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
#endif

#ifdef USES_IID_IClassFactory
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
#endif

#ifdef USES_IID_IMalloc
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
#endif

#ifdef USES_IID_IMarshal
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);
#endif


/* RPC related interfaces */
#ifdef USES_IID_IRpcChannel
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
#endif

#ifdef USES_IID_IRpcStub
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
#endif

#ifdef USES_IID_IStubManager
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
#endif

#ifdef USES_IID_IRpcProxy
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
#endif

#ifdef USES_IID_IProxyManager
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
#endif

#ifdef USES_IID_IPSFactory
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);
#endif

#ifdef USES_IID_IRpcProxyBuffer
DEFINE_GUID(IID_IRpcProxyBuffer, 0xD5F56A34, 0x593B, 0x101A, 0xB5, 0x69, 0x08, 0x00, 0x2B, 0x2D, 0xBF, 0x7A);
#endif

#ifdef USES_IID_IPSFactoryBuffer
DEFINE_GUID(IID_IPSFactoryBuffer,0xD5F569D0,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);
#endif

#ifdef USES_IID_IRpcChannelBuffer
DEFINE_GUID(IID_IRpcChannelBuffer,0xD5F56B60,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);
#endif

#ifdef USES_IID_IRpcStubBuffer
DEFINE_GUID(IID_IRpcStubBuffer,0xD5F56AFC,0x593B,0x101A,0xB5,0x69,0x08,0x00,0x2B,0x2D,0xBF,0x7A);
#endif

/* storage related interfaces */
#ifdef USES_IID_ILockBytes
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
#endif

#ifdef USES_IID_IStorage
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
#endif

#ifdef USES_IID_IStream
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
#endif

#ifdef USES_IID_IEnumSTATSTG
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);
#endif


/* moniker related interfaces */
#ifdef USES_IID_IBindCtx
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
#endif

#ifdef USES_IID_IMoniker
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
#endif

#ifdef USES_IID_IRunningObjectTable
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
#endif

#ifdef USES_IID_IInternalMoniker
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);
#endif


/* storage related interfaces */
#ifdef USES_IID_IRootStorage
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
#endif

#ifdef USES_IID_IDfReserved1
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
#endif

#ifdef USES_IID_IDfReserved2
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
#endif

#ifdef USES_IID_IDfReserved3
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);
#endif


/* concurrency releated interfaces */
#ifdef USES_IID_IMessageFilter
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);
#endif


/* CLSID of standard marshaler */
#ifdef USES_CLSID_StdMarshal
DEFINE_OLEGUID(CLSID_StdMarshal,		0x00000017L, 0, 0);
#endif


/* interface on server for getting info for std marshaler */
#ifdef USES_IID_IStdMarshalInfo
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);
#endif


/* NOTE: LSB 0x19 through 0xff are reserved for future use */

//	End of COGUID.H clone

//	Copied from OLEGUID.H

/* this file is the master definition of all public GUIDs specific to OLE
   and is included in ole2.h.

   NOTE: The second least significant byte of all of these GUIDs is 1.
*/


#ifdef USES_IID_IEnumUnknown
DEFINE_OLEGUID(IID_IEnumUnknown,            0x00000100, 0, 0);
#endif

#ifdef USES_IID_IEnumString
DEFINE_OLEGUID(IID_IEnumString,             0x00000101, 0, 0);
#endif

#ifdef USES_IID_IEnumMoniker
DEFINE_OLEGUID(IID_IEnumMoniker,            0x00000102, 0, 0);
#endif

#ifdef USES_IID_IEnumFORMATETC
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
#endif

#ifdef USES_IID_IEnumOLEVERB
DEFINE_OLEGUID(IID_IEnumOLEVERB,            0x00000104, 0, 0);
#endif

#ifdef USES_IID_IEnumSTATDATA
DEFINE_OLEGUID(IID_IEnumSTATDATA,           0x00000105, 0, 0);
#endif


#ifdef USES_IID_IEnumGeneric
DEFINE_OLEGUID(IID_IEnumGeneric,            0x00000106, 0, 0);
#endif

#ifdef USES_IID_IEnumHolder
DEFINE_OLEGUID(IID_IEnumHolder,             0x00000107, 0, 0);
#endif

#ifdef USES_IID_IEnumCallback
DEFINE_OLEGUID(IID_IEnumCallback,           0x00000108, 0, 0);
#endif


#ifdef USES_IID_IPersistStream
DEFINE_OLEGUID(IID_IPersistStream,          0x00000109, 0, 0);
#endif

#ifdef USES_IID_IPersistStorage
DEFINE_OLEGUID(IID_IPersistStorage,         0x0000010a, 0, 0);
#endif

#ifdef USES_IID_IPersistFile
DEFINE_OLEGUID(IID_IPersistFile,            0x0000010b, 0, 0);
#endif

#ifdef USES_IID_IPersist
DEFINE_OLEGUID(IID_IPersist,                0x0000010c, 0, 0);
#endif


#ifdef USES_IID_IViewObject
DEFINE_OLEGUID(IID_IViewObject,             0x0000010d, 0, 0);
#endif

#ifdef USES_IID_IDataObject
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
#endif

#ifdef USES_IID_IAdviseSink
DEFINE_OLEGUID(IID_IAdviseSink,             0x0000010f, 0, 0);
#endif

#ifdef USES_IID_IDataAdviseHolder
DEFINE_OLEGUID(IID_IDataAdviseHolder,       0x00000110, 0, 0);
#endif

#ifdef USES_IID_IOleAdviseHolder
DEFINE_OLEGUID(IID_IOleAdviseHolder,        0x00000111, 0, 0);
#endif


#ifdef USES_IID_IOleObject
DEFINE_OLEGUID(IID_IOleObject,              0x00000112, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceObject
DEFINE_OLEGUID(IID_IOleInPlaceObject,       0x00000113, 0, 0);
#endif

#ifdef USES_IID_IOleWindow
DEFINE_OLEGUID(IID_IOleWindow,              0x00000114, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceUIWindow
DEFINE_OLEGUID(IID_IOleInPlaceUIWindow,     0x00000115, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceFrame
DEFINE_OLEGUID(IID_IOleInPlaceFrame,        0x00000116, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceActiveObject
DEFINE_OLEGUID(IID_IOleInPlaceActiveObject, 0x00000117, 0, 0);
#endif


#ifdef USES_IID_IOleClientSite
DEFINE_OLEGUID(IID_IOleClientSite,          0x00000118, 0, 0);
#endif

#ifdef USES_IID_IOleInPlaceSite
DEFINE_OLEGUID(IID_IOleInPlaceSite,         0x00000119, 0, 0);
#endif


#ifdef USES_IID_IParseDisplayName
DEFINE_OLEGUID(IID_IParseDisplayName,       0x0000011a, 0, 0);
#endif

#ifdef USES_IID_IOleContainer
DEFINE_OLEGUID(IID_IOleContainer,           0x0000011b, 0, 0);
#endif

#ifdef USES_IID_IOleItemContainer
DEFINE_OLEGUID(IID_IOleItemContainer,       0x0000011c, 0, 0);
#endif


#ifdef USES_IID_IOleLink
DEFINE_OLEGUID(IID_IOleLink,                0x0000011d, 0, 0);
#endif

#ifdef USES_IID_IOleCache
DEFINE_OLEGUID(IID_IOleCache,               0x0000011e, 0, 0);
#endif

#ifdef USES_IID_IOleManager
DEFINE_OLEGUID(IID_IOleManager,             0x0000011f, 0, 0);
#endif

#ifdef USES_IID_IOlePresObj
DEFINE_OLEGUID(IID_IOlePresObj,             0x00000120, 0, 0);
#endif


#ifdef USES_IID_IDropSource
DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
#endif

#ifdef USES_IID_IDropTarget
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);
#endif


#ifdef USES_IID_IDebug
DEFINE_OLEGUID(IID_IDebug,                  0x00000123, 0, 0);
#endif

#ifdef USES_IID_IDebugStream
DEFINE_OLEGUID(IID_IDebugStream,            0x00000124, 0, 0);
#endif



/* NOTE: LSB values 0x25 through 0xff are reserved */


/* GUIDs defined in OLE's private range */
#ifdef USES_CLSID_StdOleLink
DEFINE_OLEGUID(CLSID_StdOleLink,			0x00000300, 0, 0);
#endif

#ifdef USES_CLSID_StaticMetafile
DEFINE_OLEGUID(CLSID_StaticMetafile,        0x00000315, 0, 0);
#endif

#ifdef USES_CLSID_StaticDib
DEFINE_OLEGUID(CLSID_StaticDib,             0x00000316, 0, 0);
#endif

//	End of OLEGUID.H clone
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\mfcext\propid.h ===
// PropID.H

#ifndef _CLSID_WABSamplePropExtSheet_
#define _CLSID_WABSamplePropExtSheet_

// {BA9EE970-87A0-11d1-9ACF-00A0C91F9C8B}
DEFINE_GUID(CLSID_WABSamplePropExtSheet,
0xba9ee970, 0x87a0, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);

#endif // _CLSID_WABSamplePropExtSheet_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\luieng.dll\luieng.h ===
//LUIENG.DLL
//Created by Chad Mumford
//2/5/96


#include <windows.h>

//********************************************************************************
//**	Declarations
//********************************************************************************

#define MODULEAPI __declspec(dllexport)
#define INAPI __declspec(dllimport)

#ifndef LUIENG
#define LUIENG

enum LOGLEVEL{LHEADING,L1,L2,L3,L4,LPASS1,LPASS2,LPASS3,LPASS4,
			LFAIL1,LFAIL2,LFAIL3,LFAIL4,LPASS,LFAIL};

enum SUMLEVEL{SL1,SL2,SL3,SL4,SLALL}; //LALL only works with 
								//LUISummaryOut & LUIClearSummary

enum MENUTYPE{NORMAL,LINE,STARTSUBMENU,ENDSUBMENU,ENDMENU};


/*e.g.

Tests
  itm1			-NORMAL
  ----			-LINE
  itm2			-NORMAL	
  submenu1		-STARTSUBMENU
    itm1		-NORMAL
	itm2		-NORMAL
	itm3		-NORMAL
	itm4		-NORMAL
	submenu2	-STARTSUBMENU
		itm1	-NORMAL
				-ENDSUBMENU
				-ENDSUBMENU
  itm3			-NORMAL
				-ENDMENU
*/

struct MenuStruct
{
	char lpszItemName[20];
	UINT nItemID;
	MENUTYPE nType;
};


#define IDM_FILEOPEN	1
#define IDM_FILECLOSE	2
#define IDM_FILESAVE	3
#define IDM_FILEPRINT	4
#define IDM_CLOSE		5
#define IDM_RUN			6
#define IDM_STOP		7
#define IDM_PAUSE		8
#define IDM_EDIT_COPY	9
#define IDM_EDIT_CLEAR	10  //implemented by dll
#define IDM_EDIT_SETTINGS 12
#define IDM_FILEEXIT	11  //implemented by dll
#define IDM_ABOUT		13 
#define IDM_CONTENTS	14

// exported functions
extern "C"{
typedef INAPI BOOL (*LUIINIT)(HWND,MenuStruct *, MenuStruct *, BOOL);
typedef INAPI BOOL (*LUIMSGHANDLER)(UINT message, UINT wParam, LONG lParam);
typedef INAPI void (*LUIOUT)(LOGLEVEL Level, LPSTR lpszString,...);
typedef INAPI void (*LUISETSUMMARY)(SUMLEVEL level, UINT nPassed, UINT nFailed);
typedef INAPI void (*LUIGETSUMMARY)(SUMLEVEL level, UINT *nPassed, UINT *nFailed);
typedef INAPI void (*LUICLEARSUMMARY)(SUMLEVEL level);
typedef INAPI void (*LUISUMMARYOUT)(SUMLEVEL level);
}

#endif
//*******************************************************
//*	Function Descriptions
//********************************************************************************



//exported functions
//********************************************************************************

// LUICLASS * LUIInit(HWND hwnd,TestStruct *Tests, TestSettingsStruct *TestSettings, BOOL bLOR = FALSE);
//
// Parameters:
// hwnd:		Handle of parent window
// Tests:		Array of TestStructs.  Creates menu options 
//				under the Test Menu.
//				nItemID == 0 - a line
//				nItemID Range = 2000-2500
//				This structure must be in order
//
// TestSettings:Array of TestSettingsStructs.  Creates menu option 
//				under the Settings Menu
//				nItemID Range = 2500-3000
//				nItemID == 0 - a line
//
// bLOR:		TRUE - use LOR logging
//
// Purpose:		Takes a default window and creates a 
//				standardized test menu, logging
//				area and supported logging functions
//					
// Notes:		All options in the Test and Test Settings					
//				menus must be implemented by the calling
//				.exe
//
//********************************************************************************

//********************************************************************************
// BOOL LUICLASS::LUIOut(LOGLEVEL Level, LPSTR lpszString, ...);
//
// Parameters:
// Level:		Specifies format of string
// lpszString:	String to display
//
// Purpose:		Adds a string to the bottom of the log
//
//********************************************************************************

//********************************************************************************
// void LUICLASS::LUIMsgHandler(UINT message, UINT wParam, LONG lParam);
//
// Purpose:		Handles messages meant for log engine.  Should be first function
//				called by WndProc
//
// Other Messages Prehandled:
//							WM_SIZE
//							WM_CLOSE
//********************************************************************************




//internal functions accessible by default menu

// File
//********************************************************************************
// BOOL SaveLog(void);
//
// Parameters:
// Purpose:	
//
//********************************************************************************

//********************************************************************************
// BOOL OpenLog(void);
//
// Parameters:
// Purpose:	
//
//********************************************************************************

//********************************************************************************
// BOOL Exit(void);
//
// Parameters:
// Purpose:	
//
//********************************************************************************

//********************************************************************************
// BOOL PrintLog(void);//not imp
//
// Parameters:
// Purpose:	
//
//********************************************************************************


// Edit
//********************************************************************************
// BOOL Copy(void);//not imp
//
// Parameters:
// Purpose:	
//
//********************************************************************************

//********************************************************************************
// BOOL Clear(void);
//
// Parameters:
// Purpose:	
//
//********************************************************************************

//********************************************************************************
// BOOL Settings(void);
//
// Parameters:
// Purpose:	
//
//********************************************************************************



//Internal only functions

//********************************************************************************
// BOOL MakeMenu(void);
//
// Parameters:
// Purpose:	
//
//********************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\mfcext\mfcext.h ===
// mfcext.h : main header file for the MFCEXT DLL
//

#if !defined(AFX_MFCEXT_H__BA583A69_879D_11D1_9ACF_00A0C91F9C8B__INCLUDED_)
#define AFX_MFCEXT_H__BA583A69_879D_11D1_9ACF_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include <ole2.h>
#include <shlobj.h>
#include <prsht.h>
#include <winuser.h>
#include "propid.h"
#include "resource.h"		// main symbols
#include <initguid.h>
#include <wab.h>



/////////////////////////////////////////////////////////////////////////////
// CMfcextApp
// See mfcext.cpp for the implementation of this class
//

class CMfcextApp : public CWinApp
{
public:
	CMfcextApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMfcextApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CMfcextApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// CMfcExt command target

class CMfcExt : public CCmdTarget
{
	DECLARE_DYNCREATE(CMfcExt)
protected:
	CMfcExt();           // protected constructor used by dynamic creation

// Attributes
public:
    UINT m_cRefThisDll;     // Reference count for this DLL
    HPROPSHEETPAGE m_hPage1; // Handle to the property sheet page
    HPROPSHEETPAGE m_hPage2; // Handle to the property sheet page

    LPWABEXTDISPLAY m_lpWED;

    LPWABEXTDISPLAY m_lpWEDContext;
    LPMAPIPROP m_lpPropObj; // For context menu extensions, hang onto the prop obj

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropExt)
	public:
	virtual void OnFinalRelease();
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CMfcExt();

	// Generated message map functions
	//{{AFX_MSG(CMfcExt)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
	DECLARE_OLECREATE(CMfcExt)

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CMfcExt)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()

    // Declare the interface map for this object
    DECLARE_INTERFACE_MAP()

    // IShellPropSheetExt interface
    BEGIN_INTERFACE_PART(MfcExt, IShellPropSheetExt)
        STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
        STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);
    END_INTERFACE_PART(MfcExt)

    // IWABExtInit interface
    BEGIN_INTERFACE_PART(WABInit, IWABExtInit)
        STDMETHOD(Initialize)(LPWABEXTDISPLAY lpWED);
    END_INTERFACE_PART(WABInit)

    BEGIN_INTERFACE_PART(ContextMenuExt, IContextMenu)
        STDMETHOD(GetCommandString)(UINT idCmd,UINT uFlags,UINT *pwReserved,LPSTR pszName,UINT cchMax);
        STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
        STDMETHOD(QueryContextMenu)(HMENU hmenu,UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);    
    END_INTERFACE_PART(ContextMenuExt)

    static BOOL APIENTRY MfcExtDlgProc( HWND hDlg, UINT message, UINT wParam, LONG lParam);
    static BOOL APIENTRY MfcExtDlgProc2( HWND hDlg, UINT message, UINT wParam, LONG lParam);

};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CDlgContext dialog

class CDlgContext : public CDialog
{
// Construction
public:
	CDlgContext(CWnd* pParent = NULL);   // standard constructor
    LPADRLIST m_lpAdrList;

// Dialog Data
	//{{AFX_DATA(CDlgContext)
	enum { IDD = IDD_CONTEXT };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgContext)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgContext)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};



//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MFCEXT_H__BA583A69_879D_11D1_9ACF_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\mfcext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mfcext.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\mfcext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mfcext.rc
//
#define IDI_ICON1                       101
#define IDD_PROP2                       103
#define IDD_PROP                        104
#define IDI_ICON2                       104
#define IDD_CONTEXT                     106
#define IDC_EXT_EDIT_HOME               1000
#define IDC_EXT_EDIT_TEAM               1002
#define IDC_STATIC_NAME                 1004
#define IDC_BUTTON1                     1006
#define IDC_BUTTON2                     1007
#define IDC_BUTTON3                     1008
#define IDC_BUTTON4                     1009
#define IDC_BUTTON5                     1010
#define IDC_LIST_EMAIL                  1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\mfcext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BA583A6B_879D_11D1_9ACF_00A0C91F9C8B__INCLUDED_)
#define AFX_STDAFX_H__BA583A6B_879D_11D1_9ACF_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BA583A6B_879D_11D1_9ACF_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\mfcext\mfcext.cpp ===
// mfcext.cpp : Defines the initialization routines for the DLL.
//
#include "stdafx.h"
#include "mfcext.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
//	Note!
//
//		If this DLL is dynamically linked against the MFC
//		DLLs, any functions exported from this DLL which
//		call into MFC must have the AFX_MANAGE_STATE macro
//		added at the very beginning of the function.
//
//		For example:
//
//		extern "C" BOOL PASCAL EXPORT ExportedFunction()
//		{
//			AFX_MANAGE_STATE(AfxGetStaticModuleState());
//			// normal function body here
//		}
//
//		It is very important that this macro appear in each
//		function, prior to any calls into MFC.  This means that
//		it must appear as the first statement within the 
//		function, even before any object variable declarations
//		as their constructors may generate calls into the MFC
//		DLL.
//
//		Please see MFC Technical Notes 33 and 58 for additional
//		details.
//

/////////////////////////////////////////////////////////////////////////////
// CMfcextApp

BEGIN_MESSAGE_MAP(CMfcextApp, CWinApp)
	//{{AFX_MSG_MAP(CMfcextApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMfcextApp construction

CMfcextApp::CMfcextApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMfcextApp object

CMfcextApp theApp;



/////////////////////////////////////////////////////////////////////////////
// CPropextApp initialization

BOOL CMfcextApp::InitInstance()
{
	// Register all OLE server (factories) as running.  This enables the
	//  OLE libraries to create objects from other applications.
	COleObjectFactory::RegisterAll();
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// Special entry points required for inproc servers

#if (_MFC_VER >= 0x300)
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return AfxDllGetClassObject(rclsid, riid, ppv);
}

STDAPI DllCanUnloadNow(void)
{
	return AfxDllCanUnloadNow();
}
#endif

// by exporting DllRegisterServer, you can use regsvr.exe
STDAPI DllRegisterServer(void)
{
	COleObjectFactory::UpdateRegistryAll();
    HKEY hSubKey = NULL;
    DWORD dwDisp = 0;
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\WAB\\WAB4\\ExtDisplay\\MailUser",
                    0, NULL, 0, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisp))
    {
        UCHAR szEmpty[] = "";
        RegSetValueEx(hSubKey,"{BA9EE970-87A0-11D1-9ACF-00A0C91F9C8B}",0,REG_SZ, szEmpty, sizeof(szEmpty));
        RegCloseKey(hSubKey);
    }
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\WAB\\WAB4\\ExtDisplay\\DistList",
                    0, NULL, 0, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisp))
    {
        UCHAR szEmpty[] = "";
        RegSetValueEx(hSubKey,"{BA9EE970-87A0-11D1-9ACF-00A0C91F9C8B}",0,REG_SZ, szEmpty, sizeof(szEmpty));
        RegCloseKey(hSubKey);
    }
    if(ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\WAB\\WAB4\\ExtContext",
                    0, NULL, 0, KEY_ALL_ACCESS, NULL, &hSubKey, &dwDisp))
    {
        UCHAR szEmpty[] = "";
        RegSetValueEx(hSubKey,"{BA9EE970-87A0-11D1-9ACF-00A0C91F9C8B}",0,REG_SZ, szEmpty, sizeof(szEmpty));
        RegCloseKey(hSubKey);
    }
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CPropExt

IMPLEMENT_DYNCREATE(CMfcExt, CCmdTarget)

CMfcExt::CMfcExt()
{
	EnableAutomation();
	
	// To keep the application running as long as an OLE automation 
	//	object is active, the constructor calls AfxOleLockApp.
	
    m_lpWED = NULL;
    m_lpWEDContext = NULL;
    m_lpPropObj = NULL;

    AfxOleLockApp();
}

CMfcExt::~CMfcExt()
{
	// To terminate the application when all objects created with
	// 	with OLE automation, the destructor calls AfxOleUnlockApp.
	
	AfxOleUnlockApp();
}

void CMfcExt::OnFinalRelease()
{
	// When the last reference for an automation object is released
	//	OnFinalRelease is called.  This implementation deletes the 
	//	object.  Add additional cleanup required for your object before
	//	deleting it from memory.
    if(m_lpPropObj)
    {
        m_lpPropObj->Release();
        m_lpPropObj = NULL;
    }

	delete this;
}


BEGIN_MESSAGE_MAP(CMfcExt, CCmdTarget)
	//{{AFX_MSG_MAP(CPropExt)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CMfcExt, CCmdTarget)
	//{{AFX_DISPATCH_MAP(CPropExt)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// {BA9EE970-87A0-11d1-9ACF-00A0C91F9C8B}
IMPLEMENT_OLECREATE(CMfcExt, "WABSamplePropExtSheet", 0xba9ee970, 0x87a0, 0x11d1, 0x9a, 0xcf, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b);

BEGIN_INTERFACE_MAP(CMfcExt, CCmdTarget)
    INTERFACE_PART(CMfcExt, IID_IShellPropSheetExt, MfcExt)
    INTERFACE_PART(CMfcExt, IID_IWABExtInit, WABInit)
    INTERFACE_PART(CMfcExt, IID_IContextMenu, ContextMenuExt)
END_INTERFACE_MAP()


// IUnknown for IShellPropSheet
STDMETHODIMP CMfcExt::XMfcExt::QueryInterface(REFIID riid, void** ppv)
{
    METHOD_PROLOGUE(CMfcExt, MfcExt);
    TRACE("CMfcExt::XMfcExt::QueryInterface\n");
    return pThis->ExternalQueryInterface(&riid, ppv);
}

STDMETHODIMP_(ULONG) CMfcExt::XMfcExt::AddRef(void)
{
    METHOD_PROLOGUE(CMfcExt, MfcExt);
    return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CMfcExt::XMfcExt::Release(void)
{
    METHOD_PROLOGUE(CMfcExt, MfcExt);
    return pThis->ExternalRelease();
}


STDMETHODIMP CMfcExt::XMfcExt::ReplacePage(UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    return E_NOTIMPL;
}


// IUnknown for IShellExtInit
STDMETHODIMP CMfcExt::XWABInit::QueryInterface(REFIID riid, void** ppv)
{
    METHOD_PROLOGUE(CMfcExt, WABInit);
    TRACE("CMfcExt::XWABInit::QueryInterface\n");
    return pThis->ExternalQueryInterface(&riid, ppv);
}

STDMETHODIMP_(ULONG) CMfcExt::XWABInit::AddRef(void)
{
    METHOD_PROLOGUE(CMfcExt, WABInit);
    return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CMfcExt::XWABInit::Release(void)
{
    METHOD_PROLOGUE(CMfcExt, WABInit);
    return pThis->ExternalRelease();
}

STDMETHODIMP CMfcExt::XWABInit::Initialize(LPWABEXTDISPLAY lpWABExtDisplay)
{
    METHOD_PROLOGUE(CMfcExt, WABInit);
    TRACE("CMfcExt::XWABInit::Intialize\n");

    if (lpWABExtDisplay == NULL)
    {
	    TRACE("CMfcExt::XWABInit::Initialize() no data object");
	    return E_FAIL;
    }

    // However if this is a context menu extension, we need to hang
    // onto the propobj till such time as InvokeCommand is called ..
    // At this point just AddRef the propobj - this will ensure that the
    // data in the lpAdrList remains valid till we release the propobj..
    // When we get another ContextMenu initiation, we can release the
    // older cached propobj - if we dont get another initiation, we 
    // release the cached object at shutdown time
    if(lpWABExtDisplay->ulFlags & WAB_CONTEXT_ADRLIST) // this means a IContextMenu operation is occuring
    {
        if(pThis->m_lpPropObj)
        {
            pThis->m_lpPropObj->Release();
            pThis->m_lpPropObj = NULL;
        }

        pThis->m_lpPropObj = lpWABExtDisplay->lpPropObj;
        pThis->m_lpPropObj->AddRef();

        pThis->m_lpWEDContext = lpWABExtDisplay;
    }
    else
    {
        // For property sheet extensions, the lpWABExtDisplay will
        // exist for the life of the property sheets ..
        pThis->m_lpWED = lpWABExtDisplay;
    }

    return S_OK;
}




// Globally cached hInstance for the DLL
HINSTANCE hinstApp = NULL;

// For the purposes of this sample, we will use 2 named properties,
// HomeTown and SportsTeam

// This demo's private GUID:
// {2B6D7EE0-36AB-11d1-9ABC-00A0C91F9C8B}
static const GUID WAB_ExtDemoGuid = 
{ 0x2b6d7ee0, 0x36ab, 0x11d1, { 0x9a, 0xbc, 0x0, 0xa0, 0xc9, 0x1f, 0x9c, 0x8b } };

static const LPTSTR lpMyPropNames[] = 
{   
    "MyHomeTown", 
    "MySportsTeam"
};

enum _MyTags
{
    myHomeTown = 0,
    mySportsTeam,
    myMax
};

ULONG MyPropTags[myMax];
ULONG PR_MY_HOMETOWN;
ULONG PR_MY_SPORTSTEAM;

// 
// Function prototypes:
//
HRESULT InitNamedProps(LPWABEXTDISPLAY lpWED);
INT_PTR CALLBACK fnDetailsPropDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void InitializeUI(HWND hDlg, LPWABEXTDISPLAY lpWED);
void SetDataInUI(HWND hDlg, LPWABEXTDISPLAY lpWED);
BOOL GetDataFromUI(HWND hDlg, LPWABEXTDISPLAY lpWED);
UINT CALLBACK fnCallback( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
void UpdateDisplayNameInfo(HWND hDlg, LPWABEXTDISPLAY lpWED);
BOOL bUpdatePropSheetData(HWND hDlg, LPWABEXTDISPLAY lpWED);



/*//$$****************************************************************
//
// InitNamedProps
//
// Gets the PropTags for the Named Props this app is interested in
//
//********************************************************************/
HRESULT InitNamedProps(LPWABEXTDISPLAY lpWED)
{
    ULONG i;
    HRESULT hr = E_FAIL;
    LPSPropTagArray lptaMyProps = NULL;
    LPMAPINAMEID * lppMyPropNames;
    SCODE sc;
    LPMAILUSER lpMailUser = NULL;
    WCHAR szBuf[myMax][MAX_PATH];

    if(!lpWED)
        goto err;

    lpMailUser = (LPMAILUSER) lpWED->lpPropObj;

    if(!lpMailUser)
        goto err;

    sc = lpWED->lpWABObject->AllocateBuffer(sizeof(LPMAPINAMEID) * myMax, 
                                            (LPVOID *) &lppMyPropNames);
    if(sc)
    {
        hr = ResultFromScode(sc);
        goto err;
    }

    for(i=0;i<myMax;i++)
    {
        sc = lpWED->lpWABObject->AllocateMore(sizeof(MAPINAMEID), 
                                                lppMyPropNames, 
                                                (LPVOID *)&(lppMyPropNames[i]));
        if(sc)
        {
            hr = ResultFromScode(sc);
            goto err;
        }
        lppMyPropNames[i]->lpguid = (LPGUID) &WAB_ExtDemoGuid;
        lppMyPropNames[i]->ulKind = MNID_STRING;

        *(szBuf[i]) = '\0';

        // Convert prop name to wide-char
        if ( !MultiByteToWideChar( GetACP(), 0, lpMyPropNames[i], -1, szBuf[i], sizeof(szBuf[i])) )
        {
            continue;
        }

        lppMyPropNames[i]->Kind.lpwstrName = (LPWSTR) szBuf[i];
    }

    hr = lpMailUser->GetIDsFromNames(   myMax, 
                                        lppMyPropNames,
                                        MAPI_CREATE, 
                                        &lptaMyProps);
    if(HR_FAILED(hr))
        goto err;

    if(lptaMyProps)
    {
        // Set the property types on the returned props
        MyPropTags[myHomeTown] = PR_MY_HOMETOWN = CHANGE_PROP_TYPE(lptaMyProps->aulPropTag[myHomeTown],    PT_TSTRING);
        MyPropTags[mySportsTeam] = PR_MY_SPORTSTEAM = CHANGE_PROP_TYPE(lptaMyProps->aulPropTag[mySportsTeam],    PT_TSTRING);
    }

err:
    if(lptaMyProps)
        lpWED->lpWABObject->FreeBuffer( lptaMyProps);

    if(lppMyPropNames)
        lpWED->lpWABObject->FreeBuffer( lppMyPropNames);

    return hr;

}


/*//$$****************************************************************
//
// fnDetailsPropDlgProc
//
// The dialog procedure that will handle all the windows messages for 
// the extended property page. 
//
//********************************************************************/
INT_PTR CALLBACK CMfcExt::MfcExtDlgProc( HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    LPWABEXTDISPLAY lpWED = (LPWABEXTDISPLAY) GetWindowLong(hDlg, DWL_USER);

    switch(message)
    {
    case WM_INITDIALOG:
        //
        // The lParam on InitDialog contains the application data
        // Cache this on the dialog so we can retrieve it later.
        //
        {
            PROPSHEETPAGE * pps = (PROPSHEETPAGE *) lParam;
            LPWABEXTDISPLAY * lppWED = (LPWABEXTDISPLAY *) pps->lParam;
            if(lppWED)
            {
                SetWindowLong(hDlg,DWL_USER,(LPARAM)*lppWED);
                lpWED = *lppWED;
            }
        }
        
        // Initialize the named props for this prop sheet
        InitNamedProps(lpWED);

        // Initialize the UI appropriately
        InitializeUI(hDlg, lpWED);
        // Fill the UI with appropriate data
        SetDataInUI(hDlg, lpWED);
        return TRUE;
        break;


    case WM_COMMAND:
        switch(HIWORD(wParam)) //check the notification code
        {
            // If data changes, we should signal back to the WAB that
            // the data changed. If this flag is not set, the WAB will not
            // write the new data back to the store!!!
        case EN_CHANGE: //one of the edit boxes changed - dont care which
            lpWED->fDataChanged = TRUE;
            break;
        }
        break;
    

    case WM_NOTIFY:
        switch(((NMHDR FAR *)lParam)->code)
        {
        case PSN_SETACTIVE:     //Page being activated
            // Get the latest display name info and update the 
            // corresponding control
            UpdateDisplayNameInfo(hDlg, lpWED);
            break;


        case PSN_KILLACTIVE:    //Losing activation to another page or OK
            //
            // Take all the data from this prop sheet and convert it to a 
            // SPropValue array and place the data in an appropriate place.
            // The advantage of doing this in the KillActive notification is
            // that other property sheets can scan these property arrays and
            // if deisred, update data on other prop sheets based on this data
            //
            bUpdatePropSheetData(hDlg, lpWED);
            break;


        case PSN_RESET:         //cancel
            break;


        case PSN_APPLY:         //ok pressed
            if (!(lpWED->fReadOnly))
            {
                //
                // Check for any required properties here
                // If some required property is not filled in, you can prevent
                // the property sheet from closing
                //
                /*
                if (RequiredDataNotFilledIn())
                {
                    // abort this OK ... ie dont let them close
                    SetWindowLong(hDlg, DWL_MSGRESULT, TRUE);
                }
                */
            }
            break;
        }
        break;
    }

    return 0;
}

INT_PTR CALLBACK CMfcExt::MfcExtDlgProc2( HWND hDlg, UINT message, WPARAM wParam,	LPARAM lParam)
{

	switch (message)
	{
		case WM_NOTIFY:
    		switch (((NMHDR FAR *) lParam)->code) 
    		{

				case PSN_APPLY:
 	           		SetWindowLong(hDlg,	DWL_MSGRESULT, TRUE);
					break;

				case PSN_KILLACTIVE:
	           		SetWindowLong(hDlg,	DWL_MSGRESULT, FALSE);
					return 1;
					break;

				case PSN_RESET:
	           		SetWindowLong(hDlg,	DWL_MSGRESULT, FALSE);
					break;
    	}
	}
	return FALSE;   
}


int EditControls[] = 
{
    IDC_EXT_EDIT_HOME,
    IDC_EXT_EDIT_TEAM
};

/*//$$****************************************************************
//
// InitializeUI
//
// Rearranges/Sets UI based on input params
//
//********************************************************************/
void InitializeUI(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    // The WAB property sheets can be readonly when opening LDAP entries,
    // or vCards or other things. If the READONLY flag is set, set this
    // prop sheets controls to readonly
    //
    int i;
    if(!lpWED)
        return;
    for(i=0;i<myMax;i++)
    {
        SendDlgItemMessage( hDlg, EditControls[i], EM_SETREADONLY, 
                            (WPARAM) lpWED->fReadOnly, 0);
        SendDlgItemMessage( hDlg, EditControls[i], EM_SETLIMITTEXT, 
                            (WPARAM) MAX_PATH-1, 0);
    }
    return;
}


/*//$$****************************************************************
//
// SetDataInUI
//
// Fills in the controls with data passed in by the WAB
//
//********************************************************************/
void SetDataInUI(HWND hDlg, LPWABEXTDISPLAY lpWED)
{

    // Search for our private named properties and set them in the UI
    //
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    ULONG i = 0, j =0;

    if(!lpWED)
        return;

    // Get all the props from this object - one can also selectively
    // ask for specific props by passing in an SPropTagArray
    //
    if(!HR_FAILED(lpWED->lpPropObj->GetProps(NULL, 0, 
                                            &ulcPropCount, 
                                            &lpPropArray)))
    {
        if(ulcPropCount && lpPropArray)
        {
            for(i=0;i<ulcPropCount;i++)
            {
                for(j=0;j<myMax;j++)
                {
                    if(lpPropArray[i].ulPropTag == MyPropTags[j])
                    {
                        SetWindowText(  GetDlgItem(hDlg, EditControls[j]),
                                        lpPropArray[i].Value.LPSZ);
                        break;
                    }
                }
            }
        }
    }
    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);
                                    
    return;
}

/*//$$****************************************************************
//
// GetDataFromUI
//
// Retrieves data from the UI and passes back to the WAB
//
//********************************************************************/
BOOL GetDataFromUI(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    TCHAR szData[myMax][MAX_PATH];
    int i;
    ULONG ulIndex = 0;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;
    SCODE sc;
    BOOL bRet = FALSE;

    // Did any data change that we have to care about ?
    // If nothing changed, old data will be retained by WAB
    //
    if(!lpWED->fDataChanged)
        return TRUE;

    // Check if we have any data to save ...
    for(i=0;i<myMax;i++)
    {
        *(szData[i]) = '\0';
        GetWindowText(GetDlgItem(hDlg, EditControls[i]), szData[i], MAX_PATH);
        if(lstrlen(szData[i]))
            ulcPropCount++;
    }

    if(!ulcPropCount) // no data
        return TRUE;

    // Else data exists. Create a return prop array to pass back to the WAB
    sc = lpWED->lpWABObject->AllocateBuffer(sizeof(SPropValue) * ulcPropCount, 
                                            (LPVOID *)&lpPropArray);
    if (sc!=S_OK)
        goto out;

    for(i=0;i<myMax;i++)
    {
        int nLen = lstrlen(szData[i]);
        if(nLen)
        {
            lpPropArray[ulIndex].ulPropTag = MyPropTags[i];
            sc = lpWED->lpWABObject->AllocateMore(  nLen+1, lpPropArray, 
                                                    (LPVOID *)&(lpPropArray[ulIndex].Value.LPSZ));

            if (sc!=S_OK)
                goto out;
            lstrcpy(lpPropArray[ulIndex].Value.LPSZ,szData[i]);
            ulIndex++;
        }
    }

    // Set this new data on the object
    //
    if(HR_FAILED(lpWED->lpPropObj->SetProps( ulcPropCount, lpPropArray, NULL)))
        goto out;

    // ** Important - do not call SaveChanges on the object
    //    SaveChanges makes persistent changes and may modify/lose data if called at this point
    //    The WAB will determine if its appropriate or not to call SaveChanges after the
    // ** user has closed the property sheets
    

    bRet = TRUE;

out:
    if(lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);

    return bRet;

} 


/*//$$****************************************************************
//
// UpdateDisplayNameInfo
//
// Demonstrates how to read information from other sibling property
// sheets when the user switches between pages
//
// This demo function attempts to get the updated display name info 
// when the user switches to this page in the UI
//
//********************************************************************/
const SizedSPropTagArray(1, ptaName)=
{
    1,
    {
        PR_DISPLAY_NAME
    }
};

void UpdateDisplayNameInfo(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    // 
    // Scan all the updated information from all the other property sheets
    //
    ULONG i = 0, j=0;
    LPTSTR lpName = NULL;
    ULONG ulcPropCount = 0;
    LPSPropValue lpPropArray = NULL;

    if(!lpWED)
        return;

    // Each sheet should update its data on the object when it looses
    // focus and gets the PSN_KILLACTIVE message, provided the user has
    // made any changes. We just scan the object for the desired properties
    // and use them.

    // Ask only for the display name
    if(!HR_FAILED(lpWED->lpPropObj->GetProps( (LPSPropTagArray) &ptaName,
                                              0,
                                              &ulcPropCount, &lpPropArray)))
    {
        if( ulcPropCount == 1 && 
            PROP_TYPE(lpPropArray[0].ulPropTag) == PT_TSTRING) // The call could succeed but there may be no DN
        {                                                      // in which case the PROP_TYPE will be PR_NULL 
            lpName = lpPropArray[0].Value.LPSZ;
        }
    }

    if(lpName && lstrlen(lpName))
        SetDlgItemText(hDlg, IDC_STATIC_NAME, lpName);

    if(ulcPropCount && lpPropArray)
        lpWED->lpWABObject->FreeBuffer(lpPropArray);

    return;
}

/*//$$*********************************************************************
//
//  UpdateOldPropTagsArray
//
//  When we update the data on a particular property sheet, we want to update
//  all the properties related to that particular sheet. Since some properties
//  may have been deleted from the UI, we delete all relevant properties from
//  the property object
//
//**************************************************************************/
BOOL UpdateOldPropTagsArray(LPWABEXTDISPLAY lpWED)
{
    LPSPropTagArray lpPTA = NULL;
    SCODE sc = 0;
    int i =0;
    
    sc = lpWED->lpWABObject->AllocateBuffer(sizeof(SPropTagArray) + sizeof(ULONG)*(myMax), 
                                        (LPVOID *)&lpPTA);

    if(!lpPTA || sc!=S_OK)
        return FALSE;

    lpPTA->cValues = myMax;

    for(i=0;i<myMax;i++)
        lpPTA->aulPropTag[i] = MyPropTags[i];

    // Delete any props in the original that may have been modified on this propsheet
    lpWED->lpPropObj->DeleteProps(lpPTA, NULL);

    if(lpPTA)
        lpWED->lpWABObject->FreeBuffer(lpPTA);

    return TRUE;

}

/*//$$*********************************************************************
//
// bUpdatePropSheetData
//
// We delete any properties relevant to us from the object, and set new
// data from the property sheet onto the object
//
****************************************************************************/
BOOL bUpdatePropSheetData(HWND hDlg, LPWABEXTDISPLAY lpWED)
{
    BOOL bRet = TRUE;

    if(!lpWED)
        return bRet;

    // ****Dont**** do anything if this is a READ_ONLY operation
    // In that case the memory variables are not all set up and this
    // prop sheet is not expected to return anything at all
    //
    if(!lpWED->fReadOnly)
    {
        // Delete old
        if(!UpdateOldPropTagsArray(lpWED))
            return FALSE;

        bRet = GetDataFromUI(hDlg, lpWED);
    }
    return bRet;
}


STDMETHODIMP CMfcExt::XMfcExt::AddPages(LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    METHOD_PROLOGUE(CMfcExt, MfcExt);
    TRACE("CMfcExt::XMfcExt::AddPages\n");

    if(pThis->m_lpWED->fReadOnly)
        return NOERROR;

    PROPSHEETPAGE psp;

    hinstApp        = AfxGetResourceHandle();
    psp.dwSize      = sizeof(psp);   // no extra data
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USETITLE ;
    psp.hInstance   = hinstApp;
    psp.lParam      = (LPARAM) &(pThis->m_lpWED);
    psp.pcRefParent = (UINT *)&(pThis->m_cRefThisDll);

    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP);
    psp.pfnDlgProc  = pThis->MfcExtDlgProc;
    psp.pszTitle    = "WAB Ext 1"; // Title for your tab

    pThis->m_hPage1 = ::CreatePropertySheetPage(&psp);
    if (pThis->m_hPage1)
    {
        if (!lpfnAddPage(pThis->m_hPage1, lParam))
            ::DestroyPropertySheetPage(pThis->m_hPage1);
    }

    // create another one, just for kicks
    psp.pfnDlgProc  = pThis->MfcExtDlgProc2;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP2);
    psp.pszTitle    = "WAB Ext 2"; 

    pThis->m_hPage2 = ::CreatePropertySheetPage(&psp);
    if (pThis->m_hPage2)
    {
        if (!lpfnAddPage(pThis->m_hPage2, lParam))
            ::DestroyPropertySheetPage(pThis->m_hPage2);
    }

    return NOERROR;
}



STDMETHODIMP CMfcExt::XContextMenuExt::QueryInterface(REFIID riid, void** ppv)
{
    METHOD_PROLOGUE(CMfcExt, ContextMenuExt);
    TRACE("CMfcExt::XContextMenuExt::QueryInterface\n");
    return pThis->ExternalQueryInterface(&riid, ppv);
}

STDMETHODIMP_(ULONG) CMfcExt::XContextMenuExt::AddRef(void)
{
    METHOD_PROLOGUE(CMfcExt, ContextMenuExt);
    return pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CMfcExt::XContextMenuExt::Release(void)
{
    METHOD_PROLOGUE(CMfcExt, ContextMenuExt);
    return pThis->ExternalRelease();
}

STDMETHODIMP CMfcExt::XContextMenuExt::GetCommandString(UINT idCmd,UINT uFlags,UINT *pwReserved,LPSTR pszName,UINT cchMax)
{
    if(uFlags & GCS_HELPTEXT)
    {
        switch (idCmd)
        {
        case 0:
            lstrcpy(pszName,"Collects E-Mail Addresses from selected entries.");
            break;
        case 1:
            lstrcpy(pszName,"Launches the Calculator (disabled when multiple entries are selected)");
            break;
        case 2:
            lstrcpy(pszName,"Launches Notepad (ignores WAB altogether).");
            break;
        }
    }
    return S_OK;
}

STDMETHODIMP CMfcExt::XContextMenuExt::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    METHOD_PROLOGUE(CMfcExt, ContextMenuExt);
    LPWABEXTDISPLAY lpWEC = pThis->m_lpWEDContext;
    LPADRLIST lpAdrList = NULL;
    int nCmdId = (int) lpici->lpVerb;

    if(!lpWEC || !(lpWEC->ulFlags & WAB_CONTEXT_ADRLIST))
        return E_FAIL;

    lpAdrList = (LPADRLIST) lpWEC->lpv;
    switch(nCmdId)
    {
    case 0:
        {
            if(!lpAdrList || !lpAdrList->cEntries)
            {
                AfxMessageBox("Please select some entries first", MB_OK, 0);
                return E_FAIL;
            }
            CDlgContext DlgContext;
            DlgContext.m_lpAdrList = lpAdrList;
            DlgContext.DoModal();
        }
        break;
    case 1:
        ShellExecute(lpici->hwnd, "open", "calc.exe", NULL, NULL, SW_RESTORE);
        break;
    case 2:
        ShellExecute(lpici->hwnd, "open", "notepad.exe", NULL, NULL, SW_RESTORE);
        break;
    }
    return S_OK;
}

STDMETHODIMP CMfcExt::XContextMenuExt::QueryContextMenu(HMENU hMenu,UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    METHOD_PROLOGUE(CMfcExt, ContextMenuExt);
    LPWABEXTDISPLAY lpWEC = pThis->m_lpWEDContext;
    UINT idCmd = idCmdFirst;     
    BOOL bAppendItems=TRUE, bMultiSelected = FALSE; 
    UINT nNumCmd = 0;

    if(lpWEC && lpWEC->lpv)
        bMultiSelected = (((LPADRLIST)(lpWEC->lpv))->cEntries > 1);


    InsertMenu( hMenu, indexMenu++,
                MF_STRING | MF_BYPOSITION,
                idCmd++,
                "E-Mail Collecter");

    InsertMenu( hMenu, indexMenu++,
                MF_STRING | MF_BYPOSITION | (bMultiSelected ? MF_GRAYED : 0),
                idCmd++,
                "Calculator");

    InsertMenu( hMenu, indexMenu++,
                MF_STRING | MF_BYPOSITION,
                idCmd++,
                "Notepad");

    return (idCmd-idCmdFirst); //Must return number of menu 
}


/////////////////////////////////////////////////////////////////////////////
// CDlgContext dialog


CDlgContext::CDlgContext(CWnd* pParent /*=NULL*/)
	: CDialog(CDlgContext::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDlgContext)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDlgContext::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgContext)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgContext, CDialog)
	//{{AFX_MSG_MAP(CDlgContext)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgContext message handlers

BOOL CDlgContext::OnInitDialog() 
{
	CDialog::OnInitDialog();
    CListBox * pListBox = (CListBox *) GetDlgItem(IDC_LIST_EMAIL);

    ULONG i = 0,j=0;
    for(i=0;i<m_lpAdrList->cEntries;i++)
    {
        LPSPropValue lpProps = m_lpAdrList->aEntries[i].rgPropVals;
        ULONG ulcPropCount = m_lpAdrList->aEntries[i].cValues;
        for(j=0;j<ulcPropCount;j++)
        {
            if(lpProps[j].ulPropTag == PR_EMAIL_ADDRESS)
            {
                pListBox->AddString(lpProps[j].Value.LPSZ);
                break;
            }
        }
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\caldlg.cpp ===
// CalDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wabapp.h"
#include "CalDlg.h"
#include "Calendar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCalDlg dialog


CCalDlg::CCalDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCalDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCalDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CCalDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCalDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


void CCalDlg::SetItemName(CString szName)
{
    CString s1("Select a birthday date for ");
    CString s2(szName);
    CString sz(s1 + s2);
    m_psz = new CString(sz);
}

void CCalDlg::SetDate(SYSTEMTIME st)
{
    m_Day = (short) st.wDay;
    m_Month = (short) st.wMonth;
    m_Year = (short) st.wYear;
}

void CCalDlg::GetDate(SYSTEMTIME * lpst)
{
    lpst->wDay = m_Day;
    lpst->wMonth = m_Month;
    lpst->wYear = m_Year;
}

BEGIN_MESSAGE_MAP(CCalDlg, CDialog)
	//{{AFX_MSG_MAP(CCalDlg)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCalDlg message handlers


BOOL CCalDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    CStatic * pStatic = (CStatic *) GetDlgItem(IDC_STATIC_FRAME);

    pStatic->SetWindowText(*m_psz);

    CCalendar * pCal = (CCalendar *) GetDlgItem(IDC_CALENDAR);

    pCal->SetDay(m_Day);
    pCal->SetMonth(m_Month);
    pCal->SetYear(m_Year);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CCalDlg::OnOK() 
{
	// TODO: Add extra validation here
	
    CCalendar * pCal = (CCalendar *) GetDlgItem(IDC_CALENDAR);
    m_Day = pCal->GetDay();
    m_Month = pCal->GetMonth();
    m_Year = pCal->GetYear();
	CDialog::OnOK();
}

void CCalDlg::OnDestroy() 
{
	CDialog::OnDestroy();
	
	// TODO: Add your message handler code here
	delete m_psz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\calendar.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "calendar.h"

// Dispatch interfaces referenced by this interface
#include "Font.h"

/////////////////////////////////////////////////////////////////////////////
// CCalendar

IMPLEMENT_DYNCREATE(CCalendar, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CCalendar properties

/////////////////////////////////////////////////////////////////////////////
// CCalendar operations

unsigned long CCalendar::GetBackColor()
{
	unsigned long result;
	InvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CCalendar::SetBackColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_BACKCOLOR, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

short CCalendar::GetDay()
{
	short result;
	InvokeHelper(0x11, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CCalendar::SetDay(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x11, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

COleFont CCalendar::GetDayFont()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x1, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return COleFont(pDispatch);
}

void CCalendar::SetDayFont(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x1, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CCalendar::GetDayFontColor()
{
	unsigned long result;
	InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CCalendar::SetDayFontColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

short CCalendar::GetDayLength()
{
	short result;
	InvokeHelper(0x12, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CCalendar::SetDayLength(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x12, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CCalendar::GetFirstDay()
{
	short result;
	InvokeHelper(0x13, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CCalendar::SetFirstDay(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x13, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CCalendar::GetGridCellEffect()
{
	long result;
	InvokeHelper(0x14, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CCalendar::SetGridCellEffect(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x14, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

COleFont CCalendar::GetGridFont()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x3, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return COleFont(pDispatch);
}

void CCalendar::SetGridFont(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x3, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CCalendar::GetGridFontColor()
{
	unsigned long result;
	InvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CCalendar::SetGridFontColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x4, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CCalendar::GetGridLinesColor()
{
	unsigned long result;
	InvokeHelper(0xd, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CCalendar::SetGridLinesColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

short CCalendar::GetMonth()
{
	short result;
	InvokeHelper(0x10, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CCalendar::SetMonth(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x10, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

short CCalendar::GetMonthLength()
{
	short result;
	InvokeHelper(0x15, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CCalendar::SetMonthLength(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0x15, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CCalendar::GetShowDateSelectors()
{
	BOOL result;
	InvokeHelper(0x5, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CCalendar::SetShowDateSelectors(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x5, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CCalendar::GetShowDays()
{
	BOOL result;
	InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CCalendar::SetShowDays(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x6, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CCalendar::GetShowHorizontalGrid()
{
	BOOL result;
	InvokeHelper(0x7, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CCalendar::SetShowHorizontalGrid(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x7, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CCalendar::GetShowTitle()
{
	BOOL result;
	InvokeHelper(0x8, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CCalendar::SetShowTitle(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x8, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CCalendar::GetShowVerticalGrid()
{
	BOOL result;
	InvokeHelper(0x9, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CCalendar::SetShowVerticalGrid(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x9, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

COleFont CCalendar::GetTitleFont()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0xa, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return COleFont(pDispatch);
}

void CCalendar::SetTitleFont(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0xa, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

unsigned long CCalendar::GetTitleFontColor()
{
	unsigned long result;
	InvokeHelper(0xb, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CCalendar::SetTitleFontColor(unsigned long newValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xb, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

VARIANT CCalendar::GetValue()
{
	VARIANT result;
	InvokeHelper(0xc, DISPATCH_PROPERTYGET, VT_VARIANT, (void*)&result, NULL);
	return result;
}

void CCalendar::SetValue(const VARIANT& newValue)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0xc, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 &newValue);
}

BOOL CCalendar::GetValueIsNull()
{
	BOOL result;
	InvokeHelper(0xe, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CCalendar::SetValueIsNull(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0xe, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

short CCalendar::GetYear()
{
	short result;
	InvokeHelper(0xf, DISPATCH_PROPERTYGET, VT_I2, (void*)&result, NULL);
	return result;
}

void CCalendar::SetYear(short nNewValue)
{
	static BYTE parms[] =
		VTS_I2;
	InvokeHelper(0xf, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

void CCalendar::NextDay()
{
	InvokeHelper(0x16, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::NextMonth()
{
	InvokeHelper(0x17, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::NextWeek()
{
	InvokeHelper(0x18, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::NextYear()
{
	InvokeHelper(0x19, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::PreviousDay()
{
	InvokeHelper(0x1a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::PreviousMonth()
{
	InvokeHelper(0x1b, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::PreviousWeek()
{
	InvokeHelper(0x1c, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::PreviousYear()
{
	InvokeHelper(0x1d, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::Today()
{
	InvokeHelper(0x1e, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CCalendar::AboutBox()
{
	InvokeHelper(0xfffffdd8, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\caldlg.h ===
#if !defined(AFX_CALDLG_H__555D45A2_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_)
#define AFX_CALDLG_H__555D45A2_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CalDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCalDlg dialog

class CCalDlg : public CDialog
{
// Construction
public:
	CCalDlg(CWnd* pParent = NULL);   // standard constructor
    void SetItemName(CString szName);
    void SetDate(SYSTEMTIME st);
    void GetDate(SYSTEMTIME * lpst);

// Dialog Data
	//{{AFX_DATA(CCalDlg)
	enum { IDD = IDD_DIALOG_CAL };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCalDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    CString * m_psz;
    short   m_Day;
    short   m_Month;
    short   m_Year;

	// Generated message map functions
	//{{AFX_MSG(CCalDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CALDLG_H__555D45A2_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\calendar.h ===
#if !defined(AFX_CALENDAR_H__555D45A3_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_)
#define AFX_CALENDAR_H__555D45A3_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class COleFont;

/////////////////////////////////////////////////////////////////////////////
// CCalendar wrapper class

class CCalendar : public CWnd
{
protected:
	DECLARE_DYNCREATE(CCalendar)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x8e27c92b, 0x1264, 0x101c, { 0x8a, 0x2f, 0x4, 0x2, 0x24, 0x0, 0x9c, 0x2 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	unsigned long GetBackColor();
	void SetBackColor(unsigned long newValue);
	short GetDay();
	void SetDay(short nNewValue);
	COleFont GetDayFont();
	void SetDayFont(LPDISPATCH newValue);
	unsigned long GetDayFontColor();
	void SetDayFontColor(unsigned long newValue);
	short GetDayLength();
	void SetDayLength(short nNewValue);
	short GetFirstDay();
	void SetFirstDay(short nNewValue);
	long GetGridCellEffect();
	void SetGridCellEffect(long nNewValue);
	COleFont GetGridFont();
	void SetGridFont(LPDISPATCH newValue);
	unsigned long GetGridFontColor();
	void SetGridFontColor(unsigned long newValue);
	unsigned long GetGridLinesColor();
	void SetGridLinesColor(unsigned long newValue);
	short GetMonth();
	void SetMonth(short nNewValue);
	short GetMonthLength();
	void SetMonthLength(short nNewValue);
	BOOL GetShowDateSelectors();
	void SetShowDateSelectors(BOOL bNewValue);
	BOOL GetShowDays();
	void SetShowDays(BOOL bNewValue);
	BOOL GetShowHorizontalGrid();
	void SetShowHorizontalGrid(BOOL bNewValue);
	BOOL GetShowTitle();
	void SetShowTitle(BOOL bNewValue);
	BOOL GetShowVerticalGrid();
	void SetShowVerticalGrid(BOOL bNewValue);
	COleFont GetTitleFont();
	void SetTitleFont(LPDISPATCH newValue);
	unsigned long GetTitleFontColor();
	void SetTitleFontColor(unsigned long newValue);
	VARIANT GetValue();
	void SetValue(const VARIANT& newValue);
	BOOL GetValueIsNull();
	void SetValueIsNull(BOOL bNewValue);
	short GetYear();
	void SetYear(short nNewValue);
	void NextDay();
	void NextMonth();
	void NextWeek();
	void NextYear();
	void PreviousDay();
	void PreviousMonth();
	void PreviousWeek();
	void PreviousYear();
	void Refresh();
	void Today();
	void AboutBox();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CALENDAR_H__555D45A3_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wabapp.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_WABAPP_DIALOG               102
#define IDR_MAINFRAME                   128
#define IDD_DIALOG_CAL                  133
#define IDC_LIST                        1000
#define IDC_RADIO_DETAILS               1001
#define IDC_RADIO_PHONELIST             1002
#define IDC_RADIO_EMAILLIST             1003
#define IDC_RADIO_BIRTHDAYS             1004
#define IDC_BUTTON                      1006
#define IDC_EXPLORER                    1012
#define IDC_CALENDAR                    1013
#define IDC_STATIC_FRAME                1014

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\font.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "font.h"


/////////////////////////////////////////////////////////////////////////////
// COleFont properties

CString COleFont::GetName()
{
	CString result;
	GetProperty(0x0, VT_BSTR, (void*)&result);
	return result;
}

void COleFont::SetName(LPCTSTR propVal)
{
	SetProperty(0x0, VT_BSTR, propVal);
}

CY COleFont::GetSize()
{
	CY result;
	GetProperty(0x2, VT_CY, (void*)&result);
	return result;
}

void COleFont::SetSize(const CY& propVal)
{
	SetProperty(0x2, VT_CY, &propVal);
}

BOOL COleFont::GetBold()
{
	BOOL result;
	GetProperty(0x3, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetBold(BOOL propVal)
{
	SetProperty(0x3, VT_BOOL, propVal);
}

BOOL COleFont::GetItalic()
{
	BOOL result;
	GetProperty(0x4, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetItalic(BOOL propVal)
{
	SetProperty(0x4, VT_BOOL, propVal);
}

BOOL COleFont::GetUnderline()
{
	BOOL result;
	GetProperty(0x5, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetUnderline(BOOL propVal)
{
	SetProperty(0x5, VT_BOOL, propVal);
}

BOOL COleFont::GetStrikethrough()
{
	BOOL result;
	GetProperty(0x6, VT_BOOL, (void*)&result);
	return result;
}

void COleFont::SetStrikethrough(BOOL propVal)
{
	SetProperty(0x6, VT_BOOL, propVal);
}

short COleFont::GetWeight()
{
	short result;
	GetProperty(0x7, VT_I2, (void*)&result);
	return result;
}

void COleFont::SetWeight(short propVal)
{
	SetProperty(0x7, VT_I2, propVal);
}

short COleFont::GetCharset()
{
	short result;
	GetProperty(0x8, VT_I2, (void*)&result);
	return result;
}

void COleFont::SetCharset(short propVal)
{
	SetProperty(0x8, VT_I2, propVal);
}

/////////////////////////////////////////////////////////////////////////////
// COleFont operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\font.h ===
#if !defined(AFX_FONT_H__555D45A4_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_)
#define AFX_FONT_H__555D45A4_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// COleFont wrapper class

class COleFont : public COleDispatchDriver
{
public:
	COleFont() {}		// Calls COleDispatchDriver default constructor
	COleFont(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	COleFont(const COleFont& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
	CString GetName();
	void SetName(LPCTSTR);
	CY GetSize();
	void SetSize(const CY&);
	BOOL GetBold();
	void SetBold(BOOL);
	BOOL GetItalic();
	void SetItalic(BOOL);
	BOOL GetUnderline();
	void SetUnderline(BOOL);
	BOOL GetStrikethrough();
	void SetStrikethrough(BOOL);
	short GetWeight();
	void SetWeight(short);
	short GetCharset();
	void SetCharset(short);

// Operations
public:
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FONT_H__555D45A4_E366_11D0_9A66_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BEF211E9_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_)
#define AFX_STDAFX_H__BEF211E9_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BEF211E9_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wabapp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\wabapp.cpp ===
// wabapp.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "wabapp.h"
#include "wabappDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWabappApp

BEGIN_MESSAGE_MAP(CWabappApp, CWinApp)
	//{{AFX_MSG_MAP(CWabappApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWabappApp construction

CWabappApp::CWabappApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWabappApp object

CWabappApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWabappApp initialization

BOOL CWabappApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CWabappDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\wabapp.h ===
// wabapp.h : main header file for the WABAPP application
//

#if !defined(AFX_WABAPP_H__BEF211E5_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_)
#define AFX_WABAPP_H__BEF211E5_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CWabappApp:
// See wabapp.cpp for the implementation of this class
//

class CWabappApp : public CWinApp
{
public:
	CWabappApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWabappApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CWabappApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WABAPP_H__BEF211E5_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\wabappdlg.h ===
// wabappDlg.h : header file
//

#if !defined(AFX_WABAPPDLG_H__BEF211E7_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_)
#define AFX_WABAPPDLG_H__BEF211E7_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
// CWabappDlg dialog

class CWabappDlg : public CDialog
{
// Construction
public:
	CWabappDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CWabappDlg)
	enum { IDD = IDD_WABAPP_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWabappDlg)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CWabappDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnBDayButtonClicked();
	afx_msg void OnClickList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnRadioDetails();
	afx_msg void OnRadioPhonelist();
	afx_msg void OnRadioEmaillist();
	afx_msg void OnRadioBirthdays();
	afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WABAPPDLG_H__BEF211E7_D210_11D0_9A46_00A0C91F9C8B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\wabobject.h ===
#include "stdafx.h"
#include "afxcview.h"
#include "wab.h"

class CWAB
{
public:
    CWAB();
    ~CWAB();
    BOOL CreatePhoneListFileFromWAB(LPTSTR szFileName);
    BOOL CreateEmailListFileFromWAB(LPTSTR szFileName);
    BOOL CreateBirthdayFileFromWAB(LPTSTR szFileName);
    BOOL CreateDetailsFileFromWAB(CListCtrl * pListView, LPTSTR szFileName);
    HRESULT LoadWABContents(CListCtrl * pListView);
    void ClearWABLVContents(CListCtrl * pListView);
    void SetDetailsOn(BOOL bOn);
    void ShowSelectedItemDetails(HWND hWndParent, CListCtrl * pListView);
    BOOL GetSelectedItemBirthday(CListCtrl * pListView, SYSTEMTIME * lpst);
    void SetSelectedItemBirthday(CListCtrl * pListView, SYSTEMTIME st);

private:
    BOOL        m_bInitialized;
    HINSTANCE   m_hinstWAB;
    LPWABOPEN   m_lpfnWABOpen;
    LPADRBOOK   m_lpAdrBook; 
    LPWABOBJECT m_lpWABObject;
    BOOL        m_bDetailsOn;

    void FreeProws(LPSRowSet prows);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\webbrwsr.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "webbrwsr.h"

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser

IMPLEMENT_DYNCREATE(CWebBrowser, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser properties

/////////////////////////////////////////////////////////////////////////////
// CWebBrowser operations

void CWebBrowser::GoBack()
{
	InvokeHelper(0x64, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::GoForward()
{
	InvokeHelper(0x65, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::GoHome()
{
	InvokeHelper(0x66, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::GoSearch()
{
	InvokeHelper(0x67, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::Navigate(LPCTSTR URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers)
{
	static BYTE parms[] =
		VTS_BSTR VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x68, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 URL, Flags, TargetFrameName, PostData, Headers);
}

void CWebBrowser::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::Refresh2(VARIANT* Level)
{
	static BYTE parms[] =
		VTS_PVARIANT;
	InvokeHelper(0x69, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 Level);
}

void CWebBrowser::Stop()
{
	InvokeHelper(0x6a, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

LPDISPATCH CWebBrowser::GetApplication()
{
	LPDISPATCH result;
	InvokeHelper(0xc8, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CWebBrowser::GetParent()
{
	LPDISPATCH result;
	InvokeHelper(0xc9, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CWebBrowser::GetContainer()
{
	LPDISPATCH result;
	InvokeHelper(0xca, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

LPDISPATCH CWebBrowser::GetDocument()
{
	LPDISPATCH result;
	InvokeHelper(0xcb, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser::GetTopLevelContainer()
{
	BOOL result;
	InvokeHelper(0xcc, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

CString CWebBrowser::GetType()
{
	CString result;
	InvokeHelper(0xcd, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CWebBrowser::GetLeft()
{
	long result;
	InvokeHelper(0xce, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetLeft(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xce, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CWebBrowser::GetTop()
{
	long result;
	InvokeHelper(0xcf, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetTop(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xcf, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CWebBrowser::GetWidth()
{
	long result;
	InvokeHelper(0xd0, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetWidth(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd0, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CWebBrowser::GetHeight()
{
	long result;
	InvokeHelper(0xd1, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetHeight(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0xd1, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CString CWebBrowser::GetLocationName()
{
	CString result;
	InvokeHelper(0xd2, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

CString CWebBrowser::GetLocationURL()
{
	CString result;
	InvokeHelper(0xd3, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser::GetBusy()
{
	BOOL result;
	InvokeHelper(0xd4, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::Quit()
{
	InvokeHelper(0x12c, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CWebBrowser::ClientToWindow(long* pcx, long* pcy)
{
	static BYTE parms[] =
		VTS_PI4 VTS_PI4;
	InvokeHelper(0x12d, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pcx, pcy);
}

void CWebBrowser::PutProperty(LPCTSTR szProperty, const VARIANT& vtValue)
{
	static BYTE parms[] =
		VTS_BSTR VTS_VARIANT;
	InvokeHelper(0x12e, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 szProperty, &vtValue);
}

VARIANT CWebBrowser::GetProperty_(LPCTSTR szProperty)
{
	VARIANT result;
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x12f, DISPATCH_METHOD, VT_VARIANT, (void*)&result, parms,
		szProperty);
	return result;
}

CString CWebBrowser::GetName()
{
	CString result;
	InvokeHelper(0x0, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

long CWebBrowser::GetHwnd()
{
	long result;
	InvokeHelper(DISPID_HWND, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

CString CWebBrowser::GetFullName()
{
	CString result;
	InvokeHelper(0x190, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

CString CWebBrowser::GetPath()
{
	CString result;
	InvokeHelper(0x191, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser::GetVisible()
{
	BOOL result;
	InvokeHelper(0x192, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetVisible(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x192, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetStatusBar()
{
	BOOL result;
	InvokeHelper(0x193, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetStatusBar(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x193, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

CString CWebBrowser::GetStatusText()
{
	CString result;
	InvokeHelper(0x194, DISPATCH_PROPERTYGET, VT_BSTR, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetStatusText(LPCTSTR lpszNewValue)
{
	static BYTE parms[] =
		VTS_BSTR;
	InvokeHelper(0x194, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 lpszNewValue);
}

long CWebBrowser::GetToolBar()
{
	long result;
	InvokeHelper(0x195, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetToolBar(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x195, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CWebBrowser::GetMenuBar()
{
	BOOL result;
	InvokeHelper(0x196, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetMenuBar(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x196, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetFullScreen()
{
	BOOL result;
	InvokeHelper(0x197, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetFullScreen(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x197, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

void CWebBrowser::Navigate2(VARIANT* URL, VARIANT* Flags, VARIANT* TargetFrameName, VARIANT* PostData, VARIANT* Headers)
{
	static BYTE parms[] =
		VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x1f4, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 URL, Flags, TargetFrameName, PostData, Headers);
}

long CWebBrowser::QueryStatusWB(long cmdID)
{
	long result;
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x1f5, DISPATCH_METHOD, VT_I4, (void*)&result, parms,
		cmdID);
	return result;
}

void CWebBrowser::ExecWB(long cmdID, long cmdexecopt, VARIANT* pvaIn, VARIANT* pvaOut)
{
	static BYTE parms[] =
		VTS_I4 VTS_I4 VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x1f6, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 cmdID, cmdexecopt, pvaIn, pvaOut);
}

void CWebBrowser::ShowBrowserBar(VARIANT* pvaClsid, VARIANT* pvarShow, VARIANT* pvarSize)
{
	static BYTE parms[] =
		VTS_PVARIANT VTS_PVARIANT VTS_PVARIANT;
	InvokeHelper(0x1f7, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 pvaClsid, pvarShow, pvarSize);
}

long CWebBrowser::GetReadyState()
{
	long result;
	InvokeHelper(DISPID_READYSTATE, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

BOOL CWebBrowser::GetOffline()
{
	BOOL result;
	InvokeHelper(0x226, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetOffline(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x226, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetSilent()
{
	BOOL result;
	InvokeHelper(0x227, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetSilent(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x227, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetRegisterAsBrowser()
{
	BOOL result;
	InvokeHelper(0x228, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetRegisterAsBrowser(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x228, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetRegisterAsDropTarget()
{
	BOOL result;
	InvokeHelper(0x229, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetRegisterAsDropTarget(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x229, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

BOOL CWebBrowser::GetTheaterMode()
{
	BOOL result;
	InvokeHelper(0x22a, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CWebBrowser::SetTheaterMode(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(0x22a, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\wabappdlg.cpp ===
// wabappDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wabapp.h"
#include "wabappDlg.h"
#include "caldlg.h"
#include "webbrwsr.h"
#include "wabobject.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CWAB * g_pWAB;

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWabappDlg dialog

CWabappDlg::CWabappDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWabappDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWabappDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CWabappDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWabappDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CWabappDlg, CDialog)
	//{{AFX_MSG_MAP(CWabappDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_BUTTON, OnBDayButtonClicked)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
	ON_BN_CLICKED(IDC_RADIO_DETAILS, OnRadioDetails)
	ON_BN_CLICKED(IDC_RADIO_PHONELIST, OnRadioPhonelist)
	ON_BN_CLICKED(IDC_RADIO_EMAILLIST, OnRadioEmaillist)
	ON_BN_CLICKED(IDC_RADIO_BIRTHDAYS, OnRadioBirthdays)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWabappDlg message handlers

BOOL CWabappDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here

    InitCommonControls();

    g_pWAB = new CWAB;
    
    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);
    g_pWAB->LoadWABContents(pListView);

    // select the first item in the list view
    pListView->SetItem(0,0,LVIF_STATE,NULL,0,LVNI_SELECTED,LVNI_SELECTED,NULL);

    // turn on the details button by default
    CButton * pButtonDetails = (CButton *) GetDlgItem(IDC_RADIO_DETAILS);
    pButtonDetails->SetCheck(BST_CHECKED);

    SendMessage(WM_COMMAND, (WPARAM) IDC_RADIO_DETAILS, 0);

	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CWabappDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CWabappDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CWabappDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CWabappDlg::OnBDayButtonClicked() 
{
    CCalDlg CalDlg;

    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);

    int iItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(iItem == -1)
        return;

    CalDlg.SetItemName(pListView->GetItemText(iItem, 0));

    SYSTEMTIME st={0};

    if(!g_pWAB->GetSelectedItemBirthday(pListView, &st))
        GetSystemTime(&st);

    CalDlg.SetDate(st);

    if(IDOK == CalDlg.DoModal())
    {
        CalDlg.GetDate(&st);
        g_pWAB->SetSelectedItemBirthday(pListView, st);
    }

}

BOOL CWabappDlg::DestroyWindow() 
{
    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);
    
    g_pWAB->ClearWABLVContents(pListView);

    delete g_pWAB;

	return CDialog::DestroyWindow();
}



void CWabappDlg::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);

    static int oldItem;

    int newItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(newItem != oldItem && newItem != -1)
    {
        TCHAR szFileName[MAX_PATH];

        g_pWAB->CreateDetailsFileFromWAB(pListView, szFileName);
        if(lstrlen(szFileName))
        {
            CWebBrowser * pCWB = (CWebBrowser *) GetDlgItem(IDC_EXPLORER);
            pCWB->Navigate(szFileName, NULL, NULL, NULL, NULL);
        }
        oldItem = newItem;
    }
	
	*pResult = 0;
}

void CWabappDlg::OnRadioDetails() 
{
    g_pWAB->SetDetailsOn(TRUE);

    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);

    TCHAR szFileName[MAX_PATH];

    g_pWAB->CreateDetailsFileFromWAB(pListView, szFileName);
    if(lstrlen(szFileName))
    {
        CWebBrowser * pCWB = (CWebBrowser *) GetDlgItem(IDC_EXPLORER);
        pCWB->Navigate(szFileName, NULL, NULL, NULL, NULL);
    }

}

void CWabappDlg::OnRadioPhonelist() 
{
    TCHAR szFileName[MAX_PATH];
    
    g_pWAB->SetDetailsOn(FALSE);

    g_pWAB->CreatePhoneListFileFromWAB(szFileName);
    
    if(lstrlen(szFileName))
    {
        CWebBrowser * pCWB = (CWebBrowser *) GetDlgItem(IDC_EXPLORER);
        pCWB->Navigate(szFileName, NULL, NULL, NULL, NULL);
    }
}

void CWabappDlg::OnRadioEmaillist() 
{
    TCHAR szFileName[MAX_PATH];
    
    g_pWAB->SetDetailsOn(FALSE);

    g_pWAB->CreateEmailListFileFromWAB(szFileName);
    
    if(lstrlen(szFileName))
    {
        CWebBrowser * pCWB = (CWebBrowser *) GetDlgItem(IDC_EXPLORER);
        pCWB->Navigate(szFileName, NULL, NULL, NULL, NULL);
    }

}

void CWabappDlg::OnRadioBirthdays() 
{
    TCHAR szFileName[MAX_PATH];
    
    g_pWAB->SetDetailsOn(FALSE);

    g_pWAB->CreateBirthdayFileFromWAB(szFileName);
    
    if(lstrlen(szFileName))
    {
        CWebBrowser * pCWB = (CWebBrowser *) GetDlgItem(IDC_EXPLORER);
        pCWB->Navigate(szFileName, NULL, NULL, NULL, NULL);
    }
}

void CWabappDlg::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    CListCtrl * pListView = (CListCtrl *) GetDlgItem(IDC_LIST);
    
    g_pWAB->ShowSelectedItemDetails(m_hWnd, pListView);

	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\_wabapp.h ===
#include "stdafx.h"
#include "webbrwsr.h"
#include "wabapp.h"
#include "wabappDlg.h"
#include "wab.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\outlookexpress\wabw\test\wabapp\wabobject.cpp ===
#include "wabobject.h"



enum {
    ieidPR_DISPLAY_NAME = 0,
    ieidPR_ENTRYID,
	ieidPR_OBJECT_TYPE,
    ieidPR_WAB_CONF_SERVERS,
    ieidMax
};
static const SizedSPropTagArray(ieidMax, ptaEid)=
{
    ieidMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
		PR_OBJECT_TYPE,
        0x8000101e,
    }
};

enum {
    iemailPR_DISPLAY_NAME = 0,
    iemailPR_ENTRYID,
    iemailPR_EMAIL_ADDRESS,
    iemailPR_OBJECT_TYPE,
    iemailMax
};
static const SizedSPropTagArray(iemailMax, ptaEmail)=
{
    iemailMax,
    {
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_EMAIL_ADDRESS,
        PR_OBJECT_TYPE
    }
};


enum {
    iphonePR_DISPLAY_NAME = 0,
    iphonePR_BUSINESS_TELEPHONE_NUMBER,
    iphonePR_HOME_TELEPHONE_NUMBER,
    iphonePR_ENTRYID,
    iphonePR_OBJECT_TYPE,
    iphoneMax
};
static const SizedSPropTagArray(iphoneMax, ptaPhone)=
{
    iphoneMax,
    {
        PR_DISPLAY_NAME,
        PR_BUSINESS_TELEPHONE_NUMBER,
        PR_HOME_TELEPHONE_NUMBER,
        PR_ENTRYID,
        PR_OBJECT_TYPE
    }
};


enum {
    ibdayPR_BIRTHDAY=0,
    ibdayPR_DISPLAY_NAME,
    ibdayPR_ENTRYID,
    ibdayPR_OBJECT_TYPE,
    ibdayMax
};
static const SizedSPropTagArray(ibdayMax, ptaBday)=
{
    ibdayMax,
    {
        PR_BIRTHDAY,
        PR_DISPLAY_NAME,
        PR_ENTRYID,
        PR_OBJECT_TYPE
    }
};




/*********************************************************************************************************/

ULONG ulProps[] = 
{
    PR_DISPLAY_NAME,
    PR_HOME_TELEPHONE_NUMBER,
    PR_HOME_FAX_NUMBER,
    PR_CELLULAR_TELEPHONE_NUMBER,
    PR_BUSINESS_TELEPHONE_NUMBER,
    PR_BUSINESS_FAX_NUMBER,
    PR_PAGER_TELEPHONE_NUMBER,
    PR_HOME_ADDRESS_STREET,
    PR_HOME_ADDRESS_CITY,
    PR_HOME_ADDRESS_STATE_OR_PROVINCE,
    PR_HOME_ADDRESS_POSTAL_CODE,
    PR_HOME_ADDRESS_COUNTRY,
    PR_DEPARTMENT_NAME,
    PR_COMPANY_NAME,
    PR_OFFICE_LOCATION,
    PR_BUSINESS_ADDRESS_STREET,
    PR_BUSINESS_ADDRESS_CITY,
    PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE,
    PR_BUSINESS_ADDRESS_POSTAL_CODE,
    PR_BUSINESS_ADDRESS_COUNTRY,
    PR_PERSONAL_HOME_PAGE,
    PR_BUSINESS_HOME_PAGE,
    PR_COMMENT,
};
#define ulPropsMax 23

enum _Parts {
    pMain=0, 
    pEmail, 
    pPhone, 
    pHome, 
    pBusiness, 
    pURLS, 
    pNotes, 
    pEnd,
    pPartsMax
};


TCHAR szEmailPageHeader[] = 
"<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"><title>WAB Email Address List</title></head><body bgcolor=\"#A02303\" text=\"#FFFF00\" link=\"#FFFFFF\" vlink=\"#800000\" alink=\"#0000FF\"><div align=\"center\"><center><table border=\"0\" cellspacing=\"1\" width=\"520\" bgcolor=\"#000040\"><tr><th><font size=\"6\">Email Addresses</font></th></tr>";

TCHAR szEmailPageEnd[] =
"<tr><th><font size=\"6\">&nbsp;</font></th></tr></table></center></div></body></html>";

LPTSTR szEmailItem[] =
{
    "<tr><td><div align=\"center\"><center><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td align=\"center\" width=\"250\" bgcolor=\"#F24F00\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#F24F00\">&nbsp;</td></tr><tr><td align=\"center\" width=\"250\" bgcolor=\"#F24F00\"bordercolor=\"#008080\"><font size=\"4\" face=\"Comic Sans MS\">%1</font></td><td width=\"250\" bgcolor=\"#F24F00\"><a href=\"mailto:%2\">%2</a></td></tr><tr><td align=\"center\" width=\"250\" bgcolor=\"#F24F00\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#F24F00\">&nbsp;</td></tr></table></center></div></td></tr>",
    "<tr><td><div align=\"center\"><center><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\"><tr><td align=\"center\" width=\"250\" bgcolor=\"#3A7474\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#3A7474\">&nbsp;</td></tr><tr><td align=\"center\" width=\"250\" bgcolor=\"#3A7474\"bordercolor=\"#008080\"><font size=\"4\" face=\"Comic Sans MS\">%1</font></td><td width=\"250\" bgcolor=\"#3A7474\"><a href=\"mailto:%2\">%2</a></td></tr><tr><td align=\"center\" width=\"250\" bgcolor=\"#3A7474\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#3A7474\">&nbsp;</td></tr></table></center></div></td></tr>"
};

TCHAR szPhonePageHeader[] =
"<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"><title>WAB Phone List</title></head><body bgcolor=\"#A02303\" text=\"#FFFF00\" link=\"#FFFFFF\" vlink=\"#800000\" alink=\"#0000FF\"><div align=\"center\"><center><table border=\"0\" cellspacing=\"1\" width=\"520\" bgcolor=\"#000040\"><tr><th><font size=\"6\">Phone List</font></th></tr><tr><td>&nbsp;</td></tr><tr><td><div align=\"center\"><center><table border=\"0\" cellpadding=\"0\" cellspacing=\"0\">";

TCHAR szPhonePageEnd[] =
"</table></center></div></td></tr><tr><td>&nbsp;</td></tr></table></center></div></body></html>";

LPTSTR szPhoneItem[] =
{
"<tr><td align=\"center\" width=\"200\" bgcolor=\"#2B69AE\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#2B69AE\">&nbsp;</td></tr><tr><td align=\"center\" valign=\"top\" width=\"200\" bgcolor=\"#2B69AE\" bordercolor=\"#008080\"><font size=\"4\" face=\"Comic Sans MS\">%1</font></td><td width=\"250\" bgcolor=\"#2B69AE\"><div align=\"left\"><table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" width=\"240\" bordercolor=\"#FFFFFF\" bordercolordark=\"#2B69AE\" bordercolorlight=\"#FFFFFF\"><tr><td width=\"100\">Work:</td><td width=\"130\">%2</td></tr><tr><td width=\"100\">Home:</td><td width=\"130\">%3</td></tr></table></div></td></tr><tr><td align=\"center\" width=\"200\" bgcolor=\"#2B69AE\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#2B69AE\">&nbsp;</td></tr>",
"<tr><td align=\"center\" width=\"200\" bgcolor=\"#F36565\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#F36565\">&nbsp;</td></tr><tr><td align=\"center\" valign=\"top\" width=\"200\" bgcolor=\"#F36565\" bordercolor=\"#008080\"><font size=\"4\" face=\"Comic Sans MS\">%1</font></td><td width=\"250\" bgcolor=\"#F36565\"><div align=\"left\"><table border=\"1\" cellpadding=\"0\" cellspacing=\"0\" width=\"240\" bordercolor=\"#FFFFFF\" bordercolordark=\"#F36565\" bordercolorlight=\"#FFFFFF\"><tr><td width=\"100\">Work:</td><td width=\"130\">%2</td></tr><tr><td width=\"100\">Home:</td><td width=\"130\">%3</td></tr></table></div></td></tr><tr><td align=\"center\" width=\"200\" bgcolor=\"#F36565\" bordercolor=\"#008080\">&nbsp;</td><td width=\"250\" bgcolor=\"#F36565\">&nbsp;</td></tr>",
};

TCHAR szDetailsPageHeader[] =
"<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\">";

TCHAR szDetailsPageMain[] =
"<title>%1</title></head><body bgcolor=\"#A02303\" text=\"#FFFF00\" link=\"#FFFFFF\"vlink=\"#00FF00\"><div align=\"center\"><center><table border=\"1\" cellspacing=\"1\" width=\"520\" bgcolor=\"#000040\"><tr><th><font size=\"6\">%1</font></th></tr><tr><td><div align=\"center\"><center><table border=\"0\"cellspacing=\"1\"><tr>";

TCHAR szEmailAddressesStart[] = 
"<td valign=\"top\" width=\"200\">E-mail Addresses:<div align=\"left\"><table border=\"1\" cellspacing=\"1\" bgcolor=\"#000000\" bordercolor=\"#FF0000\">";

TCHAR szEmailAddressesMiddle[] = 
"<tr><td><font size=\"2\" face=\"Courier New\"><a href=\"mailto:%1\">%1</a></font></td></tr>";

TCHAR szEmailAddressesEnd[] =
"</table></div></td>";

TCHAR szPhoneNumbers[] = 
"<td valign=\"top\" width=\"300\">Phone Numbers:<div align=\"left\"><table border=\"1\" cellspacing=\"1\"bgcolor=\"#000000\" bordercolor=\"#FF0000\"><tr><td><font size=\"2\" face=\"Courier New\">Home:</font></td><td><font size=\"2\" face=\"Courier New\">%2</font></td></tr><tr><td><font size=\"2\" face=\"Courier New\">Home Fax:</font></td><td><font size=\"2\" face=\"Courier New\">%3</font></td></tr><tr><td><font size=\"2\" face=\"Courier New\">Cellular:</font></td><td><font size=\"2\" face=\"Courier New\">%4</font></td></tr><tr><td><font size=\"2\" face=\"Courier New\">Business:</font></td><td><font size=\"2\" face=\"Courier New\">%5</font></td></tr><tr><td><font size=\"2\" face=\"Courier New\">Business-Fax:</font></td><td><font size=\"2\" face=\"Courier New\">%6</font></td></tr><tr><td><font size=\"2\" face=\"Courier New\">Pager:</font></td><td><font size=\"2\" face=\"Courier New\">%7</font></td></tr></table></div></td>";

TCHAR szHomeAddress[] = 
"<td valign=\"top\">&nbsp;</td></tr></table></center></div></td></tr><tr><td><div align=\"center\"><center><table border=\"0\" cellspacing=\"1\"><tr><td valign=\"top\" width=\"200\">Home Address:<address>%8</address><address>%9 %10 %11</address><address>%12 </address></td>";

TCHAR szBusinessAddress[] = 
"<td width=\"200\">Business Address:<address>%13</address><address>%14</address><address>%15</address><address>%16</address><address>%17 %18 %19</address><address>%20</address></td></tr></table></center></div></td></tr>";

TCHAR szURLS[] = 
"<tr><td><ul><li>Personal Home Page: <a href=\"%21\">%21</a></li></ul><ul><li>Business Web Page: <a href=\"%22\">%22</a></li></ul></td></tr>";

TCHAR szNotes[] = 
"<tr><td>Notes: %23</td></tr></table></center></div>";

TCHAR szDetailsPageEnd[] = 
"</body></html>";


TCHAR szBdayHeader[] =
"<html><head><meta http-equiv=\"Content-Type\" content=\"text/html; charset=iso-8859-1\"><meta name=\"GENERATOR\" content=\"Microsoft FrontPage 2.0\"><title>Birthdays</title></head><body bgcolor=\"#A02303\" text=\"#FFFF00\" link=\"#FFFFFF\" vlink=\"#800000\" alink=\"#0000FF\"><div align=\"center\"><center><table border=\"0\" cellspacing=\"1\" width=\"520\" bgcolor=\"#000040\"><tr><th><font color=\"#C0C0C0\" size=\"6\">Birthdays</font></th></tr><tr><td><table border=\"0\" cellspacing=\"1\" width=\"100%\">";

TCHAR szBdayEnd[] =
"</table></td></tr><tr><td>&nbsp;</td></tr></table></center></div></body></html>";

TCHAR szBdaySingleItem[] =
"<tr><td width=\"100\">&nbsp;</td><td align=\"right\" width=\"200\"><ul><li><p align=\"left\"><font size=\"4\" face=\"Comic Sans MS\">%2</font></p></li></ul></td><td align=\"right\" width=\"100\"><p align=\"center\"><font size=\"4\" face=\"Comic Sans MS\"><em>%1</em></font></p></td></tr>";

LPTSTR szBdayMonthItemStart[] =
{
    "<tr><td width=\"250\" bgcolor=\"#2B69AE\"><blockquote><h1><font color=\"#80FFFF\" size=\"5\" face=\"Comic Sans MS\">%1</font></h1></blockquote><div align=\"center\"><center><table border=\"0\" cellspacing=\"1\" width=\"400\">",
    "<tr><td width=\"250\" bgcolor=\"#77943A\"><blockquote><h1><font color=\"#80FFFF\" size=\"5\" face=\"Comic Sans MS\">%1</font></h1></blockquote><div align=\"center\"><center><table border=\"0\" cellspacing=\"1\" width=\"400\">",
};

TCHAR szBdayMonthItemEnd[]=
"</table></center></div></td></tr><tr><td>&nbsp;</td></tr>";

const LPTSTR szMonth[] = 
{
    "January", "February", "March", "April", "May", "June", 
    "July", "August", "September", "October", "November", "December"
};


/*********************************************************************************************************/


// contructor
CWAB::CWAB()
{
    // Here we load the WAB Object and initialize it
    m_bInitialized = FALSE;

    {
        TCHAR  szWABDllPath[MAX_PATH];

        DWORD  dwType = 0;
        ULONG  cbData = sizeof(szWABDllPath);
        HKEY hKey = NULL;

        *szWABDllPath = '\0';
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
            RegQueryValueEx( hKey, "", NULL, &dwType, (LPBYTE) szWABDllPath, &cbData);

        if(hKey) RegCloseKey(hKey);

        m_hinstWAB = LoadLibrary( (lstrlen(szWABDllPath)) ? szWABDllPath : WAB_DLL_NAME );
    }

    if(m_hinstWAB)
        m_lpfnWABOpen = (LPWABOPEN) GetProcAddress(m_hinstWAB, "WABOpen");

    if(m_lpfnWABOpen)
    {
        HRESULT hr = E_FAIL;
        hr = m_lpfnWABOpen(&m_lpAdrBook,&m_lpWABObject,NULL,0);
        if(!hr)
            m_bInitialized = TRUE;
    }

}


CWAB::~CWAB()
{
    if(m_bInitialized)
    {
        if(m_lpAdrBook)
            m_lpAdrBook->Release();

        if(m_lpWABObject)
            m_lpWABObject->Release();

        if(m_hinstWAB)
            FreeLibrary(m_hinstWAB);
    }
}


void CWAB::ClearWABLVContents(CListCtrl * pListView)
{
    int i;
    int nCount = pListView->GetItemCount();
    
    if(nCount<=0)
        return;

    for(i=0;i<nCount;i++)
    {
        LV_ITEM lvi ={0};
        lvi.mask = LVIF_PARAM;
        lvi.iItem = i;
        lvi.iSubItem = 0;
        pListView->GetItem(&lvi);
        if(lvi.lParam)
        {
            LPSBinary lpSB = (LPSBinary) lvi.lParam;
            m_lpWABObject->FreeBuffer(lpSB);
        }
    }

    pListView->DeleteAllItems();
}


HRESULT CWAB::LoadWABContents(CListCtrl * pListView)
{
    ULONG ulObjType =   0;
	LPMAPITABLE lpAB =  NULL;
    LPTSTR * lppszArray=NULL;
    ULONG cRows =       0;
    LPSRowSet lpRow =   NULL;
	LPSRowSet lpRowAB = NULL;
    LPABCONT  lpContainer = NULL;
    
    HRESULT hr = E_FAIL;

    ULONG lpcbEID;
	LPENTRYID lpEID = NULL;

    hr = m_lpAdrBook->GetPAB( &lpcbEID, &lpEID);

	ulObjType = 0;

    hr = m_lpAdrBook->OpenEntry(lpcbEID,
					    		(LPENTRYID)lpEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);

	m_lpWABObject->FreeBuffer(lpEID);

	lpEID = NULL;
		
    hr = lpContainer->GetContentsTable( 0,
            							&lpAB);


	if ( SUCCEEDED(hr) )
		hr =lpAB->SetColumns( (LPSPropTagArray)&ptaEid, 0 );

	if ( SUCCEEDED(hr) )
		hr = lpAB->SeekRow( BOOKMARK_BEGINNING, 0, NULL );


	int cNumRows = 0;
    int nRows=0;



	do {

		if ( SUCCEEDED(hr) )
			hr = lpAB->QueryRows(1,	0, &lpRowAB);

        if(lpRowAB)
        {
            cNumRows = lpRowAB->cRows;

		    if ( SUCCEEDED(hr) && cNumRows)
		    {
                LPTSTR lpsz = lpRowAB->aRow[0].lpProps[ieidPR_DISPLAY_NAME].Value.lpszA;
                LPENTRYID lpEID = (LPENTRYID) lpRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.lpb;
                ULONG cbEID = lpRowAB->aRow[0].lpProps[ieidPR_ENTRYID].Value.bin.cb;

                if(lpRowAB->aRow[0].lpProps[ieidPR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
                {
                    LPSBinary lpSB = NULL;

                    m_lpWABObject->AllocateBuffer(sizeof(SBinary), (LPVOID *) &lpSB);
                
                    if(lpSB)
                    {
                        m_lpWABObject->AllocateMore(cbEID, lpSB, (LPVOID *) &(lpSB->lpb));

                        if(!lpSB->lpb)
                        {
                            m_lpWABObject->FreeBuffer(lpSB);
                            continue;
                        }
                    
                        CopyMemory(lpSB->lpb, lpEID, cbEID);
                        lpSB->cb = cbEID;

                        LV_ITEM lvi = {0};
                        lvi.mask = LVIF_TEXT | LVIF_PARAM;
                        lvi.iItem = pListView->GetItemCount();
                        lvi.iSubItem = 0;
                        lvi.pszText = lpsz;
                        lvi.lParam = (LPARAM) lpSB;

                        // Now add this item to the list view
                        pListView->InsertItem(&lvi);
                    }
                }
		    }
		    FreeProws(lpRowAB );		
        }

	}while ( SUCCEEDED(hr) && cNumRows && lpRowAB)  ;

	if ( lpContainer )
		lpContainer->Release();

	if ( lpAB )
		lpAB->Release();

    return hr;
}

BOOL CWAB::CreatePhoneListFileFromWAB(LPTSTR szFileName)
{
    BOOL bRet = FALSE;
    ULONG ulObjType =   0;
	LPMAPITABLE lpAB =  NULL;
    LPTSTR * lppszArray=NULL;
    ULONG cRows =       0;
    LPSRowSet lpRow =   NULL;
	LPSRowSet lpRowAB = NULL;
    LPABCONT  lpContainer = NULL;
    
    HRESULT hr = E_FAIL;

    ULONG lpcbEID;
	LPENTRYID lpEID = NULL;

    TCHAR szDir[MAX_PATH];

    GetTempPath(MAX_PATH, szDir);

    lstrcpy(szFileName, szDir);
    lstrcat(szFileName, "temp.htm");

    hr = m_lpAdrBook->GetPAB( &lpcbEID, &lpEID);

	ulObjType = 0;

    hr = m_lpAdrBook->OpenEntry(lpcbEID,
					    		(LPENTRYID)lpEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);

	m_lpWABObject->FreeBuffer(lpEID);

	lpEID = NULL;
		
    hr = lpContainer->GetContentsTable( 0,
            							&lpAB);


	if ( SUCCEEDED(hr) )
		hr =lpAB->SetColumns( (LPSPropTagArray)&ptaPhone, 0 );

	if ( SUCCEEDED(hr) )
		hr = lpAB->SeekRow( BOOKMARK_BEGINNING, 0, NULL );


	int cNumRows = 0;
    int nRows=0;

    HANDLE hFile = NULL;
    DWORD dw;
    hFile = CreateFile( szFileName,
                          GENERIC_WRITE,	
                          0,    // sharing
                          NULL,
                          CREATE_ALWAYS,
                          FILE_FLAG_SEQUENTIAL_SCAN,	
                          NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        WriteFile(  hFile,
                    (LPCVOID) szPhonePageHeader,
                    (DWORD) lstrlen(szPhonePageHeader),
                    &dw,
                    NULL);
    }

    int nType = 0;

	do {

		if ( SUCCEEDED(hr) )
			hr = lpAB->QueryRows(1,	0, &lpRowAB);

        if(lpRowAB)
        {
            cNumRows = lpRowAB->cRows;
            LPTSTR sz[iphoneMax];

		    if ( SUCCEEDED(hr) && cNumRows)
		    {

                int i;
                for(i=0;i<iphoneMax-2;i++)
                {
                    sz[i] = lpRowAB->aRow[0].lpProps[i].Value.lpszA;
                    if(!sz[i] || !lstrlen(sz[i]))
                        sz[i] = TEXT("&nbsp;");
                }


                if(lpRowAB->aRow[0].lpProps[iphonePR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
                {
                    LPTSTR lpPhoneItem =NULL;

                    FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    szPhoneItem[nType],
                                    0, 0, //ignored
                                    (LPTSTR) &lpPhoneItem, 0,
                                    (va_list *)sz);
                    nType = 1- nType;

                    if(lpPhoneItem)
                    {
                        if(hFile != INVALID_HANDLE_VALUE)
                        {
                            WriteFile(  hFile,
                                        (LPCVOID) lpPhoneItem,
                                        (DWORD) lstrlen(lpPhoneItem),
                                        &dw,
                                        NULL);
                        }

                        LocalFree(lpPhoneItem);
                    }
                }
		    }
		    FreeProws(lpRowAB );		
        }

	}while ( SUCCEEDED(hr) && cNumRows && lpRowAB)  ;

    if(hFile != INVALID_HANDLE_VALUE)
    {
        WriteFile(  hFile,
                    (LPCVOID) szPhonePageEnd,
                    (DWORD) lstrlen(szPhonePageEnd),
                    &dw,
                    NULL);
        CloseHandle(hFile);
    }

    if ( lpContainer )
		lpContainer->Release();

	if ( lpAB )
		lpAB->Release();

    return bRet;
}

BOOL CWAB::CreateEmailListFileFromWAB(LPTSTR szFileName)
{
    BOOL bRet = FALSE;
    ULONG ulObjType =   0;
	LPMAPITABLE lpAB =  NULL;
    LPTSTR * lppszArray=NULL;
    ULONG cRows =       0;
    LPSRowSet lpRow =   NULL;
	LPSRowSet lpRowAB = NULL;
    LPABCONT  lpContainer = NULL;
    
    HRESULT hr = E_FAIL;

    ULONG lpcbEID;
	LPENTRYID lpEID = NULL;

    TCHAR szDir[MAX_PATH];

    GetTempPath(MAX_PATH, szDir);

    lstrcpy(szFileName, szDir);
    lstrcat(szFileName, "temp.htm");

    hr = m_lpAdrBook->GetPAB( &lpcbEID, &lpEID);

	ulObjType = 0;

    hr = m_lpAdrBook->OpenEntry(lpcbEID,
					    		(LPENTRYID)lpEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);

	m_lpWABObject->FreeBuffer(lpEID);

	lpEID = NULL;
		
    hr = lpContainer->GetContentsTable( 0,
            							&lpAB);


	if ( SUCCEEDED(hr) )
		hr =lpAB->SetColumns( (LPSPropTagArray)&ptaEmail, 0 );

	if ( SUCCEEDED(hr) )
		hr = lpAB->SeekRow( BOOKMARK_BEGINNING, 0, NULL );


	int cNumRows = 0;
    int nRows=0;

    HANDLE hFile = NULL;
    DWORD dw;
    hFile = CreateFile( szFileName,
                          GENERIC_WRITE,	
                          0,    // sharing
                          NULL,
                          CREATE_ALWAYS,
                          FILE_FLAG_SEQUENTIAL_SCAN,	
                          NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        WriteFile(  hFile,
                    (LPCVOID) szEmailPageHeader,
                    (DWORD) lstrlen(szEmailPageHeader),
                    &dw,
                    NULL);
    }

    int nType = 0;

	do {

		if ( SUCCEEDED(hr) )
			hr = lpAB->QueryRows(1,	0, &lpRowAB);

        if(lpRowAB)
        {
            cNumRows = lpRowAB->cRows;
            LPTSTR sz[2];

		    if ( SUCCEEDED(hr) && cNumRows)
		    {
                sz[0] = lpRowAB->aRow[0].lpProps[iemailPR_DISPLAY_NAME].Value.lpszA;
                sz[1] = lpRowAB->aRow[0].lpProps[iemailPR_EMAIL_ADDRESS].Value.lpszA;

                if(!sz[1] || !lstrlen(sz[1]))
                    sz[1] = "No E-mail";

                if(lpRowAB->aRow[0].lpProps[iemailPR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
                {
                    LPTSTR lpEmailItem =NULL;

                    FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    szEmailItem[nType],
                                    0, 0, //ignored
                                    (LPTSTR) &lpEmailItem, 0,
                                    (va_list *)sz);
                    nType = 1- nType;

                    if(lpEmailItem)
                    {
                        if(hFile != INVALID_HANDLE_VALUE)
                        {
                            WriteFile(  hFile,
                                        (LPCVOID) lpEmailItem,
                                        (DWORD) lstrlen(lpEmailItem),
                                        &dw,
                                        NULL);
                        }

                        LocalFree(lpEmailItem);
                    }
                }
		    }
		    FreeProws(lpRowAB );		
        }

	}while ( SUCCEEDED(hr) && cNumRows && lpRowAB)  ;

    if(hFile != INVALID_HANDLE_VALUE)
    {
        WriteFile(  hFile,
                    (LPCVOID) szEmailPageEnd,
                    (DWORD) lstrlen(szEmailPageEnd),
                    &dw,
                    NULL);
        CloseHandle(hFile);
    }

    if ( lpContainer )
		lpContainer->Release();

	if ( lpAB )
		lpAB->Release();

    return bRet;
}

BOOL CWAB::CreateBirthdayFileFromWAB(LPTSTR szFileName)
{
    BOOL bRet = FALSE;
    ULONG ulObjType =   0;
	LPMAPITABLE lpAB =  NULL;
    LPTSTR * lppszArray=NULL;
    ULONG cRows =       0;
    LPSRowSet lpRow =   NULL;
	LPSRowSet lpRowAB = NULL;
    LPABCONT  lpContainer = NULL;
    
    HRESULT hr = E_FAIL;

    ULONG lpcbEID;
	LPENTRYID lpEID = NULL;

    TCHAR szDir[MAX_PATH];

    GetTempPath(MAX_PATH, szDir);

    lstrcpy(szFileName, szDir);
    lstrcat(szFileName, "temp.htm");

    hr = m_lpAdrBook->GetPAB( &lpcbEID, &lpEID);

	ulObjType = 0;

    hr = m_lpAdrBook->OpenEntry(lpcbEID,
					    		(LPENTRYID)lpEID,
						    	NULL,
							    0,
							    &ulObjType,
							    (LPUNKNOWN *)&lpContainer);

	m_lpWABObject->FreeBuffer(lpEID);

	lpEID = NULL;
		
    hr = lpContainer->GetContentsTable( 0,
            							&lpAB);


	if ( SUCCEEDED(hr) )
		hr =lpAB->SetColumns( (LPSPropTagArray)&ptaBday, 0 );


	int cNumRows = 0;
    int nRows=0;

    HANDLE hFile = NULL;
    DWORD dw;
    hFile = CreateFile( szFileName,
                          GENERIC_WRITE,	
                          0,    // sharing
                          NULL,
                          CREATE_ALWAYS,
                          FILE_FLAG_SEQUENTIAL_SCAN,	
                          NULL);
    if(hFile != INVALID_HANDLE_VALUE)
    {
        WriteFile(  hFile,
                    (LPCVOID) szBdayHeader,
                    (DWORD) lstrlen(szBdayHeader),
                    &dw,
                    NULL);
    }

    int nType = 0;
    int LastMonth = 0;
    BOOL bMonthSet = FALSE;

    for(LastMonth=1;LastMonth<=12;LastMonth++)
    {
        bMonthSet = FALSE;
        if ( SUCCEEDED(hr) )
	        hr = lpAB->SeekRow( BOOKMARK_BEGINNING, 0, NULL );


	do {

		if ( SUCCEEDED(hr) )
			hr = lpAB->QueryRows(1,	0, &lpRowAB);

        if(lpRowAB)
        {
            cNumRows = lpRowAB->cRows;

		    if ( SUCCEEDED(hr) && cNumRows)
		    {

                if( lpRowAB->aRow[0].lpProps[ibdayPR_BIRTHDAY].ulPropTag == PR_BIRTHDAY &&
                    lpRowAB->aRow[0].lpProps[ibdayPR_OBJECT_TYPE].Value.l == MAPI_MAILUSER)
                {
                    FILETIME ft = lpRowAB->aRow[0].lpProps[ibdayPR_BIRTHDAY].Value.ft;
                    SYSTEMTIME st;

                    FileTimeToSystemTime(&ft, &st);

                    if(st.wMonth == LastMonth)
                    {
                        if(bMonthSet == FALSE)
                        {

                            nType = 1- nType;

                            LPTSTR lpMonthItem =NULL;

                            FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                            szBdayMonthItemStart[nType],
                                            0, 0, //ignored
                                            (LPTSTR) &lpMonthItem, 0,
                                            (va_list *)&szMonth[LastMonth-1]);

                            if(lpMonthItem)
                            {
                                if(hFile != INVALID_HANDLE_VALUE)
                                {
                                    WriteFile(  hFile,
                                                (LPCVOID) lpMonthItem,
                                                (DWORD) lstrlen(lpMonthItem),
                                                &dw,
                                                NULL);
                                }
                                LocalFree(lpMonthItem);
                            }
                            bMonthSet = TRUE;
                        }

                        LPTSTR lpBdayItem = NULL;
                        LPTSTR sz[2];
                        TCHAR szDate[256];
                        wsprintf(szDate,"%d",st.wDay);
                        sz[0] = szDate;
                        sz[1] = lpRowAB->aRow[0].lpProps[ibdayPR_DISPLAY_NAME].Value.LPSZ;

                        FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        szBdaySingleItem,
                                        0, 0, //ignored
                                        (LPTSTR) &lpBdayItem, 0,
                                        (va_list *)sz);

                        if(lpBdayItem)
                        {
                            if(hFile != INVALID_HANDLE_VALUE)
                            {
                                WriteFile(  hFile,
                                            (LPCVOID) lpBdayItem,
                                            (DWORD) lstrlen(lpBdayItem),
                                            &dw,
                                            NULL);
                            }
                            LocalFree(lpBdayItem);
                        }
                    }

                }
		    }
		    FreeProws(lpRowAB );		
        }

	}while ( SUCCEEDED(hr) && cNumRows && lpRowAB)  ;

        if(bMonthSet)
        {
            if(hFile != INVALID_HANDLE_VALUE)
            {
                WriteFile(  hFile,
                            (LPCVOID) szBdayMonthItemEnd,
                            (DWORD) lstrlen(szBdayMonthItemEnd),
                            &dw,
                            NULL);
            }
        }

    }//for

    if(hFile != INVALID_HANDLE_VALUE)
    {
        if(LastMonth > 0)
        {
            WriteFile(  hFile,
                        (LPCVOID) szBdayMonthItemEnd,
                        (DWORD) lstrlen(szBdayMonthItemEnd),
                        &dw,
                        NULL);
        }
        WriteFile(  hFile,
                    (LPCVOID) szBdayEnd,
                    (DWORD) lstrlen(szBdayEnd),
                    &dw,
                    NULL);
        CloseHandle(hFile);
    }

    if ( lpContainer )
		lpContainer->Release();

	if ( lpAB )
		lpAB->Release();

    return bRet;
}

BOOL CWAB::CreateDetailsFileFromWAB(CListCtrl * pListView, LPTSTR szFileName)
{
    BOOL bRet = FALSE;
    TCHAR szDir[MAX_PATH];
    LV_ITEM lvi = {0};
    LPMAILUSER lpMailUser = NULL;
    ULONG ulcProps;
    LPSPropValue lpPropArray = NULL;

    if(!szFileName)
        goto out;

    *szFileName = '\0';

    if(!m_bDetailsOn) // This is not a details view
        goto out;
 
    // Get the Selected Item from the listview
    lvi.mask = LVIF_PARAM;
    lvi.iItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(lvi.iItem == -1)
        goto out;

    lvi.iSubItem = 0;
 

    GetTempPath(MAX_PATH, szDir);

    lstrcpy(szFileName, szDir);
    lstrcat(szFileName, "temp.htm");

    pListView->GetItem(&lvi);

    if(lvi.lParam)
    {
        LPSBinary lpSB = (LPSBinary) lvi.lParam;
        ULONG ulObjType;
        HRESULT hr = E_FAIL;

        hr = m_lpAdrBook->OpenEntry(lpSB->cb,
                                   (LPENTRYID) lpSB->lpb,
                                  NULL,         // interface
                                  0,            // flags
                                  &ulObjType,
                                  (LPUNKNOWN *)&lpMailUser);

        if(hr || !lpMailUser)
            goto out;

        lpMailUser->GetProps(NULL, 0, &ulcProps, &lpPropArray);

        if(lpPropArray)
        {
            LPTSTR lpsz[ulPropsMax];
            LPTSTR szEmpty = "";
            ULONG i,j,nEmail = -1;
            for(i=0;i<ulPropsMax;i++)
            {
                lpsz[i] = szEmpty;
                for(j=0;j<ulcProps;j++)
                {
                    if(lpPropArray[j].ulPropTag == ulProps[i])
                    {
                        lpsz[i] = lpPropArray[j].Value.LPSZ;
                        break;
                    }
                }
            }

            LPTSTR lp[pPartsMax];
            LPTSTR lpTemplate[pPartsMax];
            LPTSTR lpFile;

            lpTemplate[pMain] = (LPTSTR) szDetailsPageMain;
            lpTemplate[pPhone] = (LPTSTR) szPhoneNumbers;
            lpTemplate[pHome] = (LPTSTR) szHomeAddress;
            lpTemplate[pBusiness] = (LPTSTR) szBusinessAddress;
            lpTemplate[pURLS] = (LPTSTR) szURLS;
            lpTemplate[pNotes] = (LPTSTR) szNotes;
            lpTemplate[pEnd] = (LPTSTR) szDetailsPageEnd;
            lpTemplate[pEmail] = NULL;

            for(i=0;i<pPartsMax;i++)
                lp[i]=NULL;

            for(i=0;i<pPartsMax;i++)
            {
                if(i!=pEmail)
                {
                    // use format message to create the various message components
                    FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    lpTemplate[i],
                                    0, 0, //ignored
                                    (LPTSTR) &(lp[i]), 0,
                                    (va_list *)lpsz);
                }
            }

            for(j=0;j<ulcProps;j++)
            {
                if(lpPropArray[j].ulPropTag == PR_CONTACT_EMAIL_ADDRESSES)
                {
                    nEmail = j;
                    break;
                }
            }
            // Get the email addresses
            if(nEmail != -1)
            {
                int nCount = lpPropArray[nEmail].Value.MVSZ.cValues;
                LPTSTR lpEmail[10];
                if(nCount>10)
                    nCount = 10;

                {
                    int i, nLen = 0;
                    for(i=0;i<nCount;i++)
                    {
                        lpEmail[i] = szEmpty;
                        if(lstrlen(lpPropArray[nEmail].Value.MVSZ.LPPSZ[i]))
                        {
                            // use format message to create the various message components
                            FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                            szEmailAddressesMiddle,
                                            0, 0, //ignored
                                            (LPTSTR) &(lpEmail[i]), 0,
                                            (va_list *)&(lpPropArray[nEmail].Value.MVSZ.LPPSZ[i]));
                            nLen += lstrlen(lpEmail[i]);
                        }
                    }
                    nLen+= lstrlen(szEmailAddressesStart);
                    nLen+= lstrlen(szEmailAddressesEnd);
                    nLen++;

                    lp[pEmail] = (LPTSTR) LocalAlloc(LMEM_ZEROINIT, nLen);
                    if(lp[pEmail])
                    {
                        lstrcpy(lp[pEmail], szEmpty);
                        lstrcat(lp[pEmail], szEmailAddressesStart);
                        for(i=0;i<nCount;i++)
                            lstrcat(lp[pEmail], lpEmail[i]);
                        lstrcat(lp[pEmail], szEmailAddressesEnd);
                    }

                    for(i=0;i<nCount;i++)
                        LocalFree(lpEmail[i]);
                }
            }
            else
            {
                // Didnt find CONTACT_EMAIL_ADDRESSES .. just look for email address
                for(j=0;j<ulcProps;j++)
                {
                    if(lpPropArray[j].ulPropTag == PR_EMAIL_ADDRESS)
                    {
                        nEmail = j;
                        break;
                    }
                }
                if(nEmail!= -1)
                {
                    LPTSTR lpEmail = NULL;
                    int nLen = 0;
                    
                    FormatMessage(  FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                    szEmailAddressesMiddle,
                                    0, 0, //ignored
                                    (LPTSTR) &(lpEmail), 0,
                                    (va_list *)&(lpPropArray[nEmail].Value.LPSZ));

                    nLen += lstrlen(lpEmail);
                    nLen+= lstrlen(szEmailAddressesStart);
                    nLen+= lstrlen(szEmailAddressesEnd);
                    nLen++;

                    lp[pEmail] = (LPTSTR) LocalAlloc(LMEM_ZEROINIT, nLen);
                    if(lp[pEmail])
                    {
                        lstrcpy(lp[pEmail], szEmpty);
                        lstrcat(lp[pEmail], szEmailAddressesStart);
                        lstrcat(lp[pEmail], lpEmail);
                        lstrcat(lp[pEmail], szEmailAddressesEnd);
                    }
                    if(lpEmail)
                        LocalFree(lpEmail);
                }

            }

            int nLen = 0;
            for(i=0;i<pPartsMax;i++)
            {
                if(lp[i])
                    nLen += lstrlen(lp[i]);
            }

            nLen++;

            lpFile = (LPTSTR) LocalAlloc(LMEM_ZEROINIT, nLen);
            if(lpFile)
            {
                lstrcpy(lpFile, szEmpty);
                for(i=0;i<pPartsMax;i++)
                {
                    if(lp[i])
                        lstrcat(lpFile,lp[i]);
                }

                HANDLE hFile = NULL;
                if (INVALID_HANDLE_VALUE != (hFile = CreateFile( szFileName,
                                                      GENERIC_WRITE,	
                                                      0,    // sharing
                                                      NULL,
                                                      CREATE_ALWAYS,
                                                      FILE_FLAG_SEQUENTIAL_SCAN,	
                                                      NULL)))
                {
                    DWORD dw;
                    WriteFile(  hFile,
                                (LPCVOID) lpFile,
                                (DWORD) lstrlen(lpFile)+1,
                                &dw,
                                NULL);
                    CloseHandle(hFile);

                }

                LocalFree(lpFile);
            }

            for(i=0;i<pPartsMax;i++)
            {
                if(lp[i])
                    LocalFree(lp[i]);
            }

        }
    }

    bRet = TRUE;

out:
    if(lpPropArray)
        m_lpWABObject->FreeBuffer(lpPropArray);

    if(lpMailUser)
        lpMailUser->Release();

    return bRet;
}


void CWAB::FreeProws(LPSRowSet prows)
{
	ULONG		irow;
	if (!prows)
		return;
	for (irow = 0; irow < prows->cRows; ++irow)
		m_lpWABObject->FreeBuffer(prows->aRow[irow].lpProps);
	m_lpWABObject->FreeBuffer(prows);
}

void CWAB::SetDetailsOn(BOOL bOn)
{
    m_bDetailsOn = bOn;
}


void CWAB::ShowSelectedItemDetails(HWND hWndParent, CListCtrl * pListView)
{
    HRESULT hr = S_OK;

    LV_ITEM lvi = {0};

    // Get the Selected Item from the listview
    lvi.mask = LVIF_PARAM;
    lvi.iSubItem = 0;
    lvi.iItem = pListView->GetNextItem(-1, LVNI_SELECTED);

    if(lvi.iItem == -1)
        return;

    pListView->GetItem(&lvi);

    if(lvi.lParam)
    {
        HWND hWnd = NULL;
        LPSBinary lpSB = (LPSBinary) lvi.lParam;
        hr = m_lpAdrBook->Details(  (LPULONG) &hWnd,            // ulUIParam
					        		NULL,
							        NULL,
								    lpSB->cb,
								    (LPENTRYID) lpSB->lpb,
								    NULL,
								    NULL,
								    NULL,
								    0);

        if(hr)
        {
            TCHAR sz[MAX_PATH];
            wsprintf(sz, "Error: %x GetLastError: %d\n",hr, GetLastError());
            OutputDebugString(sz);
        }

    }

    return;

}

BOOL CWAB::GetSelectedItemBirthday(CListCtrl * pListView, SYSTEMTIME * lpst)
{
    BOOL bRet = FALSE;

    LV_ITEM lvi = {0};
    // Get the Selected Item from the listview
    lvi.mas