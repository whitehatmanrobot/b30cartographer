       pSessionEntry->Session.LanmanSessionKey,
                    MSV1_0_LANMAN_SESSION_KEY_LENGTH);
            }

            RtlCopyMemory(
                ConnectionInfo->LanmanSessionKey,
                pSessionEntry->Session.LanmanSessionKey,
                MSV1_0_LANMAN_SESSION_KEY_LENGTH);

            ConnectionInfo->Capabilities = 0;

            if (DialectFlags & DF_UNICODE) {
                ConnectionInfo->Capabilities |= CAPABILITY_UNICODE;
            }

            if (DialectFlags & DF_RPC_REMOTE) {
                ConnectionInfo->Capabilities |= CAPABILITY_RPC;
            }

            if ((DialectFlags & DF_NT_SMBS) && (DialectFlags & DF_RPC_REMOTE)) {
                ConnectionInfo->Capabilities |= CAPABILITY_SAM_PROTOCOL;
            }

            if (DialectFlags & DF_MIXEDCASE) {
                ConnectionInfo->Capabilities |= CAPABILITY_CASE_SENSITIVE_PASSWDS;
            }

            if (DialectFlags & DF_LANMAN10) {
                ConnectionInfo->Capabilities |= CAPABILITY_REMOTE_ADMIN_PROTOCOL;
            }

            ASSERT (!RxContext->PostRequest);
            RxDbgTrace(0, Dbg, ("PackC data---> capabilities  %08lx \n",  ConnectionInfo->Capabilities));
        }

        if (!MRxSmbPackStringIntoConnectInfoThunked(
                &ConnectionInfo->UNCName,
                &ConnectName,
                BufferStart,
                BufferEnd,
                BufferDisplacement,
                NULL)) {
            if (Level > 1) {
                ConnectionInfo->UserName.Length = 0;
                ConnectionInfo->UserName.Buffer = NULL;
            }

            try_return( ReturnValue = FALSE);
        }

        if (Level > 1) {
            WCHAR UserNameBuffer[UNLEN + 1];
            WCHAR UserDomainNameBuffer[UNLEN + 1];

            UNICODE_STRING UserName,UserDomainName;

            UserName.Length = UserName.MaximumLength = UNLEN * sizeof(WCHAR);
            UserName.Buffer = UserNameBuffer;
            UserDomainName.Length = UserDomainName.MaximumLength = UNLEN * sizeof(WCHAR);
            UserDomainName.Buffer = UserDomainNameBuffer;

            Status = SmbCeGetUserNameAndDomainName(
                         pSessionEntry,
                         &UserName,
                         &UserDomainName);

            if (NT_SUCCESS(Status)) {
               if (!MRxSmbPackStringIntoConnectInfoThunked(
                       &ConnectionInfo->UserName,
                       &UserName,
                       BufferStart,
                       BufferEnd,
                       BufferDisplacement,
                       TotalBytesNeeded)) {
                   try_return( ReturnValue = FALSE);
               }

               if (!MRxSmbPackStringIntoConnectInfoThunked(
                        &ConnectionInfo->DomainName,
                        &UserDomainName,
                        BufferStart,
                        BufferEnd,
                        BufferDisplacement,
                        TotalBytesNeeded)) {
                   try_return( ReturnValue = FALSE);
               }
            } else {
               try_return( ReturnValue = FALSE);
            }
        }

        if (Level > 2) {
            MRxSmbGetConnectInfoLevel3FieldsThunked(ConnectionInfo,pServerEntry, FALSE);

            if ((pServerEntry->pTransport != NULL) &&
                !SmbCeIsServerInDisconnectedMode(pServerEntry)) {
                NTSTATUS RefTransportStatus;

                RefTransportStatus = SmbCeReferenceServerTransport(&pServerEntry->pTransport);

                if (RefTransportStatus == STATUS_SUCCESS) {
                    PUNICODE_STRING RxCeTransportName = &pServerEntry->pTransport->pTransport->RxCeTransport.Name;

                    if (!MRxSmbPackStringIntoConnectInfoThunked(
                            &ConnectionInfo->TransportName,
                            RxCeTransportName,
                            BufferStart,
                            BufferEnd,
                            BufferDisplacement,
                            TotalBytesNeeded)) {
                        ReturnValue = FALSE;
                    }

                    SmbCeDereferenceServerTransport(&pServerEntry->pTransport);
                }
            }
        }

    try_exit:
        NOTHING;

    } finally {
        RxFreePool(ConnectName.Buffer);
    }
    RxDbgTrace(-1, Dbg, ("PackC...%08lx\n",ReturnValue));

    return ReturnValue;
}
#endif

VOID
MRxSmbGetConnectInfoLevel3Fields(
    IN OUT PLMR_CONNECTION_INFO_3 ConnectionInfo,
    IN     PSMBCEDB_SERVER_ENTRY  pServerEntry,
    BOOL   fAgentCall
    )
{
    ULONG DialectFlags = pServerEntry->Server.DialectFlags;

    NTSTATUS Status;
    RXCE_CONNECTION_INFO        QueryConnectionInfo;
    PSMBCE_SERVER_VC_TRANSPORT  pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;
    PSMBCE_VC                   pVc;

    PAGED_CODE();

    ConnectionInfo->Throughput = 0;
    ConnectionInfo->Delay = 0;
    ConnectionInfo->Reliable = FALSE;
    ConnectionInfo->ReadAhead = TRUE;
    ConnectionInfo->IsSpecialIpcConnection = FALSE;

    if ((pServerEntry->Header.State == SMBCEDB_ACTIVE) &&
        (pVcTransport != NULL) &&
        (!SmbCeIsServerInDisconnectedMode(pServerEntry)||fAgentCall)) {
        pVc = &pVcTransport->Vcs[0];

        Status = RxCeQueryInformation(
                 &pVc->RxCeVc,
                 RxCeConnectionEndpointInformation,
                 &QueryConnectionInfo,
                 sizeof(QueryConnectionInfo));

        if (NT_SUCCESS(Status)) {
            ConnectionInfo->Reliable = !QueryConnectionInfo.Unreliable;

            if (QueryConnectionInfo.Delay.QuadPart != 0) {
                if (QueryConnectionInfo.Delay.QuadPart == -1) {
                    ConnectionInfo->Delay = 0;
                } else if (QueryConnectionInfo.Delay.HighPart != 0xffffffff) {
                    ConnectionInfo->Delay = 0xffffffff;
                } else {
                    ConnectionInfo->Delay = -1 * QueryConnectionInfo.Delay.LowPart;
                }
            } else {
                ConnectionInfo->Delay = 0;
            }

            if (QueryConnectionInfo.Throughput.QuadPart == -1) {
                ConnectionInfo->Throughput = 0;
            } else if (QueryConnectionInfo.Throughput.HighPart != 0) {
                ConnectionInfo->Throughput = 0xffffffff;
            } else {
                ConnectionInfo->Throughput = QueryConnectionInfo.Throughput.LowPart;
            }
        }
    }

    ConnectionInfo->TimeZoneBias = pServerEntry->Server.TimeZoneBias;
    ConnectionInfo->Core = (DialectFlags & DF_CORE) != 0;
    ConnectionInfo->MsNet103 = (DialectFlags & DF_OLDRAWIO) != 0;
    ConnectionInfo->Lanman10 = (DialectFlags & DF_LANMAN10) != 0;
    ConnectionInfo->WindowsForWorkgroups = (DialectFlags & DF_WFW) != 0;
    ConnectionInfo->Lanman20 = (DialectFlags & DF_LANMAN20) != 0;
    ConnectionInfo->Lanman21 = (DialectFlags & DF_LANMAN21) != 0;
    ConnectionInfo->WindowsNt = (DialectFlags & DF_NTPROTOCOL) != 0;
    ConnectionInfo->MixedCasePasswords = (DialectFlags & DF_MIXEDCASEPW) != 0;
    ConnectionInfo->MixedCaseFiles = (DialectFlags & DF_MIXEDCASE) != 0;
    ConnectionInfo->LongNames = (DialectFlags & DF_LONGNAME) != 0;
    ConnectionInfo->ExtendedNegotiateResponse = (DialectFlags & DF_EXTENDNEGOT) != 0;
    ConnectionInfo->LockAndRead = (DialectFlags & DF_LOCKREAD) != 0;
    ConnectionInfo->NtSecurity = (DialectFlags & DF_SECURITY) != 0;
    ConnectionInfo->SupportsEa = (DialectFlags & DF_SUPPORTEA) != 0;
    ConnectionInfo->NtNegotiateResponse = (DialectFlags & DF_NTNEGOTIATE) != 0;
    ConnectionInfo->CancelSupport = (DialectFlags & DF_CANCEL) != 0;
    ConnectionInfo->UnicodeStrings = (DialectFlags & DF_UNICODE) != 0;
    ConnectionInfo->LargeFiles = (DialectFlags & DF_LARGE_FILES) != 0;
    ConnectionInfo->NtSmbs = (DialectFlags & DF_NT_SMBS) != 0;
    ConnectionInfo->RpcRemoteAdmin = (DialectFlags & DF_RPC_REMOTE) != 0;
    ConnectionInfo->NtStatusCodes = (DialectFlags & DF_NT_STATUS) != 0;
    ConnectionInfo->LevelIIOplock = (DialectFlags & DF_OPLOCK_LVL2) != 0;
    ConnectionInfo->UtcTime = (DialectFlags & DF_TIME_IS_UTC) != 0;
    ConnectionInfo->UserSecurity = (pServerEntry->Server.SecurityMode==SECURITY_MODE_USER_LEVEL);
    ConnectionInfo->EncryptsPasswords = pServerEntry->Server.EncryptPasswords;

    return;
}

#ifdef _WIN64
VOID
MRxSmbGetConnectInfoLevel3FieldsThunked(
    IN OUT PLMR_CONNECTION_INFO_3_32 ConnectionInfo,
    IN     PSMBCEDB_SERVER_ENTRY     pServerEntry,
    BOOL   fAgentCall
    )
{
    ULONG DialectFlags = pServerEntry->Server.DialectFlags;

    NTSTATUS Status;
    RXCE_CONNECTION_INFO        QueryConnectionInfo;
    PSMBCE_SERVER_VC_TRANSPORT  pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;
    PSMBCE_VC                   pVc;

    PAGED_CODE();

    ConnectionInfo->Throughput = 0;
    ConnectionInfo->Delay = 0;
    ConnectionInfo->Reliable = FALSE;
    ConnectionInfo->ReadAhead = TRUE;
    ConnectionInfo->IsSpecialIpcConnection = FALSE;

    if ((pServerEntry->Header.State == SMBCEDB_ACTIVE) &&
        (pVcTransport != NULL) &&
        (!SmbCeIsServerInDisconnectedMode(pServerEntry)||fAgentCall)) {
        pVc = &pVcTransport->Vcs[0];

        Status = RxCeQueryInformation(
                 &pVc->RxCeVc,
                 RxCeConnectionEndpointInformation,
                 &QueryConnectionInfo,
                 sizeof(QueryConnectionInfo));

        if (NT_SUCCESS(Status)) {
            ConnectionInfo->Reliable = !QueryConnectionInfo.Unreliable;

            if (QueryConnectionInfo.Delay.QuadPart != 0) {
                if (QueryConnectionInfo.Delay.QuadPart == -1) {
                    ConnectionInfo->Delay = 0;
                } else if (QueryConnectionInfo.Delay.HighPart != 0xffffffff) {
                    ConnectionInfo->Delay = 0xffffffff;
                } else {
                    ConnectionInfo->Delay = -1 * QueryConnectionInfo.Delay.LowPart;
                }
            } else {
                ConnectionInfo->Delay = 0;
            }

            if (QueryConnectionInfo.Throughput.QuadPart == -1) {
                ConnectionInfo->Throughput = 0;
            } else if (QueryConnectionInfo.Throughput.HighPart != 0) {
                ConnectionInfo->Throughput = 0xffffffff;
            } else {
                ConnectionInfo->Throughput = QueryConnectionInfo.Throughput.LowPart;
            }
        }
    }

    ConnectionInfo->TimeZoneBias = pServerEntry->Server.TimeZoneBias;
    ConnectionInfo->Core = (DialectFlags & DF_CORE) != 0;
    ConnectionInfo->MsNet103 = (DialectFlags & DF_OLDRAWIO) != 0;
    ConnectionInfo->Lanman10 = (DialectFlags & DF_LANMAN10) != 0;
    ConnectionInfo->WindowsForWorkgroups = (DialectFlags & DF_WFW) != 0;
    ConnectionInfo->Lanman20 = (DialectFlags & DF_LANMAN20) != 0;
    ConnectionInfo->Lanman21 = (DialectFlags & DF_LANMAN21) != 0;
    ConnectionInfo->WindowsNt = (DialectFlags & DF_NTPROTOCOL) != 0;
    ConnectionInfo->MixedCasePasswords = (DialectFlags & DF_MIXEDCASEPW) != 0;
    ConnectionInfo->MixedCaseFiles = (DialectFlags & DF_MIXEDCASE) != 0;
    ConnectionInfo->LongNames = (DialectFlags & DF_LONGNAME) != 0;
    ConnectionInfo->ExtendedNegotiateResponse = (DialectFlags & DF_EXTENDNEGOT) != 0;
    ConnectionInfo->LockAndRead = (DialectFlags & DF_LOCKREAD) != 0;
    ConnectionInfo->NtSecurity = (DialectFlags & DF_SECURITY) != 0;
    ConnectionInfo->SupportsEa = (DialectFlags & DF_SUPPORTEA) != 0;
    ConnectionInfo->NtNegotiateResponse = (DialectFlags & DF_NTNEGOTIATE) != 0;
    ConnectionInfo->CancelSupport = (DialectFlags & DF_CANCEL) != 0;
    ConnectionInfo->UnicodeStrings = (DialectFlags & DF_UNICODE) != 0;
    ConnectionInfo->LargeFiles = (DialectFlags & DF_LARGE_FILES) != 0;
    ConnectionInfo->NtSmbs = (DialectFlags & DF_NT_SMBS) != 0;
    ConnectionInfo->RpcRemoteAdmin = (DialectFlags & DF_RPC_REMOTE) != 0;
    ConnectionInfo->NtStatusCodes = (DialectFlags & DF_NT_STATUS) != 0;
    ConnectionInfo->LevelIIOplock = (DialectFlags & DF_OPLOCK_LVL2) != 0;
    ConnectionInfo->UtcTime = (DialectFlags & DF_TIME_IS_UTC) != 0;
    ConnectionInfo->UserSecurity = (pServerEntry->Server.SecurityMode==SECURITY_MODE_USER_LEVEL);
    ConnectionInfo->EncryptsPasswords = pServerEntry->Server.EncryptPasswords;

    return;
}
#endif

NTSTATUS
MRxSmbEnumerateConnections (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine enumerates the connections on all minirdrs. we may have to do
    it by minirdr.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context

Return Value:

NTSTATUS

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PLMR_REQUEST_PACKET InputBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    PUCHAR OriginalOutputBuffer = LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
    ULONG OutputBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    PUCHAR OutputBuffer;
    ULONG  BufferDisplacement;

    ULONG  Level, ResumeHandle;

    PCHAR BufferStart;
    PCHAR BufferEnd;
    PCHAR PreviousBufferStart;

    PLIST_ENTRY ListEntry;
    LUID LogonId;
    BOOLEAN TableLockHeld = FALSE;
    ULONG TotalBytesNeeded = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbEnumerateConnections [Start] -> %08lx\n", 0));

    OutputBuffer = RxMapUserBuffer( RxContext, RxContext->CurrentIrp );
    BufferDisplacement = (ULONG)(OutputBuffer - OriginalOutputBuffer);
    BufferStart = OutputBuffer;
    BufferEnd = OutputBuffer+OutputBufferLength;

    if (InFSD && RxContext->CurrentIrp->RequestorMode != KernelMode) {
        ASSERT(BufferDisplacement==0);

        try {
            ProbeForWrite(InputBuffer,InputBufferLength,sizeof(UCHAR));
            ProbeForWrite(OutputBuffer,OutputBufferLength,sizeof(UCHAR));
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    try {
        try {
            if (InputBufferLength < sizeof(LMR_REQUEST_PACKET)) {
                try_return(Status = STATUS_BUFFER_TOO_SMALL);
            }

            if (InputBuffer->Version != REQUEST_PACKET_VERSION) {
                try_return(Status = STATUS_INVALID_PARAMETER);
            }

            Level = InputBuffer->Level;
            ResumeHandle = InputBuffer->Parameters.Get.ResumeHandle;
            LogonId = InputBuffer->LogonId;
            RxDbgTrace(0, Dbg, ("MRxSmbEnumerateConnections Level -> %08lx\n", Level));

#ifdef _WIN64
            if (IoIs32bitProcess(RxContext->CurrentIrp)) {
                switch (Level) {
                case 0:
                    if ( OutputBufferLength < sizeof(LMR_CONNECTION_INFO_0_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 1:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_1_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 2:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_2_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 3:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_3_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                default:
                    try_return(Status = STATUS_INVALID_INFO_CLASS);
                }
            } else {
                switch (Level) {
                case 0:
                    if ( OutputBufferLength < sizeof(LMR_CONNECTION_INFO_0)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 1:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_1)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 2:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_2)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 3:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_3)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                default:
                    try_return(Status = STATUS_INVALID_INFO_CLASS);
                }
            }
#else
            switch (Level) {
            case 0:
                if ( OutputBufferLength < sizeof(LMR_CONNECTION_INFO_0)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            case 1:
                if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_1)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            case 2:
                if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_2)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            case 3:
                if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_3)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            default:
                try_return(Status = STATUS_INVALID_INFO_CLASS);
            }
#endif
            InputBuffer->Parameters.Get.EntriesRead = 0;
            InputBuffer->Parameters.Get.TotalEntries = 0;

            RxAcquirePrefixTableLockExclusive( &RxNetNameTable, TRUE);
            TableLockHeld = TRUE;

            if (IsListEmpty( &RxNetNameTable.MemberQueue )) {
                try_return(Status = RX_MAP_STATUS(SUCCESS));
            }

            //must do the list forwards!!!!!
            ListEntry = RxNetNameTable.MemberQueue.Flink;
            for (;ListEntry != &RxNetNameTable.MemberQueue;) {
                PVOID Container;
                PRX_PREFIX_ENTRY PrefixEntry;
                PNET_ROOT NetRoot;
                PV_NET_ROOT VNetRoot;
                PUNICODE_STRING VNetRootName;

                PrefixEntry = CONTAINING_RECORD( ListEntry, RX_PREFIX_ENTRY, MemberQLinks );
                ListEntry = ListEntry->Flink;
                ASSERT (NodeType(PrefixEntry) == RDBSS_NTC_PREFIX_ENTRY);
                Container = PrefixEntry->ContainingRecord;
                RxDbgTrace(0, Dbg, ("---> ListE PfxE Container Name  %08lx %08lx %08lx %wZ\n",
                                ListEntry, PrefixEntry, Container, &PrefixEntry->Prefix));

                switch (NodeType(Container)) {
                case RDBSS_NTC_NETROOT :
                    continue;

                case RDBSS_NTC_SRVCALL :
                    continue;

                case RDBSS_NTC_V_NETROOT :
                    VNetRoot = (PV_NET_ROOT)Container;
                    NetRoot = (PNET_ROOT)VNetRoot->NetRoot;
                    VNetRootName = &VNetRoot->PrefixEntry.Prefix;

                    if ((VNetRoot->SerialNumberForEnum >= ResumeHandle) &&
                        (VNetRootName->Buffer[1] != L';') &&
                        (VNetRoot->Condition == Condition_Good) &&
                        MRxSmbShowConnection(LogonId,VNetRoot) &&
                        VNetRoot->IsExplicitConnection) {
                        break;
                    } else {
                        continue;
                    }

                default:
                    continue;
                }

                RxDbgTrace(0, Dbg, ("      ImplicitConnectionFound!!!\n"));

                InputBuffer->Parameters.Get.TotalEntries ++ ;

                PreviousBufferStart = BufferStart;
#ifdef _WIN64
                if (IoIs32bitProcess(RxContext->CurrentIrp)) {
                    if (MRxSmbPackConnectEntryThunked(RxContext,Level,
                                  &BufferStart,
                                  &BufferEnd,
                                  VNetRoot,
                                  BufferDisplacement,
                                  &TotalBytesNeeded)) {
                        InputBuffer->Parameters.Get.EntriesRead ++ ;
                        RxDbgTrace(0, Dbg, ("       Processed %wZ\n",
                                       &((PLMR_CONNECTION_INFO_0)PreviousBufferStart)->UNCName
                                            ));
                    } else {
                        break;
                    }
                } else {
                    if (MRxSmbPackConnectEntry(RxContext,Level,
                                  &BufferStart,
                                  &BufferEnd,
                                  VNetRoot,
                                  BufferDisplacement,
                                  &TotalBytesNeeded)) {
                        InputBuffer->Parameters.Get.EntriesRead ++ ;
                        RxDbgTrace(0, Dbg, ("       Processed %wZ\n",
                                       &((PLMR_CONNECTION_INFO_0)PreviousBufferStart)->UNCName
                                            ));
                    } else {
                        break;
                    }
                }
#else
                if (MRxSmbPackConnectEntry(RxContext,Level,
                              &BufferStart,
                              &BufferEnd,
                              VNetRoot,
                              BufferDisplacement,
                              &TotalBytesNeeded)) {
                    InputBuffer->Parameters.Get.EntriesRead ++ ;
                    RxDbgTrace(0, Dbg, ("       Processed %wZ\n",
                                   &((PLMR_CONNECTION_INFO_0)PreviousBufferStart)->UNCName
                                        ));
                } else {
                    break;
                }
#endif
            }

            InputBuffer->Parameters.Get.TotalBytesNeeded = TotalBytesNeeded;
            RxContext->InformationToReturn = sizeof(LMR_REQUEST_PACKET);

            try_return(Status = RX_MAP_STATUS(SUCCESS));

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }

try_exit:NOTHING;

    } finally {

        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
        }

        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}

NTSTATUS
MRxSmbGetConnectionInfo (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine gets the connection info for a single vnetroot.

    There is some happiness here about the output buffer. What happens is that we
    pick up the output buffer in the usual way. However, there are all sorts of
    pointers in the return structure and these pointers must obviously be in terms
    of the original process. so, if we post then we have to apply a fixup!

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context

Return Value:

   STATUS_SUCCESS if successful

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    RxCaptureFobx;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PLMR_REQUEST_PACKET InputBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    PUCHAR OriginalOutputBuffer = LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
    ULONG OutputBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    PUCHAR OutputBuffer;
    ULONG  BufferDisplacement;

    ULONG Level;

    PCHAR BufferStart;
    PCHAR OriginalBufferStart;
    PCHAR BufferEnd;

    BOOLEAN TableLockHeld = FALSE;

    PNET_ROOT   NetRoot;
    PV_NET_ROOT VNetRoot;

    ULONG TotalBytesNeeded = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbGetConnectionInfo [Start] -> %08lx\n", 0));

    OutputBuffer = RxMapUserBuffer( RxContext, RxContext->CurrentIrp );
    BufferDisplacement = (ULONG)(OutputBuffer - OriginalOutputBuffer);
    BufferStart = OutputBuffer;
    OriginalBufferStart = BufferStart;
    BufferEnd = OutputBuffer+OutputBufferLength;

    if (InFSD && RxContext->CurrentIrp->RequestorMode != KernelMode) {
        ASSERT(BufferDisplacement==0);

        try {
            ProbeForWrite(InputBuffer,InputBufferLength,sizeof(UCHAR));
            ProbeForWrite(OutputBuffer,OutputBufferLength,sizeof(UCHAR));
        } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    try {
        try {
            PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

            ASSERT (NodeType(capFobx)==RDBSS_NTC_V_NETROOT);
            VNetRoot = (PV_NET_ROOT)capFobx;
            NetRoot = (PNET_ROOT)(VNetRoot->NetRoot);

            if (NetRoot == NULL) {
                try_return(Status = STATUS_ALREADY_DISCONNECTED);
            }

            if (InputBufferLength < sizeof(LMR_REQUEST_PACKET)) {
                try_return(Status = STATUS_BUFFER_TOO_SMALL);
            }

            if (InputBuffer->Version != REQUEST_PACKET_VERSION) {
                try_return(Status = STATUS_INVALID_PARAMETER);
            }

            // if the level is asking for the session key, determine whether we are able
            // to give it out yet.
            pVNetRootContext = SmbCeGetAssociatedVNetRootContext((PMRX_V_NET_ROOT)VNetRoot);
            if( InputBuffer->Level > 2 &&
                pVNetRootContext->pSessionEntry->Session.SessionKeyState != SmbSessionKeyAvailible )
            {
                try_return(Status = STATUS_ACCESS_DENIED);
            }

            Level = InputBuffer->Level;
            RxDbgTrace(0, Dbg, ("MRxSmbGetConnectionInfo Level -> %08lx\n", Level));

#ifdef _WIN64
            if (IoIs32bitProcess(RxContext->CurrentIrp)) {
                switch (Level) {
                case 0:
                    if ( OutputBufferLength < sizeof(LMR_CONNECTION_INFO_0_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 1:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_1_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 2:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_2_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 3:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_3_32)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                default:
                    try_return(Status = STATUS_INVALID_INFO_CLASS);
                }
            } else {
                switch (Level) {
                case 0:
                    if ( OutputBufferLength < sizeof(LMR_CONNECTION_INFO_0)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 1:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_1)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 2:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_2)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                case 3:
                    if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_3)) {
                        try_return(Status = STATUS_BUFFER_TOO_SMALL);
                    }
                    break;
                default:
                    try_return(Status = STATUS_INVALID_INFO_CLASS);
                }
            }
#else
            switch (Level) {
            case 0:
                if ( OutputBufferLength < sizeof(LMR_CONNECTION_INFO_0)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            case 1:
                if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_1)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            case 2:
                if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_2)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            case 3:
                if (OutputBufferLength < sizeof(LMR_CONNECTION_INFO_3)) {
                    try_return(Status = STATUS_BUFFER_TOO_SMALL);
                }
                break;
            default:
                try_return(Status = STATUS_INVALID_INFO_CLASS);
            }
#endif

            InputBuffer->Parameters.Get.TotalEntries = 1;

            RxAcquirePrefixTableLockExclusive( &RxNetNameTable, TRUE);
            TableLockHeld = TRUE;

#ifdef _WIN64
            if (IoIs32bitProcess(RxContext->CurrentIrp)) {
                if (MRxSmbPackConnectEntryThunked(RxContext,Level,
                                  &BufferStart,
                                  &BufferEnd,
                                  VNetRoot,
                                  BufferDisplacement,
                                  &TotalBytesNeeded)) {

                    InputBuffer->Parameters.Get.EntriesRead = 1;
                    RxDbgTrace(0, Dbg, ("       Processed %wZ\n",
                                   &((PLMR_CONNECTION_INFO_0)OriginalBufferStart)->UNCName
                                        ));
                }
            } else {
                if (MRxSmbPackConnectEntry(RxContext,Level,
                                  &BufferStart,
                                  &BufferEnd,
                                  VNetRoot,
                                  BufferDisplacement,
                                  &TotalBytesNeeded)) {

                    InputBuffer->Parameters.Get.EntriesRead = 1;
                    RxDbgTrace(0, Dbg, ("       Processed %wZ\n",
                                   &((PLMR_CONNECTION_INFO_0)OriginalBufferStart)->UNCName
                                        ));
                }
            }
#else
            if (MRxSmbPackConnectEntry(RxContext,Level,
                              &BufferStart,
                              &BufferEnd,
                              VNetRoot,
                              BufferDisplacement,
                              &TotalBytesNeeded)) {

                InputBuffer->Parameters.Get.EntriesRead = 1;
                RxDbgTrace(0, Dbg, ("       Processed %wZ\n",
                               &((PLMR_CONNECTION_INFO_0)OriginalBufferStart)->UNCName
                                    ));
            }
#endif

            InputBuffer->Parameters.Get.TotalBytesNeeded = TotalBytesNeeded;
            RxContext->InformationToReturn = InputBuffer->Parameters.Get.TotalBytesNeeded;
            try_return(Status = RX_MAP_STATUS(SUCCESS));

        } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }

try_exit:NOTHING;

    } finally {
        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
        }
        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}

NTSTATUS
MRxSmbDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine deletes a single vnetroot. joejoe

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context....for later when i need the buffers

Return Value:

RXSTATUS

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    RxCaptureFobx;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PLMR_REQUEST_PACKET InputBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    ULONG Level;

    //PLIST_ENTRY ListEntry;
    BOOLEAN TableLockHeld = FALSE;

    PMRX_NET_ROOT NetRoot = NULL;
    PMRX_V_NET_ROOT VNetRoot = NULL;
    PSMBCE_V_NET_ROOT_CONTEXT VNetRootContext = NULL;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbDeleteConnection Fobx %08lx\n", capFobx));
    ASSERT( (FSCTL_LMR_DELETE_CONNECTION&3)==METHOD_BUFFERED );
    //no probing for buffered!

    if (!Wait) {
        //just post right now!
        *PostToFsp = TRUE;
        return(RX_MAP_STATUS(PENDING));
    }

    try {

        if (NodeType(capFobx)==RDBSS_NTC_V_NETROOT) {
            VNetRoot = (PMRX_V_NET_ROOT)capFobx;
            VNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)VNetRoot->Context;
            NetRoot = (PMRX_NET_ROOT)VNetRoot->pNetRoot;
        } else {
            ASSERT(FALSE);
            try_return(Status = STATUS_INVALID_DEVICE_REQUEST);
            NetRoot = (PMRX_NET_ROOT)capFobx;
            VNetRoot = NULL;
        }

        if (InputBufferLength < sizeof(LMR_REQUEST_PACKET)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        if (InputBuffer->Version != REQUEST_PACKET_VERSION) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        Level = InputBuffer->Level;
        RxDbgTrace(0, Dbg, ("MRxSmbDeleteConnection Level(ofForce) -> %08lx\n", Level));

        if (Level <= USE_LOTS_OF_FORCE) {
            if (Level == USE_LOTS_OF_FORCE) {
                //SmbCeFinalizeAllExchangesForNetRoot(VNetRoot->pNetRoot);
            }

            if (VNetRootContext != NULL && Level == USE_LOTS_OF_FORCE) {
                // Prevent any new connection from reusing the session if this is the last connection on
                // this session right now
                SmbCeDecrementNumberOfActiveVNetRootOnSession(VNetRootContext);

                // Recover the count which will be taken away when VNetRoot is finalized
                InterlockedIncrement(&VNetRootContext->pSessionEntry->Session.NumberOfActiveVNetRoot);
            }

            // The boolean ForceFilesClosed is now a tristate. If the state is 0xff then
            // we take off the extra reference on vnetroot made during xxx_CONNECT
            Status = RxFinalizeConnection(
                         (PNET_ROOT)NetRoot,
                         (PV_NET_ROOT)VNetRoot,
                         (Level==USE_LOTS_OF_FORCE)?TRUE:
                            ((Level==USE_NOFORCE)?FALSE:0xff));
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }

        try_return(Status);

try_exit:NOTHING;

    } finally {

        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
        }

        RxDbgTraceUnIndent(-1,Dbg);
    }

    return Status;
}


NTSTATUS
MRxEnumerateTransports(
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN   pPostToFsp)
/*++

Routine Description:

    This routine invokes the underlying connection engine method to bind to a transport
    or unbind from it in the context of FSP.

Arguments:

    RxContext - the  context

    pPostToFsp - set to TRUE if the routine cannot be completed in the context of the FSD.

Return Value:

     returns RxStatus(PENDING) if invoked in FSD.
     returns the status value from the connection engine if invoked in FSP.

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    RxCaptureFobx;

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    BOOLEAN InFSD  = !BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_IN_FSP);

    PLMR_REQUEST_PACKET pLmrRequestBuffer = LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    PUCHAR pTransportEnumerationBuffer = LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
    ULONG  EnumerationBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG  LmrRequestBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

   PAGED_CODE();

   RxDbgTrace(+1, Dbg, ("RxEnumerateTransports [Start] ->\n"));

   //
   // This routine is invoked as part of ioinit on a remote boot client.
   // In that case, previous mode is kernel and the buffers are in kernel
   // space, so we can't probe the buffers.
   //

   if (RxContext->CurrentIrp->RequestorMode != KernelMode) {
       try {
           ProbeForWrite(pLmrRequestBuffer,LmrRequestBufferLength,sizeof(UCHAR));
           ProbeForWrite(pTransportEnumerationBuffer,EnumerationBufferLength,sizeof(UCHAR));
       } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_ACCESS_VIOLATION;
       }
   }

   try {
       try {
           if (LmrRequestBufferLength < sizeof(LMR_REQUEST_PACKET)) {
               try_return(Status = STATUS_BUFFER_TOO_SMALL);
           }

           if (pLmrRequestBuffer->Version != REQUEST_PACKET_VERSION) {
               try_return(Status = STATUS_INVALID_PARAMETER);
           }

           Status = MRxEnumerateTransportBindings(
                        pLmrRequestBuffer,
                        LmrRequestBufferLength,
                        pTransportEnumerationBuffer,
                        EnumerationBufferLength);

           RxContext->InformationToReturn = sizeof(LMR_REQUEST_PACKET);
       } except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_ACCESS_VIOLATION;
       }

try_exit:NOTHING;

   } finally {
       RxDbgTraceUnIndent(-1,Dbg);
   }

   return Status;
}

#define ADAPTER_STATUS_LENGTH_IN_BYTES (26)
UNICODE_STRING NullAdapterStatus = {
        ADAPTER_STATUS_LENGTH_IN_BYTES,
        ADAPTER_STATUS_LENGTH_IN_BYTES,
        L"000000000000\0"};

#define HexDigit(a) ((CHAR)( (a) > 9 ? ((a) + 'A' - 0xA) : ((a) + '0') ))

NTSTATUS
MRxEnumerateTransportBindings(
    IN PLMR_REQUEST_PACKET pLmrRequestPacket,
    IN ULONG               LmrRequestPacketLength,
    OUT PVOID              pBindingBuffer,
    IN OUT ULONG           BindingBufferLength)
/*++

Routine Description:

    This routine enables the specified transport.

Arguments:

    pLmrRequestPacket - the LM Request Packet for enumerating bindings to transports.

    LmrRequestPacketLength - length of the LM request.

    pBindingBuffer - the buffer for returning transport bindings

    BindingBufferLength -- length of the buffer in which bindings are returned.

Return Value:

    STATUS_SUCCESS - if the call was successfull.

Notes:

    The workstation service and other clients of LMR_FSCTL's expect the variable length
    data to be packed in a specific way, i.e., the variable length data is copied from
    the end while the fixed length data is copied from the left. Any changes to the format
    in which the data is packed should be accompanied by the corresponding changes for
    unpacking in these services.

--*/
{
    NTSTATUS         ReturnStatus = STATUS_SUCCESS;
    NTSTATUS         Status;
    PSMBCE_TRANSPORT pTransport;
    ULONG            TransportsPreviouslyReturned;
    PVOID            pVariableLengthInfo;
    ULONG            VariableLengthInfoOffset;
    PSMBCE_TRANSPORT_ARRAY pTransportArray;

    PAGED_CODE();

    try {
        // Ensure that the buffer can hold atleast one entry
        if (BindingBufferLength < sizeof(WKSTA_TRANSPORT_INFO_0)) {
            try_return(ReturnStatus = STATUS_BUFFER_TOO_SMALL);
        }

        VariableLengthInfoOffset = BindingBufferLength;
        TransportsPreviouslyReturned = pLmrRequestPacket->Parameters.Get.ResumeHandle;
        pLmrRequestPacket->Parameters.Get.EntriesRead = 0;

        // Skip the transports that were previously returned
        pTransportArray = SmbCeReferenceTransportArray();

        if (pTransportArray == NULL || pTransportArray->Count == 0) {
            if (pTransportArray != NULL) {
                SmbCeDereferenceTransportArray(pTransportArray);
            }

            RxDbgTrace(0, Dbg, ("MRxEnumerateTransportBindings : Transport not available.\n"));
            try_return(ReturnStatus = STATUS_NETWORK_UNREACHABLE);
        }

        if (TransportsPreviouslyReturned < pTransportArray->Count) {
            // The subsequent entries have not been returned. Obtain the information
            // for them.
            WKSTA_TRANSPORT_INFO_0 UNALIGNED *pTransportInfo = (WKSTA_TRANSPORT_INFO_0 UNALIGNED *)pBindingBuffer;

            LONG   RemainingLength = (LONG)BindingBufferLength;
            PCHAR  pBufferEnd      = (PCHAR)pBindingBuffer + BindingBufferLength;
            PCHAR  pBufferStart    = (PCHAR)pBindingBuffer;
            ULONG  Length;
            ULONG  TransportsPacked = 0;
            ULONG  CurrentTransport;
            ULONG  LengthRequired  = 0;

            CurrentTransport = TransportsPreviouslyReturned;

            while(CurrentTransport < pTransportArray->Count) {
                RXCE_TRANSPORT_INFORMATION TransportInformation;

                pTransport = pTransportArray->SmbCeTransports[CurrentTransport++];

                Status = RxCeQueryTransportInformation(
                             &pTransport->RxCeTransport,
                             &TransportInformation);

                if (Status == STATUS_SUCCESS) {
                    ULONG BufferSize;

                    if (pTransport->RxCeTransport.Name.Length > UNLEN * sizeof(WCHAR)) {
                        Status = STATUS_BUFFER_OVERFLOW;
                    }

                    BufferSize = sizeof(WKSTA_TRANSPORT_INFO_0) +
                                 ADAPTER_STATUS_LENGTH_IN_BYTES +
                                 (pTransport->RxCeTransport.Name.Length + sizeof(WCHAR));

                    RemainingLength -= BufferSize;
                    LengthRequired  += BufferSize;

                    if (Status == STATUS_SUCCESS && RemainingLength >= 0) {
                        PCHAR           pName;
                        PWCHAR          pAdapter;
                        ADAPTER_STATUS  AdapterStatus;

                        // Copy the values for the current binding into the output buffer.
                        pTransportInfo->wkti0_quality_of_service =
                            TransportInformation.QualityOfService;

                        pTransportInfo->wkti0_wan_ish =
                            TransportInformation.ServiceFlags & TDI_SERVICE_ROUTE_DIRECTED;

                        pTransportInfo->wkti0_number_of_vcs = TransportInformation.ConnectionCount;

                        VariableLengthInfoOffset -= (pTransport->RxCeTransport.Name.Length + sizeof(WCHAR));

                        pName = ((PCHAR)pBindingBuffer + VariableLengthInfoOffset);

                        pTransportInfo->wkti0_transport_name = (LPWSTR)pName;

                        // Copy the variable length data, i.e. the transport name and in the case of
                        // NETBIOS provides the adapter address
                        RtlCopyMemory(
                            pName,
                            pTransport->RxCeTransport.Name.Buffer,
                            pTransport->RxCeTransport.Name.Length);

                        pName += pTransport->RxCeTransport.Name.Length;
                        *((PWCHAR)pName) = L'\0';

                        VariableLengthInfoOffset -= ADAPTER_STATUS_LENGTH_IN_BYTES;

                        pAdapter = (PWCHAR)((PCHAR)pBindingBuffer + VariableLengthInfoOffset);
                        pTransportInfo->wkti0_transport_address = pAdapter;

                        Status = RxCeQueryAdapterStatus(
                                     &pTransport->RxCeTransport,
                                     &AdapterStatus);

                        if (NT_SUCCESS(Status) ||
                            (Status == STATUS_BUFFER_OVERFLOW)) {
                            ULONG i;

                            for (i = 0; i < 6; i++) {
                                *pAdapter++ = HexDigit((AdapterStatus.adapter_address[i] >> 4) & 0x0F);
                                *pAdapter++ = HexDigit(AdapterStatus.adapter_address[i] & 0x0F);
                            }

                            *pAdapter = L'\0';
                        } else {
                            RtlCopyMemory(
                                pAdapter,
                                NullAdapterStatus.Buffer,
                                ADAPTER_STATUS_LENGTH_IN_BYTES);
                        }

                        // Increment the number of transports that have been returned.
                        pLmrRequestPacket->Parameters.Get.ResumeHandle++;
                        pLmrRequestPacket->Parameters.Get.EntriesRead++;
                        pTransportInfo++;
                    } else {
                        pTransportInfo->wkti0_transport_name = NULL;
                        pTransportInfo->wkti0_transport_address = NULL;
                    }
                }
            }

            if (RemainingLength < 0) {
                ReturnStatus = STATUS_MORE_ENTRIES;
                pLmrRequestPacket->Parameters.Get.TotalBytesNeeded = LengthRequired;
            }
        } else {
            ReturnStatus = STATUS_NO_MORE_FILES;
        }

       SmbCeDereferenceTransportArray(pTransportArray);

try_exit:NOTHING;

   } finally {
       RxDbgTraceUnIndent(-1,Dbg);
   }

   return ReturnStatus;
}

BOOLEAN
MRxSmbShowConnection(
    IN LUID LogonId,
    IN PV_NET_ROOT VNetRoot
    )
/*++

Routine Description:

    Returns whether the given V_NET_ROOT should be returned
    from an LMR_ENUMERATE_CONNECTIONS call.

Arguments:

    IN LUID LogonId - LogonId of caller asking for enumeration of connections

    IN PVNET_ROOT VNetRoot - Supplies the NetRoot to enumerate.

Return Value:

    BOOLEAN - True if the entry should be returned to the caller


--*/
{
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = SmbCeGetAssociatedVNetRootContext((PMRX_V_NET_ROOT)VNetRoot);

    // If no Context, not session specific
    if( pVNetRootContext == NULL ) {
        return TRUE;
    }

    if( RtlEqualLuid( &LogonId, &pVNetRootContext->pSessionEntry->Session.LogonId ) ) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\vcsndrcv.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    vcsndrcv.c

Abstract:

    This module implements all functions related to transmitting and recieving SMB's on a
    connection based transport.

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995

Notes:


--*/

#include "precomp.h"
#pragma hdrstop

#include "vcsndrcv.h"
#include "nbtioctl.h"

//
// Forward declarations
//

NTSTATUS
VctTranceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

NTSTATUS
VctReceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange);

NTSTATUS
VctSend(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

NTSTATUS
VctSendDatagram(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

struct _SMBCE_VC *
VctSelectVc(
    struct SMBCE_SERVER_VC_TRANSPORT *pVcTransport,
    BOOLEAN                    fMultiplexed);

NTSTATUS
VctInitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange);

NTSTATUS
VctUninitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange);

NTSTATUS
VctIndReceive(
    IN PVOID              pEventContext,
    IN PRXCE_VC           pVc,
    IN ULONG              ReceiveFlags,
    IN ULONG              BytesIndicated,
    IN ULONG              BytesAvailable,
    OUT ULONG             *pBytesTaken,
    IN PVOID              pTsdu,
    OUT PMDL *pDataBufferPointer,
    OUT PULONG            pDataBufferSize
    );

NTSTATUS
VctIndDataReady(
    IN PVOID        pEventContext,
    IN PMDL         pBuffer,
    IN ULONG        DataSize,
    IN NTSTATUS     CopyDataStatus
    );

NTSTATUS
VctIndEndpointError(
    IN PVOID          pEventContext,
    IN NTSTATUS       IndicatedStatus
    );

NTSTATUS
VctIndSendPossible(
    IN PVOID          pEventContext,
    IN PRXCE_VC       pRxCeVc,
    IN ULONG          BytesAvailable
    );

NTSTATUS
VctIndReceiveDatagram(
    IN PVOID   pRxCeEventContext,
    IN int     SourceAddressLength,
    IN PVOID   SourceAddress,
    IN int     OptionsLength,
    IN PVOID   Options,
    IN ULONG   ReceiveDatagramFlags,
    IN ULONG   BytesIndicated,
    IN ULONG   BytesAvailable,
    OUT ULONG  *BytesTaken,
    IN PVOID   Tsdu,
    OUT PMDL   *pDataBufferPointer,
    OUT PULONG pDataBufferSize
    );

NTSTATUS
VctIndSendComplete(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pRxCeVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       SendCompletionStatus
   );

NTSTATUS
VctCompleteInitialization(
    PSMBCEDB_SERVER_ENTRY      pServerEntry,
    PSMBCE_TRANSPORT           pTransport,
    struct SMBCE_SERVER_VC_TRANSPORT *pVcTransport);

NTSTATUS
VctUninitialize(
    PVOID pTransport);

NTSTATUS
VctpTranslateNetbiosNameToIpAddress(
    IN  OEM_STRING *pName,
    OUT ULONG      *pIpAddress
    );

ULONG
VctComputeTransportAddressSize(
   IN PUNICODE_STRING pServerName);

NTSTATUS
VctBuildTransportAddress (
    IN  PTRANSPORT_ADDRESS pTransportAddress,
    IN  ULONG              TransportAddressLength,
    IN  PUNICODE_STRING    pServerName,
    OUT PULONG             pServerIpAddress
    );

NTSTATUS
VctpCreateConnection(
    IN PSMBCEDB_SERVER_ENTRY    pServerEntry,
    IN PTRANSPORT_ADDRESS       pTransportAddress,
    IN ULONG                    TransportAddressLength,
    IN PUNICODE_STRING          pServerName,
    OUT PSMBCE_TRANSPORT        *pTransportPtr,
    IN OUT PRXCE_CONNECTION     pRxCeConnection,
    IN OUT PRXCE_VC             pRxCeVc);

VOID
VctpInitializeServerTransport(
    struct _RXCE_VC_CONNECT_CONTEXT *pRxCeConnectContext);

NTSTATUS
VctpInvokeTransportFunction(
    struct _RXCE_VC_CONNECT_CONTEXT *pRxCeConnectContext);

VOID
VctpUninitializeServerTransport(
    struct _RXCE_VC_CONNECT_CONTEXT *pRxCeConnectContext);

NTSTATUS
VctTearDownServerTransport(
   PSMBCE_SERVER_TRANSPORT pServerTransport);

NTSTATUS
VctInitiateDisconnect(
    PSMBCE_SERVER_TRANSPORT pServerTransport);

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, VctTranceive)
#pragma alloc_text(PAGE, VctReceive)
#pragma alloc_text(PAGE, VctSend)
#pragma alloc_text(PAGE, VctSendDatagram)
#pragma alloc_text(PAGE, VctSelectVc)
#pragma alloc_text(PAGE, VctInitializeExchange)
#pragma alloc_text(PAGE, VctUninitializeExchange)
#pragma alloc_text(PAGE, VctIndEndpointError)
#pragma alloc_text(PAGE, VctIndSendPossible)
#pragma alloc_text(PAGE, VctCompleteInitialization)
#pragma alloc_text(PAGE, VctUninitialize)
#pragma alloc_text(PAGE, VctpTranslateNetbiosNameToIpAddress)
#pragma alloc_text(PAGE, VctComputeTransportAddressSize)
#pragma alloc_text(PAGE, VctBuildTransportAddress)
#pragma alloc_text(PAGE, VctpCreateConnection)
#pragma alloc_text(PAGE, VctpInitializeServerTransport)
#pragma alloc_text(PAGE, VctpUninitializeServerTransport)
#pragma alloc_text(PAGE, VctpInvokeTransportFunction)
#pragma alloc_text(PAGE, VctInstantiateServerTransport)
#pragma alloc_text(PAGE, VctTearDownServerTransport)
#pragma alloc_text(PAGE, VctInitiateDisconnect)
#endif

RXDT_DefineCategory(VCSNDRCV);
#define Dbg        (DEBUG_TRACE_VCSNDRCV)

// Move this def to a common .h file.
#define MAX_SMB_PACKET_SIZE (65536)

#define MIN(a,b) ((a) < (b) ? (a) : (b))

//
// Forward references of functions ....
//

extern NTSTATUS
VctTearDownServerTransport(
    PSMBCE_SERVER_TRANSPORT pTransport);

extern NTSTATUS
VctInitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE            pExchange);

extern PSMBCE_VC
VctSelectVc(
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport,
    BOOLEAN                    fMultiplexed);

extern NTSTATUS
SmbCeReceiveIndWithSecuritySignature(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN ULONG                 BytesIndicated,
    IN ULONG                 BytesAvailable,
    OUT ULONG                *pBytesTaken,
    IN PVOID                 pTsdu,
    OUT PMDL                 *pDataBufferPointer,
    OUT PULONG               pDataBufferSize,
    IN ULONG                 ReceiveFlags
    );

extern NTSTATUS
SmbCeDataReadyIndWithSecuritySignature(
   IN PSMBCEDB_SERVER_ENTRY pServerEntry,
   IN PMDL                  pBuffer,
   IN ULONG                 DataSize,
   IN NTSTATUS              CopyDataStatus);

#define SmbMmInitializeVcEntry(pVcEntry)                      \
         SmbMmInitializeHeader((pVcEntry));

#define SmbMmUninitializeVcEntry(pVcEntry)    \
         ASSERT(IsListEmpty(&(pVcEntry)->Requests.ListHead))

#define VctSelectMultiplexedVcEntry(pVcTransport)  VctSelectVc(pVcTransport,TRUE)
#define VctSelectRawVcEntry(pVcTransport)          VctSelectVc(pVcTransport,FALSE)

//
// Inline functions to update the state of a VC.
//

INLINE BOOLEAN
VctUpdateVcStateLite(
    PSMBCE_VC       pVc,
    SMBCE_VC_STATE  NewState)
{
    BOOLEAN Result = TRUE;

    ASSERT(SmbCeSpinLockAcquired());

    if (NewState == SMBCE_VC_STATE_RAW) {
        if (pVc->SwizzleCount != 0) {
            Result = FALSE;
        } else {
            pVc->State = NewState;
        }
    } else {
        pVc->State = NewState;
    }

    return Result;
}

INLINE BOOLEAN
VctUpdateVcState(
    PSMBCE_VC       pVc,
    SMBCE_VC_STATE  NewState)
{
    BOOLEAN Result = TRUE;

    SmbCeAcquireSpinLock();

    Result = VctUpdateVcStateLite(pVc,NewState);

    SmbCeReleaseSpinLock();

    return Result;
}

NTSTATUS
VctTranceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pTransport    - the transport

    pServerEntry  - the server entry

    pExchange     - the exchange instance issuing this SMB.

    SendOptions   - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be transmitted

    pSendCompletionContext - the send completion context

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    STATUS_PENDING - the open involves network traffic and the exchange has been
                     queued for notification ( pServerPointer is set to NULL)

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS                   Status = STATUS_SUCCESS;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;
    PSMB_HEADER                pSmbHeader = MmGetSystemAddressForMdlSafe(pSmbMdl,LowPagePriority);
    USHORT                     Mid;
    BOOLEAN                    fInvokeSendCompleteHandler = TRUE;

    PAGED_CODE();

    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

    if (pSmbHeader == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } else {
        pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;

        // Ensure that the connection is still active before satisfying the request.
        if (SmbCeIsEntryInUse(&pServerEntry->Header)) {
            pVc = pExchange->SmbCeContext.TransportContext.Vcs.pVc;
            if (pVc == NULL) {
                Status = STATUS_CONNECTION_DISCONNECTED;
            }

            if ((Status == STATUS_SUCCESS) &&
                (pVc->State == SMBCE_VC_STATE_MULTIPLEXED)) {
                Status = RxCeSend(
                             &pVc->RxCeVc,
                             SendOptions,
                             pSmbMdl,
                             SendLength,
                             pSendCompletionContext);

                if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
                    Status = STATUS_PENDING;
                    // The underlying connection engine assumes the responsibility of
                    // invoking the send complete handler from this point.
                    fInvokeSendCompleteHandler = FALSE;
                }
            } else {
                RxDbgTrace(0, Dbg, ("VctTranceive: Disconnected connection detected\n"));
                Status = STATUS_CONNECTION_DISCONNECTED;
            }
        } else {
            // The server entry is not valid ...
            Status = STATUS_CONNECTION_DISCONNECTED;
        }
    }

    if (Status != STATUS_PENDING) {
        RxDbgTrace(0, Dbg, ("VctTranceive: Return Status %lx\n",Status));
    }

    // There are instances in which the send was aborted even before the underlying
    // transport was invoked. In such cases the appropriate send complete handler
    // needs to be called so that the associated exchange can be finalized.

    if (fInvokeSendCompleteHandler) {
        NTSTATUS LocalStatus;

        LocalStatus = SmbCeSendCompleteInd(
                          pServerEntry,
                          pSendCompletionContext,
                          Status);

        RxDbgTrace(0, Dbg, ("VctTranceive: Send Complete Handler Return Status %lx\n",LocalStatus));
    }

    return Status;
}


NTSTATUS
VctReceive(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine transmits/receives a SMB for a give exchange

Arguments:

    pTransport   - the server transport

    pServerEntry - the server entry

    pExchange  - the exchange instance issuing this SMB.

Return Value:

    STATUS_PENDING - the request has been queued

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS                   Status = STATUS_SUCCESS;
    PSMBCEDB_NET_ROOT_ENTRY    pNetRootEntry;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

    PAGED_CODE();

    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;
    pVc          = pExchange->SmbCeContext.TransportContext.Vcs.pVc;

    // Ensure that the connection is still active before satisfying the request.
    if (SmbCeIsEntryInUse(&pServerEntry->Header) &&
        (pVc != NULL)) {
        Status = STATUS_SUCCESS;
    } else {
        // The server entry is not valid ...
        Status = STATUS_CONNECTION_DISCONNECTED;
    }

    return Status;
}

NTSTATUS
VctSend(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pTransport - the server transport

    pServer    - the recepient server

    SendOptions - options for send

    pSmbMdl       - the SMB that needs to be sent.

    SendLength    - length of data to be sent

    pSendCompletionContext - the send completion context

Return Value:

    STATUS_SUCCESS - the send was successful.

    STATUS_PENDING - the send has been queued

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS                   Status = STATUS_CONNECTION_DISCONNECTED;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;
    BOOLEAN                    fInvokeSendCompleteHandler = TRUE;

    PAGED_CODE();

    ASSERT(pServerEntry->Header.ObjectType == SMBCEDB_OT_SERVER);

    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;
    pVc = VctSelectMultiplexedVcEntry(pVcTransport);

    if  (pVc != NULL) {
        if (pVc->State == SMBCE_VC_STATE_MULTIPLEXED) {
            Status = RxCeSend(
                         &pVc->RxCeVc,
                         SendOptions,
                         pSmbMdl,
                         SendLength,
                         pSendCompletionContext);

            if ((Status == STATUS_SUCCESS) || (Status == STATUS_PENDING)) {
                // The underlying connection engine assumes the responsibility of
                // invoking the send complete handler from this point.
                fInvokeSendCompleteHandler = FALSE;
            }
        }
    }

    if (!NT_SUCCESS(Status)) {
        RxDbgTrace(0, Dbg, ("VctSend: RxCeSend returned %lx\n",Status));
    }

    // There are instances in which the send was aborted even before the underlying
    // transport was invoked. In such cases the appropriate send complete handler
    // needs to be called so that the associated exchange can be finalized.

    if (fInvokeSendCompleteHandler) {
        NTSTATUS LocalStatus;

        LocalStatus = SmbCeSendCompleteInd(
                          pServerEntry,
                          pSendCompletionContext,
                          Status);

        RxDbgTrace(0, Dbg, ("VctTranceive: Send Complete Handler Return Status %lx\n",LocalStatus));
    }

    return Status;
}

NTSTATUS
VctSendDatagram(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext)
/*++

Routine Description:

    This routine opens/creates a server entry in the connection engine database

Arguments:

    pTransport - the server transport

    pServer    - the recepient server

    SendOptions - options for send

    pSmbMdl     - the SMB that needs to be sent.

    SendLength  - length of data to be sent

    pSendCompletionContext - the send completion context

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    STATUS_PENDING - the open involves network traffic and the exchange has been
                     queued for notification ( pServerPointer is set to NULL)

    Other Status codes correspond to error situations.

--*/
{
    PAGED_CODE();

    return STATUS_NOT_IMPLEMENTED;
}

PSMBCE_VC
VctSelectVc(
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport,
    BOOLEAN                    fMultiplexed)
/*++

Routine Description:

    This routine embodies the logic for the selection of a VC on which the SMB exchange
    will transpire

Arguments:

    pVcTransport  - the transport structure

    fMultiplexed  - the desired mode

Return Value:

    a referenced VC entry if successful otherwise NULL

--*/
{
    NTSTATUS        Status;
    PSMBCE_VC       pVc = NULL;
    ULONG           VcIndex,NumberOfActiveVcs = 0;
    SMBCE_VC_STATE  DesiredState;

    PAGED_CODE();

    if (fMultiplexed) {
        RxDbgTrace(0, Dbg, ("VctSelectVc: Referencing Multiplexed entry\n"));
        DesiredState = SMBCE_VC_STATE_MULTIPLEXED;
    } else {
        RxDbgTrace(0, Dbg, ("VctSelectVc: Referencing Raw entry\n"));
        DesiredState = SMBCE_VC_STATE_RAW;
    }

    // Acquire the resource
    SmbCeAcquireResource();

    // Choose the first VC that can support multiplexed requests
    for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
        PSMBCE_VC pTempVc = &pVcTransport->Vcs[VcIndex];

        NumberOfActiveVcs++;

        if (pTempVc->State == SMBCE_VC_STATE_MULTIPLEXED) {
            if (DesiredState == SMBCE_VC_STATE_MULTIPLEXED) {
                pVc = pTempVc;
                break;
            } else {
                // If the current number of active references to a VC is zero, it can
                // be transformed into the raw mode.
                if (VctUpdateVcState(pTempVc,SMBCE_VC_STATE_RAW)) {
                    pVc = pTempVc;
                    break;
                } else {
                    NumberOfActiveVcs++;
                }
            }
        }
    }

    if (pVc == NULL) {
        // Check if it is O.K. to add VCs to this connection. Currently the server
        // implementation supports only one VC per connection. Therefore if an
        // active VC exists which has been grabbed for raw mode use an error is returned.
        // Subsequently when the server is upgraded to handle multiple VCs the logic
        // for adding a new VC will be implemented as part of this routine.
    }

    if (pVc != NULL) {
        VctReferenceVc(pVc);
    }

    // release the resource
    SmbCeReleaseResource();

    return pVc;
}

NTSTATUS
VctInitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine initializes the transport information pertinent to a exchange

Arguments:

    pTransport         - the transport structure

    pExchange          - the exchange instance

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
    PSMBCEDB_SERVER_ENTRY      pServerEntry;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

    PAGED_CODE();

    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;

    ASSERT(pExchange->SmbCeContext.TransportContext.Vcs.pVc == NULL);

    pExchange->SmbCeContext.TransportContext.Vcs.pVc
                     = VctSelectMultiplexedVcEntry(pVcTransport);

    if (pExchange->SmbCeContext.TransportContext.Vcs.pVc == NULL) {
        RxDbgTrace(0, Dbg, ("VctInitializeExchange: Unsuccessful\n"));
        return STATUS_CONNECTION_DISCONNECTED;
    } else {
        RxDbgTrace(0, Dbg, ("VctInitializeExchange: Successful\n"));
        return STATUS_SUCCESS;
    }
}

NTSTATUS
VctUninitializeExchange(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE           pExchange)
/*++

Routine Description:

    This routine uninitializes the transport information pertinent to a exchange

Arguments:

    pExchange          - the exchange instance

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport;

    PAGED_CODE();

    pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;

    RxDbgTrace(0, Dbg, ("VctUninitializeExchange: Successful\n"));

    if (pExchange->SmbCeContext.TransportContext.Vcs.pVc != NULL) {
        VctDereferenceVc(pExchange->SmbCeContext.TransportContext.Vcs.pVc);
    }

    pExchange->SmbCeContext.TransportContext.Vcs.pVc = NULL;

    return STATUS_SUCCESS;
}


NTSTATUS
VctIndReceive(
    IN PVOID              pEventContext,
    IN PRXCE_VC           pVc,
    IN ULONG              ReceiveFlags,
    IN ULONG              BytesIndicated,
    IN ULONG              BytesAvailable,
    OUT ULONG             *pBytesTaken,
    IN PVOID              pTsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL              *pDataBufferPointer,    // the buffer in which data is to be copied.
    OUT PULONG            pDataBufferSize         // amount of data to copy
    )
/*++

Routine Description:

    This routine handles the receive indication for SMB's along all vcs in a connection to a
    server.

Arguments:

    pEventContext      - the server entry

    hVc                - the Vc on which the SMB has been received

    ReceiveFlags       - options for receive

    BytesIndicated     - the bytes that are present in the indication.

    BytesAvailable     - the total data available

    pTsdu              - the data

    pDataBufferPointer - the buffer for copying the data not indicated.

    pDataBufferSize    - the length of the buffer

Return Value:

    STATUS_SUCCESS -

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS Status;
    PSMBCEDB_SERVER_ENTRY  pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;

    Status = SmbCeReceiveInd(
                 pServerEntry,
                 BytesIndicated,
                 BytesAvailable,
                 pBytesTaken,
                 pTsdu,
                 pDataBufferPointer,
                 pDataBufferSize,
                 ReceiveFlags);
    
    return Status;
}

NTSTATUS
VctIndDataReady(
    IN PVOID        pEventContext,
    IN PMDL         pBuffer,
    IN ULONG        DataSize,
    IN NTSTATUS     CopyDataStatus
    )
/*++

Routine Description:

    This routine handles the indication when the requested data has been copied

Arguments:

    pEventContext - the server instance

    pBuffer       - the buffer being returned

    DataSize      - the amount of data copied in bytes

    CopyDataStatus - CopyDataStatus

Return Value:

    STATUS_SUCCESS - the server call construction has been finalized.

    Other Status codes correspond to error situations.

--*/
{
    NTSTATUS Status;
    PSMBCEDB_SERVER_ENTRY  pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;

    Status = SmbCeDataReadyInd(
                 pServerEntry,
                 pBuffer,
                 DataSize,
                 CopyDataStatus);

    return STATUS_SUCCESS;
}

NTSTATUS
VctIndDisconnect(
    IN PVOID          pEventContext,
    IN PRXCE_VC       pRxCeVc,
    IN int            DisconnectDataLength,
    IN PVOID          DisconnectData,
    IN int            DisconnectInformationLength,
    IN PVOID          DisconnectInformation,
    IN ULONG          DisconnectFlags
    )
/*++

Routine Description:

    This routine handles the disconnect indication for a VC.

Arguments:

    pEventContext               - the server instance

    hVc                         - the virtual circuit

    DisconnectDataLength        -

    DisconnectData              -

    DisconnectInformationLength -

    DisconnectInformation       -

    DisconnectFlags             -

Return Value:

    STATUS_SUCCESS - the disconnect indication has been handled

--*/
{
    PSMBCEDB_SERVER_ENTRY       pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;
    PSMBCEDB_SERVER_ENTRY       pListEntry;
    PSMBCE_VC                   pVc;
    PSMBCEDB_REQUEST_ENTRY      pRequestEntry;
    PSMB_EXCHANGE               pExchange;
    PSMBCE_SERVER_VC_TRANSPORT  pVcTransport;

    BOOLEAN fValidServerEntry = FALSE;
    BOOLEAN OutstandingWorkItem;

    // Traverse the list of server entries to ensure that the disconnect was on a
    // valid server entry. If it is not on a valid server entry ignore it.

    SmbCeAcquireSpinLock();

    pListEntry = SmbCeGetFirstServerEntry();

    while (pListEntry != NULL) {
        if (pListEntry == pServerEntry) {
            // The invalidation needs to hold onto an extra reference to avoid
            // race conditions which could lead to premature destruction of
            // this server entry.
            SmbCeReferenceServerEntry(pServerEntry);
            fValidServerEntry = TRUE;
            break;
        }
        pListEntry = SmbCeGetNextServerEntry(pListEntry);
    }
 
    if (fValidServerEntry) {
        pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;

        if (pVcTransport != NULL) {
            ULONG VcIndex;

            for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
                pVc = &pVcTransport->Vcs[VcIndex];

                if (&pVc->RxCeVc == pRxCeVc) {
                    VctUpdateVcStateLite(pVc,SMBCE_VC_STATE_DISCONNECTED);
                    pVc->Status   = STATUS_CONNECTION_DISCONNECTED;
                    break;
                }
            }
        }

	OutstandingWorkItem = pServerEntry->DisconnectWorkItemOutstanding;
	// OK to unconditionally set to TRUE
	pServerEntry->DisconnectWorkItemOutstanding = TRUE;
    }

    // Release the resource
    SmbCeReleaseSpinLock();

    if (fValidServerEntry) {
        RxDbgTrace(0,Dbg,("@@@@@@ Disconnect Indication for %lx @@@@@\n",pServerEntry));
        InterlockedIncrement(&MRxSmbStatistics.ServerDisconnects);

        // Update the Server entry if this is the only VC associated with the transport.
        SmbCeTransportDisconnectIndicated(pServerEntry);
   
	// only dereference if necessary (we might already have an outstanding request)
	if(OutstandingWorkItem == FALSE ) {  

	    InitializeListHead(&pServerEntry->WorkQueueItemForDisconnect.List);

	    RxPostToWorkerThread(
		MRxSmbDeviceObject,
		CriticalWorkQueue,
		&pServerEntry->WorkQueueItemForDisconnect,
		SmbCepDereferenceServerEntry,  
		pServerEntry);
	}
	 
        RxDbgTrace(0, Dbg, ("VctIndDisconnect: Processing Disconnect indication on VC entry %lx\n",pVc));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
VctIndError(
    IN PVOID          pEventContext,
    IN PRXCE_VC       pRxCeVc,
    IN NTSTATUS       IndicatedStatus
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    pRxCeVc       - the RxCe virtual circuit

    Status        - the error

Return Value:

    STATUS_SUCCESS

--*/
{
    NTSTATUS                   Status;
    ULONG                      VcIndex;
    PSMBCEDB_SERVER_ENTRY      pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerEntry->pTransport;

    // Acquire the resource
    SmbCeAcquireSpinLock();

    // Map the RXCE vc handle to the appropriate SMBCE entry and get the request
    // list associated with it.

    for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
        pVc = &pVcTransport->Vcs[VcIndex];

        if (&pVc->RxCeVc == pRxCeVc) {
            VctUpdateVcStateLite(pVc,SMBCE_VC_STATE_DISCONNECTED);
            pVc->Status   = IndicatedStatus;
            break;
        }
    }

    // Release the resource
    SmbCeReleaseSpinLock();

    RxDbgTrace(0, Dbg, ("VctIndError: Processing Error indication on VC entry %lx\n",pVc));

    Status = SmbCeErrorInd(
                 pServerEntry,
                 IndicatedStatus);

    return Status;
}

NTSTATUS
VctIndEndpointError(
    IN PVOID          pEventContext,
    IN NTSTATUS       IndicatedStatus
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    Status        - the error

Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();

    return STATUS_SUCCESS;
}

NTSTATUS
VctIndSendPossible(
    IN PVOID          pEventContext,    // the event context.
    IN PRXCE_VC       pRxCeVc,
    IN ULONG          BytesAvailable
    )
/*++

Routine Description:

    This routine handles the error indication

Arguments:

    pEventContext - the server instance

    hVc           - the VC instance

    BytesAvailable - the number of bytes that can be sent

Return Value:

    STATUS_SUCCESS

--*/
{
    PAGED_CODE();

    return STATUS_SUCCESS;
}

NTSTATUS
VctIndReceiveDatagram(
    IN PVOID   pRxCeEventContext,      // the event context
    IN int     SourceAddressLength,    // length of the originator of the datagram
    IN PVOID   SourceAddress,          // string describing the originator of the datagram
    IN int     OptionsLength,          // options for the receive
    IN PVOID   Options,                //
    IN ULONG   ReceiveDatagramFlags,   //
    IN ULONG   BytesIndicated,         // number of bytes this indication
    IN ULONG   BytesAvailable,         // number of bytes in complete Tsdu
    OUT ULONG  *BytesTaken,            // number of bytes used
    IN PVOID   Tsdu,                   // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL   *pDataBufferPointer,    // the buffer in which data is to be copied.
    OUT PULONG pDataBufferSize         // amount of data to copy
    )
{
    return STATUS_SUCCESS;
}

NTSTATUS
VctIndSendComplete(
   IN PVOID          pEventContext,
   IN PRXCE_VC       pRxCeVc,
   IN PVOID          pCompletionContext,
   IN NTSTATUS       SendCompletionStatus
   )
/*++

Routine Description:

    This routine handles the send complete indication for asynchronous sends

Arguments:

    pEventContext - the server instance

    pRxCeVc       - the RxCe VC instance

    pCompletionContext - the context for identifying the send request

    SendCompletionStatus - the send completion status

Return Value:

    STATUS_SUCCESS always ..

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SERVER_ENTRY    pServerEntry = (PSMBCEDB_SERVER_ENTRY)pEventContext;

    Status = SmbCeSendCompleteInd(
                 pServerEntry,
                 pCompletionContext,
                 SendCompletionStatus);

    return Status;
}

//
// Static dispatch vectors for Virtual Circuit based transports
//

RXCE_ADDRESS_EVENT_HANDLER
MRxSmbVctAddressEventHandler = {
                                   VctIndEndpointError,
                                   VctIndReceiveDatagram,
                                   VctIndDataReady,
                                   VctIndSendPossible,
                                   NULL
                               };

RXCE_CONNECTION_EVENT_HANDLER
MRxSmbVctConnectionEventHandler = {
                                      VctIndDisconnect,
                                      VctIndError,
                                      VctIndReceive,
                                      VctIndReceiveDatagram,
                                      VctIndReceive,
                                      VctIndSendPossible,
                                      VctIndDataReady,
                                      VctIndSendComplete
                                  };

TRANSPORT_DISPATCH_VECTOR
MRxSmbVctTransportDispatch = {
                                VctSend,
                                VctSendDatagram,
                                VctTranceive,
                                VctReceive,
                                NULL,
                                VctInitializeExchange,
                                VctUninitializeExchange,
                                VctTearDownServerTransport,
                                VctInitiateDisconnect
                             };


typedef enum _RXCE_VC_FUNCTION_CODE {
   VcConnect,
   VcDisconnect
} RXCE_VC_FUNCTION_CODE, *PRXCE_VC_FUNCTION_CODE;

typedef struct _RXCE_VC_CONNECT_CONTEXT {
   RXCE_VC_FUNCTION_CODE         FunctionCode;
   PRX_WORKERTHREAD_ROUTINE      pRoutine;
   PSMBCEDB_SERVER_ENTRY         pServerEntry;
   PMRX_SRVCALL_CALLBACK_CONTEXT pCallbackContext;
   PSMBCE_SERVER_TRANSPORT       pServerTransport;
   NTSTATUS                      Status;
   KEVENT                        SyncEvent;
} RXCE_VC_CONNECT_CONTEXT, *PRXCE_VC_CONNECT_CONTEXT;

NTSTATUS
VctCompleteInitialization(
    PSMBCEDB_SERVER_ENTRY      pServerEntry,
    PSMBCE_TRANSPORT           pTransport,
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport)
/*++

Routine Description:

    This routine initializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    The remote address can be either deduced from the information in the Rx Context
    or a NETBIOS address needs to be built from the server name.
    This transport address is used subsequently to establish the connection.

--*/
{
    NTSTATUS Status;
    PSMBCE_VC                  pVc;

    RXCE_CONNECTION_INFO         ConnectionInfo;
    RXCE_TRANSPORT_PROVIDER_INFO ProviderInfo;

    PAGED_CODE();

    pVc = &pVcTransport->Vcs[0];

    // Query the transport information ...
    Status = RxCeQueryInformation(
                  &pVc->RxCeVc,
                  RxCeTransportProviderInformation,
                  &ProviderInfo,
                  sizeof(ProviderInfo));

    if (NT_SUCCESS(Status)) {
        pVcTransport->MaximumSendSize = MIN( ProviderInfo.MaxSendSize,
                                           MAXIMUM_PARTIAL_BUFFER_SIZE );
    } else {
        // CODE.IMPROVMENT - fix constant below to a #define, also is the
        //    value correct?
        ASSERT( 1024 <= MAXIMUM_PARTIAL_BUFFER_SIZE );
        pVcTransport->MaximumSendSize = 1024;
    }

    // Query the connection information ....
    Status = RxCeQueryInformation(
                 &pVc->RxCeVc,
                 RxCeConnectionEndpointInformation,
                 &ConnectionInfo,
                 sizeof(ConnectionInfo));

    if (NT_SUCCESS(Status)) {
        // The setting of the delay parameter is an important heuristic
        // that determines how quickly and how often timeouts occur. As
        // a first cut a very conservative estimate for the time has been
        // choosen, i.e., double the time required to transmit a 64 k packet.
        // This parameter should be fine tuned.

        pVcTransport->Delay.QuadPart = (-ConnectionInfo.Delay.QuadPart) +
                           (-ConnectionInfo.Delay.QuadPart);
        if (ConnectionInfo.Throughput.LowPart != 0) {
            pVcTransport->Delay.QuadPart +=
                     (MAX_SMB_PACKET_SIZE/ConnectionInfo.Throughput.LowPart) * 1000 * 10000;
        }

        RxDbgTrace( 0, Dbg, ("Connection delay set to %ld 100ns ticks\n",pVcTransport->Delay.LowPart));

        pVcTransport->pDispatchVector = &MRxSmbVctTransportDispatch;
        pVcTransport->MaximumNumberOfVCs = 1;

        pVc->State     = SMBCE_VC_STATE_MULTIPLEXED;

        pVcTransport->State = SMBCEDB_ACTIVE;
    } else {
        RxDbgTrace(0, Dbg, ("VctInitialize : RxCeQueryInformation returned %lx\n",Status));
    }

    if (NT_SUCCESS(Status)) {
        pVcTransport->pTransport   = pTransport;
    } else {
        RxDbgTrace(0, Dbg, ("VctInitialize : Connection Initialization Failed %lx\n",Status));
    }

    return Status;
}

NTSTATUS
VctUninitialize(
    PVOID pTransport)
/*++

Routine Description:

    This routine uninitializes the transport instance

Arguments:

    pVcTransport - the VC transport instance

Return Value:

    STATUS_SUCCESS - the server transport construction has been uninitialzied.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS                   Status = STATUS_SUCCESS;
    ULONG                      VcIndex;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;
    ULONG                      TransportFlags;

    PAGED_CODE();

    // The spinlock needs to be acquired for manipulating the list of Vcs because of
    // indications that will be processed till the appropriate RXCE data structures are
    // dismantled

    for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
        pVc = &pVcTransport->Vcs[VcIndex];

        // Assert the fact that the request list associated with the VC is empty.
        // Tear down the VC entry
        Status = RxCeTearDownVC(&pVc->RxCeVc);
        ASSERT(Status == STATUS_SUCCESS);
    }

    // Tear down the connection endpoint ..
    Status = RxCeTearDownConnection(&pVcTransport->RxCeConnection);
    ASSERT(Status == STATUS_SUCCESS);

    RxDbgTrace(0, Dbg, ("VctUninitialize : RxCeDisconnect returned %lx\n",Status));

    // Dereference the underlying transport
    if (pVcTransport->pTransport != NULL) {
        SmbCeDereferenceTransport(pVcTransport->pTransport);
    }

    ASSERT((pVcTransport->Vcs[0].RxCeVc.hEndpoint == INVALID_HANDLE_VALUE) ||
           (pVcTransport->Vcs[0].RxCeVc.hEndpoint == NULL));

    ASSERT(pVcTransport->Vcs[0].RxCeVc.pEndpointFileObject == NULL);

    // Free up the transport entry
    RxFreePool(pVcTransport);

    return Status;
}

NTSTATUS
VctpTranslateNetbiosNameToIpAddress(
    IN  OEM_STRING *pName,
    OUT ULONG      *pIpAddress
    )
/*++

Routine Description:

    This routine converts ascii ipaddr (11.101.4.25) into a ULONG.  This is
    based on the inet_addr code in winsock

Arguments:
    pName   - the string containing the ipaddress

Return Value:

    the ipaddress as a ULONG if it's a valid ipaddress.  Otherwise, 0.

Notes:

    The body of this routine has been borrowed fron NetBt.

--*/
{
    NTSTATUS  Status;
    PCHAR    pStr;
    int      i;
    int      len, fieldLen;
    int      fieldsDone;
    ULONG    IpAddress;
    BYTE     ByteVal;
    PCHAR    pIpPtr;
    BOOLEAN  fDotFound;
    BOOLEAN  fieldOk;

    PAGED_CODE();

    Status = STATUS_INVALID_ADDRESS_COMPONENT;

    if (pName->Length > NETBIOS_NAME_LEN) {
        return Status;
    }

    pStr = pName->Buffer;
    len = 0;
    pIpPtr = (PCHAR)&IpAddress;
    pIpPtr += 3;                   // so that we store in network order
    fieldsDone=0;

    //
    // the 11.101.4.25 format can be atmost 15 chars, and pName is guaranteed
    // to be at least 16 chars long (how convenient!!).  Convert the string to
    // a ULONG.
    //
    while(len < NETBIOS_NAME_LEN)
    {
        fieldLen=0;
        fieldOk = FALSE;
        ByteVal = 0;
        fDotFound = FALSE;

        //
        // This loop traverses each of the four fields (max len of each
        // field is 3, plus 1 for the '.'
        //
        while (fieldLen < 4)
        {
            if (*pStr >='0' && *pStr <='9')
            {
                ByteVal = (ByteVal*10) + (*pStr - '0');
                fieldOk = TRUE;
            }

            else if (*pStr == '.' || *pStr == ' ' || *pStr == '\0')
            {
                *pIpPtr = ByteVal;
                pIpPtr--;
                fieldsDone++;

                if (*pStr == '.')
                    fDotFound = TRUE;

                // if we got a space or 0, assume it's the 4th field
                if (*pStr == ' ' || *pStr == '\0')
                {
                    break;
                }
            }

            // unacceptable char: can't be ipaddr
            else
            {
                return(Status);
            }

            pStr++;
            len++;
            fieldLen++;

            // if we found the dot, we are done with this field: go to the next one
            if (fDotFound)
                break;
        }

        // this field wasn't ok (e.g. "11.101..4" or "11.101.4." etc.)
        if (!fieldOk)
        {
            return(Status);
        }

        // if we are done with all 4 fields, we are done with the outer loop too
        if ( fieldsDone == 4)
            break;

        if (!fDotFound)
        {
            return(Status);
        }
    }

    //
    // make sure the remaining chars are spaces or 0's (i.e. don't allow
    // 11.101.4.25xyz to succeed)
    //
    for (i=len; i<NETBIOS_NAME_LEN; i++, pStr++)
    {
        if (*pStr != ' ' && *pStr != '\0')
        {
            return(Status);
        }
    }

    *pIpAddress = IpAddress;
    return( STATUS_SUCCESS );
}


ULONG
VctComputeTransportAddressSize(
   IN PUNICODE_STRING pServerName)

/*++

Routine Description:

    This routine takes a computer name (PUNICODE_STRING) and computes the size of the
    TRANSPORT_ADDRESSS buffer required to connect to it.

Arguments:

    IN PUNICODE_STRING Name - Supplies the name to put into the transport

Return Value:

    size of the buffer.

Notes:

    The compound transport address passed to the transports consists of two
    TDI_NETBIOS_EX_ADDRESSes and a TDI_NETBIOS_ADDRESS. The two NETBIOS_EX addresses refer
    to the two different endpoints registered by the server, i.e., *SMBSERVER and
    the Server name padded upto NETBIOS_NAME_LEN with blanks. The order in which
    the two NETBIOS_EX addresses are constructed depend upon the length of the server
    name. If it is greater than NETBIOS_NAME_LEN *SMBSERVER is the first enpoint
    and vice versa

--*/
{
   ULONG NetbiosAddressLength,NetbiosExAddressLength,NetbiosUnicodeExAddressLength,TransportAddressSize;
   ULONG OemServerNameLength;

   PAGED_CODE();

   OemServerNameLength = RtlUnicodeStringToOemSize(pServerName);

   NetbiosAddressLength = sizeof(TDI_ADDRESS_NETBIOS);
   if( OemServerNameLength > NETBIOS_NAME_LEN ) {
       NetbiosAddressLength += OemServerNameLength - NETBIOS_NAME_LEN;
   }

   NetbiosExAddressLength = FIELD_OFFSET(TDI_ADDRESS_NETBIOS_EX,NetbiosAddress) +
                        NetbiosAddressLength;
   
   NetbiosUnicodeExAddressLength = FIELD_OFFSET(TDI_ADDRESS_NETBIOS_UNICODE_EX,RemoteNameBuffer) +
                        pServerName->Length +
                        DNS_NAME_BUFFER_LENGTH * sizeof(WCHAR);

   TransportAddressSize = FIELD_OFFSET(TRANSPORT_ADDRESS,Address) +
                          3 * FIELD_OFFSET(TA_ADDRESS,Address) +
                          NetbiosAddressLength +
                          2 * NetbiosExAddressLength +
                          NetbiosUnicodeExAddressLength;

   return TransportAddressSize;
}

NTSTATUS
VctBuildTransportAddress (
    IN  PTRANSPORT_ADDRESS pTransportAddress,
    IN  ULONG              TransportAddressLength,
    IN  PUNICODE_STRING    pServerName,
    OUT PULONG             pServerIpAddress
    )
/*++

Routine Description:

    This routine takes a computer name (PUNICODE_STRING) and converts it into an
    acceptable form for passing in as transport address.

Arguments:

    pTransportAddress      - Supplies the structure to fill in

    TransportAddressLength - Supplies the length of the buffer at TransportAddress

    pServerName            - Supplies the name to put into the transport

    pServerNameIsInIpAddressFormat = Server Name is of the dotted IP address kind

Return Value:

    None.

Notes:

    The compound transport address passed to the transports consists of two
    TDI_NETBIOS_EX_ADDRESSes and a TDI_NETBIOS_ADDRESS. The two NETBIOS_EX addresses refer
    to the two different endpoints registered by the server, i.e., *SMBSERVER and
    the Server name padded upto NETBIOS_NAME_LEN with blanks. The order in which
    the two NETBIOS_EX addresses are constructed depend upon the length of the server
    name. If it is greater than NETBIOS_NAME_LEN *SMBSERVER is the first enpoint
    and vice versa

    The WINS database can be inconsistent for extended periods of time. In order to
    account for this inconsistency on NETBIOS names and DNS names we will not
    issue the address for *SMBSERVER. This will be revisited when we have a better
    mechanism for identifying/authenticating the server and the client machine to each other.

--*/

{
    OEM_STRING OemServerName;
    NTSTATUS   Status;

    PTDI_ADDRESS_NETBIOS_EX pTdiNetbiosExAddress;
    PTDI_ADDRESS_NETBIOS    pTdiNetbiosAddress;
    PTA_ADDRESS             pFirstNetbiosExAddress,pSecondNetbiosExAddress,pNetbiosAddress,pNetbiosUnicodeExAddress;
    PTDI_ADDRESS_NETBIOS_UNICODE_EX pTdiNetbiosUnicodeExAddress;

    PCHAR  FirstEndpointName,SecondEndpointName;
    CHAR   EndpointNameBuffer[NETBIOS_NAME_LEN];
    WCHAR  UnicodeEndpointNameBuffer[NETBIOS_NAME_LEN];
    USHORT NetbiosAddressLength,NetbiosExAddressLength;
    USHORT NetbiosAddressType = TDI_ADDRESS_TYPE_NETBIOS;

    ULONG  ComponentLength;

    ULONG   RemoteIpAddress;
    BOOLEAN ServerNameIsInIpAddressForm;

    PAGED_CODE();

    if (TransportAddressLength < VctComputeTransportAddressSize(pServerName)) {
       return STATUS_BUFFER_OVERFLOW;
    }

    if (pServerName->Length > DNS_MAX_NAME_LENGTH) {
       return STATUS_BAD_NETWORK_PATH;
    }

    pFirstNetbiosExAddress = &pTransportAddress->Address[0];

    pTdiNetbiosExAddress = (PTDI_ADDRESS_NETBIOS_EX)pFirstNetbiosExAddress->Address;
    pTdiNetbiosExAddress->NetbiosAddress.NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;

    OemServerName.Length = pServerName->Length;
    OemServerName.MaximumLength = OemServerName.Length + 1;
    OemServerName.Buffer = pTdiNetbiosExAddress->NetbiosAddress.NetbiosName;

    Status = RtlUpcaseUnicodeStringToOemString(&OemServerName, pServerName, FALSE);
    if( !NT_SUCCESS( Status ) ) {
        //return STATUS_BAD_NETWORK_PATH;
        OemServerName.Length = 0;
    }

    if (OemServerName.Length < NETBIOS_NAME_LEN) {
       RtlCopyMemory( &OemServerName.Buffer[ OemServerName.Length ],
                      "                ",
                      NETBIOS_NAME_LEN - OemServerName.Length
                    );
       OemServerName.Length = NETBIOS_NAME_LEN;
    }

    Status = VctpTranslateNetbiosNameToIpAddress(&OemServerName,&RemoteIpAddress);
    if (Status == STATUS_SUCCESS) {
        if ((RemoteIpAddress == 0) || (RemoteIpAddress == 0xffffffff)) {
           // If the server name is a valid IP address and matches with one of the two
           // broadcast addresses used by IP turn back the request.
           return STATUS_INVALID_ADDRESS_COMPONENT;
        }

        *pServerIpAddress = RemoteIpAddress;
        ServerNameIsInIpAddressForm = TRUE;
    } else {
        *pServerIpAddress = 0;
        ServerNameIsInIpAddressForm = FALSE;
    }


    NetbiosAddressLength = sizeof(TDI_ADDRESS_NETBIOS);
    if( OemServerName.Length > NETBIOS_NAME_LEN ) {
        NetbiosAddressLength += OemServerName.Length - NETBIOS_NAME_LEN;
    }

    NetbiosExAddressLength = (USHORT)(FIELD_OFFSET(TDI_ADDRESS_NETBIOS_EX,NetbiosAddress) +
                             NetbiosAddressLength);

    pFirstNetbiosExAddress->AddressLength = NetbiosExAddressLength;
    pFirstNetbiosExAddress->AddressType   = TDI_ADDRESS_TYPE_NETBIOS_EX;

#if 0
    // This arm of the code will be activated and the other arm deactivated when we have
    // mutual authenitication between server and client machines in NT5.0

    if (ServerNameIsInIpAddressForm) {
       pTransportAddress->TAAddressCount = 2;

       pNetbiosAddress = (PTA_ADDRESS)((PCHAR)pFirstNetbiosExAddress +
                                       FIELD_OFFSET(TA_ADDRESS,Address) +
                                       NetbiosExAddressLength);

       FirstEndpointName = SMBSERVER_LOCAL_ENDPOINT_NAME;
    } else {
       pTransportAddress->TAAddressCount = 3;

       pSecondNetbiosExAddress = (PTA_ADDRESS)((PCHAR)pFirstNetbiosExAddress +
                                         FIELD_OFFSET(TA_ADDRESS,Address) +
                                         NetbiosExAddressLength);

       pNetbiosAddress = (PTA_ADDRESS)((PCHAR)pSecondNetbiosExAddress +
                                       FIELD_OFFSET(TA_ADDRESS,Address) +
                                       NetbiosExAddressLength);

       // Scan the server name till the first delimiter (DNS delimiter .) and form
       // the endpoint name by padding the remaining name with blanks.

       RtlCopyMemory(
             EndpointNameBuffer,
             OemServerName.Buffer,
             NETBIOS_NAME_LEN);

       ComponentLength = 0;
       while (ComponentLength < NETBIOS_NAME_LEN) {
          if (EndpointNameBuffer[ComponentLength] == '.') {
             break;
          }
          ComponentLength++;
       }

       if (ComponentLength == NETBIOS_NAME_LEN) {
          EndpointNameBuffer[NETBIOS_NAME_LEN - 1] = ' ';
       } else {
          RtlCopyMemory(&EndpointNameBuffer[ComponentLength],
                        "                ",
                        NETBIOS_NAME_LEN - ComponentLength);
       }

       FirstEndpointName  = EndpointNameBuffer;
       SecondEndpointName = SMBSERVER_LOCAL_ENDPOINT_NAME;
    }
#else
    pTransportAddress->TAAddressCount = 3;

    pNetbiosAddress = (PTA_ADDRESS)((PCHAR)pFirstNetbiosExAddress +
                                    FIELD_OFFSET(TA_ADDRESS,Address) +
                                    NetbiosExAddressLength);
    
    if (ServerNameIsInIpAddressForm) {
       FirstEndpointName = SMBSERVER_LOCAL_ENDPOINT_NAME;
    } else {
       // Scan the server name till the first delimiter (DNS delimiter .) and form
       // the endpoint name by padding the remaining name with blanks.

       RtlCopyMemory(
             EndpointNameBuffer,
             OemServerName.Buffer,
             NETBIOS_NAME_LEN);

       ComponentLength = 0;
       while (ComponentLength < NETBIOS_NAME_LEN) {
          if (EndpointNameBuffer[ComponentLength] == '.') {
             break;
          }
          ComponentLength++;
       }

       if (ComponentLength == NETBIOS_NAME_LEN) {
          EndpointNameBuffer[NETBIOS_NAME_LEN - 1] = ' ';
       } else {
          RtlCopyMemory(&EndpointNameBuffer[ComponentLength],
                        "                ",
                        NETBIOS_NAME_LEN - ComponentLength);
       }

       FirstEndpointName  = EndpointNameBuffer;
    }
#endif

    // Copy the first endpoint name
    RtlCopyMemory(
        pTdiNetbiosExAddress->EndpointName,
        FirstEndpointName,
        NETBIOS_NAME_LEN);

#if 0
    // This will be activated alongwith the other code when mutual authentication is
    // in place
    if (!ServerNameIsInIpAddressForm) {
       // The same NETBIOS_EX address needs to be duplicated with a different endpoint name
       // for the second TA_ADDRESS.

       RtlCopyMemory(
            pSecondNetbiosExAddress,
            pFirstNetbiosExAddress,
            (FIELD_OFFSET(TA_ADDRESS,Address) + NetbiosExAddressLength));

       RtlCopyMemory(
            ((PCHAR)pSecondNetbiosExAddress +
             FIELD_OFFSET(TA_ADDRESS,Address) +
             FIELD_OFFSET(TDI_ADDRESS_NETBIOS_EX,EndpointName)),
            SecondEndpointName,
            NETBIOS_NAME_LEN);
    }
#else
    //ASSERT(pTransportAddress->TAAddressCount == 2);
#endif
    // The Netbios address associated with the first NETBIOS_EX address is the last netbios
    // address that is passed in.

    RtlCopyMemory(
         ((PCHAR)pNetbiosAddress),
         &NetbiosAddressLength,
         sizeof(USHORT));

    RtlCopyMemory(
         ((PCHAR)pNetbiosAddress + FIELD_OFFSET(TA_ADDRESS,AddressType)),
         &NetbiosAddressType,
         sizeof(USHORT));

    RtlCopyMemory(
         ((PCHAR)pNetbiosAddress + FIELD_OFFSET(TA_ADDRESS,Address)),
         &pTdiNetbiosExAddress->NetbiosAddress,
         NetbiosAddressLength);

    // Unicode Netbios name
    pNetbiosUnicodeExAddress = (PTA_ADDRESS)((PCHAR)pNetbiosAddress +
                                    FIELD_OFFSET(TA_ADDRESS,Address) +
                                    NetbiosAddressLength);

    pNetbiosUnicodeExAddress->AddressLength = (USHORT)(FIELD_OFFSET(TDI_ADDRESS_NETBIOS_UNICODE_EX,RemoteNameBuffer) +
                                              DNS_NAME_BUFFER_LENGTH * sizeof(WCHAR));
    pNetbiosUnicodeExAddress->AddressType   = TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX;
    
    pTdiNetbiosUnicodeExAddress = (PTDI_ADDRESS_NETBIOS_UNICODE_EX)pNetbiosUnicodeExAddress->Address;
    pTdiNetbiosUnicodeExAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE;
    pTdiNetbiosUnicodeExAddress->NameBufferType = NBT_READWRITE;

    pTdiNetbiosUnicodeExAddress->EndpointName.Length = (NETBIOS_NAME_LEN)*sizeof(WCHAR);
    pTdiNetbiosUnicodeExAddress->EndpointName.MaximumLength = (NETBIOS_NAME_LEN+1)*sizeof(WCHAR);
    pTdiNetbiosUnicodeExAddress->EndpointName.Buffer = (PWSTR)pTdiNetbiosUnicodeExAddress->EndpointBuffer;

    pTdiNetbiosUnicodeExAddress->RemoteName.Length = pServerName->Length;
    pTdiNetbiosUnicodeExAddress->RemoteName.MaximumLength = DNS_NAME_BUFFER_LENGTH*sizeof(WCHAR);
    pTdiNetbiosUnicodeExAddress->RemoteName.Buffer = (PWSTR)pTdiNetbiosUnicodeExAddress->RemoteNameBuffer;

    if (pTdiNetbiosUnicodeExAddress->RemoteName.MaximumLength > pServerName->Length) {
        ComponentLength = pServerName->Length;
    } else {
        ComponentLength = pTdiNetbiosUnicodeExAddress->RemoteName.MaximumLength;
    }

    RtlCopyMemory(
          pTdiNetbiosUnicodeExAddress->RemoteNameBuffer,
          pServerName->Buffer,
          ComponentLength);
    
    if (ServerNameIsInIpAddressForm) {
        RtlCopyMemory(
              pTdiNetbiosUnicodeExAddress->EndpointBuffer,
              SMBSERVER_LOCAL_ENDPOINT_NAME_UNICODE,
              NETBIOS_NAME_LEN);
    } else {
        // Scan the server name till the first delimiter (DNS delimiter .) and form
        // the endpoint name by padding the remaining name with blanks.
        
        RtlCopyMemory(
             pTdiNetbiosUnicodeExAddress->EndpointBuffer,
             L"                ",
             NETBIOS_NAME_LEN*sizeof(WCHAR));
      
        if (pTdiNetbiosUnicodeExAddress->EndpointName.Length > pServerName->Length) {
            ComponentLength = pServerName->Length;
        } else {
            ComponentLength = pTdiNetbiosUnicodeExAddress->EndpointName.Length;
        }

        RtlCopyMemory(
             pTdiNetbiosUnicodeExAddress->EndpointBuffer,
             pServerName->Buffer,
             ComponentLength);

        ComponentLength = 0;
        while (ComponentLength < NETBIOS_NAME_LEN) {
           if (pTdiNetbiosUnicodeExAddress->EndpointBuffer[ComponentLength] == L'.') {
              break;
           }
           ComponentLength++;
        }

        if (ComponentLength == NETBIOS_NAME_LEN) {
           pTdiNetbiosUnicodeExAddress->EndpointBuffer[NETBIOS_NAME_LEN - 1] = ' ';
        } else {
           RtlCopyMemory(&pTdiNetbiosUnicodeExAddress->EndpointBuffer[ComponentLength],
                        L"                ",
                        (NETBIOS_NAME_LEN-ComponentLength)*sizeof(WCHAR));
        }
    }

    //DbgPrint("Build TA %lx %lx %lx\n",pFirstNetbiosExAddress,pNetbiosAddress,pNetbiosUnicodeExAddress);
    
    return STATUS_SUCCESS;
}

typedef struct _SMBCE_VC_CONNECTION_COMPLETION_CONTEXT {
    RXCE_CONNECTION_COMPLETION_CONTEXT;

    PSMBCE_TRANSPORT_ARRAY     pTransportArray;
    PSMBCE_TRANSPORT           pTransport;
    PSMBCE_SERVER_VC_TRANSPORT pServerTransport;

    ULONG                   TransportAddressLength;
    PTRANSPORT_ADDRESS      pTransportAddress;

    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext;
} SMBCE_VC_CONNECTION_COMPLETION_CONTEXT,
  *PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT;

NTSTATUS
VctpCreateConnectionCallback(
    IN OUT PRXCE_CONNECTION_COMPLETION_CONTEXT pContext)
/*++

Routine Description:

    This is the connection callback routine initiated when the underlying
    transports have completed initialization

Arguments:

    pCOntext = the connection completion context

Notes:

--*/
{
    NTSTATUS Status;

    PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT      pVcCompletionContext;
    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pSmbCeContext;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    pVcCompletionContext = (PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT)pContext;
    pSmbCeContext        = pVcCompletionContext->pContext;

    pServerEntry = pSmbCeContext->pServerEntry;

    pSmbCeContext->Status = pVcCompletionContext->Status;

    Status = pVcCompletionContext->Status;

    if (Status == STATUS_SUCCESS) {
        PTA_ADDRESS pTaAdress;
        PTRANSPORT_ADDRESS pTransportAddress = (PTRANSPORT_ADDRESS)pVcCompletionContext->pConnectionInformation->RemoteAddress;
        LONG NoOfAddress;

        if (pVcCompletionContext->pTransport == NULL) {
            pVcCompletionContext->pTransport =
                pVcCompletionContext->pTransportArray->SmbCeTransports[
                    pVcCompletionContext->AddressIndex];

            SmbCeReferenceTransport(pVcCompletionContext->pTransport);
        }
        
        //DbgPrint("Remote address %lx \n",pVcCompletionContext->pConnectionInformation->RemoteAddress);

        //DbgPrint("Number of TA returned %d %lx\n",pTransportAddress->TAAddressCount,pTransportAddress->Address);
        pTaAdress = &pTransportAddress->Address[0];

        for (NoOfAddress=0; NoOfAddress<pTransportAddress->TAAddressCount;NoOfAddress++) {
            if (pTaAdress->AddressType == TDI_ADDRESS_TYPE_NETBIOS_UNICODE_EX) {
                PTDI_ADDRESS_NETBIOS_UNICODE_EX pTdiNetbiosUnicodeExAddress;

                pTdiNetbiosUnicodeExAddress = (PTDI_ADDRESS_NETBIOS_UNICODE_EX)pTaAdress->Address;
                pTdiNetbiosUnicodeExAddress->EndpointName.Buffer = (PWSTR)pTdiNetbiosUnicodeExAddress->EndpointBuffer;
                pTdiNetbiosUnicodeExAddress->RemoteName.Buffer = (PWSTR)pTdiNetbiosUnicodeExAddress->RemoteNameBuffer;
                
                SmbCeAcquireResource();
                if (pTdiNetbiosUnicodeExAddress->NameBufferType == NBT_WRITTEN) {
                    //DbgPrint("DNS name was returned from NetBT %wZ\n", &pTdiNetbiosUnicodeExAddress->RemoteName);

                    DWORD dwNewSize = pTdiNetbiosUnicodeExAddress->RemoteName.Length+2*sizeof(WCHAR);

                    // if old allocation is to small get rid of it
                    if(pServerEntry->DnsName.Buffer != NULL && 
                       dwNewSize > pServerEntry->DnsName.MaximumLength) {
                        RxFreePool(pServerEntry->DnsName.Buffer);
                        pServerEntry->DnsName.Buffer = NULL;
                    }

                    // make new allocation (if we don't already have one)
                    if(pServerEntry->DnsName.Buffer == NULL) {
                        pServerEntry->DnsName.Buffer = RxAllocatePoolWithTag(NonPagedPool, dwNewSize, MRXSMB_SERVER_POOLTAG);
                    }

                    if (pServerEntry->DnsName.Buffer != NULL) {
                        pServerEntry->DnsName.Length = pTdiNetbiosUnicodeExAddress->RemoteName.Length;
                        pServerEntry->DnsName.MaximumLength = pServerEntry->DnsName.Length+2*sizeof(WCHAR);

                        RtlCopyMemory(pServerEntry->DnsName.Buffer,
                                      pTdiNetbiosUnicodeExAddress->RemoteNameBuffer,
                                      pServerEntry->DnsName.Length);

                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                } else {
                    //DbgPrint("DNS name was not returned from NetBT for %wZ\n", &pTdiNetbiosUnicodeExAddress->RemoteName);
                    if(pServerEntry->DnsName.Buffer != NULL) {
                        RxFreePool(pServerEntry->DnsName.Buffer);
                        pServerEntry->DnsName.Buffer = NULL;
                    }
                }
                SmbCeReleaseResource();

                break;
            } else {
                //DbgPrint("TA %lx is not a NETBIOS_UNICODE_EX\n", pTaAdress);
                pTaAdress = (PTA_ADDRESS)((PCHAR)pTaAdress +
                                FIELD_OFFSET(TA_ADDRESS,Address) +
                                pTaAdress->AddressLength);
            }
        }
        
        if (Status == STATUS_SUCCESS) {
            // The Server IP address is not known. Query the underlying
            // transport for the remote transport address, i.e., NETBIOS
            // name or IP address. This will be subsequently used to
            // determine the VC number to be used in session setup and X for
            // downlevel servers.

            Status = RxCeQueryInformation(
                        pVcCompletionContext->pVc,
                        RxCeRemoteAddressInformation,
                        pVcCompletionContext->pTransportAddress,
                        pVcCompletionContext->TransportAddressLength);
        }

        if (Status == STATUS_SUCCESS) {
            ULONG   NumberOfAddresses;
            USHORT  AddressLength;
            USHORT  AddressType;
            PBYTE   pBuffer = (PBYTE)pVcCompletionContext->pTransportAddress;
            
            // All Transports currently return a data structure in which
            // the first four bytes are a ULONG which encodes the number
            // of connections opened to the given remote address. The
            // actual Transport address follows.
            pBuffer += sizeof(ULONG);

            // The buffer contains a TRANSPORT_ADDRESS, the first field
            // of which is the count.
            NumberOfAddresses = SmbGetUlong(pBuffer);

            // This is followed by an array of variable length TA_ADDRESS
            // structures. At this point pBuffer points to the first
            // TA_ADDRESS.
            pBuffer += sizeof(ULONG);

            while (NumberOfAddresses-- > 0) {
                AddressLength = SmbGetUshort(pBuffer);
                pBuffer += sizeof(USHORT);

                AddressType = SmbGetUshort(pBuffer);

                if (AddressType != TDI_ADDRESS_TYPE_IP) {
                    // skip to the next TA_ADDRESS
                    pBuffer += AddressLength + sizeof(USHORT);
                } else {
                    // Skip past the type field to position at the
                    // corresponding TDI_ADDRESS_IP structure
                    pBuffer += sizeof(USHORT);

                    // skip to the in_addr field
                    pBuffer += FIELD_OFFSET(TDI_ADDRESS_IP,in_addr);

                    // Extract the IP address
                    RtlCopyMemory(
                        &pServerEntry->Server.IpAddress,
                        pBuffer,
                        sizeof(ULONG));

                    break;
                }
            }
        } else {
           RxDbgTrace(0, Dbg, ("Remote Address Query returned %lx\n",Status));
        }

        if (NT_SUCCESS(Status)) {
            Status = VctCompleteInitialization(
                         pServerEntry,                            // The server entry
                         pVcCompletionContext->pTransport,        // the transport/address information
                         pVcCompletionContext->pServerTransport); // the server transport instance
        }

        if (NT_SUCCESS(Status)) {
            pSmbCeContext->pTransport =
                (PSMBCE_SERVER_TRANSPORT)pVcCompletionContext->pServerTransport;
            pVcCompletionContext->pServerTransport = NULL;
            pVcCompletionContext->pTransport = NULL;
        }

        pSmbCeContext->Status = Status;
    } else {
        SmbLogError(Status,
                    LOG,
                    VctpCreateConnectionCallback,
                    LOGULONG(Status)
                    LOGPTR(pServerEntry)
                    LOGUSTR(pServerEntry->Name));
    }

    if (!NT_SUCCESS(Status)) {
        RxCeTearDownVC(pVcCompletionContext->pVc);
        RxCeTearDownConnection(pVcCompletionContext->pConnection);
        SmbCeDereferenceTransport(pVcCompletionContext->pTransport);
        pVcCompletionContext->pTransport = NULL;
    }

    if (pVcCompletionContext->pTransportArray != NULL) {
        SmbCeDereferenceTransportArray(pVcCompletionContext->pTransportArray);
    }

    if (pVcCompletionContext->pTransportAddress != NULL) {
        RxFreePool(pVcCompletionContext->pTransportAddress);
    }

    if (pVcCompletionContext->pConnectionInformation != NULL) {
        RxFreePool(pVcCompletionContext->pConnectionInformation);
    }

    ASSERT(pVcCompletionContext->pTransport == NULL);

    if (pVcCompletionContext->pServerTransport != NULL) {
        SmbMmFreeServerTransport(
            (PSMBCE_SERVER_TRANSPORT)pVcCompletionContext->pServerTransport);
    }

    RxFreePool(pVcCompletionContext);

    pSmbCeContext->State  = SmbCeServerVcTransportConstructionEnd;

    SmbCeConstructServerTransport(pSmbCeContext);
    return STATUS_SUCCESS;
}

NTSTATUS
VctInstantiateServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
/*++

Routine Description:

    This routine initializes the transport information corresponding to a server

Arguments:

    pContext - the transport construction context

Return Value:

    STATUS_PENDING - asynchronous construction has been initiated

Notes:

    Currently, only connection oriented transports are handled. The current TDI
    spec expects handles to be passed in as part of the connect request. This
    implies that connect/reconnect/disconnect requests need to be issued from the
    process which created the connection. In the case of the SMB mini rdr there
    is no FSP associated with it ( threads are borrowed/commandeered ) from the
    system process to do all the work. This is the reason for special casing VC
    initialization into a separate routine. The server transport initialization
    routine handles the other transport initialization and also provides the
    context for VC initialization.

--*/
{
    NTSTATUS Status = STATUS_PENDING;

    PSMBCE_TRANSPORT_ARRAY pTransportArray;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    pTransportArray   = SmbCeReferenceTransportArray();


    if (pTransportArray == NULL) {
        Status = STATUS_NETWORK_UNREACHABLE;
    } else {
        PSMBCEDB_SERVER_ENTRY  pServerEntry;
        UNICODE_STRING         ServerName;

        PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT pCompletionContext;
        PRXCE_CONNECTION_INFORMATION InitialConnectionInformation = NULL;

        ULONG ServerIpAddress;

        pServerEntry = pContext->pServerEntry;

        ServerName.Buffer        = pServerEntry->Name.Buffer + 1;
        ServerName.Length        = pServerEntry->Name.Length - sizeof(WCHAR);
        ServerName.MaximumLength = pServerEntry->Name.MaximumLength - sizeof(WCHAR);

        pServerEntry->Server.IpAddress = 0;

        pCompletionContext = (PSMBCE_VC_CONNECTION_COMPLETION_CONTEXT)
                             RxAllocatePoolWithTag(
                                 NonPagedPool,
                                 sizeof(SMBCE_VC_CONNECTION_COMPLETION_CONTEXT),
                                 MRXSMB_VC_POOLTAG);

        if (pCompletionContext != NULL) {
            RtlZeroMemory(pCompletionContext,sizeof(SMBCE_VC_CONNECTION_COMPLETION_CONTEXT));
            
            pCompletionContext->pContext = pContext;

            pCompletionContext->TransportAddressLength = VctComputeTransportAddressSize(
                                                             &ServerName);

            pCompletionContext->pTransportAddress = (PTRANSPORT_ADDRESS)
                                                    RxAllocatePoolWithTag(
                                                        NonPagedPool,
                                                        pCompletionContext->TransportAddressLength,
                                                        MRXSMB_VC_POOLTAG);

            if (pCompletionContext->pTransportAddress == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {
                RtlZeroMemory(pCompletionContext->pTransportAddress,
                              pCompletionContext->TransportAddressLength);

                Status = VctBuildTransportAddress(
                             pCompletionContext->pTransportAddress,
                             pCompletionContext->TransportAddressLength,
                             &ServerName,
                             &ServerIpAddress);
            }

            if (Status == STATUS_SUCCESS) {
                pCompletionContext->pServerTransport = (PSMBCE_SERVER_VC_TRANSPORT)
                                                       SmbMmAllocateServerTransport(
                                                           SMBCE_STT_VC);

                if (pCompletionContext->pServerTransport == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    pCompletionContext->pConnection =
                        &(pCompletionContext->pServerTransport->RxCeConnection);
                    pCompletionContext->pVc =
                        &(pCompletionContext->pServerTransport->Vcs[0].RxCeVc);
                }
            }

            if (Status == STATUS_SUCCESS) {
                InitialConnectionInformation = RxAllocatePoolWithTag(
                                                   NonPagedPool,
                                                   sizeof(RXCE_CONNECTION_INFORMATION),
                                                   MRXSMB_VC_POOLTAG);

                if (InitialConnectionInformation == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    InitialConnectionInformation->UserDataLength = 0;
                    InitialConnectionInformation->OptionsLength  = 0;
                    InitialConnectionInformation->RemoteAddressLength = pCompletionContext->TransportAddressLength;
                    InitialConnectionInformation->RemoteAddress = pCompletionContext->pTransportAddress;
                }
            }

            if (Status == STATUS_SUCCESS) {
                PSMBCE_TRANSPORT        pTransport;
                
                pCompletionContext->pTransport = NULL;
                pCompletionContext->pTransportArray   = pTransportArray;
                pCompletionContext->pConnectionInformation = InitialConnectionInformation;
                //DbgPrint("Remote address %lx \n",pCompletionContext->pConnectionInformation->RemoteAddress);

                if (pServerEntry->PreferredTransport != NULL) {
                    pTransport = pServerEntry->PreferredTransport;

                    Status = RxCeBuildConnection(
                                 &pTransport->RxCeAddress,
                                 InitialConnectionInformation,
                                 &MRxSmbVctConnectionEventHandler,
                                 pServerEntry,
                                 pCompletionContext->pConnection,
                                 pCompletionContext->pVc);

                    if (Status == STATUS_SUCCESS) {
                        pCompletionContext->pTransport = pTransport;
                        SmbCeReferenceTransport(pTransport);
                    }

                    ASSERT(Status != STATUS_PENDING);

                    if (Status != STATUS_SUCCESS) {
                        SmbCeDereferenceTransport(pServerEntry->PreferredTransport);
                        pServerEntry->PreferredTransport = NULL;
                    }

                    pCompletionContext->Status = Status;

                    VctpCreateConnectionCallback(
                        (PRXCE_CONNECTION_COMPLETION_CONTEXT)pCompletionContext);

                    Status = STATUS_PENDING;
                } else {

                    Status = RxCeBuildConnectionOverMultipleTransports(
                                 MRxSmbDeviceObject,
                                 MRxSmbObeyBindingOrder ?
                                    RxCeSelectBestSuccessfulTransport :
                                    RxCeSelectFirstSuccessfulTransport,

                                 pCompletionContext->pTransportArray->Count,
                                 pCompletionContext->pTransportArray->LocalAddresses,
                                 &ServerName,
                                 InitialConnectionInformation,
                                 &MRxSmbVctConnectionEventHandler,
                                 pServerEntry,
                                 VctpCreateConnectionCallback,
                                 (PRXCE_CONNECTION_COMPLETION_CONTEXT)pCompletionContext);

//                    ASSERT(Status == STATUS_PENDING);
                }
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (Status != STATUS_PENDING) {
            if (pCompletionContext != NULL) {
                if (pCompletionContext->pTransportAddress != NULL) {
                    RxFreePool(pCompletionContext->pTransportAddress);
                }

                if (pCompletionContext->pServerTransport != NULL) {
                    RxFreePool(pCompletionContext->pServerTransport);
                }
                
                RxFreePool(pCompletionContext);
            }

            if (InitialConnectionInformation != NULL) {
                RxFreePool(InitialConnectionInformation);
            }

            SmbCeDereferenceTransportArray(pTransportArray);
        }
    }

    if (Status != STATUS_PENDING) {
        ASSERT(Status != STATUS_SUCCESS);

        pContext->State  = SmbCeServerVcTransportConstructionEnd;
        pContext->Status = Status;

        // Call the construct server transport routine to complete the construction
        SmbCeConstructServerTransport(pContext);

        Status = STATUS_PENDING;
    }

    return Status;
}

NTSTATUS
VctTearDownServerTransport(
   PSMBCE_SERVER_TRANSPORT pServerTransport)
{
    NTSTATUS Status;
    PKEVENT pRundownEvent = pServerTransport->pRundownEvent;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    Status = VctUninitialize(pServerTransport);

    if (pRundownEvent != NULL) {
        KeSetEvent(pRundownEvent, 0, FALSE );
    }

    return Status;
}

NTSTATUS
VctInitiateDisconnect(
    PSMBCE_SERVER_TRANSPORT pServerTransport)
{
    ULONG                      VcIndex;
    PSMBCE_VC                  pVc;
    PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pServerTransport;

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    for (VcIndex = 0; VcIndex < pVcTransport->MaximumNumberOfVCs; VcIndex++) {
        NTSTATUS Status;

        pVc = &pVcTransport->Vcs[VcIndex];

        Status = RxCeInitiateVCDisconnect(&pVc->RxCeVc);

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(0, Dbg, ("VctInitiateDisconnect: Disconnected Status %lxd\n",Status));
        }
    }

    return STATUS_SUCCESS;
}

PFILE_OBJECT
SmbCepReferenceEndpointFileObject(
    PSMBCE_SERVER_TRANSPORT pTransport)
/*++

Routine Description:

    This routine returns the connection file object associated with
    a transport

Arguments:

    pTransport - the transport instance

Notes:

    This routine currently returns this for VC transports. When we implement
    other transports a suitable abstraction needs to be implemented

--*/
{
    PFILE_OBJECT         pEndpointFileObject =  NULL;
    PSMBCE_OBJECT_HEADER pHeader = (PSMBCE_OBJECT_HEADER)pTransport;

    if ((pHeader != NULL) && (pHeader->ObjectType == SMBCE_STT_VC)) {
        PSMBCE_SERVER_VC_TRANSPORT pVcTransport = (PSMBCE_SERVER_VC_TRANSPORT)pTransport;

        pEndpointFileObject = pVcTransport->Vcs[0].RxCeVc.pEndpointFileObject;

        if (pEndpointFileObject != NULL) {
            ObReferenceObject(pEndpointFileObject);
        }

    }

    return pEndpointFileObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\transprt.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    transprt.h

Abstract:

    This module implements all transport related functions in the SMB connection
    engine

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995

Notes:


--*/

#ifndef _TRANSPRT_H_
#define _TRANSPRT_H_

// The SMBCE_TRANSPORT data structure encapsulates all the information w.r.t a
// particular transport for the connection engine. All the transports that are
// of interest to the SMB mini redirector are maintained in a doubly linked list
//
// The connection engine tries all the transports in this list when trying to
// establish a connection to a server. Currently only connection oriented
// transports are handled.

typedef struct _SMBCE_TRANSPORT_ {
   SMBCE_OBJECT_HEADER;

   RXCE_TRANSPORT   RxCeTransport;
   RXCE_ADDRESS     RxCeAddress;

   ULONG            Priority;       // the priority in the binding list.

   BOOLEAN          Active;

   // Additional information regarding quality of service and other selection
   // criterion for a transport will be included here.

} SMBCE_TRANSPORT, *PSMBCE_TRANSPORT;

typedef struct _SMBCE_TRANSPORT_ARRAY_ {
    ULONG               ReferenceCount;
    ULONG               Count;
    PSMBCE_TRANSPORT    *SmbCeTransports;
    PRXCE_ADDRESS       *LocalAddresses;
} SMBCE_TRANSPORT_ARRAY, *PSMBCE_TRANSPORT_ARRAY;


typedef struct _SMBCE_TRANSPORTS_ {
   RX_SPIN_LOCK             Lock;
   PSMBCE_TRANSPORT_ARRAY   pTransportArray;
} SMBCE_TRANSPORTS, *PSMBCE_TRANSPORTS;

extern SMBCE_TRANSPORTS MRxSmbTransports;


// Transport entries are added to the list of known transports upon receipt of
// PnP notifications. Currently the list is static since transport disabling
// notifications are not handled by the underlying TDI/PnP layer.
// The following routines provide the ability for adding/deleting entries to
// this list.

extern
PSMBCE_TRANSPORT_ARRAY
SmbCeReferenceTransportArray(VOID);

extern NTSTATUS
SmbCeDereferenceTransportArray(PSMBCE_TRANSPORT_ARRAY pTransportArray);

extern NTSTATUS
SmbCeAddTransport(PSMBCE_TRANSPORT pTransport);

extern NTSTATUS
SmbCeRemoveTransport(PSMBCE_TRANSPORT pTransport);

#define SmbCeGetAvailableTransportCount()   \
        (MRxSmbTransports.Count)

// The connection engine maintains a reference count associated with each transport
// which indicates the number of servers that are using the transport. This will
// eventually provide the mechanism for disabling/enabling transport on receipt
// of PnP notifications.

#define SmbCeReferenceTransport(pTransport)                                   \
        SmbCepReferenceTransport(pTransport)

#define SmbCeDereferenceTransport(pTransport)                                 \
        SmbCepDereferenceTransport(pTransport)

// The server transport types encapsulate the various usages of the underlying
// transport to communicate with a server. For example the type of interactions
// with a mailslot server ( primarily datagrams ) is very different from the
// interactions with a FILE SERVER ( connection oriented send/receives). The
// type of interactions can be further classified by the underlying connection
// characterstics, e.g., connecting to a FILE_SERVER over a RAS connection as
// opposed to connecting to a file server over EtherNet.
//
// The interactions are currently classified into four types, MAILSOT, Virtual
// Circuit, Datagram and Htbrid ( VC + Datagram ).
//
// The type chosen will depend upon the characterstics of the available
// connection. Each type is associated with its own dispatch vector which
// encapsulates the interaction between the connection engine and the transport.
//
// This includes Send,Receive, Receive Ind. etc. These are modelled after the
// TDI interfaces.


typedef enum _SMBCE_SERVER_TRANSPORT_TYPE_ {
    SMBCE_STT_MAILSLOT = 1,
    SMBCE_STT_VC       = 2,
    SMBCE_STT_DATAGRAM = 4,
    SMBCE_STT_HYBRID   = 8
} SMBCE_SERVER_TRANSPORT_TYPE, *PSMBCE_SERVER_TRANSPORT_TYPE;

typedef struct SMBCE_SERVER_TRANSPORT {
   SMBCE_OBJECT_HEADER;

   struct TRANSPORT_DISPATCH_VECTOR *pDispatchVector;
   struct _SMBCE_TRANSPORT_         *pTransport;

   PKEVENT                          pRundownEvent;      // used for finalization.

   ULONG                            MaximumSendSize;    // max data size
} SMBCE_SERVER_TRANSPORT, *PSMBCE_SERVER_TRANSPORT;

// The SMBCE_SERVER_TRANSPORT instances are reference counted. The following
// routines provide the referencing mechanism. Defining them as macros also
// provides us with a easy debugging capability, i.e., it can be easily modified
// to include a FILE/LINE number each time an instance is referenced and
// dereferenced

#define SmbCeReferenceServerTransport(pServerTransportPointer)                    \
        SmbCepReferenceServerTransport(pServerTransportPointer)

#define SmbCeDereferenceServerTransport(pServerTransportPointer)           \
        SmbCepDereferenceServerTransport(pServerTransportPointer)

// The server transport establishment mechanism requires a callback mechanism
// to handle the asynchronous connection establishment cases.

typedef
VOID
(*PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CALLBACK)(
    PVOID   pContext);

typedef
VOID
(*PSMBCE_SERVER_TRANSPORT_DESTRUCTION_CALLBACK)(
    PVOID   pContext);

typedef enum _SMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE {
    SmbCeServerTransportConstructionBegin,
    SmbCeServerMailSlotTransportConstructionBegin,
    SmbCeServerMailSlotTransportConstructionEnd,
    SmbCeServerVcTransportConstructionBegin,
    SmbCeServerVcTransportConstructionEnd,
    SmbCeServerTransportConstructionEnd
} SMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE,
  *PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE;

typedef struct _SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT {
    NTSTATUS                      Status;

    SMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE State;

    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CALLBACK pCompletionRoutine;
    PMRX_SRVCALL_CALLBACK_CONTEXT                 pCallbackContext;

    PKEVENT                       pCompletionEvent;

    PSMBCEDB_SERVER_ENTRY         pServerEntry;
    ULONG                         TransportsToBeConstructed;

    PSMBCE_SERVER_TRANSPORT pMailSlotTransport;
    PSMBCE_SERVER_TRANSPORT pTransport;

    RX_WORK_QUEUE_ITEM    WorkQueueItem;
} SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT,
  *PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT;

// The SERVER transport dispatch vector prototypes

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_SEND)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL                    pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_SEND_DATAGRAM)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SendOptions,
    PMDL              pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_TRANCEIVE)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange,
    ULONG                   SendOptions,
    PMDL              pSmbMdl,
    ULONG                   SendLength,
    PVOID                   pSendCompletionContext);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_RECEIVE)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    PSMB_EXCHANGE           pExchange);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_INITIALIZE_EXCHANGE)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE         pExchange);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_UNINITIALIZE_EXCHANGE)(
    PSMBCE_SERVER_TRANSPORT pTransport,
    PSMB_EXCHANGE         pExchange);

typedef
VOID
(*PTRANSPORT_DISPATCH_TEARDOWN)(
    PSMBCE_SERVER_TRANSPORT    pTransport);

typedef
NTSTATUS
(*PTRANSPORT_DISPATCH_INITIATE_DISCONNECT)(
    PSMBCE_SERVER_TRANSPORT    pTransport);

typedef struct TRANSPORT_DISPATCH_VECTOR {
   PTRANSPORT_DISPATCH_SEND                  Send;
   PTRANSPORT_DISPATCH_SEND_DATAGRAM         SendDatagram;
   PTRANSPORT_DISPATCH_TRANCEIVE             Tranceive;
   PTRANSPORT_DISPATCH_RECEIVE               Receive;
   PRX_WORKERTHREAD_ROUTINE                  TimerEventHandler;
   PTRANSPORT_DISPATCH_INITIALIZE_EXCHANGE   InitializeExchange;
   PTRANSPORT_DISPATCH_UNINITIALIZE_EXCHANGE UninitializeExchange;
   PTRANSPORT_DISPATCH_TEARDOWN              TearDown;
   PTRANSPORT_DISPATCH_INITIATE_DISCONNECT   InitiateDisconnect;
} TRANSPORT_DISPATCH_VECTOR, *PTRANSPORT_DISPATCH_VECTOR;

// A macro for invoking a routine through the SMBCE_SERVER_TRANSPORT
// dispatch vector.

#define SMBCE_TRANSPORT_DISPATCH(pServerEntry,Routine,Arguments)        \
      (*((pServerEntry)->pTransport->pDispatchVector->Routine))##Arguments

// The currently known transport type dispatch vectors and the mechanisms
// for instanting an instance.

extern TRANSPORT_DISPATCH_VECTOR MRxSmbVctTransportDispatch;
extern TRANSPORT_DISPATCH_VECTOR MRxSmbMsTransportDispatch;

extern NTSTATUS
MsInstantiateServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext);

extern NTSTATUS
VctInstantiateServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext);

extern VOID
SmbCeConstructServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext);

// The following routines constitute the interface by which the clients of
// the connection engine initialize/send/receive/uninitialize data to the
// remote servers

extern NTSTATUS
SmbCeInitializeExchangeTransport(
    PSMB_EXCHANGE         pExchange);

extern NTSTATUS
SmbCeUninitializeExchangeTransport(
    PSMB_EXCHANGE         pExchange);

extern NTSTATUS
SmbCeInitiateDisconnect(
    IN OUT PSMBCEDB_SERVER_ENTRY pServerEntry);


// The routines for constructing the transports provide the flexibility to
// construct certain combination of transports. This is provided by the
// SmbCepInitializeServerTransport routine and the different flavours of
// construction routines provided

#define SMBCE_CONSTRUCT_ALL_TRANSPORTS \
            (SMBCE_STT_MAILSLOT | SMBCE_STT_VC)

extern NTSTATUS
SmbCepInitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY                         pServerEntry,
    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CALLBACK pCallbackRoutine,
    PMRX_SRVCALL_CALLBACK_CONTEXT                 pCallbackContext,
    ULONG                                         TransportsToBeConsstructed);


#define SmbCeInitializeServerTransport(pServerEntry,pCallbackRoutine,pCallbackContext) \
        SmbCepInitializeServerTransport(                                               \
            (pServerEntry),                                                            \
            (pCallbackRoutine),                                                        \
            (pCallbackContext),                                                        \
            SMBCE_CONSTRUCT_ALL_TRANSPORTS)

#define SmbCeInitializeServerMailSlotTransport(pServerEntry,pCallbackRoutine,pCallbackContext) \
        SmbCepInitializeServerTransport(                                               \
            (pServerEntry),                                                            \
            (pCallbackRoutine),                                                        \
            (pCallbackContext),                                                        \
            SMBCE_STT_MAILSLOT)


extern NTSTATUS
SmbCeUninitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY                        pServerEntry,
    PSMBCE_SERVER_TRANSPORT_DESTRUCTION_CALLBACK pCallbackRoutine,
    PVOID                                        pCallbackContext);

extern VOID
SmbCeCompleteUninitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY pServerEntry);

extern NTSTATUS
SmbCepReferenceTransport(
    IN OUT PSMBCE_TRANSPORT pTransport);

extern NTSTATUS
SmbCepDereferenceTransport(
    IN OUT PSMBCE_TRANSPORT pTransport);

extern PSMBCE_TRANSPORT
SmbCeFindTransport(
    PUNICODE_STRING pTransportName);

extern NTSTATUS
SmbCepReferenceServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT *pTransportPointer);

extern NTSTATUS
SmbCepDereferenceServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT *pTransportPointer);

extern PFILE_OBJECT
SmbCepReferenceEndpointFileObject(
    IN PSMBCE_SERVER_TRANSPORT pTransport);

extern NTSTATUS
SmbCeSend(
    PSMB_EXCHANGE         pExchange,
    ULONG                 SendOptions,
    PMDL            pSmbMdl,
    ULONG                 SendLength);

extern NTSTATUS
SmbCeSendToServer(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    ULONG                 SendOptions,
    PMDL            pSmbMdl,
    ULONG                 SendLength);

extern NTSTATUS
SmbCeSendDatagram(
    PSMB_EXCHANGE         pExchange,
    ULONG                 SendOptions,
    PMDL            pSmbMdl,
    ULONG                 SendLength);

extern NTSTATUS
SmbCeTranceive(
    PSMB_EXCHANGE         pExchange,
    ULONG                 SendOptions,
    PMDL            pRxCeDataBuffer,
    ULONG                 SendLength);

extern NTSTATUS
SmbCeReceive(
    PSMB_EXCHANGE         pExchange);


//
// Call ups from the transport to the connection engine
//

extern NTSTATUS
SmbCeReceiveInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN ULONG                 BytesIndicated,
    IN ULONG                 BytesAvailable,
    OUT ULONG                *pBytesTaken,
    IN PVOID                 pTsdu,                  // pointer describing this TSDU, typically a lump of bytes
    OUT PMDL                 *pDataBufferPointer,    // the buffer in which data is to be copied.
    OUT PULONG               pDataBufferSize,        // amount of data to copy
    IN ULONG                 ReceiveFlags
    );

extern NTSTATUS
SmbCeDataReadyInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN PMDL            pBuffer,
    IN ULONG                 DataSize,
    IN NTSTATUS              DataReadyStatus
    );

extern NTSTATUS
SmbCeErrorInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN NTSTATUS              IndicatedStatus
    );

extern NTSTATUS
SmbCeSendCompleteInd(
    IN PSMBCEDB_SERVER_ENTRY pServerEntry,
    IN PVOID                 pCompletionContext,
    IN NTSTATUS              SendCompletionStatus
    );

extern VOID
MRxSmbLogTransportError(
    PUNICODE_STRING pTransportName,
    PUNICODE_STRING pDomainName,
    NTSTATUS        Status,
    ULONG           Id);


#endif // _TRANSPRT_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\transprt.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    transport.c

Abstract:

    This module implements all transport related functions in the SMB connection engine

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995
    Will Lees (wlees) 08-Sep-1997     Initialize MoTcp Device

Notes:


--*/

#include "precomp.h"
#include <nbtioctl.h>
#pragma hdrstop

#include "ntddbrow.h"
#include "tdikrnl.h"
#include "dfsfsctl.h"

NTSTATUS
SmbCeIsServerAvailable(
    PUNICODE_STRING Name
);

VOID
SmbCeServerIsUnavailable(
    PUNICODE_STRING Name,
    NTSTATUS Status
);

VOID
SmbCeDiscardUnavailableServerList( );

VOID
MRxSmbpOverrideBindingPriority(
    PUNICODE_STRING pTransportName,
    PULONG pPriority
    );

VOID
MRxSmbPnPBindingHandler(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  pTransportName,
    IN PWSTR            BindingList
    );

NTSTATUS
MRxSmbPnPPowerHandler(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
);

VOID
SmbMRxNotifyChangesToNetBt(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  DeviceName,
    IN PWSTR            MultiSZBindList
    );

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeFindTransport)
#pragma alloc_text(PAGE, SmbCepInitializeServerTransport)
#pragma alloc_text(PAGE, SmbCeInitializeExchangeTransport)
#pragma alloc_text(PAGE, SmbCeUninitializeExchangeTransport)
#pragma alloc_text(PAGE, SmbCepDereferenceTransport)
#pragma alloc_text(PAGE, MRxSmbpBindTransportCallback)
#pragma alloc_text(PAGE, MRxSmbpBindTransportWorkerThreadRoutine)
#pragma alloc_text(PAGE, MRxSmbBindTransportCallback)
#pragma alloc_text(PAGE, MRxSmbUnbindTransportCallback)
#pragma alloc_text(PAGE, MRxSmbRegisterForPnpNotifications)
#pragma alloc_text(PAGE, MRxSmbDeregisterForPnpNotifications)
#pragma alloc_text(PAGE, MRxSmbpBindTransportCallback)
#pragma alloc_text(PAGE, MRxSmbpBindTransportWorkerThreadRoutine)
#pragma alloc_text(PAGE, MRxSmbpUnbindTransportCallback)
#pragma alloc_text(PAGE, MRxSmbpOverrideBindingPriority)
#pragma alloc_text(PAGE, MRxSmbPnPBindingHandler)
#pragma alloc_text(PAGE, MRxSmbRegisterForPnpNotifications)
#pragma alloc_text(PAGE, MRxSmbDeregisterForPnpNotifications)
#pragma alloc_text(PAGE, SmbCePnpBindBrowser)
#pragma alloc_text(PAGE, SmbCeDereferenceTransportArray)
#pragma alloc_text(PAGE, SmbCeIsServerAvailable)
#pragma alloc_text(PAGE, SmbCeServerIsUnavailable)
#pragma alloc_text(PAGE, SmbCeDiscardUnavailableServerList)
#endif

SMBCE_TRANSPORTS MRxSmbTransports;

//
// The head of the list of servers that are currently unavailable
//
LIST_ENTRY UnavailableServerList = { &UnavailableServerList, &UnavailableServerList };

//
// Each entry in the UnavailableServerList is one of these:
//
typedef struct {
    LIST_ENTRY ListEntry;
    UNICODE_STRING Name;        // Name of server that is unavailable
    NTSTATUS Status;            // Status received when we tried to connect to it
    LARGE_INTEGER Time;         // Time when we last attempted to connect
} *PUNAVAILABLE_SERVER;

//
// Protects UnavailableServerList
//
ERESOURCE  UnavailableServerListResource = {0};

//
// Time (seconds) that we keep an entry in the UnavailableServerList.
// We will not retry a connection attempt to a server
//  for UNAVAILABLE_SERVER_TIME seconds
//
#define UNAVAILABLE_SERVER_TIME 10

RXDT_DefineCategory(TRANSPRT);
#define Dbg        (DEBUG_TRACE_TRANSPRT)

extern NTSTATUS
SmbCePnpBindBrowser(
    PUNICODE_STRING pTransportName,
    BOOLEAN         IsBind);


NTSTATUS
MRxSmbInitializeTransport()
/*++

Routine Description:

    This routine initializes the transport related data structures

Returns:

    STATUS_SUCCESS if the transport data structures was successfully initialized

Notes:

--*/
{
    KeInitializeSpinLock(&MRxSmbTransports.Lock);

    MRxSmbTransports.pTransportArray = NULL;

    ExInitializeResource( &UnavailableServerListResource );

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbUninitializeTransport()
/*++

Routine Description:

    This routine uninitializes the transport related data structures

Notes:

--*/
{
    PSMBCE_TRANSPORT pTransport;
    KIRQL            SavedIrql;
    ULONG            TransportCount = 0;
    PSMBCE_TRANSPORT_ARRAY pTransportArray = NULL;

    KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);

    if (MRxSmbTransports.pTransportArray != NULL) {
        pTransportArray = MRxSmbTransports.pTransportArray;
        MRxSmbTransports.pTransportArray = NULL;
    }

    KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

    if (pTransportArray != NULL) {
        SmbCeDereferenceTransportArray(pTransportArray);
    }

    SmbCeDiscardUnavailableServerList();

    ExDeleteResource( &UnavailableServerListResource );

    return STATUS_SUCCESS;
}


NTSTATUS
SmbCeAddTransport(
    PSMBCE_TRANSPORT pNewTransport)
/*++

Routine Description:

    This routine adds a new instance to the known list of transports

Parameters:

    pNewTransport -- the transport instance to be added

Notes:

--*/

{
    NTSTATUS                Status = STATUS_SUCCESS;
    KIRQL                   SavedIrql;

    LONG                    Count;
    PSMBCE_TRANSPORT_ARRAY  pNewTransportArray = NULL;
    PSMBCE_TRANSPORT_ARRAY  pOldTransportArray;
    PSMBCE_TRANSPORT        *pTransports = NULL;
    PRXCE_ADDRESS           *LocalAddresses = NULL;
    BOOLEAN                 SignalCscAgent = FALSE;

    SmbCeAcquireResource();

    pOldTransportArray = SmbCeReferenceTransportArray();

    if (pOldTransportArray != NULL)
        Count = pOldTransportArray->Count + 1;
    else
        Count = 1;

    pNewTransportArray = (PSMBCE_TRANSPORT_ARRAY)RxAllocatePoolWithTag(
                                NonPagedPool,
                                sizeof(SMBCE_TRANSPORT_ARRAY),
                                MRXSMB_TRANSPORT_POOLTAG);
    if (pNewTransportArray == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) {
        pTransports = (PSMBCE_TRANSPORT *)RxAllocatePoolWithTag(
                             NonPagedPool,
                             Count * sizeof(PSMBCE_TRANSPORT),
                             MRXSMB_TRANSPORT_POOLTAG);
        if (pTransports == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }


    if (Status == STATUS_SUCCESS) {
        LocalAddresses = (PRXCE_ADDRESS *)RxAllocatePoolWithTag(
                             NonPagedPool,
                             Count * sizeof(PRXCE_ADDRESS),
                             MRXSMB_TRANSPORT_POOLTAG);
        if (LocalAddresses == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (Status == STATUS_SUCCESS) {
        LONG  i;

        if (Count > 1) {
            PSMBCE_TRANSPORT *pOldTransports;

            pOldTransports = pOldTransportArray->SmbCeTransports;

            for (i=0;i<Count-1;i++) {
                if (pNewTransport->Priority < pOldTransports[i]->Priority) { // The lower number, the higher priority
                    break;
                }
                pTransports[i] = pOldTransports[i];
                LocalAddresses[i] = &pOldTransports[i]->RxCeAddress;
            }
            pTransports[i] = pNewTransport;
            LocalAddresses[i] = &pNewTransport->RxCeAddress;
            for (;i<Count-1;i++) {
                pTransports[i+1] = pOldTransports[i];
                LocalAddresses[i+1] = &pOldTransports[i]->RxCeAddress;
            }

        } else {
            pTransports[0] = pNewTransport;
            LocalAddresses[0] = &pNewTransport->RxCeAddress;
        }

        for(i=0;i<Count;i++)
            SmbCeReferenceTransport(pTransports[i]);

        pNewTransportArray->ReferenceCount = 1;
        pNewTransportArray->Count = Count;
        pNewTransportArray->SmbCeTransports = &pTransports[0];
        pNewTransportArray->LocalAddresses = &LocalAddresses[0];

        // signal the CSC agent if this is the first transport
        SignalCscAgent = (pNewTransportArray->Count == 1);

        KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);
        MRxSmbTransports.pTransportArray = pNewTransportArray;
        KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

        // Double dereferencing is necessary to ensure that
        // the old transport array is destroyed.

        SmbCeDereferenceTransportArray(pOldTransportArray);
    }

    SmbCeDereferenceTransportArray(pOldTransportArray);

    SmbCeReleaseResource();

    MRxSmbCscSignalNetStatus(TRUE, SignalCscAgent);

    if (Status != STATUS_SUCCESS) {
        if (pNewTransportArray != NULL) {
            RxFreePool(pNewTransportArray);
        }
        if (pTransports != NULL) {
            RxFreePool(pTransports);
        }
        if (LocalAddresses != NULL) {
            RxFreePool(LocalAddresses);
        }
    }

    SmbCeDiscardUnavailableServerList();

    return Status;
}

NTSTATUS
SmbCeRemoveTransport(
    PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine removes a transport from the list of known transports

Parameters:

    pTransport - the transport instance to be removed.

Notes:

--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    KIRQL                   SavedIrql;

    LONG                    Count;
    PSMBCE_TRANSPORT_ARRAY  pTransportArray = NULL;
    PSMBCE_TRANSPORT_ARRAY  pOldTransportArray = NULL;
    PSMBCE_TRANSPORT        *pTransports = NULL;
    PRXCE_ADDRESS           *pLocalAddresses = NULL;

    BOOLEAN                 SignalCscAgent = FALSE, fReportRemovalToCSC=FALSE;

    SmbCeAcquireResource();

    pOldTransportArray = SmbCeReferenceTransportArray();

    if (pOldTransportArray != NULL) {
        LONG                Index;
        BOOLEAN             Found = FALSE;
        PSMBCE_TRANSPORT    *pOldTransports;

        // Establish the fact that the given transport is part of the array.
        // if it is not then no further action is necessary

        pOldTransports = pOldTransportArray->SmbCeTransports;

        for (Index = 0; Index < (LONG)pOldTransportArray->Count; Index++) {
            if (pTransport == pOldTransports[Index]) {
                Found = TRUE;
            }
        }

        if (Found) {
            Count = pOldTransportArray->Count - 1;
            fReportRemovalToCSC = (pOldTransportArray->Count != 0);

            if (Count > 0) {


                pTransportArray = (PSMBCE_TRANSPORT_ARRAY)RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     sizeof(SMBCE_TRANSPORT_ARRAY),
                                     MRXSMB_TRANSPORT_POOLTAG);
                if (pTransportArray == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }

                if (Status == STATUS_SUCCESS) {
                    pTransports = (PSMBCE_TRANSPORT *)RxAllocatePoolWithTag(
                                     NonPagedPool,
                                     Count * sizeof(PSMBCE_TRANSPORT),
                                     MRXSMB_TRANSPORT_POOLTAG);
                    if (pTransports == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (Status == STATUS_SUCCESS) {
                    pLocalAddresses = (PRXCE_ADDRESS *)RxAllocatePoolWithTag(
                                         NonPagedPool,
                                         Count * sizeof(PRXCE_ADDRESS),
                                         MRXSMB_TRANSPORT_POOLTAG);
                    if (pLocalAddresses == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                if (Status == STATUS_SUCCESS) {
                    LONG i, j;

                    for (i=0, j=0;i<Count+1;i++) {
                        if (pTransport != pOldTransports[i]) {
                            pTransports[j] = pOldTransports[i];
                            pLocalAddresses[j] = &pOldTransports[i]->RxCeAddress;
                            j++;
                        }
                    }

                    for(i=0;i<Count;i++)
                        SmbCeReferenceTransport(pTransports[i]);

                    pTransportArray->ReferenceCount = 1;
                    pTransportArray->Count = Count;
                    pTransportArray->SmbCeTransports = &pTransports[0];
                    pTransportArray->LocalAddresses = &pLocalAddresses[0];
                }
            }

            if (Status == STATUS_SUCCESS) {
                // signal the CSC agent if this is the last transport
                SignalCscAgent = (pTransportArray == NULL);

                KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);
                MRxSmbTransports.pTransportArray = pTransportArray;
                KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

                // Double dereferencing is necessary to ensure that
                // the old transport array is destroyed.

                SmbCeDereferenceTransportArray(pOldTransportArray);
            } else {
                if (pTransportArray != NULL) {
                    RxFreePool(pTransportArray);
                }

                if (pTransports != NULL) {
                    RxFreePool(pTransports);
                }

                if (pLocalAddresses != NULL) {
                    RxFreePool(pLocalAddresses);
                }
            }
        }

        SmbCeDereferenceTransportArray(pOldTransportArray);
    }

    SmbCeReleaseResource();

    if (fReportRemovalToCSC)
    {
        MRxSmbCscSignalNetStatus(FALSE, SignalCscAgent);
    }

    SmbCeDiscardUnavailableServerList();

    return Status;
}


PSMBCE_TRANSPORT
SmbCeFindTransport(
    PUNICODE_STRING pTransportName)
/*++

Routine Description:

    This routine maps a transport name to the appropriate
    PSMBCE_TRANSPORT instance

Arguments:

    pTransportName - the transport name

Return Value:

    a valid PSMBCE_TRANSPORT if one exists otherwise NULL

Notes:

--*/
{
    KIRQL                   SavedIrql;
    PLIST_ENTRY             pEntry;
    PSMBCE_TRANSPORT        pTransport;
    BOOLEAN                 Found = FALSE;
    PSMBCE_TRANSPORT_ARRAY  pTransportArray;

    PAGED_CODE();

    pTransportArray = SmbCeReferenceTransportArray();

    if (pTransportArray == NULL) {
        RxDbgTrace(0, Dbg, ("SmbCeFindTransport : Transport not available.\n"));
        return NULL;
    }

    if (pTransportArray != NULL) {
        ULONG i;

        for (i=0;i<pTransportArray->Count;i++) {
            pTransport = pTransportArray->SmbCeTransports[i];

            if (RtlEqualUnicodeString(
                    &pTransport->RxCeTransport.Name,
                    pTransportName,
                    TRUE)) {
                SmbCeReferenceTransport(pTransport);
                Found = TRUE;
                break;
            }
        }
    }

    if (!Found) {
        pTransport = NULL;
    }

    SmbCeDereferenceTransportArray(pTransportArray);

    return pTransport;
}


VOID
SmbCepTearDownServerTransport(
    PSMBCEDB_SERVER_ENTRY   pServerEntry)
/*++

Routine Description:

    This routine uninitializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Notes:


--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SMBCEDB_SERVER_TYPE     ServerType   = SmbCeGetServerType(pServerEntry);

    BOOLEAN WaitForMailSlotTransportRundown = FALSE;
    BOOLEAN WaitForTransportRundown = FALSE;
    BOOLEAN TearDown = FALSE;

    SmbCeAcquireSpinLock();

    if (!pServerEntry->IsTransportDereferenced) {

        // ServerEntry takes only one reference count of transport, which should only be
        // dereferenced once when it comes to tear down transport. Multiple dereference called
        // from construct server transport and PNP unbind transport needs to be prevented.
        pServerEntry->IsTransportDereferenced = TRUE;
        TearDown = TRUE;

        KeInitializeEvent(&pServerEntry->MailSlotTransportRundownEvent,NotificationEvent,FALSE);
        KeInitializeEvent(&pServerEntry->TransportRundownEvent,NotificationEvent,FALSE);

        if (pServerEntry->pTransport != NULL) {
            pServerEntry->pTransport->State = SMBCEDB_MARKED_FOR_DELETION;
            pServerEntry->pTransport->pRundownEvent = &pServerEntry->TransportRundownEvent;

            WaitForTransportRundown = TRUE;
        }

        if (pServerEntry->pMailSlotTransport != NULL) {
            pServerEntry->pMailSlotTransport->State = SMBCEDB_MARKED_FOR_DELETION;
            pServerEntry->pMailSlotTransport->pRundownEvent = &pServerEntry->MailSlotTransportRundownEvent;

            WaitForMailSlotTransportRundown = TRUE;
        }
    } else {
        if (pServerEntry->pTransport != NULL) {
            WaitForTransportRundown = TRUE;
        }

        if (pServerEntry->pMailSlotTransport != NULL) {
            WaitForMailSlotTransportRundown = TRUE;
        }
    }

    SmbCeReleaseSpinLock();

    if (TearDown) {
        if (pServerEntry->pTransport != NULL) {
            SmbCeDereferenceServerTransport(&pServerEntry->pTransport);
        }

        if (pServerEntry->pMailSlotTransport != NULL) {
            SmbCeDereferenceServerTransport(&pServerEntry->pMailSlotTransport);
        }
    }

    if (WaitForTransportRundown) {
        KeWaitForSingleObject(
            &pServerEntry->TransportRundownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL );
    }

    if (WaitForMailSlotTransportRundown) {
        KeWaitForSingleObject(
            &pServerEntry->MailSlotTransportRundownEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL );
    }
}

VOID
SmbCeTearDownServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
/*++

Routine Description:

    This routine tears down the server transport instance

Arguments:

    pContext - the server transport construction context

Notes:


--*/
{
    SmbCepTearDownServerTransport(pContext->pServerEntry);

    if (pContext->pCompletionEvent != NULL) {
        ASSERT(pContext->pCallbackContext == NULL);
        ASSERT(pContext->pCompletionRoutine == NULL);
        KeSetEvent(
            pContext->pCompletionEvent,
            0,
            FALSE );
    } else if (pContext->pCallbackContext != NULL) {
        ASSERT(pContext->pCompletionEvent == NULL);
        (pContext->pCompletionRoutine)(pContext->pCallbackContext);
    }

    RxFreePool(pContext);
}

VOID
SmbCepUpdateTransportConstructionState(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
{
    SMBCE_SERVER_TRANSPORT_CONSTRUCTION_STATE State;

    if (pContext->Status == STATUS_SUCCESS) {
        if (pContext->TransportsToBeConstructed & SMBCE_STT_MAILSLOT) {
            pContext->TransportsToBeConstructed &= ~SMBCE_STT_MAILSLOT;
            State = SmbCeServerMailSlotTransportConstructionBegin;
        } else if (pContext->TransportsToBeConstructed & SMBCE_STT_VC) {
            pContext->TransportsToBeConstructed &= ~SMBCE_STT_VC;
            State = SmbCeServerVcTransportConstructionBegin;
        } else {
            State = SmbCeServerTransportConstructionEnd;
        }
    } else {
        State = SmbCeServerTransportConstructionEnd;
    }

    pContext->State = State;
}

VOID
SmbCeConstructServerTransport(
    IN OUT PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext)
/*++

Routine Description:

    This routine constructs the server transport instance

Arguments:

    pContext - the server transport construction context

Notes:


--*/
{
    NTSTATUS               Status;
    PSMBCEDB_SERVER_ENTRY  pServerEntry;
    SMBCEDB_SERVER_TYPE    ServerType;

    BOOLEAN  ContinueConstruction = TRUE;
    BOOLEAN  UpdateUnavailableServerlist = TRUE;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    pServerEntry = pContext->pServerEntry;
    ServerType   = SmbCeGetServerType(pServerEntry);

    do {
        switch (pContext->State) {
        case  SmbCeServerTransportConstructionBegin :
            {
                if ((pServerEntry->pTransport != NULL) ||
                    (pServerEntry->pMailSlotTransport != NULL)) {
                    SmbCepTearDownServerTransport(pServerEntry);
                }

                ASSERT((pServerEntry->pTransport == NULL) &&
                       (pServerEntry->pMailSlotTransport == NULL));

                pContext->Status = STATUS_SUCCESS;

                // See if we have any reason to believe this server is unavailable
                pContext->Status = SmbCeIsServerAvailable( &pServerEntry->Name );

                if (pContext->Status != STATUS_SUCCESS) {
                    UpdateUnavailableServerlist = FALSE;
                }

                SmbCepUpdateTransportConstructionState(pContext);
            }
            break;

        case SmbCeServerMailSlotTransportConstructionBegin:
            {
                Status = MsInstantiateServerTransport(
                            pContext);

                if (Status == STATUS_PENDING) {
                    ContinueConstruction = FALSE;
                    break;
                }

                ASSERT(pContext->State == SmbCeServerMailSlotTransportConstructionEnd);
            }
            // lack of break intentional

        case SmbCeServerMailSlotTransportConstructionEnd:
            {
                SmbCepUpdateTransportConstructionState(pContext);
            }
            break;

        case SmbCeServerVcTransportConstructionBegin:
            {
                Status = VctInstantiateServerTransport(
                            pContext);

                if (Status == STATUS_PENDING) {
                    ContinueConstruction = FALSE;
                    break;
                }

                ASSERT(pContext->State == SmbCeServerVcTransportConstructionEnd);
            }
            // lack of break intentional

        case SmbCeServerVcTransportConstructionEnd:
            {
                SmbCepUpdateTransportConstructionState(pContext);
            }
            break;

        case SmbCeServerTransportConstructionEnd:
            {
                pServerEntry->ServerStatus = pContext->Status;

                if (pServerEntry->ServerStatus == STATUS_SUCCESS) {
                    SmbCeAcquireSpinLock();

                    ASSERT(pContext->pMailSlotTransport != NULL);
                    pContext->pMailSlotTransport->SwizzleCount = 1;

                    if (pContext->pTransport != NULL) {
                        pContext->pTransport->SwizzleCount = 1;
                    }

                    pServerEntry->pTransport         = pContext->pTransport;
                    pServerEntry->pMailSlotTransport = pContext->pMailSlotTransport;

                    pContext->pTransport = NULL;
                    pContext->pMailSlotTransport = NULL;

                    if (pContext->pCallbackContext != NULL) {
                        pContext->pCallbackContext->Status = STATUS_SUCCESS;
                    }

                    pServerEntry->IsTransportDereferenced = FALSE;
                    pServerEntry->SecuritySignaturesActive = FALSE;
                    pServerEntry->SecuritySignaturesEnabled = FALSE;

                    SmbCeReleaseSpinLock();
                } else {
                    PRX_CONTEXT pRxContext =  NULL;

                    if (UpdateUnavailableServerlist &&
                        !pServerEntry->Server.IsRemoteBootServer &&
                        (pServerEntry->PreferredTransport == NULL)) {
                        // In remote boot or specific transport cases, we don't add it to
                        // the list so that no negative caching is introduced.
                        SmbCeServerIsUnavailable( &pServerEntry->Name, pServerEntry->ServerStatus );
                    }

                    if (pContext->pMailSlotTransport != NULL) {
                        pContext->pMailSlotTransport->pDispatchVector->TearDown(
                            pContext->pMailSlotTransport);
                    }

                    if (pContext->pTransport != NULL) {
                        pContext->pTransport->pDispatchVector->TearDown(
                            pContext->pTransport);
                    }

                    pContext->pTransport = NULL;
                    pContext->pMailSlotTransport = NULL;

                    pServerEntry->pTransport         = NULL;
                    pServerEntry->pMailSlotTransport = NULL;

                    if ((pContext->pCallbackContext) &&
                        (pContext->pCallbackContext->SrvCalldownStructure)) {
                        pRxContext =
                            pContext->pCallbackContext->SrvCalldownStructure->RxContext;
                    }

                    Status = CscTransitionServerEntryForDisconnectedOperation(
                                 pServerEntry,
                                 pRxContext,
                                 pServerEntry->ServerStatus,
                                 TRUE   // to autodial or not to autodial
                                );

                    if (pContext->pCallbackContext != NULL) {
                        pContext->pCallbackContext->Status = Status;
                    }

                    if (SmbCeIsServerInDisconnectedMode(pServerEntry)) {
                        pServerEntry->ServerStatus = STATUS_SUCCESS;
                    }
                    else
                    {
                        pServerEntry->ServerStatus = Status;
                    }
                }

                if (pContext->pCompletionEvent != NULL) {
                    ASSERT(pContext->pCallbackContext == NULL);
                    ASSERT(pContext->pCompletionRoutine == NULL);
                    KeSetEvent(
                        pContext->pCompletionEvent,
                        0,
                        FALSE );
                } else if (pContext->pCallbackContext != NULL) {
                    ASSERT(pContext->pCompletionEvent == NULL);

                    (pContext->pCompletionRoutine)(pContext->pCallbackContext);
                } else {
                    ASSERT(!"ill formed transport initialization context");
                }

                if (pContext->WorkQueueItem.List.Flink != NULL) {
                    //DbgBreakPoint();
                }

                // pServerEntry->ConstructionContext = NULL;
                RxFreePool(pContext);

                ContinueConstruction = FALSE;
            }
        }
    } while (ContinueConstruction);
}

NTSTATUS
SmbCepInitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY                         pServerEntry,
    PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CALLBACK pCallbackRoutine,
    PMRX_SRVCALL_CALLBACK_CONTEXT                 pCallbackContext,
    ULONG                                         TransportsToBeConstructed)
/*++

Routine Description:

    This routine initializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

    pCallbackRoutine - the callback routine

    pCallbackContext - the callback context

    TransportsToBeConstructed -- the transports to be constructed

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

    Currently, only connection oriented transports are handled.

--*/
{
    NTSTATUS Status;

    BOOLEAN  CompleteConstruction;

    PAGED_CODE();

    if ((pServerEntry->ServerStatus == STATUS_SUCCESS) &&
        (pServerEntry->pTransport != NULL) &&
        (pServerEntry->pMailSlotTransport != NULL)) {
        Status = STATUS_SUCCESS;
        CompleteConstruction = TRUE;
    } else {
        PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext;

        pContext = RxAllocatePoolWithTag(
                       NonPagedPool,
                       sizeof(SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT),
                       MRXSMB_TRANSPORT_POOLTAG);

        CompleteConstruction = (pContext == NULL);

        if (pContext != NULL) {
            KEVENT  CompletionEvent;

            RtlZeroMemory(
                pContext,
                sizeof(SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT));

            pContext->Status             = STATUS_SUCCESS;
            pContext->pServerEntry       = pServerEntry;
            pContext->State              = SmbCeServerTransportConstructionBegin;
            pContext->TransportsToBeConstructed = TransportsToBeConstructed;

            if (pCallbackContext == NULL) {
                KeInitializeEvent(
                    &CompletionEvent,
                    NotificationEvent,
                    FALSE);

                pContext->pCompletionEvent = &CompletionEvent;
            } else {
                pContext->pCallbackContext   = pCallbackContext;
                pContext->pCompletionRoutine = pCallbackRoutine;
            }

            pServerEntry->ConstructionContext = (PVOID)pContext;

            Status = STATUS_PENDING;

            // always post to a worker thread. This is to avaoid the problem of
            // a thread in system process that is impersonating for a non-admin user
            // When this happens, the thread gets access denied while opening a transport
            // handle

            Status = RxPostToWorkerThread(
                         MRxSmbDeviceObject,
                         CriticalWorkQueue,
                         &pContext->WorkQueueItem,
                         SmbCeConstructServerTransport,
                         pContext);

            if (Status == STATUS_SUCCESS) {
                Status = STATUS_PENDING;
            } else {
                pServerEntry->ConstructionContext = NULL;
                RxFreePool(pContext);
                CompleteConstruction = TRUE;
            }

            if ((Status == STATUS_PENDING) && (pCallbackContext == NULL)) {
                KeWaitForSingleObject(
                    &CompletionEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    NULL );

                Status = pServerEntry->ServerStatus;
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (CompleteConstruction) {
        pServerEntry->ServerStatus = Status;

        if (pCallbackRoutine != NULL) {
            pCallbackContext->Status = Status;

            (pCallbackRoutine)(pCallbackContext);

            Status = STATUS_PENDING;
        }
    }

    return Status;
}

NTSTATUS
SmbCeUninitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY                        pServerEntry,
    PSMBCE_SERVER_TRANSPORT_DESTRUCTION_CALLBACK pCallbackRoutine,
    PVOID                                        pCallbackContext)
/*++

Routine Description:

    This routine uninitializes the transport information corresponding to a server

Arguments:

    pServerEntry - the server entry instance in the database

Returns:

    STATUS_SUCCESS if successful

Notes:

    Currently, only connection oriented transports are handled.

    In order to handle async. operations the uninitialization has to be coordinated
    with the referencing mechanism. It is for this reason that this routine sets up
    a rundown event and waits for it to be set.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if (pCallbackRoutine == NULL &&
        IoGetCurrentProcess() == RxGetRDBSSProcess()) {
        SmbCepTearDownServerTransport(pServerEntry);
    } else {
        PSMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT pContext;

        pContext = RxAllocatePoolWithTag(
                       NonPagedPool,
                       sizeof(SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT),
                       MRXSMB_TRANSPORT_POOLTAG);

        if (pContext != NULL) {
            KEVENT  CompletionEvent;

            RtlZeroMemory(
                pContext,
                sizeof(SMBCE_SERVER_TRANSPORT_CONSTRUCTION_CONTEXT));

            pContext->Status = STATUS_SUCCESS;
            pContext->pServerEntry = pServerEntry;

            if (pCallbackRoutine == NULL) {
                KeInitializeEvent(
                    &CompletionEvent,
                    NotificationEvent,
                    FALSE);

                pContext->pCompletionEvent = &CompletionEvent;
            } else {
                pContext->pCallbackContext   = pCallbackContext;
                pContext->pCompletionRoutine = pCallbackRoutine;
            }

            if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                SmbCeTearDownServerTransport(pContext);
            } else {
                Status = RxPostToWorkerThread(
                             MRxSmbDeviceObject,
                             CriticalWorkQueue,
                             &pContext->WorkQueueItem,
                             SmbCeTearDownServerTransport,
                             pContext);
            }

            if (Status == STATUS_SUCCESS) {
                if (pCallbackRoutine == NULL) {
                    KeWaitForSingleObject(
                        &CompletionEvent,
                        Executive,
                        KernelMode,
                        FALSE,
                        NULL );
                } else {
                    Status = STATUS_PENDING;
                }
            } else {
                RxFreePool(pContext);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return Status;
}

VOID
SmbCeCompleteUninitializeServerTransport(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
{
    // in case of async uninitialize server transport, an additional reference count of
    // server entry should be taken so that uninitialize server transport will not be
    // called once again from tear down server entry if its reference count comes to 0
    // before uninitialize server transport is done.
    SmbCeDereferenceServerEntry(pServerEntry);
}

NTSTATUS
SmbCeInitiateDisconnect(
    PSMBCEDB_SERVER_ENTRY   pServerEntry)
/*++

Routine Description:

    This routine initiates the TDI disconnect

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport construction has been finalized.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMBCE_SERVER_TRANSPORT pTransport;
    PSMBCE_SERVER_TRANSPORT pMailSlotTransport;

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    Status = SmbCeReferenceServerTransport(&pServerEntry->pTransport);

    if (Status == STATUS_SUCCESS) {
        Status = (pServerEntry->pTransport->pDispatchVector->InitiateDisconnect)(
                    pServerEntry->pTransport);

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(0, Dbg, ("SmbCeInitiateDisconnect : Status %lx\n",Status));
        }

        SmbCeDereferenceServerTransport(&pServerEntry->pTransport);
    }

    Status = SmbCeReferenceServerTransport(&pServerEntry->pMailSlotTransport);

    if (Status == STATUS_SUCCESS) {
        Status = (pServerEntry->pMailSlotTransport->pDispatchVector->InitiateDisconnect)(
                    pServerEntry->pMailSlotTransport);

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace(0, Dbg, ("SmbCeInitiateDisconnect MS : Status %lx\n",Status));
        }

        SmbCeDereferenceServerTransport(&pServerEntry->pMailSlotTransport);
    }

    return STATUS_SUCCESS;
}

LONG Initializes[SENTINEL_EXCHANGE] = {0,0,0,0,0};
LONG Uninitializes[SENTINEL_EXCHANGE] = {0,0,0,0,0};

NTSTATUS
SmbCeInitializeExchangeTransport(
   PSMB_EXCHANGE         pExchange)
/*++

Routine Description:

    This routine initializes the transport associated with the exchange

Arguments:

    pExchange - the exchange to be initialized

Return Value:

    STATUS_SUCCESS - the exchange transport initialization has been finalized.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    Status = pExchange->SmbStatus;
    if (Status == STATUS_SUCCESS) {
        PSMBCE_SERVER_TRANSPORT *pTransportPointer;

        if (FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
            pTransportPointer = &pServerEntry->pMailSlotTransport;
        } else {
            pTransportPointer = &pServerEntry->pTransport;
        }

        if (*pTransportPointer != NULL) {
            Status = SmbCeReferenceServerTransport(pTransportPointer);

            if (Status == STATUS_SUCCESS) {
                Status = ((*pTransportPointer)->pDispatchVector->InitializeExchange)(
                             *pTransportPointer,
                             pExchange);

                if (Status == STATUS_SUCCESS) {
                    ULONG TransportInitialized;

                    InterlockedIncrement(&Initializes[pExchange->Type]);
                    TransportInitialized = InterlockedExchange(&pExchange->ExchangeTransportInitialized,1);
                    ASSERT(TransportInitialized == 0);
                } else {
                    SmbCeDereferenceServerTransport(pTransportPointer);
                }
            }
        } else {
            Status = STATUS_CONNECTION_DISCONNECTED;
        }
   }

   return Status;
}

NTSTATUS
SmbCeUninitializeExchangeTransport(
   PSMB_EXCHANGE         pExchange)
/*++

Routine Description:

    This routine uniinitializes the transport associated with the exchange

Arguments:

    pExchange - the exchange to be initialized

Return Value:

    STATUS_SUCCESS - the exchange transport initialization has been finalized.

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status;
    PSMBCEDB_SERVER_ENTRY pServerEntry;

    PAGED_CODE();

    pServerEntry = SmbCeGetExchangeServerEntry(pExchange);

    if (InterlockedExchange(&pExchange->ExchangeTransportInitialized,0)==1) {
        PSMBCE_SERVER_TRANSPORT *pTransportPointer;

        if (FlagOn(pExchange->SmbCeFlags,SMBCE_EXCHANGE_MAILSLOT_OPERATION)) {
            pTransportPointer = &pServerEntry->pMailSlotTransport;
        } else {
            pTransportPointer = &pServerEntry->pTransport;
        }

        if (*pTransportPointer != NULL) {
            Status = ((*pTransportPointer)->pDispatchVector->UninitializeExchange)(
                        *pTransportPointer,
                        pExchange);

            SmbCeDereferenceServerTransport(pTransportPointer);
            InterlockedIncrement(&Uninitializes[pExchange->Type]);

            return Status;
        } else {
            return STATUS_CONNECTION_DISCONNECTED;
        }
    } else {
        return pExchange->SmbStatus;
    }
}

NTSTATUS
SmbCepReferenceServerTransport(
    PSMBCE_SERVER_TRANSPORT *pServerTransportPointer)
/*++

Routine Description:

    This routine references the transport associated with a server entry

Arguments:

    pServerEntry - the server entry instance in the database

Return Value:

    STATUS_SUCCESS - the server transport was successfully referenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    SmbCeAcquireSpinLock();

    if (*pServerTransportPointer != NULL &&
        (*pServerTransportPointer)->State == SMBCEDB_ACTIVE) {
        InterlockedIncrement(&(*pServerTransportPointer)->SwizzleCount);
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_CONNECTION_DISCONNECTED;
    }

    SmbCeReleaseSpinLock();

    return Status;
}

NTSTATUS
SmbCepDereferenceServerTransport(
    PSMBCE_SERVER_TRANSPORT *pServerTransportPointer)
/*++

Routine Description:

    This routine dereferences the transport associated with a server entry

Arguments:

    pServerTransportPointer - the server entry transport instance pointer

Return Value:

    STATUS_SUCCESS - the server transport was successfully dereferenced

    Other Status codes correspond to error situations.

Notes:

    On finalization this routine sets the event to enable the process awaiting
    tear down to restart. It also tears down the associated server transport
    instance.

    As a side effect the pointer value is set to NULL under the protection of a
    spin lock.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    SmbCeAcquireSpinLock();

    if (*pServerTransportPointer != NULL) {
        LONG    FinalRefCount;
        PKEVENT pRundownEvent;
        PSMBCE_SERVER_TRANSPORT pServerTransport;

        pServerTransport = *pServerTransportPointer;

        FinalRefCount = InterlockedDecrement(&pServerTransport->SwizzleCount);

        if (FinalRefCount == 0) {
            pServerTransport->State = SMBCEDB_INVALID;

            // transport is set to NULL before the spinlock is release so that no
            // exchange should reference it after it's been torn down
            *pServerTransportPointer = NULL;
            pRundownEvent = pServerTransport->pRundownEvent;
        }

        SmbCeReleaseSpinLock();

        if (FinalRefCount == 0) {
            if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                pServerTransport->pDispatchVector->TearDown(pServerTransport);
            } else {
                Status = RxDispatchToWorkerThread(
                             MRxSmbDeviceObject,
                             CriticalWorkQueue,
                             pServerTransport->pDispatchVector->TearDown,
                             pServerTransport);
            }
        }
    } else {
        SmbCeReleaseSpinLock();
        Status = STATUS_CONNECTION_DISCONNECTED;
    }

    return Status;
}


NTSTATUS
SmbCepReferenceTransport(
    PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine references the transport instance

Arguments:

    pTransport - the transport instance

Return Value:

    STATUS_SUCCESS - the server transport was successfully referenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (pTransport != NULL) {
        SmbCeAcquireSpinLock();

        if (pTransport->Active) {
            InterlockedIncrement(&pTransport->SwizzleCount);
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }

        SmbCeReleaseSpinLock();
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
SmbCepDereferenceTransport(
    PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    This routine dereferences the transport

Arguments:

    pTransport - the transport instance

Return Value:

    STATUS_SUCCESS - the server transport was successfully dereferenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AttachToSystemProcess = FALSE;
    KAPC_STATE ApcState;

    PAGED_CODE();

    if (pTransport != NULL) {
        LONG FinalRefCount;

        FinalRefCount = InterlockedDecrement(&pTransport->SwizzleCount);

        if (FinalRefCount == 0) {
            SmbCeRemoveTransport(pTransport);

            if (IoGetCurrentProcess() != RxGetRDBSSProcess()) {
                KeStackAttachProcess(RxGetRDBSSProcess(),&ApcState);
                AttachToSystemProcess = TRUE;
            }

            RxCeTearDownAddress(&pTransport->RxCeAddress);

            RxCeTearDownTransport(&pTransport->RxCeTransport);

            if (AttachToSystemProcess) {
                KeUnstackDetachProcess(&ApcState);
            }

            RxFreePool(pTransport);
        }
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

#ifndef MRXSMB_PNP_POWER5

HANDLE MRxSmbTdiNotificationHandle = NULL;

VOID
MRxSmbpBindTransportCallback(
    IN PUNICODE_STRING pTransportName
)
/*++

Routine Description:

    TDI calls this routine whenever a transport creates a new device object.

Arguments:

    DeviceName - the name of the newly created device object

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCE_TRANSPORT   pTransport;

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;

    ULONG   Priority;
    BOOLEAN fBindToTransport = FALSE;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    // if this is one of the transports that is of interest to the SMB
    // mini rdr then register the address with it, otherwise skip it.

    if (SmbCeContext.Transports.Length != 0) {
        PWSTR          pSmbMRxTransports = (PWSTR)SmbCeContext.Transports.Buffer;
        UNICODE_STRING SmbMRxTransport;

        Priority = 1;
        while (*pSmbMRxTransports) {
            SmbMRxTransport.Length = wcslen(pSmbMRxTransports) * sizeof(WCHAR);

            if (SmbMRxTransport.Length == pTransportName->Length) {
                SmbMRxTransport.MaximumLength = SmbMRxTransport.Length;
                SmbMRxTransport.Buffer = pSmbMRxTransports;

                if (RtlCompareUnicodeString(
                       &SmbMRxTransport,
                       pTransportName,
                       TRUE) == 0) {
                    fBindToTransport = TRUE;
                    break;
                }
            }

            pSmbMRxTransports += (SmbMRxTransport.Length / sizeof(WCHAR) + 1);
            Priority++;
        }
    }

    if (!fBindToTransport) {
        return;
    }

    pTransport = RxAllocatePoolWithTag(
                     NonPagedPool,
                     sizeof(SMBCE_TRANSPORT),
                     MRXSMB_TRANSPORT_POOLTAG);

    if (pTransport != NULL) {
        Status = RxCeBuildTransport(
                     &pTransport->RxCeTransport,
                     pTransportName,
                     0xffff);

        if (Status == STATUS_SUCCESS) {
            PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;

            pProviderInfo = pTransport->RxCeTransport.pProviderInfo;

            if (!(pProviderInfo->ServiceFlags & TDI_SERVICE_CONNECTION_MODE) ||
                !(pProviderInfo->ServiceFlags & TDI_SERVICE_ERROR_FREE_DELIVERY)) {
                RxCeTearDownTransport(
                    &pTransport->RxCeTransport);

                Status = STATUS_PROTOCOL_UNREACHABLE;

                RxFreePool(pTransport);
            }
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) {
        // The connection capabilities match the capabilities required by the
        // SMB mini redirector. Attempt to register the local address with the
        // transport and if successful update the local transport list to include
        // this transport for future connection considerations.

        OEM_STRING   OemServerName;
        CHAR  TransportAddressBuffer[TDI_TRANSPORT_ADDRESS_LENGTH +
                          TDI_ADDRESS_LENGTH_NETBIOS];
        PTRANSPORT_ADDRESS pTransportAddress = (PTRANSPORT_ADDRESS)TransportAddressBuffer;
        PTDI_ADDRESS_NETBIOS pNetbiosAddress = (PTDI_ADDRESS_NETBIOS)pTransportAddress->Address[0].Address;

        pTransportAddress->TAAddressCount = 1;
        pTransportAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
        pTransportAddress->Address[0].AddressType   = TDI_ADDRESS_TYPE_NETBIOS;
        pNetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        OemServerName.MaximumLength = NETBIOS_NAME_LEN;
        OemServerName.Buffer        = pNetbiosAddress->NetbiosName;

        Status = RtlUpcaseUnicodeStringToOemString(
                     &OemServerName,
                     &SmbCeContext.ComputerName,
                     FALSE);

        if (NT_SUCCESS(Status)) {
            // Ensure that the name is always of the desired length by padding
            // white space to the end.
            RtlCopyMemory(
                &OemServerName.Buffer[OemServerName.Length],
                "                ",
                NETBIOS_NAME_LEN - OemServerName.Length);

            OemServerName.Buffer[NETBIOS_NAME_LEN - 1] = '\0';

            // Register the Transport address for this mini redirector with the connection
            // engine.

            Status = RxCeBuildAddress(
                        &pTransport->RxCeAddress,
                        &pTransport->RxCeTransport,
                        pTransportAddress,
                        &MRxSmbVctAddressEventHandler,
                        &SmbCeContext);

            if (Status == STATUS_SUCCESS) {
                RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Adding new transport\n"));

                pTransport->Active       = TRUE;
                pTransport->Priority     = Priority;
                pTransport->SwizzleCount = 0;

                pTransport->ObjectCategory = SMB_SERVER_TRANSPORT_CATEGORY;
                pTransport->ObjectType     = SMBCEDB_OT_TRANSPORT;
                pTransport->State          = 0;
                pTransport->Flags          = 0;

                // notify the browser about the transport
                Status = SmbCePnpBindBrowser(pTransportName, TRUE);

                // Add the transport to the list of transports
                if (Status == STATUS_SUCCESS) {
                    SmbCeAddTransport(pTransport);
                } else {
                    RxCeTearDownAddress(&pTransport->RxCeAddress);

                    MRxSmbLogTransportError(pTransportName,
                                            &SmbCeContext.DomainName,
                                            Status,
                                            EVENT_RDR_CANT_BIND_TRANSPORT);
                    SmbLogError(Status,
                                LOG,
                                MRxSmbpBindTransportCallback_1,
                                LOGULONG(Status)
                                LOGUSTR(*pTransportName));

                }
            } else {
                RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Address registration failed %lx\n",Status));
                MRxSmbLogTransportError(pTransportName,
                                         &SmbCeContext.DomainName,
                                         Status,
                                         EVENT_RDR_CANT_REGISTER_ADDRESS);
                SmbLogError(Status,
                            LOG,
                            MRxSmbpBindTransportCallback_2,
                            LOGUSTR(*pTransportName));
            }
        }

        if (Status != STATUS_SUCCESS) {
            RxCeTearDownTransport(
                &pTransport->RxCeTransport);

            Status = STATUS_PROTOCOL_UNREACHABLE;
            RxFreePool(pTransport);
        }
    }
}

VOID
MRxSmbpBindTransportWorkerThreadRoutine(
    IN PUNICODE_STRING pTransportName)
{
    PAGED_CODE();

    MRxSmbpBindTransportCallback(pTransportName);

    RxFreePool(pTransportName);
}

VOID
MRxSmbBindTransportCallback(
    IN PUNICODE_STRING pTransportName
)
/*++

Routine Description:

    TDI calls this routine whenever a transport creates a device object

Arguments:

    TransportName = the name of the deleted device object

--*/
{
    PAGED_CODE();

    if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
        MRxSmbpBindTransportCallback(pTransportName);
    } else {
        PUNICODE_STRING pNewTransportName;
        NTSTATUS Status;

        pNewTransportName = RxAllocatePoolWithTag(
                                PagedPool,
                                sizeof(UNICODE_STRING) + pTransportName->Length,
                                MRXSMB_TRANSPORT_POOLTAG);

        if (pNewTransportName != NULL) {
            pNewTransportName->MaximumLength = pTransportName->MaximumLength;
            pNewTransportName->Length = pTransportName->Length;
            pNewTransportName->Buffer = (PWCHAR)((PBYTE)pNewTransportName +
                                                  sizeof(UNICODE_STRING));

            RtlCopyMemory(
                pNewTransportName->Buffer,
                pTransportName->Buffer,
                pNewTransportName->Length);

            Status = RxDispatchToWorkerThread(
                         MRxSmbDeviceObject,
                         CriticalWorkQueue,
                         MRxSmbpBindTransportWorkerThreadRoutine,
                         pNewTransportName);
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (Status != RX_MAP_STATUS(SUCCESS)) {
            RxLog(("SmbCe Tdi Bind .Error %lx\n", Status));

            MRxSmbLogTransportError(pTransportName,
                                     &SmbCeContext.DomainName,
                                     Status,
                                     EVENT_RDR_CANT_BIND_TRANSPORT);
        }
    }
}

VOID
MRxSmbUnbindTransportCallback(
    IN PUNICODE_STRING pTransportName
)
/*++

Routine Description:

    TDI calls this routine whenever a transport deletes a device object

Arguments:

    TransportName = the name of the deleted device object

--*/
{
    PSMBCE_TRANSPORT pTransport;

    PAGED_CODE();

    pTransport = SmbCeFindTransport(pTransportName);

    if (pTransport != NULL) {
        // notify the browser about the transport
        SmbCePnpBindBrowser(pTransportName, FALSE);

        // Remove this transport from the list of transports under consideration
        // in the mini redirector.
        SmbCeRemoveTransport(pTransport);

        // Enumerate the servers and mark those servers utilizing this transport
        // as having an invalid transport.
        SmbCeHandleTransportInvalidation(pTransport);

        // dereference the transport
        SmbCeDereferenceTransport(pTransport);
    }
}

NTSTATUS
MRxSmbRegisterForPnpNotifications()
/*++

Routine Description:

    This routine registers with TDI for receiving transport notifications

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(MRxSmbTdiNotificationHandle == NULL ) {
        Status = TdiRegisterNotificationHandler (
                     MRxSmbBindTransportCallback,
                     MRxSmbUnbindTransportCallback,
                     &MRxSmbTdiNotificationHandle );
    }

    return Status;
}

NTSTATUS
MRxSmbDeregisterForPnpNotifications()
/*++

Routine Description:

    This routine deregisters the TDI notification mechanism

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if( MRxSmbTdiNotificationHandle != NULL ) {
        Status = TdiDeregisterNotificationHandler( MRxSmbTdiNotificationHandle );

        if( NT_SUCCESS( Status ) ) {
            MRxSmbTdiNotificationHandle = NULL;
        }
    }

    return Status;
}

#else

HANDLE MRxSmbTdiNotificationHandle = NULL;

KEVENT TdiNetStartupCompletionEvent;

LONG   TdiBindRequestsActive = 0;

BOOLEAN TdiPnpNetReadyEventReceived = FALSE;

// The TRANSPORT_BIND_CONTEXT contains the result of the priority determination
// as well as the name. The priority is used to order the transports in the order
// in which connection attempts will be made

typedef struct _TRANSPORT_BIND_CONTEXT_ {
    ULONG           Priority;
    UNICODE_STRING  TransportName;
} TRANSPORT_BIND_CONTEXT, *PTRANSPORT_BIND_CONTEXT;

VOID
SmbCeSignalNetReadyEvent()
/*++

Routine Description:

    The routine signals the net ready event if all the bind requests
    have been completed and if the net ready event has been received from TDI

Arguments:

--*/
{
    BOOLEAN SignalNetReadyEvent = FALSE;

    SmbCeAcquireSpinLock();

    if (TdiPnpNetReadyEventReceived &&
        TdiBindRequestsActive == 0) {
        SignalNetReadyEvent = TRUE;
    }

    SmbCeReleaseSpinLock();

    if (SignalNetReadyEvent) {
        KeSetEvent(
            &TdiNetStartupCompletionEvent,
            IO_NETWORK_INCREMENT,
            FALSE);
    }
}

VOID
MRxSmbpBindTransportCallback(
    IN PTRANSPORT_BIND_CONTEXT pTransportContext)
/*++

Routine Description:

    TDI calls this routine whenever a transport creates a new device object.

Arguments:

    TransportName - the name of the newly created device object

    TransportBindings - the transport bindings ( multi sz)

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PSMBCE_TRANSPORT   pTransport;

    PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;

    PUNICODE_STRING pTransportName;

    PAGED_CODE();

    ASSERT(IoGetCurrentProcess() == RxGetRDBSSProcess());

    pTransportName = &pTransportContext->TransportName;

    RxDbgTrace( 0, Dbg, ("MrxSmbpBindTransportCallback, Transport Name = %wZ\n", pTransportName ));

    pTransport = RxAllocatePoolWithTag(
                     NonPagedPool,
                     sizeof(SMBCE_TRANSPORT),
                     MRXSMB_TRANSPORT_POOLTAG);

    if (pTransport != NULL) {
        Status = RxCeBuildTransport(
                     &pTransport->RxCeTransport,
                     pTransportName,
                     0xffff);

        if (Status == STATUS_SUCCESS) {
            PRXCE_TRANSPORT_PROVIDER_INFO pProviderInfo;

            pProviderInfo = pTransport->RxCeTransport.pProviderInfo;

            if (!(pProviderInfo->ServiceFlags & TDI_SERVICE_CONNECTION_MODE) ||
                !(pProviderInfo->ServiceFlags & TDI_SERVICE_ERROR_FREE_DELIVERY)) {
                RxCeTearDownTransport(
                    &pTransport->RxCeTransport);

                Status = STATUS_PROTOCOL_UNREACHABLE;

                RxFreePool(pTransport);
            }
        }
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (Status == STATUS_SUCCESS) {
        // The connection capabilities match the capabilities required by the
        // SMB mini redirector. Attempt to register the local address with the
        // transport and if successful update the local transport list to include
        // this transport for future connection considerations.

        OEM_STRING   OemServerName;
        CHAR  TransportAddressBuffer[TDI_TRANSPORT_ADDRESS_LENGTH +
                          TDI_ADDRESS_LENGTH_NETBIOS];
        PTRANSPORT_ADDRESS pTransportAddress = (PTRANSPORT_ADDRESS)TransportAddressBuffer;
        PTDI_ADDRESS_NETBIOS pNetbiosAddress = (PTDI_ADDRESS_NETBIOS)pTransportAddress->Address[0].Address;

        pTransportAddress->TAAddressCount = 1;
        pTransportAddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_NETBIOS;
        pTransportAddress->Address[0].AddressType   = TDI_ADDRESS_TYPE_NETBIOS;
        pNetbiosAddress->NetbiosNameType = TDI_ADDRESS_NETBIOS_TYPE_UNIQUE;

        OemServerName.MaximumLength = NETBIOS_NAME_LEN;
        OemServerName.Buffer        = pNetbiosAddress->NetbiosName;

        Status = RtlUpcaseUnicodeStringToOemString(
                     &OemServerName,
                     &SmbCeContext.ComputerName,
                     FALSE);

        if (NT_SUCCESS(Status)) {
            // Ensure that the name is always of the desired length by padding
            // white space to the end.
            RtlCopyMemory(
                &OemServerName.Buffer[OemServerName.Length],
                "                ",
                NETBIOS_NAME_LEN - OemServerName.Length);

            OemServerName.Buffer[NETBIOS_NAME_LEN - 1] = '\0';

            // Register the Transport address for this mini redirector with the connection
            // engine.

            Status = RxCeBuildAddress(
                        &pTransport->RxCeAddress,
                        &pTransport->RxCeTransport,
                        pTransportAddress,
                        &MRxSmbVctAddressEventHandler,
                        &SmbCeContext);

            if (Status == STATUS_SUCCESS) {
                RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Adding new transport\n"));

                pTransport->Active       = TRUE;
                pTransport->Priority     = pTransportContext->Priority;
                pTransport->SwizzleCount = 0;

                pTransport->ObjectCategory = SMB_SERVER_TRANSPORT_CATEGORY;
                pTransport->ObjectType     = SMBCEDB_OT_TRANSPORT;
                pTransport->State          = 0;
                pTransport->Flags          = 0;

                // notify the browser about the transport
                Status = SmbCePnpBindBrowser(pTransportName, TRUE);

                if (MRxSmbBootedRemotely && (Status == STATUS_REDIRECTOR_NOT_STARTED)) {

                    //
                    // Ignore failures here, because when starting during
                    // textmode setup in remote boot, the browser is not around.
                    //

                    Status = STATUS_SUCCESS;
                }

                // Add the transport to the list of transports
                if (Status == STATUS_SUCCESS) {
                    SmbCeAddTransport(pTransport);
                    RxDbgTrace( 0, Dbg, ("MrxSmbpBindTransportCallback, Transport %wZ added\n", pTransportName ));
                } else {
                    RxCeTearDownAddress(&pTransport->RxCeAddress);

                    MRxSmbLogTransportError(pTransportName,
                                             &SmbCeContext.DomainName,
                                             Status,
                                             EVENT_RDR_CANT_BIND_TRANSPORT);
                    SmbLogError(Status,
                                LOG,
                                MRxSmbpBindTransportCallback_1,
                                LOGULONG(Status)
                                LOGUSTR(*pTransportName));
                }
            } else {
                RxDbgTrace( 0, Dbg, ("MRxSmbTransportUpdateHandler: Address registration failed %lx\n",Status));
                MRxSmbLogTransportError(pTransportName,
                                         &SmbCeContext.DomainName,
                                         Status,
                                         EVENT_RDR_CANT_REGISTER_ADDRESS);
                SmbLogError(Status,
                            LOG,
                            MRxSmbpBindTransportCallback_2,
                            LOGULONG(Status)
                            LOGUSTR(*pTransportName));
            }
        }

        if (Status != STATUS_SUCCESS) {
            RxDbgTrace( 0, Dbg, ("MrxSmbpBindTransportCallback, Transport %wZ unreachable 0x%x\n",
                                 pTransportName, Status ));
            RxCeTearDownTransport(
                &pTransport->RxCeTransport);

            Status = STATUS_PROTOCOL_UNREACHABLE;
            RxFreePool(pTransport);
        }
    }

    InterlockedDecrement(&TdiBindRequestsActive);
    SmbCeSignalNetReadyEvent();
}

VOID
MRxSmbpBindTransportWorkerThreadRoutine(
    IN PTRANSPORT_BIND_CONTEXT pTransportContext)
/*++

Routine Description:

    The TDI callbacks always do not occur in the context of the FSP process.
    Since there are a few TDi interfaces that accept handles we need to ensure
    that such calls always gets funnelled back to the FSP.

Arguments:

    pTransportContext - the transport binding context

--*/
{
    PAGED_CODE();

    MRxSmbpBindTransportCallback(pTransportContext);

    RxFreePool(pTransportContext);
}

VOID
MRxSmbpUnbindTransportCallback(
    PSMBCE_TRANSPORT pTransport)
/*++

Routine Description:

    The Unbind callback routine which is always executed in the context of the
    RDR process so that handles can be closed correctly

Arguments:

    pTransport - the transport for which the PNP_OP_DEL was received

Notes:

    On entry to this routine the appropriate transport must have been referenced
    This routine will dereference it and invalidate the existing exchanges using
    this transport.

--*/
{
    PAGED_CODE();

    // notify the browser about the transport
    SmbCePnpBindBrowser(&pTransport->RxCeTransport.Name, FALSE);

    // Remove this transport from the list of transports under consideration
    // in the mini redirector.

    SmbCeRemoveTransport(pTransport);

    // Enumerate the servers and mark those servers utilizing this transport
    // as having an invalid transport.
    SmbCeHandleTransportInvalidation(pTransport);

    // dereference the transport
    SmbCeDereferenceTransport(pTransport);
}


VOID
MRxSmbpOverrideBindingPriority(
    PUNICODE_STRING pTransportName,
    PULONG pPriority
    )

/*++

Routine Description:

This function obtains a overriding priority value from the registry for a given
transport.

The priority of a transport controls the order in which connections are accepted.  It is
sometimes useful for a customer to control which transport is used first in the redirector.

The priority is usually determined by the order of the transports in the binding list.  With
the new Connections UI model for network setup, it will no longer be possible to adjust
the order of the bindings in the binding list.  Thus, another mechanism is needed when the
user wants to override the priority assigned to a given binding.

Arguments:

    pTransportName - pointer to UNICODE_STRING descriptor for transport string, for example
        "\Device\Netbt_tcpip_{guid}"
    pPriority - pointer to LONG to receive new priority on success, otherwise not touched

Return Value:

    None

--*/

{
    WCHAR valueBuffer[128];
    UNICODE_STRING path, value, key;
    USHORT length,ulength;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    HANDLE parametersHandle;
    ULONG temp;

    PAGED_CODE();

    // Validate input

    if (pTransportName->Length == 0) {
        return;
    }

    // Open parameters key

    RtlInitUnicodeString( &path, SMBMRX_MINIRDR_PARAMETERS );

    InitializeObjectAttributes(
        &objectAttributes,
        &path,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    status = ZwOpenKey (&parametersHandle, KEY_READ, &objectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    // Construct value name = "BindingPriority" + transportname
    // First, find the last slash.  Then form the value from the prefix and
    // the remainder of the transport name.
    ulength = pTransportName->Length / sizeof(WCHAR);
    for( length = ulength - 1; length != 0; length-- ) {
        if (pTransportName->Buffer[length] == L'\\') {
            break;
        }
    }

    length++;
    key.Buffer = pTransportName->Buffer + length;
    key.Length = (ulength - length) * sizeof(WCHAR);

    value.Buffer = valueBuffer;
    value.MaximumLength = 128 * sizeof(WCHAR);
    value.Length = 0;

    RtlAppendUnicodeToString( &value, L"BindingPriority" );
    RtlAppendUnicodeStringToString( &value, &key );

    // Check if the value is present.  If so, replace priority
    // A value of zero is valid and indicates do not bind this one

    status = MRxSmbGetUlongRegistryParameter(
                 parametersHandle,
                 value.Buffer,
                 (PULONG)&temp,
                 FALSE );

    if (NT_SUCCESS(status)) {
        *pPriority = temp;
    }

    ZwClose(parametersHandle);
}

VOID
MRxSmbPnPBindingHandler(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  pTransportName,
    IN PWSTR            BindingList)
/*++

Routine Description:

    The TDI callbacks routine for binding changes

Arguments:

    PnPOpcode - the PNP op code

    pTransportName - the transport name

    BindingList - the binding order

--*/
{
    ULONG Priority;

    PAGED_CODE();

    switch (PnPOpcode) {
    case TDI_PNP_OP_ADD:
        {
            BOOLEAN        fBindToTransport = FALSE;
            PWSTR          pSmbMRxTransports;
            UNICODE_STRING SmbMRxTransport;
            NTSTATUS       Status;

            Status = SmbCeGetConfigurationInformation();

            if (Status != STATUS_SUCCESS) {
                return;
            }

            pSmbMRxTransports = (PWSTR)SmbCeContext.Transports.Buffer;
            Priority = 1;
            while (*pSmbMRxTransports) {
                SmbMRxTransport.Length = wcslen(pSmbMRxTransports) * sizeof(WCHAR);

                if (SmbMRxTransport.Length == pTransportName->Length) {
                    SmbMRxTransport.MaximumLength = SmbMRxTransport.Length;
                    SmbMRxTransport.Buffer = pSmbMRxTransports;

                    if (RtlCompareUnicodeString(
                           &SmbMRxTransport,
                           pTransportName,
                           TRUE) == 0) {
                        fBindToTransport = TRUE;
                        break;
                    }
                }

                pSmbMRxTransports += (SmbMRxTransport.Length / sizeof(WCHAR) + 1);
                Priority++;
            }

            // Provide a local registry means to alter binding priority
            if (fBindToTransport) {
                MRxSmbpOverrideBindingPriority( pTransportName, &Priority );
                fBindToTransport = (Priority != 0);
            }

            if (fBindToTransport) {
                InterlockedIncrement(&TdiBindRequestsActive);

                if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                    TRANSPORT_BIND_CONTEXT TransportContext;

                    TransportContext.Priority = Priority;
                    TransportContext.TransportName = *pTransportName;
                    MRxSmbpBindTransportCallback(&TransportContext);
                } else {
                    PTRANSPORT_BIND_CONTEXT pNewTransportContext;

                    NTSTATUS Status;

                    pNewTransportContext = RxAllocatePoolWithTag(
                                               PagedPool,
                                               sizeof(TRANSPORT_BIND_CONTEXT) + pTransportName->Length,
                                               MRXSMB_TRANSPORT_POOLTAG);

                    if (pNewTransportContext != NULL) {
                        pNewTransportContext->Priority = Priority;
                        pNewTransportContext->TransportName.MaximumLength = pTransportName->MaximumLength;
                        pNewTransportContext->TransportName.Length = pTransportName->Length;
                        pNewTransportContext->TransportName.Buffer = (PWCHAR)((PBYTE)pNewTransportContext +
                                                                      sizeof(TRANSPORT_BIND_CONTEXT));

                        RtlCopyMemory(
                            pNewTransportContext->TransportName.Buffer,
                            pTransportName->Buffer,
                            pTransportName->Length);

                        Status = RxDispatchToWorkerThread(
                                     MRxSmbDeviceObject,
                                     CriticalWorkQueue,
                                     MRxSmbpBindTransportWorkerThreadRoutine,
                                     pNewTransportContext);
                    } else {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }

                    if (Status != STATUS_SUCCESS) {
                        InterlockedDecrement(&TdiBindRequestsActive);
                        SmbCeSignalNetReadyEvent();
                    }
                }
            }
        }
        break;

    case TDI_PNP_OP_DEL:
        {
            PSMBCE_TRANSPORT pTransport;

            pTransport = SmbCeFindTransport(pTransportName);

            if (pTransport != NULL) {
                if (IoGetCurrentProcess() == RxGetRDBSSProcess()) {
                    MRxSmbpUnbindTransportCallback(pTransport);
                } else {
                    NTSTATUS Status;

                    Status = RxDispatchToWorkerThread(
                                 MRxSmbDeviceObject,
                                 CriticalWorkQueue,
                                 MRxSmbpUnbindTransportCallback,
                                 pTransport);
                }
            }
        }
        break;

    case TDI_PNP_OP_UPDATE:
        {
        }
        break;

    case  TDI_PNP_OP_NETREADY:
        {
            TdiPnpNetReadyEventReceived = TRUE;
            SmbCeSignalNetReadyEvent();
        }
        break;

    default:
        break;
    }

    if( PnPOpcode != TDI_PNP_OP_NETREADY )
    {
        SmbMRxNotifyChangesToNetBt( PnPOpcode, pTransportName, BindingList );
    }
}

NTSTATUS
MRxSmbPnPPowerHandler(
    IN PUNICODE_STRING  DeviceName,
    IN PNET_PNP_EVENT   PowerEvent,
    IN PTDI_PNP_CONTEXT Context1,
    IN PTDI_PNP_CONTEXT Context2
)
/*++

Routine Description:

    This routine deals with power changes

Notes:

    The implementation needs to be completed

--*/
{
    NTSTATUS Status;
    LONG     NumberOfActiveOpens;

    Status = STATUS_SUCCESS;

    FsRtlEnterFileSystem();

    RxPurgeAllFobxs(MRxSmbDeviceObject);

    RxScavengeAllFobxs(MRxSmbDeviceObject);
    NumberOfActiveOpens = MRxSmbNumberOfSrvOpens;

    switch (PowerEvent->NetEvent) {
    case NetEventQueryPower:
        {
            // If the redirector were to return an error on this request there
            // is no underlying support to tell the user about the files that
            // are open. There are two approaches to doing this.. either the RDR
            // rolls its own UI or the PNP manager provides the infra structure.
            // The problem with the former is that hibernation becomes a painstaking
            // process wherein the user has to contend with a variety of UI.
            // Till this is resolved the decision was to use the power mgmt. API
            // to manage system initiated hibernate requests and succeed user
            // initiated requests after appropriate purging/scavenging.

            Status = STATUS_SUCCESS;
        }
        break;

    case NetEventQueryRemoveDevice:
        {
            PSMBCEDB_SERVER_ENTRY pServerEntry;
            ULONG                 NumberOfFilesOpen = 0;
            PSMBCE_TRANSPORT      pTransport = NULL;

            pTransport = SmbCeFindTransport(DeviceName);

            if (pTransport != NULL) {
                SmbCeAcquireSpinLock();

                pServerEntry = SmbCeGetFirstServerEntry();

                while (pServerEntry != NULL) {
                    if ((pServerEntry->pTransport != NULL) &&
                        (pTransport == pServerEntry->pTransport->pTransport)) {
                        NumberOfFilesOpen += pServerEntry->Server.NumberOfSrvOpens;
                    }

                    pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
                }

                SmbCeReleaseSpinLock();

                SmbCeDereferenceTransport(pTransport);
            }
        }
        break;

    default:
        break;
    }

    FsRtlExitFileSystem();

    return Status;
}

NTSTATUS
MRxSmbRegisterForPnpNotifications()
/*++

Routine Description:

    This routine registers with TDI for receiving transport notifications

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if(MRxSmbTdiNotificationHandle == NULL ) {
        UNICODE_STRING ClientName;

        TDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo;

        RtlInitUnicodeString(&ClientName,L"LanmanWorkStation");

        ClientInterfaceInfo.MajorTdiVersion = 2;
        ClientInterfaceInfo.MinorTdiVersion = 0;

        ClientInterfaceInfo.Unused = 0;
        ClientInterfaceInfo.ClientName = &ClientName;

        ClientInterfaceInfo.BindingHandler = MRxSmbPnPBindingHandler;
        ClientInterfaceInfo.AddAddressHandler = NULL;
        ClientInterfaceInfo.DelAddressHandler = NULL;
        ClientInterfaceInfo.PnPPowerHandler = MRxSmbPnPPowerHandler;

        KeInitializeEvent(
            &TdiNetStartupCompletionEvent,
            NotificationEvent,
            FALSE);

        Status = TdiRegisterPnPHandlers (
                     &ClientInterfaceInfo,
                     sizeof(ClientInterfaceInfo),
                     &MRxSmbTdiNotificationHandle );

        if (Status == STATUS_SUCCESS) {
            LARGE_INTEGER WaitInterval;

            WaitInterval.QuadPart = -( 10000 * 2 * 60 * 1000 );

            Status = KeWaitForSingleObject(
                         &TdiNetStartupCompletionEvent,
                         Executive,
                         KernelMode,
                         FALSE,
                         &WaitInterval);

            if (Status != STATUS_SUCCESS) {
                DbgPrint("MRxSmb Finishes waiting on TDI_PNP_OP_NETREADY %lx\n",Status);
            }
        }
    }

    return Status;
}

NTSTATUS
MRxSmbDeregisterForPnpNotifications()
/*++

Routine Description:

    This routine deregisters the TDI notification mechanism

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if( MRxSmbTdiNotificationHandle != NULL ) {
        Status = TdiDeregisterPnPHandlers( MRxSmbTdiNotificationHandle );

        if( NT_SUCCESS( Status ) ) {
            MRxSmbTdiNotificationHandle = NULL;
        }
    }

    return Status;
}

#endif

NTSTATUS
SmbCePnpBindBrowser( PUNICODE_STRING pTransportName, BOOLEAN IsBind)
/*++

Routine Description:

    This routine binds the browser with the specified transport

Arguments:

    pTransportName - the name of the transport

Notes:

--*/
{
    NTSTATUS             Status;
    HANDLE               BrowserHandle;
    PLMDR_REQUEST_PACKET pLmdrRequestPacket;
    IO_STATUS_BLOCK      IoStatusBlock;
    OBJECT_ATTRIBUTES    ObjectAttributes;
    UNICODE_STRING       BrowserDeviceName;
    ULONG                LmdrRequestPacketSize;

    PAGED_CODE();

    //
    // Open up a handle to the browser
    //
    RtlInitUnicodeString( &BrowserDeviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &BrowserDeviceName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL
        );

    Status = IoCreateFile(
                &BrowserHandle,                 // FileHandle
                SYNCHRONIZE,                    // DesiredAccess
                &ObjectAttributes,              // ObjectAttributes
                &IoStatusBlock,                 // IoStatusBlock
                NULL,                           // AllocationSize
                0L,                             // FileAttributes
                FILE_SHARE_VALID_FLAGS,         // ShareAccess
                FILE_OPEN,                      // Disposition
                FILE_SYNCHRONOUS_IO_NONALERT,   // CreateOptions
                NULL,                           // EaBuffer
                0,                              // EaLength
                CreateFileTypeNone,             // CreateFileType
                NULL,                           // ExtraCreateParameters
                0                               // Options
            );

    if( NT_SUCCESS( Status ) ) {
        Status = IoStatusBlock.Status;
    }

    if( !NT_SUCCESS(Status ) ) {
        return Status;
    }

    // The browser requires that the computer name and the domain name be
    // concatenated to the transport name and passed on. Since no length
    // fields are provided to supply the length of these two names the
    // NULL delimiter needs to be attached. This accounts for the two
    // additional characters in the calculation

    LmdrRequestPacketSize = sizeof(*pLmdrRequestPacket) +
                            pTransportName->Length +
                            SmbCeContext.DomainName.Length + sizeof(WCHAR) +
                            SmbCeContext.ComputerName.Length + sizeof(WCHAR);

    pLmdrRequestPacket = RxAllocatePoolWithTag(
                              NonPagedPool,
                              LmdrRequestPacketSize,
                              MRXSMB_TRANSPORT_POOLTAG);

    if (pLmdrRequestPacket != NULL) {
        ULONG BufferOffset = 0;
        PVOID pBuffer;
        WCHAR NullChar = L'\0';
        ULONG BindMode;

        //
        // Tell the browser to bind to this new transport
        //

        RtlZeroMemory( pLmdrRequestPacket, sizeof(LMDR_REQUEST_PACKET));
        pLmdrRequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;
        pLmdrRequestPacket->Parameters.Bind.TransportNameLength = pTransportName->Length;

        pBuffer = pLmdrRequestPacket->Parameters.Bind.TransportName;

        RtlCopyMemory(
            pBuffer,
            pTransportName->Buffer,
            pTransportName->Length);
        BufferOffset = pTransportName->Length;

        // Tell the browser our computer name.
        pLmdrRequestPacket->Level = TRUE; // Emulated computer name follows transport name.
        RtlCopyMemory(
            ((PBYTE)pBuffer + BufferOffset),
            SmbCeContext.ComputerName.Buffer,
            SmbCeContext.ComputerName.Length);
        BufferOffset += SmbCeContext.ComputerName.Length;

        RtlCopyMemory(
            ((PBYTE)pBuffer + BufferOffset),
            &NullChar,
            sizeof(WCHAR));
        BufferOffset += sizeof(WCHAR);


        // Tell the browser our domain name.
        pLmdrRequestPacket->EmulatedDomainName.Buffer = (LPWSTR)
                ((PBYTE)pBuffer + BufferOffset);
        pLmdrRequestPacket->EmulatedDomainName.MaximumLength =
                pLmdrRequestPacket->EmulatedDomainName.Length =
                SmbCeContext.DomainName.Length;
        RtlCopyMemory(
            ((PBYTE)pBuffer + BufferOffset),
            SmbCeContext.DomainName.Buffer,
            SmbCeContext.DomainName.Length);
        BufferOffset += SmbCeContext.DomainName.Length;

        RtlCopyMemory(
            ((PBYTE)pBuffer + BufferOffset),
            &NullChar,
            sizeof(WCHAR));
        BufferOffset += sizeof(WCHAR);

        BindMode = IsBind?
                   IOCTL_LMDR_BIND_TO_TRANSPORT_DOM:
                   IOCTL_LMDR_UNBIND_FROM_TRANSPORT_DOM;

        Status = NtDeviceIoControlFile(
                     BrowserHandle,                  // FileHandle
                     NULL,                           // Event
                     NULL,                           // ApcRoutine
                     NULL,                           // ApcContext
                     &IoStatusBlock,                 // IoStatusBlock
                     BindMode,                       // IoControlCode
                     pLmdrRequestPacket,             // InputBuffer
                     LmdrRequestPacketSize,          // InputBufferLength
                     NULL,                           // OutputBuffer
                     0                               // OutputBufferLength
                     );

        RxFreePool(pLmdrRequestPacket);

        if( NT_SUCCESS(Status ) ) {
            Status = IoStatusBlock.Status;
        }
    }

    ZwClose( BrowserHandle );

    return Status;
}

PSMBCE_TRANSPORT_ARRAY
SmbCeReferenceTransportArray(VOID)
/*++

Routine Description:

    This routine references and returns the current transport array instance

Return Value:

    PSMBCE_TRANSPORT_ARRAY - the pointer of the current transport array instance

Notes:

--*/
{
    KIRQL                  SavedIrql;
    PSMBCE_TRANSPORT_ARRAY pTransportArray;

    KeAcquireSpinLock(&MRxSmbTransports.Lock,&SavedIrql);

    pTransportArray = MRxSmbTransports.pTransportArray;

    if (pTransportArray != NULL) {
        InterlockedIncrement(&pTransportArray->ReferenceCount);
    }

    KeReleaseSpinLock(&MRxSmbTransports.Lock,SavedIrql);

    return pTransportArray;
}

NTSTATUS
SmbCeDereferenceTransportArray(
    PSMBCE_TRANSPORT_ARRAY pTransportArray)
/*++

Routine Description:

    This routine dereferences the transport array instance

Arguments:

    pTransportArray - the transport array instance

Return Value:

    STATUS_SUCCESS - the server transport was successfully dereferenced

    Other Status codes correspond to error situations.

Notes:

--*/
{
    KIRQL    SavedIrql;
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    if (pTransportArray != NULL) {
        ASSERT( pTransportArray->ReferenceCount > 0 );

        if(InterlockedDecrement(&pTransportArray->ReferenceCount)==0) {
            ULONG i;

            for(i=0;i<pTransportArray->Count;i++) {
                SmbCeDereferenceTransport(pTransportArray->SmbCeTransports[i]);
            }

            RxFreePool(pTransportArray->SmbCeTransports);
            RxFreePool(pTransportArray->LocalAddresses);
            RxFreePool(pTransportArray);
        }
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
SmbCeIsServerAvailable(
    PUNICODE_STRING Name
)
/*++

Routine Description:

    This routine scans the list of "unreachable" servers and returns the status
    of the last failed connection attempt.

Return:
    STATUS_SUCCESS -> we have no reason to believe this server is unreachable
    other -> server is unreachable for this reason
--*/
{
    PUNAVAILABLE_SERVER server;
    LARGE_INTEGER now;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    KeQueryTickCount( &now );

    ExAcquireResourceExclusive( &UnavailableServerListResource, TRUE );

    for( server  = (PUNAVAILABLE_SERVER)UnavailableServerList.Flink;
         server != (PUNAVAILABLE_SERVER)&UnavailableServerList;
         server  = (PUNAVAILABLE_SERVER)server->ListEntry.Flink ) {

        //
        // If this entry has timed out, remove it.
        //
        if( now.QuadPart > server->Time.QuadPart ) {
            PUNAVAILABLE_SERVER tmp;
            //
            // Unlink this entry from the list and discard it
            //
            tmp = (PUNAVAILABLE_SERVER)(server->ListEntry.Blink);
            RemoveEntryList( &server->ListEntry );
            RxFreePool( server );
            server = tmp;
            continue;
        }

        //
        // See if this entry is the one we want
        //
        if( RtlCompareUnicodeString( &server->Name, Name, TRUE ) == 0 ) {

            status = server->Status;

            RxDbgTrace(0, Dbg, ("SmbCeIsServerAvailable: Found %wZ %X\n",
                        &server->Name, status ));
        }
    }

    ExReleaseResource( &UnavailableServerListResource );

    return status;
}

VOID
SmbCeServerIsUnavailable(
    PUNICODE_STRING Name,
    NTSTATUS Status
)
{
    PUNAVAILABLE_SERVER server;

    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ExpiryTimeInTicks;

    PAGED_CODE();

    server = (PUNAVAILABLE_SERVER)RxAllocatePoolWithTag(
                                        PagedPool,
                                        sizeof( *server ) + Name->Length,
                                        MRXSMB_TRANSPORT_POOLTAG
                                        );

    if( server == NULL ) {
        return;
    }

    RxDbgTrace(0, Dbg, ("SmbCeServerIsUnavailable: Add %wZ %X\n", Name, Status ));

    server->Name.Buffer = (PUSHORT)(server + 1);
    server->Name.MaximumLength = Name->Length;
    RtlCopyUnicodeString( &server->Name, Name );

    KeQueryTickCount( &CurrentTime );

    ExpiryTimeInTicks.QuadPart = (1000 * 1000 * 10) / KeQueryTimeIncrement();

    ExpiryTimeInTicks.QuadPart = UNAVAILABLE_SERVER_TIME * ExpiryTimeInTicks.QuadPart;

    server->Time.QuadPart = CurrentTime.QuadPart + ExpiryTimeInTicks.QuadPart;

    server->Status = Status;

    ExAcquireResourceExclusive( &UnavailableServerListResource, TRUE );
    InsertHeadList( &UnavailableServerList, &server->ListEntry );
    ExReleaseResource( &UnavailableServerListResource );
}

VOID
SmbCeDiscardUnavailableServerList(
)
{
    PUNAVAILABLE_SERVER server;

    PAGED_CODE();

    RxDbgTrace(0, Dbg, ("SmbCeDiscardUnavailableServerList\n" ));

    ExAcquireResourceExclusive( &UnavailableServerListResource, TRUE );

    while( UnavailableServerList.Flink != &UnavailableServerList ) {
        server  = (PUNAVAILABLE_SERVER)UnavailableServerList.Flink;
        RemoveEntryList( &server->ListEntry );
        RxFreePool( server );
    }

    ExReleaseResource( &UnavailableServerListResource );
}

extern BOOLEAN SetupInProgress;

VOID
MRxSmbLogTransportError(
    PUNICODE_STRING pTransportName,
    PUNICODE_STRING pDomainName,
    NTSTATUS        ErrorStatus,
    IN ULONG        Id)
/*++

Routine Description:

    This routine reports the error that occurs at binding the browser with the specified transport

Arguments:

    pTransportName - the name of the transport

    Status - the NT status of the error occured

Notes:

--*/
{
    NTSTATUS Status;
    USHORT RemainingLength = ERROR_LOG_MAXIMUM_SIZE - sizeof(IO_ERROR_LOG_PACKET) - 3*sizeof(UNICODE_NULL);
    UNICODE_STRING ErrorLog[3];
    UNICODE_STRING UnicodeStatus;
    UNICODE_STRING TempUnicode;
    ULONG DosError;

    // strip of the "\device\" at the beginning of transport name to reduce the message length
    pTransportName->Length -= 8*sizeof(UNICODE_NULL);

    // assume the dos error code won't be larger than 10 digits
    UnicodeStatus.Length = 12 * sizeof(UNICODE_NULL);
    UnicodeStatus.MaximumLength = UnicodeStatus.Length;
    UnicodeStatus.Buffer = RxAllocatePoolWithTag(NonPagedPool,
                                              UnicodeStatus.Length,
                                              MRXSMB_TRANSPORT_POOLTAG);
    if (UnicodeStatus.Buffer == NULL) {
        goto FINALY;
    }

    // use the dos error code to display the status on the event message
    UnicodeStatus.Buffer[0] = L'%';
    UnicodeStatus.Buffer[1] = L'%';

    DosError = RtlNtStatusToDosError(ErrorStatus);

    TempUnicode.Length = UnicodeStatus.Length - 2*sizeof(UNICODE_NULL);
    TempUnicode.MaximumLength = UnicodeStatus.MaximumLength - 2*sizeof(UNICODE_NULL);
    TempUnicode.Buffer = &UnicodeStatus.Buffer[2];

    Status = RtlIntegerToUnicodeString(
                 DosError,
                 0,
                 &TempUnicode);

    if (Status != STATUS_SUCCESS) {
        goto FINALY;
    }

    ErrorLog[2].Length = TempUnicode.Length + 2*sizeof(UNICODE_NULL);
    ErrorLog[2].MaximumLength = ErrorLog[2].Length;
    ErrorLog[2].Buffer = UnicodeStatus.Buffer;

    RemainingLength -= ErrorLog[2].Length;

    if (pDomainName->Length + pTransportName->Length > RemainingLength) {
        // the length error log message is limited by the ERROR_LOG_MAXIMUM_SIZE. This restriction can be
        // enfored by truncating the doamin and transport names so that both of them can get chance to be
        // displayed on the EvenLog.

        ErrorLog[0].Length = pDomainName->Length < RemainingLength / 2 ?
                             pDomainName->Length :
                             RemainingLength / 2;

        RemainingLength -= ErrorLog[0].Length;

        ErrorLog[1].Length = pTransportName->Length < RemainingLength ?
                             pTransportName->Length :
                             RemainingLength;
    } else {
        ErrorLog[0].Length = pDomainName->Length;
        ErrorLog[1].Length = pTransportName->Length;
    }

    ErrorLog[0].MaximumLength = ErrorLog[0].Length;
    ErrorLog[1].MaximumLength = ErrorLog[1].Length;

    ErrorLog[0].Buffer = pDomainName->Buffer;

    // strip of the "\device\" at the beginning of transport name
    ErrorLog[1].Buffer = &pTransportName->Buffer[8];

    RxLogEventWithAnnotation (
        MRxSmbDeviceObject,
        Id,
        ErrorStatus,
        NULL,
        0,
        ErrorLog,
        3
        );

FINALY:

    // restore the length with "\device\" at the beginning of transport name
    pTransportName->Length += 8*sizeof(UNICODE_NULL);

    if (UnicodeStatus.Buffer != NULL) {
        RxFreePool(UnicodeStatus.Buffer);
    }

    if (!SetupInProgress && ErrorStatus == STATUS_DUPLICATE_NAME) {
        IoRaiseInformationalHardError(ErrorStatus, NULL, NULL);
    }
}


VOID
SmbMRxNotifyChangesToNetBt(
    IN TDI_PNP_OPCODE   PnPOpcode,
    IN PUNICODE_STRING  DeviceName,
    IN PWSTR            MultiSZBindList)

/*++

Routine Description:

    This routine should not be part of rdr. It has been introduced into this
    component to overcome current limitations in NetBt. The NetBt transport
    exposes two  kinds of devices -- the traditional NetBt device and the
    new non Netbios device which make use of the NetBt framing code without the
    name resolution aspects of it. The current implementation in NetBt exposes
    the former devices on a per adapter basis while the second category of device
    is exposed on a global basis ( one for all the adapters ). This poses
    problems in disabling/enabling srv on a given adapter.

    The correct solution is to expose the second category of devices on a per
    adapter basis. Till it is done this workaround is reqd. With this workaround
    whenever the server is notified of any changes to the binding string it turns
    around and notifies the NetBt transport about these changes.

    This routine is based upon the following assumptions ...

        1) The notification from TDI is not done at raised IRQL.

        2) The thread on which this notification occurs has enough access rights.

        3) The notification to NetBt is done asynchronously with srv's reaction
        to the change. The srv handles the PNP notification by passing it off to
        user mode and have it come through the server service.

Arguments:

    PNPOpcode - the PNP opcode

    DeviceName - the transport for which this opcode is intended

    MultiSZBindList - the binding list

Return Value:

    None.

--*/
{
    NTSTATUS          Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE            NetbioslessSmbHandle;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    NetbioslessSmbName = {36,36, L"\\device\\NetbiosSmb"};

    InitializeObjectAttributes(
        &ObjectAttributes,
        &NetbioslessSmbName,
        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
        NULL,
        NULL );

    Status = ZwCreateFile (
                 &NetbioslessSmbHandle,
                 FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES, // desired access
                 &ObjectAttributes,     // object attributes
                 &IoStatusBlock,        // returned status information
                 NULL,                  // block size (unused)
                 0,                     // file attributes
                 FILE_SHARE_READ | FILE_SHARE_WRITE, // share access
                 FILE_CREATE,           // create disposition
                 0,                     // create options
                 NULL,                  // EA buffer
                 0                      // EA length
                 );

    if ( NT_SUCCESS(Status) ) {
        NETBT_SMB_BIND_REQUEST      NetBtNotificationParameters;

        NetBtNotificationParameters.RequestType = SMB_CLIENT;
        NetBtNotificationParameters.PnPOpCode   = PnPOpcode;
        NetBtNotificationParameters.pDeviceName = DeviceName;
        NetBtNotificationParameters.MultiSZBindList = MultiSZBindList;

        Status = ZwDeviceIoControlFile(
                     NetbioslessSmbHandle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     IOCTL_NETBT_SET_SMBDEVICE_BIND_INFO,
                     &NetBtNotificationParameters,
                     sizeof(NetBtNotificationParameters),
                     NULL,
                     0);

        Status = ZwClose(NetbioslessSmbHandle);
    }
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\vcsndrcv.h ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    vcsndrcv.h

Abstract:

    This is the include file that defines all constants and types for VC
    (Virtual Circuit) related Send/Receive/INitialization etc.

Revision History:

    Balan Sethu Raman (SethuR) 06-Mar-95    Created

Notes:

--*/

#ifndef _VCSNDRCV_H_
#define _VCSNDRCV_H_

// The connection oriented transport to a server can utilize multiple VC's to
// acheive better throughput to a server. It is for this reason that the
// VC transport data structure is built around multiple VC's. Howvever this
// feature is not utilized currently.
//
// Though the SMB protocol permits multiple number of VC's to be associated with
// a particular connection to a share, the data transfer of data is done in the
// raw mode. In this mode of operation the SMB protocol does not permit multiple
// outstanding requests. In the SMB protocol a number of requests can be multiplexed
// along a connection to the server There are certain kind of requests which can
// be completed on the client, i.e., no acknowledgement is neither expected nor
// received. In these cases the send call is completed synchronoulsy. On the
// other hand there is a second class of sends which cannot be resumed locally
// till the appropriate acknowledgement is recieved from the server. In such
// cases a list of requests is built up with each VC. On receipt of the appropriate
// acknowledgement these requests are resumed.
//

typedef enum _SMBCE_VC_STATE_ {
    SMBCE_VC_STATE_MULTIPLEXED,
    SMBCE_VC_STATE_RAW,
    SMBCE_VC_STATE_DISCONNECTED,
} SMBCE_VC_STATE, *PSMBCE_VC_STATE;

typedef struct _SMBCE_VC {
    SMBCE_OBJECT_HEADER;                // the struct header

    RXCE_VC     RxCeVc;

    NTSTATUS    Status;      // Status of the VC.
} SMBCE_VC, *PSMBCE_VC;

typedef struct SMBCE_SERVER_VC_TRANSPORT {
    SMBCE_SERVER_TRANSPORT;     // Anonymous struct for common fields

    RXCE_CONNECTION RxCeConnection;     // the connection handle
    LARGE_INTEGER   Delay;           // the estimated delay on the connection
    ULONG           MaximumNumberOfVCs;

    SMBCE_VC                    Vcs[1];          // Vcs associated with the connection.
} SMBCE_SERVER_VC_TRANSPORT, *PSMBCE_SERVER_VC_TRANSPORT;


#define VctReferenceVc(pVc)                           \
            InterlockedIncrement(&(pVc)->SwizzleCount)

#define VctReferenceVcLite(pVc)                       \
            ASSERT(SmbCeSpinLockAcquired());                    \
            (pVc)->SwizzleCount++


#define VctDereferenceVc(pVc)                           \
            InterlockedDecrement(&(pVc)->SwizzleCount)

#define VctDereferenceVcLite(pVc)                       \
            ASSERT(SmbCeSpinLockAcquired());                    \
            (pVc)->SwizzleCount--

#endif // _VCSNDRCV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\vnrcntxt.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    smbcedb.c

Abstract:

    This module implements all functions related to accessing the SMB connection engine
    database

Revision History:

    Balan Sethu Raman     [SethuR]    6-March-1995

Notes:

    The mapping between MRX_V_NET_ROOT and a mini rdr data structure is a many to
    one relationship, i.e., more than one MRX_V_NET_ROOT instance can be associated with the
    same mini rdr data structure.

--*/

#include "precomp.h"
#pragma hdrstop

#include "exsessup.h"
#include "secext.h"

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, SmbCeCompleteVNetRootContextInitialization)
#pragma alloc_text(PAGE, SmbCeDestroyAssociatedVNetRootContext)
#pragma alloc_text(PAGE, SmbCeTearDownVNetRootContext)
#endif

RXDT_Extern(SMBCEDB);
#define Dbg        (DEBUG_TRACE_SMBCEDB)

extern BOOLEAN Win9xSessionRestriction;

PSMBCE_V_NET_ROOT_CONTEXT
SmbCeFindVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXTS pVNetRootContexts,
    PSMBCEDB_SERVER_ENTRY      pServerEntry,
    PSMBCEDB_SESSION_ENTRY     pSessionEntry,
    PSMBCEDB_NET_ROOT_ENTRY    pNetRootEntry,
    BOOLEAN                    fCscAgentOpen)
/*++

Routine Description:

    This routine finds a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:
    pVNetRootContexts - list of VNetRootContexts for searching
    
    PServerEntry - the ServerEntry should be the same as the one on found VNetRootContext
    
    PSessionEntry - the SessionEntry should be the same as the one on found VNetRootContext
    
    pNetRootEntry - the NetRootEntry should be the same as the one on found VNetRootContext
  
    fCscAgentOpen - this V_NET_ROOT_CONTEXT instance is being created for the CSC
                    agent

Return Value:

    VNetRootContext if found

Notes:

--*/
{
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;

    pVNetRootContext = SmbCeGetFirstVNetRootContext(
                            pVNetRootContexts);

    while (pVNetRootContext != NULL) {
        if ((pVNetRootContext->pServerEntry  == pServerEntry)  &&
            (pVNetRootContext->pSessionEntry == pSessionEntry) &&
            (pVNetRootContext->pNetRootEntry == pNetRootEntry) &&
            (BooleanFlagOn(pVNetRootContext->Flags,
                           SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE) == fCscAgentOpen)) {

            SmbCeRemoveVNetRootContext(
                pVNetRootContexts,
                pVNetRootContext);

            SmbCeAddVNetRootContext(
                &pServerEntry->VNetRootContexts,
                pVNetRootContext);

            InterlockedDecrement(&pServerEntry->Server.NumberOfVNetRootContextsForScavenging);
            SmbCeLog(("CachedVNRContext(S) %lx\n",pVNetRootContext));
            SmbLog(LOG,
                   SmbCeFindVNetRootContext,
                   LOGPTR(pVNetRootContext));
            break;
        } else {
            pVNetRootContext = SmbCeGetNextVNetRootContext(
                                   pVNetRootContexts,
                                   pVNetRootContext);
        }
    }

    return pVNetRootContext;
}

NTSTATUS
SmbCeFindOrConstructVNetRootContext(
    PMRX_V_NET_ROOT         pVNetRoot,
    BOOLEAN                 fDeferNetworkInitialization,
    BOOLEAN                 fCscAgentOpen)
/*++

Routine Description:

    This routine finds or constructs a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pVNetRoot - the MRX_V_NET_ROOT instance

    fDeferNetworkInitialization - a directive to delay network initialization for new
                                  instances.

    fCscAgentOpen - this V_NET_ROOT_CONTEXT instance is being created for the CSC
                    agent

Return Value:

    STATUS_SUCCESS if the MRX_V_NET_ROOT instance was successfully initialized

Notes:

    The algorithm that has been implemented tries to delay the construction of a
    new instance as much as possible. It does this be either reusing a context
    that has already been active or a context instance that has been marked for
    scavenging but has not been scavenged.

--*/
{
    NTSTATUS Status;

    PMRX_SRV_CALL pSrvCall;
    PMRX_NET_ROOT pNetRoot;

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;

    PSMBCEDB_SERVER_ENTRY   pServerEntry  = NULL;
    PSMBCEDB_SESSION_ENTRY  pSessionEntry = NULL;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = NULL;

    BOOLEAN  fInitializeNetRoot;
    BOOLEAN  fDereferenceSessionEntry = FALSE;
    BOOLEAN  fDereferenceNetRootEntry = FALSE;

    pNetRoot = pVNetRoot->pNetRoot;
    pSrvCall = pNetRoot->pSrvCall;

    SmbCeAcquireResource();

    pServerEntry = SmbCeGetAssociatedServerEntry(pSrvCall);

    // The V_NET_ROOT is associated with a NET_ROOT. The two cases of interest are as
    // follows
    // 1) the V_NET_ROOT and the associated NET_ROOT are being newly created.
    // 2) a new V_NET_ROOT associated with an existing NET_ROOT is being created.
    //
    // These two cases can be distinguished by checking if the context associated with
    // NET_ROOT is NULL. Since the construction of NET_ROOT's/V_NET_ROOT's are serialized
    // by the wrapper this is a safe check.
    // ( The wrapper cannot have more then one thread tryingto initialize the same
    // NET_ROOT).

    pNetRootEntry = (PSMBCEDB_NET_ROOT_ENTRY)pNetRoot->Context;
    fInitializeNetRoot = (pNetRootEntry == NULL);

    pVNetRoot->Context = NULL;

    // Find or construct the session entry that will be associated with the context. The
    // one error that deserves special consideration is STATUS_NETWORK_CREDENTIAL_CONFLICT.
    // This error signifies that the credentials presented with the MRX_V_NET_ROOT instance
    // conflicted with an existing session. This conflict could be either becuase there
    // exists an active session or because a previously active session is awaiting
    // scavenging. In the former case the error needs to be propagated back but in the
    // later case the contexts must be selectively scavenged.
    //
    // The scavenging should be limited only to those contexts to the appropriate server.

    Status = SmbCeFindOrConstructSessionEntry(
                 pVNetRoot,
                 &pSessionEntry);


    if (Status == STATUS_NETWORK_CREDENTIAL_CONFLICT) {
        NTSTATUS ScavengingStatus;

        SmbCeReleaseResource();

        ScavengingStatus = SmbCeScavengeRelatedContexts(pServerEntry);

        if (ScavengingStatus == STATUS_SUCCESS) {
            SmbCeAcquireResource();

            Status = SmbCeFindOrConstructSessionEntry(
                         pVNetRoot,
                         &pSessionEntry);
        } else {
            return Status;
        }
    }

    fDereferenceSessionEntry = (Status == STATUS_SUCCESS);

    if (Status == STATUS_SUCCESS) {
        if (fInitializeNetRoot) {
            pNetRoot->MRxNetRootState = MRX_NET_ROOT_STATE_GOOD;

            // Initialize the device type and state for a new MRX_NET_ROOT instance
            switch (pNetRoot->Type) {
            case NET_ROOT_DISK:
               {
                   pNetRoot->DeviceType = RxDeviceType(DISK);

                   RxInitializeNetRootThrottlingParameters(
                       &pNetRoot->DiskParameters.LockThrottlingParameters,
                       MRxSmbConfiguration.LockIncrement,
                       MRxSmbConfiguration.MaximumLock
                       );
               }
               break;

            case NET_ROOT_PIPE:
               {
                   pNetRoot->DeviceType = RxDeviceType(NAMED_PIPE);

                   RxInitializeNetRootThrottlingParameters(
                       &pNetRoot->NamedPipeParameters.PipeReadThrottlingParameters,
                       MRxSmbConfiguration.PipeIncrement,
                       MRxSmbConfiguration.PipeMaximum
                       );
               }
               break;
            case NET_ROOT_COMM:
               pNetRoot->DeviceType = RxDeviceType(SERIAL_PORT);
               break;
            case NET_ROOT_PRINT:
               pNetRoot->DeviceType = RxDeviceType(PRINTER);
               break;
            case NET_ROOT_MAILSLOT:
               pNetRoot->DeviceType = RxDeviceType(MAILSLOT);
               break;
            case NET_ROOT_WILD:
               break;
            default:
               ASSERT(!"Valid Net Root Type");
            }

            Status = SmbCeFindOrConstructNetRootEntry(
                         pNetRoot,
                         &pNetRootEntry);

            RxDbgTrace( 0, Dbg, ("SmbCeOpenNetRoot %lx\n",Status));
        } else {
            SmbCeLog(("ReuseNREntry %lx\n",pNetRootEntry));
            SmbLog(LOG,
                   SmbCeFindOrConstructVNetRootContext_1,
                   LOGPTR(pNetRootEntry));
            SmbCeReferenceNetRootEntry(pNetRootEntry);
        }

        fDereferenceNetRootEntry = (Status == STATUS_SUCCESS);
    }

    if (Status == STATUS_SUCCESS) {
        pVNetRootContext = SmbCeFindVNetRootContext(
                               &pServerEntry->VNetRootContexts,
                               pServerEntry,
                               pSessionEntry,
                               pNetRootEntry,
                               fCscAgentOpen);

        if (pVNetRootContext == NULL) {
            pVNetRootContext = SmbCeFindVNetRootContext(
                                   &MRxSmbScavengerServiceContext.VNetRootContexts,
                                   pServerEntry,
                                   pSessionEntry,
                                   pNetRootEntry,
                                   fCscAgentOpen);
        }

        if (pVNetRootContext != NULL) {
            // An existing instance can be reused. No more work to be done
            SmbCeReferenceVNetRootContext(pVNetRootContext);
        } else {
            // None of the existing instances can be reused. A new instance needs to be
            // constructed.

            pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)
                               RxAllocatePoolWithTag(
                                    NonPagedPool,
                                    sizeof(SMBCE_V_NET_ROOT_CONTEXT),
                                    MRXSMB_VNETROOT_POOLTAG);

            if (pVNetRootContext != NULL) {
                // Initialize the new instance

                RtlZeroMemory(
                    pVNetRootContext,
                    sizeof(SMBCE_V_NET_ROOT_CONTEXT));

                // Transfer the references made during the construction of the session and
                // the net root entries to the new context. Disable the dereferencing at
                // the end of this routine.

                fDereferenceSessionEntry = FALSE;
                fDereferenceNetRootEntry = FALSE;

                SmbCeReferenceServerEntry(pServerEntry);

                pVNetRootContext->Header.NodeType = SMB_CONNECTION_ENGINE_NTC(
                                                        SMBCEDB_OT_VNETROOTCONTEXT);

                if (pNetRootEntry->NetRoot.NetRootType == NET_ROOT_MAILSLOT) {
                    pVNetRootContext->Header.State = SMBCEDB_ACTIVE;
                } else {
                    pVNetRootContext->Header.State = SMBCEDB_INVALID;
                }

                pVNetRootContext->Flags = 0;

                if (fCscAgentOpen) {
                    pVNetRootContext->Flags |= SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE;

                }

                InitializeListHead(&pVNetRootContext->Requests.ListHead);

                pVNetRootContext->pServerEntry  = pServerEntry;
                pVNetRootContext->pSessionEntry = pSessionEntry;
                pVNetRootContext->pNetRootEntry = pNetRootEntry;

                SmbCeReferenceVNetRootContext(pVNetRootContext);

                // Add it to the list of active contexts
                SmbCeAddVNetRootContext(
                    &pServerEntry->VNetRootContexts,
                    pVNetRootContext);

                SmbCeLog(("NewVNetRootContext %lx\n",pVNetRootContext));
                SmbLog(LOG,
                       SmbCeFindOrConstructVNetRootContext_2,
                       LOGPTR(pVNetRootContext));
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    if (Status == STATUS_SUCCESS) {
        // If everything was successful set up the MRX_V_NET_ROOT and MRX_NET_ROOT
        // instances
        pVNetRoot->Context = pVNetRootContext;
        pVNetRootContext->pRdbssVNetRoot = pVNetRoot;

        if (fInitializeNetRoot) {
            ASSERT(pNetRootEntry->pRdbssNetRoot == NULL);

            InterlockedExchangePointer(
                &pNetRootEntry->pRdbssNetRoot,
                pNetRoot);

            SmbCeUpdateNetRoot(pNetRootEntry,pNetRoot);

            SmbCeReferenceNetRootEntry(pNetRootEntry);
            pNetRoot->Context = pNetRootEntry;
        } else {
            if (FlagOn(pNetRoot->Flags,NETROOT_FLAG_FINALIZE_INVOKED)) {
                ClearFlag(pNetRoot->Flags,NETROOT_FLAG_FINALIZE_INVOKED);
                SmbCeReferenceNetRootEntry(pNetRootEntry);
            }
        }

        InterlockedIncrement(&pSessionEntry->Session.NumberOfActiveVNetRoot);
    } else {
        pVNetRoot->Context = NULL;
        if (fInitializeNetRoot) {
            pNetRoot->Context  = NULL;
        }
    }

    SmbCeReleaseResource();

    if (fDereferenceSessionEntry) {
        SmbCeDereferenceSessionEntry(pSessionEntry);
    }

    if (fDereferenceNetRootEntry) {
        SmbCeDereferenceNetRootEntry(pNetRootEntry);
    }

    if (!fDeferNetworkInitialization &&
        (Status == STATUS_SUCCESS)) {

        Status = STATUS_MORE_PROCESSING_REQUIRED;
    }

    if (SmbCeGetServerType(pServerEntry) == SMBCEDB_FILE_SERVER) {
        ASSERT((Status != STATUS_SUCCESS) || (pVNetRoot->Context != NULL));
    }

    return Status;
}

VOID
SmbCeCompleteVNetRootContextInitialization(
    PVOID  pContext)
/*++

Routine Description:

    This routine is invoked in the context of a worker thread to finalize the
    construction of a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pContext  - the SMBCE_V_NET_ROOT_CONTEXT instance


Notes:

    PRE_CONDITION: The VNetRootContext must have been referenced to ensure that
    even it has been finalized it will not be deleted.

--*/
{
    NTSTATUS Status;

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    PSMBCEDB_REQUEST_ENTRY    pRequestEntry;
    SMBCEDB_REQUESTS          Requests;

    PAGED_CODE();

    RxDbgTrace( 0, Dbg, ("Net Root Entry Finalization\n"));

    pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)pContext;

    ASSERT(pVNetRootContext->Header.ObjectType == SMBCEDB_OT_VNETROOTCONTEXT);

    SmbCeAcquireResource();
    
    pVNetRootContext->pExchange = NULL;

    SmbCeTransferRequests(&Requests,&pVNetRootContext->Requests);

    if (pVNetRootContext->Header.State == SMBCEDB_ACTIVE) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INVALID_CONNECTION;
        SmbCeUpdateVNetRootContextState(
            pVNetRootContext,
            SMBCEDB_INVALID);
    }

    SmbCeReleaseResource();

    // Iterate over the list of pending requests and resume all of them
    SmbCeResumeOutstandingRequests(&Requests,Status);

    SmbCeDereferenceVNetRootContext(pVNetRootContext);
}

VOID
SmbCepDereferenceVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext)
/*++

Routine Description:

    This routine dereferences a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pVNetRootContext  - the SMBCE_V_NET_ROOT_CONTEXT instance

Notes:

    There are two intersting points to note. A mini redirector can avoid potential
    network traffic by delaying the scavenging of the SMBCE_V_NET_ROOT_CONTEXT
    instance since it contains all the relevant network setup to satisfy requests.

    This is a policy that is implemented in the mini redirector and is different from
    the wrapper policies.

    Once the decision to delay scavenging has been made, there are two options. The
    successful and unsuccessful instances can be delayed or only the successful
    instances. The current algorithm is to delay the scavenging of the successful
    SMBCE_V_NET_ROOT_CONTEXT instances only.

    Also there are three components to a VNetRootContext that can be scavenged
    independently. If the server exists and a session setup to the server fails
    because of wrong credentials there is no point in throwing away the server
    entry eagerly. This routine selectively gathers the failed fields for eager
    scavenging and retains the VNetRootContext skeleton alongwith the other
    structures that can be deferred.

--*/
{
    if (pVNetRootContext != NULL) {
        LONG FinalRefCount;

        FinalRefCount = InterlockedDecrement(
                            &pVNetRootContext->Header.SwizzleCount);

        if (FinalRefCount == 0) {
            LARGE_INTEGER CurrentTime;
            BOOLEAN       TearDownVNetRootContext = FALSE;

            PSMBCE_SERVER           pServer = &pVNetRootContext->pServerEntry->Server;
            PSMBCE_SESSION          pSession = &pVNetRootContext->pSessionEntry->Session;

            SmbCeAcquireResource();

            if (pVNetRootContext->Header.SwizzleCount == 0) {
                // Remove the instance from the active list of contexts to the server.
                SmbCeRemoveVNetRootContext(
                    &pVNetRootContext->pSessionEntry->pServerEntry->VNetRootContexts,
                    pVNetRootContext);

                // if it was a successful instance mark it for scavenging, otherwise
                // tear it down immediately

                if ((pVNetRootContext->pSessionEntry != NULL) &&
                    (pVNetRootContext->pSessionEntry->Header.State != SMBCEDB_ACTIVE ||
                     pSession->pUserName != NULL ||
                     pSession->pPassword != NULL ||
                     pSession->pUserDomainName != NULL)) {
                    TearDownVNetRootContext = TRUE;
                }

                if ((pVNetRootContext->pNetRootEntry != NULL) &&
                    (pVNetRootContext->pNetRootEntry->Header.State != SMBCEDB_ACTIVE ||
                     TearDownVNetRootContext)) {
                    TearDownVNetRootContext = TRUE;
                }

                if (Win9xSessionRestriction &&
                    (pVNetRootContext->pServerEntry != NULL) &&
                    FlagOn(pVNetRootContext->pServerEntry->Server.DialectFlags,DF_W95)) {
                    TearDownVNetRootContext = TRUE;
                }

                InterlockedIncrement(&pServer->NumberOfVNetRootContextsForScavenging);

                if (!TearDownVNetRootContext &&
                    (pVNetRootContext->pNetRootEntry != NULL) &&
                    (pVNetRootContext->pSessionEntry != NULL) &&
                    pServer->NumberOfVNetRootContextsForScavenging < MaximumNumberOfVNetRootContextsForScavenging) {

                    ClearFlag(pVNetRootContext->Flags, SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE);

                    KeQueryTickCount( &CurrentTime );

                    pVNetRootContext->ExpireTime.QuadPart = CurrentTime.QuadPart +
                        (LONGLONG) ((MRXSMB_V_NETROOT_CONTEXT_SCAVENGER_INTERVAL * 10 * 1000 * 1000) / KeQueryTimeIncrement());

                    SmbCeAddVNetRootContext(
                        &MRxSmbScavengerServiceContext.VNetRootContexts,
                        pVNetRootContext);

                    MRxSmbActivateRecurrentService(
                        (PRECURRENT_SERVICE_CONTEXT)&MRxSmbScavengerServiceContext);

                    SmbCeLog(("ScavngVNetRootCntxt %lx\n",pVNetRootContext));
                    SmbLog(LOG,
                           SmbCepDereferenceVNetRootContext,
                           LOGPTR(pVNetRootContext));
                } else {
                    TearDownVNetRootContext = TRUE;
                }
            }

            SmbCeReleaseResource();

            if (TearDownVNetRootContext) {
                pVNetRootContext->Header.State = SMBCEDB_MARKED_FOR_DELETION;
                SmbCeTearDownVNetRootContext(pVNetRootContext);
            }
        }
    }
}

NTSTATUS
SmbCeDestroyAssociatedVNetRootContext(
    PMRX_V_NET_ROOT pVNetRoot)
/*++

Routine Description:

    This routine derferences a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pVNetRootContext - the SMBCE_V_NET_ROOT_CONTEXT instance to be dereferenced

--*/
{
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    PAGED_CODE();

    pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)pVNetRoot->Context;

    if (pVNetRootContext != NULL) {
        pVNetRootContext->pRdbssVNetRoot = NULL;

        SmbCeDecrementNumberOfActiveVNetRootOnSession(pVNetRootContext);
        SmbCeDereferenceVNetRootContext(pVNetRootContext);
    }

    pVNetRoot->Context = NULL;
    
    return STATUS_SUCCESS;
}

VOID
SmbCeTearDownVNetRootContext(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext)
/*++

Routine Description:

    This routine tears down a SMBCE_V_NET_ROOT_CONTEXT instance

Arguments:

    pVNetRootContext - the SMBCE_V_NET_ROOT_CONTEXT instance to be torn down

--*/
{
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    PAGED_CODE();

    SmbCeLog(("TearVNetRootContext %lx\n",pVNetRootContext));
    SmbLog(LOG,
           SmbCeTearDownVNetRootContext,
           LOGPTR(pVNetRootContext));

    pNetRootEntry = pVNetRootContext->pNetRootEntry;

    if ((pNetRootEntry != NULL) &&
        BooleanFlagOn(pVNetRootContext->Flags,SMBCE_V_NET_ROOT_CONTEXT_FLAG_VALID_TID) &&
        (SmbCeGetServerType(pVNetRootContext->pServerEntry) == SMBCEDB_FILE_SERVER)) {

        SmbCeDisconnect(pVNetRootContext);
    }

    if (pNetRootEntry != NULL) {
        pVNetRootContext->pNetRootEntry = NULL;
        SmbCeDereferenceNetRootEntry(pNetRootEntry);
    }

    if (pVNetRootContext->pSessionEntry != NULL) {
        SmbCeDereferenceSessionEntry(pVNetRootContext->pSessionEntry);
    }

    InterlockedDecrement(&pVNetRootContext->pServerEntry->Server.NumberOfVNetRootContextsForScavenging);

    SmbCeDereferenceServerEntry(pVNetRootContext->pServerEntry);

    RxFreePool(pVNetRootContext);
}

NTSTATUS
SmbCeScavenger(
    PVOID pContext)
/*++

Routine Description:

    This routine scavenges SMBCE_V_NET_ROOT_CONTEXT instances

Arguments:

    pContext - the scavenger service context

Notes:

    Since the contexts for scavenging are threaded together in an entry that
    is managed in a FIFO fashion, if the first entry fails the time interval
    test ( expiry time has not elapsed ) all the other entries in the list
    are guaranteed to fail the test. This is an important property that eases
    the implementation of scavenging.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PMRXSMB_SCAVENGER_SERVICE_CONTEXT pScavengerServiceContext;
    LARGE_INTEGER             CurrentTime;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;
    BOOLEAN                   fTerminateScavenging = FALSE;

    pScavengerServiceContext = (PMRXSMB_SCAVENGER_SERVICE_CONTEXT)pContext;

    do {

        SmbCeAcquireResource();

        KeQueryTickCount( &CurrentTime );

        pVNetRootContext = SmbCeGetFirstVNetRootContext(
                               &pScavengerServiceContext->VNetRootContexts);

        fTerminateScavenging = (pVNetRootContext == NULL);

        if (!fTerminateScavenging) {
            if ((CurrentTime.QuadPart >= pVNetRootContext->ExpireTime.QuadPart) ||
                (pScavengerServiceContext->RecurrentServiceContext.State == RECURRENT_SERVICE_SHUTDOWN)) {
                SmbCeRemoveVNetRootContext(
                    &pScavengerServiceContext->VNetRootContexts,
                    pVNetRootContext);
            } else {
                fTerminateScavenging = TRUE;
            }
        }

        SmbCeReleaseResource();

        if (!fTerminateScavenging &&
            (pVNetRootContext != NULL)) {
            SmbCeTearDownVNetRootContext(pVNetRootContext);
        }
    } while (!fTerminateScavenging);

    return Status;
}

NTSTATUS
SmbCeScavengeRelatedContexts(
    PSMBCEDB_SERVER_ENTRY pServerEntry)
/*++

Routine Description:

    This routine scavenges SMBCE_V_NET_ROOT_CONTEXT instances for a given
    server entry

Arguments:

    pServerEntry - the server entry

Notes:

--*/
{
    NTSTATUS Status;
    SMBCE_V_NET_ROOT_CONTEXTS VNetRootContexts;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    InitializeListHead(&VNetRootContexts.ListHead);

    SmbCeAcquireResource();

    pVNetRootContext = SmbCeGetFirstVNetRootContext(
                           &MRxSmbScavengerServiceContext.VNetRootContexts);
    while (pVNetRootContext != NULL) {
        PSMBCE_V_NET_ROOT_CONTEXT pNextVNetRootContext;


        pNextVNetRootContext = SmbCeGetNextVNetRootContext(
                                   &MRxSmbScavengerServiceContext.VNetRootContexts,
                                   pVNetRootContext);

        if (pVNetRootContext->pServerEntry == pServerEntry) {
            SmbCeRemoveVNetRootContext(
                &MRxScavengerServiceContext.VNetRootContexts,
                pVNetRootContext);

            SmbCeAddVNetRootContext(
                &VNetRootContexts,
                pVNetRootContext);
        }

        pVNetRootContext = pNextVNetRootContext;
    }

    SmbCeReleaseResource();

    pVNetRootContext = SmbCeGetFirstVNetRootContext(
                           &VNetRootContexts);

    if (pVNetRootContext != NULL) {
        do {
            SmbCeRemoveVNetRootContext(
                &VNetRootContexts,
                pVNetRootContext);

            SmbCeTearDownVNetRootContext(pVNetRootContext);

            pVNetRootContext = SmbCeGetFirstVNetRootContext(
                                   &VNetRootContexts);
        } while ( pVNetRootContext != NULL );

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    SmbCeLog(("Scavctxts Srv %lx Status %lx\n",pServerEntry,Status));
    SmbLog(LOG,
           SmbCeScavengeRelatedContexts,
           LOGULONG(Status)
           LOGPTR(pServerEntry)
           LOGUSTR(pServerEntry->Name));

    return Status;
}

VOID
SmbCeDecrementNumberOfActiveVNetRootOnSession(
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext
    )
{
    ULONG   NumberOfVNetRoot;
    BOOLEAN fLogOffRequired = FALSE;

    PSMBCEDB_SERVER_ENTRY  pServerEntry = NULL;
    PSMBCEDB_SESSION_ENTRY pSessionEntry = NULL;

    SmbCeAcquireResource();

    NumberOfVNetRoot = InterlockedDecrement(&pVNetRootContext->pSessionEntry->Session.NumberOfActiveVNetRoot);

    if (NumberOfVNetRoot == 0) {
        pSessionEntry = pVNetRootContext->pSessionEntry;
        pServerEntry  = pVNetRootContext->pServerEntry;

        if (!FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_LOGGED_OFF)) {
            SmbCeRemoveSessionEntry(pServerEntry,pSessionEntry);
            SmbCeRemoveDefaultSessionEntry(pSessionEntry);
        }

        if ((pSessionEntry->Session.UserId != (SMB_USER_ID)(SMBCE_SHARE_LEVEL_SERVER_USERID)) &&
            (pSessionEntry->Session.UserId != 0) &&
            (pSessionEntry->Header.State == SMBCEDB_ACTIVE) &&
            !FlagOn(pSessionEntry->Session.Flags,SMBCE_SESSION_FLAGS_LOGGED_OFF)) {
            SmbCeReferenceServerEntry(pServerEntry);
            SmbCeReferenceSessionEntry(pSessionEntry);
            fLogOffRequired = TRUE;
        }

        // all the consequent requests on this session should fail
        pSessionEntry->Header.State = SMBCEDB_MARKED_FOR_DELETION;
        pSessionEntry->Session.Flags |= SMBCE_SESSION_FLAGS_LOGGED_OFF;
        pSessionEntry->Session.Flags |= SMBCE_SESSION_FLAGS_MARKED_FOR_DELETION;
    }

    SmbCeReleaseResource();

    if (fLogOffRequired) {
        SmbCeLogOff(pServerEntry,pSessionEntry);
        SmbCeDereferenceServerEntry(pServerEntry);
    }
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\chunk.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Chunk.c

Abstract:

    This module implements the copychunk interface for the smbcsc agent.

Author:

    Joe Linn [JoeLinn]    10-apr-1997

Revision History:

Notes:

The following describes the intended implementation.

On win95, the following sequence is performed:

    Win32OpenWithCopyChunkIntent ();
    while (MoreToDo()) {
        Win32CopyChunk();
    }
    Win32CloseWithCopyChunkIntent ();

Win32OpenWithCopyChunkIntent and Win32CloseWithCopyChunkIntent are implemented
by Win32 open and close operations; CopyChunk is an ioctl. On NT, all three
operations will be performed by ioctls. Internally, the will allow internal
NT-only calls to be used as appropriate. A major advantage of implementing
Win32OpenWithCopyChunkIntent as an ioctl is that the intent is unambiguously
captured.

A wrapper modification has been  made whereby a calldown to the minirdr is
made before collapsing is tried..a minirdr is able to bypass collapsing using
this calldown.

There are two important cases: surrogate opens and copychunk-thru opens. For
surrogate opens, the mini is able to discover an existing srvopen (the
surrogate) with read access. Here, the mini simply records the surrogate
srvopen (and surrounding UID/PID in the smbFcb for use later with the read.
For copychunk-thru opens, the mini must go on the wire with an open. When complete,
it records in the smbFcb all of the appropriate stuff.

Thus, when a OpenWithCopyChunkIntent comes in one of the following will obtain:
   1. a surrogate can be found; information is recorded and the open succeeds
   2. there is an existing open and no surrogate is found and the open fails
   3. nonchunk opens are in progress..the open fails
   4. a copychunk-thru is attempted at the server. Here, we must stall
      subsequent opens on the same fcb. When the open completes we have
      two cases:
        a. the open failed. Unblock any stalled opens and fail the open
        b. the open succeeded. Record the information, unblock the stalled
           guys and the open succeeds.

A surrogate open is invalidated when the corresponding srvopen is closed..the
data is in the fcb so normal Fcb serialization makes this work correctly. A
copychunk-thru open is invalidated by any any nonchunk open on the same fcb.
The logistics will be handled by MrxSmbCscCloseCopychunkThruOpen; the major
problem will be to get into an exchange in the right security context (i.e. UID).

An OpenWithCopyChunkIntent is implemented as a normal open except that it is
identified (currently) by using specifying a profile of
    FILE_OPEN
    FILE_READ_ATTRIBUTES
    AllocationSize = {`\377ffCSC',?ioctl-irp}

A ReadWithCopyChunkIntent and CloseWithCopyChunkIntent just normal read and
close operations but are further identified by a bit set in the smbSrvOpen by
OpenWithCopyChunkIntent. For the read, if the copychunk info in the fcb is
invalid, the read just fails and copychunk fails. Otherwise the issue is again
just to get into the right context (UID/TID) so that the fid will be valid.



--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

//there is some toplevel irp manipulation in here.......
#ifdef RX_PRIVATE_BUILD
#undef IoGetTopLevelIrp
#undef IoSetTopLevelIrp
#endif //ifdef RX_PRIVATE_BUILD

extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_MRXSMBCSC;
#define Dbg (DEBUG_TRACE_MRXSMBCSC)

LONG MRxSmbSpecialCopyChunkAllocationSizeMarker = (LONG)'\377csc';

typedef union _SMBMRX_COPYCHUNKCONTEXT {
   COPYCHUNKCONTEXT;
   struct {
       ULONG spacer[3];
       PRX_CONTEXT RxContext;
   };
} SMBMRX_COPYCHUNKCONTEXT, *PSMBMRX_COPYCHUNKCONTEXT;

#define UNC_PREFIX_STRING  L"\\??\\UNC"
PWCHAR MRxSmbCscUncPrefixString = UNC_PREFIX_STRING;

#ifdef RX_PRIVATE_BUILD
#if 1
BOOLEAN AllowAgentOpens = TRUE;
#else
BOOLEAN AllowAgentOpens = FALSE;
#endif
#else
BOOLEAN AllowAgentOpens = TRUE;
#endif //ifdef RX_PRIVATE_BUILD


NTSTATUS
MRxSmbCscIoctlOpenForCopyChunk (
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine performs a fileopen with copychunk intent.

Arguments:

    RxContext - the RDBSS context. this contains a pointer to the bcs text
                giving the UNC filename and also the copychunk context where
                we store various things...including the underlying filehandle.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PWCHAR  FileName = (PWCHAR)LowIoContext->ParamsFor.IoCtl.pInputBuffer;
    ULONG   FileNameLength = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    PSMBMRX_COPYCHUNKCONTEXT CopyChunkContext =
                     (PSMBMRX_COPYCHUNKCONTEXT)(LowIoContext->ParamsFor.IoCtl.pOutputBuffer);

    ULONG   UncPrefixLength = sizeof(UNC_PREFIX_STRING)-sizeof(WCHAR);
    UNICODE_STRING FileNameU,tmpU;
    PWCHAR pPrefixedName = NULL;

    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    ULONG Disposition,ShareAccess,CreateOptions;
    LARGE_INTEGER SpecialCopyChunkAllocationSize;

    C_ASSERT(sizeof(SMBMRX_COPYCHUNKCONTEXT) == sizeof(COPYCHUNKCONTEXT));

    RxDbgTrace(+1, Dbg, ("MRxSmbCscIoctlOpenForCopyChunk entry...%08lx %08lx %08lx %08lx\n",
            RxContext, FileName, FileNameLength, CopyChunkContext));

    CopyChunkContext->handle = INVALID_HANDLE_VALUE;

    IF_DEBUG {
        if (!AllowAgentOpens) {
            Status = (STATUS_INVALID_PARAMETER);
            goto FINALLY;
        }
    }

    // Bug 554655 
    //Make sure that the filename is atleast 2 chars (\\) long
    if (FileName[FileNameLength/sizeof(WCHAR)]!= 0 ||
        FileNameLength/sizeof(WCHAR) < 2) {
        RxDbgTrace(0, Dbg, ("Bad Filename passed...%08lx %08lx\n",FileName,FileNameLength));
        Status = (STATUS_INVALID_PARAMETER);
        goto FINALLY;
    }

    //  we allow multiple temporary agents (spp)
//    if (!IsSpecialApp()) {
//        DbgPrint(0, Dbg, ("CopyChunk operation in wrong thread!!!\n");
//        Status = (STATUS_INVALID_PARAMETER);
//        goto FINALLY;
//    }

    RxDbgTrace(0, Dbg,  ("MRxSmbCscIoctlOpenForCopyChunk name...%08lx %s\n", RxContext, FileName));

    pPrefixedName = (PWCHAR)RxAllocatePoolWithTag(
                             PagedPool,
                             UncPrefixLength + FileNameLength,  // one wchar extra
                             MRXSMB_MISC_POOLTAG );

    if (pPrefixedName == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    FileNameU.Buffer = pPrefixedName;

    RtlCopyMemory(pPrefixedName, MRxSmbCscUncPrefixString, UncPrefixLength);

    // copy the UNC name, step over the first back slash of the two leading ones
    RtlCopyMemory(&pPrefixedName[UncPrefixLength/sizeof(WCHAR)], &FileName[1], FileNameLength-sizeof(WCHAR));

    FileNameU.Length = FileNameU.MaximumLength = (USHORT)(UncPrefixLength + FileNameLength-sizeof(WCHAR));
    RxDbgTrace(0, Dbg, ("MRxSmbCscIoctlOpenForCopyChunk Uname...%08lx %wZ\n", RxContext, &FileNameU));


    InitializeObjectAttributes(
          &ObjectAttributes,
          &FileNameU,
          OBJ_CASE_INSENSITIVE,
          0,
          NULL
          );

    SpecialCopyChunkAllocationSize.HighPart = MRxSmbSpecialCopyChunkAllocationSizeMarker;

    SpecialCopyChunkAllocationSize.LowPart = ((CopyChunkContext->dwFlags & COPYCHUNKCONTEXT_FLAG_IS_AGENT_OPEN)!=0);

    Disposition = FILE_OPEN;
    ShareAccess = FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE;
    CreateOptions = FILE_SYNCHRONOUS_IO_NONALERT
                                    | FILE_NON_DIRECTORY_FILE;
    //CODE.IMPROVEMENT.ASHAMED
    //i am doing this as unbuffered ios.....the alternative is to do
    //buffered ios but the problem is that we must not have any
    //pagingIOs issued on these handles. so, the following would also
    //have to be done:
    //   1) no fastio on these...or fix fastio so it didn;t always wait
    //   2) always flush....we would always want to flush at the top of read
    //   3) no initialize cachemap...rather, use the FO in the segment-pointers
    //   4) no wait on cccopyread calls.
    //the effect of these improvements would be pretty big: you wouldn't have to go
    //back to the server for stuff already in the cache. but 'til then
    CreateOptions |= FILE_NO_INTERMEDIATE_BUFFERING;


    //CODE.IMPROVEMENT if we used IoCreateFile instead and IO_NO_PARAMETER
    //                 checking, then we could pass in a nonsensical value
    //                 and have even more foolproof way of describing a chunk
    //                 open

    Status = ZwCreateFile(
        &CopyChunkContext->handle,  //OUT PHANDLE FileHandle,
        FILE_READ_ATTRIBUTES | SYNCHRONIZE, //IN ACCESS_MASK DesiredAccess,
        &ObjectAttributes, //IN POBJECT_ATTRIBUTES ObjectAttributes,
        &IoStatusBlock, //OUT PIO_STATUS_BLOCK IoStatusBlock,
        &SpecialCopyChunkAllocationSize, //IN PLARGE_INTEGER AllocationSize OPTIONAL,
        FILE_ATTRIBUTE_NORMAL, //IN ULONG FileAttributes,
        ShareAccess, //IN ULONG ShareAccess,
        Disposition, //IN ULONG CreateDisposition,
        CreateOptions, //IN ULONG CreateOptions,
        NULL, //IN PVOID EaBuffer OPTIONAL,
        0  //IN ULONG EaLength,
        );

    IF_DEBUG {
        //this little snippett just allows me to test the closechunkopen logic
        if (FALSE) {
            HANDLE h;
            NTSTATUS TestOpenStatus;
            RxDbgTrace(0, Dbg, ("MRxSmbCscIoctlOpenForCopyChunk...f***open %08lx\n",
                      RxContext));
            TestOpenStatus = ZwCreateFile(
                &h,  //OUT PHANDLE FileHandle,
                GENERIC_READ | SYNCHRONIZE, //IN ACCESS_MASK DesiredAccess,
                &ObjectAttributes, //IN POBJECT_ATTRIBUTES ObjectAttributes,
                &IoStatusBlock, //OUT PIO_STATUS_BLOCK IoStatusBlock,
                NULL, //IN PLARGE_INTEGER AllocationSize OPTIONAL,
                FILE_ATTRIBUTE_NORMAL, //IN ULONG FileAttributes,
                ShareAccess, //IN ULONG ShareAccess,
                Disposition, //IN ULONG CreateDisposition,
                CreateOptions, //IN ULONG CreateOptions,
                NULL, //IN PVOID EaBuffer OPTIONAL,
                0  //IN ULONG EaLength
                );
            RxDbgTrace(0, Dbg, ("MRxSmbCscIoctlOpenForCopyChunk...f***open %08lx teststs=%08lx %08lx\n",
                      RxContext, TestOpenStatus, h));
            if (NT_SUCCESS(TestOpenStatus)) {
                NtClose(h);
            }
        }
    }


FINALLY:
    if (pPrefixedName!=NULL) {
        RxFreePool(pPrefixedName);
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbCscIoctlOpenForCopyChunk...%08lx %08lx %08lx\n",
              RxContext, Status, CopyChunkContext->handle));
    return(Status);
}

NTSTATUS
MRxSmbCscIoctlCloseForCopyChunk (
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine performs the special IOCTL operation for the CSC agent.

Arguments:

    RxContext - the RDBSS context which points to the copychunk context. this contains the
                underlying handle to close.

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PSMBMRX_COPYCHUNKCONTEXT CopyChunkContext =
                     (PSMBMRX_COPYCHUNKCONTEXT)(LowIoContext->ParamsFor.IoCtl.pOutputBuffer);

    RxDbgTrace(+1, Dbg, ("MRxSmbCscIoctlCloseForCopyChunk...%08lx %08lx %08lx\n",
            RxContext, 0, CopyChunkContext));
    if (CopyChunkContext->handle != INVALID_HANDLE_VALUE) {
        Status = NtClose(CopyChunkContext->handle);
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }
//FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCscIoctlCloseForCopyChunk...%08lx %08lx\n", RxContext, Status));
    return(Status);
}

//CODE.IMPROVEMENT.NTIFS had to get this from ntifs.h since we use ntsrv.h
extern POBJECT_TYPE *IoFileObjectType;

NTSTATUS
MRxSmbCscIoctlCopyChunk (
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine performs the copychunk function.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    what we do here is
    1)  get the filesize of the shadow...we use the handle stored in the
        agent's smbsrvopen......hence complicated synchronization.
    2)  allocate a read buffer COODE.IMPROVEMENT...should be done in the agent
    3)  issue the underlying read
    4)  write the acquired data to the file

   the putaway is done in the read tail. it must seem that we go to a lot of trouble
   to get the filesize using the underlying handle....actually, we could just get our
   handle. maybe, we should do that.

   also, it may seem that we should just rely on the underlying read to
   calculate where the chunk read should start. we do not do that because that
   would mean that we would have to bypass the cache! actually, we bypass it
   now anyway but later we may stop doing that. it's really, really bad to
   go back to the server for data that we have in cache. as well, the
   cachemanager/memorymanager can turn our small IOs into large Ios. so, we would
   need code in the minirdr read loop to keep the Ios down to the maximum chunk size.


--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    //PBYTE   FileName = (PBYTE)LowIoContext->ParamsFor.IoCtl.pInputBuffer;
    //ULONG   FileNameLength = LowIoContext->ParamsFor.IoCtl.InputBufferLength - 1;
    PSMBMRX_COPYCHUNKCONTEXT CopyChunkContext =
                     (PSMBMRX_COPYCHUNKCONTEXT)(LowIoContext->ParamsFor.IoCtl.pOutputBuffer);
    int iRet,ShadowFileLength;
    PFILE_OBJECT FileObject;
    BOOLEAN ObjectReferenceTaken = FALSE;
    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN CriticalSectionEntered = FALSE;
    PMRX_FCB underlyingFcb;
    PMRX_FOBX underlyingFobx;
    PMRX_SRV_OPEN underlyingSrvOpen;
    PMRX_SMB_SRV_OPEN underlyingsmbSrvOpen;
    PVOID hfShadow;

    IO_STATUS_BLOCK IoStatusBlock;
    PBYTE Buffer = NULL;
    LARGE_INTEGER ReadOffset;
    int iAmountRead; //need this as int

    PIRP TopIrp;

    // all probing/validation is already on entry to mrxsmbcscioctl
    RxDbgTrace(+1, Dbg, ("MRxSmbCscIoctlCopyChunk...%08lx %08lx\n", RxContext,CopyChunkContext));

    //
    // we have to find out the size of the shadow file. we do this by going thru
    // the objectmanager. in this way, we do not require any extra state about
    // the ongoing copy....only the underlying handle. if we did not do this, we
    // would have to rely on whoever had the copychunk context to preserve it
    // correctly.

    //
    // Reference the file object to get the pointer.
    //

    Status = ObReferenceObjectByHandle( CopyChunkContext->handle,
                                        0,
                                        *IoFileObjectType,
                                        RxContext->CurrentIrp->RequestorMode,
                                        (PVOID *) &FileObject,
                                        NULL );
    if (!NT_SUCCESS( Status )) {
        goto FINALLY;
    }

    ObjectReferenceTaken = TRUE;
    // keep the reference so the handle doesn't vanish from underneath us
#if 0
    // make sure this handle belongs to us
    if (FileObject->DeviceObject != (PDEVICE_OBJECT)MRxSmbDeviceObject)
    {
        Status = STATUS_INVALID_PARAMETER;
        RxDbgTrace(0, Dbg, ("Invalid device object, not our handle \r\n"));
        goto FINALLY;
    }
#endif
    underlyingFcb = (PMRX_FCB)(FileObject->FsContext);
    underlyingFobx = (PMRX_FOBX)(FileObject->FsContext2);

    if(NodeType(underlyingFcb) != RDBSS_NTC_STORAGE_TYPE_FILE)
    {
        Status = STATUS_INVALID_PARAMETER;
        RxDbgTrace(0, Dbg, ("Invalid storage type, handle is not for a file\r\n"));
        goto FINALLY;

    }

    Status = RxAcquireSharedFcbResourceInMRx( underlyingFcb );

    if (!NT_SUCCESS( Status )) {
        goto FINALLY;
    }
    FcbAcquired = TRUE;

    underlyingSrvOpen = underlyingFobx->pSrvOpen;
    underlyingsmbSrvOpen = MRxSmbGetSrvOpenExtension(underlyingSrvOpen);

    //if this is not a copychunk handle quit
    if (!FlagOn(underlyingsmbSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN)){
        Status = STATUS_INVALID_PARAMETER;
        RxDbgTrace(0, Dbg, ("not a copychunk handle\r\n"));
        goto FINALLY;
    }

    hfShadow = underlyingsmbSrvOpen->hfShadow;
    if (hfShadow==0) {
        Status = STATUS_UNSUCCESSFUL;
        RxDbgTrace(0, Dbg, ("Nt5CSC: no shadowhandle for copychunk\n"));
        goto FINALLY;
    }

    ASSERT_MINIRDRFILEOBJECT((PNT5CSC_MINIFILEOBJECT)hfShadow);

    EnterShadowCrit();
    CriticalSectionEntered = TRUE;


    //don't need the shadowreadwritemutex here because it's not really important
    //to have the correct endoffile value....worst case: an extra read flows....

    iRet = GetFileSizeLocal(hfShadow, &ShadowFileLength);
    RxDbgTrace( 0, Dbg,
        ("MRxSmbCscIoctlCopyChunk... %08lx (st=%08lx) fsize= %08lx\n",
            RxContext, iRet, ShadowFileLength));

    if (iRet <0) {
        Status = STATUS_UNSUCCESSFUL;
        goto FINALLY;
    }

    LeaveShadowCrit();
    CriticalSectionEntered = FALSE;

    RxReleaseFcbResourceInMRx( underlyingFcb );
    FcbAcquired = FALSE;

    ObDereferenceObject( FileObject );
    ObjectReferenceTaken = FALSE;

    Buffer = RxAllocatePoolWithTag(
                             PagedPool,
                             CopyChunkContext->ChunkSize,
                             MRXSMB_MISC_POOLTAG );

    if (Buffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    RxDbgTrace( 0, Dbg,
        ("MRxSmbCscIoctlCopyChunk... about to read %08lx %08lx\n",
            RxContext, Buffer));

    ReadOffset.QuadPart = ShadowFileLength;

    try {

        try {
            TopIrp = IoGetTopLevelIrp();
            IoSetTopLevelIrp(NULL); //tell the underlying guy he's all clear

            Status = ZwReadFile(
                            CopyChunkContext->handle, //IN HANDLE FileHandle,
                            0, //IN HANDLE Event OPTIONAL,
                            0, //IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
                            NULL, //IN PVOID ApcContext OPTIONAL,
                            &IoStatusBlock, //OUT PIO_STATUS_BLOCK IoStatusBlock,
                            Buffer, //OUT PVOID Buffer,
                            CopyChunkContext->ChunkSize, //IN ULONG Length,
                            &ReadOffset, //IN PLARGE_INTEGER ByteOffset OPTIONAL,
                            NULL //IN PULONG Key OPTIONAL
                            );
        } finally {
            IoSetTopLevelIrp(TopIrp); //restore my context for unwind
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_UNSUCCESSFUL;
    }

    RxDbgTrace( 0, Dbg,
        ("MRxSmbCscIoctlCopyChunk... back from read %08lx %08lx %08lx\n",
            RxContext, Status, IoStatusBlock.Information));

    CopyChunkContext->LastAmountRead = 0;
    if (Status == STATUS_END_OF_FILE) {
        //we're cookin'...just map it
        Status = STATUS_SUCCESS;
        goto FINALLY;
    }
    if (!NT_SUCCESS(Status)) {
        goto FINALLY;
    }
    CopyChunkContext->LastAmountRead = (ULONG)IoStatusBlock.Information;
    CopyChunkContext->TotalSizeBeforeThisRead = ShadowFileLength;


FINALLY:
    if (Buffer != NULL) {
        RxFreePool(Buffer);
    }
    if (CriticalSectionEntered) {
        LeaveShadowCrit();
    }
    if (FcbAcquired) {
        RxReleaseFcbResourceInMRx( underlyingFcb );
    }
    if (ObjectReferenceTaken) {
        ObDereferenceObject( FileObject );
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbCscIoctlCopyChunk...%08lx %08lx\n", RxContext, Status));
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\csc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    csc.c

Abstract:

    This module implements the client side caching interface for the SMB mini rdr.

Author:

    Joe Linn [joelinn]    21-jan-1997

Revision History:

    Shishir Pardikar disconnected ops, parameter validation, bug fixes .....

--*/

#include "precomp.h"
#pragma hdrstop

#include <smbdebug.h>

#define Dbg (DEBUG_TRACE_MRXSMBCSC)
RXDT_DefineCategory(MRXSMBCSC);


//local prototype

LONG
MRxSmbCSCExceptionFilter (
    IN PRX_CONTEXT RxContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    );

BOOLEAN
CscpAccessCheck(
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformation,
    ULONG                        CachedSecurityInformationLength,
    CSC_SID_INDEX                SidIndex,
    ACCESS_MASK                  AccessMask,
    BOOLEAN                      *pSidHasAccessmask
);

BOOLEAN
CscAccessCheck(
    HSHADOW              hParent,
    HSHADOW              hFile,
    PRX_CONTEXT          RxContext,
    ACCESS_MASK          AccessMask,
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformationForShadow,
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformationForShare
    );

VOID
MRxSmbCscFillWithoutNamesFind32FromFcb (
      IN  PMINIMAL_CSC_SMBFCB MinimalCscSmbFcb,
      OUT _WIN32_FIND_DATA  *Find32
      );

NTSTATUS
MRxSmbCscGetFileInfoForCshadow(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

NTSTATUS
MRxSmbGetFileInfoFromServer (
    IN  OUT PRX_CONTEXT     RxContext,
    IN  PUNICODE_STRING     FullFileName,
    OUT _WIN32_FIND_DATA    *Find32,
    IN  PMRX_SRV_OPEN       pSrvOpen,
    OUT BOOLEAN             *lpfIsRoot
    );

BOOLEAN
MRxSmbCscIsFatNameValid (
    IN PUNICODE_STRING FileName,
    IN BOOLEAN WildCardsPermissible
    );

VOID
MRxSmbCscGenerate83NameAsNeeded(
      IN     CSC_SHADOW_HANDLE   hDir,
      PWCHAR FileName,
      PWCHAR SFN
      );
int
RefreshShadow( HSHADOW  hDir,
   IN HSHADOW  hShadow,
   IN LPFIND32 lpFind32,
   OUT ULONG *lpuShadowStatus
   );

NTSTATUS
SmbPseExchangeStart_CloseCopyChunk(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbCscCloseExistingThruOpen(
    IN OUT PRX_CONTEXT   RxContext
    );

ULONG
GetPathLevelFromUnicodeString (
    PUNICODE_STRING Name
      );

NTSTATUS
MRxSmbCscFixupFindFirst (
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
    );
VOID
MRxSmbCscLocateAndFillFind32WithinSmbbuf(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      );

NTSTATUS
MRxSmbCscGetFileInfoFromServerWithinExchange (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    PUNICODE_STRING FileName
    );

NTSTATUS
IoctlGetDebugInfo(
    PRX_CONTEXT RxContext,
    PBYTE InputBuffer,
    ULONG InputBufferLength,
    PBYTE OutputBuffer,
    ULONG OutputBufferLength);

NTSTATUS
MRxSmbCscLocalFileOpen(
      IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
MRxSmbCscObtainShadowHandles (
    IN OUT PRX_CONTEXT       RxContext,
    IN OUT PNTSTATUS         Status,
    IN OUT _WIN32_FIND_DATA  *Find32,
    OUT    PBOOLEAN          Created,
    IN     ULONG             CreateShadowControls,
    IN     BOOLEAN           Disconnected
    );

// type of buffer used to capture structures passed in which have embedded pointers.
// Once we have captured the structure, the embedded pointers cannot be changed and
// our parameter validation holds good throughout the duration of the call

typedef union tagCAPTURE_BUFFERS
{
    COPYPARAMSW  sCP;
    SHADOWINFO  sSI;
    SHAREINFO  sSVI;
}
CAPTURE_BUFFERS, *LPCAPTURE_BUFFERS;

// table entry type off which the parameter validation is driven
typedef struct tagCSC_IOCTL_ENTRY
{
    ULONG   IoControlCode;  // iocontrolcode for sanity check
    DWORD   dwFlags;        // bits indicating what type of strucutre is passed in
    DWORD   dwLength;       // size of the passed in strucutre
}
CSC_IOCTL_ENTRY;

// defines for the flags in dwFlags field in CSC_IOCTL_ENTRY structure
#define FLAG_CSC_IOCTL_PQPARAMS         0x00000001
#define FLAG_CSC_IOCTL_COPYPARAMS       0x00000002
#define FLAG_CSC_IOCTL_SHADOWINFO       0x00000004
#define FLAG_CSC_IOCTL_COPYCHUNKCONTEXT 0x00000008
#define FLAG_CSC_IOCTL_GLOBALSTATUS     0x00000010

#define FLAG_CSC_IOCTL_BUFFERTYPE_MASK  0xff

#define SMB_CSC_BITS_TO_DATABASE_CSC_BITS(CscFlags) (((CscFlags) << 4) & SHARE_CACHING_MASK)
#define DATABASE_CSC_BITS_TO_SMB_CSC_BITS(CscFlags) (((CscFlags) & SHARE_CACHING_MASK) >> 4)


// #define IOCTL_NAME_OF_SERVER_GOING_OFFLINE      (_SHADOW_IOCTL_CODE(45))

#ifdef  DEBUG
extern ULONG HookKdPrintVector = HOOK_KDP_BADERRORS;
extern ULONG HookKdPrintVectorDef = HOOK_KDP_GOOD_DEFAULT;
#endif

#ifdef RX_PRIVATE_BUILD
ULONG MRxSmbCscDbgPrintF = 0; // 1;
#endif //ifdef RX_PRIVATE_BUILD

//
// this variable is used to "help" the agent know when to recalculate
// the reference priorities
//
ULONG MRxSmbCscNumberOfShadowOpens = 0;
ULONG MRxSmbCscActivityThreshold = 16;
ULONG MRxSmbCscInitialRefPri = MAX_PRI;
// these two lists are used to list up all the netroots and fcbs
// that have shadows so that we can find them for the ioctls. today
// are just doubly-linked lists but we can anticipate that this may
// become a performance issue, particularly for fcbs. at that point, we
// can either change to bucket hashing or tries

LIST_ENTRY xCscFcbsList;
PIRP    vIrpReint = NULL;

#define MRxSmbCscAddReverseFcbTranslation(smbFcb) {\
    InsertTailList(&xCscFcbsList,                      \
               &(smbFcb)->ShadowReverseTranslationLinks); \
    }
#define MRxSmbCscRemoveReverseFcbTranslation(smbFcb) {\
    RemoveEntryList(&(smbFcb)->ShadowReverseTranslationLinks); \
    }

PMRX_SMB_FCB
MRxSmbCscRecoverMrxFcbFromFdb (
    IN PFDB Fdb
    );

BOOL
CscDfsShareIsInReint(
    IN  PRX_CONTEXT         RxContext
    );
//
// From zwapi.h.
//

NTSYSAPI
NTSTATUS
NTAPI
ZwSetSecurityObject(
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
CaptureInputBufferIfNecessaryAndProbe(
    DWORD   IoControlCode,
    PRX_CONTEXT     pRxContext,
    PBYTE   InputBuffer,
    LPCAPTURE_BUFFERS lpCapBuff,
    PBYTE   *ppAuxBuf,
    PBYTE   *ppOrgBuf,
    PBYTE   *ppReturnBuffer
    );

NTSTATUS
ValidateCopyParams(
    LPCOPYPARAMS    lpCP
    );

NTSTATUS
ValidateShadowInfo(
    DWORD           IoControlCode,
    LPSHADOWINFO    lpSI,
    LPBYTE          *ppAuxBuf,
    LPBYTE          *ppOrgBuf
    );

NTSTATUS
ValidateCopyChunkContext(
    PRX_CONTEXT RxContext,
    DWORD       IoControlCode
    );

NTSTATUS
CscProbeForReadWrite(
    PBYTE   pBuffer,
    DWORD   dwSize
    );

NTSTATUS
CscProbeAndCaptureForReadWrite(
    PBYTE   pBuffer,
    DWORD   dwSize,
    PBYTE   *ppAuxBuf
    );

VOID
CopyBackIfNecessary(
    DWORD   IoControlCode,
    PBYTE   InputBuffer,
    LPCAPTURE_BUFFERS lpCapBuff,
    PBYTE   pAuxBuf,
    PBYTE   pOrgBuf,
    BOOL    fSuccess
    );

VOID
EnterShadowCritRx(
    PRX_CONTEXT     pRxContext
    );

VOID
LeaveShadowCritRx(
    PRX_CONTEXT     pRxContext
    );

#if defined(REMOTE_BOOT)
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenThreadToken(
    IN HANDLE ThreadHandle,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN OpenAsSelf,
    OUT PHANDLE TokenHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwOpenProcessToken(
    IN HANDLE ProcessHandle,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE TokenHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwDuplicateToken(
    IN HANDLE ExistingTokenHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN BOOLEAN EffectiveOnly,
    IN TOKEN_TYPE TokenType,
    OUT PHANDLE NewTokenHandle
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwAdjustPrivilegesToken (
    IN HANDLE TokenHandle,
    IN BOOLEAN DisableAllPrivileges,
    IN PTOKEN_PRIVILEGES NewState OPTIONAL,
    IN ULONG BufferLength OPTIONAL,
    IN PTOKEN_PRIVILEGES PreviousState OPTIONAL,
    OUT PULONG ReturnLength
    );

//
// From ntrtl.h.
//

NTSYSAPI
NTSTATUS
NTAPI
RtlGetSaclSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PBOOLEAN SaclPresent,
    PACL *Sacl,
    PBOOLEAN SaclDefaulted
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlGetGroupSecurityDescriptor (
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    PSID *Group,
    PBOOLEAN GroupDefaulted
    );

#endif

//sigh BUBUG get this stuff into an include file.....
#define SHADOW_VERSION 0x8287
extern char vszShadowDir[MAX_SHADOW_DIR_NAME+1];
extern PVOID lpdbShadow;
//CODE.IMPROFVEMENT this should be in a .h file
extern PKEVENT MRxSmbAgentSynchronizationEvent;
extern PKEVENT MRxSmbAgentFillEvent;
extern PSMBCEDB_SERVER_ENTRY   CscServerEntryBeingTransitioned;
extern ULONG CscSessionIdCausingTransition;
extern ULONG vulDatabaseStatus;
extern unsigned cntInodeTransactions;

extern VOID
MRxSmbDecrementSrvOpenCount(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    LONG                  SrvOpenServerVersion,
    PMRX_SRV_OPEN         SrvOpen);

VOID ValidateSmbFcbList(VOID);

BOOL SetOfflineOpenStatusForShare(
    CSC_SHARE_HANDLE    hShare,
    CSC_SHADOW_HANDLE   hRootDir,
    OUT PULONG pShareStatus
    );

LONG CSCBeginReint(
    IN OUT  PRX_CONTEXT RxContext,
    IN OUT  LPSHADOWINFO    lpSI
    );

ULONG CSCEndReint(
    IN OUT  LPSHADOWINFO    lpSI
    );

VOID CSCCancelReint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP ThisIrp
    );

VOID
CreateFakeFind32(
    CSC_SHADOW_HANDLE hDir,
    _WIN32_FIND_DATA  *pFind32,
    PRX_CONTEXT         RxContext,
    BOOLEAN LastComponentInName
    );

NTSTATUS
OkToDeleteObject(
    HSHADOW hDir,
    HSHADOW hShadow,
    _WIN32_FIND_DATA  *Find32,
    ULONG   uShadowStatus,
    BOOLEAN fDisconnected
    );

#pragma alloc_text(PAGE, MRxSmbCSCExceptionFilter)

#if defined(REMOTE_BOOT)
#pragma alloc_text(PAGE, ZwImpersonateSelf)
#pragma alloc_text(PAGE, ZwAdjustPrivilege)
#pragma alloc_text(PAGE, RtlGetSecurityInformationFromSecurityDescriptor)
#endif

#pragma alloc_text(PAGE, MRxSmbInitializeCSC)
#pragma alloc_text(PAGE, MRxSmbUninitializeCSC)
#pragma alloc_text(PAGE, CscpAccessCheck)
#pragma alloc_text(PAGE, CscAccessCheck)
#pragma alloc_text(PAGE, MRxSmbCscAcquireSmbFcb)
#pragma alloc_text(PAGE, MRxSmbCscReleaseSmbFcb)
#pragma alloc_text(PAGE, MRxSmbCscSetFileInfoEpilogue)
#pragma alloc_text(PAGE, MRxSmbCscIoCtl)
#pragma alloc_text(PAGE, MRxSmbCscObtainShareHandles)
#pragma alloc_text(PAGE, MRxSmbCscFillWithoutNamesFind32FromFcb)
#pragma alloc_text(PAGE, MRxSmbCscGetFileInfoForCshadow)
#pragma alloc_text(PAGE, MRxSmbGetFileInfoFromServer)
#pragma alloc_text(PAGE, MRxSmbCscIsFatNameValid)
#pragma alloc_text(PAGE, MRxSmbCscGenerate83NameAsNeeded)
#pragma alloc_text(PAGE, MRxSmbCscCreateShadowFromPath)
#pragma alloc_text(PAGE, RefreshShadow)
#pragma alloc_text(PAGE, MRxSmbCscIsThisACopyChunkOpen)
#pragma alloc_text(PAGE, SmbPseExchangeStart_CloseCopyChunk)
#pragma alloc_text(PAGE, MRxSmbCscCloseExistingThruOpen)
#pragma alloc_text(PAGE, MRxSmbCscCreatePrologue)
#pragma alloc_text(PAGE, MRxSmbCscObtainShadowHandles)
#if defined(REMOTE_BOOT)
#pragma alloc_text(PAGE, MRxSmbCscSetSecurityOnShadow)
#endif
#pragma alloc_text(PAGE, MRxSmbCscCreateEpilogue)
#pragma alloc_text(PAGE, MRxSmbCscDeleteAfterCloseEpilogue)
#pragma alloc_text(PAGE, GetPathLevelFromUnicodeString)
#pragma alloc_text(PAGE, MRxSmbCscRenameEpilogue)
#pragma alloc_text(PAGE, MRxSmbCscCloseShadowHandle)
#pragma alloc_text(PAGE, MRxSmbCscFixupFindFirst)
#pragma alloc_text(PAGE, MRxSmbCscLocateAndFillFind32WithinSmbbuf)
#pragma alloc_text(PAGE, MRxSmbCscGetFileInfoFromServerWithinExchange)
#pragma alloc_text(PAGE, MRxSmbCscUpdateShadowFromClose)
#pragma alloc_text(PAGE, MRxSmbCscDeallocateForFcb)
#pragma alloc_text(PAGE, MRxSmbCscRecoverMrxFcbFromFdb)
#pragma alloc_text(PAGE, MRxSmbCscFindFdbFromHShadow)
#pragma alloc_text(PAGE, MRxSmbCscFindResourceFromHandlesWithModify)
#pragma alloc_text(PAGE, MRxSmbCscFindLocalFlagsFromFdb)
#pragma alloc_text(PAGE, MRxSmbCscSetSecurityPrologue)
#pragma alloc_text(PAGE, MRxSmbCscSetSecurityEpilogue)
#pragma alloc_text(PAGE, CaptureInputBufferIfNecessaryAndProbe)
#pragma alloc_text(PAGE, ValidateCopyParams)
#pragma alloc_text(PAGE, ValidateShadowInfo)
#pragma alloc_text(PAGE, ValidateCopyChunkContext)
#pragma alloc_text(PAGE, CscProbeForReadWrite)
#pragma alloc_text(PAGE, CopyBackIfNecessary)
#pragma alloc_text(PAGE, ValidateSmbFcbList)
#pragma alloc_text(PAGE, SetOfflineOpenStatusForShare)
#pragma alloc_text(PAGE, MRxSmbCscLocalFileOpen)
#pragma alloc_text(PAGE, CSCCheckLocalOpens)
#pragma alloc_text(PAGE, IsCSCBusy)
#pragma alloc_text(PAGE, ClearCSCStateOnRedirStructures)
#pragma alloc_text(PAGE, CscDfsShareIsInReint)
#pragma alloc_text(PAGE, CloseOpenFiles)
#pragma alloc_text(PAGE, CreateFakeFind32)
#pragma alloc_text(PAGE, OkToDeleteObject)
#pragma alloc_text(PAGE, IoctlGetDebugInfo)

//remember whether to delete the link
BOOLEAN MRxSmbCscLinkCreated = FALSE;

PCONTEXT CSCExpCXR;
PEXCEPTION_RECORD CSCExpEXR;
PVOID CSCExpAddr;
NTSTATUS CSCExpCode;

LONG
MRxSmbCSCExceptionFilter (
    IN PRX_CONTEXT RxContext,
    IN PEXCEPTION_POINTERS ExceptionPointer
    )


/*++

Routine Description:

    This routine is used to decide if we should or should not handle
    an exception status that is being raised.  It first determines the true exception
    code by examining the exception record. If there is an Irp Context, then it inserts the status
    into the RxContext. Finally, it determines whether to handle the exception or bugcheck
    according to whether the except is one of the expected ones. in actuality, all exceptions are expected
    except for some lowlevel machine errors (see fsrtl\filter.c)

Arguments:

    RxContext    - the irp context of current operation for storing away the code.

    ExceptionPointer - Supplies the exception context.

Return Value:

    ULONG - returns EXCEPTION_EXECUTE_HANDLER or bugchecks

--*/

{
    NTSTATUS ExceptionCode;

    //save these values in statics so i can see 'em on the debugger............
    ExceptionCode = CSCExpCode = ExceptionPointer->ExceptionRecord->ExceptionCode;
    CSCExpAddr = ExceptionPointer->ExceptionRecord->ExceptionAddress;
    CSCExpEXR  = ExceptionPointer->ExceptionRecord;
    CSCExpCXR  = ExceptionPointer->ContextRecord;

    RxDbgTrace(0, Dbg, ("!!! ExceptioCode=%lx Addr=%lx EXR=%lx CXR=%lx\n", CSCExpCode, CSCExpAddr, CSCExpEXR, CSCExpCXR));
    RxLog(("!!! %lx %lx %lx %lx\n", CSCExpCode, CSCExpAddr, CSCExpEXR, CSCExpCXR));

//    ASSERT(FALSE);

    return EXCEPTION_EXECUTE_HANDLER;
}

#if defined(REMOTE_BOOT)
//
// Stolen from RTL, changed to use Zw APis.
//

NTSTATUS
ZwImpersonateSelf(
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    )

/*++

Routine Description:

    This routine may be used to obtain an Impersonation token representing
    your own process's context.  This may be useful for enabling a privilege
    for a single thread rather than for the entire process; or changing
    the default DACL for a single thread.

    The token is assigned to the callers thread.



Arguments:

    ImpersonationLevel - The level to make the impersonation token.



Return Value:

    STATUS_SUCCESS -  The thread is now impersonating the calling process.

    Other - Status values returned by:

            ZwOpenProcessToken()
            ZwDuplicateToken()
            ZwSetInformationThread()

--*/

{
    NTSTATUS
        Status,
        IgnoreStatus;

    HANDLE
        Token1,
        Token2;

    OBJECT_ATTRIBUTES
        ObjectAttributes;

    SECURITY_QUALITY_OF_SERVICE
        Qos;


    InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);

    Qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    Qos.ImpersonationLevel = ImpersonationLevel;
    Qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    Qos.EffectiveOnly = FALSE;
    ObjectAttributes.SecurityQualityOfService = &Qos;

    Status = ZwOpenProcessToken( NtCurrentProcess(), TOKEN_DUPLICATE, &Token1 );

    if (NT_SUCCESS(Status)) {
        Status = ZwDuplicateToken(
                     Token1,
                     TOKEN_IMPERSONATE,
                     &ObjectAttributes,
                     FALSE,                 //EffectiveOnly
                     TokenImpersonation,
                     &Token2
                     );
        if (NT_SUCCESS(Status)) {
            Status = ZwSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &Token2,
                         sizeof(HANDLE)
                         );

            IgnoreStatus = ZwClose( Token2 );
        }


        IgnoreStatus = ZwClose( Token1 );
    }


    return(Status);

}


NTSTATUS
ZwAdjustPrivilege(
    ULONG Privilege,
    BOOLEAN Enable,
    BOOLEAN Client,
    PBOOLEAN WasEnabled
    )

/*++

Routine Description:

    This procedure enables or disables a privilege process-wide.

Arguments:

    Privilege - The lower 32-bits of the privilege ID to be enabled or
        disabled.  The upper 32-bits is assumed to be zero.

    Enable - A boolean indicating whether the privilege is to be enabled
        or disabled.  TRUE indicates the privilege is to be enabled.
        FALSE indicates the privilege is to be disabled.

    Client - A boolean indicating whether the privilege should be adjusted
        in a client token or the process's own token.   TRUE indicates
        the client's token should be used (and an error returned if there
        is no client token).  FALSE indicates the process's token should
        be used.

    WasEnabled - points to a boolean to receive an indication of whether
        the privilege was previously enabled or disabled.  TRUE indicates
        the privilege was previously enabled.  FALSE indicates the privilege
        was previoulsy disabled.  This value is useful for returning the
        privilege to its original state after using it.


Return Value:

    STATUS_SUCCESS - The privilege has been sucessfully enabled or disabled.

    STATUS_PRIVILEGE_NOT_HELD - The privilege is not held by the specified context.

    Other status values as may be returned by:

            ZwOpenProcessToken()
            ZwAdjustPrivilegesToken()


--*/

{
    NTSTATUS
        Status,
        TmpStatus;

    HANDLE
        Token;

    LUID
        LuidPrivilege;

    PTOKEN_PRIVILEGES
        NewPrivileges,
        OldPrivileges;

    ULONG
        Length;

    UCHAR
        Buffer1[sizeof(TOKEN_PRIVILEGES)+
                ((1-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES))],
        Buffer2[sizeof(TOKEN_PRIVILEGES)+
                ((1-ANYSIZE_ARRAY)*sizeof(LUID_AND_ATTRIBUTES))];


    NewPrivileges = (PTOKEN_PRIVILEGES)Buffer1;
    OldPrivileges = (PTOKEN_PRIVILEGES)Buffer2;

    //
    // Open the appropriate token...
    //

    if (Client == TRUE) {
        Status = ZwOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                     FALSE,
                     &Token
                     );
    } else {

        Status = ZwOpenProcessToken(
                     NtCurrentProcess(),
                     TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                     &Token
                    );
    }

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }



    //
    // Initialize the privilege adjustment structure
    //

    LuidPrivilege = RtlConvertUlongToLuid(Privilege);


    NewPrivileges->PrivilegeCount = 1;
    NewPrivileges->Privileges[0].Luid = LuidPrivilege;
    NewPrivileges->Privileges[0].Attributes = Enable ? SE_PRIVILEGE_ENABLED : 0;



    //
    // Adjust the privilege
    //

    Status = ZwAdjustPrivilegesToken(
                 Token,                     // TokenHandle
                 FALSE,                     // DisableAllPrivileges
                 NewPrivileges,             // NewPrivileges
                 sizeof(Buffer1),           // BufferLength
                 OldPrivileges,             // PreviousState (OPTIONAL)
                 &Length                    // ReturnLength
                 );


    TmpStatus = ZwClose(Token);
    ASSERT(NT_SUCCESS(TmpStatus));


    //
    // Map the success code NOT_ALL_ASSIGNED to an appropriate error
    // since we're only trying to adjust the one privilege.
    //

    if (Status == STATUS_NOT_ALL_ASSIGNED) {
        Status = STATUS_PRIVILEGE_NOT_HELD;
    }


    if (NT_SUCCESS(Status)) {

        //
        // If there are no privileges in the previous state, there were
        // no changes made. The previous state of the privilege
        // is whatever we tried to change it to.
        //

        if (OldPrivileges->PrivilegeCount == 0) {

            (*WasEnabled) = Enable;

        } else {

            (*WasEnabled) =
                (OldPrivileges->Privileges[0].Attributes & SE_PRIVILEGE_ENABLED)
                ? TRUE : FALSE;
        }
    }

    return(Status);
}

//
// May move this into RTL someday, and let it access internals directly.
//

NTSTATUS
RtlGetSecurityInformationFromSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSECURITY_INFORMATION SecurityInformation
    )

/*++

Routine Description:

    This procedure sets the security information bits for fields
    that are valid in the security descriptor.

Arguments:

    SecurityDescriptor - The passed-in security descriptor.

    SecurityInformation - Returns the bitmask.

Return Value:

    STATUS_SUCCESS - The bitmask was returned successfully.

    Other status values if the security descriptor is invalid.

--*/

{
    SECURITY_INFORMATION BuiltSecurityInformation = 0;
    PACL TempAcl;
    PSID TempSid;
    BOOLEAN Present;
    BOOLEAN Defaulted;
    NTSTATUS Status;

    Status = RtlGetDaclSecurityDescriptor(SecurityDescriptor,
                                          &Present,
                                          &TempAcl,
                                          &Defaulted);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (Present) {
        BuiltSecurityInformation |= DACL_SECURITY_INFORMATION;
    }

    Status = RtlGetSaclSecurityDescriptor(SecurityDescriptor,
                                          &Present,
                                          &TempAcl,
                                          &Defaulted);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (Present) {
        BuiltSecurityInformation |= SACL_SECURITY_INFORMATION;
    }

    Status = RtlGetOwnerSecurityDescriptor(SecurityDescriptor,
                                           &TempSid,
                                           &Defaulted);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (TempSid != NULL) {
        BuiltSecurityInformation |= OWNER_SECURITY_INFORMATION;
    }

    Status = RtlGetGroupSecurityDescriptor(SecurityDescriptor,
                                           &TempSid,
                                           &Defaulted);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (TempSid != NULL) {
        BuiltSecurityInformation |= GROUP_SECURITY_INFORMATION;
    }

    *SecurityInformation = BuiltSecurityInformation;

    return STATUS_SUCCESS;

}
#endif

NTSTATUS
MRxSmbInitializeCSC (
    PUNICODE_STRING SmbMiniRedirectorName
    )
/*++

Routine Description:

    This routine initializes the CSC database

Arguments:

    SmbMiniRedirectorName - the mini redirector name

Return Value:

    STATUS_SUCCESS if successfull otherwise appropriate error

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING CscLinkName;
    ULONG ii;

    C_ASSERT(sizeof(GENERICHEADER)==64);
    C_ASSERT(sizeof(INODEHEADER)==sizeof(GENERICHEADER));
    C_ASSERT(sizeof(SHAREHEADER)==sizeof(GENERICHEADER));
    C_ASSERT(sizeof(FILEHEADER)==sizeof(GENERICHEADER));
    C_ASSERT(sizeof(QHEADER)==sizeof(GENERICHEADER));

    if(!MRxSmbIsCscEnabled) {
        return (STATUS_SUCCESS);
    }

    try {

        InitializeListHead(&xCscFcbsList);

        ExInitializeFastMutex(&CscServerEntryTransitioningMutex);
        KeInitializeEvent(
            &CscServerEntryTransitioningEvent,
            NotificationEvent,
            FALSE);

        //initialize the "semaphore" for the shadow critical section......
        InitializeShadowCritStructures();

        //create a symbolic link for the agent
        RtlInitUnicodeString(&CscLinkName,MRXSMB_CSC_SYMLINK_NAME);
        IoDeleteSymbolicLink(&CscLinkName);
        Status = IoCreateSymbolicLink(&CscLinkName,SmbMiniRedirectorName);
        if (!NT_SUCCESS( Status )) {
            try_return( Status );
        }

        MRxSmbCscLinkCreated = TRUE;

        try_exit: NOTHING;
        } finally {
        if (Status != STATUS_SUCCESS) {
            MRxSmbUninitializeCSC();
        }
    }
    return(Status);
}

VOID
MRxSmbUninitializeCSC(
    void
    )
/*++

Routine Description:

    This routine uninitializes the CSC database

Notes:


--*/
{
    NTSTATUS Status;
    ULONG ii;

    if(!MRxSmbIsCscEnabled) {
        return;
    }
    if (MRxSmbCscLinkCreated) {
        UNICODE_STRING CscLinkName;
        RtlInitUnicodeString(&CscLinkName,MRXSMB_CSC_SYMLINK_NAME);
        Status = IoDeleteSymbolicLink(&CscLinkName);
        ASSERT(Status==STATUS_SUCCESS);
    }

    ii = CloseShadowDB();
    CleanupShadowCritStructures();

    //get rid of references on events
    if (MRxSmbAgentSynchronizationEvent!=NULL) {
        ObDereferenceObject(MRxSmbAgentSynchronizationEvent);
        MRxSmbAgentSynchronizationEvent = NULL;
    }
    if (MRxSmbAgentFillEvent!=NULL) {
        ObDereferenceObject(MRxSmbAgentFillEvent);
        MRxSmbAgentFillEvent = NULL;
    }
}

// The CSC database access rights are stored in terms of SID. The SID is the
// user security id that persists across reboots. The retrieval of the SID
// is a complicated process. This mechanism is captured by the two routines
// CscRetrieveSid and CscDiscardSid. This mechanism is required to avoid
// redundant copying of the SID data from the buffer allocated by the security
// sub system to the redirector buffers. Consequently we need to create a new
// data type which contains the SID alongwith the context ( security allocated
// buffer ). This buffer is allocated on retrieval and freed on discard.

NTSTATUS
CscRetrieveSid(
    PRX_CONTEXT     pRxContext,
    PSID_CONTEXT    pSidContext)
/*++

Routine Description:

    This routine retrieves the SID associated with a given context

Arguments:

    RxContext - the RX_CONTEXT instance

    pSidContext - the SID context

Return Value:

    STATUS_SUCCESS if successfull otherwise appropriate error

Notes:


--*/
{
    NTSTATUS Status;

    PIO_SECURITY_CONTEXT pSecurityContext;

    PACCESS_TOKEN pToken;

    pSecurityContext    = pRxContext->Create.NtCreateParameters.SecurityContext;

    if (pSecurityContext != NULL) {
        pToken = pSecurityContext->AccessState->SubjectSecurityContext.ClientToken;

        if (pToken == NULL) {
            pToken = pSecurityContext->AccessState->SubjectSecurityContext.PrimaryToken;
        }
    } else {
        pSidContext->Context = NULL;
        pSidContext->pSid = NULL;
        return STATUS_SUCCESS;
    }

    if (pToken != NULL) {
        Status = SeQueryInformationToken(
                 pToken,
                 TokenUser,
                 &pSidContext->Context);

        if (Status == STATUS_SUCCESS) {
            PTOKEN_USER    pCurrentTokenUser;

            pCurrentTokenUser = (PTOKEN_USER)pSidContext->Context;

            pSidContext->pSid = pCurrentTokenUser->User.Sid;
        }
    }
    else {
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

VOID
CscDiscardSid(
    PSID_CONTEXT pSidContext)
/*++

Routine Description:

    This routine discards the sid context

Arguments:

    pSidContext - the SID context

--*/
{
    PTOKEN_USER pTokenUser;

    pTokenUser = (PTOKEN_USER)pSidContext->Context;

    if (pTokenUser != NULL) {
        ASSERT(pTokenUser->User.Sid == pSidContext->pSid);

        ExFreePool(pTokenUser);
    }
}

BOOLEAN UseEagerEvaluation = TRUE;

BOOLEAN
CscpAccessCheck(
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformation,
    ULONG                        CachedSecurityInformationLength,
    CSC_SID_INDEX                SidIndex,
    ACCESS_MASK                  AccessMask,
    BOOLEAN                      *pSidHasAccessMask
    )
/*++

Routine Description:

    This routine evaluates the access rights for a given SID index with the
    cached security information

Arguments:

    pCachedSecurityInformation - the cached security information

    CachedSecurityInformationLength - the cached security information length

    SidIndex - the SID index

    AccessMask - desired access

--*/
{
    CSC_SID_INDEX i;
    BOOLEAN AccessGranted = FALSE;

    *pSidHasAccessMask = FALSE;

    if (CachedSecurityInformationLength == sizeof(CACHED_SECURITY_INFORMATION)) {
        // Walk through the cached access rights to determine the
        // maximal permissible access rights.
        for (i = 0;
            ((i < CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES) &&
            (pCachedSecurityInformation->AccessRights[i].SidIndex != SidIndex));
            i++) {
        }

        if (i < CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES) {
            // Ensure that the desired access is a subset of the
            // maximal access rights allowed for this SID

            *pSidHasAccessMask = TRUE;

            AccessGranted = ((AccessMask &
                             pCachedSecurityInformation->AccessRights[i].MaximalRights)
                            == AccessMask);
        } else {
            // if the index cannot be found, ensure that the SID_INDEXES
            // are valid. If none of them are valid then we treat the
            // cached security information as being invalid and let the
            // access through

            for(i = 0;
                ((i < CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES) &&
                (pCachedSecurityInformation->AccessRights[i].SidIndex ==
                CSC_INVALID_SID_INDEX));
                i++);

            if (i == CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES) {
                AccessGranted = TRUE;
            }
        }
    } else if (CachedSecurityInformationLength == 0) {
        AccessGranted = TRUE;
    } else {
        AccessGranted = FALSE;
    }

    return AccessGranted;
}

BOOLEAN
CscAccessCheck(
    HSHADOW              hParent,
    HSHADOW              hFile,
    PRX_CONTEXT          RxContext,
    ACCESS_MASK          AccessMask,
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformationForShadow,
    PCACHED_SECURITY_INFORMATION pCachedSecurityInformationForShare
    )
/*++

Routine Description:

    This routine performs the access check for a given LUID and an ACCESS_MASK
    against the saved rights

Arguments:

Return Value:

    TRUE -- if access is granted

    FALSE -- if access is denied

Notes:

    This routine is the primary routine for evaluating access rights. In order
    to acheive total encapsulation the signature of this routine needs to be
    specified such that the eager evaluation approach as well as the lazy
    evaluation approach can be supported.

    This is a kernel mode only routine.

    The ACCESS_MASK as specified in NT consists of two parts.. the lower 16 bits
    are specific rights ( specified by file system etc. ) while the upper 16 bits
    are generic rights common to all components.

    The cached access rights stored in the CSC data structure store the specific
    rights. Consequently the ACCESS_MASK specified needs to be stripped of the
    generic rights bit before comparing them.

--*/
{
    NTSTATUS    Status;
    BOOLEAN     AccessGranted = FALSE, SidHasAccessMask;
    SID_CONTEXT SidContext;

    Status = CscRetrieveSid(
         RxContext,
         &SidContext);

    if (Status == STATUS_SUCCESS) {
        if (UseEagerEvaluation) {
            HSHARE hShare = 0;

            CACHED_SECURITY_INFORMATION CachedSecurityInformation;

            ULONG BytesReturned,SidLength;
            DWORD CscStatus;
            CSC_SID_INDEX SidIndex;

            if (SidContext.pSid != NULL) {
                SidLength = RtlLengthSid(
                            SidContext.pSid);

            SidIndex = CscMapSidToIndex(
                       SidContext.pSid,
                       SidLength);
            } else {
                SidIndex = CSC_INVALID_SID_INDEX;
            }

            if (SidIndex == CSC_INVALID_SID_INDEX) {
                // The sid was not located in the existing Sid mappings
                // Map this Sid to that of a Guest
                SidIndex = CSC_GUEST_SID_INDEX;
            }

            // Check the share level ACL if there is any.
            if (GetAncestorsHSHADOW(
                    hFile,
                    NULL,
                    &hShare)) {

                BytesReturned = sizeof(CachedSecurityInformation);

                CscStatus = GetShareInfoEx(
                        hShare,
                        NULL,
                        NULL,
                        &CachedSecurityInformation,
                        &BytesReturned);

                // return the info if the caller want's it
                if (pCachedSecurityInformationForShare)
                {
                    *pCachedSecurityInformationForShare = CachedSecurityInformation;
                }

                if (CscStatus == ERROR_SUCCESS) {
                    AccessGranted = CscpAccessCheck(
                        &CachedSecurityInformation,
                        BytesReturned,
                        SidIndex,
                        AccessMask & FILE_SHARE_VALID_FLAGS,
                        &SidHasAccessMask
                        );

                    // if access was not granted for a non-guest
                    // because there was no accessmask for him, then check whether
                    // he should be allowed access as guest

                    if (!AccessGranted && (SidIndex != CSC_GUEST_SID_INDEX) && !SidHasAccessMask)
                    {
                        AccessGranted = CscpAccessCheck(
                            &CachedSecurityInformation,
                            BytesReturned,
                            CSC_GUEST_SID_INDEX,
                            AccessMask & FILE_SHARE_VALID_FLAGS,
                            &SidHasAccessMask
                            );

                    }
                }
            }

            if (AccessGranted) {

                BytesReturned = sizeof(CachedSecurityInformation);

                CscStatus = GetShadowInfoEx(
                    hParent,
                    hFile,
                    NULL,
                    NULL,
                    NULL,
                    &CachedSecurityInformation,
                    &BytesReturned);
                if (CscStatus == ERROR_SUCCESS) {

                    // return the info if the caller want's it
                    if (pCachedSecurityInformationForShadow)
                    {
                        *pCachedSecurityInformationForShadow = CachedSecurityInformation;
                    }

                    AccessGranted = CscpAccessCheck(
                        &CachedSecurityInformation,
                        BytesReturned,
                        SidIndex,
                        AccessMask & 0x1ff,
                        &SidHasAccessMask
                        );

                    // if access was not granted for a non-guest
                    // because there was no accessmask for him, then check whether
                    // he should be allowed access as guest
                    if (!AccessGranted && (SidIndex != CSC_GUEST_SID_INDEX) && !SidHasAccessMask)
                    {
                        AccessGranted = CscpAccessCheck(
                            &CachedSecurityInformation,
                            BytesReturned,
                            CSC_GUEST_SID_INDEX,
                            AccessMask & 0x1ff,
                            &SidHasAccessMask
                            );

                    }
                }
            }
        }

        CscDiscardSid(&SidContext);
    }

    if (RxContext->CurrentIrp && (RxContext->CurrentIrp->Tail.Overlay.OriginalFileObject->FileName.Length > 0)) {
        RxDbgTrace(0,Dbg,
            ("CscAccessCheck for %wZ DesiredAccess %lx AccessGranted %lx\n",
            &RxContext->CurrentIrp->Tail.Overlay.OriginalFileObject->FileName,
            AccessMask,
            AccessGranted));
    } else {
        RxDbgTrace(0,Dbg,
            ("CscAccessCheck for DesiredAccess %lx AccessGranted %lx\n",
            AccessMask,
            AccessGranted));
    }

    return AccessGranted;
}

NTSTATUS
MRxSmbCscAcquireSmbFcb (
    IN OUT PRX_CONTEXT RxContext,
    IN  ULONG TypeOfAcquirePlusFlags,
    OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    )
/*++

Routine Description:

   This routine performs the readwrite synchronization that is required for
   keeping the cache consistent. Basically, the rule is many-readers-one-writer.
   This code relies on being able to use the minirdr context for links.

   A key concept here is that if we are entered and the minirdr context
   is nonull, then we are being reentered(!) after being queued and our
   acquire has succeeded.

Arguments:

    RxContext - the RDBSS context

    TypeOfAcquirePlusFlags -- flags for resource acquisition

    SmbFcbHoldingState -- resource holding state on exit

Return Value:

    NTSTATUS - STATUS_SUCCESS - the lock was acquired
           STATUS_CANCELLED - the operation was cancelled
                  while you were waiting
           STATUS_PENDING - the lock was not acquire; the operation
                will be issued when you do get it
           STATUS_LOCK_NOT_GRANTED - couldn't get it and fail
                     immediately was spec'd

Notes:


--*/
{
    NTSTATUS Status = STATUS_PENDING;
    RxCaptureFcb;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    BOOLEAN MutexAcquired = FALSE;
    DEBUG_ONLY_DECL(BOOLEAN HadToWait = FALSE;)
    USHORT TypeOfAcquire = (USHORT)TypeOfAcquirePlusFlags;
    BOOLEAN FailImmediately = BooleanFlagOn(TypeOfAcquirePlusFlags,
                        FailImmediately_SmbFcbAcquire);
    BOOLEAN DroppingFcbLock = BooleanFlagOn(TypeOfAcquirePlusFlags,
                        DroppingFcbLock_SmbFcbAcquire);

    PMRXSMBCSC_SYNC_RX_CONTEXT pRxSyncContext
        = MRxSmbGetMinirdrContextForCscSync(RxContext);

    RxDbgTrace(0,Dbg,("MRxSmbCscAcquireSmbFcb"
        "  %08lx %08lx %08lx %08lx <%wZ>\n",
        RxContext, TypeOfAcquire,
        smbFcb, smbFcb->CscOutstandingReaders,
        GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)));

    ASSERT ((TypeOfAcquire==Shared_SmbFcbAcquire)
           ||(TypeOfAcquire==Exclusive_SmbFcbAcquire));
    ASSERT (sizeof(MRXSMBCSC_SYNC_RX_CONTEXT) <= MRX_CONTEXT_SIZE);

    ExAcquireFastMutex(&MRxSmbSerializationMutex);
    MutexAcquired = TRUE;

    ASSERT(pRxSyncContext->Dummy == 0);

    if (pRxSyncContext->TypeOfAcquire == 0) {
        pRxSyncContext->TypeOfAcquire = TypeOfAcquire;
        pRxSyncContext->FcbLockWasDropped = FALSE;

        if (smbFcb->CscReadWriteWaitersList.Flink==NULL) {
            InitializeListHead(&smbFcb->CscReadWriteWaitersList);
        }

        do {
            if (pRxSyncContext->FcbLockWasDropped){
                NTSTATUS AStatus;
                RxDbgTrace(
                    0,Dbg,
                    ("MRxSmbCscAcquireSmbFcb %08lx acquireing fcblock\n",
                     RxContext));

                Status = RxAcquireExclusiveFcbResourceInMRx(capFcb);

                if (Status != STATUS_SUCCESS) {
                    break;
                }

                pRxSyncContext->FcbLockWasDropped = FALSE;

                Status = STATUS_PENDING;

                // Acquire the mutex again
                ExAcquireFastMutex(&MRxSmbSerializationMutex);
                MutexAcquired = TRUE;
            }

            //if no one is waiting, maybe we can get right in.....
            if (IsListEmpty(&smbFcb->CscReadWriteWaitersList)) {
                if (TypeOfAcquire==Shared_SmbFcbAcquire) {
                    if (smbFcb->CscOutstandingReaders >= 0) {
                        smbFcb->CscOutstandingReaders++;
                        Status = STATUS_SUCCESS;
                    }
                } else {
                    if (smbFcb->CscOutstandingReaders == 0) {
                        smbFcb->CscOutstandingReaders--; //sets to -1
                        Status = STATUS_SUCCESS;
                    }
                }
            }

            if ((Status == STATUS_PENDING) && FailImmediately) {
                Status = STATUS_LOCK_NOT_GRANTED;
            }

            if (Status == STATUS_PENDING) {
                InsertTailList(&smbFcb->CscReadWriteWaitersList,
                   &pRxSyncContext->CscSyncLinks);
                if (DroppingFcbLock) {
                    RxDbgTrace(
                        0,Dbg,
                        ("MRxSmbCscAcquireSmbFcb %08lx dropping fcblock\n",
                         RxContext));
                    RxReleaseFcbResourceInMRx(capFcb);
                    pRxSyncContext->FcbLockWasDropped = TRUE;
                }
                if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
                    ASSERT(Status == STATUS_PENDING);
                    goto FINALLY;
                }

                KeInitializeEvent( &RxContext->SyncEvent,
                    NotificationEvent,
                    FALSE );
                ExReleaseFastMutex( &MRxSmbSerializationMutex );
                MutexAcquired = FALSE;
                RxWaitSync( RxContext );

                if (BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_CANCELLED)) {
                    Status = STATUS_CANCELLED;
                } else {
                    Status = STATUS_SUCCESS;
                }
            }
        } while ( (pRxSyncContext->FcbLockWasDropped) && (Status == STATUS_SUCCESS) );
    } else {
        Status = STATUS_SUCCESS;
        DbgDoit(
            HadToWait = TRUE;
           )
    }

FINALLY:
    ASSERT(pRxSyncContext->Dummy == 0);
    if (MutexAcquired) {
        ExReleaseFastMutex(&MRxSmbSerializationMutex);
    }

    if (Status == STATUS_SUCCESS) {
        *SmbFcbHoldingState = TypeOfAcquire;
        RxDbgTrace(0,Dbg,("MRxSmbCscAcquireSmbFcb"
        " %08lx acquired %s %s c=%08lx,%08lx\n",
        RxContext,
        (TypeOfAcquire==Shared_SmbFcbAcquire)
                     ?"Shared":"Exclusive",
        (HadToWait)?"HadToWait":"W/O waiting",
        smbFcb->CscOutstandingReaders));
    }

    return(Status);
}

VOID
MRxSmbCscReleaseSmbFcb (
    IN OUT PRX_CONTEXT RxContext,
    IN SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    )
/*++

Routine Description:

   This routine performs the readwrite synchronization that is required for
   keeping the cache consistent. Basically, the rule is many-readers-one-writer.
   This code relies on being able to use the minirdr context for links.

   A key concept here is that if we are entered and the minirdr context
   is nonull, then we are being reentered(!) after being queued and our
   acquire has succeeded.

Arguments:

    RxContext - the RDBSS context

Return Value:


Notes:


--*/
{
    NTSTATUS Status = STATUS_PENDING;
    RxCaptureFcb;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    BOOLEAN Reader = (RxContext->MajorFunction == IRP_MJ_READ);

    PMRXSMBCSC_SYNC_RX_CONTEXT pRxSyncContext
        = MRxSmbGetMinirdrContextForCscSync(RxContext);

    RxDbgTrace(0,Dbg,("MRxSmbCscReleaseSmbFcb entry"
        "  %08lx %08lx %08lx <%wZ>\n",
        RxContext, smbFcb,
        smbFcb->CscOutstandingReaders,
        GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)));

    ASSERT(pRxSyncContext->Dummy == 0);
    ASSERT(*SmbFcbHoldingState!=SmbFcb_NotHeld);

    ExAcquireFastMutex(&MRxSmbSerializationMutex);

    //first, undo my doings.....
    if (*SmbFcbHoldingState == SmbFcb_HeldShared) {
        ASSERT(smbFcb->CscOutstandingReaders>0);
        smbFcb->CscOutstandingReaders--;
    } else {
        ASSERT(smbFcb->CscOutstandingReaders==-1);
        smbFcb->CscOutstandingReaders++; //sets it to zero
    }

    //now start up some guys who may be waiting
    if (!IsListEmpty(&smbFcb->CscReadWriteWaitersList)) {

        PLIST_ENTRY ListEntry = smbFcb->CscReadWriteWaitersList.Flink;

        for (;ListEntry != &smbFcb->CscReadWriteWaitersList;) {
            PLIST_ENTRY ThisListEntry = ListEntry;
            PMRXSMBCSC_SYNC_RX_CONTEXT innerRxSyncContext
                =  CONTAINING_RECORD(ListEntry,
                       MRXSMBCSC_SYNC_RX_CONTEXT,
                       CscSyncLinks);
            PRX_CONTEXT innerRxContext
                = CONTAINING_RECORD(innerRxSyncContext,
                      RX_CONTEXT,
                      MRxContext[0]);
            ULONG innerTypeOfAcquire = (innerRxSyncContext->TypeOfAcquire);

            //move down the list before removing this entry!!!
            ListEntry = ListEntry->Flink;

            // in the followng, Routine is used to restart an async guy. only
            // create, read, and write currently come thru here and of these
            // only read and write are async. so it is okay to ignore create
            // w.r.t. seeting the Routine
            ASSERT(innerRxSyncContext->Dummy == 0);

            if (!innerRxSyncContext->FcbLockWasDropped) {
                if (innerTypeOfAcquire==Shared_SmbFcbAcquire) {
                    if (smbFcb->CscOutstandingReaders < 0) break;
                    smbFcb->CscOutstandingReaders++;
                } else {
                    if (smbFcb->CscOutstandingReaders != 0) break;
                    smbFcb->CscOutstandingReaders--; //sets to -1
                }
            }
            ASSERT(&innerRxSyncContext->CscSyncLinks == ThisListEntry);
            RemoveEntryList(ThisListEntry);
            RxDbgTrace(
                0,Dbg,
                ("MRxSmbCscReleaseSmbFcb acquired after for %s c=%08lx, %08lx\n",
                 (innerTypeOfAcquire==Shared_SmbFcbAcquire)
                  ?"Shared":"Exclusive",
                 smbFcb->CscOutstandingReaders,
                 innerRxContext));
            if (FlagOn(innerRxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
                NTSTATUS PostStatus;
                DbgDoit(InitializeListHead(&innerRxSyncContext->CscSyncLinks);)

                PostStatus = RxPostToWorkerThread(
                                 MRxSmbDeviceObject,
                                 CriticalWorkQueue,
                                 &innerRxContext->WorkQueueItem,
                                 MRxSmbResumeAsyncReadWriteRequests,
                                 innerRxContext);
                ASSERT(PostStatus == STATUS_SUCCESS);
            } else {
                RxSignalSynchronousWaiter(innerRxContext);
            }
        }
    }

    ASSERT(smbFcb->CscOutstandingReaders>=-1);

    ExReleaseFastMutex(&MRxSmbSerializationMutex);
    *SmbFcbHoldingState = SmbFcb_NotHeld;

    RxDbgTrace(0,Dbg,("MRxSmbCscReleaseSmbFcb exit"
        "  %08lx %08lx\n", RxContext, smbFcb->CscOutstandingReaders));
}

VOID
MRxSmbCscSetFileInfoEpilogue (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PNTSTATUS   Status
    )
/*++

Routine Description:

   This routine performs the tail of a write operation for CSC. In
   particular, if the written data overlaps or extends the cached prefix
   then we write the data into the cache.

   The status of the write operation is passed in case we someday find
   things are so messed up that we want to return a failure even after
   a successful read. not today however...

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS LocalStatus = STATUS_SUCCESS;
    ULONG iRet,ShadowFileLength;

    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    BOOLEAN EnteredCriticalSection = FALSE;

    FILE_INFORMATION_CLASS  FileInformationClass;
    PVOID                   pBuffer;
    ULONG                   BufferLength;

    _WIN32_FIND_DATA        Find32;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
     = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);

    BOOLEAN fDisconnected;

    ULONG uShadowStatus;
    DWORD   dwNotifyFilter=0;


    if(!MRxSmbIsCscEnabled ||
       (fShadow == 0)||
        (!smbFcb->hShadow)
        ) {
        return;
    }

    fDisconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    RxDbgTrace(+1, Dbg,
    ("MRxSmbCscSetFileInfoEpilogue...%08lx  on handle %08lx\n",
        RxContext,
        smbSrvOpen->hfShadow ));

    if (*Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("MRxSmbCscSetFileInfoEpilogue exit w/o extending -> %08lx\n", Status ));
        goto FINALLY;
    }

    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    BufferLength = RxContext->Info.Length;

    RxDbgTrace(0, Dbg,
    ("MRxSmbCscSetFileInfoEpilogue: Class %08lx size %08lx\n",
        FileInformationClass,BufferLength));

    switch (FileInformationClass) {
        case FileBasicInformation:
        break;

        case FileAllocationInformation:
        break;

        case FileEndOfFileInformation:
        break;

        case FileDispositionInformation:
        break;

        case FileRenameInformation:
        default:

        goto FINALLY;
   }

    EnterShadowCritRx(RxContext);
    EnteredCriticalSection = TRUE;

    if(GetShadowInfo(smbFcb->hParentDir,
             smbFcb->hShadow,
             &Find32,
             &uShadowStatus, NULL) < SRET_OK) {
        goto FINALLY;
    }

    // Bypass the shadow if it is not visibile for this connection
    if (!IsShadowVisible(fDisconnected,
             Find32.dwFileAttributes,
             uShadowStatus)) {
        goto FINALLY;
    }

    if (FileInformationClass==FileBasicInformation) {
        //copy the stuff from the userbuffer as appropriate...these values
        //must be appropriate since we were successful
        PFILE_BASIC_INFORMATION BasicInfo = (PFILE_BASIC_INFORMATION)pBuffer;
        if (BasicInfo->FileAttributes != 0) {
            Find32.dwFileAttributes = ((BasicInfo->FileAttributes & ~(FILE_ATTRIBUTE_NORMAL|FILE_ATTRIBUTE_DIRECTORY))
                                        | (Find32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY));
                                        ;
            dwNotifyFilter |= FILE_NOTIFY_CHANGE_ATTRIBUTES;
            if (fDisconnected)
            {
                uShadowStatus |= SHADOW_ATTRIB_CHANGE;
                smbSrvOpen->Flags |= SMB_SRVOPEN_FLAG_SHADOW_ATTRIB_MODIFIED;
            }
        }
        if ((BasicInfo->CreationTime.QuadPart != 0)&&
                (BasicInfo->CreationTime.QuadPart != 0xffffffffffffffff))
        {
            COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32.ftCreationTime,
                            BasicInfo->CreationTime);
        }
        if ((BasicInfo->LastAccessTime.QuadPart != 0) &&
            (BasicInfo->LastAccessTime.QuadPart != 0xffffffffffffffff))
        {
            COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32.ftLastAccessTime,
                            BasicInfo->LastAccessTime);
        }

        //
        //  If the user is specifying -1 for a field, that means
        //  we should leave that field unchanged, even if we might
        //  have otherwise set it ourselves.  We'll set the Ccb flag
        //  saying that the user set the field so that we
        //  don't do our default updating.
        //
        //  We set the field to 0 then so we know not to actually
        //  set the field to the user-specified (and in this case,
        //  illegal) value.
        //

       if (BasicInfo->LastWriteTime.QuadPart == 0xffffffffffffffff)
       {
           BasicInfo->LastWriteTime.QuadPart = 0;

           if (fDisconnected)
           {
               smbSrvOpen->Flags |= SMB_SRVOPEN_FLAG_SHADOW_LWT_MODIFIED;
           }
       }

       if (BasicInfo->LastWriteTime.QuadPart != 0)
       {
           ASSERT(BasicInfo->LastWriteTime.QuadPart != 0xffffffffffffffff);

            COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32.ftLastWriteTime,
                            BasicInfo->LastWriteTime);
            if (fDisconnected)
            {
                uShadowStatus |= SHADOW_TIME_CHANGE;
                smbSrvOpen->Flags |= SMB_SRVOPEN_FLAG_SHADOW_LWT_MODIFIED;
            }
            dwNotifyFilter |= FILE_NOTIFY_CHANGE_LAST_WRITE;
        }
    }
    else if (FileInformationClass==FileDispositionInformation)
    {
        if (fDisconnected)
        {
            // if this is a file and we are trying to delete it
            // without permissions, then bail

            if (!(Find32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)&&
                !(FILE_WRITE_DATA & smbSrvOpen->MaximalAccessRights)&&
                !(FILE_WRITE_DATA & smbSrvOpen->GuestMaximalAccessRights))
            {
                *Status = STATUS_ACCESS_DENIED;
                RxLog(("No rights to del %x in dcon Status=%x\n", smbFcb->hShadow, LocalStatus));
                HookKdPrint(BADERRORS, ("No rights to del %x in dcon Status=%x\n", smbFcb->hShadow, LocalStatus));
            }
            else
            {
                LocalStatus = OkToDeleteObject(smbFcb->hParentDir, smbFcb->hShadow, &Find32, uShadowStatus, fDisconnected);

                if (LocalStatus != STATUS_SUCCESS)
                {
                    RxLog(("Can't del %x in dcon Status=%x\n", smbFcb->hShadow, LocalStatus));
                    *Status = LocalStatus;
                }
            }
        }

        goto FINALLY;

    }
    else {
        //basically, all i can do here is to ensure that the shadow is no bigger than the size
        //given, whether allocationsize or filesize. when we read back the actual size at close
        //some readjusting may be required so we turn sparse on.
        PFILE_END_OF_FILE_INFORMATION UserEndOfFileInformation
                         = (PFILE_END_OF_FILE_INFORMATION)pBuffer;
        int iRet;
        ULONG ShadowFileLength;

        ASSERT( FIELD_OFFSET(FILE_END_OF_FILE_INFORMATION,EndOfFile)
                       == FIELD_OFFSET(FILE_ALLOCATION_INFORMATION,AllocationSize) );

        //don't need the shadowreadwritemutex here because SetFileInfo has both resources...
        //thus, no other operations can come down

        if (!(CSCHFILE)(smbSrvOpen->hfShadow))
        {
            if (fDisconnected)
            {
                *Status = STATUS_OBJECT_TYPE_MISMATCH;
            }

            goto FINALLY;
        }
        iRet = GetFileSizeLocal((CSCHFILE)(smbSrvOpen->hfShadow), &ShadowFileLength);
        if (iRet<0) {
            if (fDisconnected)
            {
                *Status = STATUS_UNSUCCESSFUL;
            }
            goto FINALLY;
        }
        if (ShadowFileLength != UserEndOfFileInformation->EndOfFile.QuadPart) {
            NTSTATUS SetStatus;
            PNT5CSC_MINIFILEOBJECT MiniFileObject
               = (PNT5CSC_MINIFILEOBJECT)(smbSrvOpen->hfShadow);
            IO_STATUS_BLOCK IoStatusBlock;
            ULONG DummyReturnedLength;

            // If we are connected, don't extend sparse files!!!!
            if (fDisconnected ||
                (!(uShadowStatus & SHADOW_SPARSE) || (ShadowFileLength > UserEndOfFileInformation->EndOfFile.QuadPart)))
            {
//                DbgPrint("SetEof on %x Old=%x New=%x \n", smbFcb->hShadow,  ShadowFileLength, UserEndOfFileInformation->EndOfFile.QuadPart);

                SetStatus = Nt5CscXxxInformation(
                        (PCHAR)IRP_MJ_SET_INFORMATION,
                        MiniFileObject,
                        FileEndOfFileInformation,
                        sizeof(FILE_END_OF_FILE_INFORMATION),
                        pBuffer,
                        &DummyReturnedLength
                        );
            }

#if defined(BITCOPY)
            // Do I need to check if EOFinfo (a 64-bit value) is using
            // the upper 32 bits? CscBmp library only supports 32-bit
            // file sizes.
            if (smbFcb->lpDirtyBitmap && fDisconnected &&
                    UserEndOfFileInformation->EndOfFile.HighPart == 0) {
                // Is it ShadowFileLength?
                CscBmpResize(
                    smbFcb->lpDirtyBitmap,
                    (DWORD)UserEndOfFileInformation->EndOfFile.QuadPart);
            } else if (UserEndOfFileInformation->EndOfFile.HighPart != 0) {
                // File is too big to be represented by a CscBmp, delete.
                CscBmpMarkInvalid(smbFcb->lpDirtyBitmap);
            }
#endif // defined(BITCOPY)

            if (fDisconnected)
            {
                uShadowStatus |= SHADOW_DIRTY;
                dwNotifyFilter |= FILE_NOTIFY_CHANGE_SIZE;
            }
            mSetBits(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED);
            Find32.nFileSizeLow = (DWORD)UserEndOfFileInformation->EndOfFile.QuadPart;
        }

    }

    if (fDisconnected)
    {
        MarkShareDirty(&smbFcb->sCscRootInfo.ShareStatus, smbFcb->sCscRootInfo.hShare);
    }

    if(SetShadowInfo(smbFcb->hParentDir,
             smbFcb->hShadow,
             &Find32,
             uShadowStatus,
             SHADOW_FLAGS_ASSIGN
            | ((fDisconnected)?SHADOW_FLAGS_DONT_UPDATE_ORGTIME
                      :0)
             ) < SRET_OK) {
        goto FINALLY;
    }


FINALLY:
    if (EnteredCriticalSection) {
        LeaveShadowCritRx(RxContext);
    }

    // in disconnected state, report the changes
    if (fDisconnected && dwNotifyFilter)
    {
        FsRtlNotifyFullReportChange(
            pNetRootEntry->NetRoot.pNotifySync,
            &pNetRootEntry->NetRoot.DirNotifyList,
            (PSTRING)GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb),
            (USHORT)(GET_ALREADY_PREFIXED_NAME(SrvOpen, capFcb)->Length -
                        smbFcb->MinimalCscSmbFcb.LastComponentLength),
            NULL,
            NULL,
            dwNotifyFilter,
            FILE_ACTION_MODIFIED,
            NULL);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscSetFileInfoEpilogue -> %08lx\n", Status ));
    return;
}

//this could easily bein a .h file

int IoctlRegisterAgent(
   ULONG_PTR uHwnd
   );

int IoctlUnRegisterAgent(
   ULONG_PTR uHwnd
   );

int IoctlGetUNCPath(
   LPCOPYPARAMS lpCopyParams
   );

int IoctlBeginPQEnum(
   LPPQPARAMS lpPQPar
   );

int IoctlEndPQEnum(
   LPPQPARAMS lpPQPar
   );

int IoctlNextPriShadow(
   LPPQPARAMS lpPQPar
   );

int IoctlPrevPriShadow(
   LPPQPARAMS lpPQPar
   );

int IoctlGetShadowInfo(
   LPSHADOWINFO   lpShadowInfo
   );

int IoctlSetShadowInfo(
   LPSHADOWINFO   lpShadowInfo
   );

int IoctlChkUpdtStatus(
   LPSHADOWINFO   lpShadowInfo
   );

int IoctlDoShadowMaintenance(
   LPSHADOWINFO   lpSI
   );

BOOLEAN
CscCheckForNullW(
    PWCHAR pBuf,
    ULONG Count);

NTSTATUS
MRxSmbCscIoctlOpenForCopyChunk (
    PRX_CONTEXT RxContext
    );
NTSTATUS
MRxSmbCscIoctlCloseForCopyChunk (
    PRX_CONTEXT RxContext
    );
NTSTATUS
MRxSmbCscIoctlCopyChunk (
    PRX_CONTEXT RxContext
    );

int IoctlBeginReint(
   LPSHADOWINFO   lpShadowInfo
   );

int IoctlEndReint(
   LPSHADOWINFO   lpShadowInfo
   );

int IoctlCreateShadow(
   LPSHADOWINFO lpSI
   );

int IoctlDeleteShadow(
   LPSHADOWINFO   lpSI
   );

int IoctlGetShareStatus(
   LPSHADOWINFO   lpSI
   );

int IoctlSetShareStatus(
   LPSHADOWINFO   lpSI
   );

int IoctlAddUse(
   LPCOPYPARAMS lpCP
   );

int IoctlDelUse(
   LPCOPYPARAMS lpCP
   );

int IoctlGetUse(
   LPCOPYPARAMS lpCP
   );

int IoctlSwitches(LPSHADOWINFO lpSI);

int IoctlGetShadow(
   LPSHADOWINFO lpSI
   );

int IoctlAddHint(      // Add a new hint or change an existing hint
   LPSHADOWINFO   lpSI
   );

int IoctlDeleteHint(   // Delete an existing hint
   LPSHADOWINFO lpSI
   );

int IoctlGetHint(
   LPSHADOWINFO   lpSI
   );

int IoctlGetGlobalStatus(
   ULONG SessionId,
   LPGLOBALSTATUS lpGS
   );

int IoctlFindOpenHSHADOW
   (
   LPSHADOWINFO   lpSI
   );

int IoctlFindNextHSHADOW
   (
   LPSHADOWINFO   lpSI
   );

int IoctlFindCloseHSHADOW
   (
   LPSHADOWINFO   lpSI
   );

int IoctlFindOpenHint
   (
   LPSHADOWINFO   lpSI
   );

int IoctlFindNextHint
   (
   LPSHADOWINFO   lpSI
   );

int IoctlFindCloseHint
   (
   LPSHADOWINFO   lpSI
   );

int IoctlSetPriorityHSHADOW(
   LPSHADOWINFO   lpSI
   );

int IoctlGetPriorityHSHADOW(
   LPSHADOWINFO   lpSI
   );

int IoctlGetAliasHSHADOW(
   LPSHADOWINFO   lpSI
   );

#define CSC_CASE(__case)         \
    case __case:                 \
    RxDbgTrace(0,Dbg,("MRxSmbCscIoctl %08lx %s %08lx %08lx\n",RxContext,#__case,InputBuffer,OutputBuffer));

ULONG GetNextPriShadowCount = 0;

NTSTATUS
MRxSmbCscIoCtl(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine performs the special IOCTL operation for the CSC agent.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    ShadowIRet is overloaded: 
         -1 == error, copy the error back
          0 == error, return Wrong password (STATUS_WRONG_PASSWORD)
          1 == success, output params, copy them back
          2 == return status unmodified, no output params


--*/
{
    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    ULONG   IoControlCode = LowIoContext->ParamsFor.IoCtl.IoControlCode;
    PBYTE   InputBuffer = LowIoContext->ParamsFor.IoCtl.pInputBuffer;
    PBYTE   pNewInputBuffer=NULL;
    ULONG   InputBufferLength = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    PBYTE   OutputBuffer = LowIoContext->ParamsFor.IoCtl.pOutputBuffer;
    ULONG   OutputBufferLength = LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
    LONG    ShadowIRet = 0;
    CAPTURE_BUFFERS sCapBuff;
    PBYTE   pAuxBuf = NULL;
    PBYTE   pOrgBuf = NULL;
    BOOLEAN SuppressFinalTrace = FALSE, fEnteredShadowCrit=FALSE;
    KPROCESSOR_MODE RequestorMode;
    ULONG   SessionId = 0;

#if defined (_WIN64)
    if (IoIs32bitProcess(RxContext->CurrentIrp)) {
        RxDbgTrace(0, Dbg, ("32 bit IOCTL in 64 bit returning STATUS_NOT_IMPLEMENTED\n"));
        return STATUS_NOT_IMPLEMENTED;
    }
#endif // _WIN64

    
    if (RxContext != NULL && RxContext->CurrentIrp != NULL)
        IoGetRequestorSessionId(RxContext->CurrentIrp, &SessionId);

    try
    {
        RequestorMode = RxContext->CurrentIrp->RequestorMode;

        if (
            RequestorMode != KernelMode
                &&
            IoControlCode != IOCTL_GET_DEBUG_INFO
        ) {
            if (CaptureInputBufferIfNecessaryAndProbe(
                        IoControlCode,
                        RxContext,
                        InputBuffer,
                        &sCapBuff,
                        &pAuxBuf,
                        &pOrgBuf,
                        &pNewInputBuffer)!=STATUS_SUCCESS) {
                RxDbgTrace(0, Dbg, ("Invalid parameters for Ioctl=%x\n", IoControlCode));
                return STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            pNewInputBuffer = InputBuffer;
        }
        // DbgPrint("MRxSmbCscIoCtl IoControlCode=%d\n", (IoControlCode >> 2) & 0xfff);
        switch (IoControlCode) {
        CSC_CASE(IOCTL_SHADOW_GETVERSION)
        Status = (NTSTATUS)(SHADOW_VERSION); // no-op
        break;

        CSC_CASE(IOCTL_SHADOW_REGISTER_AGENT)
        ShadowIRet = IoctlRegisterAgent((ULONG_PTR)pNewInputBuffer);
        if (ShadowIRet>=0) {
            MRxSmbCscReleaseRxContextFromAgentWait();
        }
        break;

        CSC_CASE(IOCTL_SHADOW_UNREGISTER_AGENT)
        ShadowIRet = IoctlUnRegisterAgent((ULONG_PTR)pNewInputBuffer);
        if (ShadowIRet>=0) {
            MRxSmbCscReleaseRxContextFromAgentWait();
        }
        break;

        CSC_CASE(IOCTL_SHADOW_GET_UNC_PATH)
        ShadowIRet = IoctlGetUNCPath((LPCOPYPARAMS)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SHADOW_BEGIN_PQ_ENUM)
        ShadowIRet = IoctlBeginPQEnum((LPPQPARAMS)pNewInputBuffer);
        GetNextPriShadowCount = 0;
        break;

        CSC_CASE(IOCTL_SHADOW_END_PQ_ENUM)
        ShadowIRet = IoctlEndPQEnum((LPPQPARAMS)pNewInputBuffer);
        break;

        //CSC_CASE(IOCTL_SHADOW_NEXT_PRI_SHADOW)
        case IOCTL_SHADOW_NEXT_PRI_SHADOW:                 \
        if ((GetNextPriShadowCount<6) || ((GetNextPriShadowCount%40)==0)) {
            RxDbgTrace(0,Dbg,("MRxSmbCscIoctl %08lx %s(%d) %08lx %08lx\n",
                       RxContext,
                       "IOCTL_SHADOW_NEXT_PRI_SHADOW",GetNextPriShadowCount,
                       pNewInputBuffer,OutputBuffer));
        }
        ShadowIRet = IoctlNextPriShadow((LPPQPARAMS)pNewInputBuffer);
        GetNextPriShadowCount++;
        SuppressFinalTrace = TRUE;
        break;

        CSC_CASE(IOCTL_SHADOW_PREV_PRI_SHADOW)
        ShadowIRet = IoctlPrevPriShadow((LPPQPARAMS)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SHADOW_GET_SHADOW_INFO)
        ShadowIRet = IoctlGetShadowInfo((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SHADOW_SET_SHADOW_INFO)
        ShadowIRet = IoctlSetShadowInfo((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SHADOW_CHK_UPDT_STATUS)
        ShadowIRet = IoctlChkUpdtStatus((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_DO_SHADOW_MAINTENANCE)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

#if defined(REMOTE_BOOT)
            // If this IOCTL is for turning caching back on we need to update
            // the mini redirector accordingly.
            if ((pShadowInfo->uOp == SHADOW_CHANGE_HANDLE_CACHING_STATE) &&
                (pShadowInfo->uStatus != FALSE)) {
                RxDbgTrace(0, Dbg, ("RB Client : Turning caching back on\n"));
                MRxSmbOplocksDisabledOnRemoteBootClients = FALSE;
            }
#endif // defined(REMOTE_BOOT)

            ShadowIRet = IoctlDoShadowMaintenance(pShadowInfo);
        }
        break;

        CSC_CASE(IOCTL_GET_DEBUG_INFO)
        ShadowIRet = 2;
        Status = IoctlGetDebugInfo(
                    RxContext,
                    InputBuffer,
                    InputBufferLength,
                    OutputBuffer,
                    OutputBufferLength);
        break;

        CSC_CASE(IOCTL_SHADOW_COPYCHUNK)
        ShadowIRet = 2; //not -1, 0 or 1, No out parameters, Status is returned unmodified
        Status = MRxSmbCscIoctlCopyChunk(RxContext);
        break;

        CSC_CASE(IOCTL_CLOSEFORCOPYCHUNK)
        ShadowIRet = 2; //not -1, 0 or 1, No out parameters, Status is returned unmodified
        Status = MRxSmbCscIoctlCloseForCopyChunk(RxContext);
        break;

        CSC_CASE(IOCTL_OPENFORCOPYCHUNK)
        ShadowIRet = 2; //not -1, 0 or 1, No out parameters, Status is returned unmodified
        Status = MRxSmbCscIoctlOpenForCopyChunk(RxContext);
        break;

        CSC_CASE(IOCTL_IS_SERVER_OFFLINE)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            if (pShadowInfo->lpBuffer == NULL
                    ||
                CscCheckForNullW(pShadowInfo->lpBuffer, pShadowInfo->cbBufferSize/sizeof(WCHAR)) == TRUE
            ) {
                ShadowIRet = 1;
                pShadowInfo->uStatus = CscIsServerOffline((PWCHAR)pShadowInfo->lpBuffer);
            }

        }
        break;

        CSC_CASE(IOCTL_TAKE_SERVER_OFFLINE)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            if (pShadowInfo->lpBuffer != NULL
                    &&
                CscCheckForNullW(pShadowInfo->lpBuffer, pShadowInfo->cbBufferSize/sizeof(WCHAR)) == TRUE
            ) {
                ShadowIRet = 1;
                pShadowInfo->uStatus = CscTakeServerOffline( (PWCHAR)pShadowInfo->lpBuffer);
            }

        }
        break;

        CSC_CASE(IOCTL_TRANSITION_SERVER_TO_OFFLINE)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = 2; //not -1, 0 or 1, No out parameters, Status is returned unmodified
            Status = CscTransitionServerToOffline(
                 SessionId,
                 pShadowInfo->hShare,
                 pShadowInfo->uStatus);
            // DbgPrint("###IOCTL_TRANSITION_SERVER_TO_OFFLINE: pulsing fill event\n");
            MRxSmbCscSignalFillAgent(NULL, 0);
        }
        break;

        CSC_CASE(IOCTL_TRANSITION_SERVER_TO_ONLINE)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = 2; //not -1, 0 or 1, No out parameters, Status is returned unmodified
            Status = CscTransitionServerToOnline(
                 pShadowInfo->hShare);
            // DbgPrint("###IOCTL_TRANSITION_SERVER_TO_ONLINE: pulsing fill event\n");
            MRxSmbCscSignalFillAgent(NULL, 0);
        }
        break;

        CSC_CASE(IOCTL_NAME_OF_SERVER_GOING_OFFLINE)
        {
            LPSHADOWINFO lpSI = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = 1;

            CscGetServerNameWaitingToGoOffline(
                    lpSI->lpBuffer,
                    &(lpSI->cbBufferSize),
                    &Status);
            if (Status == STATUS_BUFFER_TOO_SMALL)
            {
                ((LPSHADOWINFO)InputBuffer)->cbBufferSize = lpSI->cbBufferSize;

                HookKdPrint(ALWAYS, ("Buffer too small, Need %d \n", ((LPSHADOWINFO)InputBuffer)->cbBufferSize));
            }
        }
        break;

        CSC_CASE(IOCTL_SHAREID_TO_SHARENAME)
        {
            LPSHADOWINFO lpSI = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = 1;

            CscShareIdToShareName(
                    lpSI->hShare,
                    lpSI->lpBuffer,
                    &(lpSI->cbBufferSize),
                    &Status);
            if (Status == STATUS_BUFFER_TOO_SMALL) {
                ((LPSHADOWINFO)InputBuffer)->cbBufferSize = lpSI->cbBufferSize;

                HookKdPrint(
                    ALWAYS,
                    ("Buffer small, Need %d \n", ((LPSHADOWINFO)InputBuffer)->cbBufferSize));
            } else if (Status != STATUS_SUCCESS) {
                lpSI->dwError = ERROR_FILE_NOT_FOUND;
                ShadowIRet = -1;
            }
        }
        break;


        CSC_CASE(IOCTL_SHADOW_BEGIN_REINT)
        ShadowIRet = CSCBeginReint(RxContext, (LPSHADOWINFO)pNewInputBuffer);
        if (ShadowIRet >= 1)
        {
            ShadowIRet = 2;
            Status = STATUS_PENDING;
        }
        break;

        CSC_CASE(IOCTL_SHADOW_END_REINT)
        ShadowIRet = CSCEndReint((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SHADOW_CREATE)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = -1;
            if (pShadowInfo->lpFind32
                   &&
                CscCheckForNullW(pShadowInfo->lpFind32->cFileName, MAX_PATH) == TRUE
            ) {
                ShadowIRet = IoctlCreateShadow(pShadowInfo);
            }
        }
        break;

        CSC_CASE(IOCTL_SHADOW_DELETE)
        ShadowIRet = IoctlDeleteShadow((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_GET_SHARE_STATUS)
        ShadowIRet = IoctlGetShareStatus((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SET_SHARE_STATUS)
        ShadowIRet = IoctlSetShareStatus((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_ADDUSE)
        //ShadowIRet = IoctlAddUse((LPCOPYPARAMS)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_DELUSE)
        //ShadowIRet = IoctlDelUse((LPCOPYPARAMS)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_GETUSE)
        //ShadowIRet = IoctlGetUse((LPCOPYPARAMS)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SWITCHES)
        ShadowIRet = IoctlSwitches((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_GETSHADOW)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = -1;
            if (pShadowInfo->lpFind32
                   &&
                CscCheckForNullW(pShadowInfo->lpFind32->cFileName, MAX_PATH) == TRUE
            ) {
                ShadowIRet = IoctlGetShadow(pShadowInfo);
            }
        }
        break;

        CSC_CASE(IOCTL_GETGLOBALSTATUS)
        ShadowIRet = IoctlGetGlobalStatus(SessionId, (LPGLOBALSTATUS)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_FINDOPEN_SHADOW)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = -1;
            if (pShadowInfo->lpFind32
                   &&
                CscCheckForNullW(pShadowInfo->lpFind32->cFileName, MAX_PATH) == TRUE
            ) {
                ShadowIRet = IoctlFindOpenHSHADOW(pShadowInfo);
            }
        }
        break;

        CSC_CASE(IOCTL_FINDNEXT_SHADOW)
        ShadowIRet = IoctlFindNextHSHADOW((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_FINDCLOSE_SHADOW)
        ShadowIRet = IoctlFindCloseHSHADOW((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_GETPRIORITY_SHADOW)
        ShadowIRet = IoctlGetPriorityHSHADOW((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_SETPRIORITY_SHADOW)
        ShadowIRet = IoctlSetPriorityHSHADOW((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_ADD_HINT)
        ShadowIRet = IoctlAddHint((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_DELETE_HINT)
        ShadowIRet = IoctlDeleteHint((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_FINDOPEN_HINT)
        {
            LPSHADOWINFO pShadowInfo = (LPSHADOWINFO)pNewInputBuffer;

            ShadowIRet = -1;
            if (pShadowInfo->lpFind32
                   &&
                CscCheckForNullW(pShadowInfo->lpFind32->cFileName, MAX_PATH) == TRUE
            ) {
                ShadowIRet = IoctlFindOpenHint(pShadowInfo);
            }
        }
        break;

        CSC_CASE(IOCTL_FINDNEXT_HINT)
        ShadowIRet = IoctlFindNextHint((LPSHADOWINFO)pNewInputBuffer);
        break;

        CSC_CASE(IOCTL_FINDCLOSE_HINT)
        ShadowIRet = IoctlFindCloseHint((LPSHADOWINFO)pNewInputBuffer);
        break;

        default:
        RxDbgTrace(-1, Dbg, ("MRxSmbCscIoCtl not csc ioctl-> %08lx\n", Status ));
        return Status;
        }
        if (ShadowIRet == 0) {
                Status = STATUS_WRONG_PASSWORD;
        } else if (ShadowIRet == -1) {
            if (RequestorMode != KernelMode)
            {
                CopyBackIfNecessary(
                    IoControlCode,
                    InputBuffer,
                    &sCapBuff,
                    pAuxBuf,
                    pOrgBuf,
                    FALSE);
            }
            Status = STATUS_UNSUCCESSFUL;
        } else if (ShadowIRet == 1) {

            if (RequestorMode != KernelMode)
            {
                CopyBackIfNecessary(
                    IoControlCode,
                    InputBuffer,
                    &sCapBuff,
                    pAuxBuf,
                    pOrgBuf,
                    TRUE);
            }

            Status = STATUS_SUCCESS;
        }

        if (SuppressFinalTrace) {
            RxDbgTraceUnIndent(-1, Dbg);
        } else {
            RxDbgTrace(-1, Dbg,
                ("MRxSmbCscIoCtl -> %08lx %08lx\n", Status, ShadowIRet ));
        }
    }
    except(MRxSmbCSCExceptionFilter( RxContext, GetExceptionInformation() ))
    {
        RxDbgTrace(0, Dbg, ("MrxSmbCSCIoctl: took an exception \r\n"));
        LeaveShadowCritIfThisThreadOwnsIt();
        Status = STATUS_INVALID_PARAMETER;
    }

    if (pAuxBuf != NULL) {
        // DbgPrint("Freeing pAuxBuf\n");
        RxFreePool(pAuxBuf);
    }

    // DbgPrint("MRxSmbCscIoCtl exit 0x%x\n", Status);
    return Status;
}

NTSTATUS
MRxSmbCscObtainShareHandles (
    IN OUT PUNICODE_STRING         ShareName,
    IN BOOLEAN                     DisconnectedMode,
    IN BOOLEAN                     CopyChunkOpen,
    IN OUT PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
)
/*++

Routine Description:

   This routine performs the obtains the handles (Share and root directory)
   for a particular \server\share, updating the values in the netrootentry
   if found.

Arguments:

    pNetRootEntry - the SMB MRX net root data structure

Return Value:

    NTSTATUS - The return status for the operation
          STATUS_NOT_INPLEMENTED - couldn't find or create
          STATUS_SUCCESS - found or created

Notes:

--*/
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;

    BOOLEAN CreateIfNotFound = FALSE;

    SHADOWINFO ShadowInfo;

    DbgDoit(ASSERT(vfInShadowCrit));

    if (fShadow == 0) {
        return(Status);
    }

    if (pNetRootEntry->NetRoot.sCscRootInfo.hShare != 0)  {
        Status = STATUS_SUCCESS;
        goto FINALLY;
    }

    // At this stage one of the following two assumptions should be TRUE.
    // Connected Mode Operation ...
    //  In this instance the call can succeed only if the Net Root is
    //  marked as being shadowable by the CSC client and iot is of type
    //  Disk.
    // Disconnected Mode Operation ...
    //  In this case we have not yet ascertained the type and attributes
    //  Therefore we let the call go through. If we can open the handle
    //  to the Share then we mark the net root to be of the appropriate
    //  type.

    if (    !DisconnectedMode &&
            !CopyChunkOpen &&
            (/*!pNetRootEntry->NetRoot.CscEnabled ||*/
            (pNetRootEntry->NetRoot.NetRootType != NET_ROOT_DISK))) {
        goto FINALLY;
    }

    // allocate a buffer that's the right size: one extra char is
    // for a trailing null and the other for a preceding L'\\'

    if (ShadowingON()) {
        if (!DisconnectedMode &&
            pNetRootEntry->NetRoot.CscShadowable) {
            CreateIfNotFound = TRUE;
        }
    }

    RxDbgTrace(0, Dbg,
    ("MRxSmbCscObtainShareHandles...servershare=%wZ %08lx\n",
         ShareName,CreateIfNotFound));

    if (FindCreateShareForNt(
        ShareName,
        CreateIfNotFound,
        &ShadowInfo,
        NULL  //this means don't tell me if you create
        ) == SRET_OK ) {

        ASSERT(ShadowInfo.hShare != 0);

        pNetRootEntry->NetRoot.sCscRootInfo.hShare = ShadowInfo.hShare;
        pNetRootEntry->NetRoot.sCscRootInfo.hRootDir = ShadowInfo.hShadow;
        pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus = (USHORT)(ShadowInfo.uStatus);
        pNetRootEntry->NetRoot.sCscRootInfo.Flags = 0;

        RxLog(("OSHH...hDir=%x\n",pNetRootEntry->NetRoot.sCscRootInfo.hRootDir));

        // if we are connected, by this time we have the smb caching flags
        // we check to see whether these match those on the database
        // If they don't, we stamp the new ones
        if (!DisconnectedMode)
        {
            if ((ShadowInfo.uStatus & SHARE_CACHING_MASK)!=
                (ULONG)SMB_CSC_BITS_TO_DATABASE_CSC_BITS(pNetRootEntry->NetRoot.CscFlags))
            {
//                RxDbgTrace(0, Dbg, ("Mismatched smb caching flags, stamping %x on hShare=%x\n",
//                                    SMB_CSC_BITS_TO_DATABASE_CSC_BITS(pNetRootEntry->NetRoot.CscFlags),
//                                    pNetRootEntry->NetRoot.sCscRootInfo.hShare));

                pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus &= ~SHARE_CACHING_MASK;
                pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus |= SMB_CSC_BITS_TO_DATABASE_CSC_BITS(pNetRootEntry->NetRoot.CscFlags);

                SetShareStatus( pNetRootEntry->NetRoot.sCscRootInfo.hShare,
                                 pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus,
                                 SHADOW_FLAGS_ASSIGN);
            }

        }
        else
        {
            // in disconnected mode we use the last set of flags
            pNetRootEntry->NetRoot.CscFlags = DATABASE_CSC_BITS_TO_SMB_CSC_BITS(pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus);

            RxDbgTrace(0, Dbg, ("Setting CscFlags=%x on the netrootentry %x in disconnected state\n",pNetRootEntry->NetRoot.CscFlags, pNetRootEntry));

            switch (pNetRootEntry->NetRoot.CscFlags) {
                case SMB_CSC_CACHE_AUTO_REINT:
                case SMB_CSC_CACHE_VDO:
                    pNetRootEntry->NetRoot.CscEnabled = TRUE;
                    pNetRootEntry->NetRoot.CscShadowable = TRUE;
                break;

                case SMB_CSC_CACHE_MANUAL_REINT:
                    pNetRootEntry->NetRoot.CscEnabled    = TRUE;
                    pNetRootEntry->NetRoot.CscShadowable = FALSE;
                break;

                case SMB_CSC_NO_CACHING:
                    pNetRootEntry->NetRoot.CscEnabled = FALSE;
                    pNetRootEntry->NetRoot.CscShadowable = FALSE;
            }

        }

        Status = STATUS_SUCCESS;
    } else {
        if (DisconnectedMode) {
            Status = STATUS_BAD_NETWORK_PATH;
        } else if (!CreateIfNotFound) {
            pNetRootEntry->NetRoot.sCscRootInfo.hShare      = 0;
            pNetRootEntry->NetRoot.sCscRootInfo.hRootDir     = 0;
            pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus = 0;
            pNetRootEntry->NetRoot.sCscRootInfo.Flags = 0;

            Status = STATUS_SUCCESS;
        }
    }

FINALLY:

    RxDbgTrace(
    -1,
    Dbg,
    ("MRxSmbCscObtainShareHandles -> %08lx (h=%08lx)\n",
        Status, pNetRootEntry->NetRoot.sCscRootInfo.hShare ));

    return Status;
}


NTSTATUS
MRxSmbCscPartOfCreateVNetRoot (
    IN PRX_CONTEXT RxContext,
    IN OUT PMRX_NET_ROOT NetRoot )
{
    NTSTATUS Status;

    PMRX_SRV_CALL           SrvCall;

    PSMBCEDB_SERVER_ENTRY   pServerEntry;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    HSHARE hShare;

    if(!MRxSmbIsCscEnabled ||
       (fShadow == 0)
        ) {
        return(STATUS_SUCCESS);
    }

    ASSERT(RxContext->MajorFunction == IRP_MJ_CREATE);

    pServerEntry  = SmbCeGetAssociatedServerEntry(NetRoot->pSrvCall);
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);

    if (!CscIsDfsOpen(RxContext)) {
        BOOLEAN Disconnected = SmbCeIsServerInDisconnectedMode(pServerEntry);

        EnterShadowCritRx(RxContext);

        // force a database entry refresh
        hShare = pNetRootEntry->NetRoot.sCscRootInfo.hShare;
        pNetRootEntry->NetRoot.sCscRootInfo.hShare = 0;
#if 0
        if ((NetRoot->pNetRootName->Length >= (sizeof(L"\\win95b\\fat")-2)) &&
            !memcmp(NetRoot->pNetRootName->Buffer, L"\\win95b\\fat", sizeof(L"\\win95b\\fat")-2))
        {
            pNetRootEntry->NetRoot.CscShadowable =
            pNetRootEntry->NetRoot.CscEnabled = TRUE;
        }
#endif
        Status = MRxSmbCscObtainShareHandles(
                 NetRoot->pNetRootName,
                 Disconnected,
                 FALSE,
                 pNetRootEntry
                );

              // update the share rights if necessary

        if (!Disconnected) {

            if(pNetRootEntry->NetRoot.UpdateCscShareRights) {
                if (pNetRootEntry->NetRoot.sCscRootInfo.hShare != 0) {
                    CSC_SID_ACCESS_RIGHTS AccessRights[2];

                    DWORD CscStatus;

                    SID_CONTEXT SidContext;

                    // not a DFS root
                    pNetRootEntry->NetRoot.sCscRootInfo.Flags = 0;

                    if (CscRetrieveSid(RxContext,&SidContext) == STATUS_SUCCESS) {
                        AccessRights[0].pSid = SidContext.pSid;
                        AccessRights[0].SidLength = RtlLengthSid(SidContext.pSid);
                        AccessRights[0].MaximalAccessRights = pNetRootEntry->MaximalAccessRights;

                        AccessRights[1].pSid = CSC_GUEST_SID;
                        AccessRights[1].SidLength = CSC_GUEST_SID_LENGTH;
                        AccessRights[1].MaximalAccessRights = pNetRootEntry->GuestMaximalAccessRights;

                        CscStatus = CscAddMaximalAccessRightsForShare(
                                pNetRootEntry->NetRoot.sCscRootInfo.hShare,
                                2,
                                AccessRights);
                        if (CscStatus != ERROR_SUCCESS) {
                            RxDbgTrace(
                            0,
                            Dbg,
                            ("MRxSmbCscCreateEpilogue Error Updating Access rights %lx\n",
                            Status));
                        }
                        else
                        {
                            pNetRootEntry->NetRoot.UpdateCscShareRights = FALSE;
                        }

                        CscDiscardSid(&SidContext);
                    }
                }
            }
        }

        LeaveShadowCritRx(RxContext);

    } else {
        pNetRootEntry->NetRoot.sCscRootInfo.hShare = 0;
        pNetRootEntry->NetRoot.sCscRootInfo.hRootDir = 0;
        pNetRootEntry->NetRoot.sCscRootInfo.Flags = 0;
        Status = STATUS_SUCCESS;
    }

    return  Status;
}

#ifndef MRXSMB_BUILD_FOR_CSC_DCON
VOID
MRxSmbCscFillWithoutNamesFind32FromFcb (
      IN  PMINIMAL_CSC_SMBFCB MinimalCscSmbFcb,
      OUT _WIN32_FIND_DATA  *Find32
      )
/*++

Routine Description:

   This routine copies the nonname stuff from the fcb to the find32.

Arguments:

    Fcb
    Find32

Return Value:

    none

Notes:


--*/
{
    PFCB wrapperFcb = (PFCB)(MinimalCscSmbFcb->ContainingFcb);
    if (wrapperFcb==NULL) {
        return;
    }
    Find32->dwFileAttributes = wrapperFcb->Attributes;   //&~FILE_ATTRIBUTE_NORMAL??
    COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32->ftLastWriteTime,
                    wrapperFcb->LastWriteTime);
    //COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32->ftChangeTime,
    //                                    wrapperFcb->LastChangeTime);
    COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32->ftCreationTime,
                    wrapperFcb->CreationTime);
    COPY_LARGEINTEGER_TO_STRUCTFILETIME(Find32->ftLastAccessTime,
                    wrapperFcb->LastAccessTime);
    Find32->nFileSizeHigh = wrapperFcb->Header.FileSize.HighPart;
    Find32->nFileSizeLow  = wrapperFcb->Header.FileSize.LowPart;
}
#endif //#ifndef MRXSMB_BUILD_FOR_CSC_DCON

NTSTATUS
MRxSmbCscGetFileInfoForCshadow(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

    This is the start routine that basically continues the implementation
    of MRxSmbGetFileInfoFromServer within the exchange initiation.

Arguments:


Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));
    Status = MRxSmbCscGetFileInfoFromServerWithinExchange (
         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
         NULL); //NULL means the name is already in the exchange
    return(Status);
}

NTSTATUS
MRxSmbGetFileInfoFromServer (
    IN  OUT PRX_CONTEXT     RxContext,
    IN  PUNICODE_STRING     FullFileName,
    OUT _WIN32_FIND_DATA    *Find32,
    IN  PMRX_SRV_OPEN       pSrvOpen,
    OUT BOOLEAN             *lpfIsRoot
    )
/*++

Routine Description:

   This routine goes to the server to get a both_directory_info for
   the file mentioned. Here, we have no exchange so we have to get
   one. the underlying machinery for this leaves the pointer in the
   exchange structure. We can then copy it out into the Find32 passed
   in here.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);
    RxCaptureFcb; RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = NULL;
    PMRX_SMB_SRV_OPEN smbSrvOpen = NULL;
    PMRX_V_NET_ROOT VNetRootToUse = NULL;
    PSMBCE_V_NET_ROOT_CONTEXT   pVNetRootContext = NULL;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;
    BOOLEAN FinalizationComplete;
    UNICODE_STRING uniRealName;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbGetFileInfoFromServer\n", 0 ));

    if (pSrvOpen)
    {
        SrvOpen = pSrvOpen;
    }
    else
    {
        SrvOpen = capFobx->pSrvOpen;
    }

    if (lpfIsRoot)
    {
        *lpfIsRoot = FALSE;
    }

    smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    VNetRootToUse = SrvOpen->pVNetRoot;
    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(VNetRootToUse);

    ASSERT( NodeType(SrvOpen) == RDBSS_NTC_SRVOPEN );

    Status = SmbPseCreateOrdinaryExchange(
               RxContext,
               SrvOpen->pVNetRoot,
               SMBPSE_OE_FROM_GETFILEINFOFORCSHADOW,
               MRxSmbCscGetFileInfoForCshadow,
               &OrdinaryExchange);

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        return Status;
    }

    if (smbFcb->uniDfsPrefix.Buffer)
    {
        UNICODE_STRING  DfsName;

        if((Status = CscDfsDoDfsNameMapping(&smbFcb->uniDfsPrefix,
                               &smbFcb->uniActualPrefix,
                               FullFileName,
                               FALSE, // fDFSNameToResolvedName
                               &uniRealName
                               )) != STATUS_SUCCESS)
        {
            RxDbgTrace(-1, Dbg, ("Couldn't map DFS name to real name!\n"));
            return Status;
        }

//        DbgPrint("MrxSmbCscgetFileInfoFromServer: %wZ, real name %wZ\n",FullFileName, &uniRealName);
        // if this is a root, then fixup the filename
        if ((uniRealName.Length == 0) ||
            ((uniRealName.Length == 2)&&(*uniRealName.Buffer == L'\\')))
        {
            if (lpfIsRoot)
            {
                *lpfIsRoot = TRUE;
            }
        }
    }
    else
    {
        uniRealName = *FullFileName;
    }

    OrdinaryExchange->pPathArgument1 = &uniRealName;

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status!=RX_MAP_STATUS(PENDING));

    if (Status == STATUS_SUCCESS) {

        RtlCopyMemory(Find32, OrdinaryExchange->Find32WithinSmbbuf,sizeof(*Find32));

    }

    FinalizationComplete = SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
    ASSERT(FinalizationComplete);

    if (smbFcb->uniDfsPrefix.Buffer){
        RxFreePool(uniRealName.Buffer);
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbGetFileInfoFromServer  exit with status=%08lx\n", Status ));
    return(Status);

}

BOOLEAN
MRxSmbCscIsFatNameValid (
    IN PUNICODE_STRING FileName,
    IN BOOLEAN WildCardsPermissible
    )

/*++

Routine Description:

    This routine checks if the specified file name is conformant to the
    Fat 8.3 file naming rules.

Arguments:

    FileName - Supplies the name to check.

    WildCardsPermissible - Tells us if wild card characters are ok.

Return Value:

    BOOLEAN - TRUE if the name is valid, FALSE otherwise.

Notes:

    i just lifted this routine from ntfs (jll-7-30-97)


--*/

{
    BOOLEAN Results;
    STRING DbcsName;
    USHORT i;
    CHAR Buffer[24];
    WCHAR wc;
    BOOLEAN AllowExtendedChars = TRUE;

    PAGED_CODE();

    //
    //  If the name is more than 24 bytes then it can't be a valid Fat name.
    //

    if (FileName->Length > 24) {

        return FALSE;
    }

    //
    //  We will do some extra checking ourselves because we really want to be
    //  fairly restrictive of what an 8.3 name contains.  That way
    //  we will then generate an 8.3 name for some nomially valid 8.3
    //  names (e.g., names that contain DBCS characters).  The extra characters
    //  we'll filter off are those characters less than and equal to the space
    //  character and those beyond lowercase z.
    //

    if (AllowExtendedChars) {

        for (i = 0; i < FileName->Length / sizeof( WCHAR ); i += 1) {

            wc = FileName->Buffer[i];

            if ((wc <= 0x0020) || (wc == 0x007c)) { return FALSE; }
        }

    } else {

        for (i = 0; i < FileName->Length / sizeof( WCHAR ); i += 1) {

            wc = FileName->Buffer[i];

            if ((wc <= 0x0020) || (wc >= 0x007f) || (wc == 0x007c)) { return FALSE; }
        }
    }

    //
    //  The characters match up okay so now build up the dbcs string to call
    //  the fsrtl routine to check for legal 8.3 formation
    //

    Results = FALSE;

    DbcsName.MaximumLength = 24;
    DbcsName.Buffer = Buffer;

    if (NT_SUCCESS(RtlUnicodeStringToCountedOemString( &DbcsName, FileName, FALSE))) {

        if (FsRtlIsFatDbcsLegal( DbcsName, WildCardsPermissible, FALSE, FALSE )) {

            Results = TRUE;
        }
    }

    //
    //  And return to our caller
    //

    return Results;
}

VOID
MRxSmbCscGenerate83NameAsNeeded(
      IN     CSC_SHADOW_HANDLE   hDir,
      PWCHAR FileName,
      PWCHAR SFN
      )
/*++

Routine Description:

   This routine generates a SFN for a filename if it's not already
   an SFN.

Arguments:
    SFN - Not checking the allocated size of SFN in this function, but it 
          is always called from within core CSC. It is always pointing to 
          Find32->cAlternateFileName.

Return Value:


Notes:


--*/
{
    UNICODE_STRING FileNameU;
    WCHAR ShortNameBuffer[14];
    UNICODE_STRING ShortUnicodeName;
    GENERATE_NAME_CONTEXT Context;

    //set up for no short name
    *SFN = 0;

    RtlInitUnicodeString(&FileNameU,FileName);
    if (MRxSmbCscIsFatNameValid (&FileNameU,FALSE)) {
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscGenerate83NameAsNeeded no SFN needed for ...<%ws>\n",
            FileName));
        return;
    }

    RxDbgTrace(0, Dbg,
    ("MRxSmbCscGenerate83NameAsNeeded need SFN  for ...<%ws>\n",
        FileName));

    //  Now generate a short name.
    //

    ShortUnicodeName.Length = 0;
    ShortUnicodeName.MaximumLength = 12 * sizeof(WCHAR);
    ShortUnicodeName.Buffer = ShortNameBuffer;

    RtlZeroMemory( &Context, sizeof( GENERATE_NAME_CONTEXT ) );

    while ( TRUE ) {

        NTSTATUS Status;
        ULONG StatusOfShadowApiCall;
        CSC_SHADOW_HANDLE hNew;
        ULONG ShadowStatus;

        RtlGenerate8dot3Name( &FileNameU, TRUE, &Context, &ShortUnicodeName );

        //add the zero.....sigh......
        ShortUnicodeName.Buffer[ShortUnicodeName.Length/sizeof(WCHAR)] = 0;

        RxDbgTrace(0, Dbg,
            ("MRxSmbCscGenerate83NameAsNeeded tryinh SFN <%ws>\n",
            ShortUnicodeName.Buffer));
            //look for existing shadow by that name
        hNew = 0;
        StatusOfShadowApiCall = GetShadow(
                          hDir,   // HSHADOW  hDir,
                          ShortUnicodeName.Buffer,
                              // USHORT *lpName,
                          &hNew,  // LPHSHADOW lphShadow,
                          NULL,   // LPFIND32 lpFind32,
                          &ShadowStatus,
                              // ULONG far *lpuShadowStatus,
                          NULL    // LPOTHERINFO lpOI
                          );

        if (hNew == 0) {
            //the name was not found.....we're in business
            RtlCopyMemory(SFN,
              ShortUnicodeName.Buffer,
              ShortUnicodeName.Length+sizeof(WCHAR));

            RxDbgTrace(0, Dbg,
            ("MRxSmbCscGenerate83NameAsNeeded using SFN <%ws>\n",
                SFN));

            return;
        }
    }

}

DEBUG_ONLY_DECL(ULONG MRxSmbCscCreateShadowEarlyExits = 0;)


NTSTATUS
MRxSmbCscCreateShadowFromPath (
    IN  PUNICODE_STRING     AlreadyPrefixedName,
    IN  PCSC_ROOT_INFO      pCscRootInfo,
    OUT _WIN32_FIND_DATA   *Find32,
    OUT PBOOLEAN            Created  OPTIONAL,
    IN     ULONG               Controls,
    IN OUT PMINIMAL_CSC_SMBFCB MinimalCscSmbFcb,
    IN OUT PRX_CONTEXT         RxContext,
    IN     BOOLEAN             fDisconnected,
    OUT      ULONG               *pulInheritedHintFlags
    )
/*++

Routine Description:

   This routine walks down the current name creating/verifying shadows as it goes.

Arguments:

   AlreadyPrefixedName - the filename for which is a shadow is found/created

   pNetRootEntry - the netroot which is the base for the shadow

   Find32 - a FIND32 structure filled in with the stored info for the shadow

   Created OPT - (NULL or) a PBOOLEANset to TRUE if a new shadow is created

   Controls - some special flags controlling when shadows are created

   MinimalCscSmbFcb - the place where the shadow info is reported

   RxContext - the RDBSS context

   Disconnected - indicates the mode of operation

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status=STATUS_SUCCESS, LocalStatus;
    UNICODE_STRING PathName, ComponentName;
    PWCHAR PreviousSlash,NextSlash,Limit;
    CSC_SHADOW_HANDLE hNew;
    CSC_SHADOW_HANDLE hDir = pCscRootInfo->hRootDir;
    ULONG StatusOfShadowApiCall;
    ULONG ShadowStatus;
    BOOLEAN LastComponentInName = FALSE, fRootHintFlagsObtained=FALSE;
    ULONG DirectoryLevel, ulHintFlags=0;
    OTHERINFO sOI;          //hint/refpri data
    BOOLEAN JunkCreated;
    PSMBCEDB_SERVER_ENTRY   pServerEntry;

    //CODE.IMPROVEMENT  this is a little dangerous.....not everyone who
    //   calls this routine has an actual smbFcb. we should get some asserts
    //   going wheever we use this that it's the same as the one that
    //   we could have gotten from the RxContext.
    PMRX_SMB_FCB smbFcb = CONTAINING_RECORD(MinimalCscSmbFcb,
                        MRX_SMB_FCB,
                        MinimalCscSmbFcb);

    BEGIN_TIMING(MRxSmbCscCreateShadowFromPath);

    RxDbgTrace(+1, Dbg, ("MRxSmbCscCreateShadowFromPath...<%wZ> %08lx %08lx\n",
                       AlreadyPrefixedName,hDir,Controls));

    DbgDoit(ASSERT(vfInShadowCrit));

    ASSERT(hDir);

    if (Created == NULL) {
        Created = &JunkCreated;
    }
    *Created = FALSE;

    PathName = *AlreadyPrefixedName;

    // Fix for Bug# 554061 CSC should not handle loopback
    if(RxContext->pRelevantSrvOpen) {

        pServerEntry  = SmbCeGetAssociatedServerEntry(RxContext->pRelevantSrvOpen->pVNetRoot->pNetRoot->pSrvCall);
    }
    else {
        //  RxContext->pRelevantSrvOpen is NULL only in the case of a tree connect 
        // to a directory on a disconnected server.
        ASSERT(RxContext->MajorFunction == IRP_MJ_CREATE);
        ASSERT(RxContext->Create.ThisIsATreeConnectOpen);
        pServerEntry = SmbCeGetAssociatedServerEntry(RxContext->Create.pSrvCall);
    }
    
    if(pServerEntry->Server.IsLoopBack)
    {
        Status =  STATUS_UNSUCCESSFUL;
        goto bailout;
    }

    if (FlagOn(Controls, CREATESHADOW_CONTROL_STRIP_SHARE_NAME))
    {
        ASSERT(!fDisconnected);

        if(CscDfsStripLeadingServerShare(&PathName) != STATUS_SUCCESS)
        {
            return Status;
        }
    }

    Limit = (PWCHAR)(((PBYTE)PathName.Buffer)+ PathName.Length);

    // strip out trailing 0s and slash
    if (PathName.Length > 2)
    {
        while ((*(Limit-1)==0)||(*(Limit-1)=='\\'))
        {
            --Limit;
            PathName.Length -= 2;
            ASSERT((*Limit == 0) || (*Limit == '\\'));
            if (Limit == PathName.Buffer)
            {
                ASSERT(FALSE);
                break;
            }
        }
    }

    PreviousSlash = PathName.Buffer;

    // in connected mode apply the character exclusion list + filetype exclusion list
    // in disconnected mode only apply the character exclusion list

    MinimalCscSmbFcb->fDoBitCopy = FALSE;
    
    if (CheckForBandwidthConservation(PathName.Buffer,                    // name
                                PathName.Length/sizeof(USHORT)))     // size in bytes
    {
        MinimalCscSmbFcb->fDoBitCopy = TRUE;
        HookKdPrint(BITCOPY, ("Bitcopy enabled for %wZ \n", &PathName));
    }
    else if (ExcludeFromCreateShadow(PathName.Buffer,                    // name
                                PathName.Length/sizeof(USHORT),     // size in bytes
                                (fDisconnected==0)))                // Check filetype Exclusion List
    {
        Controls |= CREATESHADOW_CONTROL_NOCREATE;
    }
    


    if ((PathName.Length == 0) ||
    ((PathName.Length == 2) &&
     (*PreviousSlash == OBJ_NAME_PATH_SEPARATOR))) {
        //in disconnected mode, we have to handle opening the root dir
        RxDbgTrace(0,
            Dbg,
            ("MRxSmbCscCreateShadowFromPath basdir ret/handles...<%08lx>\n",
             hDir));

        //fill in the stuff that we have.....
        MinimalCscSmbFcb->hParentDir = 0;
        MinimalCscSmbFcb->hShadow = hDir;
        MinimalCscSmbFcb->LastComponentOffset = 0;
        MinimalCscSmbFcb->LastComponentLength = 0;

        if (!FlagOn(Controls,CREATESHADOW_CONTROL_NOREVERSELOOKUP)
            && (smbFcb->ShadowReverseTranslationLinks.Flink == 0)) {
            ValidateSmbFcbList();
            smbFcb->ContainingFcb->fMiniInited = TRUE;
            MRxSmbCscAddReverseFcbTranslation(smbFcb);
        }

        //fill in a vacuous find32structure
        RtlZeroMemory(Find32,sizeof(_WIN32_FIND_DATA));
        Find32->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;


        //make sure that we avoid the loop below
        PreviousSlash = Limit;
        //we're outta here......
    }

    // stop the guy if he doesn't have access
    if (FlagOn(Controls,CREATESHADOW_CONTROL_DO_SHARE_ACCESS_CHECK))
    {
        ASSERT(fDisconnected);

        if(!CscAccessCheck(
                        0,
                        hDir,
                        RxContext,
                        RxContext->Create.NtCreateParameters.DesiredAccess,
                        NULL,
                        NULL
                        ))
        {
            Status = STATUS_ACCESS_DENIED;
            HookKdPrint(BADERRORS, ("CSFP: Access Check failed on root directory %x", hDir));
            goto bailout;
        }
    }

    for (DirectoryLevel=1;;DirectoryLevel++) {
        BOOLEAN UsingExistingShadow;

        if (PreviousSlash >= Limit) {
            break;
        }

        NextSlash = PreviousSlash + 1;

        for (;;NextSlash++) {
            if (NextSlash >= Limit) {
                LastComponentInName = TRUE;
                break;
            }
            if (*NextSlash == OBJ_NAME_PATH_SEPARATOR) {

                // assert that we don't have a trailing slash at the end
                ASSERT((NextSlash+1) < Limit);

                break;
            }
        }

        ComponentName.Buffer = PreviousSlash+1;
        ComponentName.Length =
            (USHORT)(((PBYTE)(NextSlash)) - ((PBYTE)ComponentName.Buffer));

        PreviousSlash = NextSlash;

        RtlZeroMemory(Find32,sizeof(_WIN32_FIND_DATA));
        RtlCopyMemory(&Find32->cFileName[0],
                  ComponentName.Buffer,
                  ComponentName.Length);

        //lastcomponentname stuff for connected has been moved below.....


        RxDbgTrace(0, Dbg,
            ("MRxSmbCscCreateShadowFromPath name from find32 for GetShadow...<%ws>\n",
            &Find32->cFileName[0]));

        hNew = 0;

        UsingExistingShadow = FALSE;

        ASSERT(Find32->cFileName[0]);

        StatusOfShadowApiCall = GetShadow(
                        hDir,                   // HSHADOW  hDir,
                        &Find32->cFileName[0],  // USHORT *lpName,
                          &hNew,                // LPHSHADOW lphShadow,
                          Find32,               // LPFIND32 lpFind32,
                          &ShadowStatus,        // ULONG far *lpuShadowStatus,
                          &sOI                  // LPOTHERINFO lpOI
                          );

        if (StatusOfShadowApiCall != SRET_OK) {
            //no need to fail the open but we get no shadow info
            break;
        }

        if (hNew) {
            // accumulate pin inheritance flags
            ulHintFlags |= (sOI.ulHintFlags & FLAG_CSC_HINT_INHERIT_MASK);
        }

        //we will have to do something about it if a directory turns
        // a file or viceversa for connected

        if (hNew==0) {
            LPOTHERINFO lpOI=NULL;
            UNICODE_STRING ComponentPath;

            if (FlagOn(Controls,CREATESHADOW_CONTROL_NOCREATE)) {
                //if no creates...we're outta here.......
                if (FALSE) {
                    DbgDoit({
                        if ( ((MRxSmbCscCreateShadowEarlyExits++)&0x7f) == 0x7f ) {
                            RxLog(("Csc EarlyExit no create %d\n",
                               MRxSmbCscCreateShadowEarlyExits));
                        }
                    })
                }
                break;
            }

            if (LastComponentInName && FlagOn(Controls,CREATESHADOW_CONTROL_NOCREATELEAF)) {
                //if no creates...we're outta here.......but we still need to set what
                //would be the hParentDir......and the name offsets
                RxDbgTrace(0, Dbg, ("MRxSmbCscCreateShadowFromPath noleaf ret/handles..."
                                "<%08lx><%08lx><%08lx>\n",
                            StatusOfShadowApiCall,hDir,hNew));
                MinimalCscSmbFcb->hParentDir = hDir;
                MinimalCscSmbFcb->LastComponentOffset = (USHORT)(ComponentName.Buffer - AlreadyPrefixedName->Buffer);
                MinimalCscSmbFcb->LastComponentLength = ComponentName.Length;
                break;
            }

            if (!LastComponentInName && FlagOn(Controls,CREATESHADOW_CONTROL_NOCREATENONLEAF)) {
                RxDbgTrace(0, Dbg, ("MRxSmbCscCreateShadowFromPath nocreatenonleaf ret/handles..."
                                "<%08lx><%08lx><%08lx>\n",
                            StatusOfShadowApiCall,hDir,hNew));
                break;
            }

            ASSERT(RxContext!=NULL);

            ShadowStatus = 0;
            if (!fDisconnected){      //ok for dcon   start of big dcon blob 1
                BOOLEAN fIsRoot = FALSE;
                BEGIN_TIMING(MRxSmbGetFileInfoFromServer);

                ComponentPath.Buffer = PathName.Buffer;
                ComponentPath.Length =
                           (USHORT)(((PBYTE)(NextSlash)) - ((PBYTE)ComponentPath.Buffer));
                LeaveShadowCritRx(RxContext);
                Status = MRxSmbGetFileInfoFromServer(RxContext,&ComponentPath,Find32, NULL, &fIsRoot);
                EnterShadowCritRx(RxContext);

                END_TIMING(MRxSmbGetFileInfoFromServer);
                if (Status != STATUS_SUCCESS)
                {
                    // if this is a DFS path and we couldn't reverse map, it
                    // just create a directory or file with fake info and mark it as stale
                    if (smbFcb->uniDfsPrefix.Buffer && (Status == STATUS_NO_SUCH_FILE))
                    {
                        ShadowStatus |= SHADOW_STALE;
                        CreateFakeFind32(hDir, Find32, RxContext, LastComponentInName);
                        HookKdPrint(NAME, ("Fake win32 for DFS share %ls\n", Find32->cFileName));
                        Status = STATUS_SUCCESS;
                    }
                    else
                    {
                        HookKdPrint(BADERRORS, (" MRxSmbGetFileInfoFromServer failed %ls Status=%x\n", Find32->cFileName, Status));
                        // we change the STATUS_RETRY to something worse. STATUS_RETRY is used
                        if (Status == STATUS_RETRY)
                        {
                            Status = STATUS_UNSUCCESSFUL;
                        }
                        break;
                    }
                }
                else
                {
                    // in case of DFS, this could be a root, in which case the naem we get back won't be
                    // correct. Restore it to the original name
                    if (smbFcb->uniDfsPrefix.Buffer && fIsRoot)
                    {
                        ShadowStatus |= SHADOW_STALE;

                        RtlCopyMemory(&Find32->cFileName[0],
                                  ComponentName.Buffer,
                                  ComponentName.Length);

                        Find32->cFileName[ComponentName.Length/sizeof(USHORT)] = 0;

                        MRxSmbCscGenerate83NameAsNeeded(hDir,
                                        &Find32->cFileName[0],
                                        &Find32->cAlternateFileName[0]);
                    }
                }

            } else {
                ShadowStatus = SHADOW_LOCALLY_CREATED;
                //CODE.IMPROVEMENT...should we check for 0-length as well
                RxDbgTrace(0, Dbg,
                    ("MRxSmbCscCreateShadowFromPath setting to locallycreated...<%ws>\n",
                    &Find32->cFileName[0],ShadowStatus));
                CreateFakeFind32(hDir, Find32, RxContext, LastComponentInName);
            }

            if (!LastComponentInName ||
                FlagOn(Controls,CREATESHADOW_CONTROL_SPARSECREATE) ||
                FlagOn(Find32->dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)  ) {

                ShadowStatus |= SHADOW_SPARSE;
                //CODE.IMPROVEMENT...should we check for 0-length as well
                RxDbgTrace(0, Dbg,
                    ("MRxSmbCscCreateShadowFromPath setting to sparse...<%ws>\n",
                &Find32->cFileName[0],ShadowStatus));
            }

            // check for pin flag inheritance when creating anything

            if(!fRootHintFlagsObtained) {
                StatusOfShadowApiCall = GetShadowInfo(
                            0,
                            pCscRootInfo->hRootDir,
                            NULL,
                            NULL,
                            &sOI
                            );

                if(StatusOfShadowApiCall != SRET_OK) {
                    break;
                }

                fRootHintFlagsObtained = TRUE;

                // or the inheritance bits
                ulHintFlags |= (sOI.ulHintFlags & FLAG_CSC_HINT_INHERIT_MASK);

            }

            // If there is any tunnelling info then use it to create this guy
            if (RetrieveTunnelInfo(
                hDir,
                &Find32->cFileName[0],    // potential SFN  OK for red/yellow
                (fDisconnected)?Find32:NULL,    // get LFN only when disconnected
                &sOI)) {
                lpOI = &sOI;
            }

            // are we supposed to do any inheritance?
            if (ulHintFlags & (FLAG_CSC_HINT_INHERIT_MASK)) {
                if (!lpOI) {
                    InitOtherInfo(&sOI);
                    lpOI = &sOI;
                    lpOI->ulHintFlags = 0;
                }

                if (ulHintFlags & FLAG_CSC_HINT_PIN_INHERIT_USER) {
                    lpOI->ulHintFlags |= FLAG_CSC_HINT_PIN_USER;
                }

                if (ulHintFlags & FLAG_CSC_HINT_PIN_INHERIT_SYSTEM) {
                    lpOI->ulHintFlags |= FLAG_CSC_HINT_PIN_SYSTEM;
                }
            }

            // if this is a file on which special heuristic needs to be applied
            // and none of it's parents have system pin inheritance bit set
            // then we do not create the file.
            // Thus on remoteboot shares, we will create entries for these files
            // even if they are opend without the execute flag set.
            // This takes care of the upgrade NT50 to an RB machine scenario

            if ((Controls & CREATESHADOW_CONTROL_FILE_WITH_HEURISTIC)&&
                !(ulHintFlags & FLAG_CSC_HINT_PIN_INHERIT_SYSTEM))
            {
                break;
            }

#if defined(REMOTE_BOOT)
            //
            // In the remote boot case, there was an extra PVOID lpContext
            // parameter to CreateShadowInternal, to which we passed a pointer
            // to a structure. The structure held the cp value (NT_CREATE_PARAMETERS)
            // from &RxContext->Create.NtCreateParameters and the address of
            // a local NTSTATUS value. Eventually this caused the underlying
            // call to IoCreateFile to be done while impersonating the current
            // user, and the status from IoCreateFile was readable upon
            // return from the local value.
            //
#endif

            StatusOfShadowApiCall = CreateShadowInternal (
                        hDir,        // HSHADOW  hDir,
                        Find32,      // LPFIND32 lpFind32,
                        ShadowStatus,// ULONG uFlags,
                        lpOI,        // LPOTHERINFO lpOI,
                        &hNew        // LPHSHADOW  lphNew
                        );

            HookKdPrint(NAME, ("Create %ws in hDir=%x, hShadow=%x Status=%x StatusOfShadowApiCall=%x\n\n", Find32->cFileName, hDir, hNew, ShadowStatus, StatusOfShadowApiCall));

            if (StatusOfShadowApiCall != SRET_OK) {
                RxDbgTrace(0, Dbg,
                    ("MRxSmbCscCreateShadowFromPath createshadowinternal failed!!!...<%ws>\n",
                    &Find32->cFileName[0],ShadowStatus));
                break; //no need to fail the open but we get no shadow info
            }

            *Created = LastComponentInName;

            RxLog(("Created %ws in hDir=%x, hShadow=%x Status=%x\n\n", Find32->cFileName, hDir, hNew, ShadowStatus));

        } else {

            RxDbgTrace(0,Dbg,
            ("MRxSmbCscCreateShadowFromPath name from getsh <%ws>\n",
                &Find32->cFileName[0]));

            if (!fDisconnected) // nothing in connected mode
            {
                // Check if this file should be invisible in connected state
                // We won't want to do this for VDO

                if( (!(Find32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) &&
                    mShadowNeedReint(ShadowStatus))
                {
                    HookKdPrint(BADERRORS, ("File needs merge %x %x Stts=%x %ls\n", hDir, hNew, ShadowStatus, Find32->cFileName));
                    Status = STATUS_ACCESS_DENIED;
                    break;
                }
            }
            else        // lots in disconnected mode
            {
                if (LastComponentInName && (FlagOn(Controls,CREATESHADOW_CONTROL_NOCREATELEAF)||
                                            FlagOn(Controls,CREATESHADOW_CONTROL_NOCREATE)))
                {
                    // if this is the last component and we are not supposed to
                    // create it then skip it.
                }
                else
                {
                    // If it is marked deleted then it is time to recreate it
                    if (mShadowDeleted(ShadowStatus))
                    {
                        PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

                        // Check for a type change from a deleted filename
                        // to a directory name; the other way around is not possible
                        // in our scheme where shadowed directories are not deletable

                        // just bailout
                        if(((IsFile(Find32->dwFileAttributes) != 0) // pre type
                                    != ((LastComponentInName && !FlagOn(cp->CreateOptions,FILE_DIRECTORY_FILE))!=0)))
                        {
                            RxLog(("MRxSmbCscCreateShadowFromPath: type change, failing\n"));
                            HookKdPrint(BADERRORS, ("MRxSmbCscCreateShadowFromPath: type change, failing\n"));
                            Status = STATUS_ACCESS_DENIED;
                            break;
                        }

                        KeQuerySystemTime(((PLARGE_INTEGER)(&Find32->ftCreationTime)));
                        Find32->ftLastAccessTime = Find32->ftLastWriteTime = Find32->ftCreationTime;
                        //already zero Find32->nFileSizeHigh = Find32->nFileSizeLow = 0;

                        ShadowStatus = SHADOW_DIRTY|SHADOW_TIME_CHANGE|SHADOW_ATTRIB_CHANGE|SHADOW_REUSED;

                        // Update the shadow info without changing the version stamp

                        if(SetShadowInfo(hDir, hNew, Find32, ShadowStatus,
                         SHADOW_FLAGS_ASSIGN|SHADOW_FLAGS_DONT_UPDATE_ORGTIME
                          ) < SRET_OK)
                        {
                            hNew = 0;
                            break;
                        }
                        // set created flag to true. Based on the Recreated bit, we will know whether
                        // this entry was resurrected or not
                        *Created = TRUE;

                    }
                    else if (IsFile(Find32->dwFileAttributes) && (mShadowSparse(ShadowStatus)))
                    {
                        ShadowStatus = SHADOW_DIRTY|SHADOW_TIME_CHANGE|SHADOW_ATTRIB_CHANGE|SHADOW_REUSED;

                        Find32->ftLastAccessTime = Find32->ftLastWriteTime = Find32->ftCreationTime;
                        Find32->nFileSizeHigh = Find32->nFileSizeLow = 0;

                        if ((TruncateDataHSHADOW(hDir, hNew)>=SRET_OK)&&
                            (SetShadowInfo(hDir, hNew, Find32, ShadowStatus,SHADOW_FLAGS_ASSIGN)>=SRET_OK))
                        {
                            // set created flag to true. Based on the Recreated bit, we will know whether
                            // this entry was resurrected or not
                            *Created = TRUE;

                        }
                        else
                        {
                            Status = STATUS_UNSUCCESSFUL;
                            hNew = 0;
                            break;

                        }
                    }
                }
            }
        }

        if (LastComponentInName && (hNew!=0)) {
            LONG nFileSizeLow, nFileSizeHigh;

            // if we are here from the createepilogue then we need to see whether there is an
            // FCB floating around for this name that has a delete_on_close issued on one of the fobxs
            // and is ready for purge. If it isn't ready for purging, ie. there are some
            // outstanding opens on it then this current create is an invalid operation

            if(FlagOn(Controls,CREATESHADOW_CONTROL_FAIL_IF_MARKED_FOR_DELETION))
            {
                PMRX_SMB_FCB pSmbFcb = MRxSmbCscRecoverMrxFcbFromFdb(MRxSmbCscFindFdbFromHShadow(hNew));


                if (pSmbFcb && (pSmbFcb->LocalFlags & FLAG_FDB_DELETE_ON_CLOSE))
                {
                    RxCaptureFcb;
                    RxLog(("delonclose FCB=%x\n", pSmbFcb));
                    RxLog(("prgrelfobx \n"));
                    LeaveShadowCritRx(RxContext);
                    RxScavengeFobxsForNetRoot((PNET_ROOT)(capFcb->pNetRoot),(PFCB)capFcb);
                    EnterShadowCritRx(RxContext);
                    if (MRxSmbCscFindFdbFromHShadow(hNew))
                    {
                        RxLog(("ACCESS_DENIED FCB=%x \n", capFcb));
                        HookKdPrint(BADERRORS, ("ACCESS_DENIED FCB=%x \n", capFcb));
                        Status = STATUS_ACCESS_DENIED;
                        break;
                    }

                    // we potentially have an inode which has been deleted
                    // let us try to get the inode again

                    RxLog(("purged relfobx \n"));
                    Status = STATUS_RETRY;
                    hNew = 0;
                    break;
                }
            }
            if (hNew!=0) {
                // When any local changes are made ensure that the share in the
                // CSC database is marked dirty if it has not been prevoiously
                // marked. This facilitates the easy detection of changes for
                // reintegration by the agent.

                if (ShadowStatus &  SHADOW_MODFLAGS) {
                    MarkShareDirty(&pCscRootInfo->ShareStatus, (ULONG)(pCscRootInfo->hShare));
                }

                //okay, lets remember this in the fcb
                smbFcb->hParentDir = hDir;
                smbFcb->hShadow = hNew;
                smbFcb->ShadowStatus = (USHORT)ShadowStatus;

                    //it's excellent if we can find the last component again...fast
                smbFcb->LastComponentOffset = (USHORT)(ComponentName.Buffer -
                                  AlreadyPrefixedName->Buffer);
                smbFcb->LastComponentLength = ComponentName.Length;

                if (!FlagOn(Controls,CREATESHADOW_CONTROL_NOREVERSELOOKUP)
                      && (smbFcb->ShadowReverseTranslationLinks.Flink == 0)) {
                    ValidateSmbFcbList();
                    smbFcb->ContainingFcb->fMiniInited = TRUE;
                    MRxSmbCscAddReverseFcbTranslation(smbFcb);
                    smbFcb->OriginalShadowSize.LowPart = Find32->nFileSizeLow;
                    smbFcb->OriginalShadowSize.HighPart = Find32->nFileSizeHigh;
                }

                // Initialize the serialization mechanism used for reads/writes
                ExInitializeFastMutex(&smbFcb->CscShadowReadWriteMutex);
            }

        }

        RxDbgTrace(0, Dbg, ("MRxSmbCscCreateShadowFromPath ret/handles...<%08lx><%08lx><%08lx><%08lx>\n",
                        StatusOfShadowApiCall,hDir,hNew));

        hDir = hNew;
    }

    if (pulInheritedHintFlags)
    {
        *pulInheritedHintFlags = ulHintFlags;
    }
bailout:
    RxDbgTrace(-1, Dbg, ("MRxSmbCscCreateShadowFromPath -> %08lx\n", Status ));

    END_TIMING(MRxSmbCscCreateShadowFromPath);
    return Status;
}

//CODE.IMPROVEMENT this routine should be in cshadow.c in the record
//    manager.....but it's in hook.c for the shadow VxD so maybe hookcmmn.c
int RefreshShadow( HSHADOW  hDir,
   IN HSHADOW  hShadow,
   IN LPFIND32 lpFind32,
   OUT ULONG *lpuShadowStatus
   )
/*++

Routine Description:

    This routine, checks whether the local copy is current or not. If it isn't then it
    stamps the local copy as being stale.

Arguments:

    hShadow     Inode representing the local copy

    lpFind32    The new find32 info as obtained from the Share

    lpuShadowStatus Returns the new status of the inode

Return Value:

    Success if >= 0, failed other wise

Notes:


--*/
{
   int iRet = -1;
   int iLocalRet;
   ULONG uShadowStatus;

   // ACHTUNG never called in disconnected state

   RxLog(("Refresh %x \n", hShadow));

   if (ChkUpdtStatusHSHADOW(hDir, hShadow, lpFind32, &uShadowStatus) < 0)
   {
      goto bailout;
   }
   if (uShadowStatus & SHADOW_STALE)
   {
        long nFileSizeHigh, nFileSizeLow;

        if (uShadowStatus & SHADOW_DIRTY)
        {
            KdPrint(("RefreshShadow: conflict on  %x\r\n", hShadow));
            iRet = -2;
            goto bailout;// conflict
        }
//        DbgPrint("Tuncating %ws %x \n", lpFind32->cFileName, hShadow);
        // Truncate the data to 0, this also adjusts the shadow space usage
        TruncateDataHSHADOW(hDir, hShadow);
        // Set status flags to indicate sparse file
        uShadowStatus = SHADOW_SPARSE;

        // ACHTUNG!!! We know we are connected,
        //            hence we don't use SHADOW_FLAG_DONT_UPDATE_ORGTIME
          iLocalRet = SetShadowInfo(hDir,
                    hShadow,
                    lpFind32,
                    uShadowStatus,
                    SHADOW_FLAGS_ASSIGN
                    );
        if (iLocalRet < SRET_OK)
        {
            goto bailout;
        }
#ifdef MAYBE
      MakeSpace(lpFind32->nFileSizeHigh, lpFind32->nFileSizeLow);
#endif //MAYBE
//      AllocShadowSpace(lpFind32->nFileSizeHigh, lpFind32->nFileSizeLow, TRUE);
        iRet = 1;
    }
    else
    {
        iRet = 0;
    }

    *lpuShadowStatus = uShadowStatus;

bailout:

   return (iRet);
}


BOOLEAN
MRxSmbCscIsThisACopyChunkOpen (
    IN PRX_CONTEXT RxContext,
    BOOLEAN   *lpfAgent
    )
/*++

Routine Description:

   This routine determines if the open described by the RxContext is
   a open-with-chunk intent.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    BOOLEAN IsChunkOpen = FALSE;

    RxCaptureFcb;
    PNT_CREATE_PARAMETERS CreateParameters = &RxContext->Create.NtCreateParameters;

    if ((CreateParameters->DesiredAccess == (FILE_READ_ATTRIBUTES | SYNCHRONIZE)) &&
    (CreateParameters->Disposition == FILE_OPEN) &&
    (CreateParameters->AllocationSize.HighPart ==
        MRxSmbSpecialCopyChunkAllocationSizeMarker)) {
        IsChunkOpen = (TRUE);
        if (lpfAgent)
        {
            *lpfAgent =  (CreateParameters->AllocationSize.LowPart != 0);
        }
    }

    return IsChunkOpen;
}


NTSTATUS
SmbPseExchangeStart_CloseCopyChunk(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the start routine for close.

Arguments:

    pExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB      smbFcb  = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    NODE_TYPE_CODE TypeOfOpen = NodeType(capFcb);
    PSMBCEDB_SERVER_ENTRY pServerEntry= SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_CloseCopyChunk %08lx\n", RxContext ));

    ASSERT(OrdinaryExchange->Type == ORDINARY_EXCHANGE);

    MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,'FC'));

    Status = MRxSmbBuildClose(StufferState);

    if (Status == STATUS_SUCCESS) {

        // Ensure that the Fid is validated....
        SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

        Status = SmbPseOrdinaryExchange(
                SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                SMBPSE_OETYPE_CLOSE
                );
        // Ensure that the Fid validation is disabled
        ClearFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);
        ASSERT (!FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_WRITE_ONLY_HANDLE));
    }

    //even if it didn't work there's nothing i can do......keep going
    SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);

    MRxSmbDecrementSrvOpenCount(pServerEntry,smbSrvOpen->Version,SrvOpen);

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_CloseCopyChunk %08lx exit w %08lx\n", RxContext, Status ));
    return Status;
}

NTSTATUS
MRxSmbCscCloseExistingThruOpen(
    IN OUT PRX_CONTEXT   RxContext
    )
/*++

Routine Description:

   This routine closes the existing copychunk thru open and marks it as not open

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING RemainingName;

    RxCaptureFcb;
    PMRX_FOBX SaveFobxFromContext = RxContext->pFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_FOBX capFobx = smbFcb->CopyChunkThruOpen;
    PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;

    PAGED_CODE();

    ASSERT ( NodeTypeIsFcb(capFcb) );

    RxDbgTrace(+1, Dbg, ("MRxSmbCscCloseExistingThruOpen %08lx %08lx %wZ\n",
        RxContext,SrvOpen,GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext) ));

    if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
        ASSERT(smbSrvOpen->hfShadow == 0);
        RxDbgTrace(-1, Dbg, ("CopyChunkOpen already closed\n"));
        return (STATUS_SUCCESS);
    }

    //briefly shanghai the capfobx field in the RxContext
    ASSERT(SaveFobxFromContext==NULL);
    RxContext->pFobx = capFobx;

    if (smbSrvOpen->hfShadow != 0){
        MRxSmbCscCloseShadowHandle(RxContext);
    }

    Status = SmbPseCreateOrdinaryExchange(
               RxContext,
               SrvOpen->pVNetRoot,
               SMBPSE_OE_FROM_CLOSECOPYCHUNKSRVCALL,
               SmbPseExchangeStart_CloseCopyChunk,
               &OrdinaryExchange);

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
        RxContext->pFobx = SaveFobxFromContext;
        return(Status);
    }

    Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);

    ASSERT (Status != (STATUS_PENDING));

    SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);

    RxDbgTrace(-1, Dbg,
    ("MRxSmbCscCloseExistingThruOpen  exit w/ status=%08lx\n", Status ));

    RxContext->pFobx = SaveFobxFromContext;

    if (smbSrvOpen->Flags & SMB_SRVOPEN_FLAG_AGENT_COPYCHUNK_OPEN)
    {
        smbFcb->CopyChunkThruOpen = NULL;
        smbSrvOpen->Flags &= ~SMB_SRVOPEN_FLAG_AGENT_COPYCHUNK_OPEN;
    }
    RxDbgTrace(0, Dbg, ("MRxSmbCscCloseExistingThruOpen status=%x\n", Status));

    return(Status);
}

ULONG SuccessfulSurrogateOpens = 0;

NTSTATUS
MRxSmbCscCreatePrologue (
    IN OUT PRX_CONTEXT RxContext,
    OUT    SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    )
/*++

Routine Description:

    This routine performs the correct synchronization among opens. This
    synchronization required because CopyChunk-thru opens are not allowed
    to exist alongside any other kind.

    So, we first must identify copychunk opens and fixup the access,
    allocationsize, etc.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;

    RxCaptureFcb;

    PMRX_SMB_FCB      smbFcb;
    PMRX_SRV_OPEN     SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;

    PMRX_NET_ROOT             NetRoot;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    BOOLEAN               IsCopyChunkOpen, IsThisTheAgent=FALSE;
    PNT_CREATE_PARAMETERS CreateParameters;

    BOOLEAN  EnteredCriticalSection = FALSE;
    NTSTATUS AcquireStatus = STATUS_UNSUCCESSFUL;
    ULONG    AcquireOptions;
    BOOLEAN Disconnected = FALSE;
    DWORD   dwEarlyOut = 0;

    ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);

    if(!MRxSmbIsCscEnabled ||
       (fShadow == 0)) {
        return Status;
    }

    SrvOpen     = RxContext->pRelevantSrvOpen;
    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(SrvOpen->pVNetRoot);

    if (FlagOn(
        pVNetRootContext->Flags,
        SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE)) {
        RxLog(("%wZ is a an AgentInstance\n", &(pVNetRootContext->pNetRootEntry->Name)));
        HookKdPrint(AGENT, ("%wZ is a an AgentInstance\n", &(pVNetRootContext->pNetRootEntry->Name)));
        ASSERT(SrvOpen->pVNetRoot->Flags & VNETROOT_FLAG_CSCAGENT_INSTANCE);
        // DbgPrint("Skipping agent instances\n");
        return Status;
    }


    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        PDFS_NAME_CONTEXT pDfsNameContext = NULL;

        pDfsNameContext = CscIsValidDfsNameContext(RxContext->Create.NtCreateParameters.DfsNameContext);

        if (pDfsNameContext && (pDfsNameContext->NameContextType == DFS_CSCAGENT_NAME_CONTEXT))
        {
            RxLog(("%wZ is a a DFS AgentInstance\n", &(pVNetRootContext->pNetRootEntry->Name)));
            HookKdPrint(NAME, ("%wZ is a DFS AgentInstance\n", &(pVNetRootContext->pNetRootEntry->Name)));
            return Status;
        }
    }

    NetRoot = capFcb->pNetRoot;
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    pServerEntry  = SmbCeGetAssociatedServerEntry(NetRoot->pSrvCall);

    if (pNetRootEntry->NetRoot.NetRootType != NET_ROOT_DISK) {
        if (!SmbCeIsServerInDisconnectedMode(pServerEntry))
        {
            return Status;
        }
        else
        {
            return STATUS_NETWORK_UNREACHABLE;
        }
    }

    // Check with CSC whether any opens need to fail on this share
    if(hShareReint &&
        ((pNetRootEntry->NetRoot.sCscRootInfo.hShare == hShareReint)||
                    (CscDfsShareIsInReint(RxContext))))
    {
        HookKdPrint(BADERRORS, ("Share %x merging \n", hShareReint));
        return STATUS_ACCESS_DENIED;

    }

    smbFcb      = MRxSmbGetFcbExtension(capFcb);
    smbSrvOpen  = MRxSmbGetSrvOpenExtension(SrvOpen);


    CreateParameters = &RxContext->Create.NtCreateParameters;

    Disconnected = SmbCeIsServerInDisconnectedMode(pServerEntry);

    RxDbgTrace(+1, Dbg,
    ("MRxSmbCscCreatePrologue(%08lx)...%08lx\n",
        RxContext,Disconnected ));

    HookKdPrint(NAME, ("CreatePrologue: Create %wZ Disposition=%x Options=%x DCON=%d \n",
                       GET_ALREADY_PREFIXED_NAME(NULL,capFcb),
                       CreateParameters->Disposition,
                       CreateParameters->CreateOptions,
                       Disconnected));

    if (smbFcb->ContainingFcb == NULL) {
        smbFcb->ContainingFcb = capFcb;
    } else {
        ASSERT(smbFcb->ContainingFcb == capFcb);
    }

    IsCopyChunkOpen = MRxSmbCscIsThisACopyChunkOpen(RxContext, &IsThisTheAgent);

    if (IsCopyChunkOpen) {
        PLIST_ENTRY ListEntry;
        ULONG NumNonCopyChunkOpens = 0;

        HookKdPrint(NAME, ("CreatePrologue: Copychunk Open \n"));
        CreateParameters->AllocationSize.QuadPart = 0;
        CreateParameters->DesiredAccess |= FILE_READ_DATA;
        SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN);
        if (IsThisTheAgent)
        {
            HookKdPrint(NAME, ("CreatePrologue: Agent Copychunk Open \n"));
            SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_AGENT_COPYCHUNK_OPEN);
        }
        SetFlag(SrvOpen->Flags,SRVOPEN_FLAG_COLLAPSING_DISABLED);

        if (Disconnected) {
            Status = STATUS_NETWORK_UNREACHABLE;
//            RxDbgTrace(0, Dbg, ("Network Unreacheable, aborting copychunk\n"));
            dwEarlyOut = 1;
            goto FINALLY;
        }

        //check for a surrogate.....this would be studly.....

        RxLog(("Checking for surrogate\n"));

        for (   ListEntry = capFcb->SrvOpenList.Flink;
            ListEntry != &capFcb->SrvOpenList;
            ListEntry = ListEntry->Flink
            ) {
            PMRX_SRV_OPEN SurrogateSrvOpen = CONTAINING_RECORD(
                             ListEntry,
                             MRX_SRV_OPEN,
                             SrvOpenQLinks);
            PMRX_SMB_SRV_OPEN smbSurrogateSrvOpen = MRxSmbGetSrvOpenExtension(SurrogateSrvOpen);

            if (smbSurrogateSrvOpen == NULL)
                continue;

            if (smbFcb->hShadow == 0) {
            // if we don't have the shadow handle...just blow it off....
                RxLog(("No shadow handle, quitting\n"));
                break;
            }

            if (smbFcb->SurrogateSrvOpen != NULL) {
                // if we already have a surrogate, just use it....
                SurrogateSrvOpen = smbFcb->SurrogateSrvOpen;
            }

            ASSERT(SurrogateSrvOpen && NodeType(SurrogateSrvOpen) == RDBSS_NTC_SRVOPEN);
            if (FlagOn(smbSurrogateSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN)) {
                //cant surrogate on a copychunk open!
                continue;
            }

            NumNonCopyChunkOpens++;

            // if it's not open or not open successfully...cant surrogate
            if (FlagOn(smbSurrogateSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN)) {
                continue;
            }

            if (!FlagOn(smbSurrogateSrvOpen->Flags,SMB_SRVOPEN_FLAG_SUCCESSFUL_OPEN)) {
                continue;
            }

            // if it doesn't have access for read or execute, cant surrogate
            if ((SurrogateSrvOpen->DesiredAccess &
                (FILE_READ_DATA|FILE_EXECUTE)) == 0) {
                continue;
            }

            ASSERT( (smbFcb->SurrogateSrvOpen == SurrogateSrvOpen)
                  || (smbFcb->SurrogateSrvOpen == NULL));
            SetFlag(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_OPEN_SURROGATED);
            smbFcb->SurrogateSrvOpen = SurrogateSrvOpen;
            smbSrvOpen->Fid = smbSurrogateSrvOpen->Fid;
            smbSrvOpen->Version = smbSurrogateSrvOpen->Version;

            RxContext->pFobx = (PMRX_FOBX)RxCreateNetFobx(RxContext, SrvOpen);

            if (RxContext->pFobx == NULL) {
                Status = (STATUS_INSUFFICIENT_RESOURCES);
                RxDbgTrace(0, Dbg, ("Failed fobx create, aborting copychunk\n"));
                goto FINALLY;
            }

            // i thought about just using the surrogate's handle here but
            // decided against it. the surrogate's localopen may have failed
            // for some reason that no longer obtains...so i get my own
            // handle.

#if defined(BITCOPY)
            OpenFileHSHADOWAndCscBmp(
                smbFcb->hShadow,
                0,
                0,
                (CSCHFILE *)(&(smbSrvOpen->hfShadow)),
                smbFcb->fDoBitCopy,
                0,
                NULL
                );
#else
            OpenFileHSHADOW(
                smbFcb->hShadow,
                0,
                0,
                (CSCHFILE *)(&(smbSrvOpen->hfShadow))
                );
#endif // defined(BITCOPY)

            if (smbSrvOpen->hfShadow == 0) {
                Status = STATUS_UNSUCCESSFUL;
                RxLog(("Couldn't find a file to piggyback on, failing copychunk\n"));
            } else {
                SuccessfulSurrogateOpens++;
                Status = STATUS_SUCCESS;
                RxLog(("Found a file to piggyback on, succeeding copychunk\n"));
            }

            dwEarlyOut = 2;
            goto FINALLY;
        }

#if 0
        //couldn't find a surrogate.......if there are existing opens then blowoff
        //this open...the agent will come back later
#endif

        if (NumNonCopyChunkOpens>0) {
            RxLog(("CscCrPro Creating thru open when NonNumCopyChunkOpens is non-zero %d for hShadow=%x\n",
                               NumNonCopyChunkOpens, smbFcb->hShadow));

            RxDbgTrace(0, Dbg, ("MRxSmbCscCreatePrologue Creating thru open when NonNumCopyChunkOpens is non-zero %d for hShadow=%x\n",
                               NumNonCopyChunkOpens, smbFcb->hShadow));

        }
    } else {
        NTSTATUS LocalStatus;

        LocalStatus = CscInitializeServerEntryDfsRoot(
                          RxContext,
                          pServerEntry);

        if (LocalStatus != STATUS_SUCCESS) {
            Status = LocalStatus;
            goto FINALLY;
        }

        LocalStatus = MRxSmbCscLocalFileOpen(RxContext);

        if (LocalStatus == STATUS_SUCCESS)
        {
            RxLog(("LocalOpen\n"));
            Status = STATUS_SUCCESS;
            Disconnected = TRUE;    // do a fake disconnected open
        }
        else if (LocalStatus != STATUS_MORE_PROCESSING_REQUIRED)
        {
            RxLog(("LocalOpen Failed Status=%x\n", LocalStatus));
            Status = LocalStatus;
            goto FINALLY;
        }

    }

    if (IsCopyChunkOpen) {
        AcquireOptions = (Exclusive_SmbFcbAcquire |
                      DroppingFcbLock_SmbFcbAcquire |
                      FailImmediately_SmbFcbAcquire);

    } else {
        AcquireOptions = (Shared_SmbFcbAcquire |
                  DroppingFcbLock_SmbFcbAcquire);
    }

    ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

    AcquireStatus = MRxSmbCscAcquireSmbFcb(
            RxContext,
            AcquireOptions,
            SmbFcbHoldingState);

    ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

    if (AcquireStatus != STATUS_SUCCESS) {
        //we couldn't acquire.....get out
        Status = AcquireStatus;
        ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscCreatePrologue couldn't acquire!!!-> %08lx %08lx\n",
            RxContext,Status ));
        RxLog(("CSC AcquireStatus=%x\n", AcquireStatus));
        dwEarlyOut = 3;
        goto FINALLY;
    }

    ASSERT( IsCopyChunkOpen?(smbFcb->CscOutstandingReaders == -1)
               :(smbFcb->CscOutstandingReaders > 0));

    // There are two cases in which the open request can be satisfied locally.
    // Either we are in a disconnected mode of operation for this share or the
    // share has been marked for a mode of operation which calls for the
    // suppression of opens and closes ( hereafter we will refer to it as
    // (Suppress Opens Client Side Caching (SOCSC)) mode of operation to
    // distinguish it from VDO ( virtual disconnected operation ) which is
    // slated for subsequent releases of NT
    // Note that in the SOCSC mode it is likely that we do not have the
    // corresponding file cached locally. In such cases the open needs to be
    // propagated to the client, i.e., you cannot create a local file without
    // checking with the server for the existence of a file with the same name

    if (Disconnected) {
        SMBFCB_HOLDING_STATE FakeSmbFcbHoldingState = SmbFcb_NotHeld;

        RxDbgTrace(0, Dbg,
            ("MRxSmbCscCreatePrologue calling epilog directly!!!-> %08lx %08lx\n",
            RxContext,Status ));

        smbSrvOpen->Flags |= SMB_SRVOPEN_FLAG_DISCONNECTED_OPEN;

        //we pass a fake holdingstate and do the release from out finally
        MRxSmbCscCreateEpilogue(
            RxContext,
            &Status,
            &FakeSmbFcbHoldingState);

        dwEarlyOut = 4;
        goto FINALLY;
    }

    // deal with any existing thru-open

    if (smbFcb->CopyChunkThruOpen != NULL) {
        if (IsCopyChunkOpen && IsThisTheAgent){
            // here we're a thruopen and there's an existing one...
            // fail the new one....
            Status = STATUS_UNSUCCESSFUL;
            // DbgPrint("Agent being turned away while attempting fill on %x\n", smbFcb->hShadow);
            RxDbgTrace(0, Dbg,
                ("MRxSmbCscCreatePrologue failing new thru open!!!-> %08lx %08lx\n",
                RxContext,Status ));
            dwEarlyOut = 5;
                goto FINALLY;
        } else {
            // the new open if not a thru open or it is a thruopen from the agent.
            // get rid of it now
#ifdef DBG
                if (IsCopyChunkOpen)
                {
                    // This is a copychunk open by the sync manager
                    // assert that the thruopen being nuked is that of the agent

                    PMRX_SMB_SRV_OPEN psmbSrvOpenT = MRxSmbGetSrvOpenExtension(smbFcb->CopyChunkThruOpen->pSrvOpen);
//                    ASSERT(psmbSrvOpenT->Flags & SMB_SRVOPEN_FLAG_AGENT_COPYCHUNK_OPEN);
                }
#endif

            MRxSmbCscCloseExistingThruOpen(RxContext);
        }
    }

FINALLY:
    if (EnteredCriticalSection) {
        LeaveShadowCrit();
    }

    if (Status!=STATUS_MORE_PROCESSING_REQUIRED) {
        if (AcquireStatus == STATUS_SUCCESS) {
            MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
        }
        ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);
    }

    if (Disconnected) {
        // at shutdown, there can be a situation where an open comes down
        // but CSC has already been shutdown. If CSC is shutdown, return the appropriate error

        if (fShadow)
        {
            if (Status==STATUS_MORE_PROCESSING_REQUIRED)
            {
                RxDbgTrace(0, Dbg, ("MRxSmbCscCreatePrologue: STATUS_MORE_PROCESSING_REQUIRED, dwEarlyOut=%d\r\n", dwEarlyOut));
            }
            ASSERT(Status!=STATUS_MORE_PROCESSING_REQUIRED);
        }
        else
        {
            if (AcquireStatus == STATUS_SUCCESS &&
                *SmbFcbHoldingState!=SmbFcb_NotHeld) {
                MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
            }
            ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);
            Status = STATUS_NETWORK_UNREACHABLE;
        }
    }

    RxLog(("CscCrPro %x %x\n", RxContext, Status ));

    RxDbgTrace(-1, Dbg, ("MRxSmbCscCreatePrologue ->  %08lx %08lx\n",
           RxContext, Status ));

    return Status;
}

NTSTATUS
MRxSmbCscObtainShadowHandles (
    IN OUT PRX_CONTEXT       RxContext,
    IN OUT PNTSTATUS         Status,
    IN OUT _WIN32_FIND_DATA  *Find32,
    OUT    PBOOLEAN          Created,
    IN     ULONG             CreateShadowControls,
    IN     BOOLEAN           Disconnected
    )
/*++

Routine Description:

   This routine tries to obtain the shadow handles for a given fcb. If it can,
   it also will get the share handle as part of the process.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    The netroot entry may have the rootinode for the actual share or it's DFS alternate.
    If it is a root for the DFS alternate, the appropritae bit in the Flags field of the
    sCscRootInfo structure in NetRootEntry is set.

    This routine essentially manufactures the correct root inode for the incoming path
    and stuffs it in the sCscRootInfo for the smbfcb. This root indoe is used for
    all subsequent operations on this file.

--*/
{
    NTSTATUS LocalStatus;

    RxCaptureFcb;

    PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN     SrvOpen;

    PMRX_NET_ROOT           NetRoot       = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);

    CSC_SHARE_HANDLE    hShare;
    CSC_SHADOW_HANDLE   hShadow;
    CSC_ROOT_INFO   *pCscRootInfo, sCscRootInfoSav;

    BOOLEAN DisconnectedMode;

    UNICODE_STRING    ShadowPath,SharePath,ServerPath;

    PDFS_NAME_CONTEXT pDfsNameContext = NULL;
    DWORD   cntRetry = 0;
    BOOLEAN fSaved = FALSE;

    DbgDoit(ASSERT(vfInShadowCrit));

    LocalStatus = STATUS_SUCCESS;

    SrvOpen = RxContext->pRelevantSrvOpen;
    if (RxContext->MajorFunction == IRP_MJ_CREATE) {
        pDfsNameContext = CscIsValidDfsNameContext(RxContext->Create.NtCreateParameters.DfsNameContext);

        //SrvOpen = RxContext->Create.pSrvOpen;
    } else {
        RxCaptureFobx;

        if (SrvOpen)
        {
            ASSERT((SrvOpen == capFobx->pSrvOpen));
        }
    }

    if (smbFcb->ContainingFcb == NULL) {
        smbFcb->ContainingFcb = capFcb;
    } else {
        ASSERT(smbFcb->ContainingFcb == capFcb);
    }

    if (pDfsNameContext) {
        LocalStatus = CscDfsParseDfsPath(
                   &pDfsNameContext->UNCFileName,
                   &ServerPath,
                   &SharePath,
                   &ShadowPath);

        HookKdPrint(NAME, ("OSHH: DfsName %wZ %wZ\n", &SharePath, &ShadowPath));
        DisconnectedMode = FALSE;

        pCscRootInfo = &(smbFcb->sCscRootInfo);

        if (pNetRootEntry->NetRoot.sCscRootInfo.hShare)
        {
            sCscRootInfoSav = pNetRootEntry->NetRoot.sCscRootInfo;
            fSaved = TRUE;
        }

        // clear this so ObtainSharehandles is forced to obtain them
        memset( &(pNetRootEntry->NetRoot.sCscRootInfo),
                0,
                sizeof(pNetRootEntry->NetRoot.sCscRootInfo));

    } else {
        PSMBCEDB_SERVER_ENTRY pServerEntry;
        pServerEntry  = SmbCeGetAssociatedServerEntry(NetRoot->pSrvCall);

        DisconnectedMode = SmbCeIsServerInDisconnectedMode(pServerEntry);

        SharePath  = *(NetRoot->pNetRootName);
        ShadowPath = *GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
        HookKdPrint(NAME, ("OSHH: NormalName %wZ %wZ\n", &SharePath, &ShadowPath));

        if (pNetRootEntry->NetRoot.sCscRootInfo.Flags & CSC_ROOT_INFO_FLAG_DFS_ROOT)

        {
//            ASSERT(pNetRootEntry->NetRoot.sCscRootInfo.hShare);
            sCscRootInfoSav = pNetRootEntry->NetRoot.sCscRootInfo;
            fSaved = TRUE;
            // clear this so ObtainSharehandles is forced to obtain them
            memset( &(pNetRootEntry->NetRoot.sCscRootInfo),
                    0,
                    sizeof(pNetRootEntry->NetRoot.sCscRootInfo));
        }

        pCscRootInfo = &(pNetRootEntry->NetRoot.sCscRootInfo);
    }


    HookKdPrint(NAME, ("hShare=%x, hRoot=%x, hDir=%x hShadow=%x \n",
             smbFcb->sCscRootInfo.hShare,
             smbFcb->sCscRootInfo.hRootDir,
             smbFcb->hParentDir,
             smbFcb->hShadow));


    if (LocalStatus == STATUS_SUCCESS){

        PMRX_SMB_SRV_OPEN smbSrvOpen;

        if(pCscRootInfo->hShare == 0)
        {
            smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
            LocalStatus = MRxSmbCscObtainShareHandles(
                      &SharePath,
                      DisconnectedMode,
                      BooleanFlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN),
                      SmbCeGetAssociatedNetRootEntry(NetRoot)
                      );

            if (LocalStatus != STATUS_SUCCESS) {

                if (pDfsNameContext) {
                    pNetRootEntry->NetRoot.sCscRootInfo = sCscRootInfoSav;
                }

                RxLog(("CscObtShdH no share handle %x %x\n", RxContext,LocalStatus ));
                RxDbgTrace(0, Dbg,("MRxSmbCscObtainShadowHandles no share handle -> %08xl %08lx\n",
                        RxContext,LocalStatus ));

                return STATUS_SUCCESS;

            }
            else {

                // if this is DFS name get the reverse mapping

                if (pDfsNameContext && !smbFcb->uniDfsPrefix.Buffer)
                {
                    UNICODE_STRING uniTemp;
                    uniTemp = *GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);
                    if (RxContext->Create.NtCreateParameters.DfsContext == UIntToPtr(DFS_OPEN_CONTEXT))
                    {
                        int i, cntSlashes=0;

                        // Strip the first two elements

                        for (i=0; i<uniTemp.Length; i+=2, uniTemp.Buffer++)
                        {
                            if (*uniTemp.Buffer == L'\\')
                            {
                                if (++cntSlashes > 2)
                                {
                                    break;
                                }
                            }

                        }

                        if (uniTemp.Length > (USHORT)i)
                        {
                            uniTemp.Length -= (USHORT)i;
                        }
                        else
                        {
                            uniTemp.Length = 0;
                        }

                    }
                    if ((LocalStatus = CscDfsObtainReverseMapping(&ShadowPath,
                                                  &uniTemp,
                                                  &smbFcb->uniDfsPrefix,
                                                  &smbFcb->uniActualPrefix)) != STATUS_SUCCESS)
                    {
                        pNetRootEntry->NetRoot.sCscRootInfo = sCscRootInfoSav;
                        return LocalStatus;
                    }

                    HookKdPrint(NAME, ("%wZ %wZ DfsPrefix=%wZ ActualPrefix=%wZ\n", &ShadowPath, &uniTemp, &smbFcb->uniDfsPrefix, &smbFcb->uniActualPrefix));

                }

                // note the fact that the NetRootEntry has the
                // root inode corresponding to the DFS
                if (pDfsNameContext)
                {
                    if (pNetRootEntry->NetRoot.sCscRootInfo.hShare)
                    {
                        pNetRootEntry->NetRoot.sCscRootInfo.Flags = CSC_ROOT_INFO_FLAG_DFS_ROOT;
                    }
                }
                else
                {
                    ASSERT(!(pNetRootEntry->NetRoot.sCscRootInfo.Flags & CSC_ROOT_INFO_FLAG_DFS_ROOT));
                }

                // stuff the FCB with the correct root info
                smbFcb->sCscRootInfo = pNetRootEntry->NetRoot.sCscRootInfo;

            }
        }
        else
        {
            // if this is a normal share or we are operating in disconnected state
            // then we need to make sure that the info that is in the NETROOT entry
            // is stuffed into the FCB
            if (!pDfsNameContext && (smbFcb->sCscRootInfo.hShare == 0))
            {
                // stuff the FCB with the correct root info
                smbFcb->sCscRootInfo = pNetRootEntry->NetRoot.sCscRootInfo;
            }
        }
    }

    // if saved, restore the original rootinfo on the netroot
    if (fSaved)
    {
        pNetRootEntry->NetRoot.sCscRootInfo = sCscRootInfoSav;
    }

    if ((LocalStatus == STATUS_SUCCESS)&&(smbFcb->sCscRootInfo.hRootDir != 0)) {

        if (smbFcb->sCscRootInfo.hShare == hShareReint)
        {
            smbFcb->hShadow = 0;
            smbFcb->hParentDir = 0;
            LocalStatus = STATUS_SUCCESS;
        }
        else
        {

            RxDbgTrace( 0, Dbg,
                ("MRxSmbCscObtainShadowHandles h's= %08lx %08lx\n",
                     pCscRootInfo->hShare, pCscRootInfo->hRootDir));

            HookKdPrint(NAME, ("Obtainshdowhandles %wZ Controls=%x\n", &ShadowPath, CreateShadowControls));

            // due to a race condition in the way RDBSS handles FCBs
            // we may get a retyr from CreateShadowFromPath.
            // see the comments in that routine near the
            // check for CREATESHADOW_CONTROL_FAIL_IF_MARKED_FOR_DELETION
            do
            {
                LocalStatus = MRxSmbCscCreateShadowFromPath(
                    &ShadowPath,
                    &smbFcb->sCscRootInfo,
                    Find32,
                    Created,
                    CreateShadowControls,
                    &smbFcb->MinimalCscSmbFcb,
                    RxContext,
                    Disconnected,
                    NULL            // don't want inherited hint flags
                    );

                if (LocalStatus != STATUS_RETRY)
                {
                    LocalStatus=STATUS_SUCCESS;
                    break;
                }
                if (++cntRetry > 4)
                {
                    LocalStatus=STATUS_SUCCESS;
                    ASSERT(FALSE);
                }
            }
            while (TRUE);
        }
    }
#if 0
    DbgPrint("hShare=%x, hRoot=%x, hDir=%x hShadow=%x \n",
             smbFcb->sCscRootInfo.hShare,
             smbFcb->sCscRootInfo.hRootDir,
             smbFcb->hParentDir,
             smbFcb->hShadow);
#endif

    return LocalStatus;
}


#if defined(REMOTE_BOOT)
NTSTATUS
MRxSmbCscSetSecurityOnShadow(
    HSHADOW hShadow,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
/*++

Routine Description:

   Given an HSHADOW, this routine opens the file and sets the
   security information passed in.

Arguments:

    hShadow - the handle to the shadow file

    SecurityInformation - the security information to set

    SecurityDescriptor - the security descriptor to set

Return Value:

Notes:


--*/
{
    PWCHAR fileName;
    DWORD fileNameSize;
    UNICODE_STRING fileNameString;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE fileHandle;
    NTSTATUS ZwStatus;
    int iRet;

    fileNameSize = sizeof(WCHAR) * MAX_PATH;
    fileName = RxAllocatePoolWithTag(NonPagedPool, fileNameSize, RX_MISC_POOLTAG);
    if (fileName == NULL) {

        ZwStatus = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        iRet = GetWideCharLocalNameHSHADOW(
                   hShadow,
                   fileName,
                   &fileNameSize,
                   FALSE);

        if (iRet == SRET_OK) {

            //
            // Open the file and set the security descriptor on it.
            //

            RtlInitUnicodeString(&fileNameString, fileName);

            InitializeObjectAttributes(
                &objectAttributes,
                &fileNameString,
                OBJ_CASE_INSENSITIVE,
                NULL,
                NULL);

            ZwStatus = ZwOpenFile(
                           &fileHandle,
                           FILE_GENERIC_WRITE,
                           &objectAttributes,
                           &ioStatusBlock,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_SYNCHRONOUS_IO_NONALERT);

            if (!NT_SUCCESS(ZwStatus) || !NT_SUCCESS(ioStatusBlock.Status)) {
                //
                // We've been getting bogus names from CSC, ignore this error for now.
                //
                if (ZwStatus == STATUS_OBJECT_NAME_NOT_FOUND) {
                    ZwStatus = STATUS_SUCCESS;
                } else {
                    KdPrint(("MRxSmbCscSetSecurityOnShadow: Could not ZwOpenFile %ws %lx %lx\n", fileName, ZwStatus, ioStatusBlock.Status));
                }
            } else {

                HANDLE TokenHandle = NULL;
                BOOLEAN Impersonated = FALSE;
                BOOLEAN WasEnabled;

                //
                // If we are going to set the owner, need to have privilege.
                //

                if (SecurityInformation & OWNER_SECURITY_INFORMATION) {

                    ZwStatus = ZwOpenThreadToken(NtCurrentThread(),
                                                 TOKEN_QUERY,
                                                 FALSE,
                                                 &TokenHandle);

                    if (ZwStatus == STATUS_NO_TOKEN) {
                        TokenHandle = NULL;
                        ZwStatus = STATUS_SUCCESS;
                    }

                    if (!NT_SUCCESS(ZwStatus)) {
                        KdPrint(("MRxSmbCscSetSecurityOnShadow: Could not NtOpenThread %ws %lx\n", fileName, ZwStatus));
                    } else {
                        ZwStatus = ZwImpersonateSelf(SecurityImpersonation);
                        if (!NT_SUCCESS(ZwStatus)) {
                            KdPrint(("MRxSmbCscSetSecurityOnShadow: Could not RtlImpersonateSelf for %ws %lx\n", fileName, ZwStatus));
                        } else {
                            Impersonated = TRUE;
                            ZwStatus = ZwAdjustPrivilege(
                                           SE_RESTORE_PRIVILEGE,
                                           TRUE,
                                           TRUE,
                                           &WasEnabled);
                            if (!NT_SUCCESS(ZwStatus)) {
                                KdPrint(("MRxSmbCscSetSecurityOnShadow: Could not RtlAdjustPrivilege for %ws %lx %d\n", fileName, ZwStatus, WasEnabled));
                            }
                        }
                    }
                }

                if (NT_SUCCESS(ZwStatus)) {

                    ZwStatus = ZwSetSecurityObject(
                                   fileHandle,
                                   SecurityInformation,
                                   SecurityDescriptor);

                    if (!NT_SUCCESS(ZwStatus)) {
                        KdPrint(("MRxSmbCscSetSecurityOnShadow: Could not ZwSetSecurityObject %ws %lx\n", fileName, ZwStatus));
                    }
                }

                if (Impersonated) {
                    NTSTATUS TmpStatus;
                    TmpStatus = ZwSetInformationThread(NtCurrentThread(),
                                                       ThreadImpersonationToken,
                                                       &TokenHandle,
                                                       sizeof(HANDLE));
                    if (!NT_SUCCESS(TmpStatus)) {
                        KdPrint(("MRxSmbCscSetSecurityOnShadow: Could not revert thread %lx!\n", TmpStatus));
                    }

                }

                if (TokenHandle != NULL) {
                    ZwClose(TokenHandle);
                }

                ZwClose(fileHandle);
            }

        } else {

            ZwStatus = STATUS_OBJECT_NAME_NOT_FOUND;
        }

        RxFreePool(fileName);

    }

    return ZwStatus;

}
#endif

VOID
MRxSmbCscCreateEpilogue (
      IN OUT PRX_CONTEXT RxContext,
      IN OUT PNTSTATUS   Status,
      IN     SMBFCB_HOLDING_STATE *SmbFcbHoldingState
      )
/*++

Routine Description:

   This routine performs the tail of a create operation for CSC.

Arguments:

    RxContext - the RDBSS context

    Status - in disconnected mode, we return the overall status of the open

    SmbFcbHoldingState - indicates whether a ReleaseSmbFcb is required or not

Return Value:

Notes:

    This is a workhorse of a routine for most of the CSC operations. It has become unwieldy and
    very messy but at this point in time we don't want to mess with it (SPP)

--*/
{
    NTSTATUS LocalStatus;
    RxCaptureFcb;RxCaptureFobx;

    PMRX_SMB_FCB      smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN     SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    BOOLEAN ThisIsAPseudoOpen =
         BooleanFlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_NOT_REALLY_OPEN);

    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry =
                  SmbCeGetAssociatedNetRootEntry(NetRoot);

    BOOLEAN Disconnected;

    CSC_SHARE_HANDLE  hShare;
    CSC_SHADOW_HANDLE  hRootDir,hShadow,hParentDir;

    BOOLEAN ShadowWasRefreshed = FALSE;
    PNT_CREATE_PARAMETERS CreateParameters = &RxContext->Create.NtCreateParameters;

    ULONG ReturnedCreateInformation
             = RxContext->Create.ReturnedCreateInformation;
    ULONG CreateInformation; //the new stuff for disconnected mode......
    ULONG CreateDisposition = RxContext->Create.NtCreateParameters.Disposition;
    ULONG CreateOptions = RxContext->Create.NtCreateParameters.CreateOptions;

    _WIN32_FIND_DATA *lpFind32=NULL; //this should not be on the stack CODE.IMPROVEMENT
    OTHERINFO oSI;
    BOOLEAN bGotOtherInfo = FALSE;

    BOOLEAN CreatedShadow = FALSE;
    BOOLEAN NeedTruncate = FALSE; //ok for red/yellow
    BOOLEAN EnteredCriticalSection = FALSE;
    DWORD   dwEarlyOuts=0, dwNotifyFilter=0, dwFileAction=0;

    ASSERT(RxContext!=NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_CREATE);

    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(SrvOpen->pVNetRoot);

    // If we shouldn't be doing CSC, quit right from here

    if(pVNetRootContext == NULL ||
       !MRxSmbIsCscEnabled ||   // MrxSmb not enabled for csc
       (fShadow == 0))   // record manager not enabled for csc
    {
        return;
    }

    if (FlagOn(                 // agent call
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE)
    ) {
        RxLog(("%wZ AgntInst\n", &(pVNetRootContext->pNetRootEntry->Name)));
        ASSERT(SrvOpen->pVNetRoot->Flags & VNETROOT_FLAG_CSCAGENT_INSTANCE);
        // DbgPrint("Skipping agent instances\n");
        goto EarlyOut;
    }

    {
        // we know that this is a create
        PDFS_NAME_CONTEXT pDfsNameContext = CscIsValidDfsNameContext(
                                            RxContext->Create.NtCreateParameters.DfsNameContext);

        if (pDfsNameContext && (pDfsNameContext->NameContextType == DFS_CSCAGENT_NAME_CONTEXT)) {
            RxLog(("%wZ DFS AgntInst\n", &(pVNetRootContext->pNetRootEntry->Name)));
            goto EarlyOut;
        }
    }

    // check whether this is a disconnected open or not
    Disconnected = BooleanFlagOn(
               smbSrvOpen->Flags,
               SMB_SRVOPEN_FLAG_DISCONNECTED_OPEN);

    HookKdPrint(NAME, ("CreateEpilogue: Create %wZ Disposition=%x Options=%x DCON=%d \n",
                       GET_ALREADY_PREFIXED_NAME(NULL,capFcb),
                       CreateDisposition,
                       CreateOptions,
                       Disconnected));

    //  If the open is for a netroot which is not a disk, then we quit from here
    //  and let the redir handle it in connected state
    //  CSC is a filesystem cache.

    if (pNetRootEntry->NetRoot.NetRootType != NET_ROOT_DISK) {

        if (Disconnected) {
            *Status = STATUS_ONLY_IF_CONNECTED;
        }

        return;
    }

    // quit if we are doing sparse filling via copychunks
    if (!Disconnected &&
        (!pNetRootEntry->NetRoot.CscEnabled) &&
        !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN)) {
        goto EarlyOut;
    }

    if (*SmbFcbHoldingState != SmbFcb_NotHeld) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscCreateEpilogue...early release %08lx\n",
               RxContext));
        MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
        ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);
    }

    ASSERT(RxIsFcbAcquiredExclusive( capFcb ));

    if ((*Status != STATUS_SUCCESS) &&
        (*Status != STATUS_ACCESS_DENIED)) {
        if (!Disconnected ||
            (*Status != STATUS_MORE_PROCESSING_REQUIRED)) {
            return;
        }
    }

    // Shadow database locked

    EnterShadowCritRx(RxContext);
    EnteredCriticalSection = TRUE;

    lpFind32 = RxAllocatePoolWithTag(
                 NonPagedPool,
                 sizeof(_WIN32_FIND_DATA),
                 MRXSMB_MISC_POOLTAG );

    if (!lpFind32)
    {
        RxDbgTrace(0, Dbg, ("MRxSmbCscCreateShadowFromPath: Failed allocation of find32 structure \n"));
        dwEarlyOuts=1;
        *Status = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY;
    }

    RxDbgTrace(+1, Dbg, ("MRxSmbCscCreateEpilogue...%08lx %wZ %wZ\n",
            RxContext,NetRoot->pNetRootName,GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext)));

    // if this is a copychunk thru-open....say so in the fcb
    if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN)) {
//        ASSERT(smbFcb->CopyChunkThruOpen == NULL);
        smbFcb->CopyChunkThruOpen = capFobx;
        RxDbgTrace( 0, Dbg,
            ("MRxSmbCscCreateEpilogue set ccto  %08lx %08lx %08lx %08lx\n",
            RxContext, capFcb, capFobx, SrvOpen));
    }

    if (ThisIsAPseudoOpen && !Disconnected) {
        
        
        PDFS_NAME_CONTEXT pDfsNameContext = NULL;


        pDfsNameContext = CscIsValidDfsNameContext(RxContext->Create.NtCreateParameters.DfsNameContext);

        if (pDfsNameContext)
        {
            LocalStatus = MRxSmbCscObtainShadowHandles(
                      RxContext,
                      Status,
                      lpFind32,
                      &CreatedShadow,
                      CREATESHADOW_CONTROL_NOCREATE,
                      FALSE);
        }

        hShadow = 0;
    } else {
        // if we have no shadow, make one as required..........ok red/yellow

        if (smbFcb->hShadow == 0){
            ULONG CreateShadowControl;

            if (!Disconnected) {
                if (*Status == STATUS_ACCESS_DENIED) {
                    CreateShadowControl = CREATESHADOW_CONTROL_NOCREATE;
                } else {

                    CreateShadowControl = (pNetRootEntry->NetRoot.CscShadowable)
                              ? CREATESHADOW_NO_SPECIAL_CONTROLS
                              : CREATESHADOW_CONTROL_NOCREATE;

                    // The step below is done to save bandwidth and make some apps
                    // like edit.exe work.
                    // It essentially creates an entry in the database for a file which
                    // is being created from this client on the server.
                    // Thus the temp files created by apps like word get created
                    // in the database and filled up during the writes.

                    if((ReturnedCreateInformation<= FILE_MAXIMUM_DISPOSITION) &&
                        (ReturnedCreateInformation!=FILE_OPENED)) {


                        CreateShadowControl &= ~CREATESHADOW_CONTROL_NOCREATE;
                    }

                    // disallow autocaching of encrypted files if the database is
                    // not encrypted.
                    if ((vulDatabaseStatus & FLAG_DATABASESTATUS_ENCRYPTED) == 0
                            &&
                        smbFcb->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED
                    ) {
                        CreateShadowControl |= CREATESHADOW_CONTROL_NOCREATE;
                    }

                //
                // The Windows Explorer likes to open .DLL and .EXE files to extract
                //  the ICON -- and it does this whenever it is trying to show the contents
                //  of a directory.  We don't want this explorer activity to force the files
                //  to be cached.  So we only automatically cache .DLL and .EXE files if they
                //  are being opened for execution
                //  We make an exception for VDO shares. The rational being that most
                //  often the users would run apps without opening a folders

                if( CreateShadowControl == CREATESHADOW_NO_SPECIAL_CONTROLS &&
                    !(CreateParameters->DesiredAccess & FILE_EXECUTE)
                    &&(pNetRootEntry->NetRoot.CscFlags != SMB_CSC_CACHE_VDO)) {

                    PUNICODE_STRING fileName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

                    UNICODE_STRING exe = { 3*sizeof(WCHAR), 3*sizeof(WCHAR), L"exe" };
                    UNICODE_STRING dll = { 3*sizeof(WCHAR), 3*sizeof(WCHAR), L"dll" };
                    UNICODE_STRING s;

                    //
                    // If the filename ends in .DLL or .EXE, then we do not cache it this time
                    //
                    if( fileName->Length > 4 * sizeof(WCHAR) &&
                    fileName->Buffer[ fileName->Length/sizeof(WCHAR) - 4 ] == L'.'){

                        s.Length = s.MaximumLength = 3 * sizeof( WCHAR );
                        s.Buffer = &fileName->Buffer[ (fileName->Length - s.Length)/sizeof(WCHAR) ];

                        if( RtlCompareUnicodeString( &s, &exe, TRUE ) == 0 ||
                            RtlCompareUnicodeString( &s, &dll, TRUE ) == 0 ) {

                            CreateShadowControl = CREATESHADOW_CONTROL_FILE_WITH_HEURISTIC;
                        }
                    }
                }
            }
        } else {   //disconnected
            switch (CreateDisposition) {
            case FILE_OVERWRITE:
            case FILE_OPEN:
                CreateShadowControl = CREATESHADOW_CONTROL_NOCREATE;
            break;
            case FILE_CREATE:
            case FILE_SUPERSEDE: //NTRAID-455238-1/31/2000-shishirp supersede not implemented
            case FILE_OVERWRITE_IF:
            case FILE_OPEN_IF:
            default:
                CreateShadowControl = CREATESHADOW_NO_SPECIAL_CONTROLS;
                break;
            }

            if (*Status != STATUS_MORE_PROCESSING_REQUIRED) {
                dwEarlyOuts=2;
                goto FINALLY;
            }

            // make sure we do share access check before we do any damage
            CreateShadowControl |= CREATESHADOW_CONTROL_DO_SHARE_ACCESS_CHECK;

        }   // if (!Disconnected)

        CreateShadowControl |= CREATESHADOW_CONTROL_FAIL_IF_MARKED_FOR_DELETION;

        if (!Disconnected &&
        ((ReturnedCreateInformation==FILE_OPENED) ||
         (ReturnedCreateInformation==FILE_OVERWRITTEN) )  ){
            CreateShadowControl |= CREATESHADOW_CONTROL_SPARSECREATE;
        }

        LocalStatus = MRxSmbCscObtainShadowHandles(
                  RxContext,
                  Status,
                  lpFind32,
                  &CreatedShadow,
                  CreateShadowControl,
                  Disconnected);

        if (LocalStatus != STATUS_SUCCESS) {
            RxDbgTrace(-1, Dbg,
                ("MRxSmbCscCreateEpilogue no handles-> %08lx %08lx\n",RxContext,LocalStatus ));
            dwEarlyOuts=3;
            *Status = LocalStatus;
            goto FINALLY;
        }

        // if we got an inode for a file which was opened or created recently
        // and there have been some writes on it before this
        // then we need to truncate the data so we don't give stale data to the user

        if (smbFcb->hShadow &&
            IsFile(lpFind32->dwFileAttributes) &&
                        !CreatedShadow &&
            FlagOn(smbFcb->MFlags, SMB_FCB_FLAG_WRITES_PERFORMED))
        {
            if(TruncateDataHSHADOW(smbFcb->hParentDir, smbFcb->hShadow) < SRET_OK)
            {
                RxDbgTrace(0, Dbg, ("MRxSmbCscCreateEpilogue: Failed to get shadowinfo for hDir=%x hShadow=%x \r\n", smbFcb->hParentDir, smbFcb->hShadow));
                dwEarlyOuts=31;
                goto FINALLY;
            }
        }

    } else {    //
        ULONG uShadowStatus;
        int iRet;

        RxDbgTrace( 0, Dbg,
        ("MRxSmbCscCreateEpilogue found existing hdir/hshadow= %08lx %08lx\n",
                       smbFcb->hParentDir, smbFcb->hShadow));

        iRet = GetShadowInfo(
               smbFcb->hParentDir,
               smbFcb->hShadow,
               lpFind32,
               &uShadowStatus,
               &oSI);

        if (iRet < SRET_OK) {
            RxDbgTrace(0, Dbg, ("MRxSmbCscCreateEpilogue: Failed to get shadowinfo for hDir=%x hShadow=%x \r\n", smbFcb->hParentDir, smbFcb->hShadow));
            dwEarlyOuts=4;
            goto FINALLY;
        }

        bGotOtherInfo = TRUE;

        //
        // Notepad bug (175322) - quick open/close/open can lose bits - OR in the disk bits
        // with the in-memory bits.
        //
        smbFcb->ShadowStatus |= (USHORT)uShadowStatus;

        RxDbgTrace(0, Dbg,
           ("MRxSmbCscCreateEpilogue name from lpFind32..<%ws>\n",lpFind32->cFileName));

    }

    hShadow    = smbFcb->hShadow;
    hParentDir = smbFcb->hParentDir;

    //
    // If a file is encrypted, but the cache is not, we only allow a file
    // to be cached when the user explicitly asks to do so.
    //
    // Unless we're in the middle of an inode transaction...
    //

    if (
        !Disconnected
            &&
        hShadow != 0
            &&
        cntInodeTransactions == 0
            &&
        (vulDatabaseStatus & FLAG_DATABASESTATUS_ENCRYPTED) == 0
            &&
        (smbFcb->dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED) != 0
    ) {
        int iRet = SRET_OK;
        ULONG uShadowStatus;

        if (bGotOtherInfo == FALSE) {
            iRet = GetShadowInfo(
                       smbFcb->hParentDir,
                       smbFcb->hShadow,
                       lpFind32,
                       &uShadowStatus,
                       &oSI);
        }
        if (
            iRet >= SRET_OK
                &&
            (oSI.ulHintFlags & (FLAG_CSC_HINT_PIN_USER | FLAG_CSC_HINT_PIN_SYSTEM)) == 0
                &&
            oSI.ulHintPri == 0
        ) {
            DeleteShadow(hParentDir, hShadow);
            hShadow = smbFcb->hShadow = 0;
        }
    }

    if (hShadow != 0) {

        if (Disconnected)
        {
            if ((CreateOptions & FILE_DIRECTORY_FILE) && !(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                *Status = STATUS_OBJECT_TYPE_MISMATCH;
                goto FINALLY;
            }
            if ((CreateOptions & FILE_NON_DIRECTORY_FILE) && (lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                *Status = STATUS_FILE_IS_A_DIRECTORY;
                goto FINALLY;
            }


            // don't allow writing to a readonly file
            if (!(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && // a file
                 (lpFind32->dwFileAttributes & FILE_ATTRIBUTE_READONLY) && // readonly attribute set
                 (CreateParameters->DesiredAccess & (FILE_WRITE_DATA|FILE_APPEND_DATA))) // wants to modify
            {
                if (!CreatedShadow)
                {
                    HookKdPrint(NAME, ("Modifying RO file %x %x\n", hParentDir, hShadow));
                    *Status = STATUS_ACCESS_DENIED;
                    goto FINALLY;
                }
            }
        }

        // If the Shadow handle was successfully manufactured we have one of
        // two possibilities -- In a disconnected state the access check
        // needs to be made and in the connected state the access rights need
        // to be updated.
#if defined(REMOTE_BOOT)
        // For remote boot, this whole next section (the if(Disconnected)
        // and the else clause) was not done, since we later impersonated
        // the user while opening the file.
#endif
        if (Disconnected) {
            BOOLEAN AccessGranted;
            CACHED_SECURITY_INFORMATION CachedSecurityInformationForShare;

            memset(&CachedSecurityInformationForShare, 0, sizeof(CachedSecurityInformationForShare));

            AccessGranted = CscAccessCheck(
                            hParentDir,
                            hShadow,
                            RxContext,
                            CreateParameters->DesiredAccess,
                            NULL,
                            &CachedSecurityInformationForShare
                            );

            if (!AccessGranted) {
                HookKdPrint(BADERRORS, ("Security access denied %x %x\n", hParentDir, hShadow));
                *Status = STATUS_ACCESS_DENIED;
                hShadow = 0;
            }
            else if (CreatedShadow && !(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                DWORD CscStatus, i;
                SID_CONTEXT SidContext;
                CSC_SID_ACCESS_RIGHTS AccessRights[2];

                // if the file has been created in offline mode, give the
                // creator all the rights

                if (CscRetrieveSid(RxContext,&SidContext) == STATUS_SUCCESS) {
                    if (SidContext.pSid != NULL) {

                        AccessRights[0].pSid = SidContext.pSid;
                        AccessRights[0].SidLength = RtlLengthSid(SidContext.pSid);

                        AccessRights[0].MaximalAccessRights = FILE_ALL_ACCESS;
                        AccessRights[1].pSid = CSC_GUEST_SID;
                        AccessRights[1].SidLength = CSC_GUEST_SID_LENGTH;
                        AccessRights[1].MaximalAccessRights = 0;

#if 0
                        for (i=0;i<CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES;++i)
                        {
                            if(CachedSecurityInformationForShare.AccessRights[i].SidIndex == CSC_GUEST_SID_INDEX)
                            {
                                AccessRights[1].MaximalAccessRights = CachedSecurityInformationForShare.AccessRights[i].MaximalRights;
                                break;
                            }
                        }
#endif
                        CscStatus = CscAddMaximalAccessRightsForSids(
                                hParentDir,
                                hShadow,
                                2,
                                AccessRights);

                        if (CscStatus != ERROR_SUCCESS) {
                            RxDbgTrace(
                                0,
                                Dbg,
                                ("MRxSmbCscCreateEpilogue Error Updating Access rights %lx\n",Status));
                        }
                     }   // if (SidContext.pSid != NULL)

                     CscDiscardSid(&SidContext);
                }
            }

        } else {
            CSC_SID_ACCESS_RIGHTS AccessRights[2];
            DWORD CscStatus;
            SID_CONTEXT SidContext;

            if (CscRetrieveSid(RxContext,&SidContext) == STATUS_SUCCESS) {
                if (SidContext.pSid != NULL) {

                    AccessRights[0].pSid = SidContext.pSid;
                    AccessRights[0].SidLength = RtlLengthSid(SidContext.pSid);

                    // update the share right if necessary
                    if (pNetRootEntry->NetRoot.UpdateCscShareRights)
                    {
                        AccessRights[0].MaximalAccessRights = pNetRootEntry->MaximalAccessRights;

                        AccessRights[1].pSid = CSC_GUEST_SID;
                        AccessRights[1].SidLength = CSC_GUEST_SID_LENGTH;
                        AccessRights[1].MaximalAccessRights = pNetRootEntry->GuestMaximalAccessRights;

                        CscStatus = CscAddMaximalAccessRightsForShare(
                                    smbFcb->sCscRootInfo.hShare,
                                    2,
                                    AccessRights);
                        if (CscStatus != ERROR_SUCCESS) {
                            RxDbgTrace(
                            0,
                            Dbg,
                            ("MRxSmbCscCreateEpilogue Error Updating Access rights %lx\n",
                            Status));
                        }
                        else
                        {
                            pNetRootEntry->NetRoot.UpdateCscShareRights = FALSE;
                        }
                    }


                    if (!(lpFind32->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                    {

                        AccessRights[0].MaximalAccessRights = smbSrvOpen->MaximalAccessRights;

                        AccessRights[1].pSid = CSC_GUEST_SID;
                        AccessRights[1].SidLength = CSC_GUEST_SID_LENGTH;
                        AccessRights[1].MaximalAccessRights = smbSrvOpen->GuestMaximalAccessRights;

                        if (*Status == STATUS_ACCESS_DENIED) {
                            AccessRights[0].MaximalAccessRights = 0;
                            AccessRights[1].MaximalAccessRights = 0;
                        } else {
                            AccessRights[0].MaximalAccessRights = smbSrvOpen->MaximalAccessRights;
                            AccessRights[1].MaximalAccessRights = smbSrvOpen->GuestMaximalAccessRights;
                        }

                        CscStatus = CscAddMaximalAccessRightsForSids(
                                hParentDir,
                                hShadow,
                                2,
                                AccessRights);

                        if (CscStatus != ERROR_SUCCESS) {
                            RxDbgTrace(
                                0,
                                Dbg,
                                ("MRxSmbCscCreateEpilogue Error Updating Access rights %lx\n",Status));
                        }
                    }
                 }   // if (SidContext.pSid != NULL)

                 CscDiscardSid(&SidContext);
            }   // if (CscRetrieveSid(RxContext,&SidContext) == STATUS_SUCCESS)

            // having updated the access fields, we quit from here.
            if (*Status == STATUS_ACCESS_DENIED)
            {
                goto FINALLY;
            }
        }
    } // if (hShadow != 0)

    if ((hShadow != 0) &&
        !Disconnected  &&  //ok for red/yellow
        (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE)) {

        // here we check to see if the timestamp of the file has changed
        // if so, the shadow needs to be truncated so we don't use it anymore
        ULONG ShadowStatus;
        LONG ShadowApiReturn;

        lpFind32->ftLastWriteTime.dwHighDateTime = smbFcb->LastCscTimeStampHigh;
        lpFind32->ftLastWriteTime.dwLowDateTime  = smbFcb->LastCscTimeStampLow;
        lpFind32->nFileSizeHigh = smbFcb->NewShadowSize.HighPart;
        lpFind32->nFileSizeLow = smbFcb->NewShadowSize.LowPart;
        lpFind32->dwFileAttributes = smbFcb->dwFileAttributes;


        RxDbgTrace(0, Dbg,
           ("MRxSmbCscCreateEpilogue trying for refresh...<%ws>\n",lpFind32->cFileName));

        ShadowApiReturn = RefreshShadow(
                  hParentDir,   //HSHADOW  hDir,
                  hShadow,      //HSHADOW  hShadow,
                  lpFind32,      //LPFIND32 lpFind32,
                  &ShadowStatus //ULONG *lpuShadowStatus
                  );

            if (ShadowApiReturn<0) {
                hShadow = 0;
                RxDbgTrace(0, Dbg,
                ("MRxSmbCscCreateEpilogue refresh failed..%08lx.<%ws>\n",RxContext,lpFind32->cFileName));
            } else {
                smbFcb->ShadowStatus = (USHORT)ShadowStatus;
                if ( ShadowApiReturn==1)
                {
                    ShadowWasRefreshed = 1;
                    //WinSE Bug 28543
                    //Set this flag so that we remember that we truncated the file
                    //and so in MrxSmbCSCUpdateShadowFromClose we don't reset the
                    //SPARSE flag. - NavjotV
                    SetFlag(smbFcb->MFlags,SMB_FCB_FLAG_CSC_TRUNCATED_SHADOW);

                }

            }
        }
    }

    NeedTruncate = FALSE;
    RxDbgTrace(0, Dbg,
       ("MRxSmbCscCreateEpilogue trying for truncate...%08lx %08lx %08lx %08lx\n",
           RxContext,hShadow,CreatedShadow,
           RxContext->Create.ReturnedCreateInformation));

    if (hShadow != 0) {

        if (!Disconnected) {
            CreateInformation = ReturnedCreateInformation;

            if (!CreatedShadow &&
                (ReturnedCreateInformation<= FILE_MAXIMUM_DISPOSITION) &&
                (ReturnedCreateInformation!=FILE_OPENED)  ) {
                if ((NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE)) {
                    NeedTruncate = TRUE;
                }
            }
        }
        else {  // Disconnected
            ULONG ShadowStatus = smbFcb->ShadowStatus;
            BOOLEAN ItsAFile = !BooleanFlagOn(lpFind32->dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY);

            CreateInformation = FILE_OPENED;

            switch (CreateDisposition) {
                case FILE_OPEN:
                NOTHING;
                break;

                case FILE_OPEN_IF:
                if (CreatedShadow) {
                    CreateInformation = FILE_CREATED;
                } else if (FlagOn(ShadowStatus,SHADOW_SPARSE)) {
                    NeedTruncate = ItsAFile;
                    CreateInformation = FILE_CREATED;
                }
                break;

                case FILE_OVERWRITE:
                case FILE_OVERWRITE_IF:
                if (CreatedShadow) {
                    ASSERT(CreateDisposition==FILE_OVERWRITE_IF);
                    CreateInformation = FILE_CREATED;
                } else {
                    NeedTruncate = ItsAFile;
                    CreateInformation = FILE_OVERWRITTEN;
                }
                break;

                case FILE_CREATE:
                if (!CreatedShadow)
                {
                    *Status = STATUS_OBJECT_NAME_COLLISION;
                    goto FINALLY;

                }
                case FILE_SUPERSEDE:
                if (!CreatedShadow) {
                    NeedTruncate = ItsAFile;
                };
                CreateInformation = FILE_CREATED;
                break;

                default:
                ASSERT(FALSE);
            }

            // In disconnected state, note down the changes that have occurred
            // in order to notify them to the fsrtl package.

            if (CreatedShadow)
            {
                dwNotifyFilter = (IsFile(smbFcb->dwFileAttributes)?FILE_NOTIFY_CHANGE_FILE_NAME:FILE_NOTIFY_CHANGE_DIR_NAME);
                dwFileAction = FILE_ACTION_ADDED;
            }
            else if (NeedTruncate)
            {
                dwNotifyFilter = FILE_NOTIFY_CHANGE_SIZE;
                dwFileAction = FILE_ACTION_MODIFIED;
            }
        }   // if (!Disconnected)
    }

    if (NeedTruncate) {
        int iLocalRet;
        ULONG uShadowStatus = smbFcb->ShadowStatus;

        uShadowStatus &= ~SHADOW_SPARSE;
        lpFind32->nFileSizeLow = lpFind32->nFileSizeHigh = 0;

        ASSERT(hShadow!=0);

        HookKdPrint(NAME, ("CreateEpilogue needtruncate %ws %08lx\n",lpFind32->cFileName,uShadowStatus));

        RxDbgTrace(0, Dbg,
            ("MRxSmbCscCreateEpilogue needtruncate...<%ws> %08lx\n",
            lpFind32->cFileName,uShadowStatus));

        TruncateDataHSHADOW(hParentDir, hShadow);
        iLocalRet = SetShadowInfo(
                hParentDir,
                hShadow,
                lpFind32,
                uShadowStatus,
                SHADOW_FLAGS_ASSIGN  |
                ((Disconnected) ?SHADOW_FLAGS_DONT_UPDATE_ORGTIME :0)
                );

        if (iLocalRet < SRET_OK) {
            hShadow = 0;
        } else {
            smbFcb->ShadowStatus = (USHORT)uShadowStatus;
        }
    }   // if (NeedTruncate)

    if (Disconnected) {
        ULONG ShadowStatus = smbFcb->ShadowStatus;
        if (*Status == STATUS_MORE_PROCESSING_REQUIRED) {

            CreateDisposition = RxContext->Create.NtCreateParameters.Disposition;

            RxDbgTrace(0, Dbg,
            ("MRxSmbCscCreateEpilogue lastDCON...<%ws> %08lx %08lx %08lx\n",
            lpFind32->cFileName,ShadowStatus,CreateDisposition,lpFind32->dwFileAttributes));

            switch (CreateDisposition) {
                case FILE_OPEN:
                case FILE_OVERWRITE:
                if ((hShadow==0) ||
                       ( FlagOn(ShadowStatus,SHADOW_SPARSE) &&
                             !FlagOn(lpFind32->dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY))
                   ) {

                    *Status = STATUS_NO_SUCH_FILE;
                } else {
                    // Bypass the shadow if it is not visibile for this connection
                    if (!IsShadowVisible(Disconnected,
                             lpFind32->dwFileAttributes,
                             ShadowStatus)) {

                        *Status = STATUS_NO_SUCH_FILE;
                    }
                    else
                    {
                        *Status = STATUS_SUCCESS;
                    }
                }
                break;

                case FILE_OPEN_IF:
                case FILE_OVERWRITE_IF:
                case FILE_CREATE:
                case FILE_SUPERSEDE:
                    if (hShadow==0) {

                        *Status = STATUS_NO_SUCH_FILE;

                    } else {
                        *Status = STATUS_SUCCESS;
                        //CreateInformation == FILE_OPENED|CREATED set in switch above;
                    }
                break;

                default:
                ASSERT(FALSE);
            }
        }

        if (*Status == STATUS_SUCCESS) {
            //next, we have to do everything that the create code would have done...
            //specifically, we have to build a fobx and we have to do a initfcb.
            //basically, we have to do the create success tail........
            BOOLEAN MustRegainExclusiveResource = FALSE;
            PSMBPSE_FILEINFO_BUNDLE FileInfo = &smbSrvOpen->FileInfo;
            SMBFCB_HOLDING_STATE FakeSmbFcbHoldingState = SmbFcb_NotHeld;
            RX_FILE_TYPE StorageType;

            //RtlZeroMemory(FileInfo,sizeof(FileInfo));

            FileInfo->Basic.FileAttributes = lpFind32->dwFileAttributes;
            COPY_STRUCTFILETIME_TO_LARGEINTEGER(
                  FileInfo->Basic.CreationTime,
                  lpFind32->ftCreationTime);
            COPY_STRUCTFILETIME_TO_LARGEINTEGER(
                  FileInfo->Basic.LastAccessTime,
                  lpFind32->ftLastAccessTime);
            COPY_STRUCTFILETIME_TO_LARGEINTEGER(
                  FileInfo->Basic.LastWriteTime,
                  lpFind32->ftLastWriteTime);

            FileInfo->Standard.NumberOfLinks = 1;
            FileInfo->Standard.EndOfFile.HighPart = lpFind32->nFileSizeHigh;
            FileInfo->Standard.EndOfFile.LowPart = lpFind32->nFileSizeLow;
            FileInfo->Standard.AllocationSize = FileInfo->Standard.EndOfFile; //rdr1 actually rounds up based of svr disk attribs
            FileInfo->Standard.Directory = BooleanFlagOn(lpFind32->dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY);

            //CODE.IMRPOVEMENT successtail should figure out the storage type
            StorageType = FlagOn(lpFind32->dwFileAttributes,FILE_ATTRIBUTE_DIRECTORY)
                       ?(FileTypeDirectory)
                       :(FileTypeFile);

            *Status = MRxSmbCreateFileSuccessTail (
                  RxContext,
                  &MustRegainExclusiveResource,
                  &FakeSmbFcbHoldingState,
                  StorageType,
                  0xf00d,
                  0xbaad,
                  SMB_OPLOCK_LEVEL_BATCH,
                  CreateInformation,
                  FileInfo
                  );

            HookKdPrint(NAME, ("CreateEpilogue %ws attrib=%x \n",lpFind32->cFileName,lpFind32->dwFileAttributes));

        }

        if (*Status != STATUS_SUCCESS){
            hShadow = 0;
        }
    }   // if (Disconnected)

    if (hShadow != 0) {

        PUNICODE_STRING pName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

        // upcase it so change notification will get it right
        // this works because rdbss always does caseinsensitive compare
        UniToUpper(pName->Buffer, pName->Buffer, pName->Length);

        // here we get a local handle on behalf of this srvopen; we only do this
        // open if it's a file (not a directory) AND if the access rights specified
        // indicate that we might use/modify the data in the shadow.


        if (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE) {
            PNT_CREATE_PARAMETERS CreateParameters = &RxContext->Create.NtCreateParameters;

            // why are we not using macros provided in ntioapi.h for access rights?
            ULONG NeedShadowAccessRights = FILE_READ_DATA
                             | FILE_WRITE_DATA
                             | FILE_READ_ATTRIBUTES
                             | FILE_WRITE_ATTRIBUTES
                             | FILE_APPEND_DATA
                             | FILE_EXECUTE;

            if ( (CreateParameters->DesiredAccess & NeedShadowAccessRights) != 0 ) {
//                ASSERT( sizeof(HFILE) == sizeof(HANDLE) );
                ASSERT( hShadow == smbFcb->hShadow );
                ASSERT( hParentDir == smbFcb->hParentDir );

#if defined(REMOTE_BOOT)
                //
                // In the remote boot case, there was an extra context
                // parameter to OpenFileHSHADOW which held a pointer
                // to CreateParameters and a local status value.
                //
#endif

#if !defined(BITCOPY)
                OpenFileHSHADOW(
                    hShadow,
                    0,
                    0,
                    (CSCHFILE *)(&(smbSrvOpen->hfShadow))
                    );
#else
                OpenFileHSHADOWAndCscBmp(
                    smbFcb->hShadow,
                    0,
                    0,
                    (CSCHFILE *)(&(smbSrvOpen->hfShadow)),
                    smbFcb->fDoBitCopy,
                    0,
                    NULL
                    );
                // Check if needed to Open a CSC_BITMAP
                if (
                    smbFcb->fDoBitCopy == TRUE
                        &&
                    smbFcb->NewShadowSize.HighPart == 0 // no 64-bit
                        &&
                    Disconnected // only in dcon mode
                        &&
                    !FlagOn(smbFcb->ShadowStatus,SHADOW_SPARSE)
                        &&
                    smbFcb->lpDirtyBitmap == NULL // shadow file not sparse
                        &&
                    // have not been created before
                    (FlagOn(
                        CreateParameters->DesiredAccess,
                        FILE_WRITE_DATA|FILE_APPEND_DATA))
                    // opened for writes
                    // && is NTFS -- see below
                ) {
                      BOOL fHasStreams;
                      
                      if (HasStreamSupport(smbSrvOpen->hfShadow, &fHasStreams) &&
                            (fHasStreams == TRUE))
                      {
                          OpenCscBmp(hShadow, &((LPCSC_BITMAP)(smbFcb->lpDirtyBitmap)));
                      }
                  }
#endif // defined(BITCOPY)



#if defined(REMOTE_BOOT)
                //
                // Here we checked the local status value and set
                // *Status from it if (iRet != SRET_OK).
                //
#endif

                if (smbSrvOpen->hfShadow != 0) {
                    HookKdPrint(NAME, ("Opened file %ws, hShadow=%x handle=%x \n", lpFind32->cFileName, hShadow, smbSrvOpen->hfShadow));
                    RxLog(("CSC Opened file %ws, hShadow=%x capFcb=%x SrvOpen=%x\n", lpFind32->cFileName, hShadow, capFcb, SrvOpen));

//                    NeedToReportFileOpen = TRUE;
                    SetPriorityHSHADOW(hParentDir, hShadow, MAX_PRI, RETAIN_VALUE);

                    if (Disconnected)
                    {
                        MRxSmbCSCObtainRightsForUserOnFile(RxContext,
                                                           hParentDir,
                                                           hShadow,
                                                           &smbSrvOpen->MaximalAccessRights,
                                                           &smbSrvOpen->GuestMaximalAccessRights);
                    }
                }

            }
        }   // if (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE)

        IF_DEBUG {
            if (FALSE) {
                BOOL thisone, nextone;
                PFDB smbLookedUpFcb,smbLookedUpFcbNext;

                smbLookedUpFcb = PFindFdbFromHShadow(hShadow);
                smbLookedUpFcbNext = PFindFdbFromHShadow(hShadow+1);
                RxDbgTrace(0, Dbg, ("MRxSmbCscCreateEpilogue lookups -> %08lx %08lx %08lx\n",
                      smbFcb,
                      MRxSmbCscRecoverMrxFcbFromFdb(smbLookedUpFcb),
                      MRxSmbCscRecoverMrxFcbFromFdb(smbLookedUpFcbNext)  ));
            }
        }
    }   // if (hShadow != 0)

FINALLY:

    if (lpFind32)
    {
        RxFreePool(lpFind32);
    }
    if (EnteredCriticalSection) {
        LeaveShadowCritRx(RxContext);
    }

#if 0
    if (NeedToReportFileOpen) {
        //this is a bit strange....it's done this way because MRxSmbCscReportFileOpens
        //enters the critsec for himself.....it is also called from within MRxSmbCollapseOpen
        //if instead MRxSmbCollapseOpen called a wrapper routine, we could have
        //MRxSmbCscReportFileOpens not enter and we could do this above
        MRxSmbCscReportFileOpens();  //CODE.IMPROVEMENT this guy shouldn't enter
    }
#endif

    if (Disconnected)
    {
        if(*Status == STATUS_MORE_PROCESSING_REQUIRED) {
            // if we ever get here after CSC is shutdown, we need to return appropriate error
            if (fShadow)
            {
                RxLog(("EarlyOut = %d \r\n", dwEarlyOuts));
                // should never get here
                DbgPrint("MRxSmbCscCreateEpilogue: EarlyOut = %d \r\n", dwEarlyOuts);
                ASSERT(FALSE);
            }
            else
            {
                *Status = STATUS_NETWORK_UNREACHABLE;
            }
        }
        else if (*Status == STATUS_SUCCESS)
        {
            // report changes to the notification package
            if (dwNotifyFilter)
            {
                ASSERT(dwFileAction);

                RxLog(("chngnot hShadow=%x filter=%x\n",smbFcb->hShadow, dwNotifyFilter));

                FsRtlNotifyFullReportChange(
                    pNetRootEntry->NetRoot.pNotifySync,
                    &pNetRootEntry->NetRoot.DirNotifyList,
                    (PSTRING)GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb),
                    (USHORT)(GET_ALREADY_PREFIXED_NAME(SrvOpen, capFcb)->Length -
                                smbFcb->MinimalCscSmbFcb.LastComponentLength),
                    NULL,
                    NULL,
                    dwNotifyFilter,
                    dwFileAction,
                    NULL);
            }
        }
    }

    HookKdPrint(NAME, ("CreateEpilogue Out: returnedCreateInfo=%x Status=%x\n",
                        ReturnedCreateInformation, *Status));

    RxDbgTrace(-1, Dbg, ("MRxSmbCscCreateEpilogue ->%08lx %08lx\n",RxContext, *Status ));
    RxLog(("CscCrEpi %x %x\n",RxContext, *Status ));
    return;

EarlyOut:
    if (*SmbFcbHoldingState != SmbFcb_NotHeld) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscCreateEpilogue...early release %08lx\n",
               RxContext));
        MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
        ASSERT(*SmbFcbHoldingState == SmbFcb_NotHeld);
    }
    return;    
}

VOID
MRxSmbCscDeleteAfterCloseEpilogue (
      IN OUT PRX_CONTEXT RxContext,
      IN OUT PNTSTATUS   Status
      )
/*++

Routine Description:

   This routine performs the tail of a delete-after-close operation for CSC.
   Basically, it deletes the file from the cache.

   The status of the operation is passed in case we someday find
   things are so messed up that we want to return a failure even if the
   nonshadowed operations was successful. not today however...

Arguments:

    RxContext - the RDBSS context

Return Value:


Notes:


--*/
{
    NTSTATUS LocalStatus=STATUS_UNSUCCESSFUL;
    int iRet = -1;
    ULONG ShadowFileLength;

    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry =
                  SmbCeGetAssociatedNetRootEntry(NetRoot);

    BOOLEAN EnteredCriticalSection = FALSE;
    _WIN32_FIND_DATA Find32; //this should not be on the stack CODE.IMPROVEMENT
    BOOLEAN Disconnected;
    ULONG uShadowStatus;
    OTHERINFO    sOI;

    if(!MRxSmbIsCscEnabled) {
        return;
    }
    if (fShadow == 0) {
        return;
    }

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    RxDbgTrace(+1, Dbg,
    ("MRxSmbCscDeleteAfterCloseEpilogue entry %08lx...%08lx on handle %08lx\n",
        RxContext, SrvOpen, smbSrvOpen->hfShadow ));

    if (*Status != STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscDeleteAfterCloseEpilogue exit(status) w/o deleteing -> %08lx %08lx\n", RxContext, Status ));
        goto FINALLY;
    }

    EnterShadowCritRx(RxContext);
    EnteredCriticalSection = TRUE;

    //if we don't have a shadow...go look for one
    if (smbFcb->hShadow == 0) {
        if (!smbFcb->hShadowRenamed)
        {
            LocalStatus = MRxSmbCscObtainShadowHandles(
                      RxContext,
                      Status,
                      &Find32,
                      NULL,
                      CREATESHADOW_CONTROL_NOCREATE,
                      Disconnected);

            if (LocalStatus != STATUS_SUCCESS) {
                RxDbgTrace(0, Dbg,
            ("MRxSmbCscDeleteAfterCloseEpilogue couldn't get handles-> %08lx %08lx\n",RxContext,LocalStatus ));
                goto FINALLY;
            }
        }
        else
        {
            smbFcb->hShadow = smbFcb->hShadowRenamed;
            smbFcb->hParentDir = smbFcb->hParentDirRenamed;
        }

        if (smbFcb->hShadow == 0) {
            RxDbgTrace(0, Dbg,
            ("MRxSmbCscDeleteAfterCloseEpilogue no handles-> %08lx %08lx\n",RxContext,LocalStatus ));
            goto FINALLY;
        }
    }

    if(GetShadowInfo(smbFcb->hParentDir,
             smbFcb->hShadow,
             &Find32,
             &uShadowStatus, &sOI) < SRET_OK) {
        goto FINALLY;
    }

    if (IsShadowVisible(
        Disconnected,
        Find32.dwFileAttributes,
        uShadowStatus)) {
        BOOLEAN fMarkDeleted = (Disconnected && !mShadowLocallyCreated(uShadowStatus));

        LocalStatus = OkToDeleteObject(smbFcb->hParentDir, smbFcb->hShadow, &Find32, uShadowStatus, Disconnected);

        // If it is not OK to delete, the quit
        if (LocalStatus != STATUS_SUCCESS)
        {
            iRet = -1;
            goto FINALLY;
        }

        if (!fMarkDeleted)
        {
            if (capFcb->OpenCount != 0)
            {
                DbgPrint("Marking for delete hDir=%x hShadow=%x %ws \n\n", smbFcb->hParentDir, smbFcb->hShadow, Find32.cFileName);
                ASSERT(FALSE);
                RxLog(("Marking for delete hDir=%x hShadow=%x %ws \n\n", smbFcb->hParentDir, smbFcb->hShadow, Find32.cFileName));

                // if we are supposed to really delete this file, note this fact on the FCB
                // we will delete it when the FCB is deallocated
                smbFcb->LocalFlags |= FLAG_FDB_DELETE_ON_CLOSE;
                iRet = 0;
            }
            else
            {
                iRet = DeleteShadowHelper(FALSE, smbFcb->hParentDir, smbFcb->hShadow);
                smbFcb->hShadow = 0;

                if (iRet < 0)
                {
                    goto FINALLY;
                }

            }
        }
        else
        {

            iRet = DeleteShadowHelper(TRUE, smbFcb->hParentDir, smbFcb->hShadow);
            smbFcb->hShadow = 0;
        }

        if (iRet >= 0)
        {
            PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
            PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);

            InsertTunnelInfo(smbFcb->hParentDir,
                     Find32.cFileName,
                     Find32.cAlternateFileName,
                     &sOI);
            if (fMarkDeleted) {
                MarkShareDirty(&smbFcb->sCscRootInfo.ShareStatus, smbFcb->sCscRootInfo.hShare);
            }
            // when disconnected, report the change
            if (Disconnected)
            {
                FsRtlNotifyFullReportChange(
                    pNetRootEntry->NetRoot.pNotifySync,
                    &pNetRootEntry->NetRoot.DirNotifyList,
                    (PSTRING)GET_ALREADY_PREFIXED_NAME(NULL,capFcb),
                    (USHORT)(GET_ALREADY_PREFIXED_NAME(NULL, capFcb)->Length -
                    smbFcb->MinimalCscSmbFcb.LastComponentLength),
                    NULL,
                    NULL,
                    IsFile(Find32.dwFileAttributes)?FILE_NOTIFY_CHANGE_FILE_NAME
                                                  :FILE_NOTIFY_CHANGE_DIR_NAME,
                    FILE_ACTION_REMOVED,
                    NULL);
            }
        }

    }

FINALLY:
    if (EnteredCriticalSection) {
        LeaveShadowCritRx(RxContext);
    }

    if (Disconnected) {
        if (iRet < 0) {
            *Status = LocalStatus; //do we need a better error mapping?
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscDeleteAfterCloseEpilogue exit-> %08lx %08lx\n", RxContext, Status ));
    return;
}

ULONG
GetPathLevelFromUnicodeString (
    PUNICODE_STRING Name
      )
/*++

Routine Description:

   This routine counts the number of L'\\' in a string. It is used to set
   the priority level for a directory on a rename operation.

Arguments:

    Name -

Return Value:


Notes:


--*/
{
    PWCHAR t = Name->Buffer;
    LONG l = Name->Length;
    ULONG Count = 1;

    for (;l<2;l--) {
        if (*t++ == L'\\') {
            Count++;
        }
    }
    return(Count);
}

VOID
MRxSmbCscRenameEpilogue (
      IN OUT PRX_CONTEXT RxContext,
      IN OUT PNTSTATUS   Status
      )
/*++

Routine Description:

   This routine performs the tail of a rename operation for CSC.
   Basically, it renames the file in the record manager datastructures.
   Unfortunately, there is no "basically" to it.

   The status of the operation is passed in case we someday find
   things are so messed up that we want to return a failure even if the
   nonshadowed operations was successful. not today however...

Arguments:

    RxContext - the RDBSS context

Return Value:


Notes:

    The routine does the following operations
    - Get the Inode for the source ie. If \foo.dir\bar.txt is the source, we traverse the path
      to get the inode for bar.txt.
    - If necessary create the destination namespace in the CSC database i.e., if \foo.dir\bar.txt
      is being renamed to \xxx.dir\yyy.dir\abc.txt, then ensure that the hierarchy \xxx.dir\yyy.dir
      exists in the local namespace.

    - If the destination inode exists, then apply the visibility and replace_if_exists logic to it.
      If the operation is still valid, then get all the info about the destination inode and
      delete it. Apply the info on the destination inode to the source.
    - Do a rename

--*/
{
    NTSTATUS LocalStatus = STATUS_UNSUCCESSFUL;
    ULONG ShadowFileLength;
    int iRet = -1;

    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry =
                  SmbCeGetAssociatedNetRootEntry(NetRoot);

    UNICODE_STRING RenameName={0,0,NULL};
    UNICODE_STRING LastComponentName = {0,0,NULL};
    PFILE_RENAME_INFORMATION RenameInformation = RxContext->Info.Buffer;
    MRX_SMB_FCB CscSmbFcb;

    BOOLEAN EnteredCriticalSection = FALSE;
    _WIN32_FIND_DATA Find32; //this should not be on the stack CODE.IMPROVEMENT
    ULONG ulInheritedHintFlags=0;

    BOOL fDoTunneling = FALSE;
    HSHADOW hDir, hDirTo, hShadow=0, hShadowTo=0;
    ULONG uShadowStatusFrom, uShadowStatusTo, uRenameFlags, attrSav;
    OTHERINFO sOI, sOIFrom;
    LPOTHERINFO lpOI=NULL;
    BOOLEAN Disconnected, fAlreadyStripped = FALSE;
    RETRIEVE_TUNNEL_INFO_RETURNS TunnelType;
    _FILETIME ftLWTime;
    BOOL fFile;
    USHORT *lpcFileNameTuna = NULL, *lpcAlternateFileNameTuna = NULL;

    if(!MRxSmbIsCscEnabled ||
       (fShadow == 0)) {
        RxLog(("RenCSC disabled \n"));
        return;
    }

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    // an open for rename should never be a local open
    ASSERT(!BooleanFlagOn(
               smbSrvOpen->Flags,
               SMB_SRVOPEN_FLAG_LOCAL_OPEN));

    if (!Disconnected &&
        !pNetRootEntry->NetRoot.CscEnabled) {
        RxLog(("NR %x Not cscenabled %x\n", pNetRootEntry));
        return;
    }

    RxDbgTrace(+1, Dbg,
    ("MRxSmbCscRenameEpilogue entry %08lx...%08lx on handle %08lx\n",
        RxContext, SrvOpen, smbSrvOpen->hfShadow ));

    if (*Status != STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue exit(status) w/o deleteing -> %08lx %08lx\n", RxContext, Status ));
        goto FINALLY;
    }

    uRenameFlags = 0;

    EnterShadowCritRx(RxContext);
    EnteredCriticalSection = TRUE;

    //if we don't have a shadow...go look for one
    if (smbFcb->hShadow == 0) {
        LocalStatus = MRxSmbCscObtainShadowHandles(
                  RxContext,
                  Status,
                  &Find32,
                  NULL,
                  CREATESHADOW_CONTROL_NOCREATE|
                  ((capFobx->Flags & FOBX_FLAG_DFS_OPEN)?CREATESHADOW_CONTROL_STRIP_SHARE_NAME:0),
                  Disconnected);

        if (LocalStatus != STATUS_SUCCESS) {
            RxDbgTrace(0, Dbg,
            ("MRxSmbCscRenameEpilogue couldn't get handles-> %08lx %08lx\n",RxContext,LocalStatus ));
            goto FINALLY;
        }

        if (smbFcb->hShadow == 0) {
            RxDbgTrace(0, Dbg,
            ("MRxSmbCscRenameEpilogue no handles-> %08lx %08lx\n",RxContext,LocalStatus ));
            goto FINALLY;
        }
    }

    if (GetShadowInfo(
        smbFcb->hParentDir,
        smbFcb->hShadow,
        &Find32,
        &uShadowStatusFrom, &sOIFrom) < SRET_OK) {
        LocalStatus = STATUS_NO_SUCH_FILE;
        goto FINALLY;
    }

    hShadow = smbFcb->hShadow;
    hDir = smbFcb->hParentDir;
    if (!hShadow ||
    !IsShadowVisible(
        Disconnected,
        Find32.dwFileAttributes,
        uShadowStatusFrom))  {
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscRenameEpilogue no shadoworinvisible-> %08lx %08lx\n",RxContext,LocalStatus ));
            LocalStatus = STATUS_NO_SUCH_FILE;
            goto FINALLY;
    }

//    DbgPrint("Renaming %ws ", Find32.cFileName);
    RxLog(("Renaming hDir=%x hShadow=%x %ws ", hDir, hShadow, Find32.cFileName));

    fFile = IsFile(Find32.dwFileAttributes);

    // NB begin temp use of uRenameFlags
    uRenameFlags = (wstrlen(Find32.cFileName)+1)*sizeof(USHORT);

    lpcFileNameTuna = AllocMem(uRenameFlags);

    lpcAlternateFileNameTuna = AllocMem(sizeof(Find32.cAlternateFileName));

    if (!lpcFileNameTuna || ! lpcAlternateFileNameTuna) {
        LocalStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto FINALLY; //bailout;
    }

    // save the alternate filename for tunnelling purposes
    memcpy(lpcAlternateFileNameTuna,
       Find32.cAlternateFileName,
       sizeof(Find32.cAlternateFileName));

    memcpy(lpcFileNameTuna, Find32.cFileName, uRenameFlags);

    // end temp use of uRenameFlags
    uRenameFlags = 0;


    // Save the last write time
    ftLWTime = Find32.ftLastWriteTime;

    if (Disconnected) {

        // if this is a file and we are trying to delete it
        // without permissions, then bail

        if (fFile &&
            !(FILE_WRITE_DATA & smbSrvOpen->MaximalAccessRights)&&
            !(FILE_WRITE_DATA & smbSrvOpen->GuestMaximalAccessRights))
        {
            LocalStatus = STATUS_ACCESS_DENIED;
            RxLog(("No rights to rename %x in dcon Status=%x\n", smbFcb->hShadow, LocalStatus));
            HookKdPrint(BADERRORS, ("No rights to rename %x in dcon Status=%x\n", smbFcb->hShadow, LocalStatus));
            goto FINALLY; //bailout;
        }

        // In disconnected state we don't allow directory renames on
        // remotely obtained directories
        // This is consistent with not allowing delete on these directories

        if (!fFile && !mShadowLocallyCreated(uShadowStatusFrom)) {
            LocalStatus = STATUS_ONLY_IF_CONNECTED;
            goto FINALLY; //bailout;
        }

        if (!mShadowLocallyCreated(uShadowStatusFrom)) { // remote object

            // Ask RenameShadow to mark the source as deleted, it will have to
            // be reintegrated later
            uRenameFlags |= RNMFLGS_MARK_SOURCE_DELETED;

            // if this is the copy of the original,
            // ie. it has not gone through delete/create cycles,
            // we need to save it's value in the new shadow structure
            // so that while reintegrating, we can do rename operations
            // before merging.
            // The SHADOW_REUSE flag is set in CreateShadowFromPath, and
            // in his routine while dealing with hShadowTo
            // when the shadow of a remote object that has been marked deleted
            // is reused during disconnected operation.
            // When a reused object is renamed, the new object is NOT a
            // true alias of the original object on the Share

            if (!mShadowReused(uShadowStatusFrom)) {
                // not been reused, give his rename alias, if any, to the new one
                uRenameFlags |= RNMFLGS_SAVE_ALIAS;
            }
        }
        else
        { // locally created

            // This is a locally created shadow that is being renamed
            // we wan't to retain it's alias, if any, so we know if it
            // was renamed from a remote object or was created locally
            uRenameFlags |= RNMFLGS_RETAIN_ALIAS;
        }
    }

    // Let us create the directory hierarchy in which the file/directory
    // is to be renamed
//    ASSERT((RenameInformation->FileName[0] == L'\\') || (RenameInformation->FileName[0] == L':'))
    RenameName.Buffer = &RenameInformation->FileName[0];
    RenameName.Length = (USHORT)RenameInformation->FileNameLength;
    if (smbFcb->uniDfsPrefix.Buffer)
    {
        UNICODE_STRING  DfsName;

        if (capFobx->Flags & FOBX_FLAG_DFS_OPEN)
        {
            LocalStatus = CscDfsStripLeadingServerShare(&RenameName);

            if (LocalStatus != STATUS_SUCCESS)
            {
                RenameName.Buffer = NULL;
                goto FINALLY;
            }

            fAlreadyStripped = TRUE;
        }

        if(CscDfsDoDfsNameMapping(&smbFcb->uniDfsPrefix,
                               &smbFcb->uniActualPrefix,
                               &RenameName,
                               TRUE,    //fResolvedNameToDFSName
                               &DfsName
                               ) != STATUS_SUCCESS)
        {
            LocalStatus = STATUS_INSUFFICIENT_RESOURCES;
            RenameName.Buffer = NULL;
            goto FINALLY;
        }

        RenameName = DfsName;
    }


    RtlZeroMemory(&CscSmbFcb, sizeof(CscSmbFcb));

    CscSmbFcb.MinimalCscSmbFcb.sCscRootInfo = smbFcb->sCscRootInfo;

    MRxSmbCscCreateShadowFromPath(
        &RenameName,
        &CscSmbFcb.MinimalCscSmbFcb.sCscRootInfo,
        &Find32,
        NULL,
        (CREATESHADOW_CONTROL_NOREVERSELOOKUP |
         CREATESHADOW_CONTROL_NOCREATELEAF|
         ((!fAlreadyStripped && (capFobx->Flags & FOBX_FLAG_DFS_OPEN))?CREATESHADOW_CONTROL_STRIP_SHARE_NAME:0)
         ),
        &CscSmbFcb.MinimalCscSmbFcb,
        RxContext,
        Disconnected,
        &ulInheritedHintFlags
        );

    hDirTo = CscSmbFcb.MinimalCscSmbFcb.hParentDir;
    hShadowTo = CscSmbFcb.MinimalCscSmbFcb.hShadow;
    uShadowStatusTo = CscSmbFcb.MinimalCscSmbFcb.ShadowStatus;

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...000=%08lx %08lx %08lx\n",
            hDirTo,hShadowTo,uShadowStatusTo));

    if (!hDirTo) {
        HookKdPrint(BADERRORS, ("Cannot rename root %x in dcon \n", hShadowTo));
        LocalStatus = STATUS_ACCESS_DENIED;
        goto FINALLY; //bailout;
    }

    //
    // allocate a buffer that's the right size: one extra char is
    // for a trailing null....this buffer is used to get the tunnelling
    // information

    LastComponentName.Length = CscSmbFcb.MinimalCscSmbFcb.LastComponentLength;
    LastComponentName.Buffer = (PWCHAR)RxAllocatePoolWithTag(
                        PagedPool,
                        LastComponentName.Length  + (1 * sizeof(WCHAR)),
                        RX_MISC_POOLTAG);

    if (LastComponentName.Buffer==NULL) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue -> noalloc\n"));
    } else {
        PWCHAR t;

        RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...lastcomponentinhex=%08lx\n",LastComponentName.Buffer));
        RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...renamebuffer=%08lx\n",RenameName.Buffer));
        RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...lcofff=%08lx,%08lx\n",
                      CscSmbFcb.MinimalCscSmbFcb.LastComponentOffset,CscSmbFcb.MinimalCscSmbFcb.LastComponentLength));

        RtlCopyMemory(
            LastComponentName.Buffer,
            RenameName.Buffer + CscSmbFcb.MinimalCscSmbFcb.LastComponentOffset,
            LastComponentName.Length);

        t = (PWCHAR)( ((PBYTE)(LastComponentName.Buffer)) + LastComponentName.Length );

        *t = 0;

        RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...lastcomponent=%ws (%08lx)\n",
                LastComponentName.Buffer,LastComponentName.Buffer));
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...hdirto 1111=(%08lx)\n", hDirTo));

    // Do we have a destination shadow for rename?
    if (hShadowTo) {

        BOOLEAN fDestShadowVisible = FALSE;

        if (IsShadowVisible(
            Disconnected,
            Find32.dwFileAttributes,
            uShadowStatusTo))
        {
            fDestShadowVisible = TRUE;
        }

        // If it is visible and this is not a replace_if_exists operation
        // then this is an illegal rename

        if (fDestShadowVisible && !RxContext->Info.ReplaceIfExists)
        {
            LocalStatus = STATUS_OBJECT_NAME_COLLISION;
            goto FINALLY; //bailout;
        }

        if (!Disconnected) {// connected

            if (!RxContext->Info.ReplaceIfExists)
            {
                // When we are connected, we are doing rename in caching mode
                // If the renameTo exists and needs reintegration,
                // we protect it by nuking the renameFrom and succeeding
                // the rename

                KdPrint(("SfnRename:unary op %x, \r\n", hShadow));

                ASSERT(mShadowOutofSync(uShadowStatusTo));

                ASSERT(!fFile || !mShadowOutofSync(uShadowStatusFrom));
                ASSERT(!mShadowBusy(uShadowStatusFrom));

                if(DeleteShadow(hDir, hShadow) < SRET_OK) {
                    LocalStatus = STATUS_UNSUCCESSFUL;
                } else {
                    iRet = 0;
                    smbFcb->hShadow = 0;
                }

                goto FINALLY; //bailout;
            }
        }

        // Nuke the renameTo shadow
        if(DeleteShadow(hDirTo, hShadowTo) < SRET_OK) {
            LocalStatus = STATUS_UNSUCCESSFUL;
            goto FINALLY; //bailout;
        } else {
            //hunt up the fcb, if any and zero the hshadow
            PFDB smbLookedUpFdbTo;
            PMRX_SMB_FCB smbFcbTo;

            smbLookedUpFdbTo = PFindFdbFromHShadow(hShadowTo);
            if (smbLookedUpFdbTo!=NULL) {
                smbFcbTo = MRxSmbCscRecoverMrxFcbFromFdb(smbLookedUpFdbTo);
                RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue lookups -> %08lx %08lx %08lx\n",
                        smbFcbTo,
                        smbLookedUpFdbTo,
                        hShadowTo  ));
                ASSERT((smbFcbTo->hShadow == hShadowTo)||(smbFcbTo->hShadowRenamed == hShadowTo));
                smbFcbTo->hShadow = 0;
            }
        }

        if (Disconnected && !mShadowLocallyCreated(uShadowStatusTo)) {
            // When the renameTo is a remote object
            // it is possible for two remote objects to get crosslinked, ie. be each others
            // aliases. The reintegrator needs to deal with this case.

            // Cleanup the locally created status of the hShadowFrom if it
            // did exist because it is being renamed to a remote object
            mClearBits(uShadowStatusFrom, SHADOW_LOCALLY_CREATED);

            // Mark the original object as having been reused so a rename
            // on it will not point back to this object.
            // Also set all the CHANGE attributes to indicate that this is a
            // spanking new object. Actually doesn't SHADOW_REUSED flag do that
            // already?
            mSetBits(uShadowStatusFrom, SHADOW_REUSED|SHADOW_DIRTY|SHADOW_ATTRIB_CHANGE);
        }
    }

    if (!hShadowTo)
    {
        if (Disconnected) {
            // we don't have a renameTo. If we are in disconnected state, let us
            // mark it as locally created, which it is.
            mSetBits(uShadowStatusFrom, SHADOW_LOCALLY_CREATED);
        }
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...hdirto 3333= (%08lx)\n", hDirTo));
    ASSERT(hDir && hShadow && hDirTo);

    if (!Disconnected)    {// connected
        //get the names and attributes from the Share
        MRxSmbGetFileInfoFromServer(RxContext,&RenameName,&Find32,NULL,NULL);
    } else {// disconnected
        if (hShadowTo) {
            // Find32 contains the orgtime of hShadowTo
            // we tell the RenameShadow routine to reuse it.

            Find32.ftLastWriteTime = ftLWTime;
            uRenameFlags |= RNMFLGS_USE_FIND32_TIMESTAMPS;
        } else {
            Find32.cFileName[0] = 0;
            Find32.cAlternateFileName[0] = 0;
        }
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...hdirto 4444= (%08lx)\n", hDirTo));

    if (!fFile) {
        // We set the reference priority of the directories to their level
        // in the hierarchiy starting 1 for the root. That way we
        // walk the PQ in reverse priority order for directories. to create
        // all the direcotry objects hierarchically. But with hints
        // this is going to be a problem.
        Find32.dwReserved0 = GetPathLevelFromUnicodeString(&RenameName);
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...hdirto 5555= (%08lx)\n", hDirTo));
    // If there is any tunnelling info then use it to create this guy
    if (LastComponentName.Buffer &&
    (TunnelType = RetrieveTunnelInfo(
              hDirTo,    // directory where the renames are happenieng
              LastComponentName.Buffer,    // potential SFN
              (Disconnected)? &Find32:NULL, // get LFN only when disconnected
              &sOI)))  {
        lpOI = &sOI;
    }

    if (Disconnected) {
        //muck with the names.......
        switch (TunnelType) {
            case TUNNEL_RET_SHORTNAME_TUNNEL:
            //we tunneled on the shortname.....retrievetunnelinfo did the copies....
            break;

            case TUNNEL_RET_NOTFOUND:
                //no tunnel. use the name passed as the long name
            RtlCopyMemory( &Find32.cFileName[0],
               LastComponentName.Buffer,
               LastComponentName.Length + sizeof(WCHAR) );
            //lack of break intentional;

            case TUNNEL_RET_LONGNAME_TUNNEL:
            //if we tunneled on the longname....retrievetunnelinfo did the copies....
            //but we may still need a shortname
            MRxSmbCscGenerate83NameAsNeeded(hDirTo,
                            &Find32.cFileName[0],
                            &Find32.cAlternateFileName[0]);
            break;
        }
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...hdirto 6666=(%08lx)\n", hDirTo));


    if (RenameShadow(
        hDir,
        hShadow,
        hDirTo,
        &Find32,
        uShadowStatusFrom,
        lpOI,
        uRenameFlags,
        &hShadowTo) < SRET_OK)
    {
        LocalStatus = STATUS_UNSUCCESSFUL;
        goto FINALLY; //bailout;
    }

    smbFcb->hShadow = 0;

    ASSERT(hShadowTo);

    smbFcb->hShadowRenamed = hShadowTo;
    smbFcb->hParentDirRenamed = hDirTo;

    fDoTunneling = TRUE;

    RxDbgTrace(0, Dbg, ("MRxSmbCscRenameEpilogue...hdirto 7777= (%08lx)\n", hDirTo));
    if (Disconnected) {
        // Mark it on the Share, so reintegration can proceed
        MarkShareDirty(&smbFcb->sCscRootInfo.ShareStatus,
                        (ULONG)(smbFcb->sCscRootInfo.hShare));
    }

    if (mPinInheritFlags(ulInheritedHintFlags))
    {
        RxDbgTrace(0, Dbg, ("RenameEpilogue: Setting inherited hintflags on hShadow=%x \n", hShadowTo));

        if(GetShadowInfo(hDirTo, hShadowTo, NULL, NULL, &sOI) >= SRET_OK)
        {
            if (ulInheritedHintFlags & FLAG_CSC_HINT_PIN_INHERIT_USER) {
                sOI.ulHintFlags |= FLAG_CSC_HINT_PIN_USER;
            }

            if (ulInheritedHintFlags & FLAG_CSC_HINT_PIN_INHERIT_SYSTEM) {
                sOI.ulHintFlags |= FLAG_CSC_HINT_PIN_SYSTEM;
            }

            SetShadowInfoEx(hDirTo, hShadowTo, NULL, 0, SHADOW_FLAGS_OR, &sOI, NULL, NULL);
        }
    }

    iRet = 0;

    // This effectively bumps up the version number of the current CSC namespace
    // if this share is a remoteboot share and is being merged, then the reintegration code will
    // backoff

    IncrementActivityCountForShare(smbFcb->sCscRootInfo.hShare);

FINALLY:
    if (fDoTunneling) {
        // We succeeded the rename, let use keep the tunneling info for the source
        InsertTunnelInfo(
            hDir,
            lpcFileNameTuna,
            lpcAlternateFileNameTuna,
            &sOIFrom);
    }

    if (EnteredCriticalSection) {
        LeaveShadowCritRx(RxContext);
    }

    if (LastComponentName.Buffer) {
        RxFreePool(LastComponentName.Buffer);
    }

    if (lpcFileNameTuna) {
        FreeMem(lpcFileNameTuna);
    }

    if (lpcAlternateFileNameTuna) {
        FreeMem(lpcAlternateFileNameTuna);
    }

    if (Disconnected) {
        if (iRet!=0) {
            *Status = LocalStatus;
        }
        else
        {
            // when disconnected, report the change
            // we can be smart about this and report only once if this is not across
            // directories
            FsRtlNotifyFullReportChange(
                pNetRootEntry->NetRoot.pNotifySync,
                &pNetRootEntry->NetRoot.DirNotifyList,
                (PSTRING)GET_ALREADY_PREFIXED_NAME(NULL,capFcb),
                (USHORT)(GET_ALREADY_PREFIXED_NAME(NULL, capFcb)->Length -
                smbFcb->MinimalCscSmbFcb.LastComponentLength),
                NULL,
                NULL,
                (fFile)?FILE_NOTIFY_CHANGE_FILE_NAME:FILE_NOTIFY_CHANGE_DIR_NAME,
                FILE_ACTION_RENAMED_OLD_NAME,
                NULL);

            // upcase it so change notification will get it right

            UniToUpper(RenameName.Buffer, RenameName.Buffer, RenameName.Length);
            FsRtlNotifyFullReportChange(
                pNetRootEntry->NetRoot.pNotifySync,
                &pNetRootEntry->NetRoot.DirNotifyList,
                (PSTRING)&RenameName,
                (USHORT)(RenameName.Length -
                    CscSmbFcb.MinimalCscSmbFcb.LastComponentLength),
                NULL,
                NULL,
                (fFile)?FILE_NOTIFY_CHANGE_FILE_NAME:FILE_NOTIFY_CHANGE_DIR_NAME,
                FILE_ACTION_RENAMED_NEW_NAME,
                NULL);
        }
    }

    if (smbFcb->uniDfsPrefix.Buffer && RenameName.Buffer)
    {
        RxFreePool(RenameName.Buffer);
    }

//    DbgPrint("to %ws\n", Find32.cFileName);
    RxLog(("to hDirTo=%x hShadowTo=%x %ws uShadowStatusFrom=%x\n", hDirTo, hShadowTo, Find32.cFileName, uShadowStatusFrom));

    RxLog(("Status=%x \n\n", *Status));

    RxDbgTrace(-1, Dbg, ("MRxSmbCscRenameEpilogue exit-> %08lx %08lx\n", RxContext, *Status ));
    return;
}


VOID
MRxSmbCscCloseShadowHandle (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine closes the filehandle opened for CSC.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

//    DbgPrint("MRxSmbCscCloseShadowHandle %x\n", smbSrvOpen->hfShadow);

    ASSERT(smbSrvOpen->hfShadow != 0);

    CloseFileLocal((CSCHFILE)(smbSrvOpen->hfShadow));

    smbSrvOpen->hfShadow = 0;

    if (smbSrvOpen->Flags & SMB_SRVOPEN_FLAG_LOCAL_OPEN)
    {
        ASSERT(smbFcb->cntLocalOpens);
        smbFcb->cntLocalOpens--;
    }

    RxDbgTrace(0, Dbg, ("MRxSmbCscCloseShadowHandle\n"));
}

NTSTATUS
MRxSmbCscFixupFindFirst (
    PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange
    )
/*++

Routine Description:

   This routine is called from the simplesyncT2 builder/sender to fixup
   the t2 request before it's sent. the deal is that the parameters section
   has to be built up in part but i don't want to preallocate. so, i pass in
   a dummy (but valid pointer) and then drop in the actual parameters
   here.

Arguments:


Return Value:


Notes:

    We will use the smbbuf for everything here. First, we use it for sending
    and receiving. at the end of receiving, the FILE_BOTH_INFORMATION will be
    in the buffer and this will be recomposed into a w32_find buffer in the
    same buffer. if we find for any reason that we can't do this (buffer too
    small, send/rcv doesn't work, whatever) then we'll nuke the shadow and it
    will have to be reloaded.


--*/
{
    PRX_CONTEXT RxContext = OrdinaryExchange->RxContext;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_HEADER SmbHeader = (PSMB_HEADER)StufferState->BufferBase;
    PREQ_TRANSACTION  TransactRequest = (PREQ_TRANSACTION)(SmbHeader+1);
    ULONG ParameterCount = SmbGetUshort(&TransactRequest->ParameterCount);
    ULONG ParameterOffset = SmbGetUshort(&TransactRequest->ParameterOffset);
    PBYTE Parameters = ((PBYTE)(SmbHeader))+ParameterOffset;
    REQ_FIND_FIRST2 FindFirst;
    NTSTATUS Status=STATUS_SUCCESS;
    PSMBCE_SERVER   pServer = NULL;

    RxDbgTrace(0, Dbg, ("MRxSmbCscFixupFindFirst %08lx %08lx %08lx %08lx\n",
        OrdinaryExchange,ParameterCount,ParameterOffset,Parameters));

    // SearchAttributes is hardcoded to the magic number 0x16
    FindFirst.SearchAttributes = (SMB_FILE_ATTRIBUTE_DIRECTORY |
                  SMB_FILE_ATTRIBUTE_SYSTEM |
                  SMB_FILE_ATTRIBUTE_HIDDEN);

    FindFirst.SearchCount = 1;

    FindFirst.Flags = (SMB_FIND_CLOSE_AFTER_REQUEST |
               SMB_FIND_CLOSE_AT_EOS |
               SMB_FIND_RETURN_RESUME_KEYS);

    FindFirst.InformationLevel = SMB_FIND_FILE_BOTH_DIRECTORY_INFO;

    FindFirst.SearchStorageType = 0;

    RtlCopyMemory (
    Parameters,
    &FindFirst,
    FIELD_OFFSET(REQ_FIND_FIRST2,Buffer[0]));
    pServer = SmbCeGetExchangeServer(OrdinaryExchange);

    ASSERT(pServer);

    if (FlagOn(pServer->DialectFlags,DF_UNICODE))
    {

        ASSERT(FlagOn(SmbHeader->Flags2,SMB_FLAGS2_UNICODE));

        RtlCopyMemory(
            Parameters + FIELD_OFFSET(REQ_FIND_FIRST2,Buffer[0]),
            OrdinaryExchange->pPathArgument1->Buffer,
            OrdinaryExchange->pPathArgument1->Length);

        SmbPutUshort(
            (Parameters +
             FIELD_OFFSET(REQ_FIND_FIRST2,Buffer[0]) +
             OrdinaryExchange->pPathArgument1->Length),
            0); //traiing null
    }
    else
    {
        OEM_STRING OemString;

        OemString.Length =
        OemString.MaximumLength =
            (USHORT)( StufferState->BufferLimit - Parameters  - sizeof(CHAR));

        OemString.Buffer = (Parameters + FIELD_OFFSET(REQ_FIND_FIRST2,Buffer[0]));

        if (FlagOn(SmbHeader->Flags,SMB_FLAGS_CASE_INSENSITIVE) &&
            !FlagOn(SmbHeader->Flags2,SMB_FLAGS2_KNOWS_LONG_NAMES)) {
            Status = RtlUpcaseUnicodeStringToOemString(
                             &OemString,
                             OrdinaryExchange->pPathArgument1,
                             FALSE);
        } else {
            Status = RtlUnicodeStringToOemString(
                             &OemString,
                             OrdinaryExchange->pPathArgument1,
                             FALSE);
        }

        if (!NT_SUCCESS(Status)) {
            ASSERT(!"BufferOverrun");
            return(RX_MAP_STATUS(BUFFER_OVERFLOW));
        }

        OemString.Length = (USHORT)RtlxUnicodeStringToOemSize(OrdinaryExchange->pPathArgument1);

        ASSERT(OemString.Length);

        *(Parameters + FIELD_OFFSET(REQ_FIND_FIRST2,Buffer[0])+OemString.Length-1) = 0;
    }

    return(Status);
}

typedef  FILE_BOTH_DIR_INFORMATION SMB_UNALIGNED *MRXSMBCSC_FILE_BOTH_DIR_INFORMATION;
VOID
MRxSmbCscLocateAndFillFind32WithinSmbbuf(
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

   When this routine is called, the associated smbbuf contains a findfirst
   response with the FILE_BOTH_INFORMATION aboard. This routine first locates
   a position in the smbbuf to hold a find32. Then, the information is
   converted from the NT format for use with the shadow routines.


Arguments:


Return Value:

    Find32 - The ptr to the find32 (actually, the smbbuf!)

Notes:


--*/
{
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_HEADER SmbHeader = (PSMB_HEADER)StufferState->BufferBase;
    PRESP_TRANSACTION TransactResponse = (PRESP_TRANSACTION)(SmbHeader+1);
    ULONG DataOffset,FileNameLength,ShortNameLength;
    _WIN32_FIND_DATA *Find32;
    PBYTE AlternateName;
    MRXSMBCSC_FILE_BOTH_DIR_INFORMATION BothDirInfo;
    PSMBCE_SERVER   pServer = NULL;

    //first, we have to get a potentially unaligned ptr to the bothdirinfo
    DataOffset = SmbGetUshort(&TransactResponse->DataOffset);

    AlternateName = ((PBYTE)SmbHeader);
    BothDirInfo = (MRXSMBCSC_FILE_BOTH_DIR_INFORMATION)(((PBYTE)SmbHeader)+DataOffset);
    FileNameLength = SmbGetUlong(&BothDirInfo->FileNameLength);
    ShortNameLength = BothDirInfo->ShortNameLength;
    RxDbgTrace(0, Dbg, ("MRxSmbCscLocateAndFillFind32WithinSmbbuf offset=%08lx %08lx %08lx\n",
        DataOffset,FileNameLength,ShortNameLength));


    //save the alternate name info in the very beginning of the buffer..that
    //way, the copy of the full name will not destroy it
    if (ShortNameLength != 0) {
        RtlCopyMemory(
            AlternateName,
            &BothDirInfo->ShortName[0],
            ShortNameLength);
    }


    Find32 = (_WIN32_FIND_DATA *)(AlternateName + LongAlign(sizeof(Find32->cAlternateFileName)));
    Find32->dwFileAttributes = SmbGetUlong(&BothDirInfo->FileAttributes);
    Find32->ftCreationTime.dwLowDateTime = SmbGetUlong(&BothDirInfo->CreationTime.LowPart);
    Find32->ftCreationTime.dwHighDateTime = SmbGetUlong(&BothDirInfo->CreationTime.HighPart);
    Find32->ftLastAccessTime.dwLowDateTime = SmbGetUlong(&BothDirInfo->LastAccessTime.LowPart);
    Find32->ftLastAccessTime.dwHighDateTime = SmbGetUlong(&BothDirInfo->LastAccessTime.HighPart);
    Find32->ftLastWriteTime.dwLowDateTime = SmbGetUlong(&BothDirInfo->LastWriteTime.LowPart);
    Find32->ftLastWriteTime.dwHighDateTime = SmbGetUlong(&BothDirInfo->LastWriteTime.HighPart);
    Find32->nFileSizeLow = SmbGetUlong(&BothDirInfo->EndOfFile.LowPart);
    Find32->nFileSizeHigh = SmbGetUlong(&BothDirInfo->EndOfFile.HighPart);

    pServer = SmbCeGetExchangeServer(OrdinaryExchange);

    ASSERT(pServer);

    if (FlagOn(pServer->DialectFlags,DF_UNICODE))
    {
        //copy the full name....don't forget the NULL
        RtlCopyMemory (
            &Find32->cFileName[0],
            &BothDirInfo->FileName[0],
            FileNameLength );

        Find32->cFileName[FileNameLength/sizeof(WCHAR)] = 0;

        //finally, copy the shortname...don't forget the null
        RtlCopyMemory(
            &Find32->cAlternateFileName[0],
            AlternateName,
            ShortNameLength );

            Find32->cAlternateFileName[ShortNameLength/sizeof(WCHAR)] = 0;
    }
    else
    {
        UNICODE_STRING  strUni;
        OEM_STRING      strOem;
        NTSTATUS Status;

        strOem.Length = strOem.MaximumLength = (USHORT)FileNameLength;
        strOem.Buffer = (PBYTE)&BothDirInfo->FileName[0];

        strUni.Length =  (USHORT)RtlxOemStringToUnicodeSize(&strOem);
        strUni.MaximumLength = (USHORT)sizeof(Find32->cFileName);
        strUni.Buffer = Find32->cFileName;

        Status = RtlOemStringToUnicodeString(&strUni, &strOem, FALSE);
        ASSERT(Status == STATUS_SUCCESS);

        Find32->cFileName[strUni.Length/sizeof(WCHAR)];

        strOem.Length = strOem.MaximumLength = (USHORT)ShortNameLength;
        strOem.Buffer = AlternateName;

        strUni.Length = (USHORT)RtlxOemStringToUnicodeSize(&strOem);
        strUni.MaximumLength = (USHORT)sizeof(Find32->cAlternateFileName);
        strUni.Buffer = Find32->cAlternateFileName;

        Status = RtlOemStringToUnicodeString(&strUni, &strOem, FALSE);

        if (Status != STATUS_SUCCESS)
        {
            DbgPrint("oem=%x, uni=%x Status=%x\n", &strUni, &strOem, Status);
            ASSERT(FALSE);
        }

        Find32->cAlternateFileName[strUni.Length/sizeof(WCHAR)];
        ASSERT(Find32->cFileName[0]);
    }

    OrdinaryExchange->Find32WithinSmbbuf = Find32;

    RxDbgTrace(0, Dbg, ("MRxSmbCscLocateAndFillFind32WithinSmbbuf size,name=%08lx %ws\n",
        Find32->nFileSizeLow, &Find32->cFileName[0]));

    return;
}


NTSTATUS
MRxSmbCscGetFileInfoFromServerWithinExchange (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    PUNICODE_STRING FileName OPTIONAL
    )
/*++

Routine Description:

   This routine reads information about a file; it may have been locally
   modified or it may be in the process of having a showdow created. in any
   case, the info is returned as a pointer to a Find32 structure. The find32
   structure is contained within the smbbuf of the exchange.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    We will use the smbbuf for everything here. First, we use it for sending
    and receiving. at the end of receiving, the FILE_BOTH_INFORMATION will be
    in the buffer and this will be recomposed into a w32_find buffer in the
    same buffer. if we find for any reason that we can't do this (buffer too
    small, send/rcv doesn't work, whatever) then we'll nuke the shadow and it
    will have to be reloaded.


--*/
{
    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;

    ULONG ParameterLength, TotalLength;
    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;

    if (FileName!=NULL) {
        OrdinaryExchange->pPathArgument1 = FileName; //so it can be found later
    } else {
        ASSERT(OrdinaryExchange->pPathArgument1 != NULL);
        FileName = OrdinaryExchange->pPathArgument1;
    }

    ParameterLength = FileName->Length + sizeof(WCHAR);
    ParameterLength += FIELD_OFFSET(REQ_FIND_FIRST2,Buffer[0]);

    TotalLength = sizeof(SMB_HEADER) + FIELD_OFFSET(REQ_TRANSACTION,Buffer[0]);  //basic
    TotalLength += sizeof(WORD); //bytecount
    TotalLength = LongAlign(TotalLength); //move past pad
    TotalLength += LongAlign(ParameterLength);

    RxDbgTrace(+1, Dbg, ("MRxSmbCscGetFileInfoFromServerWithinExchange %08lx %08lx %08lx\n",
      RxContext,TotalLength,ParameterLength));

    if (TotalLength > OrdinaryExchange->SmbBufSize) {
        goto FINALLY;
    }

    //note that the parameter buffer is not the actual parameters BUT
    //it is a valid buffer. CODE.IMPROVEMENT perhaps the called routine
    //should take cognizance of the passed fixup routine and not require
    //a valid param buffer and not do the copy.

    Status = __MRxSmbSimpleSyncTransact2(
         SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
         SMBPSE_OETYPE_T2_FOR_ONE_FILE_DIRCTRL,
         TRANS2_FIND_FIRST2,
         StufferState->ActualBufferBase,ParameterLength,
         NULL,0,
         MRxSmbCscFixupFindFirst
         );

    if (Status!=STATUS_SUCCESS) {
        goto FINALLY;
    }

    MRxSmbCscLocateAndFillFind32WithinSmbbuf(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS);

FINALLY:
    RxDbgTrace(-1, Dbg, ("MRxSmbCscGetFileInfoFromServerWithinExchange %08lx %08lx\n",
        RxContext,Status));

    return(Status);

}

VOID
MRxSmbCscUpdateShadowFromClose (
      SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
      )
/*++

Routine Description:

   This routine updates the shadow information after a close.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    If anything every goes wrong, we just don't update. this will cause
    the shadow to be reload later.


--*/
{
    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;

    RxCaptureFcb;RxCaptureFobx;

    PMRX_SMB_FCB      smbFcb     = MRxSmbGetFcbExtension(capFcb);

    _WIN32_FIND_DATA *Find32 = NULL;
    ULONG uStatus;
    int TruncateRetVal = -1;
    _WIN32_FIND_DATA *AllocatedFind32 = NULL;

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PSMBCEDB_SERVER_ENTRY   pServerEntry;

    PMRX_SRV_OPEN     SrvOpen    = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    BOOLEAN Disconnected;

    RxDbgTrace(+1, Dbg, ("MRxSmbCscUpdateShadowFromClose %08lx\n",
      RxContext));

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    pServerEntry  = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    if (smbFcb->hShadow==0) {
        if (Disconnected) {
            if (smbSrvOpen->hfShadow != 0){
                MRxSmbCscCloseShadowHandle(RxContext);
            }
        }

        RxDbgTrace(-1, Dbg,
            ("MRxSmbCscUpdateShadowFromClose shadowzero %08lx\n",RxContext));

        return;
    }

    if (smbFcb->ContainingFcb->FcbState & FCB_STATE_ORPHANED)
    {
        if (smbSrvOpen->hfShadow != 0){
            MRxSmbCscCloseShadowHandle(RxContext);
        }

        RxDbgTrace(-1, Dbg,
            ("MRxSmbCscUpdateShadowFromClose Orphaned FCB %x\n", smbFcb->ContainingFcb));

        return;
    }

    EnterShadowCritRx(RxContext);

    if (!Disconnected) {
        // If the file has been modified, we need to get the new timestamp
        // from the server. By the time we come here the file has already been
        // closed on the server, so we can safely get the new timestamp.

        if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED)){
            NTSTATUS LocalStatus;

            LeaveShadowCritRx(RxContext);

            LocalStatus = MRxSmbCscGetFileInfoFromServerWithinExchange(
                       SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                       GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext));

            if (LocalStatus == STATUS_SUCCESS) {
                Find32 = OrdinaryExchange->Find32WithinSmbbuf;
                RxLog(("Fromclose hShadow=%x l=%x h=%x\n", smbFcb->hShadow, Find32->ftLastWriteTime.dwLowDateTime, Find32->ftLastWriteTime.dwHighDateTime));
            } else {
                RxLog(("MRxSmbCscGetFileInfoFromServerWithinExchange returned LocalStatus\n"));
            }

            EnterShadowCritRx(RxContext);
        }

        if(GetShadowInfo(smbFcb->hParentDir,
                 smbFcb->hShadow,
                 NULL,
                 &uStatus, NULL) < SRET_OK)
        {
            goto FINALLY;
        }
        

        // in connected mode for a sparsely filled file that is not corrupt
        // ie. no writes have failed on it, if the original size and the
        // current size match, remove the sparse marking
        
        // This optimization was added for notepad case in which when the app
        // opens the file it reads the entire file. Therefore CSC does not need 
        // to fill the file and therefore we should clear the SPARSE flag. - NavjotV

        //WinSE Bug- 25843
        // We want to do this only if file is not Truncated in an earlier
        // create. When we truncate the file we want it to stay SPARSE till 
        // we actually fill the file - NavjotV


        if((NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE) &&
           !smbFcb->ShadowIsCorrupt &&
           !FlagOn(smbFcb->MFlags, SMB_FCB_FLAG_CSC_TRUNCATED_SHADOW) && 
           (uStatus & SHADOW_SPARSE))
        {
            LARGE_INTEGER liTemp;

            if(GetSizeHSHADOW(
                smbFcb->hShadow,
                &(liTemp.HighPart),
                &(liTemp.LowPart))>=0)
            {
                
                if ((liTemp.HighPart == smbFcb->OriginalShadowSize.HighPart)&&
                    (liTemp.LowPart == smbFcb->OriginalShadowSize.LowPart))
                {
                    uStatus &= ~SHADOW_SPARSE;
                    smbFcb->ShadowStatus &= ~SHADOW_SPARSE;
//                    RxDbgTrace(0, Dbg, ("hShadow=%x unsparsed\r\n", smbFcb->hShadow));
                    RxLog(("hShadow=%x unsparsed\r\n", smbFcb->hShadow));
                }
            }
        }
    } else {
    // disconnected operation

        if (smbFcb->hParentDir==0xffffffff) {
            goto FINALLY;
        }

        AllocatedFind32 = (_WIN32_FIND_DATA *)RxAllocatePoolWithTag(
                            PagedPool | POOL_COLD_ALLOCATION,
                            sizeof(_WIN32_FIND_DATA),
                            RX_MISC_POOLTAG);
        if (AllocatedFind32==NULL) {
            goto FINALLY;
        }

        Find32 = AllocatedFind32;

        if (GetShadowInfo(
            smbFcb->hParentDir,
            smbFcb->hShadow,
            Find32,
            &uStatus,
            NULL) < SRET_OK) {
            goto FINALLY; //bailout;
        }

        if (IsFile(Find32->dwFileAttributes))
        {
            GetSizeHSHADOW(
                smbFcb->hShadow,
                &(Find32->nFileSizeHigh),
                &(Find32->nFileSizeLow));
        }
        else
        {
            Find32->nFileSizeHigh = Find32->nFileSizeLow = 0;
        }

    }

    // If the shadow has become stale due to write errors
    // or has become dirty because of writes on a complete file
    // or sparse because of writes beyond what we have cached
    // we need to mark it as such

    uStatus |= (smbFcb->ShadowStatus & SHADOW_MODFLAGS);

    if (Disconnected && FlagOn(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED))
    {
        uStatus |= SHADOW_DIRTY;
    }

    if (Disconnected && FlagOn(smbFcb->LocalFlags, FLAG_FDB_SHADOW_SNAPSHOTTED))
    {
        uStatus |= SHADOW_DIRTY;
    }

    if (Find32) {
        smbFcb->OriginalShadowSize.LowPart = Find32->nFileSizeLow;
        smbFcb->OriginalShadowSize.HighPart = Find32->nFileSizeHigh;
    }

    if (smbFcb->ShadowIsCorrupt) {
        TruncateRetVal = TruncateDataHSHADOW(smbFcb->hParentDir, smbFcb->hShadow);
        if (TruncateRetVal>=SRET_OK) {
            // Set status flags to indicate sparse file
            uStatus |= SHADOW_SPARSE;
        }
    }


    if (Disconnected &&
        FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED) &&
        !FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_SHADOW_LWT_MODIFIED))
    {
        GetSystemTime(&(Find32->ftLastWriteTime));
    }

    if (SetShadowInfo(
        smbFcb->hParentDir,
        smbFcb->hShadow,
        Find32,
        uStatus,
        ( SHADOW_FLAGS_ASSIGN |
        ((Disconnected) ?
        SHADOW_FLAGS_DONT_UPDATE_ORGTIME :
        0)
        )) < SRET_OK)  {

        goto FINALLY;
    }

    if (TruncateRetVal>=SRET_OK) {
        smbFcb->ShadowIsCorrupt = FALSE;
    }

    if (Disconnected) {
        if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_SHADOW_MODIFIED)) {
            MarkShareDirty(&smbFcb->sCscRootInfo.ShareStatus, smbFcb->sCscRootInfo.hShare);
        }

        if (smbSrvOpen->hfShadow != 0){
            MRxSmbCscCloseShadowHandle(RxContext);
        }
    }

FINALLY:
    LeaveShadowCritRx(RxContext);

    if (AllocatedFind32!=NULL) {
        RxFreePool(AllocatedFind32);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscUpdateShadowFromClose %08lx\n",
        RxContext));

}

VOID
MRxSmbCscDeallocateForFcb (
    IN OUT PMRX_FCB pFcb
    )
/*++

Routine Description:

   This routine tears down the Csc part of a netroot. Currently, all it does is
   to pull the netroot out of the list of csc netroots.

Arguments:

    pNetRootEntry -

Return Value:

Notes:


--*/
{
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(pFcb);
    PMRX_NET_ROOT NetRoot = pFcb->pNetRoot;

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = NULL;

    if(!MRxSmbIsCscEnabled ||
       (fShadow == 0)
        ) {
        pFcb->fMiniInited = FALSE; // clean it up on shutdown
        return;
    }

    if( !(NodeType(pFcb)== RDBSS_NTC_STORAGE_TYPE_DIRECTORY ||
      NodeType(pFcb)== RDBSS_NTC_STORAGE_TYPE_FILE ||
      NodeType(pFcb)== RDBSS_NTC_STORAGE_TYPE_UNKNOWN))
    {
        return;
    }

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    
    if (pNetRootEntry->NetRoot.NetRootType != NET_ROOT_DISK)
    {
        return;
    }

    EnterShadowCrit();
    
#if defined(BITCOPY)

    if (smbFcb && smbFcb->lpDirtyBitmap) {
        LPSTR strmName;
        // Save Bitmap to disk and Delete Bitmap      
        strmName = FormAppendNameString(lpdbShadow,
                                smbFcb->hShadow,
                                CscBmpAltStrmName);
        if (strmName != NULL) {
            if (smbFcb->hShadow >= 0x80000000) {
                // Write only to file inodes
                CscBmpWrite(smbFcb->lpDirtyBitmap, strmName);
            }
            CscBmpDelete(&((LPCSC_BITMAP)(smbFcb->lpDirtyBitmap)));
            ExFreePool(strmName);
        }
    }
#endif // defined(BITCOPY)

    try
    {
        if (smbFcb->ShadowReverseTranslationLinks.Flink != 0) {

            RxDbgTrace(+1, Dbg, ("MRxSmbCscDeallocateForFcb...%08lx %08lx %08lx %08lx\n",
                            pFcb,
                            smbFcb->hShadow,
                            smbFcb->hParentDir,
                            smbFcb->ShadowReverseTranslationLinks.Flink ));

            ValidateSmbFcbList();
            ASSERT(pFcb->fMiniInited);
            pFcb->fMiniInited = FALSE;
            MRxSmbCscRemoveReverseFcbTranslation(smbFcb);

            RxDbgTrace(-1, Dbg, ("MRxSmbCscDeallocateForFcb exit\n"));
        } else {
            ASSERT(smbFcb->ShadowReverseTranslationLinks.Flink == 0);
        }

        if(FlagOn(smbFcb->LocalFlags, FLAG_FDB_DELETE_ON_CLOSE))
        {
            RxLog(("Dealloc: Deleting hShadow=%x %x %x \n", smbFcb->hShadow, pFcb, smbFcb));
            DeleteShadowHelper(FALSE, smbFcb->hParentDir, smbFcb->hShadow);
            smbFcb->hParentDir = smbFcb->hShadow = 0;
        }
        // if there are any Dfs reverse mapping structures, free them
        if (smbFcb->uniDfsPrefix.Buffer)
        {
            FreeMem(smbFcb->uniDfsPrefix.Buffer);
            ASSERT(smbFcb->uniActualPrefix.Buffer);
            FreeMem(smbFcb->uniActualPrefix.Buffer);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        if(pFcb->fMiniInited)
        {
            DbgPrint("CSCFcbList messed up \n");
            ASSERT(FALSE);
        }
        goto FINALLY;
    }
FINALLY:
    LeaveShadowCrit();

    return;
}

PMRX_SMB_FCB
MRxSmbCscRecoverMrxFcbFromFdb (
    IN PFDB Fdb
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    if (Fdb==NULL) {
        return NULL;
    }

    return CONTAINING_RECORD(
           &Fdb->usFlags,
           MRX_SMB_FCB,
           ShadowStatus
           );

}

PFDB MRxSmbCscFindFdbFromHShadow (
    IN HSHADOW hShadow
    )
/*++

Routine Description:

   This routine looks thru the current open mrxsmbfcbs and returns a mrxsmbfcb
   that corresponds to the HSHADOW passed. In the interest of not mucking with
   the w95 code, we cast this pointer into a PFDB in such a way that
   the the shadowstatus in the mrxsmbfcb lines up with the usFlags in PFDB.

Arguments:

Return Value:

Notes:


--*/
{
    PLIST_ENTRY pListEntry;

    DbgDoit(ASSERT(vfInShadowCrit));

    pListEntry = xCscFcbsList.Flink;
    while (pListEntry != &xCscFcbsList) {
        PMRX_SMB_FCB smbFcb;

        smbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                        pListEntry,
                        MRX_SMB_FCB,
                        ShadowReverseTranslationLinks);

        if (((smbFcb->hShadow == hShadow)||(smbFcb->hShadowRenamed == hShadow)) &&
            (!(smbFcb->ContainingFcb->FcbState & FCB_STATE_ORPHANED)))
        {
            PFDB Fdb;
            PUSHORT pShadowStatus = &smbFcb->ShadowStatus;
            ASSERT ( sizeof(Fdb->usFlags) == sizeof (USHORT) );
            Fdb = CONTAINING_RECORD(pShadowStatus,FDB,usFlags);
            return Fdb;
        }

        pListEntry = pListEntry->Flink;
    }

    return NULL;
}

PRESOURCE
MRxSmbCscFindResourceFromHandlesWithModify (
    IN HSHARE  hShare,
    IN HSHADOW  hRoot,
    IN USHORT usLocalFlagsIncl,
    IN USHORT usLocalFlagsExcl,
    OUT PULONG ShareStatus,
    OUT PULONG DriveMap,
    IN  ULONG uStatus,
    IN  ULONG uOp
   )
/*++

Routine Description:

   This routine looks thru the currently connected netrootentries and
   returns the one that corresponds EITHER to the HSHADOW passed or to
   the HSHARE passed. In the interest of not mucking with the w95 code,
   we cast this pointer into a PRESOURCE. we also return the share
   status as well as the drivemap.....we dont know the drivemap
   but we could get it by walking the list of vnetroots. It is not used anywhere by the UI

   If the uOp is not 0xffffffff, then we modify the status as well as
   returning it.

Arguments:

    IN HSHARE  hShare - the share handle to look for
    IN HSHADOW  hRoot - the rootdir handle to look for
    IN USHORT usLocalFlagsIncl - make sure that some of these flags are included (0xffff mean
                         include any flags)
    IN USHORT usLocalFlagsExcl - make sure that none of these flags are included
    OUT PULONG ShareStatus - a pointer to where we will store the status
    OUT PULONG DriveMap - a pointer to where we will store the drivemap info
    IN  ULONG uStatus - input status to use in the "bit operations"
    IN  ULONG uOp - which operation

Return Value:

Notes:

   The flags passed here are used in one ioctl to either exclude or include
   connected or disconnected resources as appropriate.


--*/

{
    PRESOURCE pResource = NULL;
    BOOLEAN TableLockHeld = FALSE;
    PLIST_ENTRY ListEntry;

    RxDbgTrace(+1, Dbg, ("MRxSmbCscFindResourceFromRoot...%08lx\n",hRoot));
    DbgDoit(ASSERT(vfInShadowCrit));
    if ((hRoot==0) && (hShare==0)) {
        return NULL;
    }

    //we can't hold this....sigh
    LeaveShadowCrit();

    try {

        RxAcquirePrefixTableLockExclusive( &RxNetNameTable, TRUE);
        TableLockHeld = TRUE;

        if (IsListEmpty( &RxNetNameTable.MemberQueue )) {
            try_return(pResource = NULL);
        }

        if (ShareStatus)
        {
            *ShareStatus = 0;
        }

        ListEntry = RxNetNameTable.MemberQueue.Flink;
        for (;ListEntry != &RxNetNameTable.MemberQueue;) {
            PVOID Container;
            PRX_PREFIX_ENTRY PrefixEntry;
            PMRX_NET_ROOT NetRoot;
            PMRX_V_NET_ROOT VNetRoot;
            PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
            PSMBCEDB_SERVER_ENTRY pServerEntry;
            PUSHORT ThisShareStatus;

            PrefixEntry = CONTAINING_RECORD( ListEntry,
                             RX_PREFIX_ENTRY,
                             MemberQLinks );
            ListEntry = ListEntry->Flink;
            ASSERT (NodeType(PrefixEntry) == RDBSS_NTC_PREFIX_ENTRY);
            Container = PrefixEntry->ContainingRecord;
            RxDbgTrace(0, Dbg,
            ("---> ListE PfxE Container Name  %08lx %08lx %08lx %wZ\n",
                ListEntry, PrefixEntry, Container, &PrefixEntry->Prefix));

            switch (NodeType(Container)) {
                case RDBSS_NTC_NETROOT :
                NetRoot = (PMRX_NET_ROOT)Container;

                RxDbgTrace(0, Dbg,
                ("NetRoot->pSrvCall=0x%x, NetRoot->Type=%d, NetRoot->Context=0x%x, NetRoot->pSrvCall->RxDeviceObject=0x%x\n",
                    NetRoot->pSrvCall, NetRoot->Type, NetRoot->Context, NetRoot->pSrvCall->RxDeviceObject));

                if ((NetRoot->pSrvCall == NULL) ||
                    (NetRoot->Type != NET_ROOT_DISK) ||
                    (NetRoot->Context == NULL) ||
                    (NetRoot->pSrvCall->RxDeviceObject != MRxSmbDeviceObject)) {
                    RxDbgTrace(0, Dbg,("Skipping \n"));
                    continue;
                }

                pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
                ThisShareStatus = &pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus;
                pServerEntry = SmbCeGetAssociatedServerEntry(NetRoot->pSrvCall);

                RxDbgTrace(0, Dbg,
                ("pNetRootEntry->NetRoot.CscEnabled=%d, pNetRootEntry->NetRoot.sCscRootInfo.hRootDir=0x%x, pNetRootEntry->NetRoot.sCscRootInfo.hShare=0x%x\n",
                    pNetRootEntry->NetRoot.CscEnabled, pNetRootEntry->NetRoot.sCscRootInfo.hRootDir, pNetRootEntry->NetRoot.sCscRootInfo.hShare
                    ));

                if ((hRoot!=0xffffffff)||(hShare != 0xffffffff))
                {
                    if (pNetRootEntry->NetRoot.CscEnabled &&
                        ((pNetRootEntry->NetRoot.sCscRootInfo.hRootDir == hRoot) ||
                        (pNetRootEntry->NetRoot.sCscRootInfo.hShare == hShare) )) {

                        if (*ThisShareStatus & usLocalFlagsExcl) {

                            RxDbgTrace(0, Dbg,("Skipping *ThisShareStatus=\n", *ThisShareStatus));
                            continue;
                        }

                        if ((usLocalFlagsIncl==0xffff)
                            || (*ThisShareStatus & usLocalFlagsIncl)) {

                            switch (mBitOpShadowFlags(uOp)) {
                                case SHADOW_FLAGS_ASSIGN:
                                *ThisShareStatus = (USHORT)uStatus;
                                break;

                                case SHADOW_FLAGS_OR:
                                *ThisShareStatus |= (USHORT)uStatus;
                                break;

                                case SHADOW_FLAGS_AND:
                                *ThisShareStatus &= (USHORT)uStatus;
                                break;
                            }

                            *ShareStatus |= (*ThisShareStatus | SHARE_CONNECTED);

                            if(SmbCeIsServerInDisconnectedMode(pServerEntry))
                            {
                                *ShareStatus |= SHARE_DISCONNECTED_OP;

                            }

                            if (pServerEntry->Server.IsPinnedOffline == TRUE)
                                *ShareStatus |= SHARE_PINNED_OFFLINE;

                            RxDbgTrace(0, Dbg,("Count of srvopens=%d\n", pServerEntry->Server.NumberOfSrvOpens));

                            *DriveMap = 0; //not used anywhere

                            try_return (pResource = (PRESOURCE)pNetRootEntry);
                        }
                    }
                }
                else // hShare and hRoot are 0xffffffff, this means we are looping
                {
                    if (mBitOpShadowFlags(uOp) == SHADOW_FLAGS_AND)
                    {
                        if (pNetRootEntry->NetRoot.sCscRootInfo.hRootDir)
                        {
                            pNetRootEntry->NetRoot.sCscRootInfo.hRootDir = 0;
                            pNetRootEntry->NetRoot.sCscRootInfo.hShare = 0;
                        }
                    }
                }
            continue;
            case RDBSS_NTC_SRVCALL :
            continue;

            case RDBSS_NTC_V_NETROOT :
            VNetRoot = (PMRX_V_NET_ROOT)Container;

            // NTRAID#455236-1/31/2000-shishirp we should'nt be using this field here, it is strictly meant
            // for the wrapper
            if (((PV_NET_ROOT)Container)->Condition == Condition_Good)
            {
                if (VNetRoot->Context != NULL) {
                    pNetRootEntry = ((PSMBCE_V_NET_ROOT_CONTEXT)VNetRoot->Context)->pNetRootEntry;
                    RxDbgTrace(0, Dbg,("RDBSS_NTC_V_NETROOT: VNetRoot=%x, pNetRootEntry=%x\r\n",
                                VNetRoot, pNetRootEntry));

                    if ((hRoot!=0xffffffff)||(hShare != 0xffffffff))
                    {
                         if ((pNetRootEntry != NULL) &&
                             pNetRootEntry->NetRoot.CscEnabled &&
                             ((pNetRootEntry->NetRoot.sCscRootInfo.hRootDir == hRoot) ||
                             (pNetRootEntry->NetRoot.sCscRootInfo.hShare == hShare))) {

                         }
                    }
                    else
                    {
                        if (pNetRootEntry->NetRoot.sCscRootInfo.hRootDir)
                        {
                            pNetRootEntry->NetRoot.sCscRootInfo.hRootDir = 0;
                            pNetRootEntry->NetRoot.sCscRootInfo.hShare = 0;
                        }
                    }
                }
            }

            default:
            continue;
        }
    }

    try_return(pResource = NULL);

try_exit:NOTHING;

    } finally {

        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
        }

        EnterShadowCrit();
        if (pResource && ((hShare != 0xffffffff) || (hRoot != 0xffffffff)))
        {
            if (ShareStatus)
            {
                SetOfflineOpenStatusForShare(hShare, hRoot, ShareStatus);
            }
        }
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscFindResourceFromRoot...%08lx\n",pResource));

    return(pResource);
}

#undef GetShadowInfo
#undef SetShadowInfo

// this is just a simple wrapper function except that we pick off the rootdir case.
// ...see the recordmanager code for args
int PUBLIC
MRxSmbCscWrappedGetShadowInfo(
    HSHADOW hDir,
    HSHADOW hNew,
    LPFIND32 lpFind32,
    ULONG far *lpuFlags,
    LPOTHERINFO lpOI)
{
    if (hDir != -1) {
        return(GetShadowInfo(hDir, hNew, lpFind32, lpuFlags, lpOI));
    }

    //otherwise....just make it up...........
    RtlZeroMemory(
    lpFind32,
    sizeof(*lpFind32));

    lpFind32->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;
    *lpuFlags = SHADOW_SPARSE;

    return(SRET_OK);
}


// this is just a simple wrapper function except that we pick off the rootdir case.
// ...see the recordmanager code for args
int PUBLIC
MRxSmbCscWrappedSetShadowInfo(
    HSHADOW hDir,
    HSHADOW hNew,
    LPFIND32 lpFind32,
    ULONG uFlags,
    ULONG uOp)
{
    if (hDir == -1) {
        return(SRET_OK);
    }

    return(SetShadowInfo(hDir, hNew, lpFind32, uFlags, uOp));
}

USHORT  *
MRxSmbCscFindLocalFlagsFromFdb(
    PFDB    pFdb
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    PMRX_SMB_FCB smbFcb;
    PUSHORT pShadowStatus = &(pFdb->usFlags);

    DbgDoit(ASSERT(vfInShadowCrit));

    smbFcb = CONTAINING_RECORD(pShadowStatus,MRX_SMB_FCB,ShadowStatus);
    return (&(smbFcb->LocalFlags));
}

NTSTATUS
MRxSmbCscSetSecurityPrologue (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine is called when a set security call is made. It tries
    to set the ACL on the CSC cached version of the file.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{

#if defined(REMOTE_BOOT)
    RxCaptureFcb;

    _WIN32_FIND_DATA Find32;
    PMRX_SMB_FCB smbFcb;
    NTSTATUS Status;

    //
    // First we need to set the security descriptor on the CSC
    // version of the file, if one exists.
    //
    smbFcb = MRxSmbGetFcbExtension(capFcb);

    EnterShadowCritRx(RxContext);

    Status = MRxSmbCscCreateShadowFromPath(
                GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext),
                SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot),
                &Find32,
                NULL,
                CREATESHADOW_CONTROL_NOCREATE,
                &smbFcb->MinimalCscSmbFcb,
                RxContext,
                FALSE,
                NULL
                );   // not disconnected

    LeaveShadowCritRx(RxContext);

    if (Status == STATUS_SUCCESS) {

        Status = MRxSmbCscSetSecurityOnShadow(
             smbFcb->MinimalCscSmbFcb.hShadow,
             RxContext->SetSecurity.SecurityInformation,
             RxContext->SetSecurity.SecurityDescriptor);

        if (!NT_SUCCESS(Status)) {
            KdPrint(("MRxSmbCscSetSecurityPrologue: Could not set security (%lx) for %wZ: %lx\n", RxContext,
                GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext), Status));
        }

    } else {

        //
        //

        Status = STATUS_SUCCESS;

    }

    return Status;
#else
    return STATUS_SUCCESS;
#endif

}

VOID
MRxSmbCscSetSecurityEpilogue (
      IN OUT PRX_CONTEXT RxContext,
      IN OUT PNTSTATUS   Status
      )
/*++

Routine Description:

   This routine performs the tail of a set security operation for CSC.

   If the set failed, it tries to restore the old ACL on the file.

Arguments:

    RxContext - the RDBSS context

    Status - the overall status of the open

Return Value:

Notes:


--*/
{
    return;
}

// Table off which the parameter validation is driven
// there is some redundancy in this table, specifically, we could have only the flags
// and get rid of the other two fields.

CSC_IOCTL_ENTRY rgCscIoctlTable[] =
{
    {IOCTL_SHADOW_GETVERSION,       0,  0},
    {IOCTL_SHADOW_REGISTER_AGENT,   FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_UNREGISTER_AGENT, 0,  0},
    {IOCTL_SHADOW_GET_UNC_PATH,     FLAG_CSC_IOCTL_COPYPARAMS,  sizeof(COPYPARAMS)},
    {IOCTL_SHADOW_BEGIN_PQ_ENUM,    FLAG_CSC_IOCTL_PQPARAMS,    sizeof(PQPARAMS)},
    {IOCTL_SHADOW_END_PQ_ENUM,      FLAG_CSC_IOCTL_PQPARAMS,    sizeof(PQPARAMS)},
    {IOCTL_SHADOW_NEXT_PRI_SHADOW,  FLAG_CSC_IOCTL_PQPARAMS,    sizeof(PQPARAMS)},
    {IOCTL_SHADOW_PREV_PRI_SHADOW,  FLAG_CSC_IOCTL_PQPARAMS,    sizeof(PQPARAMS)},
    {IOCTL_SHADOW_GET_SHADOW_INFO,  FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_SET_SHADOW_INFO,  FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_CHK_UPDT_STATUS,  FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_DO_SHADOW_MAINTENANCE,   FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_COPYCHUNK,        FLAG_CSC_IOCTL_COPYCHUNKCONTEXT,    sizeof(COPYCHUNKCONTEXT)},
    {IOCTL_SHADOW_BEGIN_REINT,      FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_END_REINT,        FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_CREATE,           FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHADOW_DELETE,           FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_GET_SHARE_STATUS,       FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SET_SHARE_STATUS,       FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_ADDUSE,                  0,  0},  // not applicable on NT
    {IOCTL_DELUSE,                  0,  0},  // not applicable on NT
    {IOCTL_GETUSE,                  0,  0},  // not applicable on NT
    {IOCTL_SWITCHES,                FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_GETSHADOW,               FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_GETGLOBALSTATUS,         FLAG_CSC_IOCTL_GLOBALSTATUS,sizeof(GLOBALSTATUS)},
    {IOCTL_FINDOPEN_SHADOW,         FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_FINDNEXT_SHADOW,         FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_FINDCLOSE_SHADOW,        FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_GETPRIORITY_SHADOW,      FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SETPRIORITY_SHADOW,      FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_ADD_HINT,                FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_DELETE_HINT,             FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_FINDOPEN_HINT,           FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_FINDNEXT_HINT,           FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_FINDCLOSE_HINT,          FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_GET_IH_PRIORITY,         FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_GETALIAS_HSHADOW,        FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {_SHADOW_IOCTL_CODE(37), 0, 0}, // hole in the ioctl range
    {_SHADOW_IOCTL_CODE(38), 0, 0}, // hole in the ioctl range
    {_SHADOW_IOCTL_CODE(39), 0, 0}, // hole in the ioctl range
    {IOCTL_OPENFORCOPYCHUNK,                FLAG_CSC_IOCTL_COPYCHUNKCONTEXT,    sizeof(COPYCHUNKCONTEXT)},
    {IOCTL_CLOSEFORCOPYCHUNK,               FLAG_CSC_IOCTL_COPYCHUNKCONTEXT,    sizeof(COPYCHUNKCONTEXT)},
    {IOCTL_IS_SERVER_OFFLINE,               FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_TRANSITION_SERVER_TO_ONLINE,     FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_TRANSITION_SERVER_TO_OFFLINE,    FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_TAKE_SERVER_OFFLINE,             FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_NAME_OF_SERVER_GOING_OFFLINE,    FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)},
    {IOCTL_SHAREID_TO_SHARENAME,            FLAG_CSC_IOCTL_SHADOWINFO,  sizeof(SHADOWINFO)}
};

NTSTATUS
CaptureInputBufferIfNecessaryAndProbe(
    IN  DWORD               IoControlCode,
    IN  PRX_CONTEXT         pRxContext,
    IN  PBYTE               InputBuffer,
    IN  LPCAPTURE_BUFFERS   lpCapBuff,
    OUT PBYTE               *ppAuxBuf,
    OUT PBYTE               *ppOrgBuf,
    OUT PBYTE               *ppReturnBuffer
    )
/*++

Routine Description:

    This routine does the capturing if necessary and probing of the buffers.
    Note that because the csc ioctls are always called with METHOD_NEITHER
    buffering mode, we always execute the code below.

Arguments:

    IoControlCode   Ioctl code

    pRxContext      context which has all the info of the original ioctl call for IO subsystem

    InputBuffer     Input Buffer

    lpCapBuff       capture buffer passed in by the caller. If this ioctl needs capturing
                    then this buffer is used to capture the input buffer.
                    We use this in case of SHADOWINFO and COPYPARAMS structures being passed in
                    as only in these two case there are embedded pointers

    ppAuxBuf        if we needed to capture another part of the buffer (lpFind32 or lpBuffer),
                    this routine will allocate a buffer which will be passed back here, and
                    must be freed by the caller.

    ppReturnBuffer  either the input buffer itself, or lpCapBuff (if inputbuffer is captured)

Return Value:

Notes:


--*/
{
    int         indx;
    BOOL        fRet = FALSE;
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;
    KPROCESSOR_MODE requestorMode;

    indx = ((IoControlCode >> 2) & 0xfff) - SHADOW_IOCTL_ENUM_BASE;

    if((indx >=0 ) && (indx < sizeof(rgCscIoctlTable)/sizeof(CSC_IOCTL_ENTRY)))
    {

        *ppReturnBuffer = InputBuffer;

        if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_COPYCHUNKCONTEXT)
        {
            return(ValidateCopyChunkContext(pRxContext, IoControlCode));
        }

        if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_BUFFERTYPE_MASK)
        {
            try
            {
                ProbeForRead(InputBuffer,
                             rgCscIoctlTable[indx].dwLength,
                             1);

                ProbeForWrite(InputBuffer,
                             rgCscIoctlTable[indx].dwLength,
                             1);

                if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_COPYPARAMS)
                {
                    lpCapBuff->sCP = *(LPCOPYPARAMS)InputBuffer;
                    *ppReturnBuffer = (PBYTE)&(lpCapBuff->sCP);
                    Status = ValidateCopyParams(&(lpCapBuff->sCP));
                }
                else if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_SHADOWINFO)
                {
                    lpCapBuff->sSI = *(LPSHADOWINFO)InputBuffer;
                    *ppReturnBuffer = (PBYTE)&(lpCapBuff->sSI);
                    Status = ValidateShadowInfo(
                                IoControlCode,
                                &(lpCapBuff->sSI),
                                ppAuxBuf,
                                ppOrgBuf);
                }
                else
                {
                    Status = STATUS_SUCCESS;
                }

            }
            except(EXCEPTION_EXECUTE_HANDLER )
            {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        else
        {
            Status = STATUS_SUCCESS;
        }
    }

    return Status;
}



NTSTATUS
ValidateCopyParams(
    LPCOPYPARAMS    lpCP
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    if((CscProbeForReadWrite((PBYTE)lpCP->lpLocalPath, MAX_PATH*sizeof(USHORT)) == STATUS_SUCCESS)&&
        (CscProbeForReadWrite((PBYTE)lpCP->lpRemotePath, MAX_PATH*sizeof(USHORT)) == STATUS_SUCCESS)&&
        (CscProbeForReadWrite((PBYTE)lpCP->lpSharePath, MAX_SERVER_SHARE_NAME_FOR_CSC*2) == STATUS_SUCCESS))
    {
        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER;
}

NTSTATUS
ValidateShadowInfo(
    DWORD           IoControlCode,
    LPSHADOWINFO    lpSI,
    LPBYTE          *ppAuxBuf,
    LPBYTE          *ppOrgBuf
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    NTSTATUS Status;

    // by the time we get here, the SHADOWINFO strucuture has already been
    // probed

    // IOCTL_DO_SHADOW_MAINTENANCE has multiple suboperations, so we
    // deal them seperately.

    if (IoControlCode == IOCTL_DO_SHADOW_MAINTENANCE)
    {
        // DbgPrint("SHADOW_OP:0x%x\n", lpSI->uOp);
        switch(lpSI->uOp)
        {
            case SHADOW_REDUCE_REFPRI:              //  2
//          case SHADOW_RECALC_IHPRI:               //  5
            case SHADOW_PER_THREAD_DISABLE:         //  7
            case SHADOW_PER_THREAD_ENABLE:          //  8
            case SHADOW_ADDHINT_FROM_INODE:         //  10
            case SHADOW_DELETEHINT_FROM_INODE:      //  11
            case SHADOW_BEGIN_INODE_TRANSACTION:    //  13
            case SHADOW_END_INODE_TRANSACTION:      //  14
            case SHADOW_TRANSITION_SERVER_TO_OFFLINE:   // 19
            case SHADOW_CHANGE_HANDLE_CACHING_STATE:    // 20
            case SHADOW_RECREATE:                       // 21
            case SHADOW_SPARSE_STALE_DETECTION_COUNTER: // 23
            case SHADOW_DISABLE_CSC_FOR_USER:           // 25
            case SHADOW_SET_DATABASE_STATUS:            // 26
            case SHADOW_MANUAL_FILE_DETECTION_COUNTER:  // 28
                return STATUS_SUCCESS;

            case SHADOW_FIND_CREATE_PRINCIPAL_ID:   //  15
            case SHADOW_GET_SECURITY_INFO:          //  16
            case SHADOW_SET_EXCLUSION_LIST:         //  17
            case SHADOW_SET_BW_CONSERVE_LIST:       //  18
            case SHADOW_GET_SPACE_STATS:            //  5
                if (!lpSI->lpBuffer || !lpSI->cbBufferSize)
                {
                    return STATUS_INVALID_PARAMETER;
                }
                else
                {
                    Status =  CscProbeAndCaptureForReadWrite(
                                lpSI->lpBuffer,
                                lpSI->cbBufferSize,
                                ppAuxBuf);
                    if (Status == STATUS_SUCCESS) {
                        *ppOrgBuf =(PBYTE) lpSI->lpBuffer;
                        lpSI->lpBuffer = (PBYTE) *ppAuxBuf;
                    }
                    return Status;
                }

            case SHADOW_REINIT_DATABASE:            //  9
            case SHADOW_MAKE_SPACE:                 //  1
            case SHADOW_ADD_SPACE:                  //  3
            case SHADOW_FREE_SPACE:                 //  4
            case SHADOW_SET_MAX_SPACE:              //  6
            case SHADOW_COPY_INODE_FILE:            //  12
            case SHADOW_RENAME:                     //  22
            case SHADOW_ENABLE_CSC_FOR_USER:        //  24
            case SHADOW_PURGE_UNPINNED_FILES:       //  27
                Status = CscProbeAndCaptureForReadWrite(
                            (PBYTE)(lpSI->lpFind32),
                            sizeof(WIN32_FIND_DATA),
                            ppAuxBuf);
                if (Status == STATUS_SUCCESS) {
                    *ppOrgBuf =(PBYTE) lpSI->lpFind32;
                    lpSI->lpFind32 = (LPFIND32) *ppAuxBuf;
                }
                return Status;

            default:
                return STATUS_INVALID_PARAMETER;

        }
    } else if (
        IoControlCode == IOCTL_GET_SHARE_STATUS
            ||
        IoControlCode == IOCTL_SET_SHARE_STATUS
    ) {
        Status =  CscProbeAndCaptureForReadWrite(
                    (PBYTE)(lpSI->lpFind32),
                    sizeof(SHAREINFOW),
                    ppAuxBuf);
        if (Status == STATUS_SUCCESS) {
            *ppOrgBuf =(PBYTE) lpSI->lpFind32;
            lpSI->lpFind32 = (LPFIND32) *ppAuxBuf;
        }
        return Status;
    } else if (
        IoControlCode == IOCTL_IS_SERVER_OFFLINE
            ||
        IoControlCode == IOCTL_TAKE_SERVER_OFFLINE
            ||
        IoControlCode == IOCTL_NAME_OF_SERVER_GOING_OFFLINE
            ||
        IoControlCode == IOCTL_SHAREID_TO_SHARENAME
    ) {
        Status =  CscProbeAndCaptureForReadWrite(
                    lpSI->lpBuffer,
                    lpSI->cbBufferSize,
                    ppAuxBuf);
        if (Status == STATUS_SUCCESS) {
            *ppOrgBuf =(PBYTE) lpSI->lpBuffer;
            lpSI->lpBuffer = (PBYTE) *ppAuxBuf;
        }
        return Status;
    }

    // for all other ioctls which take SHADOWINFO structure, there may be an embedded
    // find32 structure, which must be probed

    ASSERT(IoControlCode != IOCTL_DO_SHADOW_MAINTENANCE);
    Status = CscProbeAndCaptureForReadWrite(
                (PBYTE)(lpSI->lpFind32),
                sizeof(WIN32_FIND_DATA),
                ppAuxBuf);
    if (Status == STATUS_SUCCESS) {
        *ppOrgBuf =(PBYTE) lpSI->lpFind32;
        lpSI->lpFind32 = (LPFIND32) *ppAuxBuf;
    }
    return Status;
}

NTSTATUS
ValidateCopyChunkContext(
    PRX_CONTEXT RxContext,
    DWORD       IoControlCode
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    // on open, validate the name
    if (IoControlCode == IOCTL_OPENFORCOPYCHUNK)
    {
        PBYTE   FileName = (PBYTE)LowIoContext->ParamsFor.IoCtl.pInputBuffer;
        ULONG   FileNameLength = LowIoContext->ParamsFor.IoCtl.InputBufferLength - 1;

        // let us varify that the name passed in is within our limits
        if ((FileNameLength > ((MAX_PATH+MAX_SERVER_SHARE_NAME_FOR_CSC)*sizeof(USHORT)))||
            CscProbeForReadWrite(FileName, FileNameLength) != STATUS_SUCCESS)
        {
            return STATUS_INVALID_PARAMETER;
        }

        return STATUS_SUCCESS;
    }
    else
    {
        // on copychunk or close we need to validate the chunk structure.
        // we don't need to validate the handle in it because the
        // object manager does that in MrxSmbCscCopyChunk and MrxSmbCscCloseForCopyChunk
        // routines

        COPYCHUNKCONTEXT *CopyChunkContext =
                     (COPYCHUNKCONTEXT *)(LowIoContext->ParamsFor.IoCtl.pOutputBuffer);

        if (!CopyChunkContext)
        {
            return STATUS_INVALID_PARAMETER;
        }


        // for all copychunk calls, validate the copychunkcontext buffer
        return CscProbeForReadWrite((PBYTE)CopyChunkContext, sizeof(COPYCHUNKCONTEXT));
    }

}

NTSTATUS
CscProbeForReadWrite(
    PBYTE   pBuffer,
    DWORD   dwSize
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    try
    {
        if (pBuffer != NULL) {
            ProbeForRead(
                pBuffer,
                dwSize,
                1);

            ProbeForWrite(
                pBuffer,
                dwSize,
                1);
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status=STATUS_INVALID_PARAMETER;
    }

    return Status;
}

NTSTATUS
CscProbeAndCaptureForReadWrite(
    PBYTE   pBuffer,
    DWORD   dwSize,
    PBYTE   *ppAuxBuf
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PBYTE pBuf = NULL;
    
    try {
        if (pBuffer != NULL && dwSize > 0) {
            ProbeForRead(pBuffer, dwSize, 1);
            ProbeForWrite(pBuffer, dwSize, 1);
            pBuf = RxAllocatePoolWithTag(PagedPool, dwSize, 'xXRM');
            if (pBuf != NULL) {
                RtlCopyMemory(pBuf, pBuffer, dwSize);
                *ppAuxBuf = pBuf;
            } else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = STATUS_INVALID_PARAMETER;
    }

    if (Status != STATUS_SUCCESS && pBuf != NULL) {
        RxFreePool(pBuf);
    }

    return Status;
}

VOID
CopyBackIfNecessary(
    IN     DWORD   IoControlCode,
    IN OUT PBYTE   InputBuffer,
    IN     LPCAPTURE_BUFFERS lpCapBuff,
    IN     PBYTE   pAuxBuf,
    IN     PBYTE   pOrgBuf,
    BOOL    fSuccess
    )
/*++

Routine Description:

    This routine copies back the capture buffer to the inout buffer, in ioctls which
    expect output.

Arguments:

Return Value:

Notes:


--*/
{
    int         indx;
    BOOL        fRet = FALSE;
    NTSTATUS    Status = STATUS_INVALID_PARAMETER;
    LPSHADOWINFO lpSI = NULL;

    indx = ((IoControlCode >> 2) & 0xfff) - SHADOW_IOCTL_ENUM_BASE;

    ASSERT((indx >=0 ) && (indx < sizeof(rgCscIoctlTable)/sizeof(CSC_IOCTL_ENTRY)));

    if (fSuccess)
    {

        if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_SHADOWINFO) {
            *(LPSHADOWINFO)InputBuffer = lpCapBuff->sSI;
            lpSI = &lpCapBuff->sSI;
            if (pAuxBuf != NULL && pOrgBuf != NULL) {
                //
                // Some ioctls have embedded pointers.  We have to copy the 2nd buffer
                // back, too, and set the embedded pointer back to that buffer.
                //
                if (IoControlCode == IOCTL_DO_SHADOW_MAINTENANCE) {
                    // DbgPrint("SHADOW_OP(2):0x%x\n", lpSI->uOp);
                    switch(lpSI->uOp) {
                        case SHADOW_FIND_CREATE_PRINCIPAL_ID:   // 15
                        case SHADOW_GET_SECURITY_INFO:          // 16
                        case SHADOW_SET_EXCLUSION_LIST:         // 17
                        case SHADOW_SET_BW_CONSERVE_LIST:       // 18
                        case SHADOW_GET_SPACE_STATS:            //  5
                            RtlMoveMemory(pOrgBuf, pAuxBuf, lpSI->cbBufferSize);
                            lpSI->lpBuffer = (PBYTE) pOrgBuf;
                            break;
                        case SHADOW_REINIT_DATABASE:            //  9
                        case SHADOW_MAKE_SPACE:                 //  1
                        case SHADOW_ADD_SPACE:                  //  3
                        case SHADOW_FREE_SPACE:                 //  4
                        case SHADOW_SET_MAX_SPACE:              //  6
                        case SHADOW_COPY_INODE_FILE:            //  12
                        case SHADOW_RENAME:                     //  22
                        case SHADOW_ENABLE_CSC_FOR_USER:        //  24
                        case SHADOW_PURGE_UNPINNED_FILES:       //  27
                            RtlMoveMemory(pOrgBuf, pAuxBuf, sizeof(WIN32_FIND_DATA));
                            lpSI->lpFind32 = (LPFIND32) pOrgBuf;
                            break;
                    }
                } else if (
                       IoControlCode == IOCTL_GET_SHARE_STATUS
                            ||
                       IoControlCode == IOCTL_SET_SHARE_STATUS
                ) {
                    RtlMoveMemory(pOrgBuf, pAuxBuf, sizeof(SHAREINFOW));
                    lpSI->lpFind32 = (LPFIND32) pOrgBuf;
                } else if (
                    IoControlCode == IOCTL_IS_SERVER_OFFLINE
                        ||
                    IoControlCode == IOCTL_TAKE_SERVER_OFFLINE
                        ||
                    IoControlCode == IOCTL_NAME_OF_SERVER_GOING_OFFLINE
                        ||
                    IoControlCode == IOCTL_SHAREID_TO_SHARENAME
                ) {
                    RtlMoveMemory(pOrgBuf, pAuxBuf, lpSI->cbBufferSize);
                    lpSI->lpBuffer = (PBYTE) pOrgBuf;
                } else {
                    RtlMoveMemory(pOrgBuf, pAuxBuf, sizeof(WIN32_FIND_DATA));
                    lpSI->lpFind32 = (LPFIND32) pOrgBuf;
                }
            }
        }
    } else {
        if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_SHADOWINFO) {
            ((LPSHADOWINFO)InputBuffer)->dwError  = lpCapBuff->sSI.dwError;
        } else if (rgCscIoctlTable[indx].dwFlags & FLAG_CSC_IOCTL_COPYPARAMS) {
            ((LPCOPYPARAMS)InputBuffer)->dwError = lpCapBuff->sCP.dwError;
        }
    }
}

VOID ValidateSmbFcbList(
    VOID)
/*++

Routine Description:

    This routine validates the smbfcb reverse lookup list

Arguments:

Return Value:

Notes:

    This validation code must be called from within the shadow critical section

--*/

{
    PLIST_ENTRY pListEntry;
    DWORD   cntFlink, cntBlink;

    DbgDoit(ASSERT(vfInShadowCrit));

    cntFlink = cntBlink = 0;

    // check forward list validity

    pListEntry = xCscFcbsList.Flink;

    while (pListEntry != &xCscFcbsList) {
        PMRX_SMB_FCB smbFcb;

        smbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                        pListEntry,
                        MRX_SMB_FCB,
                        ShadowReverseTranslationLinks);


        try
        {
            if((NodeType(smbFcb->ContainingFcb) != RDBSS_NTC_STORAGE_TYPE_FILE) &&
                (NodeType(smbFcb->ContainingFcb) != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)&&
                (NodeType(smbFcb->ContainingFcb) != RDBSS_NTC_STORAGE_TYPE_UNKNOWN)
                )
            {
                DbgPrint("ValidateSmbFcbList:Invalid nodetype %x fcb=%x smbfcb=%x\n",
                            NodeType(smbFcb->ContainingFcb),smbFcb->ContainingFcb, smbFcb);
//                DbgBreakPoint();
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            DbgPrint("ValidateSmbFcbList:Invalid smbFcb %x \n", smbFcb);
            //Bug - 578682
            //DbgBreakPoint();
        }


        ++cntFlink;
        pListEntry = pListEntry->Flink;
    }

    // check backward list validity

    pListEntry = xCscFcbsList.Blink;

    while (pListEntry != &xCscFcbsList) {
        PMRX_SMB_FCB smbFcb;

        smbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                        pListEntry,
                        MRX_SMB_FCB,
                        ShadowReverseTranslationLinks);


        try
        {
            if((NodeType(smbFcb->ContainingFcb) != RDBSS_NTC_STORAGE_TYPE_FILE) &&
                (NodeType(smbFcb->ContainingFcb) != RDBSS_NTC_STORAGE_TYPE_DIRECTORY)&&
                (NodeType(smbFcb->ContainingFcb) != RDBSS_NTC_STORAGE_TYPE_UNKNOWN))
            {
                DbgPrint("ValidateSmbFcbList:Invalid nodetype %x fcb=%x smbfcb=%x\n",
                            NodeType(smbFcb->ContainingFcb),smbFcb->ContainingFcb, smbFcb);
//                DbgBreakPoint();
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            DbgPrint("ValidateSmbFcbList:Invalid smbFcb %x \n", smbFcb);
//            DbgBreakPoint();
        }

        ++cntBlink;
        pListEntry = pListEntry->Blink;
    }

    // both counts should be the same
    ASSERT(cntFlink == cntBlink);
}

BOOL SetOfflineOpenStatusForShare(
    CSC_SHARE_HANDLE  hShare,
    CSC_SHADOW_HANDLE   hRootDir,
    OUT PULONG pShareStatus
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:


--*/

{
    PLIST_ENTRY pListEntry;

    DbgDoit(ASSERT(vfInShadowCrit));

    if ((hRootDir==0) && (hShare==0)) {
        return 0;
    }

    ASSERT((hShare!=0xffffffff) || (hRootDir!=0xffffffff));

    pListEntry = xCscFcbsList.Flink;

    while (pListEntry != &xCscFcbsList) {
        PMRX_SMB_FCB smbFcb;

        smbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                        pListEntry,
                        MRX_SMB_FCB,
                        ShadowReverseTranslationLinks);

        if (((smbFcb->sCscRootInfo.hShare == hShare)
            ||(smbFcb->sCscRootInfo.hRootDir == hRootDir)))

        {
            if(smbFcb->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                *pShareStatus |= SHARE_FINDS_IN_PROGRESS;
            }
            else
            {
                *pShareStatus |= SHARE_FILES_OPEN;
            }

        }
        pListEntry = pListEntry->Flink;
    }

    return FALSE;
}

VOID
EnterShadowCritRx(
    PRX_CONTEXT     pRxContext
    )
{
    EnterShadowCrit();

#if DBG
    if (pRxContext)
    {
        ASSERT( !pRxContext->ShadowCritOwner );
        pRxContext->ShadowCritOwner = GetCurThreadHandle();
    }
#endif
}

VOID
LeaveShadowCritRx(
    PRX_CONTEXT     pRxContext
    )
{

#if DBG
    if (pRxContext)
    {
        ASSERT( pRxContext->ShadowCritOwner );
        pRxContext->ShadowCritOwner = 0;
    }
#endif
    LeaveShadowCrit();
}

NTSTATUS
CscInitializeServerEntryDfsRoot(
    PRX_CONTEXT     pRxContext,
    PSMBCEDB_SERVER_ENTRY   pServerEntry
    )
{
    PDFS_NAME_CONTEXT pDfsNameContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING ServerPath;

    if (pRxContext &&
        pRxContext->CurrentIrpSp &&
        (pRxContext->CurrentIrpSp->MajorFunction == IRP_MJ_CREATE)) {
        pDfsNameContext = CscIsValidDfsNameContext(pRxContext->Create.NtCreateParameters.DfsNameContext);

        if (pDfsNameContext){
            Status = CscDfsParseDfsPath(
                         &pDfsNameContext->UNCFileName,
                         &ServerPath,
                         NULL,
                         NULL);

            if (Status == STATUS_SUCCESS) {
                if (pServerEntry->DfsRootName.Buffer == NULL) {
                    pServerEntry->DfsRootName.Buffer = RxAllocatePoolWithTag(
                                                       NonPagedPool,
                                                       ServerPath.Length,
                                                       RX_MISC_POOLTAG);

                    if (pServerEntry->DfsRootName.Buffer == NULL)
                    {
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }

                    RtlCopyMemory(pServerEntry->DfsRootName.Buffer,
                                  ServerPath.Buffer,
                                  ServerPath.Length);

                    pServerEntry->DfsRootName.MaximumLength = ServerPath.Length;
                    pServerEntry->DfsRootName.Length = ServerPath.Length;

//                    DbgPrint("Initialized %x with DfsRoot %wZ\n", pServerEntry, &pServerEntry->DfsRootName);
                }
            }
        }
    }

    return Status;
}


NTSTATUS
MRxSmbCscLocalFileOpen(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine performs the conserving bandwidth for remote boot client. The bandwidth
   is saved by the way of reducing the files opened on the boot server, instead the local
   copy of the file on CSC is used.

   There is a set the rules that the file has to meet in order to be opened locally.

   * file tried to open on VDO share
   * a local copy of the file has been created on CSC, which is not sparse
   * the write or name space operations have to go through the server except
   * Only execute operations are allowed through

   The routine checks the file whether it meets those rules. The actual open happens on
   MRxSmbCscCreateEpilogue.

Arguments:

    RxContext - the RDBSS context


Return Value:

    Status -  we return the local open status

Notes:


--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    NTSTATUS LocalStatus;

    RxCaptureFcb;

    PMRX_SMB_FCB      smbFcb;
    PMRX_SRV_OPEN     SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;

    PMRX_NET_ROOT             NetRoot;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;
    PSMBCEDB_SERVER_ENTRY     pServerEntry;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    ULONG       CreateDisposition = RxContext->Create.NtCreateParameters.Disposition;
    ULONG       CreateOptions = RxContext->Create.NtCreateParameters.CreateOptions;
    ACCESS_MASK DesiredAccess = RxContext->Create.NtCreateParameters.DesiredAccess;

    BOOLEAN CreatedShadow = FALSE;
    ULONG uShadowStatus;
    _WIN32_FIND_DATA Find32, CscFind32;
    PUNICODE_STRING PathName;
    int iRet;
    int EarlyOut = 0;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER DeadLine;
    BOOL    fLocalOpens = FALSE;

    NetRoot = capFcb->pNetRoot;
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);

    SrvOpen    = RxContext->pRelevantSrvOpen;
    smbFcb     = MRxSmbGetFcbExtension(capFcb);
    smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PathName = GET_ALREADY_PREFIXED_NAME(SrvOpen,capFcb);

    pServerEntry  = SmbCeGetAssociatedServerEntry(NetRoot->pSrvCall);

    // don't do local open if the share is either in disconnected state
    // or the share is not a VDO share

    if (SmbCeIsServerInDisconnectedMode(pServerEntry) ||
        (pNetRootEntry->NetRoot.CscFlags != SMB_CSC_CACHE_VDO))
    {
        RxDbgTrace( 0, Dbg, ("Server disconnected or not VDO share, CscFlags=%x\n", pNetRootEntry->NetRoot.CscFlags));
        return Status;
    }

    EnterShadowCritRx(RxContext);


    LocalStatus = MRxSmbCscObtainShadowHandles(
                  RxContext,
                  &Status,
                  &CscFind32,
                  &CreatedShadow,
                  CREATESHADOW_CONTROL_NOCREATE,
                  FALSE);

    if (LocalStatus != STATUS_SUCCESS) {
        EarlyOut = 1;
        goto FINALLY;
    }

    if ((smbFcb->hShadow == 0) ||
         (smbFcb->ShadowStatus == SHADOW_SPARSE) ||
         (smbFcb->ShadowStatus & SHADOW_MODFLAGS) ||
         (CscFind32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        // if no local copy or file is sparse, or modified, or it is a directory,
        // file cannot open locally
        EarlyOut = 2;
        goto FINALLY;
    }

    LeaveShadowCritRx(RxContext);
    fLocalOpens = CSCCheckLocalOpens(RxContext);
    EnterShadowCritRx(RxContext);

    if (DesiredAccess &
         (  GENERIC_WRITE |
            FILE_WRITE_EA |
            FILE_ADD_FILE |
            FILE_WRITE_DATA |
            FILE_APPEND_DATA |
            FILE_DELETE_CHILD |
            FILE_ADD_SUBDIRECTORY)) { // FILE_WRITE_ATTRIBUTE is OK
        if (fLocalOpens)
        {
            HookKdPrint(BADERRORS, ("VDO not allowed for this desired access %x %x\n", smbFcb->hShadow, DesiredAccess));
            Status = STATUS_ACCESS_DENIED;
        }

        EarlyOut = 3;
        goto FINALLY;
    }

    if (CreateOptions & FILE_DELETE_ON_CLOSE)
    {
        if (fLocalOpens)
        {
            HookKdPrint(BADERRORS, ("DeletOnClose not allowed %x %x\n", smbFcb->hShadow, DesiredAccess));
            Status = STATUS_ACCESS_DENIED;
            EarlyOut = 30;
            goto FINALLY;
        }
    }

    if (CreateDisposition != FILE_OPEN)
    {
        // name space operations should go to the server
        if (fLocalOpens)
        {
            Status = STATUS_SHARING_VIOLATION;
        }

        EarlyOut = 4;
        goto FINALLY;
    }

    if (!(DesiredAccess & FILE_EXECUTE))
    {
        // DbgPrint("FILE_EXECUTE not set (0x%x) on %wZ\n", DesiredAccess, PathName);
        EarlyOut = 5;
        goto FINALLY;
    }


#if 0
    KeQuerySystemTime( &CurrentTime );

    // system time is based on 100ns
    DeadLine.QuadPart = smbFcb->LastSyncTime.QuadPart + (LONGLONG) (CscSyncInterval * 10 * 1000 * 1000);

    if (CurrentTime.QuadPart < DeadLine.QuadPart) {
        Status = STATUS_SUCCESS;
        goto FINALLY;
    }
#endif

    // do a check on the server only when there is no outstanding local open
    if (!fLocalOpens)
    {
        LeaveShadowCritRx(RxContext);
        LocalStatus = MRxSmbGetFileInfoFromServer(RxContext,PathName,&Find32,SrvOpen,NULL);
        EnterShadowCritRx(RxContext);

        if (LocalStatus != STATUS_SUCCESS) {
            // if cannot get file information from the server, file cannot open locally
            EarlyOut = 6;
            goto FINALLY;
        }

        iRet = RefreshShadow(
                  smbFcb->hParentDir,
                  smbFcb->hShadow,
                  &Find32,
                  &uShadowStatus
                  );

        if (iRet < SRET_OK) {
            // if refresh shadow fails, file cannot open locally
            EarlyOut = 7;
            goto FINALLY;
        } else {
            SetShadowInfo(smbFcb->hParentDir,
                          smbFcb->hShadow,
                          NULL,
                          0,
                          SHADOW_FLAGS_OR|SHADOW_FLAGS_SET_REFRESH_TIME);
        }

        if (uShadowStatus == SHADOW_SPARSE) {
            // if the file is sparse, it cannot open locally
            EarlyOut = 8;
            goto FINALLY;
        } else {
            // no more rule, file can open locally
            Status = STATUS_SUCCESS;
        }
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

FINALLY:

    if (Status == STATUS_SUCCESS) {
        SetFlag(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_LOCAL_OPEN);
        smbFcb->cntLocalOpens++;
        //RxDbgTrace(0, Dbg, ("Local :   %wZ\n",PathName));
        RxLog(("Local Open %lx %lx %lx\n",smbFcb->hParentDir, smbFcb->hShadow, capFcb));

        RxDbgTrace( 0, Dbg,
            ("MRxSmbCscLocalFileOpen hdir/hshadow= %08lx %08lx\n",
            smbFcb->hParentDir, smbFcb->hShadow));
    } else {
        RxDbgTrace(0, Dbg, ("Remote: %d %wZ\n",EarlyOut,PathName));
    }

    LeaveShadowCritRx(RxContext);

    return Status;
}





BOOL
CSCCheckLocalOpens(
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   The routine checks whether there is any fcb in the fcb list which has our inode.
   The reason why this has to be done is because of rename.
   Thus if a file cat.exe is opened the smbFcb->hShadow field had the inode.
   Then if a rename to dog.exe is done while the file is open, the smbfcb->hShadow field is
   set to 0 and smbFcb->hShadowRename is set to the inode value.
   After that when a delete comes through, RDBSS cannot check the sharing violation because
   it doesn'nt change the name in the FCB to dog.exe. So it creates a new FCB for dog.exe.
   Yet we do have to give sharing violation in this scenario. We accomplish this
   by detecting just such a scenario in the routine below.

   It essentially goes though the FCB reverselookup list and if it finds an FCB which
   has the same hShadow or hShadowRenamed as this one, and it's cntLocalOpens is
   non-zero, then it gives sharing violation.

Arguments:

    RxContext - the RDBSS context

    Status    - miniredir status

Return Value:

    Status -  Passed in status, or STATUS_SHARING_VILOATION

Notes:


--*/
{
    BOOL    fRet = FALSE;
    RxCaptureFcb;
    PMRX_SMB_FCB            smbFcb, pSmbFcbT;
    PMRX_NET_ROOT           NetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    CSC_SHADOW_HANDLE       hShadow;
    PLIST_ENTRY             pListEntry;


    NetRoot = capFcb->pNetRoot;
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(NetRoot);
    smbFcb     = MRxSmbGetFcbExtension(capFcb);

    hShadow = (smbFcb->hShadow)?smbFcb->hShadow:smbFcb->hShadowRenamed;


    if (!hShadow || (pNetRootEntry->NetRoot.CscFlags != SMB_CSC_CACHE_VDO))
    {
        return FALSE;
    }

    EnterShadowCritRx(RxContext);

    pListEntry = xCscFcbsList.Flink;

    while (pListEntry != &xCscFcbsList) {

        pSmbFcbT = (PMRX_SMB_FCB)CONTAINING_RECORD(
                        pListEntry,
                        MRX_SMB_FCB,
                        ShadowReverseTranslationLinks);
        if ((pSmbFcbT->hShadow==smbFcb->hShadow) ||
            (pSmbFcbT->hShadowRenamed==smbFcb->hShadow))
        {
            if (pSmbFcbT->cntLocalOpens)
            {
                RxLog(("smbfcb=%x has local opens for hShadow=%x\n", pSmbFcbT, smbFcb->hShadow));
                fRet = TRUE;
                break;

            }
        }

        pListEntry = pListEntry->Flink;
    }

    LeaveShadowCritRx(RxContext);
    return fRet;
}


BOOL
IsCSCBusy(
    VOID
    )
/*++

Routine Description:

    This routine checks whether any files are being shadowed by CSC

Arguments:

    None

Return Value:

    TRUE if any files are being shadowed, FALSE otherwise

Notes:

    Used by the diableCSC ioctl

--*/
{
    DbgDoit(ASSERT(vfInShadowCrit));
    return (xCscFcbsList.Flink != &xCscFcbsList);
}

VOID
ClearCSCStateOnRedirStructures(
    VOID
    )
/*++

Routine Description:

    This routine clears the csc state on netroots

Arguments:

    None

Return Value:

    None

Notes:

    Used by the diableCSC ioctl

--*/
{

    DbgDoit(ASSERT(vfInShadowCrit));
    ASSERT(!IsCSCBusy());
    ClearAllResourcesOfShadowingState();

    DbgDoit(ASSERT(vfInShadowCrit));
    CscTransitionServerToOnline(0); // transition all servers
}

BOOL
CscDfsShareIsInReint(
    IN  PRX_CONTEXT         RxContext
    )
/*++

Routine Description:


Arguments:


Return Value:


Notes:


--*/
{
    PDFS_NAME_CONTEXT pDfsNameContext = NULL;
    UNICODE_STRING    SharePath;
    NTSTATUS    LocalStatus;
    CSC_SHARE_HANDLE    CscShareHandle;
    ULONG               ulRootHintFlags;

    if (RxContext->MajorFunction == IRP_MJ_CREATE) {

        pDfsNameContext = CscIsValidDfsNameContext(RxContext->Create.NtCreateParameters.DfsNameContext);

        if (pDfsNameContext)
        {
            LocalStatus = CscDfsParseDfsPath(
                       &pDfsNameContext->UNCFileName,
                       NULL,
                       &SharePath,
                       NULL);

            if (LocalStatus == STATUS_SUCCESS)
            {
                GetHShareFromUNCString(
                    SharePath.Buffer,
                    SharePath.Length,
                    1,
                    TRUE,
                    &CscShareHandle,
                    &ulRootHintFlags);


                if (CscShareHandle && (CscShareHandle == hShareReint))
                {
                    return TRUE;
                }
            }

        }
    }
    return FALSE;
}

LONG CSCBeginReint(
    IN OUT  PRX_CONTEXT RxContext,
    IN OUT  LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

    begins merge. This routine needs to be in pagelocked memory because
    it takes cancel spinlock.

    We pend the Irp that issued the beginreint ioctl and set our cancel routine in it.
    If the thread doing the merge dies for some reason, the Ps code calls our cancel routine
    to cacncel this irp, this is when we cleanup the merge state.

Arguments:

    RxContext

    lpSI        Buffer passed down by the caller

Return Value:

    None.

--*/
{
    LONG   ShadowIRet;
    KIRQL   CancelIrql;
    BOOL    fCancelled = FALSE;


    ShadowIRet = IoctlBeginReint(lpSI);

    if (ShadowIRet >= 1)
    {
        CloseOpenFiles(lpSI->hShare, NULL, 0);
        IoAcquireCancelSpinLock( &CancelIrql);
        if (RxContext->CurrentIrp->Cancel)
        {
            vIrpReint = NULL;
            IoReleaseCancelSpinLock( CancelIrql );
            IoctlEndReint(lpSI);

        }
        else
        {
            // succeeded begin merge on this share
            vIrpReint = RxContext->CurrentIrp;

            IoSetCancelRoutine( RxContext->CurrentIrp, CSCCancelReint );
            IoReleaseCancelSpinLock( CancelIrql );

            // Returning STATUS_PENDING
            IoMarkIrpPending( RxContext->CurrentIrp );

            // as we hijacked the Irp, let us make sure that rdbss gets rid of the rxcontext
            RxCompleteRequest_Real( RxContext, NULL, STATUS_PENDING );
        }
    }

    return ShadowIRet;
}

ULONG CSCEndReint(
    LPSHADOWINFO    lpSI
    )
/*++

Routine Description:

    ends merge. This routine needs to be in pagelocked memory because it takes cancel spinlock
    This is normal termination. We cleanup our merge state and complete the irp we pended
    during begin

Arguments:

    lpSI

Return Value:

    None.

--*/
{
    int ShadowIRet=-1;
    KIRQL   CancelIrql;
    PIRP    pIrp;

    // check if reint was actualy going on on this share
    ShadowIRet = IoctlEndReint(lpSI);

    if (ShadowIRet >= 0)
    {
        IoAcquireCancelSpinLock( &CancelIrql);

        pIrp = vIrpReint;
        vIrpReint = NULL;

        if (pIrp)
        {
            pIrp->IoStatus.Status = STATUS_SUCCESS;
            pIrp->IoStatus.Information = 0;
            IoSetCancelRoutine(pIrp, NULL);
        }

        IoReleaseCancelSpinLock( CancelIrql );

        if (pIrp)
        {
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        }
    }
    return ShadowIRet;
}

VOID CSCCancelReint(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP ThisIrp
    )
/*++

Routine Description:

    Cancels a merge begun by the user. This routine needs to be in pagelocked memory because
    it takes cancel spinlock.


Arguments:

    DeviceObject - Ignored.

    ThisIrp  -  This is the Irp to cancel.

Return Value:

    None.

--*/
{
    SHADOWINFO  sSI;

    memset(&sSI, 0, sizeof(sSI));
    sSI.hShare = hShareReint;
    IoSetCancelRoutine( ThisIrp, NULL );
    vIrpReint = NULL;
    IoReleaseCancelSpinLock( ThisIrp->CancelIrql );
    ThisIrp->IoStatus.Status = STATUS_SUCCESS;
    ThisIrp->IoStatus.Information = 0;
    IoCompleteRequest(ThisIrp, IO_NO_INCREMENT);
    IoctlEndReint(&sSI);
}

BOOL
CloseOpenFiles(
    HSHARE  hShare,
    PUNICODE_STRING pServerName,
    int     lenSkip
    )
/*++

Routine Description:

    Closes all open files for CSC. Does this by issuing a foceclose on the vneteroot
    This an equivalent of wnetcancelconnection on a share with forced close of files

Arguments:

    hShare          CSC handle to the share to close, ignored if pServerName is non-NULL

    pServerName     All open files on on shares belonging to this server

    lenskip         #of  backslashes in servername (usually one)

Return Value:

    Whether atleast one open file was found

--*/
{
    BOOL    fFoundAtleastOne=FALSE, fFound;
    PLIST_ENTRY pListEntry;
    SHAREINFOW sSR;
    UNICODE_STRING uniShare;

    EnterShadowCrit();
    pListEntry = xCscFcbsList.Flink;

    while (pListEntry != &xCscFcbsList) {
        PMRX_SMB_FCB smbFcb;

        smbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                        pListEntry,
                        MRX_SMB_FCB,
                        ShadowReverseTranslationLinks);

        fFound = FALSE;
        if (pServerName)
        {
            ASSERT(smbFcb->sCscRootInfo.hShare);
            GetShareInfo(smbFcb->sCscRootInfo.hShare, &sSR, NULL);

            uniShare.Buffer = sSR.rgSharePath+lenSkip;
            uniShare.Length = uniShare.MaximumLength = pServerName->Length;

//            DbgPrint("matching %wZ with Servername\n", &uniShare);
            if(RtlEqualUnicodeString(pServerName, &uniShare, TRUE)&&
                (uniShare.Buffer[pServerName->Length/sizeof(WCHAR)]==(WCHAR)'\\'))
            {
//                DbgPrint("matched \n");
                fFound=TRUE;
            }
        }
        else  if ((smbFcb->sCscRootInfo.hShare == hShare))
        {
            fFound = TRUE;
        }

        if (fFound)
        {
            if (!(smbFcb->ContainingFcb->FcbState & FCB_STATE_ORPHANED))
            {
                PNET_ROOT pNetRoot = (PNET_ROOT)((PFCB)(smbFcb->ContainingFcb))->pNetRoot;

                
               fFoundAtleastOne = TRUE;
               LeaveShadowCrit();
               RxAcquirePrefixTableLockExclusive( &RxNetNameTable, TRUE);
               RxForceFinalizeAllVNetRoots(pNetRoot);
               RxReleasePrefixTableLock( &RxNetNameTable );
               EnterShadowCrit();
               pListEntry = xCscFcbsList.Flink;
               //
               //  ...start again
               //
               continue;
            }
            else
            {
//                DbgPrint("Skipping orphaned FCB for hShadow=%x \n", smbFcb->hShadow);
            }
        }

        pListEntry = pListEntry->Flink;
    }

    LeaveShadowCrit();
    return fFoundAtleastOne;
}

VOID
CreateFakeFind32(
    HSHADOW hDir,
    _WIN32_FIND_DATA  *Find32,
    PRX_CONTEXT         RxContext,
    BOOLEAN LastComponentInName
    )
/*++

Routine Description:

    Creates a win32 structure for offline use. This is also created for DFS directories

Arguments:

    hDir    directory inode where the item is to be created

    Find32  win32 data to be fixed up

    RxContext

    LastComponentInname If this is not true, then this must be a directory

Return Value:

    None.

--*/
{
    KeQuerySystemTime(((PLARGE_INTEGER)(&Find32->ftCreationTime)));
    Find32->ftLastAccessTime = Find32->ftLastWriteTime = Find32->ftCreationTime;
    //already zero Find32->nFileSizeHigh = Find32->nFileSizeLow = 0;

    if (!LastComponentInName) {

        // must be a directory....don't know the other attribs without going to get them
        Find32->dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;

    } else {
        PNT_CREATE_PARAMETERS cp = &RxContext->Create.NtCreateParameters;

        Find32->dwFileAttributes = cp->FileAttributes;
        Find32->dwFileAttributes   &= (FILE_ATTRIBUTE_READONLY |
               FILE_ATTRIBUTE_HIDDEN   |
               FILE_ATTRIBUTE_SYSTEM   |
               FILE_ATTRIBUTE_ARCHIVE );
        if (FlagOn(cp->CreateOptions,FILE_DIRECTORY_FILE)) {
            Find32->dwFileAttributes |= FILE_ATTRIBUTE_DIRECTORY;
        }
    }

    MRxSmbCscGenerate83NameAsNeeded(hDir,
                    &Find32->cFileName[0],
                    &Find32->cAlternateFileName[0]);
}

NTSTATUS
OkToDeleteObject(
    HSHADOW hDir,
    HSHADOW hShadow,
    _WIN32_FIND_DATA  *Find32,
    ULONG   uShadowStatus,
    BOOLEAN fDisconnected
    )
/*++

Routine Description:

    Check to see if the file can be deleted.

Arguments:


Return Value:

    STATUS_SUCCESS if Ok to delete, some appropriate status otherwise

--*/
{
    BOOLEAN fHasDescendents = FALSE;
    NTSTATUS    LocalStatus = STATUS_SUCCESS;

    // in disconnected mode, we don't allow deletions of directories
    // which have been cached while online
    // This automatically takes care of the roots

    if (fDisconnected)
    {
        if (!IsFile(Find32->dwFileAttributes))
        {
            if(!mShadowLocallyCreated(uShadowStatus)) {
                LocalStatus = STATUS_ONLY_IF_CONNECTED;
                goto FINALLY; //bailout;
            }
        }

        ASSERT(hDir);
    }

    // if we are deleting a directory, and it has descendents
    // then fail with appropriate error
    if (!IsFile(Find32->dwFileAttributes))
    {
        if(HasDescendentsHShadow(hDir, hShadow, &fHasDescendents) >= 0)
        {
            if (fHasDescendents)
            {
                LocalStatus = STATUS_DIRECTORY_NOT_EMPTY;
                goto FINALLY; //bailout;
            }
        }
        else
        {
            goto FINALLY; //bailout;
        }
    }

    // don't delete if readonly
    if (Find32->dwFileAttributes & FILE_ATTRIBUTE_READONLY)
    {
        LocalStatus = STATUS_CANNOT_DELETE;
        goto FINALLY; //bailout;

    }

FINALLY:
    return LocalStatus;
}

int IoctlGetGlobalStatus(
    ULONG SessionId,
    LPGLOBALSTATUS lpGS
    )
/*++

Routine Description:

Parameters:

Return Value:

Notes:


--*/
{
    #if 0
    if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_NO_NET)
        DbgPrint("IoctlGetGlobalStatus: FLAG_GLOBALSTATUS_NO_NET\r\n");
    if (sGS.uFlagsEvents & FLAG_GLOBALSTATUS_SHARE_DISCONNECTED)
        DbgPrint("IoctlGetGlobalStatus: FLAG_GLOBALSTATUS_SHARE_DISCONNECTED share=%d\r\n",
            sGS.hShareDisconnected);
    #endif

    // DbgPrint("IOCTL_GETGLOBALSTATUS Transitioning 0x%x sess 0x%x vs 0x%x\n",
    //                 CscServerEntryBeingTransitioned,
    //                 SessionId,
    //                 CscSessionIdCausingTransition);

    EnterShadowCrit();
    GetShadowSpaceInfo(&(sGS.sST));
    *lpGS = sGS;
    lpGS->uDatabaseErrorFlags = QueryDatabaseErrorFlags();
    if ((sGS.uFlagsEvents & FLAG_GLOBALSTATUS_SHARE_DISCONNECTED) != 0) {
        // Only the session causing a transition will see the SHARE_DISCONNECT bit, and
        // reset it.
        if (SessionId == CscSessionIdCausingTransition)
            sGS.uFlagsEvents = 0;
        else
            lpGS->uFlagsEvents &= ~FLAG_GLOBALSTATUS_SHARE_DISCONNECTED;
    } else {
        sGS.uFlagsEvents = 0;
    }
    LeaveShadowCrit();
    return (1);
}

NTSTATUS
IoctlGetDebugInfo(
    PRX_CONTEXT RxContext,
    PBYTE InputBuffer,
    ULONG InputBufferLength,
    PBYTE OutputBuffer,
    ULONG OutputBufferLength)
{
    ULONG Cmd = 0;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PIOCTL_GET_DEBUG_INFO_ARG pInfoArg = NULL;
    PBYTE pOutBuf = OutputBuffer;
    KPROCESSOR_MODE RequestorMode;

    // DbgPrint("In IoctlGetDebugInfo(IP=0x%x,IL=0x%x,OP=0x%x,OL=0x%x)\n",
    //              InputBuffer,
    //              InputBufferLength,
    //              OutputBuffer,
    //              OutputBufferLength);

    if (
        InputBufferLength < sizeof(ULONG)
            ||
        OutputBufferLength < FIELD_OFFSET(IOCTL_GET_DEBUG_INFO_ARG, ServerEntryObject)
    ) {
        return STATUS_INVALID_PARAMETER;
    }

    RequestorMode = RxContext->CurrentIrp->RequestorMode;

    if (RequestorMode != KernelMode) {
        try {
            ProbeForRead(InputBuffer, InputBufferLength, 1);
            Cmd = *(PULONG)InputBuffer;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
        if (NtStatus != STATUS_SUCCESS)
            return NtStatus;
        pOutBuf = RxAllocatePoolWithTag(PagedPool | POOL_COLD_ALLOCATION, OutputBufferLength, RX_MISC_POOLTAG);
        if (pOutBuf == NULL)
            return STATUS_INSUFFICIENT_RESOURCES;
    }

    // DbgPrint("Cmd=%d\n", Cmd);
    if (Cmd == DEBUG_INFO_SERVERLIST) {
        PSMBCEDB_SERVER_ENTRY pServerEntry = NULL;
        PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry = NULL;
        PSMBCEDB_SERVER_ENTRY_ARG pServerEntryArg = NULL;
        PSMBCEDB_NETROOT_ENTRY_ARG pNetRootEntryArg = NULL;
        ULONG Size = 0;
        ULONG ServerEntryCount = 0;
        ULONG NetRootEntryCount = 0;
        PCHAR pCh = NULL;
        ULONG i;
        ULONG j;

        //
        // Two passes - 1st to check size, 2nd to marshal the info in
        //
        SmbCeAcquireResource();
        try {
            Size = 0;
            ServerEntryCount = 0;
            pServerEntry = SmbCeGetFirstServerEntry();
            while (pServerEntry != NULL) {
                ServerEntryCount++;
                Size += pServerEntry->Name.Length + sizeof(WCHAR) +
                            pServerEntry->DomainName.Length  + sizeof(WCHAR) +
                                pServerEntry->DfsRootName.Length + sizeof(WCHAR) +
                                    pServerEntry->DnsName.Length + sizeof(WCHAR);
                NetRootEntryCount = 0;
                pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
                while (pNetRootEntry != NULL) {
                    NetRootEntryCount++;
                    Size += pNetRootEntry->Name.Length + sizeof(WCHAR);
                    pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
                }
                Size += sizeof(SMBCEDB_NETROOT_ENTRY_ARG) * NetRootEntryCount;
                pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
        // DbgPrint("Sizecheck1: ServerEntryCount=%d,NtStatus=0x%x\n", ServerEntryCount, NtStatus);
        if (NtStatus != STATUS_SUCCESS || ServerEntryCount == 0) {
            SmbCeReleaseResource();
            RtlZeroMemory(pOutBuf, OutputBufferLength);
            pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) pOutBuf;
            pInfoArg->Status = NtStatus;
            goto AllDone;
        }
        Size += FIELD_OFFSET(IOCTL_GET_DEBUG_INFO_ARG, ServerEntryObject[ServerEntryCount]);
        // DbgPrint("Sizecheck2: Size=%d(0x%x)\n", Size, Size);
        if (Size > OutputBufferLength) {
            RtlZeroMemory(pOutBuf, OutputBufferLength);
            pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) pOutBuf;
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            pInfoArg->Status = NtStatus;
            pInfoArg->EntryCount = Size;
            SmbCeReleaseResource();
            goto AllDone;
        }
        //
        // Marshal it in
        //
        // Start of buffer is the array of server entries
        // Middle are the arrays of netroots
        // End contains all the strings
        //
        RtlZeroMemory(pOutBuf, OutputBufferLength);
        pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) pOutBuf;
        pInfoArg->Status = 0;
        pInfoArg->Version = 4;
        pInfoArg->EntryCount = ServerEntryCount;
        pCh = (PCHAR)(pOutBuf + OutputBufferLength);
        pNetRootEntryArg = (PSMBCEDB_NETROOT_ENTRY_ARG)
                                &pInfoArg->ServerEntryObject[ServerEntryCount];
        ServerEntryCount = 0;
        pServerEntry = SmbCeGetFirstServerEntry();
        while (pServerEntry != NULL) {
            pServerEntryArg = &pInfoArg->ServerEntryObject[ServerEntryCount];
            pServerEntryArg->ServerStatus = pServerEntry->ServerStatus;
            pServerEntryArg->SecuritySignaturesEnabled = pServerEntry->SecuritySignaturesEnabled;
            pServerEntryArg->CscState = pServerEntry->Server.CscState;
            pServerEntryArg->IsFakeDfsServerForOfflineUse =
                                            pServerEntry->Server.IsFakeDfsServerForOfflineUse;
            pServerEntryArg->IsPinnedOffline = pServerEntry->Server.IsPinnedOffline;
            pServerEntryArg->pNetRoots = pNetRootEntryArg;
            pCh -= pServerEntry->Name.Length + sizeof(WCHAR);
            pServerEntryArg->Name = (PWCHAR) pCh;
            RtlCopyMemory(pCh, pServerEntry->Name.Buffer, pServerEntry->Name.Length);
            pCh -= pServerEntry->DomainName.Length + sizeof(WCHAR);
            pServerEntryArg->DomainName = (PWCHAR)pCh;
            RtlCopyMemory(pCh, pServerEntry->DomainName.Buffer, pServerEntry->DomainName.Length);
            pCh -= pServerEntry->DfsRootName.Length + sizeof(WCHAR) + 1;;
            pServerEntryArg->DfsRootName = (PWCHAR)pCh;
            RtlCopyMemory(pCh, pServerEntry->DfsRootName.Buffer, pServerEntry->DfsRootName.Length);
            pCh -= pServerEntry->DnsName.Length + sizeof(WCHAR);
            pServerEntryArg->DnsName = (PWCHAR)pCh;
            RtlCopyMemory(pCh, pServerEntry->DnsName.Buffer, pServerEntry->DnsName.Length);
            NetRootEntryCount = 0;
            pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
            while (pNetRootEntry != NULL) {
                pNetRootEntryArg->MaximalAccessRights = pNetRootEntry->MaximalAccessRights;
                pNetRootEntryArg->GuestMaximalAccessRights=pNetRootEntry->GuestMaximalAccessRights;
                pNetRootEntryArg->DfsAware = pNetRootEntry->NetRoot.DfsAware;
                pNetRootEntryArg->hShare = pNetRootEntry->NetRoot.sCscRootInfo.hShare;
                pNetRootEntryArg->hRootDir = pNetRootEntry->NetRoot.sCscRootInfo.hRootDir;
                pNetRootEntryArg->ShareStatus = pNetRootEntry->NetRoot.sCscRootInfo.ShareStatus;
                pNetRootEntryArg->CscEnabled = pNetRootEntry->NetRoot.CscEnabled;
                pNetRootEntryArg->CscFlags = pNetRootEntry->NetRoot.CscFlags;
                pNetRootEntryArg->CscShadowable = pNetRootEntry->NetRoot.CscShadowable;
                pNetRootEntryArg->Disconnected = pNetRootEntry->NetRoot.Disconnected;
                pCh -= pNetRootEntry->Name.Length + sizeof(WCHAR);
                pNetRootEntryArg->Name = (PWCHAR)pCh;
                RtlCopyMemory(pCh, pNetRootEntry->Name.Buffer, pNetRootEntry->Name.Length);
                NetRootEntryCount++;
                pNetRootEntryArg++;
                pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
            }
            pServerEntryArg->NetRootEntryCount = NetRootEntryCount;
            ServerEntryCount++;
            pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        }
        SmbCeReleaseResource();
        //
        // Now do fixups
        //
        for (i = 0; i < pInfoArg->EntryCount; i++) {
            POINTER_TO_OFFSET(pInfoArg->ServerEntryObject[i].Name, pOutBuf);
            POINTER_TO_OFFSET(pInfoArg->ServerEntryObject[i].DomainName, pOutBuf);
            POINTER_TO_OFFSET(pInfoArg->ServerEntryObject[i].DfsRootName, pOutBuf);
            POINTER_TO_OFFSET(pInfoArg->ServerEntryObject[i].DnsName, pOutBuf);
            for (j = 0; j < pInfoArg->ServerEntryObject[i].NetRootEntryCount; j++)
                POINTER_TO_OFFSET(pInfoArg->ServerEntryObject[i].pNetRoots[j].Name, pOutBuf);
            POINTER_TO_OFFSET(pInfoArg->ServerEntryObject[i].pNetRoots, pOutBuf);
        }
    } else if (Cmd == DEBUG_INFO_CSCFCBSLIST) {
        PIOCTL_GET_DEBUG_INFO_ARG pInfoArg = NULL;
        PMRX_SMB_FCB_ENTRY_ARG pFcbEntryArg = NULL;
        PMRX_SMB_FCB pSmbFcb = NULL;
        PLIST_ENTRY pListEntry = NULL;
        ULONG Size = 0;
        PCHAR pCh = NULL;
        ULONG FcbCount = 0;
        ULONG i;

        EnterShadowCritRx(RxContext);
        pListEntry = xCscFcbsList.Flink;
        FcbCount = 0;
        while (pListEntry != &xCscFcbsList) {
            FcbCount++;
            pSmbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                            pListEntry,
                            MRX_SMB_FCB,
                            ShadowReverseTranslationLinks);
            Size += pSmbFcb->MinimalCscSmbFcb.uniDfsPrefix.Length + sizeof(WCHAR) +
                        pSmbFcb->MinimalCscSmbFcb.uniActualPrefix.Length + sizeof(WCHAR);
            pListEntry = pListEntry->Flink;
        }
        Size += FIELD_OFFSET(IOCTL_GET_DEBUG_INFO_ARG, FcbEntryObject[FcbCount]);
        if (Size > OutputBufferLength) {
            RtlZeroMemory(pOutBuf, OutputBufferLength);
            pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) pOutBuf;
            NtStatus = STATUS_BUFFER_TOO_SMALL;
            pInfoArg->Status = NtStatus;
            pInfoArg->EntryCount = Size;
            LeaveShadowCritRx(RxContext);
            goto AllDone;
        }
        RtlZeroMemory(pOutBuf, OutputBufferLength);
        pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) pOutBuf;
        pInfoArg->Status = 0;
        pInfoArg->Version = 1;
        pInfoArg->EntryCount = FcbCount;
        FcbCount = 0;
        pCh = (PCHAR)(pOutBuf + OutputBufferLength);
        pListEntry = xCscFcbsList.Flink;
        while (pListEntry != &xCscFcbsList) {
            pFcbEntryArg = &pInfoArg->FcbEntryObject[FcbCount];
            pSmbFcb = (PMRX_SMB_FCB)CONTAINING_RECORD(
                            pListEntry,
                            MRX_SMB_FCB,
                            ShadowReverseTranslationLinks);
            pFcbEntryArg->MFlags = pSmbFcb->MFlags;
            pFcbEntryArg->Tid = pSmbFcb->Tid;
            pFcbEntryArg->ShadowIsCorrupt = pSmbFcb->ShadowIsCorrupt;
            pFcbEntryArg->hShadow = pSmbFcb->hShadow;
            pFcbEntryArg->hParentDir = pSmbFcb->hParentDir;
            pFcbEntryArg->hShadowRenamed = pSmbFcb->hShadowRenamed;
            pFcbEntryArg->ShadowStatus = pSmbFcb->ShadowStatus;
            pFcbEntryArg->LocalFlags = pSmbFcb->LocalFlags;
            pFcbEntryArg->LastComponentOffset = pSmbFcb->LastComponentOffset;
            pFcbEntryArg->LastComponentLength = pSmbFcb->LastComponentLength;
            pFcbEntryArg->hShare = pSmbFcb->sCscRootInfo.hShare;
            pFcbEntryArg->hRootDir = pSmbFcb->sCscRootInfo.hRootDir;
            pFcbEntryArg->ShareStatus = pSmbFcb->sCscRootInfo.ShareStatus;
            pFcbEntryArg->Flags = pSmbFcb->sCscRootInfo.Flags;
            pCh -= pSmbFcb->MinimalCscSmbFcb.uniDfsPrefix.Length + sizeof(WCHAR);
            pFcbEntryArg->DfsPrefix = (PWCHAR)pCh;
            RtlCopyMemory(
                    pCh,
                    pSmbFcb->MinimalCscSmbFcb.uniDfsPrefix.Buffer,
                    pSmbFcb->MinimalCscSmbFcb.uniDfsPrefix.Length);
            pCh -= pSmbFcb->MinimalCscSmbFcb.uniActualPrefix.Length + sizeof(WCHAR);
            pFcbEntryArg->ActualPrefix = (PWCHAR)pCh;
            RtlCopyMemory(
                    pCh,
                    pSmbFcb->MinimalCscSmbFcb.uniActualPrefix.Buffer,
                    pSmbFcb->MinimalCscSmbFcb.uniActualPrefix.Length);
            FcbCount++;
            pListEntry = pListEntry->Flink;
        }
        LeaveShadowCritRx(RxContext);
        for (i = 0; i < pInfoArg->EntryCount; i++) {
            POINTER_TO_OFFSET(pInfoArg->FcbEntryObject[i].DfsPrefix, pOutBuf);
            POINTER_TO_OFFSET(pInfoArg->FcbEntryObject[i].ActualPrefix, pOutBuf);
        }
    } else {
        RtlZeroMemory(pOutBuf, OutputBufferLength);
        pInfoArg = (PIOCTL_GET_DEBUG_INFO_ARG) pOutBuf;
        NtStatus = STATUS_INVALID_PARAMETER;
        pInfoArg->Status = NtStatus;
        goto AllDone;
    }

AllDone:

    if (RequestorMode != KernelMode) {
        try {
            ProbeForWrite(OutputBuffer, OutputBufferLength, 1);
            RtlCopyMemory(OutputBuffer, pOutBuf, OutputBufferLength);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
    }

    if (pOutBuf != OutputBuffer)
        RxFreePool(pOutBuf);
        
    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\write.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    write.c

Abstract:

    This module implements the mini redirector call down routines pertaining
    to write of file system objects.

Author:

    Joe Linn      [JoeLinn]      7-March-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma warning(error:4101)   // Unreferenced local variable

#ifdef  ALLOC_PRAGMA
#pragma alloc_text(PAGE, MRxSmbWrite)
#pragma alloc_text(PAGE, MRxSmbWriteMailSlot)
#pragma alloc_text(PAGE, MRxSmbBuildWriteRequest)
#pragma alloc_text(PAGE, SmbPseExchangeStart_Write)
#pragma alloc_text(PAGE, MRxSmbFinishWrite)
#endif

#define MAX(a,b) ((a) > (b) ? (a) : (b))

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

#ifndef FORCE_NO_NTWRITEANDX
#define MRxSmbForceNoNtWriteAndX FALSE
#else
BOOLEAN MRxSmbForceNoNtWriteAndX = TRUE;
#endif

#define WRITE_COPY_THRESHOLD 64
#define FORCECOPYMODE FALSE

#ifdef SETFORCECOPYMODE
#undef  FORCECOPYMODE
#define FORCECOPYMODE MRxSmbForceCopyMode
ULONG MRxSmbForceCopyMode = TRUE;
#endif

extern ULONG MaxNumOfExchangesForPipelineReadWrite;

NTSTATUS
SmbPseExchangeStart_Write(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    );

NTSTATUS
MRxSmbFindNextSectionForReadWrite(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    PULONG NumOfOutstandingExchanges
    );

ULONG MRxSmbWriteSendOptions = 0;

NTSTATUS
MRxSmbDereferenceGlobalReadWrite (
    PSMB_PSE_OE_READWRITE GlobalReadWrite
    )
{
    ULONG RefCount;

    RefCount = InterlockedDecrement(&GlobalReadWrite->RefCount);
    SmbCeLog(("Deref GRW %x %d\n",GlobalReadWrite,RefCount));

    if (RefCount == 0) {
        PRX_CONTEXT RxContext = GlobalReadWrite->RxContext;
        PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;

        // update shadow as appropriate
        // We do this here to ensure the shadow is updated only once (at IRP completion)
        IF_NOT_MRXSMB_CSC_ENABLED{
            ASSERT(MRxSmbGetSrvOpenExtension(SrvOpen)->hfShadow == 0);
        } else {
            if (MRxSmbGetSrvOpenExtension(SrvOpen)->hfShadow != 0){
                MRxSmbCscWriteEpilogue(RxContext,&RxContext->StoredStatus);
            }
        }

        if (BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION) &&
            (GlobalReadWrite->SmbFcbHoldingState != SmbFcb_NotHeld)) {
            MRxSmbCscReleaseSmbFcb(RxContext,&GlobalReadWrite->SmbFcbHoldingState);
        }

        RxContext->StoredStatus = GlobalReadWrite->CompletionStatus;
        RxLowIoCompletion(RxContext);

        if (!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
            KeSetEvent(
                GlobalReadWrite->CompletionEvent,
                0,
                FALSE);
        }

        RxFreePool(GlobalReadWrite);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
MRxSmbWrite (
    IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine opens a file across the network.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;

    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange;
    SMBFCB_HOLDING_STATE SmbFcbHoldingState = SmbFcb_NotHeld;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    ULONG NumberOfSections;
    ULONG NumOfOutstandingExchanges = 0;
    ULONG MaximumBufferSizeThisIteration;
    PSMB_PSE_OE_READWRITE GlobalReadWrite = NULL;
    ULONG GlobalReadWriteAllocationSize;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;
    BOOLEAN EnablePipelineWrite = TRUE;
    BOOLEAN MsgModePipeOperation = FALSE;
    BOOLEAN ExchangePending = FALSE;
    KEVENT  CompletionEvent;


    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbWrite\n", 0 ));

    // Pipe buffer cannot be bigger than MAX_PIPE_BUFFER_SIZE, otherwise the
    // server has problems.
    if (RxContext->pFcb->pNetRoot->Type == NET_ROOT_PIPE) {
        if (RxContext->CurrentIrpSp->Parameters.Write.Length > MAX_PIPE_BUFFER_SIZE) {
            return STATUS_INVALID_BUFFER_SIZE;
        }
    }

    if ( NodeType(capFcb) == RDBSS_NTC_MAILSLOT ) {
        // This is an attempt to write on a mailslot file which is handled
        // differently.

        Status = MRxSmbWriteMailSlot(RxContext);

        RxDbgTrace(-1, Dbg, ("MRxSmbWrite: Mailslot write returned %lx\n",Status));
        return Status;
    }

    // For CSC we go ahead and mark an FCB as having been written to.
    // When CSC is turned ON, if this flag is set before we obtained
    // shadow handles, then the data corresponding to the file is
    // deemed stale and is truncated

    if (NodeType(capFcb) == RDBSS_NTC_STORAGE_TYPE_FILE) {
        PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
        smbFcb->MFlags |= SMB_FCB_FLAG_WRITES_PERFORMED;
    }

    ASSERT( NodeType(capFobx->pSrvOpen) == RDBSS_NTC_SRVOPEN );

    SrvOpen = capFobx->pSrvOpen;
    smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    pVNetRootContext = (PSMBCE_V_NET_ROOT_CONTEXT)SrvOpen->pVNetRoot->Context;

    if (smbSrvOpen->OplockLevel == SMB_OPLOCK_LEVEL_II &&
        !BooleanFlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,
                       LOWIO_READWRITEFLAG_PAGING_IO)) {
        PMRX_SRV_CALL             pSrvCall;

        pSrvCall = SrvOpen->pVNetRoot->pNetRoot->pSrvCall;

        RxIndicateChangeOfBufferingStateForSrvOpen(
            pSrvCall,
            SrvOpen,
            MRxSmbMakeSrvOpenKey(pVNetRootContext->TreeId,smbSrvOpen->Fid),
            ULongToPtr(SMB_OPLOCK_LEVEL_NONE));
        SmbCeLog(("Breaking oplock to None in Write SO %lx\n",SrvOpen));
        SmbLog(LOG,
               MRxSmbWrite,
               LOGPTR(SrvOpen));
    }

    IF_NOT_MRXSMB_CSC_ENABLED{
        ASSERT(smbSrvOpen->hfShadow == 0);
    } else {
        if (smbSrvOpen->hfShadow != 0){
            NTSTATUS ShadowReadNtStatus;
            ShadowReadNtStatus = MRxSmbCscWritePrologue(
                                     RxContext,
                                     &SmbFcbHoldingState);

            if (ShadowReadNtStatus != STATUS_MORE_PROCESSING_REQUIRED) {
                RxDbgTrace(-1, Dbg, ("MRxSmbWrite shadow hit with status=%08lx\n", ShadowReadNtStatus ));
                return(ShadowReadNtStatus);
            } else {
                RxDbgTrace(0, Dbg, ("MRxSmbWrite shadowmiss with status=%08lx\n", ShadowReadNtStatus ));
            }
        }
    }

    if (capFcb->pNetRoot->Type == NET_ROOT_PIPE) {
        EnablePipelineWrite = FALSE;

        if (capFobx->PipeHandleInformation->ReadMode != FILE_PIPE_BYTE_STREAM_MODE) {
            MsgModePipeOperation = TRUE;
        }
    }

    if (!FlagOn(pVNetRootContext->pServerEntry->Server.DialectFlags,DF_LARGE_WRITEX)) {
        EnablePipelineWrite = FALSE;
    }

    MaximumBufferSizeThisIteration = pVNetRootContext->pNetRootEntry->NetRoot.MaximumWriteBufferSize;

    if (MsgModePipeOperation) {
        MaximumBufferSizeThisIteration -= 2;
    }

    NumberOfSections = LowIoContext->ParamsFor.ReadWrite.ByteCount / MaximumBufferSizeThisIteration;

    if ( (LowIoContext->ParamsFor.ReadWrite.ByteCount % MaximumBufferSizeThisIteration) ||
         (LowIoContext->ParamsFor.ReadWrite.ByteCount == 0) ) {
        NumberOfSections ++;
    }

    GlobalReadWriteAllocationSize = sizeof(SMB_PSE_OE_READWRITE) +
                                    NumberOfSections*sizeof(SMB_PSE_OE_READWRITE_STATE);

    GlobalReadWrite = RxAllocatePoolWithTag(
                          NonPagedPool,
                          GlobalReadWriteAllocationSize,
                          MRXSMB_RW_POOLTAG);

    if (GlobalReadWrite == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(GlobalReadWrite,GlobalReadWriteAllocationSize);

    GlobalReadWrite->RxContext = RxContext;
    GlobalReadWrite->MaximumBufferSize = MaximumBufferSizeThisIteration;
    GlobalReadWrite->TotalNumOfSections = NumberOfSections;

    if (!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
        KeInitializeEvent(
            &CompletionEvent,
            SynchronizationEvent,
            FALSE);

        GlobalReadWrite->CompletionEvent = &CompletionEvent;
    }

    GlobalReadWrite->UserBufferBase = RxLowIoGetBufferAddress( RxContext );
    GlobalReadWrite->ByteOffsetAsLI.QuadPart = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    GlobalReadWrite->RemainingByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;

    if (GlobalReadWrite->ByteOffsetAsLI.QuadPart == -1 ) {
        GlobalReadWrite->WriteToTheEnd = TRUE;
        GlobalReadWrite->ByteOffsetAsLI.QuadPart = smbSrvOpen->FileInfo.Standard.EndOfFile.QuadPart;
    }

    if (LowIoContext->ParamsFor.ReadWrite.Buffer != NULL) {
        GlobalReadWrite->UserBufferBase = RxLowIoGetBufferAddress( RxContext );
    } else {
        GlobalReadWrite->UserBufferBase = (PBYTE)1;   //any nonzero value will do
    }

    GlobalReadWrite->CompressedReadOrWrite = FALSE;

#if 0
    if (MRxSmbEnableCompression &&
        (capFcb->Attributes & FILE_ATTRIBUTE_COMPRESSED) &&
        (pVNetRootContext->pServerEntry->Server.Capabilities & COMPRESSED_DATA_CAPABILITY)) {
        GlobalReadWrite->CompressedReadOrWrite = TRUE;
        EnablePipelineWrite = FALSE;
    }
#endif

    GlobalReadWrite->ThisBufferOffset = 0;

    GlobalReadWrite->PartialExchangeMdlInUse = FALSE;
    GlobalReadWrite->PartialDataMdlInUse     = FALSE;
    GlobalReadWrite->pCompressedDataBuffer   = NULL;
    GlobalReadWrite->RefCount = 1;
    GlobalReadWrite->SmbFcbHoldingState = SmbFcbHoldingState;

    do {
        Status = SmbPseCreateOrdinaryExchange(
                               RxContext,
                               capFobx->pSrvOpen->pVNetRoot,
                               SMBPSE_OE_FROM_WRITE,
                               SmbPseExchangeStart_Write,
                               &OrdinaryExchange);

        if (Status != STATUS_SUCCESS) {
            GlobalReadWrite->CompletionStatus = Status;
            RxDbgTrace(-1, Dbg, ("Couldn't get the smb buf!\n"));
            break;
        }

        OrdinaryExchange->AsyncResumptionRoutine = SmbPseExchangeStart_Write;
        OrdinaryExchange->GlobalReadWrite = GlobalReadWrite;

        RtlCopyMemory(&OrdinaryExchange->ReadWrite,
                      GlobalReadWrite,
                      sizeof(SMB_PSE_OE_READWRITE));

        if ((capFcb->pNetRoot->Type == NET_ROOT_PIPE) &&
            (capFobx->PipeHandleInformation->ReadMode != FILE_PIPE_BYTE_STREAM_MODE) ) {
            SetFlag(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_MSGMODE_PIPE_OPERATION);
        }

        ExAcquireFastMutex(&MRxSmbReadWriteMutex);

        Status = MRxSmbFindNextSectionForReadWrite(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                   &NumOfOutstandingExchanges);

        ExReleaseFastMutex(&MRxSmbReadWriteMutex);

        if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
            ULONG RefCount;

            RefCount = InterlockedIncrement(&GlobalReadWrite->RefCount);

            SmbCeLog(("Ref GRW %x %d\n",GlobalReadWrite,RefCount));
            SmbCeLog(("Pipeline Write %x %d %d\n",OrdinaryExchange,NumberOfSections,NumOfOutstandingExchanges));

            Status = SmbPseInitiateOrdinaryExchange(OrdinaryExchange);
            NumberOfSections --;

            if ( Status != RX_MAP_STATUS(PENDING) ) {
                ExAcquireFastMutex(&MRxSmbReadWriteMutex);

                if (Status != STATUS_SUCCESS) {
                    NumberOfSections ++;

                    GlobalReadWrite->SectionState[OrdinaryExchange->ReadWrite.CurrentSection] = SmbPseOEReadWriteIoStates_Initial;
                    SmbCeLog(("Section undo %d\n",OrdinaryExchange->ReadWrite.CurrentSection));
                }

                if (!OrdinaryExchange->ReadWrite.ReadWriteFinalized) {
                    MRxSmbDereferenceGlobalReadWrite(GlobalReadWrite);
                    NumOfOutstandingExchanges = InterlockedDecrement(&GlobalReadWrite->NumOfOutstandingOperations);
                } else {
                    NumOfOutstandingExchanges --;
                }

                if ((Status == STATUS_TOO_MANY_COMMANDS) && (NumOfOutstandingExchanges > 0)) {
                    Status = STATUS_SUCCESS;
                }

                if ((Status != STATUS_SUCCESS) &&
                    (GlobalReadWrite->CompletionStatus == STATUS_SUCCESS)) {
                    GlobalReadWrite->CompletionStatus = Status;
                }

                ExReleaseFastMutex(&MRxSmbReadWriteMutex);

                SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
            }
            else {
                ExchangePending = TRUE;
            }

            if (NumOfOutstandingExchanges >= MaxNumOfExchangesForPipelineReadWrite) {
                break;
            }
        } else {
            SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
            Status = STATUS_PENDING;
            break;
        }
    } while ((Status == STATUS_RETRY) ||
             EnablePipelineWrite &&
             (NumberOfSections > 0) &&
             (Status == STATUS_PENDING));

    SmbCeLog(("Pipeline Write out %x %d\n",Status,NumberOfSections));

    MRxSmbDereferenceGlobalReadWrite(GlobalReadWrite);

    if (!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {
        KeWaitForSingleObject(
            &CompletionEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL );

        Status = RxContext->StoredStatus;

        if (SmbFcbHoldingState != SmbFcb_NotHeld) {
            MRxSmbCscReleaseSmbFcb(
                RxContext,
                &SmbFcbHoldingState);
        }
    } else {
        Status = STATUS_PENDING;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbWrite  exit with status=%08lx\n", Status ));

    return(Status);
} // MRxSmbWrite

NTSTATUS
MRxSmbWriteMailSlot(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine processes a write smb for a mail slot.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = RX_MAP_STATUS(SUCCESS);

    RxCaptureFcb;
    RxCaptureFobx;

    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;

    UNICODE_STRING TransactionName;
    UNICODE_STRING MailSlotName;
    PUNICODE_STRING FcbName = &(((PFCB)(capFcb))->FcbTableEntry.Path);
    PUNICODE_STRING AlreadyPrefixedName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);

    PAGED_CODE();

    if (AlreadyPrefixedName->Length > sizeof(WCHAR)) {
        MailSlotName.Length = AlreadyPrefixedName->Length - sizeof(WCHAR);
    } else {
        MailSlotName.Length = 0;
    }

    MailSlotName.MaximumLength = MailSlotName.Length;
    MailSlotName.Buffer = AlreadyPrefixedName->Buffer + 1;

    TransactionName.Length = (USHORT)(s_MailSlotTransactionName.Length +
                                     MailSlotName.Length);
    TransactionName.MaximumLength = TransactionName.Length;
    TransactionName.Buffer = (PWCHAR)RxAllocatePoolWithTag(
                                        PagedPool,
                                        TransactionName.Length,
                                        MRXSMB_MAILSLOT_POOLTAG);

    if (TransactionName.Buffer != NULL) {
        USHORT    Setup[3];        // Setup params for mailslot write transaction
        USHORT    OutputParam;

        PBYTE  pInputDataBuffer        = NULL;
        PBYTE  pOutputDataBuffer       = NULL;

        ULONG  InputDataBufferLength   = 0;
        ULONG  OutputDataBufferLength  = 0;

        SMB_TRANSACTION_RESUMPTION_CONTEXT  ResumptionContext;
        SMB_TRANSACTION_OPTIONS             TransactionOptions;

        TransactionOptions = RxDefaultTransactionOptions;

        pInputDataBuffer = RxLowIoGetBufferAddress( RxContext );
        InputDataBufferLength= pLowIoContext->ParamsFor.ReadWrite.ByteCount;

        RtlCopyMemory(
            TransactionName.Buffer,
            s_MailSlotTransactionName.Buffer,
            s_MailSlotTransactionName.Length );

        RtlCopyMemory(
            (PBYTE)TransactionName.Buffer +
             s_MailSlotTransactionName.Length,
            MailSlotName.Buffer,
            MailSlotName.Length );

        RxDbgTrace(0, Dbg, ("MRxSmbWriteMailSlot: Mailslot transaction name %wZ\n",&TransactionName));

        Setup[0] = TRANS_MAILSLOT_WRITE;
        Setup[1] = 0;                   // Priority of write
        Setup[2] = 2;                   // Unreliable request (Second class mailslot)

        TransactionOptions.NtTransactFunction = 0; // TRANSACT2/TRANSACT.
        TransactionOptions.pTransactionName   = &TransactionName;
        TransactionOptions.Flags              = (SMB_TRANSACTION_NO_RESPONSE |
                                               SMB_XACT_FLAGS_FID_NOT_NEEDED |
                                               SMB_XACT_FLAGS_MAILSLOT_OPERATION);
        TransactionOptions.TimeoutIntervalInMilliSeconds =
                                             SMBCE_TRANSACTION_TIMEOUT_NOT_USED;

        Status = SmbCeTransact(
                     RxContext,                    // RXContext for transaction
                     &TransactionOptions,          // transaction options
                     Setup,                        // the setup buffer
                     sizeof(Setup),                // setup buffer length
                     NULL,                         // the output  setup buffer
                     0,                            // output setup buffer length
                     NULL,                         // Input Param Buffer
                     0,                            // Input param buffer length
                     &OutputParam,                 // Output param buffer
                     sizeof(OutputParam),          // output param buffer length
                     pInputDataBuffer,             // Input data buffer
                     InputDataBufferLength,        // Input data buffer length
                     NULL,                         // output data buffer
                     0,                            // output data buffer length
                     &ResumptionContext            // the resumption context
                     );

        if ( RX_MAP_STATUS(SUCCESS) == Status ) {
            RxContext->InformationToReturn += InputDataBufferLength;
        }

        RxFreePool( TransactionName.Buffer );
    } else {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    RxDbgTrace( 0, Dbg, ("MRxSmbMailSlotWrite: ...returning %lx\n",Status));

    return Status;
} // MRxSmbWriteMailSlot

NTSTATUS
MRxSmbPrepareCompressedWriteRequest(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    PBYTE                      *pWriteDataBufferPointer,
    PMDL                       *pWriteDataMdlPointer)
/*++

Routine Description:

    This routine prepares the buffers for a compressed write request

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    The write requests issued to an uplevel server for a file which is stored in
    a compressed fashion on the server can be classified into two categories ..

        1) ALIGNED WRITE REQUESTS
            These requests begin at an offset in the file which is an integral
            multiple of the compression chunk size. If the write length is either
            an integral multiple of the number of chunks or the write is at the
            end of the file then the data can be sent as a compressed write request.

        2) UNALIGNED WRITE REQUESTS
            These requests begin at offsets which are not an integral multiple of
            the compression chunk size.

    Any Write request submitted by the user can be decomposed into atmost two
    UNALIGNED WRITE REQUESTS and 0 or more ALIGNED WRITE REQUESTS.

    The RDR adopts a strategy of sending atmst 64K of compressed data alongwith
    the COMPRESSED_DATA_INFO structure in a single write request to the server.
    In the worst case this will involving writing the request 64k at a time
    ( no compression possible in the given data ) and in the best case we will
    be able to write using a single request.

    In addition to the write buffer supplied by the user we require two more
    buffers to complete the write request using compressed data. The first
    buffer is for holding the COMPRESSED_DATA_INFO structure and the second
    buffer is for holding the compressed data. The buffer associated with the
    exchange is used to hold the CDI while a separate buffer is allocated to store
    the compressed data. The two MDL's allocated as part of the
    SMB_PSE_OE_READWRITE is used as the MDLs for the compressed data buffer and
    the COMPRESSED_DATA_INFO structure

--*/
{
#define COMPRESSED_DATA_BUFFER_SIZE (0x10000)

    NTSTATUS Status = STATUS_SUCCESS;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PSMBCE_NET_ROOT pNetRoot;

    PCOMPRESSED_DATA_INFO pCompressedDataInfo;
    PUCHAR  pWriteDataBuffer;
    ULONG   WriteDataBufferLength,CompressedDataInfoLength;
    ULONG   CompressedDataLength;
    USHORT  NumberOfChunks;

    *pWriteDataBufferPointer = NULL;
    *pWriteDataMdlPointer    = NULL;

    pWriteDataBuffer = rw->UserBufferBase + rw->ThisBufferOffset;

    pNetRoot = SmbCeGetExchangeNetRoot((PSMB_EXCHANGE)OrdinaryExchange);

    rw->CompressedRequestInProgress = FALSE;

    if (rw->RemainingByteCount < (2 * pNetRoot->ChunkSize)) {
        WriteDataBufferLength = rw->RemainingByteCount;
    } else if (rw->ByteOffsetAsLI.LowPart & (pNetRoot->ChunkSize - 1)) {
        // The Write request is not aligned at a chunk size. Send the unaligned
        // portion as an uncompressed write request

        WriteDataBufferLength = pNetRoot->ChunkSize -
                                (
                                 rw->ByteOffsetAsLI.LowPart &
                                 (pNetRoot->ChunkSize - 1)
                                );
    } else {
        PUCHAR pCompressedDataBuffer,pWorkSpaceBuffer;
        ULONG  WorkSpaceBufferSize,WorkSpaceFragmentSize;

        if (rw->pCompressedDataBuffer == NULL) {
            rw->pCompressedDataBuffer = RxAllocatePoolWithTag(
                                            NonPagedPool,
                                            COMPRESSED_DATA_BUFFER_SIZE,
                                            MRXSMB_RW_POOLTAG);

            if (rw->pCompressedDataBuffer == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        pCompressedDataBuffer = rw->pCompressedDataBuffer;

        if (Status == STATUS_SUCCESS) {
            Status = RtlGetCompressionWorkSpaceSize(
                         COMPRESSION_FORMAT_LZNT1,
                         &WorkSpaceBufferSize,
                         &WorkSpaceFragmentSize );

            if (Status == STATUS_SUCCESS) {
                pWorkSpaceBuffer = RxAllocatePoolWithTag(
                                       PagedPool,
                                       WorkSpaceBufferSize,
                                       MRXSMB_RW_POOLTAG);

                if (pWorkSpaceBuffer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
            }
        }

        if (Status == STATUS_SUCCESS) {
            COMPRESSED_DATA_INFO CompressedChunkInfo;

            USHORT MaximumNumberOfChunks;
            ULONG  CompressedChunkInfoLength;
            ULONG  RequestByteCount;

            RequestByteCount = rw->RemainingByteCount -
                               (rw->RemainingByteCount & (pNetRoot->ChunkSize - 1));

            CompressedChunkInfoLength = sizeof(CompressedChunkInfo);

            pCompressedDataInfo = (PCOMPRESSED_DATA_INFO)
                                  ROUND_UP_POINTER(
                                      (StufferState->BufferBase +
                                       sizeof(SMB_HEADER) +
                                       FIELD_OFFSET(REQ_NT_WRITE_ANDX,Buffer)),
                                      ALIGN_QUAD);

            CompressedDataInfoLength = (ULONG)(StufferState->BufferLimit -
                                               (PBYTE)pCompressedDataInfo);

            MaximumNumberOfChunks = (USHORT)(
                                        (CompressedDataInfoLength -
                                         FIELD_OFFSET(
                                             COMPRESSED_DATA_INFO,
                                             CompressedChunkSizes)) /
                                        sizeof(ULONG));

            if ((RequestByteCount / pNetRoot->ChunkSize) < MaximumNumberOfChunks) {
                MaximumNumberOfChunks = (USHORT)(RequestByteCount /
                                                 pNetRoot->ChunkSize);
            }

            pCompressedDataInfo->CompressionFormatAndEngine =
                pNetRoot->CompressionFormatAndEngine;
            pCompressedDataInfo->ChunkShift =
                pNetRoot->ChunkShift;
            pCompressedDataInfo->CompressionUnitShift =
                pNetRoot->CompressionUnitShift;
            pCompressedDataInfo->ClusterShift =
                pNetRoot->ClusterShift;

            RtlCopyMemory(
                &CompressedChunkInfo,
                pCompressedDataInfo,
                FIELD_OFFSET(
                    COMPRESSED_DATA_INFO,
                    NumberOfChunks)
                );

            NumberOfChunks = 0;
            CompressedDataLength = 0;

            for (;;) {
                if ((COMPRESSED_DATA_BUFFER_SIZE - CompressedDataLength) <
                    pNetRoot->ChunkSize) {
                    if (CompressedDataLength == 0) {
                        Status = STATUS_SMB_USE_STANDARD;
                    }
                    break;
                }

                Status = RtlCompressChunks(
                             pWriteDataBuffer,
                             pNetRoot->ChunkSize,
                             pCompressedDataBuffer,
                             (COMPRESSED_DATA_BUFFER_SIZE - CompressedDataLength),
                             &CompressedChunkInfo,
                             CompressedChunkInfoLength,
                             pWorkSpaceBuffer);

                if (Status != STATUS_SUCCESS) {
                    break;
                }

                pCompressedDataBuffer += CompressedChunkInfo.CompressedChunkSizes[0];
                CompressedDataLength += CompressedChunkInfo.CompressedChunkSizes[0];

                pCompressedDataInfo->CompressedChunkSizes[NumberOfChunks] =
                    CompressedChunkInfo.CompressedChunkSizes[0];

                pWriteDataBuffer += pNetRoot->ChunkSize;

                if (++NumberOfChunks >= MaximumNumberOfChunks) {
                    break;
                }
            }

            if (Status != STATUS_SUCCESS) {
                if (CompressedDataLength  > 0) {
                    Status = STATUS_SUCCESS;
                }
            }

            if (Status == STATUS_SUCCESS) {
                rw->CompressedRequestInProgress = TRUE;
                pWriteDataBuffer = rw->pCompressedDataBuffer;
                WriteDataBufferLength = CompressedDataLength;
            } else if (Status != STATUS_BUFFER_TOO_SMALL) {
                DbgPrint("Failure compressing data -- Status %lx, Switching over to uncompressed\n",Status);
            }

            if (pWorkSpaceBuffer != NULL) {
                RxFreePool(
                    pWorkSpaceBuffer);
            }
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (Status == STATUS_SUCCESS) {
        rw->PartialDataMdlInUse = TRUE;

        MmInitializeMdl(
            &rw->PartialDataMdl,
            pWriteDataBuffer,
            WriteDataBufferLength);

        MmBuildMdlForNonPagedPool( &rw->PartialDataMdl );

        if (rw->CompressedRequestInProgress) {
            rw->CompressedDataInfoLength = FIELD_OFFSET(
                                               COMPRESSED_DATA_INFO,
                                               CompressedChunkSizes) +
                                               NumberOfChunks * sizeof(ULONG);
            pCompressedDataInfo->NumberOfChunks = NumberOfChunks;

            rw->PartialExchangeMdlInUse = TRUE;

            MmInitializeMdl(
                &rw->PartialExchangeMdl,
                pCompressedDataInfo,
                rw->CompressedDataInfoLength);

            MmBuildMdlForNonPagedPool( &rw->PartialExchangeMdl );

            rw->ThisByteCount = pCompressedDataInfo->NumberOfChunks *
                                pNetRoot->ChunkSize;

            rw->PartialExchangeMdl.Next = &rw->PartialDataMdl;

            *pWriteDataMdlPointer = &rw->PartialExchangeMdl;
        } else {
            rw->ThisByteCount = WriteDataBufferLength;

            *pWriteDataMdlPointer = &rw->PartialDataMdl;
        }
    } else {
        // If for whatever reason the compression fails switch over to an
        // uncompressed write mode.
        rw->CompressedReadOrWrite = FALSE;
    }

    ASSERT(
        !rw->CompressedReadOrWrite ||
        ((*pWriteDataMdlPointer != NULL) && (*pWriteDataBufferPointer == NULL)));

    return Status;
}

NTSTATUS
MRxSmbBuildWriteRequest(
    PSMB_PSE_ORDINARY_EXCHANGE OrdinaryExchange,
    BOOLEAN                    IsPagingIo,
    UCHAR                      WriteCommand,
    ULONG                      ByteCount,
    PLARGE_INTEGER             ByteOffsetAsLI,
    PBYTE                      Buffer,
    PMDL                       BufferAsMdl)
/*++

Routine Description:

    This is the start routine for write.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_PSE_OE_READWRITE GlobalReadWrite = OrdinaryExchange->GlobalReadWrite;
    PRX_CONTEXT RxContext = StufferState->RxContext;

    RxCaptureFcb;
    RxCaptureFobx;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;

    PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)(StufferState->BufferBase);

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    ULONG OffsetLow,OffsetHigh;

    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;

    USHORT  WriteMode = 0;
    ULONG   DataLengthLow,DataLengthHigh;
    ULONG   BytesRemaining = 0;
    BOOLEAN AddLengthBytes = FALSE;
    ULONG   WriteCommandSize;

    PSMBCE_SERVER pServer = SmbCeGetExchangeServer((PSMB_EXCHANGE)OrdinaryExchange);
    BOOLEAN UseNtVersion;

    UseNtVersion = BooleanFlagOn(pServer->DialectFlags,DF_NT_SMBS) &&
                   !MRxSmbForceNoNtWriteAndX;

    // The data length field in SMB is a USHORT, and hence the data length given
    // needs to be split up into two parts -- DataLengthHigh and DataLengthLow
    DataLengthLow  = (ByteCount & 0xffff);
    DataLengthHigh = ((ByteCount & 0xffff0000) >> 16);

    OffsetLow  = ByteOffsetAsLI->LowPart;
    OffsetHigh = ByteOffsetAsLI->HighPart;

    switch (WriteCommand) {
    case SMB_COM_WRITE_ANDX:
        WriteCommandSize = SMB_REQUEST_SIZE(NT_WRITE_ANDX);
        break;
    case SMB_COM_WRITE:
        WriteCommandSize = SMB_REQUEST_SIZE(WRITE);
        break;
    case SMB_COM_WRITE_PRINT_FILE:
        WriteCommandSize = SMB_REQUEST_SIZE(WRITE_PRINT_FILE);
        break;
    }

    Status = MRxSmbStartSMBCommand(
                 StufferState,
                 SetInitialSMB_Never,
                 WriteCommand,
                 WriteCommandSize,
                 NO_EXTRA_DATA,
                 NO_SPECIAL_ALIGNMENT,
                 RESPONSE_HEADER_SIZE_NOT_SPECIFIED,
                 0,0,0,0 STUFFERTRACE(Dbg,'FC'));

    MRxSmbDumpStufferState(
        1000,
        "SMB Write Request before stuffing",
        StufferState);

    switch (WriteCommand) {
    case SMB_COM_WRITE_ANDX :
        {
            if ( UseNtVersion && IsPagingIo ) {
                SmbPutAlignedUshort(
                    &NtSmbHeader->Flags2,
                    SmbGetAlignedUshort(&NtSmbHeader->Flags2)|SMB_FLAGS2_PAGING_IO );
            }

            // set the writemode correctly....mainly multismb pipe stuff but also
            // writethru for diskfiles
            if (FlagOn(
                    OrdinaryExchange->OpSpecificFlags,
                    OE_RW_FLAG_MSGMODE_PIPE_OPERATION) ) {

                //DOWNLEVEL pinball has wants a different value here....see rdr1.

                // We need to use the GlobalReadWrite structure here because the local one
                // will always have RemainingByteCount == write length.  Note that pipe writes
                // will be broken if we do not disable pipeline writes on them..
                BytesRemaining = GlobalReadWrite->RemainingByteCount;

                //  If this write takes more than one Smb then we must set WRITE_RAW.
                //  The first Smb of the series must have START_OF_MESSAGE.
                if (!FlagOn(
                        OrdinaryExchange->OpSpecificFlags,
                        OE_RW_FLAG_SUBSEQUENT_OPERATION) ) {
                    if ( rw->ThisByteCount < BytesRemaining ) {

                        //  First Smb in a multi SMB write.
                        //  Add a USHORT at the start of data saying how large the
                        //  write is.

                        AddLengthBytes = TRUE;
                        DataLengthLow += sizeof(USHORT);
                        ASSERT(DataLengthHigh == 0);

                        SetFlag(
                            OrdinaryExchange->OpSpecificFlags,
                            OE_RW_FLAG_REDUCE_RETURNCOUNT);

                        //  Tell the server that the data has the length at the start.
                        WriteMode |= (SMB_WMODE_WRITE_RAW_NAMED_PIPE |
                                      SMB_WMODE_START_OF_MESSAGE);
                    } else {
                        //  All fits in one Smb
                        WriteMode |= SMB_WMODE_START_OF_MESSAGE;
                    }
                } else {
                    // any subsequent pipewrites are obviously raw and not the first
                    WriteMode |= SMB_WMODE_WRITE_RAW_NAMED_PIPE;
                }
            } else {
                // If the data is to be written in a compressed fashion turn on
                // the compressed data bit in the header
                if ((rw->CompressedReadOrWrite) &&
                    (rw->CompressedDataInfoLength > 0)) {
                    ASSERT(UseNtVersion);

                    SmbPutAlignedUshort(
                        &NtSmbHeader->Flags2,
                        SmbGetAlignedUshort(&NtSmbHeader->Flags2) | SMB_FLAGS2_COMPRESSED );

                    // The Remaining field in NT_WRITE_ANDX also doubles as the field
                    // in which the CDI length is sent to the server
                    BytesRemaining = rw->CompressedDataInfoLength;
                }


                //
                //  If the file object was opened in write through mode, set write
                //  through on the write operation.
                if (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_WRITE_THROUGH)) {
                    WriteMode |= SMB_WMODE_WRITE_THROUGH;
                }
            }

            MRxSmbStuffSMB (
                StufferState,
                "XwddwwwwQ",
                                                  //  X UCHAR WordCount;
                                                  //    UCHAR AndXCommand;
                                                  //    UCHAR AndXReserved;
                                                  //    _USHORT( AndXOffset );
                smbSrvOpen->Fid,                  //  w _USHORT( Fid );
                OffsetLow,                        //  d _ULONG( Offset );
                -1,                               //  d _ULONG( Timeout );
                WriteMode,                        //  w _USHORT( WriteMode );
                BytesRemaining,                   //  w _USHORT( Remaining );
                DataLengthHigh,                   //  w _USHORT( DataLengthHigh );
                DataLengthLow,                    //  w _USHORT( DataLength );
                                                  //  Q _USHORT( DataOffset );
                SMB_OFFSET_CHECK(WRITE_ANDX,DataOffset)
                StufferCondition(UseNtVersion), "D",
                SMB_OFFSET_CHECK(NT_WRITE_ANDX,OffsetHigh)
                OffsetHigh,                       //  D NTonly  _ULONG( OffsetHigh );
                                                  //
                STUFFER_CTL_NORMAL, "BS5",
                                                  //  B _USHORT( ByteCount );
                SMB_WCT_CHECK(((UseNtVersion)?14:12))
                                                  //    UCHAR Buffer[1];
                                                  //  S //UCHAR Pad[];
                                                  //  5 //UCHAR Data[];
                StufferCondition(AddLengthBytes), "w", LowIoContext->ParamsFor.ReadWrite.ByteCount,
                StufferCondition(Buffer!=NULL), "c!",
                ByteCount,
                Buffer,                           //  c the actual data
                0
                );
        }
        break;

    case SMB_COM_WRITE :
        {
            MRxSmbStuffSMB (
                StufferState,
                "0wwdwByw",
                                       //  0   UCHAR WordCount;                    // Count of parameter words = 5
                smbSrvOpen->Fid,       //  w   _USHORT( Fid );                     // File handle
                DataLengthLow,         //  w   _USHORT( Count );                   // Number of bytes to be written
                OffsetLow,             //  d   _ULONG( Offset );                   // Offset in file to begin write
                BytesRemaining,        //  w   _USHORT( Remaining );               // Bytes remaining to satisfy request
                SMB_WCT_CHECK(5)       //  B   _USHORT( ByteCount );               // Count of data bytes
                                            //      //UCHAR Buffer[1];                  // Buffer containing:
                0x01,                  //  y     UCHAR BufferFormat;               //  0x01 -- Data block
                DataLengthLow,            //  w     _USHORT( DataLength );            //  Length of data
                                       //        ULONG Buffer[1];                  //  Data
                StufferCondition(Buffer!=NULL), "c!",
                ByteCount,
                Buffer,     //  c     the actual data
                0
                );
        }
        break;

    case SMB_COM_WRITE_PRINT_FILE:
        {
            MRxSmbStuffSMB (
                StufferState,
                "0wByw",
                                       // 0  UCHAR WordCount;                    // Count of parameter words = 1
                smbSrvOpen->Fid,       // w  _USHORT( Fid );                     // File handle
                SMB_WCT_CHECK(1)       // B  _USHORT( ByteCount );               // Count of data bytes; min = 4
                                            //    UCHAR Buffer[1];                    // Buffer containing:
                0x01,                  // y  //UCHAR BufferFormat;               //  0x01 -- Data block
                DataLengthLow,         // w  //USHORT DataLength;                //  Length of data
                                            //    //UCHAR Data[];                     //  Data
                StufferCondition(Buffer!=NULL), "c!",
                ByteCount,
                Buffer,     //  c     the actual data
                0
                );
        }
        break;

    default:
        Status = STATUS_UNSUCCESSFUL ;
        break;
    }

    if ( BufferAsMdl ) {
        MRxSmbStuffAppendRawData( StufferState, BufferAsMdl );
        MRxSmbStuffSetByteCount( StufferState );
    }

    MRxSmbDumpStufferState(
        700,
        "SMB Write Request after stuffing",
        StufferState);

    if (Status==STATUS_SUCCESS) {
        InterlockedIncrement(&MRxSmbStatistics.SmallWriteSmbs);
    }

    return Status;
}

BOOLEAN DisableLargeWrites = 0;

NTSTATUS
SmbPseExchangeStart_Write (
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE
    )
/*++

Routine Description:

    This is the start routine for write.

Arguments:

    pExchange - the exchange instance

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    ULONG StartEntryCount;

    PSMBSTUFFER_BUFFER_STATE StufferState = &OrdinaryExchange->AssociatedStufferState;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PSMB_PSE_OE_READWRITE GlobalReadWrite = OrdinaryExchange->GlobalReadWrite;
    ULONG NumOfOutstandingOperations;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PMDL OriginalDataMdl = LowIoContext->ParamsFor.ReadWrite.Buffer;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FCB  SmbFcb = MRxSmbGetFcbExtension(capFcb);

    BOOLEAN SynchronousIo, IsPagingIo;
    UCHAR   WriteCommand;

    PAGED_CODE();
    RxDbgTrace(+1, Dbg, ("SmbPseExchangeStart_Write\n"));

    ASSERT( OrdinaryExchange->Type == ORDINARY_EXCHANGE );

    ASSERT(
        (
            (OriginalDataMdl!=NULL) &&
            (
                RxMdlIsLocked(OriginalDataMdl) ||
                RxMdlSourceIsNonPaged(OriginalDataMdl)
            )
        ) ||
        (
            (OriginalDataMdl==NULL) &&
            (LowIoContext->ParamsFor.ReadWrite.ByteCount==0)
        )
        );

    ASSERT((OrdinaryExchange->SmbCeFlags&SMBCE_EXCHANGE_ATTEMPT_RECONNECTS) == 0 );

    OrdinaryExchange->StartEntryCount++;
    StartEntryCount = OrdinaryExchange->StartEntryCount;

    SynchronousIo = !BooleanFlagOn(
                        RxContext->Flags,
                        RX_CONTEXT_FLAG_ASYNC_OPERATION);

    IsPagingIo = BooleanFlagOn(
                     LowIoContext->ParamsFor.ReadWrite.Flags,
                     LOWIO_READWRITEFLAG_PAGING_IO);

    // Ensure that the Fid is validated
    SetFlag(OrdinaryExchange->Flags,SMBPSE_OE_FLAG_VALIDATE_FID);

    for (;;) {
        PSMBCE_SERVER         pServer;
        PSMBCE_NET_ROOT       pNetRoot;

        pServer  = SmbCeGetExchangeServer(OrdinaryExchange);
        pNetRoot = SmbCeGetExchangeNetRoot(OrdinaryExchange);

        switch (OrdinaryExchange->OpSpecificState) {
        case SmbPseOEInnerIoStates_Initial:
            {
                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;
                MRxSmbSetInitialSMB( StufferState STUFFERTRACE(Dbg,'FC') );
            }
            //lack of break is intentional

        case SmbPseOEInnerIoStates_ReadyToSend:
            {
                ULONG MaximumBufferSizeThisIteration;
                PCHAR Buffer = NULL;
                PMDL  BufferAsMdl = NULL;

                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_OperationOutstanding;
                OrdinaryExchange->SendOptions = MRxSmbWriteSendOptions;

                if (FlagOn(pServer->DialectFlags,DF_LANMAN10) &&
                    FlagOn(pServer->DialectFlags,DF_LARGE_FILES) &&
                    (StufferState->RxContext->pFcb->pNetRoot->Type != NET_ROOT_PRINT)) {
                    WriteCommand = SMB_COM_WRITE_ANDX;
                } else {
                    WriteCommand = SMB_COM_WRITE;
                }

                MaximumBufferSizeThisIteration = rw->MaximumBufferSize;

                // There are four parameters pertaining to a write request
                //
                //  1. Write Length -- rw->ThisByteCount
                //  2. Write Offset -- rw->ByteOffsetAsLI
                //  3. Write Buffer -- Buffer
                //  4. Write Buffer as a MDL -- BufferAsMdl
                //
                // All writes can be classified into one of the following
                // categories ...
                //
                //  1. Extremely Small writes
                //      These are writes lesser than the COPY_THRESHOLD or
                //      we are in a debug mode that forces us to do only small
                //      writes.
                //
                //  2. Write requests against downlevel servers or non disk
                //     file write requests against up level servers.
                //      In all these cases we are constrained by the Server
                //      which limits the number of bytes to roughly 4k. This
                //      is based upon the Smb Buffer size returned during
                //      negotiation.
                //
                //  3. Write requests ( Uncompressed ) against uplevel (NT5+)
                //     servers
                //      These write requests can be arbitrarily large
                //
                //  4. Write requests (Compressed) against uplevel servers
                //      In these cases the server constrains us to send
                //      only 64k of compressed data with the added restriction
                //      that the compressed data info structure must be less
                //      than the SMB buffer size.
                //

                rw->CompressedDataInfoLength = 0;

                if ((rw->RemainingByteCount < WRITE_COPY_THRESHOLD) ||
                    FORCECOPYMODE) {
                    if (FORCECOPYMODE &&
                        (rw->ThisByteCount > MaximumBufferSizeThisIteration) ) {
                        rw->ThisByteCount = MaximumBufferSizeThisIteration;
                    } else {
                        rw->ThisByteCount = rw->RemainingByteCount;
                    }

                    Buffer = rw->UserBufferBase + rw->ThisBufferOffset;

                    ASSERT( WRITE_COPY_THRESHOLD <= pNetRoot->MaximumWriteBufferSize );
                } else {
                    if (rw->CompressedReadOrWrite) {
                        MRxSmbPrepareCompressedWriteRequest(
                            OrdinaryExchange,
                            &Buffer,
                            &BufferAsMdl);
                    }

                    if (!rw->CompressedReadOrWrite) {
                        rw->ThisByteCount = min(
                                                rw->RemainingByteCount,
                                                MaximumBufferSizeThisIteration);

                        if ((rw->ThisBufferOffset != 0) ||
                            (rw->ThisByteCount != OriginalDataMdl->ByteCount)) {
                            MmInitializeMdl(
                                &rw->PartialDataMdl,
                                0,
                                MAX_PARTIAL_DATA_MDL_BUFFER_SIZE);

                            IoBuildPartialMdl(
                                OriginalDataMdl,
                                &rw->PartialDataMdl,
                                (PCHAR)MmGetMdlVirtualAddress(OriginalDataMdl) +
                                    rw->ThisBufferOffset,
                                rw->ThisByteCount );

                            BufferAsMdl = &rw->PartialDataMdl;
                        } else {
                            BufferAsMdl = OriginalDataMdl;
                        }
                    }
                }

                Status = MRxSmbBuildWriteRequest(
                             OrdinaryExchange,
                             IsPagingIo,
                             WriteCommand,
                             rw->ThisByteCount,
                             &rw->ByteOffsetAsLI,
                             Buffer,
                             BufferAsMdl);

                if (Status != STATUS_SUCCESS) {
                    RxDbgTrace(0, Dbg, ("bad write stuffer status........\n"));
                    goto FINALLY;
                }

                InterlockedIncrement(&MRxSmbStatistics.WriteSmbs);

                Status = SmbPseOrdinaryExchange(
                             SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                             SMBPSE_OETYPE_WRITE );

                if ( Status == STATUS_PENDING) {
                    goto FINALLY;
                }
            }
            //lack of break is intentional

        case SmbPseOEInnerIoStates_OperationOutstanding:
        case SmbPseOEInnerIoStates_OperationCompleted:
            {
                NTSTATUS ExchangeStatus;

                //
                // If we are retrying the operation, then don't touch the SUBSEQUENT flag.
                //
                if( OrdinaryExchange->Status != STATUS_RETRY ) {
                    SetFlag( OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_SUBSEQUENT_OPERATION );
                }

                OrdinaryExchange->OpSpecificState = SmbPseOEInnerIoStates_ReadyToSend;

                if (rw->PartialExchangeMdlInUse) {
                    MmPrepareMdlForReuse(
                        &rw->PartialExchangeMdl);
                    rw->PartialDataMdlInUse = FALSE;
                }

                if (rw->PartialDataMdlInUse) {
                    MmPrepareMdlForReuse(
                        &rw->PartialDataMdl);
                    rw->PartialDataMdlInUse = FALSE;
                }

                Status = OrdinaryExchange->Status;
                ExchangeStatus = OrdinaryExchange->Status;

                if (Status != STATUS_SUCCESS) {
                    PSMBCE_SESSION pSession = SmbCeGetExchangeSession(OrdinaryExchange);

                    if (Status == STATUS_RETRY) {
                        SmbCeUninitializeExchangeTransport((PSMB_EXCHANGE)OrdinaryExchange);
                        Status = SmbCeReconnect(SmbCeGetExchangeVNetRoot(OrdinaryExchange));

                        if (Status == STATUS_SUCCESS) {
                            OrdinaryExchange->Status = STATUS_SUCCESS;
                            OrdinaryExchange->SmbStatus = STATUS_SUCCESS;
                            Status = SmbCeInitializeExchangeTransport((PSMB_EXCHANGE)OrdinaryExchange);
                            ASSERT(Status == STATUS_SUCCESS);

                            if (Status != STATUS_SUCCESS) {
                                goto FINALLY;
                            }
                        } else {
                            goto FINALLY;
                        }
                    } else if (FlagOn(pSession->Flags,SMBCE_SESSION_FLAGS_REMOTE_BOOT_SESSION) &&
                        (smbSrvOpen->DeferredOpenContext != NULL) &&
                        (Status == STATUS_IO_TIMEOUT ||
                         Status == STATUS_BAD_NETWORK_PATH ||
                         Status == STATUS_NETWORK_UNREACHABLE ||
                         Status == STATUS_USER_SESSION_DELETED ||
                         Status == STATUS_REMOTE_NOT_LISTENING ||
                         Status == STATUS_CONNECTION_DISCONNECTED)) {

                        Status = SmbCeRemoteBootReconnect((PSMB_EXCHANGE)OrdinaryExchange,RxContext);

                        if (Status == STATUS_SUCCESS) {
                            // Resume the write from the previous offset.

                            OrdinaryExchange->SmbStatus = STATUS_SUCCESS;
                            SmbCeInitializeExchangeTransport((PSMB_EXCHANGE)OrdinaryExchange);
                        } else {
                            Status = STATUS_RETRY;
                        }
                    }
                }

                ExAcquireFastMutex(&MRxSmbReadWriteMutex);

                if (ExchangeStatus == STATUS_SUCCESS) {
                    rw->RemainingByteCount -= rw->BytesReturned;
                    RxContext->InformationToReturn += rw->BytesReturned;
                    rw->ByteOffsetAsLI.QuadPart += rw->BytesReturned;
                    rw->ThisBufferOffset += rw->BytesReturned;

                    if (rw->WriteToTheEnd) {
                        smbSrvOpen->FileInfo.Standard.EndOfFile.QuadPart += rw->BytesReturned;
                        MRxSmbUpdateFileInfoCacheFileSize(RxContext, (PLARGE_INTEGER)(&smbSrvOpen->FileInfo.Standard.EndOfFile.QuadPart));
                    }
                }

                if ((Status != STATUS_SUCCESS) ||
                    (rw->RemainingByteCount ==0)) {

                    if (rw->RemainingByteCount == 0) {
                        RxDbgTrace(
                            0,
                            Dbg,
                            (
                             "OE %lx TBC %lx RBC %lx BR %lx TBO %lx\n",
                             OrdinaryExchange,rw->ThisByteCount,
                             rw->RemainingByteCount,
                             rw->BytesReturned,
                             rw->ThisBufferOffset )
                            );

                        RxDbgTrace(
                            0,
                            Dbg,
                            ("Bytes written %lx\n",
                             RxContext->InformationToReturn)
                            );

                        if (rw->pCompressedDataBuffer != NULL) {
                            RxFreePool(rw->pCompressedDataBuffer);
                            rw->pCompressedDataBuffer = NULL;
                        }
                    }

                    if (rw->RemainingByteCount == 0 &&
                        GlobalReadWrite->SectionState[rw->CurrentSection] == SmbPseOEReadWriteIoStates_OperationOutstanding) {
                        GlobalReadWrite->SectionState[rw->CurrentSection] = SmbPseOEReadWriteIoStates_OperationCompleted;
                        SmbCeLog(("Section done %d\n",rw->CurrentSection));
                    } else {
                        GlobalReadWrite->SectionState[rw->CurrentSection] = SmbPseOEReadWriteIoStates_Initial;
                        SmbCeLog(("Section undo %d\n",rw->CurrentSection));
                    }

                    if ((Status == STATUS_RETRY) ||
                        (Status == STATUS_SUCCESS) ||
                        (Status == STATUS_SMB_USE_STANDARD)) {
                        if (Status == STATUS_SMB_USE_STANDARD) {
                            GlobalReadWrite->CompletionStatus = STATUS_SMB_USE_STANDARD;
                        }

                        Status = MRxSmbFindNextSectionForReadWrite(SMBPSE_ORDINARY_EXCHANGE_ARGUMENTS,
                                                                   &NumOfOutstandingOperations);
                    }

                    NumOfOutstandingOperations = InterlockedDecrement(&GlobalReadWrite->NumOfOutstandingOperations);

                    if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
                        if ((Status == STATUS_TOO_MANY_COMMANDS) && (NumOfOutstandingOperations > 0)) {
                            Status = STATUS_SUCCESS;
                        }

                        if (Status != STATUS_SUCCESS &&
                            GlobalReadWrite->CompletionStatus == STATUS_SUCCESS) {
                            GlobalReadWrite->CompletionStatus = Status;
                        }

                        rw->ReadWriteFinalized = TRUE;

                        SmbCeLog(("Pipeline Write final %x %x %d\n",OrdinaryExchange,Status,NumOfOutstandingOperations));
                    }

                    ExReleaseFastMutex(&MRxSmbReadWriteMutex);

                    if (Status != STATUS_MORE_PROCESSING_REQUIRED) {
                        goto FINALLY;
                    }
                } else {
                    ExReleaseFastMutex(&MRxSmbReadWriteMutex);
                }

                RxDbgTrace(
                    0,
                    Dbg,
                    ( "Next Iteration OE %lx RBC %lx TBO %lx\n",
                      OrdinaryExchange,
                      rw->RemainingByteCount,
                      rw->ThisBufferOffset)
                    );

                RxDbgTrace(
                    0,
                    Dbg,
                    ("OE %lx TBC %lx, BR %lx\n",
                     OrdinaryExchange,
                     rw->ThisByteCount,
                     rw->BytesReturned));

                MRxSmbSetInitialSMB(StufferState STUFFERTRACE(Dbg,0));
            }
            break;
        }
    }

FINALLY:

    if (Status != STATUS_PENDING) {
        BOOLEAN ReadWriteOutStanding = FALSE;
        PSMB_PSE_OE_READWRITE GlobalReadWrite = OrdinaryExchange->GlobalReadWrite;

        if (!rw->ReadWriteFinalized) {
            ExAcquireFastMutex(&MRxSmbReadWriteMutex);

            if (rw->RemainingByteCount == 0 &&
                GlobalReadWrite->SectionState[rw->CurrentSection] == SmbPseOEReadWriteIoStates_OperationOutstanding) {
                GlobalReadWrite->SectionState[rw->CurrentSection] = SmbPseOEReadWriteIoStates_OperationCompleted;
                SmbCeLog(("Section done %d\n",rw->CurrentSection));
            } else {
                GlobalReadWrite->SectionState[rw->CurrentSection] = SmbPseOEReadWriteIoStates_Initial;
                SmbCeLog(("Section undo %d\n",rw->CurrentSection));
            }

            NumOfOutstandingOperations = InterlockedDecrement(&GlobalReadWrite->NumOfOutstandingOperations);

            if ((Status == STATUS_TOO_MANY_COMMANDS) && (NumOfOutstandingOperations > 0)) {
                Status = STATUS_SUCCESS;
            }

            if (Status != STATUS_SUCCESS &&
                GlobalReadWrite->CompletionStatus == STATUS_SUCCESS) {
                GlobalReadWrite->CompletionStatus = Status;
            }

            rw->ReadWriteFinalized = TRUE;

            SmbCeLog(("Pipeline Write final %x %x %d\n",OrdinaryExchange,Status,NumOfOutstandingOperations));

            ExReleaseFastMutex(&MRxSmbReadWriteMutex);
        }

        SmbPseFinalizeOrdinaryExchange(OrdinaryExchange);
        MRxSmbDereferenceGlobalReadWrite(GlobalReadWrite);

        Status = STATUS_PENDING;
    }

    RxDbgTrace(-1, Dbg, ("SmbPseExchangeStart_Write exit w %08lx\n", Status ));
    return Status;

} // SmbPseExchangeStart_Write

NTSTATUS
MRxSmbFinishWrite (
    IN OUT  PSMB_PSE_ORDINARY_EXCHANGE  OrdinaryExchange,
    IN      PBYTE                       ResponseBuffer
    )
/*++

Routine Description:

    This routine actually gets the stuff out of the write response and finishes
    the write. Everything you need is locked down... so we can finish in the
    indication routine

Arguments:

    OrdinaryExchange - the exchange instance

    ResponseBuffer - the response

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BytesReturned = 0;

    PAGED_CODE();

    RxDbgTrace(+1, Dbg, ("MRxSmbFinishWrite\n"));
    SmbPseOEAssertConsistentLinkageFromOE("MRxSmbFinishWrite:");

    switch (OrdinaryExchange->LastSmbCommand) {
    case SMB_COM_WRITE_ANDX:
        {
            PSMBCE_SERVER    pServer;
            PSMBCE_NET_ROOT  pNetRoot;
            PRESP_WRITE_ANDX Response = (PRESP_WRITE_ANDX)ResponseBuffer;

            if (Response->WordCount != 6 ||
                SmbGetUshort(&Response->ByteCount) != 0) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            pServer = SmbCeGetExchangeServer((PSMB_EXCHANGE)OrdinaryExchange);
            pNetRoot = SmbCeGetExchangeNetRoot((PSMB_EXCHANGE)OrdinaryExchange);

            BytesReturned = SmbGetUshort( &Response->Count );

            if (FlagOn(pServer->DialectFlags,DF_LARGE_WRITEX)) {
                ULONG BytesReturnedHigh;

                BytesReturnedHigh = SmbGetUshort(&Response->CountHigh);

                BytesReturned = (BytesReturnedHigh << 16) | BytesReturned;
            }

            if (pNetRoot->NetRootType != NET_ROOT_PIPE) {
                if ((OrdinaryExchange->Status == STATUS_SUCCESS) &&
                    (OrdinaryExchange->ReadWrite.ThisByteCount > 2) &&
                    (BytesReturned == 0)) {
                        Status = STATUS_INVALID_NETWORK_RESPONSE;
                }
            } else {
                // Servers are not setting the bytes returned correctly for
                // pipe writes. This enables us to gracefully handle responses
                // from such servers

                BytesReturned = OrdinaryExchange->ReadWrite.ThisByteCount;
            }

            //if we added 2 headerbytes then let's get rid of them......
            if ( FlagOn(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_REDUCE_RETURNCOUNT) ) {
                // BytesReturned -= sizeof(USHORT);
                ClearFlag(OrdinaryExchange->OpSpecificFlags,OE_RW_FLAG_REDUCE_RETURNCOUNT);
            }
        }
        break;

    case SMB_COM_WRITE :
        {
            PRESP_WRITE  Response = (PRESP_WRITE)ResponseBuffer;

            if (Response->WordCount != 1 ||
                SmbGetUshort(&Response->ByteCount) != 0) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            BytesReturned = SmbGetUshort( &Response->Count );
        }
        break;

    case SMB_COM_WRITE_PRINT_FILE:
        {
            PRESP_WRITE_PRINT_FILE Response = (PRESP_WRITE_PRINT_FILE)ResponseBuffer;

            if (Response->WordCount != 0) {
                Status = STATUS_INVALID_NETWORK_RESPONSE;
            }

            //the response does not tell how many bytes were taken! get the byte count from the exchange
            BytesReturned = OrdinaryExchange->ReadWrite.ThisByteCount;
        }
        break;

    default :
        Status = STATUS_INVALID_NETWORK_RESPONSE;
        break;
    }

    RxDbgTrace(0, Dbg, ("-->BytesReturned=%08lx\n", BytesReturned));

    OrdinaryExchange->ReadWrite.BytesReturned = BytesReturned;

    if (Status == STATUS_SUCCESS &&
        OrdinaryExchange->ReadWrite.ThisByteCount > 2 &&
        BytesReturned > OrdinaryExchange->ReadWrite.ThisByteCount) {
        Status = STATUS_INVALID_NETWORK_RESPONSE;

        // For safety sake, don't leave the bogus BytesReturned in our buffers
        OrdinaryExchange->ReadWrite.BytesReturned = OrdinaryExchange->ReadWrite.ThisByteCount;
    }

    // invalidate the name based file info cache since it is almost impossible
    // to know the last write time of the file on the server.
    MRxSmbInvalidateFileInfoCache(OrdinaryExchange->RxContext);

    // Mark FullDir Cache, weak for bdi : Current Invalidate for correctness
    MRxSmbInvalidateFullDirectoryCacheParent(OrdinaryExchange->RxContext, TRUE);

    RxDbgTrace(-1, Dbg, ("MRxSmbFinishWrite   returning %08lx\n", Status ));

    return Status;
} // MRxSmbFinishWrite

NTSTATUS
MRxSmbFindNextSectionForReadWrite(
    SMBPSE_ORDINARY_EXCHANGE_ARGUMENT_SIGNATURE,
    PULONG NumOfOutstandingExchanges
    )
/*++

Routine Description:

    This routine find out the next section for the read/write operation and set up the
    exchange readwrite struction accordingly.

Arguments:

    RxContext - the RDBSS context

    OrdinaryExchange - the exchange instance

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    RxCaptureFcb;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Section;
    BOOLEAN SectionFound = FALSE;
    PSMB_PSE_OE_READWRITE rw = &OrdinaryExchange->ReadWrite;
    PSMB_PSE_OE_READWRITE GlobalReadWrite = OrdinaryExchange->GlobalReadWrite;
    PSMBCE_SERVER         pServer;

    pServer  = SmbCeGetExchangeServer(OrdinaryExchange);
    *NumOfOutstandingExchanges = GlobalReadWrite->NumOfOutstandingOperations;

    if ((GlobalReadWrite->CompletionStatus != STATUS_SUCCESS) &&
        (GlobalReadWrite->CompletionStatus != STATUS_SMB_USE_STANDARD)) {

        Status = GlobalReadWrite->CompletionStatus;
        goto FINALLY;
    }

    if (GlobalReadWrite->CompletionStatus == STATUS_SMB_USE_STANDARD) {
        RxContext->InformationToReturn = 0;

        GlobalReadWrite->CompressedRequestInProgress = FALSE;
        GlobalReadWrite->CompressedReadOrWrite = FALSE;
        GlobalReadWrite->CompletionStatus = STATUS_SUCCESS;
        OrdinaryExchange->Status = STATUS_SUCCESS;

        for (Section=0;Section<GlobalReadWrite->TotalNumOfSections;Section++) {
            switch (GlobalReadWrite->SectionState[Section]) {
            case SmbPseOEReadWriteIoStates_OperationOutstanding:
                 GlobalReadWrite->SectionState[Section] = SmbPseOEReadWriteIoStates_OperationAbandoned;
                 break;
            case SmbPseOEReadWriteIoStates_OperationCompleted:
                 GlobalReadWrite->SectionState[Section] = SmbPseOEReadWriteIoStates_Initial;
                 break;
            }
        }
    }

    for (Section=0;Section<GlobalReadWrite->TotalNumOfSections;Section++) {
        if (GlobalReadWrite->SectionState[Section] == SmbPseOEReadWriteIoStates_Initial) {
            GlobalReadWrite->SectionState[Section] = SmbPseOEReadWriteIoStates_OperationOutstanding;
            SectionFound = TRUE;
            break;
        }
    }

    if (SectionFound) {
        rw->ByteOffsetAsLI.QuadPart = GlobalReadWrite->ByteOffsetAsLI.QuadPart +
                                      (ULONGLONG)GlobalReadWrite->MaximumBufferSize*Section;

        if ((Section == GlobalReadWrite->TotalNumOfSections - 1) &&
            (GlobalReadWrite->RemainingByteCount % GlobalReadWrite->MaximumBufferSize != 0)) {
            rw->RemainingByteCount = GlobalReadWrite->RemainingByteCount % GlobalReadWrite->MaximumBufferSize;
        } else if( GlobalReadWrite->RemainingByteCount != 0 ) {
            rw->RemainingByteCount = GlobalReadWrite->MaximumBufferSize;
        } else {
            rw->RemainingByteCount = 0;
        }

        rw->ThisBufferOffset = GlobalReadWrite->MaximumBufferSize*Section;

        rw->CurrentSection = Section;

        *NumOfOutstandingExchanges = InterlockedIncrement(&GlobalReadWrite->NumOfOutstandingOperations);
        Status = STATUS_MORE_PROCESSING_REQUIRED;
        SmbCeLog(("Next section found %d %x\n",Section,OrdinaryExchange));
    }

FINALLY:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\dconnect.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    DConnect.c

Abstract:

    This module implements the routines by which the a server\share comes
    up in a disconnected state.

Author:

    Joe Linn [JoeLinn]    5-may-1997

Revision History:

    Shishir Pardikar(shishirp)      Various bug fixes   Aug 1997 onwards

    Shishir Pardikar(shishirp)      Change Notification In disconnected state 27-aug-1998

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

#ifdef MRXSMB_BUILD_FOR_CSC_DCON
extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_MRXSMBCSC;
#define Dbg (DEBUG_TRACE_MRXSMBCSC)

WCHAR   wchSingleBackSlash = '\\';
UNICODE_STRING  vRootString = {2,2,&wchSingleBackSlash};     // root string for change notification

WCHAR   vtzOfflineVolume[] = L"Offline";

typedef struct tagNOTIFYEE_FOBX
{
    LIST_ENTRY  NextNotifyeeFobx;
    MRX_FOBX       *pFobx;
}
NOTIFYEE_FOBX, *PNOTIFYEE_FOBX;

PNOTIFYEE_FOBX
PIsFobxInTheList(
    PLIST_ENTRY pNotifyeeFobxList,
    PMRX_FOBX       pFobx
    );

BOOL
FCleanupAllNotifyees(
    PNOTIFY_SYNC pNotifySync,
    PLIST_ENTRY pDirNotifyList,
    PLIST_ENTRY pNotifyeeFobxList,
    PFAST_MUTEX pNotifyeeFobxListMutex
    );

PMRX_SMB_FCB
MRxSmbCscRecoverMrxFcbFromFdb (
    IN PFDB Fdb
    );

NTSTATUS
MRxSmbCscNegotiateDisconnected(
    PSMBCEDB_SERVER_ENTRY   pServerEntry
    )

/*++

Routine Description:

   This routine takes the place of negotiating when the special tranport marker
   has been detected in the negotiate routine.

Arguments:


Return Value:


Notes:


--*/
{
    NTSTATUS Status;

    RxDbgTrace(0,Dbg,("MRxSmbCscNegotiateDisconnected %08lx %08lx\n",
                pServerEntry, pServerEntry->pTransport));
    if (MRxSmbIsCscEnabledForDisconnected) {

        pServerEntry->ServerStatus = STATUS_SUCCESS;

        SmbCeUpdateServerEntryState(
                            pServerEntry,
                            SMBCEDB_ACTIVE);

        //no need for anyting else!
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_HOST_UNREACHABLE;
    }

    return Status;
}

NTSTATUS
MRxSmbCscDisconnectedConnect (
    IN OUT PSMB_CONSTRUCT_NETROOT_EXCHANGE pNetRootExchange
    )
/*++

Routine Description:

   This routine takes the place of connecting when we're doing disconnected
   mode. what we do is to simulate what would happen if the exchange had come thru
   ParseSmbHeader.

Arguments:


Return Value:


Notes:


--*/
{
    NTSTATUS Status = STATUS_PENDING;
    BOOLEAN PostFinalize;
    PSMBCEDB_SERVER_ENTRY   pServerEntry;
//    PSMBCEDB_SESSION_ENTRY  pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    SMBCEDB_OBJECT_STATE SessionState;
    SMBCEDB_OBJECT_STATE NetRootState;

    PMRX_V_NET_ROOT VNetRoot;
    PMRX_NET_ROOT   NetRoot;

    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext;

    CSC_SHARE_HANDLE  hShare;
    CSC_SHADOW_HANDLE  hRootDir,hShadow;


    PRX_CONTEXT RxContext = pNetRootExchange->pCreateNetRootContext->RxContext;

    VNetRoot = pNetRootExchange->SmbCeContext.pVNetRoot;
    NetRoot  = VNetRoot->pNetRoot;

    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(VNetRoot);

    pServerEntry  = SmbCeGetExchangeServerEntry(&pNetRootExchange->Exchange);
//    pSessionEntry = SmbCeGetExchangeSessionEntry(&pNetRootExchange->Exchange);
    pNetRootEntry = SmbCeGetExchangeNetRootEntry(&pNetRootExchange->Exchange);

    if ((NetRoot->Type == NET_ROOT_DISK) ||
        (NetRoot->Type == NET_ROOT_WILD)) {

        ASSERT(MRxSmbIsCscEnabledForDisconnected);

        RxDbgTrace(0,Dbg,("MRxSmbCscDisconnectedConnect %08lx %08lx\n",
                    pServerEntry, pServerEntry->pTransport));

        // init netrootentry. This will be inited by the ObtainShareHandles call
        pNetRootEntry->NetRoot.CscEnabled = TRUE;       // assume csc is enabled
        pNetRootEntry->NetRoot.CscShadowable = FALSE;   // ACHTUNG, don't set this to TRUE
                                                        // otherwise a share will get created
                                                        // in disconnectd state
        

        pNetRootEntry->NetRoot.NetRootType = NET_ROOT_DISK;

        hShare = pNetRootEntry->NetRoot.sCscRootInfo.hShare;
        if (hShare==0) {
            NTSTATUS LocalStatus;
            EnterShadowCrit();
            LocalStatus = MRxSmbCscObtainShareHandles(
                              NetRoot->pNetRootName,
                              TRUE,
                              FALSE,
                              SmbCeGetAssociatedNetRootEntry(NetRoot)
                              );
            if (LocalStatus != STATUS_SUCCESS) {
                RxDbgTrace(0, Dbg,
                    ("MRxSmbCscDisconnectedConnect no server handle -> %08xl %08lx\n",
                        RxContext,LocalStatus ));
            } else {
                hShare = pNetRootEntry->NetRoot.sCscRootInfo.hShare;
            }
            LeaveShadowCrit();
        }
    } else {
        hShare = 0;
    }

    //ok, we have to do everything that parsesmbheader would have done

    if (hShare==0) {
        //can't find it in the table......just fail........
        pNetRootExchange->Status = STATUS_BAD_NETWORK_NAME;
//        SessionState = SMBCEDB_INVALID;
        NetRootState = SMBCEDB_MARKED_FOR_DELETION;
    } else {
        pNetRootExchange->Status = STATUS_SUCCESS;
        pNetRootExchange->SmbStatus = STATUS_SUCCESS;


//        SessionState = SMBCEDB_ACTIVE;

        //NETROOT STUFF
        //some of the netroot stuff is earlier....before the lookup
        NetRootState = SMBCEDB_ACTIVE;
    }

#if 0
    SmbCeUpdateSessionEntryState(
        pSessionEntry,
        SessionState);
#endif

    SmbCeUpdateVNetRootContextState(
        pVNetRootContext,
        NetRootState);

    SmbConstructNetRootExchangeFinalize(
        &pNetRootExchange->Exchange,
        &PostFinalize);

    ASSERT(!PostFinalize);
    return Status;
}

typedef struct _MRXSMBCSC_QUERYDIR_INFO {
    WCHAR Pattern[2];
    FINDSHADOW sFS;
    ULONG uShadowStatus;
    _WIN32_FIND_DATA Find32;
    ULONG NumCallsSoFar;
    BOOLEAN IsNonEmpty;
} MRXSMBCSC_QUERYDIR_INFO, *PMRXSMBCSC_QUERYDIR_INFO;

NTSTATUS
MRxSmbCscLoadNextDirectoryEntry(
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PMRXSMBCSC_QUERYDIR_INFO QuerydirInfo,
    OUT LPHSHADOW hShadowp
    )
{
    NTSTATUS Status;
    int iRet;
    HSHADOW hTmp=0; //???

    if (QuerydirInfo->NumCallsSoFar <= 1)
    {
        iRet = GetAncestorsHSHADOW(QuerydirInfo->sFS.hDir, &hTmp, NULL);

        if (iRet >= SRET_OK)
        {
            iRet = GetShadowInfo(hTmp,
                                QuerydirInfo->sFS.hDir,
                                &QuerydirInfo->Find32,
                                &QuerydirInfo->uShadowStatus,
                                NULL
                                );
            if (iRet >= SRET_OK)
            {

                if (QuerydirInfo->NumCallsSoFar == 0 )
                {
                    QuerydirInfo->Find32.cFileName[0] = (WCHAR)'.';
                    QuerydirInfo->Find32.cFileName[1] = 0;
                    QuerydirInfo->Find32.cAlternateFileName[0] = (WCHAR)'.';
                    QuerydirInfo->Find32.cAlternateFileName[1] = 0;
                }
                else
                {
                    QuerydirInfo->Find32.cFileName[0] = (WCHAR)'.';
                    QuerydirInfo->Find32.cFileName[1] = (WCHAR)'.';
                    QuerydirInfo->Find32.cFileName[2] = 0;
                    QuerydirInfo->Find32.cAlternateFileName[0] = (WCHAR)'.';
                    QuerydirInfo->Find32.cAlternateFileName[1] = (WCHAR)'.';
                    QuerydirInfo->Find32.cAlternateFileName[2] = 0;
                }


            }
        }
    }
    else if (QuerydirInfo->NumCallsSoFar == 2)
    {

        iRet = FindOpenHSHADOW(&QuerydirInfo->sFS,
                               &hTmp,
                               &QuerydirInfo->Find32,
                               &QuerydirInfo->uShadowStatus,
                               NULL);
    } else {
        iRet = FindNextHSHADOW(&QuerydirInfo->sFS,
                               &hTmp,
                               &QuerydirInfo->Find32,
                               &QuerydirInfo->uShadowStatus,
                               NULL);
    }


    if (iRet < SRET_OK)
    {
        Status = STATUS_UNSUCCESSFUL;
    }
    else
    {
        if (QuerydirInfo->NumCallsSoFar >= 2)
        {
            if (hTmp)
            {
                *hShadowp = hTmp;
                Status = STATUS_SUCCESS;
            }
            else
            {
                Status = STATUS_NO_MORE_FILES;
            }
        }
        else
        {
            *hShadowp = hTmp;
            Status = STATUS_SUCCESS;
        }
    }


    QuerydirInfo->NumCallsSoFar++;
    QuerydirInfo->IsNonEmpty = (Status==STATUS_SUCCESS);

    return(Status);
}


NTSTATUS
MRxSmbDCscQueryDirectory (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_FOBX smbFobx = MRxSmbGetFileObjectExtension(capFobx);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    FILE_INFORMATION_CLASS FileInformationClass;
    PBYTE   pBuffer;
    PULONG  pLengthRemaining;
    PFILE_DIRECTORY_INFORMATION pPreviousBuffer = NULL;

    PMRXSMBCSC_QUERYDIR_INFO QuerydirInfo;
    BOOLEAN EnteredCriticalSection = FALSE;

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
         = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    BOOLEAN Disconnected;

    ULONG EntriesReturned = 0;
    BOOLEAN IsResume = FALSE;

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    if (!Disconnected) {
        return (STATUS_CONNECTION_DISCONNECTED);
    }

    // if there is reumeinfo but it is not the one that CSC allocated,
    // we want to fail this find.

    if (smbFobx->Enumeration.ResumeInfo &&
        !FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_IS_CSC_SEARCH))
    {
        return (STATUS_NO_MORE_FILES);
    }

    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbDCscQueryDirectory entry(%08lx)...%08lx %08lx %08lx %08lx\n",
            RxContext,
            FileInformationClass,pBuffer,*pLengthRemaining,
            smbFobx->Enumeration.ResumeInfo ));

    if (smbFobx->Enumeration.ResumeInfo == NULL) {
        PUNICODE_STRING Template = &capFobx->UnicodeQueryTemplate;

        if (smbFobx->Enumeration.WildCardsFound = FsRtlDoesNameContainWildCards(Template)){
            //we need an upcased template for
            RtlUpcaseUnicodeString( Template, Template, FALSE );
        }

        //allocate and initialize the structure
        QuerydirInfo = (PMRXSMBCSC_QUERYDIR_INFO)RxAllocatePoolWithTag(
                                                      PagedPool,
                                                      sizeof(MRXSMBCSC_QUERYDIR_INFO),
                                                      MRXSMB_DIRCTL_POOLTAG);
        if (QuerydirInfo==NULL) {
            RxDbgTrace(0, Dbg, ("  --> Couldn't get the QuerydirInfo!\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto FINALLY;
        }

        smbFobx->Enumeration.Flags |= SMBFOBX_ENUMFLAG_IS_CSC_SEARCH;

        smbFobx->Enumeration.ResumeInfo = (PMRX_SMB_DIRECTORY_RESUME_INFO)QuerydirInfo;
        RtlZeroMemory(QuerydirInfo,sizeof(*QuerydirInfo));
        QuerydirInfo->Pattern[0] = L'*'; //[1] is already null

        QuerydirInfo->sFS.hDir = smbFcb->hShadow;

        QuerydirInfo->sFS.uSrchFlags = FLAG_FINDSHADOW_META
                                         |FLAG_FINDSHADOW_ALLOW_NORMAL
                                         |FLAG_FINDSHADOW_NEWSTYLE;

        QuerydirInfo->sFS.uAttrib = 0xffffffff;
        QuerydirInfo->sFS.lpPattern = &QuerydirInfo->Pattern[0];
        QuerydirInfo->sFS.lpfnMMProc = FsobjMMProc;

    } else {
        QuerydirInfo = (PMRXSMBCSC_QUERYDIR_INFO)(smbFobx->Enumeration.ResumeInfo);
        ASSERT(FlagOn(smbFobx->Enumeration.Flags,SMBFOBX_ENUMFLAG_IS_CSC_SEARCH));
        IsResume = TRUE;
    }

    EnterShadowCrit();
    EnteredCriticalSection = TRUE;

    for (;;) {
        NTSTATUS LoadStatus;
        BOOLEAN FilterFailure;
        UNICODE_STRING FileName,AlternateFileName;
        ULONG SpaceNeeded;
        PBYTE pRememberBuffer;
        _WIN32_FIND_DATA *Find32 = &QuerydirInfo->Find32;
        BOOLEAN BufferOverflow;
        HSHADOW hShadow = 0;

        if (!QuerydirInfo->IsNonEmpty) {
            LoadStatus = MRxSmbCscLoadNextDirectoryEntry(RxContext,QuerydirInfo, &hShadow);
            if (LoadStatus!=STATUS_SUCCESS) {
                smbFobx->Enumeration.Flags &= ~SMBFOBX_ENUMFLAG_IS_CSC_SEARCH;
                Status = (EntriesReturned==0)?STATUS_NO_MORE_FILES:STATUS_SUCCESS;
                if (EntriesReturned > 0)
                    Status = STATUS_SUCCESS;
                else
                    Status = (IsResume == TRUE) ? STATUS_NO_MORE_FILES : STATUS_NO_SUCH_FILE;
                goto FINALLY;
            }
        }

        RxDbgTrace(0, Dbg,
            ("MRxSmbDCscQueryDirectory (%08lx)...qdiryaya <%ws>\n",
                RxContext,
                &QuerydirInfo->Find32.cFileName[0] ));
        RtlInitUnicodeString(&FileName,&QuerydirInfo->Find32.cFileName[0]);
        RtlInitUnicodeString(&AlternateFileName,&QuerydirInfo->Find32.cAlternateFileName[0]);
        RxDbgTrace(0, Dbg,
            ("MRxSmbDCscQueryDirectory (%08lx)...qdiryaya2 <%wZ><%wZ>|<%wZ>\n",
                RxContext,
                &FileName,&AlternateFileName,
                &capFobx->UnicodeQueryTemplate));

        FilterFailure = FALSE;

        if (smbFobx->Enumeration.WildCardsFound ) {
            try
            {
            
                FilterFailure = !FsRtlIsNameInExpression(
                                       &capFobx->UnicodeQueryTemplate,
                                       &FileName,
                                       TRUE,
                                       NULL );
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                FilterFailure = TRUE;
            }
        } else {
            FilterFailure = !RtlEqualUnicodeString(
                                   &capFobx->UnicodeQueryTemplate,
                                   &FileName,
                                   TRUE );   //case-insensitive
        }

        //check shortname
        if (FilterFailure) {
            if (smbFobx->Enumeration.WildCardsFound ) {
                try
                {
                    FilterFailure = !FsRtlIsNameInExpression(
                                           &capFobx->UnicodeQueryTemplate,
                                           &AlternateFileName,
                                           TRUE,
                                           NULL );
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    FilterFailure = TRUE;
                }
            } else {
                FilterFailure = !RtlEqualUnicodeString(
                                       &capFobx->UnicodeQueryTemplate,
                                       &AlternateFileName,
                                       TRUE );   //case-insensitive
            }
        }

        if (FilterFailure) {
            QuerydirInfo->IsNonEmpty = FALSE;
            continue;
        }

        //OK, we have an entry we'd like to return.....see if it will fit.

        pRememberBuffer = pBuffer;
        if (EntriesReturned != 0) {
            pBuffer = (PBYTE)QuadAlignPtr(pBuffer); //assume that this will fit
        }
        SpaceNeeded = smbFobx->Enumeration.FileNameOffset+FileName.Length;

        RxDbgTrace(0, Dbg,
            ("MRxSmbDCscQueryDirectory (%08lx)...qdiryaya3 <%wZ><%wZ>|<%wZ> needs %08lx %08lx %08lx %08lx\n",
                RxContext,
                &FileName,&AlternateFileName,
                &capFobx->UnicodeQueryTemplate,
                pBuffer,SpaceNeeded,pRememberBuffer,*pLengthRemaining));

        if (pBuffer+SpaceNeeded > pRememberBuffer+*pLengthRemaining) {

            //buffer overflow on this enrty....
            //pBuffer = pRememberBuffer; //rollback
            Status = (EntriesReturned==0)?STATUS_BUFFER_OVERFLOW:STATUS_SUCCESS;
            goto FINALLY;

        } else {
            PFILE_DIRECTORY_INFORMATION pThisBuffer = (PFILE_DIRECTORY_INFORMATION)pBuffer;

            if (pPreviousBuffer != NULL) {
                pPreviousBuffer->NextEntryOffset = (ULONG)(((PBYTE)pThisBuffer)-((PBYTE)pPreviousBuffer));
            }
            pPreviousBuffer = pThisBuffer;
            RtlZeroMemory(pBuffer,smbFobx->Enumeration.FileNameOffset);
            RtlCopyMemory(pBuffer+smbFobx->Enumeration.FileNameOffset,
                          FileName.Buffer,
                          FileName.Length);
            *((PULONG)(pBuffer+smbFobx->Enumeration.FileNameLengthOffset)) = FileName.Length;
            //hallucinate the record based on specific return type
            switch (FileInformationClass) {
            case FileNamesInformation:
                break;

            case FileBothDirectoryInformation:{
                PFILE_BOTH_DIR_INFORMATION pThisBufferAsBOTH
                                   = (PFILE_BOTH_DIR_INFORMATION)pThisBuffer;

                //Do not copy more than size of shortname
                pThisBufferAsBOTH->ShortNameLength = min(sizeof(pThisBufferAsBOTH->ShortName),(CCHAR)(AlternateFileName.Length));
                RtlCopyMemory( &pThisBufferAsBOTH->ShortName[0],
                               AlternateFileName.Buffer,
                               pThisBufferAsBOTH->ShortNameLength );
                }
                //no break intentional

            case FileDirectoryInformation:
            case FileFullDirectoryInformation:
                //just fill what we have...
                pThisBuffer->FileAttributes = Find32->dwFileAttributes;
                COPY_STRUCTFILETIME_TO_LARGEINTEGER(
                          pThisBuffer->CreationTime,
                          Find32->ftCreationTime);
                COPY_STRUCTFILETIME_TO_LARGEINTEGER(
                          pThisBuffer->LastAccessTime,
                          Find32->ftLastAccessTime);
                COPY_STRUCTFILETIME_TO_LARGEINTEGER(
                          pThisBuffer->LastWriteTime,
                          Find32->ftLastWriteTime);

                pThisBuffer->EndOfFile.HighPart = Find32->nFileSizeHigh;
                pThisBuffer->EndOfFile.LowPart = Find32->nFileSizeLow;
                pThisBuffer->AllocationSize = pThisBuffer->EndOfFile;

                if (IsLeaf(hShadow)) {
                    PFDB pFDB = MRxSmbCscFindFdbFromHShadow(hShadow);
                    if (pFDB != NULL) {
                        PMRX_SMB_FCB smbFcb = MRxSmbCscRecoverMrxFcbFromFdb(pFDB);
                        PMRX_FCB mrxFcb = smbFcb->ContainingFcb;

                        pThisBuffer->EndOfFile = mrxFcb->Header.FileSize;
                        pThisBuffer->AllocationSize = pThisBuffer->EndOfFile;
                    }
                }

                break;

            default:
               RxDbgTrace( 0, Dbg, ("MRxSmbCoreFileSearch: Invalid FS information class\n"));
               ASSERT(!"this can't happen");
               Status = STATUS_INVALID_PARAMETER;
               goto FINALLY;
            }
            pBuffer += SpaceNeeded;
            *pLengthRemaining -= (ULONG)(pBuffer-pRememberBuffer);
            EntriesReturned++;
            QuerydirInfo->IsNonEmpty = FALSE;
            if (RxContext->QueryDirectory.ReturnSingleEntry) {
                Status = STATUS_SUCCESS;
                goto FINALLY;
            }
        }


    }


FINALLY:

    if (EnteredCriticalSection) {
        LeaveShadowCrit();
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbDCscQueryDirectory exit-> %08lx %08lx\n", RxContext, Status ));
    return Status;
}

NTSTATUS
MRxSmbDCscGetFsSizeInfo (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine routes a fs size query to the underlying filesystem. It does
   this by opening a handle to the priorityqueue inode and uses this to route
   call. CODE.IMPROVEMENT.ASHAMED if the system is converted to use relative
   opens, then we should just use the relative open fileobject for this passthru.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    FS_INFORMATION_CLASS FsInformationClass;
    PBYTE   pBuffer;
    PULONG  pLengthRemaining;
    ULONG PassedInLength,ReturnedLength;

    BOOLEAN CriticalSectionEntered = FALSE;

    PNT5CSC_MINIFILEOBJECT MiniFileObject;

    FsInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbDCscGetFsSizeInfo entry(%08lx)...%08lx  %08lx %08lx\n",
            RxContext,
            FsInformationClass, pBuffer, *pLengthRemaining ));

    EnterShadowCrit();
    CriticalSectionEntered = TRUE;


    OpenFileHSHADOW(ULID_PQ,
                    0,
                    0,
                    (CSCHFILE *)(&MiniFileObject)
                    );

    if (MiniFileObject == NULL) {
        Status = STATUS_UNSUCCESSFUL;
        goto FINALLY;
    }

    PassedInLength = *pLengthRemaining;
    //DbgBreakPoint();

    Status = Nt5CscXxxInformation(
                        (PCHAR)IRP_MJ_QUERY_VOLUME_INFORMATION,
                        MiniFileObject,
                        FsInformationClass,
                        PassedInLength,
                        pBuffer,
                        &ReturnedLength
                        );

    if (!NT_ERROR(Status)) {
        *pLengthRemaining -= ReturnedLength;
    }



FINALLY:
    if (MiniFileObject != NULL) {
        CloseFileLocal((CSCHFILE)(MiniFileObject));
    }

    if (CriticalSectionEntered) {
        LeaveShadowCrit();
    }


    RxDbgTrace(-1, Dbg, ("MRxSmbDCscGetFsSizeInfo exit-> %08lx %08lx %08lx %08lx\n",
                 RxContext, Status, ReturnedLength, *pLengthRemaining ));
    return Status;
}

NTSTATUS
MRxSmbDCscFlush (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine just performs a flush in disconnected mode. since we don't send
   a flush in disconnected mode and since we dont need to flush the shadow
   (since we use all unbuffered writes) we can just return SUCCESS.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;

    PSMBCEDB_SERVER_ENTRY pServerEntry;

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    if (!SmbCeIsServerInDisconnectedMode(pServerEntry)) {
        return(STATUS_MORE_PROCESSING_REQUIRED);
    }

    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbDCscQueryVolumeInformation (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine just performs a queryvolume in disconnected mode. it draws on
   the same philosphy as downlevel queryvolume.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
 
    FS_INFORMATION_CLASS FsInformationClass;
    PBYTE   pBuffer;
    PULONG  pLengthRemaining;
    ULONG   LengthUsed;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
         = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    BOOLEAN Disconnected;
    PSMBCE_NET_ROOT psmbNetRoot = &pNetRootEntry->NetRoot;

    Disconnected = SmbCeIsServerInDisconnectedMode(pServerEntry);

    if (!Disconnected) {
        return(STATUS_CONNECTION_DISCONNECTED);
    }

    FsInformationClass = RxContext->Info.FsInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbDCscQueryVolumeInformation entry(%08lx)...%08lx  %08lx %08lx bytes @ %08lx %08lx %08lx\n",
            RxContext,
            FsInformationClass, pBuffer, *pLengthRemaining,
            smbSrvOpen->hfShadow ));

    switch (FsInformationClass) {
    case FileFsAttributeInformation:
        //here, cause it to return the data from our tableentry in downlvli.c
        if (psmbNetRoot->FileSystemNameLength == 0) {
            //set our name
            psmbNetRoot->FileSystemNameLength = 14;
            psmbNetRoot->FileSystemName[0] = '*';
            psmbNetRoot->FileSystemName[1] = 'N';
            psmbNetRoot->FileSystemName[2] = 'T';
            psmbNetRoot->FileSystemName[3] = '5';
            psmbNetRoot->FileSystemName[4] = 'C';
            psmbNetRoot->FileSystemName[5] = 'S';
            psmbNetRoot->FileSystemName[6] = 'C';
        }
        psmbNetRoot->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES | FILE_UNICODE_ON_DISK;
        psmbNetRoot->MaximumComponentNameLength = 255;
        Status = MRxSmbGetFsAttributesFromNetRoot(RxContext);
        goto FINALLY;
        //no break needed because of gotofinally

    case FileFsVolumeInformation: {
        PFILE_FS_VOLUME_INFORMATION FsVolInfo = (PFILE_FS_VOLUME_INFORMATION)pBuffer;
        
        ASSERT(*pLengthRemaining >= sizeof(FILE_FS_VOLUME_INFORMATION));
        //here, we have no reliable information....return zeros
        FsVolInfo->VolumeCreationTime.QuadPart = 0;
        FsVolInfo->VolumeSerialNumber = 0;
        FsVolInfo->VolumeLabelLength = 0;
        FsVolInfo->SupportsObjects = FALSE;
        
        // calculate the size of the VolumeLabel we have and put it in a temp var
        LengthUsed = *pLengthRemaining - FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION,VolumeLabel[0]);

        LengthUsed = min(LengthUsed, sizeof(vtzOfflineVolume)-2);

        memcpy(FsVolInfo->VolumeLabel, vtzOfflineVolume, LengthUsed);
        FsVolInfo->VolumeLabelLength = LengthUsed;
        *pLengthRemaining -= (FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION,VolumeLabel[0])+LengthUsed);
        }
        goto FINALLY;
        //no break needed because of gotofinally

    case FileFsSizeInformation: case FileFsFullSizeInformation:
        //here, we route to the underlying filesystem
        Status = MRxSmbDCscGetFsSizeInfo(RxContext);
        goto FINALLY;
        //no break needed because of gotofinally

    case FileFsDeviceInformation:
        ASSERT(!"this should have been turned away");
        //no break;
    default:
        Status = STATUS_NOT_IMPLEMENTED;
        goto FINALLY;
    }


FINALLY:

    RxDbgTrace(-1, Dbg, ("MRxSmbDCscQueryVolumeInformation exit(%08lx %08lx)...%08lx  %08lx %08lx bytes @ %08lx\n",
            RxContext, Status,
            FsInformationClass, pBuffer, *pLengthRemaining,
            smbSrvOpen->hfShadow ));

    return Status;
}

NTSTATUS
MRxSmbDCscQueryFileInfo (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine just performs a queryfileinfo in disconnected mode. because info buffering
   is enabled, it should never call down here! so we can just return STATUS_DISCONNECTED
   all the time!.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PSMBPSE_FILEINFO_BUNDLE pFileInfo = &smbSrvOpen->FileInfo;

    FILE_INFORMATION_CLASS FileInformationClass;
    PBYTE   pBuffer;
    PULONG  pLengthRemaining;

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
         = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    BOOLEAN Disconnected;
    PSMBCE_NET_ROOT psmbNetRoot = &pNetRootEntry->NetRoot;

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    if (!Disconnected) {
        PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

        if (pServerEntry->Header.State == SMBCEDB_ACTIVE) {
            return(STATUS_MORE_PROCESSING_REQUIRED);
        } else {
            return(STATUS_CONNECTION_DISCONNECTED);
        }
    }


    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbDCscQueryFileInfo entry(%08lx)...%08lx  %08lx %08lx bytes @ %08lx %08lx %08lx\n",
            RxContext,
            FileInformationClass, pBuffer, *pLengthRemaining,
            smbSrvOpen->hfShadow ));

    switch (FileInformationClass) {
    case FileBasicInformation:
        {
        PFILE_BASIC_INFORMATION Buffer = (PFILE_BASIC_INFORMATION)pBuffer;

        switch (NodeType(capFcb)) {
        case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:
        case RDBSS_NTC_STORAGE_TYPE_FILE:

            //copy in all the stuff that we know....it may be enough.....

            Buffer->ChangeTime     = pFileInfo->Basic.ChangeTime;
            Buffer->CreationTime   = pFileInfo->Basic.CreationTime;
            Buffer->LastWriteTime  = pFileInfo->Basic.LastWriteTime;
            Buffer->LastAccessTime = pFileInfo->Basic.LastAccessTime;
            Buffer->FileAttributes = pFileInfo->Basic.FileAttributes;

            if (FlagOn( capFcb->FcbState, FCB_STATE_TEMPORARY )) {
                SetFlag( Buffer->FileAttributes, FILE_ATTRIBUTE_TEMPORARY );
            }

            RxContext->Info.LengthRemaining -= sizeof(FILE_BASIC_INFORMATION);
            break;

        default:
            Status = STATUS_NOT_IMPLEMENTED;
        }
        }
        break;
    case FileStandardInformation:
        {
        PFILE_STANDARD_INFORMATION Buffer = (PFILE_STANDARD_INFORMATION)pBuffer;
        PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);

        switch (NodeType(capFcb)) {
        case RDBSS_NTC_STORAGE_TYPE_DIRECTORY:
            Buffer->Directory = TRUE;
            RxContext->Info.LengthRemaining -= sizeof(FILE_STANDARD_INFORMATION);
            break;
        case RDBSS_NTC_STORAGE_TYPE_FILE:
            memset(Buffer, 0, sizeof(FILE_STANDARD_INFORMATION));
            Buffer->AllocationSize = smbFcb->NewShadowSize;
            Buffer->EndOfFile = smbFcb->NewShadowSize;
            RxContext->Info.LengthRemaining -= sizeof(FILE_STANDARD_INFORMATION);
            break;
        default:
            Status = STATUS_NOT_IMPLEMENTED;
        }
        }
        break;
    case FileEaInformation:
        {
            PFILE_EA_INFORMATION EaBuffer = (PFILE_EA_INFORMATION)pBuffer;

            EaBuffer->EaSize = 0;
            RxContext->Info.LengthRemaining -= sizeof(FILE_EA_INFORMATION);
        }
        break;
    default:
        Status = STATUS_NOT_IMPLEMENTED;
    }

    RxDbgTrace(-1, Dbg,
        ("MRxSmbDCscQueryFileInfo exit(%08lx %08lx)...%08lx  %08lx %08lx bytes @ %08lx\n",
            RxContext, Status,
            FileInformationClass, pBuffer, *pLengthRemaining,
            smbSrvOpen->hfShadow ));

    return Status;
}

NTSTATUS
MRxSmbDCscSetFileInfo (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine just performs a querydirectory in disconnected mode. it draws on
   the same philosphy as downlevel querydirectory.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    FILE_INFORMATION_CLASS FileInformationClass;
    PBYTE   pBuffer;
    PULONG  pLengthRemaining;
    ULONG DummyReturnedLength;

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
         = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    BOOLEAN Disconnected;
    PSMBCE_NET_ROOT psmbNetRoot = &pNetRootEntry->NetRoot;
    PNT5CSC_MINIFILEOBJECT MiniFileObject = (PNT5CSC_MINIFILEOBJECT)(smbSrvOpen->hfShadow);

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    if (!Disconnected) {
        return(STATUS_CONNECTION_DISCONNECTED);
    }

    FileInformationClass = RxContext->Info.FileInformationClass;
    pBuffer = RxContext->Info.Buffer;
    pLengthRemaining = &RxContext->Info.LengthRemaining;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbDCscSetFileInfo entry(%08lx)...%08lx  %08lx %08lx bytes @ %08lx %08lx %08lx\n",
            RxContext,
            FileInformationClass, pBuffer, *pLengthRemaining,
            smbSrvOpen->hfShadow ));

    switch (FileInformationClass) {
    case FileEndOfFileInformation:
    case FileAllocationInformation:
    case FileBasicInformation:
    case FileDispositionInformation:
        MRxSmbCscSetFileInfoEpilogue(RxContext,&Status);
        goto FINALLY;
    
    case FileRenameInformation:
        MRxSmbCscRenameEpilogue(RxContext,&Status);
        goto FINALLY;

    default:
        Status = STATUS_NOT_IMPLEMENTED;
        goto FINALLY;
    }

FINALLY:

    RxDbgTrace(-1, Dbg,
        ("MRxSmbDCscSetFileInfo exit(%08lx %08lx)...%08lx  %08lx %08lx bytes @ %08lx\n",
            RxContext, Status,
            FileInformationClass, pBuffer, *pLengthRemaining,
            smbSrvOpen->hfShadow ));

    return Status;
}


NTSTATUS
MRxSmbDCscFsCtl(
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine just performs a querydirectory in disconnected mode. it draws on
   the same philosphy as downlevel querydirectory.


Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
MRxSmbDCscIsValidDirectory(
    IN OUT PRX_CONTEXT     RxContext,
    IN     PUNICODE_STRING DirectoryName)
{
    NTSTATUS            Status;
    MRX_SMB_FCB         CscSmbFcb;
    WIN32_FIND_DATA     Find32;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(RxContext->Create.pNetRoot);
    memset(&(CscSmbFcb.MinimalCscSmbFcb), 0, sizeof(CscSmbFcb.MinimalCscSmbFcb));

    if (!pNetRootEntry->NetRoot.sCscRootInfo.hRootDir)
    {
        return STATUS_BAD_NETWORK_PATH;
    }

    EnterShadowCrit();

    Status = MRxSmbCscCreateShadowFromPath(
                DirectoryName,
                &(pNetRootEntry->NetRoot.sCscRootInfo),
                &Find32,
                NULL,
                (CREATESHADOW_CONTROL_NOCREATE |
                 CREATESHADOW_CONTROL_NOREVERSELOOKUP),
                &(CscSmbFcb.MinimalCscSmbFcb),
                RxContext,
                TRUE,
                NULL);

    if ((Status != STATUS_SUCCESS) ||
        !(Find32.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
        Status = STATUS_BAD_NETWORK_PATH;
    }

    LeaveShadowCrit();

    return Status;
}

NTSTATUS
MRxSmbCscNotifyChangeDirectory(
      IN OUT PRX_CONTEXT RxContext
      )

/*++

Routine Description:

    This routine sets a directory notification for a directory in disconnected state
    The smbmini makes this call when it notices that the serverentry is in disconnected state
    All change notifications are maintained in a list, so that when the server is being transitioned
    from offline to online, we can complete all of them.
    
    We use FOBX as the unique key for change notifications.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    If successfully registered a change notify, it returns STATUS_PENDING. It also
    hijacks the IRP and reduces the refcount on the RxContext, so that the wrapper
    will delete this rxcontext.

--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;
    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    BOOLEAN FcbAcquired = FALSE;
    ULONG CompletionFilter;
    BOOLEAN WatchTree;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PUNICODE_STRING pDirName=NULL;
    PNOTIFYEE_FOBX  pNF = NULL;

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);

    if (!RxIsFcbAcquiredExclusive(capFcb)) {
        ASSERT(!RxIsFcbAcquiredShared(capFcb));
        Status = RxAcquireExclusiveFcbResourceInMRx( capFcb );

        FcbAcquired = (Status == STATUS_SUCCESS);
    }

    CompletionFilter = pLowIoContext->ParamsFor.NotifyChangeDirectory.CompletionFilter;
    WatchTree = pLowIoContext->ParamsFor.NotifyChangeDirectory.WatchTree;

    if (!(((PFCB)capFcb)->PrivateAlreadyPrefixedName).Length)
    {
        pDirName = &vRootString;
    }
    else
    {
        pDirName = &(((PFCB)capFcb)->PrivateAlreadyPrefixedName);
    }
    //
    //  Call the Fsrtl package to process the request.
    //

    pNF = AllocMem(sizeof(NOTIFYEE_FOBX));

    if (!pNF)
    {
        return STATUS_INSUFFICIENT_RESOURCES;        
    }

    pNF->pFobx = capFobx;

    SmbCeLog(("chngnotify fobx=%x\n", capFobx));
    SmbLog(LOG,
           MRxSmbCscNotifyChangeDirectory,
           LOGPTR(capFobx));

//    DbgPrint("chngnotify %wZ fobx=%x NR=%x DirList=%x\n", pDirName, capFobx, pNetRootEntry, &pNetRootEntry->NetRoot.DirNotifyList);
    FsRtlNotifyFullChangeDirectory( pNetRootEntry->NetRoot.pNotifySync,
                                    &pNetRootEntry->NetRoot.DirNotifyList,
                                    capFobx,
                                    (PSTRING)pDirName,
                                    WatchTree,
                                    TRUE,
                                    CompletionFilter,
                                    RxContext->CurrentIrp,
                                    NULL,
                                    NULL
                                    );

    // attach this 
    ExAcquireFastMutex(&pNetRootEntry->NetRoot.NotifyeeFobxListMutex);
    
    if (!PIsFobxInTheList(&pNetRootEntry->NetRoot.NotifyeeFobxList, capFobx))
    {
        InsertTailList(&pNetRootEntry->NetRoot.NotifyeeFobxList, &pNF->NextNotifyeeFobx);
    }
    else
    {
        FreeMem((PVOID)pNF);
    }

    ExReleaseFastMutex(&pNetRootEntry->NetRoot.NotifyeeFobxListMutex);

    // as we hijacked the Irp, let us make sure that rdbss gets rid of the rxcontext

    RxCompleteRequest_Real( RxContext, NULL, STATUS_PENDING );

    Status = STATUS_PENDING;

    if (FcbAcquired) {
        RxReleaseFcbResourceInMRx(capFcb );
    }

    return Status;

}

NTSTATUS
MRxSmbCscCleanupFobx(
    IN PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine cleans up a file system object.
   For CSC, the only thing we do is to remove changenotification.
Arguments:

    pRxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{

    RxCaptureFcb;
    RxCaptureFobx;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    BOOLEAN fInList = FALSE;
    PNOTIFYEE_FOBX pNF = NULL;

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);

    if (MRxSmbCSCIsDisconnectedOpen(capFcb, MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen)))
    {
        ExAcquireFastMutex(&pNetRootEntry->NetRoot.NotifyeeFobxListMutex);

        pNF = PIsFobxInTheList(&pNetRootEntry->NetRoot.NotifyeeFobxList, capFobx);

        if (pNF)
        {
            RemoveEntryList(&pNF->NextNotifyeeFobx);
            FreeMem(pNF);
            pNF = NULL;
            fInList = TRUE;
        }
        ExReleaseFastMutex(&pNetRootEntry->NetRoot.NotifyeeFobxListMutex);

        if (fInList)
        {
            SmbCeLog(("chngnotify cleanup fobx=%x\n", capFobx));
            SmbLog(LOG,
                   MRxSmbCscCleanupFobx,
                   LOGPTR(capFobx));
//            DbgPrint("chngnotify Cleanup fobx=%x NR=%x DirList=%x\n", capFobx, pNetRootEntry, &pNetRootEntry->NetRoot.DirNotifyList);
            FsRtlNotifyCleanup (
                pNetRootEntry->NetRoot.pNotifySync,
                &pNetRootEntry->NetRoot.DirNotifyList,
                capFobx
                );
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
MRxSmbCscInitializeNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
    )
/*++

Routine Description:

    This routine initializes, the change notify structures in the netrootentry

Arguments:

Return Value:


--*/
{
        NTSTATUS NtStatus = STATUS_SUCCESS;

        try {
            FsRtlNotifyInitializeSync( &pNetRootEntry->NetRoot.pNotifySync );
        } except(EXCEPTION_EXECUTE_HANDLER) {
                NtStatus = GetExceptionCode();
        }
        if (NtStatus == STATUS_SUCCESS) {
            InitializeListHead( &pNetRootEntry->NetRoot.DirNotifyList );
            InitializeListHead( &pNetRootEntry->NetRoot.NotifyeeFobxList);
            ExInitializeFastMutex(&pNetRootEntry->NetRoot.NotifyeeFobxListMutex);
        }
        return NtStatus;

}

VOID
MRxSmbCscUninitializeNetRootEntry(
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
    )
/*++

Routine Description:

    This routine unitializes, the change notify structures

Arguments:


Return Value:


--*/
{
        FsRtlNotifyUninitializeSync( &pNetRootEntry->NetRoot.pNotifySync );

}

BOOLEAN
MRxSmbCSCIsDisconnectedOpen(
    PMRX_FCB    pFcb,
    PMRX_SMB_SRV_OPEN smbSrvOpen
    )
/*++

Routine Description:

    A slightly more involved check to see whether this is a disconnected open.

Arguments:

Return Value:


--*/
{
    PSMBCEDB_SERVER_ENTRY pServerEntry = SmbCeGetAssociatedServerEntry(pFcb->pNetRoot->pSrvCall);
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(pFcb);

    if(BooleanFlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_DISCONNECTED_OPEN))
    {
        return TRUE;
    }

    // we need to also check that the serverentry is non-NULL. This can happen when
    // you the syetem is about to shut down, or the FCB has been orphaned.
    
    if (pServerEntry && SmbCeIsServerInDisconnectedMode(pServerEntry))
    {
        if (smbFcb->hShadow || smbFcb->hShadowRenamed)
        {
            // is the shadow visible in disconnected state?
            return(IsShadowVisible(TRUE, smbFcb->dwFileAttributes, smbFcb->ShadowStatus) != 0);
        }
    }
    return FALSE;
}
#endif //ifdef MRXSMB_BUILD_FOR_CSC_DCON




PNOTIFYEE_FOBX
PIsFobxInTheList(
    PLIST_ENTRY pNotifyeeFobxList,
    PMRX_FOBX       pFobx
    )
/*++

Routine Description:

    This a support routine form change notification. It checks whether an FOBX, which is
    the redir's internal representation of a handle, is a change notification handle
    or not. Note, the shadow crit sect must be held when calling this.

Arguments:

Return Value:


--*/
{
    PLIST_ENTRY pListEntry;


    pListEntry = pNotifyeeFobxList->Flink;

    if (pListEntry)
    {
        while (pListEntry != pNotifyeeFobxList)
        {
            PNOTIFYEE_FOBX pNF = (PNOTIFYEE_FOBX)CONTAINING_RECORD(pListEntry, NOTIFYEE_FOBX, NextNotifyeeFobx);

            if (pNF->pFobx == pFobx)
            {
                return pNF;
            }
            
            pListEntry = pListEntry->Flink;
        }
    }
    
    return NULL;
}

BOOL
FCleanupAllNotifyees(
    PNOTIFY_SYNC pNotifySync,
    PLIST_ENTRY pDirNotifyList,
    PLIST_ENTRY pNotifyeeFobxList,
    PFAST_MUTEX pNotifyeeFobxListMutex
    )
/*++

Routine Description:

    This routine completes all outstanding changenotifications for a paricular list of 
    notifyees

Arguments:

Return Value:


--*/
{

    PLIST_ENTRY pListEntry;
    PNOTIFYEE_FOBX pNF;
    BOOL fDoneSome = FALSE;

    ExAcquireFastMutex(pNotifyeeFobxListMutex);

    pListEntry = pNotifyeeFobxList->Flink;

    if (pListEntry)
    {
        while (pListEntry != pNotifyeeFobxList)
        {
            pNF = (PNOTIFYEE_FOBX)CONTAINING_RECORD(pListEntry, NOTIFYEE_FOBX, NextNotifyeeFobx);

            SmbCeLog(("chngnotify cleanup fobx=%x\n", pNF->pFobx));
            SmbLog(LOG,
                   FCleanupAllNotifyees,
                   LOGPTR(pNF->pFobx));
//            DbgPrint("chngnotify Cleanup fobx=%x DirList=%x\n", pNF->pFobx, pDirNotifyList);
            FsRtlNotifyCleanup (
                pNotifySync,
                pDirNotifyList,
                pNF->pFobx
                );
            
            RemoveEntryList(&pNF->NextNotifyeeFobx);

            FreeMem(pNF);
            fDoneSome = TRUE;

            pListEntry = pNotifyeeFobxList->Flink;

        }
        
    }
    
    ExReleaseFastMutex(pNotifyeeFobxListMutex);

    return fDoneSome;
}

VOID
MRxSmbCSCResumeAllOutstandingOperations(
    PSMBCEDB_SERVER_ENTRY   pServerEntry
)
/*++

Routine Description:

    This routine completes all outstanding change notifications on the server.
    This is called when a server is being transitioned from offline to online.
    The caller must make sure that smbceresource is held, so that there are
    no synchronization problems while enumerating.

Arguments:

Return Value:


--*/
{
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;

    pNetRootEntry = SmbCeGetFirstNetRootEntry(pServerEntry);
    while (pNetRootEntry != NULL) {
        if (pNetRootEntry->NetRoot.pNotifySync)
        {

            FCleanupAllNotifyees(pNetRootEntry->NetRoot.pNotifySync,
                                &pNetRootEntry->NetRoot.DirNotifyList,
                                &pNetRootEntry->NetRoot.NotifyeeFobxList,
                                &pNetRootEntry->NetRoot.NotifyeeFobxListMutex
                                 );
        }
        pNetRootEntry = SmbCeGetNextNetRootEntry(pServerEntry,pNetRootEntry);
    }
}

VOID
MRxSmbCSCObtainRightsForUserOnFile(
    IN  PRX_CONTEXT     pRxContext,
    HSHADOW             hDir,
    HSHADOW             hShadow,
    OUT ACCESS_MASK     *pMaximalAccessRights,
    OUT ACCESS_MASK     *pGuestMaximalAccessRights
    )
/*++

Routine Description:

    This routine gets the rights for a specific user. The routine is called during
    
    a create operation in disconnected state.
    
    
Arguments:

    pRxContext  Context for the create operation. We use this to get the user SID
    
    hDir        Directory Inode
    
    hShadow     File Inode

    pMaximalAccessRights    Access rights on the file for the user returned to the caller
    
    pGuestMaximalAccessRights Guest Access rights on the file returned to the caller

Return Value:

    None

--*/
{
    NTSTATUS    Status;
    BOOLEAN     AccessGranted = FALSE, SidHasAccessMask;
    SID_CONTEXT SidContext;
    int i;

    *pMaximalAccessRights = *pGuestMaximalAccessRights = 0;

    Status = CscRetrieveSid(
         pRxContext,
         &SidContext);

    if (Status == STATUS_SUCCESS) {
        CACHED_SECURITY_INFORMATION CachedSecurityInformation;

        ULONG BytesReturned,SidLength;
        DWORD CscStatus;
        CSC_SID_INDEX SidIndex;

        if (SidContext.pSid != NULL) {
            SidLength = RtlLengthSid(
                        SidContext.pSid);

        SidIndex = CscMapSidToIndex(
                   SidContext.pSid,
                   SidLength);
        } else {
            SidIndex = CSC_INVALID_SID_INDEX;
        }

        if (SidIndex == CSC_INVALID_SID_INDEX) {
            // The sid was not located in the existing Sid mappings
            // Map this Sid to that of a Guest
            SidIndex = CSC_GUEST_SID_INDEX;
        }

        BytesReturned = sizeof(CachedSecurityInformation);

        CscStatus = GetShadowInfoEx(
            hDir,
            hShadow,
            NULL,
            NULL,
            NULL,
            &CachedSecurityInformation,
            &BytesReturned);

        if (CscStatus == ERROR_SUCCESS) {
            if (BytesReturned == sizeof(CACHED_SECURITY_INFORMATION)) {
                // Walk through the cached access rights to determine the
                // maximal permissible access rights.
                for (i = 0; (i < CSC_MAXIMUM_NUMBER_OF_CACHED_SID_INDEXES); i++) {

                    if(CachedSecurityInformation.AccessRights[i].SidIndex == SidIndex)
                    {
                        if (CSC_GUEST_SID_INDEX != SidIndex)
                        {
                            *pMaximalAccessRights = CachedSecurityInformation.AccessRights[i].MaximalRights;
                        }
                    }

                    if (CachedSecurityInformation.AccessRights[i].SidIndex == CSC_GUEST_SID_INDEX)
                    {
                        *pGuestMaximalAccessRights = CachedSecurityInformation.AccessRights[i].MaximalRights;
                    }
                    
                }
            }

        }

        CscDiscardSid(&SidContext);
    }

}


VOID
MRxSmbCscFlushFdb(
    IN PFDB Fdb
    )
/*++

Routine Description:

    This routine is called from delete ioctl to flush an open file which is being delay closed.
    Files which are closed by the user but for which the redir hasn't pushed out the
    close, cannot have their cached replicas deleted because these are open too. This 
    causes CSCDeleteIoctl to fail, and the user has not idea why.
    
    This routine must be called with ShadowCritSect held
    
Arguments:

    Fdb CSC version of smbfcb.
    
Return Value:

    None

--*/
{
    PMRX_SMB_FCB pSmbFcb;
    PNET_ROOT pNetRoot;

    pSmbFcb = MRxSmbCscRecoverMrxFcbFromFdb(Fdb);
    pNetRoot = (PNET_ROOT)(pSmbFcb->ContainingFcb->pNetRoot);

    LeaveShadowCrit();
    RxScavengeFobxsForNetRoot(pNetRoot,NULL);
    EnterShadowCrit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\agntevnt.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    AgntEvnt.c

Abstract:

    This module implements the interface by which the csc driver reports
    stuff to the agent.

Author:

    Joe Linn [JoeLinn]    5-may-1997

Revision History:

Notes:

Additional synchronization surrounds net_start and net_stop. for netstop, we
have to wait for the agent to signal that he is finished before we can proceed.
we probably we should implement a mechanism by which he can refuse the
netstop. anyway this is done by recording the netstop context that is waiting
before signaling the event. the same sort of thing is true for netstart.
--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_MRXSMBCSC;
#define Dbg (DEBUG_TRACE_MRXSMBCSC)

// A global variable which indicates the current status of the net
// TRUE implies available. This is used in controlling the
// transitioning indication to the agent
LONG CscNetPresent = FALSE;
LONG CscAgentNotifiedOfNetStatusChange = CSC_AGENT_NOT_NOTIFIED;
LONG CscAgentNotifiedOfFullCache = CSC_AGENT_NOT_NOTIFIED;

PKEVENT MRxSmbAgentSynchronizationEvent = NULL;
ULONG MRxSmbAgentSynchronizationEventIdx = 0;
PKEVENT MRxSmbAgentFillEvent = NULL;
PRX_CONTEXT MRxSmbContextAwaitingAgent = NULL;
PRX_CONTEXT MRxSmbContextAwaitingFillAgent = NULL;
LONG    vcntTransportsForCSC=0;
extern ULONG CscSessionIdCausingTransition;

//CODE.IMPROVEMENT.NTIFS had to just know to do this......
extern POBJECT_TYPE *ExEventObjectType;

//CODE.IMPROVEMENT.NTIFS just stole this from oak\in\zwapi.h
NTSYSAPI
NTSTATUS
NTAPI
ZwOpenEvent (
    OUT PHANDLE EventHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

typedef struct _MRXSMBCSC_OPENEVENT_POSTCONTEXT {
    KEVENT PostEvent;
    RX_WORK_QUEUE_ITEM  WorkQueueItem;
} MRXSMBCSC_OPENEVENT_POSTCONTEXT, *PMRXSMBCSC_OPENEVENT_POSTCONTEXT;

VOID
MRxSmbCscOpenAgentEvent (
    BOOLEAN PostedCall);

VOID
MRxSmbCscOpenAgentFillEvent (
    BOOLEAN PostedCall);

NTSTATUS
MRxSmbCscOpenAgentEventPostWrapper(
    IN OUT PMRXSMBCSC_OPENEVENT_POSTCONTEXT OpenEventPostContext
    )
{

    RxDbgTrace( 0, Dbg, ("MRxSmbCscOpenAgentEventPostWrapper entry\n"));

    MRxSmbCscOpenAgentEvent(TRUE);

    RxDbgTrace( 0, Dbg, ("MRxSmbCscOpenAgentEventPostWrapper exit\n"));

    KeSetEvent( &OpenEventPostContext->PostEvent, 0, FALSE );
    return(STATUS_SUCCESS);
}

NTSTATUS
MRxSmbCscOpenAgentFillEventPostWrapper(
    IN OUT PMRXSMBCSC_OPENEVENT_POSTCONTEXT OpenFillEventPostContext
    )
{

    RxDbgTrace( 0, Dbg, ("MRxSmbCscOpenAgentFillEventPostWrapper entry\n"));

    MRxSmbCscOpenAgentFillEvent(TRUE);

    RxDbgTrace( 0, Dbg, ("MRxSmbCscOpenAgentFillEventPostWrapper exit\n"));

    KeSetEvent( &OpenFillEventPostContext->PostEvent, 0, FALSE );
    return(STATUS_SUCCESS);
}

VOID
MRxSmbCscOpenAgentEvent (
    BOOLEAN PostedCall
    )
/*++

Routine Description:

   This routine gets a pointer to the agent's event.

Arguments:

Return Value:

Notes:

    The shadowcrit serialization mutex must have already been acquired before the call.

--*/
{
    NTSTATUS Status;
    HANDLE EventHandle;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR SessEventName[100];
    WCHAR IdBuffer[16];
    UNICODE_STRING IdString;

    ASSERT (MRxSmbAgentSynchronizationEvent == NULL);

    // DbgPrint("MRxSmbCscOpenAgentEvent(%d) Caused by sess 0x%x\n",
    //                 PostedCall,
    //                 CscSessionIdCausingTransition);

    if (PsGetCurrentProcess()!= RxGetRDBSSProcess()) {
        //CODE.IMPROVEMENT we should capture the rdbss process
        //  and avoid this call (RxGetRDBSSProcess)
        NTSTATUS PostStatus;
        MRXSMBCSC_OPENEVENT_POSTCONTEXT PostContext;

        ASSERT(!PostedCall);

        KeInitializeEvent(&PostContext.PostEvent,
                          NotificationEvent,
                          FALSE );

        IF_DEBUG {
            //fill the workqueue structure with deadbeef....all the better to diagnose
            //a failed post
            ULONG i;
            for (i=0;i+sizeof(ULONG)-1<sizeof(PostContext.WorkQueueItem);i+=sizeof(ULONG)) {
                PBYTE BytePtr = ((PBYTE)&PostContext.WorkQueueItem)+i;
                PULONG UlongPtr = (PULONG)BytePtr;
                *UlongPtr = 0xdeadbeef;
            }
        }

        PostStatus = RxPostToWorkerThread(
                         MRxSmbDeviceObject,
                         CriticalWorkQueue,
                         &PostContext.WorkQueueItem,
                         MRxSmbCscOpenAgentEventPostWrapper,
                         &PostContext);

        ASSERT(PostStatus == STATUS_SUCCESS);


        KeWaitForSingleObject( &PostContext.PostEvent,
                               Executive, KernelMode, FALSE, NULL );

        return;
    }

    // Build an event name with the session id at the end
    wcscpy(SessEventName, SESSION_EVENT_NAME_NT);
    wcscat(SessEventName, L"_");
    EventName.Buffer = SessEventName;
    EventName.Length = wcslen(SessEventName) * sizeof(WCHAR);
    EventName.MaximumLength = sizeof(SessEventName);
    IdString.Buffer = IdBuffer;
    IdString.Length = 0;
    IdString.MaximumLength = sizeof(IdBuffer);
    RtlIntegerToUnicodeString(CscSessionIdCausingTransition, 10, &IdString);
    RtlAppendUnicodeStringToString(&EventName, &IdString);

    // DbgPrint("MRxSmbCscOpenAgentEvent: SessEventName = %wZ\n", &EventName);

    InitializeObjectAttributes( &ObjectAttributes,
                                &EventName,
                                0,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    Status = ZwOpenEvent( &EventHandle,
                         EVENT_ALL_ACCESS,
                         &ObjectAttributes
                         );
    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalAgent no event %08lx\n",Status));
        return;
    }

    Status = ObReferenceObjectByHandle( EventHandle,
                                        0,
                                        *ExEventObjectType,
                                        KernelMode,
                                        (PVOID *) &MRxSmbAgentSynchronizationEvent,
                                        NULL );

    MRxSmbAgentSynchronizationEventIdx = CscSessionIdCausingTransition;

    ZwClose(EventHandle);

    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalAgent couldn't reference %08lx\n", Status));
        MRxSmbAgentSynchronizationEvent = NULL;
        MRxSmbAgentSynchronizationEventIdx = 0;
        return;
    }

    return;
}

NTSTATUS
MRxSmbCscSignalAgent (
    PRX_CONTEXT RxContext OPTIONAL,
    ULONG  Controls
    )
/*++

Routine Description:

   This routine signals the csc usermode agent using the appropriate event.

Arguments:

    RxContext - the RDBSS context. if this is provided then the context is
                as the guy who is waiting.

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    The shadowcrit serialization mutex must have already been acquired before the call.
    We will drop it here.


--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN ShadowCritEntered = TRUE; //must be in critsect on
    BOOLEAN PreventLeaveCrit = BooleanFlagOn(Controls,SIGNALAGENTFLAG_DONT_LEAVE_CRIT_SECT);

    RxDbgTrace(+1, Dbg, ("MRxSmbCscSignalAgent entry...%08lx\n",RxContext));

    DbgDoit(ASSERT(vfInShadowCrit));
    ASSERT(MRxSmbIsCscEnabled);

    if (!FlagOn(Controls,SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT)) {
        if (hthreadReint==0) {
            //no agent and no force...just get out
            RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalAgent no agent/noforce %08lx\n", RxContext));
            goto FINALLY;
        }
    }

    if (
        MRxSmbAgentSynchronizationEvent != NULL
            &&
        MRxSmbAgentSynchronizationEventIdx != CscSessionIdCausingTransition
    ) {
        ObDereferenceObject(MRxSmbAgentSynchronizationEvent);
        MRxSmbAgentSynchronizationEvent = NULL;
        MRxSmbAgentSynchronizationEventIdx = 0;
    }

    if (MRxSmbAgentSynchronizationEvent == NULL) {
        MRxSmbCscOpenAgentEvent(FALSE); //FALSE==>not a posted call
        if (MRxSmbAgentSynchronizationEvent == NULL) {
            //still NULL...no agent.........
            RxDbgTrace(0, Dbg, ("MRxSmbCscSignalAgent no event %08lx %08lx\n",
                               RxContext,Status));
            Status = STATUS_SUCCESS;
            goto FINALLY;
        }
    }

    if (RxContext != NULL) {
        MRxSmbContextAwaitingAgent = RxContext;
    }

    if (!PreventLeaveCrit) {
        LeaveShadowCrit();
        ShadowCritEntered = FALSE;
    } else {
        ASSERT(RxContext==NULL); //cant wait with critsect held
    }

    // reduce the window of MRxSmbAgentSynchronizationEvent getting nulled out
    // by explictly checking before pulsing
    if (MRxSmbAgentSynchronizationEvent)
    {
        KeSetEvent(MRxSmbAgentSynchronizationEvent,0,FALSE);
    }

    if (RxContext != NULL) {
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalAgent waiting %08lx\n", RxContext));
        RxWaitSync(RxContext);
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalAgent end of wait %08lx\n", RxContext));
    }

    RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalAgent %08lx\n", RxContext));

FINALLY:
    if (ShadowCritEntered && !PreventLeaveCrit) {
        LeaveShadowCrit();
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscSignalAgent... exit %08lx %08lx\n",
              RxContext, Status));
    return(Status);
}

VOID
MRxSmbCscSignalNetStatus(
    BOOLEAN NetPresent,
    BOOLEAN fFirstLast
    )
{
    if(!MRxSmbIsCscEnabled) {
        return;
    }

    if (NetPresent)
    {
        InterlockedIncrement(&vcntTransportsForCSC);
    }
    else
    {
        if(vcntTransportsForCSC == 0)
        {
            DbgPrint("CSC:Mismatched transport departure messages from mini redir \n");
            return;
        }
        InterlockedDecrement(&vcntTransportsForCSC);
    }

    if (!fFirstLast)
    {
        return;
    }

    InterlockedExchange(
        &CscNetPresent,
        NetPresent);

    InterlockedExchange(
        &CscAgentNotifiedOfNetStatusChange,
        CSC_AGENT_NOT_NOTIFIED);

    CscNotifyAgentOfNetStatusChangeIfRequired(FALSE);
}

VOID
CscNotifyAgentOfNetStatusChangeIfRequired(
    BOOLEAN fInvokeAutoDial
    )
{
    LONG AgentNotificationState;

    AgentNotificationState = InterlockedExchange(
                                 &CscAgentNotifiedOfNetStatusChange,
                                 CSC_AGENT_NOTIFIED);

    if (AgentNotificationState == CSC_AGENT_NOT_NOTIFIED) {
        EnterShadowCrit();   //this is dropped in the signalagent routine....

        if (CscNetPresent) {
            SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_GOT_NET);
        } else {
            SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_NO_NET);
            if (fInvokeAutoDial)
            {
                SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_INVOKE_AUTODIAL);
            }

        }

        MRxSmbCscSignalAgent(
            NULL,
            SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT);
    }
}

VOID
CscNotifyAgentOfFullCacheIfRequired(
    VOID)
{
    // DbgPrint("CscNotifyAgentOfFullCacheIfRequired()\n");

    if (MRxSmbAgentSynchronizationEvent == NULL) {
        MRxSmbCscOpenAgentEvent(FALSE); //FALSE==>not a posted call
        if (MRxSmbAgentSynchronizationEvent == NULL) {
            RxDbgTrace(0, Dbg, ("MRxSmbCscSignalAgent no event %08lx %08lx\n"));
            // DbgPrint("CscNotifyAgentOfFullCacheIfRequired exit no event\n");
            return;
        }
    }

    SetFlag(sGS.uFlagsEvents, FLAG_GLOBALSTATUS_INVOKE_FREESPACE);

    if (MRxSmbAgentSynchronizationEvent)
        KeSetEvent(MRxSmbAgentSynchronizationEvent,0,FALSE);

    // DbgPrint("CscNotifyAgentOfFullCacheIfRequired exit\n");
}

//CODE.IMPROVEMENT.ASHAMED...the next two routines are virtually identical; also there's
// a lot of very similar codein the third
VOID
MRxSmbCscAgentSynchronizationOnStart (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine signals the csc usermode agent that a start is occurring.
   By passing the context to the signal routine, we indicate that we want
   to wait for an external guy (in this case ioctl_register_start) to signal us
   tro proceed

Arguments:

    RxContext - the RDBSS context.

Return Value:


Notes:


--*/
{
#if 0
    NTSTATUS Status;

    if(!MRxSmbIsCscEnabled) {
        return;
    }

    RxDbgTrace(+1, Dbg, ("MRxSmbCscAgentSynchronizationOnStart entry...%08lx\n",RxContext));

    EnterShadowCrit();   //this is dropped in the signalagent routine....

    // check if an agent is already registered
    // if he is then we don't need to do any of this stuff

    if (!hthreadReint)
    {
        SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_START);

        Status = MRxSmbCscSignalAgent(RxContext,
                                  SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT);
    }
    else
    {
        LeaveShadowCrit();
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscAgentSynchronizationOnStart...%08lx %08lx\n",
              RxContext, Status));
#endif
    return;

}


VOID
MRxSmbCscAgentSynchronizationOnStop (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine signals the csc usermode agent that a stop is occurring.
   By passing the context to the signal routine, we indicate that we want
   to wait for an external guy (in this case ioctl_register_stop) to signal us
   tro proceed

Arguments:

    RxContext - the RDBSS context.

Return Value:


Notes:


--*/
{
#if 0
    NTSTATUS Status;

    if(!MRxSmbIsCscEnabled) {
        return;
    }

    RxDbgTrace(+1, Dbg, ("MRxSmbCscAgentSynchronizationOnStop entry...%08lx\n",RxContext));

    EnterShadowCrit();   //this is dropped in the signalagent routine....

    if (hthreadReint)
    {
        SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_STOP);

        Status = MRxSmbCscSignalAgent(RxContext,0); //0 means no special operations
    }
    else
    {
        LeaveShadowCrit();
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscAgentSynchronizationOnStop...%08lx %08lx\n",
              RxContext, Status));
#endif
    return;
}


VOID
MRxSmbCscReleaseRxContextFromAgentWait (
    void
    )
/*++

Routine Description:

   This routine checks to see if there is a context waiting for the agent. If so,
   it signals the context's syncevent. It also clears the specified flags.

Arguments:

    RxContext - the RDBSS context.

Return Value:


Notes:


--*/
{
    PRX_CONTEXT WaitingContext;
    RxDbgTrace(+1, Dbg, ("MRxSmbCscReleaseRxContextFromAgentWait entry...%08lx\n"));

    ASSERT(MRxSmbIsCscEnabled);
    EnterShadowCrit();

    WaitingContext = MRxSmbContextAwaitingAgent;
    MRxSmbContextAwaitingAgent = NULL;

    LeaveShadowCrit();

    if (WaitingContext != NULL) {
        RxSignalSynchronousWaiter(WaitingContext);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscReleaseRxContextFromAgentWait...%08lx\n"));
    return;
}

//CODE.IMPROVEMENT get this in an include file
extern ULONG MRxSmbCscNumberOfShadowOpens;
extern ULONG MRxSmbCscActivityThreshold;

VOID
MRxSmbCscReportFileOpens (
    void
    )
/*++

Routine Description:

   This routine checks to see if there has been enough activity to signal
   the agent to recompute reference priorities.

Arguments:

Return Value:


Notes:


--*/
{
    NTSTATUS Status;
    RxDbgTrace(+1, Dbg, ("MRxSmbCscReportFileOpens entry...%08lx %08lx\n",
           MRxSmbCscNumberOfShadowOpens,(ULONG)(sGS.cntFileOpen) ));

    EnterShadowCrit();   //this is dropped in the signalagent routine....

    MRxSmbCscNumberOfShadowOpens++;

    if ((MRxSmbCscNumberOfShadowOpens > (ULONG)(sGS.cntFileOpen) )   // to guard against rollover
          &&  ((MRxSmbCscNumberOfShadowOpens - (ULONG)(sGS.cntFileOpen))
                                    < MRxSmbCscActivityThreshold)) {
        RxDbgTrace(-1, Dbg, ("MRxSmbCscReportFileOpens inactive...\n"));
        LeaveShadowCrit();
        return;
    }

    //SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_START);
    sGS.cntFileOpen = MRxSmbCscNumberOfShadowOpens;

    Status = MRxSmbCscSignalAgent(NULL,0);   //this means don't wait for a repsonse

    RxDbgTrace(-1, Dbg, ("MRxSmbCscReportFileOpens...activeexit\n"));
    return;
}

NTSTATUS
MRxSmbCscSignalFillAgent(
    PRX_CONTEXT RxContext OPTIONAL,
    ULONG  Controls)
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN ShadowCritEntered = TRUE; //must be in critsect on
    BOOLEAN PreventLeaveCrit = BooleanFlagOn(Controls,SIGNALAGENTFLAG_DONT_LEAVE_CRIT_SECT);

    RxDbgTrace(+1, Dbg, ("MRxSmbCscSignalFillAgent entry...%08lx\n",RxContext));

    // DbgPrint("MRxSmbCscSignalFillAgent entry...%08lx\n",RxContext);

    ASSERT(MRxSmbIsCscEnabled);

    if (!FlagOn(Controls,SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT)) {
        if (hthreadReint==0) {
            //no agent and no force...just get out
            RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalFillAgent no agent/noforce %08lx\n", RxContext));
            goto FINALLY;
        }
    }

    if (MRxSmbAgentFillEvent == NULL) {
        // DbgPrint("MRxSmbCscSignalFillAgent: gotta open the event...\n");
        MRxSmbCscOpenAgentFillEvent(FALSE); //FALSE==>not a posted call
        if (MRxSmbAgentFillEvent == NULL) {
            //still NULL...no agent.........
            RxDbgTrace(0, Dbg, ("MRxSmbCscSignalFillAgent no event %08lx %08lx\n",
                               RxContext,Status));
            // DbgPrint("MRxSmbCscSignalFillAgent no event %08lx %08lx\n");
            Status = STATUS_SUCCESS;
            goto FINALLY;
        }
    }

    if (RxContext != NULL) {
        MRxSmbContextAwaitingFillAgent = RxContext;
    }

    // if (!PreventLeaveCrit) {
    //     LeaveShadowCrit();
    //     ShadowCritEntered = FALSE;
    // } else {
    //     ASSERT(RxContext==NULL); //cant wait with critsect held
    // }

    // reduce the window of MRxSmbAgentFillEvent getting nulled out
    // by explictly checking before pulsing

    if (MRxSmbAgentFillEvent) {
        KeSetEvent(MRxSmbAgentFillEvent,0,FALSE);
    }

    if (RxContext != NULL) {
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalFillAgent waiting %08lx\n", RxContext));
        RxWaitSync(RxContext);
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalFillAgent end of wait %08lx\n", RxContext));
    }

    RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalFillAgent %08lx\n", RxContext));

FINALLY:
    // if (ShadowCritEntered && !PreventLeaveCrit) {
    //     LeaveShadowCrit();
    // }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscSignalFillAgent... exit %08lx %08lx\n",
              RxContext, Status));

    // DbgPrint("MRxSmbCscSignalFillAgent... exit %08lx %08lx\n", Status);

    return(Status);
}

VOID
MRxSmbCscOpenAgentFillEvent (
    BOOLEAN PostedCall)
{
    NTSTATUS Status;
    HANDLE EventHandle;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES ObjectAttributes;

    if (PsGetCurrentProcess()!= RxGetRDBSSProcess()) {
        //CODE.IMPROVEMENT we should capture the rdbss process
        //  and avoid this call (RxGetRDBSSProcess)
        NTSTATUS PostStatus;
        MRXSMBCSC_OPENEVENT_POSTCONTEXT PostContext;

        ASSERT(!PostedCall);

        // DbgPrint("MRxSmbCscOpenAgentFillEvent: posting...\n");

        KeInitializeEvent(&PostContext.PostEvent,
                          NotificationEvent,
                          FALSE );

        PostStatus = RxPostToWorkerThread(
                         MRxSmbDeviceObject,
                         CriticalWorkQueue,
                         &PostContext.WorkQueueItem,
                         MRxSmbCscOpenAgentFillEventPostWrapper,
                         &PostContext);

        ASSERT(PostStatus == STATUS_SUCCESS);


        KeWaitForSingleObject( &PostContext.PostEvent,
                               Executive, KernelMode, FALSE, NULL );

        // DbgPrint("MRxSmbCscOpenAgentFillEvent: posting done...\n");

        return;
    }

    RtlInitUnicodeString(&EventName,SHARED_FILL_EVENT_NAME_NT);
    InitializeObjectAttributes( &ObjectAttributes,
                                &EventName,
                                0,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    Status = ZwOpenEvent( &EventHandle,
                         EVENT_ALL_ACCESS,
                         &ObjectAttributes);

    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalFillAgent no event %08lx\n",Status));
        DbgPrint("MRxSmbCscSignalFillAgent no event %08lx\n",Status);
        return;
    }

    Status = ObReferenceObjectByHandle( EventHandle,
                                        0,
                                        *ExEventObjectType,
                                        KernelMode,
                                        (PVOID *) &MRxSmbAgentFillEvent,
                                        NULL );

    ZwClose(EventHandle);

    if (Status!=STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg,  ("MRxSmbCscSignalFillAgent couldn't reference %08lx\n", Status));
        DbgPrint("MRxSmbCscSignalFillAgent couldn't reference %08lx\n", Status);
        MRxSmbAgentFillEvent = NULL;
        return;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\cscdfs.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cscdfs.c

Abstract:

    This module implements the routines for integrating DFS funcitionality with
    CSC

Author:

    Balan Sethu Raman [SethuR]    23 - January - 1998

Revision History:

Notes:

    The CSC/DFS integration poses some interesting problem for transparent
    switchover from online to offline operation and viceversa.

    The DFS driver ( incorporated into MUP in its current incarnation ) builds
    up a logical name space by stitching together varios physical volumes on
    different machines. In the normal course of events the CSC framework will
    be above the DFS driver in the food chain. In such cases this module
    would be redundant and the entire process is contained in the CSC code.
    Since this is not an available option owing to the necessity of integrating
    the CSC code in its present form this module tries to seamlessly provide
    that functionality.

    The DFS driver uses specially defined IOCTL's over the SMB protocol to garner
    and disperse DFS state information. The SMB protocol contains additional
    flag definitions that communicate the type of shares ( DFS aware or otherwise)
    to the clients. This information is stored in the redirector data structures.
    The DFS driver uses the FsContext2 field of the file object passed to it in
    Create calls to communicate the fact that it is a DFS open to the underlying
    redirector. This is used to validate opens in the redirector.

    With the introduction of CSC as part of the redirector there are some new
    wrinkles in the system. Since the DFS driver munges the names passed to it
    the name seen by the redirector is very different from the passed in by the
    user. If the CSC were to base its database based upon the names passed to
    the redirector then a DFS will be required to operate in the offline case.
    The DFS driver will persistently store its PKT data structure and do the same
    name munging in the offline case. With the introduction of fault tolerant DFS
    maintaining the state consistently and persistently will be a very tough
    problem.

    Another option to consider would be that the CSC database will be maintained
    in terms of the path names passed in by the user and not the munged names
    passed in by the redirector. This would imply that in the offline state the
    CSC code can independently exist to serve files off the DFS namespace without
    the DFS driver. The current solution that has been implemented for integrating
    CSC and DFS is based on this premise.

    In order to make this work we need to establish a mechanism for DFS to pass
    in the original name passed into DFS. This is done by usurping the FsContext
    field in the file object associated with the IRP that is passed in. DFS
    fills in this field with an instance of a DFS defined data structure
    (DFS_CSC_NAME_CONTEXT). This data structure contains the original name
    passed into DFS alonwith an indication of whether the open was triggerred by
    the CSC agent. The DFS driver is responsible for managing the storage
    associated with these contexts. When the DFS driver hands over the IRP this
    value is filled in and must remain valid till the IRP is completed. On
    completion of the IRP the context field would have been overridden by the
    underlying driver. The DFS driver cannot rely on the context fields having
    the value on return and must take adequate steps to squirrel away the data
    in its data structures.

    Having thus established the mechanism for DFS to pass in the original name
    the next step is to outline the mechanisms for CSC to use it. Since the CSC
    database is organized in terms of server/share names we will limit the
    discussion to shares with the implicit understanding that the extension to
    all file names in the name space is trivial.

    The DFS shares that are established for accessing files/folders can be classified
    into four categories based on their lifetimes

    1) DFS Share accessed in connected mode only

    2) DFS Share accessed in disconnected mode only

    3) DFS Share established in connected mode but is accessed after transitioning to
       disconnected mode

    4) DFS Share established in disconnected mode but is accessed after transitioning
       to connected mode.

    In the case of connected mode operation we need to ensure that the redirector
    consistently manipulates the RDR data structures in terms of the munged name
    passed in by the DFS driver and the CSC database in terms of the original
    name passed in by the user. As an example consider the following name

       \\DfsRoot\DfsShare\foo\bar passed in by the user. This name can be

    munged into one of three possible names by the DFS driver.

        TBD -- fill in appropriate FTDFS, middle level volume and leaf volume
        munged name.

    In the current RDR data structures the NET_ROOT_ENTRY claims the first two
    components of a name for the CSC database structures. There are two instances
    of CSC database handles for the Server ( server and share name in UNC
    terminology ) and the root directory. These names were driven off the name
    as seen by the redirector ( munged name ). In the modified scheme these will
    be driven off the original name passed in by the user. This ensures that no
    other code path need be changed in the redirector to facilitate DFS/CSC
    integration.

    In disconnected mode the names as passed in by the user is passed into the
    redirector which passes the appropriate components to CSC. Since CSC is
    maintained in terms of original names it works as before.

    When the user has modified files on a DFS share it is necessary to ensure
    that the DFS name space munging/resolution does not come into play till
    the CSC agent has had a chance to ensure that the files have been integrated
    This is accomplished by having the redirector preprocess the DFS open requests
    in connected mode. If the share has been marked dirty in the CSC database
    the redirector munges the name on its own to bypass DFS name resolution and
    returns STATUS_REPARSE to the DFS driver.

    There is one other situation which needs special treatment. A DFS server/share
    cannot be transitioned to disconnected operation by the redirector. Since
    the DFS name space is built out of multiple options with a variety of fault
    tolerant options the inability to open a file/contact a server in the DFS
    namespace cannot lead to transitioning in the redirector. It is left to
    the discretion of the DFS driver to implement the appropriate mechanism

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

NTSTATUS
CscDfsParseDfsPath(
    PUNICODE_STRING pDfsPath,
    PUNICODE_STRING pServerName,
    PUNICODE_STRING pSharePath,
    PUNICODE_STRING pFilePathRelativeToShare)
/*++

Routine Description:

    This routine parses the DFS path into a share path and a file path

Arguments:

    pDfsPath -- the DFS path

    pServerName -- the name of the server

    pSharePath -- the share path

    pFilePathRelativeToShare -- file path relative to share

Return Value:

    STATUS_SUCCESS -- successful

    STATUS_OBJECT_PATH_INVALID -- the path supplied was invalid

Notes:

    Either pServerName or pSharePath or pFilePathRelativeToShare can be NULL

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    PWCHAR pTempPathString;

    ULONG NumberOfBackSlashesSkipped;
    ULONG TempPathLengthInChars;
    ULONG SharePathLengthInChars;

    pTempPathString = pDfsPath->Buffer;
    TempPathLengthInChars = pDfsPath->Length / sizeof(WCHAR);

    if (pServerName != NULL) {
        pServerName->Length = pServerName->MaximumLength = 0;
        pServerName->Buffer = NULL;
    }

    if (pSharePath != NULL) {
        pSharePath->Length = pSharePath->MaximumLength = 0;
        pSharePath->Buffer = NULL;
    }

    if (pFilePathRelativeToShare != NULL) {
        pFilePathRelativeToShare->Length = pFilePathRelativeToShare->MaximumLength = 0;
        pFilePathRelativeToShare->Buffer = NULL;
    }

    // Skip till after the third backslash or the end of the name
    // whichever comes first.
    // The name we are interested in is of the form \server\share\
    // with the last backslash being optional.

    NumberOfBackSlashesSkipped = 0;
    SharePathLengthInChars = 0;

    while (TempPathLengthInChars > 0) {
        if (*pTempPathString++ == L'\\') {
            NumberOfBackSlashesSkipped++;

            if (NumberOfBackSlashesSkipped == 2) {
                if (pServerName != NULL) {
                    pServerName->Length = (USHORT)SharePathLengthInChars * sizeof(WCHAR);
                    pServerName->MaximumLength = pServerName->Length;
                    pServerName->Buffer = pDfsPath->Buffer;
                }
            } else if (NumberOfBackSlashesSkipped == 3) {
                break;
            }
        }

        TempPathLengthInChars--;
        SharePathLengthInChars++;
    }

    if (NumberOfBackSlashesSkipped >= 2) {
        if (pSharePath != NULL) {
            pSharePath->Length = (USHORT)SharePathLengthInChars * sizeof(WCHAR);
            pSharePath->MaximumLength = pSharePath->Length;
            pSharePath->Buffer = pDfsPath->Buffer;
        }

        if ((pFilePathRelativeToShare != NULL) &&
            (NumberOfBackSlashesSkipped == 3)) {
            pFilePathRelativeToShare->Length =
                pDfsPath->Length - ((USHORT)SharePathLengthInChars * sizeof(WCHAR));
            pFilePathRelativeToShare->MaximumLength = pFilePathRelativeToShare->Length;
            pFilePathRelativeToShare->Buffer = pDfsPath->Buffer + SharePathLengthInChars;
        }

        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_OBJECT_PATH_INVALID;
    }

    return Status;
}

PDFS_NAME_CONTEXT
CscIsValidDfsNameContext(
    PVOID   pFsContext)
/*++

Routine Description:

    This routine determines if the supplied context is a valid DFS_NAME_CONTEXT

Arguments:

    pFsContext - the supplied context

Return Value:

    valid context ponter if the supplied context is a valid DFS_NAME_CONTEXT
    instance, otherwise NULL

Notes:

--*/
{
    PDFS_NAME_CONTEXT pValidDfsNameContext = NULL;

    if (pFsContext != NULL) {
        pValidDfsNameContext = pFsContext;
    }

    return pValidDfsNameContext;
}

NTSTATUS
CscGrabPathFromDfs(
    PFILE_OBJECT      pFileObject,
    PDFS_NAME_CONTEXT pDfsNameContext)
/*++

Routine Description:

    This routine modifies the file object in preparation for returning
    STATUS_REPARSE

Arguments:

    pFileObject - the file object

    pDfsNameContext - the DFS_NAME_CONTEXT instance

Return Value:

    STATUS_REPARSE if everything is successful

Notes:

--*/
{
    NTSTATUS Status;

    USHORT DeviceNameLength,ReparsePathLength;
    PWSTR  pFileNameBuffer;

    DeviceNameLength = wcslen(DD_NFS_DEVICE_NAME_U) *
                       sizeof(WCHAR);


    ReparsePathLength = DeviceNameLength +
                        pDfsNameContext->UNCFileName.Length;

    if (pDfsNameContext->UNCFileName.Buffer[0] != L'\\') {
        ReparsePathLength += sizeof(WCHAR);
    }

    pFileNameBuffer = RxAllocatePoolWithTag(
                          PagedPool | POOL_COLD_ALLOCATION,
                          ReparsePathLength,
                          RX_MISC_POOLTAG);

    if (pFileNameBuffer != NULL) {
        // Copy the device name
        RtlCopyMemory(
            pFileNameBuffer,
            DD_NFS_DEVICE_NAME_U,
            DeviceNameLength);

        if (pDfsNameContext->UNCFileName.Buffer[0] != L'\\') {
            DeviceNameLength += sizeof(WCHAR);

            pFileNameBuffer[DeviceNameLength/sizeof(WCHAR)]
                = L'\\';
        }

        // Copy the new name
        RtlCopyMemory(
            ((PBYTE)pFileNameBuffer +
             DeviceNameLength),
            pDfsNameContext->UNCFileName.Buffer,
            pDfsNameContext->UNCFileName.Length);

        if (pFileObject->FileName.Buffer != NULL)
            ExFreePool(pFileObject->FileName.Buffer);

        pFileObject->FileName.Buffer = pFileNameBuffer;
        pFileObject->FileName.Length = ReparsePathLength;
        pFileObject->FileName.MaximumLength =
            pFileObject->FileName.Length;

        Status = STATUS_REPARSE;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS
CscPreProcessCreateIrp(
    PIRP    pIrp)
/*++

Routine Description:

    This routine determines if the CSC/Redirector should defeat the DFS
    name resolution scheme

Arguments:

    pIrp - the IRP

Return Value:

    This routine bases this determination on whether there are dirty files
    corresponding to this DFS share name. If there are the name is claimed by
    the redirector by changing the file name to the new value and returning
    STATUS_REPARSE. In all other cases STATUS_SUCCESS is returned.

Notes:

    This routine assumes that the name passed in the DFS_NAME_CONTEXT is a
    name in the following format irrespective of whether the user specifies a
    drive letter based name or a UNC name.

        \DfsRoot\DfsShare\ ....

--*/
{
    NTSTATUS    Status;

    PIO_STACK_LOCATION pIrpSp;
    PFILE_OBJECT       pFileObject;
    PDFS_NAME_CONTEXT  pDfsNameContext;

    if(!MRxSmbIsCscEnabled ||
        !fShadow
        ) {
        return(STATUS_SUCCESS);
    }

    Status = STATUS_SUCCESS;

    pIrpSp  = IoGetCurrentIrpStackLocation(pIrp);

    pFileObject = pIrpSp->FileObject;

    pDfsNameContext = CscIsValidDfsNameContext(pFileObject->FsContext);

    if ((pDfsNameContext != NULL) &&
        (pDfsNameContext->NameContextType != DFS_CSCAGENT_NAME_CONTEXT)) {
        UNICODE_STRING ShareName;
        UNICODE_STRING  ServerName;

        Status = CscDfsParseDfsPath(
                     &pDfsNameContext->UNCFileName,
                     &ServerName,
                     &ShareName,
                     NULL);

        // Locate the share name / server name in the database.
        if (Status == STATUS_SUCCESS) {
            // At this stage the given path name has been parsed into the
            // relevant components, i.e., the server name, the share name
            // ( also includes the server name ) and the file name relative
            // to the share. Of these the first two components are valuable
            // in determining whether the given path has to be grabbed from
            // DFS.

            Status = STATUS_MORE_PROCESSING_REQUIRED;

            // If a server entry exists in the connection engine database
            // for the given server name and it had been marked for
            // disconnected operation then the path needs to be grabbed from
            // DFS. This will take into account those cases wherein there
            // is some connectivity but the DFS root has been explicitly
            // marked for disconnected operation.

            if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                PSMBCEDB_SERVER_ENTRY pServerEntry;

                SmbCeAcquireResource();

                pServerEntry = SmbCeFindServerEntry(
                                   &ServerName,
                                   SMBCEDB_FILE_SERVER,
                                   NULL);

                SmbCeReleaseResource();

                if (pServerEntry != NULL) {
                    if (SmbCeIsServerInDisconnectedMode(pServerEntry)) {
                        Status = STATUS_REPARSE;
                    }

                    SmbCeDereferenceServerEntry(pServerEntry);
                }
            }

            if (Status == STATUS_MORE_PROCESSING_REQUIRED) {

                // If no server entry exists or it has not been transitioned into
                // disconnected mode we check the CSC database for an entry
                // corresponding to the given share name. If one exists and there
                // are no transports available then the name needs to be grabbed.
                // This takes into account all the cases wherein there is no
                // net connectivity.

                SHADOWINFO ShadowInfo;
                DWORD      CscServerStatus;

                EnterShadowCrit();

                CscServerStatus = FindCreateShareForNt(
                                      &ShareName,
                                      FALSE,
                                      &ShadowInfo,
                                      NULL);

                LeaveShadowCrit();

                if ( CscServerStatus == SRET_OK ) {
                    PSMBCE_TRANSPORT_ARRAY pTransportArray;

                    // If an entry corresponding to the dfs root exists in the
                    // CSC database transition to using it either if it is marked
                    // dirty or there are no transports.

                    pTransportArray = SmbCeReferenceTransportArray();
                    SmbCeDereferenceTransportArray(pTransportArray);

                    if (pTransportArray == NULL) {
                        Status = STATUS_REPARSE;
                    }
                }
            }

            // if the status value is STATUS_REPARSE one of the rule applications
            // was successful and we do the appropriate name munging to grab
            // the DFS path
            // If the status value is still STATUS_MORE_PROCESSING_REQUIRED
            // it implies that none of our rules for reparsing the DFS path
            // was successful. We map the status back to STATUS_SUCCESS to
            // resume the connected mode of operation

            if (Status == STATUS_REPARSE) {
                if (pDfsNameContext->Flags & DFS_FLAG_LAST_ALTERNATE) {
                    Status = CscGrabPathFromDfs(
                                 pFileObject,
                                 pDfsNameContext);
                } else {
                    Status = STATUS_NETWORK_UNREACHABLE;
                }
            } else if (Status == STATUS_MORE_PROCESSING_REQUIRED) {
                Status = STATUS_SUCCESS;
            }
        }
    }

    return Status;
}

NTSTATUS
CscDfsDoDfsNameMapping(
    IN  PUNICODE_STRING pDfsPrefix,
    IN  PUNICODE_STRING pActualPrefix,
    IN  PUNICODE_STRING pNameToMap,
    IN  BOOL            fResolvedNameToDFSName,
    OUT PUNICODE_STRING pResult
    )
/*++

Routine Description:

    Given the DfsPrefix and it's corresponding actualprefix, this routine maps a resolved
    name to the corresponding DFS name or viceversa

    As an example if \\csctest\dfs\ntfs is actually resolved to \\dkruse1\ntfs
    then \\csctest\dfs\ntfs\dir1\foo.txt resolves to \\dkruse1\ntfs\dir1\foo.txt.

    The DFS prefix in this case is \ntfs and the Actual prefix is \.

    Thus, given an actual path \dir1\foo.txt, this routine reverse maps it to
    \ntfs\dir1\foo.txt or viceversa


Arguments:

    pDfsPrefix              Dfs Name prefix

    pActaulPrefix           Corresponding actual prefix

    pNameToMap              Actual name

    fResolvedNameToDFSName  If true, we are converting resolved name to DFS name, else viceversa

    pResult                 Output DFS name

Return Value:

    STATUS_SUCCESS if successful, NT error code otherwise

Notes:


    This routine is used by CSC to obtain a DFS name from an actual name or viceversa. It is used to get the
    DFS name of a rename name so that the CSC database can do the manipulations in terms
    of the DFS names. It is also used to get the info from the server using the real name
    while createing entries in the CSC database in the DFS namespace.

--*/
{
    NTSTATUS    Status = STATUS_NO_SUCH_FILE;
    PUNICODE_STRING pSourcePrefix=pActualPrefix , pDestPrefix=pDfsPrefix;
    UNICODE_STRING  NameToCopy;

    memset(pResult, 0, sizeof(UNICODE_STRING));

    if (fResolvedNameToDFSName)
    {
        // converting resolved name to DFS name
        pSourcePrefix=pActualPrefix;
        pDestPrefix=pDfsPrefix;
    }
    else
    {
        // converting DFS name to resolved name
        pSourcePrefix=pDfsPrefix;
        pDestPrefix=pActualPrefix;

    }
  //  DbgPrint("CscDoDfsnamemapping: DestPrefix=%wZ SourcePrefix=%wZ NameToMap=%wZ\n",
//                pDestPrefix, pSourcePrefix,  pNameToMap);

    //mathc the prefix
    if (RtlPrefixUnicodeString(pSourcePrefix, pNameToMap, TRUE))
    {
        ASSERT(pNameToMap->Length >= pSourcePrefix->Length);

        // Calculate the max length.
        pResult->MaximumLength = pDestPrefix->Length + pNameToMap->Length - pSourcePrefix->Length+2;

        pResult->Buffer = (PWCHAR)AllocMem(pResult->MaximumLength);

        if (pResult->Buffer)
        {
            // set the initial length
            pResult->Length = pDestPrefix->Length;
            memcpy(pResult->Buffer, pDestPrefix->Buffer, pDestPrefix->Length);

            // if there isn't a terminating backslash, put it in there
            if (pResult->Buffer[pResult->Length/sizeof(USHORT)-1] != L'\\')
            {
                pResult->Buffer[pResult->Length/sizeof(USHORT)] = L'\\';
                pResult->Length += 2;

            }

            NameToCopy.Buffer = pNameToMap->Buffer+pSourcePrefix->Length/sizeof(USHORT);
            NameToCopy.Length = pNameToMap->Length-pSourcePrefix->Length;

//            DbgPrint("CscDoDfsNameMapping: Copying %wZ\n", &NameToCopy);

            // now copy the nametomap without the sourceprefix, into the buffer
            memcpy( pResult->Buffer+pResult->Length/sizeof(USHORT),
                    NameToCopy.Buffer,
                    NameToCopy.Length);

            pResult->Length += NameToCopy.Length;

            ASSERT(pResult->Length <= pResult->MaximumLength);

//            DbgPrint("CscDoDfsNameMapping: pResult %wZ\n", pResult);
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return Status;
}

NTSTATUS
CscDfsObtainReverseMapping(
    IN  PUNICODE_STRING pDfsPath,
    IN  PUNICODE_STRING pResolvedPath,
    OUT PUNICODE_STRING pReverseMappingDfs,
    OUT PUNICODE_STRING pReverseMappingActual)

/*++

Routine Description:

    This routine obtains the mapping strings which allow csc to map a resolved path
    to a DFS path

    As an example if \\csctest\dfs\ntfs is actually resolved to \\dkruse1\ntfs
    then \\csctest\dfs\ntfs\dir1\foo.txt resolves to \\dkruse1\ntfs\dir1\foo.txt.

    The DFS prefix in this case is \ntfs and the Actual prefix is \.

Arguments:

    pDfsPath    Path relative to the root of the DFS share

    pResolvedPath   Path relative to the actual share

    pReverseMappingDfs

    pReverseMappingActual

Return Value:

    STATUS_SUCCESS if successful, NT error code otherwise

Notes:


--*/
{
    NTSTATUS    Status=STATUS_INSUFFICIENT_RESOURCES;
    PWCHAR  pDfs, pActual;
    WCHAR   wDfs, wActual;
    DWORD   cbDfs=0, cbActual=0;
    UNICODE_STRING  uniSavResolved, uniSavDfs;
    BOOL    fSavedResolved = FALSE, fSavedDfs = FALSE;


    // take care of the root
    if (pResolvedPath->Length == 0)
    {
        uniSavResolved = *pResolvedPath;
        pResolvedPath->Length = pResolvedPath->MaximumLength = 2;
        pResolvedPath->Buffer = L"\\";
        fSavedResolved = TRUE;
    }
    // take care of the root
    if (pDfsPath->Length == 0)
    {
        uniSavDfs = *pDfsPath;
        pDfsPath->Length = pDfsPath->MaximumLength = 2;
        pDfsPath->Buffer = L"\\";
        fSavedDfs = TRUE;
    }

    memset(pReverseMappingDfs, 0, sizeof(UNICODE_STRING));
    memset(pReverseMappingActual, 0, sizeof(UNICODE_STRING));

    // point to the end of each string
    pDfs = (PWCHAR)((LPBYTE)(pDfsPath->Buffer)+pDfsPath->Length - 2);
    cbDfs = pDfsPath->Length;

    pActual = (PWCHAR)((LPBYTE)(pResolvedPath->Buffer)+pResolvedPath->Length - 2);
    cbActual = pResolvedPath->Length;

//    DbgPrint("CscDfsObtainReverseMapping: In DfsPath=%wZ ResolvedPath=%wZ\n", pDfsPath, pResolvedPath);

    pReverseMappingDfs->MaximumLength = pReverseMappingDfs->Length = (USHORT)cbDfs;
    pReverseMappingActual->MaximumLength = pReverseMappingActual->Length = (USHORT)cbActual;

    for (;;)
    {
        // do an upcase comparison
        wDfs = RtlUpcaseUnicodeChar(*pDfs);
        wActual = RtlUpcaseUnicodeChar(*pActual);

        if (wDfs != wActual)
        {
            ASSERT(pReverseMappingDfs->Length && pReverseMappingActual->Length);
            break;
        }

        // if we reached a backslash, checkpoint the path upto this point
        if (wDfs == (WCHAR)'\\')
        {
            pReverseMappingDfs->MaximumLength = pReverseMappingDfs->Length = (USHORT)cbDfs;
            pReverseMappingActual->MaximumLength = pReverseMappingActual->Length = (USHORT)cbActual;
        }

        if ((pDfs == pDfsPath->Buffer)||(pActual ==  pResolvedPath->Buffer))
        {
            break;
        }

        --pDfs;--pActual;
        cbDfs -= 2; cbActual -= 2;
    }

    pReverseMappingDfs->Buffer = (PWCHAR)RxAllocatePoolWithTag(NonPagedPool, pReverseMappingDfs->Length, RX_MISC_POOLTAG);

    if (pReverseMappingDfs->Buffer)
    {
        pReverseMappingActual->Buffer = (PWCHAR)RxAllocatePoolWithTag(NonPagedPool, pReverseMappingActual->Length, RX_MISC_POOLTAG);

        if (pReverseMappingActual->Buffer)
        {

            memcpy(pReverseMappingDfs->Buffer, pDfsPath->Buffer, pReverseMappingDfs->Length);
            memcpy(pReverseMappingActual->Buffer, pResolvedPath->Buffer, pReverseMappingActual->Length);

//            DbgPrint("CscDfsObtainReverseMapping: out DfsPrefix=%wZ ActualPrefix=%wZ\n", pReverseMappingDfs, pReverseMappingActual);
            Status = STATUS_SUCCESS;
        }
    }

    if (Status != STATUS_SUCCESS)
    {
        if (pReverseMappingDfs->Buffer)
        {
            FreeMem(pReverseMappingDfs->Buffer);
        }
        pReverseMappingDfs->Buffer = NULL;

        if (pReverseMappingActual->Buffer)
        {
            FreeMem(pReverseMappingActual->Buffer);
        }
        pReverseMappingActual->Buffer = NULL;
    }

    if (fSavedResolved)
    {
        *pResolvedPath = uniSavResolved;
    }
    if (fSavedDfs)
    {
        *pDfsPath = uniSavDfs;

    }
    return Status;
}

NTSTATUS
CscDfsStripLeadingServerShare(
    IN  PUNICODE_STRING pDfsRootPath
    )
/*++

Routine Description:

    This routine strips the leading server-share of a DFS root path. Thus when Dfs sends down a path
    relative to the root such as \server\share\foo.txt, this routien makes the path \foo.txt

Arguments:

    pDfsRootPath    Path relative to the root of the DFS share

Return Value:

    STATUS_SUCCESS if successful, NT error code otherwise

Notes:


--*/
{
    ULONG cnt = 0, i;

    DbgPrint("Stripping %wZ \n", pDfsRootPath);
    for (i=0; ;++i)
    {
        if (i*sizeof(WCHAR) > pDfsRootPath->Length)
        {
            return STATUS_UNSUCCESSFUL;
        }
        if (pDfsRootPath->Buffer[i] == '\\')
        {
            // if this is the 3rd slash then we have successfully stripped the name
            if (cnt == 2)
            {
                break;
            }
            cnt++;
        }
    }
    pDfsRootPath->Buffer = &pDfsRootPath->Buffer[i];
    pDfsRootPath->Length -= (USHORT)(i * sizeof(WCHAR));
    DbgPrint("Stripped name %wZ \n", pDfsRootPath);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\precomp.h ===
#include "..\rdbss\smb.mrx\precomp.h" //this should find it form rdr2\inc
#include "dfsfsctl.h"
#include "nt5csc.h"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\daytona\security.c ===
/*++ BUILD Version: 0009    // Increment this if a change has global effects
Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    sessetup.c

Abstract:

    This module implements the Session setup related routines

Author:

    Balan Sethu Raman (SethuR) 06-Mar-95    Created

--*/

#include "precomp.h"
#pragma hdrstop

#include <exsessup.h>
#include "ntlsapi.h"
#include "mrxsec.h"

NTSTATUS
BuildSessionSetupSecurityInformation(
    PSMB_EXCHANGE   pExchange,
    PBYTE           pSmbBuffer,
    PULONG          pSmbBufferSize)
/*++

Routine Description:

   This routine builds the security related information for the session setup SMB

Arguments:

    pServer  - the server instance

    pSmbBuffer - the SMB buffer

    pSmbBufferSize - the size of the buffer on input ( modified to size remaining on
                     output)

Return Value:

    RXSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
    NTSTATUS Status;
    BOOLEAN  fProcessAttached = FALSE;

    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;

    STRING CaseSensitiveResponse;
    STRING CaseInsensitiveResponse;

    PVOID  pSecurityBlob;
    USHORT SecurityBlobSize;

    PSMBCE_SERVER  pServer  = &pExchange->SmbCeContext.pServerEntry->Server;
    PSMBCE_SESSION pSession = &pExchange->SmbCeContext.pSessionEntry->Session;

    SECURITY_RESPONSE_CONTEXT ResponseContext;

    PAGED_CODE();
    RxDbgTrace( +1, Dbg, ("BuildSessionSetupSecurityInformation -- Entry\n"));

    //  Attach to the redirector's FSP to allow us to call into the security impl.
    if (PsGetCurrentProcess() != RxGetRDBSSProcess()) {
        KeAttachProcess(RxGetRDBSSProcess());

        fProcessAttached = TRUE;
    }

    if (pServer->DialectFlags & DF_EXTENDED_SECURITY) {
        Status = BuildExtendedSessionSetupResponsePrologue(
                     pExchange,
                     &pSecurityBlob,
                     &SecurityBlobSize,
                     &ResponseContext);
    } else {
        Status = BuildNtLanmanResponsePrologue(
                     pExchange,
                     &UserName,
                     &DomainName,
                     &CaseSensitiveResponse,
                     &CaseInsensitiveResponse,
                     &ResponseContext);
    }

    if (NT_SUCCESS(Status)) {
        PBYTE    pBuffer    = pSmbBuffer;
        ULONG    BufferSize = *pSmbBufferSize;

        if ((pServer->Dialect == NTLANMAN_DIALECT) &&
            (BooleanFlagOn(pServer->DialectFlags,DF_EXTENDED_SECURITY))) {
            PREQ_NT_EXTENDED_SESSION_SETUP_ANDX pExtendedNtSessionSetupReq;

            // Position the buffer for copying the security blob
            pBuffer += FIELD_OFFSET(REQ_NT_EXTENDED_SESSION_SETUP_ANDX,Buffer);
            BufferSize -= FIELD_OFFSET(REQ_NT_EXTENDED_SESSION_SETUP_ANDX,Buffer);

            pExtendedNtSessionSetupReq = (PREQ_NT_EXTENDED_SESSION_SETUP_ANDX)pSmbBuffer;

            SmbPutUshort(
                &pExtendedNtSessionSetupReq->SecurityBlobLength,
                SecurityBlobSize);

            if (BufferSize >= SecurityBlobSize) {
                RtlCopyMemory(
                    pBuffer,
                    pSecurityBlob,
                    SecurityBlobSize);
                BufferSize -= SecurityBlobSize;
            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }
        } else if (pServer->Dialect == NTLANMAN_DIALECT) {
            PREQ_NT_SESSION_SETUP_ANDX pNtSessionSetupReq = (PREQ_NT_SESSION_SETUP_ANDX)pSmbBuffer;

            // It it is a NT server both the case insensitive and case sensitive passwords
            // need to be copied. for share-level, just copy a token 1-byte NULL password

            // Position the buffer for copying the password.
            pBuffer += FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer);
            BufferSize -= FIELD_OFFSET(REQ_NT_SESSION_SETUP_ANDX,Buffer);

            if (pServer->SecurityMode == SECURITY_MODE_USER_LEVEL){

                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- NtUserPasswords\n"));

                SmbPutUshort(
                    &pNtSessionSetupReq->CaseInsensitivePasswordLength,
                    CaseInsensitiveResponse.Length);

                SmbPutUshort(
                    &pNtSessionSetupReq->CaseSensitivePasswordLength,
                    CaseSensitiveResponse.Length);

                Status = SmbPutString(
                             &pBuffer,
                             &CaseInsensitiveResponse,
                             &BufferSize);

                if (NT_SUCCESS(Status)) {
                    Status = SmbPutString(
                                 &pBuffer,
                                 &CaseSensitiveResponse,
                                 &BufferSize);
                }
            } else {

                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- NtSharePasswords\n"));

                SmbPutUshort(&pNtSessionSetupReq->CaseInsensitivePasswordLength, 1);
                SmbPutUshort(&pNtSessionSetupReq->CaseSensitivePasswordLength, 1);
                *pBuffer = 0;
                *(pBuffer+1) = 0;
                pBuffer += 2;
                BufferSize -= 2;
            }
        } else {
            PREQ_SESSION_SETUP_ANDX pSessionSetupReq = (PREQ_SESSION_SETUP_ANDX)pSmbBuffer;

            // Position the buffer for copying the password.
            pBuffer += FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer);
            BufferSize -= FIELD_OFFSET(REQ_SESSION_SETUP_ANDX,Buffer);

            if (pServer->SecurityMode == SECURITY_MODE_USER_LEVEL) {
                // For othe lanman servers only the case sensitive password is required.
                SmbPutUshort(
                    &pSessionSetupReq->PasswordLength,
                    CaseSensitiveResponse.Length);

                // Copy the password
                Status = SmbPutString(
                             &pBuffer,
                             &CaseSensitiveResponse,
                             &BufferSize);
            } else {
                // Share level security. Send a null string for the password
                SmbPutUshort(&pSessionSetupReq->PasswordLength,1);
                *pBuffer++ = '\0';
                BufferSize -= sizeof(CHAR);
            }
        }

        // The User name and the domain name strings can be either copied from
        // the information returned in the request response or the information
        // that is already present in the session entry.
        if (NT_SUCCESS(Status) &&
            !BooleanFlagOn(pServer->DialectFlags,DF_EXTENDED_SECURITY)) {
            if ((pServer->Dialect == NTLANMAN_DIALECT) &&
                (pServer->NtServer.NtCapabilities & CAP_UNICODE)) {
                // Copy the account/domain names as UNICODE strings
                PBYTE pTempBuffer = pBuffer;

                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- account/domain as unicode\n"));
                pBuffer = ALIGN_SMB_WSTR(pBuffer);
                BufferSize -= (pBuffer - pTempBuffer);

                Status = SmbPutUnicodeString(
                             &pBuffer,
                             &UserName,
                             &BufferSize);

                if (NT_SUCCESS(Status)) {
                    Status = SmbPutUnicodeString(
                                 &pBuffer,
                                 &DomainName,
                                 &BufferSize);

                }
            } else {
                // Copy the account/domain names as ASCII strings.
                RxDbgTrace( 0, Dbg, ("BuildSessionSetupSecurityInformation -- account/domain as ascii\n"));
                Status = SmbPutUnicodeStringAsOemString(
                             &pBuffer,
                             &UserName,
                             &BufferSize);

                if (NT_SUCCESS(Status)) {
                    Status = SmbPutUnicodeStringAsOemString(
                                 &pBuffer,
                                 &DomainName,
                                 &BufferSize);
                }
            }
        }

        if (NT_SUCCESS(Status)) {
            *pSmbBufferSize = BufferSize;
        }
    }

    // Free the buffer allocated by the security package.
    if (pServer->DialectFlags & DF_EXTENDED_SECURITY) {
        BuildExtendedSessionSetupResponseEpilogue(&ResponseContext);
    } else {
        BuildNtLanmanResponseEpilogue(&ResponseContext);
    }

    // Detach from the rdr process.
    if (fProcessAttached) {
        KeDetachProcess();
    }

    RxDbgTrace( -1, Dbg, ("BuildSessionSetupSecurityInformation -- Exit, status=%08lx\n",Status));
    return Status;
}
NTSTATUS
BuildTreeConnectSecurityInformation(
    PSMB_EXCHANGE  pExchange,
    PBYTE          pBuffer,
    PBYTE          pPasswordLength,
    PULONG         pSmbBufferSize)
/*++

Routine Description:

    This routine builds the security related information for the session setup SMB

Arguments:

    pServer  - the server instance

    pLogonId - the logon id. for which the session is being setup

    pPassword - the user  supplied password if any

    pBuffer - the password buffer

    pPasswordLength - where the password length is to be stored

    pSmbBufferSize - the size of the buffer on input ( modified to size remaining on
                     output)

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    Eventhough the genral structure of the code tries to isolate dialect specific issues
    as much as possible this routine takes the opposite approach. This is because of the
    preamble and prologue to security interaction which far outweigh the dialect specific
    work required to be done. Therefore in the interests of a smaller footprint this approach
    has been adopted.

--*/
{
    NTSTATUS FinalStatus,Status;
    BOOLEAN  fProcessAttached = FALSE;

    UNICODE_STRING UserName,DomainName;
    STRING         CaseSensitiveChallengeResponse,CaseInsensitiveChallengeResponse;

    SECURITY_RESPONSE_CONTEXT ResponseContext;

    ULONG PasswordLength = 0;

    PSMBCE_SERVER  pServer  = &pExchange->SmbCeContext.pServerEntry->Server;
    PSMBCE_SESSION pSession = &pExchange->SmbCeContext.pSessionEntry->Session;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    if (pServer->EncryptPasswords) {
        //  Attach to the redirector's FSP to allow us to call into the securiy impl.
        if (PsGetCurrentProcess() != RxGetRDBSSProcess()) {
            KeAttachProcess(RxGetRDBSSProcess());
            fProcessAttached = TRUE;
        }

        Status = BuildNtLanmanResponsePrologue(
                     pExchange,
                     &UserName,
                     &DomainName,
                     &CaseSensitiveChallengeResponse,
                     &CaseInsensitiveChallengeResponse,
                     &ResponseContext);

        if (NT_SUCCESS(Status)) {
            if (FlagOn(pServer->DialectFlags,DF_MIXEDCASEPW)) {
                RxDbgTrace( 0, Dbg, ("BuildTreeConnectSecurityInformation -- case sensitive password\n"));
                // Copy the password length onto the SMB buffer
                PasswordLength = CaseSensitiveChallengeResponse.Length;

                // Copy the password
                Status = SmbPutString(
                             &pBuffer,
                             &CaseSensitiveChallengeResponse,
                             pSmbBufferSize);
            } else {
                RxDbgTrace( 0, Dbg, ("BuildTreeConnectSecurityInformation -- case insensitive password\n"));
                // Copy the password length onto the SMB buffer
                PasswordLength = CaseInsensitiveChallengeResponse.Length;

                // Copy the password
                Status = SmbPutString(
                             &pBuffer,
                             &CaseInsensitiveChallengeResponse,
                             pSmbBufferSize);
            }

            BuildNtLanmanResponseEpilogue(&ResponseContext);
        }

        if (fProcessAttached) {
            KeDetachProcess();
        }
    } else {
        if (pSession->pPassword == NULL) {
            // The logon password cannot be sent as plain text. Send a single blank as password.

            PasswordLength = 2;
            if (*pSmbBufferSize >= 2) {
                *((PCHAR)pBuffer) = ' ';
                pBuffer += sizeof(CHAR);
                *((PCHAR)pBuffer) = '\0';
                pBuffer += sizeof(CHAR);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_BUFFER_OVERFLOW;
            }
        } else {
            OEM_STRING OemString;

            OemString.Length = OemString.MaximumLength = (USHORT)(*pSmbBufferSize - sizeof(CHAR));
            OemString.Buffer = pBuffer;
            Status = RtlUnicodeStringToOemString(
                         &OemString,
                         pSession->pPassword,
                         FALSE);

            if (NT_SUCCESS(Status)) {
                PasswordLength = OemString.Length+1;
            }
        }

        // reduce the byte count
        *pSmbBufferSize -= PasswordLength;
    }

    SmbPutUshort(pPasswordLength,(USHORT)PasswordLength);

    return Status;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\readrite.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    ReadRite.c

Abstract:

    This module implements the routines for reading/writeng shadows at
    the right time.

Author:

    Joe Linn [JoeLinn]    5-may-1997

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#pragma code_seg("PAGE")

extern DEBUG_TRACE_CONTROLPOINT RX_DEBUG_TRACE_MRXSMBCSC;
#define Dbg (DEBUG_TRACE_MRXSMBCSC)

// The CscEnterShadowReadWriteCrit and CscLeaveShadowReadWriteCrit are defined
// as macros to allow us the ability to capture context information. In non
// debug builds these will be defined as the regular Ex routines for
// mutex acquisition/release

#if DBG

#define CscEnterShadowReadWriteCrit(pSmbFcb) \
            CscpEnterShadowReadWriteCrit(pSmbFcb,__FILE__,__LINE__);

#define CscLeaveShadowReadWriteCrit(pSmbFcb) \
            CscpLeaveShadowReadWriteCrit(pSmbFcb,__FILE__,__LINE__);

VOID
CscpEnterShadowReadWriteCrit(
    PMRX_SMB_FCB    pSmbFcb,
    PCHAR           FileName,
    ULONG           Line)
{
    ExAcquireFastMutex(&pSmbFcb->CscShadowReadWriteMutex);
}

VOID
CscpLeaveShadowReadWriteCrit(
    PMRX_SMB_FCB pSmbFcb,
    PCHAR        FileName,
    ULONG        Line)
{
    ExReleaseFastMutex(&pSmbFcb->CscShadowReadWriteMutex);
}
#else

#define CscEnterShadowReadWriteCrit(pSmbFcb) \
            ExAcquireFastMutex(&pSmbFcb->CscShadowReadWriteMutex);

#define CscLeaveShadowReadWriteCrit(pSmbFcb) \
            ExReleaseFastMutex(&pSmbFcb->CscShadowReadWriteMutex);

#endif

NTSTATUS
MRxSmbCscShadowWrite (
    IN OUT PRX_CONTEXT RxContext,
    IN     ULONG       ByteCount,
    IN     ULONGLONG   ShadowFileLength,
    OUT PULONG LengthActuallyWritten
    );

#ifdef RX_PRIVATE_BUILD
#undef IoGetTopLevelIrp
#undef IoSetTopLevelIrp
#endif //ifdef RX_PRIVATE_BUILD


NTSTATUS
MRxSmbCscReadPrologue (
    IN OUT PRX_CONTEXT RxContext,
    OUT    SMBFCB_HOLDING_STATE *SmbFcbHoldingState
    )
/*++

Routine Description:

   This routine first performs the correct read synchronization and then
   looks at the shadow file and tries to do a read.

   CODE.IMPROVEMENT because the minirdr is not set up to handle "the rest of
   a read", we fail here if any part of the read is not in the cache. indeed,
   the minirdr should be setup to continue....if it were then we could take
   a prefix of the chunk here and get the rest on the net.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    ULONG iRet,ShadowFileLength;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_FCB      smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry;
    BOOLEAN                 Disconnected;

    PMRXSMBCSC_SYNC_RX_CONTEXT pRxSyncContext;
    BOOLEAN                    ThisIsAReenter;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PBYTE          UserBuffer = RxLowIoGetBufferAddress(RxContext);
    ULONGLONG      ByteOffset = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    ULONG          ByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;

    BOOLEAN EnteredCriticalSection = FALSE;
    NTSTATUS AcquireStatus;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbCscReadPrologue(%08lx)...%08lx bytes @ %08lx on handle %08lx\n",
            RxContext,ByteCount,((PLARGE_INTEGER)(&ByteOffset))->LowPart,smbSrvOpen->hfShadow ));

    pNetRootEntry = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    pRxSyncContext = MRxSmbGetMinirdrContextForCscSync(RxContext);

    ASSERT((pRxSyncContext->TypeOfAcquire == 0) ||
           (FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)));

    ThisIsAReenter = (pRxSyncContext->TypeOfAcquire != 0);

    AcquireStatus = MRxSmbCscAcquireSmbFcb(
                        RxContext,
                        Shared_SmbFcbAcquire,
                        SmbFcbHoldingState);

    if (AcquireStatus != STATUS_SUCCESS) {
        //we couldn't acquire.....get out
        Status = AcquireStatus;
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscReadPrologue couldn't acquire!!!-> %08lx %08lx\n",
                Status, RxContext ));
        goto FINALLY;
    }

    ASSERT( smbFcb->CscOutstandingReaders > 0);

    //if this is a copychunk open......don't try to get it from the cache.....
    if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN)){
        goto FINALLY;
    }

#if 0
    //if this is the agent......don't try to get it from the cache.....
    //because of the way this test is done.....the agent must do all synchronous
    //I/O. otherwise, we could have posted and this test will be wrong.
    if (IsSpecialApp()) {
        goto FINALLY;
    }
#endif

    // we cannot satisfy the read from here in connected mode unless
    //     a) we have an oplock, or
    //     b) our opens add up to deny write

    if ((smbFcb->LastOplockLevel == SMB_OPLOCK_LEVEL_NONE) &&
        (!Disconnected)) {
        PSHARE_ACCESS ShareAccess;
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscReadPrologue no oplock!!!-> %08lx %08lx\n",
                Status, RxContext ));

        ShareAccess = &((PFCB)capFcb)->ShareAccessPerSrvOpens;

        if ((ShareAccess->OpenCount > 0) &&
            (ShareAccess->SharedWrite == ShareAccess->OpenCount)) {
            RxDbgTrace(0, Dbg,
                ("MRxSmbCscReadPrologue no oplock and write access allowed!!!"
                 "-> %08lx %08lx\n",
                    Status, RxContext ));
            goto FINALLY;
        }
    }

    CscEnterShadowReadWriteCrit(smbFcb);
    EnteredCriticalSection = TRUE;

    // check whether we can satisfy the read locally
    iRet = GetFileSizeLocal((CSCHFILE)(smbSrvOpen->hfShadow), &ShadowFileLength);
    RxDbgTrace( 0, Dbg,
        ("MRxSmbCscReadPrologue (st=%08lx) fsize= %08lx\n",
             iRet, ShadowFileLength));

    if (Disconnected && (ByteOffset >= ShadowFileLength)) {
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscReadPrologue %08lx EOFdcon\n",
                               RxContext ));
        RxContext->InformationToReturn = 0;
        Status = STATUS_END_OF_FILE;
    } else if ( Disconnected ||
        (ByteOffset+ByteCount <= ShadowFileLength) ) {
        //okay then....let's get it from cache!!!!
        //CODE.IMPROVEMENT.ASHAMED we should get any part that overlaps the
        //                         cache from cache....sigh...this is for
        //                         connected obviously
        LONG ReadLength;
        IO_STATUS_BLOCK IoStatusBlockT;

        ReadLength = Nt5CscReadWriteFileEx (
                R0_READFILE,
                (CSCHFILE)smbSrvOpen->hfShadow,
                (ULONG)ByteOffset,
                UserBuffer,
                ByteCount,
                0,
                &IoStatusBlockT);


        if (ReadLength >= 0)
        {
            RxDbgTrace(0, Dbg,
                ("MRxSmbCscReadPrologue %08lx read %08lx bytes\n",
                               RxContext, ReadLength ));
            //sometimes things are good........
            RxContext->InformationToReturn = ReadLength;
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = IoStatusBlockT.Status;
        }
    }

FINALLY:
    if (EnteredCriticalSection) {
        CscLeaveShadowReadWriteCrit(smbFcb);
    }

    if (Status==STATUS_SUCCESS) {
        MRxSmbCscReleaseSmbFcb(RxContext,SmbFcbHoldingState);
    }

    if (ThisIsAReenter &&
        (Status != STATUS_MORE_PROCESSING_REQUIRED)) {
        ASSERT(Status != STATUS_PENDING);
        ASSERT(FlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
        RxContext->StoredStatus = Status;
        RxLowIoCompletion(RxContext);
        Status = STATUS_PENDING;
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscReadPrologue -> %08lx\n", Status ));
    return Status;
}

ULONG ExtendOnSurrogateOpen = 0;

VOID
MRxSmbCscReadEpilogue (
      IN OUT PRX_CONTEXT RxContext,
      IN OUT PNTSTATUS   Status
      )
/*++

Routine Description:

   This routine performs the tail of a read operation for CSC. In
   particular, if the read data can be used to extend the cached
   prefix, then we make it so.

   The status of the read operation is passed in case we someday find
   things are so messed up that we want to return a failure even after
   a successful read. not today however...

   CODE.IMPROVEMENT.ASHAMED when we get here the buffer may overlap..we
   should only write the suffix. if we do this, we will have to do some
   wierd stuff in the pagingio path but it will be worth it.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS LocalStatus;
    ULONG ShadowFileLength;
    LONG iRet;

    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB  smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PBYTE UserBuffer = RxLowIoGetBufferAddress(RxContext);
    ULONGLONG ByteOffset = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    ULONG ByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;
    ULONG ReadLength = (ULONG)RxContext->InformationToReturn;
    BOOLEAN EnteredCriticalSection = FALSE;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbCscReadEpilogueentry %08lx...%08lx bytes @ %08lx on handle %08lx\n",
            RxContext, ByteCount,
            ((PLARGE_INTEGER)(&ByteOffset))->LowPart,
            smbSrvOpen->hfShadow ));

    if ((*Status != STATUS_SUCCESS)
           || (ReadLength ==0) ){
        RxDbgTrace(0, Dbg, ("MRxSmbCscReadEpilogue exit w/o extending -> %08lx\n", Status ));
        goto FINALLY;
    }
    if (smbFcb->ShadowIsCorrupt) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscReadEpilogue exit w/o extending sh_corrupt-> %08lx\n", Status ));
        goto FINALLY;
    }

    // we cannot ask for the csc lock if we are not the toplevel guy......
    if (!FlagOn(RxContext->Flags, RX_CONTEXT_FLAG_THIS_DEVICE_TOP_LEVEL)) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscReadEpilogue exit w/o extending NOTTOP -> %08lx\n", Status ));
        //KdPrint(("MRxSmbCscReadEpilogue exit w/o extending NOTTOP -> %08lx\n", Status ));
        goto FINALLY;
    }

    CscEnterShadowReadWriteCrit(smbFcb);
    EnteredCriticalSection = TRUE;

    // check whether we are extend overlapping the prefix
    iRet = GetFileSizeLocal((CSCHFILE)(smbSrvOpen->hfShadow), &ShadowFileLength);
    RxDbgTrace( 0, Dbg,
        ("MRxSmbCscReadEpilogue %08lx (st=%08lx) fsize= %08lx, readlen=%08lx\n",
            RxContext, iRet, ShadowFileLength, ReadLength));

    if (iRet <0) {
        goto FINALLY;
    }

    if ((ByteOffset <= ShadowFileLength) && (ByteOffset+ReadLength > ShadowFileLength)) {
        NTSTATUS ShadowWriteStatus;
        ULONG LengthActuallyWritten;
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscReadEpilogue %08lx writing  %08lx bytes\n",
                RxContext,ReadLength ));

        if (FlagOn(smbSrvOpen->Flags,SMB_SRVOPEN_FLAG_OPEN_SURROGATED)) {
            ExtendOnSurrogateOpen++;
        }

        // do a write only if there is non-zero size data to be written.
        if (RxContext->InformationToReturn)
        {
            ShadowWriteStatus = MRxSmbCscShadowWrite(
                                    RxContext,
                                    (ULONG)RxContext->InformationToReturn,
                                    ShadowFileLength,
                                    &LengthActuallyWritten);
            RxDbgTrace(0, Dbg,
                ("MRxSmbCscReadEpilogue %08lx writing  %08lx bytes %08lx written\n",
                    RxContext,ReadLength,LengthActuallyWritten ));

            if (ShadowWriteStatus != STATUS_SUCCESS)
            {
                if (FlagOn(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_COPYCHUNK_OPEN)) {

//                    RxDbgTrace(0, Dbg, ("Copychunk failed status=%x \r\n", ShadowWriteStatus));

                    *Status = ShadowWriteStatus;
                }
            }

        }
    }

FINALLY:
    if (EnteredCriticalSection) {
        CscLeaveShadowReadWriteCrit(smbFcb);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscReadEpilogue exit -> %08lx %08lx\n", RxContext, Status ));
    return;
}



NTSTATUS
MRxSmbCscWritePrologue (
      IN OUT PRX_CONTEXT RxContext,
      OUT    SMBFCB_HOLDING_STATE *SmbFcbHoldingState
      )
/*++

Routine Description:

   This routine just performs the correct write synchronization.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    NTSTATUS AcquireStatus;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN     SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
         = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);

    BOOLEAN Disconnected;

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PBYTE          UserBuffer = RxLowIoGetBufferAddress(RxContext);
    ULONGLONG      ByteOffset = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    ULONG          ByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbCscWritePrologue entry(%08lx)...%08lx bytes @ %08lx on handle %08lx\n",
            RxContext,ByteCount,
            ((PLARGE_INTEGER)(&ByteOffset))->LowPart,smbSrvOpen->hfShadow ));

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);
                        



    IF_NOT_MRXSMB_BUILD_FOR_DISCONNECTED_CSC{
        ASSERT(!Disconnected);
    } else {
        if (Disconnected) {
            Status = MRxSmbCscWriteDisconnected(RxContext);
            RxDbgTrace(-1, Dbg,
                ("MRxSmbCscWritePrologue dcon(%08lx)... %08lx %08lx\n",
                    RxContext,Status,RxContext->InformationToReturn ));
            return(Status);
        }
    }

    AcquireStatus = MRxSmbCscAcquireSmbFcb(
                        RxContext,
                        Exclusive_SmbFcbAcquire,
                        SmbFcbHoldingState);

    if (AcquireStatus != STATUS_SUCCESS) {
        //we couldn't acquire.....get out
        Status = AcquireStatus;
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscWritePrologue couldn't acquire!!!-> %08lx %08lx\n",
                RxContext, Status ));
    }

    IF_DEBUG {
        if (Status == STATUS_SUCCESS) {
            RxCaptureFcb;
            PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
            ASSERT( smbFcb->CscOutstandingReaders < 0);
        }
    }
    RxDbgTrace(-1, Dbg, ("MRxSmbCscWritePrologue exit-> %08lx %08lx\n", RxContext, Status ));
    return Status;
}

VOID
MRxSmbCscWriteEpilogue (
      IN OUT PRX_CONTEXT RxContext,
      IN OUT PNTSTATUS   Status
      )
/*++

Routine Description:

   This routine performs the tail of a write operation for CSC. In
   particular, if the written data overlaps or extends the cached prefix
   then we write the data into the cache.

   The status of the write operation is passed in case we someday find
   things are so messed up that we want to return a failure even after
   a successful read. not today however...

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS LocalStatus;
    ULONG ShadowFileLength;
    LONG iRet;

    RxCaptureFcb;RxCaptureFobx;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PBYTE UserBuffer = RxLowIoGetBufferAddress(RxContext);
    ULONGLONG ByteOffset = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    ULONG ByteCount = LowIoContext->ParamsFor.ReadWrite.ByteCount;
    ULONG WriteLength = (ULONG)RxContext->InformationToReturn;
    BOOLEAN EnteredCriticalSection = FALSE;

    RxDbgTrace(+1, Dbg,
        ("MRxSmbCscWriteEpilogue entry %08lx...%08lx bytes @ %08lx on handle %08lx\n",
            RxContext, ByteCount,
            ((PLARGE_INTEGER)(&ByteOffset))->LowPart,
            smbSrvOpen->hfShadow ));

    if ((*Status != STATUS_SUCCESS) || (WriteLength ==0)) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscWriteEpilogue exit w/o extending -> %08lx\n", Status ));
        goto FINALLY;
    }

    if (smbFcb->ShadowIsCorrupt) {
        RxDbgTrace(0, Dbg, ("MRxSmbCscWriteEpilogue exit w/o extending sh_corrupt-> %08lx\n", Status ));
        goto FINALLY;
    }

    // remember that modifications have happened
    // so that we can update the time stamp at close
    mSetBits(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED);

    CscEnterShadowReadWriteCrit(smbFcb);
    EnteredCriticalSection = TRUE;

    // check whether we are extend overlapping the prefix
    iRet = GetFileSizeLocal((CSCHFILE)(smbSrvOpen->hfShadow), &ShadowFileLength);
    RxDbgTrace( 0, Dbg,
        ("MRxSmbCscWriteEpilogue %08lx (st=%08lx) fsize= %08lx, writelen=%08lx\n",
            RxContext, iRet, ShadowFileLength, WriteLength));

    if (iRet <0) {
        goto FINALLY;
    }

    if (!mShadowSparse(smbFcb->ShadowStatus)
                     || (ByteOffset <= ShadowFileLength)) {
        ULONG LengthActuallyWritten;
        NTSTATUS ShadowWriteStatus;
        // do a write only if there is non-zero size data to be written.
        if (RxContext->InformationToReturn)
        {

            RxDbgTrace(0, Dbg,
                 ("MRxSmbCscWriteEpilogue writing  %08lx bytes\n", WriteLength ));

            ShadowWriteStatus = MRxSmbCscShadowWrite(
                                    RxContext,
                                    (ULONG)RxContext->InformationToReturn,
                                    ShadowFileLength,
                                    &LengthActuallyWritten);

            if (LengthActuallyWritten != WriteLength) {
                //the localwrite has failedso the shadowis now corrupt!
                smbFcb->ShadowIsCorrupt = TRUE;
                RxDbgTrace(0, Dbg, ("MRxSmbCscWriteEpilogue: Shadow Is Now corrupt"
                                  "  %08lx %08lx %08lx\n",
                               ShadowWriteStatus,
                               LengthActuallyWritten,
                               WriteLength  ));
            }
        }
    }

FINALLY:
    if (EnteredCriticalSection) {
        CscLeaveShadowReadWriteCrit(smbFcb);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscWriteEpilogue exit-> %08lx %08lx\n", RxContext, Status ));
    return;
}

// this is used to do pagesized read-before-write
// CHAR xMRxSmbCscSideBuffer[PAGE_SIZE];

NTSTATUS
MRxSmbCscShadowWrite (
      IN OUT PRX_CONTEXT RxContext,
      IN     ULONG       ByteCount,
      IN     ULONGLONG   ShadowFileLength,
         OUT PULONG LengthActuallyWritten
      )
/*++

Routine Description:

   This routine performs a shadowwrite. it uses unbuffered write doing
   prereads as necessary. sigh. we cannot use buffered write because such
   a write could be arbitrarily deferred (as in CcCanIWrite) so that we
   deadlock.
   

Arguments:

    RxContext - the RDBSS context

Return Value:
       RxPxBuildAsynchronousRequest

Notes:

CODE.IMPROVEMENT.ASHAMED if we could get a nondeferrable cached write....we
would only have to do all this nobuffered stuff under intense memory pressure
instead of all the time.

The routine does this in (potentially) 3 phases

1) If the starting offset is not aligned on a page boundary then
   - read from the earlier page boundary to the next page boundary to the starting offset
   - merge the passed in buffer
   - write the whole page

2) 0 or more page size writes

3) residual write of less than page size, similar to what is explained in 1) above


--*/
{
    NTSTATUS Status;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PLOWIO_CONTEXT LowIoContext = &RxContext->LowIoContext;
    PBYTE UserBuffer = RxLowIoGetBufferAddress(RxContext);

    LARGE_INTEGER ByteOffset,EndBytePlusOne;
    ULONG MisAlignment,InMemoryMisAlignment;
    ULONG LengthRead,BytesToCopy,BytesToWrite,LengthWritten;
    CHAR *pAllocatedSideBuffer = NULL;

    IO_STATUS_BLOCK IoStatusBlock;

    BOOLEAN PagingIo = BooleanFlagOn(LowIoContext->ParamsFor.ReadWrite.Flags,
                                     LOWIO_READWRITEFLAG_PAGING_IO);

    PNT5CSC_MINIFILEOBJECT MiniFileObject = (PNT5CSC_MINIFILEOBJECT)(smbSrvOpen->hfShadow);


    ByteOffset.QuadPart     = LowIoContext->ParamsFor.ReadWrite.ByteOffset;
    EndBytePlusOne.QuadPart = ByteOffset.QuadPart + ByteCount;
    *LengthActuallyWritten  = 0;

    ASSERT_MINIRDRFILEOBJECT(MiniFileObject);

    pAllocatedSideBuffer = RxAllocatePoolWithTag(
                               NonPagedPool,
                               PAGE_SIZE,
                               MRXSMB_MISC_POOLTAG );

    if (pAllocatedSideBuffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // In attempting to do the write there are a multitude of error cases. The
    // following for loop is a scoping construct to ensure that the recovery
    // code can be concentrated in the tail of the routine.

    try {
        RxDbgTrace(
            +1, Dbg,
            ("MRxSmbCscShadowWrite %08lx len/off=%08lx %08lx %08lx %08lx\n",
            RxContext,ByteCount,ByteOffset.LowPart,UserBuffer,&pAllocatedSideBuffer[0]));

        // CASE 1: byteoffset is not aligned
        //         we write enough to get aligned.

        MisAlignment = ByteOffset.LowPart & (PAGE_SIZE - 1);
        if ( MisAlignment != 0) {
            LARGE_INTEGER AlignedOffset = ByteOffset;

            AlignedOffset.LowPart &= ~(PAGE_SIZE - 1);

            RtlZeroMemory(
                &pAllocatedSideBuffer[0],
                PAGE_SIZE);

            //if the aligned offset is within the file, we have to read
            if ((ShadowFileLength!=0) &&
                (AlignedOffset.QuadPart < ((LONGLONG)(ShadowFileLength)) )) {
                LengthRead = Nt5CscReadWriteFileEx (
                                 R0_READFILE,
                                (CSCHFILE)MiniFileObject,
                                 AlignedOffset.QuadPart,
                                 &pAllocatedSideBuffer[0],
                                 PAGE_SIZE,
                                 NT5CSC_RW_FLAG_IRP_NOCACHE,
                                 &IoStatusBlock
                                 );

                Status = IoStatusBlock.Status;

                if ((Status != STATUS_SUCCESS) &&
                    (Status != STATUS_END_OF_FILE)) {
                    RxDbgTrace (
                        -1, Dbg,
                        ("  -->Status/count after preread failed %08lx(%08lx,%08lx)\n",
                        RxContext,Status,*LengthActuallyWritten));
                    try_return(Status);
                }
            } else {
                LengthRead = 0;
            }

            //copy the right bytes into the buffer
            BytesToCopy = min(ByteCount,PAGE_SIZE-MisAlignment);

            RtlCopyMemory(
                &pAllocatedSideBuffer[0]+MisAlignment,
                UserBuffer,
                BytesToCopy);

            BytesToWrite = MisAlignment + BytesToCopy;

            if (BytesToWrite < LengthRead) {
                BytesToWrite = LengthRead;
            }

            RxDbgTrace(
                0, Dbg,
                ("alignwrite len/off=%08lx %08lx %08lx\n",
                BytesToWrite,AlignedOffset.LowPart,0));

            LengthWritten = Nt5CscReadWriteFileEx (
                                R0_WRITEFILE,
                               (CSCHFILE)MiniFileObject,
                                AlignedOffset.QuadPart,
                                &pAllocatedSideBuffer[0],
                                BytesToWrite,
                                NT5CSC_RW_FLAG_IRP_NOCACHE,
                                &IoStatusBlock
                                );

            Status = IoStatusBlock.Status;

            if (Status != STATUS_SUCCESS) {
                RxDbgTrace (
                    -1, Dbg,
                    ("  -->Status/count after alingwrite failed %08lx(%08lx,%08lx)\n",
                    RxContext,Status,*LengthActuallyWritten));
                try_return(Status);
            }

            *LengthActuallyWritten += BytesToCopy;
            if (BytesToCopy == ByteCount) {
                RxDbgTrace (-1, Dbg,
                         ("  -->Status/count after alingwrite succeded and out %08lx(%08lx,%08lx)\n",
                         RxContext,Status,*LengthActuallyWritten));
                try_return(Status);
            }

            ByteCount -= BytesToCopy;
            ByteOffset.QuadPart += BytesToCopy;
            UserBuffer += BytesToCopy;
        }

        //  CASE 2 with an aligned startpointer, we write out as much as we can
        //         without copying. if the endpointer is aligned OR we cover the
        //         end of the file, then we write out everything. otherwise, we
        //         just write however many whole pages we have.

        // we also have to back to to just writing full pages if including the
        // "trailing bytes" would take us onto a new physical page of memory
        // because we are doing this write under the original Mdl lock.

        RxDbgTrace(
            +1, Dbg,
            ("MRxSmbCscShadowWrite case 2 %08lx len/off=%08lx %08lx %08lx %08lx\n",
            RxContext,ByteCount,ByteOffset.LowPart,UserBuffer,&pAllocatedSideBuffer[0]));

        BytesToWrite = (ByteCount >> PAGE_SHIFT) << PAGE_SHIFT;

        MisAlignment = EndBytePlusOne.LowPart & (PAGE_SIZE - 1);
        InMemoryMisAlignment = (ULONG)((ULONG_PTR)UserBuffer) & (PAGE_SIZE - 1);

        if ((InMemoryMisAlignment == 0) &&
            (EndBytePlusOne.QuadPart) >= ((LONGLONG)ShadowFileLength)) {
            BytesToWrite = ByteCount;
        }

        if ((BytesToWrite != 0)&&(BytesToWrite>=PAGE_SIZE)) {
            if (((ULONG_PTR)UserBuffer & 0x3) == 0) {
                RxDbgTrace(
                    0, Dbg,
                    ("spaningwrite len/off=%08lx %08lx %08lx %08lx\n",
                    BytesToWrite,ByteCount,ByteOffset.LowPart,UserBuffer));

                LengthWritten = Nt5CscReadWriteFileEx (
                                    R0_WRITEFILE,
                                    (CSCHFILE)MiniFileObject,
                                    ByteOffset.QuadPart,
                                    UserBuffer,
                                    BytesToWrite,
                                    NT5CSC_RW_FLAG_IRP_NOCACHE,
                                    &IoStatusBlock
                                    );

                Status = IoStatusBlock.Status;

                if (Status != STATUS_SUCCESS) {
                    RxDbgTrace (
                        -1, Dbg,
                        ("  -->Status/count after spanningingwrite failed %08lx(%08lx,%08lx)\n",
                        RxContext,Status,*LengthActuallyWritten));
                    try_return(Status);
                }

                *LengthActuallyWritten += BytesToWrite;

                if (BytesToWrite == ByteCount) {
                    RxDbgTrace (
                        -1, Dbg,
                        ("  -->Status/count after spanningingwrite succeded and out %08lx(%08lx,%08lx)\n",
                        RxContext,Status,*LengthActuallyWritten));
                    try_return(Status);
                }

                ByteCount -= BytesToWrite;
                ByteOffset.QuadPart += BytesToWrite;
                UserBuffer += BytesToWrite;
            } else {
                // This is the case when the offsets are aligned but the user supplied
                // buffer is not aligned. In such cases we have to resort to copying
                // the user supplied buffer onto the local buffer allocated and then
                // spin out the writes

                while (BytesToWrite > 0) {
                    ULONG BytesToWriteThisIteration;

                    BytesToWriteThisIteration = (BytesToWrite < PAGE_SIZE) ?
                                                BytesToWrite :
                                                PAGE_SIZE;

                    RtlCopyMemory(
                        &pAllocatedSideBuffer[0],
                        UserBuffer,
                        BytesToWriteThisIteration);

                    LengthWritten = Nt5CscReadWriteFileEx (
                                        R0_WRITEFILE,
                                        (CSCHFILE)MiniFileObject,
                                        ByteOffset.QuadPart,
                                        &pAllocatedSideBuffer[0],
                                        BytesToWriteThisIteration,
                                        NT5CSC_RW_FLAG_IRP_NOCACHE,
                                        &IoStatusBlock
                                        );

                    Status = IoStatusBlock.Status;

                    if (Status != STATUS_SUCCESS) {
                        try_return(Status);
                    }

                    ByteCount -= LengthWritten;
                    ByteOffset.QuadPart += LengthWritten;
                    UserBuffer += LengthWritten;

                    *LengthActuallyWritten += LengthWritten;

                    BytesToWrite -= LengthWritten;
                }

                if (*LengthActuallyWritten == ByteCount) {
                    try_return(Status);
                }
            }
        }

        // CASE 3: we don't have the whole buffer, ByteCount is less than PAGE_SIZE

        RtlZeroMemory(&pAllocatedSideBuffer[0], PAGE_SIZE);

        RxDbgTrace(
            +1, Dbg,
            ("MRxSmbCscShadowWrite case 3 %08lx len/off=%08lx %08lx %08lx %08lx\n",
            RxContext,ByteCount,ByteOffset.LowPart,
                                UserBuffer,
                                &pAllocatedSideBuffer[0]));


        LengthRead = Nt5CscReadWriteFileEx (
                         R0_READFILE,
                         (CSCHFILE)MiniFileObject,
                         ByteOffset.QuadPart,
                         &pAllocatedSideBuffer[0],
                         PAGE_SIZE,
                         NT5CSC_RW_FLAG_IRP_NOCACHE,
                         &IoStatusBlock
                         );

        Status = IoStatusBlock.Status;
        if ((Status != STATUS_SUCCESS) &&
                (Status != STATUS_END_OF_FILE)) {
            RxDbgTrace (-1, Dbg,
                     ("  -->Status/count after punkread failed %08lx(%08lx,%08lx)\n",
                     RxContext,Status,*LengthActuallyWritten));
            try_return(Status);
        }

        RtlCopyMemory(&pAllocatedSideBuffer[0],UserBuffer,ByteCount);
        BytesToWrite = ByteCount;
        
        // here, if the ByetsToWrite is not sector aligned, it gets so
        // because LeghthRead must be sector aligned

        if (BytesToWrite < LengthRead) {
            BytesToWrite = LengthRead;
        }

        RxDbgTrace(0, Dbg, ("punkwrite len/off=%08lx %08lx %08lx\n",
                                BytesToWrite,
                                ByteOffset.LowPart,
                                UserBuffer));
        if (BytesToWrite)
        {
            LengthWritten = Nt5CscReadWriteFileEx (
                                R0_WRITEFILE,
                                (CSCHFILE)MiniFileObject,
                                ByteOffset.QuadPart,
                                &pAllocatedSideBuffer[0],
                                BytesToWrite,
                                NT5CSC_RW_FLAG_IRP_NOCACHE,
                                &IoStatusBlock
                                );
            Status = IoStatusBlock.Status;
            if (Status != STATUS_SUCCESS) {
                RxDbgTrace (-1, Dbg,
                         ("  -->Status/count after punkwrite failed %08lx(%08lx,%08lx)\n",
                         RxContext,Status,*LengthActuallyWritten));
                try_return(Status);
            }
        }

        *LengthActuallyWritten += ByteCount;
        RxDbgTrace (-1, Dbg,
                 ("  -->Status/count after punkwrite succeded and out %08lx(%08lx,%08lx)\n",
                 RxContext,Status,*LengthActuallyWritten));

    try_exit: NOTHING;
    } finally {
        ASSERT(pAllocatedSideBuffer);
        RxFreePool(pAllocatedSideBuffer);
    }

    return(Status);
}


#ifdef MRXSMB_BUILD_FOR_CSC_DCON
NTSTATUS
MRxSmbDCscExtendForCache (
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine performs the extend-for-cache operation. if connected, the
   cache is backed up by the server's disk....so we do nothing. if disconnected,
   we extend on the underlying shadow file by writing a zero in a good place and then
   reading back the allocation size.

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:


--*/
{
    NTSTATUS Status = STATUS_MORE_PROCESSING_REQUIRED;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
         = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
    BOOLEAN Disconnected;

    ULONG Buffer = 0;
    ULONG LengthActuallyWritten;
    LARGE_INTEGER ByteOffset;
    PNT5CSC_MINIFILEOBJECT MiniFileObject = (PNT5CSC_MINIFILEOBJECT)(smbSrvOpen->hfShadow);

    IO_STATUS_BLOCK IoStatusBlock;


    ASSERT_MINIRDRFILEOBJECT(MiniFileObject);

    Disconnected = MRxSmbCSCIsDisconnectedOpen(capFcb, smbSrvOpen);

    if (!Disconnected) {
        return(Status);
    }

    RxDbgTrace(+1, Dbg,
        ("MRxSmbDCscExtendForCache(%08lx)...%08lx/%08lx @ %08lx on handle %08lx\n",
            RxContext,pNewFileSize->LowPart,
            pNewAllocationSize->LowPart,smbSrvOpen->hfShadow ));

    ByteOffset.QuadPart = pNewFileSize->QuadPart - 1;

    LengthActuallyWritten = Nt5CscReadWriteFileEx (
                                R0_WRITEFILE,
                                (CSCHFILE)MiniFileObject,
                                ByteOffset.QuadPart,
                                &Buffer,
                                1,
                                0,
                                &IoStatusBlock
                                );

    if (LengthActuallyWritten != 1) {
        Status = IoStatusBlock.Status;
        RxDbgTrace(0, Dbg,
            ("MRxSmbDCscExtendForCache(%08lx) write error... %08lx\n",RxContext,Status));
        goto FINALLY;
    }

    //MiniFileObject->StandardInfo.EndOfFile.LowPart = 0xfffffeee;

    Status = Nt5CscXxxInformation(
                    (PCHAR)IRP_MJ_QUERY_INFORMATION,
                    MiniFileObject,
                    FileStandardInformation,
                    sizeof(MiniFileObject->StandardInfo),
                    &MiniFileObject->StandardInfo,
                    &MiniFileObject->ReturnedLength
                    );

    if (Status != STATUS_SUCCESS) {
       RxDbgTrace(0, Dbg,
            ("MRxSmbDCscExtendForCache(%08lx) qfi error... %08lx\n",RxContext,Status));
       goto FINALLY;
    }

    *pNewAllocationSize = MiniFileObject->StandardInfo.AllocationSize;

FINALLY:

    RxDbgTrace(-1, Dbg,
        ("MRxSmbDCscExtendForCache(%08lx) exit...%08lx/%08lx @ %08lx, status %08lx\n",
            RxContext,pNewFileSize->LowPart,
            pNewAllocationSize->LowPart,smbSrvOpen->hfShadow ));

    return(Status);

}



NTSTATUS
MRxSmbCscWriteDisconnected (
      IN OUT PRX_CONTEXT RxContext
      )
/*++

Routine Description:

   This routine just performs the correct write when we're disconnected. it
   calls the same routine for writing (ShadowWrite) as connected mode writes.
   ShadowWrite requires the filelength for its correct operation; in
   disconnected mode, we just get this out of the smb!

Arguments:

    RxContext - the RDBSS context

Return Value:

    NTSTATUS - The return status for the operation

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_SRV_OPEN SrvOpen = capFobx->pSrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);
    PMRX_SMB_FCB smbFcb = MRxSmbGetFcbExtension(capFcb);

    PFCB wrapperFcb = (PFCB)(capFcb); 
    ULONGLONG ShadowFileLength;
    ULONG LengthActuallyWritten;
    ULONG ByteCount = RxContext->LowIoContext.ParamsFor.ReadWrite.ByteCount;
    ULONGLONG   ByteOffset;
    BOOLEAN EnteredCriticalSection = FALSE;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry =
                  SmbCeGetAssociatedNetRootEntry(NetRoot);
#if defined(BITCOPY)
    ULONG * lpByteOffset;
#endif // defined(BITCOPY)


    ByteOffset = RxContext->LowIoContext.ParamsFor.ReadWrite.ByteOffset;

    IF_DEBUG {
        PSMBCEDB_NET_ROOT_ENTRY pNetRootEntry
             = SmbCeGetAssociatedNetRootEntry(capFcb->pNetRoot);
        PSMBCEDB_SERVER_ENTRY   pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
        BOOLEAN Disconnected;

        Disconnected = (BooleanFlagOn(
                           smbSrvOpen->Flags,
                           SMB_SRVOPEN_FLAG_DISCONNECTED_OPEN)||
                        SmbCeIsServerInDisconnectedMode(pServerEntry));


        ASSERT(Disconnected);
    }

    IF_DEBUG {
        ASSERT_MINIRDRFILEOBJECT((PNT5CSC_MINIFILEOBJECT)(smbSrvOpen->hfShadow));

        RxDbgTrace(+1, Dbg,
            ("MRxSmbCscWriteDisconnected entry(%08lx)...%08lx bytes @ %08lx on handle %08lx\n",
                RxContext,ByteCount,
                (ULONG)ByteOffset,smbSrvOpen->hfShadow ));
    }

    // remember that modifications have happened
    // so that we can update the time stamp at close
    mSetBits(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_SHADOW_DATA_MODIFIED);

    CscEnterShadowReadWriteCrit(smbFcb);
    EnteredCriticalSection = TRUE;

    ShadowFileLength = wrapperFcb->Header.FileSize.QuadPart;

    Status = MRxSmbCscShadowWrite(
                 RxContext,
                 ByteCount,
                 ShadowFileLength,
                 &LengthActuallyWritten);

    RxContext->InformationToReturn = LengthActuallyWritten;

#if defined(BITCOPY)
    // Mark the bitmap, if it exists
    lpByteOffset = (ULONG*)(LPVOID)&ByteOffset;
    if (Status == STATUS_SUCCESS) {
        CscBmpMark(smbFcb->lpDirtyBitmap,
            lpByteOffset[0],
            LengthActuallyWritten);
    }
#endif // defined(BITCOPY)

    if (Status != STATUS_SUCCESS) {
        RxDbgTrace(0, Dbg,
            ("MRxSmbCscWriteDisconnected(%08lx) write error... %08lx %08lx %08lx\n",
                        RxContext,Status,ByteCount,LengthActuallyWritten));
        goto FINALLY;
    }
    else
    {
        // note the fact that this replica is dirty and it's data would have to merged
        smbFcb->ShadowStatus |= SHADOW_DIRTY;

        // if the file has gotten extended, then notify the change
        if ((ByteOffset+LengthActuallyWritten) > ShadowFileLength)
        {
            FsRtlNotifyFullReportChange(
                pNetRootEntry->NetRoot.pNotifySync,
                &pNetRootEntry->NetRoot.DirNotifyList,
                (PSTRING)GET_ALREADY_PREFIXED_NAME(NULL,capFcb),
                (USHORT)(GET_ALREADY_PREFIXED_NAME(NULL, capFcb)->Length -
                smbFcb->MinimalCscSmbFcb.LastComponentLength),
                NULL,
                NULL,
                FILE_NOTIFY_CHANGE_SIZE,
                FILE_ACTION_MODIFIED,
                NULL);
        }
    }


FINALLY:
    if (EnteredCriticalSection) {
        CscLeaveShadowReadWriteCrit(smbFcb);
    }

    RxDbgTrace(-1, Dbg, ("MRxSmbCscWriteDisconnected exit-> %08lx %08lx\n", RxContext, Status ));
    return Status;
}

#endif //ifdef MRXSMB_BUILD_FOR_CSC_DCON
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\nt5csc.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    nt5csc.h

Abstract:

    The global include file for nt5csc within the nt5csc library

Author:

    Joe Linn (Joelinn) - Created  5-may-97

Revision History:

--*/

#ifndef _NT5CSC_H_
#define _NT5CSC_H_

//this include finds ntcsc.h from rdr2\inc
#include "..\csc\record.mgr\ntcsc.h"

#define CSC_AGENT_NOTIFIED     (0x11111111)
#define CSC_AGENT_NOT_NOTIFIED (0x22222222)

extern LONG    CscNetPresent;
extern LONG    CscAgentNotifiedOfNetStatusChange;
extern LONG    CscAgentNotifiedOfFullCache;

extern VOID
CscNotifyAgentOfNetStatusChangeIfRequired(BOOLEAN fInvokeAutodial);

// this event and mutex is used for synchronizing the transitioning of a
// server entry from connected to disconnected mode

extern KEVENT       CscServerEntryTransitioningEvent;
extern FAST_MUTEX   CscServerEntryTransitioningMutex;

extern FAST_MUTEX MRxSmbCscShadowReadWriteMutex;

//shared routines

INLINE
BOOLEAN
CscIsDfsOpen(
    PRX_CONTEXT RxContext)
{
    ASSERT(RxContext->MajorFunction == IRP_MJ_CREATE);

    return (RxContext->Create.NtCreateParameters.DfsContext != NULL);
}

PDFS_NAME_CONTEXT
CscIsValidDfsNameContext(
    PVOID   pFsContext);

NTSTATUS
CscDfsParseDfsPath(
    PUNICODE_STRING pDfsPath,
    PUNICODE_STRING pServerName,
    PUNICODE_STRING pSharePath,
    PUNICODE_STRING pFilePathRelativeToShare);

NTSTATUS
CscGrabPathFromDfs(
    PFILE_OBJECT      pFileObject,
    PDFS_NAME_CONTEXT pDfsNameContext);

NTSTATUS
MRxSmbCscObtainShareHandles (
    IN PUNICODE_STRING              ShareName,
    IN BOOLEAN                      DisconnectedMode,
    IN BOOLEAN                      CopyChunkOpen,
    IN OUT PSMBCEDB_NET_ROOT_ENTRY  pNetRootEntry
    );

//acquire/release stuff


// Another view of the minirdr context in the RxContext is as
// links for Csc Synchronization. This is used both for read/write
// synchronization and open synchornization when surrogate opens are
// involved

typedef struct _MRXSMBCSC_SYNC_RX_CONTEXT {
    ULONG Dummy; //this is the cancel routine....it must not be filled in
    USHORT TypeOfAcquire;
    UCHAR  FcbLockWasDropped;
    LIST_ENTRY   CscSyncLinks;
} MRXSMBCSC_SYNC_RX_CONTEXT, *PMRXSMBCSC_SYNC_RX_CONTEXT;


#define MRxSmbGetMinirdrContextForCscSync(pRxContext)     \
        ((PMRXSMBCSC_SYNC_RX_CONTEXT)(&(pRxContext)->MRxContext[0]))

#define Shared_SmbFcbAcquire SmbFcb_HeldShared
#define Exclusive_SmbFcbAcquire SmbFcb_HeldExclusive
#define DroppingFcbLock_SmbFcbAcquire 0x80000000
#define FailImmediately_SmbFcbAcquire 0x40000000


typedef struct _SID_CONTEXT_ {
    PSID    pSid;
    PVOID   Context;
} SID_CONTEXT, *PSID_CONTEXT;


NTSTATUS
MRxSmbCscAcquireSmbFcb (
      IN OUT PRX_CONTEXT RxContext,
      IN  ULONG TypeOfAcquirePlusFlags,
      OUT SMBFCB_HOLDING_STATE *SmbFcbHoldingState
      );

VOID
MRxSmbCscReleaseSmbFcb (
      IN OUT PRX_CONTEXT RxContext,
      IN SMBFCB_HOLDING_STATE *SmbFcbHoldingState
      );

VOID
MRxSmbCSCResumeAllOutstandingOperations(
    PSMBCEDB_SERVER_ENTRY   pServerEntry
);

// Control flag definitions for creating shadow handles
#define CREATESHADOW_NO_SPECIAL_CONTROLS                    0x0000
#define CREATESHADOW_CONTROL_NOCREATE                       0x0001
#define CREATESHADOW_CONTROL_NOREVERSELOOKUP                0x0002
#define CREATESHADOW_CONTROL_NOCREATELEAF                   0x0004
#define CREATESHADOW_CONTROL_NOCREATENONLEAF                0x0008
#define CREATESHADOW_CONTROL_SPARSECREATE                   0x0010
#define CREATESHADOW_CONTROL_FILE_WITH_HEURISTIC            0x0020  //.exe or .dll
#define CREATESHADOW_CONTROL_FAIL_IF_MARKED_FOR_DELETION    0x0040
#define CREATESHADOW_CONTROL_DO_SHARE_ACCESS_CHECK          0x0080
#define CREATESHADOW_CONTROL_STRIP_SHARE_NAME               0x0100


#ifdef DEBUG
//Hook dbgprint interface
#define HookKdPrint(__bit,__x) {\
    if (((HOOK_KDP_##__bit)==0) || FlagOn(HookKdPrintVector,(HOOK_KDP_##__bit))) {\
    KdPrint (__x);\
    }\
}
#define HOOK_KDP_ALWAYS             0x00000000
#define HOOK_KDP_BADERRORS          0x00000001
#define HOOK_KDP_NAME               0x00000002
#define HOOK_KDP_NET                0x00000004
#define HOOK_KDP_RW                 0x00000008
#define HOOK_KDP_TRANSITION         0x00000010
#define HOOK_KDP_AGENT              0x00000020
#define HOOK_KDP_IOCTL              0x00000040
#define HOOK_KDP_BITCOPY            0x00000080

#define HOOK_KDP_GOOD_DEFAULT (HOOK_KDP_BADERRORS         \
                | 0)

extern ULONG HookKdPrintVector;
extern ULONG HookKdPrintVectorDef;
#else
#define HookKdPrint(__bit,__x)  {NOTHING;}
#endif


extern NTSTATUS
MRxSmbCscCreateShadowFromPath (
    IN      PUNICODE_STRING     AlreadyPrefixedName,
    IN      PCSC_ROOT_INFO      pCscRootInfo,
    OUT     _WIN32_FIND_DATA   *Find32,
    OUT     PBOOLEAN            Created  OPTIONAL,
    IN      ULONG               Controls,
    IN OUT  PMINIMAL_CSC_SMBFCB MinimalCscSmbFcb,
    IN OUT  PRX_CONTEXT         RxContext,
    IN      BOOLEAN             fDisconnected,
    OUT     ULONG               *pulInheritedHintFlags
    );


#ifndef MRXSMB_BUILD_FOR_CSC_DCON
#define MRxSmbCscWriteDisconnected(__RXCONTEXT) (STATUS_SUCCESS)
#else
NTSTATUS
MRxSmbCscWriteDisconnected (
      IN OUT PRX_CONTEXT RxContext
      );
#endif
//NTSTATUS
//MRxSmbCscSpecialShadowWriteForPagingIo (
//      IN OUT PRX_CONTEXT RxContext,
//      IN     ULONG       ShadowFileLength,
//         OUT PULONG LengthActuallyWritten
//      );



#define CSC_REPORT_CHANGE(pNetRootEntry, pFcb, pSmbFcb, Filter, Action) \
            (pNetRootEntry)->NetRoot.pNotifySync,                       \
            &((pNetRootEntry)->NetRoot.DirNotifyList)                   \
            (pFcb)->pPrivateAlreaydPrefixedName.Buffer,                 \
            (USHORT)(GET_ALREADY_PREFIXED_NAME(pFcb)->PrivateAlreaydPrefixedName.Length -        \
                        (pSmbFcb)->MinimalCscSmbFcb.LastComponentLength),                \
            NULL,                                                       \
            NULL,                                                       \
            (ULONG)Filter,                                              \
            (ULONG)Action,                                              \
            NULL)


#ifdef RX_PRIVATE_BUILD
#if 1
#ifdef RDBSSTRACE
extern ULONG MRxSmbCscDbgPrintF;
#undef RxDbgTrace
#define RxDbgTrace(a,b,__d__) { if(MRxSmbCscDbgPrintF){DbgPrint __d__;}}
#undef RxDbgTraceUnIndent
#define RxDbgTraceUnIndent(a,b) {NOTHING;}
#endif //#ifdef RDBSSTRACE
#endif //if 1
#endif //ifdef RX_PRIVATE_BUILD



//CODE.IMPROVEMENT if we added another field to the large_integer union then we'd
//                 eliminate these 2 macros
#define COPY_LARGEINTEGER_TO_STRUCTFILETIME(dest,src) {\
     (dest).dwLowDateTime = (src).LowPart;             \
     (dest).dwHighDateTime = (src).HighPart;           \
     }
#define COPY_STRUCTFILETIME_TO_LARGEINTEGER(dest,src) {\
     (dest).LowPart = (src).dwLowDateTime;             \
     (dest).HighPart = (src).dwHighDateTime;           \
     }


NTSTATUS
CscDfsDoDfsNameMapping(
    PUNICODE_STRING pDfsPrefix, 
    PUNICODE_STRING pActualPrefix, 
    PUNICODE_STRING pNameToReverseMap,
    BOOL            fResolvedNameToDFSName,
    PUNICODE_STRING pResult);
    
NTSTATUS
CscDfsObtainReverseMapping( 
    PUNICODE_STRING pDfsPath,
    PUNICODE_STRING pResolvedPath,
    PUNICODE_STRING pReversemappingFrom,
    PUNICODE_STRING pReverseMappingTo);
    
NTSTATUS
CscDfsStripLeadingServerShare(
    IN  PUNICODE_STRING pDfsRootPath
    );

BOOLEAN
MRxSmbCSCIsDisconnectedOpen(
    PMRX_FCB    pFcb,
    PMRX_SMB_SRV_OPEN smbSrvOpen
    );

BOOL
CloseOpenFiles(
    HSHARE  hShare,
    PUNICODE_STRING pServerName,
    int     lenSkip
    );
    
VOID
MRxSmbCSCObtainRightsForUserOnFile(
    IN  PRX_CONTEXT     pRxContext,
    HSHADOW             hDir,
    HSHADOW             hShadow,
    OUT ACCESS_MASK     *pMaximalAccessRights,
    OUT ACCESS_MASK     *pGuestMaximalAccessRights
    );
    
NTSTATUS
CscRetrieveSid(
    PRX_CONTEXT     pRxContext,
    PSID_CONTEXT    pSidContext
    );

VOID
CscDiscardSid(
    PSID_CONTEXT pSidContext
    );

    
    
#endif   // _NT5CSC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\chal.c ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    nlmain.c

Abstract:

    This file contains the initialization and dispatch routines
    for the LAN Manager portions of the MSV1_0 authentication package.

Author:

    Jim Kelly 11-Apr-1991

Revision History:
    25-Apr-1991 (cliffv)
        Added interactive logon support for PDK.

    Chandana Surlu   21-Jul-1996
        Stolen from \\kernel\razzle3\src\security\msv1_0\nlmain.c
    Adam Barr        15-Dec-1997
        Modified from private\security\msv_sspi\nlmain.c

--*/


#include <rdrssp.h>

#include <nturtl.h>
#include <align.h>
#define NLP_ALLOCATE
#include "nlp.h"
#undef NLP_ALLOCATE

#include <md4.h>
#include <md5.h>
#include <hmac.h>


VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    )

/*++

Routine Description:

    This routine copies the InString string to the memory pointed to by
    the Where parameter, and fixes the OutString string to point to that
    new copy.

Parameters:

    OutString - A pointer to a destination NT string

    InString - A pointer to an NT string to be copied

    Where - A pointer to space to put the actual string for the
        OutString.  The pointer is adjusted to point to the first byte
        following the copied string.

Return Values:

    None.

--*/

{
    ASSERT( OutString != NULL );
    ASSERT( InString != NULL );
    ASSERT( Where != NULL && *Where != NULL);
    ASSERT( *Where == ROUND_UP_POINTER( *Where, sizeof(WCHAR) ) );
#ifdef notdef
    KdPrint(("NlpPutString: %ld %Z\n", InString->Length, InString ));
    KdPrint(("  InString: %lx %lx OutString: %lx Where: %lx\n", InString,
        InString->Buffer, OutString, *Where ));
#endif

    if ( InString->Length > 0 ) {

        OutString->Buffer = (PWCH) *Where;
        OutString->MaximumLength = (USHORT)(InString->Length + sizeof(WCHAR));

        RtlCopyUnicodeString( OutString, InString );

        *Where += InString->Length;
//        *((WCHAR *)(*Where)) = L'\0';
        *(*Where) = '\0';
        *(*Where + 1) = '\0';
        *Where += 2;

    } else {
        RtlInitUnicodeString(OutString, NULL);
    }
#ifdef notdef
    KdPrint(("  OutString: %ld %lx\n",  OutString->Length, OutString->Buffer));
#endif

    return;
}


NTSTATUS
NlpMakePrimaryCredential(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    IN PUNICODE_STRING CleartextPassword,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize,
    IN BOOLEAN OwfPasswordProvided
    )


/*++

Routine Description:

    This routine makes a primary credential for the given user nam and
    password.

Arguments:

    LogonDomainName - Is a string representing the domain in which the user's
        account is defined.

    UserName - Is a string representing the user's account name.  The
        name may be up to 255 characters long.  The name is treated case
        insensitive.

    CleartextPassword - Is a string containing the user's cleartext password.
        The password may be up to 255 characters long and contain any
        UNICODE value.

    CredentialBuffer - Returns a pointer to the specified credential allocated
        on the LsaHeap.  It is the callers responsibility to deallocate
        this credential.

    CredentialSize - the size of the allocated credential buffer (in bytes).

    OwfPasswordProvided - If TRUE, then we assume the password is provided as the LM and NT OWF,
        passwords concatenated together.


Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.


--*/

{
    PMSV1_0_PRIMARY_CREDENTIAL Credential;
    NTSTATUS Status;
    PUCHAR Where;
    CHAR LmPassword[LM20_PWLEN+1];
    BOOLEAN LmPasswordPresent;
    STRING AnsiCleartextPassword;

    if (!OwfPasswordProvided) {

        //
        // Compute the Ansi version to the Cleartext password.
        //
        //  The Ansi version of the Cleartext password is at most 14 bytes long,
        //      exists in a trailing zero filled 15 byte buffer,
        //      is uppercased.
        //

        AnsiCleartextPassword.Buffer = LmPassword;
        AnsiCleartextPassword.MaximumLength = sizeof(LmPassword);

        RtlZeroMemory( &LmPassword, sizeof(LmPassword) );

        Status = RtlUpcaseUnicodeStringToOemString(
                                      &AnsiCleartextPassword,
                                      CleartextPassword,
                                      (BOOLEAN) FALSE );

         if ( !NT_SUCCESS(Status) ) {
            RtlSecureZeroMemory( &LmPassword, sizeof(LmPassword) );
            AnsiCleartextPassword.Length = 0;
            LmPasswordPresent = FALSE;
         } else {

            LmPasswordPresent = TRUE;
        }
    }


    //
    // Build the credential
    //

    *CredentialSize = sizeof(MSV1_0_PRIMARY_CREDENTIAL) +
            LogonDomainName->Length + sizeof(WCHAR) +
            UserName->Length + sizeof(WCHAR);

    Credential = ExAllocatePool ( NonPagedPool, *CredentialSize );

    if ( Credential == NULL ) {
        KdPrint(("MSV1_0: NlpMakePrimaryCredential: No memory %ld\n",
            *CredentialSize ));
        return STATUS_QUOTA_EXCEEDED;
    }


    //
    // Put the LogonDomainName into the Credential Buffer.
    //

    Where = (PUCHAR)(Credential + 1);

    NlpPutString( &Credential->LogonDomainName, LogonDomainName, &Where );


    //
    // Put the UserName into the Credential Buffer.
    //

    NlpPutString( &Credential->UserName, UserName, &Where );


    if (OwfPasswordProvided) {

        RtlCopyMemory(&Credential->LmOwfPassword, CleartextPassword->Buffer, LM_OWF_PASSWORD_SIZE);
        Credential->LmPasswordPresent = TRUE;

        RtlCopyMemory(&Credential->NtOwfPassword, ((PUCHAR)CleartextPassword->Buffer) + LM_OWF_PASSWORD_SIZE, NT_OWF_PASSWORD_SIZE);
        Credential->NtPasswordPresent = TRUE;

    } else {

        //
        // Save the OWF encrypted versions of the passwords.
        //

        Status = RtlCalculateLmOwfPassword( LmPassword,
                                            &Credential->LmOwfPassword );

        ASSERT( NT_SUCCESS(Status) );

        Credential->LmPasswordPresent = LmPasswordPresent;

        Status = RtlCalculateNtOwfPassword( CleartextPassword,
                                            &Credential->NtOwfPassword );

        ASSERT( NT_SUCCESS(Status) );

        Credential->NtPasswordPresent = ( CleartextPassword->Length != 0 );

        //
        // Don't leave passwords around in the pagefile
        //

        RtlSecureZeroMemory( &LmPassword, sizeof(LmPassword) );


    }

    //
    // Return the credential to the caller.
    //
    *CredentialBuffer = Credential;
    return STATUS_SUCCESS;
}

VOID
SspUpcaseUnicodeString(
    IN OUT UNICODE_STRING* pUnicodeString
    )

/*++

Routine Description:

    Upcase unicode string, modifying string in place.

Arguments:

    pUnicodeString - string

Return Value:

    none

--*/

{
    ULONG i;

    for (i = 0; i < pUnicodeString->Length / sizeof(WCHAR); i++)
    {
        pUnicodeString->Buffer[i] = RtlUpcaseUnicodeChar(pUnicodeString->Buffer[i]);
    }
}

#define MSV1_0_NTLMV2_OWF_LENGTH MSV1_0_NTLM3_RESPONSE_LENGTH

VOID
SspCalculateNtlmv2Owf(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    OUT UCHAR Ntlmv2Owf[MSV1_0_NTLMV2_OWF_LENGTH]
    )
/*++

Routine Description:

    Calculate Ntlm v2 OWF, salted with username and logon domain name

Arguments:

    pNtOwfPassword    - NT OWF
    pUserName         - user name
    pLogonDomainName  - logon domain name
    Ntlmv2Owf         - NTLM v2 OWF

Return Value:

    none

--*/

{
    HMACMD5_CTX HMACMD5Context;

    //
    // reserve a scratch buffer
    //

    WCHAR szUserName[(UNLEN + 4)] = {0};
    UNICODE_STRING UserName = {0, sizeof(szUserName), szUserName};

    //
    //  first make a copy then upcase it
    //

    UserName.Length = min(UserName.MaximumLength, pUserName->Length);

    ASSERT(UserName.Length == pUserName->Length);

    memcpy(UserName.Buffer, pUserName->Buffer, UserName.Length);

    SspUpcaseUnicodeString(&UserName);

    //
    // Calculate Ntlmv2 OWF -- HMAC(MD4(P), (UserName, LogonDomainName))
    //

    HMACMD5Init(
        &HMACMD5Context,
        (UCHAR *) pNtOwfPassword,
        sizeof(*pNtOwfPassword)
        );

    HMACMD5Update(
        &HMACMD5Context,
        (UCHAR *) UserName.Buffer,
        UserName.Length
        );

    HMACMD5Update(
        &HMACMD5Context,
        (UCHAR *) pLogonDomainName->Buffer,
        pLogonDomainName->Length
        );

    HMACMD5Final(
        &HMACMD5Context,
        Ntlmv2Owf
        );
}

#define MSV1_0_NTLMV2_RESPONSE_LENGTH MSV1_0_NTLM3_RESPONSE_LENGTH

VOID
SspGetLmv2Response(
    IN NT_OWF_PASSWORD* pNtOwfPassword,
    IN UNICODE_STRING* pUserName,
    IN UNICODE_STRING* pLogonDomainName,
    IN UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH],
    IN UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH],
    OUT UCHAR Response[MSV1_0_NTLMV2_RESPONSE_LENGTH],
    OUT USER_SESSION_KEY* pUserSessionKey,
    OUT UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH]
    )

/*++

Routine Description:

    Get LMv2 response

Arguments:

    pNtOwfPassword       - NT OWF
    pUserName            - user name
    pLogonDomainName     - logon domain name
    ChallengeToClient    - challenge to client
    pLmv2Response        - Lm v2 response
    Routine              - response

Return Value:

    NTSTATUS

--*/

{
    HMACMD5_CTX HMACMD5Context;
    UCHAR Ntlmv2Owf[MSV1_0_NTLMV2_OWF_LENGTH];

    C_ASSERT(MD5DIGESTLEN == MSV1_0_NTLMV2_RESPONSE_LENGTH);

    //
    // get Ntlmv2 OWF
    //

    SspCalculateNtlmv2Owf(
        pNtOwfPassword,
        pUserName,
        pLogonDomainName,
        Ntlmv2Owf
        );

    //
    // Calculate Ntlmv2 Response
    // HMAC(Ntlmv2Owf, (ChallengeToClient, ChallengeFromClient))
    //

    HMACMD5Init(
        &HMACMD5Context,
        Ntlmv2Owf,
        MSV1_0_NTLMV2_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeToClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        ChallengeFromClient,
        MSV1_0_CHALLENGE_LENGTH
        );

    HMACMD5Final(
        &HMACMD5Context,
        Response
        );

    // now compute the session keys
    //  HMAC(Kr, R)
    HMACMD5Init(
        &HMACMD5Context,
        Ntlmv2Owf,
        MSV1_0_NTLM3_OWF_LENGTH
        );

    HMACMD5Update(
        &HMACMD5Context,
        Response,
        MSV1_0_NTLM3_RESPONSE_LENGTH
        );

    ASSERT(MD5DIGESTLEN == MSV1_0_USER_SESSION_KEY_LENGTH);

    HMACMD5Final(
        &HMACMD5Context,
        (PUCHAR)pUserSessionKey
        );

    ASSERT(MSV1_0_LANMAN_SESSION_KEY_LENGTH <= MSV1_0_USER_SESSION_KEY_LENGTH);
    RtlCopyMemory(
        LanmanSessionKey,
        pUserSessionKey,
        MSV1_0_LANMAN_SESSION_KEY_LENGTH
        );
}

typedef struct {
        UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH];
        UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
} MSV1_0_LM3_RESPONSE, *PMSV1_0_LM3_RESPONSE;

#define NULL_SESSION_REQUESTED 0x10

NTSTATUS
MspLm20GetChallengeResponse (
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    IN BOOLEAN OwfPasswordProvided
    )

/*++

Routine Description:

    This routine is the dispatch routine for LsaCallAuthenticationPackage()
    with a message type of MsV1_0Lm20GetChallengeResponse.  It is called by
    the LanMan redirector to determine the Challenge Response to pass to a
    server when trying to establish a connection to the server.

    This routine is passed a Challenge from the server.  This routine encrypts
    the challenge with either the specified password or with the password
    implied by the specified Logon Id.

    Two Challenge responses are returned.  One is based on the Unicode password
    as given to the Authentication package.  The other is based on that
    password converted to a multi-byte character set (e.g., ASCII) and upper
    cased.  The redirector should use whichever (or both) challenge responses
    as it needs them.

Arguments:

    The first four arguments to this routine are identical to those of LsaApCallPackage.
    Only the special attributes of these parameters as they apply to
    this routine are mentioned here.

    OwfPasswordProvided use is used to distinquish if the password is Owf or not.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_QUOTA_EXCEEDED -  This error indicates that the logon
        could not be completed because the client does not have
        sufficient quota to allocate the return buffer.

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    PMSV1_0_GETCHALLENRESP_REQUEST GetRespRequest;

    PMSV1_0_GETCHALLENRESP_RESPONSE GetRespResponse;

    PMSV1_0_PRIMARY_CREDENTIAL Credential = NULL;
    PMSV1_0_PRIMARY_CREDENTIAL BuiltCredential = NULL;

    PVOID ClientBuffer = NULL;
    PUCHAR ClientStrings;

    //
    // Responses to return to the caller.
    //
    MSV1_0_LM3_RESPONSE LmResp = {0};
    STRING LmResponseString;

    NT_RESPONSE NtResponse = {0};
    STRING NtResponseString;

    UNICODE_STRING NullUnicodeString = {0};
    USER_SESSION_KEY UserSessionKey;
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
    ULONG CredentialSize = 0;

    RtlZeroMemory( &UserSessionKey, sizeof(UserSessionKey) );
    RtlZeroMemory( LanmanSessionKey, sizeof(LanmanSessionKey) );

    //
    // If no credentials are associated with the client, a null session
    // will be used.  For a downlevel server, the null session response is
    // a 1-byte null string (\0).  Initialize LmResponseString to the
    // null session response.
    //

    RtlInitString( &LmResponseString, "" );
    LmResponseString.Length = 1;

    //
    // Initialize the NT response to the NT null session credentials,
    // which are zero length.
    //

    RtlInitString( &NtResponseString, NULL );

    //
    // Ensure the specified Submit Buffer is of reasonable size and
    // relocate all of the pointers to be relative to the LSA allocated
    // buffer.
    //

    if ( SubmitBufferSize < sizeof(MSV1_0_GETCHALLENRESP_REQUEST) ) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    GetRespRequest = (PMSV1_0_GETCHALLENRESP_REQUEST) ProtocolSubmitBuffer;

    ASSERT( GetRespRequest->MessageType == MsV1_0Lm20GetChallengeResponse );


    //
    // If the caller wants information from the credentials of a specified
    //  LogonId, get those credentials from the LSA.
    //
    // If there are no such credentials,
    //  tell the caller to use the NULL session.
    //

#define PRIMARY_CREDENTIAL_NEEDED \
        (RETURN_PRIMARY_USERNAME | \
        USE_PRIMARY_PASSWORD )

    if ( ((GetRespRequest->ParameterControl & PRIMARY_CREDENTIAL_NEEDED) != 0 ) && ((GetRespRequest->ParameterControl & NULL_SESSION_REQUESTED) == 0)) {

        ASSERT(FALSE);
    }

    //
    // If the caller passed in a password to use,
    //  use it to build a credential.
    //
    // The password is assumed to be the LM and NT OWF
    // passwords concatenated together.
    //

    if ( (GetRespRequest->ParameterControl & USE_PRIMARY_PASSWORD) == 0 ) {
        Status = NlpMakePrimaryCredential( &GetRespRequest->LogonDomainName,
                                           &GetRespRequest->UserName,
                                           &GetRespRequest->Password,
                                           &BuiltCredential,
                                           &CredentialSize,
                                           OwfPasswordProvided
                                         );

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        //
        // Use the newly allocated credential to get the password information
        // from.
        //

        Credential = BuiltCredential;
    }

    //
    // Build the appropriate response.
    //

    if ( Credential != NULL ) {

        ASSERT(Credential->UserName.Length);

        SspGetLmv2Response(
             &Credential->NtOwfPassword,
             &Credential->UserName,
             &Credential->LogonDomainName,
             GetRespRequest->ChallengeToClient,
             LmResp.ChallengeFromClient,
             LmResp.Response,
             &UserSessionKey,
             LanmanSessionKey
             );

        LmResponseString.Buffer = (UCHAR*) &LmResp;
        LmResponseString.Length = LmResponseString.MaximumLength = sizeof(LmResp);

        NtResponseString.Buffer = (CHAR*) L"";
        NtResponseString.Length = 0;
        NtResponseString.MaximumLength = sizeof(WCHAR);

        //
        // Compute the session keys
        //

        if ( GetRespRequest->ParameterControl & RETURN_NON_NT_USER_SESSION_KEY) {

            //
            // If the redir didn't negotiate an NT protocol with the server,
            //  use the lanman session key.
            //

            if ( Credential->LmPasswordPresent ) {

                ASSERT( sizeof(UserSessionKey) >= sizeof(LanmanSessionKey) );

                RtlCopyMemory( &UserSessionKey,
                               &Credential->LmOwfPassword,
                               sizeof(LanmanSessionKey) );
            }

            if ( Credential->LmPasswordPresent ) {
                RtlCopyMemory( LanmanSessionKey,
                               &Credential->LmOwfPassword,
                               sizeof(LanmanSessionKey) );
            }

        } else {

            if ( !Credential->NtPasswordPresent ) {

                RtlCopyMemory( &Credential->NtOwfPassword,
                            &NlpNullNtOwfPassword,
                            sizeof(Credential->NtOwfPassword) );
            }
        }
    }

    //
    // Allocate a buffer to return to the caller.
    //

    *ReturnBufferSize = sizeof(MSV1_0_GETCHALLENRESP_RESPONSE) +
                        Credential->LogonDomainName.Length + sizeof(WCHAR) +
                        Credential->UserName.Length + sizeof(WCHAR) +
                        NtResponseString.Length + sizeof(WCHAR) +
                        LmResponseString.Length + sizeof(WCHAR);

    ClientBuffer = ExAllocatePool(NonPagedPool, *ReturnBufferSize);
    if (ClientBuffer == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    GetRespResponse = (PMSV1_0_GETCHALLENRESP_RESPONSE) ClientBuffer;

    //
    // Fill in the return buffer.
    //

    GetRespResponse->MessageType = MsV1_0Lm20GetChallengeResponse;
    RtlCopyMemory( GetRespResponse->UserSessionKey,
                   &UserSessionKey,
                   sizeof(UserSessionKey));
    RtlCopyMemory( GetRespResponse->LanmanSessionKey,
                   LanmanSessionKey,
                   sizeof(LanmanSessionKey) );

    ClientStrings = ((PUCHAR)ClientBuffer) + sizeof(MSV1_0_GETCHALLENRESP_RESPONSE);


    //
    // Copy the logon domain name (the string may be empty)
    //

    NlpPutString(
        &GetRespResponse->LogonDomainName,
        &Credential->LogonDomainName,
        &ClientStrings );

    //
    // Copy the user name (the string may be empty)
    //

    NlpPutString(
        &GetRespResponse->UserName,
        &Credential->UserName,
        &ClientStrings );

    //
    // Copy the Challenge Responses to the client buffer.
    //

    NlpPutString(
        (PUNICODE_STRING)
            &GetRespResponse->CaseSensitiveChallengeResponse,
        (PUNICODE_STRING) &NtResponseString,
        &ClientStrings );

    NlpPutString(
        (PUNICODE_STRING)
            &GetRespResponse->CaseInsensitiveChallengeResponse,
        (PUNICODE_STRING)&LmResponseString,
        &ClientStrings );

    *ProtocolReturnBuffer = ClientBuffer;

Cleanup:

    //
    // If we weren't successful, free the buffer in the clients address space.
    //

    if ( !NT_SUCCESS(Status) && ( ClientBuffer != NULL ) ) {
        ExFreePool(ClientBuffer);
    }

    //
    // Cleanup locally used resources
    //

    if ( BuiltCredential != NULL ) {
        RtlZeroMemory(BuiltCredential, CredentialSize);
        ExFreePool(BuiltCredential);
    }

    //
    // Return status to the caller.
    //

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\connmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        connmgr.h
//
// Contents:    Connection Manager code for KSecDD
//
//
// History:     3 Jun 92    RichardW    Created
//              15 Dec 97   AdamBa      Modified from private\lsa\client\ssp
//
//------------------------------------------------------------------------

#ifndef __CONNMGR_H__
#define __CONNMGR_H__


typedef struct _KernelContext {
    struct _KernelContext * pNext;      // Link to next context
    struct _KernelContext * pPrev;      // Link to previous context
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
    HANDLE TokenHandle;
    PACCESS_TOKEN AccessToken;
} KernelContext, *PKernelContext;


void            AddKernelContext(PKernelContext *, PKSPIN_LOCK, PKernelContext);
SECURITY_STATUS DeleteKernelContext(PKernelContext *, PKSPIN_LOCK, PKernelContext);

#endif // __CONNMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\csc.nt5\transitn.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    transitn.c

Abstract:

    This module implements the routines for transitioning from the connected mode
    and vice versa

Author:

    Balan Sethu Raman [SethuR]    11 - November - 1997

Revision History:

Notes:

    The transition of a connection from a connected mode to a disconnected mode
    and vice versa is guided by the principles of transparency and fideltiy.

    The principle of transparency demands that the transition be made smoothly
    on the detection of the appropriate condition without any user intervention
    if at all possible and the principle of fidelity relies upon the notion of
    truth and the responsibility for its maintenance. If we wish to adhere to the
    opinion that the client has the truth at all times and the server is merely
    a convenient repositiory for snapshots of the truth one set of semantics falls
    out. On the other hand we could insist that the server has the truth at all
    times and the client caches snapshots of the truth for offline availability
    and performance gains from avoiding network traffic a different set of
    semantics falls out. Note that under certain scenarios the both schemes yield
    identical results, i.e., absence of file sharing.

    Transitioning from connected mode to disconnected mode
    ------------------------------------------------------

    When transitioning from connected mode it is important to consider existing
    connections and the existing file system objects. In the mini redirector
    terminology it is the SRV_CALL, NET_ROOT instances and the FCB instances that
    are important.

    The trigger for the transition is normally due to the occurence of one of the
    following two events.

    1) all the existing transports are going away, because the user has unplugged
    the net.

    2) an ongoing operation on the connection returns an error that indicates that
    the server is no longer accessible.

    These two cases are different -- the first one indicates the unavailability
    of net for a potentially long period of time and the second one indicates a
    transient loss of the net. Consequently we treat these two different events
    in different ways -- the first one triggers a top down transition to a
    disconnected mode while the second one triggers a bottom up transition to a
    disconnected mode. As an example consider the case when we have two files
    foo.doc, foo1.doc open on a particular share. When we get an indication that
    the net is no longer available, we mark the SRV_CALL and NET_ROOT instances
    as having transitioned to the disconnected mode. This automatically entails
    that as file system operations are performed on the various open files, foo.doc
    foo1.doc respectively the corresponding transition occurs.

    On the other hand if there was an error in a particular operation of foo.doc
    then the transition to disconected mode is done for the appropriate FCB alone.
    Thus if we open a new file immediately after that and the net becomes
    available we go on the net for opening the second file.

    However, owing to the multi step renames that apps use we forego this option.
    Thus the following distinction needs to be made. When no FCB instances are
    open and an error occurs we delay the transition till a open request comes
    through. This will allow us to mask some transient failures on the NET.

--*/


#include "precomp.h"
#pragma hdrstop
#include "acd.h"
#include "acdapi.h"
#include "ntddmup.h"

#pragma code_seg("PAGE")

#define Dbg (DEBUG_TRACE_MRXSMBCSC_TRANSITN)
RXDT_DefineCategory(MRXSMBCSC_TRANSITN);

#define CSC_AUTODIAL_POLL_COUNT  10
#define INVALID_SESSION_ID 0xffffffff

BOOLEAN
CscIsSpecialShare(
    PUNICODE_STRING ShareName);

#define UNICODE_STRING_STRUCT(s) \
        {sizeof(s) - sizeof(WCHAR), sizeof(s) - sizeof(WCHAR), (s)}

static UNICODE_STRING CscSpecialShares[] = {
    UNICODE_STRING_STRUCT(L"PIPE"),
    UNICODE_STRING_STRUCT(L"IPC$"),
    UNICODE_STRING_STRUCT(L"ADMIN$"),
    UNICODE_STRING_STRUCT(L"MAILSLOT")
};

KEVENT       CscServerEntryTransitioningEvent;
FAST_MUTEX   CscServerEntryTransitioningMutex;

PSMBCEDB_SERVER_ENTRY   CscServerEntryBeingTransitioned  = NULL;
ULONG                   CscSessionIdCausingTransition = 0;
HSHARE                  CscShareHandlePassedToAgent;
BOOLEAN                 vfRetryFromUI = FALSE;
PSMBCEDB_SERVER_ENTRY   CscDfsRootServerEntryBeingTransitioned  = NULL;

BOOLEAN CscDisableOfflineOperation = FALSE;
ULONG   hTransitionMutexOwner=0;

BOOLEAN CSCCheckForAcd(VOID);

BOOLEAN CscTransitnOKToGoOffline(
    NTSTATUS    RemoteStatus
    );

BOOLEAN
CscIsServerOffline(
    PWCHAR ServerName)
/*++

Routine Description:

   This routine initiates the processing of a transition request by notifying
   the agent and waiting for the response.

Arguments:

    ServerName - the server name


Return Value:

    returns TRUE if the server entry is offline

Notes:

    If ServerName is NULL we return the status of the Net

--*/
{
    BOOLEAN ServerOffline;
    DWORD   cntSlashes;
    UNICODE_STRING uniTemp;

    ServerOffline = (CscNetPresent == 0);

    if (ServerName != NULL) {
        PSMBCEDB_SERVER_ENTRY pServerEntry;
        USHORT                ServerNameLengthInBytes;
        PWCHAR                pTempName;
        UNICODE_STRING        ServerNameString;

        ServerOffline = FALSE;

        pTempName = ServerName;
        ServerNameLengthInBytes = 0;
        cntSlashes = 0;

        if (*pTempName == L'\\')
        {
            ++pTempName;
            ++cntSlashes;
        }

        if (*pTempName == L'\\')
        {
            ++pTempName;
            ++cntSlashes;
        }

        // we allow \\servername or servername (with no \\)
        if (cntSlashes == 1)
        {
            return FALSE;
        }

        while (*pTempName++ != L'\0') {
            ServerNameLengthInBytes += sizeof(WCHAR);
        }

        ServerNameString.MaximumLength = ServerNameString.Length = ServerNameLengthInBytes;
        ServerNameString.Buffer        = ServerName+cntSlashes;

        SmbCeAcquireResource();

        try
        {
            pServerEntry = SmbCeGetFirstServerEntry();
            while (pServerEntry != NULL) {

                uniTemp = pServerEntry->Name;

                // skip the single backslash on the server entry name
                uniTemp.Length -= sizeof(WCHAR);
                uniTemp.Buffer += 1;

                if (uniTemp.Length == ServerNameLengthInBytes) {
                    if (RtlCompareUnicodeString(
                            &uniTemp,
                            &ServerNameString,
                            TRUE) == 0) {

                        ServerOffline = SmbCeIsServerInDisconnectedMode(pServerEntry);

                        break;
                    }
                }

                pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            SmbCeReleaseResource();
            return FALSE;
        }

        SmbCeReleaseResource();

        if (!pServerEntry && !CscNetPresent)
        {
            HSHARE  CscShareHandle = 0;
            ULONG    ulRootHintFlags=0;

            GetHShareFromUNCString(
                ServerNameString.Buffer,
                ServerNameString.Length,
                2,      // No double-leading backslashes in the name passed in
                FALSE,  // server name
                &CscShareHandle,
                &ulRootHintFlags);
            ServerOffline = (CscShareHandle != 0);
        }
    }

    return ServerOffline;
}


NTSTATUS
CscTakeServerOffline(
    PWCHAR ServerName)
{
    PSMBCEDB_SERVER_ENTRY pServerEntry;
    UNICODE_STRING ServerNameString;
    UNICODE_STRING tmpSrvName;
    NTSTATUS Status = STATUS_OBJECT_NAME_NOT_FOUND;

    // DbgPrint("CscTakeServerOffline(%ws)\n", ServerName);

    if (ServerName == NULL) {
        Status = ERROR_INVALID_PARAMETER;
        goto AllDone;
    }
    // Clip leading backslashes
    while (*ServerName == L'\\') {
        ServerName++;
    }
    RtlInitUnicodeString(&ServerNameString, ServerName);
    // Scan list of server entries looking for this one
    SmbCeAcquireResource();
    try {
        pServerEntry = SmbCeGetFirstServerEntry();
        while (pServerEntry != NULL) {
            if (pServerEntry->Server.CscState == ServerCscShadowing) {
                if (pServerEntry->DfsRootName.Length > 0) {
                    tmpSrvName = pServerEntry->DfsRootName;
                    tmpSrvName.Length -= sizeof(WCHAR);
                    tmpSrvName.Buffer += 1;
                    if (RtlCompareUnicodeString(&tmpSrvName, &ServerNameString, TRUE) == 0)
                        break;
                } else {
                    tmpSrvName = pServerEntry->Name;
                    tmpSrvName.Length -= sizeof(WCHAR);
                    tmpSrvName.Buffer += 1;
                    if (RtlCompareUnicodeString(&tmpSrvName, &ServerNameString, TRUE) == 0)
                        break;
                }
            }
            pServerEntry = SmbCeGetNextServerEntry(pServerEntry);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SmbCeReleaseResource();
        Status = ERROR_INVALID_PARAMETER;
    }
    if (pServerEntry != NULL) {
        // DbgPrint("Found ServerEntry@0x%x\n", pServerEntry);
        SmbCeReferenceServerEntry(pServerEntry);
        SmbCeReleaseResource();
        Status = CscTransitionServerEntryForDisconnectedOperation(
            pServerEntry,
            NULL,
            STATUS_BAD_NETWORK_NAME,
            FALSE);
        // Mark it so it will not auto-reconnect
        if (Status == STATUS_SUCCESS)
            pServerEntry->Server.IsPinnedOffline = TRUE;
        SmbCeDereferenceServerEntry(pServerEntry);
    } else {
        SmbCeReleaseResource();
    }

AllDone:
    return Status;
}

BOOLEAN
CscCheckWithAgentForTransitioningServerEntry(
    PSMBCEDB_SERVER_ENTRY   pServerEntry,
    ULONG                   SessionId,
    HSHARE                  AgentShareHandle,
    BOOLEAN                 fInvokeAutoDial,
    BOOLEAN                 *lpfRetryFromUI,
    PSMBCEDB_SERVER_ENTRY   *pDfsRootServerEntry
    )
/*++

Routine Description:

   This routine initiates the processing of a transition request by notifying
   the agent and waiting for the response.

Arguments:

    pServerEntry  - the server entry

    pNetRootEntry - the net root entry instance

Return Value:

    returns TRUE if the server entry was transitioned for offlien operation

--*/
{
    LONG    cntTransportsForCSC=0;
    BOOLEAN TransitionedServerEntry, OkToTransition = FALSE;
    PSMBCEDB_SERVER_ENTRY   pTempServerEntry = NULL;

    if(!MRxSmbIsCscEnabled) {
        return(FALSE);
    }

//    DbgPrint("CscCheckWithAgent %wZ \n", &pServerEntry->Name);

    ExAcquireFastMutex(&CscServerEntryTransitioningMutex);

    hTransitionMutexOwner = GetCurThreadHandle();
    if (pServerEntry->DfsRootName.Length != 0)
    {
        PSMBCEDB_SERVER_ENTRY pThisServerEntry;
        PSMBCEDB_SERVER_ENTRY pNextServerEntry;

        SmbCeAcquireResource();

        pThisServerEntry = SmbCeGetFirstServerEntry();

        while (pThisServerEntry != NULL) {
            pNextServerEntry = SmbCeGetNextServerEntry(pThisServerEntry);

            if (RtlEqualUnicodeString(&pServerEntry->DfsRootName,
                                          &pThisServerEntry->Name,
                                          TRUE)) {

//                DbgPrint("CscCheckWithAgent DfsRoot %wZ \n", &pThisServerEntry->Name);
                pTempServerEntry = pThisServerEntry;

                break;
            }

            pThisServerEntry = pNextServerEntry;
        }
        SmbCeReleaseResource();
    }


    CscServerEntryBeingTransitioned  = pServerEntry;
    CscDfsRootServerEntryBeingTransitioned = pTempServerEntry;
    CscShareHandlePassedToAgent     = AgentShareHandle;
    vfRetryFromUI = FALSE;

    KeResetEvent(&CscServerEntryTransitioningEvent);

    OkToTransition = (!SmbCeIsServerInDisconnectedMode(pServerEntry)||
                      (pTempServerEntry && !SmbCeIsServerInDisconnectedMode(pTempServerEntry)));

    if (OkToTransition) {

        // This is dropped in MRxSmbCscSignalAgent
        EnterShadowCrit();

        SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_SHARE_DISCONNECTED);
        if (fInvokeAutoDial)
        {
            SetFlag(sGS.uFlagsEvents,FLAG_GLOBALSTATUS_INVOKE_AUTODIAL);
        }
        sGS.hShareDisconnected = AgentShareHandle;

        CscSessionIdCausingTransition = SessionId;

        MRxSmbCscSignalAgent(
            NULL,
            SIGNALAGENTFLAG_CONTINUE_FOR_NO_AGENT);

        KeWaitForSingleObject(
            &CscServerEntryTransitioningEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL);
    }

    TransitionedServerEntry = (SmbCeIsServerInDisconnectedMode(pServerEntry) &&
                               (!pTempServerEntry || SmbCeIsServerInDisconnectedMode(pTempServerEntry)));

    *pDfsRootServerEntry = pTempServerEntry;

    CscServerEntryBeingTransitioned  = NULL;
    CscShareHandlePassedToAgent     = 0;
    CscDfsRootServerEntryBeingTransitioned = NULL;
    CscSessionIdCausingTransition = 0;
    *lpfRetryFromUI = vfRetryFromUI;
    hTransitionMutexOwner = 0;
    ExReleaseFastMutex(&CscServerEntryTransitioningMutex);

    return TransitionedServerEntry;
}

NTSTATUS
CscTransitionServerToOffline(
    ULONG SessionId,
    HSHARE hShare,
    ULONG   TransitionStatus)
/*++

Routine Description:

   This routine updates the RDR data structures based upon the decision of the
   agent

Arguments:

    hShare - the shadow handle to the server

    TransitionStatus -- it is tri state value.
        0 implies retry the operation.
        1 transition this server for offline operation
        anything else means fail

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    LONG CscState = ServerCscShadowing;

    if(!MRxSmbIsCscEnabled) {
        return(STATUS_UNSUCCESSFUL);
    }

    // DbgPrint("CscTransitionServerToOffline: Share 0x%x SessionId 0x%x (vs 0x%x)\n",
    //                 hShare,
    //                 SessionId,
    //                 CscSessionIdCausingTransition);

    switch (TransitionStatus) {
    case 1 :
        if (fShadow &&  // only if CSC is turned ON by the agent do we go disconnected
            CscServerEntryBeingTransitioned &&  // there is a server entry (this must be true
            CscSessionIdCausingTransition == SessionId &&  // The right session
            CscShareHandlePassedToAgent    // and we have a share in the database
            )
        {
            // then it is OK to go disconnected
            CscState = ServerCscDisconnected;
        }
        break;


    case 0 :  // UI said retry
        vfRetryFromUI = TRUE;
        break;

    default:
        break;
    }


    if (CscServerEntryBeingTransitioned != NULL && SessionId == CscSessionIdCausingTransition) {
//        DbgPrint("CscTransitionServerToOffline %wZ \n", &CscServerEntryBeingTransitioned->Name);
        InterlockedExchange(
                &CscServerEntryBeingTransitioned->Server.CscState,
                CscState);

        // DbgPrint("CscTransitionServerToOffline %wZ Sess 0x%x\n",
        //         &CscServerEntryBeingTransitioned->Name,
        //         SessionId);

        if (CscDfsRootServerEntryBeingTransitioned)
        {
            // if this is an alternate, then also put the
            // dfs root in disconnected state if it isn't already

            if (!SmbCeIsServerInDisconnectedMode(CscDfsRootServerEntryBeingTransitioned))
            {
                SmbCeReferenceServerEntry(CscDfsRootServerEntryBeingTransitioned);
            }

            InterlockedExchange(
                    &CscDfsRootServerEntryBeingTransitioned->Server.CscState,
                    CscState);

        }

        // Signal the event on which the other requests in the RDR are waiting
        KeSetEvent(
            &CscServerEntryTransitioningEvent,
            0,
            FALSE );
    } else {
//        ASSERT(!"No server entry is transitioning to offline");
    }


    return STATUS_SUCCESS;
}

VOID
CscPrepareServerEntryForOnlineOperation(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    BOOL    fGoAllTheWay
    )
/*++

Routine Description:

   This routine transitions a given server entry for online operation

Arguments:

    pServerEntry - the server entry that needs to be transitioned
    NTSTATUS - The return status for the operation

--*/
{
    PSMBCEDB_SESSION_ENTRY      pSessionEntry;
    PSMBCEDB_NET_ROOT_ENTRY     pNetRootEntry;
    PSMBCE_V_NET_ROOT_CONTEXT   pVNetRootContext;

    LONG CscState;

    SmbCeLog(("Transition SE %lx fGoAllTheWay=%d\n",pServerEntry, fGoAllTheWay));
    SmbLog(LOG,
           CscPrepareServerEntryForOnlineOperation_1,
           LOGULONG(fGoAllTheWay)
           LOGPTR(pServerEntry)
           LOGUSTR(pServerEntry->Name));

    if (fGoAllTheWay)
    {
        CscState = InterlockedCompareExchange(
                       &pServerEntry->Server.CscState,
                       ServerCscTransitioningToShadowing,
                       ServerCscDisconnected);
        if(pServerEntry->Server.IsFakeDfsServerForOfflineUse == TRUE)
        {
            HookKdPrint(TRANSITION, ("CscPrepareServerEntryForOnlineOperation: %x is a FAKE DFS entry, mark it for destruction \n", pServerEntry));
            pServerEntry->Header.State =  SMBCEDB_DESTRUCTION_IN_PROGRESS;
        }

        SmbCeLog(("Transition SE %lx %wZ fGoAllTheWay CscState=%x\n",pServerEntry, &pServerEntry->Name, CscState));
        SmbLog(LOG,
               CscPrepareServerEntryForOnlineOperation_2,
               LOGULONG(CscState)
               LOGPTR(pServerEntry)
               LOGUSTR(pServerEntry->Name));
    }

    if (!fGoAllTheWay || (CscState == ServerCscDisconnected)) {
        SmbCeLog(("Transition SE CO %lx, fGoAllTheWay=%d\n",pServerEntry, fGoAllTheWay));
        SmbLog(LOG,
               CscPrepareServerEntryForOnlineOperation_3,
               LOGULONG(fGoAllTheWay)
               LOGPTR(pServerEntry)
               LOGUSTR(pServerEntry->Name));

        InterlockedCompareExchange(
            &pServerEntry->Header.State,
            SMBCEDB_DESTRUCTION_IN_PROGRESS,
            SMBCEDB_ACTIVE);

        SmbCeReferenceServerEntry(pServerEntry);
        SmbCeResumeAllOutstandingRequestsOnError(pServerEntry);
        pServerEntry->ServerStatus = STATUS_CONNECTION_DISCONNECTED;

        if (fGoAllTheWay)
        {
            MRxSmbCSCResumeAllOutstandingOperations(pServerEntry);
            pServerEntry->Server.CscState = ServerCscShadowing;
            pServerEntry->Server.IsPinnedOffline = FALSE;
            SmbCeDereferenceServerEntry(pServerEntry);
        }
    }
}

VOID
CscPrepareServerEntryForOnlineOperationFull(
    PSMBCEDB_SERVER_ENTRY pServerEntry
    )
/*++

Routine Description:

   This routine transitions a given server entry for online operation

Arguments:

    pServerEntry - the server entry that needs to be transitioned
    NTSTATUS - The return status for the operation

--*/
{
    CscPrepareServerEntryForOnlineOperation(pServerEntry, TRUE);
}

VOID
CscPrepareServerEntryForOnlineOperationPartial(
    PSMBCEDB_SERVER_ENTRY pServerEntry
    )
/*++

Routine Description:

   This routine transitions a given server entry for online operation

Arguments:

    pServerEntry - the server entry that needs to be transitioned
    NTSTATUS - The return status for the operation

--*/
{
    CscPrepareServerEntryForOnlineOperation(pServerEntry, FALSE);
}

NTSTATUS
CscTransitionServerToOnline(
    HSHARE hShare)
/*++

Routine Description:

   This routine updates the RDR data structures based upon the decision of the
   agent

Arguments:

    hShare - the shadow handle to the server

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    PSMBCEDB_SERVER_ENTRY   pServerEntry;
    SHAREINFOW sSR;
    NTSTATUS    Status=STATUS_INVALID_PARAMETER;

    if (hShare == 0) {

        Status=STATUS_SUCCESS;

        SmbCeLog(("Transtioning all servers online \n"));
        SmbLog(LOG,
               CscTransitionServerToOnline_1,
               LOGULONG(hShare));
        SmbCeAcquireResource();
        pServerEntry = SmbCeGetFirstServerEntry();
        while (pServerEntry != NULL) {
            PSMBCEDB_SERVER_ENTRY pNextServerEntry;

            pNextServerEntry = SmbCeGetNextServerEntry(pServerEntry);
            CscPrepareServerEntryForOnlineOperationFull(pServerEntry);
            pServerEntry = pNextServerEntry;
        }
        SmbCeReleaseResource();

    } else {
        int iRet;

        EnterShadowCrit();
        iRet = GetShareInfo(hShare, &sSR, NULL);
        LeaveShadowCrit();
        SmbCeLog(("Transtioning %ls online \n", sSR.rgSharePath));
        SmbLog(LOG,
               CscTransitionServerToOnline_2,
               LOGWSTR(sSR.rgSharePath));

        if (iRet >= 0)
        {
            Status = STATUS_SUCCESS;
            if ((FindServerEntryFromCompleteUNCPath(sSR.rgSharePath, &pServerEntry)) == STATUS_SUCCESS)
            {
                PSMBCEDB_SERVER_ENTRY pThisServerEntry;
                PSMBCEDB_SERVER_ENTRY pNextServerEntry;

//                DbgPrint("Close all open files on %wZ\n", &pServerEntry->Name);
                CloseOpenFiles(hShare, &pServerEntry->Name, 1); // skip one slash
                SmbCeAcquireResource();

                pThisServerEntry = SmbCeGetFirstServerEntry();
                while (pThisServerEntry != NULL) {
                    pNextServerEntry = SmbCeGetNextServerEntry(pThisServerEntry);

                    if (pThisServerEntry != pServerEntry &&
                        pThisServerEntry->DfsRootName.Length != 0) {
                        if (RtlEqualUnicodeString(&pThisServerEntry->DfsRootName,
                                                  &pServerEntry->Name,
                                                  TRUE)) {
                            SmbCeLog(("Go online ServerEntry With DFS name %x\n",pThisServerEntry));
                            SmbLog(LOG,
                                   CscTransitionServerToOnline_3,
                                   LOGPTR(pThisServerEntry)
                                   LOGUSTR(pThisServerEntry->Name));

                            CscPrepareServerEntryForOnlineOperationFull(pThisServerEntry);
                        }
                    }

                    pThisServerEntry = pNextServerEntry;
                }

                CscPrepareServerEntryForOnlineOperationFull(pServerEntry);
                SmbCeDereferenceServerEntry(pServerEntry);

                SmbCeReleaseResource();
            }
        }
    }

    return Status;
}

NTSTATUS
CscpTransitionServerEntryForDisconnectedOperation(
    RX_CONTEXT                  *RxContext,
    PSMBCEDB_SERVER_ENTRY       pServerEntry,
    PSMBCEDB_NET_ROOT_ENTRY     pNetRootEntry,
    NTSTATUS                    RemoteStatus,
    BOOLEAN                     fInvokeAutoDial,
    ULONG                       uFlags
    )
/*++

Routine Description:

   This routine transitions the server entry for disconnected mode of
   operation

Arguments:

    pServerEntry -- the server entry instance to be transitioned

    pNetRootEntry -- the net root entry instance

    RemoteStatus -- the failed status of the remote operation

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    If this routine returns STATUS_RETRY it implies that the associated server
    entry has been successfully trnaisitioned for disconnected operation.

--*/
{
    NTSTATUS Status;
    BOOLEAN  TransitionServerEntryToDisconnectedMode, fRetryFromUI=FALSE;
    ULONG    ulRootHintFlags=0;
    LONG     CscState, cntTransports=0;
    ULONG    SessionId = INVALID_SESSION_ID;

    SmbCeLog(("CscTrPSrv IN DFSFlgs %x\n",uFlags));
    SmbLog(LOG,
           CscpTransitionServerEntryForDisconnectedOperation_1,
           LOGULONG(uFlags));

    if(!MRxSmbIsCscEnabled ||
       !CscTransitnOKToGoOffline(RemoteStatus) ||
       !(uFlags & DFS_FLAG_LAST_ALTERNATE) ||
       pServerEntry->Server.IsLoopBack) {

        SmbCeLog(("CscTrPSrv Out RemoteStatus=%x\n",RemoteStatus));
        SmbLog(LOG,
               CscpTransitionServerEntryForDisconnectedOperation_2,
               LOGULONG(RemoteStatus));
        return(RemoteStatus);
    }

    // if we are supposed to invoke autodial, check if autodial service is running
    // this will ensure that we don't go up in usermode when we shouldn't.

    if (fInvokeAutoDial) {
        fInvokeAutoDial = CSCCheckForAcd();
    }

    SmbCeLog(("CscTrPSrv Autodial %x\n",fInvokeAutoDial));
    SmbLog(LOG,
           CscpTransitionServerEntryForDisconnectedOperation_3,
           LOGUCHAR(fInvokeAutoDial));

    if (!fInvokeAutoDial) {
        // Notify the CSC agent of any transport changes if required
        CscNotifyAgentOfNetStatusChangeIfRequired(FALSE);
    }

    // Ensure that we are never called to prepare for a transition if the remote
    // operation was successful.
    ASSERT(RemoteStatus != STATUS_SUCCESS);

    // The transition to disconnected operation is a three step process...
    // If the remote status is not one of the list of statuses that can signal
    // a transition to disconnected operation relect the remote status back.

    Status = RemoteStatus;

    if (CscDisableOfflineOperation) {
        return Status;
    }

    CscState = InterlockedCompareExchange(
                   &pServerEntry->Server.CscState,
                   ServerCscTransitioningToDisconnected,
                   ServerCscShadowing);

    if (CscState == ServerCscShadowing) {
        HSHARE  CscShareHandle = 0;

        if (pNetRootEntry != NULL) {
            CscShareHandle = pNetRootEntry->NetRoot.sCscRootInfo.hShare;
        }

/***********************************************************************************************

        ACHTUNG !!! do not hold the shadow critical section here
        This may cause a deadlock, as a paging read could come down this way because
        a server has gone down. The guy doing the paging read may be holding the
        VCB and the FCB locks on FAT. Some other thread might own the shadowcritsect
        and may be trying to open a file. This would cause it to try to acquire the
        VCB and hence block. Thus we have classic deadlock situation.

        This happens only on FAT.

        The only consequence of not holding the critsect here is that we
        may get a false warning for a share that used to be in the database but has gotten
        deleted. It would be very difficult to hit that timing window so the
        chances of this happening are slim to none.

        There is another aspect to this solution, which is to make sure that handle for
        the shares inode is always kept open, so FAT will never have to hold the VCB


***********************************************************************************************/

        // do any CSC operations only if it is indeed enabled
        if (fShadow )
        {
            if (CscShareHandle == 0) {
                PDFS_NAME_CONTEXT pDfsNameContext = NULL;
                UNICODE_STRING uUncName = {0, 0, NULL};
                UNICODE_STRING uShareName = {0, 0, NULL};
                BOOL fIsShareName = FALSE;
                PIO_STACK_LOCATION IrpSp = NULL;
                PQUERY_PATH_REQUEST QpReq;
                ULONG cntSlashes = 0;
                ULONG i;

                if (RxContext != NULL && RxContext->CurrentIrpSp != NULL) {
                    IrpSp = RxContext->CurrentIrpSp;
                    //
                    // If this is a create AND a dfs path, use the dfs path passed in
                    //
                    if (IrpSp->MajorFunction == IRP_MJ_CREATE) {
                        pDfsNameContext = CscIsValidDfsNameContext(
                                             RxContext->Create.NtCreateParameters.DfsNameContext);
                        if (pDfsNameContext != NULL) {
                            // DbgPrint("DfsNameContext UNCFileName=[%wZ]\n",
                            //         &pDfsNameContext->UNCFileName);
                            uUncName = pDfsNameContext->UNCFileName;
                            fIsShareName = TRUE;
                        }
                    //
                    // If this is a query ioctl, use the path we're querying
                    //
                    } else if (IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL
                            &&
                        IrpSp->MinorFunction == 0
                            &&
                        IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_REDIR_QUERY_PATH
                    ) {
                        QpReq =
                            (PQUERY_PATH_REQUEST)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                        uUncName.Buffer = QpReq->FilePathName;
                        uUncName.Length = (USHORT) QpReq->PathNameLength;
                        uUncName.MaximumLength = uUncName.Length;
                        fIsShareName = TRUE;
                    }
                }
                //
                // Not a dfs create nor a query path - use the redir's netrootentry,
                // if we have one
                //
                if (uUncName.Buffer == NULL && pNetRootEntry && pNetRootEntry->Name.Length) {
                    uUncName = pNetRootEntry->Name;
                    fIsShareName = TRUE;
                }
                //
                // Bottom out using the server entry, either the dfsrootname
                // or the serverentry name.  This will take the server offline
                // w/o regard to which share the error was in reference to.
                //
                if (uUncName.Buffer == NULL) {
                    if (pServerEntry->DfsRootName.Buffer) {
                        uUncName = pServerEntry->DfsRootName;
                    } else {
                        uUncName = pServerEntry->Name;
                    }
                }
                //
                // Be sure all we have is \server\share, or \server,
                //
                for (cntSlashes = i = 0; i < uUncName.Length/sizeof(WCHAR); i++) {
                    if (uUncName.Buffer[i] == L'\\')
                        cntSlashes++;
                    if (cntSlashes >= 3) {
                        uUncName.Length = (USHORT) (sizeof(WCHAR) * i);
                        break;
                    }
                }
                //
                // If this is a special share (like IPC$), treat it as a valid
                // share to go offline against.  (IE, we go offline against
                // \server\IPC$)
                if (fIsShareName == TRUE) {
                    uShareName = uUncName;
                    for (cntSlashes = i = 0; i < uUncName.Length/sizeof(WCHAR); i++) {
                        uShareName.Buffer++;
                        uShareName.Length -= sizeof(WCHAR);
                        if (uUncName.Buffer[i] == L'\\')
                            cntSlashes++;
                        if (cntSlashes == 2)
                            break;
                    }
                    if (CscIsSpecialShare(&uShareName) == TRUE) {
                        fIsShareName = FALSE;
                        // revert to just \servername
                        uUncName.Length -= uShareName.Length + sizeof(WCHAR);
                    }
                }
                GetHShareFromUNCString(
                    uUncName.Buffer,
                    uUncName.Length,
                    1,
                    fIsShareName,
                    &CscShareHandle,
                    &ulRootHintFlags);

                ulRootHintFlags &= ~FLAG_CSC_HINT_PIN_SYSTEM;

                // DbgPrint("CscpTransitionServerEntry: [%wZ] CSCHandle=%x\n",
                //            &uUncName,
                //            CscShareHandle);
                RxDbgTrace(0, Dbg, ("CscpTransitionServerEntry: [%wZ] CSCHandle=%x\n",
                          &uUncName,
                          CscShareHandle));
            } else {
                ulRootHintFlags = 0;
            }
        } // if (fShadow)
        else
        {
            CscShareHandle = 0; // if the agent hasn't turned on CSC
                                 // then don't tell him for CSC shares
        }


        if (fInvokeAutoDial || // either autodial
            (CscShareHandle != 0)) {   // or CSC

            if (MRxSmbCscTransitionEnabledByDefault) {

                RxDbgTrace(0, Dbg, ("CscTransitionServerEntryForDisconnectedOperation: silently going offline on %wZ\r\n", CscShareHandle, ulRootHintFlags));

                InterlockedExchange(
                    &pServerEntry->Server.CscState,
                    ServerCscDisconnected);

                SmbCeReferenceServerEntry(pServerEntry);
                Status = STATUS_SUCCESS;
                RxDbgTrace(0, Dbg, ("Transitioning Server Entry for DC %lx Status %lx\n",pServerEntry,Status));
                SmbCeLog(("Transitioning Server Entry for DC %lx Status %lx\n",pServerEntry,Status));
                SmbLog(LOG,
                       CscpTransitionServerEntryForDisconnectedOperation_4,
                       LOGULONG(Status)
                       LOGPTR(pServerEntry)
                       LOGUSTR(pServerEntry->Name));

            } else {
                PSMBCEDB_SERVER_ENTRY       pDfsRootServerEntry = NULL;
                PIO_STACK_LOCATION IrpSp = NULL;

                if (RxContext != NULL && RxContext->CurrentIrpSp != NULL)
                    IrpSp = RxContext->CurrentIrpSp;

                // If the remote status was such that a transition to disconnected operation
                // should be triggerred we need to signal the agent to trigger the appropriate
                // mechanism for involving the client in this decision and decide based on the
                // result.

                cntTransports = vcntTransportsForCSC;

                SmbCeLog(("CscTrPSrv ChkAgnt %x\n",CscShareHandle));
                SmbLog(LOG,
                       CscpTransitionServerEntryForDisconnectedOperation_5,
                       LOGULONG(CscShareHandle));
                RxDbgTrace(0, Dbg, ("CscTransitionServerEntryForDisconnectedOperation: Checking with agent before going offline on CscShareHandle=%x HintFlags=%x\r\n", CscShareHandle, ulRootHintFlags));

                // if (RxContext != NULL && RxContext->CurrentIrpSp != NULL) {
                //     DbgPrint("** Transition: MJ/MN = 0x%x/0x%x\n",
                //             RxContext->CurrentIrpSp->MajorFunction,
                //             RxContext->CurrentIrpSp->MinorFunction);
                // }

                if (
                    RxContext
                        &&
                    RxContext->pRelevantSrvOpen
                        &&
                    RxContext->pRelevantSrvOpen->pVNetRoot
                ) {
                    SessionId = RxContext->pRelevantSrvOpen->pVNetRoot->SessionId;
                } else {
                    // DbgPrint("** pVnetRoot's sessionid not present\n");
                }

                if (
                    SessionId == INVALID_SESSION_ID
                        &&
                    IrpSp != NULL
                        &&
                    IrpSp->MajorFunction == IRP_MJ_CREATE
                ) {
                    PIO_SECURITY_CONTEXT pSecurityContext;
                    PACCESS_TOKEN        pAccessToken;

                    // DbgPrint("**CREATE\n");
                    pSecurityContext = RxContext->Create.NtCreateParameters.SecurityContext;
                    pAccessToken = SeQuerySubjectContextToken(
                                       &pSecurityContext->AccessState->SubjectSecurityContext);
                    if (!SeTokenIsRestricted(pAccessToken))
                        SeQuerySessionIdToken(pAccessToken, &SessionId);
                }

                if (
                    SessionId == INVALID_SESSION_ID
                        &&
                    IrpSp != NULL
                        &&
                    IrpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL
                        &&
                    IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_REDIR_QUERY_PATH
                ) {
                    PQUERY_PATH_REQUEST QpReq;
                    PSECURITY_SUBJECT_CONTEXT pSecurityContext;

                    // DbgPrint("**QUERY_PATH\n");
                    QpReq = (PQUERY_PATH_REQUEST)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                    pSecurityContext = &QpReq->SecurityContext->AccessState->SubjectSecurityContext;
                    if (pSecurityContext->ClientToken != NULL)
                        SeQuerySessionIdToken(pSecurityContext->ClientToken, &SessionId);
                    else
                        SeQuerySessionIdToken(pSecurityContext->PrimaryToken, &SessionId);
                }

                if (SessionId == INVALID_SESSION_ID) {
                    // DbgPrint("** Not CREATE or QUERY_PATH...\n");
                    if (RxContext != NULL && RxContext->CurrentIrp != NULL)
                        IoGetRequestorSessionId(RxContext->CurrentIrp, &SessionId);
                }

                if (SessionId == INVALID_SESSION_ID) {
                    // DbgPrint("All sessionid attempts failed, setting to 0..\n");
                    SessionId = 0;
                }

                // DbgPrint("** CscTrPSrv ChkAgnt SessionId: 0x%x\n", SessionId);

                if (CscCheckWithAgentForTransitioningServerEntry(
                        pServerEntry,
                        SessionId,
                        CscShareHandle,
                        fInvokeAutoDial,
                        &fRetryFromUI,
                        &pDfsRootServerEntry
                        )) {

                    SmbCeReferenceServerEntry(pServerEntry);

                    Status = STATUS_SUCCESS;
                    RxDbgTrace(0, Dbg, ("Transitioning Server Entry for DC %lx Status %lx\n",pServerEntry,Status));
                    SmbCeLog(("Transitioning Server Entry for DC %lx Status %lx\n",pServerEntry,Status));
                    SmbLog(LOG,
                           CscpTransitionServerEntryForDisconnectedOperation_4,
                           LOGULONG(Status)
                           LOGPTR(pServerEntry)
                           LOGUSTR(pServerEntry->Name));
                }
                else if (fRetryFromUI)
                {
                    LARGE_INTEGER interval;
                    int i;

                    SmbCeLog(("CscTrPSrv UIretry\n"));
                    SmbLog(LOG,
                           CscpTransitionServerEntryForDisconnectedOperation_6,
                           LOGUCHAR(fRetryFromUI));
                    RxDbgTrace(0, Dbg, ("UI sent us rerty, polling for %d seconds\n", CSC_AUTODIAL_POLL_COUNT));

                    for (i=0; i<CSC_AUTODIAL_POLL_COUNT; ++i)
                    {
                        if(cntTransports != vcntTransportsForCSC)
                        {
                            Status = STATUS_RETRY;
                            RxDbgTrace(0, Dbg, ("A new transport arrived \r\n"));
                            break;
                        }

                        interval.QuadPart = -1*10*1000*10*100; // 1 second

                        KeDelayExecutionThread( KernelMode, FALSE, &interval );
                    }


                    InterlockedExchange(
                        &pServerEntry->Server.CscState,
                        ServerCscShadowing);
                }
            }

        }
        else
        {
            InterlockedExchange(
                   &pServerEntry->Server.CscState,
                   ServerCscShadowing);

        }
    } else if (CscState == ServerCscDisconnected) {
        Status = STATUS_SUCCESS;
    }

    SmbCeLog(("CscTrPSrv Out St %x\n",Status));
    SmbLog(LOG,
           CscpTransitionServerEntryForDisconnectedOperation_7,
           LOGULONG(Status));

    return Status;
}

BOOLEAN
CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation(
    PRX_CONTEXT RxContext)
{
    BOOLEAN TransitionVNetRoot = FALSE;

    SmbCeLog(("CSCTrIsDfs IN %x\n", RxContext));
    SmbLog(LOG,
           CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_1,
           LOGPTR(RxContext));
    if ((RxContext != NULL) &&
        RxContext->CurrentIrpSp &&
        (RxContext->CurrentIrpSp->MajorFunction == IRP_MJ_CREATE)){

        NTSTATUS          Status;
        PDFS_NAME_CONTEXT pDfsNameContext;
        UNICODE_STRING    ShareName;

        pDfsNameContext = CscIsValidDfsNameContext(
                             RxContext->Create.NtCreateParameters.DfsNameContext);


        if (pDfsNameContext != NULL) {
            // Ensure that the server handles in the NET_ROOT instance
            // are initialized. This is because the DFS server munges
            // the names and the original DFS name needs to be presented
            // to the user for transitioning.

            SmbCeLog(("CSCTrIsDfs IsDsf %x\n", pDfsNameContext));
            SmbLog(LOG,
                   CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_2,
                   LOGPTR(pDfsNameContext)
                   LOGULONG(pDfsNameContext->NameContextType)
                   LOGULONG(pDfsNameContext->Flags)
                   LOGUSTR(pDfsNameContext->UNCFileName));

            Status = CscDfsParseDfsPath(
                         &pDfsNameContext->UNCFileName,
                         NULL,
                         &ShareName,
                         NULL);

            if (Status == STATUS_SUCCESS) {
                SHADOWINFO ShadowInfo;
                int        Result;

                SmbCeLog(("CSCTrDfs Parsed %wZ\n",&ShareName));
                SmbLog(LOG,
                       CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_3,
                       LOGUSTR(ShareName));

                EnterShadowCrit();

                TransitionVNetRoot = (FindCreateShareForNt(
                                         &ShareName,
                                         FALSE,     // do not create a new one
                                         &ShadowInfo,
                                         NULL) == SRET_OK);

                LeaveShadowCrit();
                if (!fShadow && TransitionVNetRoot)
                {
                    // DbgPrint("FindCreateServerForNt incorrectly returned TRUE for %wZ\n", &ShareName);
                    ASSERT(FALSE);
                }
                if (TransitionVNetRoot)
                {
                    SmbCeLog(("CSCTrDfs TrOffl \n"));
                    SmbLog(LOG,
                           CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_4,
                           LOGUCHAR(TransitionVNetRoot));

//                    DbgPrint("CSC:transitioning DFS share %wZ to offline hShare=%x shadowinfo=%x\n",&ShareName, ShadowInfo.hShare, &ShadowInfo);
                    ASSERT(ShadowInfo.hShare != 0);
                }
            }
        } else {
            TransitionVNetRoot = FALSE;
        }
    } else {
        TransitionVNetRoot = FALSE;
    }

    SmbCeLog(("CSCTrIsDfs Out %x\n", TransitionVNetRoot));
    SmbLog(LOG,
           CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation_5,
           LOGUCHAR(TransitionVNetRoot));

    return TransitionVNetRoot;
}

NTSTATUS
CscPrepareDfsServerEntryForDisconnectedOperation(
    PSMBCEDB_SERVER_ENTRY pCurrentServerEntry,
    PRX_CONTEXT           RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;

    PDFS_NAME_CONTEXT pDfsNameContext;

    PSMBCEDB_SERVER_ENTRY pServerEntry;
    BOOLEAN               fNewServerEntry;

    UNICODE_STRING    ServerName;

    if ((RxContext == NULL) ||
        (RxContext->CurrentIrp == NULL) ||
        (RxContext->CurrentIrpSp->MajorFunction != IRP_MJ_CREATE)) {
        return Status;
    }

    pDfsNameContext = CscIsValidDfsNameContext(
                         RxContext->Create.NtCreateParameters.DfsNameContext);

    if (pDfsNameContext == NULL) {
        return Status;
    }

    Status = CscDfsParseDfsPath(
                 &pDfsNameContext->UNCFileName,
                 &ServerName,
                 NULL,
                 NULL);

    if (Status != STATUS_SUCCESS) {
        return Status;
    }

    if (!fShadow)
    {
        ASSERT(FALSE);
    }
    // Ensure that a server entry in the disconnected
    // state is created

    SmbCeAcquireResource();

    pServerEntry = SmbCeFindServerEntry(
                       &ServerName,
                       SMBCEDB_FILE_SERVER,
                       NULL);

    if (pServerEntry == NULL) {
        Status = SmbCeFindOrConstructServerEntry(
                     &ServerName,
                     SMBCEDB_FILE_SERVER,
                     &pServerEntry,
                     &fNewServerEntry,
                     NULL);
        if (pServerEntry && fNewServerEntry)
        {
            pServerEntry->Server.IsFakeDfsServerForOfflineUse = TRUE;
            // DbgPrint(
            //   "CscPrepareDfsServerEntryForDisconnectedOperation: 0x%x [%wZ] is a FAKE DFS entry\n",
            //     pServerEntry,
            //     &ServerName);
        }
    } else {
        if (pServerEntry == pCurrentServerEntry) {
            // The find routine references the server entry.
            // If this happens to be the same as the current server
            // entry then the appropriate referencing for disconnected
            // operaton has already been done,
            SmbCeDereferenceServerEntry(pServerEntry);
        }
    }

    if (pServerEntry != NULL) {
//        DbgPrint("CscPrepareDfsServerEntry %wZ \n", &pServerEntry->Name);
        InterlockedExchange(
            &pServerEntry->Server.CscState,
            ServerCscDisconnected);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    SmbCeReleaseResource();

    if (Status == STATUS_SUCCESS) {
        Status = CscGrabPathFromDfs(
                     RxContext->CurrentIrpSp->FileObject,
                     pDfsNameContext);
    }

    return Status;
}


NTSTATUS
CscTransitionVNetRootForDisconnectedOperation(
    PRX_CONTEXT     RxContext,
    PMRX_V_NET_ROOT pVNetRoot,
    NTSTATUS        RemoteStatus)
/*++

Routine Description:

   This routine transitions the server entry for disconnected mode of
   operation

Arguments:

    pVNetRoot -- the net root instance

    RemoteStatus -- the failed status of the remote operation

Return Value:

    NTSTATUS - The return status for the operation

Notes:

    If this routine returns STATUS_RETRY it implies that the associated server
    entry has been successfully tranisitioned for disconnected operation.

--*/
{
    NTSTATUS Status,ReturnStatus;
    PMRX_FOBX capFobx = NULL;
    PSMBCE_V_NET_ROOT_CONTEXT pVNetRootContext = NULL;
    PSMBCEDB_NET_ROOT_ENTRY   pNetRootEntry;

    if(!MRxSmbIsCscEnabled || !fShadow) {
        return(RemoteStatus);
    }

    // Notify the CSC agent of any transport changes if required
    CscNotifyAgentOfNetStatusChangeIfRequired(FALSE);

    ReturnStatus = RemoteStatus;

    if (!CscTransitnOKToGoOffline(RemoteStatus)) {
        return RemoteStatus;
    }

    if (pVNetRoot != NULL) {
        pVNetRootContext = SmbCeGetAssociatedVNetRootContext(pVNetRoot);
    }

    SmbCeLog(("CSCTrVNR %x VNR\n", pVNetRootContext));
    SmbLog(LOG,
           CscTransitionVNetRootForDisconnectedOperation_1,
           LOGPTR(pVNetRootContext));

    if (pVNetRootContext == NULL ||
        pVNetRootContext->pServerEntry->Server.IsLoopBack) {
        return RemoteStatus;
    }

    if (RxContext != NULL) {
        capFobx = RxContext->pFobx;
    }

    pNetRootEntry = pVNetRootContext->pNetRootEntry;



    if (!FlagOn(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE) &&
        (pNetRootEntry != NULL) &&
        (pNetRootEntry->NetRoot.NetRootType == NET_ROOT_DISK ||
         pNetRootEntry->NetRoot.NetRootType == NET_ROOT_WILD)) {

        if (pNetRootEntry->NetRoot.CscFlags != SMB_CSC_NO_CACHING) {
            BOOLEAN           TransitionVNetRoot;
            UNICODE_STRING    ServerName;
            PDFS_NAME_CONTEXT pDfsNameContext = NULL;
            ULONG               uFlags = DFS_FLAG_LAST_ALTERNATE;

            TransitionVNetRoot = TRUE;

            if ((capFobx != NULL) &&
                (capFobx->pSrvOpen != NULL)) {
                PMRX_SMB_SRV_OPEN smbSrvOpen = MRxSmbGetSrvOpenExtension(capFobx->pSrvOpen);

                if ((pVNetRootContext->pServerEntry->Server.Version -
                     smbSrvOpen->Version) > 1) {
                    TransitionVNetRoot = FALSE;
                }
            }

            if (TransitionVNetRoot) {
                PDFS_NAME_CONTEXT pDfsNameContext = NULL;
                ULONG   uFlags = DFS_FLAG_LAST_ALTERNATE;
                if (RxContext &&
                    RxContext->CurrentIrpSp &&
                    RxContext->CurrentIrpSp->MajorFunction == IRP_MJ_CREATE) {

                    pDfsNameContext = CscIsValidDfsNameContext(RxContext->Create.NtCreateParameters.DfsNameContext);

                    if (pDfsNameContext)
                    {
                        uFlags = pDfsNameContext->Flags;
                    }
                }

                SmbCeLog(("CSCTrVNR DfsFlgs %x\n", uFlags));
                SmbLog(LOG,
                       CscTransitionVNetRootForDisconnectedOperation_2,
                       LOGULONG(uFlags));

                Status = CscpTransitionServerEntryForDisconnectedOperation(
                             RxContext,
                             pVNetRootContext->pServerEntry,
                             pNetRootEntry,
                             RemoteStatus,
                             FALSE,   // to autodial or not to autodial
                             uFlags
                             );

                // If the DFS share is in the database and the agent says it is OK to go disconnected
                // then we want to create a DFS server entry and put that one in
                // disconnected state too

                if ((Status == STATUS_SUCCESS)  &&
                    ((pDfsNameContext != NULL)||(pNetRootEntry->NetRoot.DfsAware))) {

//                    DbgPrint("CSCTransitionVNETroot: Transitioning %wZ \n", &pVNetRootContext->pServerEntry->Name);
                    SmbCeLog(("CSCTrVNR try Tr %wZ \n", &pVNetRootContext->pServerEntry->Name));
                    SmbLog(LOG,
                           CscTransitionVNetRootForDisconnectedOperation_3,
                           LOGUSTR(pVNetRootContext->pServerEntry->Name));

                    Status = CscPrepareDfsServerEntryForDisconnectedOperation(
                                 pVNetRootContext->pServerEntry,
                                 RxContext);
                }

                if (Status != STATUS_SUCCESS) {
                    ReturnStatus = Status;
                } else {
                    ReturnStatus = STATUS_RETRY;
                }
            }
        }
    }

    return ReturnStatus;
}

NTSTATUS
CscTransitionServerEntryForDisconnectedOperation(
    PSMBCEDB_SERVER_ENTRY pServerEntry,
    PRX_CONTEXT           RxContext,
    NTSTATUS              RemoteStatus,
    BOOLEAN               AutoDialRequired)
{
    NTSTATUS        TransitionStatus = STATUS_SUCCESS;
    PMRX_V_NET_ROOT pVNetRoot = NULL;

    ULONG   uFlags = DFS_FLAG_LAST_ALTERNATE;

    SmbCeLog(("CSCTrSvr IN %x %x %x %x\n", pServerEntry, RxContext, RemoteStatus, AutoDialRequired));
    SmbLog(LOG,
           CscTransitionServerEntryForDisconnectedOperation_1,
           LOGPTR(pServerEntry)
           LOGPTR(RxContext)
           LOGULONG(RemoteStatus)
           LOGUCHAR(AutoDialRequired)
           LOGUSTR(pServerEntry->Name));

    if ((RxContext != NULL) &&
        (RxContext->CurrentIrp != NULL) &&
        (RxContext->CurrentIrpSp->MajorFunction == IRP_MJ_CREATE)) {
        PDFS_NAME_CONTEXT pDfsNameContext;

        pDfsNameContext = CscIsValidDfsNameContext(
                             RxContext->Create.NtCreateParameters.DfsNameContext);

        if (pDfsNameContext != NULL) {
            uFlags = pDfsNameContext->Flags;
            SmbCeLog(("CSCTrSvr DFSFlgs %x\n", uFlags));
            SmbLog(LOG,
                   CscTransitionServerEntryForDisconnectedOperation_2,
                   LOGULONG(uFlags));
        }
    }

    if ((RxContext != NULL) &&
        (RxContext->pFobx != NULL) &&
        (RxContext->pFobx->pSrvOpen != NULL)) {
        pVNetRoot = RxContext->pFobx->pSrvOpen->pVNetRoot;
    }

    if (pVNetRoot != NULL) {
        TransitionStatus =
            CscTransitionVNetRootForDisconnectedOperation(
                RxContext,
                pVNetRoot,
                pServerEntry->ServerStatus);
    } else {
        TransitionStatus =
            CscpTransitionServerEntryForDisconnectedOperation(
                RxContext,
                pServerEntry,
                NULL,
                RemoteStatus,
                AutoDialRequired,
                uFlags
                );

        if ((TransitionStatus == STATUS_SUCCESS) &&
            (RxContext != NULL)) {
            BOOLEAN TransitionDfsVNetRoot = FALSE;

            TransitionDfsVNetRoot =
                CscIsThisDfsCreateOperationTransitionableForDisconnectedOperation(
                    RxContext);

            if (TransitionDfsVNetRoot) {
  //              DbgPrint("CSCTransitionServerEntry: Transitioning DFS server for ServerEntry %x \n", pServerEntry);

                TransitionStatus = CscPrepareDfsServerEntryForDisconnectedOperation(
                                        pServerEntry,
                                        RxContext);
            }
        }
    }
    // Pulse the fill thread so it will start 10-min tries to reconnect
    // It will go back to sleep if it succeeds
    // DbgPrint("###CSCTransitionServerEntry: pulsing fill event\n");
    MRxSmbCscSignalFillAgent(NULL, 0);

    SmbCeLog(("CSCTrSvr Out %x\n", TransitionStatus));
    SmbLog(LOG,
           CscTransitionServerEntryForDisconnectedOperation_3,
           LOGULONG(TransitionStatus));

    return TransitionStatus;
}

BOOLEAN
CscPerformOperationInDisconnectedMode(
    PRX_CONTEXT RxContext)
/*++

Routine Description:

   This routine detects if the operation should be performed in a disconnected
   mode. Additionally if the operation needs to be performed in a disconnected
   mode it prepares the open accordingly.

Arguments:

    RxContext - the Wrapper context for the operation

Return Value:

    TRUE -- if the operation needs to be performed in the disconnected mode
    and FALSE otherwise

Notes:

    There are certain opens that are deferred by the SMB mini redirector in
    the connected mode. These modes need to be evaluated when the transition is
    made to disconnected mode, since in disconnected mode there are no
    deferred opens.

    The appropriate buffering change requests need to be done as well (TBI)
--*/
{
    NTSTATUS Status;

    RxCaptureFcb;
    RxCaptureFobx;

    PMRX_SRV_OPEN     SrvOpen;
    PMRX_SMB_SRV_OPEN smbSrvOpen;

    PSMBCEDB_SERVER_ENTRY       pServerEntry;
    PSMBCE_V_NET_ROOT_CONTEXT   pVNetRootContext;
    BOOLEAN PerformOperationInDisconnectedMode = FALSE;

    if(!MRxSmbIsCscEnabled) {
        return(FALSE);
    }

    SrvOpen    = RxContext->pRelevantSrvOpen;

    // check if SrvOpen is NULL. This could happen if a mailslot operation was passed in here
    if (!SrvOpen)
    {
        return(FALSE);
    }

    smbSrvOpen = MRxSmbGetSrvOpenExtension(SrvOpen);

    if (FlagOn(smbSrvOpen->Flags, SMB_SRVOPEN_FLAG_LOCAL_OPEN)) {
        return FALSE;
    }

    pServerEntry = SmbCeGetAssociatedServerEntry(capFcb->pNetRoot->pSrvCall);
    pVNetRootContext = SmbCeGetAssociatedVNetRootContext(capFobx->pSrvOpen->pVNetRoot);

    if (SmbCeIsServerInDisconnectedMode(pServerEntry) &&
        !FlagOn(
            pVNetRootContext->Flags,
            SMBCE_V_NET_ROOT_CONTEXT_CSCAGENT_INSTANCE)) {
        PMRX_SMB_FCB smbFcb;

        smbFcb = MRxSmbGetFcbExtension(capFcb);
        if (smbFcb->hShadow == 0) {
            BOOLEAN FcbAcquired;
            BOOLEAN PreviouslyAcquiredShared = FALSE;

            // If the FCB resource has not been acquired, acquire it before
            // performing the create.

            if (!RxIsFcbAcquiredExclusive(capFcb)) {
                if (RxIsFcbAcquiredShared(capFcb)) {
                    RxDbgTrace(0, Dbg, ("Shared holding condition detected for disconnected operation\n"));
                    RxReleaseFcbResourceInMRx(capFcb);
                    PreviouslyAcquiredShared = TRUE;
                }

                RxAcquireExclusiveFcbResourceInMRx(capFcb );
                FcbAcquired = TRUE;
            } else {
                FcbAcquired = FALSE;
            }

            // This is a case of a deferred open for which the transition has
            // been made to disconnected operation.

            Status = MRxSmbDeferredCreate(RxContext);

            //RxIndicateChangeOfBufferingState(
            //    capFcb->pNetRoot->pSrvCall,
            //    MRxSmbMakeSrvOpenKey(smbFcb->Tid,smbSrvOpen->Fid),
            //    (PVOID)2);

            if (FcbAcquired) {
                RxReleaseFcbResourceInMRx(capFcb);
            }

            if (PreviouslyAcquiredShared) {
                RxAcquireSharedFcbResourceInMRx(capFcb );
            }
        }

        PerformOperationInDisconnectedMode = TRUE;
    }

    return PerformOperationInDisconnectedMode;
}

#if 0
int
AllPinnedFilesFilled(
    HSHARE hShare,
    BOOL    *lpfComplete
    )

/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    CSC_ENUMCOOKIE  hPQ;
    PQPARAMS sPQP;
    int iRet = SRET_ERROR;

    ASSERT(hShare);
    ASSERT(lpfComplete);


    // Open the priority q
    if (!(hPQ = HBeginPQEnum()))
    {
        RxDbgTrace(0, Dbg, ("AllPinnedFilesFilled: Error opening Priority Q database\r\n"));
        return SRET_ERROR;
    }

    *lpfComplete = TRUE;
    memset(&sPQP, 0, sizeof(PQPARAMS));
    sPQP.uEnumCookie = hPQ;

    // go down the Q once
    do
    {
        if(NextPriSHADOW(&sPQP) < SRET_OK)
        {
            RxDbgTrace(0, Dbg, ("AllPinnedFilesFilled: PQ record read error\r\n"));
            goto bailout;
        }



        if (!sPQP.hShadow)
        {
            break;
        }

        // see if any of the pinned files for the specific
        // server is sparse
        if ((hShare == sPQP.hShare)
            && (sPQP.ulStatus & SHADOW_IS_FILE) // It is a file
            && ((sPQP.ulHintPri || mPinFlags(sPQP.ulHintFlags)))// it is a pinned file
            )
        {
            if (sPQP.ulStatus & SHADOW_SPARSE)
            {
                // we found a sparse file
                *lpfComplete = FALSE;
                break;
            }
        }

    }
    while (sPQP.uPos);

    iRet = SRET_OK;

bailout:
    if (hPQ)
    {
        EndPQEnum(hPQ);
    }
    if (iRet == SRET_ERROR)
    {
        *lpfComplete = FALSE;
    }
    return (iRet);
}
#endif

BOOLEAN
CscGetServerNameWaitingToGoOffline(
    OUT     PWCHAR      ServerName,
    IN OUT  LPDWORD     lpdwBufferSize,
    OUT     NTSTATUS    *lpStatus
    )
/*++

Routine Description:
                This routine returns the name of the server which has asked the agent to
                throw a popup to the user.
Arguments:
                ServerName  returns the name of the server
Return Value:
                Fails if no server is waiting for the popup to comeback
Notes:

--*/
{
    BOOLEAN fRet = FALSE;
    DWORD   dwSize = *lpdwBufferSize;
    *lpStatus = STATUS_UNSUCCESSFUL;

    if (CscServerEntryBeingTransitioned)
    {
        PWCHAR Name;
        ULONG  NameLength;

        if (!CscDfsRootServerEntryBeingTransitioned) {
            NameLength = CscServerEntryBeingTransitioned->Name.Length;
            Name = CscServerEntryBeingTransitioned->Name.Buffer;
        } else {
            NameLength = CscDfsRootServerEntryBeingTransitioned->Name.Length;
            Name = CscDfsRootServerEntryBeingTransitioned->Name.Buffer;
        }

        *lpdwBufferSize = (DWORD)(NameLength+2+2);

        if(dwSize >= (DWORD)(NameLength+2+2))
        {
            *ServerName='\\';

            memcpy(
                ServerName+1,
                Name,
                NameLength);

            memset(((LPBYTE)(ServerName+1))+NameLength, 0, 2);

            *lpStatus = STATUS_SUCCESS;
            fRet = TRUE;
        }
        else
        {
            *lpStatus = STATUS_BUFFER_TOO_SMALL;
        }
    }
    return fRet;
}

BOOLEAN
CscShareIdToShareName(
    IN      ULONG       hShare,
    OUT     PWCHAR      ShareName,
    IN OUT  LPDWORD     lpdwBufferSize,
    OUT     NTSTATUS    *lpStatus
    )
{
    SHAREREC sSR;
    DWORD   dwSize = *lpdwBufferSize;
    ULONG  NameLength;
    INT iRet;

    // DbgPrint("CscShareIdToShareName(%d)\n", hShare);

    *lpStatus = STATUS_OBJECT_NAME_NOT_FOUND;

    if (hShare == 0)
        goto AllDone;

    EnterShadowCrit();
    iRet = GetShareRecord(lpdbShadow, hShare, &sSR);
    LeaveShadowCrit();
    if (iRet >= 0 && sSR.uchType == (UCHAR)REC_DATA) {
        NameLength = (wcslen(sSR.rgPath)+1) * sizeof(WCHAR);
        *lpdwBufferSize = (DWORD)NameLength;
        if(dwSize >= (DWORD)(NameLength)) {
            memset(ShareName, 0, dwSize);
            if (NameLength > 0)
                memcpy(ShareName, sSR.rgPath, NameLength);
            *lpStatus = STATUS_SUCCESS;
        } else {
            *lpStatus = STATUS_BUFFER_TOO_SMALL;
        }
    }
AllDone:
    // DbgPrint("CscShareIdToShareName exit 0x%x\n", *lpStatus);
    return TRUE;
}

BOOLEAN
CSCCheckForAcd(VOID)
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    PFILE_OBJECT pAcdFileObject;
    PDEVICE_OBJECT pAcdDeviceObject;
    BOOLEAN    fAutoDialON=FALSE;
    PIRP pIrp;

    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Get the file and device objects for the
    // device.
    //
    status = IoGetDeviceObjectPointer(
               &nameString,
               SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
               &pAcdFileObject,
               &pAcdDeviceObject);
    if (status != STATUS_SUCCESS)
    {
        RxDbgTrace(0, Dbg, ("CSCCheckForAcd: failed with status=%x \r\n", status));
        return FALSE;
    }

    //
    // Reference the device object.
    //
    ObReferenceObject(pAcdDeviceObject);
    //
    // Remove the reference IoGetDeviceObjectPointer()
    // put on the file object.
    //
    ObDereferenceObject(pAcdFileObject);

    pIrp = IoBuildDeviceIoControlRequest(
             IOCTL_INTERNAL_ACD_QUERY_STATE,
             pAcdDeviceObject,
             NULL,
             0,
             &fAutoDialON,
             sizeof(fAutoDialON),
             TRUE,
             NULL,
             &ioStatusBlock);
    if (pIrp == NULL) {
        ObDereferenceObject(pAcdDeviceObject);
        return FALSE;
    }
    //
    // Submit the request to the
    // automatic connection driver.
    //
    status = IoCallDriver(pAcdDeviceObject, pIrp);

    ObDereferenceObject(pAcdDeviceObject);
    return fAutoDialON;
}

BOOLEAN
CscTransitnOKToGoOffline(
    NTSTATUS    RemoteStatus
    )
/*++

Routine Description:

Arguments:

Return Value:

Notes:

--*/
{

    switch (RemoteStatus) {
    case STATUS_CONNECTION_DISCONNECTED:
    case STATUS_IO_TIMEOUT:
    case STATUS_NETWORK_UNREACHABLE:
    case STATUS_BAD_NETWORK_NAME:
    case STATUS_BAD_NETWORK_PATH:
    case STATUS_NETWORK_NAME_DELETED:
        return TRUE;
    default :
        return FALSE;
    }
}

BOOLEAN
CscIsSpecialShare(
    PUNICODE_STRING ShareName)
{
    ULONG i;
    BOOLEAN fSpecial = FALSE;

    // DbgPrint("CscIsSpecialShare(%wZ)\n", ShareName);
    for (i = 0;
            (i < (sizeof(CscSpecialShares) / sizeof(CscSpecialShares[0]))) &&
                !fSpecial;
                    i++) {
        if (CscSpecialShares[i].Length == ShareName->Length) {
            if (_wcsnicmp(
                    CscSpecialShares[i].Buffer,
                        ShareName->Buffer,
                            ShareName->Length/sizeof(WCHAR)) == 0) {
                fSpecial = TRUE;
            }
        }
    }
    // DbgPrint("CscIsSpecialShare returning %d\n", fSpecial);
    return fSpecial;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\block.c ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    block.c

Abstract:

    Block encryption functions implementation :

        RtlEncryptBlock
        RtlEncrypStdBlock


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

    Scott Field (sfield)    03-Nov-97
        Removed critical section around crypto calls.
    Adam Barr (adamba)      15-Dec-97
        Modified from private\security\lsa\crypt\dll

--*/

#include <rdrssp.h>



NTSTATUS
RtlEncryptBlock(
    IN PCLEAR_BLOCK ClearBlock,
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    )

/*++

Routine Description:

    Takes a block of data and encrypts it with a key producing
    an encrypted block of data.

Arguments:

    ClearBlock - The block of data that is to be encrypted.

    BlockKey - The key to use to encrypt data

    CypherBlock - Encrypted data is returned here

Return Values:

    STATUS_SUCCESS - The data was encrypted successfully. The encrypted
                     data block is in CypherBlock

    STATUS_UNSUCCESSFUL - Something failed. The CypherBlock is undefined.
--*/

{
    unsigned Result;

    Result = DES_ECB_LM(ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)ClearBlock,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(STATUS_SUCCESS);
    } else {
        KdPrint(("RDRSSP: RtlEncryptBlock failed %x\n\r", Result));
        return(STATUS_UNSUCCESSFUL);
    }
}



NTSTATUS
RtlEncryptStdBlock(
    IN PBLOCK_KEY BlockKey,
    OUT PCYPHER_BLOCK CypherBlock
    )

/*++

Routine Description:

    Takes a block key encrypts the standard text block with it.
    The resulting encrypted block is returned.
    This is a One-Way-Function - the key cannot be recovered from the
    encrypted data block.

Arguments:

    BlockKey - The key to use to encrypt the standard text block.

    CypherBlock - The encrypted data is returned here

Return Values:

    STATUS_SUCCESS - The encryption was successful.
                     The result is in CypherBlock

    STATUS_UNSUCCESSFUL - Something failed. The CypherBlock is undefined.
--*/

{
    unsigned Result;
    char StdEncrPwd[] = "KGS!@#$%";

    Result = DES_ECB_LM(ENCR_KEY,
                        (const char *)BlockKey,
                        (unsigned char *)StdEncrPwd,
                        (unsigned char *)CypherBlock
                       );

    if (Result == CRYPT_OK) {
        return(STATUS_SUCCESS);
    } else {
#if DBG
        DbgPrint("EncryptStd failed\n\r");
#endif
        return(STATUS_UNSUCCESSFUL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\context.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        context.cxx
//
// Contents:    context kernel-mode functions
//
//
// History:     3/17/94     MikeSw          Created
//              12/15/97    AdamBa          Modified from private\lsa\client\ssp
//
//------------------------------------------------------------------------

#include <rdrssp.h>


//+-------------------------------------------------------------------------
//
//  Function:   DeleteKernelContext
//
//  Synopsis:   Deletes a kernel context
//
//  Effects:    Frees memory, closes token handle.
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS
DeleteKernelContext(PKernelContext *    ppList,
                    PKSPIN_LOCK         pslLock,
                    PKernelContext      pContext)
{
    KIRQL OldIrql;

    //
    // First, find the record, then unlink the record from the list,
    // and fix up pointers.
    //

    KeAcquireSpinLock(pslLock, &OldIrql);


    if (!pContext)
    {
        KeReleaseSpinLock(pslLock, OldIrql);
        return(SEC_E_INVALID_HANDLE);
    }

    //
    // Now unlink from the list
    //

    if (pContext->pPrev)
    {
        pContext->pPrev->pNext = pContext->pNext;
    }
    else
    {
        *ppList = pContext->pNext;
    }


    if (pContext->pNext)
    {
        pContext->pNext->pPrev = pContext->pPrev;
    }

    //
    // copy out the package-specific context to return.
    // We are done with the list so we can release the spin lock
    //

    KeReleaseSpinLock(pslLock, OldIrql);


    if (pContext->TokenHandle != NULL)
    {
        NtClose(pContext->TokenHandle);
    }
    if (pContext->AccessToken != NULL)
    {
        ObDereferenceObject(pContext->AccessToken);
    }

    // And, finally, return the context record to our pool:

    FreeContextRec(pContext);

    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   AddKernelContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
AddKernelContext(   PKernelContext * ppList,
                    PKSPIN_LOCK     pslLock,
                    PKernelContext  pContext)
{
    KIRQL   OldIrql;


    KeAcquireSpinLock(pslLock, &OldIrql);

    pContext->pNext = *ppList;
    if (pContext->pNext)
    {
        pContext->pNext->pPrev = pContext;
    }
    pContext->pPrev = NULL;

    *ppList = pContext;

    KeReleaseSpinLock(pslLock, OldIrql);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\ksecdd.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        KSecDD.C
//
// Contents:    Base level stuff for the device driver
//
//
// History:     19 May 92,  RichardW    Blatently stolen from DarrylH
//              15 Dec 97,  AdamBa      Modified from private\lsa\crypt\ssp
//
//------------------------------------------------------------------------

#include <rdrssp.h>


#if DBG
ULONG KsecInfoLevel;

void
KsecDebugOut(unsigned long  Mask,
            const char *    Format,
            ...)
{
    PETHREAD    pThread;
    PEPROCESS   pProcess;
    va_list     ArgList;
    char        szOutString[256] = {0};

    if (KsecInfoLevel & Mask)
    {
        pThread = PsGetCurrentThread();
        pProcess = PsGetCurrentProcess();

        va_start(ArgList, Format);
        DbgPrint("%#x.%#x> KSec:  ", pProcess, pThread);
        if (_vsnprintf(szOutString, sizeof(szOutString) - 1, Format, ArgList) < 0)
        {
                //
                // Less than zero indicates that the string could not be
                // fitted into the buffer.  Output a special message indicating
                // that:
                //

                DbgPrint("Error printing message\n");

        }
        else
        {
            DbgPrint(szOutString);
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\ksecdd.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        KSECDD.H
//
// Contents:    Structures and defines for the security device driver
//
//
// History:     19 May 92,  RichardW    Created
//              15 Dec 97,  AdamBa      Modified from private\lsa\client\ssp
//
//------------------------------------------------------------------------

#ifndef __KSECDD_H__
#define __KSECDD_H__

VOID * SEC_ENTRY
SecAllocate(ULONG cbMemory);

void SEC_ENTRY
SecFree(PVOID pvMemory);

BOOLEAN
GetTokenBuffer(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PVOID * TokenBuffer,
    OUT PULONG TokenSize,
    IN BOOLEAN ReadonlyOK
    );

BOOLEAN
GetSecurityToken(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PSecBuffer * TokenBuffer
    );

#define DEB_ERROR   0x1
#define DEB_WARN    0x2
#define DEB_TRACE   0x4


#ifdef POOL_TAGGING
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a, b, 'cesK')
#define ExAllocatePoolWithQuota(a,b)    ExAllocatePoolWithQuotaTag(a, b, 'cesK')
#endif


#if DBG
void
KsecDebugOut(unsigned long  Mask,
            const char *    Format,
            ...);

#define DebugStmt(x) x
#define DebugLog(x) KsecDebugOut x
#else
#define DebugStmt(x)
#define DebugLog(x)
#endif


#endif // __KSECDD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\kfuncs.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        KFUNCS.H
//
// Contents:    xxxK versions of SSPI functions.
//
//
// History:     15 Dec 97,  AdamBa      Created
//
//------------------------------------------------------------------------

#ifndef __KFUNCS_H__
#define __KFUNCS_H__

SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleK(
    PSECURITY_STRING pPrincipal,
    PSECURITY_STRING pPackage,
    unsigned long fCredentialUse,       // Flags indicating use
    void SEC_FAR * pvLogonId,           // Pointer to logon ID
    void SEC_FAR * pAuthData,           // Package specific data
    SEC_GET_KEY_FN pGetKeyFn,           // Pointer to GetKey() func
    void SEC_FAR * pvGetKeyArgument,    // Value to pass to GetKey()
    PCredHandle phCredential,           // (out) Cred Handle
    PTimeStamp ptsExpiry                // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandleK(
    PCredHandle phCredential            // Handle to free
    );

SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextK(
    PCredHandle phCredential,               // Cred to base context
    PCtxtHandle phContext,                  // Existing context (OPT)
    PSECURITY_STRING pTargetName,
    unsigned long fContextReq,              // Context Requirements
    unsigned long Reserved1,                // Reserved, MBZ
    unsigned long TargetDataRep,            // Data rep of target
    PSecBufferDesc pInput,                  // Input Buffers
    unsigned long Reserved2,                // Reserved, MBZ
    PCtxtHandle phNewContext,               // (out) New Context handle
    PSecBufferDesc pOutput,                 // (inout) Output Buffers
    unsigned long SEC_FAR * pfContextAttr,  // (out) Context attrs
    PTimeStamp ptsExpiry                    // (out) Life span (OPT)
    );

SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextK(
    PCtxtHandle phContext               // Context to delete
    );

SECURITY_STATUS SEC_ENTRY
FreeContextBufferK(
    void SEC_FAR * pvContextBuffer      // buffer to free
    );

SECURITY_STATUS SEC_ENTRY
MapSecurityErrorK( SECURITY_STATUS hrValue );

#if 0
SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesK(
    unsigned long SEC_FAR * pcPackages,     // Receives num. packages
    PSecPkgInfoW SEC_FAR * ppPackageInfo    // Receives array of info
    );

SECURITY_STATUS SEC_ENTRY
QuerySecurityContextTokenK(
    PCtxtHandle phContext,
    void SEC_FAR * SEC_FAR * Token
    );
#endif

#endif   // __KFUNCS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\memmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        memmgr.h
//
// Contents:    Memory Manager code for KSecDD
//
//
// History:     23 Feb 93   RichardW    Created
//              15 Dec 97   AdamBa      Modified from private\lsa\client\ssp
//
//------------------------------------------------------------------------

#ifndef __MEMMGR_H__
#define __MEMMGR_H__

PKernelContext  AllocContextRec(void);
void            FreeContextRec(PKernelContext);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\memmgr.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        memmgr.c
//
// Contents:    Fast memory manager code for KSecDD
//
//
// History:     23 Feb 93   RichardW    Created
//              15 Dec 97   AdamBa      Modified from private\lsa\client\ssp
//               
//
//------------------------------------------------------------------------

#include <rdrssp.h>


#if DBG
ULONG               cActiveCtxtRecs = 0;
#endif


//+-------------------------------------------------------------------------
//
//  Function:   AllocContextRec
//
//  Synopsis:   Allocates a KernelContext structure
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
PKernelContext
AllocContextRec(void)
{
    PKernelContext  pContext = NULL;

    pContext = (PKernelContext)
                ExAllocatePool(NonPagedPool, sizeof(KernelContext));

    if (pContext == NULL)
    {
        DebugLog((DEB_ERROR,"Could not allocate from pool!\n"));
        return(NULL);
    }

    pContext->pNext = NULL;
    pContext->pPrev = NULL;

    DebugStmt(cActiveCtxtRecs++);

    return(pContext);
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeContextRec
//
//  Synopsis:   Returns a KernelContext record to the free list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
void
FreeContextRec(PKernelContext   pContext)
{
    //
    // Just return the context to the pool.
    //

    ExFreePool(pContext);

    DebugStmt(cActiveCtxtRecs--);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\nlp.h ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    nlp.h

Abstract:

    NETLOGON private definitions.




Author:

    Jim Kelly 11-Apr-1991

Revision History:
   Chandana Surlu         21-Jul-96      Stolen from \\kernel\razzle3\src\security\msv1_0\nlp.h
   Adam Barr              15-Dec-97      Copied from private\security\msv_sspi

--*/

#ifndef _NLP_
#define _NLP_

#include <windef.h>
#include <winbase.h>
#include <crypt.h>
#include <lmcons.h>
#include <ntsam.h>
#include <ntsamp.h>
#include <logonmsv.h>
#include <samrpc.h>
#include <align.h>
#include <dsgetdc.h>


//
// nlmain.c will #include this file with NLP_ALLOCATE defined.
// That will cause each of these variables to be allocated.
//
#ifdef NLP_ALLOCATE
#define EXTERN
#define INIT(_X) = _X
#else
#define EXTERN extern
#define INIT(_X)
#endif

#define NETLOGON_STARTUP_TIME   900             

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private data structures                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Structure used to keep track of all private information related to a
//  particular LogonId.
//

typedef struct _PACTIVE_LOGON {

    LUID LogonId;               // The logon Id of this logon session

    ULONG EnumHandle;           // The enumeration handle of this logon session

    SECURITY_LOGON_TYPE LogonType;  // Type of logon (interactive or service)

    PSID UserSid;               // Sid of the logged on user

    UNICODE_STRING UserName;    // Name of the logged on user

    UNICODE_STRING LogonDomainName;  // Name of the domain logged onto

    UNICODE_STRING LogonServer; // Name of the server which logged this user on

    ULONG Flags;                    // Attributes of this entry.

#define LOGON_BY_NETLOGON   0x01    // Entry was validated by NETLOGON service
#define LOGON_BY_CACHE      0x02    // Entry was validated by local cache
#define LOGON_BY_OTHER_PACKAGE 0x04 // Entry was validated by another authentication package
#define LOGON_BY_LOCAL 0x08         // Entry was validated by local sam

    struct _PACTIVE_LOGON * Next;   // Next entry in linked list.

} ACTIVE_LOGON, *PACTIVE_LOGON;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//       CREDENTIAL Related Data Structures                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
//   Following is a description of the content and format of each type
//   of credential maintained by the MsV1_0 authentication package.
//
//   The MsV1_0 authentication package defines the following credential
//   primary key string values:
//
//       "Primary" - Is used to hold the primary credentials provided at
//           initial logon time.  This includes the username and both
//           case-sensitive and case-insensitive forms of the user's
//           password.
//
//   NOTE: All poitners stored in credentials must be
//   changed to be an offset to the body rather than a pointer.  This is
//   because credential fields are copied by the LSA and so the pointer
//   would become invalid.
//


//
// MsV1_0 Primary Credentials
//
//
//        The PrimaryKeyValue string of this type of credential contains the
//        following string:
//
//                  "Primary"
//
//        The Credential string of a Primary credential contains the following
//        values:
//
//             o  The user's username
//
//             o  A one-way function of the user's password as typed.
//
//             o  A one-way function of the user's password upper-cased.
//
//        These values are structured as follows:
//

#define MSV1_0_PRIMARY_KEY "Primary"

typedef struct _MSV1_0_PRIMARY_CREDENTIAL {
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    NT_OWF_PASSWORD NtOwfPassword;
    LM_OWF_PASSWORD LmOwfPassword;
    BOOLEAN NtPasswordPresent;
    BOOLEAN LmPasswordPresent;
} MSV1_0_PRIMARY_CREDENTIAL, *PMSV1_0_PRIMARY_CREDENTIAL;



//
// Structure describing a buffer in the clients address space.
//

typedef struct _CLIENT_BUFFER_DESC {
    PLSA_CLIENT_REQUEST ClientRequest;
    LPBYTE UserBuffer;      // Address of buffer in client's address space
    LPBYTE MsvBuffer;       // Address of mirror buffer in MSV's address space
    ULONG StringOffset;     // Current offset to variable length data
    ULONG TotalSize;        // Size (in bytes) of buffer
} CLIENT_BUFFER_DESC, *PCLIENT_BUFFER_DESC;


//
// Structure describing logon information and credential use flags
//

typedef struct _MS_LOGON_CREDENTIAL {
    LUID LogonId;
    ULONG_PTR CredentialUse;
} MS_LOGON_CREDENTIAL, *PMS_LOGON_CREDENTIAL;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal routine definitions                                              //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// From nlmain.c.
//

NTSTATUS
NlSamInitialize(
    ULONG Timeout
    );

//
// From nlp.c.
//

VOID
NlpPutString(
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString,
    IN PUCHAR *Where
    );

VOID
NlpInitClientBuffer(
    OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PLSA_CLIENT_REQUEST ClientRequest
    );

NTSTATUS
NlpAllocateClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN ULONG FixedSize,
    IN ULONG TotalSize
    );

NTSTATUS
NlpFlushClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    OUT PVOID* UserBuffer
    );

VOID
NlpFreeClientBuffer(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc
    );

VOID
NlpPutClientString(
    IN OUT PCLIENT_BUFFER_DESC ClientBufferDesc,
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    );

VOID
NlpMakeRelativeString(
    IN PUCHAR BaseAddress,
    IN OUT PUNICODE_STRING String
    );

VOID
NlpRelativeToAbsolute(
    IN PVOID BaseAddress,
    IN OUT PULONG RelativeValue
    );

BOOLEAN
NlpFindActiveLogon(
    IN PLUID LogonId,
    OUT PACTIVE_LOGON **ActiveLogon
    );

ULONG
NlpCountActiveLogon(
    IN PUNICODE_STRING LogonDomainName,
    IN PUNICODE_STRING UserName
    );

NTSTATUS
NlpAllocateInteractiveProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO2 NlpUser
    );

NTSTATUS
NlpAllocateNetworkProfile (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    OUT PMSV1_0_LM20_LOGON_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO2 NlpUser
    );

PSID
NlpMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    );

NTSTATUS
NlpMakeTokenInformationV1(
    IN  PNETLOGON_VALIDATION_SAM_INFO2 NlpUser,
    OUT PLSA_TOKEN_INFORMATION_V1 *TokenInformation
    );

NTSTATUS
NlpMakePrimaryCredential(
    IN  PUNICODE_STRING LogonDomainName,
    IN  PUNICODE_STRING UserName,
    IN PUNICODE_STRING CleartextPassword,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize,
    IN BOOLEAN OwfPasswordProvided
    );

NTSTATUS
NlpAddPrimaryCredential(
    IN PLUID LogonId,
    IN PMSV1_0_PRIMARY_CREDENTIAL Credential,
    IN ULONG CredentialSize
    );

NTSTATUS
NlpGetPrimaryCredential(
    IN PLUID LogonId,
    OUT PMSV1_0_PRIMARY_CREDENTIAL *CredentialBuffer,
    OUT PULONG CredentialSize
    );

NTSTATUS
NlpDeletePrimaryCredential(
    IN PLUID LogonId
    );

NTSTATUS
NlpChangePassword(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING UserName,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    IN PNT_OWF_PASSWORD NtOwfPassword
    );


//
// msvsam.c
//

BOOLEAN
MsvpPasswordValidate (
    IN BOOLEAN UasCompatibilityRequired,
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN PUSER_INTERNAL1_INFORMATION Passwords,
    OUT PULONG UserFlags,
    OUT PUSER_SESSION_KEY UserSessionKey,
    OUT PLM_SESSION_KEY LmSessionKey
);




//
// nlnetapi.c
//

VOID
NlpLoadNetapiDll (
    VOID
    );

VOID
NlpLoadNetlogonDll (
    VOID
    );

//
// subauth.c
//

VOID
Msv1_0SubAuthenticationInitialization(
    VOID
);


///////////////////////////////////////////////////////////////////////
//                                                                   //
// Global variables                                                  //
//                                                                   //
///////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ ONLY  Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////


//
// Null copies of Lanman and NT OWF password.
//
//

EXTERN LM_OWF_PASSWORD NlpNullLmOwfPassword;
EXTERN NT_OWF_PASSWORD NlpNullNtOwfPassword;

//
// Routines in NetApi32.dll
//


EXTERN BOOLEAN NlpNetapiDllLoaded;
EXTERN NET_API_STATUS  (NET_API_FUNCTION *NlpNetApiBufferFree)(LPVOID);
EXTERN NET_API_STATUS  (NET_API_FUNCTION *NlpRxNetUserPasswordSet)(LPWSTR, LPWSTR, LPWSTR, LPWSTR);
EXTERN NET_API_STATUS  (NET_API_FUNCTION *NlpDsGetDcName)(LPCWSTR, LPCWSTR, GUID *, LPCWSTR, ULONG, PDOMAIN_CONTROLLER_INFOW *);
EXTERN NTSTATUS (*NlpNetpApiStatusToNtStatus)( NET_API_STATUS );

//
// Routines in netlogon.dll
//

EXTERN HANDLE NlpNetlogonDllHandle;
EXTERN PNETLOGON_SAM_LOGON_PROCEDURE NlpNetLogonSamLogon;
EXTERN PNETLOGON_SAM_LOGOFF_PROCEDURE NlpNetLogonSamLogoff;

//
// TRUE if package is initialized
//

EXTERN BOOLEAN NlpMsvInitialized INIT(FALSE);

//
// TRUE if this is a workstation.
//

EXTERN BOOLEAN NlpWorkstation INIT(TRUE);

//
// TRUE once the MSV AP has initialized its connection to SAM.
//

EXTERN BOOLEAN NlpSamInitialized INIT(FALSE);

//
// TRUE if the MSV AP has initialized its connection to the NETLOGON service
//

EXTERN BOOLEAN NlpNetlogonInitialized INIT(FALSE);

//
// TRUE if LanMan is installed.
//

EXTERN BOOLEAN NlpLanmanInstalled INIT(FALSE);

//
// Computername of this computer.
//

EXTERN UNICODE_STRING NlpComputerName;

//
// Name and domain id of the SAM account database.
//

EXTERN UNICODE_STRING NlpSamDomainName;
EXTERN PSID NlpSamDomainId;
EXTERN SAMPR_HANDLE NlpSamDomainHandle;
EXTERN BOOLEAN NlpUasCompatibilityRequired INIT(TRUE);

//
// Trusted Handle to the Lsa database.
//

EXTERN LSA_HANDLE NlpPolicyHandle INIT(NULL);


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                   READ/WRITE Variables                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
// Define the list of active interactive logons.
//
// The NlpActiveLogonLock must be locked while referencing the list or
// any of its elements.
//

#define NlpLockActiveLogons()   RtlEnterCriticalSection(&NlpActiveLogonLock)
#define NlpUnlockActiveLogons() RtlLeaveCriticalSection(&NlpActiveLogonLock)

EXTERN RTL_CRITICAL_SECTION NlpActiveLogonLock;
EXTERN PACTIVE_LOGON NlpActiveLogons;

//
// Define the running enumeration handle.
//
// This variable defines the enumeration handle to assign to a logon
//  session.  It will be incremented prior to assigning it value to
//  the next created logon session.  Access is serialize using
//  NlpActiveLogonLocks.

EXTERN ULONG NlpEnumerationHandle;

//
// Define a running Session Number which is incremented once for each
// challenge given to the server.
//

EXTERN RTL_CRITICAL_SECTION NlpSessionCountLock;
EXTERN ULONG NlpSessionCount;
EXTERN ULONG NlpLogonAttemptCount;


#undef EXTERN
#undef INIT
#endif _NLP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\rdrssp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        rdrssp.h
//
// Contents:    precompiled header include for rdrssp.lib
//
//
// History:     3-17-94     MikeSw      Created
//              12-15-97    AdamBa      Modified from private\lsa\client\ssp\sspdrv.h
//
//------------------------------------------------------------------------

#ifndef __RDRSSP_H__
#define __RDRSSP_H__


#include <stdio.h>
#include <ntos.h>
#include <ntlmsp.h>
#define SECURITY_NTLM
#include <security.h>
#include <ntmsv1_0.h>
#include <zwapi.h>
#include <windef.h>
#include <lmcons.h>
#include <crypt.h>
#include <engine.h>
#include "connmgr.h"
#include "ksecdd.h"
#include "package.h"
#include "memmgr.h"
#include "kfuncs.h"  // xxxK functions
#include "secret.h"



#endif // __RDRSSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\ntlm.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        ntlm.c
//
// Contents:    ntlm kernel-mode functions
//
//
// History:     3/17/94     MikeSw          Created
//              12/15/97    AdamBa          Modified from private\lsa\client\ssp
//
//------------------------------------------------------------------------

#include <rdrssp.h>


KSPIN_LOCK NtlmLock;
PKernelContext pNtlmList;
BOOLEAN NtlmInitialized = FALSE;


//+-------------------------------------------------------------------------
//
//  Function:   NtlmInitialize
//
//  Synopsis:   initializes the NTLM package functions
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NtlmInitialize(void)
{
    KeInitializeSpinLock(&NtlmLock);
    pNtlmList = NULL;
    return(STATUS_SUCCESS);
}


#if 0
//+-------------------------------------------------------------------------
//
//  Function:   NtlmGetToken
//
//  Synopsis:   returns the token from a context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
NtlmGetToken(   ULONG   ulContext,
                PHANDLE phToken,
                PACCESS_TOKEN * pAccessToken)
{
    PKernelContext  pContext;
    NTSTATUS Status;


    PAGED_CODE();

    pContext = (PKernelContext) ulContext;

    if (pContext == NULL)
    {
        DebugLog((DEB_ERROR,"Invalid handle 0x%x\n", ulContext));

        return(SEC_E_INVALID_HANDLE);
    }

    // Now, after all that checking, let's actually try and set the
    // thread impersonation token.


    if (phToken != NULL)
    {
        *phToken = pContext->TokenHandle;
    }

    if (pAccessToken != NULL)
    {
        if (pContext->TokenHandle != NULL)
        {
            if (pContext->AccessToken == NULL)
            {
                Status = ObReferenceObjectByHandle(
                            pContext->TokenHandle,
                            TOKEN_IMPERSONATE,
                            NULL,       
                            KeGetPreviousMode(),
                            (PVOID *) &pContext->AccessToken,
                            NULL                // no handle information
                            );

                if (!NT_SUCCESS(Status))
                {
                    return(Status);
                }
            }
        }

        *pAccessToken = pContext->AccessToken;
    }

    return(STATUS_SUCCESS);

}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   NtlmInitKernelContext
//
//  Synopsis:   Initializes a kernel context with the session key
//              and possible token handle.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS
NtlmInitKernelContext(
    IN PUCHAR UserSessionKey,
    IN PUCHAR LanmanSessionKey,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
    )
{
    PKernelContext pContext;
    KIRQL   OldIrql;

    if (!NtlmInitialized) {
        NtlmInitialize();
        NtlmInitialized = TRUE;
    }

    pContext = AllocContextRec();
    if (!pContext)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    RtlCopyMemory(
        pContext->UserSessionKey,
        UserSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH
        );

    RtlCopyMemory(
        pContext->LanmanSessionKey,
        LanmanSessionKey,
        MSV1_0_LANMAN_SESSION_KEY_LENGTH
        );

    pContext->TokenHandle = TokenHandle;
    pContext->AccessToken = NULL;
    pContext->pPrev = NULL;

    ContextHandle->dwLower = (ULONG_PTR) pContext;
    ContextHandle->dwUpper = 0;

    //
    // Add it to the client record
    //

    AddKernelContext(&pNtlmList, &NtlmLock, pContext);
    return(STATUS_SUCCESS);
}




//+-------------------------------------------------------------------------
//
//  Function:   NtlmDeleteKernelContext
//
//  Synopsis:   Deletes a kernel context from the list of contexts
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS
NtlmDeleteKernelContext( PCtxtHandle ContextHandle)
{
    SECURITY_STATUS scRet;


    scRet = DeleteKernelContext(
                    &pNtlmList,
                    &NtlmLock,
                    (PKernelContext) ContextHandle->dwLower );

    return(scRet);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\package.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        package.h
//
// Contents:    kernel package structures
//
//
// History:     3-18-94     MikeSw      Created
//
//------------------------------------------------------------------------

#ifndef __PACKAGE_H__
#define __PACKAGE_H__

typedef SECURITY_STATUS
(SEC_ENTRY KspInitPackageFn)(void);

typedef SECURITY_STATUS
(SEC_ENTRY KspDeleteContextFn)(PCtxtHandle ulContextId);

typedef SECURITY_STATUS
(SEC_ENTRY KspInitContextFn)(
    IN PUCHAR UserSessionKey,
    IN PUCHAR LanmanSessionKey,
    IN HANDLE TokenHandle,
    OUT PCtxtHandle ContextHandle
);

#if 0
typedef SECURITY_STATUS
(SEC_ENTRY KspGetTokenFn)(  ULONG               ulContextId,
                            HANDLE *            phImpersonationToken,
                            PACCESS_TOKEN *     pAccessToken);
#endif


KspInitPackageFn NtlmInitialize;
KspInitContextFn NtlmInitKernelContext;
KspDeleteContextFn NtlmDeleteKernelContext;
#if 0
KspGetTokenFn NtlmGetToken;
#endif



#endif __PACKAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\secret.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1997
//
// File:        SECRET.H
//
// Contents:    Redirector functions to read/write remote boot secrets
//
//
// History:     29 Dec 97,  AdamBa      Created
//
//------------------------------------------------------------------------

#ifndef __RDRSECRET_H__
#define __RDRSECRET_H__

#include <remboot.h>

#define SECPKG_CRED_OWF_PASSWORD  0x00000010

#if defined(REMOTE_BOOT)
NTSTATUS
RdrOpenRawDisk(
    PHANDLE Handle
    );

NTSTATUS
RdrCloseRawDisk(
    HANDLE Handle
    );

NTSTATUS
RdrCheckForFreeSectors (
    HANDLE Handle
    );

NTSTATUS
RdrReadSecret(
    HANDLE Handle,
    PRI_SECRET Secret
    );

NTSTATUS
RdrWriteSecret(
    HANDLE Handle,
    PRI_SECRET Secret
    );

VOID
RdrInitializeSecret(
    IN PUCHAR Domain,
    IN PUCHAR User,
    IN PUCHAR LmOwfPassword1,
    IN PUCHAR NtOwfPassword1,
    IN PUCHAR LmOwfPassword2 OPTIONAL,
    IN PUCHAR NtOwfPassword2 OPTIONAL,
    IN PUCHAR Sid,
    IN OUT PRI_SECRET Secret
    );
#endif // defined(REMOTE_BOOT)

VOID
RdrParseSecret(
    IN OUT PUCHAR Domain,
    IN OUT PUCHAR User,
    IN OUT PUCHAR LmOwfPassword1,
    IN OUT PUCHAR NtOwfPassword1,
#if defined(REMOTE_BOOT)
    IN OUT PUCHAR LmOwfPassword2,
    IN OUT PUCHAR NtOwfPassword2,
#endif // defined(REMOTE_BOOT)
    IN OUT PUCHAR Sid,
    IN PRI_SECRET Secret
    );

#if defined(REMOTE_BOOT)
VOID
RdrOwfPassword(
    IN PUNICODE_STRING Password,
    IN OUT PUCHAR LmOwfPassword,
    IN OUT PUCHAR NtOwfPassword
    );
#endif // defined(REMOTE_BOOT)


#endif // __RDRSECRET_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\owf.c ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    owf.c

Abstract:

    Implentation of the one-way-functions used to implement password hashing.

        RtlCalculateLmOwfPassword
        RtlCalculateNtOwfPassword


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

    Adam Barr (AdamBa) 12-15-97
        Modified from private\security\lsa\crypt\dll

--*/

#include <rdrssp.h>



NTSTATUS
RtlCalculateLmOwfPassword(
    IN PLM_PASSWORD LmPassword,
    OUT PLM_OWF_PASSWORD LmOwfPassword
    )

/*++

Routine Description:

    Takes the passed LmPassword and performs a one-way-function on it.
    The current implementation does this by using the password as a key
    to encrypt a known block of text.

Arguments:

    LmPassword - The password to perform the one-way-function on.

    LmOwfPassword - The hashed password is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully. The hashed
                     password is in LmOwfPassword.

    STATUS_UNSUCCESSFUL - Something failed. The LmOwfPassword is undefined.
--*/

{
    NTSTATUS    Status;
    BLOCK_KEY    Key[2];
    PCHAR       pKey;

    // Copy the password into our key buffer and zero pad to fill the 2 keys

    pKey = (PCHAR)(&Key[0]);

    while (*LmPassword && (pKey < (PCHAR)(&Key[2]))) {
        *pKey++ = *LmPassword++;
    }

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }


    // Use the keys to encrypt the standard text

    Status = RtlEncryptStdBlock(&Key[0], &(LmOwfPassword->data[0]));

    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptStdBlock(&Key[1], &(LmOwfPassword->data[1]));

    //
    // clear our copy of the cleartext password
    //

    pKey = (PCHAR)(&Key[0]);

    while (pKey < (PCHAR)(&Key[2])) {
        *pKey++ = 0;
    }

    return(Status);
}




NTSTATUS
RtlCalculateNtOwfPassword(
    IN PNT_PASSWORD NtPassword,
    OUT PNT_OWF_PASSWORD NtOwfPassword
    )

/*++

Routine Description:

    Takes the passed NtPassword and performs a one-way-function on it.
    Uses the RSA MD4 function

Arguments:

    NtPassword - The password to perform the one-way-function on.

    NtOwfPassword - The hashed password is returned here

Return Values:

    STATUS_SUCCESS - The function was completed successfully. The hashed
                     password is in NtOwfPassword.
--*/

{
    MD4_CTX     MD4_Context;


    MD4Init(&MD4_Context);

    MD4Update(&MD4_Context, (PCHAR)NtPassword->Buffer, NtPassword->Length);

    MD4Final(&MD4_Context);


    // Copy the digest into our return data area

    ASSERT(sizeof(*NtOwfPassword) == sizeof(MD4_Context.digest));

    RtlMoveMemory((PVOID)NtOwfPassword, (PVOID)MD4_Context.digest,
                  sizeof(*NtOwfPassword));

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\response.c ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    response.c

Abstract:

    Contains functions that calculate the correct response to return
    to the server when logging on.

        RtlCalculateLmResponse
        RtlCalculateNtResponse


Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

    Adam Barr (AdamBa) 12-15-97
        Modified from private\security\lsa\crypt\dll

--*/

#include <rdrssp.h>



NTSTATUS
RtlCalculateLmResponse(
    IN PLM_CHALLENGE LmChallenge,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PLM_RESPONSE LmResponse
    )

/*++

Routine Description:

    Takes the challenge sent by the server and the OwfPassword generated
    from the password the user entered and calculates the response to
    return to the server.

Arguments:

    LmChallenge - The challenge sent by the server

    LmOwfPassword - The hashed password.

    LmResponse - The response is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The response
                     is in LmResponse.

    STATUS_UNSUCCESSFUL - Something failed. The LmResponse is undefined.
--*/

{
    NTSTATUS    Status;
    BLOCK_KEY    Key;
    PCHAR       pKey, pData;

    // The first 2 keys we can get at by type-casting

    Status = RtlEncryptBlock(LmChallenge,
                             &(((PBLOCK_KEY)(LmOwfPassword->data))[0]),
                             &(LmResponse->data[0]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    Status = RtlEncryptBlock(LmChallenge,
                             &(((PBLOCK_KEY)(LmOwfPassword->data))[1]),
                             &(LmResponse->data[1]));
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    // To get the last key we must copy the remainder of the OwfPassword
    // and fill the rest of the key with 0s

    pKey = &(Key.data[0]);
    pData = (PCHAR)&(((PBLOCK_KEY)(LmOwfPassword->data))[2]);

    while (pData < (PCHAR)&(LmOwfPassword->data[2])) {
        *pKey++ = *pData++;
    }

    // Zero extend

    while (pKey < (PCHAR)&((&Key)[1])) {
        *pKey++ = 0;
    }

    // Use the 3rd key

    Status = RtlEncryptBlock(LmChallenge, &Key, &(LmResponse->data[2]));

    return(Status);
}







NTSTATUS
RtlCalculateNtResponse(
    IN PNT_CHALLENGE NtChallenge,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PNT_RESPONSE NtResponse
    )
/*++

Routine Description:

    Takes the challenge sent by the server and the OwfPassword generated
    from the password the user entered and calculates the response to
    return(to the server.

Arguments:

    NtChallenge - The challenge sent by the server

    NtOwfPassword - The hashed password.

    NtResponse - The response is returned here.


Return Values:

    STATUS_SUCCESS - The function completed successfully. The response
                     is in NtResponse.

    STATUS_UNSUCCESSFUL - Something failed. The NtResponse is undefined.
--*/

{

    // Use the LM version until we change the definitions of any of
    // these data types

    return(RtlCalculateLmResponse((PLM_CHALLENGE)NtChallenge,
                                  (PLM_OWF_PASSWORD)NtOwfPassword,
                                  (PLM_RESPONSE)NtResponse));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\secret.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    secret.c

Abstract:

    This module contains the code to read and write secrets from disk.

Author:

    Adam Barr (adamba) 13-June-1997

Revision History:

    Adam Barr (adamba) 29-December-1997
        Modified from private\ntos\boot\lib\blsecret.c.

--*/

#include <rdrssp.h>
#include <rc4.h>
#include <wcstr.h>

#if defined(REMOTE_BOOT)

#if 0
VOID
RdrpDumpSector(
    PUCHAR Sector
    )
{
    int i, j;

    PUCHAR SectorChar = (PUCHAR)Sector;

    for (i = 0; i < 512; i+= 16) {

        for (j = 0; j < 16; j++) {
            DbgPrint("%2.2x ", SectorChar[i + j]);
        }
        DbgPrint("  ");
        for (j = 0; j < 16; j++) {
            if ((SectorChar[i+j] >= ' ') && (SectorChar[i+j] < '~')) {
                DbgPrint("%c", SectorChar[i+j]);
            } else {
                DbgPrint(".");
            }
        }
        DbgPrint("\n");
    }
}
#endif


NTSTATUS
RdrOpenRawDisk(
    PHANDLE Handle
    )

/*++

Routine Description:

    This routine opens the raw disk for read/write.

Arguments:

    Handle - returns the Handle if successful, for use in subsequent calls.

Return Value:

    The status return from the ZwOpenFile.

--*/

{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING physicalDriveString;
    IO_STATUS_BLOCK ioStatus;

    RtlInitUnicodeString(&physicalDriveString, L"\\Device\\Harddisk0\\Partition0");

    InitializeObjectAttributes(
        &objectAttributes,
        &physicalDriveString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL);

    status = ZwOpenFile(
                 Handle,
                 FILE_READ_DATA | FILE_WRITE_DATA | SYNCHRONIZE,
                 &objectAttributes,
                 &ioStatus,
                 FILE_SHARE_READ | FILE_SHARE_WRITE,
                 FILE_SYNCHRONOUS_IO_NONALERT);

    if ((!NT_SUCCESS(status)) || (!NT_SUCCESS(ioStatus.Status))) {

        KdPrint(("RdrOpenRawDisk: status on ZwOpenFile: %x, %x\n", status, ioStatus.Status));
        if (NT_SUCCESS(status)) {
            status = ioStatus.Status;
        }

    }

    return status;

}


NTSTATUS
RdrCloseRawDisk(
    HANDLE Handle
    )

/*++

Routine Description:

    This routine closes the raw disk.

Arguments:

    Handle - The Handle returned by RdrOpenRawDisk.

Return Value:

    The status return from the ZwClose.

--*/

{

    return ZwClose(Handle);

}


NTSTATUS
RdrCheckForFreeSectors (
    HANDLE Handle
    )

/*++

Routine Description:

    This routine makes sure that the MBR looks correct and that there
    is nothing installed (OnTrack or EZ-Drive need to detect
    NT fault-tolerance also) that would prevent us from using the third
    sector for storing the password secret.

Arguments:

    Handle - The Handle returned by RdrOpenRawDisk.

Return Value:

    ESUCCESS if the disk is OK, or an error.

--*/

{

    NTSTATUS status;
    USHORT Sector[256];
    ULONG BytesRead;
    PPARTITION_DESCRIPTOR Partition;
    LARGE_INTEGER SeekPosition;
    IO_STATUS_BLOCK ioStatus;


    SeekPosition.QuadPart = 0;

    //
    // Read the MBR at the start of the disk.
    //

    status = ZwReadFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &ioStatus,
                 Sector,
                 512,
                 &SeekPosition,
                 NULL);

    if ((!NT_SUCCESS(status)) || (!NT_SUCCESS(ioStatus.Status))) {

        KdPrint(("RdrCheckForFreeSectors: status on ZwReadFile: %x, %x\n", status, ioStatus.Status));
        if (NT_SUCCESS(status)) {
            status = ioStatus.Status;
        }
        return status;

    }

#if 0
    RdrpDumpSector((PUCHAR)Sector);
#endif

    //
    // Make sure the signature is OK, and that the type of partition
    // 0 is not 0x54 (OnTrack) or 0x55 (EZ-Drive).
    //

    if (Sector[BOOT_SIGNATURE_OFFSET] != BOOT_RECORD_SIGNATURE) {

        KdPrint(("RdrCheckForFreeSectors: Boot record signature %x not found (%x found)\n",
                BOOT_RECORD_SIGNATURE,
                Sector[BOOT_SIGNATURE_OFFSET] ));
        return STATUS_INVALID_PARAMETER;
    }

    Partition = (PPARTITION_DESCRIPTOR)&Sector[PARTITION_TABLE_OFFSET];

    if ((Partition->PartitionType == 0x54) ||
        (Partition->PartitionType == 0x55)) {

        KdPrint(("RdrCheckForFreeSectors: First partition has type %x, exiting\n", Partition->PartitionType));
        return STATUS_INVALID_PARAMETER;
    }

    KdPrint(("RdrCheckForFreeSectors: Partition type is %d\n", Partition->PartitionType));

    return STATUS_SUCCESS;

}


NTSTATUS
RdrReadSecret(
    HANDLE Handle,
    PRI_SECRET Secret
    )

/*++

Routine Description:

    This routine reads the secret from the disk, if present.

Arguments:

    Handle - The Handle returned by RdrOpenRawDisk.

Return Value:

    ESUCCESS if the secret is OK, an error otherwise.

--*/

{

    NTSTATUS status;
    ULONG BytesRead;
    LARGE_INTEGER SeekPosition;
    IO_STATUS_BLOCK ioStatus;
    UCHAR Sector[512];


    //
    // Seek to the third sector.

    // DEADISSUE 08/08/2000 -- this is in an #ifdef REMOTE_BOOT block,
    // which is dead code, left here in case it is ever resuurected:
    // I am pretty sure we can assume that the first disk has 512-byte sectors.
    //

    SeekPosition.QuadPart = 2 * 512;

    //
    // Read a full sector. The secret is at the beginning.
    //

    status = ZwReadFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &ioStatus,
                 Sector,
                 512,
                 &SeekPosition,
                 NULL);

    if ((!NT_SUCCESS(status)) || (!NT_SUCCESS(ioStatus.Status))) {

        KdPrint(("RdrReadSecret: status on ZwReadFile: %x, %x\n", status, ioStatus.Status));
        if (NT_SUCCESS(status)) {
            status = ioStatus.Status;
        }
        return status;

    }

    RtlMoveMemory(Secret, Sector, sizeof(RI_SECRET));

    if (memcmp(Secret->Signature, RI_SECRET_SIGNATURE, 4) != 0) {

        KdPrint(("RdrReadSecret: No signature found\n"));
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;

}



NTSTATUS
RdrWriteSecret(
    HANDLE Handle,
    PRI_SECRET Secret
    )

/*++

Routine Description:

    This routine writes the secret to the disk.

Arguments:

    Handle - The Handle returned by RdrOpenRawDisk.

Return Value:

    ESUCCESS if the secret is written OK, an error otherwise.

--*/

{

    NTSTATUS status;
    ULONG BytesWritten;
    LARGE_INTEGER SeekPosition;
    IO_STATUS_BLOCK ioStatus;
    UCHAR Sector[512];


    //
    // Seek to the third sector.
    //

    SeekPosition.QuadPart = 2 * 512;

    //
    // Copy the secret to a full sector since the raw disk requires
    // reads/writes in sector multiples.
    //

    RtlZeroMemory(Sector, sizeof(Sector));
    RtlMoveMemory(Sector, Secret, sizeof(RI_SECRET));

    //
    // Write a secret-sized chunk.
    //

    status = ZwWriteFile(
                 Handle,
                 NULL,
                 NULL,
                 NULL,
                 &ioStatus,
                 Sector,
                 512,
                 &SeekPosition,
                 NULL);

    if ((!NT_SUCCESS(status)) || (!NT_SUCCESS(ioStatus.Status))) {

        KdPrint(("RdrWriteSecret: status on ZwWriteFile: %x, %x\n", status, ioStatus.Status));
        if (NT_SUCCESS(status)) {
            status = ioStatus.Status;
        }
        return status;

    }

    return STATUS_SUCCESS;

}



VOID
RdrInitializeSecret(
    IN PUCHAR Domain,
    IN PUCHAR User,
    IN PUCHAR LmOwfPassword1,
    IN PUCHAR NtOwfPassword1,
    IN PUCHAR LmOwfPassword2 OPTIONAL,
    IN PUCHAR NtOwfPassword2 OPTIONAL,
    IN PUCHAR Sid,
    IN OUT PRI_SECRET Secret
    )
{
    int Length;
    int i;
    struct RC4_KEYSTRUCT Key;

    memset(Secret, 0, sizeof(RI_SECRET));

    memcpy(Secret->Signature, RI_SECRET_SIGNATURE, 4);
    Secret->Version = 1;

    Length = strlen(Domain);
    memcpy(Secret->Domain, Domain, Length);

    Length = strlen(User);
    memcpy(Secret->User, User, Length);

    memcpy(Secret->Sid, Sid, RI_SECRET_SID_SIZE);

    //
    // Encrypt the passwords using the user name.
    //

#ifdef RDR_USE_LM_PASSWORD
    memcpy(Secret->LmEncryptedPassword1, LmOwfPassword1, LM_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, LM_OWF_PASSWORD_SIZE, Secret->LmEncryptedPassword1);

    if (LmOwfPassword2 != NULL) {
        memcpy(Secret->LmEncryptedPassword2, LmOwfPassword2, LM_OWF_PASSWORD_SIZE);
        rc4_key(&Key, strlen(User), User);
        rc4(&Key, LM_OWF_PASSWORD_SIZE, Secret->LmEncryptedPassword2);
    }
#endif

    memcpy(Secret->NtEncryptedPassword1, NtOwfPassword1, NT_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, NT_OWF_PASSWORD_SIZE, Secret->NtEncryptedPassword1);

    if (NtOwfPassword2 != NULL) {
        memcpy(Secret->NtEncryptedPassword2, NtOwfPassword2, NT_OWF_PASSWORD_SIZE);
        rc4_key(&Key, strlen(User), User);
        rc4(&Key, NT_OWF_PASSWORD_SIZE, Secret->NtEncryptedPassword2);
    }

}
#endif // defined(REMOTE_BOOT)



VOID
RdrParseSecret(
    IN OUT PUCHAR Domain,
    IN OUT PUCHAR User,
    IN OUT PUCHAR LmOwfPassword1,
    IN OUT PUCHAR NtOwfPassword1,
#if defined(REMOTE_BOOT)
    IN OUT PUCHAR LmOwfPassword2,
    IN OUT PUCHAR NtOwfPassword2,
#endif // defined(REMOTE_BOOT)
    IN OUT PUCHAR Sid,
    IN PRI_SECRET Secret
    )
{
    struct RC4_KEYSTRUCT Key;

    memcpy(Domain, Secret->Domain, RI_SECRET_DOMAIN_SIZE);
    Domain[RI_SECRET_DOMAIN_SIZE] = '\0';

    memcpy(User, Secret->User, RI_SECRET_USER_SIZE);
    User[RI_SECRET_USER_SIZE] = '\0';

    memcpy(Sid, Secret->Sid, RI_SECRET_SID_SIZE);

    //
    // Decrypt the passwords using the user name.
    //

#ifdef RDR_USE_LM_PASSWORD
    memcpy(LmOwfPassword1, Secret->LmEncryptedPassword1, LM_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, LM_OWF_PASSWORD_SIZE, LmOwfPassword1);

#if defined(REMOTE_BOOT)
    memcpy(LmOwfPassword2, Secret->LmEncryptedPassword2, LM_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, LM_OWF_PASSWORD_SIZE, LmOwfPassword2);
#endif // defined(REMOTE_BOOT)
#else
    memset(LmOwfPassword1, 0, LM_OWF_PASSWORD_SIZE);
#if defined(REMOTE_BOOT)
    memset(LmOwfPassword2, 0, LM_OWF_PASSWORD_SIZE);
#endif // defined(REMOTE_BOOT)
#endif

    memcpy(NtOwfPassword1, Secret->NtEncryptedPassword1, NT_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, NT_OWF_PASSWORD_SIZE, NtOwfPassword1);

#if defined(REMOTE_BOOT)
    memcpy(NtOwfPassword2, Secret->NtEncryptedPassword2, NT_OWF_PASSWORD_SIZE);
    rc4_key(&Key, strlen(User), User);
    rc4(&Key, NT_OWF_PASSWORD_SIZE, NtOwfPassword2);
#endif // defined(REMOTE_BOOT)

}



#if defined(REMOTE_BOOT)
VOID
RdrOwfPassword(
    IN PUNICODE_STRING Password,
    IN OUT PUCHAR LmOwfPassword,
    IN OUT PUCHAR NtOwfPassword
    )
{
    char TmpText[CLEAR_BLOCK_LENGTH*2];
    char TmpChar;
    int Length;
    int i;

#ifdef RDR_USE_LM_PASSWORD
    Length = Password.Length / sizeof(WCHAR);

    //
    // Convert the password to an upper-case ANSI buffer.
    //

    if (Length == 0) {
        TmpText[0] = '\0';
    } else {
        for (i = 0; i <= Length; i++) {
            wctomb(&TmpChar, Password.Buffer[i]);
            TmpText[i] = toupper(TmpChar);
        }
    }

    RtlCalculateLmOwfPassword((PLM_PASSWORD)TmpText, (PLM_OWF_PASSWORD)LmOwfPassword);
#else
    memset(LmOwfPassword, 0, LM_OWF_PASSWORD_SIZE);
#endif

    RtlCalculateNtOwfPassword(Password, (PNT_OWF_PASSWORD)NtOwfPassword);

    RtlSecureZeroMemory(TmpText, sizeof(TmpText));
}
#endif // defined(REMOTE_BOOT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\support.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        support.cxx
//
// Contents:    support routines for ksecdd.sys
//
//
// History:     3-7-94      Created     MikeSw
//              12-15-97    Modified from private\lsa\client\ssp   AdamBa
//
//------------------------------------------------------------------------

#include <rdrssp.h>



//+-------------------------------------------------------------------------
//
//  Function:   SecAllocate
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID * SEC_ENTRY
SecAllocate(ULONG cbMemory)
{
    return(ExAllocatePool(NonPagedPool, cbMemory));
}



//+-------------------------------------------------------------------------
//
//  Function:   SecFree
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


void SEC_ENTRY
SecFree(PVOID pvMemory)
{
    ExFreePool(pvMemory);
}



//+-------------------------------------------------------------------------
//
//  Function:   MapSecurityErrorK
//
//  Synopsis:   maps a HRESULT from the security interface to a NTSTATUS
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS SEC_ENTRY
MapSecurityErrorK(HRESULT Error)
{
    return((NTSTATUS) Error);
}


//+-------------------------------------------------------------------------
//
//  Function:   GetTokenBuffer
//
//  Synopsis:
//
//    This routine parses a Token Descriptor and pulls out the useful
//    information.
//
//  Effects:
//
//  Arguments:
//
//    TokenDescriptor - Descriptor of the buffer containing (or to contain) the
//        token. If not specified, TokenBuffer and TokenSize will be returned
//        as NULL.
//
//    BufferIndex - Index of the token buffer to find (0 for first, 1 for
//        second).
//
//    TokenBuffer - Returns a pointer to the buffer for the token.
//
//    TokenSize - Returns a pointer to the location of the size of the buffer.
//
//    ReadonlyOK - TRUE if the token buffer may be readonly.
//
//  Requires:
//
//  Returns:
//
//    TRUE - If token buffer was properly found.
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
GetTokenBuffer(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PVOID * TokenBuffer,
    OUT PULONG TokenSize,
    IN BOOLEAN ReadonlyOK
    )
{
    ULONG i, Index = 0;

    //
    // If there is no TokenDescriptor passed in,
    //  just pass out NULL to our caller.
    //

    if ( !ARGUMENT_PRESENT( TokenDescriptor) ) {
        *TokenBuffer = NULL;
        *TokenSize = 0;
        return TRUE;
    }

    //
    // Check the version of the descriptor.
    //

    if ( TokenDescriptor->ulVersion != SECBUFFER_VERSION ) {
        return FALSE;
    }

    //
    // Loop through each described buffer.
    //

    for ( i=0; i<TokenDescriptor->cBuffers ; i++ ) {
        PSecBuffer Buffer = &TokenDescriptor->pBuffers[i];
        if ( (Buffer->BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_TOKEN ) {

            //
            // If the buffer is readonly and readonly isn't OK,
            //  reject the buffer.
            //

            if ( !ReadonlyOK && (Buffer->BufferType & SECBUFFER_READONLY) ) {
                return FALSE;
            }

            if (Index != BufferIndex)
            {
                Index++;
                continue;
            }

            //
            // Return the requested information
            //

            *TokenBuffer = Buffer->pvBuffer;
            *TokenSize = Buffer->cbBuffer;
            return TRUE;
        }

    }

    return FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetSecurityToken
//
//  Synopsis:
//    This routine parses a Token Descriptor and pulls out the useful
//    information.
//
//  Effects:
//
//  Arguments:
//    TokenDescriptor - Descriptor of the buffer containing (or to contain) the
//        token. If not specified, TokenBuffer and TokenSize will be returned
//        as NULL.
//
//    BufferIndex - Index of the token buffer to find (0 for first, 1 for
//        second).
//
//    TokenBuffer - Returns a pointer to the buffer for the token.
//
//  Requires:
//
//  Returns:
//
//    TRUE - If token buffer was properly found.
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
GetSecurityToken(
    IN PSecBufferDesc TokenDescriptor OPTIONAL,
    IN ULONG BufferIndex,
    OUT PSecBuffer * TokenBuffer
    )
{
    ULONG i;
    ULONG Index = 0;

    PAGED_CODE();

    //
    // If there is no TokenDescriptor passed in,
    //  just pass out NULL to our caller.
    //

    if ( !ARGUMENT_PRESENT( TokenDescriptor) ) {
        *TokenBuffer = NULL;
        return TRUE;
    }

    //
    // Check the version of the descriptor.
    //

    if ( TokenDescriptor->ulVersion != SECBUFFER_VERSION ) {
        return FALSE;
    }

    //
    // Loop through each described buffer.
    //

    for ( i=0; i<TokenDescriptor->cBuffers ; i++ ) {
        PSecBuffer Buffer = &TokenDescriptor->pBuffers[i];
        if ( (Buffer->BufferType & (~SECBUFFER_ATTRMASK)) == SECBUFFER_TOKEN ) {

            //
            // If the buffer is readonly and readonly isn't OK,
            //  reject the buffer.
            //

            if ( Buffer->BufferType & SECBUFFER_READONLY ) {
                return FALSE;
            }

            if (Index != BufferIndex)
            {
                Index++;
                continue;
            }
            //
            // Return the requested information
            //

            *TokenBuffer = Buffer;
            return TRUE;
        }

    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\stubs.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        stubs.cxx
//
// Contents:    user-mode stubs for security API
//
//
// History:     3/5/94      MikeSw      Created
//              12/15/97    AdamBa      Modified from security\lsa\security\ntlm
//
//------------------------------------------------------------------------

#include <rdrssp.h>

#include <nturtl.h>
#include <align.h>
#include "nlp.h"


static CredHandle NullCredential = {0,0};

#define NTLMSSP_REQUIRED_NEGOTIATE_FLAGS (  NTLMSSP_NEGOTIATE_UNICODE | \
                                            NTLMSSP_REQUEST_INIT_RESPONSE )

NTSTATUS
MspLm20GetChallengeResponse (
    IN PVOID ProtocolSubmitBuffer,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    IN BOOLEAN OwfPasswordProvided
    );


//+-------------------------------------------------------------------------
//
//  Function:   AcquireCredentialsHandleK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



SECURITY_STATUS SEC_ENTRY
AcquireCredentialsHandleK(
    PSECURITY_STRING            pssPrincipal,       // Name of principal
    PSECURITY_STRING            pssPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    )
{
    SECURITY_STATUS scRet;
    SECURITY_STRING Principal;
    TimeStamp   OptionalTimeStamp;
    UNICODE_STRING PackageName;
    PMS_LOGON_CREDENTIAL LogonCredential;

    if (!pssPackageName)
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

    //
    // We don't accept principal names either.
    //

    if (pssPrincipal)
    {
        return(SEC_E_UNKNOWN_CREDENTIALS);
    }


    //
    // Make sure they want the NTLM security package
    //
    RtlInitUnicodeString(
        &PackageName,
        NTLMSP_NAME
        );


    if (!RtlEqualUnicodeString(
            pssPackageName,
            &PackageName,
            TRUE))
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

#if 0
    //
    // For the moment, only accept OWF passwords. This is the
    // easiest for now since there is no place to record the
    // flag otherwise. The password provided is assumed to
    // be the LM and NT OWF passwords concatenated together.
    //

    if ((fCredentialUse & SECPKG_CRED_OWF_PASSWORD) == 0) {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }
#endif

    //
    // The credential handle is the logon id
    //

    if (fCredentialUse & SECPKG_CRED_OUTBOUND)
    {
        if (pvLogonId != NULL)
        {
            LogonCredential = (PMS_LOGON_CREDENTIAL)SecAllocate(sizeof(MS_LOGON_CREDENTIAL));

            if (LogonCredential == NULL) {
                return(SEC_E_INSUFFICIENT_MEMORY);
            }

            LogonCredential->LogonId = *((PLUID)pvLogonId);
            LogonCredential->CredentialUse = fCredentialUse;

            *(PMS_LOGON_CREDENTIAL *)phCredential = LogonCredential;
        }
        else
        {
            return(SEC_E_UNKNOWN_CREDENTIALS);
        }

    }
    else if (fCredentialUse & SECPKG_CRED_INBOUND)
    {
        //
        // For inbound credentials, we will accept a logon id but
        // we don't require it.
        //

        if (pvLogonId != NULL)
        {
            LogonCredential = (PMS_LOGON_CREDENTIAL)SecAllocate(sizeof(MS_LOGON_CREDENTIAL));

            if (LogonCredential == NULL) {
                return(SEC_E_INSUFFICIENT_MEMORY);
            }

            LogonCredential->LogonId = *((PLUID)pvLogonId);
            LogonCredential->CredentialUse = fCredentialUse;
            *(PMS_LOGON_CREDENTIAL *)phCredential = LogonCredential;
        }
        else
        {
            *phCredential = NullCredential;
        }

    }
    else
    {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }


    return(SEC_E_OK);

}



//+-------------------------------------------------------------------------
//
//  Function:   FreeCredentialsHandleK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
FreeCredentialsHandleK(
    PCredHandle                 phCredential        // Handle to free
    )
{
    if ((phCredential != NULL) && (!RtlEqualMemory(phCredential, &NullCredential, sizeof(NullCredential)))) {

        PMS_LOGON_CREDENTIAL LogonCredential = *((PMS_LOGON_CREDENTIAL *)phCredential);

        if (LogonCredential != NULL) {
            SecFree(LogonCredential);
            *phCredential = NullCredential;
        }

    }

    return(SEC_E_OK);
}


VOID
PutString(
    OUT PSTRING32 Destination,
    IN PSTRING Source,
    IN PVOID Base,
    IN OUT PUCHAR * Where
    )
{
    Destination->Buffer = (ULONG)((ULONG_PTR) *Where - (ULONG_PTR) Base);
    Destination->Length =
        Source->Length;
    Destination->MaximumLength =
        Source->Length;

    RtlCopyMemory(
        *Where,
        Source->Buffer,
        Source->Length
        );
    *Where += Source->Length;
}


//+-------------------------------------------------------------------------
//
//  Function:   InitializeSecurityContextK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
InitializeSecurityContextK(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSECURITY_STRING            pssTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    )
{
    SECURITY_STATUS scRet;
    PMSV1_0_GETCHALLENRESP_REQUEST ChallengeRequest = NULL;
    ULONG ChallengeRequestSize;
    PMSV1_0_GETCHALLENRESP_RESPONSE ChallengeResponse = NULL;
    ULONG ChallengeResponseSize;
    PCHALLENGE_MESSAGE ChallengeMessage = NULL;
    ULONG ChallengeMessageSize;
    PNTLM_CHALLENGE_MESSAGE NtlmChallengeMessage = NULL;
    ULONG NtlmChallengeMessageSize;
    PAUTHENTICATE_MESSAGE AuthenticateMessage = NULL;
    ULONG AuthenticateMessageSize;
    PNTLM_INITIALIZE_RESPONSE NtlmInitializeResponse = NULL;
    UNICODE_STRING PasswordToUse;
    UNICODE_STRING UserNameToUse;
    UNICODE_STRING DomainNameToUse;
    ULONG ParameterControl = USE_PRIMARY_PASSWORD |
                                RETURN_PRIMARY_USERNAME |
                                RETURN_PRIMARY_LOGON_DOMAINNAME;

    NTSTATUS FinalStatus = STATUS_SUCCESS;
    PUCHAR Where;
    PSecBuffer AuthenticationToken = NULL;
    PSecBuffer InitializeResponseToken = NULL;
    BOOLEAN UseSuppliedCreds = FALSE;


    RtlInitUnicodeString(
        &PasswordToUse,
        NULL
        );

    RtlInitUnicodeString(
        &UserNameToUse,
        NULL
        );

    RtlInitUnicodeString(
        &DomainNameToUse,
        NULL
        );

    //
    // Check for valid sizes, pointers, etc.:
    //


    if (!phCredential)
    {
        return(SEC_E_INVALID_HANDLE);
    }


    //
    // Locate the buffers with the input data
    //

    if (!GetTokenBuffer(
            pInput,
            0,          // get the first security token
            (PVOID *) &ChallengeMessage,
            &ChallengeMessageSize,
            TRUE        // may be readonly
            ))
    {
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // If we are using supplied creds, get them now too.
    //


    if (fContextReq & ISC_REQ_USE_SUPPLIED_CREDS)
    {
        if (!GetTokenBuffer(
            pInput,
            1,          // get the second security token
            (PVOID *) &NtlmChallengeMessage,
            &NtlmChallengeMessageSize,
            TRUE        // may be readonly
            ))
        {
            scRet = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }
        else
        {
            UseSuppliedCreds = TRUE;
        }

    }

    //
    // Get the output tokens
    //

    if (!GetSecurityToken(
            pOutput,
            0,
            &AuthenticationToken) ||
        !GetSecurityToken(
            pOutput,
            1,
            &InitializeResponseToken ) )
    {
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Make sure the sizes are o.k.
    //

    if ((ChallengeMessageSize < sizeof(CHALLENGE_MESSAGE)) ||
        (UseSuppliedCreds &&
            !(NtlmChallengeMessageSize < sizeof(NTLM_CHALLENGE_MESSAGE))))
    {
        scRet = SEC_E_INVALID_TOKEN;
    }

    //
    // Make sure the caller wants us to allocate memory:
    //

    if (!(fContextReq & ISC_REQ_ALLOCATE_MEMORY))
    {
        scRet = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

   //
   // KB: allow calls requesting PROMPT_FOR_CREDS to go through.
   // We won't prompt, but we will setup a context properly.
   // This is OK because PROMPT_FOR_CREDS flag doesnt' do anything
   // in the NTLM package
   //

//    if ((fContextReq & ISC_REQ_PROMPT_FOR_CREDS) != 0)
//    {
//        scRet = SEC_E_UNSUPPORTED_FUNCTION;
//        goto Cleanup;
//    }

    //
    // Verify the validity of the challenge message.
    //

    if (strncmp(
            ChallengeMessage->Signature,
            NTLMSSP_SIGNATURE,
            sizeof(NTLMSSP_SIGNATURE)))
    {
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if (ChallengeMessage->MessageType != NtLmChallenge)
    {
        scRet = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if ((ChallengeMessage->NegotiateFlags & NTLMSSP_REQUIRED_NEGOTIATE_FLAGS) !=
        NTLMSSP_REQUIRED_NEGOTIATE_FLAGS)
    {
        scRet = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    if ((ChallengeMessage->NegotiateFlags & NTLMSSP_REQUEST_NON_NT_SESSION_KEY) != 0)
    {
        ParameterControl |= RETURN_NON_NT_USER_SESSION_KEY;
    }

    if ((fContextReq & ISC_REQ_USE_SUPPLIED_CREDS) != 0)
    {
        if ( NtlmChallengeMessage->Password.Buffer != 0)
        {
            ParameterControl &= ~USE_PRIMARY_PASSWORD;
            PasswordToUse.Length = NtlmChallengeMessage->Password.Length;
            PasswordToUse.MaximumLength = NtlmChallengeMessage->Password.MaximumLength;
            PasswordToUse.Buffer = (LPWSTR) (NtlmChallengeMessage->Password.Buffer +
                                              (PCHAR) NtlmChallengeMessage);
        }

        if (NtlmChallengeMessage->UserName.Length != 0)
        {
            UserNameToUse.Length = NtlmChallengeMessage->UserName.Length;
            UserNameToUse.MaximumLength = NtlmChallengeMessage->UserName.MaximumLength;
            UserNameToUse.Buffer = (LPWSTR) (NtlmChallengeMessage->UserName.Buffer +
                                              (PCHAR) NtlmChallengeMessage);
            ParameterControl &= ~RETURN_PRIMARY_USERNAME;
        }
        if (NtlmChallengeMessage->DomainName.Length != 0)
        {
            DomainNameToUse.Length = NtlmChallengeMessage->DomainName.Length;
            DomainNameToUse.MaximumLength = NtlmChallengeMessage->DomainName.MaximumLength;
            DomainNameToUse.Buffer = (LPWSTR) (NtlmChallengeMessage->DomainName.Buffer +
                                              (PCHAR) NtlmChallengeMessage);
            ParameterControl &= ~RETURN_PRIMARY_LOGON_DOMAINNAME;
        }

    }

    //
    // Package up the parameter for a call to the LSA.
    //

    ChallengeRequestSize = sizeof(MSV1_0_GETCHALLENRESP_REQUEST) +
                                PasswordToUse.Length + UserNameToUse.Length + DomainNameToUse.Length;

    ChallengeRequest = SecAllocate(ChallengeRequestSize);
    if (ChallengeRequest == NULL) {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }


    //
    // Build the challenge request message.
    //

    ChallengeRequest->MessageType = MsV1_0Lm20GetChallengeResponse;
    ChallengeRequest->ParameterControl = ParameterControl;
    if (RtlEqualMemory(phCredential, &NullCredential, sizeof(NullCredential))) {
        ChallengeRequest->LogonId = *((PLUID)&NullCredential);
    } else {
        ChallengeRequest->LogonId = (*((PMS_LOGON_CREDENTIAL *)phCredential))->LogonId;
    }
    RtlCopyMemory(
        ChallengeRequest->ChallengeToClient,
        ChallengeMessage->Challenge,
        MSV1_0_CHALLENGE_LENGTH
        );
    if ((ParameterControl & USE_PRIMARY_PASSWORD) == 0)
    {
        //
        // We assume the user specified SECPKG_CRED_OWF_PASSWORD when
        // AcquireSecurityContext was called, so the password is the
        // LM and NT OWF passwords concatenated together.
        //
        ChallengeRequest->Password.Buffer = (LPWSTR) (ChallengeRequest + 1);
        RtlCopyMemory(
            ChallengeRequest->Password.Buffer,
            PasswordToUse.Buffer,
            PasswordToUse.Length
            );
        ChallengeRequest->Password.Length = PasswordToUse.Length;
        ChallengeRequest->Password.MaximumLength = PasswordToUse.Length;

        //
        // need user name in NTLMv2
        //

        ChallengeRequest->UserName.Buffer = (PWSTR) (((UCHAR*) ChallengeRequest->Password.Buffer)
                          + ChallengeRequest->Password.MaximumLength);

        RtlCopyMemory(
            ChallengeRequest->UserName.Buffer,
            UserNameToUse.Buffer,
            UserNameToUse.Length
            );
        ChallengeRequest->UserName.Length = UserNameToUse.Length;
        ChallengeRequest->UserName.MaximumLength = UserNameToUse.Length;

        //
        // need logon domain in NTLMv2
        //

        ChallengeRequest->LogonDomainName.Buffer = (PWSTR) (((UCHAR*) ChallengeRequest->UserName.Buffer)
                  + ChallengeRequest->UserName.MaximumLength);

        RtlCopyMemory(
            ChallengeRequest->LogonDomainName.Buffer,
            DomainNameToUse.Buffer,
            DomainNameToUse.Length
            );
        ChallengeRequest->LogonDomainName.Length = DomainNameToUse.Length;
        ChallengeRequest->LogonDomainName.MaximumLength = DomainNameToUse.Length;
    }

    FinalStatus = MspLm20GetChallengeResponse(
                      ChallengeRequest,
                      ChallengeRequestSize,
                      &ChallengeResponse,
                      &ChallengeResponseSize,
                      (BOOLEAN)((RtlEqualMemory(phCredential, &NullCredential, sizeof(NullCredential))) ?
                                TRUE :
                                ((*((PMS_LOGON_CREDENTIAL *)phCredential))->CredentialUse & SECPKG_CRED_OWF_PASSWORD) != 0x0)
                      );

    if (!NT_SUCCESS(FinalStatus))
    {
        scRet = FinalStatus;
        goto Cleanup;
    }

    ASSERT(ChallengeResponse->MessageType == MsV1_0Lm20GetChallengeResponse);
    //
    // Now prepare the output message.
    //

    if (UserNameToUse.Buffer == NULL)
    {
        UserNameToUse = ChallengeResponse->UserName;
    }
    if (DomainNameToUse.Buffer == NULL)
    {
        DomainNameToUse = ChallengeResponse->LogonDomainName;
    }

    AuthenticateMessageSize = sizeof(AUTHENTICATE_MESSAGE) +
                                UserNameToUse.Length +
                                DomainNameToUse.Length +
                                ChallengeResponse->CaseSensitiveChallengeResponse.Length +
                                ChallengeResponse->CaseInsensitiveChallengeResponse.Length;

    AuthenticateMessage = (PAUTHENTICATE_MESSAGE) SecAllocate(AuthenticateMessageSize);
    if (AuthenticateMessage == NULL)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }

    Where = (PUCHAR) (AuthenticateMessage + 1);
    RtlCopyMemory(
        AuthenticateMessage->Signature,
        NTLMSSP_SIGNATURE,
        sizeof(NTLMSSP_SIGNATURE)
        );
    AuthenticateMessage->MessageType = NtLmAuthenticate;

    PutString(
        &AuthenticateMessage->LmChallengeResponse,
        &ChallengeResponse->CaseInsensitiveChallengeResponse,
        AuthenticateMessage,
        &Where
        );

    PutString(
        &AuthenticateMessage->NtChallengeResponse,
        &ChallengeResponse->CaseSensitiveChallengeResponse,
        AuthenticateMessage,
        &Where
        );

    PutString(
        &AuthenticateMessage->DomainName,
        (PSTRING) &DomainNameToUse,
        AuthenticateMessage,
        &Where
        );

    PutString(
        &AuthenticateMessage->UserName,
        (PSTRING) &UserNameToUse,
        AuthenticateMessage,
        &Where
        );

    //
    // KB. no workstation name to fill in.  This is
    // OK because the workstation name is only used
    // in loopback detection, and this is not relevant
    // to this implementation of NTLM.
    //

    AuthenticateMessage->Workstation.Length = 0;
    AuthenticateMessage->Workstation.MaximumLength = 0;
    AuthenticateMessage->Workstation.Buffer = 0;


    //
    // Build the initialize response.
    //

    NtlmInitializeResponse = (PNTLM_INITIALIZE_RESPONSE) SecAllocate(sizeof(NTLM_INITIALIZE_RESPONSE));
    if (NtlmInitializeResponse == NULL)
    {
        scRet = SEC_E_INSUFFICIENT_MEMORY;
        goto Cleanup;
    }


    RtlCopyMemory(
        NtlmInitializeResponse->UserSessionKey,
        ChallengeResponse->UserSessionKey,
        MSV1_0_USER_SESSION_KEY_LENGTH
        );

    RtlCopyMemory(
        NtlmInitializeResponse->LanmanSessionKey,
        ChallengeResponse->LanmanSessionKey,
        MSV1_0_LANMAN_SESSION_KEY_LENGTH
        );

    //
    // Fill in the output buffers now.
    //

    AuthenticationToken->pvBuffer = AuthenticateMessage;
    AuthenticationToken->cbBuffer = AuthenticateMessageSize;
    InitializeResponseToken->pvBuffer = NtlmInitializeResponse;
    InitializeResponseToken->cbBuffer = sizeof(NTLM_INITIALIZE_RESPONSE);


    //
    // Make a local context for this
    //

    scRet = NtlmInitKernelContext(
                NtlmInitializeResponse->UserSessionKey,
                NtlmInitializeResponse->LanmanSessionKey,
                NULL,           // no token,
                phNewContext
                );

    if (!NT_SUCCESS(scRet))
    {
        goto Cleanup;
    }
    scRet = SEC_E_OK;




Cleanup:

    if (ChallengeRequest != NULL)
    {
        SecFree(ChallengeRequest);
    }

    if (ChallengeResponse != NULL)
    {
        ExFreePool( ChallengeResponse );
    }

    if (!NT_SUCCESS(scRet))
    {
        if (AuthenticateMessage != NULL)
        {
            SecFree(AuthenticateMessage);
        }
        if (NtlmInitializeResponse != NULL)
        {
            SecFree(NtlmInitializeResponse);
        }
    }
    return(scRet);
}




//+-------------------------------------------------------------------------
//
//  Function:   DeleteSecurityContextK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
DeleteSecurityContextK(
    PCtxtHandle                 phContext          // Context to delete
    )
{
    SECURITY_STATUS     scRet;

    // For now, just delete the LSA context:

    if (!phContext)
    {
        return(SEC_E_INVALID_HANDLE);
    }

    scRet = NtlmDeleteKernelContext(phContext);


    return(scRet);

}


#if 0

//+-------------------------------------------------------------------------
//
//  Function:   EnumerateSecurityPackagesK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



SECURITY_STATUS SEC_ENTRY
EnumerateSecurityPackagesK(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfo SEC_FAR *       ppPackageInfo       // Receives array of info
    )
{
    ULONG PackageInfoSize;
    PSecPkgInfoW PackageInfo = NULL;
    PUCHAR Where;

    //
    // Figure out the size of the returned data
    //

    PackageInfoSize = sizeof(SecPkgInfoW) +
                        sizeof(NTLMSP_NAME) +
                        sizeof(NTLMSP_COMMENT);

    PackageInfo = (PSecPkgInfoW) SecAllocate(PackageInfoSize);

    if (PackageInfo == NULL)
    {
        return(SEC_E_INSUFFICIENT_MEMORY);
    }

    //
    // Fill in the fixed length fields
    //

    PackageInfo->fCapabilities = SECPKG_FLAG_CONNECTION |
                                 SECPKG_FLAG_TOKEN_ONLY;
    PackageInfo->wVersion = NTLMSP_VERSION;
    PackageInfo->wRPCID = NTLMSP_RPCID;
    PackageInfo->cbMaxToken = NTLMSSP_MAX_MESSAGE_SIZE;

    //
    // Fill in the fields
    //

    Where = (PUCHAR) (PackageInfo+1);
    PackageInfo->Name = (LPWSTR) Where;
    RtlCopyMemory(
        PackageInfo->Name,
        NTLMSP_NAME,
        sizeof(NTLMSP_NAME)
        );
    Where += sizeof(NTLMSP_NAME);

    PackageInfo->Comment = (LPWSTR) Where;
    RtlCopyMemory(
        PackageInfo->Comment,
        NTLMSP_COMMENT,
        sizeof(NTLMSP_COMMENT)
        );
    Where += sizeof(NTLMSP_COMMENT);


    *pcPackages = 1;
    *ppPackageInfo = PackageInfo;
    return(SEC_E_OK);
}



//+-------------------------------------------------------------------------
//
//  Function:   QuerySecurityPackageInfoK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS SEC_ENTRY
QuerySecurityPackageInfoK(
    PSECURITY_STRING pssPackageName,    // Name of package
    PSecPkgInfo * ppPackageInfo         // Receives package info
    )
{

    UNICODE_STRING PackageName;
    ULONG PackageCount;

    RtlInitUnicodeString(
        &PackageName,
        NTLMSP_NAME
        );


    if (!RtlEqualUnicodeString(
            pssPackageName,
            &PackageName,
            TRUE                    // case insensitive
            ))
    {
        return(SEC_E_SECPKG_NOT_FOUND);
    }

    return(EnumerateSecurityPackagesK(&PackageCount,ppPackageInfo));

}

#endif


//+-------------------------------------------------------------------------
//
//  Function:   FreeContextBufferK
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
FreeContextBufferK(
    void SEC_FAR *      pvContextBuffer
    )
{
    SecFree(pvContextBuffer);

    return(SEC_E_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\umt_stff\umt_stff.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    startrx.c

Abstract:

    This module contains the support routines to start and initialize the RDBSS

Author:

    Joe Linn (JoeLinn) 21-jul-94

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#include <stdlib.h>
#include <stdio.h>
#include "string.h"
#include <stdarg.h>

BOOLEAN RxGlobalTraceSuppress = FALSE;

//.............sigh
NTSTATUS
SmbCeBuildSmbHeader(
      PSMB_EXCHANGE     pExchange,
      UCHAR             SmbCommand,
      PVOID             pBuffer,
      ULONG             BufferLength,
      PULONG            pBufferConsumed)
{
    PNT_SMB_HEADER NtSmbHeader = (PNT_SMB_HEADER)pBuffer;
    RtlZeroMemory(NtSmbHeader,sizeof(NT_SMB_HEADER));
    *(PULONG)(&NtSmbHeader->Protocol) = SMB_HEADER_PROTOCOL;
    NtSmbHeader->Command = SMB_COM_NO_ANDX_COMMAND;
    SmbPutUshort (&NtSmbHeader->Pid, MRXSMB_PROCESS_ID_ZERO);
    SmbPutUshort (&NtSmbHeader->Mid, MRXSMB_MULTIPLX_ID_ZERO);
    SmbPutUshort (&NtSmbHeader->Uid, MRXSMB_USER_ID_ZERO);
    SmbPutUshort (&NtSmbHeader->Tid, MRXSMB_TREE_ID_ZERO);
    *pBufferConsumed = sizeof(SMB_HEADER);
    return(STATUS_SUCCESS);
}


ULONG
DbgPrint(
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    UCHAR Buffer[512];
    ULONG retval;

    //
    // Format the output into a buffer and then print it.
    //

    //printf("Here in debgprint\n");
    va_start(arglist, Format);
    retval = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);
    //*(Buffer+retval) = 0;
    printf("%s",Buffer);
    return(retval);
}


BOOLEAN
RxDbgTraceActualNew (
    IN ULONG NewMask,
    IN OUT PDEBUG_TRACE_CONTROLPOINT ControlPoint
    )
//we aren't fancy in this test stub........just return print it out no matter what!
{
/*
This routine has the responsibility to determine if a particular dbgprint is going to be printed and ifso to
fiddle with the indent. so the return value is whether to print; it is also used for just fiddling with the indent
by setting the highoredr bit of the mask.

The Mask is now very complicated owing to the large number of dbgprints i'm trying to control...sigh.
The low order byte is the controlpoint....usually the file. each controlpoint has a current level associated
with it. if the level of a a debugtrace is less that then current control level then the debug is printed.
The next byte is the level of this particular call; again if the level is <= the current level for the control
you get printed. The next byte is the indent. indents are only processed if printing is done.
*/
#if DBG
    LONG Indent = ((NewMask>>RxDT_INDENT_SHIFT)&RxDT_INDENT_MASK) - RxDT_INDENT_EXCESS;
    LONG LevelOfThisWrite = (NewMask) & RxDT_LEVEL_MASK;
    BOOLEAN PrintIt = (NewMask&RxDT_SUPPRESS_PRINT)==0;
    BOOLEAN OverrideReturn = (NewMask&RxDT_OVERRIDE_RETURN)!=0;


    return PrintIt||OverrideReturn;
#else
    return(FALSE);
#endif
}



RDBSS_EXPORTS Junk;
PRDBSS_EXPORTS MRxSmbRxImports;
VOID
__cdecl
main(
    int argc,
    char *argv[]
    )

{
    printf("Calling stufferdebug\n");
    //signal to assert login that we're in usermode
    MRxSmbRxImports = &Junk;
    MRxSmbRxImports->pRxNetNameTable = NULL;
    MRxSmbStufferDebug("");
}


#define Dbg                              (DEBUG_TRACE_ALWAYS)
VOID
RxAssert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message OPTIONAL
    )
{
    char STARS[] = "**************************************";

    RxDbgTrace(0,Dbg,("%s\n%s\n",STARS,STARS));
    RxDbgTrace (0,Dbg,("Failed Assertion %s\n",FailedAssertion));
    RxDbgTrace(0,Dbg,("%s at line %lu\n",FileName,LineNumber));
    if (Message) {
        RxDbgTrace (0,Dbg,("%s\n",Message));
    }
    RxDbgTrace(0,Dbg,("%s\n%s\n",STARS,STARS));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\dll\dllmain.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dllmain.c

Abstract:

    This module implements the initialization routines for RDP mini redirector network
    provider router interface DLL

Author:

    Joy Chik    1/17/2000

--*/

#include <windows.h>
#include <process.h>
#include <windef.h>
#include <ntsecapi.h>

// TS Network Provider Name
WCHAR ProviderName[MAX_PATH];

UNICODE_STRING DrProviderName;

#define TSNETWORKPROVIDER   \
    L"SYSTEM\\CurrentControlSet\\Services\\RDPNP\\NetworkProvider"

#define TSNETWORKPROVIDERNAME \
    L"Name"



// NOTE:
//
// Function:	DllMain
//
// Return:	TRUE  => Success
//		      FALSE => Failure

BOOL WINAPI DllMain(HINSTANCE hDLLInst, DWORD fdwReason, LPVOID lpvReserved)
{
    BOOL	bStatus = FALSE;
    WORD	wVersionRequested;
    LONG status;
    HKEY regKey;
    LONG sz;

    switch (fdwReason) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDLLInst);

        bStatus = TRUE;
        break;

    case DLL_PROCESS_DETACH:
        bStatus = TRUE;
        break;

    default:
        break;
    }

    //
    //  Read the TS Network Provider out of the registry
    //
    ProviderName[0] = L'\0';
    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TSNETWORKPROVIDER, 0,
            KEY_READ, &regKey);
    if (status == ERROR_SUCCESS) {
        sz = sizeof(ProviderName);
        status = RegQueryValueEx(regKey, TSNETWORKPROVIDERNAME, NULL, 
                NULL, (PBYTE)ProviderName, &sz); 
        RegCloseKey(regKey);
    }
    
    if (status == ERROR_SUCCESS) {
        // make sure ProviderName is null terminated
        ProviderName[MAX_PATH - 1] = L'\0';
    }
    else {    
        ProviderName[0] = L'\0';
    }              
 
    DrProviderName.Length = wcslen(ProviderName) * sizeof(WCHAR);
    DrProviderName.MaximumLength = DrProviderName.Length + sizeof(WCHAR);
    DrProviderName.Buffer = ProviderName;

    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdbss\smb.mrx\rdrssp\userkey.c ===
/*++

Copyright (c) 1989-1997  Microsoft Corporation

Module Name:

    userkey.c

Abstract:

    Implentation of the functions that get and generate user session keys

        RtlCalculateUserSessionKeyLm
        RtlCalculateUserSessionKeyNt

Author:

    David Chalmers (Davidc) 10-21-91

Revision History:

    Adam Barr (AdamBa) 12-15-97
        Modified from private\security\lsa\crypt\dll

--*/

#include <rdrssp.h>


//
// Define this if you want to know all about user session keys
//

// #define DEBUG_USER_SESSION_KEYS

//
// Define the user session key that represents an error.
// This value will be generated by other parts of the system on failure.
// We will check for it in our query code and return an error if it's found.
//

USER_SESSION_KEY ErrorSessionKey = { 0, 0, 0, 0, 0, 0, 0, 0,
                                     0, 0, 0, 0, 0, 0, 0, 0
                                   };



NTSTATUS
RtlCalculateUserSessionKeyLm(
    IN PLM_RESPONSE LmResponse,
    IN PLM_OWF_PASSWORD LmOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Takes the passed Response and OwfPassword and generates a UserSessionKey.

    The current implementation takes the one-way-function of the OwfPassword
    and returns this as the key.

Arguments:

    LmResponse - The response sent during session setup.

    LmOwfPassword - The hashed version of the user's password.

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_UNSUCCESSFUL - Something failed. The UserSessionKey is undefined.
--*/

{
    NTSTATUS Status;
    NT_PASSWORD NtPassword;

    //
    // Make the Owf password look like an NT password
    //

    NtPassword.Buffer = (PWSTR)LmOwfPassword; // We can do this cast because we
                                              // know the OWF routine treats this
                                              // pointer as a byte pointer.
    NtPassword.Length = sizeof(*LmOwfPassword);
    NtPassword.MaximumLength = sizeof(*LmOwfPassword);


    //
    // Calculate the OWF of the OwfPassword
    //

    ASSERT(sizeof(NT_OWF_PASSWORD) == sizeof(*UserSessionKey));

    Status = RtlCalculateNtOwfPassword( &NtPassword,
                                        (PNT_OWF_PASSWORD)UserSessionKey
                                        );
    if (!NT_SUCCESS(Status)) {
        KdPrint(("RtlCalculateUserSessionKeyLm : OWF calculation failed, status = 0x%lx\n", Status));
        return(Status);
    }

    //
    // Check if we've generated the error session key
    //

    if (RtlCompareMemory(UserSessionKey, &ErrorSessionKey,
                       sizeof(*UserSessionKey)) == sizeof(*UserSessionKey)) {

#ifdef DEBUG_USER_SESSION_KEYS
        KdPrint(("RtlCalculateSessionKeyLm - generated error session key, modifying it\n"));
#endif
        //
        // Move away from the error session key
        //

        UserSessionKey->data[0].data[0] ++;

        ASSERT(RtlCompareMemory(UserSessionKey, &ErrorSessionKey,
                       sizeof(*UserSessionKey)) != sizeof(*UserSessionKey));
    }

#ifdef DEBUG_USER_SESSION_KEYS
    KdPrint(("RtlCalculateUserSessionKeyLm : Key = 0x%lx : %lx : %lx : %lx\n",
            ((PULONG)UserSessionKey)[0], ((PULONG)UserSessionKey)[1],
            ((PULONG)UserSessionKey)[2], ((PULONG)UserSessionKey)[3]));
#endif

    return(STATUS_SUCCESS);

    UNREFERENCED_PARAMETER(LmResponse);
}



NTSTATUS
RtlCalculateUserSessionKeyNt(
    IN PNT_RESPONSE NtResponse,
    IN PNT_OWF_PASSWORD NtOwfPassword,
    OUT PUSER_SESSION_KEY UserSessionKey)

/*++

Routine Description:

    Takes the passed Response and OwfPassword and generates a UserSessionKey.

Arguments:

    NtResponse - The response sent during session setup.

    NtOwfPassword - The hashed version of the user's password.

Return Values:

    STATUS_SUCCESS - The function was completed successfully.
                     The UserSessionKey is in UserSessionKey.

    STATUS_UNSUCCESSFUL - Something failed. The UserSessionKey is undefined.
--*/

{
    // Just call the LM version

    ASSERT(sizeof(NT_RESPONSE) == sizeof(LM_RESPONSE));
    ASSERT(sizeof(NT_OWF_PASSWORD) == sizeof(LM_OWF_PASSWORD));

    return(RtlCalculateUserSessionKeyLm((PLM_RESPONSE)NtResponse,
                                        (PLM_OWF_PASSWORD)NtOwfPassword,
                                        UserSessionKey));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\dll\drenum.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    drenum.c

Abstract:

    This module implements the routines required for interaction with network
    provider router interface in NT

Author:

    Joy Chik 1/20/2000

--*/

#include <drprov.h>
#include "drdbg.h"

extern UNICODE_STRING DrProviderName;
extern UNICODE_STRING DrDeviceName;
extern DWORD GLOBAL_DEBUG_FLAGS;

DWORD 
DrOpenMiniRdr(
    OUT HANDLE *DrDeviceHandle
    )
/*++

Routine Description:

    This routine opens the RDP redirector File System Driver.

Arguments:

    DrDeviceHandle - Device handle to the MiniRdr

Return Value:

    STATUS - Success or reason for failure.

--*/
{
    NTSTATUS            ntstatus;
    DWORD               Status = WN_SUCCESS;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      DeviceName;

    DBGMSG(DBG_TRACE, ("DRPROV: DrOpenMiniRdr\n"));

    //
    // Open the redirector device.
    //
    RtlInitUnicodeString(&DeviceName, RDPDR_DEVICE_NAME_U);

    InitializeObjectAttributes(
            &ObjectAttributes,
            &DeviceName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

    ntstatus = NtOpenFile(
            DrDeviceHandle,
            SYNCHRONIZE,
            &ObjectAttributes,
            &IoStatusBlock,
            FILE_SHARE_VALID_FLAGS,
            FILE_SYNCHRONOUS_IO_NONALERT
            );

    // If we failed to open the rdpdr minirdr, we 
    // return as access denied
    if (ntstatus != STATUS_SUCCESS) {
        DBGMSG(DBG_TRACE, ("DRPROV: DrOpenMiniRdr failed with status: %x\n", ntstatus));
        Status = WN_ACCESS_DENIED;
    }

    DBGMSG(DBG_TRACE, ("DRPROV: DrOpenMiniRdr, return status: %x\n", Status));
    return Status;
}

DWORD
DrDeviceControlGetInfo(
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPBYTE *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG_PTR Information OPTIONAL
    )
/*++

Routine Description:

    This function allocates the buffer and fill it with the information
    that is retrieved from the redirector.

Arguments:

    FileHandle - Supplies a handle to the file or device of which to get
        information about.

    DeviceControlCode - Supplies the NtFsControlFile or NtIoDeviceControlFile
        function control code.

    RequestPacket - Supplies a pointer to the device request packet.

    RrequestPacketLength - Supplies the length of the device request packet.

    OutputBuffer - Returns a pointer to the buffer allocated by this routine
        which contains the use information requested.  This pointer is set to
         NULL if return code is not wn_success.

    PreferedMaximumLength - Supplies the number of bytes of information to
        return in the buffer.  If this value is MAXULONG, we will try to
        return all available information if there is enough memory resource.

    BufferHintSize - Supplies the hint size of the output buffer so that the
        memory allocated for the initial buffer will most likely be large
        enough to hold all requested data.

    Information - Returns the information code from the NtFsControlFile or
        NtIoDeviceControlFile call.

Return Value:

    STATUS - Success or reason for failure.

--*/
{
    DWORD status;
    NTSTATUS ntStatus;
    DWORD OutputBufferLength;
    DWORD TotalBytesNeeded = 1;
    ULONG OriginalResumeKey;
    PRDPDR_REQUEST_PACKET Rrp = (PRDPDR_REQUEST_PACKET) RequestPacket;
    IO_STATUS_BLOCK IoStatusBlock;
    
    DBGMSG(DBG_TRACE, ("DRPROV: DrDeviceControlGetINfo\n"));

    //
    // If PreferedMaximumLength is MAXULONG, then we are supposed to get all
    // the information, regardless of size.  Allocate the output buffer of a
    // reasonable size and try to use it.  If this fails, the Redirector FSD
    // will say how much we need to allocate.
    //
    if (PreferedMaximumLength == MAXULONG) {
        OutputBufferLength = (BufferHintSize) ? BufferHintSize :
                INITIAL_ALLOCATION_SIZE;
    }
    else {
        OutputBufferLength = PreferedMaximumLength;
    }

    if ((*OutputBuffer = (BYTE *)MemAlloc(OutputBufferLength)) == NULL) {
        DBGMSG(DBG_TRACE, ("DRPROV: DrDeviceControlGetInfo, MemAlloc failed\n"));
        status = WN_OUT_OF_MEMORY;
        goto EXIT;
    }

    OriginalResumeKey = Rrp->Parameters.Get.ResumeHandle;

    //
    // Make the request of the Redirector
    //

    ntStatus = NtFsControlFile(
                 FileHandle,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 DeviceControlCode,
                 Rrp,
                 RequestPacketLength,
                 *OutputBuffer,
                 OutputBufferLength
                 );

    if (ntStatus == STATUS_SUCCESS) {
        TotalBytesNeeded = Rrp->Parameters.Get.TotalBytesNeeded;
        status = WN_SUCCESS;
        goto EXIT;
    }
    else {
        if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
            DBGMSG(DBG_TRACE, ("DRPROV: DrDeviceControlGetInfo, buffer too small\n"));
            TotalBytesNeeded = Rrp->Parameters.Get.TotalBytesNeeded;
            status = WN_MORE_DATA;
        }
        else {
            DBGMSG(DBG_TRACE, ("DRPROV: DrDeviceControlGetInfo, failed NtFsControlFile, %x\n", ntStatus));
            status = WN_BAD_NETNAME;
            goto EXIT;
        }
    }
    
    if ((TotalBytesNeeded > OutputBufferLength) &&
            (PreferedMaximumLength == MAXULONG)) {
        //
        // Initial output buffer allocated was too small and we need to return
        // all data.  First free the output buffer before allocating the
        // required size plus a fudge factor just in case the amount of data
        // grew.
        //

        MemFree(*OutputBuffer);

        OutputBufferLength = TotalBytesNeeded + FUDGE_FACTOR_SIZE;

        if ((*OutputBuffer = (BYTE *)MemAlloc(OutputBufferLength)) == NULL) {
            DBGMSG(DBG_TRACE, ("DRPROV: DrDeviceControlGetInfo, MemAlloc failed\n"));
            status = WN_OUT_OF_MEMORY;
            goto EXIT;
        }

        //
        // Try again to get the information from the redirector 
        //
        Rrp->Parameters.Get.ResumeHandle = OriginalResumeKey;

        //
        // Make the request of the Redirector
        //
        ntStatus = NtFsControlFile(
                     FileHandle,
                     NULL,
                     NULL,
                     NULL,
                     &IoStatusBlock,
                     DeviceControlCode,
                     Rrp,
                     RequestPacketLength,
                     *OutputBuffer,
                     OutputBufferLength
                     ); 

        if (ntStatus == STATUS_SUCCESS) 
        {
            TotalBytesNeeded = Rrp->Parameters.Get.TotalBytesNeeded;
            status = WN_SUCCESS;
            goto EXIT;
        }
        else {
            if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                DBGMSG(DBG_TRACE, ("DRPROV: DrDeviceControlGetInfo, buffer too small\n"));
                status = WN_OUT_OF_MEMORY;
                TotalBytesNeeded = Rrp->Parameters.Get.TotalBytesNeeded;
                goto EXIT;
            }
            else {
                DBGMSG(DBG_TRACE, ("DRPROV: DrDeviceControlGetInfo, failed NtFsControlFile, %x\n", ntStatus));
                status = WN_BAD_NETNAME;
                goto EXIT;
            }
        }        
    }
     
EXIT:

    //
    // If not successful in getting any data, or if TotalBytesNeeded is 0,
    // Free the output buffer.
    //
    if ((status != WN_SUCCESS) || (TotalBytesNeeded == 0)) {
        if (*OutputBuffer != NULL) {
            MemFree(*OutputBuffer);
            *OutputBuffer = NULL;
        }

        if (TotalBytesNeeded == 0) {
            status = WN_NO_MORE_ENTRIES;
        }
    }

    DBGMSG(DBG_TRACE, ("DRPROV: DrDeviceControlGetInfo, return status, %x\n", status));
    return status;
}


DWORD 
DrEnumServerInfo(PRDPDR_ENUMERATION_HANDLE pEnumHandle,
                 LPDWORD lpcCount,
                 LPNETRESOURCEW pBufferResource,
                 LPDWORD lpBufferSize)
/*++

Routine Description:

    This function requests the redirector to enumerate the server info,
    it then reckages it into the user supplied buffer and return
    
Arguments:

    pEnumHandle - Supplies the enumeration handle.  It's a structure the dll
        used to store enumberation state and info.
        
    lpcCount - On return, this contains the number of NETRESOURCE entries
        returned back to user.

    pBufferResource - On return, this contains all the netresource entries.

    lpBufferSize - This contains the size of the buffer.  On return, it 
       is the size of the network resource entries.
                                                                              
Return Value:

    STATUS - Success or reason for failure.

--*/
{
    DWORD status = WN_SUCCESS;
    DWORD localCount = 0;
    RDPDR_REQUEST_PACKET Rrp;            // Redirector request packet
    HANDLE DrDeviceHandle = INVALID_HANDLE_VALUE;
    LPBYTE Buffer = NULL;
    PRDPDR_SERVER_INFO pServerEntry;
    
    DBGMSG(DBG_TRACE, ("DRENUM: DrEnumServerInfo\n"));

    // Initialize enum count to 0
    *lpcCount = 0;

    if (pEnumHandle->enumIndex == 0) { 
        if (DrOpenMiniRdr(&DrDeviceHandle) != WN_SUCCESS) {
            //
            //  MPR doesn't like return device error in this case
            //  We'll just return 0 entries
            //
            DBGMSG(DBG_TRACE, ("DRENUM: DrEnumServerInfo, DrOpenMiniRdr failed\n"));
            status = WN_NO_MORE_ENTRIES;
            DrDeviceHandle = INVALID_HANDLE_VALUE;
            goto EXIT;
        }
                        
        //
        // Ask the redirector to enumerate the information of server
        // established by the caller.
        //
        Rrp.SessionId = NtCurrentPeb()->SessionId;
        Rrp.Parameters.Get.ResumeHandle = 0;

        //
        // Make the request to the Redirector
        //
        status = DrDeviceControlGetInfo(DrDeviceHandle,
                FSCTL_DR_ENUMERATE_SERVERS,
                &Rrp,
                sizeof(RDPDR_REQUEST_PACKET),
                (LPBYTE *) &Buffer,
                MAXULONG,
                0,
                NULL);

        if (status == WN_SUCCESS) {
            pEnumHandle->pEnumBuffer = Buffer;
        }
        else {
            DBGMSG(DBG_TRACE, ("DRENUM: DrEnumServerInfo, DrDeviceControlGetInfo failed, %x\n", status));
            goto EXIT;
        }
        
        pServerEntry = ((PRDPDR_SERVER_INFO) Buffer);

        if (*lpBufferSize >= sizeof(NETRESOURCEW) + 
                pServerEntry->ServerName.Length + sizeof(WCHAR) +
                DrProviderName.Length + sizeof(WCHAR)) {
            UNICODE_STRING ServerName;

            ServerName.Length = pServerEntry->ServerName.Length;
            ServerName.MaximumLength = pServerEntry->ServerName.MaximumLength;
            ServerName.Buffer = (PWCHAR)((PCHAR)(pServerEntry) + pServerEntry->ServerName.BufferOffset);

            pBufferResource->dwScope = pEnumHandle->dwScope;
            pBufferResource->dwType = RESOURCETYPE_DISK;
            pBufferResource->dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
            pBufferResource->dwUsage = RESOURCEUSAGE_CONTAINER ;
            pBufferResource->lpLocalName = NULL;
            
            // Server name
            pBufferResource->lpRemoteName = (PWCHAR) &pBufferResource[1];
            RtlCopyMemory(pBufferResource->lpRemoteName, 
                    ServerName.Buffer, 
                    ServerName.Length);
            pBufferResource->lpRemoteName[ServerName.Length / 
                    sizeof(WCHAR)] = L'\0';
            
            DBGMSG(DBG_TRACE, ("DRENUM: DrEnumServerInfo, ServerName, %ws\n",
                              pBufferResource->lpRemoteName));

            // Provider name
            pBufferResource->lpProvider = pBufferResource->lpRemoteName +
                    (ServerName.Length / sizeof(WCHAR) + 1);
            RtlCopyMemory(pBufferResource->lpProvider, DrProviderName.Buffer,
                    DrProviderName.Length);
            pBufferResource->lpProvider[DrProviderName.Length /
                    sizeof(WCHAR)] = L'\0';
            
            pBufferResource->lpComment = NULL;

            localCount = 1;
            pEnumHandle->enumIndex++;

            status = WN_SUCCESS;
            goto EXIT;
        }
        else {
            localCount = 0;
            *lpBufferSize = sizeof(NETRESOURCEW) +
                            pServerEntry->ServerName.Length + sizeof(WCHAR) +
                            DrProviderName.Length + sizeof(WCHAR);
            DBGMSG(DBG_TRACE, ("DRENUM: DrEnumServerInfo, buffer too small\n"));
            status = WN_MORE_DATA;
            goto EXIT;
        }
    } else {
        localCount = 0;
        status = WN_NO_MORE_ENTRIES;
        goto EXIT;
    }

EXIT:

    *lpcCount = localCount;
    if (DrDeviceHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(DrDeviceHandle);
    }
    
    DBGMSG(DBG_TRACE, ("DRENUM: DrEnumServerInfo, return status %x\n", status));
    return status;
}


DWORD
DrEnumShareInfo(PRDPDR_ENUMERATION_HANDLE pEnumHandle,
                LPDWORD lpcCount,
                LPNETRESOURCEW pBufferResource,
                LPDWORD lpBufferSize)
/*++

Routine Description:

    This function requests the redirector to enumerate the share info,
    it then reckages it into the user supplied buffer and return
    
Arguments:

    pEnumHandle - Supplies the enumeration handle.  It's a structure the dll
        used to store enumberation state and info.
        
    lpcCount - On return, this contains the number of NETRESOURCE entries
        returned back to user.

    pBufferResource - On return, this contains all the netresource entries.

    lpBufferSize - This contains the size of the buffer.  On return, it 
       is the size of the network resource entries.
                                                                              
Return Value:

    STATUS - Success or reason for failure.

--*/
{
    DWORD status = WN_SUCCESS;
    DWORD localCount = 0;
    HANDLE DrDeviceHandle = INVALID_HANDLE_VALUE;
    RDPDR_REQUEST_PACKET Rrp;            // Redirector request packet
    LPBYTE Buffer = NULL;
    PRDPDR_SHARE_INFO pShareEntry;
    DWORD Entry, RemainingBufferSize;
    BYTE *BufferResourceStart, *BufferResourceEnd;
    
    DBGMSG(DBG_TRACE, ("DRENUM: DrEnumShareInfo\n"));

    *lpcCount = 0;   
    BufferResourceStart = (PBYTE)pBufferResource;
    BufferResourceEnd = ((PBYTE)(pBufferResource)) + *lpBufferSize;

    if (pEnumHandle->RemoteName.Length == 0 || pEnumHandle->RemoteName.Buffer == NULL) {
        DBGMSG(DBG_TRACE, ("DRENUM: DrEnumShareInfo, no RemoteName\n"));
        status = WN_BAD_NETNAME;
        goto EXIT;
    }

    if (pEnumHandle->enumIndex == 0) {
        if (DrOpenMiniRdr(&DrDeviceHandle) != WN_SUCCESS) {
            //
            //  MPR doesn't like return device error in this case
            //  We'll just return 0 entries
            DBGMSG(DBG_TRACE, ("DRENUM: DrEnumShareInfo, DrOpenMiniRdr failed\n"));
            status = WN_NO_MORE_ENTRIES;
            DrDeviceHandle = INVALID_HANDLE_VALUE;
            goto EXIT;
        }

        //
        // Ask the redirector to enumerate the information of connections
        // established by the caller.
        //
        Rrp.SessionId = NtCurrentPeb()->SessionId;
        Rrp.Parameters.Get.ResumeHandle = 0;

        //
        // Make the request to the Redirector
        //
        status = DrDeviceControlGetInfo(DrDeviceHandle,
                FSCTL_DR_ENUMERATE_SHARES,
                &Rrp,
                sizeof(RDPDR_REQUEST_PACKET),
                (LPBYTE *) &Buffer,
                MAXULONG,
                0,
                NULL);

        if (status == WN_SUCCESS) {
            pEnumHandle->totalEntries = Rrp.Parameters.Get.EntriesRead;
            pEnumHandle->pEnumBuffer = Buffer;
        }
        else {
            DBGMSG(DBG_TRACE, ("DRENUM: DrEnumShareInfo, DrDeviceControlGetInfo failed, %x\n", status));
            goto EXIT;
        }        
    }
    else {
        Buffer = pEnumHandle->pEnumBuffer;

        if (Buffer == NULL) {
            status = WN_NO_MORE_ENTRIES;
            goto EXIT;
        }
    }

    if (pEnumHandle->enumIndex == pEnumHandle->totalEntries) {
        status = WN_NO_MORE_ENTRIES;
        goto EXIT;
    }

    for (Entry = pEnumHandle->enumIndex; Entry < pEnumHandle->totalEntries; Entry++) {
        pShareEntry = ((PRDPDR_SHARE_INFO) Buffer) + Entry;
        
        if ((unsigned) (BufferResourceEnd - BufferResourceStart) >
                sizeof(NETRESOURCEW) +
                pShareEntry->ShareName.Length + sizeof(WCHAR) +
                DrProviderName.Length + sizeof(WCHAR)) {
            UNICODE_STRING ShareName;

            pBufferResource[localCount].dwScope = pEnumHandle->dwScope;
            pBufferResource[localCount].dwType = RESOURCETYPE_DISK;
            pBufferResource[localCount].dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            pBufferResource[localCount].dwUsage = RESOURCEUSAGE_CONNECTABLE;
            pBufferResource[localCount].lpLocalName = NULL;
            
            ShareName.Length = pShareEntry->ShareName.Length;
            ShareName.MaximumLength = pShareEntry->ShareName.MaximumLength;
            ShareName.Buffer = (PWCHAR)((PCHAR)(pShareEntry) + pShareEntry->ShareName.BufferOffset);

            // share name
            BufferResourceEnd -= ShareName.Length + sizeof(WCHAR);
            pBufferResource[localCount].lpRemoteName = (PWCHAR) (BufferResourceEnd);
            RtlCopyMemory(pBufferResource[localCount].lpRemoteName, 
                    ShareName.Buffer,
                    ShareName.Length);
            pBufferResource[localCount].lpRemoteName[ShareName.Length / 
                    sizeof(WCHAR)] = L'\0';
            
            DBGMSG(DBG_TRACE, ("DRENUM: DrEnumShareInfo, ShareName, %ws\n",
                              pBufferResource[localCount].lpRemoteName));

            // provider name
            BufferResourceEnd -= DrProviderName.Length + sizeof(WCHAR);
            pBufferResource[localCount].lpProvider = (PWCHAR) (BufferResourceEnd);
            RtlCopyMemory(pBufferResource[localCount].lpProvider, DrProviderName.Buffer,
                    DrProviderName.Length);
            pBufferResource[localCount].lpProvider[DrProviderName.Length /
                    sizeof(WCHAR)] = L'\0';
            
            pBufferResource[localCount].lpComment = NULL;

            localCount += 1;
            BufferResourceStart = (PBYTE)(&pBufferResource[localCount]);
            pEnumHandle->enumIndex++;
        } 
        else {
            // enumerated some entries, so return success
            if (localCount) {
                status = WN_SUCCESS;
                break;
            }
            // can't even hold a single entry, return buffer too small
            else {
                *lpBufferSize = sizeof(NETRESOURCEW) +
                            pEnumHandle->RemoteName.Length +
                            pShareEntry->ShareName.Length + sizeof(WCHAR) +
                            DrProviderName.Length + sizeof(WCHAR);
                DBGMSG(DBG_TRACE, ("DRENUM: DrEnumShareInfo, buffer too small\n"));
                status = WN_MORE_DATA;
                goto EXIT;
            }
        }        
    }    

EXIT:
    
    *lpcCount = localCount;
    if (DrDeviceHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(DrDeviceHandle);
    }

    DBGMSG(DBG_TRACE, ("DRENUM: DrEnumShareInfo, return status %x\n", status));
    return status;
}

DWORD
DrEnumConnectionInfo(PRDPDR_ENUMERATION_HANDLE pEnumHandle,
                LPDWORD lpcCount,
                LPNETRESOURCEW pBufferResource,
                LPDWORD lpBufferSize)
/*++

Routine Description:

    This function requests the redirector to enumerate the connection info,
    it then reckages it into the user supplied buffer and return
    
Arguments:

    pEnumHandle - Supplies the enumeration handle.  It's a structure the dll
        used to store enumberation state and info.
        
    lpcCount - On return, this contains the number of NETRESOURCE entries
        returned back to user.

    pBufferResource - On return, this contains all the netresource entries.

    lpBufferSize - This contains the size of the buffer.  On return, it 
       is the size of the network resource entries.
                                                                              
Return Value:

    STATUS - Success or reason for failure.

--*/
{
    DWORD status = WN_SUCCESS;
    DWORD localCount = 0;
    HANDLE DrDeviceHandle = INVALID_HANDLE_VALUE;
    RDPDR_REQUEST_PACKET Rrp;            // Redirector request packet
    LPBYTE Buffer = NULL;
    PRDPDR_CONNECTION_INFO pConnectionEntry;
    DWORD Entry, RemainingBufferSize;
    BYTE *BufferResourceStart, *BufferResourceEnd;
    
    DBGMSG(DBG_TRACE, ("DRENUM: DrEnumConnectionInfo\n"));

    *lpcCount = 0;   
    BufferResourceStart = (PBYTE)pBufferResource;
    BufferResourceEnd = ((PBYTE)(pBufferResource)) + *lpBufferSize;

    if (pEnumHandle->enumIndex == 0) {
        
        if (DrOpenMiniRdr(&DrDeviceHandle) != WN_SUCCESS) {
            //
            //  MPR doesn't like return device error in this case
            //  We'll just return 0 entries
            //
            DBGMSG(DBG_TRACE, ("DRENUM: DrEnumConnectionInfo, DrOpenMiniRdr failed\n"));
            status = WN_NO_MORE_ENTRIES;
            DrDeviceHandle = INVALID_HANDLE_VALUE;
            goto EXIT;
        }

        //
        // Ask the redirector to enumerate the information of connections
        // established by the caller.
        //
        Rrp.SessionId = NtCurrentPeb()->SessionId;
        Rrp.Parameters.Get.ResumeHandle = 0;

        //
        // Make the request to the Redirector
        //
        status = DrDeviceControlGetInfo(DrDeviceHandle,
                FSCTL_DR_ENUMERATE_CONNECTIONS,
                &Rrp,
                sizeof(RDPDR_REQUEST_PACKET),
                (LPBYTE *) &Buffer,
                MAXULONG,
                0,
                NULL);

        if (status == WN_SUCCESS) {
            pEnumHandle->totalEntries = Rrp.Parameters.Get.EntriesRead;
            pEnumHandle->pEnumBuffer = Buffer;
        }
        else {
            DBGMSG(DBG_TRACE, ("DRENUM: DrEnumConnectionInfo, DrDeviceControlGetInfo failed, %x\n", status));
            goto EXIT;
        }        
    }
    else {
        Buffer = pEnumHandle->pEnumBuffer;

        if (Buffer == NULL) {
            status = WN_NO_MORE_ENTRIES;
            goto EXIT;
        }
    }

    if (pEnumHandle->enumIndex == pEnumHandle->totalEntries) {
        status = WN_NO_MORE_ENTRIES;
        goto EXIT;
    }

    for (Entry = pEnumHandle->enumIndex; Entry < pEnumHandle->totalEntries; Entry++) {
        pConnectionEntry = ((PRDPDR_CONNECTION_INFO) Buffer) + Entry;
        
        if ((unsigned) (BufferResourceEnd - BufferResourceStart) >
                sizeof(NETRESOURCEW) +
                pConnectionEntry->RemoteName.Length + sizeof(WCHAR) +
                pConnectionEntry->LocalName.Length + sizeof(WCHAR) +
                DrProviderName.Length + sizeof(WCHAR)) {
            UNICODE_STRING RemoteName;
            UNICODE_STRING LocalName;
        
            pBufferResource[localCount].dwScope = pEnumHandle->dwScope;
            pBufferResource[localCount].dwType = RESOURCETYPE_DISK;
            pBufferResource[localCount].dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
            pBufferResource[localCount].dwUsage = 0;
            
            RemoteName.Length = pConnectionEntry->RemoteName.Length;
            RemoteName.MaximumLength = pConnectionEntry->RemoteName.MaximumLength;
            RemoteName.Buffer = (PWCHAR)((PCHAR)pConnectionEntry + 
                    pConnectionEntry->RemoteName.BufferOffset);

            LocalName.Length = pConnectionEntry->LocalName.Length;
            LocalName.MaximumLength = pConnectionEntry->LocalName.MaximumLength;
            LocalName.Buffer = (PWCHAR)((PCHAR)pConnectionEntry + 
                    pConnectionEntry->LocalName.BufferOffset);

            // Remote name
            BufferResourceEnd -= RemoteName.Length + sizeof(WCHAR);
            pBufferResource[localCount].lpRemoteName = (PWCHAR) (BufferResourceEnd);
            RtlCopyMemory(pBufferResource[localCount].lpRemoteName, 
                    RemoteName.Buffer,
                    RemoteName.Length);
            pBufferResource[localCount].lpRemoteName[RemoteName.Length /
                    sizeof(WCHAR)] = L'\0';
                
            DBGMSG(DBG_TRACE, ("DRENUM: DrEnumConnectionInfo, RemoteName, %ws\n",
                              pBufferResource[localCount].lpRemoteName));

            // Local name
            if (LocalName.Length != 0) {
                BufferResourceEnd -= LocalName.Length + sizeof(WCHAR);
                pBufferResource[localCount].lpLocalName = (PWCHAR) (BufferResourceEnd);
                RtlCopyMemory(pBufferResource[localCount].lpLocalName, 
                        LocalName.Buffer,
                        LocalName.Length);
                pBufferResource[localCount].lpLocalName[LocalName.Length /
                        sizeof(WCHAR)] = L'\0';

                DBGMSG(DBG_TRACE, ("DRENUM: DrEnumConnectionInfo, LocalName, %ws\n",
                              pBufferResource[localCount].lpLocalName));
            }
            else {
                pBufferResource[localCount].lpLocalName = NULL;
            }

            // Provider name
            BufferResourceEnd -= DrProviderName.Length + sizeof(WCHAR);
            pBufferResource[localCount].lpProvider = (PWCHAR) (BufferResourceEnd);
            RtlCopyMemory(pBufferResource[localCount].lpProvider, DrProviderName.Buffer,
                    DrProviderName.Length);
            pBufferResource[localCount].lpProvider[DrProviderName.Length / 
                    sizeof(WCHAR)] = L'\0';
            
            pBufferResource[localCount].lpComment = NULL;

            localCount += 1;
            BufferResourceStart = (PBYTE)(&pBufferResource[localCount]);
            pEnumHandle->enumIndex++;

        } else {
            // enumerated some entries, so return success
            if (localCount) {
                status = WN_SUCCESS;
                break;
            }
            // can't even hold a single entry, return buffer too small
            else {
                *lpBufferSize = sizeof(NETRESOURCEW) +
                            pConnectionEntry->RemoteName.Length + sizeof(WCHAR) +
                            DrProviderName.Length + sizeof(WCHAR) +
                            pConnectionEntry->LocalName.Length + sizeof(WCHAR);
                DBGMSG(DBG_TRACE, ("DRENUM: DrEnumConnectionInfo, buffer too small\n"));
                status = WN_MORE_DATA;
                break;
            }
        }        
    }
    
EXIT:

    *lpcCount = localCount;
    if (DrDeviceHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(DrDeviceHandle);
    }

    DBGMSG(DBG_TRACE, ("DRENUM: DrEnumConnectionInfo, return status %x\n", status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\dll\drdbg.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :
    
    drdbg.h

Abstract:

    User-Mode RDP Network Provider Debugging Module.

Author:

    JoyC 

Revision History:
--*/

#ifndef _DRDBG_
#define _DRDBG_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

////////////////////////////////////////////////////////
//      
//      Debugging
//
#undef ASSERT

// Used to scramble released memory.
#define DBG_GARBAGEMEM  0xCC

// Debug message levels
#define DBG_NONE        0x0000
#define DBG_INFO        0x0001
#define DBG_WARN        0x0002
#define DBG_WARNING     0x0002
#define DBG_ERROR       0x0004
#define DBG_TRACE       0x0008
#define DBG_SECURITY    0x0010
#define DBG_EXEC        0x0020
#define DBG_PORT        0x0040
#define DBG_NOTIFY      0x0080
#define DBG_PAUSE       0x0100
#define DBG_ASSERT      0x0200
#define DBG_THREADM     0x0400
#define DBG_MIN         0x0800
#define DBG_TIME        0x1000
#define DBG_FOLDER      0x2000
#define DBG_NOHEAD      0x8000

#if DBG
ULONG DbgPrint(PCH Format, ...);

VOID DbgBreakPoint(VOID);

/* These flags are not used as arguments to the DBGMSG macro.
 * You have to set the high word of the global variable to cause it to break.
 * It is ignored if used with DBGMSG.
 * (Here mainly for explanatory purposes.)
 */
#define DBG_BREAK_ON_WARNING    ( DBG_WARNING << 16 )
#define DBG_BREAK_ON_ERROR      ( DBG_ERROR << 16 )

/* Double braces are needed for this one, e.g.:
 *
 *     DBGMSG( DBG_ERROR, ( "Error code %d", Error ) );
 *
 * This is because we can't use variable parameter lists in macros.
 * The statement gets pre-processed to a semi-colon in non-debug mode.
 *
 * Set the global variable GLOBAL_DEBUG_FLAGS via the debugger.
 * Setting the flag in the low word causes that level to be printed;
 * setting the high word causes a break into the debugger.
 * E.g. setting it to 0x00040006 will print out all warning and error
 * messages, and break on errors.
 */
#define DBGMSG( Level, MsgAndArgs ) \
{                                   \
    if( ( Level & 0xFFFF ) & GLOBAL_DEBUG_FLAGS ) \
        DbgPrint MsgAndArgs;      \
    if( ( Level << 16 ) & GLOBAL_DEBUG_FLAGS ) \
        DbgBreakPoint(); \
}

#define ASSERT(expr)                      \
    if (!(expr)) {                           \
        DbgPrint( "Failed: %s\nLine %d, %s\n", \
                                #expr,       \
                                __LINE__,    \
                                __FILE__ );  \
        DebugBreak();                        \
    }

#else
#define DBGMSG
#define ASSERT(exp)
#endif

#ifdef __cplusplus
}
#endif // __cplusplus


#endif // #ifndef _DRDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\dll\drprov.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    drprov.h

Abstract:

    This module includes all network provider router interface related
    definitions

Author:

    Joy Chik (1/27/2000)
    
--*/

#ifndef _DRPROV_H_
#define _DRPROV_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsvc.h>
#include <winnetwk.h>
#include <winnetp.h>
#include <npapi.h>
#include <wchar.h>

#include <rdpdr.h>
#include <rdpnp.h>

#define USERNAMELEN              256      // Maximum user name length
#define INITIAL_ALLOCATION_SIZE  48*1024  // First attempt size (48K)
#define FUDGE_FACTOR_SIZE        1024     // Second try TotalBytesNeeded
                                          // plus this amount

// Enumeration type
typedef enum _ENUM_TYPE {
    SERVER = 0,
    SHARE,
    CONNECTION,
    EMPTY
} ENUM_TYPE;

typedef struct _RDPDR_ENUMERATION_HANDLE_ {
    DWORD dwScope;
    DWORD dwType;
    DWORD dwUsage;
    UNICODE_STRING RemoteName;      // Remote Name
    ENUM_TYPE enumType;             // Enumeration type
    DWORD enumIndex;                // Current enumeration index
    DWORD totalEntries;             // Total number of entries returned
    PBYTE pEnumBuffer;              // Enumeration buffer that holds entries returned from
                                    // kernel mode redirector
} RDPDR_ENUMERATION_HANDLE, *PRDPDR_ENUMERATION_HANDLE;

#define MemAlloc(size)     HeapAlloc(RtlProcessHeap(), 0, size)
#define MemFree(pointer)   HeapFree(RtlProcessHeap(), 0, pointer)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\drkdx\rdpdrkd.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    rdpdrkd.h

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#ifndef _RDPDRKD_H_
#define _RDPDRKD_H_

typedef enum _FOLLOWON_HELPER_RETURNS {
    FOLLOWONHELPER_CALLTHRU,
    FOLLOWONHELPER_DUMP,
    FOLLOWONHELPER_ERROR,
    FOLLOWONHELPER_DONE
} FOLLOWON_HELPER_RETURNS;

typedef struct _PERSISTENT_RDPDRKD_INFO {
    DWORD OpenCount;
    ULONG_PTR LastAddressDumped[100];
    ULONG IdOfLastDump;
    ULONG IndexOfLastDump;
    BYTE StructDumpBuffer[2048];
} PERSISTENT_RDPDRKD_INFO, *PPERSISTENT_RDPDRKD_INFO;

PPERSISTENT_RDPDRKD_INFO LocatePersistentInfoFromView ();
VOID
FreePersistentInfoView (
    PPERSISTENT_RDPDRKD_INFO p
    );


typedef
FOLLOWON_HELPER_RETURNS
(NTAPI *PFOLLOWON_HELPER_ROUTINE) (
    IN OUT PPERSISTENT_RDPDRKD_INFO p,
    OUT    PBYTE Name,
    OUT    PBYTE Buffer2
    );

#define DECLARE_FOLLOWON_HELPER_CALLEE(s) \
    FOLLOWON_HELPER_RETURNS s (           \
    IN OUT PPERSISTENT_RDPDRKD_INFO p,     \
    OUT    PBYTE Name,                    \
    OUT    PBYTE Buffer2       \
    )

#endif // _RDPDRKD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\drkdx\rdpdrkd.cpp ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    rdpdrkd.c

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#define KDEXT_32BIT
#include "rx.h"       // NT network file system driver include file
#include "ntddnfs2.h" // new stuff device driver definitions
#include <pchannel.h>
#include <tschannl.h>
#include <rdpdr.h>
#include "rdpdrp.h"
#include "namespc.h"
#include "strcnv.h"
#include "dbg.h"
#include "topobj.h"
#include "smartptr.h"
#include "kernutil.h"
#include "isession.h"
#include "iexchnge.h"
#include "channel.h"
#include "device.h"
#include "prnport.h"
#include "serport.h"
#include "parport.h"
#include "devmgr.h"
#include "exchnge.h"
#include "session.h"
#include "sessmgr.h"
#include "rdpdyn.h"
#include "rdpevlst.h"
#include "rdpdrpnp.h"
#include "rdpdrprt.h"
#include "trc.h"

#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <rdpdrkd.h>

/*
 * RDPDR global variables.
 *
 */

LPSTR GlobalBool[]  = {
             0};

LPSTR GlobalShort[] = {0};
LPSTR GlobalLong[]  = {
            0};

LPSTR GlobalPtrs[]  = {
            "rdpdr!RxExpCXR",
            "rdpdr!RxExpEXR",
            "rdpdr!RxExpAddr",
            "rdpdr!RxExpCode",
            "rdpdr!RxActiveContexts",
            "rdpdr!RxNetNameTable",
            "rdpdr!RxProcessorArchitecture",
            "rdpdr!RxBuildNumber",
            "rdpdr!RxPrivateBuild",
            "rdpdr!ClientList",
            0};


/*
 * IRP_CONTEXT debugging.
 *
 */

FIELD_DESCRIPTOR RxContextFields[] =
   {
      FIELD3(FieldTypeUShort,RX_CONTEXT,NodeTypeCode),
      FIELD3(FieldTypeShort,RX_CONTEXT,NodeByteSize),
      FIELD3(FieldTypeULong,RX_CONTEXT,ReferenceCount),
      FIELD3(FieldTypeULong,RX_CONTEXT,SerialNumber),
      FIELD3(FieldTypeStruct,RX_CONTEXT,WorkQueueItem),
      FIELD3(FieldTypePointer,RX_CONTEXT,CurrentIrp),
      FIELD3(FieldTypePointer,RX_CONTEXT,CurrentIrpSp),
      FIELD3(FieldTypePointer,RX_CONTEXT,pFcb),
      FIELD3(FieldTypePointer,RX_CONTEXT,pFobx),
      //FIELD3(FieldTypePointer,RX_CONTEXT,pRelevantSrvOpen),
      FIELD3(FieldTypePointer,RX_CONTEXT,LastExecutionThread),
#ifdef RDBSS_TRACKER
      FIELD3(FieldTypePointer,RX_CONTEXT,AcquireReleaseFcbTrackerX),
#endif
      FIELD3(FieldTypePointer,RX_CONTEXT,MRxContext[2]),
      FIELD3(FieldTypeSymbol,RX_CONTEXT,ResumeRoutine),
      FIELD3(FieldTypePointer,RX_CONTEXT,RealDevice),
      FIELD3(FieldTypeULongFlags,RX_CONTEXT,Flags),
      FIELD3(FieldTypeChar,RX_CONTEXT,MajorFunction),
      FIELD3(FieldTypeChar,RX_CONTEXT,MinorFunction),
      FIELD3(FieldTypeULong,RX_CONTEXT,StoredStatus),
      FIELD3(FieldTypeStruct,RX_CONTEXT,SyncEvent),
      FIELD3(FieldTypeStruct,RX_CONTEXT,RxContextSerializationQLinks),
      FIELD3(FieldTypeStruct,RX_CONTEXT,Create),
      FIELD3(FieldTypeStruct,RX_CONTEXT,LowIoContext),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.NetNamePrefixEntry),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pSrvCall),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pNetRoot),
      FIELD3(FieldTypePointer,RX_CONTEXT,Create.pVNetRoot),
      //FIELD3(FieldTypePointer,RX_CONTEXT,Create.pSrvOpen),
      FIELDLAST
   };

/*
 * SRV_CALL debugging.
 *
 */

//CODE.IMPROVEMENT we should have a fieldtype for prefixentry that
//                 will print out the names

FIELD_DESCRIPTOR SrvCallFields[] =
   {
      FIELD3(FieldTypeUShort,SRV_CALL,NodeTypeCode),
      FIELD3(FieldTypeShort,SRV_CALL,NodeByteSize),
      FIELD3(FieldTypeStruct,SRV_CALL,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,SRV_CALL,PrefixEntry.Prefix),
      FIELD3(FieldTypePointer,SRV_CALL,Context),
      FIELD3(FieldTypePointer,SRV_CALL,Context2),
      FIELD3(FieldTypeULong,SRV_CALL,Flags),
      FIELDLAST
   };

/*
 * NET_ROOT debugging.
 *
 */

FIELD_DESCRIPTOR NetRootFields[] =
   {
      FIELD3(FieldTypeUShort,NET_ROOT,NodeTypeCode),
      FIELD3(FieldTypeShort,NET_ROOT,NodeByteSize),
      FIELD3(FieldTypeULong,NET_ROOT,NodeReferenceCount),
      FIELD3(FieldTypeStruct,NET_ROOT,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,NET_ROOT,PrefixEntry.Prefix),
      FIELD3(FieldTypeStruct,NET_ROOT,FcbTable),
      //FIELD3(FieldTypePointer,NET_ROOT,Dispatch),
      FIELD3(FieldTypePointer,NET_ROOT,Context),
      FIELD3(FieldTypePointer,NET_ROOT,Context2),
      FIELD3(FieldTypePointer,NET_ROOT,pSrvCall),
      FIELD3(FieldTypeULong,NET_ROOT,Flags),
      FIELDLAST
   };


/*
 * V_NET_ROOT debugging.
 *
 */

FIELD_DESCRIPTOR VNetRootFields[] =
   {
      FIELD3(FieldTypeUShort,V_NET_ROOT,NodeTypeCode),
      FIELD3(FieldTypeShort,V_NET_ROOT,NodeByteSize),
      FIELD3(FieldTypeULong,V_NET_ROOT,NodeReferenceCount),
      FIELD3(FieldTypeStruct,V_NET_ROOT,PrefixEntry),
      FIELD3(FieldTypeUnicodeString,V_NET_ROOT,PrefixEntry.Prefix),
      FIELD3(FieldTypeUnicodeString,V_NET_ROOT,NamePrefix),
      FIELD3(FieldTypePointer,V_NET_ROOT,Context),
      FIELD3(FieldTypePointer,V_NET_ROOT,Context2),
      FIELD3(FieldTypePointer,V_NET_ROOT,pNetRoot),
      FIELDLAST
   };


/*
 * FCB debugging.
 *
 */

FIELD_DESCRIPTOR FcbFields[] =
   {
      FIELD3(FieldTypeUShort,FCB,Header.NodeTypeCode),
      FIELD3(FieldTypeShort,FCB,Header.NodeByteSize),
      FIELD3(FieldTypeULong,FCB,NodeReferenceCount),
      FIELD3(FieldTypeULong,FCB,FcbState),
      FIELD3(FieldTypeULong,FCB,OpenCount),
      FIELD3(FieldTypeULong,FCB,UncleanCount),
      FIELD3(FieldTypePointer,FCB,Header.Resource),
      FIELD3(FieldTypePointer,FCB,Header.PagingIoResource),
      FIELD3(FieldTypeStruct,FCB,FcbTableEntry),
      FIELD3(FieldTypeUnicodeString,FCB,PrivateAlreadyPrefixedName),
      FIELD3(FieldTypePointer,FCB,VNetRoot),
      FIELD3(FieldTypePointer,FCB,pNetRoot),
      FIELD3(FieldTypePointer,FCB,Context),
      FIELD3(FieldTypePointer,FCB,Context2),
      FIELDLAST
   };


/*
 * SRV_OPEN debugging.
 *
 */

FIELD_DESCRIPTOR SrvOpenFields[] =
   {
      FIELD3(FieldTypeShort,SRV_OPEN,NodeTypeCode),
      FIELD3(FieldTypeShort,SRV_OPEN,NodeByteSize),
      FIELD3(FieldTypeULong,SRV_OPEN,NodeReferenceCount),
      FIELD3(FieldTypePointer,SRV_OPEN,pFcb),
      FIELD3(FieldTypeULong,SRV_OPEN,Flags),
      FIELDLAST
   };


/*
 * FOBX debugging.
 *
 */

FIELD_DESCRIPTOR FobxFields[] =
   {
      FIELD3(FieldTypeShort,FOBX,NodeTypeCode),
      FIELD3(FieldTypeShort,FOBX,NodeByteSize),
      FIELD3(FieldTypeULong,FOBX,NodeReferenceCount),
      FIELD3(FieldTypePointer,FOBX,pSrvOpen),
      FIELDLAST
   };

//this enum is used in the definition of the structures that can be dumped....the order here
//is not important, only that there is a definition for each dumpee structure.....

typedef enum _STRUCTURE_IDS {
    StrEnum_RX_CONTEXT = 1,
    StrEnum_FCB,
    StrEnum_SRV_OPEN,
    StrEnum_FOBX,
    StrEnum_SRV_CALL,
    StrEnum_NET_ROOT,
    StrEnum_V_NET_ROOT,
    StrEnum_CHANNELAPCCONTEXT,
    StrEnum_TopObj,
    StrEnum_DrExchangeManager,
    StrEnum_DrExchange,
    StrEnum_DrIoContext,
    StrEnum_DrDeviceManager,
    StrEnum_DoubleList,
    StrEnum_KernelResource,
    StrEnum_VirtualChannel,
    StrEnum_DrDevice,
    StrEnum_DrPrinterPort,
    StrEnum_DrParallelPort,
    StrEnum_DrSerialPort,
    StrEnum_DrSessionManager,
    StrEnum_DrSession,
    StrEnum_ReferenceTraceRecord,
    StrEnum_SESSIONLISTNODE,
    StrEnum_EVENTLISTNODE,
    StrEnum_RDPDR_IOCOMPLETION_PACKET,
    StrEnum_RDPDR_IOREQUEST_PACKET,
    StrEnum_RDPDR_UPDATE_DEVICEINFO_PACKET,
    StrEnum_RDPDR_DEVICE_REPLY_PACKET,
    StrEnum_RDPDR_DEVICELIST_ANNOUNCE_PACKET,
    StrEnum_RDPDR_DEVICE_ANNOUNCE,
    StrEnum_RDPDR_CLIENT_NAME_PACKET,
    StrEnum_RDPDR_CLIENT_CONFIRM_PACKET,
    StrEnum_RDPDR_SERVER_ANNOUNCE_PACKET,
    StrEnum_RDPDR_HEADER,
    StrEnum_TRC_CONFIG,
    StrEnum_TRC_PREFIX_DATA,
    StrEnum_last
};

// 1) All ENUM_VALUE_DESCRIPTOR definitions are named EnumValueDescrsOf_ENUMTYPENAME, where
// ENUMTYPENAME defines the corresponding enumerated type.
//

ENUM_VALUE_DESCRIPTOR EnumValueDescrsOf_DEVICE_STATUS [] =
{
    {0, "dsAvailable"},
    {1, "dsDisabled"},
    {0, NULL}
};

ENUM_VALUE_DESCRIPTOR EnumValueDescrsOf_DEVICE_TYPE [] =
{
    {1, "RDPDR_DTYP_SERIAL"},
    {2, "RDPDR_DTYP_PARALLEL"},
    {3, "RDPDR_DTYP_FILE"},
    {4, "RDPDR_DTYP_PRINT"},
    {0, NULL}
};

ENUM_VALUE_DESCRIPTOR EnumValueDescrsOf_CLIENT_STATUS [] =
{
    {0, "csDisconnected"},
    {1, "csPendingClientConfirm"},
    {2, "csPendingClientReconfirm"},
    {3, "csConnected"},
    {4, "csExpired"},
    {0, NULL}
};

ENUM_VALUE_DESCRIPTOR EnumValueDescrsOf_ExchangeManagerState [] =
{
    {0, "demsStopped"},
    {1, "demsStarted"},
    {0, NULL}
};

#if DBG
#define TOPOBJFIELDS(ObjTyp) \
    FIELD3(FieldTypeBoolean, ObjTyp, _IsValid),     \
    FIELD3(FieldTypeULong, ObjTyp, _ObjectType),    \
    FIELD3(FieldTypeBoolean, ObjTyp, _ForceTrace),  \
    FIELD3(FieldTypePointer, ObjTyp, _ClassName),   \
    FIELD3(FieldTypeULong, ObjTyp, _magicNo)
#else // DBG
#define TOPOBJFIELDS(ObjTyp) \
    FIELD3(FieldTypeBoolean, ObjTyp, _IsValid),     \
    FIELD3(FieldTypeULong, ObjTyp, _ObjectType)     
#endif // DBG

FIELD_DESCRIPTOR TopObjFields[] =
{
    TOPOBJFIELDS(TopObj),
    FIELDLAST
};


FIELD_DESCRIPTOR DrExchangeManagerFields[] =
{
    TOPOBJFIELDS(DrExchangeManager),
    FIELD3(FieldTypePointer, DrExchangeManager, _RxMidAtlas),
    FIELD4(FieldTypeEnum, DrExchangeManager, _demsState, EnumValueDescrsOf_ExchangeManagerState),
    FIELD3(FieldTypePointer, DrExchangeManager, _Session),
    FIELDLAST
};

FIELD_DESCRIPTOR DrExchangeFields[] =
{
    TOPOBJFIELDS(DrExchange),
    FIELD3(FieldTypeULong, DrExchange, _crefs),
    FIELD3(FieldTypePointer, DrExchange, _ExchangeManager),
    FIELD3(FieldTypePointer, DrExchange, _Context),
    FIELD3(FieldTypePointer, DrExchange, _ExchangeUser),
    FIELD3(FieldTypeUShort, DrExchange, _Mid),
    FIELDLAST
};

FIELD_DESCRIPTOR DrIoContextFields[] =
{
    TOPOBJFIELDS(DrIoContext),
    FIELD3(FieldTypePointer, DrIoContext, _Device),
    FIELD3(FieldTypeBool, DrIoContext, _Busy),
    FIELD3(FieldTypeBool, DrIoContext, _Cancelled),
    FIELD3(FieldTypeBool, DrIoContext, _Disconnected),
    FIELD3(FieldTypePointer, DrIoContext, _RxContext),
    FIELD3(FieldTypeChar, DrIoContext, _MajorFunction),
    FIELD3(FieldTypeChar, DrIoContext, _MinorFunction),
    FIELDLAST
};

FIELD_DESCRIPTOR DrDeviceManagerFields[] =
{
    TOPOBJFIELDS(DrDeviceManager),
    FIELD3(FieldTypeStruct, DrDeviceManager, _DeviceList),
    FIELD3(FieldTypePointer, DrDeviceManager, _Session),
    FIELDLAST
};

FIELD_DESCRIPTOR DoubleListFields[] =
{
    TOPOBJFIELDS(DoubleList),
    FIELD3(FieldTypeStruct, DoubleList, _List),
    FIELDLAST
};

FIELD_DESCRIPTOR KernelResourceFields[] =
{
    TOPOBJFIELDS(KernelResource),
    FIELD3(FieldTypeStruct, KernelResource, _Resource),
    FIELDLAST
};

FIELD_DESCRIPTOR VirtualChannelFields[] =
{
    TOPOBJFIELDS(VirtualChannel),
    FIELD3(FieldTypeULong, VirtualChannel, _crefs),
    FIELD3(FieldTypePointer, VirtualChannel, _Channel),
    FIELD3(FieldTypeStruct, VirtualChannel, _HandleLock),
    FIELD3(FieldTypePointer, VirtualChannel, _DeletionEvent),
    FIELDLAST
};

#define DRDEVICEFIELDS(ObjType) \
    TOPOBJFIELDS(ObjType),                         \
    FIELD3(FieldTypeULong, ObjType, _crefs),       \
    FIELD3(FieldTypeStruct, ObjType, _Session),    \
    FIELD3(FieldTypeULong, ObjType, _DeviceId),    \
    FIELD4(FieldTypeEnum, ObjType, _DeviceType, EnumValueDescrsOf_DEVICE_TYPE),    \
    FIELD3(FieldTypeStruct, ObjType, _PreferredDosName),   \
    FIELD4(FieldTypeEnum, ObjType, _DeviceStatus, EnumValueDescrsOf_DEVICE_STATUS)
    
FIELD_DESCRIPTOR DrDeviceFields[] =
{
    DRDEVICEFIELDS(DrDevice),
    FIELDLAST
};

#define DRPRINTERPORTFIELDS(ObjType) \
    DRDEVICEFIELDS(ObjType),                                \
    FIELD3(FieldTypeULong, ObjType, _PortNumber),           \
    FIELD3(FieldTypeStruct, ObjType, _SymbolicLinkName),    \
    FIELD3(FieldTypeBool, ObjType, _IsOpen)

FIELD_DESCRIPTOR DrPrinterPortFields[] =
{
    DRPRINTERPORTFIELDS(DrPrinterPort),
    FIELDLAST
};

FIELD_DESCRIPTOR DrParallelPortFields[] =
{
    DRPRINTERPORTFIELDS(DrParallelPort),
    FIELDLAST
};

FIELD_DESCRIPTOR DrSerialPortFields[] =
{
    DRPRINTERPORTFIELDS(DrSerialPort),
    FIELDLAST
};

FIELD_DESCRIPTOR DrSessionManagerFields[] =
{
    TOPOBJFIELDS(DrSessionManager),
    FIELD3(FieldTypeStruct, DrSessionManager, _SessionList),
    FIELDLAST
};

FIELD_DESCRIPTOR DrSessionFields[] =
{
    TOPOBJFIELDS(DrSession),
    FIELD3(FieldTypeULong, DrSession, _crefs),
    FIELD3(FieldTypeStruct, DrSession, _Channel),
    FIELD3(FieldTypeStruct, DrSession, _PacketReceivers),
    FIELD3(FieldTypeStruct, DrSession, _ConnectNotificatingLock),
    FIELD3(FieldTypeStruct, DrSession, _ChannelLock),
    FIELD4(FieldTypeEnum, DrSession, _SessionState, EnumValueDescrsOf_CLIENT_STATUS),
    FIELD3(FieldTypePointer, DrSession, _ChannelBuffer),
    FIELD3(FieldTypeULong, DrSession, _ChannelBufferSize),
    FIELD3(FieldTypeStruct, DrSession, _ChannelDeletionEvent),
    FIELD3(FieldTypeULong, DrSession, _ReadStatus.Status),
    FIELD3(FieldTypeULong, DrSession, _ReadStatus.Information),
    FIELD3(FieldTypeULong, DrSession, _ClientId),
    FIELD3(FieldTypeStruct, DrSession, _ExchangeManager),
    FIELD3(FieldTypeULong, DrSession, _PartialPacketData),
    FIELD3(FieldTypeStruct, DrSession, _ClientName),
    FIELD3(FieldTypeStruct, DrSession, _DeviceManager),
    FIELD3(FieldTypeULong, DrSession, _SessionId),
    FIELD3(FieldTypeUShort, DrSession, _ClientVersion.Major),
    FIELD3(FieldTypeUShort, DrSession, _ClientVersion.Major),
    FIELD3(FieldTypeLong, DrSession, _Initialized),
    FIELDLAST
};

typedef struct tagCHANNELAPCCONTEXT {
    SmartPtr<VirtualChannel> Channel;
    PIO_APC_ROUTINE ApcRoutine;
    PVOID ApcContext;
} CHANNELAPCCONTEXT, *PCHANNELAPCCONTEXT;

FIELD_DESCRIPTOR ChannelApcContextFields[] =
{
    FIELD3(FieldTypeStruct, CHANNELAPCCONTEXT, Channel),
    FIELD3(FieldTypePointer, CHANNELAPCCONTEXT, ApcRoutine),
    FIELD3(FieldTypePointer, CHANNELAPCCONTEXT, ApcContext),
    FIELDLAST
};

#if DBG
FIELD_DESCRIPTOR ReferenceTraceRecordFields[] =
{
    FIELD3(FieldTypeSymbol, ReferenceTraceRecord, Stack[0]),
    FIELD3(FieldTypeSymbol, ReferenceTraceRecord, Stack[1]),
    FIELD3(FieldTypeSymbol, ReferenceTraceRecord, Stack[2]),
    FIELD3(FieldTypeSymbol, ReferenceTraceRecord, Stack[3]),
    FIELD3(FieldTypeSymbol, ReferenceTraceRecord, Stack[4]),
    FIELD3(FieldTypeSymbol, ReferenceTraceRecord, Stack[5]),
    FIELD3(FieldTypeSymbol, ReferenceTraceRecord, Stack[6]),
    FIELD3(FieldTypeSymbol, ReferenceTraceRecord, Stack[7]),
    FIELD3(FieldTypeSymbol, ReferenceTraceRecord, Stack[8]),
    FIELD3(FieldTypeSymbol, ReferenceTraceRecord, Stack[9]),
    FIELD3(FieldTypePointer, ReferenceTraceRecord, pRefCount),
    FIELD3(FieldTypePointer, ReferenceTraceRecord, ClassName),
    FIELD3(FieldTypeLong, ReferenceTraceRecord, refs),
    FIELDLAST
};
#endif

FIELD_DESCRIPTOR SESSIONLISTNODEFields[] =
{
#if DBG
    FIELD3(FieldTypeULong, SESSIONLISTNODE, magicNo),
#endif
    FIELD3(FieldTypeULong, SESSIONLISTNODE, sessionID),
    FIELD3(FieldTypeStruct, SESSIONLISTNODE, requestListHead),
    FIELD3(FieldTypeStruct, SESSIONLISTNODE, eventListHead),
    FIELD3(FieldTypeStruct, SESSIONLISTNODE, listEntry),
    FIELDLAST
};

FIELD_DESCRIPTOR EVENTLISTNODEFields[] =
{
#if DBG
    FIELD3(FieldTypeULong, EVENTLISTNODE, magicNo),
#endif
    FIELD3(FieldTypePointer, EVENTLISTNODE, event),
    FIELD3(FieldTypeULong, EVENTLISTNODE, type),
    FIELD3(FieldTypeStruct, EVENTLISTNODE, listEntry),
    FIELDLAST
};

#define RDPDRPACKETCODE(Component, PacketId) \
    MAKELONG(Component, PacketId)

ENUM_VALUE_DESCRIPTOR EnumValueDescrsOf_PACKET_CODE [] =
{
    {RDPDRPACKETCODE(RDPDR_CTYP_CORE, DR_CORE_SERVER_ANNOUNCE), "RDPDR_SERVER_ANNOUNCE_PACKET@"},
    {RDPDRPACKETCODE(RDPDR_CTYP_CORE, DR_CORE_CLIENTID_CONFIRM), "DR_CORE_CLIENTID_CONFIRM_PACKET@"},
    {RDPDRPACKETCODE(RDPDR_CTYP_CORE, DR_CORE_CLIENT_NAME), "DR_CORE_CLIENT_NAME_PACKET@"},
    {RDPDRPACKETCODE(RDPDR_CTYP_CORE, DR_CORE_DEVICE_ANNOUNCE), "DR_CORE_DEVICE_ANNOUNCE@"},
    {RDPDRPACKETCODE(RDPDR_CTYP_CORE, DR_CORE_DEVICELIST_ANNOUNCE), "DR_CORE_DEVICELIST_ANNOUNCE_PACKET@"},
    {RDPDRPACKETCODE(RDPDR_CTYP_CORE, DR_CORE_DEVICELIST_REPLY), "DR_CORE_DEVICELIST_REPLY_PACKET@"},
    {RDPDRPACKETCODE(RDPDR_CTYP_CORE, DR_CORE_DEVICE_REPLY), "DR_CORE_DEVICE_REPLY_PACKET@"},
    {RDPDRPACKETCODE(RDPDR_CTYP_CORE, DR_CORE_DEVICE_IOREQUEST), "DR_CORE_DEVICE_IOREQUEST_PACKET@"},
    {RDPDRPACKETCODE(RDPDR_CTYP_CORE, DR_CORE_DEVICE_IOCOMPLETION), "DR_CORE_DEVICE_IOCOMPLETION_PACKET@"},
    {0, NULL}
};

FIELD_DESCRIPTOR RdpdrHeaderFields[] =
{
    FIELD3(FieldTypeUShort, RDPDR_HEADER, Component),
    FIELD3(FieldTypeUShort, RDPDR_HEADER, PacketId),
    FIELD4(FieldTypeEnum, RDPDR_HEADER, Component, EnumValueDescrsOf_PACKET_CODE),
    FIELDLAST
};

FIELD_DESCRIPTOR RdpdrServerAnnounceFields[] =
{
    FIELD3(FieldTypeUShort, RDPDR_HEADER, Component),
    FIELD3(FieldTypeUShort, RDPDR_HEADER, PacketId),
    FIELD4(FieldTypeEnum, RDPDR_HEADER, Component, EnumValueDescrsOf_PACKET_CODE),
    FIELD3(FieldTypeUShort, RDPDR_SERVER_ANNOUNCE_PACKET, VersionInfo.Major),
    FIELD3(FieldTypeUShort, RDPDR_SERVER_ANNOUNCE_PACKET, VersionInfo.Minor),
    FIELD3(FieldTypeULong, RDPDR_SERVER_ANNOUNCE_PACKET, ServerAnnounce.ClientId),
    FIELDLAST
};

FIELD_DESCRIPTOR RdpdrClientConfirmFields[] =
{
    FIELD3(FieldTypeUShort, RDPDR_HEADER, Component),
    FIELD3(FieldTypeUShort, RDPDR_HEADER, PacketId),
    FIELD4(FieldTypeEnum, RDPDR_HEADER, Component, EnumValueDescrsOf_PACKET_CODE),
    FIELD3(FieldTypeUShort, RDPDR_CLIENT_CONFIRM_PACKET, VersionInfo.Major),
    FIELD3(FieldTypeUShort, RDPDR_CLIENT_CONFIRM_PACKET, VersionInfo.Minor),
    FIELD3(FieldTypeULong, RDPDR_CLIENT_CONFIRM_PACKET, ClientConfirm.ClientId),
    FIELDLAST
};


FIELD_DESCRIPTOR RdpdrClientNameFields[] =
{
    FIELD3(FieldTypeUShort, RDPDR_HEADER, Component),
    FIELD3(FieldTypeUShort, RDPDR_HEADER, PacketId),
    FIELD4(FieldTypeEnum, RDPDR_HEADER, Component, EnumValueDescrsOf_PACKET_CODE),
//    FIELD3(FieldTypeULong, RDPDR_CLIENT_NAME_PACKET, (ULONG)Name.Unicode),
    FIELD3(FieldTypeULong, RDPDR_CLIENT_NAME_PACKET, Name.CodePage),
    FIELD3(FieldTypeULong, RDPDR_CLIENT_NAME_PACKET, Name.ComputerNameLen),
    FIELDLAST
};

FIELD_DESCRIPTOR RdpdrDeviceAnnounceFields[] =
{
    FIELD3(FieldTypeULong, RDPDR_DEVICE_ANNOUNCE, DeviceType),
    FIELD3(FieldTypeULong, RDPDR_DEVICE_ANNOUNCE, DeviceId),
    FIELD3(FieldTypeStruct, RDPDR_DEVICE_ANNOUNCE, PreferredDosName),
    FIELD3(FieldTypeULong, RDPDR_DEVICE_ANNOUNCE, DeviceDataLength),
    FIELDLAST
};

FIELD_DESCRIPTOR RdpdrDeviceListAnnounceFields[] =
{
    FIELD3(FieldTypeUShort, RDPDR_HEADER, Component),
    FIELD3(FieldTypeUShort, RDPDR_HEADER, PacketId),
    FIELD4(FieldTypeEnum, RDPDR_HEADER, Component, EnumValueDescrsOf_PACKET_CODE),
    FIELD3(FieldTypeULong, RDPDR_DEVICELIST_ANNOUNCE_PACKET, DeviceListAnnounce.DeviceCount),
    FIELD3(FieldTypeStruct, RDPDR_DEVICELIST_ANNOUNCE_PACKET, DeviceAnnounce),
    FIELDLAST
};

ENUM_VALUE_DESCRIPTOR EnumValueDescrsOf_DEVICE_REPLY_RESULT [] =
{
    {0, "RDPDR_DEVICE_REPLY_SUCCESS"},
    {1, "RDPDR_DEVICE_REPLY_REJECTED"},
    {0, NULL}
};

FIELD_DESCRIPTOR RdpdrDeviceReplyFields[] =
{
    FIELD3(FieldTypeUShort, RDPDR_HEADER, Component),
    FIELD3(FieldTypeUShort, RDPDR_HEADER, PacketId),
    FIELD4(FieldTypeEnum, RDPDR_HEADER, Component, EnumValueDescrsOf_PACKET_CODE),
    FIELD3(FieldTypeULong, RDPDR_DEVICE_REPLY_PACKET, DeviceReply.DeviceId),
    FIELD4(FieldTypeEnum, RDPDR_DEVICE_REPLY_PACKET, DeviceReply.ResultCode, EnumValueDescrsOf_DEVICE_REPLY_RESULT ),
    FIELDLAST
};

FIELD_DESCRIPTOR RdpdrUpdateDeviceInfoFields[] =
{
    FIELD3(FieldTypeUShort, RDPDR_HEADER, Component),
    FIELD3(FieldTypeUShort, RDPDR_HEADER, PacketId),
    FIELD4(FieldTypeEnum, RDPDR_HEADER, Component, EnumValueDescrsOf_PACKET_CODE),
    FIELD3(FieldTypeULong, RDPDR_UPDATE_DEVICEINFO_PACKET, DeviceUpdate.DeviceId),
    FIELD3(FieldTypeULong, RDPDR_UPDATE_DEVICEINFO_PACKET, DeviceUpdate.DeviceDataLength),
    FIELDLAST
};

ENUM_VALUE_DESCRIPTOR EnumValueDescrsOf_MAJOR_FUNCTION [] =
{
    {0x00, "IRP_MJ_CREATE"},
    {0x01, "IRP_MJ_CREATE_NAMED_PIPE"},
    {0x02, "IRP_MJ_CLOSE"},
    {0x03, "IRP_MJ_READ"},
    {0x04, "IRP_MJ_WRITE"},
    {0x05, "IRP_MJ_QUERY_INFORMATION"},
    {0x06, "IRP_MJ_SET_INFORMATION"},
    {0x07, "IRP_MJ_QUERY_EA"},
    {0x08, "IRP_MJ_SET_EA"},
    {0x09, "IRP_MJ_FLUSH_BUFFERS"},
    {0x0a, "IRP_MJ_QUERY_VOLUME_INFORMATION"},
    {0x0b, "IRP_MJ_SET_VOLUME_INFORMATION"},
    {0x0c, "IRP_MJ_DIRECTORY_CONTROL"},
    {0x0d, "IRP_MJ_FILE_SYSTEM_CONTROL"},
    {0x0e, "IRP_MJ_DEVICE_CONTROL"},
    {0x0f, "IRP_MJ_INTERNAL_DEVICE_CONTROL"},
    {0x10, "IRP_MJ_SHUTDOWN"},
    {0x11, "IRP_MJ_LOCK_CONTROL"},
    {0x12, "IRP_MJ_CLEANUP"},
    {0x13, "IRP_MJ_CREATE_MAILSLOT"},
    {0x14, "IRP_MJ_QUERY_SECURITY"},
    {0x15, "IRP_MJ_SET_SECURITY"},
    {0x16, "IRP_MJ_POWER"},
    {0x17, "IRP_MJ_SYSTEM_CONTROL"},
    {0x18, "IRP_MJ_DEVICE_CHANGE"},
    {0x19, "IRP_MJ_QUERY_QUOTA"},
    {0x1a, "IRP_MJ_SET_QUOTA"},
    {0x1b, "IRP_MJ_PNP"},
    {0x1b, "IRP_MJ_MAXIMUM_FUNCTION"},
    {0, NULL}
};

FIELD_DESCRIPTOR RdpdrIoRequestFields[] =
{
    FIELD3(FieldTypeUShort, RDPDR_HEADER, Component),
    FIELD3(FieldTypeUShort, RDPDR_HEADER, PacketId),
    FIELD4(FieldTypeEnum,  RDPDR_HEADER, Component, EnumValueDescrsOf_PACKET_CODE),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.DeviceId),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.FileId),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.CompletionId),
    FIELD4(FieldTypeEnum,  RDPDR_IOREQUEST_PACKET, IoRequest.MajorFunction, EnumValueDescrsOf_MAJOR_FUNCTION),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.MinorFunction),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.Create.DesiredAccess),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.Create.AllocationSize.u.HighPart),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.Create.AllocationSize.u.LowPart),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.Create.FileAttributes),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.Create.ShareAccess),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.Create.Disposition),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.Create.CreateOptions),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.Create.PathLength),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.Read.Length),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.Write.Length),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.DeviceIoControl.OutputBufferLength),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.DeviceIoControl.InputBufferLength),
    FIELD3(FieldTypeULong, RDPDR_IOREQUEST_PACKET, IoRequest.Parameters.DeviceIoControl.IoControlCode),
    FIELDLAST
};

FIELD_DESCRIPTOR RdpdrIoCompletionFields[] =
{
    FIELD3(FieldTypeUShort, RDPDR_HEADER, Component),
    FIELD3(FieldTypeUShort, RDPDR_HEADER, PacketId),
    FIELD4(FieldTypeEnum, RDPDR_HEADER, Component, EnumValueDescrsOf_PACKET_CODE),
    FIELD3(FieldTypeULong, RDPDR_IOCOMPLETION_PACKET, IoCompletion.DeviceId),
    FIELD3(FieldTypeULong, RDPDR_IOCOMPLETION_PACKET, IoCompletion.CompletionId),
    FIELD3(FieldTypeULong, RDPDR_IOCOMPLETION_PACKET, IoCompletion.IoStatus),
    FIELD3(FieldTypeULong, RDPDR_IOCOMPLETION_PACKET, IoCompletion.Parameters.Create.FileId),
    FIELD3(FieldTypeULong, RDPDR_IOCOMPLETION_PACKET, IoCompletion.Parameters.Read.Length),
    FIELD3(FieldTypeStruct, RDPDR_IOCOMPLETION_PACKET, IoCompletion.Parameters.Read.Buffer),
    FIELD3(FieldTypeULong, RDPDR_IOCOMPLETION_PACKET, IoCompletion.Parameters.Write.Length),
    FIELD3(FieldTypeULong, RDPDR_IOCOMPLETION_PACKET, IoCompletion.Parameters.DeviceIoControl.OutputBufferLength),
    FIELD3(FieldTypeStruct, RDPDR_IOCOMPLETION_PACKET, IoCompletion.Parameters.DeviceIoControl.OutputBuffer),
    FIELDLAST
};

#if DBG
ENUM_VALUE_DESCRIPTOR EnumValueDescrsOf_TRACE_LEVEL [] =
{
    {0, "TRC_LEVEL_DBG"},
    {1, "TRC_LEVEL_NRM"},
    {2, "TRC_LEVEL_ALT"},
    {3, "TRC_LEVEL_ERR"},
    {4, "TRC_LEVEL_ASSERT"},
    {5, "TRC_LEVEL_DIS"},
    {0, NULL}
};

FIELD_DESCRIPTOR TRC_CONFIGFields[] = 
{
    FIELD4(FieldTypeULong, TRC_CONFIG, TraceLevel, EnumValueDescrsOf_TRACE_LEVEL),
    FIELD3(FieldTypeULong, TRC_CONFIG, FunctionLength),
    FIELD3(FieldTypeULong, TRC_CONFIG, TraceDebugger),
    FIELD3(FieldTypeULong, TRC_CONFIG, TraceProfile),
    FIELD3(FieldTypeStruct, TRC_CONFIG, Prefix[0]),
    FIELD3(FieldTypeStruct, TRC_CONFIG, Prefix[1]),
    FIELDLAST
};


FIELD_DESCRIPTOR TRC_PREFIX_DATAFields[] = 
{
    FIELD3(FieldTypeStruct, TRC_PREFIX_DATA, name),
    FIELD3(FieldTypeULong, TRC_PREFIX_DATA, start),
    FIELD3(FieldTypeULong, TRC_PREFIX_DATA, end),
    FIELDLAST
};
#endif // DBG

//
// List of structs currently handled by the debugger extensions
//

STRUCT_DESCRIPTOR Structs[] =
   {
       STRUCT(RX_CONTEXT,RxContextFields,0xffff,RDBSS_NTC_RX_CONTEXT),
       STRUCT(FCB,FcbFields,0xeff0,RDBSS_STORAGE_NTC(0)),
       STRUCT(FCB,FcbFields,0xeff0,RDBSS_STORAGE_NTC(0xf0)),
       STRUCT(SRV_OPEN,SrvOpenFields,0xffff,RDBSS_NTC_SRVOPEN),
       STRUCT(FOBX,FobxFields,0xffff,RDBSS_NTC_FOBX),
       STRUCT(SRV_CALL,SrvCallFields,0xffff,RDBSS_NTC_SRVCALL),
       STRUCT(NET_ROOT,NetRootFields,0xffff,RDBSS_NTC_NETROOT),
       STRUCT(V_NET_ROOT,VNetRootFields,0xffff,RDBSS_NTC_V_NETROOT),
       STRUCT(CHANNELAPCCONTEXT,ChannelApcContextFields,0xffff,0),
       STRUCT(TopObj,TopObjFields,0xffff,0),
       STRUCT(DrExchangeManager,DrExchangeManagerFields,0xffff,0),
       STRUCT(DrExchange,DrExchangeFields,0xffff,0),
       STRUCT(DrIoContext,DrIoContextFields,0xffff,0),
       STRUCT(DrDeviceManager,DrDeviceManagerFields,0xffff,0),
       STRUCT(DoubleList,DoubleListFields,0xffff,0),
       STRUCT(KernelResource,KernelResourceFields,0xffff,0),
       STRUCT(VirtualChannel,VirtualChannelFields,0xffff,0),
       STRUCT(DrDevice,DrDeviceFields,0xffff,0),
       STRUCT(DrPrinterPort,DrPrinterPortFields,0xffff,0),
       STRUCT(DrParallelPort,DrParallelPortFields,0xffff,0),
       STRUCT(DrSerialPort,DrSerialPortFields,0xffff,0),
       STRUCT(DrSessionManager,DrSessionManagerFields,0xffff,0),
       STRUCT(DrSession,DrSessionFields,0xffff,0),
#if DBG
       STRUCT(ReferenceTraceRecord,ReferenceTraceRecordFields,0xffff,0),
#endif
       STRUCT(SESSIONLISTNODE,SESSIONLISTNODEFields,0xffff,0),
       STRUCT(EVENTLISTNODE,EVENTLISTNODEFields,0xffff,0),
       STRUCT(RDPDR_IOCOMPLETION_PACKET,RdpdrIoCompletionFields,0xffff,0),
       STRUCT(RDPDR_IOREQUEST_PACKET,RdpdrIoRequestFields,0xffff,0),
       STRUCT(RDPDR_UPDATE_DEVICEINFO_PACKET,RdpdrUpdateDeviceInfoFields,0xffff,0),
       STRUCT(RDPDR_DEVICE_REPLY_PACKET,RdpdrDeviceReplyFields,0xffff,0),
       STRUCT(RDPDR_DEVICELIST_ANNOUNCE_PACKET,RdpdrDeviceListAnnounceFields,0xffff,0),
       STRUCT(RDPDR_DEVICE_ANNOUNCE,RdpdrDeviceAnnounceFields,0xffff,0),
       STRUCT(RDPDR_CLIENT_NAME_PACKET,RdpdrClientNameFields,0xffff,0),
       STRUCT(RDPDR_CLIENT_CONFIRM_PACKET,RdpdrClientConfirmFields,0xffff,0),
       STRUCT(RDPDR_SERVER_ANNOUNCE_PACKET,RdpdrServerAnnounceFields,0xffff,0),
       STRUCT(RDPDR_HEADER,RdpdrHeaderFields,0xffff,0),
#if DBG
       STRUCT(TRC_CONFIG,TRC_CONFIGFields,0xffff,0),
       STRUCT(TRC_PREFIX_DATA,TRC_PREFIX_DATAFields,0xffff,0),
#endif // DBG
       STRUCTLAST
   };


ULONG_PTR FieldOffsetOfContextListEntryInRxC(){ return FIELD_OFFSET(RX_CONTEXT,ContextListEntry);}


PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture){
    switch (DebugeeArchitecture) {
    case RX_PROCESSOR_ARCHITECTURE_INTEL:
        return L"kdextx86.dll";
    case RX_PROCESSOR_ARCHITECTURE_MIPS:
        return L"kdextmip.dll";
    case RX_PROCESSOR_ARCHITECTURE_ALPHA:
        return L"kdextalp.dll";
    case RX_PROCESSOR_ARCHITECTURE_PPC:
        return L"kdextppc.dll";
    default:
        return(NULL);
    }
}

//CODE.IMPROVEMENT it is not good to try to structure along the lines of "this routine knows
//                 rxstructures" versus "this routine knows debugger extensions". also we
//                 need a precomp.h

BOOLEAN wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type);
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2)
{
    RX_CONTEXT RxContextBuffer;
    if (!wGetData(RxContext,&RxContextBuffer,sizeof(RxContextBuffer),"RxContextFieldss")) return;
    *pFcb = (ULONG_PTR)(RxContextBuffer.pFcb);
    *pThread = (ULONG_PTR)(RxContextBuffer.LastExecutionThread);
    *pMiniCtx2 = (ULONG_PTR)(RxContextBuffer.MRxContext[2]);
}

FOLLOWON_HELPER_RETURNS
__FollowOnError (
    OUT    PBYTE Buffer2,
    IN     PBYTE followontext,
    ULONG LastId,
    ULONG Index)
{
    if (LastId==0) {
        sprintf((char *)Buffer2,"Cant dump a %s. no previous dump.\n",
                 followontext,Index);
    } else {
        sprintf((char *)Buffer2,"Cant dump a %s from a %s\n",
                 followontext,Structs[Index].StructName);
    }
    return(FOLLOWONHELPER_ERROR);
}
#define FollowOnError(A) (__FollowOnError(Buffer2,A,p->IdOfLastDump,p->IndexOfLastDump))

VOID dprintfsprintfbuffer(BYTE *Buffer);


DECLARE_FOLLOWON_HELPER_CALLEE(FcbFollowOn)
{
    //BYTE DbgBuf[200];
    //sprintf(DbgBuf,"top p,id=%08lx,%d",p,p->IdOfLastDump);
    //dprintfsprintfbuffer(DbgBuf);

    switch (p->IdOfLastDump) {
    case StrEnum_RX_CONTEXT:{
        PRX_CONTEXT RxContext = (PRX_CONTEXT)(&p->StructDumpBuffer[0]);
        sprintf((char *)Buffer2," %08p\n",RxContext->pFcb);
        return(FOLLOWONHELPER_DUMP);
        }
        break;
    default:
        return FollowOnError((PUCHAR)"irp");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\drkdx\wdbgxlib.cpp ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    wdbgxlib.c

Abstract:

    This module realizes most of the routines needed for the rdbss/smbmini debugger extension.

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created
    11-Nov-1995         Changed to newer windbg apis

--*/

#define KDEXT_32BIT
#include "rxovride.h" //common compile flags
#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <rdpdrkd.h>

#include <ntrxdef.h>
#include <rxtypes.h>
extern "C" {
#include <rxlog.h>
}

#include "dbg.h"
#include "topobj.h"
#include "smartptr.h"
#include "trc.h"

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

BOOL ParseTrc(PCSTR args, DWORD *dwLines);

#define    ERRPRT     dprintf

#define    NL      1
#define    NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL   ChkTarget;            // is debuggee a CHK build?


/*
 * Print out an optional message, an ANSI_STRING, and maybe a new-line
 */
BOOL
wPrintStringA( IN LPSTR msg OPTIONAL, IN PANSI_STRING pStr, IN BOOL nl )
{
    PCHAR    StringData;
    ULONG    BytesRead;

    if( msg )
        dprintf( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            dprintf( "\n" );
        return TRUE;
    }

    StringData = (PCHAR)LocalAlloc( LPTR, pStr->Length + 1 );

    if( StringData == NULL ) {
        ERRPRT( "Out of memory!\n" );
        return FALSE;
    }

    ReadMemory( (ULONG_PTR)pStr->Buffer,
               StringData,
               pStr->Length,
               &BytesRead );

    if ( BytesRead ) {
        StringData[ pStr->Length ] = '\0';
        dprintf("%s%s", StringData, nl ? "\n" : "" );
    }

    LocalFree((HLOCAL)StringData);

    return BytesRead;
}

/*
 * Fetches the data at the given address
 */
BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type)
{
    BOOL b;
    ULONG BytesRead;

    b = ReadMemory( dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        dprintf( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
wGetString( ULONG_PTR dwAddress, PSZ buf )
{
    for(;;) {
        if( !wGetData( dwAddress,buf, 1, "..stringfetch") ){
            //dprintf("readfailure at %08lx\n",dwAddress);
            return FALSE;
        }

        //dprintf ("stringing %08lx %08lx %c\n", dwAddress, buf,
        //                                     ((*buf==0)?'.':*buf) );

        if ( *buf == '\0' ) { break; }

        dwAddress++;
        buf++;

    };

    return TRUE;
}

#if 0
/*
 * Get 'size' bytes from the debuggee program at 'dwAddress' and place it
 * in our address space at 'ptr'.  Use 'type' in an error printout if necessary
 */
BOOL
wGetData_srv( IN LPVOID ptr, IN ULONG_PTR dwAddress, IN ULONG size, IN PCSTR type )
{
    BOOL b;
    ULONG BytesRead;
    ULONG count;

    while( size > 0 ) {

        count = min( size, 3000 );

        b = ReadMemory((ULONG) dwAddress, ptr, count, &BytesRead );

        if (!b || BytesRead != count ) {
            ERRPRT( "Unable to read %u bytes at %X, for %s\n", size, dwAddress, type );
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG)ptr + count);
    }

    return TRUE;
}

/*
 * Follow a LIST_ENTRY list beginning with a head at dwListHeadAddr in the debugee's
 * address space.  For each element in the list, print out the pointer value at 'offset'
 */
BOOL
PrintListEntryList( IN ULONG_PTR dwListHeadAddr, IN LONG offset )
{
    LIST_ENTRY    ListEntry;
    ULONG i=0;
    BOOL retval = TRUE;
    ULONG count = 20;

    if( !wGetData_srv( &ListEntry, dwListHeadAddr, sizeof( ListEntry ), "LIST_ENTRY" ) )
        return FALSE;

    while( count-- ) {

        if( (ULONG_PTR)ListEntry.Flink == dwListHeadAddr || (ULONG_PTR)ListEntry.Flink == 0 )
            break;

        if( !wGetData_srv( &ListEntry, (ULONG_PTR)ListEntry.Flink, sizeof( ListEntry ), "ListEntry" ) ) {
            retval = FALSE;
            break;
        }

        dprintf( "%16X%s", (LONG)ListEntry.Flink + offset, (i && !(i&3)) ? "\n" : "" );
        i++;
    }


    if( count == 0 && (ULONG_PTR)ListEntry.Flink != dwListHeadAddr && ListEntry.Flink ) {
        dprintf( "\nTruncated list dump\n" );

    } else if( ! ( i && !(i&3) ) ) {
        dprintf( "\n" );
    }

    return retval;
}
#endif

/*
 * Print out a single HEX character
 */
VOID
wPrintHexChar( IN UCHAR c )
{
    dprintf( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Print out 'buf' of 'cbuf' bytes as HEX characters
 */
VOID
wPrintHexBuf( IN PUCHAR buf, IN ULONG cbuf )
{
    while( cbuf-- ) {
        wPrintHexChar( *buf++ );
        dprintf( " " );
    }
}

#if 0
/*
 * Fetch the null terminated UNICODE string at dwAddress into buf
 */
BOOL
GetString( IN ULONG_PTR dwAddress, IN LPWSTR buf, IN ULONG MaxChars )
{
    do {
        if( !wGetData_srv( buf, dwAddress, sizeof( *buf ), "UNICODE Character" ) )
            return FALSE;

        dwAddress += sizeof( *buf );

    } while( --MaxChars && *buf++ != '\0' );

    return TRUE;
}
#endif

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
//    ExtensionApis = *lpExtensionApis;
    memcpy(&ExtensionApis, lpExtensionApis, sizeof(ExtensionApis));
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf(
        "%s RDBSS+RdpDr Extension dll for Build %d debugging %s kernel for Build %d\n",
                    kind,
                    VER_PRODUCTBUILD,
                    SavedMajorVersion == 0x0c ? "Checked" : "Free",
                    SavedMinorVersion
    );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

LPSTR LibCommands[] = {
    "dump <Struct Type Name>@<address expr> ",
    "listref [address of specific RefCount object]"
    "ddd <address expr> -- dump using context"
    "columns <d> -- controls the number of columns in the display ",
    "lg [<logentries>][@filename] -- dump the log",
    "gv -- dump out important variables",
    "activerx [fcbtomatch]-- dump the list of active contexts",
    "flags <value>-- print which flags are actually set (no text yet)",
    "cxr -- looks up cxr value from memory and does !cxr/!kb",
    "irp,thread,fcb,fobx,srvopen,exchange,stuff,smbbuf -- dumps the named item from the last dumpee",
    "version",
    0
};

DECLARE_API( help )
{
    int i;

    dprintf( "\nRDBSS debugger extensions:\n");

    for( i=0; LibCommands[i]; i++ )
        dprintf( "   %s\n", LibCommands[i] );
}


ULONG FieldOffsetOfContextListEntryInRxC();
VOID  ReadRxContextFields(ULONG_PTR RxContext,PULONG_PTR pFcb,PULONG_PTR pThread, PULONG_PTR pMiniCtx2);
DECLARE_API( dump );
DECLARE_API( activerx )
{
    //ULONG dwAddress;
    LIST_ENTRY LEbuffer;
    PLIST_ENTRY pRxActiveContexts,pListEntry;
    ULONG_PTR RxContext,CapturedFcb,LastThread,MinirdrCtx2;
    ULONG_PTR MatchFcb = 0x1badf00d;

    pRxActiveContexts = pListEntry = (PLIST_ENTRY)GetExpression("rdpdr!RxActiveContexts");

    if( args && *args ) {
        MatchFcb = GetExpression( args );
    }

    dprintf("\n Firstplentry: %08lx\n", pListEntry);

    for (;;) {
        if (!wGetData((ULONG_PTR)pListEntry,&LEbuffer,sizeof(LEbuffer),"RxActiveContexts")) return;
        if (LEbuffer.Flink == pRxActiveContexts) {
            if (pRxActiveContexts == pListEntry){
                dprintf("Active RxContext List Empty!\n");
            }
            return;
        }
        RxContext = ((ULONG_PTR)LEbuffer.Flink)-FieldOffsetOfContextListEntryInRxC();
        CapturedFcb = LastThread = 0x0badf00d;
        ReadRxContextFields(RxContext,&CapturedFcb,&LastThread,&MinirdrCtx2);
        if (MatchFcb == 0x1badf00d) {
            dprintf("%08lx: %08lx %08lx:  %08lx %08lx %08lx %08lx\n", pListEntry,
                           LEbuffer.Flink,LEbuffer.Blink,RxContext,CapturedFcb,LastThread,MinirdrCtx2);
        } else if ((MatchFcb == CapturedFcb)
                         || (MatchFcb == LastThread) ) {
            // if a matchfcb is specified and we have a match, the print and dump
            char Bufferqq[100];
            dprintf("%08lx: %08lx %08lx:  %08lx %08lx %08lx %08lx\n", pListEntry,
                           LEbuffer.Flink,LEbuffer.Blink,RxContext,CapturedFcb,LastThread,MinirdrCtx2);
            sprintf(Bufferqq," %08lx ",RxContext);
            dump( hCurrentProcess,
                  hCurrentThread,
                  dwCurrentPc,
                  dwProcessor,
                  Bufferqq
                  );

        }
        pListEntry = LEbuffer.Flink;
    }
}


#define GV_dprintf(__FORMAT__,__NAME__,__VALUE__) { \
        dprintf( "%s%-30s %08lx " __FORMAT__ "%s",  \
            c&1 ? "    " : "",                      \
            __NAME__,                               \
            dwAddress,                              \
            __VALUE__,                              \
            c&1 ? "\n" : "" );                      \
}
DECLARE_API( gv )
{
    ULONG_PTR dwAddress;
    CHAR buf[ 100 ];
    int i;
    int c=0;

    //CODE.IMPROVEMENT maybe we should hallucinate the moduleprefix instead
    // of having to specify it
    //CODE.IMPROVEMENT if we're not doing that, we shouldn't copy the name!

    //cause stuff to be loaded before we start printing
    dwAddress = GetExpression( "rdpdr!RxExpCXR" );
    dwAddress = GetExpression( "mrxsmb!SmbMmExchangesInUse" );

    for( i=0; GlobalBool[i]; i++, c++ ) {
        BOOL b;

        strcpy( &buf[0], GlobalBool[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalBool[i] );
            continue;
        }
        if( !wGetData( dwAddress,&b, sizeof(b), "global BOOL") ) continue;

        GV_dprintf("%10s",GlobalBool[i],(b ? " TRUE" : "FALSE"));
    }

    for( i=0; GlobalShort[i]; i++, c++ ) {
        SHORT s;

        strcpy( &buf[0], GlobalShort[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalShort[i] );
            continue;
        }
        if( !wGetData( dwAddress,&s,sizeof(s), "global SHORT") )  continue;

        GV_dprintf("%10d",GlobalShort[i],s);
    }

    for( i=0; GlobalLong[i]; i++, c++ ) {
        LONG l;

        strcpy( &buf[0], GlobalLong[i] );
        dwAddress = GetExpression( buf );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalLong[i] );
            continue;
        }
        if( !wGetData( dwAddress,&l, sizeof(l), "global LONG") )  continue;

        GV_dprintf("%10d",GlobalLong[i],l);
    }

    for( i=0; GlobalPtrs[i]; i++, c++ ) {
        LONG l;

        //ERRPRT( "zaaaaa %s\n", GlobalPtrs[i] );
        strcpy( &buf[0], GlobalPtrs[i] );
        dwAddress = GetExpression( buf );
        //ERRPRT( "zbbbbb %s %08lx\n", GlobalPtrs[i], dwAddress );
        if( dwAddress == 0 ) {
            ERRPRT( "Unable to get address of %s\n", GlobalPtrs[i] );
            continue;
        }
        if( !wGetData( dwAddress,&l, sizeof(l), "global PTR") )  continue;
        //ERRPRT( "zccccc %s %08lx\n", GlobalPtrs[i], dwAddress );

        GV_dprintf("  %08lx",GlobalPtrs[i],l);
    }

    dprintf( "\n" );
}



HANDLE DumpFile;
CHAR wwDumpFormat[] = "-%06d:  %s\n";
VOID DumpRoutine(
    ULONG EntryNumber,
    PSZ   OriginalStringToPrint
    )
{
    UCHAR Buffer[200];
    UCHAR StringToPrint[160];
    PUCHAR p,q,r; LONG i;
    ULONG n,l3,l2,l1,l0; UCHAR Numbuf[32];
    ULONG ReturnedSize;

    //dprintf("before %d\n",EntryNumber);
    for (p=(PUCHAR)OriginalStringToPrint,q=StringToPrint,i=160;;) {
        PSZ format=NULL;

        if (*p==0) break;

        if (*p==0x4) {
            format = "%lx";
        } else if (*p==0x5) {
            format = "%ld";
        } else if (*p < ' ') {
            p++;i--;continue;
        }

        if (format!=NULL) {
            LONG Length;
            //translate the number
            p++;
            l0=*p++;
            l1=(*p++)<<8;
            l2=(*p++)<<16;
            l3=(*p++)<<24;
            n = l0 + l1 + l2 + l3;
            //dprintf("yaya %d %08lx %08lx %08lx %08lx %08lx\n",n,n,l0,l1,l2,l3);
            Length = sprintf((char *)Numbuf,format,n);
            if (Length <= i) {
                for (r=Numbuf;*r;) { *q++ = *r++; }
                i -= Length;
            } else {
                i = 0;
            }
            if (i>0) continue;
        }
        if (i<=0) break;
        *q++ = *p++; i--;
    }
    *q = 0;

    //dprintf("after %d\n",EntryNumber);
    if (DumpFile == INVALID_HANDLE_VALUE) {
        dprintf(wwDumpFormat,EntryNumber,StringToPrint);
        return;
    }
    sprintf((char *)Buffer,wwDumpFormat,EntryNumber,StringToPrint);
    WriteFile(DumpFile,Buffer,strlen((char *)Buffer),&ReturnedSize,NULL);
    //should i check??
    return;
}


DECLARE_API( lg )
{
    ULONG_PTR dwAddress;
    BYTE DataBuffer[MAX_RX_LOG_ENTRY_SIZE];
    BYTE AlternateLine[110];
    RX_LOG RxLog;
    ULONG LogEntries = 30;
    BOOLEAN LogEntriesSpecified = FALSE;
    PRX_LOG_ENTRY_HEADER CurrentEntry;

    //SETCALLBACKS();
    dwAddress = GetExpression("rdpdr!s_RxLog");
    if (!wGetData(dwAddress,&RxLog,sizeof(RX_LOG),"RxLog")) return;


    DumpFile = INVALID_HANDLE_VALUE;
    if( args && *args ) {
        LPSTR lpArgs;
        for (;*args;) {
            if (*args=='@') { break;}
            if ((*args>='0') && (*args<='9')) {
                sscanf(args,"%ld",&LogEntries);
                LogEntriesSpecified = TRUE;
                break;
            }
            args++;
        }
        lpArgs = strpbrk(args, "@");
        if (lpArgs) {
            DumpFile = CreateFileA(lpArgs+1,
                       GENERIC_READ|GENERIC_WRITE,0,
                       NULL,
                       CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
            if (DumpFile == INVALID_HANDLE_VALUE){
                ULONG rc = LOWORD(GetLastError());
                dprintf("Error Opening <%s> is %d.",lpArgs+1,rc);
                return;
            }
            if (!LogEntriesSpecified) {
                LogEntries = 99999999; //this will be reset to the right size
            }
        }
    }


    // Dump the log header followed by the log entries ...

    dprintf("s_RxLog.State                    %lx\n",RxLog.State);
    dprintf("s_RxLog.CurrentEntry             %lx\n",RxLog.CurrentEntry);
    dprintf("s_RxLog.BaseEntry                %lx\n",RxLog.BaseEntry);
    dprintf("s_RxLog.EntryLimit               %lx\n",RxLog.EntryLimit);
    dprintf("s_RxLog.LogBufferSizeInEntries   %ld\n",RxLog.LogBufferSizeInEntries);
    dprintf("s_RxLog.NumberOfEntriesIgnored   %ld\n",RxLog.NumberOfEntriesIgnored);
    dprintf("s_RxLog.NumberOfLogWriteAttempts %ld\n",RxLog.NumberOfLogWriteAttempts);
    dprintf("s_RxLog.NumberOfLogWraps         %ld\n",RxLog.NumberOfLogWraps);

    if (LogEntries > RxLog.LogBufferSizeInEntries) {
        LogEntries = RxLog.LogBufferSizeInEntries;
    }
    if (LogEntries < 1) {
        LogEntries = 1;
    }

    CurrentEntry = RxLog.CurrentEntry;
    CurrentEntry -= (LogEntries-1);
    if (CurrentEntry < RxLog.BaseEntry) {
        CurrentEntry += (RxLog.EntryLimit - RxLog.BaseEntry);
    }

    for (;;) {
        ULONG TextPtr;
        BOOLEAN ExtraOrdinaryLogEntry;
        LogEntries--;
        if ( CheckControlC() ) {
            return;
        }
        if (!wGetData((ULONG_PTR)CurrentEntry,&TextPtr,sizeof(TextPtr),"TextPtr")) return;
        if (!wGetData(TextPtr,&DataBuffer[0],sizeof(DataBuffer),"LogEntryBuffer")) return;

        ExtraOrdinaryLogEntry = (DataBuffer[0] == '#')&&(DataBuffer[1] == '>')&&(DataBuffer[3] == 0);

        if (!ExtraOrdinaryLogEntry) {
            //dprintf("-%06d:  %s\n",LogEntries,DataBuffer);
            DumpRoutine(LogEntries,(char *)DataBuffer);
        } else {
            ULONG BinaryArgs = DataBuffer[2]-'0';
            PULONG_PTR x = (PULONG_PTR)&DataBuffer[sizeof(ULONG_PTR)];
            char Buffers[12*100]; //CODE.IMPROVEMENT this is stupid but effective
            ULONG i;
            ULONG_PTR BinaryStringMask;
            PSZ ffFormat;

            //dprintf("textptr = %08lx, binaryString = %08lx\n", TextPtr, x[0]);
            for (i=1,BinaryStringMask=x[0];i<=BinaryArgs;i++) {
                if (BinaryStringMask & (1<<(i-1))) {
                    //dprintf("Stringing %d\n",i);
                    wGetString(x[i],&Buffers[i*100]); //this could fail!!!!
                    x[i] = ((ULONG_PTR)&Buffers[i*100]);
                    //dprintf("    string is %s\n",x[i]);
                }
            }

            ffFormat = (PSZ)(x[1]);

            switch (BinaryArgs) {
            case 9:
                sprintf((char *)AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7],x[8],x[9]);
                break;
            case 8:
                sprintf((char *)AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7],x[8]);
                break;
            case 7:
                sprintf((char *)AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6],x[7]);
                break;
            case 6:
                sprintf((char *)AlternateLine,ffFormat,x[2],x[3],x[4],x[5],x[6]);
                break;
            case 5:
                sprintf((char *)AlternateLine,ffFormat,x[2],x[3],x[4],x[5]);
                break;
            case 4:
                sprintf((char *)AlternateLine,ffFormat,x[2],x[3],x[4]);
                break;
            case 3:
                sprintf((char *)AlternateLine,ffFormat,x[2],x[3]);
                break;
            case 2:
                sprintf((char *)AlternateLine,ffFormat,x[2]);
                break;
            case 1:
                sprintf((char *)AlternateLine,ffFormat);
                break;
            }
            DumpRoutine(LogEntries,(char *)AlternateLine);
        }
        if (LogEntries==0) break;
        CurrentEntry++;
        if (CurrentEntry==RxLog.EntryLimit) {
            CurrentEntry = RxLog.BaseEntry;
        }
    }

    if (DumpFile != INVALID_HANDLE_VALUE) {
        CloseHandle(DumpFile);
        DumpFile = INVALID_HANDLE_VALUE;
    }
}


PCWSTR   ExtensionLib   = NULL;
HANDLE   hExtensionMod  = NULL;
ULONG    DebugeeArchitecture = 0;

PCWSTR   GetExtensionLibPerDebugeeArchitecture(ULONG DebugeeArchitecture);

PWINDBG_EXTENSION_ROUTINE
GetKdExtProcAddress(
    IN PCSTR FuncName
    )
{
    PWINDBG_EXTENSION_ROUTINE       WindbgExtRoutine     = NULL;
    //dprintf( "yaya\n");
    if (hExtensionMod == NULL) {
        if (DebugeeArchitecture == 0) {
            ULONG_PTR pArchitecture;
            ReloadSymbols(" rdbss.sys");
            pArchitecture = GetExpression("rdpdr!RxProcessorArchitecture");
            if (pArchitecture==0) {
                dprintf("couldn't get architecture value...\n");
                return NULL;
            }
            if (!wGetData(pArchitecture,&DebugeeArchitecture,sizeof(DebugeeArchitecture),"RxArch")) return NULL;
            if ((DebugeeArchitecture&0x0fff0000) != 0xabc0000) {
                dprintf("\n Bad DebugeeArchitecture %08lx\n", DebugeeArchitecture);
                return(NULL);
            }
            DebugeeArchitecture &= 0xffff;
        }

        ExtensionLib = GetExtensionLibPerDebugeeArchitecture(DebugeeArchitecture);
        if (ExtensionLib == NULL) {
            dprintf( "bad debuggee arch\n");
            return(NULL);
        }

        hExtensionMod = LoadLibrary( ExtensionLib );
        if (hExtensionMod == NULL) {
            dprintf( "couldn't load %ws\n", ExtensionLib );
            return(NULL);
        }

    }

    WindbgExtRoutine = (PWINDBG_EXTENSION_ROUTINE)GetProcAddress( (HINSTANCE)hExtensionMod, FuncName );
    if (WindbgExtRoutine == NULL) {
        dprintf( "couldn't find %ws%s\n", ExtensionLib, FuncName );
    }
    return WindbgExtRoutine;
}

#define CALL_THRU(NAME,ARGS) { \
    PWINDBG_EXTENSION_ROUTINE       WindbgExtRoutine     = GetKdExtProcAddress(NAME); \
    if (WindbgExtRoutine != NULL) {                                                   \
        (WindbgExtRoutine)( hCurrentProcess,                                          \
                            hCurrentThread,                                           \
                            dwCurrentPc,                                              \
                            dwProcessor,                                              \
                            ARGS                                                      \
                            );                                                        \
    }                                                                                 \
}

DECLARE_API( testr )
{

    CALL_THRU ( "threadfields", "");
}

DECLARE_API( dump );
VOID
__FollowOnHelper (
     PFOLLOWON_HELPER_ROUTINE Callee,
     HANDLE                 hCurrentProcess,
     HANDLE                 hCurrentThread,
     ULONG                  dwCurrentPc,
     ULONG                  dwProcessor,
     PCSTR                  args
     )
{
    BYTE Name[100], Buffer2[200];
    FOLLOWON_HELPER_RETURNS ret;
    PPERSISTENT_RDPDRKD_INFO p;

    p = LocatePersistentInfoFromView();

    if (!p) {
        dprintf("Couldn't allocate perstistent info buffer...sorry...\n");
        return;
    }

    ret = Callee(p,Name,Buffer2);
    if (p!= NULL) FreePersistentInfoView(p);
    p = NULL;

    switch (ret) {

    case FOLLOWONHELPER_DUMP:
        dump(hCurrentProcess,
             hCurrentThread,
             dwCurrentPc,
             dwProcessor,
             (char *)Buffer2
             );
        break;

    case FOLLOWONHELPER_CALLTHRU:
        CALL_THRU ( (char *)Name, (char *)Buffer2);
        break;

    case FOLLOWONHELPER_ERROR:
        dprintf("%s",Buffer2);
        break;

    case FOLLOWONHELPER_DONE:
        break;
    }

    return;
}
#define FollowOnHelper(a) {            \
    __FollowOnHelper(a,                \
                     hCurrentProcess,  \
                     hCurrentThread,   \
                     dwCurrentPc,      \
                     dwProcessor,      \
                     args);            \
}

DECLARE_FOLLOWON_HELPER_CALLEE(FcbFollowOn);
DECLARE_API( fcb )
{
    FollowOnHelper(FcbFollowOn);
}


DECLARE_API( flags )
{
    ULONG i,mask,newline,value;

    if( args && *args ) {
        sscanf(args,"%lx",&value);
        dprintf("Flags for %08lx\n",value);
    } else {
        dprintf("error in flags: no value presented\n");
        return;
    }

    for (i=newline=0,mask=1;i<32;i++,mask<<=1) {
        if (value&mask) {
            dprintf("    %02d 0x%08lx%c",i,mask,(newline==0)?' ':'\n');
            newline ^= 1;
        }
    }
    if (newline) {
        dprintf("\n");
    }
}

DECLARE_API( cxr )
{
    ULONG_PTR dwAddress,cxr;
    BYTE NumBuffer[16];
    RX_LOG RxLog;
    ULONG LogEntries = 30;
    PRX_LOG_ENTRY_HEADER CurrentEntry;

    //SETCALLBACKS();


    dwAddress = GetExpression("rdpdr!RxExpCXR");
    if (!wGetData(dwAddress,&cxr,sizeof(cxr),"cxr")) return;

    dprintf("\nRxExpCXR=%08lx\n",cxr);
    sprintf((char *)NumBuffer,"%08lx \n",cxr);

    CALL_THRU ( "cxr", (char *)NumBuffer);
    if (DebugeeArchitecture==0) {
        CALL_THRU ( "kb", "");
    }

}

VOID dprintfsprintfbuffer(BYTE *Buffer)
{
    dprintf("%s\n",Buffer);
}

DECLARE_API(ddd);

#if DBG
VOID ListRefs(ULONG_PTR dwAddress, BOOL ShowStack,
              HANDLE                 hCurrentProcess,
        HANDLE                 hCurrentThread,
        ULONG                  dwCurrentPc,
        ULONG                  dwProcessor)
{
    ULONG_PTR dwRecordListAddr;
    ULONG_PTR dwCurrentAddr;
    ULONG_PTR dwAddr;
    ReferenceTraceRecord CurrentRecord;
    ULONG_PTR dwTotalRefs;
    ULONG_PTR dwRefs;
    ULONG_PTR dwRefsPrinted;
    char szObjectName[32];

    dwRecordListAddr = GetExpression("rdpdr!RefCount___TraceRecordList");
    if (dwRecordListAddr == 0) {
        dprintf("Unable to get address of rdpdr!RefCount___TraceRecordList\n");
        return;
    }
    dwAddr = GetExpression("rdpdr!RefCount___dwReferenceTraceIndex");
    if (dwAddr == 0) {
        dprintf("Unable to get address of rdpdr!RefCount___dwReferenceTraceIndex\n");
        return;
    }
    if (!wGetData(dwAddr, &dwTotalRefs, sizeof(dwTotalRefs), "ULONG_PTR")) {
        return;
    }

    if (dwAddress != 0xFFFFFFFF) {
        dprintf("dumping references to object %p\n", dwAddress);
    }
    dprintf("TraceRecord References ObjectPointer ObjectType\n");
    dwCurrentAddr = dwRecordListAddr;
    dwRefs = 0;
    dwRefsPrinted = 0;
    while(dwRefs < dwTotalRefs && dwCurrentAddr < dwRecordListAddr + sizeof(RefCount::_TraceRecordList))
    {
        if (wGetData(dwCurrentAddr, &CurrentRecord, sizeof(CurrentRecord), "ReferenceTraceRecord")) {
            
            if (wGetData((ULONG_PTR)CurrentRecord.ClassName, &szObjectName, sizeof(szObjectName), "Object Name")) {
                szObjectName[sizeof(szObjectName) - 1] = 0;
            } else {
                szObjectName[0] = 0;
            }
            if (dwAddress == 0xFFFFFFFF || (ULONG_PTR)CurrentRecord.pRefCount == dwAddress) {
                dprintf("%p    %p   %p   %s\n", dwCurrentAddr, CurrentRecord.refs, CurrentRecord.pRefCount, szObjectName);
                dwRefsPrinted++;
                if (ShowStack) {
                    char szCmd[32];

                    sprintf(szCmd, "ReferenceTraceRecord@%p", dwCurrentAddr);
                    ddd(hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor, szCmd);
                }
            }
        } else {
            break;
        }
        dwCurrentAddr += sizeof(CurrentRecord);
        dwRefs++;
    }
    dprintf("Printed %ld of %ld paged in objects of %ld records\n", dwRefsPrinted, dwRefs, dwTotalRefs);
}
#endif

DECLARE_API( trc )
{
    #if DBG
    ULONG_PTR dwRecentTracesAddr;
    ULONG_PTR dwCurrentMsgAddr;
    ULONG_PTR dwCurrentAddr;
    ULONG_PTR dwCurrentMsg;
    ULONG_PTR dwFirstLine;
    ULONG_PTR dwFinalLine;
    ULONG_PTR dwCurrentLine;
    ULONG_PTR dwLinesToPrint;
    ULONG_PTR dwLines = 0;
    char szTraceLine[TRC_BUFFER_SIZE];

    if (!ParseTrc(args, &dwLines)) {
        return;
    }

    dwRecentTracesAddr = GetExpression("rdpdr!TRC_RecentTraces");
    if (dwRecentTracesAddr == 0) {
        dprintf("Unable to get address of rdpdr!TRC_RecentTraces\n");
        return;
    }

    dwCurrentMsgAddr = GetExpression("rdpdr!TRC_CurrentMsg");
    if (dwCurrentMsgAddr == 0) {
        dprintf("Unable to get address of rdpdr!TRC_CurrentMsg\n");
        return;
    }

    //
    // Look up how many traces have been done
    //
    if (!wGetData(dwCurrentMsgAddr, &dwCurrentMsg, sizeof(dwCurrentMsg), "ULONG_PTR")) {
        return;
    }

    if (dwCurrentMsg == 0xFFFFFFFF) {
        dprintf("No tracing\n");
        return;
    }

    dprintf("Total Traces: %ld\n", dwCurrentMsg);


    if (dwCurrentMsg > TRC_RamMsgMask) {

        //
        // We wrapped at least once
        //

        dwFirstLine = (dwCurrentMsg + 1) & TRC_RamMsgMask;
        dwFinalLine = (dwCurrentMsg) & TRC_RamMsgMask;
        dwLinesToPrint = TRC_RamMsgMax;
    } else {
        dwFirstLine = 0;
        dwFinalLine = dwCurrentMsg;
        dwLinesToPrint = dwFinalLine + 1;
    }

    if (dwLinesToPrint > dwLines) {
        // Advance first line by the difference
        dwFirstLine = (dwFirstLine + (dwLinesToPrint - dwLines)) & TRC_RamMsgMask;

        // Adjust number of lines downward
        dwLinesToPrint = dwLines;

    }

    dwCurrentLine = dwFirstLine;

    while(dwLinesToPrint > 0)
    {
        dwCurrentAddr = dwRecentTracesAddr + dwCurrentLine * TRC_BUFFER_SIZE;
        if (wGetData(dwCurrentAddr, &szTraceLine[0], sizeof(szTraceLine), "TraceLine")) {
            dprintf("%s", szTraceLine);
        } else {
            break;
        }
        dwCurrentLine = (dwCurrentLine + 1) & TRC_RamMsgMask;
        dwLinesToPrint--;
    }
    #endif
}

#if DBG
BOOL ParseTrc(PCSTR args, DWORD *dwLines)
{
    PCSTR p = args;
    enum tagParseState {
        Nominal,
        Usage,
        PostMinus,
        StartLines,
        Lines
    } ParseState = Nominal;
    DWORD LinesT = 0;

    if (args == NULL) {
        return TRUE;
    }

    while (ParseState != Usage && *p) {
        switch(ParseState) {
        case Nominal:
            switch (*p) {
            case '-':
                ParseState = PostMinus;
                break;
            case ' ':
            case '\t':
                break;
            default:
                ParseState = Usage;
            }
            break;

        case PostMinus:
            switch (*p) {
            case 'l':
                ParseState = StartLines;
                break;

            default:
                ParseState = Usage;
            
            }
            break;

        case Lines:
        case StartLines:
            int i;
            
            i = (*p) - '0';
            if (i >= 0 && i <= 9) {
                //
                // Now past initial whitespace
                //
                ParseState = Lines;
                LinesT *= 10;
                LinesT += i;
            } else {
                switch (*p) {
                case ' ':
                case '\t':
                    if (ParseState == Lines) {
                        // Must be done
                        ParseState = Nominal;
                    } // else skip initial whitespace
                    break;

                default:
                    ParseState = Usage;
                }
            }
            break;
        }
        p++;
    }

    if (ParseState == Usage) {
        dprintf("Error in arguments: %s\n", args);
        dprintf("                    %*c\n", p - args, '^');
        dprintf("usage: trc [-l] [<numlines>]\n\n");
        dprintf("   numlines: number of lines to trace\n");
        return FALSE;
    } else {
        *dwLines = LinesT;
        return TRUE;
    }
}

#endif // DBG

DECLARE_API( listref )
{
    ULONG_PTR RefObj = 0xFFFFFFFF;

    if( args && *args ) {
        RefObj = GetExpression( args );
    }
#if DBG
    ListRefs(RefObj, FALSE, hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor);
#endif
}

DECLARE_API( listreff )
{
    ULONG_PTR RefObj = 0xFFFFFFFF;

    if( args && *args ) {
        RefObj = GetExpression( args );
    }
#if DBG
    ListRefs(RefObj, TRUE, hCurrentProcess, hCurrentThread, dwCurrentPc, dwProcessor);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\drkdx\strucsup.cpp ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    strucsup.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#define KDEXT_32BIT
#include "rxovride.h" //common compile flags
#include <ntos.h>
#include <nturtl.h>
#include "ntverp.h"

#include <windows.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <rdpdrkd.h>

#include <ntrxdef.h>
#include <rxtypes.h>
//#include <rxlog.h>

//need this for unaligned smbget macros
#include <smbgtpt.h>

extern WINDBG_EXTENSION_APIS ExtensionApis;
//EXT_API_VERSION ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };

#define    ERRPRT     dprintf
#define    PRINTF     dprintf

#define    NL      1
#define    NONL    0

BOOLEAN
wGetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, IN PSZ type);

//
// No. of columns used to display struct fields;
//

ULONG s_MaxNoOfColumns = 3;
#ifndef RXKD_2col
ULONG s_NoOfColumns = 1;
#else
ULONG s_NoOfColumns = 2;
#endif

/*
 * Displays all the fields of a given struct. This is the driver routine that is called
 * with the appropriate descriptor array to display all the fields in a given struct.
 */

char *NewLine  = "\n";
char *FieldSeparator = " ";
#define NewLineForFields(FieldNo) \
        ((((FieldNo) % s_NoOfColumns) == 0) ? NewLine : FieldSeparator)
#define FIELD_NAME_LENGTH 30

/*
 * Print out an optional message, a UNICODE_STRING, and maybe a new-line
 */
BOOL
wPrintStringU( IN LPSTR PrefixMsg OPTIONAL, IN PUNICODE_STRING puStr, IN LPSTR SuffixMsg OPTIONAL )
{
    PWCHAR    StringData;
    UNICODE_STRING UnicodeString;
    ULONG BytesRead;

    if (PrefixMsg == NULL) {
        PrefixMsg = "";
    }
    if (SuffixMsg == NULL) {
        SuffixMsg = "";
    }

    StringData = (PWCHAR)LocalAlloc( LPTR, puStr->Length + sizeof(UNICODE_NULL));
    if( StringData == NULL ) {
        dprintf( "Out of memory!\n" );
        return FALSE;
    }
    UnicodeString.Buffer =  StringData; //puStr->Buffer;
    UnicodeString.Length =  puStr->Length;
    UnicodeString.MaximumLength =  puStr->MaximumLength;

    ReadMemory( (ULONG_PTR)puStr->Buffer,
               StringData,
               puStr->Length,
               &BytesRead);

    if (BytesRead)  {
        dprintf("%s%wZ%s", PrefixMsg, &UnicodeString, SuffixMsg );
    } else {
        dprintf("MEMORYREAD FAILED %s%s",PrefixMsg,SuffixMsg);
    }

    LocalFree( (HLOCAL)StringData );

    return BytesRead;
}

VOID
SetFlagString(
    ULONG Value,
    PCHAR FlagString
    )
{
    ULONG i,t,mask;
    *FlagString = '('; FlagString++;
    for (i=t=0,mask=1;i<32;i++,mask<<=1) {
        //PRINTF("hithere %08lx %08lx %08lx\n",Value,mask,i);
        if (i==t+10) {
            *FlagString = ':'; FlagString++;
            t=t+10;
        }
        if (Value&mask) {
            *FlagString = '0'+(UCHAR)(i-t); FlagString++;
        }
    }

    *FlagString = ')'; FlagString++;
    *FlagString = 0;
}

VOID
PrintStructFields( ULONG_PTR dwAddress, VOID *ptr, FIELD_DESCRIPTOR *pFieldDescriptors )
{
    int i;

    // Display the fields in the struct.
    for( i=0; pFieldDescriptors->Name; i++, pFieldDescriptors++ ) {

        // Indentation to begin the struct display.
        PRINTF( "    " );

        if( strlen( pFieldDescriptors->Name ) > FIELD_NAME_LENGTH ) {
            PRINTF( "%-17s...%s ", pFieldDescriptors->Name, pFieldDescriptors->Name+strlen(pFieldDescriptors->Name)-10 );
        } else {
            PRINTF( "%-30s ", pFieldDescriptors->Name );
        }

        switch( pFieldDescriptors->FieldType ) {
        case FieldTypeByte:
        case FieldTypeChar:
           PRINTF( "%-16X%s",
               *(BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ),
               NewLineForFields(i) );
           break;
        case FieldTypeBoolean:
           PRINTF( "%-16s%s",
               *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
               NewLineForFields(i));
           break;
        case FieldTypeBool:
            PRINTF( "%-16s%s",
                *(BOOLEAN *)(((char *)ptr) + pFieldDescriptors->Offset ) ? "TRUE" : "FALSE",
                NewLineForFields(i));
            break;
        case FieldTypePointer:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULong:
        case FieldTypeLong:
            PRINTF( "%-16X%s",
                *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeULongUnaligned:
        case FieldTypeLongUnaligned:
            PRINTF( "%-16X%s",
                SmbGetUlong( (BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ) ),
                NewLineForFields(i) );
            break;
        case FieldTypeShort:
            PRINTF( "%-16X%s",
                *(SHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShort:
            PRINTF( "%-16X%s",
                *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeUShortUnaligned:
            PRINTF( "%-16X%s",
                SmbGetUshort( (BYTE *)(((char *)ptr) + pFieldDescriptors->Offset ) ),
                NewLineForFields(i) );
            break;
        case FieldTypeULongFlags:{ULONG Value; char FlagString[60];
            Value = *(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset );
            SetFlagString(Value,FlagString);
            PRINTF( "%-16X%s%s", Value, FlagString,
                NewLineForFields(i) );
            break;}
        case FieldTypeUShortFlags:{USHORT Value; char FlagString[60];
            Value = *(USHORT *)(((char *)ptr) + pFieldDescriptors->Offset ),
            SetFlagString(Value,FlagString);
            PRINTF( "%-16X%s%s", Value, FlagString,
                NewLineForFields(i) );
            break;}
        case FieldTypeUnicodeString:
            wPrintStringU( NULL, (UNICODE_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NULL );
            PRINTF( NewLine );
            break;
        //case FieldTypeAnsiString:
        //    //PrintStringA( NULL, (ANSI_STRING *)(((char *)ptr) + pFieldDescriptors->Offset ), NONL );
        //    //PRINTF( NewLine );
        //    PRINTF( NewLine );
        //    break;
        case FieldTypeSymbol:
            {
                UCHAR SymbolName[ 200 ];
                ULONG_PTR Displacement;
                ULONG sym = (*(ULONG *)(((char *)ptr) + pFieldDescriptors->Offset ));

                GetSymbol( sym, SymbolName, &Displacement );
                PRINTF( "%-16s%s",
                        SymbolName,
                        NewLineForFields(i) );
            }
            break;
        case FieldTypeEnum:
            {
               ULONG EnumValue;
               ENUM_VALUE_DESCRIPTOR *pEnumValueDescr;
               // Get the associated numericla value.

               EnumValue = *((ULONG *)(((BYTE *)ptr) + pFieldDescriptors->Offset));

               if ((pEnumValueDescr = pFieldDescriptors->AuxillaryInfo.pEnumValueDescriptor)
                    != NULL) {
                   //
                   // An auxilary textual description of the value is
                   // available. Display it instead of the numerical value.
                   //

                   LPSTR pEnumName = NULL;

                   while (pEnumValueDescr->EnumName != NULL) {
                       if (EnumValue == pEnumValueDescr->EnumValue) {
                           pEnumName = pEnumValueDescr->EnumName;
                           break;
                       }
                       pEnumValueDescr++;
                   }

                   if (pEnumName != NULL) {
                       PRINTF( "%-16s ", pEnumName );
                   } else {
                       PRINTF( "%-4d (%-10s) ", EnumValue,"@$#%^&*");
                   }

               } else {
                   //
                   // No auxilary information is associated with the ehumerated type
                   // print the numerical value.
                   //
                   PRINTF( "%-16d",EnumValue);
               }
               PRINTF( NewLine );
            }
            break;
        case FieldTypeStruct:
            PRINTF( "@%-15X%s",
                (dwAddress + pFieldDescriptors->Offset ),
                NewLineForFields(i) );
            break;
        case FieldTypeLargeInteger:
        case FieldTypeFileTime:
        default:
            ERRPRT( "Unrecognized field type %c for %s\n", pFieldDescriptors->FieldType, pFieldDescriptors->Name );
            break;
        }
    }
}

DECLARE_API( columns )
{
    ULONG NoOfColumns;
    int   i;

    //SETCALLBACKS();

    //sscanf(lpArgumentString,"%ld",&NoOfColumns);
    sscanf(args,"%ld",&NoOfColumns);

    if (NoOfColumns > s_MaxNoOfColumns) {
        // PRINTF( "No. Of Columns exceeds maximum(%ld) -- directive Ignored\n", s_MaxNoOfColumns );
    } else {
        s_NoOfColumns = NoOfColumns;
    }

    PRINTF("Not Yet Implemented\n");

    return;
}

#define NAME_DELIMITER '@'
#define NAME_DELIMITERS "@"
#define INVALID_INDEX 0xffffffff
#define MIN(x,y)  ((x) < (y) ? (x) : (y))

ULONG SearchStructs(LPSTR lpArgument)
{
    ULONG             i = 0;
    STRUCT_DESCRIPTOR *pStructs = Structs;
    ULONG             NameIndex = INVALID_INDEX;
    ULONG             ArgumentLength = strlen(lpArgument);
    BOOLEAN           fAmbigous = FALSE;


    while ((pStructs->StructName != 0)) {
        int Result = _strnicmp(lpArgument,
                              pStructs->StructName,
                              MIN(strlen(pStructs->StructName),ArgumentLength));

        if (Result == 0) {
            if (NameIndex != INVALID_INDEX) {
                // We have encountered duplicate matches. Print out the
                // matching strings and let the user disambiguate.
               fAmbigous = TRUE;
               break;
            } else {
               NameIndex = i;
            }

        }
        pStructs++;i++;
    }

    if (fAmbigous) {
       PRINTF("Ambigous Name Specification -- The following structs match\n");
       PRINTF("%s\n",Structs[NameIndex].StructName);
       PRINTF("%s\n",Structs[i].StructName);
       while (pStructs->StructName != 0) {
           if (_strnicmp(lpArgument,
                        pStructs->StructName,
                        MIN(strlen(pStructs->StructName),ArgumentLength)) == 0) {
               PRINTF("%s\n",pStructs->StructName);
           }
           pStructs++;
       }
       PRINTF("Dumping Information for %s\n",Structs[NameIndex].StructName);
    }

    return(NameIndex);
}

VOID DisplayStructs()
{
    STRUCT_DESCRIPTOR *pStructs = Structs;

    PRINTF("The following structs are handled .... \n");
    while (pStructs->StructName != 0) {
        PRINTF("\t%s\n",pStructs->StructName);
        pStructs++;
    }
}

PPERSISTENT_RDPDRKD_INFO
LocatePersistentInfoFromView()
/*
    the purpose of this routine is to allocate or find the named section that holds the
    data we expect to find across calls. the way that we make this persitent is that we
    do not close the handle used to create the view. it will go away when the process does.
*/
{
    BYTE SectionName[128];
    DWORD SectionSize;
    DWORD ProcessId;
    HANDLE h;
    BOOLEAN CreatedSection = FALSE;
    PPERSISTENT_RDPDRKD_INFO p;

    ProcessId = GetCurrentProcessId();
    SectionSize = sizeof(PERSISTENT_RDPDRKD_INFO);
    sprintf((char *)SectionName,"RdpDrKdSection_%08lx",ProcessId);
    //PRINTF("sectionname=%s, size=%x\n",SectionName,SectionSize);

    h = OpenFileMappingA(
           FILE_MAP_WRITE, //DWORD  dwDesiredAccess,	// access mode
           FALSE,           //BOOL  bInheritHandle,	// inherit flag
           (char *)SectionName     //LPCTSTR  lpName 	// address of name of file-mapping object
           );

    if (h==NULL) {
        h = CreateFileMappingA(
                   (HANDLE)0xFFFFFFFF, // HANDLE  hFile,	// handle of file to map
                    NULL,              //LPSECURITY_ATTRIBUTES  lpFileMappingAttributes,	// optional security attributes
                    PAGE_READWRITE,    //DWORD  flProtect,	// protection for mapping object
                    0,                 //DWORD  dwMaximumSizeHigh,	// high-order 32 bits of object size
                    SectionSize,       //DWORD  dwMaximumSizeLow,	// low-order 32 bits of object size
                    (char *)SectionName        //LPCTSTR  lpName 	// name of file-mapping object
                    );
        if (h==NULL) {
            return(FALSE);
        }
        CreatedSection = TRUE;
    }

    //now we have a filemapping....get a view.....
    p = (PPERSISTENT_RDPDRKD_INFO)MapViewOfFile(h,FILE_MAP_WRITE,0,0,0);
    if (p==NULL) {
        CloseHandle(h);
        return(NULL);
    }

    if (CreatedSection) {
        //zero the stuff that needs to be zeroed....
        ULONG i;
        p->IdOfLastDump = 0;
        for (i=0;i<100;i++) {
            p->LastAddressDumped[i] = 0;
        }
        p->OpenCount = 100;
    } else {
        CloseHandle(h);
        p->OpenCount++;
    }

    //PRINTF("Opencount for persistent section = %08lx\n",p->OpenCount);
    return(p);
}

VOID
FreePersistentInfoView (
    PPERSISTENT_RDPDRKD_INFO p
    )
{
    UnmapViewOfFile(p);
}

VOID
DumpAStruct (
    ULONG_PTR dwAddress,
    STRUCT_DESCRIPTOR *pStruct
    )
{
    DWORD Index = (DWORD)(pStruct - Structs);
    DWORD SizeToRead = min(pStruct->StructSize,2048);
    PPERSISTENT_RDPDRKD_INFO p;

    p = LocatePersistentInfoFromView();

    PRINTF("top @ %lx and %lx for %s(%d,%d)\n",dwAddress,p,pStruct->StructName,Index,p->IdOfLastDump);
    if (!p) {
        PRINTF("Couldn't allocate perstistent info buffer...sorry...\n");
        return;
    }

    if ((dwAddress==0) &&(Index<100)) {
        dwAddress = p->LastAddressDumped[Index];
        PRINTF("setting @ %lx and %lx for %s\n",dwAddress,p->LastAddressDumped[Index],pStruct->StructName);
    }

    if (wGetData(dwAddress,&p->StructDumpBuffer[0],SizeToRead,pStruct->StructName)) {

        p->LastAddressDumped[Index] = dwAddress;
        p->IdOfLastDump = pStruct->EnumManifest;
        p->IndexOfLastDump = Index;

        PRINTF("++++++++++++++++ %s(%d/%d)@%lx ---+++++++++++++\n",
            pStruct->StructName,
            p->IdOfLastDump,p->IndexOfLastDump,
            dwAddress);
        PrintStructFields(
            dwAddress,
            &p->StructDumpBuffer[0],
            pStruct->FieldDescriptors);
        PRINTF("---------------- %s@%lx ----------------\n",
            pStruct->StructName,
            dwAddress);
    }

    if (p!= NULL) FreePersistentInfoView(p);
    return;
}


DECLARE_API( dump )
{
    ULONG_PTR dwAddress;

    //SETCALLBACKS();

    if( args && *args ) {
        // Parse the argument string to determine the structure to be displayed.
        // Scan for the NAME_DELIMITER ( '@' ).

        LPSTR lpName = (PSTR)args;
        LPSTR lpArgs = strpbrk(args, NAME_DELIMITERS);
        ULONG Index;

        if (lpArgs) {
            //
            // The specified command is of the form
            // dump <name>@<address expr.>
            //
            // Locate the matching struct for the given name. In the case
            // of ambiguity we seek user intervention for disambiguation.
            //
            // We do an inplace modification of the argument string to
            // facilitate matching.
            //
            *lpArgs = '\0';

            for (;*lpName==' ';) { lpName++; } //skip leading blanks

            Index = SearchStructs(lpName);

            //
            // Let us restore the original value back.
            //

            *lpArgs = NAME_DELIMITER;

            if (INVALID_INDEX != Index) {
                BYTE DataBuffer[512];

                dwAddress = GetExpression( ++lpArgs );
                DumpAStruct(dwAddress,&Structs[Index]);
                //if (wGetData(dwAddress,DataBuffer,Structs[Index].StructSize,"..structure")) {
                //
                //    PRINTF(
                //        "++++++++++++++++ %s@%lx ++++++++++++++++\n",
                //        Structs[Index].StructName,
                //        dwAddress);
                //    PrintStructFields(
                //        dwAddress,
                //        &DataBuffer,
                //        Structs[Index].FieldDescriptors);
                //    PRINTF(
                //        "---------------- %s@%lx ----------------\n",
                //        Structs[Index].StructName,
                //        dwAddress);
                //} else {
                //    PRINTF("Error reading Memory @ %lx\n",dwAddress);
                //}
            } else {
                // No matching struct was found. Display the list of
                // structs currently handled.

                DisplayStructs();
            }
        } else {
#if 0
            //
            // The command is of the form
            // dump <name>
            //
            // Currently we do not handle this. In future we will map it to
            // the name of a global variable and display it if required.
            //

            DisplayStructs();
#endif
            //
            // here we try to figure out what to display based on the context....whoa, nellie!
            //
            USHORT Tag;
            STRUCT_DESCRIPTOR *pStructs = Structs;
            ULONG             NameIndex = INVALID_INDEX;
            BYTE DataBuffer[512];
            //ULONG             ArgumentLength = strlen(lpArgument);
            //BOOLEAN           fAmbigous = FALSE;



            dwAddress = GetExpression( args );
            if (!wGetData(dwAddress,&Tag,sizeof(Tag),"..structure TAG")) return;

            PRINTF("here's the tag: %04lx\n",Tag);

            //look thru the table for matching structs

            while ((pStructs->StructName != 0)) {
                int Result = (Tag&pStructs->MatchMask)==pStructs->MatchValue;

                if (Result != 0) {

                    DumpAStruct(dwAddress,pStructs);
                    break;
                }


                pStructs++;
            }

        }
    } else {
            DisplayStructs();
    }

    return;
}


DECLARE_API( ddd )
{
    dump( hCurrentProcess,
          hCurrentThread,
          dwCurrentPc,
          dwProcessor,
          args
          );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\dll\drprov.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    drprov.c

Abstract:

    This module implements the routines required for interaction with network
    provider router interface in NT for RDP mini-redirector

Author:

    Joy Chik 1/20/2000

--*/

#define TRC_FILE "drprov"
#include "drprov.h"
#include "drdbg.h"

DWORD GLOBAL_DEBUG_FLAGS=0x0;

//
// the RDP mini redirector and provider name. The original constants
// are defined in rdpdr.h
//
// The length does not include the null terminator
//
UNICODE_STRING DrDeviceName = 
        {RDPDR_DEVICE_NAME_U_LENGTH - sizeof(WCHAR),
         RDPDR_DEVICE_NAME_U_LENGTH,
         RDPDR_DEVICE_NAME_U};

extern UNICODE_STRING DrProviderName;

//
// Function prototypes defined in drenum.c
//                                
DWORD DrOpenMiniRdr(HANDLE *DrDeviceHandle);

DWORD DrDeviceControlGetInfo(IN HANDLE FileHandle,
        IN  ULONG DeviceControlCode,
        IN  PVOID RequestPacket,
        IN  ULONG RequestPacketLength,
        OUT LPBYTE *OutputBuffer,
        IN  ULONG PreferedMaximumLength,
        IN  ULONG BufferHintSize,
        OUT PULONG_PTR Information OPTIONAL);

DWORD DrEnumServerInfo(IN PRDPDR_ENUMERATION_HANDLE pEnumHandle,
        OUT LPDWORD lpcCount,
        OUT LPNETRESOURCEW pBufferResource,
        IN OUT LPDWORD lpBufferSize);

DWORD DrEnumShareInfo(IN PRDPDR_ENUMERATION_HANDLE pEnumHandle,
        OUT LPDWORD lpcCount,
        OUT LPNETRESOURCEW pBufferResource,
        IN OUT LPDWORD lpBufferSize);

DWORD DrEnumConnectionInfo(IN PRDPDR_ENUMERATION_HANDLE pEnumHandle,
        OUT LPDWORD lpcCount,
        OUT LPNETRESOURCEW pBufferResource,
        IN OUT LPDWORD lpBufferSize);

BOOL ValidateRemoteName(IN PWCHAR pRemoteName);

DWORD APIENTRY
NPGetCaps(
    DWORD nIndex )
/*++

Routine Description:

    This routine returns the capabilities of the RDP Mini redirector
    network provider implementation

Arguments:

    nIndex - category of capabilities desired

Return Value:

    the appropriate capabilities

--*/
{

    DBGMSG(DBG_TRACE, ("DRPROV: NPGetCaps, index: %d\n", nIndex));

    switch (nIndex) {
        case WNNC_SPEC_VERSION:
            return WNNC_SPEC_VERSION51;

        case WNNC_NET_TYPE:
            return WNNC_NET_TERMSRV;

        case WNNC_DRIVER_VERSION:
#define WNNC_DRIVER(major,minor) (major*0x00010000 + minor)
            return (WNNC_DRIVER(RDPDR_MAJOR_VERSION, RDPDR_MINOR_VERSION));

        case WNNC_USER:
            return WNNC_USR_GETUSER;

        case WNNC_CONNECTION:
            return (WNNC_CON_GETCONNECTIONS |
                    WNNC_CON_CANCELCONNECTION |
                    WNNC_CON_ADDCONNECTION |
                    WNNC_CON_ADDCONNECTION3);

        case WNNC_DIALOG:
            return WNNC_DLG_GETRESOURCEINFORMATION;
            //return (WNNC_DLG_SEARCHDIALOG |
            //        WNNC_DLG_FORMATNETNAME);

        case WNNC_ADMIN:
            return 0;

        case WNNC_ENUMERATION:
            return (WNNC_ENUM_LOCAL |
                    WNNC_ENUM_GLOBAL |
                    WNNC_ENUM_SHAREABLE);

        case WNNC_START:
            //
            //  JOYC: Need to figure what we should return here
            //
            return 1;

        default:
            return 0;
    }
}

DWORD APIENTRY
NPOpenEnum(
    DWORD          dwScope,
    DWORD          dwType,
    DWORD          dwUsage,
    LPNETRESOURCE  lpNetResource,
    LPHANDLE       lphEnum )
/*++

Routine Description:

    This routine opens a handle for enumeration of resources. 

Arguments:

    dwScope - the scope of enumeration

    dwType  - the type of resources to be enumerated

    dwUsage - the usage parameter

    lpNetResource - a pointer to the desired NETRESOURCE struct.

    lphEnum - a pointer for passing back the enumeration handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

--*/
{
    DWORD Status = WN_NOT_SUPPORTED;
    RDPDR_ENUMERATION_HANDLE *pEnum;
    DWORD ConsoleId, CurrentId;

    DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, dwScope=%d, dwType=%d, dwUsage=%d\n",
                       dwScope, dwType, dwUsage));
                       
    //
    //  Basic parameter checking, make sure lphEnum is not NULL
    //
    if (lphEnum != NULL) {
        *lphEnum = NULL;
    }
    else {
        DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, null lphEnum parameter.\n"));
        Status = WN_BAD_VALUE;
        goto EXIT;
    }

    //
    //  Check if the request comes from console, if so, bail immediately
    //
    ConsoleId = WTSGetActiveConsoleSessionId();
    if (ProcessIdToSessionId(GetCurrentProcessId(), &CurrentId)) {
        if (ConsoleId == CurrentId) {
            if (!(dwScope == RESOURCE_GLOBALNET && lpNetResource == NULL)) {

                DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, console request, bail.\n"));
                Status = WN_NOT_SUPPORTED;
                goto EXIT;
            }            
        }
    }

    //
    //  Allocating the enumeration handle
    //
    *lphEnum = MemAlloc(sizeof(RDPDR_ENUMERATION_HANDLE));

    if (*lphEnum == NULL) {
        DBGMSG(DBG_ERROR, ("DRPROV: NPOpenEnum, MemAlloc failed for enum handle.\n"));
        Status = WN_OUT_OF_MEMORY;
        goto EXIT;
    }

    RtlZeroMemory(*lphEnum, sizeof(RDPDR_ENUMERATION_HANDLE));

    if (dwScope == RESOURCE_CONNECTED)
    {
        //
        // we are looking for current uses
        //
        if (lpNetResource != NULL)
        {
            DBGMSG(DBG_ERROR, ("DRPROV: NPOpenEnum invalid parameter\n"));
            Status = WN_BAD_VALUE;
            goto EXIT;
        }

        pEnum = (PRDPDR_ENUMERATION_HANDLE)(*lphEnum);
        pEnum->dwScope = dwScope;
        pEnum->dwType = dwType;
        pEnum->dwUsage = dwUsage;
        pEnum->enumType = CONNECTION;
        pEnum->enumIndex = 0;
        Status = WN_SUCCESS;        

        DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, RESOURCE_CONNECTED.\n"));
        goto EXIT;
    }
    else if (dwScope == RESOURCE_SHAREABLE)
    {
        //
        // We are looking for shareable resources
        // If we're not given a server, return an EMPTY_ENUM
        //
        if ((lpNetResource != NULL) &&
                (lpNetResource->lpRemoteName != NULL) &&
                (lpNetResource->lpRemoteName[0] == L'\\') &&
                (lpNetResource->lpRemoteName[1] == L'\\'))
        {
            //
            // Check if the lpRemoteName is what we recognize
            if (ValidateRemoteName(lpNetResource->lpRemoteName)) {
            
                pEnum = (PRDPDR_ENUMERATION_HANDLE)(*lphEnum);
                pEnum->dwScope = dwScope;
                pEnum->dwType = dwType;
                pEnum->dwUsage = dwUsage;
                pEnum->enumType = SHARE;
                pEnum->enumIndex = 0;
                pEnum->RemoteName.MaximumLength =
                        (wcslen(lpNetResource->lpRemoteName) + 1) * sizeof(WCHAR);
                pEnum->RemoteName.Buffer = 
                        MemAlloc(pEnum->RemoteName.MaximumLength);                              
    
                if (pEnum->RemoteName.Buffer) {
                    pEnum->RemoteName.Length = pEnum->RemoteName.MaximumLength - sizeof(WCHAR);
                    wcscpy(pEnum->RemoteName.Buffer, lpNetResource->lpRemoteName);
    
                    DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, RESOURCE_SHARABLE for remote name: %ws\n",
                                       lpNetResource->lpRemoteName));
                    Status = WN_SUCCESS;
                    goto EXIT;
                }
                else {
                    DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, MemAlloc failed for RemoteName\n"));
                    Status = WN_OUT_OF_MEMORY;
                    goto EXIT;
                }
            }
            else {
                DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, RESOURCE_SHAREABLE, RemoteName: %ws not supported\n",
                                   lpNetResource->lpRemoteName));
                Status = WN_NOT_SUPPORTED;
                goto EXIT;
            }
        }
        else
        {
            pEnum = (PRDPDR_ENUMERATION_HANDLE)(*lphEnum);
            pEnum->dwScope = dwScope;
            pEnum->dwType = dwType;
            pEnum->dwUsage = dwUsage;
            pEnum->enumType = EMPTY;
            pEnum->enumIndex = 0;
            
            DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, RESOURCE_SHAREABLE, NetResource empty\n"));
            Status = WN_SUCCESS;
            goto EXIT;
        }
    }
    else if (dwScope == RESOURCE_GLOBALNET)
    {
        /* Look for the combination of all bits and substitute "All" for
         * them.  Ignore bits we don't know about.
         */
        dwUsage &= (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER);

        if ( dwUsage == (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER) )
        {
            dwUsage = 0 ;
        }

        /*
         * we are looking for global resources out on the net
         */
        if (lpNetResource == NULL || lpNetResource->lpRemoteName == NULL)
        {
            /*
             * at top level, therefore enumerating servers. if user
             * asked for connectable, well, there aint none.
             */
            if (dwUsage == RESOURCEUSAGE_CONNECTABLE)
            { 
                pEnum = (PRDPDR_ENUMERATION_HANDLE)(*lphEnum);
                pEnum->dwScope = dwScope;
                pEnum->dwType = dwType;
                pEnum->dwUsage = dwUsage;
                pEnum->enumType = EMPTY;
                pEnum->enumIndex = 0;
                
                DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, RESOURCE_GLOBALNET, empty node\n"));
                Status = WN_SUCCESS;                
                goto EXIT;
            }  
            else
            {
                // return server name, i.e. tsclient
                pEnum = (PRDPDR_ENUMERATION_HANDLE)(*lphEnum);
                pEnum->dwScope = dwScope;
                pEnum->dwType = dwType;
                pEnum->dwUsage = dwUsage;
                pEnum->enumType = SERVER;
                pEnum->enumIndex = 0;

                DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, RESOURCE_GLOBALNET, enumerate server name.\n"));
                Status = WN_SUCCESS;                
                goto EXIT;
            }
        } 
        else
        {                  
            /*
             * we are assured of lpRemoteName != NULL.
             * things get interesting here. the cases are as follows:
             *
             * if (dwUsage == 0)
             *     if have \\ in front
             *         return shares
             *     else
             *         return empty enum
             * else if (dwUsage == CONNECTABLE)
             *     if have \\ in front
             *         return shares
             *     else
             *         empty enum
             * else if (dwUsage == CONTAINER)
             *     if have \\ in front
             *         empty enum
             *     else
             *         return empty enum
             *
             */

            if (((dwUsage == RESOURCEUSAGE_CONNECTABLE) || (dwUsage == 0)) &&
                    ((lpNetResource->lpRemoteName[0] == L'\\') &&
                    (lpNetResource->lpRemoteName[1] == L'\\')))
            {

                /* Confirm that this really is a computer name (i.e., a
                 * container we can enumerate).
                 */

                if (ValidateRemoteName(lpNetResource->lpRemoteName)) {
                    pEnum = (PRDPDR_ENUMERATION_HANDLE)(*lphEnum);
                    pEnum->dwScope = dwScope;
                    pEnum->dwType = dwType;
                    pEnum->dwUsage = dwUsage;
                    pEnum->enumType = SHARE;
                    pEnum->enumIndex = 0;
                    pEnum->RemoteName.MaximumLength =
                            (wcslen(lpNetResource->lpRemoteName) + 1) * sizeof(WCHAR);
                    pEnum->RemoteName.Buffer = 
                            MemAlloc(pEnum->RemoteName.MaximumLength);                              
    
                    if (pEnum->RemoteName.Buffer) {
                        pEnum->RemoteName.Length = pEnum->RemoteName.MaximumLength - sizeof(WCHAR);
                        wcscpy(pEnum->RemoteName.Buffer, lpNetResource->lpRemoteName);
    
                        DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, RESOURCE_GLOBALNET for remote name: %ws\n",
                                lpNetResource->lpRemoteName));
                        Status = WN_SUCCESS;
                        goto EXIT;
                    }
                    else {
                        DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, MemAlloc failed for RemoteName\n"));
                        Status = WN_OUT_OF_MEMORY;
                        goto EXIT;
                    }
                }
                else {
                    DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, RESOURCE_GLOBALNET, RemoteName: %ws not supported\n",
                                   lpNetResource->lpRemoteName));
                    Status = WN_NOT_SUPPORTED;
                    goto EXIT;
                }
            } 
            else if (((dwUsage == RESOURCEUSAGE_CONTAINER) || (dwUsage == 0)) &&
                    (lpNetResource->lpRemoteName[0] != L'\\'))
            {
                // return empty enum.
                pEnum = (PRDPDR_ENUMERATION_HANDLE)(*lphEnum);
                pEnum->dwScope = dwScope;
                pEnum->dwType = dwType;
                pEnum->dwUsage = dwUsage;
                pEnum->enumType = EMPTY;
                pEnum->enumIndex = 0;

                DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, RESOURCE_GLOBALNET, empty node\n"));
                Status = WN_SUCCESS;                 
                goto EXIT;
            } 
            else if (
                    // ask for share but aint starting from server
                    ((dwUsage == RESOURCEUSAGE_CONNECTABLE) &&
                    (lpNetResource->lpRemoteName[0] != L'\\')) ||
                    // ask for server but is starting from server
                    ((dwUsage == RESOURCEUSAGE_CONTAINER) &&
                    ((lpNetResource->lpRemoteName[0] == L'\\') &&
                    (lpNetResource->lpRemoteName[1] == L'\\')))
                    )
            {
                // return empty
                pEnum = (PRDPDR_ENUMERATION_HANDLE)(*lphEnum);
                pEnum->dwScope = dwScope;
                pEnum->dwType = dwType;
                pEnum->dwUsage = dwUsage;
                pEnum->enumType = EMPTY;
                pEnum->enumIndex = 0;

                DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, RESOURCE_GLOBALNET, empty node\n"));
                Status = WN_SUCCESS;                
                goto EXIT;
            } 
            else
            {
                // incorrect dwUsage
                DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, invalid dwUsage parameter\n"));
                Status = WN_BAD_VALUE;
                goto EXIT;
            }
        }
    }
    else
    {
        // invalid dwScope
        DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, invalid dwScope parameter\n"));
        Status = WN_BAD_VALUE;
        goto EXIT;
    }
       
EXIT:

    //
    // clean up enumeration handle in failure case
    if (Status != WN_SUCCESS && lphEnum != NULL && *lphEnum != NULL) {
        MemFree(*lphEnum);
        *lphEnum = NULL;
    }

    DBGMSG(DBG_TRACE, ("DRPROV: NPOpenEnum, return status: %x\n", Status));
    return Status;
}


DWORD APIENTRY
NPEnumResource(
    HANDLE  hEnum,
    LPDWORD lpcCount,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize)
/*++

Routine Description:

    This routine uses the handle obtained by a call to NPOpenEnum for
    enuerating the connected shares

Arguments:

    hEnum  - the enumeration handle

    lpcCount - the number of resources returned

    lpBuffer - the buffere for passing back the entries

    lpBufferSize - the size of the buffer

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

    WN_NO_MORE_ENTRIES - if the enumeration has exhausted the entries

    WN_MORE_DATA - if nmore data is available

--*/
{
    DWORD status = WN_SUCCESS;
    LPNETRESOURCEW pBufferResource;
    PRDPDR_ENUMERATION_HANDLE pEnumHandle;
    
    pEnumHandle = (PRDPDR_ENUMERATION_HANDLE)hEnum;
    pBufferResource = (LPNETRESOURCEW)lpBuffer;

    if (lpcCount == NULL || lpBuffer == NULL || lpBufferSize == NULL) {
        DBGMSG(DBG_TRACE, ("DRPROV: NPEnumResource, Invalid parameter(s)\n"));
        status = WN_BAD_VALUE;
        goto EXIT;
    }

    if (pEnumHandle != NULL) {
        DBGMSG(DBG_TRACE, ("DRPROV: NPEnumResource, EnumType: %d\n", pEnumHandle->enumType));

        if ( pEnumHandle->enumType == SERVER ) {
            status = DrEnumServerInfo(pEnumHandle, lpcCount, pBufferResource, lpBufferSize);        
            goto EXIT;
        }

        else if ( pEnumHandle->enumType == SHARE ) {
            status = DrEnumShareInfo(pEnumHandle, lpcCount, pBufferResource, lpBufferSize);
            goto EXIT;
        }

        else if ( pEnumHandle->enumType == CONNECTION ) {
            status = DrEnumConnectionInfo(pEnumHandle, lpcCount, pBufferResource, lpBufferSize);
            goto EXIT;
        }

        else if ( pEnumHandle->enumType == EMPTY) {
            status = WN_NO_MORE_ENTRIES;
            goto EXIT;
        }

        else {
            DBGMSG(DBG_TRACE, ("DRPROV: NPEnumResource, invalid enum type\n"));
            status = WN_BAD_HANDLE;
            goto EXIT;
        }
    }
    else {
        DBGMSG(DBG_TRACE, ("DRPROV: NPEnumResource, NULL enum handle\n"));
        status = WN_BAD_HANDLE;
        goto EXIT;
    }

EXIT:
    DBGMSG(DBG_TRACE, ("DRPROV: NPEnumResource, return status: %x\n", status));
    return status;
}

DWORD APIENTRY
NPCloseEnum(
    HANDLE hEnum )
/*++

Routine Description:

    This routine closes the handle for enumeration of resources.

Arguments:

    hEnum  - the enumeration handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

--*/
{
    DWORD Status = WN_SUCCESS;

    DBGMSG(DBG_TRACE, ("DRPROV: NPCloseEnum, handle: %p\n", hEnum));

    if (hEnum != NULL) {
        PRDPDR_ENUMERATION_HANDLE pEnumHandle = (PRDPDR_ENUMERATION_HANDLE)hEnum;

        // free the enumeration buffer
        if (pEnumHandle->pEnumBuffer != NULL) {
            MemFree(pEnumHandle->pEnumBuffer);
        }

        // free the remote name
        if (pEnumHandle->RemoteName.Buffer != NULL) {
            MemFree(pEnumHandle->RemoteName.Buffer);
        }

        // free the enum handle
        MemFree(hEnum);
        hEnum = NULL;
    }

    Status = WN_SUCCESS;
    return Status;
}


DWORD
OpenConnection(
    PUNICODE_STRING             pConnectionName,
    DWORD                       Disposition,
    DWORD                       CreateOption,
    PFILE_FULL_EA_INFORMATION	  pEABuffer,
    DWORD                       EABufferLength,
    PHANDLE                     pConnectionHandle )
/*++

Routine Description:

    This routine opens the connection. This routine is shared by NpAddConnection
    and NPCancelConnection

Arguments:

    pConnectionName - the connection name

    Disposition - the Open disposition
    
    CreateOption - the create option

    pEABuffer  - the EA buffer associated with the open

    EABufferLength - the EA buffer length

    pConnectionHandle - the placeholder for the connection handle

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    NTSTATUS            Status;
    DWORD               NPStatus;
    IO_STATUS_BLOCK     IoStatusBlock;
    OBJECT_ATTRIBUTES	ConnectionObjectAttributes;

    DBGMSG(DBG_TRACE, ("DRPROV: OpenConnection, connectionName: %ws\n",
                       pConnectionName->Buffer));

    ASSERT(pConnectionName != NULL);
    ASSERT(pConnectionHandle != NULL);

    InitializeObjectAttributes(
            &ConnectionObjectAttributes,
            pConnectionName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL);

    Status = NtCreateFile(
            pConnectionHandle,
            FILE_LIST_DIRECTORY | SYNCHRONIZE,
            &ConnectionObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
            Disposition,
            CreateOption,
            pEABuffer,
            EABufferLength);

    DBGMSG(DBG_TRACE, ("DRPROV: OpenConnection, NtCreateFile status: %x\n", Status));

    if (Status != STATUS_SUCCESS) {
        NPStatus = ERROR_BAD_NETPATH;
    }
    else {
        NPStatus = WN_SUCCESS;
    }
    return NPStatus;
}

DWORD
CreateConnectionName(
    PWCHAR pLocalName,
    PWCHAR pRemoteName,
    PUNICODE_STRING pConnectionName)
/*++

Routine Description:

    This routine create connection name from the remote name
    
Arguments:

    pLocalName - the local name for the connection                
    pRemoteName - the UNC remote name

    pConnectionName - the connection name used to talk to mini redirector    

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    DWORD status;
    DWORD LocalNameLength,RemoteNameLength;
    DWORD dwSessionId;
    WCHAR pSessionId[16];
    WCHAR LocalName[MAX_PATH + 1];
    
    ASSERT(pRemoteName != NULL);
    ASSERT(pConnectionName != NULL);

    DBGMSG(DBG_TRACE, ("DRPROV: CreateConnectionName, RemoteName: %ws\n",
                           pRemoteName));
    
    if (pLocalName != NULL) {
        DBGMSG(DBG_TRACE, ("DRPROV: CreateConnection Name, LocalName: %ws\n",
                           pLocalName));
    }

    //
    // The remote name is in the UNC format \\Server\Share.  This name
    // needs to be translated to an appropriate NT name in order to
    // issue the request to the underlying mini redirector to create the
    // connection.
    //
    // The NT style name is of the form
    //
    //  \device\rdpdr\;<DriveLetter>:<sessionid>\Server\Share
    //
    // The additional ; is required by the new RDR for extensibility.
    //

    // skip past the first back slash since the name to be appended for the
    // NT name does not require this.
    pRemoteName++;
    RemoteNameLength = wcslen(pRemoteName) * sizeof(WCHAR);

    if (pLocalName != NULL) {
        // Local name should not be greater than MAX_PATH;
        LocalNameLength = wcslen(pLocalName) * sizeof(WCHAR);

        if (LocalNameLength <= MAX_PATH * sizeof(WCHAR)) {
            wcscpy(LocalName, pLocalName);
        }
        else {
            wcsncpy(LocalName, pLocalName, MAX_PATH);
            LocalName[MAX_PATH] = L'\0';
        }
        
        // remove the trailing : in localname if there is one
        if (LocalName[LocalNameLength/sizeof(WCHAR) - 1] == L':') {
            LocalName[LocalNameLength/sizeof(WCHAR) - 1] = L'\0';
            LocalNameLength -= sizeof(WCHAR);    
        }
    } else {
        LocalNameLength = 0;
    }

    //
    // Get SessionId
    //
    dwSessionId = NtCurrentPeb()->SessionId;
    swprintf(pSessionId, L"%d", dwSessionId);

    pConnectionName->MaximumLength = (USHORT)(DrDeviceName.Length +
            RemoteNameLength + LocalNameLength +
            sizeof(WCHAR) * 3 + // account for \; and :
            wcslen(pSessionId) * sizeof(WCHAR) +
            sizeof(WCHAR));     // account of terminator null

    pConnectionName->Buffer = MemAlloc(pConnectionName->MaximumLength);

    if (pConnectionName->Buffer == NULL) {
        DBGMSG(DBG_TRACE, ("DRPROV: CreateConnectionName, MemAlloc failed\n"));
        status = WN_OUT_OF_MEMORY;
        goto EXIT;
    }

    // Copy the name into the buffer
    pConnectionName->Length = 0;
    pConnectionName->Buffer[0] = L'\0';
    RtlAppendUnicodeToString(pConnectionName, DrDeviceName.Buffer);

    RtlAppendUnicodeToString(pConnectionName, L"\\;");

    if (LocalNameLength != 0) {
        RtlAppendUnicodeToString(pConnectionName, LocalName);
    }
    
    RtlAppendUnicodeToString(pConnectionName, L":");
    
    
    RtlAppendUnicodeToString(pConnectionName, pSessionId);
    RtlAppendUnicodeToString(pConnectionName, pRemoteName);

    DBGMSG(DBG_TRACE, ("DRPROV: CreateConnectionName, %wZ\n", pConnectionName));
    status = WN_SUCCESS;

EXIT:    
    return status;
}

BOOL ValidateRemoteName(PWCHAR pRemoteName) 
/*++

Routine Description:

    This routine checks if the remote name belongs to our provider
    
Arguments:

    pRemoteName - the UNC remote name

Return Value:

    TRUE if the remote name belongs to our provider, otherwise FALSE

Notes:

--*/

{
    BOOL rc = FALSE;
    DWORD status;
    RDPDR_REQUEST_PACKET Rrp;            // Redirector request packet
    HANDLE DrDeviceHandle = INVALID_HANDLE_VALUE;
    LPBYTE Buffer = NULL;
    PRDPDR_SERVER_INFO pServerEntry;

    if (DrOpenMiniRdr(&DrDeviceHandle) != WN_SUCCESS) {
        //
        //  MPR doesn't like return device error in this case
        //  We'll just return 0 entries
        //
        DBGMSG(DBG_TRACE, ("DRPROV: ValidateRemoteName, DrOpenMiniRdr failed\n"));
        DrDeviceHandle = INVALID_HANDLE_VALUE;
        goto EXIT;
    }
                    
    //
    // Ask the redirector to enumerate the information of server
    // established by the caller.
    //
    Rrp.SessionId = NtCurrentPeb()->SessionId;
    Rrp.Parameters.Get.ResumeHandle = 0;

    //
    // Make the request to the Redirector
    //
    status = DrDeviceControlGetInfo(DrDeviceHandle,
            FSCTL_DR_ENUMERATE_SERVERS,
            &Rrp,
            sizeof(RDPDR_REQUEST_PACKET),
            (LPBYTE *) &Buffer,
            MAXULONG,
            0,
            NULL);

    if (status == WN_SUCCESS) {
        UNICODE_STRING ServerName;

        pServerEntry = ((PRDPDR_SERVER_INFO) Buffer);
        
        ServerName.Length = pServerEntry->ServerName.Length;
        ServerName.MaximumLength = pServerEntry->ServerName.MaximumLength;
        ServerName.Buffer = (PWCHAR)((PCHAR)(pServerEntry) + pServerEntry->ServerName.BufferOffset);

        if ((wcslen(pRemoteName) == ServerName.Length / sizeof(WCHAR)) &&
                _wcsnicmp(pRemoteName, ServerName.Buffer, 
                ServerName.Length/sizeof(WCHAR)) == 0) {
    
            rc = TRUE;
        }
        else {
            DBGMSG(DBG_TRACE, ("DRPROV: ValidateRemoteName, remote name not for drprov, %wZ\n",
                               pRemoteName));
            goto EXIT;
        }
    }
    else {
        DBGMSG(DBG_TRACE, ("DRENUM: ValidateRemoteName, DrDeviceControlGetInfo failed, %x\n", status));
        goto EXIT;
    }
    
EXIT:
    if (DrDeviceHandle != INVALID_HANDLE_VALUE) {
        CloseHandle(DrDeviceHandle);
    }

    if (Buffer != NULL) {
        MemFree(Buffer);
    }  

    DBGMSG(DBG_TRACE, ("DRPROV: ValidateRemoteName, return, %d\n", rc));
    return rc;
}

DWORD APIENTRY
NPAddConnection(
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName )
/*++

Routine Description:

    This routine adds a connection to the list of connections associated
    with this network provider

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpPassword  - the password

    lpUserName - the user name

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    DBGMSG(DBG_TRACE, ("DRPROV: NPAddConnection.\n"));
    return NPAddConnection3(NULL, lpNetResource, lpPassword, lpUserName, 0);
}


DWORD
TestAddConnection(
    LPNETRESOURCE   lpNetResource)
/*++

Routine Description:

    This routine tests adding a connection to the list of connections associated
    with this network provider

Arguments:

    lpNetResource - the NETRESOURCE struct

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error
    
--*/

{
    DWORD Status = 0;
    UNICODE_STRING ConnectionName;
    HANDLE ConnectionHandle = INVALID_HANDLE_VALUE;
    PWCHAR pRemoteName;
    
    DBGMSG(DBG_TRACE, ("DRPROV: TestAddConnection\n"));

    pRemoteName = lpNetResource->lpRemoteName;

    // Create ConnectionName with NULL local name
    Status = CreateConnectionName(NULL, pRemoteName, &ConnectionName);

    if (Status != WN_SUCCESS) {
        DBGMSG(DBG_TRACE, ("DRPROV: TestAddConnection, CreateConnectName failed\n"));
        goto EXIT;
    }

    Status = OpenConnection(
            &ConnectionName,
            FILE_OPEN,
            (FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT),
            NULL,
            0,
            &ConnectionHandle);

    if (Status != WN_SUCCESS) {
        ConnectionHandle = INVALID_HANDLE_VALUE;
        goto EXIT;
    }

EXIT:
    if (ConnectionHandle != INVALID_HANDLE_VALUE) {
        NtClose(ConnectionHandle);
        ConnectionHandle = INVALID_HANDLE_VALUE;
    }

    if (ConnectionName.Buffer != NULL) {
        MemFree(ConnectionName.Buffer);
        ConnectionName.Buffer = NULL;
    }

    return Status;
}


DWORD APIENTRY
NPAddConnection3(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPWSTR          lpPassword,
    LPWSTR          lpUserName,
    DWORD           dwFlags )
/*++

Routine Description:

    This routine adds a connection to the list of connections associated
    with this network provider

Arguments:

    hwndOwner - the owner handle

    lpNetResource - the NETRESOURCE struct

    lpPassword  - the password

    lpUserName - the user name

    dwFlags - flags for the connection

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

    // JOYC: do we need to pass credential to the redirector?
    // Seems the sessionId verification is enough    

--*/
{
    DWORD Status = 0;
    UNICODE_STRING ConnectionName;
    HANDLE ConnectionHandle;
    PWCHAR pLocalName,pRemoteName;
    
    DBGMSG(DBG_TRACE, ("DRPROV: NPAddConnection 3.\n"));

    ConnectionName.Buffer = NULL;
    ConnectionName.Length = 0;
    ConnectionHandle = INVALID_HANDLE_VALUE;


    // 
    //  Make sure remote name starts with \\
    //
    if ((lpNetResource == NULL) ||
        (lpNetResource->lpRemoteName == NULL) ||
        (lpNetResource->lpRemoteName[0] != L'\\') ||
        (lpNetResource->lpRemoteName[1] != L'\\')) {
        DBGMSG(DBG_TRACE, ("DRPROV: invalid lpNetResource parameter.\n"));
        Status = WN_BAD_NETNAME;
        goto EXIT;
    }

    //
    // The remote name is in the UNC format \\Server\Share.  This name
    // needs to be translated to an appropriate NT name in order to
    // issue the request to the underlying mini redirector to create the
    // connection.
    //
    // The NT style name is of the form
    //
    //  \device\rdpdr\;<DriveLetter>:<sessionid>\Server\Share
    //
    // The additional ; is required by the new RDR for extensibility.
    //

    // Test if rdpdr provider recognize this remote name or not
    Status = TestAddConnection(lpNetResource);

    if (Status != WN_SUCCESS) {
        DBGMSG(DBG_TRACE, ("DRPROV: NPAddConnection3, TestAddConnection failed\n"));
        goto EXIT;
    }

    pLocalName = lpNetResource->lpLocalName;
    pRemoteName = lpNetResource->lpRemoteName;

    Status = CreateConnectionName(pLocalName, pRemoteName, &ConnectionName);

    if (Status != WN_SUCCESS) {
        DBGMSG(DBG_TRACE, ("DRPROV: NPAddConnection3, CreateConnectName failed\n"));
        goto EXIT;
    }

    if ((Status == WN_SUCCESS) && (pLocalName != NULL)) {
        WCHAR TempBuf[64];

        DBGMSG(DBG_TRACE, ("DRPROV: NPAddConnection3, create dos symbolic link\n"));

        if (!QueryDosDeviceW(pLocalName, TempBuf, 64)) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND) {
                //
                // ERROR_FILE_NOT_FOUND (translated from OBJECT_NAME_NOT_FOUND)
                // means it does not exist and we can redirect this device.
                goto Done;
            }
         
            else {
                //
                // Most likely failure occurred because our output
                // buffer is too small.  It still means someone already
                // has an existing symbolic link for this device.
                //
                DBGMSG(DBG_TRACE, ("DRPROV: NPAddConnection3, DosName already assigned, %ws\n",
                                  pLocalName));
                Status = ERROR_ALREADY_ASSIGNED;
                goto EXIT;
            } 
        } 
        else {

            //
            // QueryDosDevice successfully an existing symbolic link--
            // somebody is already using this device.
            //
            DBGMSG(DBG_TRACE, ("DRPROV: NPAddConnection3, DosName already assigned, %ws\n",
                               pLocalName));
            Status = ERROR_ALREADY_ASSIGNED;
            goto EXIT;
        }
    } 

Done:
    //
    //  We are not doing anything with username/password
    //
    Status = OpenConnection(
            &ConnectionName,
            FILE_OPEN,
            (FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT),
            NULL,
            0,
            &ConnectionHandle);

    if (Status != WN_SUCCESS) {
        ConnectionHandle = INVALID_HANDLE_VALUE;
    }
    else {
        //
        // Create a symbolic link object to the device we are redirecting
        //
        if (DefineDosDeviceW(
                        DDD_RAW_TARGET_PATH |
                        DDD_NO_BROADCAST_SYSTEM,
                        pLocalName,
                        ConnectionName.Buffer)) {
            Status = WN_SUCCESS;
        }
        else {
            Status = GetLastError();
            DBGMSG(DBG_TRACE, ("DRPROV: NPAddConnection3, failed DefineDosDeviceW, %x.\n",
                               Status));
            goto EXIT;
        }
    }
    
EXIT:

    if (ConnectionHandle != INVALID_HANDLE_VALUE) {
        NtClose(ConnectionHandle);
    }

    if (ConnectionName.Buffer != NULL) {
        MemFree(ConnectionName.Buffer);
    }

    DBGMSG(DBG_TRACE, ("DRPROV: NPAddConnection3, return status: %x\n", Status));
    return Status;
}

DWORD APIENTRY
NPCancelConnection(
    LPWSTR  lpName,
    BOOL    fForce )
/*++

Routine Description:

    This routine cancels ( deletes ) a connection from the list of connections
    associated with this network provider

Arguments:

    lpName - name of the connection

    fForce - forcefully delete the connection

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/

{
    BOOL            bLocalName = FALSE;
    DWORD           Status = 0;
    NTSTATUS        ntStatus;
    HANDLE          ConnectionHandle;
    IO_STATUS_BLOCK IoStatusBlock;
    UNICODE_STRING  ConnectionName;
    WCHAR           TargetPath[MAX_PATH + 1];
    
    DBGMSG(DBG_TRACE, ("DRPROV: NPCancelConnection.\n"));

    ConnectionName.Buffer = NULL;
    ConnectionName.Length = 0;
    ConnectionHandle = INVALID_HANDLE_VALUE;

    // lpName should contain at least two characters: either two back slashes or dos name
    if (lpName == NULL || wcslen(lpName) == 0) {
        DBGMSG(DBG_TRACE, ("DRPROV: NPCancelConnection, invalid lpName parameter.\n"));
        Status = WN_BAD_VALUE;
        goto EXIT;
    }

    // We get the UNC name
    if (*lpName == L'\\' && *(lpName + 1) == L'\\') {
        DBGMSG(DBG_TRACE, ("DRPROV: NPCancelConnection, lpName is UNC name, %ws.\n", *lpName));
        bLocalName = FALSE;

        // Setup the NT Device Name
        Status = CreateConnectionName(NULL, lpName, &ConnectionName);      
        
        if (Status != WN_SUCCESS) {
            DBGMSG(DBG_TRACE, ("DRPROV: NPCancelConnection, CreateConnectName failed\n"));
            goto EXIT;
        }
    }
    // We get the local name
    else {
        DBGMSG(DBG_TRACE, ("DRPROV: NPCancelConnection, lpName is local name, %ws.\n", *lpName));
        bLocalName = TRUE;

        // Find the NT devive path
        if (QueryDosDevice(lpName, TargetPath, sizeof(TargetPath)/sizeof(WCHAR) - 1)) {
            ConnectionName.Length =  wcslen(TargetPath) * sizeof(WCHAR);
            ConnectionName.MaximumLength =  ConnectionName.Length + sizeof(WCHAR);
            ConnectionName.Buffer = TargetPath;
        }
        else {
            Status = WN_BAD_NETNAME;
            DBGMSG(DBG_TRACE, ("DRPROV: NPCancelConnection, QueryDosDevice failed, %x.\n", Status));
            goto EXIT;
        }
    }

    Status = OpenConnection(
                 &ConnectionName,
                 FILE_OPEN,
                 (FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT),
                 NULL,
                 0,
                 &ConnectionHandle);

    if (Status == WN_SUCCESS) {
        // Request the driver to delete the connection entry
        ntStatus = NtFsControlFile(
                            ConnectionHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            FSCTL_DR_DELETE_CONNECTION,
                            NULL,
                            0,
                            NULL,
                            0);

        if (ntStatus == STATUS_SUCCESS) {
            DBGMSG(DBG_TRACE, ("DRPROV: NPCancelConnection, Deleting dos symbolic link, %ws\n", lpName));

            if (bLocalName) {
                if (DefineDosDevice(
                        DDD_REMOVE_DEFINITION | DDD_RAW_TARGET_PATH | DDD_EXACT_MATCH_ON_REMOVE,
                        lpName,
                        ConnectionName.Buffer)) {
                    Status = WN_SUCCESS;
                    goto EXIT;
                }
                else {
                    Status = GetLastError();
                    DBGMSG(DBG_TRACE, ("DRPROV: NPCancelConnection failed to delete symbolic link, %x.\n",
                                       Status));
                    goto EXIT;
                }
            }
        }
        else {
            DBGMSG(DBG_TRACE, ("DRPROV: NPCancelConnection, failed NtFsControlFile, %x\n", ntStatus));
            Status = WN_BAD_NETNAME;
            goto EXIT;
        }    
    }
    else {
        DBGMSG(DBG_TRACE, ("DRPROV: NPCancelConnection, OpenConnection %wZ failed, %x\n", 
                           &ConnectionName, Status));
        ConnectionHandle = INVALID_HANDLE_VALUE;
        Status = WN_BAD_NETNAME;
        goto EXIT;
    }
    
EXIT:
    if (bLocalName != TRUE && ConnectionName.Buffer != NULL) {
        MemFree(ConnectionName.Buffer);
    }

    if (ConnectionHandle != INVALID_HANDLE_VALUE) {
        NtClose(ConnectionHandle);
    }

    DBGMSG(DBG_TRACE, ("DRPROV: NPCancelConnection, return status: %x\n", Status));
    return Status;
}

DWORD APIENTRY
NPGetConnection(
    LPWSTR  lpLocalName,
    LPWSTR  lpRemoteName,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information associated with a connection

Arguments:

    lpLocalName - local name associated with the connection

    lpRemoteName - the remote name associated with the connection

    lpBufferSize - the remote name buffer size

Return Value:

    WN_SUCCESS if successful, otherwise the appropriate error

Notes:

--*/
{
    DWORD Status = 0;
    NTSTATUS ntStatus;
    HANDLE ConnectionHandle;
    RDPDR_REQUEST_PACKET Rrp;            // Redirector request packet
    UNICODE_STRING  ConnectionName;
    WCHAR TargetPath[MAX_PATH + 1];
    LPBYTE Buffer = NULL;
    PRDPDR_CONNECTION_INFO ConnectionInfo;

    DBGMSG(DBG_TRACE, ("DRPROV: NPGetConnection.\n"));

    ConnectionName.Buffer = NULL;
    ConnectionName.Length = 0;
    ConnectionHandle = INVALID_HANDLE_VALUE;

    if (lpLocalName == NULL || lpRemoteName == NULL || lpBufferSize == NULL) {
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetConnection, invalid parameter(s).\n"));
        Status = WN_BAD_VALUE;
        goto EXIT;
    }

    // Find the NT devive path
    if (QueryDosDevice(lpLocalName, TargetPath, sizeof(TargetPath)/sizeof(WCHAR) - 1)) {
        ConnectionName.Length =  wcslen(TargetPath) * sizeof(WCHAR);
        ConnectionName.MaximumLength =  ConnectionName.Length + sizeof(WCHAR);
        ConnectionName.Buffer = TargetPath;
    }
    else {
        Status = GetLastError();
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetConnection, querydosdevice failed, %x\n", Status));
        goto EXIT;
    }
    
    // Check if this connection belongs to rdpdr
    if (wcsstr(TargetPath, RDPDR_DEVICE_NAME_U) != NULL) {
        
        Status = OpenConnection(
                     &ConnectionName,
                     FILE_OPEN,
                     (FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT),
                     NULL,
                     0,
                     &ConnectionHandle);
    
        if (Status == WN_SUCCESS) {
            // Request the driver to retrieve the connection entry info
            Rrp.SessionId = NtCurrentPeb()->SessionId;
            Rrp.Parameters.Get.ResumeHandle = 0;
    
            DBGMSG(DBG_TRACE, ("DRPROV: NPGetConnection, call DrDeviceControlGetInfo\n"));
    
            //
            // Make the request to the Redirector
            //
            if (DrDeviceControlGetInfo(
                                  ConnectionHandle,
                                  FSCTL_DR_GET_CONNECTION_INFO,
                                  &Rrp,
                                  sizeof(RDPDR_REQUEST_PACKET),
                                  (LPBYTE *) &Buffer,
                                  MAXULONG,
                                  0,
                                  NULL
                                  ) == WN_SUCCESS) {
                UNICODE_STRING RemoteName;
    
                ConnectionInfo = (PRDPDR_CONNECTION_INFO)Buffer;
                RemoteName.Length = ConnectionInfo->RemoteName.Length;
                RemoteName.MaximumLength = ConnectionInfo->RemoteName.MaximumLength;
                RemoteName.Buffer = (PWCHAR)((PCHAR)(ConnectionInfo) + 
                        ConnectionInfo->RemoteName.BufferOffset);
                if (*lpBufferSize > RemoteName.Length) {
                    *lpBufferSize = RemoteName.Length + sizeof(WCHAR);
                    RtlCopyMemory(
                            lpRemoteName,
                            RemoteName.Buffer,
                            RemoteName.Length);
                    lpRemoteName[RemoteName.Length/sizeof(WCHAR)] = L'\0';
                    DBGMSG(DBG_TRACE, ("DRPROV: NPGetConnection, remote name %ws\n", lpRemoteName));
                    Status = WN_SUCCESS;
                    goto EXIT;
                }
                else {
                    DBGMSG(DBG_TRACE, ("DRPROV: NPGetConnection, buffer too small\n"));
                    *lpBufferSize = RemoteName.Length + sizeof(WCHAR);
                    Status = WN_MORE_DATA;
                    goto EXIT;
                }
            } 
            else {
                DBGMSG(DBG_TRACE, ("DRPROV: NPGetConnection, DrDeviceControlGetInfo failed\n"));
                Status = WN_BAD_NETNAME;
                goto EXIT;
            }    
        }
        else {
            DBGMSG(DBG_TRACE, ("DRPROV: NPGetConnection, OpenConnection failed, %x\n", Status));
            ConnectionHandle = INVALID_HANDLE_VALUE;
            Status = WN_BAD_NETNAME;
            goto EXIT;
        }    
    }
    else {
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetConnection, DrDeviceControlGetInfo failed\n"));
        Status = WN_BAD_NETNAME;
        goto EXIT;
    }

EXIT:

    if (ConnectionHandle != INVALID_HANDLE_VALUE) {
        NtClose(ConnectionHandle);
    }

    if (Buffer != NULL) {
        MemFree(Buffer);
    }
    DBGMSG(DBG_TRACE, ("DRPROV: NPGetConnection, return status: %x\n", Status));
    return Status;               
}


DWORD APIENTRY
NPGetResourceParent(
    LPNETRESOURCE   lpNetResource,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the parent of a given resource

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpBuffer - the buffer for passing back the parent information

    lpBufferSize - the buffer size

Return Value:

    WN_NOT_SUPPORTED

Notes:

    The current sample does not handle this call.

--*/
{
    //
    //  JOYC: Need to support this?
    //
    DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceParent.\n"));
    return WN_NOT_SUPPORTED;
}

DWORD APIENTRY
NPGetResourceInformation(
    LPNETRESOURCE   lpNetResource,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize,
    LPWSTR  *lplpSystem )
/*++

Routine Description:

    This routine returns the information associated net resource

Arguments:

    lpNetResource - the NETRESOURCE struct

    lpBuffer - the buffer for passing back the resource information

    lpBufferSize - the buffer size

    lplpSystem -

Return Value:

Notes:

--*/
{
    DWORD Status = 0;
    LPNETRESOURCE pOutNetResource;
    UNICODE_STRING RemoteName;
    UNICODE_STRING SystemPath;
    BOOL fResourceTypeDisk = FALSE ;
    WORD wSlashCount = 0;
    BYTE *BufferResourceStart, *BufferResourceEnd;
    PWCHAR pCurPos;
    
    DBGMSG(DBG_TRACE, ("DRPROV: NPGetConnection.\n"));

    RemoteName.Buffer = NULL;
    RemoteName.Length = RemoteName.MaximumLength = 0;

    if (lpBuffer == NULL || lpBufferSize == NULL) {
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, invalid parameter(s).\n"));
        Status = WN_BAD_VALUE;
        goto EXIT;
    }

    pOutNetResource = (LPNETRESOURCE)lpBuffer;
    BufferResourceStart = (PBYTE)lpBuffer;
    BufferResourceEnd = ((PBYTE)(pOutNetResource)) + *lpBufferSize;
    
    SystemPath.Buffer = NULL;
    SystemPath.Length = SystemPath.MaximumLength = 0;
    
    //
    //  JOYC: Do we need to check if we are the right provider from lpProvider?
    //        And the dwType?
    //
    if (lpNetResource == NULL || lpNetResource->lpRemoteName == NULL) {
        if (*lpBufferSize >= sizeof(NETRESOURCEW)) {
            //
            // Handle this as if we are at the root of our provider hierarchy.
            //
            pOutNetResource->dwScope = RESOURCE_GLOBALNET;
            pOutNetResource->dwType = RESOURCETYPE_ANY;
            pOutNetResource->dwDisplayType = RESOURCEDISPLAYTYPE_NETWORK;
            pOutNetResource->dwUsage = RESOURCEUSAGE_CONTAINER;

            pOutNetResource->lpLocalName = NULL;
            pOutNetResource->lpRemoteName = NULL;

            // JOYC: need to set this to our provider?
            pOutNetResource->lpProvider = NULL;
            pOutNetResource->lpComment = NULL;
            *lpBufferSize = sizeof(NETRESOURCEW);

            if (lplpSystem) {
                *lplpSystem = NULL;
            }

            DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, NULL remote Name\n"));
            Status = WN_SUCCESS;
            goto EXIT;
        }
        else {
            DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, buffer too small.\n"));
            *lpBufferSize = sizeof(NETRESOURCEW);
            Status = WN_MORE_DATA;
            goto EXIT;
        }
    }

    //
    // Find out if we are looking at a \\server, \\server\vol, or
    // \\server\vol\dir . . .
    //
    wSlashCount = 0;
    pCurPos = lpNetResource->lpRemoteName;
    while (*pCurPos != '\0') {
        if (*pCurPos == L'\\') {
            wSlashCount++;
        }

        //  Get the system path
        if (wSlashCount == 4) {
            SystemPath.Buffer = pCurPos;
            SystemPath.Length =
                    (USHORT) (wcslen(lpNetResource->lpRemoteName) * sizeof(WCHAR) -
                    (SystemPath.Buffer - lpNetResource->lpRemoteName) * sizeof(WCHAR));
            SystemPath.MaximumLength = SystemPath.Length + sizeof(WCHAR);
            break;
        }
        pCurPos++;
    }

    if ( wSlashCount > 2 )
        fResourceTypeDisk = TRUE;

    //
    // Open a connection handle to \\server\vol\...
    //
    
    // Setup remote name
    pCurPos = lpNetResource->lpRemoteName;
    if (SystemPath.Length != 0) {
        RemoteName.Length = (USHORT)((SystemPath.Buffer - pCurPos) * sizeof(WCHAR));       
        RemoteName.MaximumLength = RemoteName.Length + sizeof(WCHAR); 
    }
    else {
        RemoteName.Length = wcslen(pCurPos) * sizeof(WCHAR);
        RemoteName.MaximumLength = RemoteName.Length + sizeof(WCHAR);
    }
   
    RemoteName.Buffer = MemAlloc(RemoteName.MaximumLength);

    if (RemoteName.Buffer == NULL) {
        Status = GetLastError();
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, MemAlloc failed.\n"));
        goto EXIT;
    }

    RtlCopyMemory(RemoteName.Buffer, pCurPos, RemoteName.Length);
    RemoteName.Buffer[RemoteName.Length/sizeof(WCHAR)] = L'\0';

    DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, RemoteName, %ws\n", RemoteName.Buffer));

    if (fResourceTypeDisk) {    
        UNICODE_STRING ConnectionName;
        HANDLE ConnectionHandle;
        
        ConnectionName.Buffer = NULL;
        ConnectionName.Length = 0;
        ConnectionHandle = INVALID_HANDLE_VALUE;

        // Setup the NT Device Name
        Status = CreateConnectionName(NULL, RemoteName.Buffer, &ConnectionName);

        if (Status == WN_SUCCESS) {
            Status = OpenConnection(&ConnectionName,
                    FILE_OPEN,
                    (FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT),
                    NULL,
                    0,
                    &ConnectionHandle);

            if (ConnectionName.Buffer != NULL) {
                MemFree(ConnectionName.Buffer);
            }

            if (Status == WN_SUCCESS) {
                CloseHandle(ConnectionHandle);
            }
            else {
                DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, OpenConnection failed"));
                goto EXIT;
            }                       
        }
        else {
            DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, CreateConnectionName failed\n"));
            goto EXIT;
        }
    }
    else {
        RDPDR_REQUEST_PACKET Rrp;            // Redirector request packet
        HANDLE DrDeviceHandle = 0;
        PRDPDR_SERVER_INFO pServerEntry;
        LPBYTE Buffer = NULL;
        UNICODE_STRING ServerName;

        if (DrOpenMiniRdr(&DrDeviceHandle) != WN_SUCCESS) {
            DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, failed to Open rdpdr\n"));
            Status = WN_BAD_NETNAME;
            goto EXIT;
        }
                        
        //
        // Ask the redirector to enumerate the information of server
        // established by the caller.
        //
        Rrp.SessionId = NtCurrentPeb()->SessionId;
        Rrp.Parameters.Get.ResumeHandle = 0;

        //
        // Make the request to the Redirector
        //
        Status = DrDeviceControlGetInfo(
                DrDeviceHandle,
                FSCTL_DR_ENUMERATE_SERVERS,
                &Rrp,
                sizeof(RDPDR_REQUEST_PACKET),
                (LPBYTE *) &Buffer,
                MAXULONG,
                0,
                NULL);

        CloseHandle(DrDeviceHandle);

        if (Status != WN_SUCCESS) {
            DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, DrDeviceControlGetInfo failed\n"));
            Status = WN_BAD_NETNAME;
            goto EXIT;
        }
        
        pServerEntry = ((PRDPDR_SERVER_INFO) Buffer);
        ServerName.Length = pServerEntry->ServerName.Length;
        ServerName.MaximumLength = pServerEntry->ServerName.MaximumLength;
        ServerName.Buffer = (PWCHAR)((PCHAR)(pServerEntry) + pServerEntry->ServerName.BufferOffset);
        
        if ((RemoteName.Length == ServerName.Length) &&
                _wcsnicmp(RemoteName.Buffer, ServerName.Buffer, 
                ServerName.Length/sizeof(WCHAR)) == 0) {

            if (Buffer != NULL) {
                MemFree(Buffer);
            }
            Status = WN_SUCCESS;
        }
        else {
            DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, invalid net name, %wZ\n",
                               RemoteName));
            if (Buffer != NULL) {
                MemFree(Buffer);
            }
            Status = WN_BAD_NETNAME;
            goto EXIT;
        }        
    }

    if (Status == WN_SUCCESS)
    {
        //
        // The resource exists, setup info.
        // 
        *lpBufferSize = sizeof(NETRESOURCEW) +
                RemoteName.Length + sizeof(WCHAR) +
                DrProviderName.Length + sizeof(WCHAR) +
                SystemPath.Length + sizeof(WCHAR);

        if ((unsigned) (BufferResourceEnd - BufferResourceStart) > *lpBufferSize) {

            pOutNetResource->dwScope = 0;
            pOutNetResource->dwType = fResourceTypeDisk ?
                           RESOURCETYPE_DISK :
                           RESOURCETYPE_ANY;
            pOutNetResource->dwDisplayType = fResourceTypeDisk ?
                                  RESOURCEDISPLAYTYPE_SHARE :
                                  RESOURCEDISPLAYTYPE_SERVER;
            pOutNetResource->dwUsage = fResourceTypeDisk ?
                            RESOURCEUSAGE_CONNECTABLE |
                            RESOURCEUSAGE_NOLOCALDEVICE :
                            RESOURCEUSAGE_CONTAINER;

            pOutNetResource->lpLocalName = NULL;
            
            // Setup remote name
            BufferResourceEnd -= RemoteName.Length + sizeof(WCHAR);
            pOutNetResource->lpRemoteName = (PWCHAR) (BufferResourceStart + sizeof(NETRESOURCE));
            RtlCopyMemory(pOutNetResource->lpRemoteName, RemoteName.Buffer,
                    RemoteName.Length);
            pOutNetResource->lpRemoteName[RemoteName.Length / 
                    sizeof(WCHAR)] = L'\0';
            
            DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, RemoteName, %ws\n",
                               pOutNetResource->lpRemoteName));

            // Setup provider name
            BufferResourceEnd -= DrProviderName.Length + sizeof(WCHAR);
            pOutNetResource->lpProvider = (PWCHAR) ((PBYTE)(pOutNetResource->lpRemoteName) + 
                    RemoteName.Length + sizeof(WCHAR));
            RtlCopyMemory(pOutNetResource->lpProvider, DrProviderName.Buffer,
                    DrProviderName.Length);
            pOutNetResource->lpProvider[DrProviderName.Length /
                    sizeof(WCHAR)] = L'\0';

            pOutNetResource->lpComment = NULL;

            // Setup system path
            if (lplpSystem) {
                if (SystemPath.Length) {
                    BufferResourceEnd -= SystemPath.Length + sizeof(WCHAR);
                    *lplpSystem = (PWCHAR) ((PBYTE)(pOutNetResource->lpProvider) + 
                            DrProviderName.Length + sizeof(WCHAR));
                    RtlCopyMemory(*lplpSystem, SystemPath.Buffer,
                            SystemPath.Length);
                    (*lplpSystem)[SystemPath.Length / sizeof(WCHAR)] = L'\0';                    

                    DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, SystemPath, %ws\n",
                                       *lplpSystem));
                }
                else {
                    DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, SystemPath null\n"));
                    *lplpSystem = NULL;
                }
            }
            else {
                DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, user doesn't require systempath\n"));
            }

            Status = WN_SUCCESS;
            goto EXIT;
        }
        else {
            DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInfo, buffer too small\n"));
            Status = WN_MORE_DATA;
            goto EXIT;
        }        
    }
    else {
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetResourceInformation, bad net name.\n"));
        Status = WN_BAD_NETNAME;
        goto EXIT;
    }
    
EXIT:
    if (RemoteName.Buffer != NULL) {
        MemFree(RemoteName.Buffer);
    }
    
    return Status;
}

DWORD APIENTRY
NPGetUser(
    IN LPTSTR lpName,
    OUT LPTSTR lpUserName,
    IN OUT LPDWORD lpBufferSize
    )
/*++

Routine Description:

    This function determines the user name that created the connection.

Arguments:

    lpName - Name of the local drive or the remote name that the user has made
             a connection to. If NULL, return currently logged on user.
    
    lpUserName - The buffer to be filled in with the requested user name.
    
    lpBufferSize - Contains the length (in chars not bytes )of the lpUserName 
                   buffer. If the length is insufficient, this place is used to 
                   inform the user the actual length needed. 

Return Value:

    WN_SUCCESS - Successful. OR

    The appropriate network error code.

--*/
{
    DWORD Status = WN_SUCCESS;
    WCHAR NameBuffer[USERNAMELEN + 1];
    DWORD NumOfChars = USERNAMELEN + 1;

    DBGMSG(DBG_TRACE, ("DRPROV: NPGetUser.\n"));

    if (lpUserName == NULL || lpBufferSize == NULL) {
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetUser, invalid parameter(s)\n"));
        Status = WN_BAD_VALUE;
        goto EXIT;
    }
    //
    // Get the name of the currently logged on user.
    //
    if (!GetUserName( NameBuffer, &(NumOfChars))) {
        Status = GetLastError();
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetUser, failed to get user name, %x\n", Status));
        goto EXIT;
    }

    //
    // Check to see if the buffer passed in is of the required length.
    //
    if ( *lpBufferSize < NumOfChars ) {
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetUser, buffer too small.\n"));
        *lpBufferSize = NumOfChars;
        Status = WN_MORE_DATA;
        goto EXIT;
    
    }

    //
    // Copy the user name.
    //
    wcscpy(lpUserName, NameBuffer);

EXIT:

    DBGMSG(DBG_TRACE, ("DRPROV: NPGetUser, return status: %x\n", Status));
    return Status;
}

DWORD APIENTRY
NPGetUniversalName(
    LPCWSTR lpLocalPath,
    DWORD   dwInfoLevel,
    LPVOID  lpBuffer,
    LPDWORD lpBufferSize )
/*++

Routine Description:

    This routine returns the information associated net resource

Arguments:
                
    lpLocalPath - the local path name

    dwInfoLevel  - the desired info level

    lpBuffer - the buffer for the univeral name

    lpBufferSize - the buffer size

Return Value:

    WN_SUCCESS if successful

Notes:

--*/
{
    DWORD   Status = WN_SUCCESS;

    DWORD   BufferRequired = 0;
    DWORD   UniversalNameLength = 0;
    DWORD   RemoteNameLength = 0;
    DWORD   RemainingPathLength = 0;

    LPWSTR  pDriveLetter,
            pRemainingPath,
            SourceStrings[3];
    
    WCHAR   RemoteName[MAX_PATH],
            LocalPath[MAX_PATH],
            UniversalName[MAX_PATH],
            ReplacedChar;

    DBGMSG(DBG_TRACE, ("DRPROV: NPGetUniversalName\n"));

    // parameter checking
    if (dwInfoLevel != UNIVERSAL_NAME_INFO_LEVEL &&
            dwInfoLevel != REMOTE_NAME_INFO_LEVEL) {
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetUniversalName, bad InfoLevel, %d\n", dwInfoLevel));
        Status = WN_BAD_LEVEL;
        goto EXIT;
    }

    if (lpLocalPath == NULL || lpBuffer == NULL || lpBufferSize == NULL) {
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetUniversalName, invalid parameter(s)\n"));
        Status = WN_BAD_VALUE;
        goto EXIT;
    }

    // Get the local name
    wcscpy(LocalPath, lpLocalPath);
    pDriveLetter = LocalPath;
    if (pRemainingPath = wcschr(pDriveLetter, L':')) {
        ReplacedChar = *(++pRemainingPath);
        *pRemainingPath = L'\0';

    }

    // Get the remote name by calling NPGetConnection
    if ((Status = NPGetConnection(pDriveLetter, RemoteName, &RemoteNameLength)) != WN_SUCCESS) {
        //  MPR expects WN_BAD_LOCALNAME to bypass us.
        if (Status == WN_BAD_NETNAME) {
            Status = WN_BAD_LOCALNAME;
        }
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetUniversalName, NPGetConnection failed\n"));
        goto EXIT;
    }

    
    if (pRemainingPath) {
        *pRemainingPath = ReplacedChar;
    }

    wcscpy(UniversalName, RemoteName);

    if (pRemainingPath)
        wcscat(UniversalName, pRemainingPath);

    // Determine if the provided buffer is large enough.
    UniversalNameLength = (wcslen(UniversalName) + 1) * sizeof(WCHAR);
    BufferRequired = UniversalNameLength;

    if (dwInfoLevel == UNIVERSAL_NAME_INFO_LEVEL) {
        BufferRequired += sizeof(UNIVERSAL_NAME_INFO);
    }
    else {
        RemoteNameLength = (wcslen(RemoteName) + 1) * sizeof(WCHAR);
        BufferRequired += sizeof(REMOTE_NAME_INFO) + RemoteNameLength;
        if (pRemainingPath) {
            RemainingPathLength = (wcslen(pRemainingPath) + 1) * sizeof(WCHAR);
            BufferRequired += RemainingPathLength;
        }
    }

    if (*lpBufferSize < BufferRequired) {
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetUniversalName, buffer too small\n"));
        *lpBufferSize = BufferRequired;
        Status = WN_MORE_DATA;
        goto EXIT;
    }

    if (dwInfoLevel == UNIVERSAL_NAME_INFO_LEVEL) {
        LPUNIVERSAL_NAME_INFOW pUniversalNameInfo;

        pUniversalNameInfo = (LPUNIVERSAL_NAME_INFOW)lpBuffer;

        pUniversalNameInfo->lpUniversalName = (PWCHAR)((PBYTE)lpBuffer + sizeof(UNIVERSAL_NAME_INFOW));

        RtlCopyMemory(
            pUniversalNameInfo->lpUniversalName,
            UniversalName,
            UniversalNameLength);
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetUniversalName, UniversalName, %ws\n", UniversalName));
        Status = WN_SUCCESS;
    } 
    else {
        LPREMOTE_NAME_INFOW pRemoteNameInfo;

        pRemoteNameInfo = (LPREMOTE_NAME_INFOW)lpBuffer;

        pRemoteNameInfo->lpUniversalName = (PWCHAR)((PBYTE)lpBuffer + sizeof(REMOTE_NAME_INFOW));
        pRemoteNameInfo->lpConnectionName = pRemoteNameInfo->lpUniversalName + UniversalNameLength;
        pRemoteNameInfo->lpRemainingPath = pRemoteNameInfo->lpConnectionName + RemoteNameLength;

        RtlCopyMemory(
            pRemoteNameInfo->lpUniversalName,
            UniversalName,
            UniversalNameLength);

        RtlCopyMemory(
            pRemoteNameInfo->lpConnectionName,
            RemoteName,
            RemoteNameLength);

        RtlCopyMemory(
            pRemoteNameInfo->lpRemainingPath,
            pRemainingPath,
            RemainingPathLength);

        DBGMSG(DBG_TRACE, ("DRPROV: NPGetUniversalName, UniversalName, %ws\n", UniversalName));
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetUniversalName, RemoteName, %ws\n", RemoteName));
        DBGMSG(DBG_TRACE, ("DRPROV: NPGetUniversalName, Remaining Path, %ws\n", pRemainingPath));
        Status = WN_SUCCESS;
    }

EXIT:

    DBGMSG(DBG_TRACE, ("DRPROV: NPGetUniversalName, return status, %x\n", Status)); 
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\drkdx\kdextlib.h ===
/*++

Copyright (c) 1990 Microsoft Corporation

Module Name:

    kdextlib.h

Abstract:

    Redirector Kernel Debugger extension

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#ifndef _KDEXTLIB_H_
#define _KDEXTLIB_H_

//#include <windef.h>

//
// The FIELD_DESCRIPTOR data structure is used to describe the field in a structure sufficiently
// for displaying information during debugging. The three pieces of information that are required
// are 1) the name of the field, 2) the offset in the corresponding structure and 3) a type descriptor.
// The type descriptor covers most primitive types.
//
// The task of generating these descriptors by augmenting the front end, but that will have to
// wait till we play around with these extensions and modify the data structures to meet most
// of the requirements.
//
// There are some types that can benefit from some auxillary information in the descriptors. A
// case in point is the "enum" defeinition. Merely printing out a numerical value for an enum
// type will invariably force the person using these extensions to refer to the corresponding
// include file. In order to avoid this we will accept an additional array for enum types that
// contains a textual description of the numerical value.
//
// There are certain conventions that have been adopted to ease the definition of the macros
// as well as facilitate the automation of the generation of these descriptors.
// These are as follows ....
//
// 1) All ENUM_VALUE_DESCRIPTOR definitions are named EnumValueDescrsOf_ENUMTYPENAME, where
// ENUMTYPENAME defines the corresponding enumerated type.
//

typedef struct _ENUM_VALUE_DESCRIPTOR {
    ULONG   EnumValue;
    LPSTR   EnumName;
} ENUM_VALUE_DESCRIPTOR;

typedef enum _FIELD_TYPE_CLASS {
    FieldTypeNone,
    FieldTypeByte,
    FieldTypeChar,
    FieldTypeBoolean,
    FieldTypeBool,
    FieldTypeULong,
    FieldTypeULongUnaligned,
    FieldTypeULongFlags,
    FieldTypeLong,
    FieldTypeLongUnaligned,
    FieldTypeUShort,
    FieldTypeUShortUnaligned,
    FieldTypeUShortFlags,
    FieldTypeShort,
    FieldTypePointer,
    FieldTypeUnicodeString,
    FieldTypeAnsiString,
    FieldTypeSymbol,
    FieldTypeEnum,
    FieldTypeByteBitMask,
    FieldTypeWordBitMask,
    FieldTypeDWordBitMask,
    FieldTypeFloat,
    FieldTypeDouble,
    FieldTypeStruct,
    FieldTypeLargeInteger,
    FieldTypeFileTime
} FIELD_TYPE_CLASS, *PFIELD_TYPE_CLASS;

typedef struct _FIELD_DESCRIPTOR_ {
    FIELD_TYPE_CLASS FieldType;   // The type of variable to be printed
    LPSTR            Name;        // The name of the field
    //USHORT           Offset;      // The offset of the field in the structure
    LONG             Offset;      // The offset of the field in the structure
    union {
        ENUM_VALUE_DESCRIPTOR  *pEnumValueDescriptor; // Auxillary information for enumerated types.
    } AuxillaryInfo;
} FIELD_DESCRIPTOR;

#define FIELDLAST {FieldTypeNone, NULL, 0, NULL}

#define FIELD3(FieldType,StructureName, FieldName) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,NULL}

#define FIELD4(FieldType, StructureName, FieldName, AuxInfo) \
        {FieldType, #FieldName , FIELD_OFFSET(StructureName,FieldName) ,AuxInfo}

//
// The structs that are displayed by the debugger extensions are further
// described in another array. Each entry in the array contains the name of
// the structure and the associated Field descriptor list.
//

typedef struct _STRUCT_DESCRIPTOR_ {
    LPSTR 	          StructName;
    ULONG             StructSize;
    ULONG             EnumManifest;
    FIELD_DESCRIPTOR  *FieldDescriptors;
    USHORT            MatchMask;
    USHORT            MatchValue;
} STRUCT_DESCRIPTOR;

#define STRUCT(StructTypeName,FieldDescriptors,MatchMask,MatchValue) \
        { #StructTypeName,sizeof(StructTypeName), \
          StrEnum_##StructTypeName,               \
          FieldDescriptors,MatchMask,MatchValue}

#define STRUCTLAST {NULL, 0, 0, NULL, 0, 0}
//
//  The array of structs handled by the debugger extension.
//

extern STRUCT_DESCRIPTOR Structs[];

//
// Support for displaying global variables
//

extern LPSTR GlobalBool[];
extern LPSTR GlobalShort[];
extern LPSTR GlobalLong[];
extern LPSTR GlobalPtrs[];

#endif // _KDEXTLIB_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\drkdx\kdextlib.cpp ===
/*++

Copyright (c) 1990 Microsoft Corporation











------------------------------
T H I S   F I L E   I S   O B S O L E T E .    I T   I S   B E I N G   K E P T
F O R   A   W H I L E   J U S T   T O   M A K E   S U R E
----------------------------
















Module Name:

    kdextlib.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:
    The implementation tends to avoid memory allocation and deallocation as much as possible.
    Therefore We have choosen an arbitrary length as the default buffer size. A mechanism will
    be provided to modify this buffer length through the debugger extension commands.

Revision History:

    11-Nov-1994 SethuR  Created

--*/
#ifdef __cplusplus
extern "C" {
#endif
#include "rxovride.h" //common compile flags
#include "ntifs.h"
#include <nt.h>
//#include <ntrtl.h>
#include "ntverp.h"
#ifdef __cplusplus
}
#endif

#define KDEXTMODE

#include <windef.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <ntrxdef.h>
#include <rxtypes.h>


PWINDBG_OUTPUT_ROUTINE                lpOutputRoutine;
PWINDBG_GET_EXPRESSION32              lpGetExpressionRoutine;
PWINDBG_GET_SYMBOL32                  lpGetSymbolRoutine;
PWINDBG_READ_PROCESS_MEMORY_ROUTINE   lpReadMemoryRoutine;

#define    PRINTF    lpOutputRoutine
#define    ERROR     lpOutputRoutine

#define    NL      1
#define    NONL    0

#define    SETCALLBACKS() \
    lpOutputRoutine = lpExtensionApis->lpOutputRoutine; \
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine; \
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine; \
    lpReadMemoryRoutine = lpExtensionApis->lpReadVirtualMemRoutine;

#define DEFAULT_UNICODE_DATA_LENGTH 512
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 512
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

/*
 * Fetches the data at the given address
 */
BOOLEAN
GetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, PSZ type)
{
    BOOL b;
    ULONG BytesRead;

    b = (lpReadMemoryRoutine)(dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        PRINTF( "Unable to read %u bytes at %p, for %s\n", size, dwAddress, type );
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
GetString( ULONG_PTR dwAddress, PSZ buf )
{
    do {
        if( !GetData( dwAddress,buf, 1, "..stringfetch") )
            return FALSE;

        dwAddress++;
        buf++;

    } while( *buf != '\0' );

    return TRUE;
}

/*
 * Displays a byte in hexadecimal
 */
VOID
PrintHexChar( UCHAR c )
{
    PRINTF( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Displays a buffer of data in hexadecimal
 */
VOID
PrintHexBuf( PUCHAR buf, ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        PRINTF( " " );
    }
}

/*
 * Displays a unicode string
 */
BOOL
PrintStringW(LPSTR msg, PUNICODE_STRING puStr, BOOL nl )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING    AnsiString;
    BOOL           b;

    if( msg )
        PRINTF( msg );

    if( puStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    UnicodeString.Buffer        = s_pUnicodeStringData;
    UnicodeString.MaximumLength = s_UnicodeStringDataLength;
    UnicodeString.Length = (puStr->Length > s_UnicodeStringDataLength)
                            ? s_UnicodeStringDataLength
                            : puStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR) puStr->Buffer,
                UnicodeString.Buffer,
                UnicodeString.Length,
                NULL);

    if (b)    {
        RtlUnicodeStringToAnsiString(&AnsiString, puStr, TRUE);
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
        RtlFreeAnsiString(&AnsiString);
    }

    return b;
}

/*
 * Displays a ANSI string
 */
BOOL
PrintStringA(LPSTR msg, PANSI_STRING pStr, BOOL nl )
{
    ANSI_STRING AnsiString;
    BOOL        b;

    if( msg )
        PRINTF( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    AnsiString.Buffer        = s_pAnsiStringData;
    AnsiString.MaximumLength = s_AnsiStringDataLength;
    AnsiString.Length = (pStr->Length > (s_AnsiStringDataLength - 1))
                        ? (s_AnsiStringDataLength - 1)
                        : pStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR) pStr->Buffer,
                AnsiString.Buffer,
                AnsiString.Length,
                NULL);

    if (b)    {
        AnsiString.Buffer[ AnsiString.Length ] = '\0';
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\inc\rdpnp.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    rdpnp.h

Abstract:

    Type definitions for the Rdp Network Provider and Redirector Interface Protocols

Author 
    
    Joy Chik  2/1/200
    
Revision History:
--*/

#ifndef _RDPNP_
#define _RDPNP_

typedef struct _RDPDR_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    LONG   BufferOffset;
} RDPDR_UNICODE_STRING, *PRDPDR_UNICODE_STRING;

typedef struct _RDPDR_REQUEST_PACKET {

    ULONG Version;                      // Version of the request packet
#define RDPDR_REQUEST_PACKET_VERSION1   0x1

    ULONG SessionId;                    // Current Session Id
    
    union {
        
        struct {
            ULONG EntriesRead;          // Number of entries returned
            ULONG TotalEntries;         // Total entries available
            ULONG TotalBytesNeeded;     // Total bytes needed to read all entries
            ULONG ResumeHandle;         // Resume handle.
        } Get;                          // OUT

    } Parameters;

} RDPDR_REQUEST_PACKET, *PRDPDR_REQUEST_PACKET;

typedef struct _RDPDR_CONNECTION_INFO {

    RDPDR_UNICODE_STRING LocalName;           // Local name for the connection
    RDPDR_UNICODE_STRING RemoteName;          // Remote name for the connection
    DEVICE_TYPE SharedResourceType;     // Type of shared resource
    ULONG ConnectionStatus;             // Status of the connection
    ULONG NumberFilesOpen;              // Number of opened files
    ULONG ResumeKey;                    // Resume key for this entry.

}  RDPDR_CONNECTION_INFO, *PRDPDR_CONNECTION_INFO;

typedef struct _RDPDR_SHARE_INFO {
    
    RDPDR_UNICODE_STRING ShareName;           // Name of shared resource
    DEVICE_TYPE SharedResourceType;     // Type of shared resource
    ULONG ResumeKey;                    // Resume key for this entry.
    
}  RDPDR_SHARE_INFO, *PRDPDR_SHARE_INFO;

typedef struct _RDPDR_SERVER_INFO {
    
    RDPDR_UNICODE_STRING ServerName;          // Name of shared resource
    ULONG ResumeKey;                    // Resume key for this entry.
    
}  RDPDR_SERVER_INFO, *PRDPDR_SERVER_INFO;

#endif // _RDPNP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\channel.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :
    
    channel.h

Abstract:

Revision History:
--*/
#pragma once

class VirtualChannel : public RefCount
{
private:
    ULONG   _LowPrioChannelWriteFlags;            
    HANDLE  _Channel;       // NT handle for the channel
    PFILE_OBJECT _ChannelFileObject;     // the fileobject for the channel
    PDEVICE_OBJECT _ChannelDeviceObject; // the deviceobject for the channel
    KernelResource _HandleLock;
    PKEVENT _DeletionEvent;
    
    NTSTATUS CreateTermDD(HANDLE *Channel, HANDLE hIca, ULONG SessionID, 
            ULONG ChannelId);

    NTSTATUS SubmitIo(IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL, 
            IN PVOID Context, OUT PVOID Buffer, IN ULONG Length, 
            ULONG IoOperation, BOOL bWorkerItem, BOOL LowPrioWrite);

    static VOID IoWorker(PDEVICE_OBJECT DeviceObject, PVOID Context);
    
    NTSTATUS Io(
        IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
        IN PVOID Context,
        OUT PVOID Buffer,
        IN ULONG Length,
        ULONG IoOperation,
        BOOL LowPrioWrite
        );

    static VOID CloseWorker(PDEVICE_OBJECT DeviceObject, PVOID Context);
    NTSTATUS Close();

public:
    VirtualChannel();
    virtual ~VirtualChannel();

    BOOL Create(HANDLE hIca, ULONG SessionID, ULONG ChannelId,
        PKEVENT DeletionEvent);

    NTSTATUS Read(IN PIO_COMPLETION_ROUTINE ReadRoutine OPTIONAL, 
            IN PVOID Context, OUT PVOID Buffer, IN ULONG Length, IN BOOL bWorkerItem);

    NTSTATUS Write(IN PIO_COMPLETION_ROUTINE WriteRoutine OPTIONAL, 
            IN PVOID Context, OUT PVOID Buffer, IN ULONG Length, IN BOOL bWorkerItem,
            BOOL LowPrioWrite);

    NTSTATUS SubmitClose();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\channel.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    Channel.cpp

Abstract:

    This module implements a thin wrapper on the Read and Write routines so
    we can issue Read/Write Irps to termdd.
    
Environment:

    Kernel mode

--*/
#include "precomp.hxx"
#define TRC_FILE "channel"
#include "trc.h"

#include <winsta.h>
#include <ntddvdeo.h>
#include <icadd.h>
#include "TSQPublic.h"

//
// RDPDr.cpp : The TS Worker Queue pointer
//
extern PVOID RDPDR_TsQueue;


typedef struct tagCHANNELIOCONTEXT {
    SmartPtr<VirtualChannel> Channel;
    PIO_COMPLETION_ROUTINE CompletionRoutine;
    PVOID Context;
    PVOID Buffer;
    ULONG Length;
    ULONG IoOperation;
    BOOL LowPrioSend;
} CHANNELIOCONTEXT, *PCHANNELIOCONTEXT;

typedef struct tagCHANNELCLOSECONTEXT {
    SmartPtr<VirtualChannel> Channel;
} CHANNELCLOSECONTEXT, *PCHANNELCLOSECONTEXT;

VirtualChannel::VirtualChannel()
{
    BEGIN_FN("VirtualChannel::VirtualChannel");
    SetClassName("VirtualChannel");
    _Channel = NULL;
    _ChannelFileObject = NULL;
    _ChannelDeviceObject = NULL;
    _DeletionEvent = NULL;    
    _LowPrioChannelWriteFlags = 0;
    _LowPrioChannelWriteFlags |= CHANNEL_WRITE_LOWPRIO;
}

VirtualChannel::~VirtualChannel()
{
    BEGIN_FN("VirtualChannel::~VirtualChannel");

    if (_DeletionEvent != NULL) {
        KeSetEvent(_DeletionEvent, IO_NO_INCREMENT, FALSE);
    }
}

BOOL VirtualChannel::Create(HANDLE hIca, ULONG SessionID, ULONG ChannelId,
        PKEVENT DeletionEvent)
/*++

Routine Description:

    Opens the virtual channel and make it a kernel handle

Arguments:

    Channel - A pointer to a location to store the Channel pointer
    hIca - Required context for opening a channel
    SessionId - The session for the channel
    ChannelId - The Id of the RdpDr channel

Return Value:

    a valid NTSTATUS code.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_HANDLE_INFORMATION HandleInformation;

    BEGIN_FN("VirtualChannel::Create");

    ASSERT(_DeletionEvent == NULL);
    _DeletionEvent = DeletionEvent;
    
    //
    // Get the channel open
    //
    Status = CreateTermDD(&_Channel, hIca, SessionID, ChannelId);
    
    if (NT_SUCCESS(Status)) {
    
        //
        // Get the file object from the handle
        // 
        
        Status = ObReferenceObjectByHandle(_Channel, 
                STANDARD_RIGHTS_REQUIRED, NULL, KernelMode, (PVOID *)(&_ChannelFileObject), 
                &HandleInformation);
    }

    if (NT_SUCCESS(Status)) {

        TRC_DBG((TB, "ObReferenced channel"));
        
        _ChannelDeviceObject = IoGetRelatedDeviceObject((PFILE_OBJECT)_ChannelFileObject);               
    }
    else {
        TRC_ERR((TB, "Failed to open channel"));

        if (_Channel != NULL) {
            ZwClose(_Channel);
            _Channel = NULL;
        }
    }

    if (NT_SUCCESS(Status)) {
        return TRUE;
    } else {
        if (_DeletionEvent) {
            KeSetEvent(_DeletionEvent, IO_NO_INCREMENT, FALSE);
        }
        return FALSE;
    }
}

NTSTATUS VirtualChannel::Read(
    IN PIO_COMPLETION_ROUTINE ReadRoutine OPTIONAL,
    IN PVOID Context,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOL bWorkerItem
    )
/*++

Routine Description:

    Reads data from the virtual channel for the specified Client

Arguments:

    ReadRoutine - Completetion routine
    Context - Data to pass to the completion routine
    Buffer - Data to transfer
    Length - Size of data to transfer

Return Value:

    a valid NTSTATUS code.

Notes:

--*/
{
    NTSTATUS Status;
    BEGIN_FN("VirtualChannel::Read");

#if DBG
    SmartPtr<DrSession> Session = (DrSession *)Context;
    //ASSERT(InterlockedIncrement(&(Session->_ApcCount)) == 1);
    InterlockedIncrement(&(Session->_ApcCount));
    InterlockedIncrement(&(Session->_ApcChannelRef));
#endif

    Status = SubmitIo(ReadRoutine, Context, Buffer, Length, IRP_MJ_READ, bWorkerItem, FALSE);

#if DBG
    if (!NT_SUCCESS(Status)) {
        //ASSERT(InterlockedDecrement(&(Session->_ApcCount)) == 0);                    
        //ASSERT(InterlockedDecrement(&(Session->_ApcChannelRef)) == 0);
        InterlockedDecrement(&(Session->_ApcCount));
        InterlockedDecrement(&(Session->_ApcChannelRef));
    }
#endif

    return Status;
}

NTSTATUS VirtualChannel::Write(
    IN PIO_COMPLETION_ROUTINE WriteRoutine OPTIONAL,
    IN PVOID Context,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOL bWorkerItem,
    IN BOOL LowPrioSend
    )
/*++

Routine Description:

    Writes data to the virtual channel for the specified Client

Arguments:

    WriteRoutine - Completetion routine
    Context - Data to pass to the completion routine
    Buffer - Data to transfer
    Length - Size of data to transfer
    LowPrioSend - Indicate that the channel write should be at
     lower priority than other client destined data.

Return Value:

    a valid NTSTATUS code.

Notes:

--*/
{
    BEGIN_FN("VirtualChannel::Write");
    return SubmitIo(WriteRoutine, Context, Buffer, Length, IRP_MJ_WRITE, 
                bWorkerItem, LowPrioSend);
}

NTSTATUS VirtualChannel::SubmitIo(
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
    IN PVOID Context,
    OUT PVOID Buffer,
    IN ULONG Length,
    ULONG IoOperation,
    BOOL bWorkerItem,
    BOOL LowPrioSend
    )
{
    PCHANNELIOCONTEXT pChannelIoContext;
    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;

    BEGIN_FN("VirtualChannel::SubmitIo");
    
    TRC_ASSERT((IoOperation == IRP_MJ_READ) || 
            (IoOperation == IRP_MJ_WRITE), (TB, "Bad ChannelIo operation"));

    if (bWorkerItem) {
        //
        // Move this operation to a system thread
        //

        TRC_NRM((TB, "DrChannelIo: queueing the I/O to a system thread"));

        pChannelIoContext = new (NonPagedPool) CHANNELIOCONTEXT;

        if (pChannelIoContext != NULL) {
            pChannelIoContext->Channel = this;
            pChannelIoContext->CompletionRoutine = CompletionRoutine;
            pChannelIoContext->Context = Context;
            pChannelIoContext->Buffer = Buffer;
            pChannelIoContext->Length = Length;
            pChannelIoContext->IoOperation = IoOperation;
            pChannelIoContext->LowPrioSend = LowPrioSend;
            //
            // Use our own TS worker queue
            // 
            Status = TSAddWorkItemToQueue(RDPDR_TsQueue, 
                                          pChannelIoContext, 
                                          IoWorker);

            if (Status == STATUS_SUCCESS) {
                Status = STATUS_PENDING;
                goto EXIT;
            }
            else {
                //
                // Ts Queue failed
                //
                TRC_ERR((TB, "RDPDR: FAILED Adding workitem to TS Queue 0x%8x", Status));
                delete pChannelIoContext;
            }
        }
        
        if (IoOperation == IRP_MJ_WRITE) {
            PIO_STATUS_BLOCK pIoStatusBlock = (PIO_STATUS_BLOCK)Context;
            pIoStatusBlock->Status = Status;
            pIoStatusBlock->Information = 0;

            CompletionRoutine(NULL, NULL, Context); 
        }
        else {
            // No read should go through here for now
            ASSERT(FALSE);
        }
        
    }
    else {
        Status = Io(CompletionRoutine,
                    Context, 
                    Buffer, 
                    Length, 
                    IoOperation,
                    LowPrioSend);
    }

EXIT:
    return Status;
}

VOID VirtualChannel::IoWorker(PDEVICE_OBJECT DeviceObject, PVOID Context)
/*++

Routine Description:

    Reads data from the virtual channel for the specified Client, and 
    signals the thread wanted it done

Arguments:

    ClientEntry - The client with which to communicate
    ApcRoutine - Completetion routine
    ApcContext - Data to pass to the completion routine
    IoStatusBlock - Place to store result code
    Buffer - Data to transfer
    Length - Size of data to transfer
    ByteOffset - Offset into Buffer
    IoOperation - Read or Write
    Event - Event to signal when done
    Status - Result code

Return Value:

    None

Notes:

--*/
{
    NTSTATUS Status;
    PCHANNELIOCONTEXT ChannelIoContext = (PCHANNELIOCONTEXT)Context;
    
    BEGIN_FN_STATIC("VirtualChannel::IoWorker");
    ASSERT(ChannelIoContext != NULL);
    UNREFERENCED_PARAMETER(DeviceObject);

#if DBG
    SmartPtr<DrSession> Session;
    
    if (ChannelIoContext->IoOperation == IRP_MJ_READ) {
        Session = (DrSession *)(ChannelIoContext->Context);
        ASSERT(Session->GetBuffer() == ChannelIoContext->Buffer);
    }
#endif

    Status = ChannelIoContext->Channel->Io(
            ChannelIoContext->CompletionRoutine,
            ChannelIoContext->Context, 
            ChannelIoContext->Buffer, 
            ChannelIoContext->Length, 
            ChannelIoContext->IoOperation,
            ChannelIoContext->LowPrioSend);


    //
    // Now delete the context
    //
    delete ChannelIoContext;
}

NTSTATUS VirtualChannel::Io(
    IN PIO_COMPLETION_ROUTINE CompletionRoutine OPTIONAL,
    IN PVOID Context,
    OUT PVOID Buffer,     
    IN ULONG Length,
    ULONG IoOperation,
    BOOL LowPrioSend
    )
/*++

Routine Description:

    Reads/Writes data from/to the virtual channel for the specified Client

Arguments:

    CompletionRoutine - Completetion routine
    Context - Data to pass to the completion routine
    Buffer - Data to transfer
    Length - Size of data to transfer
    IoOperation - Read or Write

Return Value:

    a valid NTSTATUS code.

Notes:

--*/
{
    NTSTATUS Status;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    LARGE_INTEGER StartOffset;
    IO_STATUS_BLOCK IoStatusBlock;

    BEGIN_FN("VirtualChannel::SubmitIo");

    SharedLock sl(_HandleLock);
    
    if (_Channel != NULL) {
        //
        //  Build a read/write irp
        //
        StartOffset.QuadPart = 0;
        Irp = IoBuildAsynchronousFsdRequest(IoOperation, _ChannelDeviceObject, Buffer, Length, 
                &StartOffset, &IoStatusBlock);

        if (Irp) {
            //
            //  Setup the fileobject parameter
            //
            IrpSp = IoGetNextIrpStackLocation(Irp);
            IrpSp->FileObject = _ChannelFileObject;

            Irp->Tail.Overlay.Thread = NULL;

            //
            //  Set for low prio write, if specified.
            //
            if (!LowPrioSend) {
                Irp->Tail.Overlay.DriverContext[0] = NULL;
            }
            else {
                Irp->Tail.Overlay.DriverContext[0] = &_LowPrioChannelWriteFlags;
            }
    
            //
            //  Setup the completion routine
            //
            IoSetCompletionRoutine(Irp, CompletionRoutine, Context, TRUE, TRUE, TRUE);
        
            //
            //  Send the Irp to Termdd
            //
            Status = IoCallDriver(_ChannelDeviceObject, Irp);

            goto EXIT;            
        }
        else {
            Status = STATUS_NO_MEMORY;
        }
    }
    else {
        Status = STATUS_DEVICE_NOT_CONNECTED;
    }    

    if (IoOperation == IRP_MJ_WRITE) {
        PIO_STATUS_BLOCK pIoStatusBlock = (PIO_STATUS_BLOCK)Context;
        pIoStatusBlock->Status = Status;
        pIoStatusBlock->Information = 0;
        CompletionRoutine(NULL, NULL, Context); 

        // read completion is not called this way.
    }
    
EXIT:
    return Status;
}

NTSTATUS VirtualChannel::CreateTermDD(HANDLE *Channel, HANDLE hIca,
        ULONG SessionID, ULONG ChannelId)
/*++

Routine Description:

    Opens a virtual channel based on the supplied context

Arguments:

    Channel - A pointer to a location to store the Channel pointer
    hIca - Required context for opening a channel
    SessionId - The session for the channel
    ChannelId - The Id of the RdpDr channel

Return Value:

    NTSTATUS code

Notes:

--*/
{
    NTSTATUS Status;
    HANDLE hChannel = NULL;
    WCHAR ChannelNameBuffer[MAX_PATH];
    UNICODE_STRING ChannelName;
    UNICODE_STRING Number;
    OBJECT_ATTRIBUTES ChannelAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    PFILE_FULL_EA_INFORMATION pEa = NULL;
    ICA_OPEN_PACKET UNALIGNED * pIcaOpenPacket;
    ULONG cbEa = sizeof( FILE_FULL_EA_INFORMATION )
            + ICA_OPEN_PACKET_NAME_LENGTH
            + sizeof( ICA_OPEN_PACKET ); 

    BEGIN_FN("VirtualChannel::CreateTermDD");

    //
    // Kernel-mode applications open a virtual channel using ZwCreateFile on 
    // \Device\ICA\sss\Virtualvvv , where
    //
    //       sss is the logon session ID 
    //       vvv is the virtual channel number.
    //

    ChannelName.Buffer = ChannelNameBuffer;
    ChannelName.Length = 0;
    ChannelName.MaximumLength = sizeof(ChannelNameBuffer);

    Status = RtlAppendUnicodeToString(&ChannelName, L"\\Device\\Termdd\\");

    TRC_ASSERT(NT_SUCCESS(Status), (TB, "Creating channel path"));

    //
    // Create and append on the sessionID string
    //

    // Point another UNICODE_STRING to the next part of the buffer
    Number.Buffer = (PWCHAR)(((PBYTE)ChannelName.Buffer) + ChannelName.Length);
    Number.Length = 0;
    Number.MaximumLength = ChannelName.MaximumLength - ChannelName.Length;

    // Use that string to put the characters in the right place
    Status = RtlIntegerToUnicodeString(SessionID, 10, &Number);
    TRC_ASSERT(NT_SUCCESS(Status), (TB, "Creating channel path"));

    // Add the length of that string to the real string
    ChannelName.Length += Number.Length;

    //
    // Append the next part of the channel path
    // 
    Status = RtlAppendUnicodeToString(&ChannelName, L"\\Virtual");
    TRC_ASSERT(NT_SUCCESS(Status), (TB, "Creating channel path"));

    //
    // Create and append the channelID string
    //

    // Point another UNICODE_STRING to the next part of the buffer
    Number.Buffer = (PWCHAR)(((PBYTE)ChannelName.Buffer) + ChannelName.Length);
    Number.Length = 0;
    Number.MaximumLength = ChannelName.MaximumLength - ChannelName.Length;

    // Use that string to put the characters in the right place
    Status = RtlIntegerToUnicodeString(ChannelId, 10, &Number);
    TRC_ASSERT(NT_SUCCESS(Status), (TB, "Creating channel path"));

    // Add the length of that string to the real string
    ChannelName.Length += Number.Length;

    //
    // Actually open the channel
    // 
    InitializeObjectAttributes(&ChannelAttributes, 
                               &ChannelName, 
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL, 
                               NULL);

    //
    // Pass in a cool EaBuffer thing so this will really work
    // I basically lifted this code from private\tsext\icaapi\stack.c
    // It's supposed to be a temporary measure
    // 

    /*
     * Allocate some memory for the EA buffer
     */
    pEa = (PFILE_FULL_EA_INFORMATION)new BYTE[cbEa]; 
    if (pEa != NULL) {
        /*
         * Initialize the EA buffer
         */
        pEa->NextEntryOffset = 0;
        pEa->Flags           = 0;
        pEa->EaNameLength    = ICA_OPEN_PACKET_NAME_LENGTH;
        RtlCopyMemory(pEa->EaName, ICAOPENPACKET, ICA_OPEN_PACKET_NAME_LENGTH + 1 );
        pEa->EaValueLength   = sizeof( ICA_OPEN_PACKET );
        pIcaOpenPacket       = (ICA_OPEN_PACKET UNALIGNED *)(pEa->EaName +
                                                              pEa->EaNameLength + 1);

        /*
         * Now put the open packet parameters into the EA buffer
         */
        pIcaOpenPacket->IcaHandle = hIca;
        pIcaOpenPacket->OpenType  = IcaOpen_Channel;
        pIcaOpenPacket->TypeInfo.ChannelClass = Channel_Virtual;
        RtlCopyMemory(pIcaOpenPacket->TypeInfo.VirtualName, DR_CHANNEL_NAME, 
                sizeof(DR_CHANNEL_NAME));

        //
        // We keep this next line without "pEa, cbEa"
        //

        Status = ZwCreateFile(&hChannel, GENERIC_READ | GENERIC_WRITE, 
            &ChannelAttributes, &IoStatusBlock, 0, FILE_ATTRIBUTE_NORMAL, 0, 
            FILE_OPEN_IF, FILE_SEQUENTIAL_ONLY, pEa, cbEa);

        delete pEa;

    } else {
        TRC_ERR((TB, "Unable to allocate EaBuffer for ZwCreateFile(channel)"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(Status)) {
        *Channel = hChannel;
    }

    return Status;
}

void VirtualChannel::CloseWorker(PDEVICE_OBJECT DeviceObject, PVOID Context)
/*++

Routine Description:

    Closes the virtual channel in a work item

Arguments:

    None

Return Value:

    NTSTATUS code from ZwClose.

Notes:

--*/

{
    PCHANNELCLOSECONTEXT ChannelCloseContext = (PCHANNELCLOSECONTEXT)Context;
    
    BEGIN_FN_STATIC("VirtualChannel::CloseWorker");
    ASSERT(ChannelCloseContext != NULL);
    UNREFERENCED_PARAMETER(DeviceObject);

    ChannelCloseContext->Channel->Close();
    

    //
    // Now delete the context
    //
    delete ChannelCloseContext;
}

NTSTATUS VirtualChannel::Close()
/*++

Routine Description:

    Closes the virtual channel

Arguments:

    None

Return Value:

    NTSTATUS code from ZwClose.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    BEGIN_FN("VirtualChannel::Close");

    ExclusiveLock el(_HandleLock);

    ASSERT(_Channel != NULL);
    ASSERT(_ChannelFileObject != NULL);

    TRC_NRM((TB, "DrChannelClose: Close the channel"));
    _ChannelDeviceObject = NULL;
    ObDereferenceObject(_ChannelFileObject);
    _ChannelFileObject = NULL;
    ZwClose(_Channel);
    _Channel = NULL;

    return Status;
}

NTSTATUS VirtualChannel::SubmitClose()
/*++

Routine Description:

    Post a close virtual channel request to a worker item

Arguments:

    None

Return Value:

    NTSTATUS code from ZwClose.

Notes:

--*/

{
    PCHANNELCLOSECONTEXT pChannelCloseContext;
    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;

    BEGIN_FN("VirtualChannel::SubmitClose");
    
    //
    // Move this operation to a system thread
    //

    TRC_NRM((TB, "DrChannelClose: queueing the I/O to a system thread"));

    pChannelCloseContext = new (NonPagedPool) CHANNELCLOSECONTEXT;

    if (pChannelCloseContext != NULL) {
        pChannelCloseContext->Channel = this;
        //
        // Use our own TS worker queue
        // 
        Status = TSAddWorkItemToQueue(RDPDR_TsQueue, 
                                      pChannelCloseContext, 
                                      CloseWorker);

        if( Status == STATUS_SUCCESS) {
            Status = STATUS_PENDING;
        }
        else {
            //
            // Ts Queue failed
            //
            TRC_ERR((TB, "RDPDR: FAILED Adding workitem to TS Queue 0x%8x", Status));
            delete pChannelCloseContext;
        }
    }
        
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\device.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    device.cpp

Abstract:

    Device object handles one redirected device

Revision History:
--*/

#include "precomp.hxx"
#define TRC_FILE "device"
#include "trc.h"

#if DBG
extern UCHAR IrpNames[IRP_MJ_MAXIMUM_FUNCTION + 1][40];
#endif // DBG

DrDevice::DrDevice(SmartPtr<DrSession> &Session, ULONG DeviceType, ULONG DeviceId, PUCHAR PreferredDosName)
{
    unsigned len;

    BEGIN_FN("DrDevice::DrDevice");
    
    ASSERT(Session != NULL);
    ASSERT(PreferredDosName != NULL);

    TRC_NRM((TB, "Create Device (%p, session: %p, type: %d, id: %d, dosname: %s",
             this, Session, DeviceType, DeviceId, PreferredDosName));

    SetClassName("DrDevice");
    _Session = Session;
    _DeviceType = DeviceType;
    _DeviceId = DeviceId;
    _DeviceStatus = dsAvailable;

#if DBG
    _VNetRootFinalized = FALSE; 
    _VNetRoot = NULL;
#endif

    RtlCopyMemory(_PreferredDosName, PreferredDosName, 
        PREFERRED_DOS_NAME_SIZE);

    //
    // Review: We don't want to redirect any device name willy nilly,
    // as I think that would be a security issue given a bad client
    //

    _PreferredDosName[PREFERRED_DOS_NAME_SIZE - 1] = 0;

    //
    //  We don't want colon for end of DosName 
    //
    len = strlen((CHAR*)_PreferredDosName);
    if (len && _PreferredDosName[len-1] == ':') {
        _PreferredDosName[len-1] = '\0';
    }
}

DrDevice::~DrDevice()
{
    
    BEGIN_FN("DrDevice::~DrDevice");

#if DBG
    if (_VNetRoot != NULL && _VNetRootFinalized != TRUE) {
        ASSERT(FALSE);
    }
#endif

    TRC_NRM((TB, "Delete Device %p for Session %p", this, _Session));    
}

BOOL DrDevice::ShouldCreateDevice()
{
    BEGIN_FN("DrDevice::ShouldCreateDevice");

    //
    //  Default is to create the device
    //
    return TRUE;
}

NTSTATUS DrDevice::Initialize(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg, ULONG Length)
{
    BEGIN_FN("DrDevice::Initialize");

    // Can't assume devAnnouceMsg is not NULL, need to check if uses it
    // ASSERT(devAnnounceMsg != NULL);

    return STATUS_SUCCESS;
}

VOID DrDevice::CreateReferenceString(
    IN OUT PUNICODE_STRING refString)
/*++

Routine Description:

    Create the device reference string using information about the
    client device.  This string is in a form suitable for reparse
    on IRP_MJ_CREATE and redirection to the minirdr DO.

    The form of the resultant reference string is:
        \;<DriveLetter>:<sessionid>\clientname\preferredDosName
  
Arguments:

    DosDeviceName       -   Dos Device Name in UNICODE       
    refString           -   UNICODE structure large enough to hold
                            the entire resultant reference string.  This
                            works out to be DRMAXREFSTRINGLEN bytes.

Return Value:

    NONE

--*/
{
    NTSTATUS status;
    STRING string;
    WCHAR numericBuf[RDPDRMAXULONGSTRING+1] = L"\0";
    WCHAR ansiBuf[RDPDRMAXDOSNAMELEN+1] = L"\0";
    UNICODE_STRING ansiUnc;
    UNICODE_STRING numericUnc;
    ULONG sessionID = _Session->GetSessionId(); 
    PCSZ preferredDosName = (PCSZ)_PreferredDosName;
    
    BEGIN_FN("DrDevice::CreateReferenceString");
    ASSERT(refString != NULL);

    // Sanity check the preferred DOS name.
    TRC_ASSERT(preferredDosName != NULL, (TB, "Invalid DOS device name."));

    // Make sure the reference string buf is big enough.
    TRC_ASSERT(refString->MaximumLength >= (RDPDRMAXREFSTRINGLEN * sizeof(WCHAR)),
              (TB, "Reference string buffer too small."));

    // Zero it out.
    refString->Length = 0;
    refString->Buffer[0] = L'\0';

    // Add a '\;'
    RtlAppendUnicodeToString(refString, L"\\;");
    
    // Initialize the ansi conversion buf.
    ansiUnc.Length = 0;
    ansiUnc.MaximumLength = RDPDRMAXDOSNAMELEN * sizeof(WCHAR);
    ansiUnc.Buffer = ansiBuf;

    // Add the preferred dos name.
    RtlInitAnsiString(&string, preferredDosName);
    RtlAnsiStringToUnicodeString(&ansiUnc, &string, FALSE);
    RtlAppendUnicodeStringToString(refString, &ansiUnc);

    // Add a ':'
    RtlAppendUnicodeToString(refString, L":");

    // Initialize the numeric buf.
    numericUnc.Length           = 0;
    numericUnc.MaximumLength    = RDPDRMAXULONGSTRING * sizeof(WCHAR);
    numericUnc.Buffer           = numericBuf;

    // Add the session ID in base 10.
    RtlIntegerToUnicodeString(sessionID, 10, &numericUnc);
    RtlAppendUnicodeStringToString(refString, &numericUnc);
    
    // Add the '\'
    RtlAppendUnicodeToString(refString, L"\\");

    // Add Client name
#if 0
    RtlAppendUnicodeToString(refString, _Session->GetClientName());
#endif
    RtlAppendUnicodeToString(refString, DRUNCSERVERNAME_U);

    // Add a '\'
    RtlAppendUnicodeToString(refString, L"\\");

    // Add the preferred dos name.
    RtlAppendUnicodeStringToString(refString, &ansiUnc);

    TRC_NRM((TB, "Reference string = %wZ", refString));
}

NTSTATUS DrDevice::CreateDevicePath(PUNICODE_STRING DevicePath)
/*++
    Create NT DeviceName compatible with RDBSS convention
    
    Format is:
        \device\rdpdr\;<DriveLetter>:<sessionid>\ClientName\DosDeviceName
    
--*/
{
    NTSTATUS Status;
    UNICODE_STRING DevicePathTail;
    
    BEGIN_FN("DrDevice::CreateDevicePath");
    ASSERT(DevicePath != NULL);

    DevicePath->Length = 0;
    Status = RtlAppendUnicodeToString(DevicePath, RDPDR_DEVICE_NAME_U);

    if (!NT_ERROR(Status)) {
        // Add the reference string to the end:
        // Format is: \;<DriveLetter>:<sessionid>\clientName\share
        DevicePathTail.Length = 0;
        DevicePathTail.MaximumLength = DevicePath->MaximumLength - DevicePath->Length;
        DevicePathTail.Buffer = DevicePath->Buffer + (DevicePath->Length / sizeof(WCHAR));

        CreateReferenceString(&DevicePathTail);

        DevicePath->Length += DevicePathTail.Length;
    }

    TRC_NRM((TB, "DevicePath=%wZ", DevicePath));

    return Status;
}

NTSTATUS DrDevice::CreateDosDevicePath(PUNICODE_STRING DosDevicePath, 
                                       PUNICODE_STRING DosDeviceName)
{
    NTSTATUS Status;
    UNICODE_STRING linkNameTail;

    BEGIN_FN("DrDevice::CreateDosDevicePath");
    ASSERT(DosDevicePath != NULL);
    ASSERT(DosDeviceName != NULL);
    
    //
    // Create the "\\Sessions\\<sessionId>\\DosDevices\\<DosDeviceName>" string
    //
    DosDevicePath->Length = 0;
    Status = RtlAppendUnicodeToString(DosDevicePath, L"\\Sessions\\");

    if (!NT_ERROR(Status)) {
        //
        // Append the Session Number
        //
        linkNameTail.Buffer = (PWSTR)(((PBYTE)DosDevicePath->Buffer) + 
                DosDevicePath->Length);
        linkNameTail.Length = 0;
        linkNameTail.MaximumLength = DosDevicePath->MaximumLength - 
                DosDevicePath->Length;
        Status = RtlIntegerToUnicodeString(_Session->GetSessionId(), 10, &linkNameTail);
    }

    if (!NT_ERROR(Status)) {
        DosDevicePath->Length += linkNameTail.Length;

        //
        // Append DosDevices
        //
       Status = RtlAppendUnicodeToString(DosDevicePath, L"\\DosDevices\\");
    }

    if (!NT_ERROR(Status)) {
        Status = RtlAppendUnicodeStringToString(DosDevicePath, DosDeviceName);
        TRC_NRM((TB, "Created DosDevicePath: %wZ", DosDevicePath));
    }
    
    TRC_NRM((TB, "DosDevicePath=%wZ", DosDevicePath));
    
    return Status;
}

NTSTATUS DrDevice::CreateDosSymbolicLink(PUNICODE_STRING DosDeviceName)
{
    WCHAR NtDevicePathBuffer[RDPDRMAXNTDEVICENAMEGLEN];
    UNICODE_STRING NtDevicePath;
    WCHAR DosDevicePathBuffer[MAX_PATH];
    UNICODE_STRING DosDevicePath;
    NTSTATUS Status;

    BEGIN_FN("DrDevice::CreateDosSymbolicLink");
    ASSERT(DosDeviceName != NULL);

    NtDevicePath.MaximumLength = sizeof(NtDevicePathBuffer);
    NtDevicePath.Length = 0;
    NtDevicePath.Buffer = &NtDevicePathBuffer[0];

    DosDevicePath.MaximumLength = sizeof(DosDevicePathBuffer);
    DosDevicePath.Length = 0;
    DosDevicePath.Buffer = &DosDevicePathBuffer[0];

    //
    // Get the NT device path to this dr device
    //

    Status = CreateDevicePath(&NtDevicePath);
    TRC_NRM((TB, "Nt Device path: %wZ", &NtDevicePath));

    if (!NT_ERROR(Status)) {

        //
        // Build the dos device path for this session
        //

        Status = CreateDosDevicePath(&DosDevicePath, DosDeviceName);
        TRC_NRM((TB, "Dos Device path: %wZ", &DosDevicePath));
    } else {
        TRC_ERR((TB, "Can't create nt device path: 0x%08lx", Status));
        return Status;
    }

    if (!NT_ERROR(Status)) {
                            
        //
        // Actually create the symbolic link
        //

         IoDeleteSymbolicLink(&DosDevicePath);
         Status = IoCreateSymbolicLink(&DosDevicePath, &NtDevicePath);

        if (NT_SUCCESS(Status)) {
            TRC_NRM((TB, "Successfully created Symbolic link"));
        }
        else {
            TRC_NRM((TB, "Failed to create Symbolic link %x", Status));
        }
    } else {
        TRC_ERR((TB, "Can't create dos device path: 0x%08lx", Status));
        return Status;
    }

    return Status;
}

NTSTATUS DrDevice::VerifyCreateSecurity(PRX_CONTEXT RxContext, ULONG CurrentSessionId)
{
    NTSTATUS Status;
    ULONG irpSessionId;

    BEGIN_FN("DrDevice::VerifyCreateSecurity");
    
    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_CREATE);

    Status = IoGetRequestorSessionId(RxContext->CurrentIrp, &irpSessionId);
    if (NT_SUCCESS(Status)) {
        
        if (irpSessionId == CurrentSessionId) {
            TRC_DBG((TB, "Access accepted in DrCreate."));
            return STATUS_SUCCESS;
        }
        //
        //  If the request is from the console session, it needs to be from a system 
        //  process.
        //
        else if (irpSessionId == CONSOLE_SESSIONID) {
            TRC_NRM((TB, "Create request from console process."));

            if (!DrIsSystemProcessRequest(RxContext->CurrentIrp, 
                                        RxContext->CurrentIrpSp)) {
                TRC_ALT((TB, "Create request not from system process."));
                return STATUS_ACCESS_DENIED;
            }
            else {
                TRC_NRM((TB, "Create request from system.  Access accepted."));
                return STATUS_SUCCESS;
            }
        }

        //
        //  If not from the console and doesn't match the client entry session
        //  ID then deny access.
        //
        else {
            TRC_ALT((TB, "Create request from %ld mismatch with session %ld.",
                    irpSessionId, _Session->GetSessionId()));
            return STATUS_ACCESS_DENIED;
        }        
    }
    else {
        TRC_ERR((TB, "IoGetRequestorSessionId failed with %08X.", Status));
        return Status;
    }
}

VOID DrDevice::FinishCreate(PRX_CONTEXT RxContext)
{
    RxCaptureFcb;
    RX_FILE_TYPE StorageType;

    BEGIN_FN("DrDevice::FinishCreate");

    ULONG Attributes = 0;             // in the fcb this is DirentRxFlags;
    ULONG NumLinks = 0;               // in the fcb this is NumberOfLinks;
    LARGE_INTEGER CreationTime;   // these fields are the same as for the Fcb
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER LastChangeTime;
    LARGE_INTEGER AllocationSize; // common header fields
    LARGE_INTEGER FileSize;
    LARGE_INTEGER ValidDataLength;
    FCB_INIT_PACKET InitPacket = { &Attributes, &NumLinks, &CreationTime, 
            &LastAccessTime, &LastWriteTime, &LastChangeTime, 
            &AllocationSize, &FileSize, &ValidDataLength };

    ASSERT(RxContext != NULL);
    //
    // Pretty sure this is Device specific, but maybe caching the information
    // be generic? We might be able to fill in these values from member 
    // variables
    //

    CreationTime.QuadPart = 0;   
    LastAccessTime.QuadPart = 0;
    LastWriteTime.QuadPart = 0;
    LastChangeTime.QuadPart = 0;
    AllocationSize.QuadPart = 0;
    FileSize.QuadPart = 0x7FFFFFFF;  // These need to be non-zero for reads to occur
    ValidDataLength.QuadPart = 0x7FFFFFFF;
    
    StorageType = RxInferFileType(RxContext);

    if (StorageType == FileTypeNotYetKnown) {
        StorageType = FileTypeFile;
    }
    RxFinishFcbInitialization(capFcb, (RX_FILE_TYPE)RDBSS_STORAGE_NTC(StorageType), &InitPacket);
}

NTSTATUS DrDevice::Create(IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

    Opens a file (or device) across the network

Arguments:

    RxContext - Context for the operation

Return Value:

    Could return status success, cancelled, or pending.

--*/
{
    NTSTATUS Status;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = RxContext->Create.pNetRoot;
    SmartPtr<DrSession> Session = _Session;
    PRDPDR_IOREQUEST_PACKET pIoPacket;
    ULONG cbPacketSize;
    PUNICODE_STRING FileName = GET_ALREADY_PREFIXED_NAME(SrvOpen, capFcb);
    LARGE_INTEGER TimeOut;

    BEGIN_FN("DrDevice::Create");

    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_CREATE);

    if (!Session->IsConnected()) {
        TRC_ALT((TB, "Tried to open client device while not "
                "connected. State: %ld", Session->GetState()));
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    
    //
    //  Security check the irp.
    //
    Status = VerifyCreateSecurity(RxContext, Session->GetSessionId());

    if (NT_ERROR(Status)) {
        return Status;
    }

    //
    // We already have an exclusive lock on the fcb. Finish the create.
    //

    if (NT_SUCCESS(Status)) {
        //
        // JC: Worry about this when do buffering
        //
        SrvOpen->Flags |= SRVOPEN_FLAG_DONTUSE_WRITE_CACHING;
        SrvOpen->Flags |=  SRVOPEN_FLAG_DONTUSE_READ_CACHING;

        RxContext->pFobx = RxCreateNetFobx(RxContext, RxContext->pRelevantSrvOpen);

        if (RxContext->pFobx != NULL) {
            // Fobx keeps a reference to the device so it won't go away

            AddRef();
            RxContext->pFobx->Context = (DrDevice *)this;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(Status)) {
        //
        // Get the file name
        //
        // If the file name only has back slash at the end and rdbss didn't record it
        // we need to pass this to the client
        //
        if (GetDeviceType() == RDPDR_DTYP_FILESYSTEM && FlagOn(RxContext->Create.Flags, RX_CONTEXT_CREATE_FLAG_STRIPPED_TRAILING_BACKSLASH) &&
                FileName->Length == 0) {
            FileName->Buffer = L"\\";
            FileName->Length = FileName->MaximumLength = sizeof(WCHAR);            
        }
        
        TRC_DBG((TB, "Attempt to open = %wZ", FileName));

        //
        // Build the create packet and send it to the client
        // We add the string null terminator to the filename
        //
        if (FileName->Length) {
            //
            //  FileName Length does not include string null terminator.
            //
            cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) + FileName->Length + sizeof(WCHAR);
        }
        else {
            cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET);
        }

        pIoPacket = (PRDPDR_IOREQUEST_PACKET)new(PagedPool) BYTE[cbPacketSize];

        if (pIoPacket != NULL) {
            memset(pIoPacket, 0, cbPacketSize);

            pIoPacket->Header.Component = RDPDR_CTYP_CORE;
            pIoPacket->Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
            pIoPacket->IoRequest.DeviceId = _DeviceId;
            pIoPacket->IoRequest.MajorFunction = IRP_MJ_CREATE;
            pIoPacket->IoRequest.MinorFunction = 0;

            pIoPacket->IoRequest.Parameters.Create.DesiredAccess = 
                    RxContext->Create.NtCreateParameters.DesiredAccess;
            pIoPacket->IoRequest.Parameters.Create.AllocationSize = 
                    RxContext->Create.NtCreateParameters.AllocationSize;
            pIoPacket->IoRequest.Parameters.Create.FileAttributes = 
                    RxContext->Create.NtCreateParameters.FileAttributes;
            pIoPacket->IoRequest.Parameters.Create.ShareAccess = 
                    RxContext->Create.NtCreateParameters.ShareAccess;
            pIoPacket->IoRequest.Parameters.Create.Disposition = 
                    RxContext->Create.NtCreateParameters.Disposition;
            pIoPacket->IoRequest.Parameters.Create.CreateOptions = 
                    RxContext->Create.NtCreateParameters.CreateOptions;

            //
            // File name path
            //
            if (FileName->Length) {
                pIoPacket->IoRequest.Parameters.Create.PathLength = FileName->Length + sizeof(WCHAR);
                RtlCopyMemory(pIoPacket + 1, FileName->Buffer, FileName->Length);
                //
                //  Packet is already zero'd, so no need to null terminate the string
                //
            } else {
                pIoPacket->IoRequest.Parameters.Create.PathLength = 0;
            }

            TRC_NRM((TB, "Sending Create IoRequest"));
            TRC_NRM((TB, "    DesiredAccess:     %lx",
                     pIoPacket->IoRequest.Parameters.Create.DesiredAccess));
            TRC_NRM((TB, "    AllocationSize:    %lx",
                     pIoPacket->IoRequest.Parameters.Create.AllocationSize));
            TRC_NRM((TB, "    FileAttributes:    %lx",
                     pIoPacket->IoRequest.Parameters.Create.FileAttributes));
            TRC_NRM((TB, "    ShareAccess:       %lx",
                     pIoPacket->IoRequest.Parameters.Create.ShareAccess));
            TRC_NRM((TB, "    Disposition:       %lx",
                     pIoPacket->IoRequest.Parameters.Create.Disposition));
            TRC_NRM((TB, "    CreateOptions:     %lx", 
                     pIoPacket->IoRequest.Parameters.Create.CreateOptions));

            //
            // Always do create synchronously
            // 30 seconds in hundreds of nano-seconds, in case client hangs,
            // we don't want this create thread to wait infinitely.
            //
            TimeOut = RtlEnlargedIntegerMultiply( 300000, -1000 ); 
            Status = SendIoRequest(RxContext, pIoPacket, cbPacketSize, TRUE, &TimeOut);

            delete pIoPacket;
        }
        else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(Status)) {
        FinishCreate(RxContext);
    } 
    else {
        // Release the Device Reference
        if (RxContext->pFobx != NULL) {
            ((DrDevice *)RxContext->pFobx->Context)->Release();
            RxContext->pFobx->Context = NULL;
          
        }
    }
    return Status;
}
  
NTSTATUS DrDevice::Flush(IN OUT PRX_CONTEXT RxContext)
{
    BEGIN_FN("DrDevice::Flush");
    ASSERT(RxContext != NULL);
    return STATUS_SUCCESS;
}

NTSTATUS DrDevice::Write(IN OUT PRX_CONTEXT RxContext, IN BOOL LowPrioSend)
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    PRDPDR_IOREQUEST_PACKET pIoPacket;
    ULONG cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) + 
            RxContext->LowIoContext.ParamsFor.ReadWrite.ByteCount;
    PVOID pv;

    BEGIN_FN("DrDevice::Write");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_WRITE);
    
    if (!Session->IsConnected()) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to write to client device which is not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (RxContext->LowIoContext.ParamsFor.ReadWrite.ByteCount == 0) {
        RxContext->IoStatusBlock.Information = 0;
        return STATUS_SUCCESS;
    }

    pIoPacket = (PRDPDR_IOREQUEST_PACKET)new(PagedPool) BYTE[cbPacketSize];

    if (pIoPacket != NULL) {

        memset(pIoPacket, 0, cbPacketSize);

        pIoPacket->Header.Component = RDPDR_CTYP_CORE;
        pIoPacket->Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
        pIoPacket->IoRequest.DeviceId = _DeviceId;
        pIoPacket->IoRequest.FileId = FileObj->GetFileId();
        pIoPacket->IoRequest.MajorFunction = IRP_MJ_WRITE;
        pIoPacket->IoRequest.MinorFunction = 0;
        pIoPacket->IoRequest.Parameters.Write.Length = 
                RxContext->LowIoContext.ParamsFor.ReadWrite.ByteCount;
        //
        //  Get the low dword byte offset of where to write
        //
        pIoPacket->IoRequest.Parameters.Write.OffsetLow =
                ((LONG)((LONGLONG)(RxContext->LowIoContext.ParamsFor.ReadWrite.ByteOffset) 
                & 0xffffffff));
        //
        //  Get the high dword by offset of where to write
        //
        pIoPacket->IoRequest.Parameters.Write.OffsetHigh = 
                ((LONG)((LONGLONG)(RxContext->LowIoContext.ParamsFor.ReadWrite.ByteOffset) 
                >> 32));

        TRC_DBG((TB, "ByteOffset to write = %x", 
                RxContext->LowIoContext.ParamsFor.ReadWrite.ByteOffset));

        pv =  MmGetSystemAddressForMdlSafe(RxContext->LowIoContext.ParamsFor.ReadWrite.Buffer, 
                NormalPagePriority);

        if (pv != NULL) {
            RtlCopyMemory(pIoPacket + 1, pv, // + RxContext->LowIoContext.ParamsFor.ReadWrite.ByteOffset?, 
                    pIoPacket->IoRequest.Parameters.Write.Length);

            TRC_DBG((TB, "Write packet length: 0x%lx", 
                    pIoPacket->IoRequest.Parameters.Write.Length));

            Status = SendIoRequest(RxContext, pIoPacket, cbPacketSize, 
                    (BOOLEAN)!BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_ASYNC_OPERATION),
                    NULL, LowPrioSend);

            TRC_NRM((TB, "IoRequestWrite returned to DrWrite: %lx", Status));
        }
        else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        delete pIoPacket;

    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS DrDevice::Read(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    RDPDR_IOREQUEST_PACKET IoPacket;

    BEGIN_FN("DrDevice::Read");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(Session != NULL);
    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_READ);
    
    if (!Session->IsConnected()) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to read from client device which is not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    memset(&IoPacket, 0, sizeof(IoPacket));

    IoPacket.Header.Component = RDPDR_CTYP_CORE;
    IoPacket.Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
    IoPacket.IoRequest.DeviceId = _DeviceId;
    IoPacket.IoRequest.FileId = FileObj->GetFileId();
    IoPacket.IoRequest.MajorFunction = IRP_MJ_READ;
    IoPacket.IoRequest.MinorFunction = 0;
    IoPacket.IoRequest.Parameters.Read.Length = 
            RxContext->LowIoContext.ParamsFor.ReadWrite.ByteCount;

    //
    //  Get low dword of read offset
    //
    IoPacket.IoRequest.Parameters.Read.OffsetLow =
            ((LONG)((LONGLONG)(RxContext->LowIoContext.ParamsFor.ReadWrite.ByteOffset) 
            & 0xffffffff));
    //
    //  Get high dword of read offset
    //
    IoPacket.IoRequest.Parameters.Read.OffsetHigh = 
            ((LONG)((LONGLONG)(RxContext->LowIoContext.ParamsFor.ReadWrite.ByteOffset) 
            >> 32));

    TRC_NRM((TB, "DrRead reading length: %ld, at offset: %x", 
            IoPacket.IoRequest.Parameters.Read.Length,
            RxContext->LowIoContext.ParamsFor.ReadWrite.ByteOffset));

    Status = SendIoRequest(RxContext, &IoPacket, sizeof(IoPacket), 
            (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
    
    TRC_NRM((TB, "IoRequestWrite returned to DrRead: %lx", Status));

    return Status;
}

NTSTATUS DrDevice::IoControl(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    PRDPDR_IOREQUEST_PACKET pIoPacket = NULL;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) + 
            LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    ULONG IoControlCode = LowIoContext->ParamsFor.IoCtl.IoControlCode;
    ULONG InputBufferLength = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    ULONG OutputBufferLength = LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
    PVOID InputBuffer = LowIoContext->ParamsFor.IoCtl.pInputBuffer;
    PVOID OutputBuffer = LowIoContext->ParamsFor.IoCtl.pOutputBuffer;
    
    BEGIN_FN("DrDevice::IoControl");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(Session != NULL);
    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_DEVICE_CONTROL || 
            RxContext->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL ||
            RxContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL);
    
    if (COMPARE_VERSION(Session->GetClientVersion().Minor, 
            Session->GetClientVersion().Major, 4, 1) < 0) {
        TRC_ALT((TB, "Failing IoCtl for client that doesn't support it"));
        return STATUS_NOT_IMPLEMENTED;
    }

    if (!Session->IsConnected()) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to send IoControl to client device which is not "
                "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    //  Validate the buffer
    //
    
    __try {
        if (RxContext->CurrentIrp->RequestorMode != KernelMode) {
            // If the buffering method is METHOD_NEITHER or METHOD_IN_DIRECT
            // then we need to probe the input buffer
            if ((IoControlCode & 0x1) && 
                    InputBuffer != NULL && InputBufferLength != 0) {
                ProbeForRead(InputBuffer, InputBufferLength, sizeof(UCHAR));
            }
                     
            // If the buffering method is METHOD_NEITHER or METHOD_OUT_DIRECT
            // then we need to probe the output buffer
            if ((IoControlCode & 0x2) && 
                    OutputBuffer != NULL && OutputBufferLength != 0) {
                ProbeForWrite(OutputBuffer, OutputBufferLength, sizeof(UCHAR));
            }
        }

        pIoPacket = (PRDPDR_IOREQUEST_PACKET)new(PagedPool) BYTE[cbPacketSize];

        if (pIoPacket != NULL) {
            memset(pIoPacket, 0, cbPacketSize);
        
            //
            //  FS Control uses the same path as IO Control. 
            //
            pIoPacket->Header.Component = RDPDR_CTYP_CORE;
            pIoPacket->Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
            pIoPacket->IoRequest.DeviceId = _DeviceId;
            pIoPacket->IoRequest.FileId = FileObj->GetFileId();
            pIoPacket->IoRequest.MajorFunction = IRP_MJ_DEVICE_CONTROL;
            pIoPacket->IoRequest.MinorFunction = 
                    LowIoContext->ParamsFor.IoCtl.MinorFunction;
            pIoPacket->IoRequest.Parameters.DeviceIoControl.OutputBufferLength =
                    LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
            pIoPacket->IoRequest.Parameters.DeviceIoControl.InputBufferLength =
                    LowIoContext->ParamsFor.IoCtl.InputBufferLength;
            pIoPacket->IoRequest.Parameters.DeviceIoControl.IoControlCode =
                    LowIoContext->ParamsFor.IoCtl.IoControlCode;
        
            if (LowIoContext->ParamsFor.IoCtl.InputBufferLength != 0) {
        
                TRC_NRM((TB, "DrIoControl inputbufferlength: %lx", 
                        LowIoContext->ParamsFor.IoCtl.InputBufferLength));
        
                RtlCopyMemory(pIoPacket + 1, LowIoContext->ParamsFor.IoCtl.pInputBuffer,  
                        LowIoContext->ParamsFor.IoCtl.InputBufferLength);
            } else {
                TRC_NRM((TB, "DrIoControl with no inputbuffer"));
            }
        
            Status = SendIoRequest(RxContext, pIoPacket, cbPacketSize, 
                    (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
            TRC_NRM((TB, "IoRequestWrite returned to DrIoControl: %lx", Status));
            delete pIoPacket;
        } else {
            TRC_ERR((TB, "DrIoControl unable to allocate packet: %lx", Status));
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        
        return Status;
            
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) {
        TRC_ERR((TB, "Invalid buffer parameter(s)"));

        if (pIoPacket) {
            delete pIoPacket;
        }

        return STATUS_INVALID_PARAMETER;
    }
}

NTSTATUS DrDevice::Close(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    RDPDR_IOREQUEST_PACKET IoPacket;

    BEGIN_FN("DrDevice::Close");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(Session != NULL);
    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_CLOSE);
    
    if (!Session->IsConnected()) {
        // Review: Since we're not connected, there shouldn't be any reason
        // to say it isn't closed, right?
        return STATUS_SUCCESS;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to close a client device which is not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_SUCCESS;
    }

    memset(&IoPacket, 0, sizeof(IoPacket));

    IoPacket.Header.Component = RDPDR_CTYP_CORE;
    IoPacket.Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
    IoPacket.IoRequest.DeviceId = _DeviceId;
    IoPacket.IoRequest.FileId = FileObj->GetFileId();
    IoPacket.IoRequest.MajorFunction = IRP_MJ_CLOSE;
    IoPacket.IoRequest.MinorFunction = 0;

    Status = SendIoRequest(RxContext, &IoPacket, sizeof(IoPacket), 
        (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

    return Status;
}

NTSTATUS DrDevice::Cleanup(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    RDPDR_IOREQUEST_PACKET IoPacket;

    BEGIN_FN("DrDevice::Cleanup");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_CLEANUP);
    
    if (!Session->IsConnected()) {
        return STATUS_SUCCESS;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to cleanup a client device which is not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_SUCCESS;
    }

    memset(&IoPacket, 0, sizeof(IoPacket));

    IoPacket.Header.Component = RDPDR_CTYP_CORE;
    IoPacket.Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
    IoPacket.IoRequest.DeviceId = _DeviceId;
    IoPacket.IoRequest.FileId = FileObj->GetFileId();
    IoPacket.IoRequest.MajorFunction = IRP_MJ_CLEANUP;
    IoPacket.IoRequest.MinorFunction = 0;

    Status = SendIoRequest(RxContext, &IoPacket, sizeof(IoPacket), 
        (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

    return Status;
}

NTSTATUS DrDevice::SendIoRequest(IN OUT PRX_CONTEXT RxContext,
        PRDPDR_IOREQUEST_PACKET IoRequest, ULONG Length, 
        BOOLEAN Synchronous, PLARGE_INTEGER TimeOut, BOOL LowPrioSend)
/*++

Routine Description:

    Sends the request to the client, and manages the completion. This IO
    can only be completed once, by returning non-STATUS_PENDING or by
    calling RxLowIoCompletion.

Arguments:

    RxContext - The IoRequest
    IoRequest - The IoRequest packet
    Length - size of IoRequest packet
    Synchronous - duh
    LowPrioSend - Packet should be sent to client at low priority.

Return Value:

    None

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT Mid = INVALID_MID;
    BOOL ExchangeCreated = FALSE;
    DrIoContext *Context = NULL;
    SmartPtr<DrExchange> Exchange;
    SmartPtr<DrDevice> Device(this);

    BEGIN_FN("DrDevice::SendIoRequest");

    ASSERT(RxContext != NULL);
    ASSERT(IoRequest != NULL);
    ASSERT(Length >= sizeof(RDPDR_IOREQUEST_PACKET));

    Context = new DrIoContext(RxContext, Device);

    if (Context != NULL) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(Status)) {

        //
        // Set up a mapping so the completion response handler can
        // find this context
        //

        TRC_DBG((TB, "Create the context for this I/O"));
        KeClearEvent(&RxContext->SyncEvent);

        ExchangeCreated = 
            _Session->GetExchangeManager().CreateExchange(this, Context, Exchange);

        if (ExchangeCreated) {

            //
            // No need to explicit Refcount for the RxContext
            // The place it's been used is the cancel routine.
            // Since CreateExchange holds the ref count.  we are okay
            //

            //Exchange->AddRef();
            RxContext->MRxContext[MRX_DR_CONTEXT] = (DrExchange *)Exchange;

            Status = STATUS_SUCCESS;
        } else {
            delete Context;
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(Status)) {

        TRC_DBG((TB, "Writing IoRequest to the client channel"));

        //
        // Mark the IoRequest with the context mapper
        //

        IoRequest->IoRequest.CompletionId = Exchange->_Mid;

        TRC_DBG((TB, "IO packet:"));
        TRC_DBG((TB, "    Component     %c%c",
                HIBYTE(IoRequest->Header.Component), 
                LOBYTE(IoRequest->Header.Component)));
        TRC_DBG((TB, "    PacketId       %c%c",
                HIBYTE(IoRequest->Header.PacketId), 
                LOBYTE(IoRequest->Header.PacketId)));
        TRC_DBG((TB, "    DeviceId      0x%lx", 
                IoRequest->IoRequest.DeviceId));
        TRC_DBG((TB, "    FileId        0x%lx",
                IoRequest->IoRequest.FileId));
        TRC_DBG((TB, "    MajorFunction 0x%lx",
                IoRequest->IoRequest.MajorFunction));
        TRC_DBG((TB, "    MinorFunction 0x%lx",
                IoRequest->IoRequest.MinorFunction));

        Status = _Session->GetExchangeManager().StartExchange(Exchange, this, 
            IoRequest, Length, LowPrioSend);
    }

    if (NT_SUCCESS(Status)) {

        TRC_DBG((TB, "Setting cancel routine for Io"));

        //
        // Set this after sending the IO to the client
        // if cancel was requested already, we can just call the
        // cancel routine ourselves
        //

        Status = RxSetMinirdrCancelRoutine(RxContext,
                MinirdrCancelRoutine);

        if (Status == STATUS_CANCELLED) {
            TRC_NRM((TB, "Io was already cancelled"));

            MinirdrCancelRoutine(RxContext);
            Status = STATUS_SUCCESS;
        }
    }

    if (Synchronous) {    
        //
        // Some failure is going to prevent our completions routine from
        // being called. Do that work now.
        //
        if (!ExchangeCreated) {
            //
            // If we couldn't even create the exchange, we need to just 
            // complete the IO as failed
            //
                                                     
            CompleteRxContext(RxContext, Status, 0);
        } 
        else {
            
            TRC_DBG((TB, "Waiting for IoResult for synchronous request")); 
            
            if (NT_SUCCESS(Status)) {                
                Status = KeWaitForSingleObject(&RxContext->SyncEvent, UserRequest,
                        KernelMode, FALSE, TimeOut);
                
                if (Status == STATUS_TIMEOUT) {
                    RxContext->IoStatusBlock.Status = Status;
    
                    TRC_DBG((TB, "Wait timed out"));
                    MarkTimedOut(Exchange);            
                }
                else {
                    Status = RxContext->IoStatusBlock.Status;
                }                                       
            }
            else {

                //
                // If we created the exchange and then got a transport failure
                // we'll be disconnected, and the the I/O will be completed
                // the same way all outstanding I/O is completed when we are 
                // disconnected.
                //
                if (MarkTimedOut(Exchange)) {
                    CompleteRxContext(RxContext, Status, 0);
                }
                else {
                    Status = KeWaitForSingleObject(&RxContext->SyncEvent, UserRequest,
                            KernelMode, FALSE, NULL);
                    Status = RxContext->IoStatusBlock.Status;
                }
            }            
        } 
    }
    else {
        TRC_DBG((TB, "Not waiting for IoResult for asynchronous request"));
        
        //
        // Some failure is going to prevent our completions routine from
        // being called. Do that work now.
        //
        if (!ExchangeCreated) {
            //
            // If we couldn't even create the exchange, we need to just 
            // complete the IO as failed
            //
    
            CompleteRxContext(RxContext, Status, 0);
        } 
        else {
            //
            // If we created the exchange and then got a transport failure
            // we'll be disconnected, and the the I/O will be completed
            // the same way all outstanding I/O is completed when we are 
            // disconnected.
            //
        }
    
        Status = STATUS_PENDING;
    }
    
    return Status;
}

VOID DrDevice::CompleteBusyExchange(SmartPtr<DrExchange> &Exchange, 
        NTSTATUS Status, ULONG Information)
/*++

Routine Description:
    Takes an exchange which is already busy and 

Arguments:
    Mid - Id to find
    ExchangeFound - Pointer to a storage for the pointer to the context

Return Value:
    drexchBusy - Exchange provided, was marked busy
    drexchCancelled - Exchange provided, was already cancelled
    drexchUnavailable - Exchange not provided, disconnected

--*/
{
    DrIoContext *Context;
    PRX_CONTEXT RxContext;

    BEGIN_FN("DrDevice::CompleteBusyExchange");

    DrAcquireMutex();
    Context = (DrIoContext *)Exchange->_Context;
    ASSERT(Context != NULL);
    ASSERT(Context->_Busy);

    RxContext = Context->_RxContext;
    Context->_RxContext = NULL;
    Exchange->_Context = NULL;
    DrReleaseMutex();

    //
    // Note: We've left the Mutex, and the Exchange with no
    // context still exists and can be looked up until we Discard it.
    //

    if (RxContext != NULL) {
        CompleteRxContext(RxContext, Status, Information);
    }
    _Session->GetExchangeManager().Discard(Exchange);

    delete Context;
}

VOID DrDevice::DiscardBusyExchange(SmartPtr<DrExchange> &Exchange)
{
    DrIoContext *Context;

    BEGIN_FN("DrDevice::DiscardBusyExchange");

    DrAcquireMutex();
    Context = (DrIoContext *)Exchange->_Context;
    ASSERT(Context != NULL);
    ASSERT(Context->_Busy);
    ASSERT(Context->_RxContext == NULL);
    Exchange->_Context = NULL;
    DrReleaseMutex();

    //
    // Note: We've left the Mutex, and the Exchange with no
    // context still exists and can be looked up until we Discard it.
    //

    _Session->GetExchangeManager().Discard(Exchange);

    delete Context;
}

BOOL DrDevice::MarkBusy(SmartPtr<DrExchange> &Exchange)
/*++

Routine Description:
    Marks an Exchange context as busy so it won't be cancelled
    while we're copying in to its buffer

Arguments:
    Exchange - Context

Return Value:
    TRUE - if Marked Busy
    FALSE - if Context was gone

--*/
{
    NTSTATUS Status;
    BOOL rc;
    DrIoContext *Context = NULL;

    BEGIN_FN("DrDevice::MarkBusy");
    ASSERT(Exchange != NULL);

    DrAcquireMutex();

    Context = (DrIoContext *)Exchange->_Context;
    if (Context != NULL) {
        ASSERT(!Context->_Busy);
        Context->_Busy = TRUE;
        rc = TRUE;
    } else {
        rc = FALSE;
    }
    DrReleaseMutex();

    return rc;
}

VOID DrDevice::MarkIdle(SmartPtr<DrExchange> &Exchange)
/*++

Routine Description:
    Marks an Exchange context as idle. If it was cancelled
    while we're copying in to its buffer, do the cancel now

Arguments:
    The busy exchange

Return Value:
    None

--*/
{
    PRX_CONTEXT RxContext = NULL;
    DrIoContext *Context = NULL;

    BEGIN_FN("DrDevice::MarkIdle");

    ASSERT(Exchange != NULL);
    DrAcquireMutex();
    Context = (DrIoContext *)Exchange->_Context;
    TRC_ASSERT(Context != NULL, (TB, "Not allowed to delete context while "
            "it is busy"));
    ASSERT(Context->_Busy);

    Context->_Busy = FALSE;

    if (Context->_Cancelled && Context->_RxContext != NULL) {
        TRC_DBG((TB, "Context was cancelled while busy, "
                "completing"));

        //
        // If we were cancelled while busy, we do the work now,
        // swap out the RxContext safely while in the Mutex and
        // actually cancel it right after. Also set the state to
        // indicate the cancelling work has been done
        //

        RxContext = Context->_RxContext;
        TRC_ASSERT(RxContext != NULL, (TB, "Cancelled RxContext was NULL "
                "going from busy to Idle"));
        Context->_RxContext = NULL;
        RxContext->MRxContext[MRX_DR_CONTEXT] = NULL;
    }

    if (Context->_Disconnected) {

        //
        // If the connection dropped while busy, clear that out
        // in the Mutex for safety, and then delete it outside
        //

        Exchange->_Context = NULL;
    }

    DrReleaseMutex();

    if (RxContext != NULL) {

        //
        // We only remove the RxContext because marking Idle means
        // we expect to come back and look for it again later after we
        // receive more data
        //

        CompleteRxContext(RxContext, STATUS_CANCELLED, 0);

        if (Context->_Disconnected) {

            //
            // We got disconnected while busy, and will get no further
            // notifications from the Exachnge manager. The Context must
            // be deleted now
            //

            delete Context;
        }
    }
}

BOOL DrDevice::MarkTimedOut(SmartPtr<DrExchange> &Exchange)
/*++

Routine Description:
    Marks an Exchange context as timed out so it won't be processd
    when the client later returns.    

Arguments:
    Exchange - Context

Return Value:
    TRUE - if Marked TimedOut
    FALSE - if Context was gone

--*/
{
    NTSTATUS Status;
    BOOL rc;
    DrIoContext *Context = NULL;
    PRX_CONTEXT RxContext = NULL;

    BEGIN_FN("DrDevice::MarkTimedOut");
    ASSERT(Exchange != NULL);

    DrAcquireMutex();

    Context = (DrIoContext *)Exchange->_Context;
    if (Context != NULL) {
        ASSERT(!Context->_TimedOut);
        Context->_TimedOut = TRUE;

        if (Context->_RxContext != NULL) {
            RxContext = Context->_RxContext;
            Context->_RxContext = NULL;
            RxContext->MRxContext[MRX_DR_CONTEXT] = NULL;
            rc = TRUE;
        }
        else {
            rc = FALSE;
        }
    } else {
        rc = FALSE;
    }

    DrReleaseMutex();

    return rc;
}

VOID DrDevice::CompleteRxContext(PRX_CONTEXT RxContext, NTSTATUS Status, 
                                 ULONG Information)
/*++

Routine Description:
    Completes the Io from the RDBSS perspective with the supplied information

Arguments:
    RxContext -     IFS kit context
    Status -        Completion status
    Information -   Completion information

Return Value:
    None

--*/
{
    BEGIN_FN_STATIC("DrDevice::CompleteRxContext");
    ASSERT(RxContext != NULL);

    RxContext->IoStatusBlock.Status = Status;
    RxContext->IoStatusBlock.Information = Information;
    
    if (((RxContext->LowIoContext.Flags & LOWIO_CONTEXT_FLAG_SYNCCALL) != 0) ||
            (RxContext->MajorFunction == IRP_MJ_CREATE)) {
        TRC_DBG((TB, "Setting event for synchronous Io"));
        KeSetEvent(&RxContext->SyncEvent, 0, FALSE);
    } else {
        TRC_DBG((TB, "Calling RxLowIoCompletion for asynchronous Io"));
        RxLowIoCompletion(RxContext);
    }
}

NTSTATUS DrDevice::OnDeviceIoCompletion(
        PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> &Exchange)
/*++

Routine Description:
    Callback from the Exchange manager to process an Io

Arguments:
    CompletionPacket -  The packet containing the completion
    cbPacket -          count of bytes in the packet
    DoDefaultRead -     Should be set to TRUE if read isn't explicitly called
    Exchange -          Context for the Io

Return Value:
    NTSTATUS code. An error indicates a protocol error or need to disconnect
    the client

--*/
{
    DrIoContext *Context = NULL;
    NTSTATUS Status;
    PRX_CONTEXT RxContext;

    BEGIN_FN("DrDevice::OnDeviceIoCompletion");

    ASSERT(CompletionPacket != NULL);
    ASSERT(DoDefaultRead != NULL);

    if (MarkBusy(Exchange)) {
        Context = (DrIoContext *)Exchange->_Context;
        ASSERT(Context != NULL);

        TRC_NRM((TB, "Client completed %s irp, Completion Status: %lx",
                IrpNames[Context->_MajorFunction],
                CompletionPacket->IoCompletion.IoStatus));

        //
        //  If the IRP was timed out, then we just discard this exchange
        //
        if (Context->_TimedOut) {
            TRC_NRM((TB, "Irp was timed out"));
            DiscardBusyExchange(Exchange);
            
            return STATUS_SUCCESS;
        }

        switch (Context->_MajorFunction) {
        case IRP_MJ_CREATE:
            Status = OnCreateCompletion(CompletionPacket, cbPacket, 
                    DoDefaultRead, Exchange);
            break;

        case IRP_MJ_WRITE:
            Status = OnWriteCompletion(CompletionPacket, cbPacket, 
                    DoDefaultRead, Exchange);
            break;

        case IRP_MJ_READ:
            Status = OnReadCompletion(CompletionPacket, cbPacket, 
                    DoDefaultRead, Exchange);
            break;

        case IRP_MJ_DEVICE_CONTROL:
        case IRP_MJ_FILE_SYSTEM_CONTROL:
            Status = OnDeviceControlCompletion(CompletionPacket, cbPacket, 
                    DoDefaultRead, Exchange);
            break;
        
        case IRP_MJ_LOCK_CONTROL:
            Status = OnLocksCompletion(CompletionPacket, cbPacket,
                    DoDefaultRead, Exchange);
            break;

        case IRP_MJ_DIRECTORY_CONTROL:
            Status = OnDirectoryControlCompletion(CompletionPacket, cbPacket,
                    DoDefaultRead, Exchange);
            break;

        case IRP_MJ_QUERY_VOLUME_INFORMATION:
            Status = OnQueryVolumeInfoCompletion(CompletionPacket, cbPacket, 
                    DoDefaultRead, Exchange);
            break;

        case IRP_MJ_SET_VOLUME_INFORMATION: 
            Status = OnSetVolumeInfoCompletion(CompletionPacket, cbPacket, 
                    DoDefaultRead, Exchange);
            break;

        case IRP_MJ_QUERY_INFORMATION:
            Status = OnQueryFileInfoCompletion(CompletionPacket, cbPacket,
                    DoDefaultRead, Exchange);
            break;

        case IRP_MJ_SET_INFORMATION:
            Status = OnSetFileInfoCompletion(CompletionPacket, cbPacket,
                    DoDefaultRead, Exchange);
            break;

        case IRP_MJ_QUERY_SECURITY:
            Status = OnQuerySdInfoCompletion(CompletionPacket, cbPacket,
                    DoDefaultRead, Exchange);
            break;

        case IRP_MJ_SET_SECURITY:
            Status = OnSetSdInfoCompletion(CompletionPacket, cbPacket,
                    DoDefaultRead, Exchange);
            break;

        case IRP_MJ_CLOSE:
            NotifyClose();
            // no break;

        default:

            RxContext = Context->_RxContext;
            if (RxContext != NULL) {
                TRC_NRM((TB, "Irp: %s, Completion Status: %lx",
                        IrpNames[RxContext->MajorFunction],
                        RxContext->IoStatusBlock.Status));

                CompleteBusyExchange(Exchange, CompletionPacket->IoCompletion.IoStatus, 0);
            } else {
                TRC_NRM((TB, "Irp was cancelled"));
                DiscardBusyExchange(Exchange);
            }
            Status = STATUS_SUCCESS;
        }
    } else {

        //
        // We could have been disconnected between getting the callback and
        // trying to mark it busy. So the only legitimate way for this to
        // happen is if we were disconnected anyway.
        //

        TRC_ALT((TB, "Found no context in Io notification"));
        *DoDefaultRead = FALSE;
        Status = STATUS_UNSUCCESSFUL;
    }

    return Status;
}

NTSTATUS DrDevice::OnCreateCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;
    PRX_CONTEXT RxContext;
    SmartPtr<DrDevice> Device;
    SmartPtr<DrFile> FileObj;
    
    BEGIN_FN("DrDevice::OnCreateCompletion");
    RxContext = Context->_RxContext;

    if (cbPacket < (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
            IoCompletion.Parameters.Create.Information)) {

        //
        // Bad packet. Bad. We've already claimed the RxContext in the
        // atlas. Complete it as unsuccessful. Then shutdown the channel
        // as this is a Bad Client.
        //
        TRC_ERR((TB, "Detected bad client CreateCompletion packet"));

        if (RxContext != NULL) {
            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
        } else {
            DiscardBusyExchange(Exchange);
        }

        //
        // No point in starting a default read or anything, what with the
        // channel being shut down and all.
        //

        *DoDefaultRead = FALSE;
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    if (RxContext != NULL) {
        
        DrAcquireSpinLock();
        Device = (DrDevice *)RxContext->Create.pVNetRoot->Context;
        DrReleaseSpinLock();

        ASSERT(Device != NULL);

        //
        // We are using a file object to keep track of file open instance
        // and any information stored in the mini-redir for this instance
        //

        FileObj = new(NonPagedPool) DrFile(Device,
                CompletionPacket->IoCompletion.Parameters.Create.FileId);

        if (FileObj) {
            //
            //  Explicit reference the file object here
            //
            FileObj->AddRef();
            RxContext->pFobx->Context2 = (VOID *)(FileObj);

            TRC_NRM((TB, "CreateCompletion: status =%d, information=%d", 
                     CompletionPacket->IoCompletion.IoStatus,
                     CompletionPacket->IoCompletion.Parameters.Create.Information));

            if (cbPacket >= sizeof(RDPDR_IOCOMPLETION_PACKET)) {
                RxContext->Create.ReturnedCreateInformation = 
                        CompletionPacket->IoCompletion.Parameters.Create.Information;

                CompleteBusyExchange(Exchange, CompletionPacket->IoCompletion.IoStatus,
                        CompletionPacket->IoCompletion.Parameters.Create.Information);
            }
            else {
                // For printer creat completion packet, the cbPacket is less than
                // sizeof(RDPDR_IOCOMPLETION_PACKET). We don't want to access information beyond its length
         
                RxContext->Create.ReturnedCreateInformation = 0;

                CompleteBusyExchange(Exchange, CompletionPacket->IoCompletion.IoStatus, 0);
            }            
        }
        else {
            CompleteBusyExchange(Exchange, STATUS_INSUFFICIENT_RESOURCES, 0);
            
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {

        //
        // Was cancelled but Context wasn't cleaned up
        //

        DiscardBusyExchange(Exchange);
    }
    return STATUS_SUCCESS;
}

NTSTATUS DrDevice::OnWriteCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    PRX_CONTEXT RxContext;
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;

    BEGIN_FN("DrDevice::OnWriteCompletion");

    RxContext = Context->_RxContext;

    if (cbPacket < sizeof(RDPDR_IOCOMPLETION_PACKET)) {

        //
        // Bad packet. Bad. We've already claimed the RxContext in the
        // atlas. Complete it as unsuccessful. Then shutdown the channel
        // as this is a Bad Client.
        //
        TRC_ERR((TB, "Detected bad client WriteCompletion packet"));

        if (RxContext != NULL) {
            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
        } else {
            DiscardBusyExchange(Exchange);
        }

        //
        // No point in starting a default read or anything, what with the
        // channel being shut down and all.
        //

        *DoDefaultRead = FALSE;
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    if (RxContext != NULL) {
        ASSERT(RxContext->MajorFunction == IRP_MJ_WRITE);

        TRC_NRM((TB, "Irp: %s, Completion Status: %lx",
                IrpNames[RxContext->MajorFunction],
                RxContext->IoStatusBlock.Status));

        CompleteBusyExchange(Exchange, CompletionPacket->IoCompletion.IoStatus,
                CompletionPacket->IoCompletion.Parameters.Write.Length);
    } else {

        //
        // Was cancelled but Context wasn't cleaned up
        //

        DiscardBusyExchange(Exchange);
    }
    return STATUS_SUCCESS;
}

NTSTATUS DrDevice::OnReadCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    PRX_CONTEXT RxContext;
    PVOID pData = CompletionPacket->IoCompletion.Parameters.Read.Buffer; 
    ULONG cbWantData;  // Amount of actual Read data in this packet
    ULONG cbHaveData;  // Amount of data available so far
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;
    NTSTATUS Status;
    PVOID pv;

    BEGIN_FN("DrDevice::OnReadCompletion");

    //
    // Even if the IO was cancelled we need to correctly parse
    // this data.
    //
    // Check to make sure this is up to size before accessing 
    // further portions of the packet
    //

    RxContext = Context->_RxContext;

    if (cbPacket < (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
            IoCompletion.Parameters.Read.Buffer)) {

        //
        // Bad packet. Bad. We've already claimed the RxContext in the
        // atlas. Complete it as unsuccessful. Then shutdown the channel
        // as this is a Bad Client.
        //

        TRC_ERR((TB, "Detected bad client read packet"));

        if (RxContext != NULL) {
            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
        } else {
            DiscardBusyExchange(Exchange);
        }

        //
        // No point in starting a default read or anything, what with the
        // channel being shut down and all.
        //

        *DoDefaultRead = FALSE;
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    //
    // Calculate how much data is available immediately and how much data
    // is coming
    //

    if (NT_SUCCESS(CompletionPacket->IoCompletion.IoStatus)) {

        //
        // Successful IO at the client end
        //

        TRC_DBG((TB, "Successful Read at the client end"));
        TRC_DBG((TB, "Read Length: 0x%d, DataCopied 0x%d",
                CompletionPacket->IoCompletion.Parameters.Read.Length,
                Context->_DataCopied));
        cbWantData = CompletionPacket->IoCompletion.Parameters.Read.Length -
                Context->_DataCopied;
        cbHaveData = cbPacket - (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
            IoCompletion.Parameters.Read.Buffer);

        if (cbHaveData > cbWantData) {
            //
            // Sounds like a bad client to me
            //

            TRC_ERR((TB, "Read returned more data than "
                    "advertised cbHaveData 0x%d cbWantData 0x%d", 
                    cbHaveData, cbWantData));

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
            } else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = FALSE;
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }

        if (RxContext != NULL) { // And not drexchCancelled

            TRC_DBG((TB, "Copying data for Read"));
            ASSERT(RxContext != NULL);

            if (cbWantData > RxContext->LowIoContext.ParamsFor.ReadWrite.ByteCount) {

                TRC_ERR((TB, "Read returned more data than "
                        "requested"));

                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                *DoDefaultRead = FALSE;
                return STATUS_DEVICE_PROTOCOL_ERROR;
            }

            //
            // Copy the actual size of the read, and check to see if we have all 
            // the data. The information field tells us what to expect.
            // 

            RxContext->IoStatusBlock.Information =
                    CompletionPacket->IoCompletion.Parameters.Read.Length;

            if (RxContext->IoStatusBlock.Information && cbHaveData) {

                pv =  MmGetSystemAddressForMdl(RxContext->LowIoContext.ParamsFor.ReadWrite.Buffer);

                RtlCopyMemory(((BYTE *)pv) + Context->_DataCopied, pData, cbHaveData);

                //
                // Keep track of how much data we've copied in case this is a
                // multi chunk completion
                //

                Context->_DataCopied += cbHaveData;
            }
        }

        if (cbHaveData == cbWantData) {

            //
            // There is exactly as much data as we need to satisfy the read,
            // I like it.
            //    

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, 
                    CompletionPacket->IoCompletion.IoStatus,
                    CompletionPacket->IoCompletion.Parameters.Read.Length);
            } else {
                DiscardBusyExchange(Exchange);
            }

            //
            // Go with a default channel read now
            //

            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        } else {

            //
            // We don't have all the data yet, release the DrExchange and 
            // read more data
            //

            MarkIdle(Exchange);

            _Session->GetExchangeManager().ReadMore(
                    (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.Read.Buffer));

            *DoDefaultRead = FALSE;
            return STATUS_SUCCESS;
        }
    } else {

        //
        // Unsuccessful IO at the client end
        //

        TRC_DBG((TB, "Unsuccessful Read at the client end"));
        if (cbPacket >= FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                IoCompletion.Parameters.Read.Buffer)) {
            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, 
                    CompletionPacket->IoCompletion.IoStatus,
                    0);
            }
            else {
                DiscardBusyExchange(Exchange);
            }
            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        } else {
            TRC_ERR((TB, "Read returned invalid data"));

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
            } else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = FALSE;
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
    }
}

NTSTATUS DrDevice::OnDeviceControlCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    PRX_CONTEXT RxContext;
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;
    PVOID pData = CompletionPacket->IoCompletion.Parameters.DeviceIoControl.OutputBuffer; 
    ULONG cbWantData;  // Amount of actual Read data in this packet
    ULONG cbHaveData;  // Amount of data available so far
    NTSTATUS Status;
    PVOID pv;

    BEGIN_FN("DrDevice::OnDeviceControlCompletion");

    //
    // Even if the IO was cancelled we need to correctly parse
    // this data.
    //
    // Check to make sure this is up to size before accessing 
    // further portions of the packet
    //

    RxContext = Context->_RxContext;

    if (cbPacket < (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
            IoCompletion.Parameters.DeviceIoControl.OutputBuffer)) {

        //
        // Bad packet. Bad. We've already claimed the RxContext in the
        // atlas. Complete it as unsuccessful. Then shutdown the channel
        // as this is a Bad Client.
        //

        TRC_ERR((TB, "Detected bad client DeviceControl packet"));

        if (RxContext != NULL) {
            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
        } else {
            DiscardBusyExchange(Exchange);
        }

        //
        // No point in starting a default read or anything, what with the
        // channel being shut down and all.
        //

        *DoDefaultRead = FALSE;
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    //
    // Calculate how much data is available immediately and how much data
    // is coming
    //

    if (NT_SUCCESS(CompletionPacket->IoCompletion.IoStatus)) {

        //
        // Successful IO at the client end
        //

        TRC_DBG((TB, "Successful DeviceControl at the client end"));

        cbWantData = CompletionPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength -
                Context->_DataCopied;
        cbHaveData = cbPacket - (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
            IoCompletion.Parameters.DeviceIoControl.OutputBuffer);

        if (cbHaveData > cbWantData) {
            //
            // Sounds like a bad client to me
            //

            TRC_ERR((TB, "DeviceControl returned more data than "
                    "advertised, cbHaveData: %ld cbWantData: %ld", cbHaveData,
                    cbWantData));
            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
            } else {
                DiscardBusyExchange(Exchange);
            }
            *DoDefaultRead = FALSE;
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }

        if (RxContext != NULL) { // And not drexchCancelled

            TRC_DBG((TB, "Copying data for DeviceControl"));
            ASSERT(RxContext != NULL);

            if (cbWantData > RxContext->LowIoContext.ParamsFor.IoCtl.OutputBufferLength) {

                TRC_ERR((TB, "DeviceControl returned more data than "
                        "requested"));

                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                *DoDefaultRead = FALSE;
                return STATUS_DEVICE_PROTOCOL_ERROR;
            }

            //
            // Copy the actual size of the read, and check to see if we have all 
            // the data. The information field tells us what to expect.
            // 

            RxContext->IoStatusBlock.Information =
                    CompletionPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength;

            __try {
                if (RxContext->IoStatusBlock.Information && cbHaveData) {
                    RtlCopyMemory(((BYTE *)RxContext->LowIoContext.ParamsFor.IoCtl.pOutputBuffer) + 
                        Context->_DataCopied, pData, cbHaveData);
    
                    //
                    // Keep track of how much data we've copied in case this is a
                    // multi chunk completion
                    //
    
                    Context->_DataCopied += cbHaveData;
                }
            }
            __except (EXCEPTION_EXECUTE_HANDLER) {
                
                TRC_ERR((TB, "Invalid buffer parameter(s)"));
                
                CompleteBusyExchange(Exchange, STATUS_INVALID_PARAMETER, 0);
                *DoDefaultRead = FALSE;
                
                // This is the status returned back to HandlePacket, not the status
                // returned back to the caller of IoControl.
                return STATUS_SUCCESS;
            }
        }

        if (cbHaveData == cbWantData) {

            //
            // There is exactly as much data as we need to satisfy the io,
            // I like it.
            //

            TRC_NRM((TB, "DeviceControl, read %d bytes", Context->_DataCopied));

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, 
                    CompletionPacket->IoCompletion.IoStatus,
                    CompletionPacket->IoCompletion.Parameters.DeviceIoControl.OutputBufferLength);
            } else {
                DiscardBusyExchange(Exchange);
            }

            //
            // Go with a default channel read now
            //

            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        } else {

            //
            // We don't have all the data yet, release the DrExchange and 
            // read more data
            //

            MarkIdle(Exchange);

            _Session->GetExchangeManager().ReadMore(
                    (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                IoCompletion.Parameters.DeviceIoControl.OutputBuffer));

            *DoDefaultRead = FALSE;
            return STATUS_SUCCESS;
        }
    } else {

        //
        // Unsuccessful IO at the client end
        //

        TRC_DBG((TB, "Unsuccessful DeviceControl at the client end"));

        if (cbPacket >= FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                IoCompletion.Parameters.DeviceIoControl.OutputBuffer)) {
            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, 
                    CompletionPacket->IoCompletion.IoStatus,
                    0);
            }
            else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        } else {
            TRC_ERR((TB, "DeviceControl returned invalid  data "));

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
            } else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = FALSE;
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
    }
}

NTSTATUS NTAPI DrDevice::MinirdrCancelRoutine(PRX_CONTEXT RxContext)
{
    SmartPtr<DrExchange> Exchange;
    DrIoContext *Context;
    BOOL bFound = FALSE;

    BEGIN_FN_STATIC("DrDevice::MinirdrCancelRoutine");
    DrAcquireMutex();
    Exchange = (DrExchange *)RxContext->MRxContext[MRX_DR_CONTEXT];

    if (Exchange == NULL) {
        DrReleaseMutex();
        return STATUS_SUCCESS;
    }

    ASSERT(Exchange->IsValid());
    Context = (DrIoContext *)Exchange->_Context;

    if (Context != NULL) {
        TRC_DBG((TB, "Marking Exchange cancelled"));

        //
        // Mark it as cancelled, if it is busy, it will be cancelled
        // when it goes back to idle
        // 

        Context->_Cancelled = TRUE;

        if (!Context->_Busy) {

            ASSERT(Context->_RxContext == RxContext);

            //
            // Wasn't busy, cancelling work should be done here
            //

            Context->_RxContext = NULL;
            TRC_DBG((TB, "Found context to cancel"));
            bFound = TRUE;
        } else {
            TRC_DBG((TB, "DrExchange was busy or RxContext "
                    "not found"));
        }
    } else {

        //
        // This could happened if we destroyed the atlas
        //

        TRC_NRM((TB, "DrExchange was already cancelled"));
    }

    DrReleaseMutex();

    if (bFound) {

        //
        // Do the cancelling outside the mutex
        //

        CompleteRxContext(RxContext, STATUS_CANCELLED, 0);
    }
    return STATUS_SUCCESS;
}

VOID DrDevice::OnIoDisconnected(SmartPtr<DrExchange> &Exchange)
{
    DrIoContext *Context, *DeleteContext = NULL;
    PRX_CONTEXT RxContext = NULL;    
    BOOL bFound = FALSE;

    
    BEGIN_FN("DrDevice::OnIoDisconnected");
    DrAcquireMutex();
    ASSERT(Exchange->IsValid());
    Context = (DrIoContext *)Exchange->_Context;

    if (Context != NULL) {
        TRC_DBG((TB, "Marking Exchange cancelled"));

        //
        // Mark it as cancelled, if it is busy, it will be cancelled
        // when it goes back to idle
        //
        // Also mark it disconnected, so we know to completely clean
        // up the Context
        // 

        Context->_Cancelled = TRUE;
        Context->_Disconnected = TRUE;

        if (!Context->_Busy) {

            RxContext = Context->_RxContext;
            Exchange->_Context = NULL;

            // Need to delete the context when the exchange is already cancelled or 
            // about to be cancelled.  Also deletion needs to happen outside the mutex
            DeleteContext = Context;
            
            //
            // Wasn't busy, cancelling work should be done here
            //

            if (RxContext) {
                RxContext->MRxContext[MRX_DR_CONTEXT] = NULL;

                TRC_DBG((TB, "Found context to cancel"));
                bFound = TRUE;
            } else {
                TRC_DBG((TB, "RxContext was already cancelled "));
            }
        } else {
            TRC_DBG((TB, "DrExchange was busy or RxContext "
                    "not found"));
        }
    } else {

        //
        // This could happened if we destroyed the atlas right after
        // the IO was completed, but before we discarded it
        //

        TRC_NRM((TB, "DrExchange was already cancelled"));
    }

    DrReleaseMutex();

    if (bFound) {

        //
        // Do the cancelling outside the mutex
        //

        CompleteRxContext(RxContext, STATUS_CANCELLED, 0);
        
    }

    if (DeleteContext != NULL) {
        delete DeleteContext;
    }
}

NTSTATUS DrDevice::OnStartExchangeCompletion(SmartPtr<DrExchange> &Exchange, 
        PIO_STATUS_BLOCK IoStatusBlock)
{
    BEGIN_FN("DrDevice::OnStartExchangeCompletion");
    //
    // if an error is returned, the connection should be dropped, and that
    // is correct when an error comes in
    //

    return IoStatusBlock->Status;
}

VOID DrDevice::Remove()
{
    BEGIN_FN("DrDevice::Remove");
    _DeviceStatus = dsDisabled;
}


DrIoContext::DrIoContext(PRX_CONTEXT RxContext, SmartPtr<DrDevice> &Device)
{
    BEGIN_FN("DrIoContext::DrIoContext");
    SetClassName("DrIoContext");
    _Device = Device;
    _MajorFunction = RxContext->MajorFunction;
    _MinorFunction = RxContext->MinorFunction;
    _Busy = FALSE;
    _Cancelled = FALSE;
    _Disconnected = FALSE;
    _TimedOut = FALSE;
    _DataCopied = 0;
    _RxContext = RxContext;
}

VOID DrDevice::NotifyClose()
{
    BEGIN_FN("DrDevice::NotifyClose");

    // This was added for ports, which need to track exclusivity
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\dbg.cpp ===
/****************************************************************************/
// dbg.c
//
// RDPDR debug code
//
// Copyright (C) 1998-2000 Microsoft Corp.
/****************************************************************************/

#include "precomp.hxx"
#define TRC_FILE "dbg"
#include "trc.h"


#if DBG
ULONG DebugBreakOnEntry = FALSE;
//DWORD RefCount::_dwReferenceTraceIndex = 0xFFFFFFFF;
//ReferenceTraceRecord RefCount::_TraceRecordList[kReferenceTraceMask + 1];

typedef struct tagRDPDR_MEMHDR
{
    ULONG   magicNo;
    ULONG   subTag;
    ULONG   size;
    ULONG   pad;
} RDPDR_MEMHDR, *PRDPDR_MEMHDR;

void *
DrAllocatePool(IN POOL_TYPE PoolType, IN SIZE_T NumberOfBytes, IN ULONG Tag)
/*++

Routine Description:

    Allocate from pool memory and add a tag.

Arguments:

    size        -   Number of bytes to allocate.
    poolType    -   Type of pool memory being allocated.
    subTag      -   Subtag of DR_POOLTAG.

Return Value:

    Pointer to allocated memory on success.  Otherwise, NULL is returned.

--*/
{
    PRDPDR_MEMHDR hdr;
    PBYTE p;

    BEGIN_FN("DrAllocatePool");
    ASSERT(
        PoolType == NonPagedPool || 
        PoolType == NonPagedPoolMustSucceed ||
        PoolType == NonPagedPoolCacheAligned ||
        PoolType == NonPagedPoolCacheAlignedMustS ||
        PoolType == PagedPool ||
        PoolType == PagedPoolCacheAligned
        );

    hdr = (PRDPDR_MEMHDR)ExAllocatePoolWithTag(
                PoolType, NumberOfBytes + sizeof(RDPDR_MEMHDR), 
                DR_POOLTAG
                );
    if (hdr != NULL) {
        hdr->magicNo = GOODMEMMAGICNUMBER;
        hdr->subTag  = Tag;
        hdr->size    = (ULONG)NumberOfBytes;

        p = (PBYTE)(hdr + 1);
        memset(p, UNITIALIZEDMEM, NumberOfBytes);
        return (void *)p;
    }
    else {
        return NULL;
    }
}

void 
DrFreePool(
    IN void *ptr
    )
/*++

Routine Description:

    Release memory allocated by a call to DrAllocatePool.

Arguments:

    ptr -   Block of memory allocated by a call to DrAllocatePool.

Return Value:

    NA

--*/
{
    BEGIN_FN("DrFreePool");
    ASSERT(ptr != NULL);
    PRDPDR_MEMHDR hdr;

    //
    //  Get a pointer to the header to the memory block.
    //
    hdr = (PRDPDR_MEMHDR)ptr;
    hdr--;

    //
    //  Make sure the block is valid.
    //
    ASSERT(hdr->magicNo == GOODMEMMAGICNUMBER);

    //
    //  Mark it as freed.
    //
    hdr->magicNo = FREEDMEMMAGICNUMBER;

    //
    //  Scramble and free the memory.
    //
    memset(ptr, BADMEM, hdr->size);
    ExFreePool(hdr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\dbg.h ===
/****************************************************************************/
// dbg.h
//
// RDPDR debug header
//
// Copyright (C) 1998-2000 Microsoft Corp.
/****************************************************************************/

//
// KDX support
//

#ifdef DRKDX
#define private public
#define protected public
#endif

#define __STR2__(x) #x
#define __STR1__(x) __STR2__(x)
#define __LOC__ __FILE__ "("__STR1__(__LINE__)") : warning CUSER: "

//
//  Object and Memory Tracking Defines
//
#define GOODMEMMAGICNUMBER  0x08854107
#define BADMEM              0xDE
#define UNITIALIZEDMEM      0xBB
#define FREEDMEMMAGICNUMBER 0x08815412

//
//  Memory Allocation Subpool Tags
//
#define DRTOPOBJ_SUBTAG     'JBOT'
#define DRGLOBAL_SUBTAG     'rDrD'

//
//  Memory Allocation Routines
//
#if DBG
//  The Functions
void *DrAllocatePool(IN POOL_TYPE PoolType, IN SIZE_T NumberOfBytes, IN ULONG Tag);

void DrFreePool(void *ptr);

//  The Macros
/*#define DRALLOCATEPOOL(size, poolType, subTag) \
    DrAllocatePool(size, poolType, subTag)

#define DRFREEPOOL(ptr) \
    DrFreePool(ptr)
    */
#define DRALLOCATEPOOL ExAllocatePoolWithTag
#define DRFREEPOOL ExFreePool
#else // DBG
#define DRALLOCATEPOOL ExAllocatePoolWithTag
#define DRFREEPOOL ExFreePool
/*#define DRALLOCATEPOOL(size, poolType, subTag) \
    ExAllocatePoolWithTag(poolType, size, DR_POOLTAG)

#define DRFREEPOOL(ptr) \
    ExFreePool(ptr)
    */

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\devmgr.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    devmgr.cpp

Abstract:

    DeviceManager object creates/manages the devices

Revision History:
--*/
#include "precomp.hxx"
#define TRC_FILE "devmgr"
#include "trc.h"

DrDeviceManager::DrDeviceManager()
{
    BEGIN_FN("DrDeviceManager::DrDeviceManager");
    TRC_NRM((TB, "DeviceManagr Class: %p", this));

    SetClassName("DrDeviceManager");
    _Session = NULL;    
}

DrDeviceManager::~DrDeviceManager()
{
    BEGIN_FN("DrDeviceManager::~DrDeviceManager");
    TRC_NRM((TB, "DeviceManager deletion: %p", this));    
}

BOOL DrDeviceManager::Initialize(DrSession *Session)
{
    BEGIN_FN("DrDeviceManager::Initialize");
    ASSERT(_Session == NULL);
    ASSERT(Session != NULL);
    ASSERT(Session->IsValid());
    _Session = Session;
    if (!NT_ERROR(_Session->RegisterPacketReceiver(this))) {
        return TRUE;
    } else {
        _Session = NULL;
        return FALSE;
    }
}

VOID DrDeviceManager::Uninitialize()
/*++

Routine Description:
    Called if the something went wrong during startup

--*/
{
    BEGIN_FN("DrDeviceManager::Uninitialize");
    ASSERT(_Session != NULL);
    ASSERT(_Session->IsValid());
    _Session->RemovePacketReceiver(this);
    _Session = NULL;
}

BOOL DrDeviceManager::RecognizePacket(PRDPDR_HEADER RdpdrHeader)
/*++

Routine Description:

    Determines if the packet will be handled by this object

Arguments:

    RdpdrHeader - Header of the packet.

Return Value:

    TRUE if this object should handle this packet
    FALSE if this object should not handle this packet

--*/
{
    BEGIN_FN("DrDeviceManager::RecognizePacket");
    ASSERT(RdpdrHeader != NULL);

    //
    // If you add a packet here, update the ASSERTS in HandlePacket
    //

    switch (RdpdrHeader->Component) {
    case RDPDR_CTYP_CORE:
        switch (RdpdrHeader->PacketId) {
        case DR_CORE_DEVICE_ANNOUNCE:
        case DR_CORE_DEVICELIST_ANNOUNCE:
        case DR_CORE_DEVICE_REMOVE:
        case DR_CORE_DEVICELIST_REMOVE:
            return TRUE;
        }
    }
    return FALSE;
}

NTSTATUS DrDeviceManager::HandlePacket(PRDPDR_HEADER RdpdrHeader, ULONG Length, 
        BOOL *DoDefaultRead)
/*++

Routine Description:

    Handles this packet

Arguments:

    RdpdrHeader - Header of the packet.
    Length - Total length of the packet

Return Value:

    NTSTATUS -  An error code indicates the client is Bad and should be 
                disconnected, otherwise SUCCESS.

--*/
{
    NTSTATUS Status = STATUS_DEVICE_PROTOCOL_ERROR;

    BEGIN_FN("DrDeviceManager::HandlePacket");

    //
    // RdpdrHeader read, dispatch based on the header
    //

    ASSERT(RdpdrHeader != NULL);
    ASSERT(RdpdrHeader->Component == RDPDR_CTYP_CORE);

    switch (RdpdrHeader->Component) {
    case RDPDR_CTYP_CORE:
        ASSERT(RdpdrHeader->PacketId == DR_CORE_DEVICE_ANNOUNCE || 
                RdpdrHeader->PacketId == DR_CORE_DEVICELIST_ANNOUNCE ||
                RdpdrHeader->PacketId == DR_CORE_DEVICE_REMOVE ||
                RdpdrHeader->PacketId == DR_CORE_DEVICELIST_REMOVE);

        switch (RdpdrHeader->PacketId) {
        case DR_CORE_DEVICE_ANNOUNCE:
            Status = OnDeviceAnnounce(RdpdrHeader, Length, DoDefaultRead);
            break;

        case DR_CORE_DEVICELIST_ANNOUNCE:
            Status = OnDeviceListAnnounce(RdpdrHeader, Length, DoDefaultRead);
            break;

        case DR_CORE_DEVICE_REMOVE:
            Status = OnDeviceRemove(RdpdrHeader, Length, DoDefaultRead);
            break;

        case DR_CORE_DEVICELIST_REMOVE:
            Status = OnDeviceListRemove(RdpdrHeader, Length, DoDefaultRead);
            break;
        }
    }
    return Status;
}

NTSTATUS DrDeviceManager::OnDeviceAnnounce(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket,
        BOOL *DoDefaultRead)
/*++

Routine Description:

    Called in response to recognizing a DeviceAnnounce packet has been
    received.

Arguments:

    RdpdrHeader - The packet
    cbPacket    - Bytes in the packet

--*/
{
    PRDPDR_DEVICE_ANNOUNCE_PACKET DeviceAnnouncePacket =
            (PRDPDR_DEVICE_ANNOUNCE_PACKET)RdpdrHeader;

    BEGIN_FN("DrDeviceManager::OnDeviceAnnounce");
    ASSERT(RdpdrHeader != NULL);
    PUCHAR pPacketLimit = ((PUCHAR)RdpdrHeader) + cbPacket;
    //
    // We just call DrProcessDeviceAnnounce, which deals with one of these
    // for this packet type and for DeviceListAnnounce

    *DoDefaultRead = FALSE;
    
    if (cbPacket >= sizeof(RDPDR_DEVICE_ANNOUNCE_PACKET)) {
        PRDPDR_DEVICE_ANNOUNCE DeviceAnnounce = &DeviceAnnouncePacket->DeviceAnnounce;
        //
        // Make sure we don't go past the end of our buffer
        // Checks:
        // The end of this device is not beyond the valid area
        //
        if ((cbPacket - sizeof(RDPDR_DEVICE_ANNOUNCE_PACKET)) >= DeviceAnnounce->DeviceDataLength) {    
            ProcessDeviceAnnounce(&DeviceAnnouncePacket->DeviceAnnounce);
            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        }
        else {
            ASSERT(FALSE);
            TRC_ERR((TB, "Invalid Device DataLength %d", DeviceAnnounce->DeviceDataLength));
        }
    }
    else {
        ASSERT(FALSE);
        TRC_ERR((TB, "Invalid Packet Length %d", cbPacket));
    }
    //
    // Invalid data. Fail
    //
    return STATUS_UNSUCCESSFUL;
}

NTSTATUS DrDeviceManager::OnDeviceListAnnounce(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket,
        BOOL *DoDefaultRead)
/*++

Routine Description:

    Called in response to recognizing a DeviceListAnnounce packet has been
    received. Reads in the DeviceCount field of the packet, and the first
    device.

Arguments:

    RdpdrHeader - The packet
    cbPacket    - Bytes in the packet

Return Value:

    Boolean indication of whether to do a default read (TRUE) or not (FALSE),
    where FALSE might be specified if another read has been requested 
    explicitly to get a full packet

--*/
{
    NTSTATUS Status;
    PRDPDR_DEVICELIST_ANNOUNCE_PACKET DeviceListAnnouncePacket =
        (PRDPDR_DEVICELIST_ANNOUNCE_PACKET)RdpdrHeader;
    PRDPDR_DEVICE_ANNOUNCE DeviceAnnounce =
            DR_FIRSTDEVICEANNOUNCE(DeviceListAnnouncePacket);
    ULONG DeviceCount = 0;
    PUCHAR pPacketLimit = ((PUCHAR)RdpdrHeader) + cbPacket;
    PUCHAR pCopyTo;
    ULONG cbRemaining;
    ULONG cbDesiredBuffer;
    PRDPDR_DEVICE_ANNOUNCE NextDeviceAnnounce;

    BEGIN_FN("DrDeviceManager::OnDeviceListAnnounce");

    ASSERT(_Session != NULL);
    ASSERT(_Session->IsValid());    
    ASSERT(RdpdrHeader != NULL);
    ASSERT(RdpdrHeader->Component == RDPDR_CTYP_CORE);
    ASSERT(RdpdrHeader->PacketId == DR_CORE_DEVICELIST_ANNOUNCE);
    TRC_NRM((TB, "OnDeviceListAnnounce called (%ld)", cbPacket));

    *DoDefaultRead = FALSE;
    if (cbPacket >= sizeof(RDPDR_DEVICELIST_ANNOUNCE_PACKET)) {
        DeviceCount = DeviceListAnnouncePacket->DeviceListAnnounce.DeviceCount;
    } else {
        //
        // Not enough data to even know the size of the rest
        // We have seen valid case assert here.
        //
        //TRC_ASSERT(cbPacket >= sizeof(RDPDR_DEVICELIST_ANNOUNCE_PACKET),
        //        (TB, "Didn't receive full DeviceListAnnounce basic packet"));

        if (_Session->ReadMore(cbPacket, sizeof(RDPDR_DEVICELIST_ANNOUNCE_PACKET))) {
            return STATUS_SUCCESS;
        } else {
            return STATUS_UNSUCCESSFUL;
        }
    }

    TRC_NRM((TB, "Annoucing %lx devices", DeviceCount));

    //
    // Make sure we don't go past the end of our buffer
    // Three checks:
    // 1) More devices to process
    // 2) Pointer is valid enough to check the variable size
    // 3) The next device (the end of this device) is not beyond the valid area
    //

    while (DeviceCount > 0 && ((PUCHAR)&DeviceAnnounce->DeviceDataLength <=
         pPacketLimit - sizeof(DeviceAnnounce->DeviceDataLength)) &&
        ((PUCHAR)(NextDeviceAnnounce = DR_NEXTDEVICEANNOUNCE(DeviceAnnounce)) <= pPacketLimit) &&
        (NextDeviceAnnounce >= DeviceAnnounce + 1)) {

        //
        // Only process the device announcement PDU when the session is connected
        //
        if (_Session->IsConnected()) {
            ProcessDeviceAnnounce(DeviceAnnounce);
        }
        
        // Move to the next device
        DeviceAnnounce = NextDeviceAnnounce;

        DeviceCount--;
    }

    if (DeviceCount == 0) {
        TRC_NRM((TB, "Finished handling all devices in DeviceList"));

        //
        // All done processing, return TRUE to use default continuation
        //
        *DoDefaultRead = TRUE;
        return STATUS_SUCCESS;
    } else {
        TRC_NRM((TB, "More devices to handle in DeviceList"));

        //
        // We didn't get all the data for the device(s)
        //

        if (DeviceCount < DeviceListAnnouncePacket->DeviceListAnnounce.DeviceCount) {

            //
            // We processed at least one device. Move the final partial device
            // up next to the header, update the header to indicate the number
            // of devices left to process,
            //

            TRC_NRM((TB, "Some devices processed, shuffling "
                "DeviceList"));

            // Move partial device
            cbRemaining = (ULONG)(pPacketLimit - ((PUCHAR)DeviceAnnounce));
            pCopyTo = (PUCHAR)DR_FIRSTDEVICEANNOUNCE(DeviceListAnnouncePacket);
            RtlMoveMemory(pCopyTo, DeviceAnnounce, cbRemaining);

            // update the device count
            DeviceListAnnouncePacket->DeviceListAnnounce.DeviceCount = DeviceCount;

            // update the Packet limit for the amount we've consumed
            pPacketLimit = pCopyTo + cbRemaining;
            cbPacket = (ULONG)(pPacketLimit - (PUCHAR)RdpdrHeader);
        }

        //
        // If we have enough information to know the size of buffer we need,
        // allocate that now
        //

        DeviceAnnounce = DR_FIRSTDEVICEANNOUNCE(DeviceListAnnouncePacket);
        if ((PUCHAR)&DeviceAnnounce->DeviceDataLength <=
                pPacketLimit - sizeof(DeviceAnnounce->DeviceDataLength)) {

            TRC_NRM((TB, "Resizing buffer for expected device"
                "size"));

            //
            // Since the DeviceAnnoucePacket include one Device, we need a
            // buffer the size of the packet plus the variable data length
            // DrReallocateChannelBuffer is smart enough not to realloc
            // if we ask for a size <= current buffer size
            //

            cbDesiredBuffer = sizeof(RDPDR_DEVICELIST_ANNOUNCE_PACKET) +
                    DeviceAnnounce->DeviceDataLength;
            TRC_NRM((TB, "DrOnDeviceListAnnounce cbDesiredBuffer is %ld.",
                    cbDesiredBuffer));

            if (cbDesiredBuffer <= DeviceAnnounce->DeviceDataLength) {
                ASSERT(FALSE);
                TRC_ERR((TB, "Invalid Device DataLength %d", DeviceAnnounce->DeviceDataLength));
                return STATUS_UNSUCCESSFUL;
            }

            //
            // Start a read right after the partially received packet with a
            // handler that can update the received size and send it back to this
            // routine to complete.
            //

            if (_Session->ReadMore(cbPacket, cbDesiredBuffer)) {
                return STATUS_SUCCESS;
            } else {
                return STATUS_UNSUCCESSFUL;
            }
        } else {

            //
            // Just ask for some more data, again after the partially received
            // packet
            //

            if (_Session->ReadMore(cbPacket, sizeof(RDPDR_DEVICELIST_ANNOUNCE_PACKET))) {
                return STATUS_SUCCESS;
            } else {
                return STATUS_UNSUCCESSFUL;
            }
        }
    }
}

NTSTATUS DrDeviceManager::OnDeviceRemove(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket,
        BOOL *DoDefaultRead)
/*++

Routine Description:

    Called in response to recognizing a DeviceRemove packet has been
    received.

Arguments:

    RdpdrHeader - The packet
    cbPacket    - Bytes in the packet

--*/
{
    PRDPDR_DEVICE_REMOVE_PACKET DeviceRemovePacket =
            (PRDPDR_DEVICE_REMOVE_PACKET)RdpdrHeader;

    BEGIN_FN("DrDeviceManager::OnDeviceRemove");
    ASSERT(RdpdrHeader != NULL);

    if (cbPacket < sizeof(RDPDR_DEVICE_REMOVE_PACKET)) {
        return STATUS_UNSUCCESSFUL;
    }
    //
    // We just call DrProcessDeviceRemove, which deals with one of these
    // for this packet type and for DeviceListRemove
    //
    
    ProcessDeviceRemove(&DeviceRemovePacket->DeviceRemove);
    *DoDefaultRead = TRUE;
    return STATUS_SUCCESS;
}

NTSTATUS DrDeviceManager::OnDeviceListRemove(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket,
        BOOL *DoDefaultRead)
/*++

Routine Description:

    Called in response to recognizing a DeviceListRemove packet has been
    received. Reads in the DeviceCount field of the packet, and the first
    device.

Arguments:

    RdpdrHeader - The packet
    cbPacket    - Bytes in the packet

Return Value:

    Boolean indication of whether to do a default read (TRUE) or not (FALSE),
    where FALSE might be specified if another read has been requested 
    explicitly to get a full packet

--*/
{
    NTSTATUS Status;
    PRDPDR_DEVICELIST_REMOVE_PACKET DeviceListRemovePacket =
        (PRDPDR_DEVICELIST_REMOVE_PACKET)RdpdrHeader;
    PRDPDR_DEVICE_REMOVE DeviceRemove =
            DR_FIRSTDEVICEREMOVE(DeviceListRemovePacket);
    ULONG DeviceCount = 0;
    PUCHAR pPacketLimit = ((PUCHAR)RdpdrHeader) + cbPacket;
    PUCHAR pCopyTo;
    ULONG cbRemaining;
    ULONG cbDesiredBuffer;
    PRDPDR_DEVICE_REMOVE NextDeviceRemove;

    BEGIN_FN("DrDeviceManager::OnDeviceListRemove");

    ASSERT(_Session != NULL);
    ASSERT(_Session->IsValid());
    ASSERT(RdpdrHeader != NULL);
    ASSERT(RdpdrHeader->Component == RDPDR_CTYP_CORE);
    ASSERT(RdpdrHeader->PacketId == DR_CORE_DEVICELIST_REMOVE);
    TRC_NRM((TB, "OnDeviceListRemove called (%ld)", cbPacket));

    *DoDefaultRead = FALSE;
    if (cbPacket >= sizeof(RDPDR_DEVICELIST_REMOVE_PACKET)) {
        DeviceCount = DeviceListRemovePacket->DeviceListRemove.DeviceCount;
    } else {
        //
        // Not enough data to even know the size of the rest
        // I don't think this should ever happen
        //
        TRC_ASSERT(cbPacket >= sizeof(RDPDR_DEVICELIST_REMOVE_PACKET),
                (TB, "Didn't receive full DeviceListRemove basic packet"));

        if (_Session->ReadMore(cbPacket, sizeof(RDPDR_DEVICELIST_REMOVE_PACKET))) {
            return STATUS_SUCCESS;
        } else {
            return STATUS_UNSUCCESSFUL;
        }
    }

    TRC_NRM((TB, "Removing %lx devices", DeviceCount));

    //
    // Make sure we don't go past the end of our buffer
    // Three checks:
    // 1) More devices to process
    // 2) Pointer is valid enough to check the variable size
    // 3) The next device (the end of this device) is not beyond the valid area
    //

    while (DeviceCount > 0 && 
        ((PUCHAR)(NextDeviceRemove = DR_NEXTDEVICEREMOVE(DeviceRemove)) <= pPacketLimit) &&
        (NextDeviceRemove >= DeviceRemove + 1)) {

        ProcessDeviceRemove(DeviceRemove);

        // Move to the next device
        DeviceRemove = NextDeviceRemove;

        DeviceCount--;
    }

    if (DeviceCount == 0) {
        TRC_NRM((TB, "Finished handling all devices in DeviceList"));

        //
        // All done processing, return TRUE to use default continuation
        //
        *DoDefaultRead = TRUE;
        return STATUS_SUCCESS;
    } else {
        TRC_NRM((TB, "More devices to handle in DeviceList"));

        //
        // We didn't get all the data for the device(s)
        //

        if (DeviceCount < DeviceListRemovePacket->DeviceListRemove.DeviceCount) {

            //
            // We processed at least one device. Move the final partial device
            // up next to the header, update the header to indicate the number
            // of devices left to process,
            //

            TRC_NRM((TB, "Some devices processed, shuffling "
                "DeviceList"));

            // Move partial device
            cbRemaining = (ULONG)(pPacketLimit - ((PUCHAR)DeviceRemove));
            pCopyTo = (PUCHAR)DR_FIRSTDEVICEREMOVE(DeviceListRemovePacket);
            RtlMoveMemory(pCopyTo, DeviceRemove, cbRemaining);

            // update the device count
            DeviceListRemovePacket->DeviceListRemove.DeviceCount = DeviceCount;

            // update the Packet limit for the amount we've consumed
            pPacketLimit = pCopyTo + cbRemaining;
            cbPacket = (ULONG)(pPacketLimit - (PUCHAR)RdpdrHeader);
        }

        //
        // Try to read the remaing device remove entries
        //
        cbDesiredBuffer = sizeof(RDPDR_DEVICE_REMOVE) * DeviceCount;
        TRC_NRM((TB, "DrOnDeviceListRemove cbDesiredBuffer is %ld.",
                cbDesiredBuffer));

        //
        // Start a read right after the partially received packet with a
        // handler that can update the received size and send it back to this
        // routine to complete.
        //

        if (_Session->ReadMore(cbPacket, cbDesiredBuffer)) {
            return STATUS_SUCCESS;
        } else {
            return STATUS_UNSUCCESSFUL;
        }        
    }
}

VOID DrDeviceManager::ProcessDeviceAnnounce(PRDPDR_DEVICE_ANNOUNCE DeviceAnnounce)
/*++

Routine Description:

    Processes a device announce, sends a reply and adds it if appropriate

Arguments:

    DeviceAnnounce - The actual device that was reported

Return Value:

    None

--*/
{
    NTSTATUS Status;
    SmartPtr<DrDevice> Device;
    SmartPtr<DrSession> Session = _Session;
    BOOL bDeviceAdded = FALSE;
    
    BEGIN_FN("DrDeviceManager::ProcessDeviceAnnounce");
    TRC_NRM((TB, "Device contains %ld bytes user data",
            DeviceAnnounce->DeviceDataLength));

    //
    // Check to make sure the device doesn't already exist,
    // if it is a smartcard subsystem device, then it is OK
    // it it already exists
    //

    if (FindDeviceById(DeviceAnnounce->DeviceId, Device) &&
        (DeviceAnnounce->DeviceType != RDPDR_DTYP_SMARTCARD)) {

        //
        // The client announced a device we already knew about. If it was
        // disabled, we can re-enable it and reply with success. If it was
        // not disabled, then the poor client is confused and needs to be
        // swatted down
        //

        TRC_ALT((TB, "Client announced a duplicate device, discarding"));

        //
        // Set DeviceEntry = NULL so error code will be used below
        //
        Device = NULL;
        Status = STATUS_DUPLICATE_OBJECTID;
    } else {
        TRC_NRM((TB, "No duplicate device found"));

        Status = STATUS_INSUFFICIENT_RESOURCES;
        
        switch (DeviceAnnounce->DeviceType)
        {
        case RDPDR_DTYP_SERIAL:
            Device = new(NonPagedPool) DrSerialPort(Session, DeviceAnnounce->DeviceType, 
                    DeviceAnnounce->DeviceId, 
                    DeviceAnnounce->PreferredDosName);
            break;

        case RDPDR_DTYP_PARALLEL:
            Device = new(NonPagedPool) DrParallelPort(Session, DeviceAnnounce->DeviceType, 
                    DeviceAnnounce->DeviceId, 
                    DeviceAnnounce->PreferredDosName);
            break;

        case RDPDR_DTYP_PRINT:
            Device = new(NonPagedPool) DrPrinter(Session, DeviceAnnounce->DeviceType, 
                    DeviceAnnounce->DeviceId, 
                    DeviceAnnounce->PreferredDosName);
            break;

        case RDPDR_DTYP_FILESYSTEM:
            Device = new(NonPagedPool) DrDrive(Session, DeviceAnnounce->DeviceType, 
                    DeviceAnnounce->DeviceId, 
                    DeviceAnnounce->PreferredDosName);
            break;

        case RDPDR_DTYP_SMARTCARD:
            Device = NULL;
            
            if (FindDeviceByDosName(DeviceAnnounce->PreferredDosName, Device, TRUE)  && 
                (Device->GetDeviceType() == RDPDR_DTYP_SMARTCARD)) {
                bDeviceAdded = TRUE;
                Status = STATUS_SUCCESS;                
            }
            else {
                Device = new(NonPagedPool) DrSmartCard(Session, DeviceAnnounce->DeviceType, 
                        DeviceAnnounce->DeviceId, 
                        DeviceAnnounce->PreferredDosName); 
            }
            
            break;

        default:
            //
            // "I don't know and I don't care"
            // We've never heard of this kind of device so we'll reject it
            //

            TRC_ALT((TB, "Client announced unsupported device %d", DeviceAnnounce->DeviceType));
            Status = STATUS_NOT_SUPPORTED;
            Device = NULL;
        }
    }

    //
    // DeviceEntry != NULL means SUCCESS
    //
    
    if (Device != NULL) {
        //
        // Give the specific device a chance to initialize based on the data
        //
        Status = Device->Initialize(DeviceAnnounce, 
                DeviceAnnounce->DeviceDataLength);

    } else {

        TRC_ERR((TB, "Error creating new device: 0x%08lx", Status));

        //
        // Don't set the Status here, it was set up above
        //
    }

    if (NT_SUCCESS(Status)) {
        if (bDeviceAdded || AddDevice(Device)) {
            if (DeviceAnnounce->DeviceType == RDPDR_DTYP_SMARTCARD) {
                SmartPtr<DrSmartCard> SmartCard((DrSmartCard*)(DrDevice *)Device);
                
                SmartCard->ClientConnect(DeviceAnnounce, DeviceAnnounce->DeviceDataLength);                
            }

            Status = STATUS_SUCCESS;
        } 
        else {
            Device = NULL;
            
            //
            // This means another thread has just added the scard device
            //
            if (DeviceAnnounce->DeviceType == RDPDR_DTYP_SMARTCARD &&
                    FindDeviceByDosName(DeviceAnnounce->PreferredDosName, Device, TRUE)) {
                SmartPtr<DrSmartCard> SmartCard((DrSmartCard*)(DrDevice *)Device);
                
                SmartCard->ClientConnect(DeviceAnnounce, DeviceAnnounce->DeviceDataLength);     
                Status = STATUS_SUCCESS;
            }
            else {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }

    //
    // Notify the client of the results
    // 
    DeviceReplyWrite(DeviceAnnounce->DeviceId, Status);
}

VOID DrDeviceManager::ProcessDeviceRemove(PRDPDR_DEVICE_REMOVE DeviceRemove)
/*++

Routine Description:

    Processes a device remove, sends a reply and adds it if appropriate

Arguments:

    DeviceRemove - The actual device that was reported

Return Value:

    None

--*/
{
    SmartPtr<DrDevice> Device;
    SmartPtr<DrSession> Session = _Session;

    BEGIN_FN("DrDeviceManager::ProcessDeviceRemove");
    TRC_NRM((TB, "Device id %ld for removal",
            DeviceRemove->DeviceId));

    //
    // Check to make sure the device exists
    //

    if (FindDeviceById(DeviceRemove->DeviceId, Device)) {

        // 
        // Found the device, now remove it
        //
        Device->Remove();
        RemoveDevice(Device);
        Device = NULL;
        
    } else {
        TRC_ALT((TB, "Client announced an invalid device, discarding"));        
    }    
}

BOOL DrDeviceManager::AddDevice(SmartPtr<DrDevice> &Device)
/*++

Routine Description:

    Adds a completely initialized Device to the list

Arguments:

    Device - The device to be added

Return Value:

    Boolean indicating success

--*/
{
    BOOL rc = FALSE;
    SmartPtr<DrDevice> DeviceFound;

    BEGIN_FN("DrDeviceManager::AddDevice");
    //
    // Explicit AddRef
    //

    ASSERT(Device != NULL);
    ASSERT(Device->IsValid());

    _DeviceList.LockExclusive();

    if (Device->GetDeviceType() == RDPDR_DTYP_SMARTCARD) {
        if (FindDeviceByDosName((UCHAR *)DR_SMARTCARD_SUBSYSTEM, DeviceFound, TRUE)) {
            goto EXIT;
        }
    }

    Device->AddRef();

    //
    // Add it to the list
    //

    if (_DeviceList.CreateEntry((DrDevice *)Device)) {

        //
        // successfully added this entry
        //

        rc = TRUE;
    } else {

        //
        // Unable to add it to the list, clean up
        //
        Device->Release();
        rc = FALSE;
    }

EXIT:

    _DeviceList.Unlock();
    return rc;
}

BOOL DrDeviceManager::FindDeviceById(ULONG DeviceId, 
        SmartPtr<DrDevice> &DeviceFound, BOOL fMustBeValid)
/*++

Routine Description:

    Finds a device in the list

Arguments:

    DeviceId - The id of the device to find
    DeviceFound - The location to store the result
    fMustBeValid - Whether it must be valid for use or can be in any state

Return Value:

    Boolean indicating success

--*/
{
    DrDevice *DeviceEnum;
    ListEntry *ListEnum;
    BOOL Found = FALSE;

    BEGIN_FN("DrDeviceManager::FindDeviceById");
    TRC_NRM((TB, "Id(%lu), %d", DeviceId, fMustBeValid));
    _DeviceList.LockShared();

    ListEnum = _DeviceList.First();
    while (ListEnum != NULL) {

        DeviceEnum = (DrDevice *)ListEnum->Node();
        ASSERT(DeviceEnum->IsValid());

        if (DeviceEnum->GetDeviceId() == DeviceId) {
            TRC_DBG((TB, "Found matching device Id"));
            if (!fMustBeValid || (DeviceEnum->IsAvailable())) {
                DeviceFound = DeviceEnum;
            }

            //
            // These aren't guaranteed valid once the resource is released
            //

            DeviceEnum = NULL;
            ListEnum = NULL;
            break;
        }

        ListEnum = _DeviceList.Next(ListEnum);
    }

    _DeviceList.Unlock();

    return DeviceFound != NULL;
}

BOOL DrDeviceManager::FindDeviceByDosName(UCHAR *DeviceDosName, 
        SmartPtr<DrDevice> &DeviceFound, BOOL fMustBeValid)
/*++

Routine Description:

    Finds a device in the list

Arguments:

    DeviceDosName - The DOS name of the device to find
    DeviceFound - The location to store the result
    fMustBeValid - Whether it must be valid for use or can be in any state

Return Value:

    Boolean indicating success

--*/
{
    DrDevice *DeviceEnum;
    ListEntry *ListEnum;
    BOOL Found = FALSE;

    BEGIN_FN("DrDeviceManager::FindDeviceByDosName");
    TRC_NRM((TB, "DosName(%s), %d", DeviceDosName, fMustBeValid));
    _DeviceList.LockShared();

    ListEnum = _DeviceList.First();
    while (ListEnum != NULL) {

        DeviceEnum = (DrDevice *)ListEnum->Node();
        ASSERT(DeviceEnum->IsValid());

        if (_stricmp((CHAR *)(DeviceEnum->GetDeviceDosName()), (CHAR *)(DeviceDosName)) == 0) {
            TRC_DBG((TB, "Found matching device Dos Name"));
            if (!fMustBeValid || (DeviceEnum->IsAvailable())) {
                DeviceFound = DeviceEnum;
            }

            //
            // These aren't guaranteed valid once the resource is released
            //

            DeviceEnum = NULL;
            ListEnum = NULL;
            break;
        }

        ListEnum = _DeviceList.Next(ListEnum);
    }

    _DeviceList.Unlock();

    return DeviceFound != NULL;
}

VOID DrDeviceManager::Disconnect()
{
    BEGIN_FN("DrDeviceManager::Disconnect");

    RemoveAll();
}

VOID DrDeviceManager::RemoveAll()
{
    DrDevice *DeviceEnum;
    ListEntry *ListEnum;
    BOOL Found = FALSE;

    BEGIN_FN("DrDeviceManager::RemoveAll");
    _DeviceList.LockExclusive();

    ListEnum = _DeviceList.First();
    while (ListEnum != NULL) {

        DeviceEnum = (DrDevice *)ListEnum->Node();
        if (!DeviceEnum->SupportDiscon()) {
            _DeviceList.RemoveEntry(ListEnum);
            DeviceEnum->Remove();
            DeviceEnum->Release();
            ListEnum = _DeviceList.First();
        }
        else {
            DeviceEnum->Disconnect();
            ListEnum = _DeviceList.Next(ListEnum);
        }
    }

    _DeviceList.Unlock();
}

VOID DrDeviceManager::RemoveDevice(SmartPtr<DrDevice> &Device)
{
    DrDevice *DeviceEnum;
    ListEntry *ListEnum;
    BOOL Found = FALSE;

    BEGIN_FN("DrDeviceManager::RemoveDevice");
    
    _DeviceList.LockExclusive();

    ListEnum = _DeviceList.First();
    while (ListEnum != NULL) {

        DeviceEnum = (DrDevice *)ListEnum->Node();
        
        if (DeviceEnum == Device) {
            TRC_DBG((TB, "Found matching device"));
            Found = TRUE;
            break;
        }

        ListEnum = _DeviceList.Next(ListEnum);
    }


    if (Found) {
        _DeviceList.RemoveEntry(ListEnum);
        Device->Release();
    }
    else {
        TRC_DBG((TB, "Not found device for remove"));
    }

    _DeviceList.Unlock();
}

VOID DrDeviceManager::DeviceReplyWrite(ULONG DeviceId, NTSTATUS Result)
/*++

Routine Description:

    Sends a DeviceReply packet to the client

Arguments:

    ClientEntry - Pointer to data about the particular client

Return Value:

    NTSTATUS - Success/failure indication of the operation

--*/
{
    PRDPDR_DEVICE_REPLY_PACKET pDeviceReplyPacket;

    BEGIN_FN("DrDeviceManager::DeviceReplyWrite");

    //
    // Construct the packet
    //

    pDeviceReplyPacket = new RDPDR_DEVICE_REPLY_PACKET;

    if (pDeviceReplyPacket != NULL) {
        pDeviceReplyPacket->Header.Component = RDPDR_CTYP_CORE;
        pDeviceReplyPacket->Header.PacketId = DR_CORE_DEVICE_REPLY;
        pDeviceReplyPacket->DeviceReply.DeviceId = DeviceId;
        pDeviceReplyPacket->DeviceReply.ResultCode = Result;

        //
        //  We use the async send, so don't free the buffer
        //
        _Session->SendToClient(pDeviceReplyPacket, sizeof(RDPDR_DEVICE_REPLY_PACKET),
            this, TRUE);        
    }
}

NTSTATUS DrDeviceManager::SendCompleted(PVOID Context, 
        PIO_STATUS_BLOCK IoStatusBlock)
{
    BEGIN_FN("DrDeviceManager::SendCompleted");
    return IoStatusBlock->Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\device.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    device.h

Abstract:

    Device object handles one redirected device

Revision History:
--*/
#pragma once

class DrSession;
class DrExchange;

typedef enum enmDeviceStatus { // ds
    dsAvailable,
    dsDisabled,
    dsConnected
} DEVICE_STATUS;

class DrDevice : public RefCount, public IExchangeUser
{
protected:
    SmartPtr<DrSession> _Session;
    ULONG _DeviceId;
    ULONG _DeviceType;
    UCHAR _PreferredDosName[PREFERRED_DOS_NAME_SIZE];
    DEVICE_STATUS _DeviceStatus;

    BOOL MarkBusy(SmartPtr<DrExchange> &Exchange);
    VOID MarkIdle(SmartPtr<DrExchange> &Exchange);
    BOOL MarkTimedOut(SmartPtr<DrExchange> &Exchange);
    NTSTATUS VerifyCreateSecurity(PRX_CONTEXT RxContext, ULONG CurrentSessionId);
    VOID FinishCreate(PRX_CONTEXT RxContext);
    NTSTATUS SendIoRequest(IN OUT PRX_CONTEXT RxContext,
            PRDPDR_IOREQUEST_PACKET IoRequest, ULONG Length, 
            BOOLEAN Synchronous, PLARGE_INTEGER TimeOut = NULL, 
            BOOL LowPrioSend = FALSE);
    static NTSTATUS NTAPI MinirdrCancelRoutine(PRX_CONTEXT RxContext);
    
    VOID CompleteBusyExchange(SmartPtr<DrExchange> &Exchange, 
            NTSTATUS Status, ULONG Information);
    static VOID CompleteRxContext(PRX_CONTEXT RxContext, NTSTATUS Status, 
                                     ULONG Information);
    VOID DiscardBusyExchange(SmartPtr<DrExchange> &Exchange);
    virtual NTSTATUS CreateDevicePath(PUNICODE_STRING DevicePath);
    virtual NTSTATUS CreateDosDevicePath(PUNICODE_STRING DosDevicePath, 
                                           PUNICODE_STRING DosDeviceName);
    NTSTATUS CreateDosSymbolicLink(PUNICODE_STRING DosDeviceName);
    virtual BOOL IsDeviceNameValid() {return TRUE;}

public:

#if DBG
    BOOL  _VNetRootFinalized;
    PVOID _VNetRoot;
#endif

    DrDevice(SmartPtr<DrSession> &Session, ULONG DeviceType, ULONG DeviceId, PUCHAR PreferredDosName);
    virtual ~DrDevice();
    virtual NTSTATUS Initialize(PRDPDR_DEVICE_ANNOUNCE DeviceAnnounce, ULONG Length);
    virtual BOOL ShouldCreateDevice();

    VOID CreateReferenceString(
        IN OUT PUNICODE_STRING refString
    );

    virtual VOID Remove();

    virtual BOOL SupportDiscon() {
        return FALSE;
    }

    virtual void Disconnect() { }
    
    virtual NTSTATUS OnDevMgmtEventCompletion(PVOID event) 
    {
        return STATUS_SUCCESS;
    }

    virtual NTSTATUS OnDevMgmtEventCompletion(IN PDEVICE_OBJECT DeviceObject, PVOID event) 
    {
        return STATUS_SUCCESS;
    }	

    virtual BOOL IsAvailable()
    {
        return _DeviceStatus == dsAvailable;
    }
    void SetDeviceStatus(DEVICE_STATUS dsStatus)
    {
        _DeviceStatus = dsStatus;
    }
    ULONG GetDeviceId()
    {
        return _DeviceId;
    }
    UCHAR* GetDeviceDosName() 
    {
        return _PreferredDosName;
    }
    ULONG GetDeviceType()
    {
        return _DeviceType;
    }
    SmartPtr<DrSession> GetSession() 
    {
        return _Session;
    }

    virtual NTSTATUS Create(IN OUT PRX_CONTEXT RxContext);
    NTSTATUS Flush(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS Write(IN OUT PRX_CONTEXT RxContext, IN BOOL LowPrioSend = FALSE);
    NTSTATUS Read(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS IoControl(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS Close(IN OUT PRX_CONTEXT RxContext);
    NTSTATUS Cleanup(IN OUT PRX_CONTEXT RxContext);
    
    //
    // These are file system specific functions.  
    //
    virtual NTSTATUS Locks(IN OUT PRX_CONTEXT RxContext) {
        return STATUS_NOT_IMPLEMENTED;
    }
    virtual NTSTATUS QueryDirectory(IN OUT PRX_CONTEXT RxContext) {
        return STATUS_NOT_IMPLEMENTED;
    }
    virtual NTSTATUS NotifyChangeDirectory(IN OUT PRX_CONTEXT RxContext) {
        return STATUS_NOT_IMPLEMENTED;
    }
    virtual NTSTATUS QueryVolumeInfo(IN OUT PRX_CONTEXT RxContext) {
        return STATUS_NOT_IMPLEMENTED;
    }
    virtual NTSTATUS SetVolumeInfo(IN OUT PRX_CONTEXT RxContext) {
        return STATUS_NOT_IMPLEMENTED;
    }
    virtual NTSTATUS QueryFileInfo(IN OUT PRX_CONTEXT RxContext) {
        return STATUS_NOT_IMPLEMENTED;
    }
    virtual NTSTATUS SetFileInfo(IN OUT PRX_CONTEXT RxContext) {
        return STATUS_NOT_IMPLEMENTED;
    }
    virtual NTSTATUS QuerySdInfo(IN OUT PRX_CONTEXT RxContext) {
        return STATUS_NOT_IMPLEMENTED;
    }
    virtual NTSTATUS SetSdInfo(IN OUT PRX_CONTEXT RxContext) {
        return STATUS_NOT_IMPLEMENTED;
    }
    virtual VOID NotifyClose();
    
    //
    // IExchangeUser methods
    //
    virtual VOID OnIoDisconnected(SmartPtr<DrExchange> &Exchange);
    virtual NTSTATUS OnStartExchangeCompletion(SmartPtr<DrExchange> &Exchange, 
            PIO_STATUS_BLOCK IoStatusBlock);
    virtual NTSTATUS OnDeviceIoCompletion(
            PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket,
            BOOL *DoDefaultRead, SmartPtr<DrExchange> &Exchange);
    NTSTATUS OnCreateCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    NTSTATUS OnWriteCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    NTSTATUS OnReadCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    virtual NTSTATUS OnDeviceControlCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    
    //
    // These are file system specific functions
    //
    virtual NTSTATUS OnLocksCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange) {
        ASSERT(FALSE);
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    virtual NTSTATUS OnDirectoryControlCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange) {
        ASSERT(FALSE);
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    virtual NTSTATUS OnQueryVolumeInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange) {
        ASSERT(FALSE);
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    virtual NTSTATUS OnSetVolumeInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange) {
        ASSERT(FALSE);
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    virtual NTSTATUS OnQueryFileInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange) {
        ASSERT(FALSE);
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    virtual NTSTATUS OnSetFileInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange) {
        ASSERT(FALSE);
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    virtual NTSTATUS OnQuerySdInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange) {
        ASSERT(FALSE);
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
    virtual NTSTATUS OnSetSdInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange) {
        ASSERT(FALSE);
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
};

class DrIoContext : public TopObj
{
public:
    DrIoContext(PRX_CONTEXT RxContext, SmartPtr<DrDevice> &Device);
    SmartPtr<DrDevice> _Device;
    BOOL _Busy;
    BOOL _Cancelled;
    BOOL _Disconnected;
    BOOL _TimedOut;
    ULONG _DataCopied;
    PRX_CONTEXT _RxContext;
    UCHAR _MajorFunction;
    UCHAR _MinorFunction;

#define DRIOCONTEXT_SUBTAG 'CIrD'
    //
    //  Memory Management Operators
    //
    inline void *__cdecl operator new(size_t sz) 
    {
        return DRALLOCATEPOOL(NonPagedPool, sz, DRIOCONTEXT_SUBTAG);
    }

    inline void __cdecl operator delete(void *ptr)
    {
        DRFREEPOOL(ptr);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\devmgr.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name :

    devmgr.h

Abstract:

    DeviceManager object creates/manages the devices

Revision History:
--*/
#pragma once

class DrDeviceManager : public TopObj, public ISessionPacketReceiver, 
        public ISessionPacketSender
{
private:
    DoubleList _DeviceList;
    
    DrSession *_Session;

    VOID ProcessDeviceAnnounce(PRDPDR_DEVICE_ANNOUNCE DeviceAnnounce);
    NTSTATUS OnDeviceAnnounce(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket, 
            BOOL *DoDefaultRead);
    NTSTATUS OnDeviceListAnnounce(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket, 
            BOOL *DoDefaultRead);
    VOID ProcessDeviceRemove(PRDPDR_DEVICE_REMOVE DeviceRemove);
    NTSTATUS OnDeviceRemove(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket, 
            BOOL *DoDefaultRead);
    NTSTATUS OnDeviceListRemove(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket, 
            BOOL *DoDefaultRead);
    VOID DeviceReplyWrite(ULONG DeviceId, NTSTATUS Result);

public:
    DrDeviceManager();
    virtual ~DrDeviceManager();

    BOOL FindDeviceById(ULONG DeviceId, SmartPtr<DrDevice> &DeviceFound,
            BOOL fMustBeValid = FALSE);
    BOOL FindDeviceByDosName(UCHAR* DeviceDosName, SmartPtr<DrDevice> &DeviceFound,
            BOOL fMustBeValid = FALSE);

    DoubleList &GetDevList() {
        return _DeviceList;
    }

    VOID Disconnect();
    VOID RemoveAll();
    
    BOOL Initialize(DrSession *Session);
    VOID Uninitialize();

    BOOL AddDevice(SmartPtr<DrDevice> &Device);
    VOID RemoveDevice(SmartPtr<DrDevice> &Device);

    //
    // ISessionPacketHandler methods
    //

    virtual BOOL RecognizePacket(PRDPDR_HEADER RdpdrHeader);
    virtual NTSTATUS HandlePacket(PRDPDR_HEADER RdpdrHeader, ULONG Length, 
            BOOL *DoDefaultRead);

    //
    // ISessionPacketSender methods
    //
    virtual NTSTATUS SendCompleted(PVOID Context, 
            PIO_STATUS_BLOCK IoStatusBlock);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\drioctl.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    drioctl.cpp

Abstract:

    This module implements IOCTL handling specific to the Dr (as opposed to
    the devices it redirects). This includes rdpwsx notification for clients
    coming and going, and start/stop service requests.

Environment:

    Kernel mode

--*/

#include "precomp.hxx"
#define TRC_FILE "drioctl"
#include "trc.h"

#include <kernutil.h>
#include <rdpdr.h>
#include <rdpnp.h>

#define DR_STARTABLE 0
#define DR_STARTING  1
#define DR_STARTED   2

extern PRDBSS_DEVICE_OBJECT DrDeviceObject;                            
#define RxNetNameTable (*(DrDeviceObject->pRxNetNameTable))

LONG DrStartStatus = DR_STARTABLE;

NTSTATUS
DrDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine handles all the device FCB related FSCTL's in the mini rdr.
    Which is to say this handles IOCTLs for this driver instead of what we're
    redirecting.

Arguments:

    RxContext - Describes the Fsctl and Context.

Return Value:

    a valid NTSTATUS code.

Notes:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFobx;
    UCHAR MajorFunctionCode  = RxContext->MajorFunction;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG ControlCode = LowIoContext->ParamsFor.FsCtl.FsControlCode;

    BEGIN_FN("DrDevFcbXXXControlFile");

    switch (MajorFunctionCode) {
    case IRP_MJ_FILE_SYSTEM_CONTROL:
        {
            switch (LowIoContext->ParamsFor.FsCtl.MinorFunction) {
            case IRP_MN_USER_FS_REQUEST:
                switch (ControlCode) {
                
                case FSCTL_DR_ENUMERATE_CONNECTIONS:
                    {
                        Status = DrEnumerateConnections(RxContext);
                    }
                    break;

                case FSCTL_DR_ENUMERATE_SHARES:
                    {
                        Status = DrEnumerateShares(RxContext);
                    }
                    break;

                case FSCTL_DR_ENUMERATE_SERVERS:
                    {
                        Status = DrEnumerateServers(RxContext);
                    }
                    break;

                case FSCTL_DR_GET_CONNECTION_INFO:
                    if (capFobx) {
                        Status = DrGetConnectionInfo(RxContext);
                    }
                    else {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                    }
                    break;

                case FSCTL_DR_DELETE_CONNECTION:
                    if (capFobx) {
                        Status = DrDeleteConnection(RxContext, &RxContext->PostRequest);
                    }
                    else {
                        Status = STATUS_INVALID_DEVICE_REQUEST;
                    }
                    break;

                default:
                    Status = STATUS_INVALID_DEVICE_REQUEST;
                    RxContext->pFobx = NULL;
                }
                break;
            default :  //minor function != IRP_MN_USER_FS_REQUEST
                Status = STATUS_INVALID_DEVICE_REQUEST;
                RxContext->pFobx = NULL;
            }
        } // FSCTL case
        break;
    case IRP_MJ_DEVICE_CONTROL:
        switch (LowIoContext->ParamsFor.FsCtl.IoControlCode) {
            case IOCTL_CHANNEL_CONNECT:
                Status = DrOnSessionConnect(RxContext);
                break;
    
            case IOCTL_CHANNEL_DISCONNECT:
                Status = DrOnSessionDisconnect(RxContext);
                break;
    
            default:
                Status = STATUS_INVALID_DEVICE_REQUEST;            
                RxContext->pFobx = NULL;
        }
        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        {
            // warning C4065: switch statement contains 'default' but no 'case' labels
            //switch (ControlCode) {
            //default :
                Status = STATUS_INVALID_DEVICE_REQUEST;
                RxContext->pFobx = NULL;
            //}
        }
        break;
    default:
        TRC_ASSERT(FALSE, (TB, "unimplemented major function"));
        Status = STATUS_INVALID_DEVICE_REQUEST;
        RxContext->pFobx = NULL;
    }

    TRC_NRM((TB, "MRxIfsDevFcb st,info=%08lx,%08lx",
                            Status,RxContext->InformationToReturn));

    return(Status);
}

NTSTATUS
DrOnSessionConnect(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:
    Called when we a session is connected for the first time. Searches the
    list of virtual channels for our channel name, and opens the channel if
    it is found.

Arguments:
    RxContext - Context information about the IOCTL call

Return Value:
    STATUS_SUCCESS - Successful operation
    STATUS_INSUFFICIENT_RESOURCES - Out of memory

--*/
{
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    PCHANNEL_CONNECT_IN ConnectIn =
        (PCHANNEL_CONNECT_IN)LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    PCHANNEL_CONNECT_OUT ConnectOut =
        (PCHANNEL_CONNECT_OUT)LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
    PCHANNEL_CONNECT_DEF Channels = (PCHANNEL_CONNECT_DEF)(ConnectIn + 1);

    BEGIN_FN("DrOnSessionConnect");
    
    __try {

        ProbeForRead(ConnectIn, sizeof(CHANNEL_CONNECT_IN), sizeof(BYTE));
        ProbeForWrite(ConnectOut, sizeof(CHANNEL_CONNECT_OUT), sizeof(BYTE));

        TRC_ASSERT(ConnectIn != NULL, (TB, "ConnectIn != NULL"));
        TRC_NRM((TB, "Session ID %ld", ConnectIn->hdr.sessionID));
    
        //
        // Basic parameter validation
        //
    
        if ((LowIoContext->ParamsFor.FsCtl.pInputBuffer == NULL) ||
            (LowIoContext->ParamsFor.FsCtl.InputBufferLength < sizeof(CHANNEL_CONNECT_IN)) ||
            (LowIoContext->ParamsFor.FsCtl.OutputBufferLength < sizeof(UINT_PTR)) ||
            (LowIoContext->ParamsFor.FsCtl.pOutputBuffer == NULL)) {
    
            TRC_ERR((TB, "Received invalid pramater for SessionCreate IOCTL"));
            return STATUS_INVALID_PARAMETER;
        }
    
        //
        // Make sure the Minirdr is started
        //
    
        DrStartMinirdr(RxContext);
    
        ASSERT(Sessions != NULL);
        Sessions->OnConnect(ConnectIn, ConnectOut);
    
        // While we may have sadly failed somewhere along the way, if we want
        // rdpwsx to save our context out, we must return STATUS_SUCCESS
        return STATUS_SUCCESS;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        TRC_NRM((TB, "Error accessing buffer in DrOnSessionConnect"));
        return GetExceptionCode();
    }
}

NTSTATUS
DrOnSessionDisconnect(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:
    Called when we a session is ended. Searches the list of clients, and
    initiates a shutdown of each of those information sets.

Arguments:
    RxContext - Context information about the IOCTL call

Return Value:
    STATUS_SUCCESS - Successful operation
    STATUS_INSUFFICIENT_RESOURCES - Out of memory

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    PCHANNEL_DISCONNECT_IN DisconnectIn =
        (PCHANNEL_DISCONNECT_IN)LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    PCHANNEL_DISCONNECT_OUT DisconnectOut =
        (PCHANNEL_DISCONNECT_OUT)LowIoContext->ParamsFor.FsCtl.pOutputBuffer;

    BEGIN_FN("DrOnSessionDisconnect");

    __try {

        ProbeForRead(DisconnectIn, sizeof(CHANNEL_DISCONNECT_IN), sizeof(BYTE));
        ProbeForWrite(DisconnectOut, sizeof(CHANNEL_DISCONNECT_OUT), sizeof(BYTE));

        //
        // Basic parameter validation
        //
    
        if ((LowIoContext->ParamsFor.FsCtl.pOutputBuffer == NULL) ||
            (LowIoContext->ParamsFor.FsCtl.InputBufferLength < sizeof(CHANNEL_DISCONNECT_IN)) ||
            (LowIoContext->ParamsFor.FsCtl.OutputBufferLength < sizeof(UINT_PTR)) ||
            (LowIoContext->ParamsFor.FsCtl.pOutputBuffer == NULL)) {
    
            TRC_ERR((TB, "Received invalid pramater for SessionClose IOCTL"));
            return STATUS_INVALID_PARAMETER;
        }
    
        ASSERT(Sessions != NULL);
        Sessions->OnDisconnect(DisconnectIn, DisconnectOut);
    
        // While we may have sadly failed somewhere along the way, if we want
        // rdpwsx to save our context out, we must return STATUS_SUCCESS
        return STATUS_SUCCESS;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        TRC_NRM((TB, "Error accessing buffer in DrOnSessionDisconnect"));
        return GetExceptionCode();
    }
}

VOID
DrStartMinirdr(
    PRX_CONTEXT RxContext
    )
/*++

Routine Description:
    We use this to start the minirdr. Checks if the work is needed and 
    kicks off a system thread if we need to.

Arguments:
    None

Return Value:
    None

--*/
{
    NTSTATUS Status;
    HANDLE ThreadHandle;
    PVOID Thread = NULL;

    BEGIN_FN("DrStartMinirdr");
    //
    // Make sure it needs to be started, and start it if we can
    //
    if (InterlockedCompareExchange(&DrStartStatus, DR_STARTING, DR_STARTABLE) == DR_STARTABLE) {
        //
        // We need to call RxStartMinirdr from the system process
        //

        Status = PsCreateSystemThread(&ThreadHandle, THREAD_ALL_ACCESS, NULL,
            NULL, NULL, DrStartMinirdrWorker, RxContext);


        //
        // Get a pointer to the thread
        //
        if (NT_SUCCESS(Status)) {
            Status = ObReferenceObjectByHandle(ThreadHandle, 
                    THREAD_ALL_ACCESS, NULL, KernelMode, &Thread, NULL);
            ZwClose(ThreadHandle);
        }

        //
        // Wait on the thread pointer
        //
        if (NT_SUCCESS(Status)) {
            KeWaitForSingleObject(Thread, UserRequest, KernelMode, FALSE, NULL);
            ObfDereferenceObject(Thread);
        }

    }
}

VOID
DrStartMinirdrWorker(
    IN PVOID StartContext
    )
/*++

Routine Description:
    We use this to start the minirdr. Checks if the work is needed and 
    kicks off a system thread if we need to.

Arguments:
    None

Return Value:
    None

--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext2;
    PRX_CONTEXT RxContext = (PRX_CONTEXT)StartContext;

    BEGIN_FN("DrStartMinirdrWorker");
    RxContext2 = RxCreateRxContext(
                    NULL,
                    RxContext->RxDeviceObject,
                    RX_CONTEXT_FLAG_IN_FSP);

    //
    // Start Redirecting
    //
    if (RxContext2 != NULL) {
        Status = RxStartMinirdr(RxContext2, &RxContext2->PostRequest);

        TRC_NRM((TB, "RxStartMinirdr returned: %lx", Status));

        RxDereferenceAndDeleteRxContext(RxContext2);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(Status)) {
        InterlockedExchange(&DrStartStatus, DR_STARTED);
    } else {
        InterlockedCompareExchange(&DrStartStatus, DR_STARTABLE, 
                DR_STARTING);
    }

    PsTerminateSystemThread(Status);
}


NTSTATUS
DrDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    )
/*++

Routine Description:

    This routine deletes a single vnetroot.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context.

Return Value:

NTSTATUS

--*/
{
    NTSTATUS Status;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    RxCaptureFobx;
    PNET_ROOT NetRoot;
    PV_NET_ROOT VNetRoot;

    BEGIN_FN("DrDeleteConnection");

    BOOLEAN Wait   = BooleanFlagOn(RxContext->Flags, RX_CONTEXT_FLAG_WAIT);
    
    TRC_NRM((TB, "Request DrDeleteConnection"));

    if (!Wait) {
        TRC_NRM((TB, "WAIT flag is not on for DeleteConnection"));

        //just post right now!
        *PostToFsp = TRUE;
        return STATUS_PENDING;
    }

    __try
    {
        if (NodeType(capFobx)==RDBSS_NTC_V_NETROOT) {
            VNetRoot = (PV_NET_ROOT)capFobx;
            NetRoot = (PNET_ROOT)((PMRX_V_NET_ROOT)VNetRoot->pNetRoot);
        } else {
            TRC_ASSERT((FALSE), (TB, "Not VNet Root"));
            try_return(Status = STATUS_INVALID_DEVICE_REQUEST);            
        }

        Status = RxFinalizeConnection(NetRoot,VNetRoot,TRUE);
        TRC_NRM((TB, "RxFinalizeConnection returned %lx", Status));

        try_return(Status);

try_exit:NOTHING;

    }
    __except (EXCEPTION_EXECUTE_HANDLER) 
    {
        TRC_NRM((TB, "Error accessing capFobx in DrDeleteConnection"));
    }

    return Status;
}

BOOLEAN
DrPackStringIntoInfoBuffer(
    IN OUT PRDPDR_UNICODE_STRING String,
    IN     PUNICODE_STRING Source,
    IN     PCHAR   BufferStart,
    IN OUT PCHAR * BufferEnd,
    IN     ULONG   BufferDisplacement,
    IN OUT PULONG TotalBytes
    )
/*

Routine Description:

    This code copies a string to the end of the buffer IF THERE'S ROOM. the buffer
    displacement is used to map the buffer back into the user's space in case we
    have posted.

Arguments:

Return Value:

*/
{
    LONG size;

    BEGIN_FN("DrPackStringIntoInfoBuffer");

    TRC_ASSERT((BufferStart <= *BufferEnd), 
               (TB, "Invalid BufferStart %p, Buffer End %p", BufferStart, *BufferEnd));

    //
    //  is there room for the string?
    //
    size = Source->Length;

    if ((*BufferEnd - BufferStart) < size) {
        String->Length = 0;
        return FALSE;
    } else {
        //
        //  Copy the source string to the end of the buffer and store 
        //  the buffer pointer in output string accordingly
        //
        String->Length = Source->Length;
        String->MaximumLength = Source->Length;

        *BufferEnd -= size;
        if (TotalBytes != NULL) { *TotalBytes += size; }
        RtlCopyMemory(*BufferEnd, Source->Buffer, size);
        String->BufferOffset = (LONG)((LONG_PTR)((PCHAR)(*BufferEnd) - (PCHAR)(BufferStart)));
        String->BufferOffset = String->BufferOffset - BufferDisplacement;
        return TRUE;
    }
}

BOOLEAN
DrPackConnectEntry (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PCHAR *BufferStart,
    IN OUT PCHAR *BufferEnd,
    IN     PV_NET_ROOT VNetRoot,
    IN OUT ULONG   BufferDisplacement,
       OUT PULONG TotalBytesNeeded
    )
/*++

Routine Description:

    This routine packs a connectlistentry into the buffer provided updating
    all relevant pointers. The way that this works is that constant length stuff is
    copied to the front of the buffer and variable length stuff to the end. The
    "start and end" pointers are updated. You have to calculate the totalbytes correctly
    no matter what but a last can be setup incompletely as long as you return false.

    the way that this works is that it calls down into the minirdr on the devfcb
    interface. it calls down twice and passes a structure back and forth thru the
    context to maintain state.

Arguments:

    IN OUT PCHAR *BufferStart - Supplies the output buffer.
                                Updated to point to the next buffer
                                
    IN OUT PCHAR *BufferEnd - Supplies the end of the buffer.  Updated to
                              point before the start of the strings being packed.
                              
    IN PVNET_ROOT NetRoot - Supplies the VNetRoot to enumerate.

    IN OUT PULONG TotalBytesNeeded - Updated to account for the length of this
                                     entry

Return Value:

    BOOLEAN - True if the entry was successfully packed into the buffer.

--*/
{
    NTSTATUS Status;
    BOOLEAN ReturnValue = TRUE;

    UNICODE_STRING Name;  
    ULONG BufferSize;
    PRDPDR_CONNECTION_INFO ConnectionInfo = (PRDPDR_CONNECTION_INFO)*BufferStart;
    PNET_ROOT NetRoot = (PNET_ROOT)(((PMRX_V_NET_ROOT)VNetRoot)->pNetRoot);
    PUNICODE_STRING VNetRootName = &VNetRoot->PrefixEntry.Prefix;
    PCHAR ConnectEntryStart;
    
    BEGIN_FN("DrPackConnectEntry");

    // 
    //  We want the connection name to have string null terminator
    //
    Name.Buffer = (PWCHAR)RxAllocatePoolWithTag(NonPagedPool, 
            MAX_PATH, DR_POOLTAG);

    if ( Name.Buffer == NULL ) {
        return FALSE;
    }

    BufferSize = sizeof(RDPDR_CONNECTION_INFO);
    ConnectEntryStart = *BufferStart;

    __try {
        //
        // Account for the constant length stuff
        //
        *BufferStart = ((PCHAR)*BufferStart) + BufferSize;
        *TotalBytesNeeded += BufferSize;

        //
        //  Initialize the name to "\" then add in the rest of the connection name
        //

        Name.Length = NetRoot->PrefixEntry.Prefix.Length + sizeof(WCHAR);
        Name.MaximumLength = Name.Length;

        ASSERT(Name.Length <= MAX_PATH);

        Name.Buffer[0] = L'\\';
        RtlCopyMemory(&Name.Buffer[1], NetRoot->PrefixEntry.Prefix.Buffer, 
                NetRoot->PrefixEntry.Prefix.Length);
        
        //
        //  Update the total number of bytes needed for this structure.
        //

        *TotalBytesNeeded += Name.Length;

        if (*BufferStart > *BufferEnd) {
            try_return(ReturnValue = FALSE);
        }

        if ((*BufferEnd - *BufferStart) < Name.Length) {
                ConnectionInfo->RemoteName.Length = 0;
                try_return( ReturnValue = FALSE);
        }    
        else if (!DrPackStringIntoInfoBuffer(
                &ConnectionInfo->RemoteName,
                &Name,
                ConnectEntryStart,
                BufferEnd,
                BufferDisplacement,
                NULL)) {

            try_return( ReturnValue = FALSE);
        }

        //
        //  Setup the local name
        //
        if (VNetRootName->Buffer[2] != L':') {
            Name.Buffer[0] = towupper(VNetRootName->Buffer[2]);
            Name.Buffer[1] = L':';
            Name.Buffer[2] = L'\0';
            Name.Length = sizeof(WCHAR) * 2;
            Name.MaximumLength = Name.Length;
            
            //
            //  Update the total number of bytes needed for this structure.
            //
    
            *TotalBytesNeeded += Name.Length;

            if (*BufferStart > *BufferEnd) {
                try_return(ReturnValue = FALSE);
            }
    
                
            if ((*BufferEnd - *BufferStart) < Name.Length) {
                ConnectionInfo->LocalName.Length = 0;
                try_return( ReturnValue = FALSE);
            }
            else if (!DrPackStringIntoInfoBuffer(
                    &ConnectionInfo->LocalName,
                    &Name,
                    ConnectEntryStart,
                    BufferEnd,
                    BufferDisplacement,
                    NULL)) {
    
                try_return( ReturnValue = FALSE);
            }
        }
        else {
            ConnectionInfo->LocalName.Length = 0;
            ConnectionInfo->LocalName.BufferOffset = 0;
        }

        ConnectionInfo->ResumeKey = NetRoot->SerialNumberForEnum;
        ConnectionInfo->SharedResourceType = NetRoot->DeviceType;
        ConnectionInfo->ConnectionStatus = NetRoot->MRxNetRootState;
        ConnectionInfo->NumberFilesOpen = NetRoot->NumberOfSrvOpens;


        //TRC_NRM((TB, "PackConnection data---> Remote Local Type Key Status Numfiles %wZ %wZ %08lx %08lx %08lx %08lx\n",
        //                    &(ConnectionInfo->RemoteName),
        //                    ConnectionInfo->LocalName.BufferOffset ? &Name : NULL,
        //                    ConnectionInfo->SharedResourceType,
        //                    ConnectionInfo->ResumeKey,
        //                    ConnectionInfo->ConnectionStatus,
        //                    ConnectionInfo->NumberFilesOpen));

    try_exit:
        RxFreePool(Name.Buffer);
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) {
        RxFreePool(Name.Buffer);
        return FALSE;
    }
    
    return ReturnValue;
}


NTSTATUS
DrEnumerateConnections (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine enumerates the connections on minirdr. 
    
Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context

Return Value:

NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    PRDPDR_REQUEST_PACKET InputBuffer = (PRDPDR_REQUEST_PACKET)(LowIoContext->ParamsFor.FsCtl.pInputBuffer);
    PCHAR OriginalOutputBuffer = (PCHAR)(LowIoContext->ParamsFor.FsCtl.pOutputBuffer);
    ULONG OutputBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    PCHAR OutputBuffer;
    ULONG BufferDisplacement;

    ULONG ResumeHandle;

    PCHAR BufferStart;
    PCHAR BufferEnd;
    PCHAR PreviousBufferStart;

    PLIST_ENTRY ListEntry;
    ULONG SessionId, IrpSessionId;
    BOOLEAN TableLockHeld = FALSE;
    
    BEGIN_FN("DrEnumerateConnections");

    OutputBuffer = (PCHAR)RxMapUserBuffer( RxContext, RxContext->CurrentIrp );
    BufferDisplacement = (ULONG)(OutputBuffer - OriginalOutputBuffer);
    BufferStart = OutputBuffer;
    BufferEnd = OutputBuffer + OutputBufferLength;

    Status = IoGetRequestorSessionId(RxContext->CurrentIrp, &IrpSessionId);
    if (!NT_SUCCESS(Status)) {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if (InputBuffer == NULL || OutputBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (RxContext->CurrentIrp->RequestorMode != KernelMode) {
        TRC_ASSERT((BufferDisplacement == 0), 
                   (TB, "Request mode is not kernel, non zero Displacement"));

        __try {
            ProbeForWrite(InputBuffer,InputBufferLength,sizeof(UCHAR));
            ProbeForWrite(OutputBuffer,OutputBufferLength,sizeof(UCHAR));
        } 
        __except (EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    __try {

        if (InputBufferLength < sizeof(RDPDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        ResumeHandle = InputBuffer->Parameters.Get.ResumeHandle;
        SessionId = InputBuffer->SessionId;

        if (SessionId != IrpSessionId) {
            try_return(Status = STATUS_INVALID_PARAMETER);
        }

        InputBuffer->Parameters.Get.EntriesRead = 0;
        InputBuffer->Parameters.Get.TotalEntries = 0;
        InputBuffer->Parameters.Get.TotalBytesNeeded = 0;

        RxAcquirePrefixTableLockExclusive(&RxNetNameTable, TRUE);
        TableLockHeld = TRUE;

        if (IsListEmpty(&RxNetNameTable.MemberQueue)) {
            try_return(Status = STATUS_SUCCESS);
        }

        //must do the list forwards!
        ListEntry = RxNetNameTable.MemberQueue.Flink;
        for (;ListEntry != &RxNetNameTable.MemberQueue;) {
            PVOID Container;
            PRX_PREFIX_ENTRY PrefixEntry;
            PNET_ROOT NetRoot;
            PV_NET_ROOT VNetRoot;
            PUNICODE_STRING VNetRootName;

            PrefixEntry = CONTAINING_RECORD(ListEntry, RX_PREFIX_ENTRY, MemberQLinks);
            ListEntry = ListEntry->Flink;
            TRC_ASSERT((NodeType(PrefixEntry) == RDBSS_NTC_PREFIX_ENTRY),
                       (TB, "Invalid PrefixEntry type"));
            Container = PrefixEntry->ContainingRecord;

            switch (NodeType(Container)) {
            case RDBSS_NTC_NETROOT :
                continue;

            case RDBSS_NTC_SRVCALL :
                continue;

            case RDBSS_NTC_V_NETROOT :
                VNetRoot = (PV_NET_ROOT)Container;
                NetRoot = (PNET_ROOT)(((PMRX_V_NET_ROOT)VNetRoot)->pNetRoot);
                VNetRootName = &VNetRoot->PrefixEntry.Prefix;

                TRC_NRM((TB, "SerialNum: %x, VNetRootName = %wZ, Condition = %d, SessionId = %d, IsExplicit = %d",
                         VNetRoot->SerialNumberForEnum, 
                         VNetRootName, 
                         VNetRoot->Condition, 
                         VNetRoot->SessionId,
                         VNetRoot->IsExplicitConnection));

                if ((VNetRoot->SerialNumberForEnum >= ResumeHandle) && 
                    (VNetRoot->Condition == Condition_Good) &&
                    (SessionId == VNetRoot->SessionId) && 
                    (VNetRoot->IsExplicitConnection == TRUE)) {
                    break;
                } else {
                    continue;
                }

            default:
                continue;
            }

            InputBuffer->Parameters.Get.TotalEntries ++ ;

            PreviousBufferStart = BufferStart;
            if (DrPackConnectEntry(RxContext,
                                   &BufferStart,
                                   &BufferEnd,
                                   VNetRoot,
                                   BufferDisplacement,
                                   &InputBuffer->Parameters.Get.TotalBytesNeeded)) {
                InputBuffer->Parameters.Get.EntriesRead ++ ;
            } else {
                // We want to continue the enumeration even pack connection
                // entry failed, because we want to enumerate the total bytes
                // needed and inform the user mode program
                Status = STATUS_BUFFER_TOO_SMALL;
                continue;
            }
        }

        try_return(Status);

try_exit:
        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
            TableLockHeld = FALSE;
        }
    } 
    __except (EXCEPTION_EXECUTE_HANDLER) {

        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
            TableLockHeld = FALSE;
        }
        return STATUS_INVALID_PARAMETER;
    }

    return Status;
}


NTSTATUS
DrGetConnectionInfo (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine gets the connection info for a single vnetroot.

    There is some happiness here about the output buffer. What happens is that we
    pick up the output buffer in the usual way. However, there are all sorts of
    pointers in the return structure and these pointers must obviously be in terms
    of the original process. so, if we post then we have to apply a fixup!

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context

Return Value:

   STATUS_SUCCESS if successful

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    RxCaptureFobx;

    PRDPDR_REQUEST_PACKET InputBuffer = (PRDPDR_REQUEST_PACKET)LowIoContext->ParamsFor.FsCtl.pInputBuffer;
    PCHAR OriginalOutputBuffer = (PCHAR)LowIoContext->ParamsFor.FsCtl.pOutputBuffer;
    ULONG OutputBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    PCHAR OutputBuffer;
    ULONG BufferDisplacement;

    PCHAR BufferStart;
    PCHAR OriginalBufferStart;
    PCHAR BufferEnd;

    BOOLEAN TableLockHeld = FALSE;

    PNET_ROOT   NetRoot;
    PV_NET_ROOT VNetRoot;
    
    BEGIN_FN("DrGetConnectionInfo");

    OutputBuffer = (PCHAR)RxMapUserBuffer( RxContext, RxContext->CurrentIrp );
    BufferDisplacement = (ULONG)(OutputBuffer - OriginalOutputBuffer);
    BufferStart = OutputBuffer;
    OriginalBufferStart = BufferStart;
    BufferEnd = OutputBuffer+OutputBufferLength;

    if (RxContext->CurrentIrp->RequestorMode != KernelMode) {
        TRC_ASSERT((BufferDisplacement == 0), 
                   (TB, "Request mode is not kernel, non zero Displacement"));
        __try {
            ProbeForWrite(InputBuffer,InputBufferLength,sizeof(UCHAR));
            ProbeForWrite(OutputBuffer,OutputBufferLength,sizeof(UCHAR));
        } 
        __except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    __try {
        TRC_ASSERT((NodeType(capFobx)==RDBSS_NTC_V_NETROOT), (TB, "Invalid Node type"));

        VNetRoot = (PV_NET_ROOT)capFobx;
        NetRoot = (PNET_ROOT)((PMRX_V_NET_ROOT)VNetRoot->pNetRoot);

        if (NetRoot == NULL) {
            try_return(Status = STATUS_ALREADY_DISCONNECTED);
        }

        if (InputBufferLength < sizeof(RDPDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        InputBuffer->Parameters.Get.TotalEntries = 1;
        InputBuffer->Parameters.Get.TotalBytesNeeded = 0;

        RxAcquirePrefixTableLockExclusive( &RxNetNameTable, TRUE);
        TableLockHeld = TRUE;

        if (DrPackConnectEntry(RxContext,
                               &BufferStart,
                               &BufferEnd,
                               VNetRoot,
                               BufferDisplacement,
                               &InputBuffer->Parameters.Get.TotalBytesNeeded)) {

            InputBuffer->Parameters.Get.EntriesRead = 1;                
            try_return(Status = STATUS_SUCCESS);
        } else {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }
  
try_exit:
        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
            TableLockHeld = FALSE;
        }
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) {
        if (TableLockHeld) {
            RxReleasePrefixTableLock( &RxNetNameTable );
            TableLockHeld = FALSE;
        }
        return STATUS_INVALID_PARAMETER;
    }

    return Status;
}


BOOLEAN
DrPackShareEntry (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PCHAR *BufferStart,
    IN OUT PCHAR *BufferEnd,
    IN DrDevice*  Device,
    IN OUT ULONG   BufferDisplacement,
       OUT PULONG TotalBytesNeeded
    )
/*++

Routine Description:

    This routine packs a sharelistentry into the buffer provided updating
    all relevant pointers. The way that this works is that constant length stuff is
    copied to the front of the buffer and variable length stuff to the end. The
    "start and end" pointers are updated. You have to calculate the totalbytes correctly
    no matter what but a last can be setup incompletely as long as you return false.

    the way that this works is that it calls down into the minirdr on the devfcb
    interface. it calls down twice and passes a structure back and forth thru the
    context to maintain state.

Arguments:

    IN OUT PCHAR *BufferStart - Supplies the output buffer.
                                Updated to point to the next buffer
                                
    IN OUT PCHAR *BufferEnd - Supplies the end of the buffer.  Updated to
                              point before the start of the strings being packed.
                              
    IN PNET_ROOT NetRoot - Supplies the NetRoot to enumerate.

    IN OUT PULONG TotalBytesNeeded - Updated to account for the length of this
                                     entry

Return Value:

    BOOLEAN - True if the entry was successfully packed into the buffer.


--*/
{
    NTSTATUS Status;
    BOOLEAN ReturnValue = TRUE;

    UNICODE_STRING ShareName;  // Buffer to hold the packed name
    PUCHAR DeviceDosName;
    ULONG BufferSize;
    PRDPDR_SHARE_INFO ShareInfo = (PRDPDR_SHARE_INFO)*BufferStart;
    PCHAR ShareEntryStart;
    
    BEGIN_FN("DrPackShareEntry");

    // 
    //  We want the connection name to have string null terminator
    //
    ShareName.Buffer = (PWCHAR)RxAllocatePoolWithTag(NonPagedPool, 
            MAX_PATH * sizeof(WCHAR), DR_POOLTAG);

    if ( ShareName.Buffer == NULL ) {
        return FALSE;
    }

    BufferSize = sizeof(RDPDR_SHARE_INFO);
    ShareEntryStart = *BufferStart;
    
    __try {
        unsigned len, devicelen, i;

        *BufferStart = ((PCHAR)*BufferStart) + BufferSize;
        *TotalBytesNeeded += BufferSize;
        
        //
        //  Initialize the name to "\\" then add in the rest
        //
        wcscpy(ShareName.Buffer, L"\\\\");
#if 0
        wcscat(ServerName.Buffer, Session->GetClientName());
#endif
        wcscat(ShareName.Buffer, DRUNCSERVERNAME_U);
        wcscat(ShareName.Buffer, L"\\");
        
        DeviceDosName = Device->GetDeviceDosName();

        len = wcslen(ShareName.Buffer);
        devicelen = strlen((char *)DeviceDosName);

        for (i = 0; i < devicelen; i++) {
            ShareName.Buffer[i + len] = (WCHAR) DeviceDosName[i];
        }
        ShareName.Buffer[i + len] = L'\0';

        ShareName.Length = wcslen(ShareName.Buffer) * sizeof(WCHAR);
        ShareName.MaximumLength = ShareName.Length;
        
        ASSERT(ShareName.Length < MAX_PATH);

        //
        //  Update the total number of bytes needed for this structure.
        //
        *TotalBytesNeeded += ShareName.MaximumLength;

        if (*BufferStart > *BufferEnd) {
            try_return( ReturnValue = FALSE);
        }

        ShareInfo->ResumeKey = Device->GetDeviceId();
        ShareInfo->SharedResourceType = RxDeviceType(DISK);

        if ((*BufferEnd - *BufferStart) < ShareName.Length) {
                ShareInfo->ShareName.Length = 0;
                try_return( ReturnValue = FALSE);
        }
        else if (!DrPackStringIntoInfoBuffer(
                &ShareInfo->ShareName,
                &ShareName,
                ShareEntryStart,
                BufferEnd,
                BufferDisplacement,
                NULL)) {
            try_return( ReturnValue = FALSE);
        }

    try_exit:
        RxFreePool(ShareName.Buffer);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        RxFreePool(ShareName.Buffer);        
        return FALSE;
    }
    
    return ReturnValue;
}


NTSTATUS
DrEnumerateShares (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine enumerates the connections on all minirdrs. we may have to do
    it by minirdr.

Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context

Return Value:

NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    PRDPDR_REQUEST_PACKET InputBuffer = (PRDPDR_REQUEST_PACKET)(LowIoContext->ParamsFor.FsCtl.pInputBuffer);
    PCHAR OriginalOutputBuffer = (PCHAR)(LowIoContext->ParamsFor.FsCtl.pOutputBuffer);
    ULONG OutputBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    PCHAR OutputBuffer;
    ULONG BufferDisplacement;

    ULONG ResumeHandle;

    PCHAR BufferStart;
    PCHAR BufferEnd;
    PCHAR PreviousBufferStart;

    ULONG SessionId;
    SmartPtr<DrSession> Session;

    BOOLEAN TableLockHeld = FALSE;

    BEGIN_FN("DrEnumerateShares");

    OutputBuffer = (PCHAR)RxMapUserBuffer( RxContext, RxContext->CurrentIrp );
    BufferDisplacement = (ULONG)(OutputBuffer - OriginalOutputBuffer);
    BufferStart = OutputBuffer;
    BufferEnd = OutputBuffer+OutputBufferLength;

    if (InputBuffer == NULL || OutputBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (RxContext->CurrentIrp->RequestorMode != KernelMode) {
        TRC_ASSERT((BufferDisplacement == 0), 
                   (TB, "Request mode is not kernel, non zero Displacement"));

        __try {
            ProbeForWrite(InputBuffer,InputBufferLength,sizeof(UCHAR));
            ProbeForWrite(OutputBuffer,OutputBufferLength,sizeof(UCHAR));
        } 
        __except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    __try {

        if (InputBufferLength < sizeof(RDPDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        ResumeHandle = InputBuffer->Parameters.Get.ResumeHandle;
        SessionId = InputBuffer->SessionId;

        InputBuffer->Parameters.Get.EntriesRead = 0;
        InputBuffer->Parameters.Get.TotalEntries = 0;
        InputBuffer->Parameters.Get.TotalBytesNeeded = 0;

        if (Sessions->FindSessionById(SessionId, Session)) {
            DrDevice *DeviceEnum;
            ListEntry *ListEnum;

            Session->GetDevMgr().GetDevList().LockShared();
            TableLockHeld = TRUE;

            ListEnum = Session->GetDevMgr().GetDevList().First();
            while (ListEnum != NULL) {

                DeviceEnum = (DrDevice *)ListEnum->Node();
                ASSERT(DeviceEnum->IsValid());

                if ((DeviceEnum->IsAvailable()) &&
                    (DeviceEnum->GetDeviceType() == RDPDR_DTYP_FILESYSTEM)) {
                    InputBuffer->Parameters.Get.TotalEntries ++ ;

                    PreviousBufferStart = BufferStart;

                    if (DrPackShareEntry(RxContext,
                                         &BufferStart,
                                         &BufferEnd,
                                         DeviceEnum,
                                         BufferDisplacement,
                                         &InputBuffer->Parameters.Get.TotalBytesNeeded)) {
                        InputBuffer->Parameters.Get.EntriesRead ++ ;
                    } else {
                        Status = STATUS_BUFFER_TOO_SMALL;
                    }
                }

                ListEnum = Session->GetDevMgr().GetDevList().Next(ListEnum);
            }

            Session->GetDevMgr().GetDevList().Unlock();                
            TableLockHeld = FALSE;
        }

        try_return(Status);
 
try_exit:
        if (TableLockHeld) {
            Session->GetDevMgr().GetDevList().Unlock();                
            TableLockHeld = FALSE;
        }
    } 
    __except(EXCEPTION_EXECUTE_HANDLER) {
        if (TableLockHeld) {
            Session->GetDevMgr().GetDevList().Unlock();                
            TableLockHeld = FALSE;
        }
        return STATUS_INVALID_PARAMETER;
    }

    return Status;
}


BOOLEAN
DrPackServerEntry (
    IN OUT PRX_CONTEXT RxContext,
    IN OUT PCHAR *BufferStart,
    IN OUT PCHAR *BufferEnd,
    IN DrSession*  Session,
    IN OUT ULONG   BufferDisplacement,
       OUT PULONG TotalBytesNeeded
    )
/*++

Routine Description:

    This routine packs a serverlistentry into the buffer provided updating
    all relevant pointers. The way that this works is that constant length stuff is
    copied to the front of the buffer and variable length stuff to the end. The
    "start and end" pointers are updated. You have to calculate the totalbytes correctly
    no matter what but a last can be setup incompletely as long as you return false.

    the way that this works is that it calls down into the minirdr on the devfcb
    interface. it calls down twice and passes a structure back and forth thru the
    context to maintain state.

Arguments:

    IN OUT PCHAR *BufferStart - Supplies the output buffer.
                                Updated to point to the next buffer
                                
    IN OUT PCHAR *BufferEnd - Supplies the end of the buffer.  Updated to
                              point before the start of the strings being packed.
                              
    IN PNET_ROOT NetRoot - Supplies the NetRoot to enumerate.

    IN OUT PULONG TotalBytesNeeded - Updated to account for the length of this
                                     entry

Return Value:

    BOOLEAN - True if the entry was successfully packed into the buffer.


--*/
{
    NTSTATUS Status;
    BOOLEAN ReturnValue = TRUE;

    UNICODE_STRING ServerName;  // Buffer to hold the packed name
    ULONG BufferSize;
    PRDPDR_SERVER_INFO ServerInfo = (PRDPDR_SERVER_INFO)*BufferStart;
    PCHAR ServerEntryStart;

    BEGIN_FN("DrPackServerEntry");

    // 
    //  We want the connection name to have string null terminator
    //
    ServerName.Buffer = (PWCHAR)RxAllocatePoolWithTag(NonPagedPool, 
            MAX_PATH * sizeof(WCHAR), DR_POOLTAG);

    if (ServerName.Buffer == NULL ) {
        return FALSE;
    }

    BufferSize = sizeof(RDPDR_SERVER_INFO);
    ServerEntryStart = *BufferStart;

    __try {
        *BufferStart = ((PCHAR)*BufferStart) + BufferSize;
        *TotalBytesNeeded += BufferSize;

        //
        //  Initialize the name to "\" then add in the rest
        //
        wcscpy(ServerName.Buffer , L"\\\\");
#if 0
        wcscat(ServerName.Buffer, Session->GetClientName());
#endif
        wcscat(ServerName.Buffer, DRUNCSERVERNAME_U);

        ServerName.Length = wcslen(ServerName.Buffer)  * sizeof(WCHAR);
        ServerName.MaximumLength = ServerName.Length;

        //
        //  Update the total number of bytes needed for this structure.
        //

        *TotalBytesNeeded += ServerName.MaximumLength;

        if (*BufferStart > *BufferEnd) {
            try_return( ReturnValue = FALSE);
        }

        ServerInfo->ResumeKey = 0;

        if ((*BufferEnd - *BufferStart) < ServerName.Length) {
                ServerInfo->ServerName.Length = 0;
                try_return( ReturnValue = FALSE);
        }
        else if (!DrPackStringIntoInfoBuffer(
                &ServerInfo->ServerName,
                &ServerName,
                ServerEntryStart,
                BufferEnd,
                BufferDisplacement,
                NULL)) {

            try_return( ReturnValue = FALSE);
        }

    try_exit:
        RxFreePool(ServerName.Buffer);

    } 
    __except(EXCEPTION_EXECUTE_HANDLER) {
        RxFreePool(ServerName.Buffer);
        return FALSE;
    }
    
    return ReturnValue;
}


NTSTATUS
DrEnumerateServers (
    IN PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This routine enumerates the server name on minirdr for a session.
    
Arguments:

    IN PRX_CONTEXT RxContext - Describes the Fsctl and Context

Return Value:

NTSTATUS

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;

    PRDPDR_REQUEST_PACKET InputBuffer = (PRDPDR_REQUEST_PACKET)(LowIoContext->ParamsFor.FsCtl.pInputBuffer);
    PCHAR OriginalOutputBuffer = (PCHAR)(LowIoContext->ParamsFor.FsCtl.pOutputBuffer);
    ULONG OutputBufferLength = LowIoContext->ParamsFor.FsCtl.OutputBufferLength;
    ULONG InputBufferLength = LowIoContext->ParamsFor.FsCtl.InputBufferLength;

    PCHAR OutputBuffer;
    ULONG BufferDisplacement;

    ULONG ResumeHandle;

    PCHAR BufferStart;
    PCHAR BufferEnd;
    PCHAR PreviousBufferStart;

    ULONG SessionId;
    BOOLEAN TableLockHeld = FALSE;
    SmartPtr<DrSession> Session;

    BEGIN_FN("DrEnumerateServers");

    OutputBuffer = (PCHAR)RxMapUserBuffer( RxContext, RxContext->CurrentIrp );
    BufferDisplacement = (ULONG)(OutputBuffer - OriginalOutputBuffer);
    BufferStart = OutputBuffer;
    BufferEnd = OutputBuffer+OutputBufferLength;

    if (InputBuffer == NULL || OutputBuffer == NULL) {
        return STATUS_INVALID_PARAMETER;
    }

    if (RxContext->CurrentIrp->RequestorMode != KernelMode) {
        TRC_ASSERT((BufferDisplacement == 0), 
                   (TB, "Request mode is not kernel, non zero Displacement"));
        
        __try {
            ProbeForWrite(InputBuffer,InputBufferLength,sizeof(UCHAR));
            ProbeForWrite(OutputBuffer,OutputBufferLength,sizeof(UCHAR));
        } 
        __except(EXCEPTION_EXECUTE_HANDLER) {
            return STATUS_INVALID_PARAMETER;
        }
    }

    __try {

        if (InputBufferLength < sizeof(RDPDR_REQUEST_PACKET)) {
            try_return(Status = STATUS_BUFFER_TOO_SMALL);
        }

        ResumeHandle = InputBuffer->Parameters.Get.ResumeHandle;
        SessionId = InputBuffer->SessionId;

        InputBuffer->Parameters.Get.EntriesRead = 0;
        InputBuffer->Parameters.Get.TotalEntries = 0;
        InputBuffer->Parameters.Get.TotalBytesNeeded = 0;

        if (Sessions->FindSessionById(SessionId, Session)) {
            InputBuffer->Parameters.Get.TotalEntries ++ ;

            PreviousBufferStart = BufferStart;

            if (DrPackServerEntry(RxContext,
                                  &BufferStart,
                                  &BufferEnd,
                                  Session,
                                  BufferDisplacement,
                                  &InputBuffer->Parameters.Get.TotalBytesNeeded)) {
                InputBuffer->Parameters.Get.EntriesRead ++ ;
                Status = STATUS_SUCCESS;
            } 
            else {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
        } 

        try_return(Status);
        
try_exit:NOTHING;

    } 
    __except(EXCEPTION_EXECUTE_HANDLER) {
        return STATUS_INVALID_PARAMETER;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\drive.cpp ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    drive.cpp

Author :

    JoyC  11/1/1999
         
Abstract:

    Drive Device object handles one redirected drive

Revision History:
--*/

#include "precomp.hxx"
#define TRC_FILE "drive"
#include "trc.h"

#if DBG
extern UCHAR IrpNames[IRP_MJ_MAXIMUM_FUNCTION + 1][40];
#endif // DBG

DrDrive::DrDrive(SmartPtr<DrSession> &Session, ULONG DeviceType, ULONG DeviceId, 
            PUCHAR PreferredDosName) : DrDevice(Session, DeviceType, DeviceId, PreferredDosName)
{
    BEGIN_FN("DrDrive::DrDrive");
    
    SetClassName("DrDrive");

    TRC_NRM((TB, "Create drive object = %p", this));
}

BOOL DrDrive::ShouldCreateDevice()
{
    BEGIN_FN("DrDrive::ShouldCreateDevice");
    //
    // Check if the device name is valid
    //
    if (!_Session->DisableDriveMapping()) {
        return IsDeviceNameValid();
    }
    return FALSE;
}

BOOL DrDrive::IsDeviceNameValid()
{
    BEGIN_FN("DrDrive::IsDeviceNameValid");
    BOOL fRet = TRUE;
    int i, Len;
    //
    // Our device name is valid only if
    // the first char contains a character between A-Z.
    // and the 2nd char is NULL.
    //
    // For Mac client, drive name can have up to 7 characters and
    //  valid characters are: [a-z], [A-Z], [0-9], '-', '_' and ' '
    //
    Len = strlen((CHAR*)_PreferredDosName);
    if ((Len <= 7) && (Len >= 1)) {
        for (i=0; i<Len; i++) {
            if(((_PreferredDosName[i] < 'A') || (_PreferredDosName[i] > 'Z')) &&
               ((_PreferredDosName[i] < 'a') || (_PreferredDosName[i] > 'z')) &&
               ((_PreferredDosName[i] < '0') || (_PreferredDosName[i] > '9')) &&
               (_PreferredDosName[i] != '-') &&
               (_PreferredDosName[i] != '_') &&
               (_PreferredDosName[i] != ' ')) {
                fRet = FALSE;
                break;
            }
        }
    }
    else {
        fRet = FALSE;
    }

    //
    // This assert should never fire for drive redirection
    //
    ASSERT(fRet);
    return fRet;
}

NTSTATUS DrDrive::Initialize(PRDPDR_DEVICE_ANNOUNCE DeviceAnnounce, ULONG Length)
{
    NTSTATUS Status;
    UNICODE_STRING DriveName;
    WCHAR DriveNameBuff[PREFERRED_DOS_NAME_SIZE];
    INT len;

    BEGIN_FN("DrDrive::Initialize");
    
    Status = DrDevice::Initialize(DeviceAnnounce, Length);

    if (ShouldCreateDevice()) {
        if (!NT_ERROR(Status)) {
            DriveName.MaximumLength = sizeof(DriveNameBuff);
            DriveName.Length = 0;
            DriveName.Buffer = &DriveNameBuff[0];
            memset(&DriveNameBuff, 0, sizeof(DriveNameBuff));

            ASSERT(_PreferredDosName != NULL);
            len = strlen((char *)_PreferredDosName);
            len = ConvertToAndFromWideChar(0, DriveName.Buffer, 
                    DriveName.MaximumLength, (char *)_PreferredDosName, 
                    len, TRUE);
    
            if (len != -1) {
    
                //
                // We need just the drive letter portion 
                //
                DriveName.Length = (USHORT)len;
                TRC_NRM((TB, "New drive: %wZ", &DriveName));
            
            } else {
                 TRC_ERR((TB, "Error converting DriveName"));
                 return STATUS_UNSUCCESSFUL;
            }
            
            //
            // Request the user mode notify dll to create UNC connection
            // for redirected client drives
            //
            Status = CreateDrive(DeviceAnnounce, DriveName.Buffer);
        }
    }
    else {
        Status = STATUS_SUCCESS;
    }

    return Status;
}

NTSTATUS DrDrive::CreateDrive(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg, PWCHAR DriveName)
{
    NTSTATUS Status;
    ULONG driveAnnounceEventReqSize;
    PRDPDR_DRIVEDEVICE_SUB driveAnnounceEvent;

    BEGIN_FN("DrDrive::CreateDrive");
    ASSERT(DriveName != NULL);

    //
    //  Allocate the drive device announce buffer.
    //
    Status = CreateDriveAnnounceEvent(devAnnounceMsg, NULL, 0, L"", 
            &driveAnnounceEventReqSize);

    ASSERT(Status == STATUS_BUFFER_TOO_SMALL);

    if( Status != STATUS_BUFFER_TOO_SMALL) {
        goto CleanUpAndReturn;
    }

    driveAnnounceEvent = (PRDPDR_DRIVEDEVICE_SUB)new(NonPagedPool) 
            BYTE[driveAnnounceEventReqSize];

    if (driveAnnounceEvent == NULL) {
        TRC_ERR((TB, "Unable to allocate driveAnnounceEvent"));
        Status = STATUS_NO_MEMORY;
        goto CleanUpAndReturn;
    }

    //
    //  Create the drive anounce message.
    //
    Status = CreateDriveAnnounceEvent(devAnnounceMsg, driveAnnounceEvent,
            driveAnnounceEventReqSize, DriveName, NULL);

    if (Status != STATUS_SUCCESS) {
        delete driveAnnounceEvent;
#if DBG
        driveAnnounceEvent = NULL;
#endif
        goto CleanUpAndReturn;
    }

    //
    //  Dispatch the event to the associated session.
    //
    Status = RDPDYN_DispatchNewDevMgmtEvent(
                                driveAnnounceEvent,
                                _Session->GetSessionId(),
                                RDPDREVT_DRIVEANNOUNCE,
                                NULL
                                );

CleanUpAndReturn:
    return Status;
}

NTSTATUS DrDrive::CreateDriveAnnounceEvent(
    IN      PRDPDR_DEVICE_ANNOUNCE  devAnnounceMsg,
    IN OUT  PRDPDR_DRIVEDEVICE_SUB driveAnnounceEvent,
    IN      ULONG driveAnnounceEventSize,
    IN      PCWSTR driveName,
    OPTIONAL OUT ULONG *driveAnnounceEventReqSize
    )
/*++

Routine Description:

    Generate a RDPDR_DRIVEDEVICE_SUB event from a client-sent
    RDPDR_DEVICE_ANNOUNCE message.

Arguments:

    devAnnounceMsg  -         Device announce message received from client.
    driveAnnounceEvent  -       Buffer for receiving finished drive announce event.
    driveAnnounceEventSize -    Size of driveAnnounceEvent buffer.
    driveName -                Name of local drive to be associated with
                              client-side drive device.
    driveAnnounceEventReqSize - Returned required size of driveAnnounceMsg buffer.

Return Value:

    STATUS_INVALID_BUFFER_SIZE is returned if the driveAnnounceEventSize size is
    too small.  STATUS_SUCCESS is returned on success.

--*/
{
    ULONG requiredSize;
    ULONG sz;

    BEGIN_FN("DrDrive::CreateDriveAnnounceEvent");

    //  Make sure the client-sent device announce message is a drive announce
    //  message.
    TRC_ASSERT(devAnnounceMsg->DeviceType == RDPDR_DTYP_FILESYSTEM,
              (TB, "file system device expected"));

    //
    // Make sure that the device datalengths we got from the client
    // doesn't exceed what we expect 
    //
    if (!DR_CHECK_DEVICEDATALEN(devAnnounceMsg, RDPDR_DRIVEDEVICE_SUB)) {
        return STATUS_INVALID_PARAMETER;
    }
    
    //
    //  Calculate the number of bytes needed in the output buffer.
    //
    requiredSize = sizeof(RDPDR_DRIVEDEVICE_SUB) + devAnnounceMsg->DeviceDataLength;

    if (driveAnnounceEventSize < requiredSize) {
        if (driveAnnounceEventReqSize != NULL) {
            *driveAnnounceEventReqSize = requiredSize;
        }
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Add the data to the output buffer.
    //

    // Drive Name.
    TRC_ASSERT(wcslen(driveName)+1 <= RDPDR_MAXPORTNAMELEN,
                (TB, "drive name too long"));
    wcscpy(driveAnnounceEvent->driveName, driveName);

    // Client Name (UNC server name).
#if 0
    TRC_ASSERT(wcslen(_Session->GetClientName())+1 <= RDPDR_MAX_COMPUTER_NAME_LENGTH,
                (TB, "Client name too long"));
    wcscpy(driveAnnounceEvent->clientName, _Session->GetClientName());
#endif
    wcscpy(driveAnnounceEvent->clientName, DRUNCSERVERNAME_U);

    // Client-received device announce message.
    RtlCopyMemory(&driveAnnounceEvent->deviceFields, devAnnounceMsg,
               sizeof(RDPDR_DEVICE_ANNOUNCE) +
               devAnnounceMsg->DeviceDataLength);


    wcscpy(driveAnnounceEvent->clientDisplayName, _Session->GetClientDisplayName());

    // Return the size.
    if (driveAnnounceEventReqSize != NULL) {
        *driveAnnounceEventReqSize = requiredSize;
    }

    TRC_NRM((TB, "exit CreateDriveAnnounceEvent."));

    return STATUS_SUCCESS;
}

VOID DrDrive::Remove()
{
    PRDPDR_REMOVEDEVICE deviceRemoveEventPtr = NULL;

    BEGIN_FN("DrDrive::Remove");

    //
    //  Create and dispatch the remove device event.
    //
    deviceRemoveEventPtr = new(NonPagedPool) RDPDR_REMOVEDEVICE;

    if (deviceRemoveEventPtr != NULL) {

        //
        //  Dispatch it.
        //
        deviceRemoveEventPtr->deviceID = _DeviceId;
        RDPDYN_DispatchNewDevMgmtEvent(
                            deviceRemoveEventPtr,
                            _Session->GetSessionId(),
                            RDPDREVT_REMOVEDEVICE,
                            NULL
                            );
    }
    else {
        TRC_ERR((TB, "Unable to allocate %ld bytes for remove event",
                sizeof(RDPDR_REMOVEDEVICE)));
    }    
}

NTSTATUS DrDrive::QueryDirectory(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    PRDPDR_IOREQUEST_PACKET pIoPacket;
    ULONG cbPacketSize;
    BOOL bTemplateEndsDOT = FALSE;
    FILE_INFORMATION_CLASS FileInformationClass = RxContext->Info.FileInformationClass;
    PUNICODE_STRING DirectoryName = GET_ALREADY_PREFIXED_NAME_FROM_CONTEXT(RxContext);
    PUNICODE_STRING QueryTemplate = &(capFobx->UnicodeQueryTemplate);
    
    BEGIN_FN("DrDrive:QueryDirectory");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL);
    ASSERT(Session != NULL);
    
    if (!Session->IsConnected()) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to query client directory information while not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    TRC_DBG((TB, "QueryDirectory information class = %x", FileInformationClass));

    //
    // Check what file information class it is requesting
    //
    switch (FileInformationClass) {
        case FileDirectoryInformation:
        case FileFullDirectoryInformation:
        case FileBothDirectoryInformation:
        case FileNamesInformation:
            // let client handle these
            break;
        
        default:
            TRC_DBG((TB, "Unhandled FileInformationClass=%x", FileInformationClass));
            return STATUS_INVALID_PARAMETER;
    }    
    
    //
    // Build the querydir packet and send it to the client
    //
    if (RxContext->QueryDirectory.InitialQuery) {
        LONG index;
        
        ASSERT(DirectoryName->Length != 0);
        ASSERT(QueryTemplate->Length != 0);
        
        //
        //  Account for 3 extra characters
        //  1) We append string null terminator to the end 
        //  2) add \ between directory name and query template
        //  3) need to translate template ending < to *.
        //
        cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) + DirectoryName->Length + 
                capFobx->UnicodeQueryTemplate.Length + sizeof(WCHAR) * 3;

        //
        //  Query template translation back into win32 format
        //  Look filefind.c from base\win32\client for the original translation
        //

        TRC_DBG((TB, "QueryTemplate before %wZ\n", QueryTemplate));

        if (QueryTemplate->Buffer[QueryTemplate->Length/sizeof(WCHAR) - 1] == DOS_STAR) {
            bTemplateEndsDOT = TRUE;
            QueryTemplate->Buffer[QueryTemplate->Length/sizeof(WCHAR) - 1] = L'*';
        }
    
        for (index = QueryTemplate->Length/sizeof(WCHAR) - 1; index >= 0; index--) {
            if (index && QueryTemplate->Buffer[index] == L'.' && 
                    QueryTemplate->Buffer[index - 1] == DOS_STAR) {
                QueryTemplate->Buffer[index - 1] = L'*';
            }

            if (QueryTemplate->Buffer[index] == DOS_QM) {
                QueryTemplate->Buffer[index] = L'?';
            }

            if (index && (QueryTemplate->Buffer[index] == L'?' || 
                          QueryTemplate->Buffer[index] == L'*') &&
                    QueryTemplate->Buffer[index - 1] == DOS_DOT) {
                QueryTemplate->Buffer[index - 1] = L'.';
            }
        }
        
        TRC_DBG((TB, "QueryTemplate after %wZ, bTemplateEndsDOT=%x\n", QueryTemplate,
                 bTemplateEndsDOT));
    }
    else {
        cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET);
    }

    pIoPacket = (PRDPDR_IOREQUEST_PACKET)new(PagedPool) BYTE[cbPacketSize];

    if (pIoPacket) {
        memset(pIoPacket, 0, cbPacketSize);

        pIoPacket->Header.Component = RDPDR_CTYP_CORE;
        pIoPacket->Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
        pIoPacket->IoRequest.DeviceId = _DeviceId;
        pIoPacket->IoRequest.FileId = FileObj->GetFileId();
        pIoPacket->IoRequest.MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
        pIoPacket->IoRequest.MinorFunction = IRP_MN_QUERY_DIRECTORY;

        pIoPacket->IoRequest.Parameters.QueryDir.FileInformationClass = 
                (RDP_FILE_INFORMATION_CLASS)FileInformationClass;
        pIoPacket->IoRequest.Parameters.QueryDir.InitialQuery = 
                RxContext->QueryDirectory.InitialQuery;

        if (RxContext->QueryDirectory.InitialQuery) {
            //
            // This is in the format of <DirectoryName>\<QueryTemplate>\0
            //
            
            RtlCopyMemory(pIoPacket + 1, DirectoryName->Buffer, DirectoryName->Length);

            if (((PWCHAR)(pIoPacket + 1))[DirectoryName->Length / sizeof(WCHAR) - 1] != L'\\') {
                ((PWCHAR)(pIoPacket + 1))[DirectoryName->Length / sizeof(WCHAR)] = L'\\';
                RtlCopyMemory((PBYTE)(pIoPacket + 1) + DirectoryName->Length + sizeof(WCHAR),
                        QueryTemplate->Buffer, QueryTemplate->Length);
                pIoPacket->IoRequest.Parameters.QueryDir.PathLength = DirectoryName->Length + 
                        QueryTemplate->Length + sizeof(WCHAR);
            }
            else {
                RtlCopyMemory((PBYTE)(pIoPacket + 1) + DirectoryName->Length,
                        QueryTemplate->Buffer, QueryTemplate->Length);
                pIoPacket->IoRequest.Parameters.QueryDir.PathLength = DirectoryName->Length + 
                        QueryTemplate->Length;
                cbPacketSize -= sizeof(WCHAR);
            }

            //
            //  Add . for the query template if it ends like *.
            //
            if (bTemplateEndsDOT) {
                ((PWCHAR)(pIoPacket + 1))[pIoPacket->IoRequest.Parameters.QueryDir.PathLength 
                        / sizeof(WCHAR)] = L'.';
                pIoPacket->IoRequest.Parameters.QueryDir.PathLength += sizeof(WCHAR);
            }
            else {
                cbPacketSize -= sizeof(WCHAR);
            }

            //
            //  Path length includes the null terminator
            //
            pIoPacket->IoRequest.Parameters.QueryDir.PathLength += sizeof(WCHAR);

            // The pIoPacket is already zero'd.  So, no need to null terminate it
        } else {
            //
            //  This is not the first query, so we should already have the file
            //  handle open
            //
            pIoPacket->IoRequest.Parameters.QueryDir.PathLength = 0;
        }

        Status = SendIoRequest(RxContext, pIoPacket, cbPacketSize, 
                (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

        delete pIoPacket;
    }
    else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    return Status;
}

NTSTATUS DrDrive::NotifyChangeDirectory(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    RDPDR_IOREQUEST_PACKET IoPacket;
    ULONG cbPacketSize;
    PLOWIO_CONTEXT pLowIoContext = &RxContext->LowIoContext;

    BEGIN_FN("DrDrive:NotifyChangeDirectory");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL);
    ASSERT(Session != NULL);
    

    if (COMPARE_VERSION(Session->GetClientVersion().Minor, 
            Session->GetClientVersion().Major, 4, 1) < 0) {
        TRC_ALT((TB, "Failing NotifyChangeDirectory for client that doesn't support it"));
        return STATUS_NOT_IMPLEMENTED;
    }

    if (!Session->IsConnected()) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to query client directory change notify information while not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET);
    
    memset(&IoPacket, 0, cbPacketSize);

    IoPacket.Header.Component = RDPDR_CTYP_CORE;
    IoPacket.Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
    IoPacket.IoRequest.DeviceId = _DeviceId;
    IoPacket.IoRequest.FileId = FileObj->GetFileId();
    IoPacket.IoRequest.MajorFunction = IRP_MJ_DIRECTORY_CONTROL;
    IoPacket.IoRequest.MinorFunction = IRP_MN_NOTIFY_CHANGE_DIRECTORY;

    IoPacket.IoRequest.Parameters.NotifyChangeDir.WatchTree =
            pLowIoContext->ParamsFor.NotifyChangeDirectory.WatchTree;
    IoPacket.IoRequest.Parameters.NotifyChangeDir.CompletionFilter =
            pLowIoContext->ParamsFor.NotifyChangeDirectory.CompletionFilter;

    Status = SendIoRequest(RxContext, &IoPacket, cbPacketSize, 
            (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

    return Status;
}

NTSTATUS DrDrive::QueryVolumeInfo(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    RDPDR_IOREQUEST_PACKET IoPacket;
    FS_INFORMATION_CLASS FsInformationClass = RxContext->Info.FsInformationClass;
    
    BEGIN_FN("DrDrive:QueryVolumeInfo");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //
    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_QUERY_VOLUME_INFORMATION);
    ASSERT(Session != NULL);
    
    if (!Session->IsConnected()) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to query client device volume information while not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    
    TRC_DBG((TB, "QueryVolume information class = %x", FsInformationClass));

    switch (FsInformationClass) {
        case FileFsVolumeInformation:
        //case FileFsLabelInformation:
            // Smb seems to handle query label information, but i think 
            // this is only for set label info.  We'll see if we should
            // actually handle query label information.
            // query label can be achieved through volume information
        case FileFsSizeInformation:            
        case FileFsAttributeInformation:
            // let client handle these
            break;
        case FileFsDeviceInformation:
        {
            PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
            PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

            if (sizeof(FILE_FS_DEVICE_INFORMATION) <= *pLengthRemaining) {
                PFILE_FS_DEVICE_INFORMATION UsersBuffer =
                        (PFILE_FS_DEVICE_INFORMATION) RxContext->Info.Buffer;

                UsersBuffer->Characteristics = FILE_REMOTE_DEVICE;
                UsersBuffer->DeviceType = FILE_DEVICE_DISK;
                *pLengthRemaining  -= (sizeof(FILE_FS_DEVICE_INFORMATION));
                return STATUS_SUCCESS;
            }
            else {
                FILE_FS_DEVICE_INFORMATION UsersBuffer;

                UsersBuffer.Characteristics = FILE_REMOTE_DEVICE;
                UsersBuffer.DeviceType = FILE_DEVICE_DISK;
                RtlCopyMemory(RxContext->Info.Buffer, &UsersBuffer, *pLengthRemaining);
                *pLengthRemaining = 0;
                return  STATUS_BUFFER_OVERFLOW;
            }
        }
        
        case FileFsFullSizeInformation:
            TRC_DBG((TB, "Unhandled FsInformationClass=%x", FsInformationClass));
            return STATUS_NOT_IMPLEMENTED;

        default:
            TRC_DBG((TB, "Unhandled FsInformationClass=%x", FsInformationClass));
            return STATUS_NOT_IMPLEMENTED;
    }    
    
    memset(&IoPacket, 0, sizeof(IoPacket));

    IoPacket.Header.Component = RDPDR_CTYP_CORE;
    IoPacket.Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
    IoPacket.IoRequest.DeviceId = _DeviceId;
    IoPacket.IoRequest.FileId = FileObj->GetFileId();
    IoPacket.IoRequest.MajorFunction = IRP_MJ_QUERY_VOLUME_INFORMATION;
    IoPacket.IoRequest.MinorFunction = 0;
    IoPacket.IoRequest.Parameters.QueryVolume.FsInformationClass = 
            (RDP_FS_INFORMATION_CLASS)FsInformationClass;

    Status = SendIoRequest(RxContext, &IoPacket, sizeof(IoPacket), 
            (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

    return Status;
}

NTSTATUS DrDrive::SetVolumeInfo(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    PRDPDR_IOREQUEST_PACKET pIoPacket; 
    ULONG cbPacketSize = 0;  
    FS_INFORMATION_CLASS FsInformationClass = RxContext->Info.FsInformationClass;

    BEGIN_FN("DrDrive:SetVolumeInfo");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_SET_VOLUME_INFORMATION);
    ASSERT(Session != NULL);
    
    if (!Session->IsConnected()) {
        RxContext->IoStatusBlock.Information = 0;
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to set client device volume information while not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    //  Check buffer length
    //
    if (RxContext->Info.Length == 0) {
        RxContext->IoStatusBlock.Information = 0;
        return STATUS_SUCCESS;
    }

    TRC_DBG((TB, "SetVolume Information class = %x", FsInformationClass));

    switch (FsInformationClass) {
        case FileFsLabelInformation:
        {
            PFILE_FS_LABEL_INFORMATION pRxBuffer =
                    (PFILE_FS_LABEL_INFORMATION) RxContext->Info.Buffer;

            //
            //  REVIEW: Find out why Info.Length has the extra 2 bytes
            //  It doesn't seem to put string null terminator to it
            //
            if ((ULONG)RxContext->Info.Length == FIELD_OFFSET(FILE_FS_LABEL_INFORMATION,
                    VolumeLabel) + pRxBuffer->VolumeLabelLength + sizeof(WCHAR)) {
                cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) + 
                        RxContext->Info.Length;
                // Make sure that label is null terminiated
                pRxBuffer->VolumeLabel[pRxBuffer->VolumeLabelLength/sizeof(WCHAR)] = L'\0';
            }
            else {
                TRC_ERR((TB, "Invalid Volume label info"));
                return STATUS_INVALID_PARAMETER;
            }
            // Let client handle this
            break;
        }
        default:
            TRC_DBG((TB, "Unhandled FsInformationClass=%x", FsInformationClass));
            return STATUS_NOT_SUPPORTED;
    }    
        
    pIoPacket = (PRDPDR_IOREQUEST_PACKET)new(PagedPool) BYTE[cbPacketSize];

    if (pIoPacket != NULL) {

        memset(pIoPacket, 0, cbPacketSize);

        pIoPacket->Header.Component = RDPDR_CTYP_CORE;
        pIoPacket->Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
        pIoPacket->IoRequest.DeviceId = _DeviceId;
        pIoPacket->IoRequest.FileId = FileObj->GetFileId();
        pIoPacket->IoRequest.MajorFunction = IRP_MJ_SET_VOLUME_INFORMATION;
        pIoPacket->IoRequest.MinorFunction = 0;
        pIoPacket->IoRequest.Parameters.SetVolume.FsInformationClass = 
                (RDP_FS_INFORMATION_CLASS)FsInformationClass;
        pIoPacket->IoRequest.Parameters.SetVolume.Length = RxContext->Info.Length;
        RtlCopyMemory(pIoPacket + 1, RxContext->Info.Buffer, RxContext->Info.Length);

        Status = SendIoRequest(RxContext, pIoPacket, cbPacketSize, 
                (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

        delete pIoPacket;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS DrDrive::QueryFileInfo(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    RDPDR_IOREQUEST_PACKET IoPacket;
    FILE_INFORMATION_CLASS FileInformationClass = RxContext->Info.FileInformationClass;
    
    BEGIN_FN("DrDrive:QueryFileInfo");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_QUERY_INFORMATION);
    ASSERT(Session != NULL);
    
    if (!Session->IsConnected()) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to query client file information while not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    TRC_DBG((TB, "QueryFile information class = %x", FileInformationClass));

    switch (FileInformationClass) {
        case FileBasicInformation:
        case FileStandardInformation:
        case FileAttributeTagInformation:
            // let client handle these
            break;
        
        case FileEaInformation:
        {
            PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;

            // Should check buffer length
            if (sizeof(FILE_EA_INFORMATION) <= *pLengthRemaining) {
                ((PFILE_EA_INFORMATION)(RxContext->Info.Buffer))->EaSize = 0;
                *pLengthRemaining -= sizeof(FILE_EA_INFORMATION);
                return STATUS_SUCCESS;
            }
            else {
                return STATUS_BUFFER_OVERFLOW;
            }
        }

        case FileAllocationInformation:
        case FileEndOfFileInformation:
        case FileAlternateNameInformation:
        case FileStreamInformation:
        case FileCompressionInformation:
            TRC_DBG((TB, "Unhandled FileInformationClass=%x", FileInformationClass));
            return STATUS_NOT_IMPLEMENTED;
    
        case FileInternalInformation:
        {
            PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
            PFILE_INTERNAL_INFORMATION UsersBuffer = 
                    (PFILE_INTERNAL_INFORMATION)RxContext->Info.Buffer;

            if (sizeof(FILE_INTERNAL_INFORMATION) <= *pLengthRemaining) {
                UsersBuffer->IndexNumber.QuadPart = (ULONG_PTR)capFcb;
                *pLengthRemaining -= sizeof(FILE_INTERNAL_INFORMATION);
                return STATUS_SUCCESS;
            }
            else {
                return  STATUS_BUFFER_OVERFLOW;
            }
        }

        default:
            TRC_DBG((TB, "Unhandled FileInformationClass=%x", FileInformationClass));
            return STATUS_INVALID_PARAMETER;
    }

    memset(&IoPacket, 0, sizeof(IoPacket));

    IoPacket.Header.Component = RDPDR_CTYP_CORE;
    IoPacket.Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
    IoPacket.IoRequest.DeviceId = _DeviceId;
    IoPacket.IoRequest.FileId = FileObj->GetFileId();
    IoPacket.IoRequest.MajorFunction = IRP_MJ_QUERY_INFORMATION;
    IoPacket.IoRequest.MinorFunction = 0;
    IoPacket.IoRequest.Parameters.QueryFile.FileInformationClass = 
            (RDP_FILE_INFORMATION_CLASS)FileInformationClass;

    Status = SendIoRequest(RxContext, &IoPacket, sizeof(IoPacket), 
            (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

    return Status;
}

NTSTATUS DrDrive::SetFileInfo(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    PRDPDR_IOREQUEST_PACKET pIoPacket;
    ULONG cbPacketSize = 0;
    FILE_INFORMATION_CLASS FileInformationClass = RxContext->Info.FileInformationClass;
    BOOLEAN bBufferRepackage = FALSE;

    BEGIN_FN("DrDrive:SetFileInfo");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(RxContext != NULL);    
    ASSERT(RxContext->MajorFunction == IRP_MJ_SET_INFORMATION);
    ASSERT(Session != NULL);
    
    if (!Session->IsConnected()) {
        RxContext->IoStatusBlock.Information = 0;
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to set client device file information while not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    //  Check buffer length
    //
    if (RxContext->Info.Length == 0) {
        RxContext->IoStatusBlock.Information = 0;
        return STATUS_SUCCESS;
    }

    TRC_DBG((TB, "SetFile information class=%x", FileInformationClass));

    switch (FileInformationClass) {
        case FileBasicInformation: 
        {
            if (sizeof(FILE_BASIC_INFORMATION) == RxContext->Info.Length) {
                if (RxContext->Info.Length == sizeof(RDP_FILE_BASIC_INFORMATION)) {
                    bBufferRepackage = FALSE;
                    cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) + RxContext->Info.Length;
                }
                else {
                    bBufferRepackage = TRUE;
                    cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) +
                            sizeof(RDP_FILE_BASIC_INFORMATION);
                }
            }
            else {
                TRC_ERR((TB, "Invalid FileBasicInformation buffer"));
                return STATUS_INVALID_PARAMETER;
            }
            break;
        }
        case FileEndOfFileInformation:
        {
            if (sizeof(FILE_END_OF_FILE_INFORMATION) == RxContext->Info.Length) {
                bBufferRepackage = FALSE;
                cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) + RxContext->Info.Length;                
            }
            else {
                TRC_ERR((TB, "Invalid FileEndOfFileInformation buffer"));
                return STATUS_INVALID_PARAMETER;
            }
            break;
        }
        case FileDispositionInformation:
        {
            if (sizeof(FILE_DISPOSITION_INFORMATION) == RxContext->Info.Length) {
                if (((PFILE_DISPOSITION_INFORMATION)(RxContext->Info.Buffer))->DeleteFile) {
                    bBufferRepackage = FALSE;
                    cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET);
                }
                else {
                    //
                    //  We shouldn't get this if the DeleteFile flag is not on
                    //
                    ASSERT(FALSE);
                    return STATUS_SUCCESS;
                }
            }
            else {
                TRC_ERR((TB, "Invalid FileDispositionInformation buffer"));
                return STATUS_INVALID_PARAMETER;
            }
            break;
        }

        case FileRenameInformation:
        {
            PFILE_RENAME_INFORMATION pRenameInformation = 
                    (PFILE_RENAME_INFORMATION)RxContext->Info.Buffer;

            if ((ULONG)(RxContext->Info.Length) == FIELD_OFFSET(FILE_RENAME_INFORMATION,
                    FileName) + pRenameInformation->FileNameLength) {
               if ((ULONG)(RxContext->Info.Length) == FIELD_OFFSET(RDP_FILE_RENAME_INFORMATION,
                       FileName) + pRenameInformation->FileNameLength) {
                   bBufferRepackage = FALSE;
                   //
                   //  Add string null terminator to the filename
                   //
                   cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) + RxContext->Info.Length + sizeof(WCHAR);
               }
               else {
                   bBufferRepackage = TRUE;
                   //
                   //  Add string null terminator to the filename
                   //
                   cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) +
                           FIELD_OFFSET(RDP_FILE_RENAME_INFORMATION,
                           FileName) + pRenameInformation->FileNameLength + sizeof(WCHAR);
               }

            }
            else {
                TRC_ERR((TB, "Bad buffer info for FileRenameInformation class, InfoBuffer length=%x, "
                        "FileName Length=%x", RxContext->Info.Length, pRenameInformation->FileNameLength));
                return STATUS_INVALID_PARAMETER;
            }
            break;
        }

        case FileAllocationInformation:
        {
  
            TRC_NRM((TB, "Get FileAllocationInfomation"));

            if (sizeof(FILE_ALLOCATION_INFORMATION) == RxContext->Info.Length) {
                bBufferRepackage = FALSE;
                cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) + RxContext->Info.Length; 
            }
            else {
                TRC_ERR((TB, "Invalid FileAllocationInformation buffer"));
                return STATUS_INVALID_PARAMETER;
            }
            break;
        }

        case FileLinkInformation:
        case FileAttributeTagInformation:    
            TRC_DBG((TB, "Unhandled FileInformationClass=%x", FileInformationClass));
            return STATUS_NOT_IMPLEMENTED;
        
        default:
            TRC_DBG((TB, "Unhandled FileInformationClass=%x", FileInformationClass));
            return STATUS_INVALID_PARAMETER;
    }    

    pIoPacket = (PRDPDR_IOREQUEST_PACKET)new(PagedPool) BYTE[cbPacketSize];

    if (pIoPacket != NULL) {
        memset(pIoPacket, 0, cbPacketSize);

        pIoPacket->Header.Component = RDPDR_CTYP_CORE;
        pIoPacket->Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
        pIoPacket->IoRequest.DeviceId = _DeviceId;
        pIoPacket->IoRequest.FileId = FileObj->GetFileId();
        pIoPacket->IoRequest.MajorFunction = IRP_MJ_SET_INFORMATION;
        pIoPacket->IoRequest.MinorFunction = 0;
        pIoPacket->IoRequest.Parameters.SetFile.FileInformationClass = 
                (RDP_FILE_INFORMATION_CLASS)FileInformationClass;

        if (cbPacketSize > sizeof(RDPDR_IOREQUEST_PACKET)) {
            if (!bBufferRepackage) {
                pIoPacket->IoRequest.Parameters.SetFile.Length = RxContext->Info.Length;
                RtlCopyMemory(pIoPacket + 1, RxContext->Info.Buffer, RxContext->Info.Length);
            }
            else {
                switch (FileInformationClass) {
                    case FileBasicInformation:
                    {
                        PFILE_BASIC_INFORMATION pRxFileInfo =
                                (PFILE_BASIC_INFORMATION) RxContext->Info.Buffer;
                        PRDP_FILE_BASIC_INFORMATION pRdpFileInfo =
                                (PRDP_FILE_BASIC_INFORMATION) (pIoPacket + 1);

                        pIoPacket->IoRequest.Parameters.SetFile.Length = 
                                sizeof(RDP_FILE_BASIC_INFORMATION);

                        pRdpFileInfo->ChangeTime.QuadPart = pRxFileInfo->ChangeTime.QuadPart;
                        pRdpFileInfo->CreationTime.QuadPart = pRxFileInfo->CreationTime.QuadPart;
                        pRdpFileInfo->FileAttributes = pRxFileInfo->FileAttributes;
                        pRdpFileInfo->LastAccessTime.QuadPart = pRxFileInfo->LastAccessTime.QuadPart;
                        pRdpFileInfo->LastWriteTime.QuadPart = pRxFileInfo->LastWriteTime.QuadPart;

                        break;
                    }
                    case FileRenameInformation:
                    {
                        PFILE_RENAME_INFORMATION pRxFileInfo =
                                (PFILE_RENAME_INFORMATION) RxContext->Info.Buffer;
                        PRDP_FILE_RENAME_INFORMATION pRdpFileInfo =
                                (PRDP_FILE_RENAME_INFORMATION) (pIoPacket + 1);

                        pIoPacket->IoRequest.Parameters.SetFile.Length = 
                                cbPacketSize - sizeof(RDPDR_IOREQUEST_PACKET);

                        pRdpFileInfo->ReplaceIfExists = pRxFileInfo->ReplaceIfExists;

                        // Always force the client to setup the root directory.
                        pRdpFileInfo->RootDirectory = 0;
                        
                        pRdpFileInfo->FileNameLength = pRxFileInfo->FileNameLength + sizeof(WCHAR);

                        RtlCopyMemory(pRdpFileInfo->FileName, pRxFileInfo->FileName, 
                                      pRxFileInfo->FileNameLength);

                        break;
                    }
                }
            }
        }

        Status = SendIoRequest(RxContext, pIoPacket, cbPacketSize, 
                (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

        delete pIoPacket;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS DrDrive::QuerySdInfo(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    RDPDR_IOREQUEST_PACKET IoPacket;
    
    BEGIN_FN("DrDrive:QuerySdInfo");

    return STATUS_INVALID_DEVICE_REQUEST;

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //
    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_QUERY_SECURITY);
    ASSERT(Session != NULL);
    
    //
    //  Return not supported if the client doesn't support query security
    //
    if (!(Session->GetClientCapabilitySet().GeneralCap.ioCode1 & RDPDR_IRP_MJ_QUERY_SECURITY)) {
        TRC_DBG((TB, "QuerySdInfo not supported"));
        Status = STATUS_NOT_SUPPORTED;
        return Status;
    }

    if (!Session->IsConnected()) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to query client security information while not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    
    memset(&IoPacket, 0, sizeof(IoPacket));

    IoPacket.Header.Component = RDPDR_CTYP_CORE;
    IoPacket.Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
    IoPacket.IoRequest.DeviceId = _DeviceId;
    IoPacket.IoRequest.FileId = FileObj->GetFileId();
    IoPacket.IoRequest.MajorFunction = IRP_MJ_QUERY_SECURITY;
    IoPacket.IoRequest.MinorFunction = 0;
    IoPacket.IoRequest.Parameters.QuerySd.SecurityInformation = 
            RxContext->QuerySecurity.SecurityInformation;

    Status = SendIoRequest(RxContext, &IoPacket, sizeof(IoPacket), 
            (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

    return Status;
}

NTSTATUS DrDrive::SetSdInfo(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    PRDPDR_IOREQUEST_PACKET IoPacket;
    ULONG SdLength = RtlLengthSecurityDescriptor(RxContext->SetSecurity.SecurityDescriptor);
    ULONG cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) + SdLength;
    
    BEGIN_FN("DrDrive:SetFileInfo");

    return STATUS_INVALID_DEVICE_REQUEST;

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_SET_SECURITY);
    ASSERT(Session != NULL);
    
    //
    //  Return not supported if the client doesn't support query security
    //
    if (!(Session->GetClientCapabilitySet().GeneralCap.ioCode1 & RDPDR_IRP_MJ_SET_SECURITY)) {
        TRC_DBG((TB, "SetSdInfo not supported"));
        Status = STATUS_NOT_SUPPORTED;
        return Status;
    }

    if (!Session->IsConnected()) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to set client device security information while not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    
    IoPacket = (PRDPDR_IOREQUEST_PACKET)new(PagedPool) BYTE[cbPacketSize];

    if (IoPacket != NULL) {

        IoPacket->Header.Component = RDPDR_CTYP_CORE;
        IoPacket->Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
        IoPacket->IoRequest.DeviceId = _DeviceId;
        IoPacket->IoRequest.FileId = FileObj->GetFileId();
        IoPacket->IoRequest.MajorFunction = IRP_MJ_SET_SECURITY;
        IoPacket->IoRequest.MinorFunction = 0;
        IoPacket->IoRequest.Parameters.SetSd.SecurityInformation = 
                RxContext->SetSecurity.SecurityInformation;
        IoPacket->IoRequest.Parameters.SetSd.Length = SdLength;
        RtlCopyMemory(IoPacket + 1,RxContext->SetSecurity.SecurityDescriptor, SdLength);

        Status = SendIoRequest(RxContext, IoPacket, cbPacketSize, 
                               (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));

        delete IoPacket;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS DrDrive::Locks(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    RxCaptureRequestPacket; 
    RxCaptureParamBlock;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    PRDPDR_IOREQUEST_PACKET pIoPacket;
    ULONG cbPacketSize = 0;
    ULONG NumLocks = 0;
    
    BEGIN_FN("DrDrive::Locks");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //
    ASSERT(RxContext != NULL);
    ASSERT(Session != NULL);
    
    // We can be called from Major function other than Lock Control
    // For example, on Cleanup to unlock all the locks.
    // ASSERT(RxContext->MajorFunction == IRP_MJ_LOCK_CONTROL);
    
    if (!Session->IsConnected()) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    if (FileObj == NULL) {
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to lock client device file which is not "
                "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    switch (RxContext->LowIoContext.Operation) {
        case LOWIO_OP_SHAREDLOCK:          
        case LOWIO_OP_EXCLUSIVELOCK:
        case LOWIO_OP_UNLOCK:
            NumLocks = 1;
            break;

        case LOWIO_OP_UNLOCK_MULTIPLE:
        {
            PLOWIO_LOCK_LIST LockList;
            LockList = RxContext->LowIoContext.ParamsFor.Locks.LockList; 
            while (LockList) {
                NumLocks++;
                LockList = LockList->Next;
            }
            break;
        }
    }

    cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) + 
            NumLocks * sizeof(RDP_LOCK_INFO);

    pIoPacket = (PRDPDR_IOREQUEST_PACKET)new(PagedPool) BYTE[cbPacketSize];

    if (pIoPacket) {
        unsigned i;
        PRDP_LOCK_INFO pLockInfo = (PRDP_LOCK_INFO) (pIoPacket + 1);


        memset(pIoPacket, 0, sizeof(pIoPacket));

        pIoPacket->Header.Component = RDPDR_CTYP_CORE;
        pIoPacket->Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
        pIoPacket->IoRequest.DeviceId = _DeviceId;
        pIoPacket->IoRequest.FileId = FileObj->GetFileId();
        pIoPacket->IoRequest.MajorFunction = IRP_MJ_LOCK_CONTROL;
        pIoPacket->IoRequest.MinorFunction = 0;
        pIoPacket->IoRequest.Parameters.Locks.Operation =
                RxContext->LowIoContext.Operation;
        pIoPacket->IoRequest.Parameters.Locks.Flags =
                (capPARAMS->Flags & SL_FAIL_IMMEDIATELY) ? SL_FAIL_IMMEDIATELY: 0;
        pIoPacket->IoRequest.Parameters.Locks.NumLocks = NumLocks;

        if (NumLocks == 1) {
            pLockInfo->LengthLow = 
                    ((LONG)((LONGLONG)(RxContext->LowIoContext.ParamsFor.Locks.Length) 
                    & 0xffffffff));
            pLockInfo->LengthHigh = 
                    ((LONG)((LONGLONG)(RxContext->LowIoContext.ParamsFor.Locks.Length) 
                    >> 32));
            pLockInfo->OffsetLow =
                    ((LONG)((LONGLONG)(RxContext->LowIoContext.ParamsFor.Locks.ByteOffset) 
                    & 0xffffffff));
            pLockInfo->OffsetHigh =
                    ((LONG)((LONGLONG)(RxContext->LowIoContext.ParamsFor.Locks.ByteOffset) 
                    >> 32));
        }
        else {
            PLOWIO_LOCK_LIST LockList;
            LockList = RxContext->LowIoContext.ParamsFor.Locks.LockList;

            for (i = 0; i < NumLocks; i++) {
                pLockInfo->LengthLow = 
                        ((LONG)((LONGLONG)(LockList->Length) & 0xffffffff));
                pLockInfo->LengthHigh = 
                        ((LONG)((LONGLONG)(LockList->Length) >> 32));
                pLockInfo->OffsetLow =
                        ((LONG)((LONGLONG)(LockList->ByteOffset) & 0xffffffff));
                pLockInfo->OffsetHigh =
                        ((LONG)((LONGLONG)(LockList->ByteOffset) >> 32));
                pLockInfo++;
                LockList = LockList->Next;
            }
        }

        Status = SendIoRequest(RxContext, pIoPacket, cbPacketSize, 
                (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
        TRC_NRM((TB, "IoRequestWrite returned to DrRead: %lx", Status));

        delete pIoPacket;
    }
    else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;
}

NTSTATUS DrDrive::OnDirectoryControlCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;

    BEGIN_FN("DrDrive::OnDirectoryControlCompletion");

    if (Context->_MinorFunction == IRP_MN_QUERY_DIRECTORY ||
            Context->_MinorFunction == 0) {
        return OnQueryDirectoryCompletion(CompletionPacket, cbPacket,
                    DoDefaultRead, Exchange);
    }
    else if (Context->_MinorFunction == IRP_MN_NOTIFY_CHANGE_DIRECTORY) {
        return OnNotifyChangeDirectoryCompletion(CompletionPacket, cbPacket,
                    DoDefaultRead, Exchange);
    }
    else {
        ASSERT(FALSE);
        
        if (Context->_RxContext != NULL) {
            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
        } else {
            DiscardBusyExchange(Exchange);
        }

        *DoDefaultRead = FALSE;
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }
}

NTSTATUS DrDrive::OnQueryDirectoryCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    PRX_CONTEXT RxContext;
    PVOID pData = CompletionPacket->IoCompletion.Parameters.QueryDir.Buffer; 
    ULONG cbWantData;  // Amount of actual Read data in this packet
    ULONG cbHaveData;  // Amount of data available so far
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;
    NTSTATUS Status;

    BEGIN_FN("DrDrive::OnQueryDirectoryCompletion");

    //
    // Even if the IO was cancelled we need to correctly parse
    // this data.
    //
    // Check to make sure this is up to size before accessing 
    // further portions of the packet
    //

    RxContext = Context->_RxContext;

    if (cbPacket < (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
            IoCompletion.Parameters.QueryDir.Buffer)) {

        //
        // Bad packet. Bad. We've already claimed the RxContext in the
        // atlas. Complete it as unsuccessful. Then shutdown the channel
        // as this is a Bad Client.
        //

        TRC_ERR((TB, "Detected bad client query directory packet"));

        if (RxContext != NULL) {
            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
        } else {
            DiscardBusyExchange(Exchange);
        }

        //
        // No point in starting a default read or anything, what with the
        // channel being shut down and all.
        //

        *DoDefaultRead = FALSE;
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    //
    // Calculate how much data is available immediately and how much data
    // is coming
    //

    if (NT_SUCCESS(CompletionPacket->IoCompletion.IoStatus)) {

        //
        // Successful IO at the client end
        //

        TRC_DBG((TB, "Successful Read at the client end"));
        TRC_DBG((TB, "Read Length: 0x%d, DataCopied 0x%d",
                CompletionPacket->IoCompletion.Parameters.QueryDir.Length,
                Context->_DataCopied));
        cbWantData = CompletionPacket->IoCompletion.Parameters.QueryDir.Length -
                Context->_DataCopied;
        cbHaveData = cbPacket - (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                IoCompletion.Parameters.QueryDir.Buffer);

        if (cbHaveData > cbWantData) {
            //
            // Sounds like a bad client to me
            //

            TRC_ERR((TB, "QueryDir returned more data than "
                    "advertised cbHaveData 0x%d cbWantData 0x%d", 
                    cbHaveData, cbWantData));

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
            } else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = FALSE;
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }

        if (RxContext != NULL) { // And not drexchCancelled
            DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
            SmartPtr<DrFile> FileObj = pFile;

            ASSERT(FileObj != NULL);

            TRC_DBG((TB, "Copying data for Query Directory"));

            if (cbHaveData < cbWantData || Context->_DataCopied) {
                if (FileObj->GetBufferSize() < CompletionPacket->IoCompletion.Parameters.QueryDir.Length) {
                    if (!FileObj->AllocateBuffer(CompletionPacket->IoCompletion.Parameters.QueryDir.Length)) {
                        CompleteBusyExchange(Exchange, STATUS_INSUFFICIENT_RESOURCES, 0);
                        *DoDefaultRead = FALSE;
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                RtlCopyMemory(FileObj->GetBuffer() + Context->_DataCopied, pData, cbHaveData);

                //
                // Keep track of how much data we've copied in case this is a
                // multi chunk completion
                //
                Context->_DataCopied += cbHaveData;
            }                                  
        }

        if (cbHaveData == cbWantData) {
            //
            // There is exactly as much data as we need to satisfy the read,
            // I like it.
            //

            if (RxContext != NULL) {
                DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
                SmartPtr<DrFile> FileObj = pFile;
                FILE_INFORMATION_CLASS FileInformationClass = RxContext->Info.FileInformationClass;
                PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
                PBYTE pBuffer;
                ULONG BufferLength;

                if (!Context->_DataCopied) {
                    pBuffer = (PBYTE) pData;
                }
                else {
                    pBuffer = FileObj->GetBuffer();
                }

                BufferLength = CompletionPacket->IoCompletion.Parameters.QueryDir.Length;

                switch (FileInformationClass) {
                    case FileDirectoryInformation:
                    {
                        PFILE_DIRECTORY_INFORMATION pRxBuffer = (PFILE_DIRECTORY_INFORMATION)
                                (RxContext->Info.Buffer);
                        PRDP_FILE_DIRECTORY_INFORMATION pRetBuffer = 
                                (PRDP_FILE_DIRECTORY_INFORMATION)pBuffer;

                        if (BufferLength >= FIELD_OFFSET(RDP_FILE_DIRECTORY_INFORMATION, FileName)) {
                            if (*pLengthRemaining >= FIELD_OFFSET(FILE_DIRECTORY_INFORMATION, FileName)) {
                                pRxBuffer->AllocationSize.QuadPart = pRetBuffer->AllocationSize.QuadPart;
                                pRxBuffer->ChangeTime.QuadPart = pRetBuffer->ChangeTime.QuadPart;
                                pRxBuffer->CreationTime.QuadPart = pRetBuffer->CreationTime.QuadPart;
                                pRxBuffer->EndOfFile.QuadPart = pRetBuffer->EndOfFile.QuadPart;
                                pRxBuffer->FileAttributes = pRetBuffer->FileAttributes;
                                pRxBuffer->FileIndex = pRetBuffer->FileIndex;
                                pRxBuffer->FileNameLength = pRetBuffer->FileNameLength;
                                pRxBuffer->LastAccessTime.QuadPart = pRetBuffer->LastAccessTime.QuadPart;
                                pRxBuffer->LastWriteTime.QuadPart = pRetBuffer->LastWriteTime.QuadPart;
                                pRxBuffer->NextEntryOffset = pRetBuffer->NextEntryOffset;

                                *pLengthRemaining -= (FIELD_OFFSET(FILE_DIRECTORY_INFORMATION, FileName));

                                if ((ULONG)*pLengthRemaining >= pRxBuffer->FileNameLength) {
                                    if (BufferLength == 
                                            FIELD_OFFSET(RDP_FILE_DIRECTORY_INFORMATION, FileName) +
                                            pRxBuffer->FileNameLength) {
                                        RtlCopyMemory(pRxBuffer->FileName, pRetBuffer->FileName, 
                                                      pRxBuffer->FileNameLength);
                                        *pLengthRemaining -= pRxBuffer->FileNameLength;
                                    } 
                                    else {
                                        TRC_ERR((TB, "Directory Information is invalid"));
                                        CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                                        *DoDefaultRead = TRUE;
                                        return STATUS_DEVICE_PROTOCOL_ERROR;
                                    }
                                }
                                else {
                                    TRC_ERR((TB, "Directory Information, RxBuffer overflows"));
                                    CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                    *DoDefaultRead = TRUE;
                                    return STATUS_SUCCESS;
                                }
                            }
                            else {
                                TRC_ERR((TB, "Directory Information, RxBuffer overflows"));
                                CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                *DoDefaultRead = TRUE;
                                return STATUS_SUCCESS;
                            }
                        }
                        else {
                            TRC_ERR((TB, "Directory Information, Bad data length"));
                            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                            *DoDefaultRead = TRUE;
                            return STATUS_DEVICE_PROTOCOL_ERROR;
                        }
                    }
                    break;

                    case FileFullDirectoryInformation:
                    {
                        PFILE_FULL_DIR_INFORMATION pRxBuffer = (PFILE_FULL_DIR_INFORMATION)
                                (RxContext->Info.Buffer);
                        PRDP_FILE_FULL_DIR_INFORMATION pRetBuffer = 
                                (PRDP_FILE_FULL_DIR_INFORMATION) pBuffer;

                        if (BufferLength >= FIELD_OFFSET(RDP_FILE_FULL_DIR_INFORMATION, FileName)) {
                            if (*pLengthRemaining >= FIELD_OFFSET(FILE_FULL_DIR_INFORMATION, FileName)) {
                                pRxBuffer->AllocationSize.QuadPart = pRetBuffer->AllocationSize.QuadPart;
                                pRxBuffer->ChangeTime.QuadPart = pRetBuffer->ChangeTime.QuadPart;
                                pRxBuffer->CreationTime.QuadPart = pRetBuffer->CreationTime.QuadPart;
                                pRxBuffer->EaSize = pRetBuffer->EaSize;
                                pRxBuffer->EndOfFile.QuadPart = pRetBuffer->EndOfFile.QuadPart;
                                pRxBuffer->FileAttributes = pRetBuffer->FileAttributes;
                                pRxBuffer->FileIndex = pRetBuffer->FileIndex;
                                pRxBuffer->FileNameLength = pRetBuffer->FileNameLength;
                                pRxBuffer->LastAccessTime.QuadPart = pRetBuffer->LastAccessTime.QuadPart;
                                pRxBuffer->LastWriteTime.QuadPart = pRetBuffer->LastWriteTime.QuadPart;
                                pRxBuffer->NextEntryOffset = pRetBuffer->NextEntryOffset;

                                *pLengthRemaining -= (FIELD_OFFSET(FILE_FULL_DIR_INFORMATION, FileName));

                                if ((ULONG)*pLengthRemaining >= pRxBuffer->FileNameLength) {
                                    if (BufferLength == 
                                            FIELD_OFFSET(RDP_FILE_FULL_DIR_INFORMATION, FileName) +
                                            pRxBuffer->FileNameLength) {
                                        RtlCopyMemory(pRxBuffer->FileName, pRetBuffer->FileName, 
                                                pRxBuffer->FileNameLength);
                                        *pLengthRemaining -= pRxBuffer->FileNameLength;
                                    }
                                    else {
                                        TRC_ERR((TB, "Directory Full Information is invalid"));
                                        CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                                        *DoDefaultRead = TRUE;
                                        return STATUS_DEVICE_PROTOCOL_ERROR;
                                    }
                                }
                                else {
                                    TRC_ERR((TB, "Directory Full Information, RxBuffer overflows"));
                                    CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                    *DoDefaultRead = TRUE;
                                    return STATUS_SUCCESS;
                                }
                            }
                            else {
                                TRC_ERR((TB, "Directory Full Information, RxBuffer overflows"));
                                CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                *DoDefaultRead = TRUE;
                                return STATUS_SUCCESS;
                            }
                        }
                        else {
                            TRC_ERR((TB, "Directory Full Information, bad data length"));
                            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                            *DoDefaultRead = TRUE;
                            return STATUS_DEVICE_PROTOCOL_ERROR;
                        }
                    }

                    break;

                    case FileBothDirectoryInformation:
                    {
                        PFILE_BOTH_DIR_INFORMATION pRxBuffer = (PFILE_BOTH_DIR_INFORMATION)
                                (RxContext->Info.Buffer);
                        PRDP_FILE_BOTH_DIR_INFORMATION pRetBuffer = 
                                (PRDP_FILE_BOTH_DIR_INFORMATION) pBuffer;

                        if (BufferLength >= FIELD_OFFSET(RDP_FILE_BOTH_DIR_INFORMATION, FileName)) {
                            if (*pLengthRemaining >= FIELD_OFFSET(FILE_BOTH_DIR_INFORMATION, FileName)) {
                                pRxBuffer->AllocationSize.QuadPart = pRetBuffer->AllocationSize.QuadPart;
                                pRxBuffer->ChangeTime.QuadPart = pRetBuffer->ChangeTime.QuadPart;
                                pRxBuffer->CreationTime.QuadPart = pRetBuffer->CreationTime.QuadPart;
                                pRxBuffer->EaSize = pRetBuffer->EaSize;
                                pRxBuffer->EndOfFile.QuadPart = pRetBuffer->EndOfFile.QuadPart;
                                pRxBuffer->FileAttributes = pRetBuffer->FileAttributes;
                                pRxBuffer->FileIndex = pRetBuffer->FileIndex;
                                pRxBuffer->FileNameLength = pRetBuffer->FileNameLength;
                                pRxBuffer->LastAccessTime.QuadPart = pRetBuffer->LastAccessTime.QuadPart;
                                pRxBuffer->LastWriteTime.QuadPart = pRetBuffer->LastWriteTime.QuadPart;
                                pRxBuffer->NextEntryOffset = pRetBuffer->NextEntryOffset;
                                pRxBuffer->ShortNameLength = pRetBuffer->ShortNameLength;
                                RtlCopyMemory(pRxBuffer->ShortName, pRetBuffer->ShortName, 
                                              sizeof(pRxBuffer->ShortName));
                                           
                                *pLengthRemaining -= (FIELD_OFFSET(FILE_BOTH_DIR_INFORMATION, FileName));

                                if ((ULONG)*pLengthRemaining >= pRxBuffer->FileNameLength) {
                                    if ((BufferLength == 
                                            FIELD_OFFSET(RDP_FILE_BOTH_DIR_INFORMATION, FileName) +
                                            pRxBuffer->FileNameLength)  &&
                                            (pRxBuffer->ShortNameLength <= sizeof(pRxBuffer->ShortName))) {
                                        RtlCopyMemory(pRxBuffer->FileName, pRetBuffer->FileName, 
                                                pRxBuffer->FileNameLength);
                                        *pLengthRemaining -= pRxBuffer->FileNameLength;
                                    }
                                    else {
                                        TRC_ERR((TB, "Directory Both Information is invalid"));
                                        CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                                        *DoDefaultRead = TRUE;
                                        return STATUS_DEVICE_PROTOCOL_ERROR;
                                    }
                                }
                                else {
                                    TRC_ERR((TB, "Directory Both Information, RxBuffer overflows"));
                                    CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                    *DoDefaultRead = TRUE;
                                    return STATUS_SUCCESS;
                                }
                            }
                            else {
                                TRC_ERR((TB, "Directory Both Information, RxBuffer overflows"));
                                CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                *DoDefaultRead = TRUE;
                                return STATUS_SUCCESS;
                            }
                        }
                        else {
                            TRC_ERR((TB, "Directory Both Information, bad data length"));
                            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                            *DoDefaultRead = TRUE;
                            return STATUS_DEVICE_PROTOCOL_ERROR;
                        }
                    }
                    break;

                    case FileNamesInformation:
                    {
                        PFILE_NAMES_INFORMATION pRxBuffer = (PFILE_NAMES_INFORMATION)
                                (RxContext->Info.Buffer);
                        PRDP_FILE_NAMES_INFORMATION pRetBuffer = 
                                (PRDP_FILE_NAMES_INFORMATION) pBuffer;

                        if (BufferLength >= FIELD_OFFSET(RDP_FILE_NAMES_INFORMATION, FileName)) {
                            if (*pLengthRemaining >= FIELD_OFFSET(FILE_NAMES_INFORMATION, FileName)) {
                                pRxBuffer->FileIndex = pRetBuffer->FileIndex;
                                pRxBuffer->FileNameLength = pRetBuffer->FileNameLength;
                                pRxBuffer->NextEntryOffset = pRetBuffer->NextEntryOffset;

                                *pLengthRemaining -= (FIELD_OFFSET(FILE_NAMES_INFORMATION, FileName));

                                if ((ULONG)*pLengthRemaining >= pRxBuffer->FileNameLength) {
                                    if (BufferLength == 
                                            FIELD_OFFSET(RDP_FILE_NAMES_INFORMATION, FileName) +
                                            pRxBuffer->FileNameLength) {
                                        RtlCopyMemory(pRxBuffer->FileName, pRetBuffer->FileName, 
                                                      pRxBuffer->FileNameLength);
                                        *pLengthRemaining -= pRxBuffer->FileNameLength;
                                    } else {
                                        TRC_ERR((TB, "Directory Names Information is invalid"));
                                        CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                                        *DoDefaultRead = TRUE;
                                        return STATUS_DEVICE_PROTOCOL_ERROR;
                                    }
                                } else {
                                    TRC_ERR((TB, "Directory Names Information, RxBuffer overflows"));
                                    CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                    *DoDefaultRead = TRUE;
                                    return STATUS_SUCCESS;
                                }
                            } else {
                                TRC_ERR((TB, "Directory Names Information, RxBuffer overflows"));
                                CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                *DoDefaultRead = TRUE;
                                return STATUS_SUCCESS;
                            }
                        } else {
                            TRC_ERR((TB, "Directory Names Information, bad data length"));
                            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                            *DoDefaultRead = TRUE;
                            return STATUS_DEVICE_PROTOCOL_ERROR;
                        }
                    }
                    break;

                    default:
                        TRC_ERR((TB, "Directory Information Class is invalid"));
                        CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                        *DoDefaultRead = TRUE;
                        return STATUS_DEVICE_PROTOCOL_ERROR;
                }

                CompleteBusyExchange(Exchange, 
                        CompletionPacket->IoCompletion.IoStatus,
                        CompletionPacket->IoCompletion.Parameters.QueryDir.Length);
            } else {
                DiscardBusyExchange(Exchange);
            }

            //
            // Go with a default channel read now
            //

            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        } else {

            //
            // We don't have all the data yet, release the DrExchange and 
            // read more data
            //

            MarkIdle(Exchange);

            _Session->GetExchangeManager().ReadMore(
                    (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.QueryDir.Buffer));

            *DoDefaultRead = FALSE;
            return STATUS_SUCCESS;
        }
    } else {

        //
        // Unsuccessful IO at the client end
        //

        TRC_DBG((TB, "Unsuccessful Read at the client end"));
        if (cbPacket >= sizeof(RDPDR_IOCOMPLETION_PACKET)) {
            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, 
                    CompletionPacket->IoCompletion.IoStatus,
                    0);
            }
            else {
                DiscardBusyExchange(Exchange);
            }
            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        } else {
            TRC_ERR((TB, "Query directory returned invalid data "));

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
            } else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = FALSE;
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
    }
}

NTSTATUS DrDrive::OnNotifyChangeDirectoryCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    PRX_CONTEXT RxContext;
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;

    BEGIN_FN("DrDrive::OnNotifyChangeDirectoryCompletion");

    RxContext = Context->_RxContext;

    if (RxContext != NULL) {
        
        ASSERT(RxContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL);

        TRC_NRM((TB, "Irp: %s, Completion Status: %lx",
                IrpNames[RxContext->MajorFunction],
                CompletionPacket->IoCompletion.IoStatus));
        
        RxContext->InformationToReturn = 0;
        RxContext->StoredStatus = CompletionPacket->IoCompletion.IoStatus;
        
        CompleteBusyExchange(Exchange, CompletionPacket->IoCompletion.IoStatus, 0);

    } else {
        //
        // Was cancelled but Context wasn't cleaned up
        //
        DiscardBusyExchange(Exchange);
    }

    return STATUS_SUCCESS;
}

NTSTATUS DrDrive::OnQueryVolumeInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    PRX_CONTEXT RxContext;
    PVOID pData = CompletionPacket->IoCompletion.Parameters.QueryVolume.Buffer; 
    ULONG cbWantData;  // Amount of actual Read data in this packet
    ULONG cbHaveData;  // Amount of data available so far
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;
    NTSTATUS Status;
    
    BEGIN_FN("DrDrive::OnQueryVolumeInfoCompletion");

    //
    // Even if the IO was cancelled we need to correctly parse
    // this data.
    //
    // Check to make sure this is up to size before accessing 
    // further portions of the packet
    //

    RxContext = Context->_RxContext;

    if (cbPacket < (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
            IoCompletion.Parameters.QueryVolume.Buffer)) {
        //
        // Bad packet. Bad. We've already claimed the RxContext in the
        // atlas. Complete it as unsuccessful. Then shutdown the channel
        // as this is a Bad Client.
        //

        TRC_ERR((TB, "Detected bad client query volume packet"));

        if (RxContext != NULL) {
            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
        } else {
            DiscardBusyExchange(Exchange);
        }

        //
        // No point in starting a default read or anything, what with the
        // channel being shut down and all.
        //

        *DoDefaultRead = FALSE;
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    //
    // Calculate how much data is available immediately and how much data
    // is coming
    //

    if (NT_SUCCESS(CompletionPacket->IoCompletion.IoStatus)) {

        //
        // Successful IO at the client end
        //

        TRC_DBG((TB, "Successful Read at the client end"));
        TRC_DBG((TB, "Read Length: 0x%d, DataCopied 0x%d",
                CompletionPacket->IoCompletion.Parameters.QueryVolume.Length,
                Context->_DataCopied));
        cbWantData = CompletionPacket->IoCompletion.Parameters.QueryVolume.Length -
                Context->_DataCopied;
        cbHaveData = cbPacket - (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                IoCompletion.Parameters.QueryVolume.Buffer);

        if (cbHaveData > cbWantData) {
            //
            // Sounds like a bad client to me
            //

            TRC_ERR((TB, "Query volume returned more data than "
                    "advertised cbHaveData 0x%d cbWantData 0x%d", 
                    cbHaveData, cbWantData));

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
            } else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = FALSE;
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }

        if (RxContext != NULL) { // And not drexchCancelled
            DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
            SmartPtr<DrFile> FileObj = pFile;

            ASSERT(FileObj != NULL);

            TRC_DBG((TB, "Copying data for Query Volume"));

            if (cbHaveData < cbWantData || Context->_DataCopied) {
                if (FileObj->GetBufferSize() < CompletionPacket->IoCompletion.Parameters.QueryVolume.Length) {
                    if (!FileObj->AllocateBuffer(CompletionPacket->IoCompletion.Parameters.QueryVolume.Length)) {
                        CompleteBusyExchange(Exchange, STATUS_INSUFFICIENT_RESOURCES, 0);
                        *DoDefaultRead = FALSE;
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                RtlCopyMemory(FileObj->GetBuffer() + Context->_DataCopied, pData, cbHaveData);

                //
                // Keep track of how much data we've copied in case this is a
                // multi chunk completion
                //
                Context->_DataCopied += cbHaveData;
            } 
        }

        if (cbHaveData == cbWantData) {
            if (RxContext != NULL) {
                DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
                SmartPtr<DrFile> FileObj = pFile;
                FS_INFORMATION_CLASS FsInformationClass = RxContext->Info.FsInformationClass;
                PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
                PBYTE pBuffer;
                ULONG BufferLength;

                //
                // There is exactly as much data as we need to satisfy the read,
                // I like it.
                //
                if (!Context->_DataCopied) {
                    pBuffer = (PBYTE) pData;
                } else {
                    pBuffer = FileObj->GetBuffer();
                }

                BufferLength = CompletionPacket->IoCompletion.Parameters.QueryVolume.Length;

                switch (FsInformationClass) {
                    case FileFsVolumeInformation:
                    {
                        PFILE_FS_VOLUME_INFORMATION pRxBuffer = (PFILE_FS_VOLUME_INFORMATION)
                                (RxContext->Info.Buffer);
                        PRDP_FILE_FS_VOLUME_INFORMATION pRetBuffer = 
                                (PRDP_FILE_FS_VOLUME_INFORMATION) pBuffer;
                                
                        if (BufferLength >= FIELD_OFFSET(RDP_FILE_FS_VOLUME_INFORMATION, VolumeLabel)) {
                            if (*pLengthRemaining >= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel)) {
                                pRxBuffer->SupportsObjects = pRetBuffer->SupportsObjects;
                                pRxBuffer->VolumeCreationTime.QuadPart = pRetBuffer->VolumeCreationTime.QuadPart;
                                pRxBuffer->VolumeSerialNumber = pRetBuffer->VolumeSerialNumber;
                                pRxBuffer->VolumeLabelLength = pRetBuffer->VolumeLabelLength;

                                *pLengthRemaining -= (FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel));

                                if ((ULONG)*pLengthRemaining >= pRxBuffer->VolumeLabelLength) {
                                    if (BufferLength == 
                                            FIELD_OFFSET(RDP_FILE_FS_VOLUME_INFORMATION, VolumeLabel) +
                                            pRxBuffer->VolumeLabelLength) {
                                        RtlCopyMemory(pRxBuffer->VolumeLabel, pRetBuffer->VolumeLabel, 
                                                      pRxBuffer->VolumeLabelLength);
                                        *pLengthRemaining -= pRxBuffer->VolumeLabelLength;
                                    } else {
                                        TRC_ERR((TB, "Volume Information is invalid"));
                                        CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                                        *DoDefaultRead = TRUE;
                                        return STATUS_DEVICE_PROTOCOL_ERROR;
                                    }
                                } else {
                                    TRC_NRM((TB, "Volume Information, RxBuffer overflows"));
                                    CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                    *DoDefaultRead = TRUE;
                                    return STATUS_SUCCESS;
                                }
                            } else {
                                TRC_ERR((TB, "Volume Information, RxBuffer overflows"));
                                CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                *DoDefaultRead = TRUE;
                                return STATUS_SUCCESS;
                            }
                        } else {
                            TRC_ERR((TB, "Volume Information, bad data length"));
                            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                            *DoDefaultRead = TRUE;
                            return STATUS_DEVICE_PROTOCOL_ERROR;
                        }
                    }
                    break;

                    case FileFsSizeInformation:
                    {
                        PFILE_FS_SIZE_INFORMATION pRxBuffer = (PFILE_FS_SIZE_INFORMATION)
                                (RxContext->Info.Buffer);
                        PRDP_FILE_FS_SIZE_INFORMATION pRetBuffer = 
                                (PRDP_FILE_FS_SIZE_INFORMATION) pBuffer;
                                
                        if (BufferLength == sizeof(RDP_FILE_FS_SIZE_INFORMATION)) {
                            if (*pLengthRemaining >= sizeof(FILE_FS_SIZE_INFORMATION)) {

                                pRxBuffer->AvailableAllocationUnits.QuadPart = 
                                        pRetBuffer->AvailableAllocationUnits.QuadPart;
                                pRxBuffer->BytesPerSector = pRetBuffer->BytesPerSector;
                                pRxBuffer->SectorsPerAllocationUnit = pRetBuffer->SectorsPerAllocationUnit;
                                pRxBuffer->TotalAllocationUnits.QuadPart =
                                        pRetBuffer->TotalAllocationUnits.QuadPart;

                                *pLengthRemaining -= (sizeof(FILE_FS_SIZE_INFORMATION));

                            } else {
                                TRC_ERR((TB, "Volume Size Information, RxBuffer overflows"));
                                CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                *DoDefaultRead = TRUE;
                                return STATUS_SUCCESS;
                            }
                        } else {
                            TRC_ERR((TB, "Volume Size Information, bad data length"));
                            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                            *DoDefaultRead = TRUE;
                            return STATUS_DEVICE_PROTOCOL_ERROR;
                        }

                    }
                    break;

                    case FileFsFullSizeInformation:
                    {
                        PFILE_FS_FULL_SIZE_INFORMATION pRxBuffer = (PFILE_FS_FULL_SIZE_INFORMATION)
                                (RxContext->Info.Buffer);
                        PRDP_FILE_FS_FULL_SIZE_INFORMATION pRetBuffer = 
                                (PRDP_FILE_FS_FULL_SIZE_INFORMATION) pBuffer;
                                
                        if (BufferLength == sizeof(RDP_FILE_FS_FULL_SIZE_INFORMATION)) {
                            if (*pLengthRemaining >= sizeof(FILE_FS_FULL_SIZE_INFORMATION)) {

                                pRxBuffer->ActualAvailableAllocationUnits.QuadPart = 
                                        pRetBuffer->ActualAvailableAllocationUnits.QuadPart;
                                pRxBuffer->BytesPerSector = pRetBuffer->BytesPerSector;
                                pRxBuffer->SectorsPerAllocationUnit = pRetBuffer->SectorsPerAllocationUnit;
                                pRxBuffer->TotalAllocationUnits.QuadPart =
                                        pRetBuffer->TotalAllocationUnits.QuadPart;
                                pRxBuffer->CallerAvailableAllocationUnits.QuadPart =
                                        pRetBuffer->CallerAvailableAllocationUnits.QuadPart;

                                *pLengthRemaining -= (sizeof(FILE_FS_FULL_SIZE_INFORMATION));

                            } else {
                                TRC_ERR((TB, "Volume Size Information, RxBuffer overflows"));
                                CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                *DoDefaultRead = TRUE;
                                return STATUS_SUCCESS;
                            }
                        } else {
                            TRC_ERR((TB, "Volume Size Information, bad data length"));
                            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                            *DoDefaultRead = TRUE;
                            return STATUS_DEVICE_PROTOCOL_ERROR;
                        }
                    }
                    break;

                    case FileFsAttributeInformation: 
                    {
                        PFILE_FS_ATTRIBUTE_INFORMATION pRxBuffer = (PFILE_FS_ATTRIBUTE_INFORMATION)
                                (RxContext->Info.Buffer);
                        PRDP_FILE_FS_ATTRIBUTE_INFORMATION pRetBuffer = 
                                (PRDP_FILE_FS_ATTRIBUTE_INFORMATION) pBuffer;

                        if (BufferLength >= FIELD_OFFSET(RDP_FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName)) {
                            if (*pLengthRemaining >= FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName)) {
                                pRxBuffer->FileSystemAttributes = pRetBuffer->FileSystemAttributes;
                                pRxBuffer->MaximumComponentNameLength = pRetBuffer->MaximumComponentNameLength;
                                pRxBuffer->FileSystemNameLength = pRetBuffer->FileSystemNameLength;

                                *pLengthRemaining -= (FIELD_OFFSET(FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName));

                                if ((ULONG)*pLengthRemaining >= pRxBuffer->FileSystemNameLength) {
                                    if (BufferLength == 
                                            FIELD_OFFSET(RDP_FILE_FS_ATTRIBUTE_INFORMATION, FileSystemName) +
                                            pRxBuffer->FileSystemNameLength) {
                                        RtlCopyMemory(pRxBuffer->FileSystemName, pRetBuffer->FileSystemName, 
                                                      pRxBuffer->FileSystemNameLength);
                                        *pLengthRemaining -= pRxBuffer->FileSystemNameLength;
                                    } else {
                                        TRC_ERR((TB, "Volume Attributes Information is invalid"));
                                        CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                                        *DoDefaultRead = TRUE;
                                        return STATUS_DEVICE_PROTOCOL_ERROR;
                                    }
                                } else {
                                    TRC_ERR((TB, "Volume Attributes Information, RxBuffer overflows"));
                                    CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                    *DoDefaultRead = TRUE;
                                    return STATUS_SUCCESS;
                                }
                            } else {
                                TRC_ERR((TB, "Volume Attributes Information, RxBuffer overflows"));
                                CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                *DoDefaultRead = TRUE;
                                return STATUS_SUCCESS;
                            }
                        } else {
                            TRC_ERR((TB, "Volume Attributes Information, bad data length"));
                            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                            *DoDefaultRead = TRUE;
                            return STATUS_DEVICE_PROTOCOL_ERROR;
                        }
                    }
                    break;

                    default:
                        TRC_ERR((TB, "Volume Information Class is invalid"));
                        CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                        *DoDefaultRead = TRUE;
                        return STATUS_DEVICE_PROTOCOL_ERROR;
                }
            
                CompleteBusyExchange(Exchange, 
                    CompletionPacket->IoCompletion.IoStatus,
                    CompletionPacket->IoCompletion.Parameters.QueryVolume.Length);
            } else {
                DiscardBusyExchange(Exchange);
            }

            //
            // Go with a default channel read now
            //

            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        } else {

            //
            // We don't have all the data yet, release the DrExchange and 
            // read more data
            //

            MarkIdle(Exchange);

            _Session->GetExchangeManager().ReadMore(
                    (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.QueryVolume.Buffer));

            *DoDefaultRead = FALSE;
            return STATUS_SUCCESS;
        }
    } else {

        //
        // Unsuccessful IO at the client end
        //

        TRC_DBG((TB, "Unsuccessful Read at the client end"));
        if (cbPacket >= sizeof(RDPDR_IOCOMPLETION_PACKET)) {
            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, 
                        CompletionPacket->IoCompletion.IoStatus, 0);
            }
            else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        } else {
            TRC_ERR((TB, "Query volume returned invalid data "));

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
            } else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = FALSE;
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
    }
}

NTSTATUS DrDrive::OnSetVolumeInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    PRX_CONTEXT RxContext;
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;

    BEGIN_FN("DrDrive::OnSetVolumeInfoCompletion");

    RxContext = Context->_RxContext;
    if (RxContext != NULL) {
        ASSERT(RxContext->MajorFunction == IRP_MJ_SET_VOLUME_INFORMATION);

        TRC_NRM((TB, "Irp: %s, Completion Status: %lx",
                IrpNames[RxContext->MajorFunction],
                RxContext->IoStatusBlock.Status));

        CompleteBusyExchange(Exchange, CompletionPacket->IoCompletion.IoStatus, 0);
    } else {
        //
        // Was cancelled but Context wasn't cleaned up
        //
        DiscardBusyExchange(Exchange);
    }
    return STATUS_SUCCESS;
}

NTSTATUS DrDrive::OnQueryFileInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    PRX_CONTEXT RxContext;
    PVOID pData = CompletionPacket->IoCompletion.Parameters.QueryFile.Buffer; 
    ULONG cbWantData;  // Amount of actual Read data in this packet
    ULONG cbHaveData;  // Amount of data available so far
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;
    NTSTATUS Status;

    BEGIN_FN("DrDrive::OnQueryFileInfoCompletion");

    //
    // Even if the IO was cancelled we need to correctly parse
    // this data.
    //
    // Check to make sure this is up to size before accessing 
    // further portions of the packet
    //

    RxContext = Context->_RxContext;

    if (cbPacket < (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
            IoCompletion.Parameters.QueryFile.Buffer)) {
        //
        // Bad packet. Bad. We've already claimed the RxContext in the
        // atlas. Complete it as unsuccessful. Then shutdown the channel
        // as this is a Bad Client.
        //

        TRC_ERR((TB, "Detected bad client read packet"));

        if (RxContext != NULL) {
            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
        } else {
            DiscardBusyExchange(Exchange);
        }

        //
        // No point in starting a default read or anything, what with the
        // channel being shut down and all.
        //

        *DoDefaultRead = FALSE;
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    //
    // Calculate how much data is available immediately and how much data
    // is coming
    //

    if (NT_SUCCESS(CompletionPacket->IoCompletion.IoStatus)) {

        //
        // Successful IO at the client end
        //

        TRC_DBG((TB, "Successful Read at the client end"));
        TRC_DBG((TB, "Read Length: 0x%d, DataCopied 0x%d",
                CompletionPacket->IoCompletion.Parameters.QueryFile.Length,
                Context->_DataCopied));
        cbWantData = CompletionPacket->IoCompletion.Parameters.QueryFile.Length -
                Context->_DataCopied;
        cbHaveData = cbPacket - (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                IoCompletion.Parameters.QueryFile.Buffer);

        if (cbHaveData > cbWantData) {
            //
            // Sounds like a bad client to me
            //

            TRC_ERR((TB, "Query file returned more data than "
                    "advertised cbHaveData 0x%d cbWantData 0x%d", 
                    cbHaveData, cbWantData));

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
            } else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = FALSE;
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }

        if (RxContext != NULL) { // And not drexchCancelled
            DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
            SmartPtr<DrFile> FileObj = pFile;

            ASSERT(FileObj != NULL);

            TRC_DBG((TB, "Copying data for Query File"));

            if (cbHaveData < cbWantData || Context->_DataCopied) {
                if (FileObj->GetBufferSize() < CompletionPacket->IoCompletion.Parameters.QueryFile.Length) {
                    if (!FileObj->AllocateBuffer(CompletionPacket->IoCompletion.Parameters.QueryFile.Length)) {
                        CompleteBusyExchange(Exchange, STATUS_INSUFFICIENT_RESOURCES, 0);
                        *DoDefaultRead = FALSE;
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                RtlCopyMemory(FileObj->GetBuffer() + Context->_DataCopied, pData, cbHaveData);

                //
                // Keep track of how much data we've copied in case this is a
                // multi chunk completion
                //
                Context->_DataCopied += cbHaveData;
            } 
        }

        if (cbHaveData == cbWantData) {

            //
            // There is exactly as much data as we need to satisfy the read,
            // I like it.
            //

            if (RxContext != NULL) {
                DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
                SmartPtr<DrFile> FileObj = pFile;
                FILE_INFORMATION_CLASS FileInformationClass = RxContext->Info.FileInformationClass;
                PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
                PBYTE pBuffer;
                ULONG BufferLength;

                if (!Context->_DataCopied) {
                    pBuffer = (PBYTE) pData;
                }
                else {
                    pBuffer = FileObj->GetBuffer();
                }

                BufferLength = CompletionPacket->IoCompletion.Parameters.QueryDir.Length;

                switch (FileInformationClass) {
                    case FileBasicInformation:
                    {
                        PFILE_BASIC_INFORMATION pRxBuffer = (PFILE_BASIC_INFORMATION)
                                (RxContext->Info.Buffer);
                        PRDP_FILE_BASIC_INFORMATION pRetBuffer = 
                                (PRDP_FILE_BASIC_INFORMATION) pBuffer;

                        if (BufferLength == sizeof(RDP_FILE_BASIC_INFORMATION)) {
                            if (*pLengthRemaining >= sizeof(FILE_BASIC_INFORMATION)) {

                                pRxBuffer->ChangeTime.QuadPart = pRetBuffer->ChangeTime.QuadPart;
                                pRxBuffer->CreationTime.QuadPart = pRetBuffer->CreationTime.QuadPart;
                                pRxBuffer->FileAttributes = pRetBuffer->FileAttributes;
                                pRxBuffer->LastAccessTime.QuadPart =
                                        pRetBuffer->LastAccessTime.QuadPart;
                                pRxBuffer->LastWriteTime.QuadPart =
                                        pRetBuffer->LastWriteTime.QuadPart;

                                *pLengthRemaining -= (sizeof(FILE_BASIC_INFORMATION));

                            } else {
                                TRC_ERR((TB, "File Basic Information, RxBuffer overflows"));
                                CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                *DoDefaultRead = TRUE;
                                return STATUS_SUCCESS;
                            }
                        } else {
                            TRC_ERR((TB, "File Basic Information, bad data length"));
                            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                            *DoDefaultRead = TRUE;
                            return STATUS_DEVICE_PROTOCOL_ERROR;
                        }
                    }
                    break;

                    case FileStandardInformation:
                    {
                        PFILE_STANDARD_INFORMATION pRxBuffer = (PFILE_STANDARD_INFORMATION)
                                (RxContext->Info.Buffer);
                        PRDP_FILE_STANDARD_INFORMATION pRetBuffer = 
                                (PRDP_FILE_STANDARD_INFORMATION) pBuffer;

                        if (BufferLength == sizeof(RDP_FILE_STANDARD_INFORMATION)) {
                            if (*pLengthRemaining >= sizeof(FILE_STANDARD_INFORMATION)) {

                                pRxBuffer->AllocationSize.QuadPart = pRetBuffer->AllocationSize.QuadPart;
                                pRxBuffer->DeletePending = pRetBuffer->DeletePending;
                                pRxBuffer->Directory = pRetBuffer->Directory;
                                pRxBuffer->EndOfFile.QuadPart =
                                        pRetBuffer->EndOfFile.QuadPart;
                                pRxBuffer->NumberOfLinks = pRetBuffer->NumberOfLinks;

                                *pLengthRemaining -= (sizeof(FILE_STANDARD_INFORMATION));

                            } else {
                                TRC_ERR((TB, "File Standard Information, RxBuffer overflows"));
                                CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                *DoDefaultRead = TRUE;
                                return STATUS_SUCCESS;
                            }
                        } else {
                            TRC_ERR((TB, "File Standard Information, bad data length"));
                            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                            *DoDefaultRead = TRUE;
                            return STATUS_DEVICE_PROTOCOL_ERROR;
                        }
                    }
                    break;

                    case FileAttributeTagInformation:
                    {
                        PFILE_ATTRIBUTE_TAG_INFORMATION pRxBuffer = (PFILE_ATTRIBUTE_TAG_INFORMATION)
                                (RxContext->Info.Buffer);
                        PRDP_FILE_ATTRIBUTE_TAG_INFORMATION pRetBuffer = 
                                (PRDP_FILE_ATTRIBUTE_TAG_INFORMATION) pBuffer;

                        if (BufferLength == sizeof(RDP_FILE_ATTRIBUTE_TAG_INFORMATION)) {
                            if (*pLengthRemaining >= sizeof(FILE_ATTRIBUTE_TAG_INFORMATION)) {
                                pRxBuffer->FileAttributes = pRetBuffer->FileAttributes;
                                pRxBuffer->ReparseTag = pRetBuffer->ReparseTag;

                                *pLengthRemaining -= (sizeof(FILE_ATTRIBUTE_TAG_INFORMATION));

                            } else {
                                TRC_ERR((TB, "File Attribute Tag Information, RxBuffer overflows"));
                                CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, 0);
                                *DoDefaultRead = TRUE;
                                return STATUS_SUCCESS;
                            }
                        } else {
                            TRC_ERR((TB, "File Attribute Tag Information, bad data length"));
                            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                            *DoDefaultRead = TRUE;
                            return STATUS_DEVICE_PROTOCOL_ERROR;
                        }
                    }
                    break;

                    default:
                        TRC_ERR((TB, "File Information Class is invalid"));
                        CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                        *DoDefaultRead = TRUE;
                        return STATUS_DEVICE_PROTOCOL_ERROR;
                }
                
                CompleteBusyExchange(Exchange, 
                    CompletionPacket->IoCompletion.IoStatus,
                    CompletionPacket->IoCompletion.Parameters.QueryFile.Length);
            } else {
                DiscardBusyExchange(Exchange);
            }

            //
            // Go with a default channel read now
            //

            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        } else {

            //
            // We don't have all the data yet, release the DrExchange and 
            // read more data
            //

            MarkIdle(Exchange);

            _Session->GetExchangeManager().ReadMore(
                    (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.QueryFile.Buffer));

            *DoDefaultRead = FALSE;
            return STATUS_SUCCESS;
        }
    } else {

        //
        // Unsuccessful IO at the client end
        //

        TRC_DBG((TB, "Unsuccessful Read at the client end"));
        if (cbPacket >= sizeof(RDPDR_IOCOMPLETION_PACKET)) {
            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, 
                        CompletionPacket->IoCompletion.IoStatus, 0);
            }
            else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        } else {
            TRC_ERR((TB, "Query file returned invalid data "));

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
            } else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = FALSE;
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
    }
}

NTSTATUS DrDrive::OnSetFileInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    PRX_CONTEXT RxContext;
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;

    BEGIN_FN("DrDrive::OnSetFileInfoCompletion");

    RxContext = Context->_RxContext;
    if (RxContext != NULL) {
        ASSERT(RxContext->MajorFunction == IRP_MJ_SET_INFORMATION);

        TRC_NRM((TB, "Irp: %s, Completion Status: %lx",
                IrpNames[RxContext->MajorFunction],
                RxContext->IoStatusBlock.Status));

        CompleteBusyExchange(Exchange, CompletionPacket->IoCompletion.IoStatus, 0);        
    } else {

        //
        // Was cancelled but Context wasn't cleaned up
        //

        DiscardBusyExchange(Exchange);
    }

    return STATUS_SUCCESS;
}

NTSTATUS DrDrive::OnQuerySdInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    PRX_CONTEXT RxContext;
    PVOID pData = CompletionPacket->IoCompletion.Parameters.QuerySd.Buffer; 
    ULONG cbWantData;  // Amount of actual Read data in this packet
    ULONG cbHaveData;  // Amount of data available so far
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;
    NTSTATUS Status;
    PVOID pv;

    BEGIN_FN("DrDrive::OnQuerySdInfoCompletion");

    //
    // Even if the IO was cancelled we need to correctly parse
    // this data.
    //
    // Check to make sure this is up to size before accessing 
    // further portions of the packet
    //

    RxContext = Context->_RxContext;

    if (cbPacket < (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
            IoCompletion.Parameters.QuerySd.Buffer)) {

        //
        // Bad packet. Bad. We've already claimed the RxContext in the
        // atlas. Complete it as unsuccessful. Then shutdown the channel
        // as this is a Bad Client.
        //

        TRC_ERR((TB, "Detected bad client read packet"));

        if (RxContext != NULL) {
            CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
        } else {
            DiscardBusyExchange(Exchange);
        }

        //
        // No point in starting a default read or anything, what with the
        // channel being shut down and all.
        //

        *DoDefaultRead = FALSE;
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    //
    // Calculate how much data is available immediately and how much data
    // is coming
    //

    if (NT_SUCCESS(CompletionPacket->IoCompletion.IoStatus)) {

        //
        // Successful IO at the client end
        //

        TRC_DBG((TB, "Successful Read at the client end"));
        TRC_DBG((TB, "Read Length: 0x%d, DataCopied 0x%d",
                CompletionPacket->IoCompletion.Parameters.QuerySd.Length,
                Context->_DataCopied));
        cbWantData = CompletionPacket->IoCompletion.Parameters.QuerySd.Length -
                Context->_DataCopied;
        cbHaveData = cbPacket - (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
            IoCompletion.Parameters.QuerySd.Buffer);

        if (cbHaveData > cbWantData) {
            //
            // Sounds like a bad client to me
            //

            TRC_ERR((TB, "Read returned more data than "
                    "advertised cbHaveData 0x%d cbWantData 0x%d", 
                    cbHaveData, cbWantData));

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
            } else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = FALSE;
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }

        if (RxContext != NULL) { // And not drexchCancelled
            
            DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
            SmartPtr<DrFile> FileObj = pFile;

            ASSERT(FileObj != NULL);

            TRC_DBG((TB, "Copying data for Query File"));

            if (cbHaveData < cbWantData || Context->_DataCopied) {
                if (FileObj->GetBufferSize() < CompletionPacket->IoCompletion.Parameters.QueryFile.Length) {
                    if (!FileObj->AllocateBuffer(CompletionPacket->IoCompletion.Parameters.QueryFile.Length)) {
                        CompleteBusyExchange(Exchange, STATUS_INSUFFICIENT_RESOURCES, 0);
                        *DoDefaultRead = FALSE;
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                RtlCopyMemory(FileObj->GetBuffer() + Context->_DataCopied, pData, cbHaveData);

                //
                // Keep track of how much data we've copied in case this is a
                // multi chunk completion
                //
                Context->_DataCopied += cbHaveData;
            } 
        }

        if (cbHaveData == cbWantData) {
            //
            // There is exactly as much data as we need to satisfy the read,
            // I like it.
            //

            if (RxContext != NULL) {
                DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
                SmartPtr<DrFile> FileObj = pFile;
                PBYTE pBuffer;
                ULONG BufferLength = CompletionPacket->IoCompletion.Parameters.QuerySd.Length;
                PBYTE RxBuffer = (PBYTE)(RxContext->Info.Buffer);
                PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
                
                if (!Context->_DataCopied) {
                    pBuffer = (PBYTE) pData;
                }
                else {
                    pBuffer = FileObj->GetBuffer();
                }

                PSECURITY_DESCRIPTOR SelfRelativeSd = (PSECURITY_DESCRIPTOR)pBuffer;
                ULONG SdLength = RtlLengthSecurityDescriptor(SelfRelativeSd);

                if (BufferLength == SdLength) {
                    if (*pLengthRemaining >= (LONG)SdLength) {
                        RtlCopyMemory(RxBuffer, SelfRelativeSd, SdLength);
                        *pLengthRemaining -= SdLength;                    
                    
                    } 
                    else {
                        TRC_ERR((TB, "File Security Information, RxBuffer overflows"));
                        RxContext->InformationToReturn = SdLength;
                        RxContext->StoredStatus = STATUS_BUFFER_OVERFLOW;
                        CompleteBusyExchange(Exchange, STATUS_BUFFER_OVERFLOW, SdLength);
                        *DoDefaultRead = TRUE;
                        return STATUS_SUCCESS;
                    }
                } 
                else {
                    TRC_ERR((TB, "File Security Information, bad data length"));
                    CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
                    *DoDefaultRead = TRUE;
                    return STATUS_DEVICE_PROTOCOL_ERROR;                
                }

                CompleteBusyExchange(Exchange, 
                        CompletionPacket->IoCompletion.IoStatus,
                        CompletionPacket->IoCompletion.Parameters.QuerySd.Length);
            } else {
                DiscardBusyExchange(Exchange);
            }

            //
            // Go with a default channel read now
            //

            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        } else {

            //
            // We don't have all the data yet, release the DrExchange and 
            // read more data
            //

            MarkIdle(Exchange);

            _Session->GetExchangeManager().ReadMore(
                    (ULONG)FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
                    IoCompletion.Parameters.QuerySd.Buffer));

            *DoDefaultRead = FALSE;
            return STATUS_SUCCESS;
        }
    } else {

        //
        // Unsuccessful IO at the client end
        //

        TRC_DBG((TB, "Unsuccessful Read at the client end"));
        if (cbPacket >= sizeof(RDPDR_IOCOMPLETION_PACKET)) {
            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, 
                    CompletionPacket->IoCompletion.IoStatus,
                    0);
            }
            else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = TRUE;
            return STATUS_SUCCESS;
        } else {
            TRC_ERR((TB, "Read returned invalid data "));

            if (RxContext != NULL) {
                CompleteBusyExchange(Exchange, STATUS_DEVICE_PROTOCOL_ERROR, 0);
            } else {
                DiscardBusyExchange(Exchange);
            }

            *DoDefaultRead = FALSE;
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
    }
}

NTSTATUS DrDrive::OnSetSdInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    PRX_CONTEXT RxContext;
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;

    BEGIN_FN("DrDrive::OnSetSdInfoCompletion");

    RxContext = Context->_RxContext;
    if (RxContext != NULL) {
        ASSERT(RxContext->MajorFunction == IRP_MJ_SET_SECURITY);

        TRC_NRM((TB, "Irp: %s, Completion Status: %lx",
                IrpNames[RxContext->MajorFunction],
                RxContext->IoStatusBlock.Status));

        CompleteBusyExchange(Exchange, CompletionPacket->IoCompletion.IoStatus, 0);
    } else {

        //
        // Was cancelled but Context wasn't cleaned up
        //

        DiscardBusyExchange(Exchange);
    }

    return STATUS_SUCCESS;
}

NTSTATUS DrDrive::OnLocksCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
        BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange)
{
    PRX_CONTEXT RxContext;
    DrIoContext *Context = (DrIoContext *)Exchange->_Context;

    BEGIN_FN("DrDrive::OnLocksCompletion");

    RxContext = Context->_RxContext;
    if (RxContext != NULL) {
        ASSERT(RxContext->MajorFunction == IRP_MJ_LOCK_CONTROL);

        TRC_NRM((TB, "Irp: %s, Completion Status: %lx",
                IrpNames[RxContext->MajorFunction],
                RxContext->IoStatusBlock.Status));

        CompleteBusyExchange(Exchange, CompletionPacket->IoCompletion.IoStatus, 0);
    } else {

        //
        // Was cancelled but Context wasn't cleaned up
        //

        DiscardBusyExchange(Exchange);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\file.cpp ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    file.cpp

Author :
 
    JoyC  11/10/1999
     
Abstract:

    RDPDr File object handles mini-redirector specific file information 

Revision History:
--*/
#include "precomp.hxx"
#define TRC_FILE "file"

#include "trc.h"

DrFile::DrFile(SmartPtr<DrDevice> &Device, ULONG FileId)
{
    BEGIN_FN("DrFile");

    TRC_DBG((TB, "Create File Object %p for device %p",
             this, Device));

    SetClassName("DrFile");

    _Device = Device;
    _FileId = FileId;
    _Buffer = NULL;
    _BufferSize = 0;
}

DrFile::~DrFile()
{
    BEGIN_FN("DrFile::~DrFile");

    TRC_DBG((TB, "Delete File Object %p for device %p",
             this, _Device));

    if (_Buffer) {
        delete _Buffer;        
    }
}

PBYTE DrFile::AllocateBuffer(ULONG size)
{
    BEGIN_FN("DrFile::AllocateBuffer")

    //
    //  if _Buffer is not NULL, free it first
    //
    if (_Buffer) {
        delete _Buffer;
    }

    _Buffer = (PBYTE) new(NonPagedPool)BYTE[size];

    if (_Buffer) {
        _BufferSize = size;
    }
    else {
        _BufferSize = 0;
    }

    return _Buffer;
}

void DrFile::FreeBuffer()
{
    BEGIN_FN("DrFile::FreeBuffer");

    if (_Buffer) {
        delete _Buffer;
        _Buffer = NULL;
    }
    _BufferSize = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\file.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    File.h

Author :
    
    JoyC  11/10/1999
              
Abstract:

    RDPDr File object handles mini-redirector specific file information 

Revision History:
--*/
#pragma once

class DrFile : public RefCount
{
protected:

    ULONG _FileId;
    ULONG _BufferSize;
    PBYTE _Buffer;
    SmartPtr<DrDevice> _Device;

public:
    DrFile(SmartPtr<DrDevice> &Device, ULONG FileId);
    ~DrFile();

    PBYTE AllocateBuffer(ULONG size);

    void FreeBuffer();

    ULONG GetFileId()
    {
        return _FileId;
    }

    void SetFileId(ULONG FileId)
    {
        _FileId = FileId;
    }

    PBYTE GetBuffer()
    {
        return _Buffer;
    }

    ULONG GetBufferSize()
    {
        return _BufferSize;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\drive.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    drive.h

Author : 

    JoyC  11/1/1999
    
Abstract:

    Drive Device object handles one redirected drive

Revision History:
--*/
#pragma once

class DrDrive : public DrDevice
{
private:
protected:
    virtual BOOL IsDeviceNameValid();
    
public:
    DrDrive(SmartPtr<DrSession> &Session, ULONG DeviceType, 
            ULONG DeviceId, PUCHAR PreferredDosName);

    virtual NTSTATUS Initialize(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg, ULONG Length);
    virtual BOOL ShouldCreateDevice();

    virtual VOID Remove();

    NTSTATUS CreateDrive(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg, PWCHAR DriveName);

    NTSTATUS CreateDriveAnnounceEvent(PRDPDR_DEVICE_ANNOUNCE  devAnnounceMsg,
            PRDPDR_DRIVEDEVICE_SUB driveAnnounceEvent,
            ULONG driveAnnounceEventSize,
            PCWSTR driveName,
            OPTIONAL ULONG *driveAnnounceEventReqSize);

    //
    // These are file system specific functions.  
    //
    virtual NTSTATUS Locks(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS QueryDirectory(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS NotifyChangeDirectory(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS QueryVolumeInfo(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS SetVolumeInfo(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS QueryFileInfo(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS SetFileInfo(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS QuerySdInfo(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS SetSdInfo(IN OUT PRX_CONTEXT RxContext);

    virtual NTSTATUS OnLocksCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    virtual NTSTATUS OnDirectoryControlCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    virtual NTSTATUS OnQueryDirectoryCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    virtual NTSTATUS OnNotifyChangeDirectoryCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    virtual NTSTATUS OnQueryVolumeInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    virtual NTSTATUS OnSetVolumeInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    virtual NTSTATUS OnQueryFileInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    virtual NTSTATUS OnSetFileInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    virtual NTSTATUS OnQuerySdInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);
    virtual NTSTATUS OnSetSdInfoCompletion(PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket, 
            BOOL *DoDefaultRead, SmartPtr<DrExchange> Exchange);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\exchnge.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    exchnge.h

Abstract:

    Defines the objects which track communication transactions with
    the client

Revision History:
--*/
#pragma once

#include <midatlax.h>

typedef enum {
    demsStopped,
    demsStarted
} DrExchangeManagerState;

class DrSession;

class DrExchangeManager : public TopObj, public ISessionPacketReceiver, 
        ISessionPacketSender
{
private:
    PRX_MID_ATLAS _RxMidAtlas;
    DrExchangeManagerState _demsState;
    DrSession *_Session;

    static VOID DestroyAtlasCallback(DrExchange *Exchange);
    NTSTATUS OnDeviceIoCompletion(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket, 
            BOOL *DoDefaultRead);
    
public:
    BOOL Start();
    VOID Stop();
    DrExchangeManager();
    BOOL Initialize(DrSession *Session);
    VOID Uninitialize();
    BOOL CreateExchange(IExchangeUser *ExchangeUser,
            PVOID Context, SmartPtr<DrExchange> &Exchange);
    NTSTATUS StartExchange(SmartPtr<DrExchange> &Exchange,
            class IExchangeUser *ExchangeUser, PVOID Buffer, ULONG Length,
            BOOL LowPrioSend = FALSE);
    BOOL Find(USHORT Mid, SmartPtr<DrExchange> &ExchangeFound);
    VOID Discard(SmartPtr<DrExchange> &Exchange);
    BOOL ReadMore(ULONG cbSaveData, ULONG cbWantData = 0);

    //
    // ISessionPacketHandler methods
    //

    virtual BOOL RecognizePacket(PRDPDR_HEADER RdpdrHeader);
    virtual NTSTATUS HandlePacket(PRDPDR_HEADER RdpdrHeader, ULONG Length, 
            BOOL *DoDefaultRead);

    //
    // ISessionPacketSender methods
    //
    virtual NTSTATUS SendCompleted(PVOID Context, 
            PIO_STATUS_BLOCK IoStatusBlock);
};

//
// This DrExchange is more like a structure than a class, because the work
// is really done in DrExchangeManager. It's set up this way because 
// the work often needs to happen in a SpinLock, and there should be no
// messing around time wise while we've got the SpinLock, not even a 
// extraneous function call.
//
// I've left it a class so I can hide the constructor and destructor
//

class DrExchange : public RefCount
{
    friend class DrExchangeManager;
private:
    DrExchangeManager *_ExchangeManager;
    DrExchange(DrExchangeManager *ExchangeManager,
        IExchangeUser *ExchangeUser, PVOID Context);
    
public:
    virtual ~DrExchange();

    //
    // These are used by ExchangeManager and the user of the exchange
    // 
    PVOID _Context;
    IExchangeUser *_ExchangeUser;
    USHORT _Mid;

#define DREXCHANGE_SUBTAG 'xErD'
    //
    //  Memory Management Operators
    //
    inline void *__cdecl operator new(size_t sz) 
    {
        return DRALLOCATEPOOL(NonPagedPool, sz, DREXCHANGE_SUBTAG);
    }

    inline void __cdecl operator delete(void *ptr)
    {
        DRFREEPOOL(ptr);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\exchnge.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    exchnge.cpp

Abstract:

    Implements methods associated with the exchange context structure. The 
    exchange context provides context for an I/O transaction with the client

Revision History:
--*/

#include "precomp.hxx"
#define TRC_FILE "exchnge"
#include "trc.h"

DrExchangeManager::DrExchangeManager()
{
    BEGIN_FN("DrExchangeManager::DrExchangeManager");
    SetClassName("DrExchangeManager");
    _RxMidAtlas = NULL;
    _demsState = demsStopped;
    _Session = NULL;
}

BOOL DrExchangeManager::Initialize(DrSession *Session)
{
    BEGIN_FN("DrExchangeManager::Initialize");
    ASSERT(_Session == NULL);
    ASSERT(Session != NULL);
    _Session = Session;
    return !NT_ERROR(_Session->RegisterPacketReceiver(this));
}

VOID DrExchangeManager::Uninitialize()
/*++

Routine Description:
    Called if the exchange manager wasn't started because something
    went wrong during startup

--*/
{
    BEGIN_FN("DrExchangeManager::Uninitialize");
    ASSERT(_Session != NULL);
    ASSERT(_demsState == demsStopped);
    _Session->RemovePacketReceiver(this);
    _Session = NULL;
}

BOOL DrExchangeManager::Start()
/*++

Routine Description:
    Start and stop really exist because there's no way to clear everything
    out of a RxMidAtlas without destroying it. So start creates it and stop
    destroys it.
    Start simply allocates the Atlas and returns whether that worked

Arguments:
    None.

Return Value:
    Boolean indication of whether we can do IO

--*/
{
    DrExchangeManagerState demsState;

    BEGIN_FN("DrExchangeManager::Start");
    demsState = (DrExchangeManagerState)InterlockedExchange((long *)&_demsState, demsStarted);

    if (demsState == demsStopped) {
        TRC_DBG((TB, "Creating Atlas"));
        ASSERT(_RxMidAtlas == NULL);
        _RxMidAtlas = RxCreateMidAtlas(DR_MAX_OPERATIONS, 
                DR_TYPICAL_OPERATIONS);
    } else {

        // The exchange has already started, so ignore this
    }
    
    TRC_DBG((TB, "Atlas 0x%p", _RxMidAtlas));
    return _RxMidAtlas != NULL;
}

VOID DrExchangeManager::Stop()
{
    PRX_MID_ATLAS RxMidAtlas;
    DrExchangeManagerState demsState;

    BEGIN_FN("DrExchangeManager::Stop");
    demsState = (DrExchangeManagerState)InterlockedExchange((long *)&_demsState, demsStopped);

    if (demsState == demsStarted) {
        ASSERT(_RxMidAtlas != NULL);

        DrAcquireMutex();
        RxMidAtlas = _RxMidAtlas;
        _RxMidAtlas = NULL;
        DrReleaseMutex();

        TRC_NRM((TB, "Destroying Atlas 0x%p", RxMidAtlas));

        RxDestroyMidAtlas(RxMidAtlas, (PCONTEXT_DESTRUCTOR)DestroyAtlasCallback);
    } else {

        //
        // We allow this multiple times because this is how you cancel 
        // outstanding client I/O
        //

        TRC_DBG((TB, "Atlas already destroyed"));
    }
}

VOID DrExchangeManager::DestroyAtlasCallback(DrExchange *pExchange)
/*++

Routine Description:
    Part of clearing out all the outstanding IO. Since we won't be able
    to complete this normally, we have to delete the Exchange

Arguments:
    RxContext - Context to cancel and delete and whatnot

Return Value:
    None.

--*/
{
    DrExchangeManager *ExchangeManager;
    PRX_CONTEXT RxContext = NULL;
    SmartPtr<DrExchange> Exchange;

    BEGIN_FN_STATIC("DrExchangeManager::DestroyAtlasCallback");

    //
    // Convert to a smart pointer and get rid of the explicit refcount
    //

    Exchange = pExchange;
    pExchange->Release();

    //
    // Notification that the conversation is over
    //

    Exchange->_ExchangeUser->OnIoDisconnected(Exchange);
}

BOOL DrExchangeManager::CreateExchange(IExchangeUser *ExchangeUser,
        PVOID Context, SmartPtr<DrExchange> &Exchange)
/*++

Routine Description:
    Creates an Exchange context data structure and initializes it
    with the basic data

Arguments:
    ExchangeUser - An interface for callbacks associated with the conversation
    Context - ExchangeUser contextual data
    Exchange - Reference to where to put the results

Return Value:
    Boolean success or failure

--*/
{
    BOOL rc = TRUE;
    NTSTATUS Status;
    USHORT Mid;

    BEGIN_FN("DrExchangeManager::CreateExchange");
    ASSERT(ExchangeUser != NULL);

    Exchange = new DrExchange(this, ExchangeUser, Context);
    if (Exchange != NULL) {
        DrAcquireMutex();

        if (_RxMidAtlas != NULL) {
            Status = RxAssociateContextWithMid(_RxMidAtlas, Exchange, &Mid);
        } else {
            Status = STATUS_DEVICE_NOT_CONNECTED;
        }

        if (NT_SUCCESS(Status)) {
            Exchange->_Mid = Mid;

            //
            // Explicit reference count for the atlas
            //
            Exchange->AddRef();
        } else {
            rc = FALSE;
        }
        DrReleaseMutex();

        if (!rc) {
            Exchange = NULL;
        }
    } else {
        rc = FALSE;
    }

    return rc;
}

DrExchange::DrExchange(DrExchangeManager *ExchangeManager,
        IExchangeUser *ExchangeUser, PVOID Context)
/*++

Routine Description:
    Constructor initializes member variables

Arguments:
    ExchangeManager - Relevant manager
    Context - Context to track this op

Return Value:
    None

--*/
{
    BEGIN_FN("DrExchange::DrExchange");
    ASSERT(ExchangeManager != NULL);
    ASSERT(ExchangeUser != NULL);

    _Context = Context;
    _ExchangeManager = ExchangeManager;
    _ExchangeUser = ExchangeUser;
    _Mid = INVALID_MID;
}

DrExchange::~DrExchange()
{
    BEGIN_FN("DrExchange::~DrExchange");
}


BOOL DrExchangeManager::Find(USHORT Mid, SmartPtr<DrExchange> &ExchangeFound)
/*++

Routine Description:
    
    Marks an Exchange context as busy so it won't be cancelled
    while we're copying in to its buffer

Arguments:
    Mid - Id to find
    ExchangeFound - storage for the pointer to the context

Return Value:
    BOOL indicating whether it was found

--*/
{
    NTSTATUS Status;
    DrExchange *Exchange = NULL;

    BEGIN_FN("DrExchangeManager::Find");

    DrAcquireMutex();
    if (_RxMidAtlas != NULL) {
        Exchange = (DrExchange *)RxMapMidToContext(_RxMidAtlas, Mid);
        TRC_DBG((TB, "Found context: 0x%p", Exchange));
    }

    //
    // This is where the Exchange is reference counted, must be
    // inside the lock
    //

    ExchangeFound = Exchange;
    DrReleaseMutex();

    return ExchangeFound != NULL;
}

BOOL DrExchangeManager::ReadMore(ULONG cbSaveData, ULONG cbWantData)
{
    BEGIN_FN("DrExchangeManager::ReadMore");
    return _Session->ReadMore(cbSaveData, cbWantData);
}


VOID DrExchangeManager::Discard(SmartPtr<DrExchange> &Exchange)
/*++

Routine Description:
    Stops tracking this as a conversation by its ID. the exchange will be
    deleted when its reference count goes to zero

Arguments:
    Exchange - Marker for the operation

Return Value:
    None.

--*/
{
    USHORT Mid;
    NTSTATUS Status;
    DrExchange *ExchangeFound = NULL;

    BEGIN_FN("DrExchangeManager::Discard");
    ASSERT(Exchange != NULL);

    DrAcquireMutex();
    Mid = Exchange->_Mid;

    if (_RxMidAtlas != NULL) {

        //
        // We already have the DrExchange, but we need to remove
        // it from the atlas
        //

        Status = RxMapAndDissociateMidFromContext(_RxMidAtlas,
                Mid, (PVOID *)&ExchangeFound);

        TRC_ASSERT(ExchangeFound == Exchange, (TB, "Mismatched "
                "DrExchange"));

        //
        // Explicit reference count for the atlas
        //
        if (ExchangeFound != NULL) 
            ExchangeFound->Release();

    } else {
        TRC_ALT((TB, "Tried to complete mid when atlas was "
                "NULL"));
        Status = STATUS_DEVICE_NOT_CONNECTED;
    }

    DrReleaseMutex();
}

BOOL DrExchangeManager::RecognizePacket(PRDPDR_HEADER RdpdrHeader)
{
    BEGIN_FN("DrExchangeManager::RecognizePacket");
    //
    // If you add a packet here, update the ASSERTS in HandlePacket
    //

    switch (RdpdrHeader->Component) {
    case RDPDR_CTYP_CORE:
        switch (RdpdrHeader->PacketId) {
            case DR_CORE_DEVICE_IOCOMPLETION:
            return TRUE;
        }
    }
    return FALSE;
}

NTSTATUS DrExchangeManager::HandlePacket(PRDPDR_HEADER RdpdrHeader, 
        ULONG Length, BOOL *DoDefaultRead)
{
    NTSTATUS Status;

    BEGIN_FN("DrExchangeManager::HandlePacket");

    //
    // RdpdrHeader read, dispatch based on the header
    //

    ASSERT(RdpdrHeader != NULL);
    ASSERT(Length >= sizeof(RDPDR_HEADER));
    ASSERT(RdpdrHeader->Component == RDPDR_CTYP_CORE);

    switch (RdpdrHeader->Component) {
    case RDPDR_CTYP_CORE:
        ASSERT(RdpdrHeader->PacketId == DR_CORE_DEVICE_IOCOMPLETION);

        switch (RdpdrHeader->PacketId) {
        case DR_CORE_DEVICE_IOCOMPLETION:
                Status = OnDeviceIoCompletion(RdpdrHeader, Length, 
                        DoDefaultRead);
            break;
        }
    }
    return Status;
}

NTSTATUS DrExchangeManager::OnDeviceIoCompletion(PRDPDR_HEADER RdpdrHeader, 
        ULONG cbPacket, BOOL *DoDefaultRead)
/*++

Routine Description:

    Called in response to recognizing a DeviceIoCompletion packet has been
    received. Finds the associated RxContext, fills out relevant information,
    and completes the request.

Arguments:

    RdpdrHeader - The header of the packet, a pointer to the packet
    cbPacket - The number of bytes of data in the packet

Return Value:

    NTSTATUS - Success/failure indication of the operation

--*/
{
    NTSTATUS Status;
    PRX_CONTEXT RxContext;
    PRDPDR_IOCOMPLETION_PACKET CompletionPacket =
        (PRDPDR_IOCOMPLETION_PACKET)RdpdrHeader;
    SmartPtr<DrExchange> Exchange;
    USHORT Mid;
    ULONG cbMinimum;

    BEGIN_FN("DrExchangeManager::OnDeviceIoCompletion");

    cbMinimum = FIELD_OFFSET(RDPDR_IOCOMPLETION_PACKET, 
            IoCompletion.Parameters);

    if (cbMinimum > cbPacket) {
        *DoDefaultRead = FALSE;
        return _Session->ReadMore(cbPacket, cbMinimum);
    }

    Mid = (USHORT)CompletionPacket->IoCompletion.CompletionId;
    TRC_DBG((TB, "IoCompletion mid: %x", Mid));

    if (Find(Mid, Exchange)) {
        Status = Exchange->_ExchangeUser->OnDeviceIoCompletion(CompletionPacket, 
                cbPacket, DoDefaultRead, Exchange);
    } else {

        //
        // Client gave us a bogus mid
        //
        Status = STATUS_DEVICE_PROTOCOL_ERROR;
        *DoDefaultRead = FALSE;
    }

    return Status;
}

NTSTATUS DrExchangeManager::StartExchange(SmartPtr<DrExchange> &Exchange,
        class IExchangeUser *ExchangeUser, PVOID Buffer, ULONG Length, 
        BOOL LowPrioSend)
/*++

Routine Description:

    Sends the information to the client, and recognizes the response. 

Arguments:

    Exchange - The conversanion token
    Buffer - Data to send
    Length - size of the data
    LowPrioSend -   Should the data be sent to the client at low priority.

Return Value:

    Status of sending, a failure means no callback will be made

--*/
{
    NTSTATUS Status;

    BEGIN_FN("DrExchangeManager::StartExchange");

    Exchange->_ExchangeUser = ExchangeUser;
    
    //
    //  This is a synchronous write
    //
    Status = _Session->SendToClient(Buffer, Length, this, FALSE, 
                            LowPrioSend, (PVOID)Exchange);
                            
    return Status;

}

NTSTATUS DrExchangeManager::SendCompleted(PVOID Context, 
        PIO_STATUS_BLOCK IoStatusBlock)
{
    DrExchange *pExchange;
    SmartPtr<DrExchange> Exchange;

    BEGIN_FN("DrExchangeManager::SendCompleted");
    pExchange = (DrExchange *)Context;
    ASSERT(pExchange != NULL);
    ASSERT(pExchange->IsValid());
    Exchange = pExchange;
    
    return Exchange->_ExchangeUser->OnStartExchangeCompletion(Exchange, 
            IoStatusBlock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\isession.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    isession.h

Abstract:

    Defines interfaces for use with sessions

Revision History:
--*/

class ISessionPacketReceiver
{
public:
    virtual BOOL RecognizePacket(PRDPDR_HEADER RdpdrHeader) = 0;
    virtual NTSTATUS HandlePacket(PRDPDR_HEADER RdpdrHeader, ULONG Length, 
            BOOL *DoDefaultRead) = 0;
};

class ISessionPacketSender
{
public:
    virtual NTSTATUS SendCompleted(PVOID Context, 
            PIO_STATUS_BLOCK IoStatusBlock) = 0;
};

typedef 
NTSTATUS (NTAPI *DrWriteCallback)(PVOID Context, PIO_STATUS_BLOCK IoStatusBlock);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\iexchnge.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    iexchnge.h

Abstract:

    Interfaces for use with the exchange manager

Revision History:
--*/
#pragma once

class DrExchange;

class IExchangeUser
{
public:
    virtual VOID OnIoDisconnected(SmartPtr<DrExchange> &Exchange) = 0;
    virtual NTSTATUS OnStartExchangeCompletion(SmartPtr<DrExchange> &Exchange, 
            PIO_STATUS_BLOCK IoStatusBlock) = 0;
    virtual NTSTATUS OnDeviceIoCompletion(
            PRDPDR_IOCOMPLETION_PACKET CompletionPacket, ULONG cbPacket,
            BOOL *DoDefaultRead, SmartPtr<DrExchange> &Exchange) = 0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\kernutil.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    kernutil.h

Abstract:

    Kernel mode utilities

Revision History:
--*/
#ifndef __KERNUTIL_H__
#define __KERNUTIL_H__

BOOL InitializeKernelUtilities();
VOID UninitializeKernelUtilities();


//
// For frequent identically-sized allocations, Lookaside Lists are faster
// and less susceptible to the low memory conditions (though not exempt)
//
class NPagedLookasideList : public TopObj
{
private:
    NPAGED_LOOKASIDE_LIST _Lookaside;

public:
    NPagedLookasideList(ULONG Size, ULONG Tag)
    {
        SetClassName("NPagedLookasideList");

        ExInitializeNPagedLookasideList(&_Lookaside, DRALLOCATEPOOL, DRFREEPOOL,
                0, Size, Tag, 0);
    }

    virtual ~NPagedLookasideList()
    {
        ExDeleteNPagedLookasideList(&_Lookaside);
    }

    //
    // Ordinarily I'd want tracing here, but it's more important these be
    // inline for retail
    //
    inline PVOID Allocate()
    {
        return ExAllocateFromNPagedLookasideList(&_Lookaside);
    }

    inline VOID Free(PVOID Entry)
    {
        ExFreeToNPagedLookasideList(&_Lookaside, Entry);
    }

    //
    //  Memory Management Operators
    //
    inline void *__cdecl operator new(size_t sz) 
    {
        return DRALLOCATEPOOL(NonPagedPool, sz, 'LLPN');
    }

    inline void __cdecl operator delete(void *ptr)
    {
        DRFREEPOOL(ptr);
    }
};

class PagedLookasideList : public TopObj
{
private:
    PAGED_LOOKASIDE_LIST _Lookaside;

public:
    PagedLookasideList(ULONG Size, ULONG Tag)
    {
        SetClassName("PagedLookasideList");

        ExInitializePagedLookasideList(&_Lookaside, DRALLOCATEPOOL, DRFREEPOOL,
                0, Size, Tag, 0);
    }

    virtual ~PagedLookasideList()
    {
        ExDeletePagedLookasideList(&_Lookaside);
    }

    //
    // Ordinarily I'd want tracing here, but it's more important these be
    // inline for retail
    //
    inline PVOID Allocate()
    {
        return ExAllocateFromPagedLookasideList(&_Lookaside);
    }

    inline VOID Free(PVOID Entry)
    {
        ExFreeToPagedLookasideList(&_Lookaside, Entry);
    }

    inline void *__cdecl operator new(size_t sz) 
    {
        return DRALLOCATEPOOL(NonPagedPool, sz, 'LLgP');
    }

    inline void __cdecl operator delete(void *ptr)
    {
        DRFREEPOOL(ptr);
    }
};

class KernelResource : public TopObj
{
private:
    ERESOURCE _Resource;

public:
    KernelResource();
    virtual ~KernelResource();

    inline VOID AcquireResourceExclusive()
    {
        KeEnterCriticalRegion();
        ExAcquireResourceExclusiveLite(&_Resource, TRUE);
    }

    inline VOID AcquireResourceShared()
    {
        KeEnterCriticalRegion();
        ExAcquireResourceSharedLite(&_Resource, TRUE);
    }

    inline VOID ReleaseResource()
    { 
        ExReleaseResourceLite(&_Resource);
        KeLeaveCriticalRegion();
    }

    inline ULONG IsAcquiredShared()
    {
        return ExIsResourceAcquiredSharedLite(&_Resource);
    }

    inline BOOLEAN IsAcquiredExclusive()
    {
        return ExIsResourceAcquiredExclusiveLite(&_Resource);
    }

    inline BOOLEAN IsAcquired()
    {
        return (IsAcquiredShared() != 0) || IsAcquiredExclusive();
    }
};

class KernelEvent : public TopObj
{
private:
    KEVENT _KernelEvent;
    static NPagedLookasideList *_Lookaside;

public:
    KernelEvent(IN EVENT_TYPE Type, IN BOOLEAN State)
    {
        KeInitializeEvent(&_KernelEvent, Type, State);
    }

    virtual ~KernelEvent()
    {
    }
    
    static inline BOOL StaticInitialization()
    {
        _Lookaside = new NPagedLookasideList(sizeof(KernelEvent), 'tnvE');
        return _Lookaside != NULL;
    }

    static inline VOID StaticUninitialization()
    {
        if (_Lookaside != NULL) {
            delete _Lookaside;
            _Lookaside = NULL;
        }
    }

    NTSTATUS Wait(IN KWAIT_REASON WaitReason, IN KPROCESSOR_MODE WaitMode,
            IN BOOLEAN Alertable, IN PLARGE_INTEGER Timeout = NULL)
    {
        return KeWaitForSingleObject(&_KernelEvent, WaitReason, WaitMode, 
                Alertable, Timeout);
    }

    inline LONG SetEvent(KPRIORITY Increment = IO_NO_INCREMENT, 
            BOOLEAN Wait = FALSE)
    {
        return KeSetEvent(&_KernelEvent, Increment, Wait);
    }

    inline LONG ResetEvent()
    {
        return KeResetEvent(&_KernelEvent);
    }

    inline VOID ClearEvent()
    {
        KeClearEvent(&_KernelEvent);
    }

    //
    // Maybe need to WaitForMultipleObjects
    //
    inline PKEVENT GetEvent()
    {
        return &_KernelEvent;
    }

    //
    //  Memory Management Operators
    //
    inline void *__cdecl operator new(size_t sz) 
    {
        return _Lookaside->Allocate();
    }

    inline void __cdecl operator delete(void *ptr)
    {
        _Lookaside->Free(ptr);
    }
};

class SharedLock
{
private:
    KernelResource &_Lock;

public:
    SharedLock(KernelResource &Lock) : _Lock(Lock) 
    {
        _Lock.AcquireResourceShared();
    }
    ~SharedLock()
    {
        _Lock.ReleaseResource();
    }
};

class ExclusiveLock
{
private:
    KernelResource &_Lock;

public:
    ExclusiveLock(KernelResource &Lock) : _Lock(Lock) 
    {
        _Lock.AcquireResourceExclusive();
    }
    ~ExclusiveLock()
    {
        _Lock.ReleaseResource();
    }
};

class DoubleList;

class ListEntry {
    friend class DoubleList;        // so it can access _List and constructor

private:
    LIST_ENTRY _List;               // really here for DoubleList

    ListEntry(PVOID Node)
    {
        _Node = Node;
    }
    PVOID _Node;                    // What it is we're tracking in the list
    static NPagedLookasideList *_Lookaside;

public:
    PVOID Node() { return _Node; }

    static inline BOOL StaticInitialization()
    {
        _Lookaside = new NPagedLookasideList(sizeof(ListEntry), 'tsiL');
        return _Lookaside != NULL;
    }

    static inline VOID StaticUninitialization()
    {
        if (_Lookaside != NULL) {
            delete _Lookaside;
            _Lookaside = NULL;
        }
    }

    //
    //  Memory Management Operators
    //
    inline void *__cdecl operator new(size_t sz) 
    {
        return _Lookaside->Allocate();
    }

    inline void __cdecl operator delete(void *ptr)
    {
        _Lookaside->Free(ptr);
    }
};
    
class DoubleList : public TopObj {
private:
    LIST_ENTRY _List;
    KernelResource _Resource;       // Writes require an exclusive lock
                                    // reads require a shared lock
public:
    DoubleList() 
    {
        SetClassName("DoubleList");
        InitializeListHead(&_List);
    }

    BOOL CreateEntry(PVOID Node);

    //
    // Enumeration of the list
    //
    // You can't add to the list while enumerating
    //
    // Sample enumeration of the list
    // In this sample find a smart pointer
    //
    /*
        SmartPtr<NodeThing> *NodeEnum;
        SmartPtr<NodeThing> NodeFound;
        DoubleList List;
        ListEntry *ListEnum;

        List.LockShared(); // or exclusive
        ListEnum = List.First();
        while (ListEnum != NULL) {

            //
            // do something with ListEnum->Node()
            //
            // In this sample, look to see if it is
            // the item we're looking for
            //
            
            NodeEnum = (SmartPtr<NodeThing> *)ListEnum->Node();

            if ((*NodeEnum)->NodeThingProperty == NodeThingPropertyCriteria) {
                NodeFound = (*NodeEnum);

                //
                // These aren't guaranteed valid once the resource is released
                //

                NodeEnum = NULL;
                ListEnum = NULL;
                break;
            }

            ListEnum = List.Next(ListEnum);
        }
        List.Unlock();

        // Do something with NodeFound;
        if (NodeFound != NULL) {

        }
    */
    //

    VOID RemoveEntry(ListEntry *Entry);
    ListEntry *First();
    ListEntry *Next(ListEntry *ListEnum);

    inline VOID LockShared()
    {
        _Resource.AcquireResourceShared();
    }

    inline VOID LockExclusive()
    {
        _Resource.AcquireResourceExclusive();
    }

    inline VOID Unlock()
    {
        _Resource.ReleaseResource();
    }
};

#endif // __KERNUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\kernutil.cpp ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    kernutil.cpp

Abstract:

    Kernel mode utilities

Revision History:
--*/
#include "precomp.hxx"
#define TRC_FILE "kernutil"
#include "trc.h"

NPagedLookasideList *ListEntry::_Lookaside = NULL;
NPagedLookasideList *KernelEvent::_Lookaside = NULL;

BOOL InitializeKernelUtilities()
{
    BOOL Success = TRUE;
    BEGIN_FN("InitializeKernelUtilities");

    if (Success) {
        Success = ListEntry::StaticInitialization();
        TRC_NRM((TB, "ListEntry::StaticInitialization result: %d", Success));
    }

    if (Success) {
        Success = KernelEvent::StaticInitialization();
        TRC_NRM((TB, "KernelEvent::StaticInitialization result: %d", Success));
    }

    if (Success) {
        TRC_NRM((TB, "Successful InitializeKernelUtilities"));
        return TRUE;
    } else {
        TRC_ERR((TB, "Unuccessful InitializeKernelUtilities"));
        UninitializeKernelUtilities();
        return FALSE;
    }
}

VOID UninitializeKernelUtilities()
{
    BEGIN_FN("UnitializeKernelUtilities");

    ListEntry::StaticUninitialization();
}

KernelResource::KernelResource()
{
    NTSTATUS Status;
    BEGIN_FN("KernelResource::KernelResource");
    SetClassName("KernelResource");
    Status = ExInitializeResourceLite(&_Resource);

    // DDK documentation says it always returns STATUS_SUCCESS

    ASSERT(Status == STATUS_SUCCESS);
}

KernelResource::~KernelResource()
{
    NTSTATUS Status;

    BEGIN_FN("KernelResource::~KernelResource");
    ASSERT(!IsAcquired());
    Status = ExDeleteResourceLite(&_Resource);
    ASSERT(!NT_ERROR(Status));
}


BOOL DoubleList::CreateEntry(PVOID Node)
{
    ListEntry *Entry;

    BEGIN_FN("DoubleList::CreateEntry");
    // Allocate a new entry
    Entry = new ListEntry(Node);

    // Insert it in the list
    
    if (Entry != NULL) {
        LockExclusive();
        InsertTailList(&_List, &Entry->_List);
        Unlock();
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID DoubleList::RemoveEntry(ListEntry *Entry)
{
    BEGIN_FN("DoubleList::RemoveEntry");
    ASSERT(_Resource.IsAcquiredExclusive());
    RemoveEntryList(&Entry->_List);
    delete Entry;
}

ListEntry *DoubleList::First()
{
    BEGIN_FN("DoubleList::First");
    ASSERT(_Resource.IsAcquiredShared());
    if (!IsListEmpty(&_List)) {
        return CONTAINING_RECORD(_List.Flink, ListEntry, _List);
    } else {
        return NULL;
    }
}

ListEntry *DoubleList::Next(ListEntry *ListEnum)
{
    BEGIN_FN("DoubleList::Next");
    //
    // Caller should have called BeginEnumeration and therefore the
    // resource should be acquired shared
    //

    ASSERT(_Resource.IsAcquiredShared());

#ifdef DBG
    //
    // Make sure this ListEnum guy is in the list
    //

    LIST_ENTRY *ListEntryT;

    ListEntryT = &_List;

    while (ListEntryT != NULL) {
        if (ListEntryT == &ListEnum->_List) {
            break;
        }

        // This is the same loop as below, just to search for the item
        if (ListEntryT->Flink != &_List) {
            ListEntryT = ListEntryT->Flink;
        } else {
            ListEntryT = NULL;
        }
    }

    // The passed in ListEnum should have been somewhere in the list
    ASSERT(ListEntryT != NULL);
#endif // DBG

    if (ListEnum->_List.Flink != &_List) {

        //
        // Use the CONTAINING_RECORD juju to get back to the pointer which
        // is the actual ListEntry
        //

        return CONTAINING_RECORD(ListEnum->_List.Flink, ListEntry, _List);
    } else {

        //
        // Next item is the list head, so return NULL to end the enumeration
        //

        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\namespc.cpp ===
/****************************************************************************/
// namespc.c
//
// Redirector namespace code
//
// Copyright (C) 1998-2000 Microsoft Corp.
/****************************************************************************/

#include "precomp.hxx"
#define TRC_FILE "namespc"
#include "trc.h"

NTSTATUS
DrCreateSrvCall(
    IN OUT PMRX_SRV_CALL                 pSrvCall,
    IN OUT PMRX_SRVCALL_CALLBACK_CONTEXT pCallbackContext)
/*++

Routine Description:

   This routine patches the RDBSS created srv call instance with the information required
   by the mini redirector.

Arguments:

    CallBackContext  - the call back context in RDBSS for continuation.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;
    PMRX_SRVCALL_CALLBACK_CONTEXT SCCBC = pCallbackContext;
    PMRX_SRVCALLDOWN_STRUCTURE SrvCalldownStructure = (PMRX_SRVCALLDOWN_STRUCTURE)(SCCBC->SrvCalldownStructure);
    SmartPtr<DrSession> Session;
    PWCHAR ClientName;

    BEGIN_FN("DrCreateSrvCall");
    TRC_NRM((TB, "SrvCallName %wZ", pSrvCall->pSrvCallName));
    ASSERT(pSrvCall);
    ASSERT(NodeType(pSrvCall) == RDBSS_NTC_SRVCALL);
    ASSERT(pSrvCall->pSrvCallName);
    ASSERT(pSrvCall->pSrvCallName->Buffer);

    // 
    // Actually do the work of setting up our stuff for this "server" (client)
    // Smb would attempt to contact the server now, but since our stuff
    // is client initiated, we already know if we have a connection
    //
    // Status = DrInitializeServerEntry(pSrvCall,pCallbackContext);
    
    //
    // Our SrvCalls look like \clientName
    // 

    ClientName = pSrvCall->pSrvCallName->Buffer;

    if (ClientName[0] == OBJ_NAME_PATH_SEPARATOR) {
        ClientName++;
    }

#if 0
    if (Sessions->FindSessionByClientName(ClientName, Session)) {
        TRC_NRM((TB, "Recognize SrvCall %wZ", pSrvCall->pSrvCallName));
        Status = STATUS_SUCCESS;
    }
    else {
        TRC_NRM((TB, "Unrecognize SrvCall %wZ", pSrvCall->pSrvCallName));
        Status = STATUS_BAD_NETWORK_NAME;
    }
#endif

    if (_wcsicmp(ClientName, DRUNCSERVERNAME_U) == 0) {
        TRC_NRM((TB, "Recognize SrvCall %wZ", pSrvCall->pSrvCallName));
        Status = STATUS_SUCCESS;
    }
    else {
        TRC_NRM((TB, "Unrecognize SrvCall %wZ", pSrvCall->pSrvCallName));
        Status = STATUS_BAD_NETWORK_NAME;
    }
     
    SCCBC->RecommunicateContext = NULL;
    SCCBC->Status = Status;
    SrvCalldownStructure->CallBack(SCCBC);

    //
    // The CreateSrvCall callback is supposed to return STATUS_PENDING, the 
    // real result goes in the ServCallbackContext thing
    // 

    return STATUS_PENDING;
}

NTSTATUS
DrSrvCallWinnerNotify(
    IN OUT PMRX_SRV_CALL SrvCall,
    IN     BOOLEAN       ThisMinirdrIsTheWinner,
    IN OUT PVOID         RecommunicateContext
    )
/*++

Routine Description:

   This routine is called by RDBSS to notify the mini redirector whether the
   previous SrvCall is actually going to be processed by this redir.

Arguments:

    SrvCall - the SrvCall in question
    ThisMinirdrIsTheWinner - True if we will be processing files on this SrvCall
    RecommunicateContext  - the context we specificed in DrCreateSrvCall

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    BEGIN_FN("DrSrvCallWinnerNotify");

    PAGED_CODE();

    if (!ThisMinirdrIsTheWinner) {

        TRC_NRM((TB, "This minirdr is not the winner"));

        //
        // Some other mini rdr has been choosen to connect. Destroy
        // the data structures created for this mini redirector.
        //
        return STATUS_SUCCESS;
    } else {
        TRC_NRM((TB, "This minirdr is the winner"));
    }

    SrvCall->Context  = NULL;

    SrvCall->Flags |= SRVCALL_FLAG_CASE_INSENSITIVE_NETROOTS |
        SRVCALL_FLAG_CASE_INSENSITIVE_FILENAMES;

    return STATUS_SUCCESS;
}

NTSTATUS
DrFinalizeSrvCall(
      PMRX_SRV_CALL    pSrvCall,
      BOOLEAN    Force
    )
/*++

Routine Description:

   This routine is called by RDBSS to notify the mini redirector when the
   SrvCall structure is being released.

Arguments:

    SrvCall - the SrvCall in question
    Force - I don't know, there's no documentation on any of this stuff

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    BEGIN_FN("DrFinalizeSrvCall");
    PAGED_CODE();

    //
    // We seem to get called with this even if we weren't the "winner"
    // Check to make sure this was filled in before we mess with it
    //

    return STATUS_SUCCESS;
}

NTSTATUS
DrUpdateNetRootState(
    IN  PMRX_NET_ROOT pNetRoot
    )
{
    BEGIN_FN("DrUpdateNetRootState");
    return STATUS_SUCCESS;
}

VOID
DrExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    )
/*++

Routine Description:

   This routine is called by RDBSS to get a NetRoot (share) name parsed out
   of the path. The SrvCall already has part parsed out. 

Arguments:

    FilePathName - The full path, including the SrvCall
    SrvCall - relevant SrvCall structure
    NetRootName - The place to put the NetRoot name
    RestOfName - What's self of the path afterwards

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    UNICODE_STRING xRestOfName;

    ULONG length = FilePathName->Length;
    PWCH w = FilePathName->Buffer;
    PWCH wlimit = (PWCH)(((PCHAR)w)+length);
    PWCH wlow;

    BEGIN_FN("DrExtractNetRootName");

    PAGED_CODE();

    w += (SrvCall->pSrvCallName->Length/sizeof(WCHAR));

    NetRootName->Buffer = wlow = w;
    for (;;) {
        if (w >= wlimit) 
            break;
        if ((*w == OBJ_NAME_PATH_SEPARATOR) && (w != wlow)) {
            break;
        }
        w++;
    }

    // Polish of the NetRootName UNICODE_STRING
    NetRootName->Length = NetRootName->MaximumLength
                = (USHORT) ((PCHAR)w - (PCHAR)wlow);

    if (!RestOfName) RestOfName = &xRestOfName;
    RestOfName->Buffer = w;
    RestOfName->Length = RestOfName->MaximumLength
                       = (USHORT) ((PCHAR)wlimit - (PCHAR)w);

    TRC_NRM((TB, "DrExtractNetRootName FilePath=%wZ",FilePathName));
    TRC_NRM((TB, "         Srv=%wZ,Root=%wZ,Rest=%wZ",
                        SrvCall->pSrvCallName, NetRootName, 
                        RestOfName));

    return;
}

NTSTATUS
DrFinalizeNetRoot(
    IN OUT PMRX_NET_ROOT pNetRoot,
    IN     PBOOLEAN      ForceDisconnect
    )
{
    BEGIN_FN("DrFinalizeNetRoot");
    return STATUS_SUCCESS;
}

NTSTATUS
DrCreateSCardDevice(SmartPtr<DrSession> &Session, PV_NET_ROOT pVNetRoot,
               SmartPtr<DrDevice> &Device)
{
    NTSTATUS Status;
    PMRX_NET_ROOT pNetRoot = NULL;
    
    BEGIN_FN("DrCreateDevice");

    Status = STATUS_BAD_NETWORK_NAME;

    if (pVNetRoot != NULL) {
        pNetRoot = pVNetRoot->pNetRoot;
    }
    
    //  We also need to create the smart card subsystem at this point
    //  even a session may not exist and/or the client smartcard subsystem
    //  is not connected
    Device = new(NonPagedPool) DrSmartCard(Session, RDPDR_DTYP_SMARTCARD,
            RDPDR_INVALIDDEVICEID, (PUCHAR)DR_SMARTCARD_SUBSYSTEM);                    
    
    if (Device != NULL) {
        //
        // Give the specific device a chance to initialize based on the data
        //
        TRC_DBG((TB, "Created new device"));
    
        Status = Device->Initialize(NULL, 0);
    
        if (NT_SUCCESS(Status)) {
            TRC_DBG((TB, "Device initialized, adding"));
            Device->SetDeviceStatus(dsAvailable);
    
            if (Session->GetDevMgr().AddDevice(Device)) {
                TRC_DBG((TB, "Added device"));                
            }
            else {
                Device = NULL;
    
                if (!Session->FindDeviceByDosName((UCHAR *)DR_SMARTCARD_SUBSYSTEM, 
                                                  Device, TRUE)) {                    
                    TRC_ERR((TB, "Failed to add device to devicelist"));                            
                    goto EXIT_POINT;
                }
            }
        }
        else {
            TRC_ERR((TB, "Failed to initialize device"));
             Device = NULL;
             goto EXIT_POINT;
        }
    } else {
        TRC_ERR((TB, "Error creating new device: 0x%08lx", Status));
        goto EXIT_POINT;
    }

    if (pVNetRoot != NULL) {
        Device->AddRef();
        pVNetRoot->Context = (DrDevice *)Device;
        pNetRoot->DeviceType = RxDeviceType(DISK);
        pNetRoot->Type = NET_ROOT_DISK;

#if DBG
        Device->_VNetRoot = (PVOID)pVNetRoot;
#endif
      
    }

    Status = STATUS_SUCCESS;

EXIT_POINT:
    return Status;
}

NTSTATUS
DrCreateSession(ULONG SessionId, PV_NET_ROOT pVNetRoot, SmartPtr<DrSession> &Session)
{
    NTSTATUS Status;
    
    BEGIN_FN("DrCreateSession");

    Status = STATUS_BAD_NETWORK_NAME;
            
    //  For smart card subsystem, we'll need to create session and
    //  smart card subsystem objects early before client connect
    Session = new(NonPagedPool) DrSession;
    
    if (Session != NULL) {
        TRC_DBG((TB, "Created new session"));

        if (Session->Initialize()) {
            TRC_DBG((TB, "Session connected, adding"));
            
            if (Sessions->AddSession(Session)) {                
                TRC_DBG((TB, "Added session"));                                    
            }
            else {
                Session = NULL;

                if (!Sessions->FindSessionById(SessionId, Session)) {
                    TRC_DBG((TB, "Session couldn't be added to session list"));
                    goto EXIT_POINT;                    
                }                
            }
        }
        else {
            TRC_DBG((TB, "Session couldn't initialize"));
            Session = NULL;
            goto EXIT_POINT;
        }
    } 
    else {
        TRC_ERR((TB, "Failed to allocate new session"));        
        goto EXIT_POINT;
    }

    Session->SetSessionId(SessionId);
    Session->GetExchangeManager().Start();  

    Status = STATUS_SUCCESS;

EXIT_POINT:
    return Status;
}

NTSTATUS
DrCreateVNetRoot(
    IN OUT PMRX_CREATENETROOT_CONTEXT CreateNetRootContext
    )
{
    NTSTATUS  Status;
    PRX_CONTEXT pRxContext = CreateNetRootContext->RxContext;
    ULONG DeviceId;
    PMRX_SRV_CALL pSrvCall;                                                                
    PMRX_NET_ROOT pNetRoot;
    SmartPtr<DrSession> Session;
    SmartPtr<DrDevice> Device;
    PUNICODE_STRING pNetRootName, pSrvCallName;
    WCHAR NetRootBuffer[64];
    UNICODE_STRING NetRoot = {0, sizeof(NetRootBuffer), NetRootBuffer};
    PV_NET_ROOT           pVNetRoot;
    UCHAR DeviceDosName[MAX_PATH];
    PWCHAR token;
    ULONG SessionId = -1;
    UNICODE_STRING SessionIdString;
    USHORT OemCodePage, AnsiCodePage;
    INT len;
    
    BEGIN_FN("DrCreateVNetRoot");

    pVNetRoot = CreateNetRootContext->pVNetRoot;
    pNetRoot = pVNetRoot->pNetRoot;
    pSrvCall = pNetRoot->pSrvCall;

    ASSERT(NodeType(pNetRoot) == RDBSS_NTC_NETROOT);
    ASSERT(NodeType(pSrvCall) == RDBSS_NTC_SRVCALL);

    token = &pRxContext->CurrentIrpSp->FileObject->FileName.Buffer[0];

    //
    //  Get the sessionId from the IRP fileName
    //  File name in the format of:
    //  \;<DosDeviceName>:<SessionId>\ClientName\DosDeviveName
    //
    for (unsigned i = 0; i < pRxContext->CurrentIrpSp->FileObject->FileName.Length / sizeof(WCHAR); i++) {
        if (*token == L':') {
            token++;
            SessionIdString.Length = pRxContext->CurrentIrpSp->FileObject->FileName.Length -
                    (i+1) * sizeof(WCHAR);
            SessionIdString.MaximumLength = pRxContext->CurrentIrpSp->FileObject->FileName.MaximumLength -
                    (i+1) * sizeof(WCHAR);
            SessionIdString.Buffer = token;
            RtlUnicodeStringToInteger(&SessionIdString, 0, &SessionId);
            break;
        }
        token++;
    }
    
    TRC_NRM((TB, "pVNetRoot->SessionId: %d", pVNetRoot->SessionId));
    TRC_NRM((TB, "SessionId from FileObject: %d", SessionId));

    // 
    //  We first try to get the session id from the FileObject name. If not,
    //  then it's because we get called directly from a UNC name, in this case
    //  we have to base on if the UNC is called from the session context and use that
    //  as the session id.
    //
    if (SessionId == -1) {
        SessionId = pVNetRoot->SessionId;
    }
    
    //
    //  Get the NetRoot name as the DeviceDosName
    //
    DrExtractNetRootName(pNetRoot->pNetRootName, pSrvCall, &NetRoot, NULL);
    if (NetRoot.Buffer[0] == OBJ_NAME_PATH_SEPARATOR) {
        NetRoot.Buffer++;
        NetRoot.Length -= sizeof(WCHAR);
        NetRoot.MaximumLength -= sizeof(WCHAR);
    }

    TRC_NRM((TB, "Name of NetRoot: %wZ", &NetRoot));

    RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);
    len = ConvertToAndFromWideChar(AnsiCodePage, NetRoot.Buffer, 
            NetRoot.MaximumLength, (char *)DeviceDosName, 
            MAX_PATH - 1, FALSE);

    if (len != -1) {
        DeviceDosName[len] = '\0';
        TRC_NRM((TB, "DeviceDosName=%s", DeviceDosName));
    }

    if (Sessions->FindSessionById(SessionId, Session)) {
        // The V_NET_ROOT is associated with a NET_ROOT. The two cases of interest are as
        // follows
        // 1) the V_NET_ROOT and the associated NET_ROOT are being newly created.
        // 2) a new V_NET_ROOT associated with an existing NET_ROOT is being created.
        //
        // These two cases can be distinguished by checking if the context associated with
        // NET_ROOT is NULL. Since the construction of NET_ROOT's/V_NET_ROOT's are serialized
        // by the wrapper this is a safe check.
        // ( The wrapper cannot have more then one thread tryingto initialize the same
        // NET_ROOT).
        
        if (pVNetRoot->Context == NULL) {
            if (len != -1) {
                
                if (Session->FindDeviceByDosName(DeviceDosName, Device, TRUE)) {
                    Device->AddRef();
                    pVNetRoot->Context = (DrDevice *)Device;

                    Status = STATUS_SUCCESS;
                    TRC_NRM((TB, "Successfully recognized VNetRoot"));

                    // Set the Device type to DISK if this is file system or 
                    // smartcard subsystem,
                    // set it to COMM if it is serial port.
                    // otherwise, treated it as printer device.
                    if (Device->GetDeviceType() == RDPDR_DTYP_FILESYSTEM) {
                        if (Device->ShouldCreateDevice()) {
                            pNetRoot->DeviceType = RxDeviceType(DISK);
                            pNetRoot->Type = NET_ROOT_DISK;
                        }
                        else {
                            Device->Release();
                            pVNetRoot->Context = NULL;
                            Status = STATUS_BAD_NETWORK_NAME;
                            TRC_NRM((TB, "We have disabled drive mapping"));                            
                        }
                    }
                    else if (Device->GetDeviceType() == RDPDR_DTYP_SERIAL) {
                        pNetRoot->DeviceType = RxDeviceType(SERIAL_PORT);
                        pNetRoot->Type = NET_ROOT_COMM;
                    }
                    else if (Device->GetDeviceType() == RDPDR_DTYP_SMARTCARD) { 
                        pNetRoot->DeviceType = RxDeviceType(DISK);
                        pNetRoot->Type = NET_ROOT_DISK;

#if DBG
                        Device->_VNetRoot = (PVOID)pVNetRoot;
#endif                                                      
                    }
                    else {
                        pNetRoot->Type = NET_ROOT_PRINT;
                        pNetRoot->DeviceType = RxDeviceType(PRINTER);
                    }                    
                } else {
                    //
                    // check to see if this is a smartcard subsystem request
                    //
    
                    if (_stricmp((CHAR *)DeviceDosName, (CHAR *)DR_SMARTCARD_SUBSYSTEM) == 0) {
                        Status = DrCreateSCardDevice(Session, pVNetRoot, Device);
                        goto EXIT_POINT;                        
                    }
                    else {
    
                        TRC_NRM((TB, "Unrecognized VNetRoot"));
                        Status = STATUS_BAD_NETWORK_NAME;
                    }
                }
            } else {
                Status = STATUS_BAD_NETWORK_NAME;
                TRC_NRM((TB, "Couldn't find VNetRoot"));
            }
        } else {

            // It already has a happy context
            // BUGBUG: What if this is a crusty old out of date
            // DeviceEntry from before a disconnect? isn't this our big chance 
            // to look for and swap in a better one?

            Status = STATUS_SUCCESS;
        }
    }
    else {
        
        //  Check if this is a smartcard subsystem request 
        if (_stricmp((CHAR *)DeviceDosName, (CHAR *)DR_SMARTCARD_SUBSYSTEM) != 0) {

            TRC_NRM((TB, "Unrecognized VNetRoot"));
            Status = STATUS_BAD_NETWORK_NAME;
        }
        else {
        
            Status = DrCreateSession(SessionId, pVNetRoot, Session);

            if (Status == STATUS_SUCCESS) {
                Status = DrCreateSCardDevice(Session, pVNetRoot, Device);
            }
        }
    }
    

EXIT_POINT:

    CreateNetRootContext->NetRootStatus = STATUS_SUCCESS;
    CreateNetRootContext->VirtualNetRootStatus = Status;
    CreateNetRootContext->Callback(CreateNetRootContext);

    ASSERT((NodeType(pNetRoot) == RDBSS_NTC_NETROOT) &&
          (NodeType(pNetRoot->pSrvCall) == RDBSS_NTC_SRVCALL));

    return STATUS_PENDING;
}

NTSTATUS
DrFinalizeVNetRoot(
    IN OUT PMRX_V_NET_ROOT pVirtualNetRoot,
    IN     PBOOLEAN    ForceDisconnect
    )
{
    DrDevice *Device = (DrDevice *)pVirtualNetRoot->Context;

    BEGIN_FN("DrFinalizeVNetRoot");

    if (Device != NULL) {

        TRC_NRM((TB, "Releasing device entry in FinalizeNetRoot "
                "Context"));

#if DBG
        Device->_VNetRootFinalized = TRUE;
#endif

        Device->Release();
        pVirtualNetRoot->Context = NULL;        
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\namespc.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :
	
    namespc.h

Abstract:

    Function prototypes for name space callbacks from the redirector kit.

Revision History:
--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif __cplusplus

NTSTATUS
DrCreateSrvCall(
    IN OUT PMRX_SRV_CALL                 pSrvCall,
    IN OUT PMRX_SRVCALL_CALLBACK_CONTEXT pCallbackContext
    );

NTSTATUS
DrSrvCallWinnerNotify(
    IN OUT PMRX_SRV_CALL SrvCall,
    IN     BOOLEAN       ThisMinirdrIsTheWinner,
    IN OUT PVOID         RecommunicateContext
    );

NTSTATUS
DrCreateVNetRoot(
    IN OUT PMRX_CREATENETROOT_CONTEXT CreateNetRootContext
    );

NTSTATUS
DrFinalizeVNetRoot(
    IN OUT PMRX_V_NET_ROOT pVirtualNetRoot,
    IN     PBOOLEAN    ForceDisconnect
    );

NTSTATUS
DrFinalizeNetRoot(
    IN OUT PMRX_NET_ROOT pNetRoot,
    IN     PBOOLEAN      ForceDisconnect);

NTSTATUS
DrUpdateNetRootState(
    IN  PMRX_NET_ROOT pNetRoot
    );

VOID
DrExtractNetRootName(
    IN PUNICODE_STRING FilePathName,
    IN PMRX_SRV_CALL   SrvCall,
    OUT PUNICODE_STRING NetRootName,
    OUT PUNICODE_STRING RestOfName OPTIONAL
    );

NTSTATUS
DrCreateSrvCall(
      PMRX_SRV_CALL                      pSrvCall,
      PMRX_SRVCALL_CALLBACK_CONTEXT  pCallbackContext
      );

NTSTATUS
DrFinalizeSrvCall(
      PMRX_SRV_CALL    pSrvCall,
      BOOLEAN    Force
      );

NTSTATUS
DrSrvCallWinnerNotify(
      IN OUT PMRX_SRV_CALL      pSrvCall,
      IN     BOOLEAN        ThisMinirdrIsTheWinner,
      IN OUT PVOID          pSrvCallContext
      );

#ifdef __cplusplus
} // extern "C"
#endif __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\parport.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    parport.h

Abstract:

    Parallel port Device object handles one redirected parellel port

Revision History:
--*/
#pragma once

class DrParallelPort : public DrPrinterPort
{

    NTSTATUS CreateLptPort(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg);

public:
    DrParallelPort(SmartPtr<DrSession> &Session, ULONG DeviceType, 
            ULONG DeviceId, PUCHAR PreferredDosName);
    virtual BOOL ShouldCreatePort();
    virtual BOOL ShouldCreatePrinter();

    virtual NTSTATUS Initialize(PRDPDR_DEVICE_ANNOUNCE DeviceAnnounce, ULONG Length);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\parport.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    parport.cpp

Abstract:

    Parallel port Device object handles one redirected parallel port

Revision History:
--*/
#include "precomp.hxx"
#define TRC_FILE "parport"
#include "trc.h"

DrParallelPort::DrParallelPort(SmartPtr<DrSession> &Session, ULONG DeviceType, ULONG DeviceId, 
            PUCHAR PreferredDosName) : DrPrinterPort(Session, DeviceType, DeviceId, PreferredDosName)
{
    BEGIN_FN("DrParallelPort::DrParallelPort");
    SetClassName("DrParallelPort");

    _PortType = FILE_DEVICE_PARALLEL_PORT;
}

BOOL DrParallelPort::ShouldCreatePrinter()
{
    BEGIN_FN("DrParallelPort::ShouldCreatePrinter");

    return FALSE;
}

BOOL DrParallelPort::ShouldCreatePort()
{
    BEGIN_FN("DrParallelPort::ShouldCreatePort");
    return !_Session->DisableLptPortMapping();
}

NTSTATUS DrParallelPort::Initialize(PRDPDR_DEVICE_ANNOUNCE DeviceAnnounce, ULONG Length)
{
    NTSTATUS Status;

    BEGIN_FN("DrParallelPort::Initialize");

    if (ShouldCreatePort()) {
        Status = DrPrinterPort::Initialize(DeviceAnnounce, Length);
    
        if (NT_SUCCESS(Status) && _Session->GetClientCapabilitySet().PortCap.version > 0) {
            Status = CreateLptPort(DeviceAnnounce);    	    
        }
    }
    else {
        Status = STATUS_SUCCESS;
    }
    return Status;
}

NTSTATUS DrParallelPort::CreateLptPort(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg)
{
    NTSTATUS Status;
    UNICODE_STRING PortName;
    WCHAR PortNameBuff[PREFERRED_DOS_NAME_SIZE];
    USHORT OemCodePage, AnsiCodePage;
	NTSTATUS status;
    INT len, comLen;
    ULONG portAnnounceEventReqSize;
    PRDPDR_PORTDEVICE_SUB portAnnounceEvent;

    BEGIN_FN("DrParallelPort::CreateLptPort");
    
    //
    // Convert the LPT name
    //

    PortName.MaximumLength = sizeof(PortNameBuff);
    PortName.Length = 0;
    PortName.Buffer = &PortNameBuff[0];
    memset(&PortNameBuff, 0, sizeof(PortNameBuff));

    comLen = strlen((char *)_PreferredDosName);
    RtlGetDefaultCodePage(&AnsiCodePage, &OemCodePage);
    len = ConvertToAndFromWideChar(AnsiCodePage, PortName.Buffer, 
            PortName.MaximumLength, (char *)_PreferredDosName, 
            comLen, TRUE);

    if (len != -1) {

        //
        // We need just the LPTx portion for later...
        //

        PortName.Length = (USHORT)len;
        PortName.Buffer[len/sizeof(WCHAR)] = L'\0';
    } else {
	    TRC_ERR((TB, "Error converting comName"));
        Status = STATUS_UNSUCCESSFUL;
        goto CleanUpAndReturn;
    }

    //
    //  Allocate the port device announce buffer.
    //
    Status = CreatePortAnnounceEvent(devAnnounceMsg, NULL, 0, L"", 
            &portAnnounceEventReqSize);

    ASSERT(Status == STATUS_BUFFER_TOO_SMALL);

    if (Status != STATUS_BUFFER_TOO_SMALL) {
    	goto CleanUpAndReturn;
    }
   

    portAnnounceEvent = (PRDPDR_PORTDEVICE_SUB)new(NonPagedPool) 
            BYTE[portAnnounceEventReqSize];

    if (portAnnounceEvent == NULL) {
        TRC_ERR((TB, "Unable to allocate portAnnounceEvent"));
        Status = STATUS_NO_MEMORY;
        goto CleanUpAndReturn;
    }

    //
    //  Create the port anounce message.
    //
    Status = CreatePortAnnounceEvent(devAnnounceMsg, portAnnounceEvent,
            portAnnounceEventReqSize, PortName.Buffer, NULL);

    if (Status != STATUS_SUCCESS) {
        delete portAnnounceEvent;
#if DBG
        portAnnounceEvent = NULL;
#endif
        goto CleanUpAndReturn;
    }

    //
    //  Dispatch the event to the associated session.  
    //
    Status = RDPDYN_DispatchNewDevMgmtEvent(
                                portAnnounceEvent,
                                _Session->GetSessionId(),
                                RDPDREVT_PORTANNOUNCE,
                                NULL
                                );

CleanUpAndReturn:

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\prnport.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    prnport.cpp

Abstract:

    Printer port Device object handles one redirected printer port

Revision History:
--*/
#include "precomp.hxx"
#define TRC_FILE "prnport"
#include "trc.h"
#include "TSQPublic.h"

extern "C" void RDPDYN_TracePrintAnnounceMsg(
    IN OUT PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg,
    IN ULONG sessionID,
    IN PCWSTR portName,
    IN PCWSTR clientName
    );

//
//  RDPDR.CPP:  Configure Devices to send IO packets to client at 
//  low priority.
//
extern ULONG DeviceLowPrioSendFlags;

//
//  RDPDR.CPP:  RDPDR.SYS Device Object
//
extern PRDBSS_DEVICE_OBJECT DrDeviceObject;

//
// RDPDr.cpp : The TS Worker Queue pointer
//
extern PVOID RDPDR_TsQueue;

#define LPTNAME "LPT"
#define COMNAME "COM"
#define PRNNAME "PRN"

/////////////////////////////////////////////////////////////////
//
//  DrPrinterPort Methods
//
  
DrPrinterPort::DrPrinterPort(SmartPtr<DrSession> &Session, ULONG DeviceType, ULONG DeviceId, 
        PUCHAR PreferredDosName) : DrDevice(Session, DeviceType, DeviceId, PreferredDosName)
{
    BEGIN_FN("DrPrinterPort::DrPrinterPort");
    SetClassName("DrPrinterPort");
    _PortNumber = 0;
    _SymbolicLinkName.Length = 0;
    _SymbolicLinkName.MaximumLength = 0;
    _SymbolicLinkName.Buffer = NULL;
    _IsOpen = FALSE;
    _PortType = FILE_DEVICE_PRINTER;
}
DrPrinterPort::~DrPrinterPort()
{
    //
    //  If the device has a port registered, then unregister the port.
    //
    if ((_PortNumber != 0) && (_SymbolicLinkName.Buffer != NULL)) {
        RDPDRPRT_UnregisterPrinterPortInterface(_PortNumber, 
                &_SymbolicLinkName);
    }
}

NTSTATUS DrPrinterPort::Initialize(PRDPDR_DEVICE_ANNOUNCE DeviceAnnounce, ULONG Length)
{
    NTSTATUS status = STATUS_SUCCESS;
    DrPrinterPortWorkItem *pItem;

    BEGIN_FN("DrPrinterPort::Initialize");
    ASSERT(DeviceAnnounce != NULL);
    
    //
    //  Create a new context for the work item.
    //
    pItem = new DrPrinterPortWorkItem;
    if (pItem == NULL) {
        status = STATUS_NO_MEMORY;
        goto CLEANUPANDEXIT;
    }
    pItem->pObj = this;

    //
    //  Copy the device announce message.
    //
    pItem->deviceAnnounce = (PRDPDR_DEVICE_ANNOUNCE)new(NonPagedPool)
                                            BYTE[sizeof(RDPDR_DEVICE_ANNOUNCE) + Length];
    if (pItem->deviceAnnounce == NULL) {
        TRC_ERR((TB, "Failed to allocate device announce message."));
        status = STATUS_NO_MEMORY;
        goto CLEANUPANDEXIT;
    }
    RtlCopyMemory(pItem->deviceAnnounce, DeviceAnnounce, 
                sizeof(RDPDR_DEVICE_ANNOUNCE) + Length);

    //
    //  AddRef ourselves so we don't go away while the work item is trying to complete.
    //
    AddRef();

    //
    // Use our TS queue worker to queue the workitem
    //
    status = TSAddWorkItemToQueue( RDPDR_TsQueue, pItem, ProcessWorkItem );

    if ( status != STATUS_SUCCESS ) {
        TRC_ERR((TB, "RDPDR: FAILED Adding workitem to TS Queue 0x%8x", status));
    }

CLEANUPANDEXIT:

    if (status != STATUS_SUCCESS) {
        if (pItem != NULL) {
            if (pItem->deviceAnnounce != NULL) {
                delete pItem->deviceAnnounce;
            }
            delete pItem;
        }
    }

    TRC_NRM((TB, "exit PrnPort::Initialize"));
    return status;
}

NTSTATUS 
DrPrinterPort::FinishDeferredInitialization(
    DrPrinterPortWorkItem *pItem
    )
/*++

Routine Description:

    FinishDeferredInitialization

    Handles deferred initialization of this object in a work item.

Arguments:

    pItem           -   Printer port work item.

Return Value:

    STATUS_SUCCESS on success.  Otherwise, an error code is returned.

 --*/   
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    BEGIN_FN("DrPrinterPort::FinishDeferredInitialization");

    TRC_ASSERT(pItem->deviceAnnounce != NULL,
            (TB, "pItem->deviceAnnounce != NULL"));

    //
    //  If printer redirection is enabled at all and the subclass okays it
    //  then create the announce message.
    //
    if (ShouldCreatePrinter()) {
        TRC_NRM((TB, "Creating printer."));
#if DBG
        // Trace information about the printer.
        RDPDYN_TracePrintAnnounceMsg(pItem->deviceAnnounce, 
                _Session->GetSessionId(), L"", 
                _Session->GetClientName());
#endif
        Status = AnnouncePrinter(pItem->deviceAnnounce);
    }
    //
    //  Otherwise, check to see if we should only announce a port device.
    //
    else if (ShouldAnnouncePrintPort()) {
        TRC_NRM((TB, "Announcing printer port."));
        Status = AnnouncePrintPort(pItem->deviceAnnounce);
    } else {
        TRC_NRM((TB, "Skipping printing device."));
        Status = STATUS_SUCCESS;
    }

    //
    //  Release the work item.
    //
    if (pItem != NULL) {
        delete pItem->deviceAnnounce;
        delete pItem;
    }

    //
    //  Release the ref count on ourselves that was added in the main initialization
    //  routine.
    //
    Release();

    return Status;
}

NTSTATUS DrPrinterPort::CreateDevicePath(PUNICODE_STRING DevicePath)
/*++
    Create NT DeviceName compatible with RDBSS convention
    
    Format is:
        \device\rdpdrport\;<DriveLetter>:<sessionid>\ClientName\DosDeviceName
    
--*/
{
    NTSTATUS Status;
    UNICODE_STRING DevicePathTail;
    
    BEGIN_FN("DrPrinterPort::CreateDevicePath");
    ASSERT(DevicePath != NULL);

    DevicePath->Length = 0;
    Status = RtlAppendUnicodeToString(DevicePath, RDPDR_PORT_DEVICE_NAME_U);

    if (!NT_ERROR(Status)) {
        // Add the reference string to the end:
        // Format is: \;<DriveLetter>:<sessionid>\clientName\share
        DevicePathTail.Length = 0;
        DevicePathTail.MaximumLength = DevicePath->MaximumLength - DevicePath->Length;
        DevicePathTail.Buffer = DevicePath->Buffer + (DevicePath->Length / sizeof(WCHAR));

        CreateReferenceString(&DevicePathTail);

        DevicePath->Length += DevicePathTail.Length;
    }

    TRC_NRM((TB, "DevicePath=%wZ", DevicePath));

    return Status;
}

BOOL DrPrinterPort::ShouldAnnouncePrintPort()
{
    BEGIN_FN("DrPrinterPort::ShouldAnnouncePrintPort");
    return IsDeviceNameValid();
}

BOOL DrPrinterPort::ShouldCreatePrinter()
{
    BEGIN_FN("DrPrinterPort::ShouldCreatePrinter");
    if(!_Session->DisablePrinterMapping()) {
        return IsDeviceNameValid();
    }
    
    return FALSE;
}

BOOL DrPrinterPort::ShouldCreatePort()
{
    BEGIN_FN("DrPrinterPort::ShouldCreatePort");
    if (!_Session->DisablePrinterMapping()) {
        return IsDeviceNameValid();
    }
    
    return FALSE;
}

BOOL DrPrinterPort::IsDeviceNameValid()
{
    BEGIN_FN("DrPrinterPort::IsDeviceNameValid");
    BOOL fRet = FALSE;
    PUCHAR PreferredDosName = _PreferredDosName;
    char* portName = NULL;
    //
    // Our device name is valid only if
    // the first 3 chars contain "LPT or "COM" or PRN"
    // and the rest are digits.
    // We will do case-sensitive compare.
    //
    switch(_DeviceType) {
        case RDPDR_DTYP_SERIAL:
            portName = COMNAME;
            break;

        case RDPDR_DTYP_PARALLEL:
            portName = LPTNAME;
            break;
            
        case RDPDR_DTYP_PRINT:
            portName = PRNNAME;
            break;
            
        default:
            break;
    }

    if (portName != NULL) {
        DWORD numChars = strlen(portName);
        //
        // ASSERT that we got atleast 3 chars for devicename
        //
        ASSERT(strlen((char*)PreferredDosName) >= numChars);

        if(!strncmp((char*)PreferredDosName, portName, numChars)) {
            fRet = TRUE;
            //
            // portname matches, check for digits.
            //
            PreferredDosName += numChars;
            while(PreferredDosName && *PreferredDosName) {
                if(!isdigit(*PreferredDosName)) {
                    fRet = FALSE;
                    break;
                }
                PreferredDosName++;
            }
        }
    }
    //
    // This assert should never fire for port redirection
    //
    ASSERT(fRet);
    return fRet;
}

NTSTATUS 
DrPrinterPort::Write(
    IN OUT PRX_CONTEXT RxContext, 
    IN BOOL LowPrioSend
    ) 
/*++

Routine Description:

    Override the 'Write' method.  This needs to go to the client at low priority
    to prevent us from filling the entire pipe on a slow link with print data.

Arguments:

Return Value:

    STATUS_SUCCESS on success.  Otherwise, an error code is returned.

 --*/   
{
    return DrDevice::Write(
                RxContext, 
                DeviceLowPrioSendFlags & DEVICE_LOWPRIOSEND_PRINTERS
                );
}

VOID
DrPrinterPort::ProcessWorkItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID context
    )
/*++

Routine Description:

    ProcessWorkItem

Arguments:

    deviceObject    -   Associated device object.
    context         -   Work item context.

Return Value:

    STATUS_SUCCESS on success.  Otherwise, an error code is returned.

 --*/   
{
    DrPrinterPortWorkItem* pItem = (DrPrinterPortWorkItem*)context;
    pItem->pObj->FinishDeferredInitialization(pItem);
}

NTSTATUS DrPrinterPort::CreatePrinterPort(PWCHAR portName)
{
    NTSTATUS status;
    WCHAR ntDevicePathBuffer[RDPDRMAXREFSTRINGLEN];
    UNICODE_STRING ntDevicePath = {0, sizeof(ntDevicePathBuffer),
            ntDevicePathBuffer};

    BEGIN_FN("DrPrinterPort::CreatePrinterPort");
    CreateReferenceString(&ntDevicePath);

    status = RDPDRPRT_RegisterPrinterPortInterface(_Session->GetClientName(),
            (LPSTR)_PreferredDosName, &ntDevicePath, portName, &_SymbolicLinkName,
            &_PortNumber);
    if (status != STATUS_SUCCESS) {
        _PortNumber = 0;
    }

    return status;
}

NTSTATUS DrPrinterPort::AnnouncePrintPort(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg)
{
    NTSTATUS Status;
    ULONG portAnnounceEventReqSize;
    PRDPDR_PORTDEVICE_SUB portAnnounceEvent;
    
    BEGIN_FN("DrPrinterPort::AnnouncePrintPort");

    WCHAR portName[RDPDR_MAXPORTNAMELEN];
    Status = CreatePrinterPort(portName);
    
    if (Status != STATUS_SUCCESS) {
        goto CleanUpAndReturn;
    }
    
    TRC_ASSERT(wcslen(portName)+1 <= RDPDR_MAXPORTNAMELEN, 
            (TB, "Port name too long"));
 
    //
    //  Allocate the port device announce buffer.
    //
    Status = CreatePortAnnounceEvent(
                    devAnnounceMsg, 
                    NULL, 
                    0, 
                    //L"", 
                    portName,
                    &portAnnounceEventReqSize
                    );

    ASSERT(Status == STATUS_BUFFER_TOO_SMALL);

    if( Status == STATUS_BUFFER_TOO_SMALL || Status == STATUS_SUCCESS ) {

        portAnnounceEvent = (PRDPDR_PORTDEVICE_SUB)new(NonPagedPool) 
                                    BYTE[portAnnounceEventReqSize];

        if (portAnnounceEvent == NULL) {
            TRC_ERR((TB, "Unable to allocate portAnnounceEvent"));
            Status = STATUS_NO_MEMORY;
            goto CleanUpAndReturn;
        }

        //
        //  Create the port anounce message.
        //
        Status = CreatePortAnnounceEvent(
                            devAnnounceMsg, 
                            portAnnounceEvent,
                            portAnnounceEventReqSize, 
                            //L"", 
                            portName,
                            &portAnnounceEventReqSize
                            );

        if (Status != STATUS_SUCCESS) {

            delete portAnnounceEvent;
        #if DBG
            portAnnounceEvent = NULL;
        #endif
            goto CleanUpAndReturn;
        }

        // device is a printer port.
        portAnnounceEvent->deviceFields.DeviceType = RDPDR_DRYP_PRINTPORT;  

        //
        //  This happens in a work item so we need to avoid a race in terms of having us 
        //  get disconnected previous to announcing the device to the user-mode component.
        //
        _Session->LockRDPDYNConnectStateChange();
        if (_Session->IsConnected()) {

            //
            //  Dispatch the event to the associated session.
            //
            Status = RDPDYN_DispatchNewDevMgmtEvent(
                                        portAnnounceEvent,
                                        _Session->GetSessionId(),
                                        RDPDREVT_PORTANNOUNCE,
                                        this
                                        );
        }
        else {
            delete portAnnounceEvent;
            portAnnounceEvent = NULL;
        }
        _Session->UnlockRDPDYNConnectStateChange();
    }

CleanUpAndReturn:
    return Status;
}

NTSTATUS DrPrinterPort::AnnouncePrinter(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg)
{
    NTSTATUS Status;
    ULONG prnAnnounceEventReqSize;
    PRDPDR_PRINTERDEVICE_SUB prnAnnounceEvent;

    BEGIN_FN("DrPrinterPort::AnnouncePrinter");

    WCHAR portName[RDPDR_MAXPORTNAMELEN];
    Status = CreatePrinterPort(portName);

    if (Status != STATUS_SUCCESS) {
        goto CleanUpAndReturn;
    }

    TRC_ASSERT(wcslen(portName)+1 <= RDPDR_MAXPORTNAMELEN, 
            (TB, "Port name too long"));

    //
    //  Allocate the printer device announce buffer.
    //
    Status = CreatePrinterAnnounceEvent(devAnnounceMsg, NULL, 0, 
            //L"", 
            portName,
            &prnAnnounceEventReqSize);
    ASSERT(Status == STATUS_BUFFER_TOO_SMALL);

    if (Status != STATUS_BUFFER_TOO_SMALL) {
        goto CleanUpAndReturn;
    }

    prnAnnounceEvent = (PRDPDR_PRINTERDEVICE_SUB)new(NonPagedPool) 
            BYTE[prnAnnounceEventReqSize];

    if (prnAnnounceEvent == NULL) {
        TRC_ERR((TB, "Unable to allocate prnAnnounceEvent"));
        Status = STATUS_NO_MEMORY;
        goto CleanUpAndReturn;
    }

    //
    //  Create the printer anounce message, but defer assigning a
    //  port name until just before we return the announce event
    //  back to user mode.
    //
    Status = CreatePrinterAnnounceEvent(devAnnounceMsg, prnAnnounceEvent,
            prnAnnounceEventReqSize, 
            //L"", 
            portName,
            NULL);
    if (Status != STATUS_SUCCESS) {
        delete prnAnnounceEvent;
#if DBG
        prnAnnounceEvent = NULL;
#endif
        goto CleanUpAndReturn;
    }

    //
    //  This happens in a work item so we need to avoid a race in terms of having us 
    //  get disconnected previous to announcing the device to the user-mode component.
    //
    _Session->LockRDPDYNConnectStateChange();
    if (_Session->IsConnected()) {

        //
        //  Dispatch the event to the associated session.
        //
        Status = RDPDYN_DispatchNewDevMgmtEvent(
                                    prnAnnounceEvent,
                                    _Session->GetSessionId(),
                                    RDPDREVT_PRINTERANNOUNCE,
                                    this
                                    );
    }
    else {
        delete prnAnnounceEvent;
        prnAnnounceEvent = NULL;
    }

    _Session->UnlockRDPDYNConnectStateChange();

CleanUpAndReturn:
    return Status;
}

NTSTATUS DrPrinterPort::CreatePrinterAnnounceEvent(
    IN      PRDPDR_DEVICE_ANNOUNCE  devAnnounceMsg,
    IN OUT  PRDPDR_PRINTERDEVICE_SUB prnAnnounceEvent,
    IN      ULONG prnAnnounceEventSize,
    IN      PCWSTR portName,
    OPTIONAL OUT ULONG *prnAnnounceEventReqSize
    )
/*++

Routine Description:

    Generate a RDPDR_PRINTERDEVICE_SUB event from a client-sent
    RDPDR_DEVICE_ANNOUNCE message.

Arguments:

    devAnnounceMsg  -         Device announce message received from client.
    prnAnnounceEvent  -       Buffer for receiving finished printer announce event.
    prnAnnounceEventSize -    Size of prnAnnounceEvent buffer.
    portName -                Name of local printer port to be associated with
                              client-side printing device.
    prnAnnounceEventReqSize - Returned required size of prnAnnounceMsg buffer.

Return Value:

    STATUS_INVALID_BUFFER_SIZE is returned if the prnAnnounceEventSize size is
    too small.  STATUS_SUCCESS is returned on success.

--*/
{
    ULONG requiredSize;
    PRDPDR_PRINTERDEVICE_ANNOUNCE pClientPrinterFields;
    ULONG sz;

    BEGIN_FN("DrPrinterPort::CreatePrinterAnnounceEvent");

    //  Make sure the client-sent device announce message is a printer announce
    //  message.
    TRC_ASSERT(devAnnounceMsg->DeviceType == RDPDR_DTYP_PRINT,
              (TB, "Printing device expected"));

    //
    // Validate device datalengths for some minimum lengths.
    // Maximum lengths are verified by the device manager.
    //
    if (devAnnounceMsg->DeviceDataLength < sizeof(RDPDR_PRINTERDEVICE_ANNOUNCE)) {

        TRC_ASSERT(FALSE,
                  (TB, "Innvalid device announce buf."));
        TRC_ERR((TB, "Invalid device datalength %ld", devAnnounceMsg->DeviceDataLength));

        return STATUS_INVALID_PARAMETER;
    }
    
    // Get access to the printer-specific fields for the device announce message.
    pClientPrinterFields = (PRDPDR_PRINTERDEVICE_ANNOUNCE)(((PBYTE)devAnnounceMsg) +
                                          sizeof(RDPDR_DEVICE_ANNOUNCE));

    //
    //  Calculate the number of bytes needed in the output buffer.
    //
    requiredSize = sizeof(RDPDR_PRINTERDEVICE_SUB) +
                            pClientPrinterFields->PnPNameLen +
                            pClientPrinterFields->DriverLen +
                            pClientPrinterFields->PrinterNameLen +
                            pClientPrinterFields->CachedFieldsLen;

    if (prnAnnounceEventSize < requiredSize) {
        if (prnAnnounceEventReqSize != NULL) {
            *prnAnnounceEventReqSize = requiredSize;
        }
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Check the integrity of the input buffer using known sizes.
    sz = pClientPrinterFields->PnPNameLen +
         pClientPrinterFields->DriverLen +
         pClientPrinterFields->PrinterNameLen +
         pClientPrinterFields->CachedFieldsLen +
         sizeof(RDPDR_PRINTERDEVICE_ANNOUNCE);

    //
    // Sanity Check
    //

    if (devAnnounceMsg->DeviceDataLength != sz) {
        TRC_ASSERT(devAnnounceMsg->DeviceDataLength == sz,
                  (TB, "Size integrity questionable in dev announce buf."));
        return STATUS_INVALID_PARAMETER;
    }
    //
    // The above check alone is not enough. 
    // Someone can do an overflow attack
    // Overflow means for example: 
    //                  PnpNameLen : 1, 
    //                  DriverLen: 2, 
    //                  PrinterNameLen:0xfffffffd, 
    //                  CachedFieldsLen:2
    // Combined these will be good, but individually, one of them will cause havoc
    //
    if (pClientPrinterFields->PnPNameLen > devAnnounceMsg->DeviceDataLength ||
        pClientPrinterFields->DriverLen > devAnnounceMsg->DeviceDataLength ||
        pClientPrinterFields->PrinterNameLen > devAnnounceMsg->DeviceDataLength ||
        pClientPrinterFields->CachedFieldsLen > devAnnounceMsg->DeviceDataLength) {
        
        TRC_ASSERT(FALSE,
                  (TB, "Field lengths and device datalengths mismatched in dev announce buf."));

        return STATUS_INVALID_PARAMETER;
    }
    

    //
    //  Add the data to the output buffer.
    //

    // Port Name.
    TRC_ASSERT(wcslen(portName)+1 <= RDPDR_MAXPORTNAMELEN,
                (TB, "Port name too long"));
    wcscpy(prnAnnounceEvent->portName, portName);

    // Client Name (computer name).
    TRC_ASSERT(wcslen(_Session->GetClientName())+1 <= RDPDR_MAX_COMPUTER_NAME_LENGTH,
                (TB, "Client name too long"));
    wcscpy(prnAnnounceEvent->clientName, _Session->GetClientName());

    // Client-received device announce message.
    RtlCopyMemory(&prnAnnounceEvent->deviceFields, devAnnounceMsg,
               sizeof(RDPDR_DEVICE_ANNOUNCE) +
               devAnnounceMsg->DeviceDataLength);

    // Return the size.
    if (prnAnnounceEventReqSize != NULL) {
        *prnAnnounceEventReqSize = requiredSize;
    }

    TRC_NRM((TB, "exit CreatePrinterAnnounceEvent."));

    return STATUS_SUCCESS;
}

NTSTATUS DrPrinterPort::CreatePortAnnounceEvent(
    IN      PRDPDR_DEVICE_ANNOUNCE  devAnnounceMsg,
    IN OUT  PRDPDR_PORTDEVICE_SUB portAnnounceEvent,
    IN      ULONG portAnnounceEventSize,
    IN      PCWSTR portName,
    OPTIONAL OUT ULONG *portAnnounceEventReqSize
    )
/*++

Routine Description:

    Generate a PRDPDR_PORTDEVICE_SUB event from a client-sent
    RDPDR_DEVICE_ANNOUNCE message.

Arguments:

    devAnnounceMsg              - Device announce message received from
                                  client.
    portAnnounceEvent           - Buffer for receiving finished printer
                                  announce event.
    portAnnounceEventSize       - Size of prnAnnounceEvent buffer.
    portName                    - Name of local printer port to be associated
                                  with client-side printing device.
    portAnnounceEventReqSize    - Returned required size of prnAnnounceMsg
                                  buffer.

Return Value:

    STATUS_INVALID_BUFFER_SIZE is returned if the prnAnnounceEventSize size is
    too small.  STATUS_SUCCESS is returned on success.

--*/
{
    ULONG requiredSize;
    PRDPDR_PRINTERDEVICE_ANNOUNCE pClientPrinterFields;
#if DBG
    ULONG sz;
#endif

    WCHAR NtDevicePathBuffer[RDPDRMAXNTDEVICENAMEGLEN + 1];
    UNICODE_STRING NtDevicePath;
    NTSTATUS Status;

    NtDevicePath.MaximumLength = sizeof(NtDevicePathBuffer);
    NtDevicePath.Length = 0;
    NtDevicePath.Buffer = &NtDevicePathBuffer[0];

    BEGIN_FN("CreatePortAnnounceEvent");

    //
    // Get the NT device path to this dr device
    //

    Status = CreateDevicePath(&NtDevicePath);
    TRC_NRM((TB, "Nt Device path: %wZ", &NtDevicePath));

    if (!NT_ERROR(Status)) {
    
        //  Make sure the client-sent device announce message is a printer announce
        //  message.
        TRC_ASSERT((devAnnounceMsg->DeviceType == RDPDR_DTYP_SERIAL) ||
                  (devAnnounceMsg->DeviceType == RDPDR_DTYP_PARALLEL),
                  (TB, "Port device expected"));

        //
        // Make sure device data length is what we expect from the client
        //
        if(!DR_CHECK_DEVICEDATALEN(devAnnounceMsg, RDPDR_PORTDEVICE_SUB)) {

            TRC_ASSERT(FALSE,
                       (TB, "Invalid Device DataLength"));

            TRC_ERR((TB,"Invalid Device DataLength %d", devAnnounceMsg->DeviceDataLength));

            return STATUS_INVALID_PARAMETER;
        }
    
        //
        //  Calculate the number of bytes needed in the output buffer.
        //
        requiredSize = sizeof(RDPDR_PORTDEVICE_SUB) + devAnnounceMsg->DeviceDataLength;
        if (portAnnounceEventSize < requiredSize) {
            if (portAnnounceEventReqSize != NULL) {
                *portAnnounceEventReqSize = requiredSize;
            }
            return STATUS_BUFFER_TOO_SMALL;
        }
    
        // We shouldn't have any "additional" device-specific data from the client.
        TRC_ASSERT(devAnnounceMsg->DeviceDataLength == 0,
                  (TB, "Size integrity questionable in dev announce buf."));
    
        //
        //  Add the data to the output buffer.
        //
    
        // Port Name.
        TRC_ASSERT(wcslen(portName)+1 <= RDPDR_MAXPORTNAMELEN, 
                (TB, "Port name too long"));
        wcscpy(portAnnounceEvent->portName, portName);

        // Device Path.
        NtDevicePath.Buffer[NtDevicePath.Length/sizeof(WCHAR)] = L'\0';
        TRC_ASSERT(wcslen(NtDevicePath.Buffer)+1 <= RDPDRMAXNTDEVICENAMEGLEN, 
                (TB, "Device path too long"));
        wcscpy(portAnnounceEvent->devicePath, NtDevicePath.Buffer);

        // Client-received device announce message.
        RtlCopyMemory(&portAnnounceEvent->deviceFields, devAnnounceMsg,
                   sizeof(RDPDR_DEVICE_ANNOUNCE) +
                   devAnnounceMsg->DeviceDataLength);

        // Return the size.
        if (portAnnounceEventReqSize != NULL) {
            *portAnnounceEventReqSize = requiredSize;
        }

        TRC_NRM((TB, "exit CreatePortAnnounceEvent."));

        return STATUS_SUCCESS;
    }
    else {
        return Status;
    }
}

VOID DrPrinterPort::Remove()
{
    PUNICODE_STRING symbolicLinkName;
    PRDPDR_REMOVEDEVICE deviceRemoveEventPtr = NULL;

    BEGIN_FN("DrPrinterPort::Remove");

    //
    //  Create and dispatch the remove device event.
    //
    deviceRemoveEventPtr = new(NonPagedPool) RDPDR_REMOVEDEVICE;

    if (deviceRemoveEventPtr != NULL) {

        //
        //  Dispatch it.
        //
        deviceRemoveEventPtr->deviceID = _DeviceId;
        RDPDYN_DispatchNewDevMgmtEvent(
                            deviceRemoveEventPtr,
                            _Session->GetSessionId(),
                            RDPDREVT_REMOVEDEVICE,
                            NULL
                            );
    }
    else {
        TRC_ERR((TB, "Unable to allocate %ld bytes for remove event",
                sizeof(RDPDR_REMOVEDEVICE)));
    }
}

NTSTATUS DrPrinterPort::Create(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status;

    BEGIN_FN("DrPrinterPort::Create");
    //
    // Fail Creates when we're already open once
    //

    DrAcquireSpinLock();
    if (_IsOpen) {
        DrReleaseSpinLock();
        TRC_ALT((TB, "Failing create while already open"));
        return STATUS_SHARING_VIOLATION;
    } else {
        _IsOpen = TRUE;
        DrReleaseSpinLock();
    }

    Status = DrDevice::Create(RxContext);
    if (!NT_SUCCESS(Status)) {
        DrAcquireSpinLock();
        ASSERT(_IsOpen);
        TRC_NRM((TB, "Marking creatable for failed open"));
        _IsOpen = FALSE;
        DrReleaseSpinLock();
    }
    return Status;
}

NTSTATUS DrPrinterPort::QueryVolumeInfo(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_NOT_IMPLEMENTED;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    FS_INFORMATION_CLASS FsInformationClass = RxContext->Info.FsInformationClass;
    
    BEGIN_FN("DrPrinterPort:QueryVolumeInfo");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //
    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_QUERY_VOLUME_INFORMATION);
    ASSERT(Session != NULL);
    
    if (!Session->IsConnected()) {
        TRC_ALT((TB, "Tried to query client device volume information while not "
            "connected. State: %ld", _Session->GetState()));

        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    // Make sure the device is still enabled
    //

    if (_DeviceStatus != dsAvailable) {
        TRC_ALT((TB, "Tried to query client device volume information while not "
            "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    
    TRC_DBG((TB, "QueryVolume information class = %x", FsInformationClass));

    switch (FsInformationClass) {
        case FileFsDeviceInformation:
        {
            PLONG pLengthRemaining = &RxContext->Info.LengthRemaining;
            PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;

            if (sizeof(FILE_FS_DEVICE_INFORMATION) <= *pLengthRemaining) {
                PFILE_FS_DEVICE_INFORMATION UsersBuffer =
                        (PFILE_FS_DEVICE_INFORMATION) RxContext->Info.Buffer;

                UsersBuffer->Characteristics = FILE_REMOTE_DEVICE;
                UsersBuffer->DeviceType = _PortType;
                *pLengthRemaining  -= (sizeof(FILE_FS_DEVICE_INFORMATION));
                return STATUS_SUCCESS;
            }
            else {
                FILE_FS_DEVICE_INFORMATION UsersBuffer;

                UsersBuffer.Characteristics = FILE_REMOTE_DEVICE;
                UsersBuffer.DeviceType = _PortType;
                RtlCopyMemory(RxContext->Info.Buffer, &UsersBuffer, *pLengthRemaining);
                *pLengthRemaining = 0;
                return  STATUS_BUFFER_OVERFLOW;
            }
        }
        
        default:
            TRC_DBG((TB, "Unhandled FsInformationClass=%x", FsInformationClass));
            return STATUS_NOT_IMPLEMENTED;
    }    
    
    return Status;
}

VOID DrPrinterPort::NotifyClose()
{
    BEGIN_FN("DrPrinterPort::NotifyClose");

    DrDevice::NotifyClose();

    DrAcquireSpinLock();
    ASSERT(_IsOpen);
    TRC_NRM((TB, "Marking creatable once closed"));
    _IsOpen = FALSE;
    DrReleaseSpinLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\prnport.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    prnport.h

Abstract:

    Printer port Device object handles one redirected printer port

Revision History:
--*/
#pragma once


/////////////////////////////////////////////////////////////////
//
//  DrPrinterPort Class
//

class DrPrinterPort : public DrDevice
{
protected:
    ULONG          _PortType;
    ULONG          _PortNumber;
    UNICODE_STRING _SymbolicLinkName;
    BOOL _IsOpen;

    typedef struct __WorkItem {
        DrPrinterPort* pObj;
        PRDPDR_DEVICE_ANNOUNCE deviceAnnounce;
    } DrPrinterPortWorkItem;

    virtual NTSTATUS CreateDevicePath(PUNICODE_STRING DevicePath);
    virtual BOOL IsDeviceNameValid();

public:
    DrPrinterPort(SmartPtr<DrSession> &Session, ULONG DeviceType, 
            ULONG DeviceId, PUCHAR PreferredDosName);
    virtual ~DrPrinterPort();            
    virtual NTSTATUS Initialize(PRDPDR_DEVICE_ANNOUNCE DeviceAnnounce, ULONG Length);
    NTSTATUS CreatePrinterPort(PWCHAR portName);
    virtual BOOL ShouldCreatePort();
    virtual BOOL ShouldCreatePrinter();
    virtual BOOL ShouldAnnouncePrintPort();
    NTSTATUS CreatePrinterAnnounceEvent(
        IN      PRDPDR_DEVICE_ANNOUNCE  devAnnounceMsg,
        IN OUT  PRDPDR_PRINTERDEVICE_SUB prnAnnounceEvent,
        IN      ULONG prnAnnounceEventSize,
        IN      PCWSTR portName,
        OPTIONAL OUT ULONG *prnAnnounceEventReqSize
        );
    NTSTATUS CreatePortAnnounceEvent(
        IN      PRDPDR_DEVICE_ANNOUNCE  devAnnounceMsg,
        IN OUT  PRDPDR_PORTDEVICE_SUB portAnnounceEvent,
        IN      ULONG portAnnounceEventSize,
        IN      PCWSTR portName,
        OPTIONAL OUT ULONG *portAnnounceEventReqSize
        );

    virtual VOID Remove();

    //  Override the 'Write' method.  This needs to go to the client at low priority
    //  to prevent us from filling the entire pipe on a slow link with print data.
    virtual NTSTATUS Write(IN OUT PRX_CONTEXT RxContext, IN BOOL LowPrioSend = FALSE);

    virtual NTSTATUS FinishDeferredInitialization(DrPrinterPortWorkItem *pItem);

    virtual NTSTATUS Create(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS QueryVolumeInfo(IN OUT PRX_CONTEXT RxContext);
    
    virtual VOID NotifyClose();

    static VOID ProcessWorkItem(
          IN PDEVICE_OBJECT DeviceObject,
          IN PVOID context
          );
    NTSTATUS AnnouncePrinter(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg);
    virtual NTSTATUS AnnouncePrintPort( 
        PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg);
};

/////////////////////////////////////////////////////////////////
//
//  DrPrinter Class
//

class DrPrinter : public DrPrinterPort
{
public:

    DrPrinter(SmartPtr<DrSession> &Session, ULONG DeviceType, 
            ULONG DeviceId, PUCHAR PreferredDosName) :
        DrPrinterPort( Session, DeviceType, DeviceId, PreferredDosName )
    {
    }
    virtual BOOL ShouldAnnouncePrintPort() { return FALSE; }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\rdpdrp.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    rdpdrp.h

Abstract:

    Private prototypes, structures, and macros that are used throughout the
    driver.

Revision History:
--*/
#pragma once

// Dr's Pooltag (doctor! doctor!)
#define DR_POOLTAG 'rDrD'

// REVIEW: um, I just made these up. They are used to determine
// how many outstandng irps we can have at one time
#define DR_MAX_OPERATIONS       1024
#define DR_TYPICAL_OPERATIONS   128

// Indexes in to RxContext->MRxContext
#define MRX_DR_CONTEXT          0

#define INVALID_MID 0xFFFF

// Session ID for console seession.
#define CONSOLE_SESSIONID   0

//
//  Flag values for configuring Devices to send IO packets to client at low priority.
//
#define DEVICE_LOWPRIOSEND_PRINTERS 0x00000000

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

extern PRDBSS_DEVICE_OBJECT      DrDeviceObject;

NTKERNELAPI NTSTATUS IoGetRequestorSessionId(
    IN PIRP Irp, 
    OUT PULONG pSessionId
    );

NTKERNELAPI
NTSTATUS
IoOpenDeviceInterfaceRegistryKey(
    IN PUNICODE_STRING SymbolicLinkName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE DeviceInterfaceKey
    );
NTKERNELAPI
NTSTATUS
NTAPI
IoRegisterDeviceInterface(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN CONST GUID *InterfaceClassGuid,
    IN PUNICODE_STRING ReferenceString,     OPTIONAL
    OUT PUNICODE_STRING SymbolicLinkName
    );
NTSYSAPI
VOID
NTAPI
RtlGetDefaultCodePage(
    OUT PUSHORT AnsiCodePage,
    OUT PUSHORT OemCodePage
    );


NTSTATUS
ObSetSecurityObjectByPointer (
    IN PVOID Object,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    );


VOID
DrUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
DrFlush(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
DrWrite(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
DrRead(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
DrIoControl(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
DrCreate(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
DrCloseSrvOpen(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
DrCleanup(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
DrQueryInformationFile(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
DrSetInformationFile(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
DrDevFcbXXXControlFile (
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
DrOnSessionConnect(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
DrOnSessionDisconnect(
    IN OUT PRX_CONTEXT RxContext
    );

NTSTATUS
DrDeallocateForFobx(
    IN OUT PMRX_FOBX pFobx
    );

NTSTATUS
DrForceClosed(
    IN PMRX_SRV_OPEN pSrvOpen
    );

VOID
DrStartMinirdr(
    PRX_CONTEXT RxContext
    );

NTSTATUS
DrEnumerateConnections (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
DrEnumerateShares (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
DrEnumerateServers (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
DrGetConnectionInfo (
    IN PRX_CONTEXT RxContext
    );

NTSTATUS
DrDeleteConnection (
    IN PRX_CONTEXT RxContext,
    OUT PBOOLEAN PostToFsp
    );

VOID
DrStartMinirdrWorker(
    IN PVOID StartContext
    );

BOOLEAN
DrFindChannelFromConnectIn(
    PULONG ChannelId,
    PCHANNEL_CONNECT_IN ConnectIn
    );

BOOLEAN
DrIsAdminIoRequest (
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp
    );

BOOLEAN 
DrIsSystemProcessRequest(
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp
);
#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

// 
//  UNC server name 
//
#define DRUNCSERVERNAME_U L"tsclient"
#define DRUNCSERVERNAME_A "tsclient"

// The following constant defines the length of the above name.

#define DRUNCSERVERNAME_U_LENGTH (sizeof(DRUNCSERVERNAME_U))
#define DRUNCSERVERNAME_A_LENGTH (sizeof(DRUNCSERVERNAME_A))

extern HANDLE DrSystemProcessId;
extern KSPIN_LOCK DrSpinLock;
extern FAST_MUTEX DrMutex;
extern KIRQL DrOldIrql;

#define DrAcquireSpinLock() KeAcquireSpinLock(&DrSpinLock, &DrOldIrql)
#define DrReleaseSpinLock() KeReleaseSpinLock(&DrSpinLock, DrOldIrql)

#define DrAcquireMutex() ExAcquireFastMutex(&DrMutex)
#define DrReleaseMutex() ExReleaseFastMutex(&DrMutex)

#define IS_SYSTEM_PROCESS() (PsGetCurrentProcessId() == DrSystemProcessId)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\rdpdrprt.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    rdpdrprt.c

Abstract:

    Manage dynamic printer port allocation for the RDP device redirection
    kernel mode component, rdpdr.sys.

    Port number 0 is reserved and is never allocated.

Author:

    tadb

Revision History:
--*/

#include "precomp.hxx"
#define TRC_FILE "rdpdrprt"
#include "trc.h"

#define DRIVER

#include <stdio.h>
#ifdef  __cplusplus
extern "C" {
#endif

#include "cfg.h"
#include "pnp.h"




////////////////////////////////////////////////////////////////////////
//
//      Function Prototypes
//

//  Generate a port name from a port number.
BOOL GeneratePortName(
    IN ULONG portNumber,
    OUT PWSTR portName
    );

//  Finds the next free port, following the last port checked, in the port bit 
//  array.  
NTSTATUS FindNextFreePortInPortArray(
    IN ULONG lastPortChecked,
    OUT ULONG *nextFreePort
    );

//  Increase the size of the port bit array to hold at least one new
//  port.
NTSTATUS IncreasePortBitArraySize();

//  Format a port description.
void GeneratePortDescription(
    IN PCSTR dosPortName,
    IN PCWSTR clientName,
    IN PWSTR description
    );

//  Return TRUE if the port's device interface is usable, from dynamon's
//  perspective.
BOOL PortIsAvailableForUse(
    IN HANDLE  regHandle                     
    );

//  Set the port description string to disabled.
NTSTATUS SetPortDescrToDisabled(
    IN PUNICODE_STRING symbolicLinkName
    );

//  Clean up ports registered in a previous boot.
NTSTATUS CleanUpExistingPorts();

//  Allocate a port.
NTSTATUS AllocatePrinterPort(
    IN ULONG  portArrayIndex,
    OUT PWSTR   portName,
    OUT ULONG   *portNumber,
    OUT HANDLE  *regHandle,
    OUT PUNICODE_STRING symbolicLinkName
    );

#ifdef  __cplusplus
} // extern "C"
#endif

////////////////////////////////////////////////////////////////////////
//
//      Defines and Macros
//

#define BITSINBYTE                      8
#define BITSINULONG                     (sizeof(ULONG) * BITSINBYTE)

// Printer port description length (in characters).
#define RDPDRPRT_PORTDESCRLENGTH          \
    MAX_COMPUTERNAME_LENGTH +        1  + 2 +  PREFERRED_DOS_NAME_SIZE + 1
//  Computer Name                    ':' '  '  Dos Name                  Terminator  

//  Initial size of the port bit array.
#define RDPDRPRT_INITIALPORTCOUNT       64
//restore this#define RDPDRPRT_INITIALPORTCOUNT       256

// Base name for TermSrv printer ports
#define RDPDRPRT_BASEPORTNAME         L"TS"

// Device interface port number registry value name.
#define PORT_NUM_VALUE_NAME         L"Port Number"

// Device interface write size registry value name.
#define PORT_WRITESIZE_VALUE_NAME   L"MaxBufferSize"

// Device interface port base name registry value name.
#define PORT_BASE_VALUE_NAME        L"Base Name"

// Device interface port description registry value name.
#define PORT_DESCR_VALUE_NAME       L"Port Description"

// Device interface port recyclable flag registry value name.
#define RECYCLABLE_FLAG_VALUE_NAME  L"recyclable"


// We will use separate arrays for the printer port and printer queues to avoid
// a race condition between creating a printer queue and listening on the printer port
#define PRINTER_PORT_ARRAY_ID 1

////////////////////////////////////////////////////////////////////////
//
//      External Globals
//

// The Physical Device Object that terminates our DO stack (defined in rdpdyn.c).
extern PDEVICE_OBJECT RDPDYN_PDO;

//  USBMON Port Write Size.  Need to keep it under 64k for 16-bit clients ... 
//  otherwise, the go off the end of a segment. (defined in rdpdr.cpp)
extern ULONG PrintPortWriteSize;

////////////////////////////////////////////////////////////////////////
//
//      Globals for this Module
//

//
//  For Tracking Allocated Ports.  A cleared bit indicates a free port.
//
ULONG *PortBitArray = NULL;
ULONG PortBitArraySizeInBytes = 0;

//
// Is this module initialized?
//
BOOL RDPDRPRT_Initialized = FALSE;


// Description for disabled port.  Note:  We can localize this later.
WCHAR DisabledPortDescription[RDPDRPRT_PORTDESCRLENGTH] = L"Inactive TS Port";
ULONG DisabledPortDescrSize = 0;

//  This is the GUID we use to identify a dynamic printer port to
//  dynamon.
// {28D78FAD-5A12-11d1-AE5B-0000F803A8C2}
const GUID DYNPRINT_GUID =
{ 0x28d78fad, 0x5a12, 0x11d1, { 0xae, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa8, 0xc2 } };

//
//  Port Allocation Lock
//
KSPIN_LOCK PortAllocLock;
KIRQL      OldIRQL;
#define RDPDRPRT_LOCK() \
    KeAcquireSpinLock(&PortAllocLock, &OldIRQL)
#define RDPDRPRT_UNLOCK() \
    KeReleaseSpinLock(&PortAllocLock, OldIRQL)


NTSTATUS
RDPDRPRT_Initialize(
    )
/*++

Routine Description:

    Initialize this module.

Arguments:

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS status = STATUS_SUCCESS;

    BEGIN_FN("RDPDRPRT_Initialize");

    //
    //  Initialize the lock for port allocations.
    //
    KeInitializeSpinLock(&PortAllocLock);

    //
    //  Compute the size of the disabled port description string.
    //
    DisabledPortDescrSize = (wcslen(DisabledPortDescription)+1)*sizeof(WCHAR);

    //
    //  Allocate and initialize the allocated port bits array.
    //

    //  Calculate initial size.
    PortBitArraySizeInBytes = (RDPDRPRT_INITIALPORTCOUNT / BITSINULONG) 
                                    * sizeof(ULONG);
    if (RDPDRPRT_INITIALPORTCOUNT % BITSINULONG) {
        PortBitArraySizeInBytes += sizeof(ULONG);
    }

    //  Allocate.
    PortBitArray = (ULONG *)new(NonPagedPool) BYTE[PortBitArraySizeInBytes];
    if (PortBitArray == NULL) {
        TRC_ERR((TB, "Error allocating %ld bytes for port array",
                PortBitArraySizeInBytes));
        PortBitArraySizeInBytes = 0;
        status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {
        // Initially, all the ports are free.
        RtlZeroMemory(PortBitArray, PortBitArraySizeInBytes);
    }

    //
    //  Clean up ports allocated in a previous boot.
    //
    if (status == STATUS_SUCCESS) {
        //
        // Cleanup status not critical for init
        //
        CleanUpExistingPorts();
        RDPDRPRT_Initialized = TRUE;
    }

    return status;
}

void
RDPDRPRT_Shutdown()
/*++

Routine Description:

    Shut down this module.

Arguments:

Return Value:

--*/
{
    BEGIN_FN("RDPDRPRT_Shutdown");
    
    if (!RDPDRPRT_Initialized) {
        TRC_ERR((TB, 
                "RDPDRPRT_Shutdown: RDPDRPRT is not initialized. Exiting."));
        return;
    }
    //
    //  Release the allocated port bits array.
    //
    RDPDRPRT_LOCK();
    if (PortBitArray != NULL) {
        delete PortBitArray;
#ifdef DBG
        PortBitArray = NULL;
        PortBitArraySizeInBytes = 0;
#endif
    }
    RDPDRPRT_UNLOCK();
}

NTSTATUS RDPDRPRT_RegisterPrinterPortInterface(
    IN PWSTR clientMachineName,    
    IN PCSTR clientPortName,
    IN PUNICODE_STRING clientDevicePath,
    OUT PWSTR portName,
    IN OUT PUNICODE_STRING symbolicLinkName,
    OUT ULONG *portNumber
    )
/*++

Routine Description:

    Register a new client-side port with the spooler via the dynamic port 
    monitor.

Arguments:

    clientMachineName   -   Client computer name for port description.
    clientPortName      -   Client-side port name for port description.
    clientDevicePath    -   Server-side device path for the port.  Reads and
                            writes to this device are reads and writes to the
                            client-side device.
    portName            -   What we end up naming the port.
    symbolicLinkName    -   Symbolic link device name for port being registered.
    portNumber          -   Port number for port being registered.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    WCHAR portDesc[RDPDRPRT_PORTDESCRLENGTH];
    NTSTATUS status;
    UNICODE_STRING unicodeStr;
    HANDLE hInterfaceKey = INVALID_HANDLE_VALUE;
    BOOL symbolicLinkNameAllocated;
    BOOL isPrinterPort = FALSE;
    ULONG portArrayIndex = 0;
    ULONG len = 0;
    PSTR tempName = NULL;

    BEGIN_FN("RDPDRPRT_RegisterPrinterPortInterface");
    TRC_NRM((TB, "Device path %wZ", clientDevicePath));

    if (!RDPDRPRT_Initialized) {
        TRC_ERR((TB, "RDPDRPRT_RegisterPrinterPortInterface:"
                      "RDPDRPRT is not initialized. Exiting."));
        return STATUS_INVALID_DEVICE_STATE;
    }

    //
    // Find if this is a printer port or printer name.
    // First make a copy of the passed in port name
    // and convert to upper case.
    //
    if (clientPortName != NULL) {
        len = strlen(clientPortName);

        tempName = (PSTR)new(NonPagedPool) CHAR[len + 1];

        if (tempName != NULL) {
            PSTR temp = tempName;        
            strcpy(tempName, clientPortName);
        
            while (len--) {
                if (*tempName <= 'z' && *tempName >= 'a') {
                    (*tempName) ^= 0x20;
                    tempName++;
                }
            }
            //
           // Search for the substring ports
          // 
            isPrinterPort = strstr(temp, "LPT") || strstr(temp, "COM");
            //
           // If printer port, we use a specific array index
          //
            if (isPrinterPort) {
                portArrayIndex = PRINTER_PORT_ARRAY_ID;
            }
        
            status = STATUS_SUCCESS;
         }
        else {
            TRC_ERR((TB, "Error allocating %ld bytes for tempName",
                    len+1));
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        status = STATUS_INVALID_PARAMETER;
    }

    //
    //  Allocate a port.
    //
    if (NT_SUCCESS(status)) {
        status = AllocatePrinterPort(portArrayIndex, portName, portNumber, &hInterfaceKey, symbolicLinkName);
        symbolicLinkNameAllocated = (status == STATUS_SUCCESS);
    }

    //
    //  Add the port number to the device interface key.
    //
    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString(&unicodeStr, 
                            PORT_NUM_VALUE_NAME);
        status=ZwSetValueKey(hInterfaceKey, &unicodeStr, 0, REG_DWORD,
                                portNumber, sizeof(ULONG));
        if (!NT_SUCCESS(status)) {
            TRC_ERR((TB, "ZwSetValueKey failed:  08X.", status));
        }
    }

    //
    //  Add the port name base component to the device interface key.
    //  This identifies us as a TS port.
    //
    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString(&unicodeStr, PORT_BASE_VALUE_NAME);
        status=ZwSetValueKey(
                        hInterfaceKey, &unicodeStr, 0, REG_SZ,
                        RDPDRPRT_BASEPORTNAME,
                        sizeof(RDPDRPRT_BASEPORTNAME)
                        );
        if (!NT_SUCCESS(status)) {
            TRC_ERR((TB, "ZwSetValueKey failed with status %08X.", status));
        }
    }

    //
    //  Add the port description string.
    //
    if (NT_SUCCESS(status)) {
        GeneratePortDescription(
                        clientPortName,
                        clientMachineName,
                        portDesc
                        );
        RtlInitUnicodeString(&unicodeStr, PORT_DESCR_VALUE_NAME);
        status=ZwSetValueKey(hInterfaceKey, &unicodeStr, 0, REG_SZ,
                            portDesc,
                            (wcslen(portDesc)+1)*sizeof(WCHAR));
        if (!NT_SUCCESS(status)) {
            TRC_ERR((TB, "ZwSetValueKey failed with status %08X.", status));
        }
    }

    //
    //  Add Port 'Write Size' Field.  This is the size of writes sent by USBMON.DLL.
    //
    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString(&unicodeStr, 
                            PORT_WRITESIZE_VALUE_NAME);
        status=ZwSetValueKey(hInterfaceKey, &unicodeStr, 0, REG_DWORD,
                                &PrintPortWriteSize, sizeof(ULONG));
        if (!NT_SUCCESS(status)) {
            TRC_ERR((TB, "ZwSetValueKey failed:  08X.", status));
        }
    }

    //
    //  Associate the client device path with the device interface so we can
    //  reparse back to the correct client device on IRP_MJ_CREATE.
    //
    if (NT_SUCCESS(status)) {
        RtlInitUnicodeString(&unicodeStr, CLIENT_DEVICE_VALUE_NAME);
        status=ZwSetValueKey(hInterfaceKey, &unicodeStr, 0, REG_SZ,
                            clientDevicePath->Buffer,
                            (wcslen(clientDevicePath->Buffer)+1)*sizeof(WCHAR));
        if (!NT_SUCCESS(status)) {
            TRC_ERR((TB, "ZwSetValueKey failed with status %08X.", status));
        }
    }

    //
    //  Make sure the changes made it to disk in case we have a hard reboot.
    //
    if (NT_SUCCESS(status)) {
        status = ZwFlushKey(hInterfaceKey);
        if (!NT_SUCCESS(status)) {
            TRC_ERR((TB, "ZwFlushKey failed with status %08X.", status));
        }
    }

    //
    //  Enable the interface.
    //
    if (NT_SUCCESS(status)) {
        status=IoSetDeviceInterfaceState(symbolicLinkName, TRUE);
        if (!NT_SUCCESS(status)) {
            TRC_ERR((TB, "IoSetDeviceInterfaceState failed with status %08X.",
                    status));
        }
    }

    // If we failed, then delete the symbolic link name.
    if (!NT_SUCCESS(status) && symbolicLinkNameAllocated)
    {
        RtlFreeUnicodeString(symbolicLinkName);
    }

    if (hInterfaceKey != INVALID_HANDLE_VALUE) {
        ZwClose(hInterfaceKey);
    }

    if (tempName != NULL) {
        delete tempName;
    }
    TRC_NRM((TB, "returning port number %ld.", *portNumber));
    return status;
}

void RDPDRPRT_UnregisterPrinterPortInterface(
    IN ULONG portNumber,                                                
    IN PUNICODE_STRING symbolicLinkName
    )
/*++

Routine Description:

    Unregister a port registered via call to RDPDRPRT_RegisterPrinterPortInterface

Arguments:

    portNumber       - Port number returned by RDPDRPRT_RegisterPrinterPortInterface.
    symbolicLinkName - Symbolic link device name returned by
                       RDPDRPRT_RegisterPrinterPortInterface.

Return Value:

    NA

--*/
{
    ULONG ofs, bit;
#if DBG
    NTSTATUS status;
#endif

    BEGIN_FN("RDPDRPRT_UnregisterPrinterPortInterface");

    if (!RDPDRPRT_Initialized) {
        TRC_ERR((TB, "RDPDRPRT_UnregisterPrinterPortInterface:"
                      "RDPDRPRT is not initialized. Exiting."));
        return;
    }


    TRC_ASSERT(symbolicLinkName != NULL, (TB, "symbolicLinkName != NULL"));
    TRC_ASSERT(symbolicLinkName->Buffer != NULL, 
            (TB, "symbolicLinkName->Buffer != NULL"));

    TRC_NRM((TB, "Disabling port %ld with interface %wZ",
            portNumber, symbolicLinkName));

    //
    //  Change the port description to disabled.
    //
    SetPortDescrToDisabled(symbolicLinkName);        

    //
    //  Disable the device interface, which effectively hides the port from the
    //  port monitor.
    //
#if DBG
    status = IoSetDeviceInterfaceState(symbolicLinkName, FALSE);
    if (status != STATUS_SUCCESS) {
        TRC_NRM((TB, "IoSetDeviceInterfaceState returned error %08X",
                status));
    }
#else
    IoSetDeviceInterfaceState(symbolicLinkName, FALSE);
#endif

    //
    //  Release the symbolic link name.
    //
    RtlFreeUnicodeString(symbolicLinkName);

    //
    //  Indicate that the port is no longer in use in the port bit array.
    //
    RDPDRPRT_LOCK();
    ofs = portNumber / BITSINULONG;
    bit = portNumber % BITSINULONG;
    PortBitArray[ofs] &= ~(1<<bit);
    RDPDRPRT_UNLOCK();

}

NTSTATUS
FindNextFreePortInPortArray(
    IN ULONG lastPortChecked,
    OUT ULONG *nextFreePort
    )
/*++

Routine Description:

    Finds the next free port, following the last port checked, in the port bit 
    array.  The status of the port is changed to "in use" prior to this function
    returning.

Arguments:

    lastPortChecked  -   Last port number checked.  Should be 0 if first time 
                         called.
    nextFreePort     -   Next free port number.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG currentPort;    
    NTSTATUS status = STATUS_SUCCESS;
    ULONG ofs, bit;
    ULONG currentArraySize;

    BEGIN_FN("FindNextFreePortInPortArray");

    //
    //  Find the offset of the long word for the port into the port array
    //  and the offset for the bit into the long word.
    //
    ofs = (lastPortChecked+1) / BITSINULONG;
    bit = (lastPortChecked+1) % BITSINULONG;
    //
    // If we re-entered this function (because from Dynamon's perspective, the port is not available),
    // it is possible that the lastPortChecked was at the array boundary (ex: 31, 63, 95, 127, ...etc).
    // In this case, the offset will mess up the array separation.
    // So, we need to adjust the offset to the next higher one 
    // to keep the printer queue array and the printer port arrays separately.
    //
    if (bit == 0) {
        ofs += 1;
    }

    RDPDRPRT_LOCK();
    
    //
    //  If we need to size the port array. 
    //  Note : We have two arrays - one for the printer ports and one for printer queues
    //  This is to avoid a race condition between creating a printer queue and listening on the printer port
    //
    currentArraySize = PortBitArraySizeInBytes/sizeof(ULONG);
    if (ofs >= (currentArraySize)) {
        status = IncreasePortBitArraySize();
        if (status == STATUS_SUCCESS) {
            currentArraySize = PortBitArraySizeInBytes/sizeof(ULONG);
        }
        else {
            RDPDRPRT_UNLOCK();
            return status;
        }
    }

    //
    //  Find the next free bit.
    //
    while (1) {
        //
        //  If the current port is already allocated..
        //
        if (PortBitArray[ofs] & (1<<bit)) {
            //
            //  Next bit.
            //
            bit += 1;
            if (bit >= BITSINULONG) {
                bit = 0;
                ofs += 2;
            }

            //
            //  See if we need to size the port bit array.
            //
            if (ofs >= (currentArraySize)) {
                status = IncreasePortBitArraySize();
                if (status == STATUS_SUCCESS) {
                    currentArraySize = PortBitArraySizeInBytes/sizeof(ULONG);
                }
                else {
                    break;
                }
            }
        }
        else {
            //
            //  Mark the port used.
            //
            PortBitArray[ofs] |= (1<<bit);

            //
            //  Return the free port.
            //
            *nextFreePort = (ofs * BITSINULONG) + bit;
            TRC_NRM((TB, "next free port is %ld", *nextFreePort));
            break;
        }
    }

    RDPDRPRT_UNLOCK();

    TRC_NRM((TB, "return status %08X", status));

    return status;
}

NTSTATUS
IncreasePortBitArraySize(
    )
/*++

Routine Description:

    Increase the size of the port bit array to hold at least one new
    port.

Arguments:

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS status;
    ULONG newPortBitArraySize;
    ULONG *newPortBitArray;

    BEGIN_FN("IncreasePortBitArraySize");
    
    TRC_ASSERT(RDPDRPRT_INITIALPORTCOUNT != 0, (TB, "invalid port count."));

    newPortBitArraySize = PortBitArraySizeInBytes + 
                            ((RDPDRPRT_INITIALPORTCOUNT / BITSINULONG) 
                             * sizeof(ULONG));
    if (RDPDRPRT_INITIALPORTCOUNT % BITSINULONG) {
        newPortBitArraySize += sizeof(ULONG);
    }

    //
    //  Allocate the new port bit array.
    //
    newPortBitArray = (ULONG *)new(NonPagedPool) BYTE[newPortBitArraySize];
    if (newPortBitArray != NULL) {
        RtlZeroMemory(newPortBitArray, newPortBitArraySize);
        RtlCopyBytes(newPortBitArray, PortBitArray, PortBitArraySizeInBytes);
        delete PortBitArray;
        PortBitArray = newPortBitArray;
        PortBitArraySizeInBytes = newPortBitArraySize;
        status = STATUS_SUCCESS;
    }
    else {
        TRC_ERR((TB, "Error allocating %ld bytes for port array",
                newPortBitArraySize));
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return status;
}

BOOL
PortIsAvailableForUse(
    IN HANDLE  regHandle                     
    )
/*++

Routine Description:

    Return TRUE if the port's device interface is usable, from dynamon's
    perspective.
 
Arguments:

    regHandle   -   Registry handle to port's device interface.

Return Value:

    Return TRUE if the port's device interface is usable.

--*/
{
    UNICODE_STRING unicodeStr;
    NTSTATUS s;
    ULONG bytesReturned;
    BOOL usable;
    BYTE basicValueInformation[sizeof(KEY_VALUE_BASIC_INFORMATION) + 256];

    BEGIN_FN("PortIsAvailableForUse");

    //
    //  Make sure that the basicValueInformation buffer is large enough 
    //  to test the existence of the values we are testing for.
    //
    TRC_ASSERT((sizeof(RECYCLABLE_FLAG_VALUE_NAME) < 256) &&
              (sizeof(PORT_NUM_VALUE_NAME) < 256), 
              (TB, "Increase basic value buffer."));

    //
    //  If there is no client device path registry value for the port's 
    //  device interface then the port is brand new and, therefore,
    //  usable.
    //
    RtlInitUnicodeString(&unicodeStr, CLIENT_DEVICE_VALUE_NAME);    
    s = ZwQueryValueKey(
                    regHandle,
                    &unicodeStr,
                    KeyValueBasicInformation,
                    (PVOID)basicValueInformation,
                    sizeof(basicValueInformation),
                    &bytesReturned
                    );
    if (s == STATUS_OBJECT_NAME_NOT_FOUND) {
        usable = TRUE;
    }
    //
    //  Otherwise, see if dynamon set the recyclable flag.
    //
    else {
        RtlInitUnicodeString(&unicodeStr, 
                            RECYCLABLE_FLAG_VALUE_NAME);
        s = ZwQueryValueKey(
                        regHandle,
                        &unicodeStr,
                        KeyValueBasicInformation,
                        (PVOID)basicValueInformation,
                        sizeof(basicValueInformation),
                        &bytesReturned
                        );
        usable = (s == STATUS_SUCCESS);
    }

    if (usable) {
        TRC_NRM((TB, "usable and status %08X.", s));
    }
    else {
        TRC_NRM((TB, "not usable and status %08X.", s));
    }
    return usable;
}

NTSTATUS
AllocatePrinterPort(
    IN ULONG  portArrayIndex,
    OUT PWSTR   portName,
    OUT ULONG   *portNumber,
    OUT HANDLE  *regHandle,
    OUT PUNICODE_STRING symbolicLinkName
    )
/*++    

Routine Description:

    Allocate a port.

Arguments:
    
    portArrayIndex  - Index into the port array
    portName         - String that holds the allocated port name.  There must be 
                       room in this buffer for RDPDR_MAXPORTNAMELEN wide characters.  
                       This includes the terminator.
    regHandle        - Registry handle for the device interface associated with the
                       port.  The calling function should close this handle using
                       ZwClose.
    symbolicLinkName - symbolic link name returned by IoRegisterDeviceInterface for
                       the port's device interface.  The symbolic link name is used
                       for a number of IO API's.  The caller must free this argument
                       when finished via a call to RtlFreeUnicodeString. 

Return Value:

    STATUS_SUCCESS is returned on success.

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    GUID *pPrinterGuid;
    UNICODE_STRING unicodeStr;
    ULONG ofs, bit;
    BOOL done;
    BOOL symbolicLinkNameAllocated = FALSE;

    BEGIN_FN("AllocatePrinterPort");

    //
    //  Find an available port.
    //
    *portNumber = portArrayIndex * BITSINULONG;
    done = FALSE;
    while (!done && (status == STATUS_SUCCESS)) {
        status = FindNextFreePortInPortArray(*portNumber, portNumber);

        //
        //  Generate the port name.
        //
        if (status == STATUS_SUCCESS) {
            if (!GeneratePortName(*portNumber, portName)) {
                status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        //
        //  Register a device interface for the port.  Note that this function
        //  opens an existing interface or creates a new one, depending on whether
        //  the port currently exists.
        //
        if (status == STATUS_SUCCESS) {
            pPrinterGuid = (GUID *)&DYNPRINT_GUID;
            RtlInitUnicodeString(&unicodeStr, portName);
            status=IoRegisterDeviceInterface(RDPDYN_PDO, pPrinterGuid, &unicodeStr,
                                        symbolicLinkName);
        }
        symbolicLinkNameAllocated = (status == STATUS_SUCCESS);

        //
        //  Get the reg key for the device interface.
        //
        if (status == STATUS_SUCCESS) {
            status=IoOpenDeviceInterfaceRegistryKey(symbolicLinkName,
                                                KEY_ALL_ACCESS, regHandle);
        }
        else {
            TRC_NRM((TB, "IoRegisterDeviceInterface failed with %08X", 
                    status));
        }

        //
        //  See if the port is available for use, from dynamon's perspective.
        //
        if (status == STATUS_SUCCESS) {
            done = PortIsAvailableForUse(*regHandle);
        }
        else {
			*regHandle = INVALID_HANDLE_VALUE;
            TRC_NRM((TB, "IoOpenDeviceInterfaceRegistryKey failed with %08X", 
                    status));
        }

        //
        //  If this iteration unsuccessfully produced a port.
        //
        if (!done || (status != STATUS_SUCCESS)) {

            //
            //  Release the symbolic link name if it was allocated.
            //

            if (symbolicLinkNameAllocated) {
                RtlFreeUnicodeString(symbolicLinkName);
                symbolicLinkNameAllocated = FALSE;
            }

            //
            //  If it's not available, from dynamon's perspective, then we need to 
            //  set it to free in our list so it can be checked later on.  This operation 
            //  needs to be locked in case the port bit array is being reallocated.
            //
            RDPDRPRT_LOCK();
            ofs = (*portNumber) / BITSINULONG;
            bit = (*portNumber) % BITSINULONG;
            PortBitArray[ofs] &= ~(1<<bit);
            RDPDRPRT_UNLOCK();

			//
			//	Clean up the open registry handle.
			//
			if (*regHandle != INVALID_HANDLE_VALUE) {
				ZwClose(*regHandle);
				*regHandle = INVALID_HANDLE_VALUE;
			}
        }
    }

    //
    //  Clean up.
    //
    if ((status != STATUS_SUCCESS) && symbolicLinkNameAllocated) {
        RtlFreeUnicodeString(symbolicLinkName);
    }

    return status;
}

BOOL
GeneratePortName(
    IN ULONG portNumber,
    OUT PWSTR portName
    )
/*++

Routine Description:

    Generate a port name from a port number.

Arguments:

    portNumber  -   port number component of port name.
    portName    -   the generated port name is formed from the RDPDRPRT_BASEPORTNAME
                    component and the portNumber component.  portName is a string
                    that holds the generated port name.  There must be room in this
                    buffer for RDPDR_MAXPORTNAMELEN characters.  This includes
                    the terminator.
Return Value:

    TRUE if a port name could be successfully generated from the port number.
    Otherwise, FALSE.
--*/
{
    ULONG           baseLen;
    UNICODE_STRING  numericUnc;
    OBJECT_ATTRIBUTES   objectAttributes;
    WCHAR           numericBuf[RDPDR_PORTNAMEDIGITS+1];
    ULONG           toPad;
    ULONG           i;
    ULONG           digitsInPortNumber;
    BOOL            done;
    ULONG           tmp;

    BEGIN_FN("GeneratePortName");
    //
    //  Compute the number of digits in the port number.
    //
    for (digitsInPortNumber=1,tmp=portNumber/10; tmp>0; digitsInPortNumber++,tmp/=10);

    //
    //  Make sure we don't exceed the maximum digits allowed in a port name.
    //
    if (digitsInPortNumber > RDPDR_PORTNAMEDIGITS) {
        TRC_ASSERT(FALSE,(TB, "Maximum digits in port exceeded."));
        return FALSE;
    }

    //
    //  Copy the port name base..
    //
    wcscpy(portName, RDPDRPRT_BASEPORTNAME);
    baseLen = (sizeof(RDPDRPRT_BASEPORTNAME)/sizeof(WCHAR))-1;

    //
    //  Convert the port number to a unicode string.
    //
    numericUnc.Length        = 0;
    numericUnc.MaximumLength = (RDPDR_PORTNAMEDIGITS+1) * sizeof(WCHAR);
    numericUnc.Buffer        = numericBuf;
    RtlIntegerToUnicodeString(portNumber, 10, &numericUnc);

    //
    //  If we need to pad the port number.
    //
    if (RDPDR_PORTNAMEDIGITSTOPAD > digitsInPortNumber) {
        toPad = RDPDR_PORTNAMEDIGITSTOPAD - digitsInPortNumber;

        //
        //  Pad.
        //
        for (i=0; i<toPad; i++) {
            portName[baseLen+i] = L'0';
        }

        //
        //  Add the rest of the name.
        //
        wcscpy(&portName[baseLen+i], numericBuf);
    }
    else {
        //
        //  Add the rest of the name.
        //
        wcscpy(&portName[baseLen], numericBuf);
    }

    return TRUE;
}

void 
GeneratePortDescription(
    IN PCSTR dosPortName,
    IN PCWSTR clientName,
    IN PWSTR description
    )
/*++

Routine Description:

    Format a port description.

Arguments:

    dosPortName     -   Preferred DOS name for port.
    clientName      -   Client name (computer name).
    description     -   Buffer for formatted port description.  This buffer 
                        must be at least RDPDRPRT_PORTDESCRLENGTH characters
                        wide.

Return Value:

    NA

--*/
{
    BEGIN_FN("GeneratePortDescription");

    swprintf(description, L"%-s:  %S", clientName, dosPortName);
}

NTSTATUS
SetPortDescrToDisabled(
            IN PUNICODE_STRING symbolicLinkName
            )
/*++

Routine Description:
    
    Set the port description string to disabled.

Arguments:

    symbolicLinkName  - Symbolic link name.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise
--*/
{
    HANDLE hInterfaceKey = INVALID_HANDLE_VALUE;
    NTSTATUS status;
    UNICODE_STRING unicodeStr;

    BEGIN_FN("SetPortDescrToDisabled");
    TRC_NRM((TB, "Symbolic link name: %wZ",
            symbolicLinkName));

    //
    //  Get the reg key for our device interface.
    //
    status=IoOpenDeviceInterfaceRegistryKey(
                                    symbolicLinkName,
                                    KEY_ALL_ACCESS,&hInterfaceKey
                                    );
    if (!NT_SUCCESS(status)) {
		hInterfaceKey = INVALID_HANDLE_VALUE;
        TRC_ERR((TB, "IoOpenDeviceInterfaceRegistryKey failed:  %08X.",
            status));
        goto CleanUpAndReturn;
    }

    //
    //  Set the string value.
    //
    RtlInitUnicodeString(&unicodeStr, PORT_DESCR_VALUE_NAME);
    status=ZwSetValueKey(hInterfaceKey, &unicodeStr, 0, REG_SZ,
                        DisabledPortDescription,
                        DisabledPortDescrSize);
    if (!NT_SUCCESS(status)) {
        TRC_ERR((TB, "ZwSetValueKey failed with status %08X.", status));
        goto CleanUpAndReturn;
    }

CleanUpAndReturn:

    if (hInterfaceKey != INVALID_HANDLE_VALUE) {
        ZwClose(hInterfaceKey);
    }

    return status;
}

NTSTATUS 
CleanUpExistingPorts()
/*++

Routine Description:
    
    Clean up ports registered in a previous boot.

Arguments:

Return Value:

    STATUS_SUCCESS if successful.
--*/
{
    NTSTATUS returnStatus;
    NTSTATUS status;
    PWSTR symbolicLinkList=NULL;
    PWSTR symbolicLink;
    ULONG len;
    HANDLE deviceInterfaceKey = INVALID_HANDLE_VALUE;
    UNICODE_STRING unicodeStr;
    ULONG bytesReturned;
    BYTE basicValueInformation[sizeof(KEY_VALUE_BASIC_INFORMATION) + 256];

    BEGIN_FN("CleanUpExistingPorts");

    //
    //  Make sure that the basicValueInformation buffer is large enough 
    //  to test the existence of the values we are testing for.
    //
    TRC_ASSERT((sizeof(RECYCLABLE_FLAG_VALUE_NAME) < 256),
              (TB, "Increase basic value buffer size."));

    //
    //  Fetch all the device interfaces for dynamic printer ports created
    //  by this driver.
    //
    TRC_ASSERT(RDPDYN_PDO != NULL, (TB, "RDPDYN_PDO == NULL"));
    returnStatus = IoGetDeviceInterfaces(
                                &DYNPRINT_GUID, 
                                RDPDYN_PDO,
                                DEVICE_INTERFACE_INCLUDE_NONACTIVE,
                                &symbolicLinkList
                                );

    if (returnStatus == STATUS_SUCCESS) {
        //
        //  Remove the port number value for each interface to indicate that the
        //  port is no longer in use to dynamon.
        //
        symbolicLink = symbolicLinkList;
        len = wcslen(symbolicLink);
        while (len > 0) {

            TRC_NRM((TB, "CleanUpExistingPorts disabling %ws...",
                     symbolicLink));

            //
            //  Open the registry key for the device interface.
            //
            RtlInitUnicodeString(&unicodeStr, symbolicLink);
            status = IoOpenDeviceInterfaceRegistryKey(
                                           &unicodeStr,
                                           KEY_ALL_ACCESS,
                                           &deviceInterfaceKey
                                           );

            //
            //  Make sure the port description has been set to "disabled"
            //
            if (status == STATUS_SUCCESS) {
                RtlInitUnicodeString(&unicodeStr, PORT_DESCR_VALUE_NAME);
                ZwSetValueKey(deviceInterfaceKey, &unicodeStr, 0, REG_SZ,
                             DisabledPortDescription,
                             DisabledPortDescrSize);
            }
            else {
                TRC_ERR((TB, "Unable to open device interface:  %08X",
                    status));

                //  Remember that the open failed.
                deviceInterfaceKey = INVALID_HANDLE_VALUE;
            }

            //
            //  See if the recyclable flag has been set by dynamon.dll.  If it has
            //  been, then the port is deletable.
            //
            if (status == STATUS_SUCCESS) {
                RtlInitUnicodeString(&unicodeStr, 
                                    RECYCLABLE_FLAG_VALUE_NAME);
                status = ZwQueryValueKey(
                                deviceInterfaceKey,
                                &unicodeStr,
                                KeyValueBasicInformation,
                                (PVOID)basicValueInformation,
                                sizeof(basicValueInformation),
                                &bytesReturned
                                );
            }

            //
            //  Delete the port number value if it exists.  Don't care about the
            //  return value because it just means that this port cannot be reused
            //  by us and this is not a critical error.
            //
            if (status == STATUS_SUCCESS) {
                RtlInitUnicodeString(&unicodeStr, PORT_NUM_VALUE_NAME);
                ZwDeleteValueKey(deviceInterfaceKey, &unicodeStr);
            }
            else {
                TRC_ERR((TB, "CleanUpExistingPorts recyclable flag not set"));
            }

            //
            //  Close the registry key.
            //
            if (deviceInterfaceKey != INVALID_HANDLE_VALUE) {
                ZwClose(deviceInterfaceKey);
            }

            //
            //  Move to the next symbolic link in the list.
            //  
            symbolicLink += (len+1);
            len = wcslen(symbolicLink);
        }

        //
        //  Release the symbolic link list.
        //
        if (symbolicLinkList != NULL) {
            ExFreePool(symbolicLinkList);
        }
    }
    else {
        TRC_NRM((TB, "IoGetDeviceInterfaces failed with status %08X",
                returnStatus));
    }

    return returnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\rdpdrprt.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    rdpdrprt.h

Abstract:

    Routines for managing dynamic printer port allocation for the RDP device 
    redirection kernel mode component, rdpdr.sys.

    Port number 0 is reserved and never allocated.

Author:

    tadb

Revision History:
--*/

#pragma once
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//  This is the GUID we use to identify a dynamic printer port to
//  dynamon.
extern const GUID DYNPRINT_GUID;

// Device interface client device registry value name
#define CLIENT_DEVICE_VALUE_NAME    L"Client Device Name"

//  Initialize this module.
NTSTATUS RDPDRPRT_Initialize();

//  Register a new client-side port with the spooler via the dynamic port 
//  monitor.
NTSTATUS RDPDRPRT_RegisterPrinterPortInterface(
    IN PWSTR clientMachineName,    
    IN PCSTR clientPortName,
    IN PUNICODE_STRING clientDevicePath,
    OUT PWSTR portName,
    IN OUT PUNICODE_STRING symbolicLinkName,
    OUT ULONG *portNumber
    );

// Unregister a port registered via call to RDPDRPRT_RegisterPrinterPortInterface.
void RDPDRPRT_UnregisterPrinterPortInterface(
    IN ULONG portNumber,                                                
    IN PUNICODE_STRING symbolicLinkName
    );

//  Shut down this module.
void RDPDRPRT_Shutdown();

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\rdpdr.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    rdpdr.cpp

Abstract:

    This module implements the driver initialization for the RDP redirector,
    and the dispatch routines for the master device object. The master
    device object mostly ignores real I/O operations

Environment:

    Kernel mode

--*/
#include "precomp.hxx"
#define TRC_FILE "rdpdr"
#include "trc.h"
#include "ntddmup.h"
#include "TSQPublic.h"

HANDLE DrSystemProcessId;
PSECURITY_DESCRIPTOR DrAdminSecurityDescriptor = NULL;
ULONG DrSecurityDescriptorLength = 0;
extern ULONG DebugBreakOnEntry;

//
//  Default USBMON Port Write Size.  Need to keep it under 64k for 
//  16-bit clients ... otherwise, the go off the end of a segment.
//
ULONG PrintPortWriteSize;
ULONG PrintPortWriteSizeDefault = 63000; // bytes
//
// Maximum numer of TS worker threads
//
#define MAX_WORKER_THREADS_COUNT     5
ULONG MaxWorkerThreadsDefault = MAX_WORKER_THREADS_COUNT;
ULONG MaxWorkerThreads = MAX_WORKER_THREADS_COUNT;

// The TS Worker Queue pointer
PVOID RDPDR_TsQueue = NULL;


//
//  Configure Devices to send IO packets to client at low priority.
//
ULONG DeviceLowPrioSendFlags;   
ULONG DeviceLowPrioSendFlagsDefault = DEVICE_LOWPRIOSEND_PRINTERS;

extern "C" BOOLEAN RxForceQFIPassThrough;

NTSTATUS DrCreateSCardDevice(SmartPtr<DrSession> &Session, PV_NET_ROOT pVNetRoot,
               SmartPtr<DrDevice> &Device);

//
//  This is the minirdr dispatch table. It is initialized by DrInitializeTables.
//  This table will be used by the wrapper to call into this minirdr
//

struct _MINIRDR_DISPATCH  DrDispatch;

#if DBG
UCHAR IrpNames[IRP_MJ_MAXIMUM_FUNCTION + 1][40] = {
    "IRP_MJ_CREATE                  ",
    "IRP_MJ_CREATE_NAMED_PIPE       ",
    "IRP_MJ_CLOSE                   ",
    "IRP_MJ_READ                    ",
    "IRP_MJ_WRITE                   ",
    "IRP_MJ_QUERY_INFORMATION       ",
    "IRP_MJ_SET_INFORMATION         ",
    "IRP_MJ_QUERY_EA                ",
    "IRP_MJ_SET_EA                  ",
    "IRP_MJ_FLUSH_BUFFERS           ",
    "IRP_MJ_QUERY_VOLUME_INFORMATION",
    "IRP_MJ_SET_VOLUME_INFORMATION  ",
    "IRP_MJ_DIRECTORY_CONTROL       ",
    "IRP_MJ_FILE_SYSTEM_CONTROL     ",
    "IRP_MJ_DEVICE_CONTROL          ",
    "IRP_MJ_INTERNAL_DEVICE_CONTROL ",
    "IRP_MJ_SHUTDOWN                ",
    "IRP_MJ_LOCK_CONTROL            ",
    "IRP_MJ_CLEANUP                 ",
    "IRP_MJ_CREATE_MAILSLOT         ",
    "IRP_MJ_QUERY_SECURITY          ",
    "IRP_MJ_SET_SECURITY            ",
    "IRP_MJ_POWER                   ",
    "IRP_MJ_SYSTEM_CONTROL          ",
    "IRP_MJ_DEVICE_CHANGE           ",
    "IRP_MJ_QUERY_QUOTA             ",
    "IRP_MJ_SET_QUOTA               ",
    "IRP_MJ_PNP                     "
};
#endif // DBG

//
// Pointer to the device Object for this minirdr. Since the device object is created
// by the wrapper when this minirdr registers, this pointer is initialized in the
// DriverEntry routine below (see RxRegisterMinirdr)
//

PRDBSS_DEVICE_OBJECT      DrDeviceObject = NULL;
PRDBSS_DEVICE_OBJECT      DrPortDeviceObject = NULL;
DrSessionManager *Sessions = NULL;

//
// A global spinlock
//
KSPIN_LOCK DrSpinLock;
KIRQL DrOldIrql;

//
// A global mutex
//
FAST_MUTEX DrMutex;

//
//  Global Registry Path for RDPDR.SYS
//
UNICODE_STRING            DrRegistryPath;

//
// The following enumerated values signify the current state of the minirdr
// initialization. With the aid of this state information, it is possible
// to determine which resources to deallocate, whether deallocation comes
// as a result of a normal stop/unload, or as the result of an exception
//

typedef enum tagDrInitStates {
    DrUninitialized,
    DrRegistered,
    DrInitialized
} DrInitStates;

//
// function prototypes
//

extern "C" {
NTSTATUS
DrInitializeTables(
    void
    );
NTSTATUS
CreateAdminSecurityDescriptor(
    VOID
    );
    
NTSTATUS
BuildDeviceAcl(
    OUT PACL *DeviceAcl
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
DrPeekDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
DrUninitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN DrInitStates DrInitState
    );

NTSTATUS
DrLoadRegistrySettings (
    IN PCWSTR   RegistryPath
    );

NTSTATUS
DrStart(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
DrStop(
    PRX_CONTEXT RxContext,
    IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject
    );

NTSTATUS
DrDeallocateForFcb(
    IN OUT PMRX_FCB pFcb
    );

NTSTATUS
ObGetObjectSecurity(
    IN PVOID Object,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor,
    OUT PBOOLEAN MemoryAllocated
    );

VOID
ObReleaseObjectSecurity(
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN BOOLEAN MemoryAllocated
    );

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

};

BOOL GetDeviceFromRxContext(PRX_CONTEXT RxContext, SmartPtr<DrDevice> &Device);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#endif

WCHAR DrDriverName[] = RDPDR_DEVICE_NAME_U;
WCHAR DrPortDriverName[] = RDPDR_PORT_DEVICE_NAME_U;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This is the initialization routine for the RDP mini redirector

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    RXSTATUS - The function value is the final status from the initialization
        operation.

--*/
{
    NTSTATUS       Status;
    UNICODE_STRING RdpDrName;
    UNICODE_STRING RdpDrPortName;
    PDEVICE_OBJECT  RdpDrDevice;
    DrInitStates DrInitState = DrUninitialized;
    PRX_CONTEXT RxContext;
    PWCHAR  path;

    BEGIN_FN("DriverEntry");

#ifdef MONOLITHIC_MINIRDR
    Status =  RxDriverEntry(DriverObject, RegistryPath);
    TRC_NRM((TB, "BackFromInitWrapper %08lx", Status));
    if (!NT_SUCCESS(Status)) {
        TRC_ERR((TB, "Wrapper failed to initialize. " 
                "Status = %08lx", Status));

        DbgPrint("rdpdr.sys erroring out (#1)\n");
        DbgBreakPoint();

        return Status;
    }
#endif

    //
    //  Copy the registry path for RDPDR.SYS.
    //
    path = (PWCHAR)new(NonPagedPool) WCHAR[RegistryPath->Length + 1];
    if (!path) {
        TRC_ERR((TB, "DR:Failed to allocate registry path %Wz",
                RegistryPath));

        DbgPrint("rdpdr.sys erroring out (#2)\n");
        DbgBreakPoint();

        Status = STATUS_INSUFFICIENT_RESOURCES;
        return (Status);
    }
    RtlZeroMemory(path, RegistryPath->Length+sizeof(WCHAR));
    RtlMoveMemory(path, RegistryPath->Buffer, RegistryPath->Length);
    DrRegistryPath.Length           = RegistryPath->Length;
    DrRegistryPath.MaximumLength    = RegistryPath->Length+sizeof(WCHAR);
    DrRegistryPath.Buffer           = path;

    //
    //  Load registry settings.
    //
    DrLoadRegistrySettings(path);

#if DBG
    if (DebugBreakOnEntry) {
        DbgBreakPoint();
    }
#endif 


    CodePageConversionInitialize();

    // Initialize the client list
    KeInitializeSpinLock(&DrSpinLock);

    // Initialize the mutex object for device I/O transaction exchange
    ExInitializeFastMutex(&DrMutex);

    if (InitializeKernelUtilities()) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;

        DbgPrint("rdpdr.sys erroring out (#3)\n");
        DbgBreakPoint();
    }

    if (NT_SUCCESS(Status)) {
        Sessions = new(NonPagedPool) DrSessionManager;

        if (Sessions != NULL) {
            Status = STATUS_SUCCESS;
            TRC_NRM((TB, "Created DrSessionManager"));
        } else {
            TRC_ERR((TB, "Unable to create DrSessionManager"));
            Status = STATUS_INSUFFICIENT_RESOURCES;

            DbgPrint("rdpdr.sys erroring out (#4)\n");
            DbgBreakPoint();
        }
    }

    if (NT_SUCCESS(Status)) {
        RtlInitUnicodeString(&RdpDrPortName, DrPortDriverName);

        // Create the port device object.
        Status = IoCreateDevice(DriverObject,
                    0,
                    &RdpDrPortName,
                    FILE_DEVICE_NETWORK_REDIRECTOR,
                    0,
                    FALSE,
                    (PDEVICE_OBJECT *)(&DrPortDeviceObject));
    }
    else {
        TRC_ERR((TB, "IoCreateDevice failed: %08lx", Status ));

        DbgPrint("rdpdr.sys erroring out (#5)\n");
        DbgBreakPoint();

        return Status;
    }

    if (NT_SUCCESS(Status)) {
        //
        //  Register the RdpDr with the connection engine. Registration 
        //  makes the connection engine aware of the device name, driver 
        //  object, and other characteristics. If registration is successful, 
        //  a new device object is returned
        //
        //  The name of the device is L"\\Device\\RdpDr"
        //
                                       
        RtlInitUnicodeString(&RdpDrName, DrDriverName);
        
        TRC_DBG((TB, "Registering minirdr"));

        Status = RxRegisterMinirdr(
                     &DrDeviceObject,   // where the new device object goes
                     DriverObject,      // the Driver Object to register
                     &DrDispatch,       // the dispatch table for this driver
                     RX_REGISTERMINI_FLAG_DONT_PROVIDE_MAILSLOTS,
                     &RdpDrName,        // the device name for this minirdr
                     0,                 // IN ULONG DeviceExtensionSize,
                     FILE_DEVICE_NETWORK_FILE_SYSTEM, // In DEVICE_TYPE DeviceType
                     0                  // IN ULONG DeviceCharacteristics
                     );        
    }
    
    if (NT_SUCCESS(Status)) {
        PSECURITY_DESCRIPTOR RdpDrSD = NULL;
        BOOLEAN memoryAllocated = FALSE;
        
        TRC_NRM((TB, "RxRegisterMinirdr succeeded."));
        //
        // Get the SD for the rdpdr device object.
        // Apply the same SD to the rdp port device object.
        //
        if (NT_SUCCESS(ObGetObjectSecurity(DrDeviceObject, 
                       &RdpDrSD, 
                       &memoryAllocated))) {
            if (!NT_SUCCESS(ObSetSecurityObjectByPointer((PDEVICE_OBJECT)DrPortDeviceObject, 
                                                          DACL_SECURITY_INFORMATION, 
                                                          RdpDrSD
                                                         ))) {
                //
                // We will ignore the error.
                //
                TRC_ERR((TB, "ObSetSecurityObjectByPointer failed: 0x%08lx", Status ));
            }
            ObReleaseObjectSecurity(RdpDrSD, memoryAllocated);
        }
        else {
            //
            // We will ignore the error. Just log the error
            //
            TRC_ERR((TB, "ObGetObjectSecurity failed: 0x%08lx", Status ));
        }

        //
        // After this we can't just return, some uninitialization is 
        // needed if we fail or unload
        //

        DrInitState = DrRegistered;

        Status = CreateAdminSecurityDescriptor();
    } else {
        TRC_ERR((TB, "RxRegisterMinirdr failed: %08lx", Status ));

        DbgPrint("rdpdr.sys erroring out (#6)\n");
        DbgBreakPoint();

        if (DrPortDeviceObject) {
            IoDeleteDevice((PDEVICE_OBJECT) DrPortDeviceObject);
            DrPortDeviceObject = NULL;
        }

        return Status;
    }

    if (NT_SUCCESS(Status)) {
        //
        // Build the dispatch tables for the minirdr
        //

        Status = DrInitializeTables();

    } else {
        TRC_ERR((TB, "CreateAdminSecurityDescriptor failed: 0x%08lx", Status ));

        DbgPrint("rdpdr.sys erroring out (#7)\n");
        DbgBreakPoint();
    }
    //
    // Initialize our TS worker queue module.
    //
    TRC_NRM((TB, "RDPDR: Initialize TS Worker Queue"));
    RDPDR_TsQueue = TSInitQueue( TSQUEUE_OWN_THREAD, 
                                 MaxWorkerThreads, 
                                 (PDEVICE_OBJECT)DrDeviceObject );

    if ( RDPDR_TsQueue == NULL) {
        TRC_ERR((TB, "RDPDR: Failed to initialize the TS Queue"));
        DbgPrint("rdpdr.sys erroring out (#8)\n");
        Status = STATUS_INSUFFICIENT_RESOURCES;
    } 


    if (NT_SUCCESS(Status)) {
        //
        //  Setup Unload Routine
        //

        DriverObject->DriverUnload = DrUnload;

        //
        //  Set up the PnP AddDevice entry point.
        //

        DriverObject->DriverExtension->AddDevice = RDPDRPNP_PnPAddDevice;

        //
        // setup the DriverDispatch for people who come in here directly
        // ....like the browser
        //

        {
            ULONG i;

            for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
            {
                DriverObject->MajorFunction[i] = (PDRIVER_DISPATCH)DrPeekDispatch;
            }
        }
        DrSystemProcessId = PsGetCurrentProcessId();
    } else {

        DbgPrint("rdpdr.sys erroring out (#9)\n");
        DbgBreakPoint();

        DrUninitialize(DriverObject, DrInitState);
    }

    return Status;
}

VOID
DrUninitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN DrInitStates DrInitState
    )
/*++

Routine Description:

     This routine does the common uninit work 

Arguments:

     DrInitState - tells how far we got into the intialization

Return Value:

     None

--*/

{
    PRX_CONTEXT RxContext;
    NTSTATUS    Status;

    BEGIN_FN("DrUninitialize");

    PAGED_CODE();
    RxContext = RxCreateRxContext(
                    NULL,
                    DrDeviceObject,
                    RX_CONTEXT_FLAG_IN_FSP);

    if (RxContext != NULL) {
        Status = RxStopMinirdr(
                     RxContext,
                     &RxContext->PostRequest);

        RxDereferenceAndDeleteRxContext(RxContext);
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    CodePageConversionCleanup();

    if (DrAdminSecurityDescriptor) {
        delete DrAdminSecurityDescriptor;
        DrAdminSecurityDescriptor = NULL;
        DrSecurityDescriptorLength = 0;
    }

    if (Sessions != NULL) {
        delete Sessions;
        Sessions = NULL;
    }

    if (DrRegistryPath.Buffer != NULL) {
        delete DrRegistryPath.Buffer;
        DrRegistryPath.Buffer = NULL;
    }

    //
    // Delete the TS Queue
    //
    if ( RDPDR_TsQueue != NULL) {
        if (TSDeleteQueue( RDPDR_TsQueue ) != STATUS_SUCCESS) {
            TRC_ERR((TB, "RDPDR: TsDeleteQueue Failed"));
        }
    }


    UninitializeKernelUtilities();

    switch (DrInitState) {
    case DrInitialized:

#ifdef MONOLITHIC_MINIRDR
    RxUnload(DriverObject);
#endif

    case DrRegistered:
        RxUnregisterMinirdr(DrDeviceObject);
    }

    if (DrPortDeviceObject) {
        IoDeleteDevice((PDEVICE_OBJECT) DrPortDeviceObject);
        DrPortDeviceObject = NULL;
    }
}

VOID
DrUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This is the dispatch routine for Unload.

Arguments:

    DriverObject - Pointer to the driver object controling all of the
                   devices.

Return Value:

    None.

--*/

{
    BEGIN_FN("DrUnload");
    PAGED_CODE();
    TRC_NRM((TB, "DriverObject =%p", DriverObject));

    DrUninitialize(DriverObject, DrInitialized);


    TRC_NRM((TB, "MRxIfsUnload exit: DriverObject =%p", 
            DriverObject));
}

NTSTATUS
DrFlush(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for flush operations.

Arguments:

    RxContext - RDBSS context structure for our mini-redir

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    BEGIN_FN("DrFlush");
    return STATUS_SUCCESS;
}

NTSTATUS
DrWrite(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for write operations.

Arguments:

    RxContext - RDBSS context structure for our mini-redir

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    SmartPtr<DrDevice> Device;

    BEGIN_FN("DrWrite");
    
    TRC_NRM((TB, "DrWrite"));

    GetDeviceFromRxContext(RxContext, Device);

    return Device->Write(RxContext);
}

NTSTATUS
DrRead(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for read operations.

Arguments:

    RxContext - RDBSS context structure for our mini-redir

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    SmartPtr<DrDevice> Device;

    BEGIN_FN("DrRead");
    
    TRC_NRM((TB, "DrRead"));

    GetDeviceFromRxContext(RxContext, Device);

    return Device->Read(RxContext);
}

NTSTATUS
DrIoControl(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for IoControl operations.

Arguments:

    RxContext - RDBSS context structure for our mini-redir

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    SmartPtr<DrDevice> Device;

    BEGIN_FN("DrIoControl");
    
    TRC_NRM((TB, "DrIoControl"));

    if (GetDeviceFromRxContext(RxContext, Device))
        return Device->IoControl(RxContext);
    else
        return STATUS_UNSUCCESSFUL;
}

NTSTATUS
DrShouldTryToCollapseThisOpen(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine determines if the mini knows of a good reason not
   to try collapsing on this open. 

Arguments:

    RxContext - Context for the operation

Return Value:

    NTSTATUS - The return status for the operation
        SUCCESS --> okay to try collapse
        other (MORE_PROCESSING_REQUIRED) --> dont collapse

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;

    BEGIN_FN("DrShouldTryToCollapseThisOpen");

    PAGED_CODE();

    TRC_NRM((TB, "DrShouldTryToCollapseThisOpen not implemented"));
    return STATUS_NOT_IMPLEMENTED;
}

ULONG
DrExtendForNonCache(
    IN OUT struct _RX_CONTEXT * RxContext,
    IN     PLARGE_INTEGER   pNewFileSize,
       OUT PLARGE_INTEGER   pNewAllocationSize
    )
/*++

Routine Description:

   This routine handles network requests to extend the file for noncached IO. since the write
   itself will extend the file, we can pretty much just get out quickly.

Arguments:

    RxContext - the RDBSS context

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    
    pNewAllocationSize->QuadPart = pNewFileSize->QuadPart;

    return (ULONG)Status;
}

NTSTATUS
DrTruncate(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

   This routine determines Truncate operation 

Arguments:

    RxContext - Context for the operation

Return Value:

    NTSTATUS - The return status for the operation        

--*/
{
    BEGIN_FN("DrTruncate");

    TRC_ERR((TB, "DrTruncate not implemented"));
    return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS DrCreate(IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

    Opens a file (or device) across the network

Arguments:

    RxContext - Context for the operation

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    NTSTATUS Status;
    RxCaptureFcb;
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = RxContext->Create.pNetRoot;
    PMRX_V_NET_ROOT VNetRoot = RxContext->Create.pVNetRoot;
    SmartPtr<DrSession> Session;
    DrDevice *pDevice;
    SmartPtr<DrDevice> Device, DeviceNew;

    BEGIN_FN("DrCreate");

    TRC_NRM((TB, "DrCreate"));

    //
    // Make sure the device is still enabled, Protect the
    // VNetRoot Context (the DeviceEntry) with the device list 
    // SpinLock because we may change it
    //
    
    DrAcquireSpinLock();
    Device = (DrDevice *)VNetRoot->Context;
    ASSERT(Device != NULL);
    DrReleaseSpinLock();

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //
    Session = Device->GetSession();

    ASSERT(Session != NULL);

    if (!Session->IsConnected() && (Device->GetDeviceType() != RDPDR_DTYP_SMARTCARD)) {
        TRC_ALT((TB, "Tried to open client device while not "
            "connected. State: %ld", Session->GetState()));
        return STATUS_DEVICE_NOT_CONNECTED;
    }
    
    //
    // We leave the SpinLock after we get our reference to the device. It could
    // change while we're gone, but since everything is reference counted it
    // is safe to put the correct pointer in later
    //

    if (!Device->IsAvailable()) {
        TRC_ALT((TB, "Tried to open client device which is not "
            "available. "));
    
        if (Device->GetDeviceType() == RDPDR_DTYP_SMARTCARD &&
                !Session->FindDeviceByDosName((UCHAR *)DR_SMARTCARD_SUBSYSTEM, 
                                              DeviceNew, TRUE)) {
            Status = DrCreateSCardDevice(Session, NULL, DeviceNew);

            if (Status != STATUS_SUCCESS) {
                return STATUS_DEVICE_NOT_CONNECTED;
            }            
        }

        if (Device->GetDeviceType() == RDPDR_DTYP_SMARTCARD ||
                Session->FindDeviceById(Device->GetDeviceId(), DeviceNew, TRUE)) {

            //
            // There's a new DeviceEntry for this device. Replace the old
            // one in the VNetRoot with this one. We also need an extra 
            // reference to stick in the fobx so we can track whether
            // this particular open is using an old DeviceEntry or a new
            // one
            //

            // Put it in the netroot, safely swapping in and manually
            // bumping the reference count up going in and down going out

            DeviceNew->AddRef();
            DrAcquireSpinLock();

            pDevice = (DrDevice *)VNetRoot->Context;
            VNetRoot->Context = (DrDevice *)DeviceNew;
            DrReleaseSpinLock();

#if DBG
            pDevice->_VNetRoot = NULL;
#endif

            pDevice->Release();
            pDevice = NULL;
            Device = DeviceNew;
        } else {

            //
            // The device is disabled, but we didn't find a shiny new
            // version with which to replace it. Leave the icky old disabled
            // one there so we know what to look for later, and return the
            // device not connected error.
            // 

            return STATUS_DEVICE_NOT_CONNECTED;
        }
    }

    return Device->Create(RxContext);
}

BOOL GetDeviceFromRxContext(PRX_CONTEXT RxContext, SmartPtr<DrDevice> &Device)
{
    BOOL rc = FALSE;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_V_NET_ROOT VNetRoot;
     
    BEGIN_FN("GetDeviceFromRxContext");
    if (SrvOpen == NULL) {
        goto Exit;
    }
    VNetRoot= SrvOpen->pVNetRoot;
    if (VNetRoot == NULL) {
        goto Exit;
    }

    DrAcquireSpinLock();
    Device = (DrDevice *)VNetRoot->Context;
    DrReleaseSpinLock();
    ASSERT(Device != NULL);

    rc = TRUE;
Exit:
    return rc;
}

NTSTATUS DrCloseSrvOpen(IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

    This is the dispatch routine for close operations.

Arguments:

    RxContext - RDBSS context structure for our mini-redir

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    SmartPtr<DrDevice> Device;

    BEGIN_FN("DrCloseSrvOpen");
    
    TRC_NRM((TB, "DrCloseSrvOpen"));

    GetDeviceFromRxContext(RxContext, Device);

    return Device->Close(RxContext);
}

NTSTATUS DrCleanupFobx(IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

    This is the dispatch routine for cleaning up Fobx.

Arguments:

    RxContext - RDBSS context structure for our mini-redir

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    RxCaptureFobx;
    
    BEGIN_FN("DrCleanupFobx");
    
    TRC_NRM((TB, "DrCleanupFobx"));
    
    return STATUS_SUCCESS;
}

NTSTATUS DrCleanup(IN OUT PRX_CONTEXT RxContext)
/*++

Routine Description:

    This is the dispatch routine for cleanup operations.

Arguments:

    RxContext - RDBSS context structure for our mini-redir

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    SmartPtr<DrDevice> Device;

    BEGIN_FN("DrCleanup");
    
    TRC_NRM((TB, "DrCleanup"));

    GetDeviceFromRxContext(RxContext, Device);

    return Device->Cleanup(RxContext);
}


NTSTATUS
DrQueryDirectory(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for Query Direcotry information.

Arguments:

    RxContext - RDBSS context structure for our mini-redir

Return Value:

    Could return status success, cancelled, or pending.

--*/

{   
    SmartPtr<DrDevice> Device;

    BEGIN_FN("DrQueryDirecotry");

    TRC_NRM((TB, "DrQueryDirectory"));

    GetDeviceFromRxContext(RxContext, Device);

    return Device->QueryDirectory(RxContext);
}


NTSTATUS
DrQueryVolumeInfo(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for Query Volume Information.

Arguments:

    RxContext - RDBSS context structure for our mini-redir
                                              
Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    SmartPtr<DrDevice> Device;
    
    BEGIN_FN("DrQueryVolumeInfo");
    
    TRC_NRM((TB, "DrQueryVolumeInfo"));

    GetDeviceFromRxContext(RxContext, Device);

    return Device->QueryVolumeInfo(RxContext);
}

NTSTATUS
DrSetVolumeInfo(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for Set Volume Information.

Arguments:

    RxContext - RDBSS context structure for our mini-redir

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    SmartPtr<DrDevice> Device;
    
    BEGIN_FN("DrSetVolumeInfo");
    
    TRC_NRM((TB, "DrSetVolumeInfo"));

    GetDeviceFromRxContext(RxContext, Device);

    return Device->SetVolumeInfo(RxContext);
}

NTSTATUS
DrQuerySdInfo(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for Query Security Information.

Arguments:

    RxContext - RDBSS context structure for our mini-redir

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    SmartPtr<DrDevice> Device;

    BEGIN_FN("DrQuerySdInfo");
    
    TRC_NRM((TB, "DrQuerySdInfo"));

    GetDeviceFromRxContext(RxContext, Device);

    return Device->QuerySdInfo(RxContext);
}

NTSTATUS
DrSetSdInfo(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for Set Security Information.

Arguments:

    RxContext - RDBSS context structure for our mini-redir
                                            
Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    SmartPtr<DrDevice> Device;

    BEGIN_FN("DrSetSdInfo");
    
    TRC_NRM((TB, "DrSetSdInfo"));

    GetDeviceFromRxContext(RxContext, Device);

    return Device->SetSdInfo(RxContext);
}


NTSTATUS
DrQueryFileInfo(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for Query File Information.

Arguments:

    RxContext - RDBSS context structure for our mini-redir
                                           
Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    SmartPtr<DrDevice> Device;

    BEGIN_FN("DrQueryFileInfo");
    
    TRC_NRM((TB, "DrQueryFileInfo"));

    GetDeviceFromRxContext(RxContext, Device);

    return Device->QueryFileInfo(RxContext);
}

NTSTATUS
DrSetFileInfo(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for SetFileInformation.

Arguments:

    RxContext - RDBSS context structure for our mini-redir

Return Value:

    Could return status success, cancelled, or pending.

--*/

{    
    SmartPtr<DrDevice> Device;
    
    BEGIN_FN("DrSetFileInfo");

    TRC_NRM((TB, "DrSetFileInfo"));
    
    GetDeviceFromRxContext(RxContext, Device);

    return Device->SetFileInfo(RxContext);
}

NTSTATUS
DrSetFileInfoAtCleanUp(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for SetFileInformationAtCleanUp.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP for the current request

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    BEGIN_FN("DrSetFileInfoAtCleanUp");
    
    TRC_NRM((TB, "DrSetFileInfoAtCleanUp"));

    return STATUS_SUCCESS;
}

NTSTATUS
DrLocks(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for file locking.

Arguments:

    RxContext - RDBSS context structure for our mini-redir

Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    SmartPtr<DrDevice> Device;

    BEGIN_FN("DrLocks");
    
    TRC_NRM((TB, "DrLocks"));

    GetDeviceFromRxContext(RxContext, Device);

    return Device->Locks(RxContext);
}

NTSTATUS
DrIsLockRealizable(
    IN OUT PMRX_FCB pFcb,
    IN PLARGE_INTEGER  ByteOffset,
    IN PLARGE_INTEGER  Length,
    IN ULONG  LowIoLockFlags
    )
/*++

Routine Description:

    This is the dispatch routine for IsLockRealizable.

Arguments:

Return Value:

    Could return status success, cancelled, or pending.

--*/

{

    BEGIN_FN("DrIsLockRealizable");
    
    TRC_NRM((TB, "DrIsLockRealizable"));

    //
    //  TODO: We do not support share locks for win9x clients
    //  Can we just return success here and then fail on the 
    //  client share lock function?
    //  
#if 0
    if (!FlagOn(LowIoLockFlags,LOWIO_LOCKSFLAG_EXCLUSIVELOCK)) {
        return STATUS_NOT_SUPPORTED;
    }
#endif

    return STATUS_SUCCESS;
}

NTSTATUS
DrIsValidDirectory(
    IN OUT PRX_CONTEXT    RxContext,
    IN PUNICODE_STRING    DirectoryName
    )
/*++

Routine Description:

    This is the dispatch routine for IsValidDirectory.

Arguments:

    RxContext - RDBSS context structure for our mini-redir
    DirectoryName - name of directory to verify its validity
    
Return Value:

    Could return status success, cancelled, or pending.

--*/

{

    BEGIN_FN("DrIsValidDirectory");
    
    TRC_NRM((TB, "DrIsValidDirectory"));

    //
    //  TODO: Always return success for now.  Need to verify later
    //
    return STATUS_SUCCESS;
}


NTSTATUS
DrNotifyChangeDirectory(
    IN OUT PRX_CONTEXT RxContext
    )
/*++

Routine Description:

    This is the dispatch routine for DrNotifyChangeDirectory.

Arguments:

    RxContext - RDBSS context structure for our mini-redir
    
Return Value:

    Could return status success, cancelled, or pending.

--*/

{
    SmartPtr<DrDevice> Device;

    BEGIN_FN("DrNotifyChangeDirectory");
    
    TRC_NRM((TB, "DrNotifyChangeDirectory"));

    GetDeviceFromRxContext(RxContext, Device);

    return Device->NotifyChangeDirectory(RxContext);    
}


NTSTATUS
DrInitializeTables(
          void
    )
/*++

Routine Description:

     This routine sets up the rdp redirector dispatch vector and also calls
     to initialize any other tables needed.

Return Value:

    NTSTATUS - The return status for the operation

--*/
{
    BEGIN_FN("DrInitializeTables");

    //
    // Build the local minirdr dispatch table and initialize
    //

    ZeroAndInitializeNodeType(&DrDispatch, RDBSS_NTC_MINIRDR_DISPATCH, 
            sizeof(MINIRDR_DISPATCH));

    //
    // redirector extension sizes and allocation policies.
    //

    // REVIEW: wtf?
    DrDispatch.MRxFlags = (RDBSS_MANAGE_FCB_EXTENSION |
                               RDBSS_MANAGE_SRV_OPEN_EXTENSION |
                               RDBSS_MANAGE_FOBX_EXTENSION);

    DrDispatch.MRxSrvCallSize  = 0;
    DrDispatch.MRxNetRootSize  = 0;
    DrDispatch.MRxVNetRootSize = 0;
    DrDispatch.MRxFcbSize      = 0; // sizeof(MRX_SMB_FCB);
    DrDispatch.MRxSrvOpenSize  = 0; // sizeof(MRX_SMB_SRV_OPEN);
    DrDispatch.MRxFobxSize     = 0; // sizeof(MRX_SMB_FOBX);

    // Transport update handler

    // REVIEW: How do we indicate we have our own dedicated transport?
    //MRxIfsDispatch.MRxTransportUpdateHandler = MRxIfsTransportUpdateHandler;

    // Mini redirector cancel routine ..

    DrDispatch.MRxCancel = NULL;

    //
    // Mini redirector Start/Stop. Each mini-rdr can be started or stopped
    // while the others continue to operate.
    //

    DrDispatch.MRxStart                = DrStart;
    DrDispatch.MRxStop                 = DrStop;
    DrDispatch.MRxDevFcbXXXControlFile = DrDevFcbXXXControlFile;

    //
    // Mini redirector name resolution.
    //

    DrDispatch.MRxCreateSrvCall       = DrCreateSrvCall;
    DrDispatch.MRxSrvCallWinnerNotify = DrSrvCallWinnerNotify;
    DrDispatch.MRxCreateVNetRoot      = DrCreateVNetRoot;
    DrDispatch.MRxUpdateNetRootState  = DrUpdateNetRootState;
    DrDispatch.MRxExtractNetRootName  = DrExtractNetRootName;
    DrDispatch.MRxFinalizeSrvCall     = DrFinalizeSrvCall;
    DrDispatch.MRxFinalizeNetRoot     = DrFinalizeNetRoot;
    DrDispatch.MRxFinalizeVNetRoot    = DrFinalizeVNetRoot;

    //
    // File System Object Creation/Deletion.
    //

    DrDispatch.MRxCreate            = DrCreate;

    //
    // TODO: Need to implement this for file system redirect caching
    //
    DrDispatch.MRxShouldTryToCollapseThisOpen = DrShouldTryToCollapseThisOpen;
    //DrDispatch.MRxCollapseOpen      = MRxIfsCollapseOpen;
    //DrDispatch.MRxExtendForCache    = MRxIfsExtendFile;
    DrDispatch.MRxExtendForNonCache = DrExtendForNonCache;
    DrDispatch.MRxTruncate          = DrTruncate;   //MRxIfsTruncate;
    
    DrDispatch.MRxCleanupFobx       = DrCleanupFobx;
    
    DrDispatch.MRxCloseSrvOpen      = DrCloseSrvOpen;
    DrDispatch.MRxFlush             = DrFlush;
    DrDispatch.MRxForceClosed       = DrForceClosed;
    DrDispatch.MRxDeallocateForFcb  = DrDeallocateForFcb;
    DrDispatch.MRxDeallocateForFobx = DrDeallocateForFobx;
    DrDispatch.MRxIsLockRealizable  = DrIsLockRealizable;

    //
    // File System Objects query/Set
    //

    DrDispatch.MRxQueryDirectory       = DrQueryDirectory;  //MRxIfsQueryDirectory;
    DrDispatch.MRxQueryVolumeInfo      = DrQueryVolumeInfo; //MRxIfsQueryVolumeInformation;
    DrDispatch.MRxSetVolumeInfo        = DrSetVolumeInfo;   //MRxSmbSetVolumeInformation;
    //DrDispatch.MRxQueryEaInfo        = MRxIfsQueryEaInformation;
    //DrDispatch.MRxSetEaInfo          = MRxIfsSetEaInformation;
    DrDispatch.MRxQuerySdInfo          = DrQuerySdInfo;     //MRxIfsQuerySecurityInformation;
    DrDispatch.MRxSetSdInfo            = DrSetSdInfo;       //MRxIfsSetSecurityInformation;
    //MRxSmbDispatch.MRxQueryQuotaInfo  = MRxSmbQueryQuotaInformation;
    //MRxSmbDispatch.MRxSetQuotaInfo    = MRxSmbSetQuotaInformation;
    DrDispatch.MRxQueryFileInfo        = DrQueryFileInfo;   //MRxIfsQueryFileInformation;
    DrDispatch.MRxSetFileInfo          = DrSetFileInfo;     //MRxIfsSetFileInformation;
    DrDispatch.MRxSetFileInfoAtCleanup = DrSetFileInfoAtCleanUp;  //MRxIfsSetFileInformationAtCleanup;
    DrDispatch.MRxIsValidDirectory     = DrIsValidDirectory;

    //
    // Buffering state change
    //

    //DrDispatch.MRxComputeNewBufferingState = MRxIfsComputeNewBufferingState;

    //
    // File System Object I/O
    //

    DrDispatch.MRxLowIOSubmit[LOWIO_OP_READ]            = DrRead;
    DrDispatch.MRxLowIOSubmit[LOWIO_OP_WRITE]           = DrWrite;
    DrDispatch.MRxLowIOSubmit[LOWIO_OP_SHAREDLOCK]      = DrLocks;
    DrDispatch.MRxLowIOSubmit[LOWIO_OP_EXCLUSIVELOCK]   = DrLocks;
    DrDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK]          = DrLocks;
    DrDispatch.MRxLowIOSubmit[LOWIO_OP_UNLOCK_MULTIPLE] = DrLocks;

    DrDispatch.MRxLowIOSubmit[LOWIO_OP_FSCTL]           = DrIoControl;  //MRxIfsFsCtl;

    DrDispatch.MRxLowIOSubmit[LOWIO_OP_IOCTL]           = DrIoControl;

    DrDispatch.MRxLowIOSubmit[LOWIO_OP_NOTIFY_CHANGE_DIRECTORY] = DrNotifyChangeDirectory;    //MRxIfsNotifyChangeDirectory;

    //
    // Miscellanous - buffering
    //

    //DrDispatch.MRxCompleteBufferingStateChangeRequest = MRxIfsCompleteBufferingStateChangeRequest;


    return STATUS_SUCCESS;
}

BOOLEAN
DrIsAdminIoRequest(
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp
    )
/*++

Routine Description:

    (Lifted from AFD - AfdPerformSecurityCheck)
    Compares security context of the endpoint creator to that
    of the administrator and local system.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    TRUE    - the socket creator has admin or local system privilige
    FALSE    - the socket creator is just a plain user

--*/

{
    BOOLEAN               accessGranted;
    PACCESS_STATE         accessState;
    PIO_SECURITY_CONTEXT  securityContext;
    PPRIVILEGE_SET        privileges = NULL;
    ACCESS_MASK           grantedAccess;
    PGENERIC_MAPPING GenericMapping;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    NTSTATUS              Status;

    BEGIN_FN("DrIsAdminIoRequest");
    ASSERT(Irp != NULL);
    ASSERT(IrpSp != NULL);
    ASSERT(IrpSp->MajorFunction == IRP_MJ_CREATE);

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask( &AccessMask, GenericMapping );

    securityContext = IrpSp->Parameters.Create.SecurityContext;

    ASSERT(securityContext != NULL);
    accessState = securityContext->AccessState;

    SeLockSubjectContext(&accessState->SubjectSecurityContext);

    TRC_ASSERT(DrAdminSecurityDescriptor != NULL, 
            (TB, "DrAdminSecurityDescriptor != NULL"));

    accessGranted = SeAccessCheck(
                        DrAdminSecurityDescriptor,
                        &accessState->SubjectSecurityContext,
                        TRUE,
                        AccessMask,
                        0,
                        &privileges,
                        IoGetFileObjectGenericMapping(),
                        (KPROCESSOR_MODE)((IrpSp->Flags & SL_FORCE_ACCESS_CHECK)
                            ? UserMode
                            : Irp->RequestorMode),
                        &grantedAccess,
                        &Status
                        );

    if (privileges) {
        (VOID) SeAppendPrivileges(
                   accessState,
                   privileges
                   );
        SeFreePrivileges(privileges);
    }

    if (accessGranted) {
        accessState->PreviouslyGrantedAccess |= grantedAccess;
        accessState->RemainingDesiredAccess &= ~( grantedAccess | MAXIMUM_ALLOWED );
        ASSERT (NT_SUCCESS (Status));
    }
    else {
        ASSERT (!NT_SUCCESS (Status));
    }
    SeUnlockSubjectContext(&accessState->SubjectSecurityContext);

    return accessGranted;
}

BOOLEAN 
DrIsSystemProcessRequest(
    PIRP                Irp,
    PIO_STACK_LOCATION  IrpSp
)
/*++

Routine Description:

    Checks to see if the IRP originated from a system process.  

Arguments:

    Irp - Pointer to I/O request packet.
    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    TRUE if the IRP originated from a system process.  FALSE, otherwise.

--*/
{
    PACCESS_STATE accessState;
    PIO_SECURITY_CONTEXT  securityContext;
    PACCESS_TOKEN accessToken;
    PTOKEN_USER userId = NULL;
    BOOLEAN result = FALSE;
    NTSTATUS status = STATUS_SUCCESS;
    PSID systemSid;

    BEGIN_FN("DrIsSystemProcessRequest");
    TRC_NRM((TB, "DrIsSystemProcessRequest called"));

    ASSERT(Irp != NULL);
    ASSERT(IrpSp != NULL);
    ASSERT(IrpSp->MajorFunction == IRP_MJ_CREATE);

    securityContext = IrpSp->Parameters.Create.SecurityContext;

    ASSERT(securityContext != NULL);

    //
    //  Get the well-known system SID.
    //
    systemSid = (PSID)new(PagedPool) BYTE[RtlLengthRequiredSid(1)];
    if (systemSid) {
        SID_IDENTIFIER_AUTHORITY identifierAuthority = SECURITY_NT_AUTHORITY;
        *(RtlSubAuthoritySid(systemSid, 0)) = SECURITY_LOCAL_SYSTEM_RID;
        status = RtlInitializeSid(systemSid, &identifierAuthority, (UCHAR)1);
    }
    else {
        TRC_ERR((TB, "Can't allocate %ld bytes for system SID.", 
                RtlLengthRequiredSid(1)));
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Get the non-impersonated, primary token for the IRP request.
    //
    accessState = securityContext->AccessState;
    accessToken = accessState->SubjectSecurityContext.PrimaryToken;

    //
    // We got the system SID. Now compare the caller's SID.
    //
    if (NT_SUCCESS(status) && accessToken){
        //
        //  Get the user ID associated with the primary token for the process
        //  that generated the IRP.
        //
        status = SeQueryInformationToken(
            accessToken,
            TokenUser,
            (PVOID *)&userId
        );

        //
        //  Do the comparison.
        //  
        if (NT_SUCCESS(status)) {
            result = RtlEqualSid(systemSid, userId->User.Sid);
            ExFreePool(userId);
        }
        else {
            TRC_ERR((TB, "SeQueryInformationToken failed with %08X", 
                    status));
        }
    }
    else {
        TRC_ERR((TB, "Failed to get system sid because of error %08X", 
                status));
    }
    
    if (systemSid) {
        delete systemSid;
    }

    return result;
}

BOOL
DrQueryServerName(PUNICODE_STRING PathName)
/*++

Routine Description:

    This routine check if the pathname belongs to our minirdr. 

Arguments:

    PathName: path name to check
    
Return Value:

    TRUE - if the path is to our mini-rdr
    FALSE - if the path not our mini-rdr

--*/
{
    PWCHAR ServerName;
    PWCHAR ServerNameEnd;
    unsigned CompareLen;    // in characters
    unsigned PathNameLen;   // in characters

    BEGIN_FN("DrQueryServerName");

    TRC_NRM((TB, "Got query path for file: %wZ", PathName));
    
    //
    //  Make sure the server name we are comparing has at least length
    //  of the server name our rdpdr recongize
    //
    if (PathName->Length >= DRUNCSERVERNAME_U_LENGTH) {
        ServerName = PathName->Buffer;
        // bypass the first backslash
        ServerName++;
        PathNameLen = PathName->Length / sizeof(WCHAR) - 1;

        // Find the next backslash
        ServerNameEnd = ServerName;
        while ((unsigned)(ServerNameEnd - ServerName) < PathNameLen) {
            if (*ServerNameEnd == L'\\') {
                break;
            }
            ServerNameEnd++;
        }
        CompareLen = (unsigned)(ServerNameEnd - ServerName);

        //
        //  Determine if this is a server name belongs to our minirdr
        //
        if ( (CompareLen == DRUNCSERVERNAME_A_LENGTH - 1) &&
                 _wcsnicmp(ServerName, DRUNCSERVERNAME_U, CompareLen) == 0) {
            
            TRC_NRM((TB, "Quick return that we know the name"));

            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
DrPeekDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the driver dispatch for the rdpdr DRIVER object. 

Arguments:

    DeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the Irp

--*/
{
    PIO_STACK_LOCATION IoStackLocation;
    NTSTATUS Status;
    ULONG  irpSessionId;
    BEGIN_FN("DrPeekDispatch ");

    IoStackLocation = IoGetCurrentIrpStackLocation(Irp);
#if DBG
    TRC_NRM((TB, "Irp: %s", IrpNames[IoStackLocation->MajorFunction]));

    switch (IoStackLocation->MajorFunction) {
    case IRP_MJ_CREATE:
        TRC_NRM((TB, "CreateFile name: %wZ", 
        &IoStackLocation->FileObject->FileName));
        break;

    case IRP_MJ_WRITE:
        TRC_NRM((TB, "IRP_MJ_WRITE")); 
        break;

    }
#endif // DBG

    //
    //  For Read and Write IRP, we disable caching because the client
    //  is an usermode app and can't synchronize with the server cache
    //  manager 
    //
    if (IoStackLocation->MajorFunction == IRP_MJ_READ ||
            IoStackLocation->MajorFunction == IRP_MJ_WRITE) {
        Irp->Flags |= IRP_NOCACHE;
    }

    //
    //  We need to return immediately for redir_query_path
    //
    if (IoStackLocation->MajorFunction == IRP_MJ_DEVICE_CONTROL &&
            IoStackLocation->Parameters.DeviceIoControl.IoControlCode == IOCTL_REDIR_QUERY_PATH &&
            Irp->RequestorMode == KernelMode) {
        
        QUERY_PATH_REQUEST *qpRequest = (QUERY_PATH_REQUEST *)
                IoStackLocation->Parameters.DeviceIoControl.Type3InputBuffer;

        if (qpRequest != NULL) {
            UNICODE_STRING PathName;

            PathName.Length = (USHORT)qpRequest->PathNameLength;
            PathName.Buffer= qpRequest->FilePathName;

            if (DrQueryServerName(&PathName)) {
                //
                // We must now complete the IRP
                //
                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
            
                return STATUS_SUCCESS;        
            }
        }
    }        

    //
    // We want to bypass filesize caching
    //
    RxForceQFIPassThrough = TRUE;

    // If it's not the IFS DO, then let RDPDYN have a shot at it.  Eventually,
    // it would be nice to confirm that it is for RDPDYN.  We can work this
    // out later ...

    if (DeviceObject != (PDEVICE_OBJECT)DrDeviceObject && 
            DeviceObject != (PDEVICE_OBJECT) DrPortDeviceObject) {

        TRC_NRM((TB, "Pass IRP on to RDPDYN_Dispatch"));
        return RDPDYN_Dispatch(DeviceObject, Irp);
    } else {

        // Only for port device, we deny driver attachment
        if (DeviceObject == (PDEVICE_OBJECT) DrPortDeviceObject) {
        
            if (DeviceObject->AttachedDevice != NULL ||
                    (IoStackLocation->FileObject != NULL &&
                    IoStackLocation->FileObject->DeviceObject != (PDEVICE_OBJECT)DrPortDeviceObject)) {
            
                //
                //  We don't accept another device attaches to us or 
                //  is passing irps to us
                //
                Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return STATUS_ACCESS_DENIED;        
            }
        
            // 
            // We swap back to the rdpdr device object for port device so it'll go through
            // the rdbss route
            //
            IoStackLocation->DeviceObject = (PDEVICE_OBJECT)DrDeviceObject; 

            // For Multi-User TS environment, we need to set the port carete share access
            // to be sharable, otherwise two users can't use com1 at the same time because
            // rdbss check for share access for NET_ROOT \\tsclient\com1.
            if (IoStackLocation->MajorFunction == IRP_MJ_CREATE) {
                IoStackLocation->Parameters.Create.ShareAccess = FILE_SHARE_VALID_FLAGS;
            }
        }

        if ((IoStackLocation->MajorFunction == IRP_MJ_CREATE) &&
                (IoStackLocation->FileObject->FileName.Length == 0)  &&
                (IoStackLocation->FileObject->RelatedFileObject == NULL)) {
            //
            // This is a blank create, like rdpwsx uses to open us for
            // session connect disconnect notification. Only allowed
            // by the system because we trust rdpwsx to hold a kernel
            // pointer for us
            //

            //
            //  Security check the irp.
            //  
            Status = IoGetRequestorSessionId(Irp, &irpSessionId);
            if (NT_SUCCESS(Status)) {
                //
                //  If the request is from the console session, it needs to be from a system 
                //  process.
                //
                if (irpSessionId == CONSOLE_SESSIONID) {
                    TRC_NRM((TB, "Create request from console process."));

                    if (!DrIsSystemProcessRequest(Irp, IoStackLocation)) {
                        TRC_ALT((TB, "Root Create request not from system process."));

                        //
                        //  We may get called from a user process through the UNC
                        //  network provider.  e.g. when user does a net use
                        //  In this case, we have to allow root access.  We have to
                        //  do the security check on per IRP bases.
                        //
                        //Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
                        //Irp->IoStatus.Information = 0;
                        //IoCompleteRequest(Irp, IO_NO_INCREMENT);
                        //return STATUS_ACCESS_DENIED;
                        return RxFsdDispatch((PRDBSS_DEVICE_OBJECT)DrDeviceObject, Irp);
                        
                    } else {
                        TRC_NRM((TB, "Root Create request from system accepted."));
                        return RxFsdDispatch((PRDBSS_DEVICE_OBJECT)DrDeviceObject, Irp);
                    }
                } else {
                    //
                    //  If not from the console then deny access.
                    //

                    TRC_ALT((TB, "Root request from %ld", irpSessionId));

                    //
                    //  We may get called from a user process through the UNC
                    //  network provider.  e.g. when user does a net use
                    //  In this case, we have to allow root access.  We have to
                    //  do the security check on per IRP bases.
                    //
                    //Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
                    //Irp->IoStatus.Information = 0;
                    //IoCompleteRequest(Irp, IO_NO_INCREMENT);
                    //return STATUS_ACCESS_DENIED;
                    return RxFsdDispatch((PRDBSS_DEVICE_OBJECT)DrDeviceObject, Irp);
                }
            }
            else {
                TRC_ERR((TB, "IoGetRequestorSessionId failed with %08X.", Status));
                Irp->IoStatus.Status = Status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return Status;
            }
        } else {

            //
            // This is not a create, or at least not a create to just the root
            //

            TRC_NRM((TB, "Pass IRP on to RxFsdDispatch = %d", IoStackLocation->MajorFunction));
            
            return RxFsdDispatch((PRDBSS_DEVICE_OBJECT)DrDeviceObject, Irp);
        }
    }
}

NTSTATUS DrLoadRegistrySettings (
    IN PCWSTR   RegistryPath
    )
/*++

Routine Description:

    This routine reads the default configuration data from the
    registry for the device redirector driver.

Arguments:

    RegistryPath - points to the entry for this driver in the
                   current control set of the registry.

Return Value:

    STATUS_SUCCESS if we got the defaults, otherwise we failed.
    The only way to fail this call is if the  STATUS_INSUFFICIENT_RESOURCES.

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;    // return value
    BEGIN_FN("DrLoadRegistrySettings ");
#if DBG
    extern TRC_CONFIG TRC_Config;
    int i;
    //
    // We use this to query into the registry for defaults
    // paramTable needs to be one entry larger than the set we
    // need because a NULL entry indicates we're done
    //

    RTL_QUERY_REGISTRY_TABLE paramTable[9];
    TRC_CONFIG trcConfig;
    ULONG   DebugBreakOnEntryDefault = FALSE;

    PAGED_CODE();

    RtlZeroMemory(&trcConfig, sizeof(trcConfig));
    trcConfig.FunctionLength = TRC_FUNCNAME_LEN;
    trcConfig.TraceDebugger = FALSE;
    trcConfig.TraceLevel = TRC_LEVEL_ALT;
    trcConfig.TraceProfile = TRUE;

    RtlZeroMemory (&paramTable[0], sizeof(paramTable));

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = L"FunctionLength";
    paramTable[0].EntryContext  = &TRC_Config.FunctionLength;
    paramTable[0].DefaultType   = REG_DWORD;
    paramTable[0].DefaultData   = &trcConfig.FunctionLength;
    paramTable[0].DefaultLength = sizeof(trcConfig.FunctionLength);
    
    paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name          = L"TraceLevel";
    paramTable[1].EntryContext  = &TRC_Config.TraceLevel;
    paramTable[1].DefaultType   = REG_DWORD;
    paramTable[1].DefaultData   = &trcConfig.TraceLevel;
    paramTable[1].DefaultLength = sizeof(trcConfig.TraceLevel);
    
    paramTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[2].Name          = L"TraceProfile";
    paramTable[2].EntryContext  = &TRC_Config.TraceProfile;
    paramTable[2].DefaultType   = REG_DWORD;
    paramTable[2].DefaultData   = &trcConfig.TraceProfile;
    paramTable[2].DefaultLength = sizeof(trcConfig.TraceProfile);
    
    paramTable[3].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[3].Name          = L"TraceDebugger";
    paramTable[3].EntryContext  = &TRC_Config.TraceDebugger;
    paramTable[3].DefaultType   = REG_DWORD;
    paramTable[3].DefaultData   = &trcConfig.TraceDebugger;
    paramTable[3].DefaultLength = sizeof(trcConfig.TraceDebugger);
    
    paramTable[4].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[4].Name          = L"BreakOnEntry";
    paramTable[4].EntryContext  = &DebugBreakOnEntry;
    paramTable[4].DefaultType   = REG_DWORD;
    paramTable[4].DefaultData   = &DebugBreakOnEntryDefault;
    paramTable[4].DefaultLength = sizeof(ULONG);

    paramTable[5].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[5].Name          = L"PrintPortWriteSize";
    paramTable[5].EntryContext  = &PrintPortWriteSize;
    paramTable[5].DefaultType   = REG_DWORD;
    paramTable[5].DefaultData   = &PrintPortWriteSizeDefault;
    paramTable[5].DefaultLength = sizeof(ULONG);

    paramTable[6].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[6].Name          = L"DeviceLowPrioSendFlags";
    paramTable[6].EntryContext  = &DeviceLowPrioSendFlags;
    paramTable[6].DefaultType   = REG_DWORD;
    paramTable[6].DefaultData   = &DeviceLowPrioSendFlagsDefault;
    paramTable[6].DefaultLength = sizeof(ULONG);

    paramTable[7].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[7].Name          = L"MaxWorkerThreads";
    paramTable[7].EntryContext  = &MaxWorkerThreads;
    paramTable[7].DefaultType   = REG_DWORD;
    paramTable[7].DefaultData   = &MaxWorkerThreadsDefault;
    paramTable[7].DefaultLength = sizeof(ULONG);



    Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                     RegistryPath,
                                     &paramTable[0],
                                     NULL,
                                     NULL);
       
    if (!NT_SUCCESS(Status)) {
            DebugBreakOnEntry = DebugBreakOnEntryDefault;
    }

    RtlZeroMemory (&paramTable[0], sizeof(paramTable));

    WCHAR wcPrefix[10] = L"Prefix";
    WCHAR wcStart[10] = L"Start";
    WCHAR wcEnd[10] = L"End";
    UNICODE_STRING usPrefix;
    UNICODE_STRING usStart;
    UNICODE_STRING usEnd;

    usPrefix.Buffer = &wcPrefix[6];             // Just past "Prefix"
    usPrefix.MaximumLength = 3 * sizeof(WCHAR); // Remaining space, room for null term.

    usStart.Buffer = &wcStart[5];               // Just past "Start"
    usStart.MaximumLength = 4 * sizeof(WCHAR);  // Remaining space, room for null term.

    usEnd.Buffer = &wcEnd[4];                   // Just past "End"
    usEnd.MaximumLength = 5 * sizeof(WCHAR);    // Remaining space, room for null term.

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = wcPrefix;
    paramTable[0].DefaultType   = REG_BINARY;
    paramTable[0].DefaultData   = &trcConfig.Prefix[0].name[0];
    paramTable[0].DefaultLength = sizeof(trcConfig.Prefix[0].name);

    paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name          = wcStart;
    paramTable[1].DefaultType   = REG_DWORD;
    paramTable[1].DefaultData   = &trcConfig.Prefix[0].start;
    paramTable[1].DefaultLength = sizeof(trcConfig.Prefix[0].start);

    paramTable[2].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[2].Name          = wcEnd;
    paramTable[2].DefaultType   = REG_DWORD;
    paramTable[2].DefaultData   = &trcConfig.Prefix[0].end;
    paramTable[2].DefaultLength = sizeof(trcConfig.Prefix[0].end);

    //
    // So the registry can have values like:
    //  Prefix1 = "rdpdr"
    //  Start1 = 400
    //  End1 = 425
    //
    //  Prefix1 = "channel"
    //  Start1 = 765
    //  End1 = 765
    //
    // And that will restrict tracing output to rdpdr, lines 400-425
    //  and channel, line 765
    //

    for (i = 0; i < TRC_MAX_PREFIX; i ++) {

        RtlZeroMemory(&TRC_Config.Prefix[i].name[0], 
                sizeof(TRC_Config.Prefix[i].name[0]));

        // Clear out the end of the strings

        usPrefix.Length = 0;    // no length yet
        RtlZeroMemory(usPrefix.Buffer, usPrefix.MaximumLength);

        usStart.Length = 0;     // no length yet
        RtlZeroMemory(usStart.Buffer, usStart.MaximumLength);

        usEnd.Length = 0;       // no length yet
        RtlZeroMemory(usEnd.Buffer, usEnd.MaximumLength);

        // Append the integer

        RtlIntegerToUnicodeString(i + 1, 10, &usPrefix);
        RtlIntegerToUnicodeString(i + 1, 10, &usStart);
        RtlIntegerToUnicodeString(i + 1, 10, &usEnd);

        paramTable[0].EntryContext  = &TRC_Config.Prefix[i].name;
        paramTable[1].EntryContext  = &TRC_Config.Prefix[i].start;
        paramTable[2].EntryContext  = &TRC_Config.Prefix[i].end;

        Status = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                         RegistryPath,
                                         &paramTable[0],
                                         NULL,
                                         NULL);
    }


#endif // DBG
    return (Status);
}

NTSTATUS DrStart(PRX_CONTEXT RxContext, IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject)
/*++

Routine Description:

     This routine completes the initialization of the mini redirector fromn the
     RDBSS perspective. Note that this is different from the initialization done
     in DriverEntry. Any initialization that depends on RDBSS should be done as
     part of this routine while the initialization that is independent of RDBSS
     should be done in the DriverEntry routine.

Arguments:

    RxContext - Supplies the Irp that was used to startup the rdbss

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    BEGIN_FN("DrStart");
    return Status;
}

NTSTATUS DrStop(PRX_CONTEXT RxContext, IN OUT PRDBSS_DEVICE_OBJECT RxDeviceObject)
/*++

Routine Description:

    This routine is used to deactivate the mini redirector from the RDBSS perspective

Arguments:

    RxContext - the context that was used to start the mini redirector

    pContext  - the mini rdr context passed in at registration time.

Return Value:

    RXSTATUS - The return status for the operation

--*/
{
    NTSTATUS Status;

    BEGIN_FN("DrStop");

    return STATUS_SUCCESS;
}

NTSTATUS DrDeallocateForFcb(IN OUT PMRX_FCB pFcb)
{
    BEGIN_FN("DrDeallocateForFcb");

    return STATUS_SUCCESS;
}

NTSTATUS DrDeallocateForFobx(IN OUT PMRX_FOBX pFobx)
/*++

Routine Description:

   This routine is the last gasp of a Fobx. We remove the DeviceEntry ref

Arguments:

    pFobx - the instance to be closed

Return Value:

    RXSTATUS - The return status for the operation

Notes:

--*/
{
    DrDevice *Device;
    DrFile *FileObj;
    
    BEGIN_FN("DrDeallocateForFobx");

    //
    // Dereference the device object.
    //
    
    if (pFobx->Context != NULL) {
        Device = (DrDevice *)pFobx->Context;
        pFobx->Context = NULL;
        Device->Release();
    }

    //
    //  Cleanup the file object
    //
    if (pFobx->Context2 != NULL) {
        FileObj = (DrFile *)pFobx->Context2;
        FileObj->Release();
        pFobx->Context2 = NULL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS DrForceClosed(IN PMRX_SRV_OPEN pSrvOpen)
/*++

Routine Description:

   This routine closes a file system object

Arguments:

    pSrvOpen - the instance to be closed

Return Value:

    RXSTATUS - The return status for the operation

Notes:



--*/
{
    BEGIN_FN("DrForceClosed");

    TRC_NRM((TB, "DrForceClosed not implemented"));
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
BuildDeviceAcl(
    OUT PACL *DeviceAcl
    )

/*++

Routine Description:

    (Lifted from AFD - AfdBuildDeviceAcl)
    This routine builds an ACL which gives Administrators and LocalSystem
    principals full access. All other principals have no access.

Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PGENERIC_MAPPING GenericMapping;
    PSID AdminsSid;
    PSID SystemSid;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl;

    BEGIN_FN("BuildDeviceAcl");
    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask( &AccessMask, GenericMapping );

    AdminsSid = SeExports->SeAliasAdminsSid;
    SystemSid = SeExports->SeLocalSystemSid;

    AclLength = sizeof( ACL )                    +
                2 * sizeof( ACCESS_ALLOWED_ACE ) +
                RtlLengthSid( AdminsSid )         +
                RtlLengthSid( SystemSid )         -
                2 * sizeof( ULONG );

    NewAcl = (PACL)new(PagedPool) BYTE[AclLength];

    if (NewAcl == NULL) {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    Status = RtlCreateAcl (NewAcl, AclLength, ACL_REVISION );

    if (!NT_SUCCESS( Status )) {
        delete NewAcl;
        return( Status );
    }

    Status = RtlAddAccessAllowedAce (
                 NewAcl,
                 ACL_REVISION2,
                 AccessMask,
                 AdminsSid
                 );

    ASSERT( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewAcl,
                 ACL_REVISION2,
                 AccessMask,
                 SystemSid
                 );

    ASSERT( NT_SUCCESS( Status ));

    *DeviceAcl = NewAcl;

    return( STATUS_SUCCESS );

} // BuildDeviceAcl

NTSTATUS
CreateAdminSecurityDescriptor(
    VOID
    )
/*++

Routine Description:

    (Lifted from AFD - AfdCreateAdminSecurityDescriptor)
    This routine creates a security descriptor which gives access
    only to Administrtors and LocalSystem. This descriptor is used
    to access check raw endpoint opens and exclisive access to transport
    addresses.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PACL                  rawAcl = NULL;
    NTSTATUS              status;
    BOOLEAN               memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR  drSecurityDescriptor;
    ULONG                 localDrSecurityDescriptorLength = 0;
    CHAR                  buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR  localSecurityDescriptor =
                             (PSECURITY_DESCRIPTOR) &buffer;
    PSECURITY_DESCRIPTOR  localDrAdminSecurityDescriptor;
    SECURITY_INFORMATION  securityInformation = DACL_SECURITY_INFORMATION;

    BEGIN_FN("CreateAdminSecurityDescriptor");

    //
    // Get a pointer to the security descriptor from the Dr device object.
    //
    status = ObGetObjectSecurity(
                 DrDeviceObject,
                 &drSecurityDescriptor,
                 &memoryAllocated
                 );

    if (!NT_SUCCESS(status)) {
        TRC_ERR((TB, "Unable to get security descriptor, error: %x",
                status));
        ASSERT(memoryAllocated == FALSE);
        return(status);
    }
    else {
        if (drSecurityDescriptor == NULL) {
            TRC_ERR((TB, "No security descriptor for DrDeviceObject"));
            status = STATUS_UNSUCCESSFUL;
            return(status);
        }
    }

    //
    // Build a local security descriptor with an ACL giving only
    // administrators and system access.
    //
    status = BuildDeviceAcl(&rawAcl);

    if (!NT_SUCCESS(status)) {
        TRC_ERR((TB, "Unable to create Raw ACL, error: %x", status));
        goto error_exit;
    }

    (VOID) RtlCreateSecurityDescriptor(
                localSecurityDescriptor,
                SECURITY_DESCRIPTOR_REVISION
                );

    (VOID) RtlSetDaclSecurityDescriptor(
                localSecurityDescriptor,
                TRUE,
                rawAcl,
                FALSE
                );

    //
    // Make a copy of the Dr descriptor. This copy will be the raw descriptor.
    //
    localDrSecurityDescriptorLength = RtlLengthSecurityDescriptor(
                                      drSecurityDescriptor
                                      );

    localDrAdminSecurityDescriptor = (PSECURITY_DESCRIPTOR)new(PagedPool) BYTE[localDrSecurityDescriptorLength];

    if (localDrAdminSecurityDescriptor == NULL) {
        TRC_ERR((TB, "couldn't allocate security descriptor"));
        status = STATUS_NO_MEMORY;
        goto error_exit;
    }

    RtlMoveMemory(
        localDrAdminSecurityDescriptor,
        drSecurityDescriptor,
        localDrSecurityDescriptorLength
        );

    DrAdminSecurityDescriptor = localDrAdminSecurityDescriptor;
    DrSecurityDescriptorLength = localDrSecurityDescriptorLength;
    //
    // Now apply the local descriptor to the raw descriptor.
    //
    status = SeSetSecurityDescriptorInfo(
                 NULL,
                 &securityInformation,
                 localSecurityDescriptor,
                 &DrAdminSecurityDescriptor,
                 PagedPool,
                 IoGetFileObjectGenericMapping()
                 );

    if (!NT_SUCCESS(status)) {
        TRC_ERR((TB, "SeSetSecurity failed, %lx", status));
        ASSERT (DrAdminSecurityDescriptor==localDrAdminSecurityDescriptor);
        delete DrAdminSecurityDescriptor;
        DrAdminSecurityDescriptor = NULL;
        DrSecurityDescriptorLength = 0;
        goto error_exit;
    }

    if (DrAdminSecurityDescriptor != localDrAdminSecurityDescriptor) {
        delete localDrAdminSecurityDescriptor;
    }

    status = STATUS_SUCCESS;

error_exit:

    ObReleaseObjectSecurity(
        drSecurityDescriptor,
        memoryAllocated
        );

    if (rawAcl!=NULL) {
        delete rawAcl;
    }

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\rdpdrpnp.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    rdpdrpnp.h

Abstract:

    This module includes routines for handling PnP-related IRP's for RDP device 
    redirection.  

Author:

    tadb

Revision History:
--*/
#pragma once

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//  Handles PnP Start Device IRP's.
NTSTATUS RDPDRPNP_HandleStartDeviceIRP(
    PDEVICE_OBJECT StackDeviceObject,
    PIO_STACK_LOCATION IoStackLocation,
    IN PIRP Irp
    );

//  Handles PnP Remove Device IRP's.
NTSTATUS RDPDRPNP_HandleRemoveDeviceIRP(
    IN PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT StackDeviceObject,
    IN PIRP Irp
    );

//  This routine should only be called one time to create the "dr"'s FDO
//  that sits on top of the PDO for the sole purpose of registering new
//  device interfaces.

//  This function is called by PnP to make the "dr" the function driver
//   for a root dev node that was created on install.
NTSTATUS RDPDRPNP_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\rdpdyn.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    rdpdyn.c

Abstract:

    This module is the dynamic device management component for RDP device
    redirection.  It exposes an interface that can be opened by device management
    user-mode components running in session context.

    Need a check in IRP_MJ_CREATE to make sure that we are not being opened
    2x by the same session.  This shouldn't be allowed.

    Where can I safely use PAGEDPOOL instead of NONPAGEDPOOL.

Author:

    tadb

Revision History:
--*/

#include "precomp.hxx"
#define TRC_FILE "rdpdyn"
#include "trc.h"

#define DRIVER

#include "cfg.h"
#include "pnp.h"
#include "stdarg.h"
#include "stdio.h"

// Just shove the typedefs in for the Power Management functions now because I can't
// get the header conflicts resolved.
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
NTKERNELAPI VOID PoStartNextPowerIrp(IN PIRP Irp);
NTKERNELAPI NTSTATUS PoCallDriver(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

////////////////////////////////////////////////////////////////////////
//
//      Defines
//
// Calculate the size of a completed RDPDR_PRINTERDEVICE_SUB event.
#define CALCPRINTERDEVICE_SUB_SZ(rec) \
    sizeof(RDPDR_PRINTERDEVICE_SUB) + \
        (rec)->clientPrinterFields.PnPNameLen +       \
        (rec)->clientPrinterFields.DriverLen +        \
        (rec)->clientPrinterFields.PrinterNameLen +   \
        (rec)->clientPrinterFields.CachedFieldsLen

// Calculate the size of a completed RDPDR_REMOVEDEVICE event.
#define CALCREMOVEDEVICE_SUB_SZ(rec) \
    sizeof(RDPDR_REMOVEDEVICE)

// Calculate the size of a completed RDPDR_PORTDEVICE_SUB event.
#define CALCPORTDEVICE_SUB_SZ(rec) \
    sizeof(RDPDR_PORTDEVICE_SUB)
    
// Calculate the size of a completed RDPDR_DRIVEDEVICE_SUB event.
#define CALCDRIVEDEVICE_SUB_SZ(rec) \
    sizeof(RDPDR_DRIVEDEVICE_SUB)

#if DBG
#define DEVMGRCONTEXTMAGICNO        0x55445544

//  Test defines.
#define TESTDRIVERNAME              L"HP LaserJet 4P"
//#define TESTDRIVERNAME              L"This driver has no match"
#define TESTPNPNAME                 L""
#define TESTPRINTERNAME             TESTDRIVERNAME
#define TESTDEVICEID                0xfafafafa

//  Test port name.
#define TESTPORTNAME                L"LPT1"
#endif


////////////////////////////////////////////////////////////////////////
//
//      Internal Typedefs
//

//
// Context for each open by a user-mode device manager component.  This
// structure is stored in the FsContext field of the file object.
//
typedef struct tagDEVMGRCONTEXT
{
#if DBG
    ULONG   magicNo;
#endif
    ULONG   sessionID;
} DEVMGRCONTEXT, *PDEVMGRCONTEXT;

//
//  Non-Opaque Version of Associated Data for a Device Managed by this Module
//
typedef struct tagRDPDYN_DEVICEDATAREC
{
    ULONG          PortNumber;
    UNICODE_STRING SymbolicLinkName;
} RDPDYN_DEVICEDATAREC, *PRDPDYN_DEVICEDATAREC;

typedef struct tagCLIENTMESSAGECONTEXT {
    RDPDR_ClientMessageCB *CB;
    PVOID ClientData;
} CLIENTMESSAGECONTEXT, *PCLIENTMESSAGECONTEXT;

////////////////////////////////////////////////////////////////////////
//
//      Internal Prototypes
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Return the next available printer port number.
NTSTATUS GetNextPrinterPortNumber(
    OUT ULONG   *portNumber
    );

// Handle file object creation by a client of this driver.
NTSTATUS RDPDYN_Create(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
// Handle file object closure by a client of this driver.
NTSTATUS RDPDYN_Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

// This routine modifies the file object in preparation for returning STATUS_REPARSE.
NTSTATUS RDPDYN_PrepareForReparse(
    PFILE_OBJECT      fileObject
    );

// Handle IOCTL IRP's.
NTSTATUS RDPDYN_DeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

// This routine modifies the file object in preparation for returning STATUS_REPARSE.
NTSTATUS RDPDYN_PrepareForDevMgmt(
    PFILE_OBJECT        fileObject,
    PCWSTR              sessionIDStr,
    PIRP                irp,
    PIO_STACK_LOCATION  irpStackLocation
    );

// Generates a printer announce message for testing.
NTSTATUS RDPDYN_GenerateTestPrintAnnounceMsg(
    IN OUT  PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg,
    IN      ULONG devAnnounceMsgSize,
    OPTIONAL OUT ULONG *prnAnnounceMsgReqSize
    );

// Completely handles IOCTL_RDPDR_GETNEXTDEVMGMTEVENT IRP's.
NTSTATUS RDPDYN_HandleGetNextDevMgmtEventIOCTL(
    IN PDEVICE_OBJECT deviceObject,
    IN PIRP irp
    );

// Handle the cleanup IRP for a file object.
NTSTATUS RDPDYN_Cleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

// Calculate the size of a device management event.
ULONG RDPDYN_DevMgmtEventSize(
    IN PVOID devMgmtEvent,
    IN ULONG type
    );

// Completely handles IOCTL_RDPDR_CLIENTMSG IRP's.
NTSTATUS RDPDYN_HandleClientMsgIOCTL(
    IN PDEVICE_OBJECT deviceObject,
    IN PIRP pIrp
    );

// Complete a pending IRP with a device management event.
NTSTATUS CompleteIRPWithDevMgmtEvent(
    IN PDEVICE_OBJECT deviceObject,
    IN PIRP      pIrp,
    IN ULONG     eventSize,
    IN ULONG     eventType,
    IN PVOID     event,
    IN DrDevice *drDevice
    );

// Complete a pending IRP with a resize buffer event to the user-mode
// component.
NTSTATUS CompleteIRPWithResizeMsg(
    IN PIRP pIrp,
    IN ULONG requiredUserBufSize
    );

// Format a port description.
void GeneratePortDescription(
    IN PCSTR dosPortName,
    IN PCWSTR clientName,
    IN PWSTR description
    );

NTSTATUS NTAPI DrSendMessageToClientCompletion(PVOID Context, 
        PIO_STATUS_BLOCK IoStatusBlock);

#if DBG
// This is for testing so we can create a new test printer on
// demand from user-mode.
NTSTATUS RDPDYN_HandleDbgAddNewPrnIOCTL(
    IN PDEVICE_OBJECT deviceObject,
    IN PIRP pIrp
    );

// Generates a printer announce message for testing.
void RDPDYN_TracePrintAnnounceMsg(
    IN OUT PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg,
    IN ULONG sessionID,
    IN PCWSTR portName,
    IN PCWSTR clientName
    );
#endif

// Returns the next pending device management event request for the specified
// session, in the form of an IRP.  Note that this function can not be called
// if a spinlock has been acquired.
PIRP GetNextEventRequest(
    IN RDPEVNTLIST list,
    IN ULONG sessionID
    );

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

////////////////////////////////////////////////////////////////////////
//
//      Globals
//

// Pointer to the device Object for the minirdr. This global is defined in rdpdr.c.
extern PRDBSS_DEVICE_OBJECT      DrDeviceObject;

//
//  Global Registry Path for RDPDR.SYS.  This global is defined in rdpdr.c.
//
extern UNICODE_STRING            DrRegistryPath;

// The Physical Device Object that terminates our DO stack.
PDEVICE_OBJECT RDPDYN_PDO = NULL;

// Manages user-mode component device management events and event requests.
RDPEVNTLIST UserModeEventListMgr = RDPEVNTLIST_INVALID_LIST;

// Remove this check, eventually.
#if DBG
BOOL RDPDYN_StopReceived = FALSE;
BOOL RDPDYN_QueryStopReceived = FALSE;
DWORD RDPDYN_StartCount = 0;
#endif


////////////////////////////////////////////////////////////////////////
//
//      Function Definitions
//

NTSTATUS
RDPDYN_Initialize(
    )
/*++

Routine Description:

    Init function for this module.

Arguments:

Return Value:

    Status

--*/
{
    NTSTATUS status;

    BEGIN_FN("RDPDYN_Initialize");

    //
    //  Create the user-mode device event manager.
    //
    TRC_ASSERT(UserModeEventListMgr == RDPEVNTLIST_INVALID_LIST,
              (TB, "Initialize called more than 1 time"));
    UserModeEventListMgr = RDPEVNTLIST_CreateNewList();
    if (UserModeEventListMgr != RDPEVNTLIST_INVALID_LIST) {
        status = STATUS_SUCCESS;
    }
    else {
        status = STATUS_UNSUCCESSFUL;
    }

    //
    //  Initialize the dynamic port management module.
    //
    if (status == STATUS_SUCCESS) {
        status = RDPDRPRT_Initialize();
    }

    TRC_NRM((TB, "return status %08X.", status));
    return status;
}

NTSTATUS
RDPDYN_Shutdown(
    )
/*++

Routine Description:

    Shutdown function for this module.

Arguments:

Return Value:

    Status

--*/
{
    ULONG sessionID;
    void *devMgmtEvent;
    PIRP pIrp;
    ULONG type;
#if DBG
    ULONG sz;
#endif
    DrDevice *device;
    KIRQL   oldIrql;
    PDRIVER_CANCEL setCancelResult;

    BEGIN_FN("RDPDYN_Shutdown");

    //
    //  Clean up any pending device management events and any pending IRP's.
    //
    TRC_ASSERT(UserModeEventListMgr != RDPEVNTLIST_INVALID_LIST,
              (TB, "Invalid list mgr"));

    RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
    while (RDPEVNTLLIST_GetFirstSessionID(UserModeEventListMgr, &sessionID)) {
        //
        //  Remove pending IRP's
        //
        pIrp = (PIRP)RDPEVNTLIST_DequeueRequest(
                                        UserModeEventListMgr,
                                        sessionID
                                        );
        while (pIrp != NULL) {
            //
            //  Set the cancel routine to NULL and record the current state.
            //
            setCancelResult = IoSetCancelRoutine(pIrp, NULL);

            //
            //  Fail the IRP request.
            //
            RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

            //
            //  If the IRP is not being canceled.
            //
            if (setCancelResult != NULL) {
                //
                //  Fail the request.
                //
                pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
                IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            }

            //
            //  Remove the next IRP from the event/request queue.
            //
            RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
            pIrp = (PIRP)RDPEVNTLIST_DequeueRequest(
                                        UserModeEventListMgr,
                                        sessionID
                                        );
        }
        RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

        //
        //  Remove pending device management events.
        //
        RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
        while (RDPEVNTLIST_DequeueEvent(
                        UserModeEventListMgr,
                        sessionID, &type,
                        &devMgmtEvent,
                        &device
                        )) {

            RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);
#if DBG
            // Zero the free'd event in checked builds.
            sz = RDPDYN_DevMgmtEventSize(devMgmtEvent, type);
            if (sz > 0) {
                RtlZeroMemory(devMgmtEvent, sz);
            }
#endif
            if (devMgmtEvent != NULL) {
                delete devMgmtEvent;
            }

            //  Release the device, if appropriate.
            if (device != NULL) {
                device->Release();
            }
            
            RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
        }
        RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);
    }

    //
    //  Shut down the dynamic port management module.
    //
    RDPDRPRT_Shutdown();

    return STATUS_SUCCESS;
}

NTSTATUS
RDPDYN_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle IRP's for DO's sitting on top of our physical device object.

Arguments:

    DeviceObject - Supplies the device object for the packet being processed.

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The status for the Irp

--*/
{
    PIO_STACK_LOCATION ioStackLocation;
    NTSTATUS status;
    PRDPDYNDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT stackDeviceObject;
    BOOLEAN isPowerIRP;

    BEGIN_FN("RDPDYN_Dispatch");

    //
    //  Get our location in the IRP stack.
    //
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);
    TRC_NRM((TB, "Major is %08X", ioStackLocation->MajorFunction));

    //
    //  Get our device extension and stack device object.
    //
    deviceExtension = (PRDPDYNDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    TRC_ASSERT(deviceExtension != NULL, (TB, "Invalid device extension."));
    if (deviceExtension == NULL) {
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        return STATUS_UNSUCCESSFUL;
    }

    stackDeviceObject = deviceExtension->TopOfStackDeviceObject;
    TRC_ASSERT(stackDeviceObject != NULL, (TB, "Invalid device object."));

    //
    //  Function Dispatch Switch
    //
    isPowerIRP = FALSE;
    switch (ioStackLocation->MajorFunction)
    {
    case IRP_MJ_CREATE:

        TRC_NRM((TB, "IRP_MJ_CREATE"));

        // RDPDYN_Create handles this completely.
        return RDPDYN_Create(DeviceObject, Irp);

    case IRP_MJ_CLOSE:

        TRC_NRM((TB, "IRP_MJ_CLOSE"));

        // RDPDYN_Close handles this completely.
        return RDPDYN_Close(DeviceObject, Irp);

    case IRP_MJ_CLEANUP:

        TRC_NRM((TB, "IRP_MJ_CLEANUP"));

        // RDPDYN_Cleanup handles this completely.
        return RDPDYN_Cleanup(DeviceObject, Irp);

    case IRP_MJ_READ:

        // We shouldn't be receiving any read requests.
        TRC_ASSERT(FALSE, (TB, "Read requests not supported."));
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    case IRP_MJ_WRITE:

        // We shouldn't be receiving any write requests.
        TRC_ASSERT(FALSE, (TB, "Write requests not supported."));
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest (Irp, IO_NO_INCREMENT);
        return STATUS_NOT_SUPPORTED;

    case IRP_MJ_DEVICE_CONTROL:

        // RDPDYN_DeviceControl handles this completely.
        return RDPDYN_DeviceControl(DeviceObject, Irp);

    case IRP_MJ_POWER:

        TRC_NRM((TB, "IRP_MJ_POWER"));
        isPowerIRP = TRUE;

        switch (ioStackLocation->MinorFunction)
        {
        case IRP_MN_SET_POWER:
            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;
        default:
            TRC_NRM((TB, "Unknown Power IRP"));
        }
        break;

    case IRP_MJ_PNP:    TRC_NRM((TB, "IRP_MJ_PNP"));

        switch (ioStackLocation->MinorFunction)
        {
        case IRP_MN_START_DEVICE:
#if DBG
            // Remove this debug code, eventually.
            RDPDYN_StartCount++;
#endif

            return(RDPDRPNP_HandleStartDeviceIRP(stackDeviceObject,
                                            ioStackLocation, Irp));

        case IRP_MN_STOP_DEVICE:

#if DBG
            // Remove this debug code, eventually.
            RDPDYN_StopReceived = TRUE;
#endif

            TRC_NRM((TB, "IRP_MN_STOP_DEVICE"));
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            return STATUS_UNSUCCESSFUL;

        case IRP_MN_REMOVE_DEVICE:

            return(RDPDRPNP_HandleRemoveDeviceIRP(DeviceObject,
                                            stackDeviceObject, Irp));

        case IRP_MN_QUERY_CAPABILITIES:

            TRC_NRM((TB, "IRP_MN_QUERY_CAPABILITIES"));
            break;

        case IRP_MN_QUERY_ID:
            TRC_NRM((TB, "IRP_MN_QUERY_ID"));
                break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            TRC_NRM((TB, "IRP_MN_QUERY_DEVICE_RELATIONS"));
            switch(ioStackLocation->Parameters.QueryDeviceRelations.Type)
            {
            case EjectionRelations:
                TRC_NRM((TB, "Type==EjectionRelations"));
                break;

            case BusRelations:
                // Note that we need to handle this if we end up kicking out any PDO's.
                TRC_NRM((TB, "Type==BusRelations"));
                break;

            case PowerRelations:
                TRC_NRM((TB, "Type==PowerRelations"));
                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;

            case RemovalRelations:
                TRC_NRM((TB, "Type==RemovalRelations"));
                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;

            case TargetDeviceRelation:
                TRC_NRM((TB, "Type==TargetDeviceRelation"));
                break;

            default:
                TRC_NRM((TB, "Unknown IRP_MN_QUERY_DEVICE_RELATIONS minor type"));
            }
            break;

        case IRP_MN_QUERY_STOP_DEVICE:

#if DBG
            // Remove this debug code, eventually.
            RDPDYN_QueryStopReceived = TRUE;
#endif

            // We will not allow a device to be stopped for load balancing.
            TRC_NRM((TB, "IRP_MN_QUERY_STOP_DEVICE"));
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            return STATUS_UNSUCCESSFUL;

        case IRP_MN_QUERY_REMOVE_DEVICE:

            // We will not allow our device to be removed.
            TRC_NRM((TB, "IRP_MN_QUERY_REMOVE_DEVICE"));
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest (Irp, IO_NO_INCREMENT);
            return STATUS_UNSUCCESSFUL;

        case IRP_MN_CANCEL_STOP_DEVICE:
            TRC_NRM((TB, "IRP_MN_CANCEL_STOP_DEVICE"));
            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            TRC_NRM((TB, "IRP_MN_CANCEL_REMOVE_DEVICE"));
            Irp->IoStatus.Status = STATUS_SUCCESS;
            break;

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            TRC_NRM((TB, "IRP_MN_FILTER_RESOURCE_REQUIREMENTS"));
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            TRC_NRM((TB, "IRP_MN_QUERY_PNP_DEVICE_STATE"));
            break;

        case IRP_MN_QUERY_BUS_INFORMATION:
            TRC_NRM((TB, "IRP_MN_QUERY_BUS_INFORMATION"));
            break;

        default:
            TRC_ALT((TB, "Unhandled PnP IRP with minor %08X",
                    ioStackLocation->MinorFunction));
        }
    }

    //
    //  By default, pass the IRP down the stack.
    //
    if (isPowerIRP) {
        PoStartNextPowerIrp(Irp);
        IoSkipCurrentIrpStackLocation(Irp);
        return PoCallDriver(stackDeviceObject, Irp);
    }
    else {
        IoSkipCurrentIrpStackLocation(Irp);
        return IoCallDriver(stackDeviceObject,Irp);
    }
}

NTSTATUS
RDPDYN_Create(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Entry point for CreateFile calls.

Arguments:

    DeviceObject - pointer to our device object.


Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PFILE_OBJECT fileObject;
    PIO_STACK_LOCATION nextStackLocation;
    PIO_STACK_LOCATION currentStackLocation;
    ULONG i;
    BOOL matches;
    WCHAR sessionIDString[]=RDPDYN_SESSIONIDSTRING;
    ULONG idStrLen;
    WCHAR *sessionIDPtr;
    ULONG fnameLength;

    BEGIN_FN("RDPDYN_Create");

    // Get the current stack location.
    currentStackLocation = IoGetCurrentIrpStackLocation(Irp);
    TRC_ASSERT(currentStackLocation != NULL, (TB, "Invalid stack location."));
    fileObject = currentStackLocation->FileObject;

    // Return STATUS_REPARSE with the minirdr DO so it gets opened instead, if
    // we have a file name.
    if (fileObject->FileName.Length != 0)
    {
        //
        //  Find out if the client is trying to open us as the device manager from
        //  user-mode.
        //

        // Check for the session identifer string as the first few characters in
        // the reference string.
        idStrLen = wcslen(sessionIDString);
        fnameLength = fileObject->FileName.Length/sizeof(WCHAR);
        for (i=0; i<fnameLength && i<idStrLen; i++) {
            if (fileObject->FileName.Buffer[i] != sessionIDString[i]) {
                break;
            }
        }
        matches = (i == idStrLen);

        //
        //  If the client is trying to open us as the device manager from user-
        //  mode.
        //
        if (matches) {

            // Prepare the file object for managing device management comms to
            // the user-mode component that opened it.
            ntStatus = RDPDYN_PrepareForDevMgmt(
                                    fileObject,
                                    &fileObject->FileName.Buffer[idStrLen],
                                    Irp, currentStackLocation
                                    );
        }
        //  Otherwise, we can assume that this create is for a device that is being
        //  managed by RDPDR and the IFS kit.
        else {
            // Prepare the file object for reparse.
            ntStatus = RDPDYN_PrepareForReparse(fileObject);
        }
    }
    // Otherwise, fail.  This should never happen.
    else
    {
        ntStatus = STATUS_UNSUCCESSFUL;
    }

    // Complete the IO request and return.
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT
                       );

    return ntStatus;
}

NTSTATUS
RDPDYN_PrepareForReparse(
    PFILE_OBJECT      fileObject
)
/*++

Routine Description:

    This routine modifies the file object in preparation for returning
    STATUS_REPARSE

Arguments:

    fileObject - the file object

Return Value:

    STATUS_REPARSE if everything is successful

Notes:

--*/
{
    NTSTATUS ntStatus;
    USHORT rootDeviceNameLength, reparsePathLength,
           clientDevicePathLength;
    PWSTR pFileNameBuffer = NULL;
    ULONG i;
    ULONG len;
    BOOL clientDevPathMissingSlash;
    HANDLE deviceInterfaceKey = INVALID_HANDLE_VALUE;
    UNICODE_STRING unicodeStr;
    ULONG requiredBytes;
    PKEY_VALUE_PARTIAL_INFORMATION keyValueInfo = NULL;
    WCHAR *clientDevicePath=L"";
    GUID *pPrinterGuid;
    UNICODE_STRING symbolicLinkName;
    WCHAR *refString;

    BEGIN_FN("RDPDYN_PrepareForReparse");

    // We are not going to use these fields for storing any contextual
    // information.
    fileObject->FsContext  = NULL;
    fileObject->FsContext2 = NULL;

    // Compute the number of bytes required to store the root of the device
    // path, without the terminator.
    rootDeviceNameLength = wcslen(RDPDR_DEVICE_NAME_U) *
                           sizeof(WCHAR);

    //
    //  Get a pointer to the reference string for the reparse.
    //
    if (fileObject->FileName.Buffer[0] == L'\\') {
        refString = &fileObject->FileName.Buffer[1];
    }
    else {
        refString = &fileObject->FileName.Buffer[0];
    }

    //
    //  Resolve the reference name for the device into the symbolic link
    //  name for the device interface. We can optimize out this
    //  step and the next one by maintaining an internal table to convert
    //  from port names to symbolic link names.
    //
    pPrinterGuid = (GUID *)&DYNPRINT_GUID;
    RtlInitUnicodeString(&unicodeStr, refString);
    ntStatus=IoRegisterDeviceInterface(
                                RDPDYN_PDO, pPrinterGuid, &unicodeStr,
                                &symbolicLinkName
                                );
    if (ntStatus == STATUS_SUCCESS) {

        TRC_ERR((TB, "IoRegisterDeviceInterface succeeded."));

        //
        //  Open the registry key for the device being opened.
        //
        ntStatus = IoOpenDeviceInterfaceRegistryKey(
                                           &symbolicLinkName,
                                           KEY_ALL_ACCESS,
                                           &deviceInterfaceKey
                                           );

        RtlFreeUnicodeString(&symbolicLinkName);
    }

    //
    //  Get the size of the value info buffer required for the client device
    //  path for the device being opened.
    //
    if (ntStatus == STATUS_SUCCESS) {
        TRC_NRM((TB, "IoOpenDeviceInterfaceRegistryKey succeeded."));
        RtlInitUnicodeString(&unicodeStr, CLIENT_DEVICE_VALUE_NAME);
        ntStatus = ZwQueryValueKey(
                           deviceInterfaceKey,
                           &unicodeStr,
                           KeyValuePartialInformation,
                           NULL, 0,
                           &requiredBytes
                           );
    }
    else {
        TRC_NRM((TB, "IoOpenDeviceInterfaceRegistryKey failed: %08X.", ntStatus));

        deviceInterfaceKey = INVALID_HANDLE_VALUE;
    }

    //
    //  Size the data buffer.
    //
    if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
        keyValueInfo = (PKEY_VALUE_PARTIAL_INFORMATION)
                new(NonPagedPool) BYTE[requiredBytes];
        if (keyValueInfo != NULL) {
            ntStatus = STATUS_SUCCESS;
        }
        else {
            TRC_NRM((TB, "failed to allocate client device path."));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    //  Read the client device path.
    //
    if (ntStatus == STATUS_SUCCESS) {
        ntStatus = ZwQueryValueKey(
                           deviceInterfaceKey,
                           &unicodeStr,
                           KeyValuePartialInformation,
                           keyValueInfo, requiredBytes,
                           &requiredBytes
                           );
    }

    //
    //  Allocate the reparsed filename.
    //
    if (ntStatus == STATUS_SUCCESS) {
        TRC_NRM((TB, "ZwQueryValueKey succeeded."));
        clientDevicePath = (WCHAR *)keyValueInfo->Data;

        // Compute the number of bytes required to store the client device path,
        // without the terminator.
        clientDevicePathLength = wcslen(clientDevicePath) *
                                 sizeof(WCHAR);

        // See if the client device path is prefixed by a '\'
        clientDevPathMissingSlash = clientDevicePath[0] != L'\\';

        // Get the length (in bytes) of the entire reparsed device path, without the
        // terminator.
        reparsePathLength = rootDeviceNameLength +
                            clientDevicePathLength;
        if (clientDevPathMissingSlash) {
            reparsePathLength += sizeof(WCHAR);
        }

        pFileNameBuffer = (PWSTR)ExAllocatePoolWithTag(
                              NonPagedPool,
                              reparsePathLength + (1 * sizeof(WCHAR)),
                              RDPDYN_POOLTAG);
        if (pFileNameBuffer == NULL) {
            TRC_NRM((TB, "failed to allocate reparse buffer."));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    //  Assign the reparse string to the IRP's file name for reparse.
    //
    if (ntStatus == STATUS_SUCCESS) {
        // Copy the device name
        RtlCopyMemory(
            pFileNameBuffer,
            RDPDR_DEVICE_NAME_U,
            rootDeviceNameLength);

        // Make sure we get a '\' between the root device name and
        // the device path.
        if (clientDevPathMissingSlash) {
            pFileNameBuffer[rootDeviceNameLength/sizeof(WCHAR)] = L'\\';
            rootDeviceNameLength += sizeof(WCHAR);
        }

        // Append the client device path to the end of the device name and
        // include the client device path's terminator.
        RtlCopyMemory(
                ((PBYTE)pFileNameBuffer + rootDeviceNameLength),
                clientDevicePath, clientDevicePathLength + (1 * sizeof(WCHAR))
                );

        // Release the IRP's previous file name.
        ExFreePool(fileObject->FileName.Buffer);

        // Assign the reparse string to the IRP's file name.
        fileObject->FileName.Buffer = pFileNameBuffer;
        fileObject->FileName.Length = reparsePathLength;
        fileObject->FileName.MaximumLength = fileObject->FileName.Length;

        ntStatus = STATUS_REPARSE;
    } else {

        TRC_ERR((TB, "failed with status %08X.", ntStatus));

        if (pFileNameBuffer != NULL) {
            ExFreePool(pFileNameBuffer);
            pFileNameBuffer = NULL;
        }
    }

    TRC_NRM((TB, "device file name after processing %wZ.",
            &fileObject->FileName));

    //
    //  Clean up and exit.
    //
    if (deviceInterfaceKey != INVALID_HANDLE_VALUE) {
        ZwClose(deviceInterfaceKey);
    }
    if (keyValueInfo != NULL) {
        delete keyValueInfo;
    }

    return ntStatus;
}

NTSTATUS
RDPDYN_PrepareForDevMgmt(
    PFILE_OBJECT        fileObject,
    PCWSTR              sessionIDStr,
    PIRP                irp,
    PIO_STACK_LOCATION  irpStackLocation
)
/*++

Routine Description:

    This routine modifies the file object for managing device management comms
    with the user-mode component that opened us.

Arguments:

    fileObject - the file object.
    sessionID  - session identifier string.
    irp        - irp corresponding to the create for this file object.
    irpStackLocation - current location in the IRP stack for the create.

Return Value:

    STATUS_SUCCESS if everything is successful

Notes:

--*/
{
    PDEVMGRCONTEXT context;
    ULONG sessionID;
    ULONG i;
    UNICODE_STRING uncSessionID;
    NTSTATUS ntStatus;
    ULONG irpSessionId;

    BEGIN_FN("RDPDYN_PrepareForDevMgmt");
    //
    //  Security check the IRP to make sure it comes from a thread
    //  with admin privilege
    //
    if (!DrIsAdminIoRequest(irp, irpStackLocation)) {
        TRC_ALT((TB, "Access denied for non-Admin IRP."));
        return STATUS_ACCESS_DENIED;
    } else {
        TRC_DBG((TB, "Admin IRP accepted."));
    }

    //
    //  Convert the session identifier string into a number.
    //
    RtlInitUnicodeString(&uncSessionID, sessionIDStr);
    ntStatus = RtlUnicodeStringToInteger(&uncSessionID, 10, &sessionID);
    if (!NT_SUCCESS(ntStatus)) {
        return ntStatus;
    }

    //
    //  Allocate a context struct so we can remember information about
    //  which session we were opened from.  
    //
    context = new(NonPagedPool) DEVMGRCONTEXT;
    if (context == NULL) {
        return STATUS_NO_MEMORY;
    }

    // Initialize this struct.
#if DBG
    context->magicNo = DEVMGRCONTEXTMAGICNO;
#endif
    context->sessionID = sessionID;
    fileObject->FsContext = context;

    // Success.
    return STATUS_SUCCESS;
}

NTSTATUS
RDPDYN_Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the closure of a file object.

Arguments:

Return Value:

    NT status code

--*/
{

    NTSTATUS ntStatus;
    PFILE_OBJECT fileObject;
    PIO_STACK_LOCATION irpStack;
    PDEVMGRCONTEXT context;
    PIRP pIrp;
    KIRQL oldIrql;
    PDRIVER_CANCEL setCancelResult;

    BEGIN_FN("RDPDYN_Close");

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    fileObject = irpStack->FileObject;

    // Grab our "open" context for this instance of us from the current stack
    // location's file object.
    context = (PDEVMGRCONTEXT)irpStack->FileObject->FsContext;
    TRC_ASSERT(context->magicNo == DEVMGRCONTEXTMAGICNO, (TB, "invalid context"));

    //
    //  Make sure we got all the pending IRP's.
    //
    TRC_ASSERT(UserModeEventListMgr != NULL, (TB, "RdpDyn EventList is NULL"));
    
    RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
    pIrp = (PIRP)RDPEVNTLIST_DequeueRequest(
                                    UserModeEventListMgr,
                                    context->sessionID
                                    );
    while (pIrp != NULL) {

        //
        //  Set the cancel routine to NULL and record the current state.
        //
        setCancelResult = IoSetCancelRoutine(pIrp, NULL);

        RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

        TRC_NRM((TB, "canceling an IRP."));

        //
        //  If the IRP is not being canceled.
        //
        if (setCancelResult != NULL) {
            //
            //  Fail the request.
            //
            pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        }

        //
        //  Get the next one.
        //
        RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
        pIrp = (PIRP)RDPEVNTLIST_DequeueRequest(
                                    UserModeEventListMgr,
                                    context->sessionID
                                    );
    }
    RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

    //
    //  Release our context.
    //
    delete context;
    irpStack->FileObject->FsContext = NULL;

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    ntStatus = Irp->IoStatus.Status;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return ntStatus;
}

NTSTATUS
RDPDYN_Cleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    Handle the cleanup IRP for a file object.

Arguments:

Return Value:

    NT status code

--*/
{
    NTSTATUS ntStatus;
    PFILE_OBJECT fileObject;
    PIO_STACK_LOCATION irpStack;
    PDEVMGRCONTEXT context;
    KIRQL oldIrql;
    PIRP pIrp;
    PDRIVER_CANCEL setCancelResult;

    BEGIN_FN("RDPDYN_Cleanup");

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    fileObject = irpStack->FileObject;

    // Grab our "open" context for this instance of us from the current stack
    // location's file object.
    context = (PDEVMGRCONTEXT)irpStack->FileObject->FsContext;
    TRC_ASSERT(context->magicNo == DEVMGRCONTEXTMAGICNO, (TB, "invalid context"));

    TRC_NRM((TB, "cancelling IRP's for session %ld.",
            context->sessionID));

    //
    //  Remove pending requests (IRP's)
    //  Nothing to do if event list is NULL
    //
    TRC_ASSERT(UserModeEventListMgr != NULL, (TB, "RdpDyn EventList is NULL"));
    
    if (UserModeEventListMgr == NULL) {
        goto CleanupAndExit;
    }
    
    RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
    pIrp = (PIRP)RDPEVNTLIST_DequeueRequest(
                                    UserModeEventListMgr,
                                    context->sessionID
                                    );
    while (pIrp != NULL) {

        //
        //  Set the cancel routine to NULL and record the current state.
        //
        setCancelResult = IoSetCancelRoutine(pIrp, NULL);

        RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

        TRC_NRM((TB, "canceling an IRP."));

        //
        //  If the IRP is not being canceled.
        //
        if (setCancelResult != NULL) {
            //
            //  Fail the request.
            //
            pIrp->IoStatus.Status = STATUS_CANCELLED;
            pIrp->IoStatus.Information = 0;
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        }

        //
        //  Get the next one.
        //
        RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
        pIrp = (PIRP)RDPEVNTLIST_DequeueRequest(
                                    UserModeEventListMgr,
                                    context->sessionID
                                    );
    }
    RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

CleanupAndExit:
    Irp->IoStatus.Status = STATUS_SUCCESS;
    ntStatus = Irp->IoStatus.Status;
    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT
                       );

    return ntStatus;
}

NTSTATUS
RDPDYN_DeviceControl(
    IN PDEVICE_OBJECT deviceObject,
    IN PIRP irp
    )
/*++

Routine Description:

    Handle IOCTL IRP's.

Arguments:

    DeviceObject - pointer to the device object for this printer.
    Irp          - the IRP.


Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION currentStackLocation;
    NTSTATUS ntStatus;
    ULONG controlCode;

    BEGIN_FN("RDPDYN_DeviceControl");

    // Get the current stack location.
    currentStackLocation = IoGetCurrentIrpStackLocation(irp);
    TRC_ASSERT(currentStackLocation != NULL, (TB, "Invalid stack location."));

    //
    //  Grab some info. out of the stack location.
    //
    controlCode  = currentStackLocation->Parameters.DeviceIoControl.IoControlCode;

    //
    //  Dispatch the IOCTL.
    //
    switch(controlCode)
    {
    case IOCTL_RDPDR_GETNEXTDEVMGMTEVENT    :

        ntStatus = RDPDYN_HandleGetNextDevMgmtEventIOCTL(deviceObject, irp);
        break;

    case IOCTL_RDPDR_CLIENTMSG              :

        ntStatus = RDPDYN_HandleClientMsgIOCTL(deviceObject, irp);
        break;

#if DBG
    case IOCTL_RDPDR_DBGADDNEWPRINTER       :

        // This is for testing so we can create a new test printer on
        // demand from user-mode.
        ntStatus = RDPDYN_HandleDbgAddNewPrnIOCTL(deviceObject, irp);
        break;

#endif

    default                                 :
        TRC_ASSERT(FALSE, (TB, "RPDR.SYS:Invalid IOCTL %08X.", controlCode));
        ntStatus = STATUS_INVALID_DEVICE_REQUEST;
        irp->IoStatus.Status = ntStatus;
        irp->IoStatus.Information = 0;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return ntStatus;
}

NTSTATUS
RDPDYN_HandleClientMsgIOCTL(
    IN PDEVICE_OBJECT deviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:

    Completely handles IOCTL_RDPDR_CLIENTMSG IRP's.

Arguments:

    DeviceObject - pointer to our device object.
    currentStackLocation - current location on the IRP stack.

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION currentStackLocation;
    PDEVMGRCONTEXT context;
    NTSTATUS ntStatus;
    ULONG inputLength;

    BEGIN_FN("RDPDYN_HandleClientMsgIOCTL");

    //
    //  Get the current stack location.
    //
    currentStackLocation = IoGetCurrentIrpStackLocation(pIrp);
    TRC_ASSERT(currentStackLocation != NULL, (TB, "Invalid stack location."));

    //
    //  Grab our "open" context for this instance of use from the current stack
    //  location's file object.
    //
    context = (PDEVMGRCONTEXT)currentStackLocation->FileObject->FsContext;

    TRC_NRM((TB, "Requestor session ID %d.", 
            context->sessionID ));

    TRC_ASSERT(context->magicNo == DEVMGRCONTEXTMAGICNO, (TB, "invalid context"));

    //
    //  Grab some information about the user-mode's buffer off the IRP stack.
    //
    inputLength  = currentStackLocation->Parameters.DeviceIoControl.InputBufferLength;

    //
    //  Send the message to the client.
    //
    ntStatus = DrSendMessageToSession(
                            context->sessionID,
                            pIrp->AssociatedIrp.SystemBuffer,
                            inputLength,
                            NULL, NULL
                            );
    if (ntStatus != STATUS_SUCCESS) {
        TRC_ERR((TB, "msg failed."));

        // Fail the IRP request.
        pIrp->IoStatus.Status = ntStatus;
    }
    else {
        TRC_ERR((TB, "msg succeeded."));

        pIrp->IoStatus.Status = STATUS_SUCCESS;
        pIrp->IoStatus.Information = 0;
    }
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return ntStatus;
}

VOID DevMgmtEventRequestIRPCancel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    IRP cancel routine that is attached to device mgmt event request IRP's.
    This routine is called with the cancel spinlock held.

Arguments:

    DeviceObject - pointer to our device object.
    pIrp - The IRP.

Return Value:

    NA

--*/
{
    PIO_STACK_LOCATION currentStackLocation;
    KIRQL oldIrql;
    ULONG sessionID;
    PDEVMGRCONTEXT context;

    BEGIN_FN("DevMgmtEventRequestIRPCancel");

    //
    //  Get the current stack location.
    //
    currentStackLocation = IoGetCurrentIrpStackLocation(Irp);
    TRC_ASSERT(currentStackLocation != NULL, (TB, "Invalid stack location."));

    //
    //  Grab our "open" context for this instance of use from the current stack
    //  location's file object.
    //
    context = (PDEVMGRCONTEXT)currentStackLocation->FileObject->FsContext;

    //
    //  Grab the session ID.
    //
    sessionID = context->sessionID;
    TRC_NRM((TB, "session ID %d.", sessionID));
    TRC_ASSERT(context->magicNo == DEVMGRCONTEXTMAGICNO, (TB, "invalid context"));

    //
    //  Wax the current cancel routine pointer.
    //
    IoSetCancelRoutine(Irp, NULL);

    //
    //  Release the IRP cancellation spinlock.
    //
    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    //  Remove the request from the device management list.
    //
    RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
    RDPEVNTLIST_DequeueSpecificRequest(UserModeEventListMgr, sessionID, Irp);
    RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

    //
    //  Complete the IRP.
    //
    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_CANCELLED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    TRC_NRM((TB, "DevMgmtEventRequestIRPCancel exiting."));
}

NTSTATUS
RDPDYN_HandleGetNextDevMgmtEventIOCTL(
    IN PDEVICE_OBJECT deviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:

    Completely handles IOCTL_RDPDR_GETNEXTDEVMGMTEVENT IRP's.

Arguments:

    DeviceObject - pointer to our device object.
    pIrp - The IRP.

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION currentStackLocation;
    NTSTATUS status;
    ULONG outputLength;
    PDEVMGRCONTEXT context;
    ULONG evType;
    PVOID evt;
    DrDevice *drDevice;
    KIRQL oldIrql;
    ULONG sessionID;
    ULONG eventSize;
    ULONG requiredUserBufSize;

    BEGIN_FN("RDPDYN_HandleGetNextDevMgmtEventIOCTL");

    //
    //  Get the current stack location.
    //
    currentStackLocation = IoGetCurrentIrpStackLocation(pIrp);
    TRC_ASSERT(currentStackLocation != NULL, (TB, "Invalid stack location."));

    //
    //  Grab our "open" context for this instance of use from the current stack
    //  location's file object.
    //
    context = (PDEVMGRCONTEXT)currentStackLocation->FileObject->FsContext;

    //
    //  Grab the session ID.
    //
    sessionID = context->sessionID;

    TRC_NRM((TB, "Requestor session ID %d.", context->sessionID ));

    TRC_ASSERT(context->magicNo == DEVMGRCONTEXTMAGICNO, (TB, "invalid context"));

    // Grab some information about the user-mode's buffer off the IRP stack.
    outputLength = currentStackLocation->Parameters.DeviceIoControl.OutputBufferLength;

    TRC_ASSERT(UserModeEventListMgr != NULL, (TB, "RdpDyn EventList is NULL"));
    //
    //  Lock the device management event list.
    //
    RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);

    //
    //  See if we have a "device mgmt event pending."
    //
    if (RDPEVNTLIST_PeekNextEvent(
                        UserModeEventListMgr,
                        sessionID, &evt,
                        &evType, &drDevice
                        )) {
        //
        //  If the pending IRP's pending buffer is large enough for the
        //  next event.
        //
        eventSize = RDPDYN_DevMgmtEventSize(evt, evType);
        requiredUserBufSize = eventSize + sizeof(RDPDRDVMGR_EVENTHEADER);
        if (outputLength >= requiredUserBufSize) {
            //
            //  Dequeue the next pending event.  This better be the one
            //  we just peeked at.
            //
            RDPEVNTLIST_DequeueEvent(
                            UserModeEventListMgr,
                            sessionID, &evType,
                            &evt, NULL
                            );

            //
            //  It's safe to unlock the device management event list now.
            //
            RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

            //
            //  Complete the pending IRP.
            //
            status = CompleteIRPWithDevMgmtEvent(
                                        deviceObject,
                                        pIrp, eventSize,
                                        evType, evt, drDevice
                                        );

            //
            //  Release the event.
            //
            if (evt != NULL) {
                delete evt;
                evt = NULL;
            }

            //
            //  Release our reference to the device, if we own one.
            //
            if (drDevice != NULL) {
                drDevice->Release();
            }
        }
        //
        //  Otherwise, need to send a resize buffer message to the
        //  user-mode copmonent.
        //
        else {
            //
            //  It's safe to unlock the device management event list now.
            //
            RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

            //
            //  Complete the IRP.
            //
            status = CompleteIRPWithResizeMsg(pIrp, requiredUserBufSize);
        }
    }
    //
    //  Otherwise, queue the IRP, mark the IRP pending and return.
    //
    else {
        //
        //  Queue the request.
        //
        status = RDPEVNTLIST_EnqueueRequest(UserModeEventListMgr,
                                            context->sessionID, pIrp);
        //
        //  Set the cancel routine for the pending IRP.
        //
        if (status == STATUS_SUCCESS) {
            IoMarkIrpPending(pIrp);
            IoSetCancelRoutine(pIrp, DevMgmtEventRequestIRPCancel);
            status = STATUS_PENDING;
        }
        else {
            // Fail the IRP request.
            pIrp->IoStatus.Status = status;
            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
        }

        //
        //  It's safe to unlock the device management event list now.
        //
        RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);
    }

    return status;
}

void
RDPDYN_SessionConnected(
    IN  ULONG   sessionID
    )
/*++

Routine Description:

    This function is called when a new session is connected.

Arguments:

    sessionID   -   Identifier for removed session.

Return Value:

    None.

--*/
{
#if DBG
    BOOL result;
    PVOID evt;
    DrDevice *drDevice;
    KIRQL oldIrql;
    ULONG evType;
#endif

    BEGIN_FN("RDPDYN_SessionConnected");
    TRC_NRM((TB, "Session %ld.", sessionID));
    //
    //  Nothing to do if the event list is NULL
    //
    TRC_ASSERT(UserModeEventListMgr != NULL, (TB, "RdpDyn EventList is NULL"));
    
    if (UserModeEventListMgr == NULL) {
        goto CleanupAndExit;
    }
#if DBG
    //
    //  See if there is still an event in the queue.  Really, we should be checking
    //  to see if there is more than one event in the queue.  This will catch most
    //  problems with events not gettin cleaned up on session disconnect.
    //
    RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
    result = RDPEVNTLIST_PeekNextEvent(
                            UserModeEventListMgr,
                            sessionID, &evt, &evType,
                            &drDevice);
    RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

    //
    //  The only pending event allowed in the queue, at this point, is
    //  a remove client device event.  RDPDYN_SessionDisconnected discards
    //  all other events.
    //
    if (result) {
        TRC_ASSERT(evType == RDPDREVT_SESSIONDISCONNECT,
            (TB, "Pending non-remove events %x on session connect.", evType));
    }
#endif
CleanupAndExit:
    return;
}

void
RDPDYN_SessionDisconnected(
    IN  ULONG   sessionID
    )
/*++

Routine Description:

    This function is called when a session is disconnected from the system.

Arguments:

    sessionID   -   Identifier for removed session.

Return Value:

    None.

--*/
{
    void *devMgmtEvent;
    ULONG type;
    BOOL queued;
    KIRQL oldIrql;
    DrDevice *device;

    BEGIN_FN("RDPDYN_SessionDisconnected");
    TRC_NRM((TB, "Session %ld.", sessionID));

    //
    //  Remove all pending device management events for this session.
    //  Nothing to do if the event list is NULL
    //
    TRC_ASSERT(UserModeEventListMgr != NULL, (TB, "RdpDyn EventList is NULL"));
    
    if (UserModeEventListMgr == NULL) {
        goto CleanupAndExit;
    }
    
    RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
    while (RDPEVNTLIST_DequeueEvent(
                    UserModeEventListMgr,
                    sessionID, &type, &devMgmtEvent,
                    &device
                    )) {

        RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

        if (devMgmtEvent != NULL) {
            delete devMgmtEvent;
        }
        if (device != NULL) {
            device->Release();
        }
        RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
    }
    RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

    //
    //  Dispatch a "session disconnect" event for the session to let user
    //  mode know about the event.
    //
    RDPDYN_DispatchNewDevMgmtEvent(
                        NULL, sessionID,
                        RDPDREVT_SESSIONDISCONNECT,
                        NULL
                        );
CleanupAndExit:
    return;
}

PIRP
GetNextEventRequest(
    IN RDPEVNTLIST list,
    IN ULONG sessionID
    )
/*++

Routine Description:

    Returns the next pending device management event request for the specified
    session, in the form of an IRP.  Note that this function can not be called
    if a spinlock has been acquired.

Arguments:

    list            -   Device Management Event and Requeust List
    sessionID       -   Destination session ID for event.

Return Value:

    The next pending request (IRP) for the specified session or NULL if there are
    not any IRP's pending.

--*/
{
    PIRP pIrp;
    KIRQL oldIrql;
    BOOL done;
    PDRIVER_CANCEL setCancelResult;

    BEGIN_FN("GetNextEventRequest");
    //
    //  Loop until we get an IRP that is not currently being cancelled.
    //
    done = FALSE;
    setCancelResult = NULL;
    while (!done) {

        //
        //  Dequeue an IRP and take it out of a cancellable state.
        //
        RDPEVNTLIST_Lock(list, &oldIrql);
        pIrp = (PIRP)RDPEVNTLIST_DequeueRequest(list, sessionID);
        if (pIrp != NULL) {
            setCancelResult = IoSetCancelRoutine(pIrp, NULL);
        }
        RDPEVNTLIST_Unlock(list, oldIrql);

        done = (pIrp == NULL) || (setCancelResult != NULL);
    }

    return pIrp;
}

NTSTATUS
RDPDYN_DispatchNewDevMgmtEvent(
    IN PVOID devMgmtEvent,
    IN ULONG sessionID,
    IN ULONG eventType,
    OPTIONAL IN DrDevice *devDevice
    )
/*++

Routine Description:

    Dispatch a device management event to the appropriate (session-wise) user-mode
    device manager component.  If there are not any event request IRP's pending
    for the specified session, then the event is queued for future dispatch.

Arguments:

    devMgmtEvent    -   The event.
    sessionID       -   Destination session ID for event.
    eventType       -   Type of event.
    queued          -   TRUE if the event was queued for future dispatch.
    devDevice       -   Device object associated with the event.  NULL, if not
                        specified.

Return Value:

    STATUS_SUCCESS if successful, error status otherwise.

--*/
{
    PIRP pIrp;
    NTSTATUS status;
    KIRQL oldIrql;
    PIO_STACK_LOCATION currentStackLocation;
    ULONG outputLength;
    ULONG eventSize;
    ULONG requiredUserBufSize;
    DrDevice *drDevice = NULL;
    PVOID evt;
    ULONG evType;

    BEGIN_FN("RDPDYN_DispatchNewDevMgmtEvent");

    //
    //  Nothing to do if the event list is NULL
    //
    TRC_ASSERT(UserModeEventListMgr != NULL, (TB, "RdpDyn EventList is NULL"));
    
    if (UserModeEventListMgr == NULL) {
        return STATUS_INVALID_DEVICE_STATE;
    }

    //
    //  Ref count the device, if provided.
    //
    if (devDevice != NULL) {
        devDevice->AddRef();
    }
    //
    //  Enqueue the new event.
    //  
    RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
    status = RDPEVNTLIST_EnqueueEvent(
                        UserModeEventListMgr,
                        sessionID,
                        devMgmtEvent,
                        eventType,
                        devDevice
                        );

    RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

    //
    //  If we have an IRP pending for the specified session.
    //
    if (status == STATUS_SUCCESS) {
        pIrp = GetNextEventRequest(UserModeEventListMgr, sessionID);
    }
    else {
        if (devDevice != NULL) {
            devDevice->Release();
        }
    }
    
    if ((status == STATUS_SUCCESS) && (pIrp != NULL)) {
        TRC_NRM((TB, "found an IRP pending for "
                "session %ld", sessionID));

        //
        //  Find out about the pending IRP.
        //
        currentStackLocation = IoGetCurrentIrpStackLocation(pIrp);
        TRC_ASSERT(currentStackLocation != NULL, (TB, "Invalid stack location."));
        outputLength =
            currentStackLocation->Parameters.DeviceIoControl.OutputBufferLength;

        //
        //  If we have a pending event.
        //
        RDPEVNTLIST_Lock(UserModeEventListMgr, &oldIrql);
        if (RDPEVNTLIST_PeekNextEvent(
                            UserModeEventListMgr,
                            sessionID, &evt, &evType,
                            &drDevice
                            )) {
            //
            //  If the pending IRP's pending buffer is large enough for the
            //  next event.
            //
            eventSize = RDPDYN_DevMgmtEventSize(evt, evType);
            requiredUserBufSize = eventSize + sizeof(RDPDRDVMGR_EVENTHEADER);
            if (outputLength >= requiredUserBufSize) {
                //
                //  Dequeue the next pending event.  This better be the one
                //  we just peeked at.
                //
                RDPEVNTLIST_DequeueEvent(
                                UserModeEventListMgr,
                                sessionID, &evType,
                                &evt, NULL
                                );

                RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

                //
                //  Complete the pending IRP.
                //
                status = CompleteIRPWithDevMgmtEvent(
                                                RDPDYN_PDO, pIrp, eventSize,
                                                evType, evt,
                                                drDevice
                                                );

                //
                //  Release the event.
                //
                if (evt != NULL) {
                    delete evt;
                    evt = NULL;
                }

                //
                //  Release our reference to the device, if we own one.
                //
                if (drDevice != NULL) {
                    drDevice->Release();
                }                

            }
            //
            //  Otherwise, need to send a resize buffer message to the
            //  user-mode component.
            //
            else {
                RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

                //
                //  Complete the IRP.
                //
                status = CompleteIRPWithResizeMsg(pIrp, requiredUserBufSize);
            }
        }
        //
        //  Otherwise, we need to requeue the IRP request.
        //
        else {
            
            status = RDPEVNTLIST_EnqueueRequest(UserModeEventListMgr,
                                                sessionID, pIrp);

            RDPEVNTLIST_Unlock(UserModeEventListMgr, oldIrql);

            //
            //  If we fail here, we need to fail the IRP.
            //
            if (status != STATUS_SUCCESS) {
                pIrp->IoStatus.Status = status;
                pIrp->IoStatus.Information = 0;
                IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            }
        }
    }

    TRC_NRM((TB, "exit RDPDYN_DispatchNewDevMgmtEvent"));
    return status;
}

ULONG
RDPDYN_DevMgmtEventSize(
    IN PVOID devMgmtEvent,
    IN ULONG type
    )
/*++

Routine Description:

    Calculate the size of a device management event.  This is more efficient than
    storing the size with each event.

Arguments:

    devMgmtEvent - Supplies the device object for the packet being processed.

    type - Supplies the Irp being processed

Return Value:

    The size, in bytes, of the event.

--*/
{
    ULONG sz = 0;

    BEGIN_FN("RDPDYN_DevMgmtEventSize");
    switch(type) {
    case RDPDREVT_PRINTERANNOUNCE :
        sz = CALCPRINTERDEVICE_SUB_SZ((PRDPDR_PRINTERDEVICE_SUB)devMgmtEvent);
        break;
    case RDPDREVT_REMOVEDEVICE  :
        sz = CALCREMOVEDEVICE_SUB_SZ((PRDPDR_REMOVEDEVICE)devMgmtEvent);
        break;
    case RDPDREVT_PORTANNOUNCE  :
        sz = CALCPORTDEVICE_SUB_SZ((PRDPDR_PORTDEVICE_SUB)devMgmtEvent);
        break;
    case RDPDREVT_DRIVEANNOUNCE  :
        sz = CALCDRIVEDEVICE_SUB_SZ((PRDPDR_DRIVEDEVICE_SUB)devMgmtEvent);
        break;

    case RDPDREVT_SESSIONDISCONNECT :
        //  There is no associated event data.
        sz = 0;
        break;
    default:
        TRC_ASSERT(FALSE, (TB, "Invalid event type"));
    }
    return sz;
}

NTSTATUS CompleteIRPWithDevMgmtEvent(
    IN PDEVICE_OBJECT deviceObject,
    IN PIRP      pIrp,
    IN ULONG     eventSize,
    IN ULONG     eventType,
    IN PVOID     event,
    IN DrDevice *drDevice
    )
/*++

Routine Description:

    Complete a pending IRP with a device management event.

Arguments:

    deviceObject-   Associated Device Object.  Must be non-NULL if
                    drDevice is non-NULL.
    pIrp        -   Pending IRP.
    eventSize   -   Size of event being returned.
    eventType   -   Event type being returned.
    event       -   The event being returned.
    drDevice    -   Device object associated with the IRP.

Return Value:

    STATUS_SUCCESS on success.

--*/
{
    PRDPDRDVMGR_EVENTHEADER msgHeader;
    ULONG bytesReturned;
    void *usrDevMgmtEvent;
    NTSTATUS status;

    BEGIN_FN("CompleteIRPWithDevMgmtEvent");

    //
    //  Optional last-minute event completion.
    //
    if (drDevice != NULL) {
        status = drDevice->OnDevMgmtEventCompletion(deviceObject, event);
    }
    else {
        status = STATUS_SUCCESS;
    }

    //
    //  Compute the size of the return buffer.
    //
    bytesReturned = eventSize + sizeof(RDPDRDVMGR_EVENTHEADER);

    //
    //  Create the message header.
    //
    msgHeader = (PRDPDRDVMGR_EVENTHEADER)pIrp->AssociatedIrp.SystemBuffer;
    msgHeader->EventType   = eventType;
    msgHeader->EventLength = eventSize;

    //
    //  Copy the device mgmt event over to the user-mode buffer.
    //
    usrDevMgmtEvent = ((PBYTE)pIrp->AssociatedIrp.SystemBuffer +
                    sizeof(RDPDRDVMGR_EVENTHEADER));
    if (event != NULL && eventSize > 0) {
        RtlCopyMemory(usrDevMgmtEvent, event, eventSize);
    }
    status = STATUS_SUCCESS;

    pIrp->IoStatus.Status = status;
    pIrp->IoStatus.Information = bytesReturned;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    TRC_NRM((TB, "exit CompleteIRPWithDevMgmtEvent"));

    return status;
}

NTSTATUS
CompleteIRPWithResizeMsg(
    IN  PIRP pIrp,
    IN  ULONG requiredUserBufSize
    )
/*++

Routine Description:

    Complete a pending IRP with a resize buffer event to the user-mode
    component.

Return Value:

    STATUS_SUCCESS is returned on success.

--*/
{
    PIO_STACK_LOCATION currentStackLocation;
    ULONG outputLength;
    PRDPDR_BUFFERTOOSMALL bufTooSmallMsg;
    PRDPDRDVMGR_EVENTHEADER msgHeader;
    ULONG bytesReturned;
    NTSTATUS status;

    BEGIN_FN("CompleteIRPWithResizeMsg");

    // Get the current stack location.
    currentStackLocation = IoGetCurrentIrpStackLocation(pIrp);
    TRC_ASSERT(currentStackLocation != NULL, (TB, "Invalid stack location."));

    // Grab some stuff off the IRP stack.
    outputLength = currentStackLocation->Parameters.DeviceIoControl.OutputBufferLength;

    //
    //  Fail the request if there isn't room for a buffer too small
    //  message.
    //
    if (outputLength < (sizeof(RDPDRDVMGR_EVENTHEADER) +
                        sizeof(RDPDR_BUFFERTOOSMALL))) {

        TRC_NRM((TB, "CompleteIRPWithResizeMsg no room for header."));

        bytesReturned = 0;
        status = STATUS_INVALID_BUFFER_SIZE;
    }
    else {
        // Create the header.
        msgHeader = (PRDPDRDVMGR_EVENTHEADER)pIrp->AssociatedIrp.SystemBuffer;
        msgHeader->EventType   = RDPDREVT_BUFFERTOOSMALL;
        msgHeader->EventLength = sizeof(RDPDR_BUFFERTOOSMALL);

        // Create the buffer too small message.
        bufTooSmallMsg = (PRDPDR_BUFFERTOOSMALL)
                            ((PBYTE)pIrp->AssociatedIrp.SystemBuffer +
                            sizeof(RDPDRDVMGR_EVENTHEADER));
        bufTooSmallMsg->RequiredSize = requiredUserBufSize;

        // Calculate the number of bytes that we are returning.
        bytesReturned = sizeof(RDPDRDVMGR_EVENTHEADER) +
                        sizeof(RDPDR_BUFFERTOOSMALL);

        status = STATUS_SUCCESS;
    }

    //
    //  Complete the IRP.
    //
    pIrp->IoStatus.Status = status;
    pIrp->IoStatus.Information = bytesReturned;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    TRC_NRM((TB, "exit CompleteIRPWithResizeMsg"));

    return status;
}

NTSTATUS
DrSendMessageToSession(
    IN ULONG SessionId,
    IN PVOID Msg,
    IN DWORD MsgSize,
    OPTIONAL IN RDPDR_ClientMessageCB CB,
    OPTIONAL IN PVOID ClientData
    )
/*++

Routine Description:

    Send a message to the client with the specified session ID.

Arguments:

    SessionId   - The session id.
    Msg         - The Message
    MsgSize     - Size (in bytes) of message.
    CB          - Optional callback to be called when the message is completely 
                  sent.
    ClientData  - Optional client-data passed to callback when message is 
                  completely sent.

Return Value:

    NTSTATUS - Success/failure indication of the operation

Notes:

--*/
{
    NTSTATUS Status;
    SmartPtr<DrSession> Session;
    PCLIENTMESSAGECONTEXT Context;

    BEGIN_FN("DrSendMessageToSession");

    //
    //  Find the client entry.
    //

    if (Sessions->FindSessionById(SessionId, Session)) {
        //
        //  Allocate the context for the function call.
        //
        Context = new CLIENTMESSAGECONTEXT;

        if (Context != NULL) {

            TRC_NRM((TB, "sending %ld bytes to server", MsgSize));

            //
            //  Set up the context.
            //
            Context->CB = CB;
            Context->ClientData  = ClientData;
            Status = Session->SendToClient(Msg, MsgSize, 
                    DrSendMessageToClientCompletion, FALSE, FALSE, Context);
        } else {
            TRC_ERR((TB, "unable to allocate memory."));
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {
        Status = STATUS_NOT_FOUND;
    }

    return Status;
}

NTSTATUS NTAPI DrSendMessageToClientCompletion(PVOID Context, 
        PIO_STATUS_BLOCK IoStatusBlock)
/*++

Routine Description:

    IoCompletion APC routine for DrSendMessageToClient.

Arguments:

    ApcContext - Contains a pointer to the client message context.
    IoStatusBlock - Status information about the operation. The Information
            indicates the actual number of bytes written
    Reserved - Reserved

Return Value:

    None

--*/
{
    PCLIENTMESSAGECONTEXT MsgContext = (PCLIENTMESSAGECONTEXT)Context;

    BEGIN_FN("DrSendMessageToClientCompletion");

    TRC_ASSERT(MsgContext != NULL, (TB, "Message context NULL."));
    TRC_ASSERT(IoStatusBlock != NULL, (TB, "IoStatusBlock NULL."));

    TRC_NRM((TB, "status %lx", IoStatusBlock->Status));

    //
    //  Call the client callback if it is defined.
    //
    if (MsgContext->CB != NULL) {
        MsgContext->CB(MsgContext->ClientData, IoStatusBlock->Status);
    }

    //
    //  Clean up.
    //

//    delete IoStatusBlock; // I don't think so, not really
    delete Context;
    return STATUS_SUCCESS;
}

/*++

Routine Description:

    Generates a printer announce message for testing.

Return Value:

    STATUS_INVALID_BUFFER_SIZE is returned if the prnAnnounceEventSize size is
    too small.  STATUS_SUCCESS is returned on success.

--*/

#if DBG
void
RDPDYN_TracePrintAnnounceMsg(
    IN OUT PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg,
    IN ULONG sessionID,
    IN PCWSTR portName,
    IN PCWSTR clientName
    )
/*++

Routine Description:

      Trace a printer device announce message.

Return Value:

--*/
{
    PWSTR driverName, printerName;
    PWSTR pnpName;
    PRDPDR_PRINTERDEVICE_ANNOUNCE clientPrinterFields;
    PBYTE pClientPrinterData;
    ULONG sz;

    BEGIN_FN("RDPDYN_TracePrintAnnounceMsg");

    // Check the type.
    TRC_ASSERT(devAnnounceMsg->DeviceType == RDPDR_DTYP_PRINT,
            (TB, "Invalid device type"));

    // Get the address of all data following the base message.
    pClientPrinterData = ((PBYTE)devAnnounceMsg) +
                        sizeof(RDPDR_DEVICE_ANNOUNCE) +
                        sizeof(RDPDR_PRINTERDEVICE_ANNOUNCE);

    // Get the address of the client printer fields.
    clientPrinterFields = (PRDPDR_PRINTERDEVICE_ANNOUNCE)(((PBYTE)devAnnounceMsg) +
                           sizeof(RDPDR_DEVICE_ANNOUNCE));

    sz = clientPrinterFields->PnPNameLen +
         clientPrinterFields->DriverLen +
         clientPrinterFields->PrinterNameLen +
         clientPrinterFields->CachedFieldsLen +
         sizeof(RDPDR_PRINTERDEVICE_ANNOUNCE);

    if (devAnnounceMsg->DeviceDataLength != sz) {
        TRC_ASSERT(FALSE,(TB, "Size integrity questionable in dev announce buf."));
    }
    else {

        // Get the specific fields.
        pnpName     = (PWSTR)((clientPrinterFields->PnPNameLen) ? pClientPrinterData : NULL);
        driverName  = (PWSTR)((clientPrinterFields->DriverLen) ?
            (pClientPrinterData + clientPrinterFields->PnPNameLen) : NULL);
        printerName = (PWSTR)((clientPrinterFields->PrinterNameLen) ? (pClientPrinterData +
            clientPrinterFields->PnPNameLen +
            clientPrinterFields->DriverLen) : NULL);
        
        TRC_NRM((TB, "New printer received for session %ld.", sessionID));
        TRC_NRM((TB, "-----------------------------------------"));
        TRC_NRM((TB, "port:\t%ws", portName));

        if (clientPrinterFields->Flags & RDPDR_PRINTER_ANNOUNCE_FLAG_ANSI) {
            TRC_NRM((TB, "driver:\t%s", (PSTR)driverName));
            TRC_NRM((TB, "pnp name:\t%s", (PSTR)pnpName));
            TRC_NRM((TB, "printer name:\t%s", (PSTR)printerName));
        }
        else {
            TRC_NRM((TB, "driver:\t%ws", driverName));
            TRC_NRM((TB, "pnp name:\t%ws", pnpName));
            TRC_NRM((TB, "printer name:\t%ws", printerName));
        }

        TRC_NRM((TB, "client name:\t%ws", clientName));
        TRC_NRM((TB, "-----------------------------------------"));
        
        TRC_NRM((TB, "exit RDPDYN_TracePrintAnnounceMsg"));
    }
}

NTSTATUS
RDPDYN_GenerateTestPrintAnnounceMsg(
    IN OUT  PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg,
    IN      ULONG devAnnounceMsgSize,
    OPTIONAL OUT ULONG *prnAnnounceMsgReqSize
    )
/*++

Routine Description:

      Generates a printer announce message for testing.

Return Value:

    STATUS_INVALID_BUFFER_SIZE is returned if the prnAnnounceMsgSize size is
    too small.  STATUS_SUCCESS is returned on success.

--*/
{
    ULONG requiredSize;
    PBYTE pClientPrinterData;
    PWSTR driverName, printerName;
    PWSTR pnpName;
    PRDPDR_PRINTERDEVICE_ANNOUNCE prnMsg;
    PRDPDR_PRINTERDEVICE_ANNOUNCE clientPrinterFields;
    PBYTE pCachedFields;

    BEGIN_FN("RDPDYN_GenerateTestPrintAnnounceMsg");
    requiredSize = (ULONG)(sizeof(RDPDR_DEVICE_ANNOUNCE) +
                         sizeof(RDPDR_PRINTERDEVICE_ANNOUNCE) +
                         ((wcslen(TESTDRIVERNAME) + 1) * sizeof(WCHAR)) +
                         ((wcslen(TESTPNPNAME) + 1) * sizeof(WCHAR)) +
                         ((wcslen(TESTPRINTERNAME) + 1) * sizeof(WCHAR)));

    //
    //  Find out if there isn't room in the return buffer for our response.
    //
    if (devAnnounceMsgSize < requiredSize) {
        if (prnAnnounceMsgReqSize != NULL) {
            *prnAnnounceMsgReqSize = requiredSize;
        }
        return STATUS_BUFFER_TOO_SMALL;
    }

    // Type
    devAnnounceMsg->DeviceType = RDPDR_DTYP_PRINT;

    // ID
    devAnnounceMsg->DeviceId = TESTDEVICEID;

    // Get the address of the client printer fields in the device announce
    // message.
    clientPrinterFields = (PRDPDR_PRINTERDEVICE_ANNOUNCE)(((PBYTE)devAnnounceMsg) +
                           sizeof(RDPDR_DEVICE_ANNOUNCE));

    // Get the address of all data following the base message.
    pClientPrinterData = ((PBYTE)devAnnounceMsg) +
                        sizeof(RDPDR_DEVICE_ANNOUNCE) +
                        sizeof(RDPDR_PRINTERDEVICE_ANNOUNCE);

    //
    //  Add the PnP Name.
    //
    // The PnP name is the first field.
    pnpName = (PWSTR)pClientPrinterData;
    wcscpy(pnpName, TESTPNPNAME);
    clientPrinterFields->PnPNameLen = ((wcslen(TESTPNPNAME) + 1) * sizeof(WCHAR));

    //
    //  Add the Driver Name.
    //
    // The driver name is the second field.
    driverName = (PWSTR)(pClientPrinterData + clientPrinterFields->PnPNameLen);
    wcscpy(driverName, TESTDRIVERNAME);
    clientPrinterFields->DriverLen = ((wcslen(TESTDRIVERNAME) + 1) * sizeof(WCHAR));

    //
    //  Add the Printer Name.
    //
    // The driver name is the second field.
    printerName = (PWSTR)(pClientPrinterData +
                          clientPrinterFields->PnPNameLen +
                          clientPrinterFields->DriverLen);
    wcscpy(printerName, TESTPRINTERNAME);
    clientPrinterFields->PrinterNameLen = ((wcslen(TESTPRINTERNAME) + 1) * sizeof(WCHAR));

    //
    //  Add the Cached Fields Len.
    //
    // The cached fields follow everything else.

/*  Don't need this for testing, yet.
    pCachedFields = (PBYTE)(pClientPrinterData + clientPrinterFields->PnPNameLen +
                           clientPrinterFields->DriverLen +
                           clientPrinterFields->PrinterNameLen);
*/
    clientPrinterFields->CachedFieldsLen = 0;

    //
    //  Set to non-ansi for now.
    //
    clientPrinterFields->Flags = 0;


    // Length of all data following deviceFields.
    devAnnounceMsg->DeviceDataLength =
                sizeof(RDPDR_PRINTERDEVICE_ANNOUNCE) +
                clientPrinterFields->PnPNameLen +
                clientPrinterFields->DriverLen +
                clientPrinterFields->PrinterNameLen +
                clientPrinterFields->CachedFieldsLen;

    if (prnAnnounceMsgReqSize != NULL) {
        *prnAnnounceMsgReqSize = requiredSize;
    }

    return STATUS_SUCCESS;
}

#endif

#if DBG
NTSTATUS
RDPDYN_HandleDbgAddNewPrnIOCTL(
    IN PDEVICE_OBJECT deviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This is for testing so we can create a new test printer on
    demand from user-mode.

Arguments:

    DeviceObject - pointer to our device object.
    currentStackLocation - current location on the IRP stack.

Return Value:

    NT status code

--*/
{
    PRDPDR_DEVICE_ANNOUNCE pDevAnnounceMsg;
    ULONG bytesToAlloc;
    PIO_STACK_LOCATION currentStackLocation;
    ULONG requiredSize;
    ULONG bytesReturned = 0;
    PDEVMGRCONTEXT context;
    NTSTATUS ntStatus;
    WCHAR buffer[64]=L"Test Printer";
    UNICODE_STRING referenceString;
    PBYTE tmp;

    BEGIN_FN("RDPDYN_HandleDbgAddNewPrnIOCTL");

    // Get the current stack location.
    currentStackLocation = IoGetCurrentIrpStackLocation(pIrp);
    TRC_ASSERT(currentStackLocation != NULL, (TB, "Invalid stack location."));

    // Grab our "open" context for this instance of us from the current stack
    // location's file object.
    context = (PDEVMGRCONTEXT)currentStackLocation->FileObject->FsContext;
    TRC_ASSERT(context->magicNo == DEVMGRCONTEXTMAGICNO,
              (TB, "invalid context"));

    // Find out how much room we need for the test message.
    RDPDYN_GenerateTestPrintAnnounceMsg(NULL, 0, &requiredSize);

    // Generate the message.
    pDevAnnounceMsg = (PRDPDR_DEVICE_ANNOUNCE)new(NonPagedPool) BYTE[requiredSize];
    if (pDevAnnounceMsg != NULL) {
        RDPDYN_GenerateTestPrintAnnounceMsg(pDevAnnounceMsg, requiredSize, &requiredSize);
    
        //
        //  Announce the new port (just send to session 0 for now).
        //
        RtlInitUnicodeString(&referenceString, buffer);
    
        //#pragma message(__LOC__"Unit test to add device disabled") 
        /*
        //
        //  Initialize the client entry struct.
        //
        RtlZeroMemory(&clientEntry, sizeof(clientEntry));
        wcscpy(clientEntry.ClientName, L"DBGTEST");
        clientEntry.SessionId = 0;
    
        // Note that I am ignoring the returned device data for this test.
        // This is okay, since I never call RDPDYN_RemoveClientDevice(
        ntStatus = RDPDYN_AddClientDevice(
                                    &clientEntry,
                                pDevAnnounceMsg,
                                &referenceString,
                                &tmp
                                );
        */
        // For a test, delete the device next.
        //    RDPDYN_RemoveClientDevice(TESTDEVICEID, 0, tmp);

        ntStatus = STATUS_SUCCESS;
    }
    else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    pIrp->IoStatus.Status = ntStatus;
    pIrp->IoStatus.Information = 0;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);

    return ntStatus;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\rdpdrpnp.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    rdpdrpnp.c

Abstract:

    This module includes routines for handling PnP and IO manager related IRP's
    for RDP device redirection.

    Don't forget to clean up the device object and the symbol link when
    our driver is unloaded.

    We should probably not expose a Win32 symbolic link.  This might be a
    security issue ... If this is the case, then I will have to do a better
    job of researching overlapped I/O with NtCreateFile vs. CreateFile.

    Need a check in IRP_MJ_CREATE to make sure that we are not being opened
    2x by the same session.  This shouldn't be allowed.

    We may need to completely lock out access to the IRP queue on a cancel
    request.

    Where can I safely use PAGEDPOOL instead of NONPAGEDPOOL.

    Make sure that we handle opens and all subsequent IRP's from bogus
    user-mode apps.

Author:

    tadb

Revision History:
--*/

#include "precomp.hxx"
#define TRC_FILE "rdpdrpnp"
#include "trc.h"

#define DRIVER

#include "cfg.h"
#include "pnp.h"
#include "stdarg.h"
#include "stdio.h"



///////////////////////////////////////////////////////////////////////////////////////
//
//   Local Prototypes
//

// This routine is called when the lower level driver completes an IRP.
NTSTATUS RDPDR_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

// Adjust the dacl on the rdpdyn device object
NTSTATUS AdjustSecurityDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength);

//
// Externals. We cannot include ob.h or ntosp.h 
// as it causes tons of conflicts.
//

extern "C" {
NTSYSAPI
NTSTATUS
NTAPI
RtlDeleteAce (
    PACL Acl,
    ULONG AceIndex
    );
}    

///////////////////////////////////////////////////////////////////////////////////////
//
//   Globals
//

// Unique Port Name Counter defined in rdpdyn.c.
extern ULONG LastPortNumberUsed;

// The Physical Device Object that terminates our DO stack.
extern PDEVICE_OBJECT RDPDYN_PDO;

//  Global Registry Path for RDPDR.SYS.  This global is defined in rdpdr.c.
extern UNICODE_STRING DrRegistryPath;

// Global Dr admin SD and sd length
extern PSECURITY_DESCRIPTOR DrAdminSecurityDescriptor;
extern ULONG DrSecurityDescriptorLength;

///////////////////////////////////////////////////////////////////////////////////////
//
//   External Prototypes
//

// Just shove the typedefs in for the Power Management functions now because I can't
// get the header conflicts resolved.
NTKERNELAPI VOID PoStartNextPowerIrp(IN PIRP Irp);
NTKERNELAPI NTSTATUS PoCallDriver(IN PDEVICE_OBJECT DeviceObject, IN OUT PIRP Irp);


///////////////////////////////////////////////////////////////////////////////////////
//
//   Internal Prototypes
//

NTSTATUS RDPDRPNP_HandleStartDeviceIRP(
    PDEVICE_OBJECT StackDeviceObject,
    PIO_STACK_LOCATION IoStackLocation,
    IN PIRP Irp
    )
/*++

Routine Description:

  Handles PnP Start Device IRP's.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp.

Return Value:

    The function value is the final status from the operation.

--*/
{
    KEVENT event;
    NTSTATUS ntStatus;

    BEGIN_FN("RDPDRPNP_HandleStartDeviceIRP");

    // Initialize this module.
    ntStatus = RDPDYN_Initialize();
    if (NT_SUCCESS(ntStatus)) {
        //
        //  Set up the IO completion routine because the lower level
        //  driver needs to handle this IRP before we can continue.
        //
        KeInitializeEvent(&event, NotificationEvent, FALSE);
        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,RDPDR_DeferIrpCompletion,&event,TRUE,TRUE,TRUE);
        ntStatus = IoCallDriver(StackDeviceObject,Irp);
        if (ntStatus == STATUS_PENDING)
        {
            KeWaitForSingleObject(&event,Suspended,KernelMode,FALSE,NULL);
            ntStatus = Irp->IoStatus.Status;
        }
    }

    // Finish the IRP.
    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return ntStatus;
}

NTSTATUS RDPDRPNP_HandleRemoveDeviceIRP(
    IN PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT StackDeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

  Handles PnP Remove Device IRP's.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    UNICODE_STRING symbolicLink;

    BEGIN_FN("RDPDRPNP_HandleRemoveDeviceIRP");

    //
    //  Remove the Win32 symbolic link name.
    //
    RtlInitUnicodeString(&symbolicLink, RDPDRDVMGR_W32DEVICE_PATH_U);

    // Delete the existing link ... if it exists.
#if DBG
    ntStatus = IoDeleteSymbolicLink(&symbolicLink);
    if (ntStatus != STATUS_SUCCESS) {
        TRC_ERR((TB, "IoDeleteSymbolicLink failed:  %08X", ntStatus));
    }
    else {
        TRC_NRM((TB, "IoDeleteSymbolicLink succeeded"));
    }
#else
    IoDeleteSymbolicLink(&symbolicLink);
#endif

    //
    //  Call the lower level driver.
    //
    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(StackDeviceObject,Irp);

    //
    //  Detach the FDO from the DO stack.
    //
    IoDetachDevice(StackDeviceObject);

    //
    //  The device is now about to be deleted4 ... we might need to perform
    //  some cleanup for the device here before we remove it.
    //

    //
    //  Release the FDO.
    //
    IoDeleteDevice(DeviceObject);

    return ntStatus;
}

NTSTATUS RDPDRPNP_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine should only be called one time to create the "dr"'s FDO
    that sits on top of the PDO for the sole purpose of registering new
    device interfaces.

    This function is called by PnP to make the "dr" the function driver
    for a root dev node that was created on install.

Arguments:

    DriverObject - pointer to the driver object for this instance of USBPRINT

    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT      fdo = NULL;
    PRDPDYNDEVICE_EXTENSION   deviceExtension;
    UNICODE_STRING      deviceName;
    UNICODE_STRING      symbolicLink;

    BEGIN_FN("RDPDRPNP_PnPAddDevice");

    // Initialize the device name.
    RtlInitUnicodeString(&deviceName, RDPDRDVMGR_DEVICE_PATH_U);

    //
    // Create our FDO.
    //
    ntStatus = IoCreateDevice(DriverObject, sizeof(RDPDYNDEVICE_EXTENSION),
                            &deviceName, FILE_DEVICE_UNKNOWN, 0, FALSE, &fdo);

    if (NT_SUCCESS(ntStatus)) {
        //
        // Adjust the default security descriptor on our device object
        //
        TRC_ASSERT(DrAdminSecurityDescriptor != NULL, 
            (TB, "DrAdminSecurityDescriptor != NULL"));
       
        ntStatus = AdjustSecurityDescriptor(fdo, DrAdminSecurityDescriptor, DrSecurityDescriptorLength);

        if (!NT_SUCCESS(ntStatus)) {
            TRC_ERR((TB, "AdjustSecurityDescriptor failed: %08X",
                      ntStatus));
            IoDeleteDevice(fdo);
            goto cleanup;
        }       
        
        // We support buffered IO.
        fdo->Flags |= DO_BUFFERED_IO;

        //
        //  Add the Win32 symbolic link name.
        //
        RtlInitUnicodeString(&symbolicLink, RDPDRDVMGR_W32DEVICE_PATH_U);

        // Delete the existing link ... in case it exists.
        IoDeleteSymbolicLink(&symbolicLink);

        // Create the new link.
        ntStatus = IoCreateSymbolicLink(&symbolicLink, &deviceName);
        if (!NT_SUCCESS(ntStatus)) {
            TRC_ERR((TB, "IoCreateSymbolicLink failed: %08X",
                      ntStatus));
            IoDeleteDevice(fdo);
        }
        else {
            //
            //  Get the device extension.
            //
            deviceExtension = (PRDPDYNDEVICE_EXTENSION)(fdo->DeviceExtension);

            //
            //  Attach to the PDO after recording the current top of the DO stack.
            //

            deviceExtension->TopOfStackDeviceObject=IoAttachDeviceToDeviceStack(
                                                                    fdo,
                                                                    PhysicalDeviceObject
                                                                    );
            if (deviceExtension->TopOfStackDeviceObject == NULL)
            {
                TRC_ERR((TB, "IoAttachDeviceToDeviceStack failed"));
                IoDeleteDevice(fdo);
            }
            else
            {
                // Record the PDO to a global.
                RDPDYN_PDO = PhysicalDeviceObject;

                // We are done initializing our device.
                fdo->Flags &= ~DO_DEVICE_INITIALIZING;
            }
        }

    } // end if creation of FDO succeeded.

cleanup:
    return ntStatus;
}


NTSTATUS
AdjustSecurityDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN ULONG SecurityDescriptorLength
    )

/*++

Routine Description:

    Use the given security descriptor to give system-only access on the given device object

Arguments:
    Device Object - Pointer to the device object to be modified
    SecurityDescriptor - Pointer to a valid SECURITY_DESCRIPTOR structure
    SecurityDescriptorLength - Length of the SecurityDescriptor
    
Return Value:

    NTSTATUS - success/error code.

--*/

{
    BEGIN_FN("AdjustSecurityDescriptor");
    //
    // We set only the Dacl from the SD    
    //
    SECURITY_INFORMATION SecurityInformation = DACL_SECURITY_INFORMATION;
    NTSTATUS status;


    PACE_HEADER AceHeader = NULL;
    PSID AceSid;
    PACL Dacl = NULL;
    BOOLEAN DaclDefaulted;
    BOOLEAN DaclPresent;
    DWORD i;
    PACL NewDacl = NULL;
    SECURITY_DESCRIPTOR NewSD;

    if (DeviceObject == NULL ||
        SecurityDescriptor == NULL ||
        SecurityDescriptorLength == 0) {
        return STATUS_INVALID_PARAMETER;
    }
    //
    // Validate the security descriptor
    //
    if (SeValidSecurityDescriptor(SecurityDescriptorLength, SecurityDescriptor)) {
        //
        // Obtain the Dacl from the security descriptor
        //
        status = RtlGetDaclSecurityDescriptor(SecurityDescriptor,
                                              &DaclPresent,
                                              &Dacl,
                                              &DaclDefaulted);
        
        if (!NT_SUCCESS(status)) {
            TRC_ERR((TB, "RDPDRPNP:RtlGetDaclSecurityDescriptor failed: %08X",
                      status));
            goto Cleanup;
        }

        TRC_ASSERT(DaclPresent != FALSE, 
            (TB, "RDPDRPNP:Dacl not present"));

        //
        // Make a copy of the Dacl so that we can modify it.
        //

        NewDacl = (PACL)ExAllocatePoolWithTag(PagedPool, Dacl->AclSize, DR_POOLTAG);

        if (NULL == NewDacl) {
            status = STATUS_NO_MEMORY;
            TRC_ERR((TB, "RDPDRPNP:Can't allocate memory for new dacl: %08X",
                      status));
            goto Cleanup;
        }

        RtlCopyMemory(NewDacl, Dacl, Dacl->AclSize);

        //
        // Loop through the DACL, removing any access allowed
        // entries that aren't for SYSTEM
        //

        for (i = 0; i < NewDacl->AceCount; i++) {
            //
            // Get each ACE.
            //
            status = RtlGetAce(NewDacl, i, (PVOID*)&AceHeader);

            if (NT_SUCCESS(status)) {
            
                if (ACCESS_ALLOWED_ACE_TYPE == AceHeader->AceType) {

                    AceSid = (PSID) &((ACCESS_ALLOWED_ACE*)AceHeader)->SidStart;
                    
                    //
                    // Check if this is system sid.
                    //
                    if (!RtlEqualSid(AceSid, SeExports->SeLocalSystemSid)) {
                        //
                        // Not a system sid. Delete ace.
                        //
                        status = RtlDeleteAce(NewDacl, i);
                        if (NT_SUCCESS(status)) {
                            i -= 1;
                        }
                    }
                }
            }
        }

        TRC_ASSERT(NewDacl->AceCount > 0, 
            (TB, "RDPDRPNP:AceCount is 0 in the new dacl"));

        //
        // Create a new security descriptor to hold the new Dacl.
        //

        status = RtlCreateSecurityDescriptor(&NewSD, SECURITY_DESCRIPTOR_REVISION);

        if (!NT_SUCCESS(status)) {
            TRC_ERR((TB, "RDPDRPNP:RtlCreateSecurityDescriptor failed: %08X",
                      status));
            goto Cleanup;
        }

        //
        // Place the new Dacl into the new SD
        //

        status = RtlSetDaclSecurityDescriptor(&NewSD, TRUE, NewDacl, FALSE);

        if (!NT_SUCCESS(status)) {
            TRC_ERR((TB, "RDPDRPNP:RtlSetDaclSecurityDescriptor failed: %08X",
                      status));
            goto Cleanup;
        }

        //
        // Set the new SD into our device object.
        //
        status = ObSetSecurityObjectByPointer(
                                              DeviceObject, 
                                              SecurityInformation, 
                                              &NewSD
                                              );
    }
    else {
        status = STATUS_INVALID_PARAMETER;
        TRC_ERR((TB, "RDPDRPNP: Invalid security descriptor",
            status));
    }

 
Cleanup:    
    if (NULL != NewDacl) {
        ExFreePool(NewDacl);
    }

    return status;
}


NTSTATUS
RDPDR_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the lower level driver completes an IRP.  It
    simply sets an event to true, which allows the blocked thread to finish
    whatever processing was pending.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = (PKEVENT)Context;

    BEGIN_FN("RDPDR_DeferIrpCompletion");

    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\rdpdyn.h ===
/*++    

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :
    
    rdpdyn.h

Abstract:

    This module is the dynamic device management component for RDP device 
    redirection.  It exposes an interface that can be opened by device management
    user-mode components running in session context.

Revision History:
--*/
#pragma once

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Our Pool Tag
#define RDPDYN_POOLTAG              ('dpdr')

//
//  Opaque Associated Data for a Device Managed by this Module
//
typedef void *RDPDYN_DEVICEDATA;
typedef RDPDYN_DEVICEDATA *PRDPDYN_DEVICEDATA;

//
// A structure representing the instance information associated with
// a particular device.  Note that this is only currently used for
// DO's sitting on top of our physical device object.
//
typedef struct tagRDPDYNDEVICE_EXTENSION
{
    // Device object we call when sending messages down the DO stack.
    PDEVICE_OBJECT TopOfStackDeviceObject;
} RDPDYNDEVICE_EXTENSION, *PRDPDYNDEVICE_EXTENSION;

// RDPDYN IRP Dispatch function.
NTSTATUS RDPDYN_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

// This function is called when a new session is connected.
void RDPDYN_SessionConnected(
    IN  ULONG   sessionID
    );

// This function is called when an existing session is disconnected.
void RDPDYN_SessionDisconnected(
    IN  ULONG   sessionID
    );

// Disable, without removing, a client device, previously announced 
// via RDPDYN_AddClientDevice.
NTSTATUS RDPDYN_DisableClientDevice(
    IN RDPDYN_DEVICEDATA deviceData
    );

//  Enable a printer device disabled by a call to RDPDYN_DisablePrinterDevice.  Note
//  that printer devices are enabled by default when they are added.
NTSTATUS RDPDYN_EnableClientDevice(
    IN RDPDYN_DEVICEDATA deviceData
    );

// Init function for this module.
NTSTATUS RDPDYN_Initialize(
    );

// Shutdown function for this module.
NTSTATUS RDPDYN_Shutdown(
    );

// This shouldn't really be here...

// Dispatch a device management event to the appropriate (session-wise)
// user-mode device manager component.  If there are not any event request
// IRP's pending for the specified session, then the event is queued for
// future dispatch.
NTSTATUS RDPDYN_DispatchNewDevMgmtEvent(
    IN PVOID devMgmtEvent,
    IN ULONG sessionID,
    IN ULONG eventType,
    OPTIONAL IN DrDevice *devDevice
    );

//
//   Callback for completion of a client send message request.
//

typedef VOID (RDPDR_ClientMessageCB)(
                        IN PVOID clientData,
                        IN NTSTATUS status
                    );

//
//  Send a message to the client with the specified session ID.
//
NTSTATUS
DrSendMessageToSession(
    IN ULONG SessionId,
    IN PVOID Msg,
    IN DWORD MsgSize,
    OPTIONAL IN RDPDR_ClientMessageCB CB,
    OPTIONAL IN PVOID ClientData
    );

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\rdpevlst.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :
    
    rdpevlst.cpp

Abstract:

    This manages user-mode RDP pending device management events.  All 
    functions are reentrant.

    Need to be more careful about holding on to spinlocks for
    two long, like when I am allocating memory, for instance.

Revision History:
--*/

#include "precomp.hxx"
#define TRC_FILE "rdpevlst"
#include "trc.h"


////////////////////////////////////////////////////////////
//
//      Defines
//

#define DEVLIST_POOLTAG 'DPDR'

#if DBG
#define     MAGICNO          0x52530
#define     BOGUSMAGICNO     0xAAAAAAAA
#endif


//////////////////////////////////////////////////////////////////////
//
//      Internal Prototypes
//

PSESSIONLISTNODE FetchSessionListNode(IN RDPEVNTLIST list, 
                                        IN ULONG sessionID,
                                        BOOL createIfNotFound);
void CleanupSessionListNodeRequestList(IN PSESSIONLISTNODE sessionListNode);
void CleanupSessionListNodeEventList( 
                                        IN PSESSIONLISTNODE sessionListNode
                                        );
void ReleaseSessionListNode(IN RDPEVNTLIST list, IN ULONG sessionID);

#if DBG
void CheckListIntegrity(IN RDPEVNTLIST list);
#endif


//////////////////////////////////////////////////////////////////////
//
//      Global Variables
//

#if DBG
ULONG RDPEVNTLIST_LockCount = 0;
#endif

RDPEVNTLIST 
RDPEVNTLIST_CreateNewList()
/*++

Routine Description:

    Create a new pending device list.

Arguments:

Return Value:

    RDPEVNTLIST_INVALID_LIST on error.  A new device list on success.

--*/
{
    PSESSIONLIST sessionList;

    BEGIN_FN("RDPEVNTLIST_CreateNewList");

    sessionList = new(NonPagedPool) SESSIONLIST;
    if (sessionList != NULL) {
#if DBG
        sessionList->magicNo = MAGICNO;
#endif
        KeInitializeSpinLock(&sessionList->spinlock);
        InitializeListHead(&sessionList->listHead);
    }

    return (RDPEVNTLIST)sessionList;
}

void RDPEVNTLIST_DestroyList(IN RDPEVNTLIST list)
/*++

Routine Description:

    Release a pending device list.

Arguments:

    list    

Return Value:

    NULL on error.  A new device list on success.

--*/
{
#ifdef DBG
    PSESSIONLIST        sessionList=NULL;
#else
    PSESSIONLIST        sessionList;
#endif
    PSESSIONLISTNODE    sessionListNode;
    PLIST_ENTRY         sessionListEntry;

    BEGIN_FN("RDPEVNTLIST_DestroyList");

    sessionList = (PSESSIONLIST)list;

#if DBG
    CheckListIntegrity(list);
#endif

    //
    //  Clean up each session node in LIFO fashion, as opposed to FIFO, for
    //  efficiency.
    //
    while (!IsListEmpty(&sessionList->listHead)) {

        sessionListEntry = RemoveHeadList(&sessionList->listHead);
        sessionListNode = CONTAINING_RECORD(sessionListEntry, SESSIONLISTNODE, listEntry);
        TRC_ASSERT(sessionListNode->magicNo == MAGICNO, 
                  (TB, "Invalid magic number in list block entry."));

        // Clean up the request list for the current session node.
        CleanupSessionListNodeRequestList(sessionListNode);

        // Clean up the event list for the current session node.
        CleanupSessionListNodeEventList(sessionListNode);


        // Release the current session node.
#if DBG
        sessionListNode->magicNo = BOGUSMAGICNO;
#endif
        delete sessionListNode;
    }

    // Release the list.
#if DBG
    sessionList->magicNo = BOGUSMAGICNO;
#endif
    delete sessionList;
}

NTSTATUS 
RDPDEVNTLIST_EnqueueEventEx(
    IN RDPEVNTLIST list, 
    IN ULONG sessionID, 
    IN void *event,
    IN DrDevice *device,
    IN ULONG type,
    IN BOOL insertAtHead
    )
/*++

Routine Description:

    Queue a new pending event for the specified session.  Note that this function simply 
    stores the event pointer.  It does not copy the data pointed to by 
    the pointer.

Arguments:

    list         -   Event management list allocated by RDPDDEVLIST_CreateNewList.
    sessionID    -   Identifier for session to associate with the device.
    devMgmtEvent -   Pending device management event.
    type         -   Numeric identifier for event type.  Valid values for this field 
                     are defined by the function caller.
    insertAtHead -   If TRUE, then the element is queued at the head of the queue
                     in standard FIFO fashion.  Otherwise, the element is queued at
                     the tail of the queue.  This is convenient for requeueing.

Return Value:

    NTSUCCESS on success.  Alternative status, otherwise.

--*/
{
    PSESSIONLISTNODE    sessionListNode;
    PLIST_ENTRY         sessionListEntry;
    PLIST_ENTRY         eventListEntry;
    PEVENTLISTNODE      eventListNode;
    NTSTATUS            ntStatus;
#if DBG
    PSESSIONLIST        sessionList=NULL;
#else
    PSESSIONLIST        sessionList;
#endif

    BEGIN_FN("RDPDEVNTLIST_EnqueueEventEx");
    TRC_NRM((TB, "session %ld.", sessionID));

    sessionList = (PSESSIONLIST)list;

#if DBG
    CheckListIntegrity(list);
#endif

    // Fetch the session list node corresponding to the session ID.
    sessionListNode = FetchSessionListNode(list, sessionID, TRUE);
    if (sessionListNode == NULL) {
        ntStatus = STATUS_NO_MEMORY;
        goto ReturnWithStatus;
    }

    //
    //  Add a new entry to the event list.
    //

    // Allocate a new event list node.
    eventListNode = new(NonPagedPool) EVENTLISTNODE;
    if (eventListNode != NULL) {
        // Initialize the new node.
#if DBG
        eventListNode->magicNo = MAGICNO;
#endif
        eventListNode->event = event;
        eventListNode->type = type;
        eventListNode->device = device;

        // Add it to the list head.
        if (insertAtHead) {
            InsertHeadList(&sessionListNode->eventListHead, 
                          &eventListNode->listEntry);
        }
        else {
            InsertTailList(&sessionListNode->eventListHead, 
              &eventListNode->listEntry);
        }
        ntStatus = STATUS_SUCCESS;
    }
    else {
        ntStatus = STATUS_NO_MEMORY;
    }

#if DBG
    CheckListIntegrity(list);
#endif

ReturnWithStatus:
    return ntStatus;
}

NTSTATUS 
RDPEVNTLIST_EnqueueEvent(
    IN RDPEVNTLIST list, 
    IN ULONG sessionID, 
    IN void *event,
    IN ULONG type,
    OPTIONAL IN DrDevice *device
    )
/*++

Routine Description:

    Queue a new pending event for the specified session.  Note that this function simply 
    stores the event pointer.  It does not copy the data pointed to by 
    the pointer.

Arguments:

    list         -   Event management list allocated by RDPDDEVLIST_CreateNewList.
    sessionID    -   Identifier for session to associate with the device.
    devMgmtEvent -   Pending device management event.
    type         -   Numeric identifier for event type.  Valid values for this field 
                     are defined by the function caller.

Return Value:

    NTSUCCESS on success.  Alternative status, otherwise.

--*/
{
    BEGIN_FN("RDPEVNTLIST_EnqueueEvent");
    // Insert at the head of the queue.
    return RDPDEVNTLIST_EnqueueEventEx(list, sessionID, event, device, type, TRUE);
}

NTSTATUS 
RDPEVNTLIST_RequeueEvent(
    IN RDPEVNTLIST list, 
    IN ULONG sessionID, 
    IN void *event,
    IN ULONG type,
    OPTIONAL IN DrDevice *device
    )
/*++

Routine Description:

    Requeue a pending event for the specified session at the tail of the queue.  
    Note that this function simply stores the event pointer.  It does not copy the 
    data pointed to by the pointer.

Arguments:

    list         -   Event management list allocated by RDPDDEVLIST_CreateNewList.
    sessionID    -   Identifier for session to associate with the device.
    devMgmtEvent -   Pending device management event.
    type         -   Numeric identifier for event type.  Valid values for this field 
                     are defined by the function caller.

Return Value:

    NTSUCCESS on success.  Alternative status, otherwise.

--*/
{
    BEGIN_FN("RDPEVNTLIST_RequeueEvent");
    // Insert at the head of the queue.
    return RDPDEVNTLIST_EnqueueEventEx(list, sessionID, event, device, type, FALSE);
}

BOOL RDPEVNTLIST_PeekNextEvent(
    IN RDPEVNTLIST list,
    IN ULONG sessionID,
    PVOID *eventPtr,
    OPTIONAL IN OUT ULONG *type,
    OPTIONAL IN OUT DrDevice **devicePtr
    )
/*++

Routine Description:

    Peek at the next pending event for the specified session, without dequeueing
    it.  NULL is returned if there are no more pending events for the specified 
    session.  Note that, if non-NULL is returned, the pointer returned is the 
    pointer that was passed in to RDPEVNTLIST_EnqueueEvent.  

Arguments:

    list        -   Event management list allocated by RDPDDEVLIST_CreateNewList.
    sessionID   -   Identifier for session to associate with the device.
    type        -   Can be used to identify the type of event.
    eventPtr    -   The returned event.

Return Value:

    TRUE if pending event exists.  FALSE, otherwise.

--*/
{
    PSESSIONLISTNODE    sessionListNode;
    PEVENTLISTNODE      eventListNode;
    PLIST_ENTRY         tail;
    BOOL result;
    PSESSIONLIST        sessionList;

    BEGIN_FN("RDPEVNTLIST_PeekNextEvent");
    TRC_NRM((TB, "session %ld.", sessionID));

    sessionList = (PSESSIONLIST)list;

#if DBG
    CheckListIntegrity(list);
#endif

    //
    //  Fetch the session list node corresponding to the session ID.
    //
    sessionListNode = FetchSessionListNode(list, sessionID, FALSE);

    //
    //  If we have a non-empty session list node.
    //
    if ((sessionListNode != NULL) && 
        !IsListEmpty(&sessionListNode->eventListHead)) {

        //
        //  Get the event at the tail of the session's event list.
        //
        tail = sessionListNode->eventListHead.Blink;
        eventListNode = CONTAINING_RECORD(tail, EVENTLISTNODE, listEntry);
        TRC_ASSERT(eventListNode->magicNo == MAGICNO, 
                (TB, "Invalid event list node."));

        //
        //  Grab the fields to return.
        //
        *eventPtr = eventListNode->event;

        if (type != NULL) *type = eventListNode->type;
        
        if (devicePtr != NULL) *devicePtr = eventListNode->device;

        result = TRUE;
    }
    else {
        *eventPtr = NULL;
        result = FALSE;
    }

    return result;
}

BOOL RDPEVNTLIST_DequeueEvent(
    IN RDPEVNTLIST list,
    IN ULONG sessionID,
    OPTIONAL IN OUT ULONG *type,
    PVOID   *eventPtr,
    OPTIONAL IN OUT DrDevice **devicePtr
    )
/*++

Routine Description:

    Returns and removes the next pending event for the specified session.
    NULL is returned if there are no more pending events for the specified session.
    Note that, if non-NULL is returned, the pointer returned is the pointer that was
    passed in to RDPEVNTLIST_EnqueueEvent.  

Arguments:

    list        -   Event management list allocated by RDPDDEVLIST_CreateNewList.
    sessionID   -   Identifier for session to associate with the device.
    type        -   Can be used to identify the type of event.
    eventPtr    -   Returned event.

Return Value:

    TRUE if Pending event if one exists.  FALSE, otherwise.

--*/
{
    PSESSIONLISTNODE    sessionListNode;
    PLIST_ENTRY         eventListEntry;
    PEVENTLISTNODE      eventListNode;
#ifdef DBG
    PSESSIONLIST        sessionList=NULL;
#else
    PSESSIONLIST        sessionList;
#endif
    BOOL                result;

    BEGIN_FN("RDPEVNTLIST_DequeueEvent");
    TRC_NRM((TB, "session %ld.", sessionID));

    sessionList = (PSESSIONLIST)list;

#if DBG
    CheckListIntegrity(list);
#endif

    //
    //  Fetch the session list node corresponding to the session ID.
    //
    sessionListNode = FetchSessionListNode(list, sessionID, FALSE);
    if (sessionListNode != NULL) {
        //
        //  Get the next session list node in FIFO fashion.
        //
        if (!IsListEmpty(&sessionListNode->eventListHead)) {

            eventListEntry = RemoveTailList(&sessionListNode->eventListHead);
            eventListNode = CONTAINING_RECORD(eventListEntry, EVENTLISTNODE, listEntry);

            TRC_ASSERT(eventListNode->magicNo == MAGICNO, 
                      (TB, "Invalid event list node."));
            *eventPtr = eventListNode->event;
            if (type != NULL) {
                *type = eventListNode->type;
            }
            if (devicePtr != NULL) {
                *devicePtr = eventListNode->device;
            }
            result = TRUE;
#if DBG
            eventListNode->magicNo = BOGUSMAGICNO;
#endif
            // Release the event list node.
            delete eventListNode;

            TRC_NRM((TB, "returning session %ld entry.", sessionID));
        }
        else {

            TRC_NRM((TB, "session %ld empty.", sessionID));

            *eventPtr = NULL;
            result = FALSE;
        }

        //
        //  If the request list is empty and the event list is empty, then
        //  delete the session node.
        //
        if (IsListEmpty(&sessionListNode->requestListHead) &&
            IsListEmpty(&sessionListNode->eventListHead)) {
            ReleaseSessionListNode(list, sessionListNode->sessionID);
        }
        
    }
    else {

        TRC_NRM((TB, "session %ld not found.", sessionID));

        *eventPtr = NULL;
        result = FALSE;
    }

#if DBG
    CheckListIntegrity(list);
#endif

    return result;
}

NTSTATUS RDPEVNTLIST_EnqueueRequest(IN RDPEVNTLIST list,
                                  IN ULONG sessionID, IN PVOID request)
/*++

Routine Description:

    Add a new pending request.  Note that this function simply stores the request 
    pointer.  It does not copy the data pointed to by the pointer.

Arguments:

    list        -   Device management list allocated by RDPDDEVLIST_CreateNewList.
    sessionID   -   Identifier for session to associate with the device.
    request     -   Pending request.

Return Value:

    Pending event if one exists.  NULL, otherwise.

--*/
{
    PSESSIONLISTNODE        sessionListNode;
    PLIST_ENTRY             sessionListEntry;
    PLIST_ENTRY             requestListEntry;
    PREQUESTLISTNODE        requestListNode;
    NTSTATUS                ntStatus;
#ifdef DBG
    PSESSIONLIST            sessionList=NULL;
#else
    PSESSIONLIST            sessionList;
#endif

    BEGIN_FN("RDPEVNTLIST_EnqueueRequest");
    TRC_NRM((TB, "session %ld.", sessionID));

    sessionList = (PSESSIONLIST)list;

#if DBG
    CheckListIntegrity(list);
#endif

    // Fetch the session list node corresponding to the session ID.
    sessionListNode = FetchSessionListNode(list, sessionID, TRUE);
    if (sessionListNode == NULL) {
        ntStatus = STATUS_NO_MEMORY;
        goto ReturnWithStatus;
    }

    //
    //  Add a new entry to the event list.
    //

    // Allocate a new request list node.
    requestListNode = new(NonPagedPool) REQUESTLISTNODE;
    if (requestListNode != NULL) {
        // Add it to the list head.
#if DBG
        requestListNode->magicNo = MAGICNO;
#endif
        requestListNode->request = request;   
        InsertHeadList(&sessionListNode->requestListHead, &requestListNode->listEntry);
        ntStatus = STATUS_SUCCESS;
    }
    else {
        ntStatus = STATUS_NO_MEMORY;
    }

#if DBG
    CheckListIntegrity(list);
#endif

ReturnWithStatus:
    return ntStatus;
}

PVOID RDPEVNTLIST_DequeueRequest(IN RDPEVNTLIST list,
                                 IN ULONG sessionID)
/*++

Routine Description:

    Returns and removes the next pending request for the specified session.
    NULL is returned if there are no more pending devices for the specified session.
    Note that, if non-NULL is returned, the pointer returned is the pointer that was
    passed in to RDPEVNTLIST_EnqueueRequest.  

Arguments:

    list        -   Device management list allocated by RDPDDEVLIST_CreateNewList.
    sessionID   -   Identifier for session to associate with the device.

Return Value:

    Pending request if one exists.  NULL, otherwise.

--*/
{
    PSESSIONLISTNODE        sessionListNode;
    PLIST_ENTRY             requestListEntry;
    PREQUESTLISTNODE        requestListNode;
    PVOID                   requestPtr;
#ifdef DBG
    PSESSIONLIST            sessionList=NULL;
#else
    PSESSIONLIST            sessionList;
#endif

    BEGIN_FN("RDPEVNTLIST_DequeueRequest");
    TRC_NRM((TB, "session %ld.", sessionID));

    sessionList = (PSESSIONLIST)list;

#if DBG
    CheckListIntegrity(list);
#endif

    //
    //  Fetch the session list node corresponding to the session ID.
    //
    sessionListNode = FetchSessionListNode(list, sessionID, FALSE);
    if (sessionListNode != NULL) {
        //
        //  Get the next session list node in FIFO fashion.
        //
        if (!IsListEmpty(&sessionListNode->requestListHead)) {

            requestListEntry = RemoveTailList(&sessionListNode->requestListHead);
            requestListNode = CONTAINING_RECORD(requestListEntry, REQUESTLISTNODE, listEntry);

            TRC_ASSERT(requestListNode->magicNo == MAGICNO, (TB, "Invalid request list node."));
            requestPtr = requestListNode->request;
#if DBG
            requestListNode->magicNo = BOGUSMAGICNO;
#endif

            // Release the event list node.
            delete requestListNode;
        }
        else {
            requestPtr = NULL;
        }

        //
        //  If the request list is empty and the event list is empty, then
        //  delete the session node.
        //
        if (IsListEmpty(&sessionListNode->requestListHead) &&
            IsListEmpty(&sessionListNode->eventListHead)) {
            ReleaseSessionListNode(list, sessionListNode->sessionID);
#if DBG
            sessionListNode = NULL;
#endif
        }
    }
    else {
        requestPtr = NULL;
    }

#if DBG
    CheckListIntegrity(list);
#endif

    return requestPtr;
}

PVOID 
RDPEVNTLIST_DequeueSpecificRequest(
    IN RDPEVNTLIST list,
    IN ULONG sessionID,  
    IN PVOID request
    )
/*++

Routine Description:

    Dequeues a specific request from a session's request list.  The dequeued request
    is returned if it is found.  Otherwise, NULL is returned.

Arguments:

    list        -   Device management list allocated by RDPDDEVLIST_CreateNewList.
    request     -   A request that was queued for the specified session via 
                    RDPEVNTLIST_EnqueueRequest.
    sessionID   -   Session from which the request should be dequeued.

Return Value:

    Pending request if one exists.  NULL, otherwise.

--*/
{
    PSESSIONLISTNODE        sessionListNode;
    PLIST_ENTRY             requestListEntry;
    PREQUESTLISTNODE        requestListNode;
    PVOID                   requestPtr = NULL;
#ifdef DBG
    PSESSIONLIST            sessionList=NULL;
#else
    PSESSIONLIST            sessionList;
#endif

    BEGIN_FN("RDPEVNTLIST_DequeueSpecificRequest");
    TRC_NRM((TB, "session %ld.", sessionID));

    sessionList = (PSESSIONLIST)list;

#if DBG
    CheckListIntegrity(list);
#endif

    //
    //  Fetch the session list node corresponding to the session ID.
    //
    sessionListNode = FetchSessionListNode(list, sessionID, FALSE);
    if (sessionListNode != NULL) {
    
        //
        //  Perform a linear search for the specified request.
        //
        requestListEntry = sessionListNode->requestListHead.Flink;
        while(requestListEntry != &sessionListNode->requestListHead) {
            requestListNode = CONTAINING_RECORD(requestListEntry, REQUESTLISTNODE, listEntry);
            TRC_ASSERT(requestListNode->magicNo == MAGICNO, 
                      (TB, "Invalid magic number in list block entry."));
            if (requestListNode->request == request) {
                requestPtr = requestListNode->request;
                break;
            }
            requestListEntry = requestListEntry->Flink;
        }

        //
        //  If we found the entry, then remove it.
        //
        if (requestPtr != NULL) {
#if DBG
            requestListNode->magicNo = BOGUSMAGICNO;
#endif
            RemoveEntryList(requestListEntry);

            // Release the request list node.
            delete requestListNode;
        }
        else {
            TRC_ALT((TB, "no req. for session %ld.", sessionID));
        }

        //
        //  If the request list is empty and the event list is empty, then
        //  delete the session node.
        //
        if (IsListEmpty(&sessionListNode->requestListHead) &&
            IsListEmpty(&sessionListNode->eventListHead)) {
            ReleaseSessionListNode(list, sessionListNode->sessionID);
#if DBG
            sessionListNode = NULL;
#endif
        }
    }
    else {
        TRC_ALT((TB, "did not find session %ld.", sessionID));
    }

#if DBG
    CheckListIntegrity(list);
#endif

    return requestPtr;
}

void CleanupSessionListNodeEventList( 
    IN PSESSIONLISTNODE sessionListNode
    )
/*++

Routine Description:

    Clean up the event list for the specified session node.  The list must
    be locked before this function is called.

Arguments:

    sessionListNode     -   Session list node to clean up.

Return Value:

    None.

--*/
{
    PLIST_ENTRY      eventListEntry;
    PEVENTLISTNODE   eventListNode;

    BEGIN_FN("CleanupSessionListNodeEventList");
    //
    //  Clean up the event list for the current session node in LIFO, as
    //  opposed to FIFO fashion, for efficiency.
    //
    while (!IsListEmpty(&sessionListNode->eventListHead)) {

        eventListEntry = RemoveHeadList(&sessionListNode->eventListHead);
        eventListNode = CONTAINING_RECORD(eventListEntry, EVENTLISTNODE, listEntry);
        TRC_ASSERT(eventListNode->magicNo == MAGICNO, 
                  (TB, "Invalid magic number in list block entry."));

        // Release the current request node.
#if DBG
        eventListNode->magicNo = BOGUSMAGICNO;
#endif
        delete eventListNode;
    }
}

void CleanupSessionListNodeRequestList( 
    IN PSESSIONLISTNODE sessionListNode
    )
/*++

Routine Description:

    Clean up the request list for the specified session node.  The list must
    be locked before this function is called.

Arguments:

    sessionListNode     -   Session list node to clean up.

Return Value:

    None.

--*/
{
    PLIST_ENTRY         requestListEntry;
    PREQUESTLISTNODE    requestListNode;
    PVOID               requestPtr;

    BEGIN_FN("CleanupSessionListNodeRequestList");
    //
    //  Clean up the request list for the current session node in LIFO
    //  fashion, as opposed to FIFO fashion, for efficiency.
    //
    while (!IsListEmpty(&sessionListNode->requestListHead)) {

        requestListEntry = RemoveHeadList(&sessionListNode->requestListHead);
        requestListNode = CONTAINING_RECORD(requestListEntry, REQUESTLISTNODE, listEntry);
        TRC_ASSERT(requestListNode->magicNo == MAGICNO, 
                  (TB, "Invalid magic number in list block entry."));

        // Release the current request node.
#if DBG
        requestListNode->magicNo = BOGUSMAGICNO;
#endif
        delete requestListNode;
    }
}

void
ReleaseSessionListNode(
    IN RDPEVNTLIST list, 
    IN ULONG sessionID
    )
/*++

Routine Description:

    Remove the session list node from the list if it exists.

Arguments:

    list                -   Device management list allocated by 
                            RDPDDEVLIST_CreateNewList.
    sessionID           -   Identifier for session list node to fetch.

Return Value:

    The matching session node or NULL on error.

--*/
{
    PSESSIONLIST        sessionList;
    PSESSIONLISTNODE    sessionListNode;
    PLIST_ENTRY         current;

    BEGIN_FN("ReleaseSessionListNode");

#if DBG
    CheckListIntegrity(list);
#endif

    // Cast the list to the correct type.
    sessionList = (PSESSIONLIST)list;

    TRC_ASSERT(sessionList->magicNo == MAGICNO, 
             (TB, "Invalid magic number in session list."));

    // 
    //  Scan through the session node list, looking for a matching session.
    //
    current = sessionList->listHead.Flink;
    while (current != &sessionList->listHead) {
        sessionListNode = CONTAINING_RECORD(current, SESSIONLISTNODE, listEntry);
        TRC_ASSERT(sessionListNode->magicNo == MAGICNO, 
                  (TB, "Invalid magic number in list block entry."));
        if (sessionListNode->sessionID == sessionID) {
            break;
        }
        current = current->Flink;
    }

    //
    //  Clean up the found entry.
    //
    if (current != &sessionList->listHead) {
        // Remove the entry from the linked list.
        RemoveEntryList(current);

        // Clean up the found node's request list.
        CleanupSessionListNodeRequestList(sessionListNode);

        // Clean up the event list for the found node.
        CleanupSessionListNodeEventList(sessionListNode);

        // Release the found session node.
#if DBG
        sessionListNode->magicNo = BOGUSMAGICNO;
#endif
        delete sessionListNode;
    }

#if DBG
    CheckListIntegrity(list);
#endif
}

PSESSIONLISTNODE 
FetchSessionListNode(
    IN RDPEVNTLIST list, 
    IN ULONG sessionID,
    IN BOOL createIfNotFound
    )
/*++

Routine Description:

    This is a convenience function that fetches the session list node with the
    specified session ID.  

Arguments:

    list                -   Device management list allocated by 
                            RDPDDEVLIST_CreateNewList.
    sessionID           -   Identifier for session list node to fetch.
    createIfNotFound    -   Flag that indicates whether the function should create
                            a session list node if one is not found.

Return Value:

    The matching session node or NULL on error.

--*/
{
    PSESSIONLIST        sessionList;
    PSESSIONLISTNODE    sessionListNode;
    PLIST_ENTRY         sessionListEntry;

    BEGIN_FN("FetchSessionListNode");

    // Cast the list to the correct type.
    sessionList = (PSESSIONLIST)list;

    TRC_ASSERT(sessionList->magicNo == MAGICNO, 
             (TB, "Invalid magic number in session list."));

#if DBG
    CheckListIntegrity(list);
#endif

    // 
    //  Scan through the session node list, looking for a matching session.
    //
    sessionListEntry = sessionList->listHead.Flink;
    while(sessionListEntry != &sessionList->listHead) {
        sessionListNode = CONTAINING_RECORD(sessionListEntry, SESSIONLISTNODE, listEntry);
        TRC_ASSERT(sessionListNode->magicNo == MAGICNO, 
                  (TB, "Invalid magic number in list block entry."));
        if (sessionListNode->sessionID == sessionID) {
            break;
        }
        sessionListEntry = sessionListEntry->Flink;
    }

    // If we didn't find a match.
    if (sessionListEntry == &sessionList->listHead) {

        // If we are supposed to create a missing node.
        if (createIfNotFound) {
            // Allocate a new session list node.
            sessionListNode = new(NonPagedPool) SESSIONLISTNODE;
            if (sessionListNode != NULL) {
    #if DBG
                sessionListNode->magicNo = MAGICNO;
    #endif
                InitializeListHead(&sessionListNode->requestListHead);
                InitializeListHead(&sessionListNode->eventListHead);
                sessionListNode->sessionID = sessionID;

                // Add it to the head list.
                InsertHeadList(&sessionList->listHead, &sessionListNode->listEntry);
            }

        }
        // Otherwise, just return NULL for the session list node.
        else {
            sessionListNode = NULL;
        }
    }

#if DBG
    CheckListIntegrity(list);
#endif

    return sessionListNode;
}

BOOL 
RDPEVNTLLIST_GetFirstSessionID(
    IN RDPEVNTLIST list,
    IN ULONG *pSessionID
    )
/*++

Routine Description:
    
    Get the first session ID in the set of currently managed sessions. A 
    session is managed if there are any pending request's or events.
    A session is no longer managed when there are no longer any
    pending request's or events.

    This session is useful for cleaning up pending request's and pending events.

Arguments:

    list        -   Device management list allocated by RDPDDEVLIST_CreateNewList.
    pSessionID  -   Pointer for storing returned first session ID.

Return Value:

    TRUE if a session ID is returned.  FALSE, if there are no more sessions being
    managed by the list.

--*/
{
    PSESSIONLIST        sessionList;
    PLIST_ENTRY         sessionListEntry;
    PSESSIONLISTNODE    sessionListNode;

    BEGIN_FN("RDPEVNTLLIST_GetFirstSessionID");
    sessionList = (PSESSIONLIST)list;

#if DBG
    CheckListIntegrity(list);
#endif

    // If the list is empty.
    if (IsListEmpty(&sessionList->listHead)) {
        return FALSE;
    }
    else {
        sessionListNode = CONTAINING_RECORD(sessionList->listHead.Flink, 
                                            SESSIONLISTNODE, listEntry);
        TRC_ASSERT(sessionListNode->magicNo == MAGICNO, 
                  (TB, "Invalid magic number in list block entry."));
        *pSessionID = sessionListNode->sessionID;
        return TRUE;
    }
}

#if DBG
void CheckListIntegrity(
    IN RDPEVNTLIST list
    )
/*++

Routine Description:
    
    Check the integrity of the event and request list.        

Arguments:

Return Value:

    None

--*/
{
    PLIST_ENTRY currentSessionEntry;
    PLIST_ENTRY listEntry;
    PREQUESTLISTNODE requestListNode;
    PEVENTLISTNODE eventListNode;
    PSESSIONLISTNODE sessionListNode;    
    PSESSIONLIST sessionList;

    BEGIN_FN("CheckListIntegrity");
    sessionList = (PSESSIONLIST)list;
    currentSessionEntry = sessionList->listHead.Flink;
    while (currentSessionEntry != &sessionList->listHead) {

        // Check the current session node.
        sessionListNode = CONTAINING_RECORD(currentSessionEntry, 
                                        SESSIONLISTNODE, listEntry);
        if (sessionListNode->magicNo == BOGUSMAGICNO) {
            TRC_ASSERT(FALSE, 
                  (TB, "Stale link in event list in session list entry in integrity check."));
        }
        else if (sessionListNode->magicNo != MAGICNO) {
            TRC_ASSERT(FALSE, 
                  (TB, "Invalid magic number in session list entry in integrity check."));
        }

        // Check the current session's request list.
        listEntry = sessionListNode->requestListHead.Flink;
        while (listEntry != &sessionListNode->requestListHead) { 
            requestListNode = CONTAINING_RECORD(listEntry, 
                                            REQUESTLISTNODE, listEntry);
            if (requestListNode->magicNo == BOGUSMAGICNO) {
                TRC_ASSERT(FALSE, 
                      (TB, "Stale link in event list entry in integrity check."));
            }
            else if (requestListNode->magicNo != MAGICNO) {
                TRC_ASSERT(FALSE, 
                      (TB, "Invalid magic number in request list entry in integrity check."));
            }
            listEntry = listEntry->Flink;
        }

        // Check the current session's event list.
        listEntry = sessionListNode->eventListHead.Flink;
        while (listEntry != &sessionListNode->eventListHead) { 
            eventListNode = CONTAINING_RECORD(listEntry, 
                                            EVENTLISTNODE, listEntry);
            if (eventListNode->magicNo == BOGUSMAGICNO) {
                TRC_ASSERT(FALSE, 
                      (TB, "Stale link in event list entry in integrity check."));
            }
            else if (eventListNode->magicNo != MAGICNO) {
                TRC_ASSERT(FALSE, 
                      (TB, "Corrupted magic number in event list entry in integrity check."));
            }
            listEntry = listEntry->Flink;
        }

        // Next session entry.
        currentSessionEntry = currentSessionEntry->Flink;
    }

}
#endif


#if DBG
void RDPEVNTLIST_UnitTest()
/*++

Routine Description:

    Unit-Test function that can be called from a kernel-mode driver to 
    cover all functions implemented by this module.

Arguments:

Return Value:

    none.

--*/
#define MAXSESSIONS     2
#define MAXREQUESTS     2
#define MAXEVENT        2
#define REQUESTADDRESS  (PVOID)0x55000055
#define DEVEVTADDRESS   (PVOID)0x66000066
#define TESTDEVTYPE     (ULONG)0
{
    RDPEVNTLIST devList;
    ULONG i,j;

    PVOID address;
    ULONG sessionID;
    BOOL result;

    BEGIN_FN("RDPEVNTLIST_UnitTest");
    devList = RDPEVNTLIST_CreateNewList();
    TRC_ASSERT(devList != NULL, 
            (TB, "Unit test failed because list did not initialize properly."));

    // Add request's and event pointers for each session.
    for (i=0; i<MAXSESSIONS; i++) {
        for (j=0; j<MAXREQUESTS; j++) {
            if (!(j%5)) {
                TRC_NRM((TB, "Adding test requests"));
            }
            RDPEVNTLIST_EnqueueRequest(devList, i, (PVOID)REQUESTADDRESS);
        }

        for (j=0; j<MAXEVENT; j++) {
            if (!(j%5)) {
                TRC_NRM((TB, "Adding test device events."));
            }
            RDPEVNTLIST_EnqueueEvent(devList, i, 
                                    DEVEVTADDRESS,
                                    TESTDEVTYPE,
                                    NULL);
        }
    }

    // Remove them.
    for (i=0; i<MAXSESSIONS; i++) {
        for (j=0; j<MAXREQUESTS; j++) {
            address = RDPEVNTLIST_DequeueRequest(devList, i);
            TRC_ASSERT(address == REQUESTADDRESS, 
                (TB, "Unit test failed because invalid request address."));
            if (!(j%5)) {
                TRC_NRM((TB, "Removing test requests"));
            }
        }
        TRC_ASSERT(RDPEVNTLIST_DequeueRequest(devList, i) == NULL, (TB, ""));

        for (j=0; j<MAXEVENT; j++) {
            if (!(j%5)) {
                TRC_NRM((TB, "Removing test events"));
            }
            result = RDPEVNTLIST_DequeueEvent(devList, i, NULL, &address, NULL);
            TRC_ASSERT(result, (TB, "Unit test failed because missing event."));
            TRC_ASSERT(address == DEVEVTADDRESS, 
                (TB, "Unit test failed because invalid event address."));
        }
        TRC_ASSERT(!RDPEVNTLIST_DequeueEvent(devList, i, NULL, &address, NULL), 
            (TB, "Unit test failed because pending session exists."));
    }

    // All sessions should now be removed.
    TRC_ASSERT(!RDPEVNTLLIST_GetFirstSessionID(devList, &sessionID),
             (TB, "Unit test failed because session exists."));

    // Destroy the list.
    RDPEVNTLIST_DestroyList(devList);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\rdpevlst.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :
    
    rdpevlst.h

Abstract:

    This manages kernel-mode pending events and event requests, organized
    around session ID's.  All functions are reentrant.  Events and requests
    are opaque to this module.

    Data stored in the list can come from paged or non-paged pool.

Revision History:
--*/

#pragma once

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


////////////////////////////////////////////////////////////////////////
//
//  Typedefs
//

//
//      A SESSIONLIST struct points to a list of SESSIONLISTNODE's.  
//      Each SESSIONLISTNODE contains a list of REQUESTLISTNODE's and a list of 
//      EVENTLISTNODE's.  The requestListHead and 
//      eventListHead fields point to the REQUESTLISTNODE lists and 
//      the event record lists, respectively.

typedef struct tagSESSIONLIST 
{
#if DBG
    ULONG               magicNo;
#endif
    KSPIN_LOCK          spinlock;
    LIST_ENTRY          listHead;
} SESSIONLIST, *PSESSIONLIST;

typedef struct tagSESSIONLISTNODE
{
#if DBG
    ULONG               magicNo;
#endif
    ULONG               sessionID;
    LIST_ENTRY          requestListHead;
    LIST_ENTRY          eventListHead;
    LIST_ENTRY          listEntry; 
} SESSIONLISTNODE, *PSESSIONLISTNODE;

typedef struct tagREQUESTLISTNODE
{
#if DBG
    ULONG               magicNo;
#endif
    PVOID               request;
    LIST_ENTRY          listEntry;
} REQUESTLISTNODE, *PREQUESTLISTNODE;

typedef struct tagEVENTLISTNODE
{
#if DBG
    ULONG                magicNo;
#endif
    void                 *event;
    SmartPtr<DrDevice>   device;
    ULONG                type;
    LIST_ENTRY           listEntry;
} EVENTLISTNODE, *PEVENTLISTNODE;

//  
//  External type for an event management list.
//
typedef PSESSIONLIST RDPEVNTLIST;
typedef RDPEVNTLIST *PRDPEVNTLIST;
#define RDPEVNTLIST_INVALID_LIST    NULL


////////////////////////////////////////////////////////////////////////
//
//  Lock Management Macros  -   Must define extern RDPEVNTLIST_LockCount 
//  for debug builds.
//

#if DBG

extern ULONG RDPEVNTLIST_LockCount;

//
//  Lock the list from access via other threads.
//
#define RDPEVNTLIST_Lock(list, irql)                            \
    KeAcquireSpinLock(&(list)->spinlock, irql); \
    RDPEVNTLIST_LockCount++

//
//  Unlock a list locked by RDPEVNTLIST_Lock
//
#define RDPEVNTLIST_Unlock(list, irql)                          \
    RDPEVNTLIST_LockCount--;                                    \
    KeReleaseSpinLock(&(list)->spinlock, irql)

#else

//
//  Lock the list from access via other threads.
//
#define RDPEVNTLIST_Lock(list, irql)                            \
    KeAcquireSpinLock(&(list)->spinlock, irql)

//
//  Unlock a list locked by RDPEVNTLIST_Lock
//
#define RDPEVNTLIST_Unlock(list, irql)                          \
    KeReleaseSpinLock(&(list)->spinlock, irql)

#endif


////////////////////////////////////////////////////////////////////////
//
//  Prototypes
//

// Create a new pending device list.
RDPEVNTLIST RDPEVNTLIST_CreateNewList();

// Release a pending device list.
void RDPEVNTLIST_DestroyList(IN RDPEVNTLIST list);

// Add a new pending event.  Note that this function simply stores the void pointer.  
// It does not copy the data pointed to by the pointer.
NTSTATUS RDPEVNTLIST_EnqueueEvent(
                    IN RDPEVNTLIST list,
                    IN ULONG sessionID, 
                    IN PVOID devMgmtEvent,
                    IN ULONG type,
                    OPTIONAL IN DrDevice *devDevice
                    );

// Requeue a pending event for the specified session at the tail of the queue,
// as opposed to the head of the queue in standard FIFO fashion.  Note that this 
// function simply stores the event pointer.  It does not copy the data pointed to 
// by the pointer.
NTSTATUS RDPEVNTLIST_RequeueEvent(
                    IN RDPEVNTLIST list, 
                    IN ULONG sessionID, 
                    IN void *event,
                    IN ULONG type,
                    OPTIONAL IN DrDevice *devDevice
                    );

// Returns and removes the next pending device management event for the specified 
// session.  The returned pointer can be cast using the returned type field.
// NULL is returned if there are no more pending device mgmt events for the 
// specified session.  Note that, if non-NULL is returned, the pointer returned is 
// the pointer that was passed in to RDPEVNTLIST_AddPendingDevMgmtEvent
BOOL RDPEVNTLIST_DequeueEvent(
                    IN RDPEVNTLIST list,
                    IN ULONG sessionID,
                    OPTIONAL IN OUT ULONG *type,
                    PVOID   *eventPtr,
                    OPTIONAL IN OUT DrDevice **devicePtr                    
                    );

// Add a new pending request.  Note that this function simply stores the request
// pointer.  It does not copy the data pointed to by the pointer.
NTSTATUS RDPEVNTLIST_EnqueueRequest(
                    IN RDPEVNTLIST list,
                    IN ULONG sessionID, 
                    IN PVOID request
                    );

// Returns and removes the next pending request for the specified session.
// NULL is returned if there are no more pending devices for the specified session.
// Note that, if non-NULL is returned, the pointer returned is the pointer that was
// passed in to RDPEVNTLIST_AddPendingRequest.  
PVOID RDPEVNTLIST_DequeueRequest(
                    IN RDPEVNTLIST list,
                    IN ULONG sessionID
                    );

// Get the first session ID in the set of currently managed sessions. A 
// session is managed if there are any pending requests or events.  A session 
// is no longer managed when there are no longer any pending requests or events.
//
// This session is useful for cleaning up pending requests and pending events.
BOOL RDPEVNTLLIST_GetFirstSessionID(
                    IN RDPEVNTLIST list,
                    IN ULONG *pSessionID
                    );

// Peek at the next pending event for the specified session, without dequeueing
// it.  NULL is returned if there are no more pending events for the specified 
// session.  Note that, if non-NULL is returned, the pointer returned is the 
// pointer that was passed in to RDPEVNTLIST_EnqueueEvent.  

BOOL RDPEVNTLIST_PeekNextEvent(
    IN RDPEVNTLIST list,
    IN ULONG sessionID,
    PVOID *eventPtr,
    OPTIONAL IN OUT ULONG *type,
    OPTIONAL IN OUT DrDevice **devicePtr    
    );

// Dequeues a specific request from a session's request list.  The dequeued request
// is returned if it is found.  Otherwise, NULL is returned.
PVOID RDPEVNTLIST_DequeueSpecificRequest(
    IN RDPEVNTLIST list,
    IN ULONG sessionID,  
    IN PVOID request
    );
    
// Unit-Test function that can be called from a kernel-mode driver to cover all 
// functions implemented by this module.
#ifdef DBG
void RDPEVNTLIST_UnitTest();
#endif

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\serport.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    serport.h

Abstract:

    Serial port Device object handles one redirected serial port

Revision History:
--*/
#pragma once

class DrSerialPort : public DrPrinterPort
{
private:
    NTSTATUS CreateSerialPort(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg);

public:
    DrSerialPort(SmartPtr<DrSession> &Session, ULONG DeviceType, 
            ULONG DeviceId, PUCHAR PreferredDosName);

    virtual NTSTATUS Initialize(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg, ULONG Length);
    virtual BOOL ShouldCreatePort();
    virtual BOOL ShouldCreatePrinter();    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\serport.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    serport.cpp

Abstract:

    Serial port Device object handles one redirected serial port

Revision History:
--*/
#include "precomp.hxx"
#define TRC_FILE "serport"
#include "trc.h"

extern PDEVICE_OBJECT RDPDYN_PDO; // This still needs a happier home
//	remove this ... when I find out where I really need to be accessing this.
const GUID GUID_CLASS_COMPORT =
		{ 0x86e0d1e0L, 0x8089, 0x11d0, { 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x73 } };

DrSerialPort::DrSerialPort(SmartPtr<DrSession> &Session, ULONG DeviceType, ULONG DeviceId, 
            PUCHAR PreferredDosName) : DrPrinterPort(Session, DeviceType, DeviceId, PreferredDosName)
{
    BEGIN_FN("DrSerialPort::DrSerialPort");
    SetClassName("DrSerialPort");
    _PortType = FILE_DEVICE_SERIAL_PORT;    
}

NTSTATUS DrSerialPort::Initialize(PRDPDR_DEVICE_ANNOUNCE DeviceAnnounce, ULONG Length)
{
    NTSTATUS Status;

    BEGIN_FN("DrSerialPort::Initialize");

    if (ShouldCreatePort()) {
        Status = DrPrinterPort::Initialize(DeviceAnnounce, Length);
    
        if (NT_SUCCESS(Status) && _Session->GetClientCapabilitySet().PortCap.version > 0) {
            Status = CreateSerialPort(DeviceAnnounce);    	    
        }
    }
    else {
        Status = STATUS_SUCCESS;
    }
    return Status;
}

BOOL DrSerialPort::ShouldCreatePrinter()
{
    BEGIN_FN("DrSerialPort::ShouldCreatePrinter");
    return FALSE;
}

BOOL DrSerialPort::ShouldCreatePort()
{
    BEGIN_FN("DrSerialPort::ShouldCreatePort");
    return !_Session->DisableComPortMapping();
}


NTSTATUS DrSerialPort::CreateSerialPort(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg)
{
    NTSTATUS Status;
    UNICODE_STRING PortName;
    WCHAR PortNameBuff[PREFERRED_DOS_NAME_SIZE];
    USHORT OemCodePage, AnsiCodePage;
	NTSTATUS status;
    INT len, comLen;
    ULONG portAnnounceEventReqSize;
    PRDPDR_PORTDEVICE_SUB portAnnounceEvent;

    BEGIN_FN("DrSerialPort::CreateSerialPort");
    
    //
    // Convert the com name
    //

    PortName.MaximumLength = sizeof(PortNameBuff);
    PortName.Length = 0;
    PortName.Buffer = &PortNameBuff[0];
    memset(&PortNameBuff, 0, sizeof(PortNameBuff));

    comLen = strlen((char *)_PreferredDosName);
    RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);
    len = ConvertToAndFromWideChar(AnsiCodePage, PortName.Buffer, 
            PortName.MaximumLength, (char *)_PreferredDosName, 
            comLen, TRUE);

    if (len != -1) {

        //
        // We need just the COMx portion for later...
        //

        PortName.Length = (USHORT)len;
        PortName.Buffer[len/sizeof(WCHAR)] = L'\0';
    } else {
	     TRC_ERR((TB, "Error converting comName"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    //  Allocate the port device announce buffer.
    //
    Status = CreatePortAnnounceEvent(devAnnounceMsg, NULL, 0, L"", 
            &portAnnounceEventReqSize);

    ASSERT(Status == STATUS_BUFFER_TOO_SMALL);

    if (Status != STATUS_BUFFER_TOO_SMALL) {
    	goto CleanUpAndReturn;
    }

    portAnnounceEvent = (PRDPDR_PORTDEVICE_SUB)new(NonPagedPool) 
            BYTE[portAnnounceEventReqSize];

    if (portAnnounceEvent == NULL) {
        TRC_ERR((TB, "Unable to allocate portAnnounceEvent"));
        Status = STATUS_NO_MEMORY;
        goto CleanUpAndReturn;
    }

    //
    //  Create the port anounce message.
    //
    Status = CreatePortAnnounceEvent(devAnnounceMsg, portAnnounceEvent,
            portAnnounceEventReqSize, PortName.Buffer, NULL);

    if (Status != STATUS_SUCCESS) {
        delete portAnnounceEvent;
#if DBG
        portAnnounceEvent = NULL;
#endif
        goto CleanUpAndReturn;
    }

    //
    //  Dispatch the event to the associated session.
	//
    Status = RDPDYN_DispatchNewDevMgmtEvent(
                                portAnnounceEvent,
                                _Session->GetSessionId(),
                                RDPDREVT_PORTANNOUNCE,
								NULL
                                );

    //
	 // Create the device map entry.
    //
    // Where you might normally have:
    //      Value Name          Value
    //      \Device\Serial0     COM1
    //
    // We will put:
    //      Value Name          Value
    //      COM1                COM1
    //
	 //
    
    status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP, L"SERIALCOMM",
										   PortName.Buffer, REG_SZ,
										   PortName.Buffer, 
										   PortName.Length + sizeof(WCHAR));

CleanUpAndReturn:
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\scardss.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    scardss.cpp

Abstract:

    Smart card subsystem Device object handles one redirected smart card subsystem

Revision History:

    JoyC    9/11/2000   Created
    
--*/
#include "precomp.hxx"
#define TRC_FILE "scardss"
#include "trc.h"
#include "scioctl.h"

DrSmartCard::DrSmartCard(SmartPtr<DrSession> &Session, ULONG DeviceType, ULONG DeviceId, 
            PUCHAR PreferredDosName) : DrDevice(Session, DeviceType, DeviceId, PreferredDosName)
{
    BEGIN_FN("DrSmartCard::DrSmartCard");
    SetClassName("DrSmartCard");    
    _SmartCardState = dsCreated;
    TRC_NRM((TB, "Create SmartCard object = %p", this));
}

BOOL DrSmartCard::IsDeviceNameValid()
{
    BEGIN_FN("DrSmartCard::IsDeviceNameValid");
    BOOL fRet = FALSE;
    //
    // device name is valid only if it contains the string
    // "SCARD"
    //
    if (!strcmp((char*)_PreferredDosName, DR_SMARTCARD_SUBSYSTEM)) {
        fRet = TRUE;
    }
    
    ASSERT(fRet);
    return fRet;
}

NTSTATUS DrSmartCard::Initialize(PRDPDR_DEVICE_ANNOUNCE DeviceAnnounce, ULONG Length)
{
    NTSTATUS Status;
    DrSmartCardState smartcardState;

    BEGIN_FN("DrSmartCard::Initialize");

    if (!IsDeviceNameValid()) {
        return STATUS_INVALID_PARAMETER;
    }
            
    Status = DrDevice::Initialize(DeviceAnnounce, Length); 
    
    // Initialize the device ref count if not already initialized
    smartcardState = (DrSmartCardState)InterlockedExchange((long *)&_SmartCardState, dsInitialized);
    if (smartcardState == dsCreated) {
        _CreateRefCount = 0;
    }
        
    return Status;
}

void DrSmartCard::ClientConnect(PRDPDR_DEVICE_ANNOUNCE devAnnouceMsg, ULONG Length)
{
    
    SmartPtr<DrExchange> Exchange;
    ListEntry *ListEnum;
    USHORT Mid;

    BEGIN_FN("DrSmartCard::ClientConnect");
    
    // Set the smartcard device to be connected by the client
    // And set the real device id 
    _DeviceStatus = dsConnected;
    _DeviceId = devAnnouceMsg->DeviceId;

    LONG l;
    l = InterlockedIncrement(&_CreateRefCount);
    
    // walk through the mid list that's waiting on the client
    // smartcard subsystem comes online and signal them
    _MidList.LockShared();
    ListEnum = _MidList.First();
    while (ListEnum != NULL) {
        
        Mid = (USHORT)ListEnum->Node();
        if (_Session->GetExchangeManager().Find(Mid, Exchange)) {
            if (MarkBusy(Exchange)) {
                DrIoContext *Context = NULL;
                PRX_CONTEXT RxContext;
                       
                Context = (DrIoContext *)Exchange->_Context;
                ASSERT(Context != NULL);

                //
                //  If the IRP was timed out, then we just discard this exchange
                //
                if (Context->_TimedOut) {
                    TRC_NRM((TB, "Irp was timed out"));
                    DiscardBusyExchange(Exchange);                                        
                }
                else {
                    RxContext = Context->_RxContext;
                    if (RxContext != NULL) {
                        CompleteBusyExchange(Exchange, STATUS_SUCCESS, 0);
                    } else {
                        TRC_NRM((TB, "Irp was cancelled"));
                        DiscardBusyExchange(Exchange);
                    }
                }                                                               
            }
        }

        ListEnum = _MidList.Next(ListEnum);
    }

    _MidList.Unlock();                    
}

NTSTATUS DrSmartCard::Create(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    PMRX_SRV_OPEN SrvOpen = RxContext->pRelevantSrvOpen;
    PMRX_SRV_CALL SrvCall = RxContext->Create.pSrvCall;
    PMRX_NET_ROOT NetRoot = RxContext->Create.pNetRoot;
    SmartPtr<DrSession> Session = _Session;
    SmartPtr<DrFile> FileObj;
    SmartPtr<DrDevice> Device(this);

    BEGIN_FN("DrSmartCard::Create");

    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_CREATE);

    //
    //  Security check the irp.
    //
    Status = VerifyCreateSecurity(RxContext, Session->GetSessionId());

    if (NT_ERROR(Status)) {
        return Status;
    }

    //
    // We already have an exclusive lock on the fcb. Finish the create.
    //

    if (NT_SUCCESS(Status)) {
        //
        // JC: Worry about this when do buffering
        //
        SrvOpen->Flags |= SRVOPEN_FLAG_DONTUSE_WRITE_CACHING;
        SrvOpen->Flags |=  SRVOPEN_FLAG_DONTUSE_READ_CACHING;

        RxContext->pFobx = RxCreateNetFobx(RxContext, RxContext->pRelevantSrvOpen);

        if (RxContext->pFobx != NULL) {
            // Fobx keeps a reference to the device so it won't go away

            AddRef();
            RxContext->pFobx->Context = (DrDevice *)this;
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // We are using a file object to keep track of file open instance
    // and any information stored in the mini-redir for this instance
    //
    if (NT_SUCCESS(Status)) {
        
        // NOTE: the special FileId agreed upon by both the client
        // and server code is used here as the FileId
        FileObj = new(NonPagedPool) DrFile(Device, DR_SMARTCARD_FILEID);
    
        if (FileObj) {
            //
            //  Explicit reference the file object here
            //
            FileObj->AddRef();
            RxContext->pFobx->Context2 = (VOID *)(FileObj);                                       
        }
        else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // We don't send the create request to the client, always return TRUE
    //
    if (NT_SUCCESS(Status)) {
        LONG l;
        l = InterlockedIncrement(&_CreateRefCount);
        FinishCreate(RxContext);
    } 
    else {
        // Release the Device Reference
        if (RxContext->pFobx != NULL) {
            ((DrDevice *)RxContext->pFobx->Context)->Release();
            RxContext->pFobx->Context = NULL;          
        }
    }
    
    return Status;
}
    
NTSTATUS DrSmartCard::Close(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    SmartPtr<DrDevice> Device = static_cast<DrDevice*>(this);

    BEGIN_FN("DrSmartCard::Close");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(Session != NULL);
    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_CLOSE);

    // Remove the smartcard subsystem if we close the last handle
    LONG l;

    if ((l = InterlockedDecrement(&_CreateRefCount)) == 0) {
        _DeviceStatus = dsDisabled;
        Session->GetDevMgr().RemoveDevice(Device);
    }
    
    return Status;    
}
    
BOOL DrSmartCard::SupportDiscon() 
{
    
    BOOL rc = TRUE;
    DrSmartCardState smartcardState;

    smartcardState = (DrSmartCardState)InterlockedExchange((long *)&_SmartCardState, dsDisconnected);

    if (smartcardState == dsInitialized) {
        
        // Remove the smartcard subsystem if we close the last handle
        LONG l;
                
        if ((l = InterlockedDecrement(&_CreateRefCount)) == 0) {
            _DeviceStatus = dsDisabled;
            rc = FALSE;
        }         
        
    }

    return rc;
}

void DrSmartCard::Disconnect () 
{
    BEGIN_FN("DrSmartCard::Disconnect");

    _DeviceStatus = dsAvailable;    
}

NTSTATUS DrSmartCard::IoControl(IN OUT PRX_CONTEXT RxContext)
{
    NTSTATUS Status = STATUS_SUCCESS;
    RxCaptureFcb;
    RxCaptureFobx;
    PMRX_NET_ROOT NetRoot = capFcb->pNetRoot;
    PMRX_SRV_CALL SrvCall = NetRoot->pSrvCall;
    SmartPtr<DrSession> Session = _Session;
    DrFile *pFile = (DrFile *)RxContext->pFobx->Context2;
    SmartPtr<DrFile> FileObj = pFile;
    PRDPDR_IOREQUEST_PACKET pIoPacket;
    PLOWIO_CONTEXT LowIoContext  = &RxContext->LowIoContext;
    ULONG cbPacketSize = sizeof(RDPDR_IOREQUEST_PACKET) + 
            LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    ULONG IoControlCode = LowIoContext->ParamsFor.IoCtl.IoControlCode;
    ULONG InputBufferLength = LowIoContext->ParamsFor.IoCtl.InputBufferLength;
    ULONG OutputBufferLength = LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
    PVOID InputBuffer = LowIoContext->ParamsFor.IoCtl.pInputBuffer;
    PVOID OutputBuffer = LowIoContext->ParamsFor.IoCtl.pOutputBuffer;
    
    BEGIN_FN("DrDevice::IoControl");

    //
    // Make sure it's okay to access the Client at this time
    // This is an optimization, we don't need to acquire the spin lock,
    // because it is okay if we're not, we'll just catch it later
    //

    ASSERT(Session != NULL);
    ASSERT(RxContext != NULL);
    ASSERT(RxContext->MajorFunction == IRP_MJ_DEVICE_CONTROL || 
            RxContext->MajorFunction == IRP_MJ_INTERNAL_DEVICE_CONTROL ||
            RxContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL);
    
    //if (COMPARE_VERSION(Session->GetClientVersion().Minor, 
    //        Session->GetClientVersion().Major, RDPDR_MINOR_VERSION_PORTS, 
    //        RDPDR_MAJOR_VERSION_PORTS) < 0) {
    //    TRC_ALT((TB, "Failing IoCtl for client that doesn't support it"));
    //    return STATUS_NOT_IMPLEMENTED;
    //}

    //
    // Make sure the device is still enabled
    //
    if (_DeviceStatus != dsConnected && IoControlCode != SCARD_IOCTL_SMARTCARD_ONLINE) {
        TRC_ALT((TB, "Tried to send IoControl to client device which is not "
                "available. State: %ld", _DeviceStatus));
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    //  Validate the buffer
    //
    if (RxContext->CurrentIrp->RequestorMode != KernelMode) {
        __try {
            // If the buffering method is METHOD_NEITHER or METHOD_IN_DIRECT
            // then we need to probe the input buffer
            if ((IoControlCode & 0x1) && 
                    InputBuffer != NULL && InputBufferLength != 0) {
                ProbeForRead(InputBuffer, InputBufferLength, sizeof(UCHAR));
            }
                     
            // If the buffering method is METHOD_NEITHER or METHOD_OUT_DIRECT
            // then we need to probe the output buffer
            if ((IoControlCode & 0x2) && 
                    OutputBuffer != NULL && OutputBufferLength != 0) {
                ProbeForWrite(OutputBuffer, OutputBufferLength, sizeof(UCHAR));
            }
        } 
        __except (EXCEPTION_EXECUTE_HANDLER) {
            TRC_ERR((TB, "Invalid buffer parameter(s)"));
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    //  Send the request to the client
    //
    if (IoControlCode != SCARD_IOCTL_SMARTCARD_ONLINE) {
    
        pIoPacket = (PRDPDR_IOREQUEST_PACKET)new(PagedPool) BYTE[cbPacketSize];
    
        if (pIoPacket != NULL) {
            memset(pIoPacket, 0, cbPacketSize);
    
            //
            //  FS Control uses the same path as IO Control. 
            //
            pIoPacket->Header.Component = RDPDR_CTYP_CORE;
            pIoPacket->Header.PacketId = DR_CORE_DEVICE_IOREQUEST;
            pIoPacket->IoRequest.DeviceId = _DeviceId;
            pIoPacket->IoRequest.FileId = FileObj->GetFileId();
            pIoPacket->IoRequest.MajorFunction = IRP_MJ_DEVICE_CONTROL;
            pIoPacket->IoRequest.MinorFunction = 
                    LowIoContext->ParamsFor.IoCtl.MinorFunction;
            pIoPacket->IoRequest.Parameters.DeviceIoControl.OutputBufferLength =
                    LowIoContext->ParamsFor.IoCtl.OutputBufferLength;
            pIoPacket->IoRequest.Parameters.DeviceIoControl.InputBufferLength =
                    LowIoContext->ParamsFor.IoCtl.InputBufferLength;
            pIoPacket->IoRequest.Parameters.DeviceIoControl.IoControlCode =
                    LowIoContext->ParamsFor.IoCtl.IoControlCode;
    
            if (LowIoContext->ParamsFor.IoCtl.InputBufferLength != 0) {
    
                TRC_NRM((TB, "DrIoControl inputbufferlength: %lx", 
                        LowIoContext->ParamsFor.IoCtl.InputBufferLength));
    
                RtlCopyMemory(pIoPacket + 1, LowIoContext->ParamsFor.IoCtl.pInputBuffer,  
                        LowIoContext->ParamsFor.IoCtl.InputBufferLength);
            } else {
                TRC_NRM((TB, "DrIoControl with no inputbuffer"));
            }
    
            Status = SendIoRequest(RxContext, pIoPacket, cbPacketSize, 
                    (BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION));
            TRC_NRM((TB, "IoRequestWrite returned to DrIoControl: %lx", Status));
            delete pIoPacket;
        } else {
            TRC_ERR((TB, "DrIoControl unable to allocate packet: %lx", Status));
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    //
    //  This is the special IOCTL waiting for client smartcard subsystem come online
    //  We are already online, so just return
    //
    else if (_DeviceStatus == dsConnected){
        Status = STATUS_SUCCESS;
    }
    //
    //  We'll have to wait for client to come online
    //
    else {
        USHORT Mid = INVALID_MID;
        BOOL ExchangeCreated = FALSE;
        DrIoContext *Context = NULL;
        SmartPtr<DrExchange> Exchange;
        SmartPtr<DrDevice> Device(this);
        
        Status = STATUS_PENDING;

        // Need to keep a list of this.
        // on create comes back, signal them

        Context = new DrIoContext(RxContext, Device);

        if (Context != NULL) {
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (NT_SUCCESS(Status)) {

            //
            // Set up a mapping so the completion response handler can
            // find this context
            //

            TRC_DBG((TB, "Create the context for this I/O"));

            KeClearEvent(&RxContext->SyncEvent);

            ExchangeCreated = 
                _Session->GetExchangeManager().CreateExchange(this, Context, Exchange);
    
            if (ExchangeCreated) {
    
                //
                // No need to explicit Refcount for the RxContext
                // The place it's been used is the cancel routine.
                // Since CreateExchange holds the ref count.  we are okay
                //
    
                //Exchange->AddRef();
                RxContext->MRxContext[MRX_DR_CONTEXT] = (DrExchange *)Exchange;
    
                if (_MidList.CreateEntry((PVOID)Exchange->_Mid)) {
                     
                    //
                    // successfully added this entry
                    //

                    Status = STATUS_SUCCESS;
                }
                else {
                    
                    //
                    // Unable to add it to the list, clean up
                    //
                
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                }
                
            } else {
                delete Context;
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        if (NT_SUCCESS(Status)) {
    
            TRC_DBG((TB, "Setting cancel routine for Io"));
    
            //
            // Set this after sending the IO to the client
            // if cancel was requested already, we can just call the
            // cancel routine ourselves
            //
    
            Status = RxSetMinirdrCancelRoutine(RxContext,
                    MinirdrCancelRoutine);
    
            if (Status == STATUS_CANCELLED) {
                TRC_NRM((TB, "Io was already cancelled"));
    
                MinirdrCancelRoutine(RxContext);
                Status = STATUS_SUCCESS;
            }
        }
    
        if ((BOOLEAN)!BooleanFlagOn(RxContext->Flags,RX_CONTEXT_FLAG_ASYNC_OPERATION)) {    
            //
            // Some failure is going to prevent our completions routine from
            // being called. Do that work now.
            //
            if (!ExchangeCreated) {
                //
                // If we couldn't even create the exchange, we need to just 
                // complete the IO as failed
                //
        
                CompleteRxContext(RxContext, Status, 0);
            } 
            else {
                LARGE_INTEGER TimeOut;
                
                //
                // If we created the exchange and then got a transport failure
                // we'll be disconnected, and the the I/O will be completed
                // the same way all outstanding I/O is completed when we are 
                // disconnected.
                //
        
                TRC_DBG((TB, "Waiting for IoResult for synchronous request"));
                
                TimeOut = RtlEnlargedIntegerMultiply( 6000000, -1000 ); 
                Status = KeWaitForSingleObject(&RxContext->SyncEvent, UserRequest,
                        KernelMode, FALSE, &TimeOut);
                
                if (Status == STATUS_TIMEOUT) {
                    RxContext->IoStatusBlock.Status = Status;
        
                    TRC_DBG((TB, "Wait timed out"));
                    MarkTimedOut(Exchange);            
                }
                else  {
                    Status = RxContext->IoStatusBlock.Status;
                }                                
            } 
        }
        else {
            TRC_DBG((TB, "Not waiting for IoResult for asynchronous request"));
            
            //
            // Some failure is going to prevent our completions routine from
            // being called. Do that work now.
            //
            if (!ExchangeCreated) {
                //
                // If we couldn't even create the exchange, we need to just 
                // complete the IO as failed
                //
        
                CompleteRxContext(RxContext, Status, 0);
            } 
            else {
                //
                // If we created the exchange and then got a transport failure
                // we'll be disconnected, and the the I/O will be completed
                // the same way all outstanding I/O is completed when we are 
                // disconnected.
                //
            }
        
            Status = STATUS_PENDING;
        }        
    }
    
    return Status;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\scardss.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    scartss.h

Abstract:

    Smart card subsystem device object handles one redirected smart card subsystem

Revision History:

    JoyC    9/11    Created
    
--*/
#pragma once

typedef enum {
    dsCreated,
    dsInitialized,
    dsDisconnected
} DrSmartCardState;

class DrSmartCard : public DrDevice
{
private:
    
    LONG _CreateRefCount;
    DrSmartCardState _SmartCardState;
protected:
    virtual BOOL IsDeviceNameValid();
public:
    DoubleList _MidList;

    DrSmartCard(SmartPtr<DrSession> &Session, ULONG DeviceType, 
            ULONG DeviceId, PUCHAR PreferredDosName);

    virtual NTSTATUS Initialize(PRDPDR_DEVICE_ANNOUNCE devAnnounceMsg, ULONG Length);

    virtual BOOL SupportDiscon();
    virtual BOOL IsAvailable()
    {
        return (_DeviceStatus == dsAvailable || _DeviceStatus == dsConnected);
    }
    virtual void Disconnect ();

    void AddDeviceRef() {
        InterlockedIncrement(&_CreateRefCount);
    }
    virtual VOID Remove() { }

    virtual NTSTATUS Create(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS Close(IN OUT PRX_CONTEXT RxContext);
    virtual NTSTATUS IoControl(IN OUT PRX_CONTEXT RxContext);    

    void ClientConnect(PRDPDR_DEVICE_ANNOUNCE devAnnouceMsg, ULONG Length);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\session.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    session.h

Abstract:

    Session object is created to handle redirection for this session

Revision History:
--*/
#pragma once

typedef enum enmSessionStatus { // cs
    csDisconnected,                 // Not yet connected, or disconnected
    csPendingClientConfirm,         // ServerAnnounce sent, waiting for ClientConfirm
    csPendingClientReconfirm,       // Insisted on ClientId, waiting for second ClientConfirm
    csConnected,                    // All connected, ready for devices or I/O
    csExpired                       // This client is gone
} SessionState;

class DrDevice;

typedef struct tagWriteContext
{
    IO_STATUS_BLOCK IoStatusBlock;
    SmartPtr<DrSession> Session;
    PVOID BufferToFree;
    PVOID AdditionalContext;
    ISessionPacketSender *PacketSender;
    DrWriteCallback WriteCallback;    
} DrWriteContext;

//
//  Server capability set
//
typedef struct tagRDPDR_SERVER_COMBINED_CAPABILITYSET
{
     RDPDR_CAPABILITY_SET_HEADER        Header;
#define RDPDR_NUM_SERVER_CAPABILITIES   5

     RDPDR_GENERAL_CAPABILITY           GeneralCap;
#define RDPDR_SERVER_IO_CODES           0xFFFF

     RDPDR_PRINT_CAPABILITY             PrintCap;
     RDPDR_PORT_CAPABILITY              PortCap;
     RDPDR_FS_CAPABILITY                FileSysCap; 
     RDPDR_SMARTCARD_CAPABILITY         SmartCardCap;
} RDPDR_SERVER_COMBINED_CAPABILITYSET, *PRDPDR_SERVER_COMBINED_CAPABILITYSET;

//
//  Server default capability set sent to client
//
const RDPDR_SERVER_COMBINED_CAPABILITYSET SERVER_CAPABILITY_SET_DEFAULT = {
    // Capability Set Header
    {
        {
            RDPDR_CTYP_CORE,
            DR_CORE_SERVER_CAPABILITY
        },

        RDPDR_NUM_SERVER_CAPABILITIES,
        0
    },

    // General Capability
    {
        RDPDR_GENERAL_CAPABILITY_TYPE,
        sizeof(RDPDR_GENERAL_CAPABILITY),
        RDPDR_GENERAL_CAPABILITY_VERSION_01,
        RDPDR_OS_TYPE_WINNT,  // the OS type
        0,  // don't care about the version
        RDPDR_MAJOR_VERSION,
        RDPDR_MINOR_VERSION,
        RDPDR_SERVER_IO_CODES,
        0,
        RDPDR_DEVICE_REMOVE_PDUS | RDPDR_CLIENT_DISPLAY_NAME_PDU,
        0,
        0
    },

    // Printing Capability
    {
        RDPDR_PRINT_CAPABILITY_TYPE,
        sizeof(RDPDR_PRINT_CAPABILITY),
        RDPDR_PRINT_CAPABILITY_VERSION_01
    },

    // Port Capability
    {
        RDPDR_PORT_CAPABILITY_TYPE,
        sizeof(RDPDR_PORT_CAPABILITY),
        RDPDR_PORT_CAPABILITY_VERSION_01
    },

    // FileSystem Capability
    {
        RDPDR_FS_CAPABILITY_TYPE,
        sizeof(RDPDR_FS_CAPABILITY),
        RDPDR_FS_CAPABILITY_VERSION_01
    },

    // SmartCard Capability
    {
        RDPDR_SMARTCARD_CAPABILITY_TYPE,
        sizeof(RDPDR_SMARTCARD_CAPABILITY),
        RDPDR_SMARTCARD_CAPABILITY_VERSION_01
    }
};

//
//  Default client capability set sent from client
//
const RDPDR_SERVER_COMBINED_CAPABILITYSET CLIENT_CAPABILITY_SET_DEFAULT = {
    // Capability Set Header
    {
        {
            RDPDR_CTYP_CORE,
            DR_CORE_CLIENT_CAPABILITY
        },

        RDPDR_NUM_SERVER_CAPABILITIES,
        0
    },

    // General Capability
    {
        RDPDR_GENERAL_CAPABILITY_TYPE,
        sizeof(RDPDR_GENERAL_CAPABILITY),
        0,
        0,  // Need to specify the OS type
        0,  // Need to specify the OS version
        0,
        0,
        0,
        0,
        0,
        0,
        0
    },

    // Printing Capability
    {
        RDPDR_PRINT_CAPABILITY_TYPE,
        sizeof(RDPDR_PRINT_CAPABILITY),
        0
    },

    // Port Capability
    {
        RDPDR_PORT_CAPABILITY_TYPE,
        sizeof(RDPDR_PORT_CAPABILITY),
        0
    },

    // FileSystem Capability
    {
        RDPDR_FS_CAPABILITY_TYPE,
        sizeof(RDPDR_FS_CAPABILITY),
        0
    },

    // SmartCard Capability
    {
        RDPDR_SMARTCARD_CAPABILITY_TYPE,
        sizeof(RDPDR_SMARTCARD_CAPABILITY),
        0
    }
};

//
// The session is not like other RefCount objects, in that releasing the last
// reference both deletes the object and removes it from the SessionMgr. As
// a result, we need a special RefCount implementation that accomodates the
// SessionMgr lock as well as the deletion of the object in an atomic operation
//

class DrSession : public TopObj, public ISessionPacketReceiver, public ISessionPacketSender
{
private:
    LONG _crefs;
    SmartPtr<VirtualChannel> _Channel;
    DoubleList _PacketReceivers;
    KernelResource _ConnectNotificationLock;
    KernelResource _ConnectRDPDYNNotificationLock;  // Need granular locking on notifying
                                                    // RDPDYN so we don't deadlock.
    KernelResource _ChannelLock;
    ULONG _AutoClientDrives : 1;    // Automatically map client drives
    ULONG _AutoClientLpts : 1;      // Automatically install client printers
    ULONG _ForceClientLptDef : 1;   // Set default printer to client default
    ULONG _DisableCpm : 1;          // Disable Print mapping completely
    ULONG _DisableCdm : 1;          // Disable Drive mapping
    ULONG _DisableCcm : 1;          // Disable COM mapping
    ULONG _DisableLPT : 1;          // Disable LPT port
    ULONG _DisableClip : 1;         // Automatically redirect clipboard
    ULONG _DisableExe : 1;          // I have no idea
    ULONG _DisableCam : 1;          // Disable Audio mapping
    SessionState _SessionState;
    LONG _ConnectCount;
    PBYTE _ChannelBuffer;
    ULONG _ChannelBufferSize;
    KernelEvent _ChannelDeletionEvent;
    IO_STATUS_BLOCK _ReadStatus;
    ULONG _ClientId;                // Id for this client (identifies SrvCall)
    DrExchangeManager _ExchangeManager;
    ULONG _PartialPacketData;
    WCHAR _ClientName[RDPDR_MAX_COMPUTER_NAME_LENGTH];
    WCHAR _ClientDisplayName[RDPDR_MAX_CLIENT_DISPLAY_NAME];
    DrDeviceManager _DeviceManager;
    ULONG _SessionId;
    RDPDR_VERSION _ClientVersion;
    RDPDR_SERVER_COMBINED_CAPABILITYSET _CliCapabilitySet;
    RDPDR_SERVER_COMBINED_CAPABILITYSET _SrvCapabilitySet;
    BOOL _Initialized;

#if DBG 
    LONG _BufCount;

    #define DEBUG_REF_BUF() /*ASSERT (InterlockedIncrement(&_BufCount) == 1)*/
    #define DEBUG_DEREF_BUF() /*ASSERT (InterlockedDecrement(&_BufCount) == 0)*/
#else 
    #define DEBUG_REF_BUF() 
    #define DEBUG_DEREF_BUF() 

#endif

    VOID SetSessionState(SessionState inSessionState)
    {
        _SessionState = inSessionState;
    }

#if DBG
    BOOL PacketReceiverExists(ISessionPacketReceiver *PacketReceiver);
#endif // DBG

    BOOL FindChannelFromConnectIn(PULONG ChannelId, 
            PCHANNEL_CONNECT_IN ConnectIn);
    VOID DeleteChannel(BOOL Wait);
    VOID SetChannel(SmartPtr<VirtualChannel> &Channel);
    VOID RemoveDevices();
    VOID CancelClientIO();
    VOID ChannelIoFailed();
    NTSTATUS ReallocateChannelBuffer(ULONG ulNewBufferSize, 
            ULONG ulSaveBytes);

    //
    // Generic Sending and Receiving data
    // 
    NTSTATUS PrivateSendToClient(PVOID Buffer, ULONG Length, 
            ISessionPacketSender *PacketSender, DrWriteCallback WriteCallback,
            BOOL bWorkerItem, BOOL LowPrioWrite = FALSE, 
            PVOID AdditionalContext = NULL);
    
    static NTSTATUS SendCompletionRoutine(IN PDEVICE_OBJECT DeviceObject,
            IN PIRP Irp, IN PVOID Context);
    static NTSTATUS ReadCompletionRoutine(IN PDEVICE_OBJECT DeviceObject,
            IN PIRP Irp, IN PVOID Context);
    
    VOID SendCompletion(DrWriteContext *WriteContext, 
            PIO_STATUS_BLOCK IoStatusBlock);
    VOID ReadCompletion(PIO_STATUS_BLOCK IoStatusBlock);

    VOID ReadPacket();
    virtual NTSTATUS SendCompleted(PVOID Context, PIO_STATUS_BLOCK IoStatusBlock);

    //
    // Packet sending
    //
    NTSTATUS ServerAnnounceWrite();
    VOID SendClientConfirm();
    VOID SendClientCapability();
    VOID SendDeviceReply(ULONG DeviceId, NTSTATUS Result);


    //
    // Packets received
    //
    NTSTATUS OnClientIdConfirm(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket, 
            BOOL *DoDefaultRead);
    NTSTATUS InitClientCapability(PRDPDR_CAPABILITY_HEADER pCapHdr, ULONG *pPacketLen, BOOL *pCapSupported);
    NTSTATUS OnClientCapability(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket, 
            BOOL *DoDefaultRead);
    NTSTATUS OnClientName(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket,
                                     BOOL *DoDefaultRead);
    NTSTATUS OnClientDisplayName(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket,
                                     BOOL *DoDefaultRead);

public:

#if DBG
    LONG _ApcCount;
    LONG _ApcChannelRef;
#endif

    DrSession();
    virtual ~DrSession();

    //
    //  Lock/Unlock connect notification.
    //
    void LockConnectStateChange() {
        _ConnectNotificationLock.AcquireResourceExclusive();
    }
    void UnlockConnectStateChange() {
        _ConnectNotificationLock.ReleaseResource();
    }
    void LockRDPDYNConnectStateChange() {
        _ConnectRDPDYNNotificationLock.AcquireResourceExclusive();
    }
    void UnlockRDPDYNConnectStateChange() {
        _ConnectRDPDYNNotificationLock.ReleaseResource();
    }

    //
    // Session specific refcounting as discussed above
    //
    void AddRef(void) 
    { 
        ULONG crefs = InterlockedIncrement(&_crefs); 
    }
    void Release(void);

    PBYTE GetBuffer()               { return _ChannelBuffer; }
    BOOL IsConnected()                  { return _SessionState == csConnected; }
    PWCHAR GetClientName()              { return &_ClientName[0]; }

    PWCHAR GetClientDisplayName()       {
        if (_ClientDisplayName[0] != L'\0') {
            return &_ClientDisplayName[0];
        }
        else {
            return &_ClientName[0];
        }
    }

    ULONG GetSessionId()                { return _SessionId; }
    void SetSessionId(ULONG SessionId)  { _SessionId = SessionId; }
    ULONG GetState()                    { return _SessionState; }
    ULONG GetClientId()                 { return _ClientId; }
    RDPDR_VERSION &GetClientVersion()   { return _ClientVersion; }
    RDPDR_SERVER_COMBINED_CAPABILITYSET &GetClientCapabilitySet()
                                        { return _CliCapabilitySet; }
    
    BOOL AutomapDrives()            { return _AutoClientDrives != 0; }
    BOOL AutoInstallPrinters()      { return _AutoClientLpts != 0; }
    BOOL SetDefaultPrinter()        { return _ForceClientLptDef != 0; }
    BOOL DisablePrinterMapping()    { return _DisableCpm != 0; }
    BOOL DisableDriveMapping()      { return _DisableCdm != 0; }
    BOOL DisableComPortMapping()    { return _DisableCcm != 0; }
    BOOL DisableLptPortMapping()    { return _DisableLPT != 0; }
    BOOL DisableClipboardMapping()  { return _DisableClip != 0; }
    BOOL DisableExe()               { return _DisableExe != 0; }
    BOOL DisableAudioMapping()      { return _DisableCam != 0; }
    DrExchangeManager &GetExchangeManager() { return _ExchangeManager; }

    virtual BOOL RecognizePacket(PRDPDR_HEADER RdpdrHeader);
    virtual NTSTATUS HandlePacket(PRDPDR_HEADER RdpdrHeader, ULONG Length, 
            BOOL *DoDefaultRead);

    BOOL ReadMore(ULONG cbSaveData, ULONG cbWantData = 0);

    BOOL Initialize();
    NTSTATUS RegisterPacketReceiver(ISessionPacketReceiver *PacketReceiver);
    VOID RemovePacketReceiver(ISessionPacketReceiver *PacketReceiver);
    
    NTSTATUS SendToClient(PVOID Buffer, ULONG Length, 
            ISessionPacketSender *PacketSender, BOOL bWorkerItem, 
            BOOL LowPrioSend = FALSE, PVOID AdditionalContext = NULL);
    NTSTATUS SendToClient(PVOID Buffer, ULONG Length, 
            DrWriteCallback WriteCallback, BOOL bWorkerItem, 
            BOOL LowPrioSend = FALSE, PVOID AdditionalContext = NULL);

    BOOL GetChannel(SmartPtr<VirtualChannel> &Channel);
    BOOL Connect(PCHANNEL_CONNECT_IN ConnectIn, 
            PCHANNEL_CONNECT_OUT ConnectOut);
    VOID Disconnect(PCHANNEL_DISCONNECT_IN DisconnectIn, 
            PCHANNEL_DISCONNECT_OUT DisconnectOut);
    BOOL FindDeviceById(ULONG DeviceId, SmartPtr<DrDevice> &DeviceFound, 
            BOOL fMustBeValid = FALSE)
    {
        return _DeviceManager.FindDeviceById(DeviceId, DeviceFound, fMustBeValid);
    }
    BOOL FindDeviceByDosName(UCHAR* DeviceDosName, SmartPtr<DrDevice> &DeviceFound, 
            BOOL fMustBeValid = FALSE)
    {
        return _DeviceManager.FindDeviceByDosName(DeviceDosName, DeviceFound, fMustBeValid);
    }

    DrDeviceManager &GetDevMgr() {
        return _DeviceManager;
    }

#if DBG
    VOID DumpUserConfigSettings();
#endif // DBG
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\session.cpp ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    session.cpp

Abstract:

    Session object is created to handle redirection for this session

Revision History:
--*/
#include "precomp.hxx"
#define TRC_FILE "session"
#include "trc.h"

typedef enum {
    scidServerAnnounce,
    scidClientConfirm,
    scidDeviceReply,
    scidIoRequest
} DrSessionCallbackId;

DrSession::DrSession() :
    _ChannelDeletionEvent(NotificationEvent, FALSE)
{
    BEGIN_FN("DrSession::DrSession");
    
    TRC_NRM((TB, "Session Class=%p", this));   
    SetClassName("DrSession");
    _crefs = 0;
    SetSessionState(csExpired);
    _ConnectCount = 0;
    _ChannelBuffer = NULL;
    _ChannelBufferSize = 0;
    _PartialPacketData = 0;
    _Initialized = FALSE;
    _ClientDisplayName[0] = L'\0';

    //
    //  Initialize the server capability set
    //  This is the capability set that we'll send to client 
    //
    memcpy(&_SrvCapabilitySet, &SERVER_CAPABILITY_SET_DEFAULT, 
            sizeof(SERVER_CAPABILITY_SET_DEFAULT));

    //
    //  Initialize the client capability set
    //  Once we receive the client side capability, we'll combine with our local 
    //  capability and stores it.
    //
    memcpy(&_CliCapabilitySet, &CLIENT_CAPABILITY_SET_DEFAULT, 
            sizeof(CLIENT_CAPABILITY_SET_DEFAULT));


#if DBG
    _BufCount = 1;
    _ApcCount = 0;
    _ApcChannelRef = 0;
#endif
    
}

BOOL DrSession::Initialize()
{
    BOOL Registered = FALSE;
    BOOL ExchangeInitialized = FALSE;
    BOOL DeviceManagerInitialized = FALSE;

    BEGIN_FN("DrSession::Initialize");

    if (!_Initialized) {
        Registered = !NT_ERROR(RegisterPacketReceiver(this));

        if (Registered) {
            TRC_DBG((TB, "Initilazing ExchangeManager"));
            ExchangeInitialized = _ExchangeManager.Initialize(this);
        }

        if (ExchangeInitialized) {
            TRC_DBG((TB, "Initilazing DeviceManager"));
            DeviceManagerInitialized = _DeviceManager.Initialize(this);
        }

        if (DeviceManagerInitialized) {
            TRC_DBG((TB, "Allocating Channel buffer"));
            _ChannelBuffer = new UCHAR[CHANNEL_CHUNK_LENGTH];
        }

        if (_ChannelBuffer != NULL) {
            TRC_DBG((TB, "Allocated default channel buffer=%p", _ChannelBuffer));

            _ChannelBufferSize = CHANNEL_CHUNK_LENGTH;

            _Initialized = TRUE;
        } else {

            //
            // Error Path, tear down initialization steps
            // 

            if (DeviceManagerInitialized) {
                TRC_ERR((TB, "Failed to allocate default channel buffer"));

                _DeviceManager.Uninitialize();
            }

            if (ExchangeInitialized) {
                TRC_ALT((TB, "Tearing down ExchangeManager"));
                _ExchangeManager.Uninitialize();
            }

            if (Registered) {
                TRC_ALT((TB, "Unregistering for packets"));
                RemovePacketReceiver(this);
            }
        }

    }
    return _Initialized;
}

DrSession::~DrSession()
{
    BEGIN_FN("DrSession::~DrSession");
    ASSERT(_crefs == 0);

    TRC_NRM((TB, "Session is deleted=%p", this));
    
    if (_ChannelBuffer) {
        delete _ChannelBuffer;
        _ChannelBuffer = NULL;
    }
}

#if DBG
VOID DrSession::DumpUserConfigSettings()
{
    BEGIN_FN("DrSession::DumpUserConfigSettings");
    TRC_NRM((TB, "Automatically map client drives: %s", 
            _AutoClientDrives ? "True" : "False"));
    TRC_NRM((TB, "Automatically map client printers: %s", 
            _AutoClientLpts ? "True" : "False"));
    TRC_NRM((TB, "Force client printer as default: %s", 
            _ForceClientLptDef ? "True" : "False"));
    TRC_NRM((TB, "Disable client printer mapping: %s", 
            _DisableCpm ? "True" : "False"));
    TRC_NRM((TB, "Disable client drive mapping: %s", 
            _DisableCdm ? "True" : "False"));
    TRC_NRM((TB, "Disable client COM port mapping: %s", 
            _DisableCcm ? "True" : "False"));
    TRC_NRM((TB, "Disable client printer mapping: %s", 
            _DisableLPT ? "True" : "False"));
    TRC_NRM((TB, "Disable clipboard redirection: %s", 
            _DisableClip ? "True" : "False"));
    TRC_NRM((TB, "DisableExe: %s", 
            _DisableExe ? "True" : "False"));
    TRC_NRM((TB, "Disable client audio mapping: %s", 
            _DisableCam ? "True" : "False"));
}
#endif // DBG

void DrSession::Release(void)
{
    BEGIN_FN("DrSession::Release");
    ULONG crefs;
    ASSERT(_crefs > 0);

    ASSERT(Sessions != NULL);
    Sessions->LockExclusive();
    if ((crefs = InterlockedDecrement(&_crefs)) == 0)
    {
        TRC_DBG((TB, "Deleting object type %s", 
                _ClassName));
        if (_Initialized) {
            Sessions->Remove(this);
        }
        Sessions->Unlock();
        delete this;
    } else {
        TRC_DBG((TB, "Releasing object type %s to %d", 
                _ClassName, crefs));
        ASSERT(_Initialized);
        Sessions->Unlock();
    }
}

BOOL DrSession::Connect(PCHANNEL_CONNECT_IN ConnectIn, 
        PCHANNEL_CONNECT_OUT ConnectOut)
{
    ULONG i;
    SmartPtr<VirtualChannel> Channel = NULL;
    BOOL ExchangeManagerStarted = FALSE;
    NTSTATUS Status;
    PCHANNEL_CONNECT_DEF Channels;

    BEGIN_FN("DrSession::Connect");
    

    _ConnectNotificationLock.AcquireResourceExclusive();

    if (InterlockedCompareExchange(&_ConnectCount, 1, 0) != 0) {
        TRC_ALT((TB, "RDPDR connect reentry called"));
        ASSERT(FALSE);
        _ConnectNotificationLock.ReleaseResource();        
        return FALSE;
    }

    //ASSERT(_ApcChannelRef == 0);
    ASSERT(GetState() == csExpired);

    //
    // Need granular locking on notifying RDPDYN so we don't deadlock.
    //
    LockRDPDYNConnectStateChange();
        
    //
    //  Tell RDPDYN about the new session.
    //
    RDPDYN_SessionConnected(ConnectIn->hdr.sessionID);

    UnlockRDPDYNConnectStateChange();

    //
    //  Clear the channel event
    //
    _ChannelDeletionEvent.ResetEvent();

    //
    // Save all the user settings, we may need them later.
    // This is conceptually "wasteful" because we don't care
    // about some of them. But some may be supported in the
    // the future, and the size is padded out to a ULONG anyway
    //

    _SessionId = ConnectIn->hdr.sessionID;
    _AutoClientDrives = ConnectIn->fAutoClientDrives;
    _AutoClientLpts = ConnectIn->fAutoClientLpts;
    _ForceClientLptDef = ConnectIn->fForceClientLptDef;
    _DisableCpm = ConnectIn->fDisableCpm;
    _DisableCdm = ConnectIn->fDisableCdm;
    _DisableCcm = ConnectIn->fDisableCcm;
    _DisableLPT = ConnectIn->fDisableLPT;
    _DisableClip = ConnectIn->fDisableClip;
    _DisableExe = ConnectIn->fDisableExe;
    _DisableCam = ConnectIn->fDisableCam;
    _ClientId = 0xFFFFFFFF;

#if DBG
    DumpUserConfigSettings();
#endif // DBG

    //
    // Is our channel name in the list of channels on which the client is 
    // prepared to communicate?
    //


    if (!FindChannelFromConnectIn(&i, ConnectIn)) {
        TRC_ALT((TB, "Undoctored client"));        
        Status = STATUS_UNSUCCESSFUL;
    }
    else {
        Status = STATUS_SUCCESS;
    }
    
    if (NT_SUCCESS(Status)) {
        ExchangeManagerStarted = _ExchangeManager.Start();
    }

    if (ExchangeManagerStarted) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    if (NT_SUCCESS(Status)) {
        Channel = new(NonPagedPool) VirtualChannel;

        if (Channel != NULL) {
            Channels = (PCHANNEL_CONNECT_DEF)(ConnectIn + 1);
            if (Channel->Create(ConnectIn->hdr.IcaHandle,
                    ConnectIn->hdr.sessionID, Channels[i].ID, 
                    _ChannelDeletionEvent.GetEvent())) {
                TRC_NRM((TB, "Channel opened for session %d",
                        ConnectIn->hdr.sessionID));
                Status = STATUS_SUCCESS;
            } else {
                TRC_ALT((TB, "Channel not opened for session %d",
                        ConnectIn->hdr.sessionID));
                Status = STATUS_UNSUCCESSFUL;
            }
        }
    }

    TRC_NRM((TB, "Channel open result: %lx", Status));

    if (NT_SUCCESS(Status)) {

        _Channel = Channel;

        //
        // Send a server announce
        //

        Status = ServerAnnounceWrite();
        if (Status == STATUS_PENDING) {
            Status = STATUS_SUCCESS;
        }

        if (!NT_SUCCESS(Status)) {
            TRC_ERR((TB, "DrServerAnnounceWrite returned error: "
                    "%lx", Status));
        }
    }

    if (NT_SUCCESS(Status)) {

        SetSessionState(csPendingClientConfirm);

        //
        // Start Reading.
        //

        ReadPacket();
    }

    if (NT_SUCCESS(Status)) {

        //
        // Release the Notification resource
        //
        _ConnectNotificationLock.ReleaseResource();
        
    } else {

        TRC_ALT((TB, "Cleaning up DrOnSession create work due "
                "to error condition: %lx.", Status));

        //
        // Since we just Closed the channel, NULL out the handle
        // to it before deleting the client entry
        //

        if (Channel != NULL) {
            Channel = NULL;
            DeleteChannel(TRUE);
        }

        if (ExchangeManagerStarted) {
            _ExchangeManager.Stop();
        }

        //
        // Need granular locking on notifying RDPDYN so we don't deadlock.
        //
        LockRDPDYNConnectStateChange();

        SetSessionState(csExpired);

        //  Notify RDPDYN about the session terminating.  
        //  We won't do this later because we're not making this a 
        //  doctored session after all, so we need this to
        //  properly frame this from an RDPDYN perspective
        RDPDYN_SessionDisconnected(ConnectIn->hdr.sessionID);

        UnlockRDPDYNConnectStateChange();

        LONG Count = InterlockedCompareExchange(&_ConnectCount, 0, 1);
        ASSERT(Count == 1);

        //
        //  Release the resource and dereference the client entry.
        //
        _ConnectNotificationLock.ReleaseResource();        
    }

    return NT_SUCCESS(Status);
}

VOID DrSession::Disconnect(PCHANNEL_DISCONNECT_IN DisconnectIn, 
        PCHANNEL_DISCONNECT_OUT DisconnectOut)
{
    BEGIN_FN("DrSession::Disconnect");
    
    
    //
    // Ensure synchronization of notification
    //
    _ConnectNotificationLock.AcquireResourceExclusive();

    //
    // Delete our reference to the channel handle and close it
    //

    DeleteChannel(TRUE);

    //
    // Enumerate the atlas entries and cancel the I/O
    //

    _ExchangeManager.Stop();

    //
    // Enumerate the devices and mark them disconnected
    //

    _DeviceManager.Disconnect();


    //
    // Need granular locking on notifying RDPDYN so we don't deadlock.
    //
    LockRDPDYNConnectStateChange();

    //
    //  Notify RDPDYN about the session terminating.  
    // This function is called when an existing session is disconnected.
    ASSERT(_SessionId == DisconnectIn->hdr.sessionID);

    RDPDYN_SessionDisconnected(DisconnectIn->hdr.sessionID);

    //
    // Avoid creating additional references which would only lead to
    // disappointing results. DrOnSessionDisconnect sets this to
    // csDisconnected, so we have to be after that
    //

    SetSessionState(csExpired);

    UnlockRDPDYNConnectStateChange();

    TRC_NRM((TB, "Session: %d is disconnected", _SessionId));

    LONG Count = InterlockedCompareExchange(&_ConnectCount, 0, 1);
    ASSERT(Count == 1);

    //
    // Release the resource before we dereference (and potentially
    // delete) the ClientEntry
    //
    _ConnectNotificationLock.ReleaseResource();
}

BOOL DrSession::FindChannelFromConnectIn(PULONG ChannelId,
        PCHANNEL_CONNECT_IN ConnectIn)
/*++

Routine Description:
    Finds the appropriate channel id given a ConnectIn structure

Arguments:
    ChannelId - Where to put the channel if it is found

Return Value:
    Whether the channel was found

--*/
{
    ANSI_STRING DrChannelName;
    ANSI_STRING ChannelSearch;
    PCHANNEL_CONNECT_DEF Channels = (PCHANNEL_CONNECT_DEF)(ConnectIn + 1);

    BEGIN_FN("DrSession::FindChannelFromConnectIn");

    TRC_NRM((TB, "%ld Channels", ConnectIn->channelCount));
    RtlInitString(&DrChannelName, DR_CHANNEL_NAME);
    for (*ChannelId = 0; *ChannelId < ConnectIn->channelCount; *ChannelId++) {
        Channels[*ChannelId].name[CHANNEL_NAME_LEN] = 0;
        RtlInitString(&ChannelSearch, Channels[*ChannelId].name);
        TRC_DBG((TB, "Found channel %wZ", &ChannelSearch));
        if (RtlEqualString(&DrChannelName, &ChannelSearch, TRUE))
            break;
    }

    return (*ChannelId != ConnectIn->channelCount);
}

VOID DrSession::DeleteChannel(BOOL bWait)
/*++

Routine Description:

    Safely removes the Channel from the session and ditches the reference

Arguments:

    ClientEntry - The relevant client entry

Return Value:

    None

Notes:

--*/
{
    SmartPtr<VirtualChannel> Channel;

    BEGIN_FN("DrSession::DeleteChannel");
    DrAcquireSpinLock();
    Channel = _Channel;
    _Channel = NULL;
    DrReleaseSpinLock();

    if (Channel != NULL) {

        //
        // Do the ZwClose on it so all I/O will be cancelled
        //

        Channel->SubmitClose();

        //
        // Remove our reference to it so it can go to zero
        //

        Channel = NULL;
    }

    if (bWait) {
        //
        // Wait for all of our Irps to finish.
        //

#if DBG
        LARGE_INTEGER Timeout;
        NTSTATUS Status;

        KeQuerySystemTime(&Timeout);
        Timeout.QuadPart += 6000000000; // 10 min in hundreds of nano-seconds

        while ((Status = _ChannelDeletionEvent.Wait(UserRequest, KernelMode,
                TRUE, &Timeout)) != STATUS_SUCCESS) {

            //TRC_ASSERT(Status != STATUS_TIMEOUT, 
            //      (TB, "Timed out waiting for channel 0x%p", Channel));
          
            if (Status == STATUS_TIMEOUT) {

                TRC_DBG((TB, "Timed out waiting for channel 0x%p", Channel));
              
                //
                // If we just hit go in the debugger, we want to give it 
                // just another 2 min
                //
                    
                KeQuerySystemTime(&Timeout);
                Timeout.QuadPart += 1200000000; // 2 min in hundreds of nano-seconds
            }

            // Do nothing, just hit an alerted state
        }
#else // !DBG
        while (_ChannelDeletionEvent.Wait(UserRequest, KernelMode, 
                TRUE) != STATUS_SUCCESS) {

            // Do nothing, just hit an alerted state
        }
#endif // DBG

        //ASSERT(_ApcChannelRef == 0);

        _ChannelDeletionEvent.ResetEvent();

    } // if (bWait)
}

BOOL
DrSession::GetChannel(
    SmartPtr<VirtualChannel> &Channel
    )
/*++

Routine Description:

    Safely gets the Channel from the session and adds a reference

Arguments:

    ClientEntry - The relevant client entry

Return Value:

    The freshly referenced channel or NULL

Notes:

--*/
{
    BEGIN_FN("DrSession::GetChannel");

    _ChannelLock.AcquireResourceShared();
    Channel = _Channel;
    _ChannelLock.ReleaseResource();
    return Channel != NULL;
}

VOID
DrSession::SetChannel(
    SmartPtr<VirtualChannel> &Channel
    )
/*++

Routine Description:

    Safely sets the Channel for the session

Arguments:

    ClientEntry - The relevant client entry

Return Value:

    None

Notes:

--*/
{
    BEGIN_FN("DrSession::SetChannel");
    
    _ChannelLock.AcquireResourceExclusive();
    _Channel = Channel;
    _ChannelLock.ReleaseResource();
}

NTSTATUS DrSession::SendToClient(PVOID Buffer, ULONG Length, 
        ISessionPacketSender *PacketSender, BOOL bWorkerItem,  
        BOOL LowPrioSend, PVOID AdditionalContext)
{
    BEGIN_FN("DrSession::SendToClient A");
    return PrivateSendToClient(
                        Buffer, Length, PacketSender, NULL, bWorkerItem, 
                        LowPrioSend, AdditionalContext
                        );
}

NTSTATUS DrSession::SendToClient(PVOID Buffer, ULONG Length, 
        DrWriteCallback WriteCallback, BOOL bWorkerItem,
        BOOL LowPrioSend, PVOID AdditionalContext)
{
    BEGIN_FN("DrSession::SendToClient B");
    return PrivateSendToClient(
                        Buffer, Length, NULL, WriteCallback, bWorkerItem, 
                        LowPrioSend, AdditionalContext
                        );
}

NTSTATUS DrSession::PrivateSendToClient(PVOID Buffer, ULONG Length, 
        ISessionPacketSender *PacketSender, DrWriteCallback WriteCallback,
        BOOL bWorkerItem, BOOL LowPrioSend, PVOID AdditionalContext)
/*++

Routine Description:

    Sends data to the client. Handles details of allocating contextual memory
    and verifying the virtual channel is available, etc.

Arguments:

    Buffer - The data to be sent
    Length - the length of Buffer in bytes
    CallbackId - An identifier for the completion work
    AdditionalContext - Context specific to CallbackId, NULL by default

Return Value:

    NTSTATUS code indicating communication status

--*/
{
    NTSTATUS Status;
    RDPDR_SERVER_ANNOUNCE_PACKET ServerAnnouncePacket;
    SmartPtr<VirtualChannel> Channel;
    DrWriteContext *WriteContext = NULL;

    BEGIN_FN("DrSession::SendToClient C");
    ASSERT(Buffer != NULL);
    ASSERT(Length > 0);

    if (GetChannel(Channel)) {
        TRC_DBG((TB, "Got session channel"));

        WriteContext = new DrWriteContext;

        if (WriteContext != NULL) {
            TRC_DBG((TB, "WriteContext allocated, sending"));

            WriteContext->Session = this;
            
            if (bWorkerItem) {
                WriteContext->BufferToFree = Buffer;
            }
            else {
                WriteContext->BufferToFree = NULL;
            }

            WriteContext->PacketSender = PacketSender;
            WriteContext->WriteCallback = WriteCallback;
            WriteContext->AdditionalContext = AdditionalContext;
            
            Status = Channel->Write(SendCompletionRoutine,
                    WriteContext, Buffer, Length, bWorkerItem, LowPrioSend);
            
        } else {
            TRC_ERR((TB, "DrServerAnnounceWrite  unable to allocate "
                    "WriteContext"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else {
        TRC_NRM((TB, "Channel not available"));
        Status = STATUS_DEVICE_NOT_CONNECTED;
    }
    return Status;
}

NTSTATUS DrSession::SendCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp, 
    IN PVOID Context
    )
/*++

Routine Description:

    IoCompletion routine once a Server Announce packet has been sent to
    the client

Arguments:

    Context - Contains a pointer to the ClientEntry information
    IoStatusBlock - Status information about the operation. The Information
            indicates the actual number of bytes written
    Reserved - Reserved

Return Value:

    None

--*/
{
    DrWriteContext *WriteContext = (DrWriteContext *)Context;

    BEGIN_FN_STATIC("DrSession::SendCompletionRoutine");
    ASSERT(Context != NULL);

    if (Irp) {
        TRC_NRM((TB, "status: 0x%x", Irp->IoStatus.Status));
        WriteContext->Session->SendCompletion(WriteContext, &(Irp->IoStatus));
        IoFreeIrp(Irp);
    }
    else {
        TRC_NRM((TB, "status: 0x%x", WriteContext->IoStatusBlock.Status));
        WriteContext->Session->SendCompletion(WriteContext, &(WriteContext->IoStatusBlock));
    }

    if (WriteContext->BufferToFree) {
        delete (WriteContext->BufferToFree);
    }
    delete WriteContext;

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID DrSession::SendCompletion(DrWriteContext *WriteContext, 
        PIO_STATUS_BLOCK IoStatusBlock)
{
    NTSTATUS Status = STATUS_SUCCESS;

    BEGIN_FN("DrSession::SendCompletion");
    //
    // One of these should be null
    //
    ASSERT(WriteContext->PacketSender == NULL || 
            WriteContext->WriteCallback == NULL);

    if (WriteContext->PacketSender != NULL) {
        Status = WriteContext->PacketSender->SendCompleted(
                WriteContext->AdditionalContext, IoStatusBlock);
    } else if (WriteContext->WriteCallback != NULL) {
        Status = WriteContext->WriteCallback(
                WriteContext->AdditionalContext, IoStatusBlock);
    }

    if (!NT_ERROR(Status)) {
        TRC_NRM((TB, "SendCompletion succeded"));
    } else {
        TRC_NRM((TB, "SendCompletion failed"));
        ChannelIoFailed();
    }
}

NTSTATUS DrSession::ServerAnnounceWrite()
{
    NTSTATUS Status;
    RDPDR_SERVER_ANNOUNCE_PACKET ServerAnnouncePacket;

    BEGIN_FN("DrSession::ServerAnnounceWrite");

    //
    // Construct the packet
    //
    ServerAnnouncePacket.Header.Component = RDPDR_CTYP_CORE;
    ServerAnnouncePacket.Header.PacketId = DR_CORE_SERVER_ANNOUNCE;
    ServerAnnouncePacket.VersionInfo.Major = RDPDR_MAJOR_VERSION;
    ServerAnnouncePacket.VersionInfo.Minor = RDPDR_MINOR_VERSION;
    ServerAnnouncePacket.ServerAnnounce.ClientId = _ClientId;

    //
    //  This is synchronous write
    //
    Status = SendToClient(&ServerAnnouncePacket, sizeof(RDPDR_SERVER_ANNOUNCE_PACKET), this, FALSE);
    
    return Status;
}

VOID DrSession::ReadPacket()
{
    NTSTATUS Status;
    SmartPtr<VirtualChannel> Channel;

    BEGIN_FN("DrSession::ReadPacket");

    ASSERT(_ChannelBuffer != NULL);
    ASSERT(_ChannelBufferSize > 0);

    if (GetChannel(Channel)) {
        TRC_DBG((TB, "Got session channel"));

        //
        // It'd be ineficient to allocate a SmartPtr just to do an
        // AddRef when instead we'd neet to remember to call delete on
        // the allocated memory. Thus the explicit AddRef.
        //

        AddRef();
        _PartialPacketData = 0;

        DEBUG_DEREF_BUF();

        Status = Channel->Read(ReadCompletionRoutine, this, 
                               _ChannelBuffer, _ChannelBufferSize, FALSE);

        if (!NT_SUCCESS(Status)) {

            //
            // Frame the AddRef above for error case
            //

            Release();
            ChannelIoFailed();
        }
    } else {
        TRC_NRM((TB, "Channel not available"));
        Status = STATUS_DEVICE_NOT_CONNECTED;
    }
}

BOOL DrSession::ReadMore(ULONG cbSaveData, ULONG cbWantData)
/*++

Routine Description:

    Initiates a read operation on the channel to retrieve more
    data and place it in the channel buffer after the
    current data. Sets an appropriate completion handler.

Arguments:

    cbSaveData - Data to be saved from the previous read
    cbWantData - Expected total size (including saved data) needed

Return Value:

    BOOL - True if reading worked, False otherwise

--*/
{
    ULONG cbNewBufferSize = _ChannelBufferSize;
    NTSTATUS Status = STATUS_SUCCESS;
    SmartPtr<VirtualChannel> Channel;

    BEGIN_FN("DrSession::ReadMore");

    if ((cbWantData != 0) && (cbNewBufferSize < cbWantData)) {
        cbNewBufferSize = ((cbWantData / CHANNEL_CHUNK_LENGTH) + 1)
                                * CHANNEL_CHUNK_LENGTH;
    }

    if (cbNewBufferSize - cbSaveData < CHANNEL_CHUNK_LENGTH) {
        cbNewBufferSize += CHANNEL_CHUNK_LENGTH;
    }

    if (cbNewBufferSize > _ChannelBufferSize ) {

        //
        // Need to expand the buffer size
        //

        TRC_NRM((TB, "Buffer full, expanding"));

        Status = ReallocateChannelBuffer(cbNewBufferSize, cbSaveData);

        if (!NT_SUCCESS(Status)) {

            // We didn't get a bigger buffer, so we really can't
            // read any more.

            TRC_ERR((TB, "Failed to expand channel buffer, %lx", Status));

            ChannelIoFailed();
        }
    }

    if (NT_SUCCESS(Status)) {

        //
        // Go ahead and read the additional data
        //

        if (GetChannel(Channel)) {
            TRC_DBG((TB, "Got session channel"));

            //
            // It'd be inefiecent to allocate a SmartPtr just to do an
            // AddRef when instead we'd neet to remember to call delete on
            // the allocated memory. Thus the explicit AddRef.
            //

            AddRef();
            _PartialPacketData = cbSaveData;

            // Deref channel buffer
            DEBUG_DEREF_BUF();

            Status = Channel->Read(ReadCompletionRoutine, this, 
                    _ChannelBuffer + cbSaveData, _ChannelBufferSize - cbSaveData, FALSE);

            if (!NT_SUCCESS(Status)) {

                //
                // Frame the AddRef above for error case
                //
                
                TRC_ERR((TB, "Failed (0x%x) to Read channel in ReadMore", Status));
                Release();
                ChannelIoFailed();
            }
        } else {
            TRC_NRM((TB, "Channel not available"));
            Status = STATUS_DEVICE_NOT_CONNECTED;
        }
    }

    return NT_SUCCESS(Status);
}

NTSTATUS DrSession::ReadCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp, 
    IN PVOID Context)
/*++

Routine Description:

    IoCompletion routine once a Server Announce packet has been sent to
    the client

Arguments:

    Context - Contains a pointer to the ClientEntry information
    IoStatusBlock - Status information about the operation. The Information
            indicates the actual number of bytes written
    Reserved - Reserved

Return Value:

    None

--*/
{
    DrSession *Session = (DrSession *)Context;

    BEGIN_FN_STATIC("DrSession::ReadCompletionRoutine");
    ASSERT(Context != NULL);

#if DBG
    InterlockedDecrement(&(Session->_ApcChannelRef));    
#endif 

    if (NT_SUCCESS(Irp->IoStatus.Status) && Irp->AssociatedIrp.SystemBuffer != NULL) {
        ASSERT(Irp->Flags & (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER | IRP_INPUT_OPERATION));
        RtlCopyMemory(Irp->UserBuffer, Irp->AssociatedIrp.SystemBuffer, Irp->IoStatus.Information);
    }

    //
    // Call the real completion routine
    //

    Session->ReadCompletion(&(Irp->IoStatus));
    
    //
    // Free the AddRef in ReadPacket()
    //

    Session->Release();

    // Free the system buffer
    if (NT_SUCCESS(Irp->IoStatus.Status) && Irp->AssociatedIrp.SystemBuffer != NULL) {
        ExFreePool(Irp->AssociatedIrp.SystemBuffer);
        Irp->AssociatedIrp.SystemBuffer = NULL;
    }
    
    //
    //  Free the irp
    //
    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID DrSession::ReadCompletion(PIO_STATUS_BLOCK IoStatusBlock)
/*++

Routine Description:

    Completion routine once a packet header has been read from
    the client. Dispatches the request to the appropriate handler

Arguments:

    None.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    BOOL fDoDefaultRead = TRUE;
    ISessionPacketReceiver *PacketReceiver;
    ListEntry *ListEnum;
    BOOL bFound = FALSE;
#if DBG
    ULONG cFound = 0;
#endif // DBG

    BEGIN_FN("DrSession::ReadCompletion");

    DEBUG_REF_BUF();

    ASSERT(InterlockedDecrement(&_ApcCount) == 0);

    PRDPDR_HEADER RdpdrHeader = (PRDPDR_HEADER)_ChannelBuffer;
    _ReadStatus = *IoStatusBlock;
    
    TRC_NRM((TB, "IoStatus %lx, Bytes %lx, Component %c%c, PacketId %c%c",
        _ReadStatus.Status, _ReadStatus.Information,
        HIBYTE(RdpdrHeader->Component), LOBYTE(RdpdrHeader->Component),
        HIBYTE(RdpdrHeader->PacketId), LOBYTE(RdpdrHeader->PacketId)));

    if (NT_SUCCESS(_ReadStatus.Status)) {

        TRC_NRM((TB, "Successful channel read")); 
        Status = STATUS_SUCCESS;
        //
        // Update the information field to reflect any data saved from a
        // previous read
        //

        _ReadStatus.Information += _PartialPacketData;

        TRC_ASSERT(_ChannelBufferSize >= _ReadStatus.Information,
                (TB, "ReadCompleted with too much data"));

        TRC_DBG((TB, "In ReadCompletion, _ChannelBuffer=%p", _ChannelBuffer));

        _PacketReceivers.LockShared();

#if DBG
        //
        // We should only have one handler, in debug, assert this, 
        //

        ListEnum = _PacketReceivers.First();
        while (ListEnum != NULL) {

            PacketReceiver = (ISessionPacketReceiver *)ListEnum->Node();

            TRC_DBG((TB, "PacketReceiver=%p", PacketReceiver));

            if (PacketReceiver->RecognizePacket(RdpdrHeader)) {

                cFound++;
                // "assert this"
                ASSERT(cFound == 1);
            }

            ListEnum = _PacketReceivers.Next(ListEnum);
        }
#endif // DBG

        if (_ReadStatus.Information < sizeof(RDPDR_HEADER)) {
            TRC_ERR((TB, "Bad RDPDR packet size"));
            Status = STATUS_DEVICE_PROTOCOL_ERROR;
            _PacketReceivers.Unlock();
            goto CleanUp;
        }

        ListEnum = _PacketReceivers.First();
        while (ListEnum != NULL) {

            PacketReceiver = (ISessionPacketReceiver *)ListEnum->Node();

            TRC_DBG((TB, "PacketReceiver=%p", PacketReceiver));

            if (PacketReceiver->RecognizePacket(RdpdrHeader)) {

                //
                // Set the _DoDefaultRead here, if we get called back to do
                // a read from the packet handler we'll clear in back out
                //
                bFound = TRUE;

                Status = PacketReceiver->HandlePacket(RdpdrHeader, (ULONG)(_ReadStatus.Information), 
                                                      &fDoDefaultRead);

                // Once we found the one handler we're done
                break;
            }

            ListEnum = _PacketReceivers.Next(ListEnum);
        }     
        _PacketReceivers.Unlock();

        if (!bFound) {
            TRC_ERR((TB, "Unrecognized RDPDR Header %d", RdpdrHeader->Component));
            Status = STATUS_DEVICE_PROTOCOL_ERROR;
            //ASSERT(bFound);
        }
    } else {
        Status = _ReadStatus.Status;
        TRC_ALT((TB, "Channel read failed 0x%X", Status)); 
    }

CleanUp:

    if (NT_SUCCESS(Status)) {
        if (fDoDefaultRead) {
            //
            // Start the next read before releasing our reference to the ClientEntry
            //
            TRC_DBG((TB, "Starting default read"));
            ReadPacket();
        } else {
            TRC_DBG((TB, "Skipping default read"));
        }
    } else {
        TRC_ERR((TB, "Error detected in ReadCompletion %lx",
                Status));
        ChannelIoFailed();
    }
}

BOOL DrSession::RecognizePacket(PRDPDR_HEADER RdpdrHeader)
/*++

Routine Description:

    Determines if the packet will be handled by this object

Arguments:

    RdpdrHeader - Header of the packet.

Return Value:

    TRUE if this object should handle this packet
    FALSE if this object should not handle this packet

--*/
{
    BEGIN_FN("DrSession::RecognizePacket");

    //
    // If you add a packet here, update the ASSERTS in HandlePacket
    //

    switch (RdpdrHeader->Component) {
    case RDPDR_CTYP_CORE:
        switch (RdpdrHeader->PacketId) {
        case DR_CORE_CLIENTID_CONFIRM:
            TRC_NRM((TB, "Recognized CLIENTID_CONFIRM packet"));
            return TRUE;
        case DR_CORE_CLIENT_NAME:
            TRC_NRM((TB, "Recognized CLIENT_NAME packet"));
            return TRUE;
        case DR_CORE_CLIENT_CAPABILITY:
            TRC_NRM((TB, "Recognized CLIENT_CAPABILITY packet"));
            return TRUE;
        case DR_CORE_CLIENT_DISPLAY_NAME:
            TRC_NRM((TB, "Recognized CLIENT_DISPLAY_NAME packet"));
            return TRUE;
        }
    }
    return FALSE;
}

NTSTATUS DrSession::HandlePacket(PRDPDR_HEADER RdpdrHeader, ULONG Length, 
        BOOL *DoDefaultRead)
/*++

Routine Description:

    Handles this packet

Arguments:

    RdpdrHeader - Header of the packet.
    Length - Total length of the packet

Return Value:

    NTSTATUS -  An error code indicates the client is Bad and should be 
                disconnected, otherwise SUCCESS.

--*/
{
    NTSTATUS Status = STATUS_DEVICE_PROTOCOL_ERROR;

    BEGIN_FN("DrSession::HandlePacket");

    //
    // RdpdrHeader read, dispatch based on the header
    //

    ASSERT(RdpdrHeader->Component == RDPDR_CTYP_CORE);

    switch (RdpdrHeader->Component) {
    case RDPDR_CTYP_CORE:
        ASSERT(RdpdrHeader->PacketId == DR_CORE_CLIENTID_CONFIRM || 
                RdpdrHeader->PacketId == DR_CORE_CLIENT_NAME ||
                RdpdrHeader->PacketId == DR_CORE_CLIENT_CAPABILITY ||
                RdpdrHeader->PacketId == DR_CORE_CLIENT_DISPLAY_NAME);

        switch (RdpdrHeader->PacketId) {
        case DR_CORE_CLIENTID_CONFIRM:
            Status = OnClientIdConfirm(RdpdrHeader, Length, DoDefaultRead);
            break;

        case DR_CORE_CLIENT_NAME:
            Status = OnClientName(RdpdrHeader, Length, DoDefaultRead);
            break;

        case DR_CORE_CLIENT_CAPABILITY:
            Status = OnClientCapability(RdpdrHeader, Length, DoDefaultRead);
            break;

        case DR_CORE_CLIENT_DISPLAY_NAME:
            Status = OnClientDisplayName(RdpdrHeader, Length, DoDefaultRead);
            break;
        }
    }
    return Status;
}

#if DBG
BOOL DrSession::PacketReceiverExists(ISessionPacketReceiver *PacketReceiver)
{
    PVOID NodeEnum;
    PVOID NodeFound = NULL;
    ListEntry *ListEnum;

    BEGIN_FN("DrSession::PacketReceiverExists");
    _PacketReceivers.LockShared();
    ListEnum = _PacketReceivers.First();
    while (ListEnum != NULL) {

        NodeEnum = ListEnum->Node();

        if (NodeEnum == (PVOID) PacketReceiver) {
            NodeFound = NodeEnum;

            NodeEnum = NULL;
            ListEnum = NULL;
            break;
        }

        ListEnum = _PacketReceivers.Next(ListEnum);
    }
    _PacketReceivers.Unlock();

    return NodeFound != NULL;
}
#endif // DBG

NTSTATUS DrSession::RegisterPacketReceiver(ISessionPacketReceiver *PacketReceiver)
/*++

Routine Description:

    Adds an object to the queue of Packet handlers. 

Arguments:

    PacketReceiver -    An interface to the object that wants to handle 
                        some packets

Return Value:

    Boolean indication of whether to do a default read (TRUE) or not (FALSE),
    where FALSE might be specified if another read has been requested 
    explicitly to get a full packet

--*/
{
    BEGIN_FN("DrSession::RegisterPacketReceiver");

    ASSERT(!PacketReceiverExists(PacketReceiver));

    ASSERT(PacketReceiver != NULL);
    if (_PacketReceivers.CreateEntry(PacketReceiver)) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
}

VOID DrSession::RemovePacketReceiver(ISessionPacketReceiver *PacketReceiver)
{
    PVOID NodeEnum;
    ListEntry *ListEnum;

    BEGIN_FN("DrSession::RemovePacketReceiver");

    _PacketReceivers.LockExclusive();
    ListEnum = _PacketReceivers.First();
    while (ListEnum != NULL) {

        NodeEnum = ListEnum->Node();

        if (NodeEnum == (PVOID) PacketReceiver) {
            break;
        }

        ListEnum = _PacketReceivers.Next(ListEnum);
    }

    ASSERT(ListEnum != NULL);
    _PacketReceivers.RemoveEntry(ListEnum);
    _PacketReceivers.Unlock();
}

NTSTATUS DrSession::OnClientIdConfirm(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket, 
        BOOL *DoDefaultRead)
/*++

Routine Description:

    Called in response to recognizing a ClientIdConfirm packet has been
    received.

Arguments:

    RdpdrHeader - The packet
    cbPacket    - Bytes in the packet
    DoDefaultRead - Set this to false if you do an explicit read

Return Value:



--*/
{
    NTSTATUS Status;
    PRDPDR_CLIENT_CONFIRM_PACKET ClientConfirmPacket =
            (PRDPDR_CLIENT_CONFIRM_PACKET)RdpdrHeader;

    BEGIN_FN("DrSession::OnClientIdConfirm");

    TRC_ASSERT(ClientConfirmPacket->Header.Component == RDPDR_CTYP_CORE,
            (TB, "Expected Core packet type!"));
    TRC_ASSERT(ClientConfirmPacket->Header.PacketId == DR_CORE_CLIENTID_CONFIRM,
            (TB, "Expected ClientConfirmPacket!"));


    *DoDefaultRead = TRUE;

    //
    // Check the version. The original protocol didn't have a version field,
    // so we first check to make sure the packet is big enough to indicate
    // one is present.
    //

    if (cbPacket < sizeof(RDPDR_CLIENT_CONFIRM_PACKET)) {

        //
        // Client version too old to have version info. Just close
        // the channel and be done with him.
        //

        TRC_ERR((TB, "ClientConfirmPacket size incorrect, may be old "
                "client. Size: %ld",
                cbPacket));
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    //
    // We have a version field
    //

    TRC_NRM((TB, "Client version Major: %d Minor: %d",
            ClientConfirmPacket->VersionInfo.Major,
            ClientConfirmPacket->VersionInfo.Minor));

    // Keep the version info
    _ClientVersion.Major = ClientConfirmPacket->VersionInfo.Major;
    _ClientVersion.Minor = ClientConfirmPacket->VersionInfo.Minor;

    // Send server capability to client
    if (COMPARE_VERSION(_ClientVersion.Minor, _ClientVersion.Major,
                    5, 1) >= 0) {
        SendClientCapability();
    }

    // Look for ClientID to have changed
    if (ClientConfirmPacket->ClientConfirm.ClientId != _ClientId) {
        TRC_NRM((TB, "Client %lx replied with alternate "
            "ClientId %lx", _ClientId,
            ClientConfirmPacket->ClientConfirm.ClientId));

        SetSessionState(csConnected);

        // TODO:
        // Kill off the old devices
        //

        _ClientId = ClientConfirmPacket->ClientConfirm.ClientId;


        //
        // Accept the clientid
        //

        SendClientConfirm();
    }
    return STATUS_SUCCESS;
}

NTSTATUS DrSession::OnClientCapability(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket, 
        BOOL *DoDefaultRead)
/*++

Routine Description:

    Called in response to recognizing a client capability packet has been
    received.

Arguments:

    RdpdrHeader - The packet
    cbPacket    - Bytes in the packet
    DoDefaultRead - Set this to false if you do an explicit read

Return Value:



--*/
{
    NTSTATUS Status;
    PRDPDR_CAPABILITY_SET_HEADER pCapSetHeader = (PRDPDR_CAPABILITY_SET_HEADER)RdpdrHeader;
    PRDPDR_CAPABILITY_HEADER pCapHdr = (PRDPDR_CAPABILITY_HEADER)(pCapSetHeader + 1);
    PBYTE pPacketEnd;
    ULONG PacketLen;
    BOOL CapSupported;

    BEGIN_FN("DrSession::OnClientCapability");

    TRC_ASSERT(pCapSetHeader->Header.Component == RDPDR_CTYP_CORE,
            (TB, "Expected Core packet type!"));
    TRC_ASSERT(pCapSetHeader->Header.PacketId == DR_CORE_CLIENT_CAPABILITY,
            (TB, "Expected ClientCapabilityPacket!"));


    *DoDefaultRead = TRUE;

    //
    // Check to make sure the server send us at least the header size
    //
    if (cbPacket < sizeof(RDPDR_CAPABILITY_SET_HEADER)) {
        TRC_ERR((TB, "ClientCapabilityPacket size incorrect. Size: %ld",
                cbPacket));
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }


    pPacketEnd = (PBYTE)RdpdrHeader + cbPacket;

    //
    //  Grab the supported capability info from client's capability PDU
    //  
    //  TODO: Should check for large capability set?
    //
    for (unsigned i = 0; i < pCapSetHeader->numberCapabilities; i++) {
        if (((PBYTE)(pCapHdr) + sizeof(RDPDR_CAPABILITY_HEADER) <= pPacketEnd) && 
             (pCapHdr->capabilityLength <= (pPacketEnd - (PBYTE)pCapHdr))) {
            PacketLen = (ULONG)(pPacketEnd - (PBYTE)pCapHdr);
            Status = InitClientCapability(pCapHdr, &PacketLen, &CapSupported);
            if (!NT_SUCCESS(Status)) {
                TRC_ASSERT(FALSE,(TB, "Bad client capability packet"));
                return Status;
            }
            pCapHdr = (PRDPDR_CAPABILITY_HEADER)(((PBYTE)pCapHdr) + pCapHdr->capabilityLength);
        }
        else {
            TRC_ERR((TB, "ClientCapabilityPacket incorrect packet."));
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
    }

    return STATUS_SUCCESS;
}

VOID DrSession::SendClientConfirm()
/*++

Routine Description:

    Sends a ClientIdConfirm packet to the client

Arguments:

    None.

Return Value:

    None.

--*/
{
    PRDPDR_CLIENT_CONFIRM_PACKET pClientConfirmPacket;

    BEGIN_FN("DrSession::SendClientConfirm");

    //
    // Construct the packet
    //
    pClientConfirmPacket = new RDPDR_CLIENT_CONFIRM_PACKET;

    if (pClientConfirmPacket != NULL) {
        pClientConfirmPacket->Header.Component = RDPDR_CTYP_CORE;
        pClientConfirmPacket->Header.PacketId = DR_CORE_CLIENTID_CONFIRM;
        pClientConfirmPacket->VersionInfo.Major = RDPDR_MAJOR_VERSION;
        pClientConfirmPacket->VersionInfo.Minor = RDPDR_MINOR_VERSION;
        pClientConfirmPacket->ClientConfirm.ClientId = _ClientId;
    
        //
        // Send it  - asynchronous write, cleanup not here
        //
        SendToClient(pClientConfirmPacket, sizeof(RDPDR_CLIENT_CONFIRM_PACKET), this, TRUE);
    }
}

VOID DrSession::SendClientCapability()
/*++

Routine Description:

    Sends server capability packet to the client

Arguments:

    None.

Return Value:

    None.

--*/
{
    PRDPDR_SERVER_COMBINED_CAPABILITYSET pSrvCapabilitySet;

    BEGIN_FN("DrSession::SendClientCapability");

    //
    // Send it
    //
    pSrvCapabilitySet = new RDPDR_SERVER_COMBINED_CAPABILITYSET;

    if (pSrvCapabilitySet != NULL) {
        memcpy(pSrvCapabilitySet, &_SrvCapabilitySet, sizeof(RDPDR_SERVER_COMBINED_CAPABILITYSET));
        //
        // Send it  - asynchronous write, cleanup not here
        //
        SendToClient(pSrvCapabilitySet, sizeof(RDPDR_SERVER_COMBINED_CAPABILITYSET), this, TRUE);
    }
}


NTSTATUS DrSession::InitClientCapability(PRDPDR_CAPABILITY_HEADER pCapHdr, ULONG *pPacketLen, BOOL *pCapSupported)
/*++

Routine Description:

    Initialize the client capability

Arguments:

    pCapHdr         -   client capability
    pPacketLen      -   In: Length of the total packet
                        Out: Length used in this function
    CapSupported    -   TRUE - if we found the same capability supported on the server side
                        FALSE - if this is not a supported capability

Return Value:

    TRUE - if we found the same capability supported on the server side
    FALSE - if this is not a supported capability

--*/

{
    *pCapSupported = FALSE;

    switch(pCapHdr->capabilityType) {
    
    case RDPDR_GENERAL_CAPABILITY_TYPE:
    {
        PRDPDR_GENERAL_CAPABILITY pGeneralCap = (PRDPDR_GENERAL_CAPABILITY)pCapHdr;

        if (*pPacketLen < sizeof(RDPDR_GENERAL_CAPABILITY)) {
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
        *pPacketLen = sizeof(RDPDR_GENERAL_CAPABILITY);

        _CliCapabilitySet.GeneralCap.version = pGeneralCap->version;
        _CliCapabilitySet.GeneralCap.osType = pGeneralCap->osType;
        _CliCapabilitySet.GeneralCap.osVersion = pGeneralCap->osVersion;
        _CliCapabilitySet.GeneralCap.ioCode1 = pGeneralCap->ioCode1;
        _CliCapabilitySet.GeneralCap.extendedPDU = pGeneralCap->extendedPDU;       
        _CliCapabilitySet.GeneralCap.protocolMajorVersion = pGeneralCap->protocolMajorVersion;
        _CliCapabilitySet.GeneralCap.protocolMinorVersion = pGeneralCap->protocolMinorVersion;
        
        *pCapSupported = TRUE;
    }
    break;

    case RDPDR_PRINT_CAPABILITY_TYPE:
    {
        PRDPDR_PRINT_CAPABILITY pPrintCap = (PRDPDR_PRINT_CAPABILITY)pCapHdr;

        if (*pPacketLen < sizeof(RDPDR_PRINT_CAPABILITY)) {
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
        *pPacketLen = sizeof(RDPDR_PRINT_CAPABILITY);

        _CliCapabilitySet.PrintCap.version = pPrintCap->version;
        *pCapSupported = TRUE;
    }
    break;

    case RDPDR_PORT_CAPABILITY_TYPE:
    {
        PRDPDR_PORT_CAPABILITY pPortCap = (PRDPDR_PORT_CAPABILITY)pCapHdr;

        if (*pPacketLen < sizeof(RDPDR_PORT_CAPABILITY)) {
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
        *pPacketLen = sizeof(RDPDR_PORT_CAPABILITY);
        
        _CliCapabilitySet.PortCap.version = pPortCap->version;
        *pCapSupported = TRUE;
    }
    break;

    case RDPDR_FS_CAPABILITY_TYPE:
    {
        PRDPDR_FS_CAPABILITY pFsCap = (PRDPDR_FS_CAPABILITY)pCapHdr;

        if (*pPacketLen < sizeof(RDPDR_FS_CAPABILITY)) {
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
        *pPacketLen = sizeof(RDPDR_FS_CAPABILITY);

        _CliCapabilitySet.FileSysCap.version = pFsCap->version;
        *pCapSupported = TRUE;
    }
    break;

    case RDPDR_SMARTCARD_CAPABILITY_TYPE:
    {
        PRDPDR_SMARTCARD_CAPABILITY pSmartCardCap = (PRDPDR_SMARTCARD_CAPABILITY)pCapHdr;

        if (*pPacketLen < sizeof(RDPDR_SMARTCARD_CAPABILITY)) {
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
        *pPacketLen = sizeof(RDPDR_SMARTCARD_CAPABILITY);

        _CliCapabilitySet.SmartCardCap.version = pSmartCardCap->version;
        *pCapSupported = TRUE;
    }
    break;

    default:
    {
    
        if (*pPacketLen < pCapHdr->capabilityLength) {
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }
        *pPacketLen = pCapHdr->capabilityLength;
    }
    break;
    
    }

    return STATUS_SUCCESS;
}

VOID DrSession::SendDeviceReply(ULONG DeviceId, NTSTATUS Result)
/*++

Routine Description:

    Sends a DeviceReply packet to the client

Arguments:

    DeviceId - Id that the client proposed
    Result - Indication of whether the device was accepted

Return Value:

    NTSTATUS - Success/failure indication of the operation

--*/
{
    PRDPDR_DEVICE_REPLY_PACKET pDeviceReplyPacket;

    BEGIN_FN("DrSession::SendDeviceReply");

    //
    // Construct the packet
    //

    pDeviceReplyPacket = new RDPDR_DEVICE_REPLY_PACKET;

    if (pDeviceReplyPacket != NULL) {
        pDeviceReplyPacket->Header.Component = RDPDR_CTYP_CORE;
        pDeviceReplyPacket->Header.PacketId = DR_CORE_DEVICE_REPLY;
        pDeviceReplyPacket->DeviceReply.DeviceId = DeviceId;
        pDeviceReplyPacket->DeviceReply.ResultCode = Result;
    
        //
        // Send it  - asynchronous write, cleanup not here
        //
        SendToClient(pDeviceReplyPacket, sizeof(RDPDR_DEVICE_REPLY_PACKET), this, TRUE);
    }
}

VOID DrSession::ChannelIoFailed()
/*++

Routine Description:

    Handles Virtual channel IO failure. Marks the client as disabled and cancels
    all the outstanding Io operations

Arguments:

    ClientEntry - The client which has been disconnected

Return Value:

    None

--*/
{
    BEGIN_FN("DrSession::ChannelIoFailed");

    //
    // Mark as disconnected
    //

    SetSessionState(csDisconnected);

    //
    // Close down the channel, but don't need to wait for all IO to
    // finish
    //

    DeleteChannel(FALSE);

    //
    // Fail outstanding IO
    // Should be done via Delete devices?
    //

    _ExchangeManager.Stop();
}

NTSTATUS DrSession::OnClientName(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket,
                                 BOOL *DoDefaultRead)
/*++

Routine Description:

    Called in response to recognizing a ClientName packet has been
    received.

Arguments:

    RdpdrHeader - The packet
    cbPacket    - Bytes in the packet

Return Value:

    Boolean indication of whether to do a default read (TRUE) or not (FALSE),
    where FALSE might be specified if another read has been requested 
    explicitly to get a full packet

--*/
{
    NTSTATUS Status;
    PRDPDR_CLIENT_NAME_PACKET ClientNamePacket =
            (PRDPDR_CLIENT_NAME_PACKET)RdpdrHeader;
    ULONG cb;

    BEGIN_FN("DrSession::OnClientName");


    *DoDefaultRead = TRUE;

    if (cbPacket < sizeof(RDPDR_CLIENT_NAME_PACKET)) {

        //
        // Sent an undersized packet
        //
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    // Copy and possibly convert the computer name
    if (ClientNamePacket->Name.Unicode) {
        TRC_NRM((TB, "Copying Unicode client name"));

        // Restrict size to max size
        cb = ClientNamePacket->Name.ComputerNameLen;

        if ((cbPacket - sizeof(RDPDR_CLIENT_DISPLAY_NAME_PACKET)) < cb) {

            //
            // Sent an undersized packet
            //
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }

        if (cb > (RDPDR_MAX_COMPUTER_NAME_LENGTH * sizeof(WCHAR))) {
            cb = RDPDR_MAX_COMPUTER_NAME_LENGTH * sizeof(WCHAR);
        }

        // Copy the text
        RtlCopyMemory(_ClientName, (ClientNamePacket + 1), cb);

        // Ensure buffer termination
        _ClientName[RDPDR_MAX_COMPUTER_NAME_LENGTH - 1] = 0;
        TRC_NRM((TB, "Copied client computer name: %S",
                _ClientName));
    } else {

        cb = ClientNamePacket->Name.ComputerNameLen;

        if (cbPacket - sizeof(RDPDR_CLIENT_NAME_PACKET) < cb) {

            //
            // Sent an undersized packet
            //
            return STATUS_DEVICE_PROTOCOL_ERROR;
        }

        if (cb > (RDPDR_MAX_COMPUTER_NAME_LENGTH)) {
            cb = RDPDR_MAX_COMPUTER_NAME_LENGTH;
        }

        // CopyConvert the buffer
        cb = ConvertToAndFromWideChar(ClientNamePacket->Name.CodePage,
                _ClientName, sizeof(_ClientName),
                (LPSTR)(ClientNamePacket + 1),
                cb, TRUE);

        if (cb != -1) {
            // Successful conversion
            _ClientName[RDPDR_MAX_COMPUTER_NAME_LENGTH - 1] = 0;
            TRC_NRM((TB, "Converted client computer name: %S",
                    _ClientName));
        } else {
            // Doh
            TRC_ERR((TB, "Failed to convert ComputerName to "
                    "Unicode."));
            _ClientName[0] = 0;
        }
    }
    return TRUE;
}

NTSTATUS DrSession::OnClientDisplayName(PRDPDR_HEADER RdpdrHeader, ULONG cbPacket,
                                 BOOL *DoDefaultRead)
/*++

Routine Description:

    Called in response to recognizing a ClientDisplayName packet has been
    received.

Arguments:

    RdpdrHeader - The packet
    cbPacket    - Bytes in the packet

Return Value:

    Boolean indication of whether to do a default read (TRUE) or not (FALSE),
    where FALSE might be specified if another read has been requested 
    explicitly to get a full packet

--*/
{
    NTSTATUS Status;
    PRDPDR_CLIENT_DISPLAY_NAME_PACKET ClientDisplayNamePacket =
            (PRDPDR_CLIENT_DISPLAY_NAME_PACKET)RdpdrHeader;
    ULONG cb;

    BEGIN_FN("DrSession::OnClientDisplayName");

    *DoDefaultRead = TRUE;

    if (cbPacket < sizeof(RDPDR_CLIENT_DISPLAY_NAME_PACKET)) {

        //
        // Sent an undersized packet
        //
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    // Copy the computer display name
    TRC_NRM((TB, "Copying Unicode client display name"));

    // Restrict size to max size
    cb = ClientDisplayNamePacket->Name.ComputerDisplayNameLen;

    if ((cbPacket - sizeof(RDPDR_CLIENT_DISPLAY_NAME_PACKET)) < cb) {

        //
        // Sent an undersized packet
        //
        return STATUS_DEVICE_PROTOCOL_ERROR;
    }

    if (cb > (RDPDR_MAX_CLIENT_DISPLAY_NAME * sizeof(WCHAR))) {
        cb = RDPDR_MAX_CLIENT_DISPLAY_NAME * sizeof(WCHAR);
    }

    // Copy the text
    RtlCopyMemory(_ClientDisplayName, (ClientDisplayNamePacket + 1), cb);

    // Ensure buffer termination
    _ClientDisplayName[RDPDR_MAX_CLIENT_DISPLAY_NAME - 1] = L'\0';

    TRC_NRM((TB, "Copied client computer display name: %S",
            _ClientName));
       
    return TRUE;
}

NTSTATUS DrSession::ReallocateChannelBuffer(ULONG ulNewBufferSize, 
        ULONG ulSaveBytes)
/*++

Routine Description:

    Attempts to make the channel buffer at least the given size, preserving
    as many bytes as desired

Arguments:

    ulNewBufferSize - The desired size
    ulSaveBytes - The number of bytes in the existing buffer that should be
            preserved

Return Value:

    STATUS_SUCCESS  - The channel buffer is now at least the desired size
    STATUS_INSUFFICIENT_RESOURCES - The new buffer could not be allocated,
            but the old buffer was preserved.

--*/
{
    PUCHAR pNewBuffer;
    NTSTATUS Status;

    BEGIN_FN("DrSession::ReallocateChannelBuffer");

    TRC_NRM((TB, "Old size: %ld, "
            "desired size: %ld save bytes:  %ld",
            _ChannelBufferSize,
            ulNewBufferSize,
            ulSaveBytes));

    if (ulNewBufferSize <= _ChannelBufferSize) {
        return STATUS_SUCCESS;
    }

    pNewBuffer = new UCHAR[ulNewBufferSize];

    if (pNewBuffer != NULL) {

        TRC_NRM((TB, "saving the old bytes."));

        // Save the current data
        RtlCopyMemory(pNewBuffer, _ChannelBuffer, ulSaveBytes);
        
        ASSERT(_ApcCount == 0);
        
        delete _ChannelBuffer;

        _ChannelBuffer = pNewBuffer;

        TRC_DBG((TB, "New ChannelBuffer=%p", _ChannelBuffer));

        _ChannelBufferSize = ulNewBufferSize;
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    return Status;
}

NTSTATUS DrSession::SendCompleted(PVOID Context, PIO_STATUS_BLOCK IoStatusBlock)
{
    BEGIN_FN("DrSession::SendCompleted");

   // 
   // return the status, if it is an error the connection will be dropped
   // automatically
   //
   return IoStatusBlock->Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\sessmgr.cpp ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    sessmgr.cpp

Abstract:

    Keeps track of the collection of session objects for the RDP
    device redirector

Revision History:
--*/
#include "precomp.hxx"
#define TRC_FILE "sessmgr"
#include "trc.h"

DrSessionManager::DrSessionManager()
{
    BEGIN_FN("DrSessionManager::DrSessionManager");
    SetClassName("DrSessionManager");
}

DrSessionManager::~DrSessionManager()
{
    BEGIN_FN("DrSessionManager::~DrSessionManager");
}

BOOL DrSessionManager::AddSession(SmartPtr<DrSession> &Session)
{
    DrSession *SessionT;
    SmartPtr<DrSession> SessionFound;
    BOOL rc = FALSE;

    BEGIN_FN("DrSessionManager::AddSession");
    //
    // Create a new SmartPtr to track in the list
    //

    ASSERT(Session != NULL);
    
    _SessionList.LockExclusive();

    if (FindSessionById(Session->GetSessionId(), SessionFound)) {
        rc = FALSE;
        goto EXIT;
    }

    SessionT = Session;
    SessionT->AddRef();

    //
    // Add it to the list
    //

    if (_SessionList.CreateEntry((PVOID)SessionT)) {

        //
        // successfully added this entry
        //

        rc = TRUE;
    } else {

        //
        // Unable to add it to the list, clean up
        //

        SessionT->Release();
        rc = FALSE;
    }

EXIT:
    _SessionList.Unlock();
    return rc;
}

BOOL DrSessionManager::OnConnect(PCHANNEL_CONNECT_IN ConnectIn, 
        PCHANNEL_CONNECT_OUT ConnectOut)
{
    SmartPtr<DrSession> ConnectingSession;
    BOOL Reconnect = FALSE;
    BOOL Connected = FALSE;
    BOOL Added = FALSE;

    BEGIN_FN("DrSessionManager::OnConnect");

    ASSERT(ConnectIn != NULL);
    ASSERT(ConnectOut != NULL);

    // Clear out the output buffer by default
    ConnectOut->hdr.contextData = (UINT_PTR)0;

    Reconnect = FindSessionById(ConnectIn->hdr.sessionID, 
            ConnectingSession);

    if (Reconnect) {
        TRC_DBG((TB, "Reconnecting session %d", 
                ConnectIn->hdr.sessionID));
    } else {
        TRC_DBG((TB, "Connecting session %d", 
                ConnectIn->hdr.sessionID));
        ConnectingSession = new(NonPagedPool) DrSession;
        if (ConnectingSession != NULL) {
            TRC_DBG((TB, "Created new session"));

            if (!ConnectingSession->Initialize()) {
                TRC_DBG((TB, "Session couldn't initialize"));
                ConnectingSession = NULL;
            }
        } else {
            TRC_ERR((TB, "Failed to allocate new session"));
        }
    }

    if (ConnectingSession != NULL) {
        Connected = ConnectingSession->Connect(ConnectIn, ConnectOut);
    }

    if (Connected) {
        TRC_DBG((TB, "Session connected, adding"));
        if (!Reconnect) {
            Added = AddSession(ConnectingSession);

            if (!Added) {
                if (FindSessionById(ConnectIn->hdr.sessionID, ConnectingSession)) {
                    Added = TRUE;
                }
            }
        } else {
            // Don't add what we found there anyway
            Added = TRUE;
        }
    }

    if (Added) {

        // Stash this here for the disconnect notification

        TRC_DBG((TB, "Added session"));
        ConnectingSession->AddRef();
        ConnectOut->hdr.contextData = (UINT_PTR)-1;
    }
    return Added;
}

VOID DrSessionManager::OnDisconnect(PCHANNEL_DISCONNECT_IN DisconnectIn, 
        PCHANNEL_DISCONNECT_OUT DisconnectOut)
{
    SmartPtr<DrSession> DisconnectingSession;

    BEGIN_FN("DrSessionManager::OnDisconnect");
    ASSERT(DisconnectIn != NULL);
    ASSERT(DisconnectOut != NULL);

    if (DisconnectIn->hdr.contextData == (UINT_PTR)-1 && 
            FindSessionById(DisconnectIn->hdr.sessionID, DisconnectingSession)) {
        
        TRC_NRM((TB, "Closing session for doctored client."));
        ASSERT(DisconnectingSession->IsValid());

        DisconnectingSession->Disconnect(DisconnectIn, DisconnectOut);
        DisconnectingSession->Release();
    } else {

        //
        // Must not have been a "doctored" client
        //

        TRC_NRM((TB, "Undoctored session ending"));
    }           
    
    //
    // make sure the output context is blank
    //
    DisconnectOut->hdr.contextData = (UINT_PTR)0;    
}

BOOL DrSessionManager::FindSessionById(ULONG SessionId, 
        SmartPtr<DrSession> &SessionFound)
{
    DrSession *SessionEnum;
    ListEntry *ListEnum;
    BOOL Found = FALSE;

    BEGIN_FN("DrSessionManager::FindSessionById");
    _SessionList.LockShared();

    ListEnum = _SessionList.First();
    while (ListEnum != NULL) {

        SessionEnum = (DrSession *)ListEnum->Node();

        if (SessionEnum->GetSessionId() == SessionId) {
            SessionFound = SessionEnum;

            //
            // These aren't guaranteed valid once the resource is released
            //

            SessionEnum = NULL;
            ListEnum = NULL;
            break;
        }

        ListEnum = _SessionList.Next(ListEnum);
    }

    _SessionList.Unlock();

    return SessionFound != NULL;
}

BOOL DrSessionManager::FindSessionByIdAndClient(ULONG SessionId, ULONG ClientId, 
        SmartPtr<DrSession> &SessionFound)
{
    DrSession *SessionEnum;
    ListEntry *ListEnum;
    BOOL Found = FALSE;

    BEGIN_FN("DrSessionManager::FindSessionByIdAndClient");
    
    _SessionList.LockShared();
    ListEnum = _SessionList.First();
    while (ListEnum != NULL) {

        SessionEnum = (DrSession *)ListEnum->Node();
        ASSERT(SessionEnum->IsValid());

        if ((SessionEnum->GetSessionId() == SessionId) &&
                (SessionEnum->GetClientId() == ClientId)) {
            SessionFound = SessionEnum;
            Found = TRUE;

            //
            // These aren't guaranteed valid past EndEnumeration() anyway
            //

            SessionEnum = NULL;
            ListEnum = NULL;
            break;
        }

        ListEnum = _SessionList.Next(ListEnum);
    }
    _SessionList.Unlock();

    return Found;
}

BOOL DrSessionManager::FindSessionByClientName(PWCHAR ClientName, 
        SmartPtr<DrSession> &SessionFound)
{
    DrSession *SessionEnum;
    ListEntry *ListEnum;
    BOOL Found = FALSE;

    BEGIN_FN("DrSessionManager::FindSessionByClientName");
    _SessionList.LockShared();

    ListEnum = _SessionList.First();
    while (ListEnum != NULL) {

        SessionEnum = (DrSession *)ListEnum->Node();

        if (_wcsicmp(SessionEnum->GetClientName(), ClientName) == 0) {
            SessionFound = SessionEnum;

            //
            // These aren't guaranteed valid once the resource is released
            //

            SessionEnum = NULL;
            ListEnum = NULL;
            break;
        }

        ListEnum = _SessionList.Next(ListEnum);
    }

    _SessionList.Unlock();

    return SessionFound != NULL;
}

VOID DrSessionManager::Remove(DrSession *Session)
{
    DrSession *SessionEnum;
    ListEntry *ListEnum;
    BOOL Found = FALSE;

    BEGIN_FN("DrSessionManager::Remove");
    _SessionList.LockExclusive();
    ListEnum = _SessionList.First();
    while (ListEnum != NULL) {

        SessionEnum = (DrSession *)ListEnum->Node();
        ASSERT(SessionEnum->IsValid());

        if (SessionEnum == Session) {
            Found = TRUE;

            _SessionList.RemoveEntry(ListEnum);
           
            //
            // These aren't guaranteed valid past EndEnumeration() anyway
            //
            SessionEnum = NULL;
            ListEnum = NULL;
            break;
        }

        ListEnum = _SessionList.Next(ListEnum);
    }

    _SessionList.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\strcnv.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    strcnv.h

Abstract:

    This module defines Ansi/Unicode conversion with a specific code page.    

Environment:

    Kernel mode

--*/
#pragma once

#ifdef __cplusplus
extern "C" {
#endif __cplusplus

VOID
CodePageConversionInitialize(
    );

VOID
CodePageConversionCleanup(
    );

INT ConvertToAndFromWideChar(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString,
    BOOLEAN ConvertToWideChar
    );

#ifdef __cplusplus
} // extern "C"
#endif __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\sessmgr.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    sessmgr.h

Abstract:

    Manages the set of sessions

Revision History:
--*/
#pragma once

class DrSessionManager : public TopObj
{
private:
    DoubleList _SessionList;
    

public:
    DrSessionManager();
    virtual ~DrSessionManager();
    VOID LockExclusive()
    {
        _SessionList.LockExclusive();
    }
    VOID Unlock()
    {
        _SessionList.Unlock();
    }

    BOOL AddSession(SmartPtr<DrSession> &Session);
    BOOL FindSessionById(ULONG SessionId, SmartPtr<DrSession> &SessionFound);
    BOOL FindSessionByIdAndClient(ULONG SessionId, ULONG ClientId,
        SmartPtr<DrSession> &SessionFound);
    BOOL FindSessionByClientName(PWCHAR ClientName, SmartPtr<DrSession> &SessionFound);

    BOOL OnConnect(PCHANNEL_CONNECT_IN ConnectIn, 
            PCHANNEL_CONNECT_OUT ConnectOut);
    VOID OnDisconnect(PCHANNEL_DISCONNECT_IN DisconnectIn, 
            PCHANNEL_DISCONNECT_OUT DisconnectOut);
    VOID Remove(DrSession *Session);
};

extern DrSessionManager *Sessions;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\topobj.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    topobj.h

Abstract:

    Base object handles default operations for all our objects and contains
    a central location for debugging entries

Revision History:
--*/
#pragma once

//
//  Global Memory Management Operators
//
#ifndef DRKDX
inline void *__cdecl operator new(size_t sz) 
{
    void *ptr = DRALLOCATEPOOL(PagedPool, sz, DRGLOBAL_SUBTAG);
    return ptr;
}
inline void *__cdecl operator new(size_t sz, POOL_TYPE poolType) 
{
    void *ptr = DRALLOCATEPOOL(poolType, sz, DRGLOBAL_SUBTAG);
    return ptr;
}
inline void __cdecl operator delete( void *ptr )
{
    DRFREEPOOL(ptr);
}
#endif // DRKDX

class TopObj
{
private:
    BOOLEAN _IsValid;
    BYTE pad1;
    BYTE pad2;
    BYTE pad3;
    ULONG _ObjectType;

#if DBG
    BOOLEAN _ForceTrace;
    BYTE pad4;
    BYTE pad5;
    BYTE pad6;
#endif // DBG

protected:
    virtual VOID SetValid(BOOLEAN IsValid = TRUE)
    {
        ASSERT(_magicNo == GOODMEMMAGICNUMBER);
        _IsValid = IsValid;
    }

public:

#if DBG
    ULONG _magicNo;
    PCHAR _ClassName;

#define SetClassName(ClassName) _ClassName = (ClassName)
#else // DBG
#define SetClassName(ClassName)
#endif // DBG

    //
    // IsValid function meaning is really defined by the individual object,
    // but one common use is to see if initialization succeeded
    //
    virtual BOOLEAN IsValid() 
    { 
        ASSERT(_magicNo == GOODMEMMAGICNUMBER);
        return _IsValid;
    }

    TopObj()
    {
        _IsValid = TRUE;
        _ObjectType = 0;
        SetClassName("TopObj");
#if DBG
        _magicNo = GOODMEMMAGICNUMBER;
#endif // DBG
    }

    virtual ~TopObj()
    {
        ASSERT(_magicNo == GOODMEMMAGICNUMBER);
#if DBG
        memset(&_magicNo, BADMEM, sizeof(_magicNo));
#endif // DBG
    }

    //
    //  Memory Management Operators
    //
    inline void *__cdecl operator new(size_t sz, POOL_TYPE poolType=PagedPool) 
    {
        void *ptr = DRALLOCATEPOOL(poolType, sz, DRTOPOBJ_SUBTAG);
        return ptr;
    }

    inline void __cdecl operator delete(void *ptr)
    {
        DRFREEPOOL(ptr);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\strcnv.cpp ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    strcnv.c

Abstract:

    This module implements Ansi/Unicode conversion with a specific code page.    

Environment:

    Kernel mode

--*/
#include "precomp.hxx"
#define TRC_FILE "strcnv"
#include "trc.h"

#include <wchar.h>

#define DEBUG_MODULE    MODULE_STRCNV

/****************************************************************************/
/* Code page based driver compatible Unicode translations                   */
/****************************************************************************/
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
NTSYSAPI
VOID
NTAPI
RtlGetDefaultCodePage(
    OUT PUSHORT AnsiCodePage,
    OUT PUSHORT OemCodePage
    );
#ifdef __cplusplus
} // extern "C" 
#endif // __cplusplus


// Note these are initialized and LastNlsTableBuffer is freed in ntdd.c
// at driver entry and exit.
FAST_MUTEX fmCodePage;
ULONG LastCodePageTranslated;  // I'm assuming 0 is not a valid codepage
PVOID LastNlsTableBuffer;
CPTABLEINFO LastCPTableInfo;
UINT NlsTableUseCount;


#define NLS_TABLE_KEY \
        L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\CodePage"


VOID
CodePageConversionInitialize(
    )
{
    BEGIN_FN("CodePageConversionInitialize");
    ExInitializeFastMutex(&fmCodePage);
    LastCodePageTranslated = 0;
    LastNlsTableBuffer = NULL;
    NlsTableUseCount = 0;
}

VOID
CodePageConversionCleanup(
    )
{
    BEGIN_FN("CodePageConversionCleanup");
    if (LastNlsTableBuffer != NULL) {
        delete LastNlsTableBuffer;
        LastNlsTableBuffer = NULL;
    }
}

BOOL GetNlsTablePath(
    UINT CodePage,
    PWCHAR PathBuffer
)
/*++

Routine Description:

  This routine takes a code page identifier, queries the registry to find the
  appropriate NLS table for that code page, and then returns a path to the
  table.

Arguments;

  CodePage - specifies the code page to look for

  PathBuffer - Specifies a buffer into which to copy the path of the NLS
    file.  This routine assumes that the size is at least MAX_PATH

Return Value:

  TRUE if successful, FALSE otherwise.

Gerrit van Wingerden [gerritv] 1/22/96

-*/
{
    NTSTATUS NtStatus;
    BOOL Result = FALSE;
    HANDLE RegistryKeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;

    BEGIN_FN("GetNlsTablePath");

    RtlInitUnicodeString(&UnicodeString, NLS_TABLE_KEY);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = ZwOpenKey(&RegistryKeyHandle, GENERIC_READ, &ObjectAttributes);

    if(NT_SUCCESS(NtStatus))
    {
        WCHAR *ResultBuffer;
        ULONG BufferSize = sizeof(WCHAR) * MAX_PATH +
          sizeof(KEY_VALUE_FULL_INFORMATION);

        ResultBuffer = new(PagedPool) WCHAR[BufferSize];
        if(ResultBuffer)
        {
            ULONG ValueReturnedLength;
            WCHAR CodePageStringBuffer[20];
            RtlZeroMemory(ResultBuffer, BufferSize);
            swprintf(CodePageStringBuffer, L"%d", CodePage);

            RtlInitUnicodeString(&UnicodeString,CodePageStringBuffer);

            KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) ResultBuffer;

            NtStatus = ZwQueryValueKey(RegistryKeyHandle,
                                       &UnicodeString,
                                       KeyValuePartialInformation,
                                       KeyValueInformation,
                                       BufferSize,
                                       &BufferSize);

            if(NT_SUCCESS(NtStatus))
            {

                swprintf(PathBuffer,L"\\SystemRoot\\System32\\%ws",
                         &(KeyValueInformation->Data[0]));
                Result = TRUE;
            }
            else
            {
                TRC_ERR((TB, "GetNlsTablePath failed to get NLS table"));
            }
            delete ResultBuffer;
        }
        else
        {
            TRC_ERR((TB, "GetNlsTablePath out of memory"));
        }

        ZwClose(RegistryKeyHandle);
    }
    else
    {
        TRC_ERR((TB, "GetNlsTablePath failed to open NLS key"));
    }


    return(Result);
}


INT ConvertToAndFromWideChar(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString,
    BOOLEAN ConvertToWideChar
)
/*++

Routine Description:

  This routine converts a character string to or from a wide char string
  assuming a specified code page.  Most of the actual work is done inside
  RtlCustomCPToUnicodeN, but this routine still needs to manage the loading
  of the NLS files before passing them to the RtlRoutine.  We will cache
  the mapped NLS file for the most recently used code page which ought to
  suffice for out purposes.

Arguments:
  CodePage - the code page to use for doing the translation.

  WideCharString - buffer the string is to be translated into.

  BytesInWideCharString - number of bytes in the WideCharString buffer
    if converting to wide char and the buffer isn't large enough then the
    string in truncated and no error results.

  MultiByteString - the multibyte string to be translated to Unicode.

  BytesInMultiByteString - number of bytes in the multibyte string if
    converting to multibyte and the buffer isn't large enough the string
    is truncated and no error results

  ConvertToWideChar - if TRUE then convert from multibyte to widechar
    otherwise convert from wide char to multibyte

Return Value:

  Success - The number of bytes in the converted WideCharString
  Failure - -1

Gerrit van Wingerden [gerritv] 1/22/96

-*/
{
    NTSTATUS NtStatus;
    USHORT OemCodePage, AnsiCodePage;
    CPTABLEINFO LocalTableInfo;
    PCPTABLEINFO TableInfo = NULL;
    PVOID LocalTableBase = NULL;
    ULONG BytesConverted = 0;

    BEGIN_FN("ConvertToAndFromWideChar");

    RtlGetDefaultCodePage(&AnsiCodePage,&OemCodePage);

    // see if we can use the default translation routinte

    if ((AnsiCodePage == CodePage) || (CodePage == 0))
    {
        if(ConvertToWideChar)
        {
            NtStatus = RtlMultiByteToUnicodeN(WideCharString,
                                              BytesInWideCharString,
                                              &BytesConverted,
                                              MultiByteString,
                                              BytesInMultiByteString);
        }
        else
        {
            NtStatus = RtlUnicodeToMultiByteN(MultiByteString,
                                              BytesInMultiByteString,
                                              &BytesConverted,
                                              WideCharString,
                                              BytesInWideCharString);
        }


        if(NT_SUCCESS(NtStatus))
        {
            return(BytesConverted);
        }
        else
        {
            return(-1);
        }
    }

    ExAcquireFastMutex(&fmCodePage);

    if(CodePage == LastCodePageTranslated)
    {
        // we can use the cached code page information
        TableInfo = &LastCPTableInfo;
        NlsTableUseCount += 1;
    }

    ExReleaseFastMutex(&fmCodePage);

    if(TableInfo == NULL)
    {
        // get a pointer to the path of the NLS table

        WCHAR NlsTablePath[MAX_PATH];

        if(GetNlsTablePath(CodePage,NlsTablePath))
        {
            UNICODE_STRING UnicodeString;
            IO_STATUS_BLOCK IoStatus;
            HANDLE NtFileHandle;
            OBJECT_ATTRIBUTES ObjectAttributes;

            RtlInitUnicodeString(&UnicodeString,NlsTablePath);

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       NULL,
                                       NULL);

            NtStatus = ZwCreateFile(&NtFileHandle,
                                    SYNCHRONIZE | FILE_READ_DATA,
                                    &ObjectAttributes,
                                    &IoStatus,
                                    NULL,
                                    0,
                                    FILE_SHARE_READ,
                                    FILE_OPEN,
                                    FILE_SYNCHRONOUS_IO_NONALERT,
                                    NULL,
                                    0);

            if(NT_SUCCESS(NtStatus))
            {
                FILE_STANDARD_INFORMATION StandardInfo;

                // Query the object to determine its length.

                NtStatus = ZwQueryInformationFile(NtFileHandle,
                                                  &IoStatus,
                                                  &StandardInfo,
                                                  sizeof(FILE_STANDARD_INFORMATION),
                                                  FileStandardInformation);

                if(NT_SUCCESS(NtStatus))
                {
                    UINT LengthOfFile = StandardInfo.EndOfFile.LowPart;

                    LocalTableBase = new(PagedPool) BYTE[LengthOfFile];

                    if(LocalTableBase)
                    {
                        RtlZeroMemory(LocalTableBase, LengthOfFile);

                        // Read the file into our buffer.

                        NtStatus = ZwReadFile(NtFileHandle,
                                              NULL,
                                              NULL,
                                              NULL,
                                              &IoStatus,
                                              LocalTableBase,
                                              LengthOfFile,
                                              NULL,
                                              NULL);

                        if(!NT_SUCCESS(NtStatus))
                        {
                            TRC_ERR((TB, "WDMultiByteToWideChar unable to read file"));
                            delete LocalTableBase;
                            LocalTableBase = NULL;
                        }
                    }
                    else
                    {
                        TRC_ERR((TB, "WDMultiByteToWideChar out of memory"));
                    }
                }
                else
                {
                    TRC_ERR((TB, "WDMultiByteToWideChar unable query NLS file"));
                }

                ZwClose(NtFileHandle);
            }
            else
            {
                TRC_ERR((TB, "EngMultiByteToWideChar unable to open NLS file"));
            }
        }
        else
        {
            TRC_ERR((TB, "EngMultiByteToWideChar get registry entry for NLS file failed"));
        }

        if(LocalTableBase == NULL)
        {
            return(-1);
        }

        // now that we've got the table use it to initialize the CodePage table

        RtlInitCodePageTable((USHORT *)LocalTableBase,&LocalTableInfo);
        TableInfo = &LocalTableInfo;
    }

    // Once we are here TableInfo points to the the CPTABLEINFO struct we want


    if(ConvertToWideChar)
    {
        NtStatus = RtlCustomCPToUnicodeN(TableInfo,
                                         WideCharString,
                                         BytesInWideCharString,
                                         &BytesConverted,
                                         MultiByteString,
                                         BytesInMultiByteString);
    }
    else
    {
        NtStatus = RtlUnicodeToCustomCPN(TableInfo,
                                         MultiByteString,
                                         BytesInMultiByteString,
                                         &BytesConverted,
                                         WideCharString,
                                         BytesInWideCharString);
    }


    if(!NT_SUCCESS(NtStatus))
    {
        // signal failure

        BytesConverted = -1;
    }


    // see if we need to update the cached CPTABLEINFO information

    if(TableInfo != &LocalTableInfo)
    {
        // we must have used the cached CPTABLEINFO data for the conversion
        // simple decrement the reference count

        ExAcquireFastMutex(&fmCodePage);
        NlsTableUseCount -= 1;
        ExReleaseFastMutex(&fmCodePage);
    }
    else
    {
        PVOID FreeTable;

        // we must have just allocated a new CPTABLE structure so cache it
        // unless another thread is using current cached entry

        ExAcquireFastMutex(&fmCodePage);
        if(!NlsTableUseCount)
        {
            LastCodePageTranslated = CodePage;
            RtlMoveMemory(&LastCPTableInfo, TableInfo, sizeof(CPTABLEINFO));
            FreeTable = LastNlsTableBuffer;
            LastNlsTableBuffer = LocalTableBase;
        }
        else
        {
            FreeTable = LocalTableBase;
        }
        ExReleaseFastMutex(&fmCodePage);

        // Now free the memory for either the old table or the one we allocated
        // depending on whether we update the cache.  Note that if this is
        // the first time we are adding a cached value to the local table, then
        // FreeTable will be NULL since LastNlsTableBuffer will be NULL

        if(FreeTable)
        {
            delete FreeTable;
        }
    }

    // we are done

    return(BytesConverted);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\smartptr.cpp ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    smartptr.pp

Abstract:

    Smart pointers and reference counting

Revision History:
--*/

#include "precomp.hxx"
#define TRC_FILE "smartptr"
#include "trc.h"

#if DBG
void RefCount::RecordReferenceStack(LONG refs)
{
    ULONG hash;
    DWORD index;

    BEGIN_FN("RefCount::RecordReferenceStack");
    
    //
    // The masking does the wrapping automatically, while keeping
    // the operation atomic using InterlockedIncrement
    //

    index = InterlockedIncrement((PLONG)&_dwReferenceTraceIndex) & kReferenceTraceMask;

    _TraceRecordList[index].ClassName = _ClassName;
    _TraceRecordList[index].pRefCount = this;
    _TraceRecordList[index].refs = refs;


    RtlZeroMemory(_TraceRecordList[index].Stack, 
            sizeof(_TraceRecordList[index].Stack));

    RtlCaptureStackBackTrace(1,
                             kdwStackSize,
                             _TraceRecordList[index].Stack,
                             &hash);
}
#endif // DBG

RefCount::~RefCount() 
{ 
    BEGIN_FN("RefCount::~RefCount");
    ASSERT(_crefs == 0);
    TRC_DBG((TB, "RefCount object deleted(%p, cref=%d)", this, _crefs)); 
}

void RefCount::AddRef(void) 
{ 
    LONG crefs = InterlockedIncrement(&_crefs);

    BEGIN_FN("RefCount::AddRef");
    ASSERT(crefs > 0);
    RecordReferenceStack(crefs);
    TRC_DBG((TB, "AddRef object type %s (%p) to %d", _ClassName, this, 
            crefs));
}

void RefCount::Release(void)
{
    LONG crefs;
#if DBG
    PCHAR ClassName = _ClassName;
#endif

    BEGIN_FN("RefCount::Release");

    ASSERT(_crefs > 0);

    //
    //  The trace below is not thread safe to access class member
    //  So we need to make a copy of the class name
    //
    RecordReferenceStack(_crefs);
    crefs = InterlockedDecrement(&_crefs);
    
    if (crefs == 0)
    {
        TRC_DBG((TB, "Deleting RefCount object type %s (%p)", 
                ClassName, this));
        delete this;
    } else {
        TRC_DBG((TB, "Releasing object type %s (%p) to %d", 
                ClassName, this, crefs));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdr2kd\kdextlib.c ===
/*++

Copyright (c) 1990 Microsoft Corporation











------------------------------
T H I S   F I L E   I S   O B S O L E T E .    I T   I S   B E I N G   K E P T
F O R   A   W H I L E   J U S T   T O   M A K E   S U R E
----------------------------
















Module Name:

    kdextlib.c

Abstract:

    Library routines for dumping data structures given a meta level descrioption

Author:

    Balan Sethu Raman (SethuR) 11-May-1994

Notes:
    The implementation tends to avoid memory allocation and deallocation as much as possible.
    Therefore We have choosen an arbitrary length as the default buffer size. A mechanism will
    be provided to modify this buffer length through the debugger extension commands.

Revision History:

    11-Nov-1994 SethuR  Created

--*/

#include "rxovride.h" //common compile flags
#include "ntifs.h"
#include <nt.h>
//#include <ntrtl.h>
#include "ntverp.h"

#define KDEXTMODE

#include <windef.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include <kdextlib.h>
#include <ntrxdef.h>
#include <rxtypes.h>
#include <rxlog.h>

PWINDBG_OUTPUT_ROUTINE                lpOutputRoutine;
PWINDBG_GET_EXPRESSION32              lpGetExpressionRoutine;
PWINDBG_GET_SYMBOL32                  lpGetSymbolRoutine;
PWINDBG_READ_PROCESS_MEMORY_ROUTINE   lpReadMemoryRoutine;

#define    PRINTF    lpOutputRoutine
#define    ERROR     lpOutputRoutine

#define    NL      1
#define    NONL    0

#define    SETCALLBACKS() \
    lpOutputRoutine = lpExtensionApis->lpOutputRoutine; \
    lpGetExpressionRoutine = lpExtensionApis->lpGetExpressionRoutine; \
    lpGetSymbolRoutine = lpExtensionApis->lpGetSymbolRoutine; \
    lpReadMemoryRoutine = lpExtensionApis->lpReadVirtualMemRoutine;

#define DEFAULT_UNICODE_DATA_LENGTH 512
USHORT s_UnicodeStringDataLength = DEFAULT_UNICODE_DATA_LENGTH;
WCHAR  s_UnicodeStringData[DEFAULT_UNICODE_DATA_LENGTH];
WCHAR *s_pUnicodeStringData = s_UnicodeStringData;

#define DEFAULT_ANSI_DATA_LENGTH 512
USHORT s_AnsiStringDataLength = DEFAULT_ANSI_DATA_LENGTH;
CHAR  s_AnsiStringData[DEFAULT_ANSI_DATA_LENGTH];
CHAR *s_pAnsiStringData = s_AnsiStringData;

/*
 * Fetches the data at the given address
 */
BOOLEAN
GetData( ULONG_PTR dwAddress, PVOID ptr, ULONG size, PSZ type)
{
    BOOL b;
    ULONG BytesRead;

    b = (lpReadMemoryRoutine)(dwAddress, ptr, size, &BytesRead );


    if (!b || BytesRead != size ) {
        PRINTF( "Unable to read %u bytes at %p, for %s\n", size, dwAddress, type );
        return FALSE;
    }

    return TRUE;
}

/*
 * Fetch the null terminated ASCII string at dwAddress into buf
 */
BOOL
GetString( ULONG_PTR dwAddress, PSZ buf )
{
    do {
        if( !GetData( dwAddress,buf, 1, "..stringfetch") )
            return FALSE;

        dwAddress++;
        buf++;

    } while( *buf != '\0' );

    return TRUE;
}

/*
 * Displays a byte in hexadecimal
 */
VOID
PrintHexChar( UCHAR c )
{
    PRINTF( "%c%c", "0123456789abcdef"[ (c>>4)&0xf ], "0123456789abcdef"[ c&0xf ] );
}

/*
 * Displays a buffer of data in hexadecimal
 */
VOID
PrintHexBuf( PUCHAR buf, ULONG cbuf )
{
    while( cbuf-- ) {
        PrintHexChar( *buf++ );
        PRINTF( " " );
    }
}

/*
 * Displays a unicode string
 */
BOOL
PrintStringW(LPSTR msg, PUNICODE_STRING puStr, BOOL nl )
{
    UNICODE_STRING UnicodeString;
    ANSI_STRING    AnsiString;
    BOOL           b;

    if( msg )
        PRINTF( msg );

    if( puStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    UnicodeString.Buffer        = s_pUnicodeStringData;
    UnicodeString.MaximumLength = s_UnicodeStringDataLength;
    UnicodeString.Length = (puStr->Length > s_UnicodeStringDataLength)
                            ? s_UnicodeStringDataLength
                            : puStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR) puStr->Buffer,
                UnicodeString.Buffer,
                UnicodeString.Length,
                NULL);

    if (b)    {
        RtlUnicodeStringToAnsiString(&AnsiString, puStr, TRUE);
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
        RtlFreeAnsiString(&AnsiString);
    }

    return b;
}

/*
 * Displays a ANSI string
 */
BOOL
PrintStringA(LPSTR msg, PANSI_STRING pStr, BOOL nl )
{
    ANSI_STRING AnsiString;
    BOOL        b;

    if( msg )
        PRINTF( msg );

    if( pStr->Length == 0 ) {
        if( nl )
            PRINTF( "\n" );
        return TRUE;
    }

    AnsiString.Buffer        = s_pAnsiStringData;
    AnsiString.MaximumLength = s_AnsiStringDataLength;
    AnsiString.Length = (pStr->Length > (s_AnsiStringDataLength - 1))
                        ? (s_AnsiStringDataLength - 1)
                        : pStr->Length;

    b = (lpReadMemoryRoutine)(
                (ULONG_PTR) pStr->Buffer,
                AnsiString.Buffer,
                AnsiString.Length,
                NULL);

    if (b)    {
        AnsiString.Buffer[ AnsiString.Length ] = '\0';
        PRINTF("%s%s", AnsiString.Buffer, nl ? "\n" : "" );
    }

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdr2kd\makefile.inc ===
copyforifskit:
# This is bogus.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\smartptr.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name :

    smartptr.h

Abstract:

    Smart pointers and reference counting

Revision History:
--*/
#pragma once
#include "topobj.h"

const DWORD kdwStackSize = 10;

#if DBG
typedef struct tagReferenceTraceRecord {
    PVOID   Stack[kdwStackSize];
    class RefCount *pRefCount;
    PCHAR ClassName;
    LONG refs;
} ReferenceTraceRecord;

const DWORD kReferenceTraceMask = 0xFF;
#endif

class RefCount : public TopObj 
{
private:
    LONG _crefs;
#if DBG
    DWORD   _dwReferenceTraceIndex;
    ReferenceTraceRecord    _TraceRecordList[kReferenceTraceMask + 1];

    void RecordReferenceStack(LONG refs);
#else
#define RecordReferenceStack(refs)
#endif

public:
    RefCount(void) : _crefs(0)
    { 
#if DBG
        _dwReferenceTraceIndex = -1;
#endif
    }
    virtual ~RefCount();
    void AddRef(void);
    void Release(void);
};

template <class T> class SmartPtr {
    T* p;
public:

    SmartPtr()
    { 
        p = NULL;
    }
    SmartPtr(SmartPtr<T> &sp)
    { 
        p = sp;
        if (p != NULL) {
            p->AddRef();
        }
    }
    SmartPtr(T* p_) : p(p_) 
    { 
        if (p != NULL) {
            p->AddRef(); 
        }
    }
    ~SmartPtr(void) 
    { 
        if ( p != NULL) {
            p->Release(); 
        }
    }
    inline T* operator->(void) 
    { 
        // No referencing needed to access a member
        ASSERT(p != NULL);
        return p; 
    }
    inline SmartPtr& operator=(SmartPtr<T> &p_)
    {
        // Referencing comes from using the other operator
        return operator=((T *) p_);
    }
    inline T& operator*(void) 
    { 
        // No referencing needed to derefence
        ASSERT(p != NULL);
        return *p; 
    }
    inline operator T*(void) 
    {
        // The assignee is responsible for doing the AddRef,
        // and in the SmartPtr case, does
        return p; 
    }
    inline int operator==(const SmartPtr<T> &p_) const
    {
        // The cast doesn't reference, so we can just do the compare
        return ((T*)p_ == p);
    }
    inline int operator==(const void *p_) const
    {
        // The cast doesn't reference, so we can just do the compare
        return ((T*)p_ == p);
    }
    inline int operator!=(const SmartPtr<T> &p_) const
    {
        // The cast doesn't reference, so we can just do the compare
        return ((T*)p_ != p);
    }
    inline int operator!=(const void *p_) const
    {
        // The cast doesn't reference, so we can just do the compare
        return ((T*)p_ != p);
    }
    inline int operator!()
    {
        return !p;
    }
    SmartPtr& operator=(T* p_) {
        if (p != NULL) {
            // Remove our reference to the old one
            p->Release(); 
        }
        p = p_; 
        if (p != NULL) {
            // Add our reference to the new one
            p->AddRef();
        }
        return *this;
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\trc.h ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    trc.h

Abstract:

    Kernel-Mode Tracing Facility.

    This module utilizes DCL's tracing macros, originally defined in atrcapi.h, 
    in a way that is intended to be independent of anything but NT DDK API's.  
    Currently, rdpwd.sys and rdpdd.sys also use these shared macros, but not 
    in a way that is independent of their respective components.

Author:

Revision History:
--*/

#pragma once

#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif

#define TRC_BUFFER_SIZE         256

/****************************************************************************/
/* Before including this file the TRC_FILE macro should be defined.  This   */
/* is much more efficient than relying on __FILE__ to give the correct      */
/* filename since it includes unnecessary path info (and extension info).   */
/* In addition each use of __FILE__ causes a new constant string to be      */
/* placed in the data segment.                                              */
/****************************************************************************/
#ifdef TRC_FILE
#define _file_name_ (CHAR *)__filename
static const CHAR __filename[] = TRC_FILE;
#endif /* TRC_FILE */

/****************************************************************************/
/*                                                                          */
/* FUNCTION PROTOTYPES                                                      */
/*                                                                          */
/****************************************************************************/
BOOL TRC_ProfileTraceEnabled();
VOID TRC_TraceLine(  ULONG    traceLevel,
                     PCHAR traceString,
                     CHAR  separator,
                     ULONG  lineNumber,
                     PCHAR funcName,
                     PCHAR fileName);

VOID TRC_TraceData(  ULONG    traceLevel,
                     PCHAR traceString,
                     CHAR  separator,
                     PVOID  buffer,
                     ULONG  length,
                     ULONG  lineNumber,
                     PCHAR funcName,
                     PCHAR fileName);

BOOL TRC_WillTrace(   ULONG   traceLevel,
                            PCHAR  fileName,
                            ULONG   line);
/****************************************************************************/
/*                                                                          */
/* CONSTANTS                                                                */
/*                                                                          */
/****************************************************************************/
/****************************************************************************/
/* Define the trace level.                                                  */
/*                                                                          */
/* TRC_LEVEL_DBG         : All tracing is enabled                           */
/* TRC_LEVEL_NRM         : Debug level tracing is disabled                  */
/* TRC_LEVEL_ALT         : Normal and debug level tracing is disabled       */
/* TRC_LEVEL_ERR         : Alert, normal and debug level tracing is         */
/*                         disabled                                         */
/* TRC_LEVEL_ASSERT      : Error, alert, normal and debug level tracing     */
/*                         is disabled                                      */
/* TRC_LEVEL_DIS         : All tracing is disabled.                         */
/****************************************************************************/
#define TRC_LEVEL_DBG       0
#define TRC_LEVEL_NRM       1
#define TRC_LEVEL_ALT       2
#define TRC_LEVEL_ERR       3
#define TRC_LEVEL_ASSERT    4
#define TRC_LEVEL_DIS       5


#define TRC_PROFILE_TRACE   8

/****************************************************************************/
/* Tracing can be switched off at compile time to allow for 'debug' and     */
/* 'retail' versions of the product.  The following macros disable specific */
/* trace processing.                                                        */
/*                                                                          */
/* TRC_ENABLE_DBG    - Enable debug tracing                                 */
/* TRC_ENABLE_NRM    - Enable normal tracing                                */
/* TRC_ENABLE_ALT    - Enable alert tracing                                 */
/* TRC_ENABLE_ERR    - Enable error tracing                                 */
/* TRC_ENABLE_ASSERT - Enable assert tracing                                */
/* TRC_ENABLE_PRF    - Enable function profile tracing                      */
/****************************************************************************/
#if (TRC_COMPILE_LEVEL == TRC_LEVEL_DBG)
#define TRC_ENABLE_DBG
#define TRC_ENABLE_NRM
#define TRC_ENABLE_ALT
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_COMPILE_LEVEL == TRC_LEVEL_NRM)
#define TRC_ENABLE_NRM
#define TRC_ENABLE_ALT
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_COMPILE_LEVEL == TRC_LEVEL_ALT)
#define TRC_ENABLE_ALT
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_COMPILE_LEVEL == TRC_LEVEL_ERR)
#define TRC_ENABLE_ERR
#define TRC_ENABLE_ASSERT
#endif

#if (TRC_COMPILE_LEVEL == TRC_LEVEL_ASSERT)
#define TRC_ENABLE_ASSERT
#endif

#ifdef TRC_COMPILE_PRF
#define TRC_ENABLE_PRF
#endif

/****************************************************************************/
/* Internal buffer sizes.                                                   */
/*                                                                          */
/* TRC_PREFIX_LIST_SIZE  : the length of the prefix string                  */
/* TRC_FILE_NAME_SIZE    : the maximum length of the fully qualified        */
/*                         trace output file name.                          */
/****************************************************************************/
#define TRC_PREFIX_LIST_SIZE             100
/**MOANSOFF */
#define TRC_FILE_NAME_SIZE          MAX_PATH
/**MOANSON */

/****************************************************************************/
/* Prefix constants                                                         */
/*                                                                          */
/* TRC_MAX_PREFIX       : number of prefixes supported                      */
/* TRC_PREFIX_NAME_LEN  : length of a prefix name                           */
/****************************************************************************/
#define TRC_MAX_PREFIX                  20
#define TRC_PREFIX_NAME_LEN             8

////////////////////////////////////////////////////////////////////////
//
//  Typedefs
//

//
//  Least significant set bits define the number of trace messages that
//  are saved in-ram.  If last 4 bits are set, then save 2^4 messages.
//

#define TRC_RamMsgMask  0x000003FF
#define TRC_RamMsgMax   (TRC_RamMsgMask + 1)

////////////////////////////////////////////////////////////////////////
//
//  Typedefs
//

typedef struct tagTRC_PREFIX_DATA
{
    CHAR        name[TRC_PREFIX_NAME_LEN];
    ULONG       start;
    ULONG       end;
} TRC_PREFIX_DATA, *PTRC_PREFIX_DATA;

//  
//  This structure stores information about the current trace configuration. 
//

typedef struct tagTRC_CONFIG
{
    ULONG    TraceLevel;        //  The current trace level (TRC_LEVEL_DBG, 
                                //                           TRC_LEVEL_NRM, etc)
    ULONG    FunctionLength;    //  Number of characters of the function name 
                                //   traced to the output file.                                   
    BOOL     TraceDebugger;        //  If true, tracing should be done to the 
                                //   debugger.
    BOOL     TraceProfile;

    TRC_PREFIX_DATA  Prefix[TRC_MAX_PREFIX];
} TRC_CONFIG;

#define TRC_CONFIG_DEFAULT { \
    TRC_LEVEL_ALT, \
    TRC_FUNCNAME_LEN, \
    0xFFFFFFFF, \
    FALSE, \
    TRUE \
    }

/****************************************************************************/
/* Various trace helper definitions                                         */
/****************************************************************************/

#define TB                  TraceBuffer, sizeof(TraceBuffer)

/****************************************************************************/
/* Trace format definitions.  These are used for printing various parts of  */
/* the trace lines.                                                         */
/*                                                                          */
/* TIME     is the time in the form hours, mins, secs, hundredths.          */
/* DATE     is the date in the form day, month, year.                       */
/* FUNC     is the module function name.  This is of variable size.         */
/* LINE     is the line number within the source file.                      */
/* PROC     is the process identifier.                                      */
/* THRD     is the thread identifier.                                       */
/*                                                                          */
/****************************************************************************/
#define TRC_TIME_FMT                   "%02d:%02d:%02d.%03d"
#define TRC_DATE_FMT                   "%02d/%02d/%02d"
#define TRC_FUNC_FMT                   "%-*.*s"
#define TRC_LINE_FMT                   "%04d"
#define TRC_PROC_FMT                   "%04.4lx"
#define TRC_THRD_FMT                   "%04.4lx"

#define TRC_FUNCNAME_LEN    24

#define TRC_SEP_DBG         ' '
#define TRC_SEP_NRM         ' '
#define TRC_SEP_ALT         '+'
#define TRC_SEP_ERR         '*'
#define TRC_SEP_ASSERT      '!'
#define TRC_SEP_PROF        ' '

#if (TRC_COMPILE_LEVEL < TRC_LEVEL_DIS)
#define TRC_FN(A)   static const CHAR __fnname[]  = A;                   \
                    PCHAR trc_fn = (PCHAR)__fnname;                   \
                    PCHAR trc_file = _file_name_;                       \
                    static CHAR TraceBuffer[TRC_BUFFER_SIZE];
#else
#define TRC_FN(A)
#endif

__inline BOOL IsValid() { return TRUE; }
#define BEGIN_FN(str)               TRC_FN(str); TRC_ENTRY; ASSERT(IsValid());
#define BEGIN_FN_STATIC(str)               TRC_FN(str); TRC_ENTRY;
//#define END_FN()                    TRC_EXIT;

/****************************************************************************/
/*                                                                          */
/* MACROS                                                                   */
/*                                                                          */
/****************************************************************************/

/****************************************************************************/
/* Standard trace macros                                                    */
/****************************************************************************/
#ifdef TRC_ENABLE_DBG
#define TRC_DBG(string)     TRCX(TRC_LEVEL_DBG, TRC_SEP_DBG, string)
#else
#define TRC_DBG(string)
#endif

#ifdef TRC_ENABLE_NRM
#define TRC_NRM(string)     TRCX(TRC_LEVEL_NRM, TRC_SEP_NRM, string)
#else
#define TRC_NRM(string)
#endif

#ifdef TRC_ENABLE_ALT
#define TRC_ALT(string)     TRCX(TRC_LEVEL_ALT, TRC_SEP_ALT, string)
#else
#define TRC_ALT(string)
#endif

#ifdef TRC_ENABLE_ERR
#define TRC_ERR(string)     TRCX(TRC_LEVEL_ERR, TRC_SEP_ERR, string)
#else
#define TRC_ERR(string)
#endif

#ifdef TRC_ENABLE_ASSERT
/****************************************************************************/
/* TRC_ASSERT & TRC_ABORT                                                   */
/****************************************************************************/
#define TRC_ASSERT(condition, string)                                        \
    {                                                                        \
        if (!(condition))                                                    \
        {                                                                    \
            TRCX(TRC_LEVEL_ERR, TRC_SEP_ASSERT, string);                     \
            DbgBreakPoint();                                                 \
        }                                                                    \
    }

#define TRC_ABORT(string)                                                    \
    {                                                                        \
        TRCX(TRC_LEVEL_ERR, TRC_SEP_ASSERT, string);                         \
        DbgBreakPoint();                                                     \
    }

#undef ASSERT
#define ASSERT(condition) TRC_ASSERT(condition, (TB, #condition))

#else /* TRC_ENABLE_ASSERT */
/****************************************************************************/
/* TRC_ASSERT & TRC_ABORT for retail builds                                 */
/****************************************************************************/
#define TRC_ASSERT(condition, string)
#define TRC_ABORT(string)
#endif /* TRC_ENABLE_ASSERT */

#ifdef TRC_ENABLE_TST
#define TRC_TST  TRC_DBG
#else
#define TRC_TST(x)
#endif /* TRC_ENABLE_TST */

/****************************************************************************/
/* TRCX for RdpDr, driver of champions                                      */
/****************************************************************************/
#define TRCX(level, separator, traceString)                                  \
    {                                                                        \
        {                                                                    \
            _snprintf traceString;                                           \
            TRC_TraceLine(level,                                             \
                          TraceBuffer,                                       \
                          separator,                                         \
                          (ULONG)__LINE__,                                   \
                          trc_fn,                                            \
                          trc_file);                                         \
        }                                                                    \
    }

/****************************************************************************/
/* Data dump trace macros                                                   */
/****************************************************************************/

#ifdef TRC_ENABLE_DBG
#define TRC_DATA_DBG(string, buffer, length)                                 \
          TRCX_DATA(TT_OUT1, TRC_SEP_DBG, string, buffer, length)
#else
#define TRC_DATA_DBG(string, buffer, length)
#endif

#ifdef TRC_ENABLE_NRM
#define TRC_DATA_NRM(string, buffer, length)                                 \
          TRCX_DATA(TT_OUT2, TRC_SEP_NRM, string, buffer, length)
#else
#define TRC_DATA_NRM(string, buffer, length)
#endif

#ifdef TRC_ENABLE_ALT
#define TRC_DATA_ALT(string, buffer, length)                                 \
          TRCX_DATA(TT_OUT3, TRC_SEP_ALT, string, buffer, length)
#else
#define TRC_DATA_ALT(string, buffer, length)
#endif

#ifdef TRC_ENABLE_ERR
#define TRC_DATA_ERR(string, buffer, length)                                 \
          TRCX_DATA(TT_OUT4, TRC_SEP_ERR, string, buffer, length)
#else
#define TRC_DATA_ERR(string, buffer, length)
#endif

#ifdef TRC_ENABLE_NRM
#define TRC_DATA_NET(string, buffer, length)                                 \
          TRCX_DATA(TT_OUT2, TRC_SEP_NRM, string, buffer, length)
#else
#define TRC_DATA_NET(string, buffer, length)
#endif

#define TRCX_DATA(level, separator, string, buffer, length)                   \
    {                                                                        \
        {                                                                    \
            sprintf string;                                                  \
            TRC_TraceData(level,                                             \
                          TraceBuffer,                                       \
                          separator,                                         \
                          (PVOID)buffer,                                     \
                          length,                                            \
                          (ULONG)__LINE__,                                   \
                          trc_fn,                                            \
                          trc_file);                                         \
        }                                                                    \
    }

/****************************************************************************/
/* Entry and exit trace macros.                                             */
/****************************************************************************/
#define TRCP(string)                                                         \
    {                                                                        \
        if (TRC_ProfileTraceEnabled())                                       \
        {                                                                    \
            TRCX(TRC_PROFILE_TRACE, TRC_SEP_PROF, string)                    \
        }                                                                    \
    }
#ifdef TRC_ENABLE_PRF
#define TRC_CLASS_OBJ TrcFn trc_fn_obj;
#define TRC_PRF(string)   TRCP(string)
#else
#define TRC_CLASS_OBJ
#define TRC_PRF(string)
#endif
#define TRC_ENTRY  TRC_PRF((TB, "Enter {")); TRC_CLASS_OBJ
#define TRC_EXIT   TRC_PRF((TB, "Exit  }"));
class TrcFn
{
    ~TrcFn()
    {
        TRC_EXIT;
    }
};

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\rdr2\rdpdr\sys\trc.cpp ===
/*++

Copyright (c) 1999-2000 Microsoft Corporation

Module Name :

    trc.cpp

Abstract:

    Kernel-Mode Tracing Facility.

    This module utilizes DCL's tracing macros, defined in atrcapi.h, in a 
    way that is intended to be independent of anything but NT DDK API's.  
    Currently, rdpwd.sys and rdpdd.sys also use these shared macros, but not 
    in a way that is independent of their respective components.

Author:

Revision History:
--*/

#include "precomp.hxx"

#include <stdio.h>
#define TRC_FILE "trc"
#include "trc.h"

//
//  This module shouldn't do much if we are not in a checked build.
//
#if DBG

////////////////////////////////////////////////////////////////////////
//
//  Globals to this Module
//

//
//  Current Tracing Parameters
//

TRC_CONFIG TRC_Config = TRC_CONFIG_DEFAULT;

//
// InterlockedIncrement is a preincrement, first thing will roll over
// and fill in entry 0
//

ULONG TRC_CurrentMsg = 0xFFFFFFFF;

//
//  Recent Traces
//

CHAR TRC_RecentTraces[TRC_RamMsgMax][TRC_BUFFER_SIZE];

BOOL TRC_ProfileTraceEnabled()
{
    return TRC_Config.TraceProfile;
}

VOID TRC_TraceLine(  
    ULONG    traceLevel,
    PCHAR traceString,
    CHAR  separator,
    ULONG  lineNumber,
    PCHAR funcName,
    PCHAR fileName
    )
/*++

Routine Description:

    "C" Tracing Entry Point.  From the perspective of the tracing macros, this
    function actaully does the tracing.

Arguments:

    traceClass  - Component doing the tracing
    traceType   - ERR, ALT, NRM, DBG
    traceString - Unadorned message
    separator   - separator character
    lineNumber  - lineNumber where the TRC_XXX call was made
    funcName    - function containing the TRC_XXX call
    fileName    - file containing the TRC_XXX call

Return Value:

    NA

--*/
{
    CHAR *msgBufEntry;
    ULONG ofs;
    CHAR tempString[TRC_BUFFER_SIZE]="";
    CHAR formatString[TRC_BUFFER_SIZE]="";
    ULONG_PTR processId;
    ULONG_PTR threadId;
    LARGE_INTEGER time;
    TIME_FIELDS TimeFields;
    ULONG idxBuffer;

    //
  