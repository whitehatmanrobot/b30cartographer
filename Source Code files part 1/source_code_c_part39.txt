 unsigned long       m_uRefs;
    PDS_SELECTION_LIST  m_pSelectionList;
};

//+----------------------------------------------------------------------------
//
//  Function:   PostPropSheet
//
//  Synopsis:   Creates a property sheet for the named object using MMC's
//              IPropertySheetProvider so that extension snapins can add pages.
//
//-----------------------------------------------------------------------------
HRESULT
PostPropSheet(PWSTR pwszObj, CDsPropPageBase * pParentPage,
              BOOL fReadOnly = FALSE);
HRESULT
PostADsPropSheet(PWSTR pwzObjDN, IDataObject * pParentObj, HWND hwndParent,
                 HWND hNotifyObj, BOOL fReadOnly);

#include "proputil.h"

#endif // _PROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\qrybase.h ===
// QryBase.h : Declaration of the CDSQuery object
//             this is an internal helper object only, not exposed
//
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      QryBase.h
//
//  Contents:  Query object for DS snapin
//
//  History:   04-dec-96 jimharr    Created
//             08-apr-98 jonn       Copied from DSADMIN QUERYSUP.H
//
//--------------------------------------------------------------------------


#ifndef __QRYBASE_H__
#define __QRYBASE_H__


#define QUERY_PAGESIZE 256
#define CMD_OPTIONS 2


/////////////////////////////////////////////////////////////////////////////
// CDSSearch

class CDSSearch
{
public:
  CDSSearch();
  ~CDSSearch();

// INTERFACES
public:
  HRESULT Init(IDirectorySearch * pObj);
  HRESULT Init(LPCWSTR lpcszObjectPath);
  HRESULT DoQuery();
  HRESULT GetNextRow ();
  HRESULT GetColumn(LPWSTR Attribute,
                    PADS_SEARCH_COLUMN pColumnData);
  HRESULT FreeColumn(PADS_SEARCH_COLUMN pColumnData) {
    return m_pObj->FreeColumn(pColumnData);
  };
  HRESULT SetAttributeList (LPWSTR *pszAttribs, INT cAttrs);
  HRESULT SetSearchScope (ADS_SCOPEENUM scope);
  HRESULT SetFilterString (LPWSTR pszFilter) {
    m_pwszFilter = pszFilter;
    return S_OK;
  };

  //Attributes
public:
  IDirectorySearch   * m_pObj;
  ADS_SEARCH_HANDLE  m_SearchHandle;

protected:
  LPWSTR             m_pwszFilter;
  LPWSTR           * m_pszAttribs;
  ULONG              m_nAttrs;


private:
  BOOL m_bInitialized;
  
};
        


#endif //__QRYBASE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\qrybase.cxx ===
// QryBase.cpp : Implementation of ds routines and classes

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:      qrybase.cpp
//
//  Contents:  DS Enumeration routines and classes
//
//  History:   02-Oct-96 WayneSc    Created
//             08-Apr-98 JonN       Copied from DSADMIN QUERYSUP.CPP
//
//
//--------------------------------------------------------------------------

#include "pch.h"

#include "qrybase.h"


///////////////////////////////////////////////////////////////////////////////
CDSSearch::CDSSearch()
{
  m_bInitialized = FALSE;
  m_pwszFilter = NULL;
  m_pObj = NULL;
  m_SearchHandle = NULL;
}

CDSSearch::~CDSSearch()
{
  if (m_pObj != NULL) {
    if (m_SearchHandle) {
      m_pObj->CloseSearchHandle (m_SearchHandle);
    }
    m_pObj->Release();
  }
}


HRESULT CDSSearch::Init(IDirectorySearch * pObj)
{
  HRESULT            hr = S_OK;
  
  m_pObj = pObj;
  pObj->AddRef();
  m_bInitialized = TRUE;
  
  return hr;
}

HRESULT CDSSearch::Init(LPCWSTR lpcszObjectPath)
{
  HRESULT            hr;

  hr = DSAdminOpenObject(const_cast<LPWSTR>(lpcszObjectPath), 
                         IID_IDirectorySearch, 
                         (void **)&m_pObj);
  if (SUCCEEDED(hr)) {
    m_bInitialized = TRUE;
  } else {
    m_bInitialized = FALSE;
    m_pObj = NULL;
  }
  return hr;
}

HRESULT CDSSearch::SetAttributeList (LPWSTR *pszAttribs, INT cAttrs)
{
  m_pszAttribs = pszAttribs;
  m_nAttrs = cAttrs;
  return S_OK;
}

HRESULT CDSSearch::SetSearchScope (ADS_SCOPEENUM scope)
{
  ADS_SEARCHPREF_INFO aSearchPref;
  HRESULT hr;

  if (m_bInitialized) {
    aSearchPref.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    aSearchPref.vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref.vValue.Integer = scope;
    return hr = m_pObj->SetSearchPreference (&aSearchPref, 1);
  } else {
    return E_ADS_BAD_PATHNAME;
  }
}


const int NUM_PREFS=2;
HRESULT CDSSearch::DoQuery()
{

  HRESULT            hr;
  ADS_SEARCHPREF_INFO aSearchPref[NUM_PREFS];

  if (m_bInitialized) {
    aSearchPref[0].dwSearchPref = ADS_SEARCHPREF_CHASE_REFERRALS;
    aSearchPref[0].vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref[0].vValue.Integer = ADS_CHASE_REFERRALS_EXTERNAL;
    aSearchPref[1].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    aSearchPref[1].vValue.dwType = ADSTYPE_INTEGER;
    aSearchPref[1].vValue.Integer = QUERY_PAGESIZE;
    
    hr = m_pObj->SetSearchPreference (aSearchPref, NUM_PREFS);
    
    if (SUCCEEDED(hr)) {
      hr = m_pObj->ExecuteSearch (m_pwszFilter,
                                  m_pszAttribs,
                                  m_nAttrs,
                                  &m_SearchHandle);
    }
  } else {
    hr = E_ADS_BAD_PATHNAME;
  }
  return hr;
}

HRESULT
CDSSearch::GetNextRow()
{
  if (m_bInitialized) {
    return m_pObj->GetNextRow (m_SearchHandle);
  }
  return E_ADS_BAD_PATHNAME;
}

HRESULT
CDSSearch::GetColumn(LPWSTR Attribute,
                     PADS_SEARCH_COLUMN pColumnData)
{
  if (m_bInitialized) {
    return m_pObj->GetColumn (m_SearchHandle,
                              Attribute,
                              pColumnData);
  }
  return E_ADS_BAD_PATHNAME;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\sources.inc ===
!IF 0

Microsoft Windows Actice Directory Property Pages

Microsoft Windows

Copyright (C) Microsoft Corporation, 1998 - 2001

    sources include file with common definitions for the AD property pages

!ENDIF

MAJORCOMP=  admin
MINORCOMP=  dsprop

DLLENTRY=   _DllMainCRTStartup

PRECOMPILED_CXX=1
PRECOMPILED_PCH=pch.pch
PRECOMPILED_OBJ=pch.obj

USE_MSVCRT= 1
USE_ATL=1
ATL_VER=30

MSC_WARNING_LEVEL= /W4

!IF "$(PLATFORM)"=="WINNT"

LIB_PLATFORM_PATH=$(SDK_LIB_PATH)
C_DEFINES= -DUNICODE -DDSADMIN

!ELSE

CHICAGO_PRODUCT = 1
LIB_PLATFORM_PATH = $(SDK_LIB_DEST)\chicago\$(TARGET_DIRECTORY)
ALT_PROJECT_TARGET = win95
SUBSYSTEM_VERSION = 4.00
UMTYPE = console
C_DEFINES=

!ENDIF

MSC_WARNING_LEVEL=/W4 /WX

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217

TARGETLIBS= \
    $(LIB_PLATFORM_PATH)\kernel32.lib \
    $(LIB_PLATFORM_PATH)\advapi32.lib \
    $(LIB_PLATFORM_PATH)\user32.lib   \
    $(LIB_PLATFORM_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\ntdsapi.lib       \
    $(SHELL_LIB_PATH)\shell32p.lib    \
    $(SDK_LIB_PATH)\shlwapi.lib       \
    $(SDK_LIB_PATH)\ole32.lib         \
    $(SDK_LIB_PATH)\oleaut32.lib      \
    $(SDK_LIB_PATH)\adsiid.lib        \
    $(SDK_LIB_PATH)\activeds.lib      \
    $(SDK_LIB_PATH)\dsuiext.lib       \
    $(SDK_LIB_PATH)\mmc.lib           \
    $(SDK_LIB_PATH)\uuid.lib          \
    $(PROJECT_ROOT)\dsadminlib\src\$(O)\dsadminp.lib

!IF "$(PLATFORM)"=="WINNT"
TARGETLIBS= $(TARGETLIBS) $(DS_LIB_PATH)\netapi32p.lib \
                          $(SHELL_LIB_PATH)\shfusion.lib
!ELSE
TARGETLIBS= $(TARGETLIBS) $(SDK_LIB_PATH)\logonsrv.lib \
                          $(SDK_LIB_PATH)\comctl32.lib \
                          $(SDK_LIB_PATH)\comdlg32.lib
!ENDIF

TARGETPATHLIB= obj

INCLUDES=   $(INCLUDES);       \
            $(DS_INC_PATH);    \
            $(SHELL_INC_PATH); \
            $(NET_INC_PATH);   \
            $(BASE_INC_PATH);  \
            $(PROJECT_ROOT)\dsadminlib\inc;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\strings.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       strings.cxx
//
//  Contents:   String constants that don't need to be localized.
//
//  History:    06-Jun-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"

PWSTR g_wzLDAPPrefix = L"LDAP://";
PWSTR g_wzLDAPProvider = L"LDAP";
PWSTR g_wzWINNTPrefix = L"WinNT://";
PWSTR g_wzPartitionsContainer = L"CN=Partitions,";
PWSTR g_wzSidPathPrefix = L"<SID=";
PWSTR g_wzSidPathSuffix = L">";
PWSTR g_wzRootDSE = L"RootDSE";
PWSTR g_wzConfigNamingContext = L"configurationNamingContext";
PWSTR g_wzSchemaNamingContext = L"schemaNamingContext";

PWSTR g_wzCRLF = L"\r\n";
PWSTR g_wzBOM = L"\xFEFF"; // Byte Order Mark

//
// Class names:
//
PWSTR g_wzUser = L"user";
PWSTR g_wzGroup = L"group";
PWSTR g_wzContact = L"contact";
PWSTR g_wzComputer = L"computer";
PWSTR g_wzFPO = L"foreignSecurityPrincipal";
PWSTR g_wzInetOrgPerson = L"inetOrgPerson";

//
// Attribute names:
//
PWSTR g_wzClass = L"class";
PWSTR g_wzObjectClass = L"objectClass";
PWSTR g_wzDescription = L"description"; // ADSTYPE_CASE_IGNORE_STRING
PWSTR g_wzName = L"name";               // ADSTYPE_CASE_IGNORE_STRING
PWSTR g_wzMemberAttr = L"member";       // ADSTYPE_DN_STRING
PWSTR g_wzObjectSID = L"objectSid";
PWSTR g_wzGroupType = L"groupType";
PWSTR g_wzADsPath = L"ADsPath";

PWSTR g_wzStreet = L"streetAddress";
PWSTR g_wzPOB = L"postOfficeBox";
PWSTR g_wzCity = L"l";
PWSTR g_wzState = L"st";
PWSTR g_wzZIP = L"postalCode";
PWSTR g_wzCountryName = L"c";
PWSTR g_wzCountryCode = L"countryCode";
PWSTR g_wzTextCountry = L"co";
PWSTR g_wzDN = L"distinguishedName";
PWSTR g_wzUserAccountControl = L"userAccountControl";
PWSTR g_wzAllowed = L"allowedAttributesEffective";
PWSTR g_wzDomainMode = L"nTMixedDomain";
PWSTR g_wzBehaviorVersion = L"msDS-Behavior-Version";
PWSTR g_wzHasMasterNCs = L"hasMasterNCs";

// 531591 JonN 2002/04/01 msDsHasMasterNCs
PWSTR g_wzMsDsHasMasterNCs = L"msDS-hasMasterNCs";

PWSTR g_wzA2D2 = L"msDS-AllowedToDelegateTo";
PWSTR g_wzSPN = L"servicePrincipalName";
PWSTR g_wzHost = L"HOST";
PWSTR g_wzSPNMappings = L"sPNMappings";
PWSTR g_wzServerRef = L"serverReference";
PWSTR g_wzServerRefBL = L"serverReferenceBL";
PWSTR g_wzLastKnownParent = L"lastKnownParent";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\strings.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       strings.h
//
//  Contents:   String constants that don't need to be localized.
//
//  History:    06-Jun-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef __STRINGS_H__
#define __STRINGS_H__

extern PWSTR g_wzLDAPPrefix;
extern PWSTR g_wzLDAPProvider;
extern PWSTR g_wzWINNTPrefix;
extern PWSTR g_wzPartitionsContainer;
extern PWSTR g_wzSidPathPrefix;
extern PWSTR g_wzSidPathSuffix;
extern PWSTR g_wzRootDSE;
extern PWSTR g_wzConfigNamingContext;
extern PWSTR g_wzSchemaNamingContext;

extern PWSTR g_wzCRLF;
extern PWSTR g_wzBOM;

extern PWSTR g_wzUser;
extern PWSTR g_wzGroup;
extern PWSTR g_wzContact;
extern PWSTR g_wzComputer;
extern PWSTR g_wzFPO;
extern PWSTR g_wzInetOrgPerson;

extern PWSTR g_wzClass;
extern PWSTR g_wzObjectClass;
extern PWSTR g_wzDescription;
extern PWSTR g_wzName;
extern PWSTR g_wzMemberAttr;
extern PWSTR g_wzObjectSID;
extern PWSTR g_wzGroupType;
extern PWSTR g_wzADsPath;
extern PWSTR g_wzStreet;
extern PWSTR g_wzPOB;
extern PWSTR g_wzCity;
extern PWSTR g_wzState;
extern PWSTR g_wzZIP;
extern PWSTR g_wzCountryName;
extern PWSTR g_wzCountryCode;
extern PWSTR g_wzTextCountry;
extern PWSTR g_wzDN;
extern PWSTR g_wzUserAccountControl;
extern PWSTR g_wzDomainMode;
extern PWSTR g_wzAllowed;
extern PWSTR g_wzBehaviorVersion;
extern PWSTR g_wzHasMasterNCs;

// 531591 JonN 2002/04/01 msDsHasMasterNCs
extern PWSTR g_wzMsDsHasMasterNCs;

extern PWSTR g_wzA2D2;
extern PWSTR g_wzSPN;
extern PWSTR g_wzHost;
extern PWSTR g_wzSPNMappings;
extern PWSTR g_wzServerRef;
extern PWSTR g_wzServerRefBL;
extern PWSTR g_wzLastKnownParent;

#endif // __STRINGS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\proputil.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       proputil.h
//
//  Contents:   DS object property pages utility and helper functions header
//
//  History:    29-Sept-98 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _PROPUTIL_H_
#define _PROPUTIL_H_

extern const CLSID CLSID_DomainAdmin; // Domains & Trusts snapin CLSID

const unsigned long DSPROP_FILETIMES_PER_MILLISECOND = 10000;
const DWORD DSPROP_FILETIMES_PER_SECOND = 1000 * DSPROP_FILETIMES_PER_MILLISECOND;
const DWORD DSPROP_FILETIMES_PER_MINUTE = 60 * DSPROP_FILETIMES_PER_SECOND;
const __int64 DSPROP_FILETIMES_PER_HOUR = 60 * (__int64)DSPROP_FILETIMES_PER_MINUTE;
const __int64 DSPROP_FILETIMES_PER_DAY  = 24 * DSPROP_FILETIMES_PER_HOUR;
const __int64 DSPROP_FILETIMES_PER_MONTH= 30 * DSPROP_FILETIMES_PER_DAY;

const UINT DSPROP_TIMER_DELAY = 300; // 300 millisecond delay.

extern ULONG g_ulMemberFilterCount;
extern ULONG g_ulMemberQueryLimit;

#define DSPROP_MEMBER_FILTER_COUNT_DEFAULT 35
#define DSPROP_MEMBER_QUERY_LIMIT_DEFAULT 500

//
// Helpers.
//
BOOL UnicodeToTchar(LPWSTR pwszIn, LPTSTR * pptszOut);
BOOL TcharToUnicode(LPTSTR ptszIn, LPWSTR * ppwszOut);
BOOL AllocWStr(PWSTR pwzStrIn, PWSTR * ppwzNewStr);
BOOL AllocTStr(PTSTR ptzStrIn, PTSTR * pptzNewStr);
BOOL LoadStringToTchar(int ids, PTSTR * pptstr);
HRESULT AddLDAPPrefix(CDsPropPageBase * pObj, PWSTR pwzObj, CStrW &strResult,
                      BOOL fServer = TRUE);
void InitAttrInfo(PADS_ATTR_INFO pAttr, PWSTR pwzName, ADSTYPEENUM type);
HRESULT GetLdapServerName(IUnknown * pDsObj, CStrW& strServer);
BOOL FValidSMTPAddress(PWSTR pwzBuffer);
HRESULT CheckRegisterClipFormats(void);
HRESULT BindToGCcopyOfObj(CDsPropPageBase * pPage, PWSTR pwzObjADsPath,
                          IDirectoryObject ** ppDsObj);
void ConvertSidToPath(PSID ObjSID, CStrW &strSIDname);
int MsgBoxParam(UINT MsgID, LPARAM lParam, HWND hWnd, int nStyle = 0);

#define ARRAYLENGTH(x)  (sizeof(x)/sizeof((x)[0]))
#define DO_DEL(x) if (x) {delete x; x = NULL;}
#define DO_RELEASE(x) if (x) {x->Release(); x = NULL;}

HRESULT GetDomainScope(CDsPropPageBase * pPage, BSTR * pBstrOut);
HRESULT GetObjectsDomain(CDsPropPageBase * pPage, PWSTR pwzObjPath, BSTR * pBstrOut);

void ReportErrorWorker(HWND hWnd, PTSTR ptzMsg);

// This will take any value that is to be used in an LDAP search
// filter and make sure that the special characters are escaped
// per RFC 2254

void GetFilterEscapedValue(PCWSTR value, CStrW& filterEscapedValue);

#if defined(DSADMIN)
//+----------------------------------------------------------------------------
//
//  Function:   DspFormatMessage
//
//  Synopsis:   Loads a string resource with replaceable parameters and uses
//              FormatMessage to populate the replaceable params from the
//              argument array. If dwErr is non-zero, will load the system
//              description for that error and include it in the argument array.
//
//-----------------------------------------------------------------------------
void
DspFormatMessage(
    int nMessageId,     // string resource ID of message. Must have replacable params to match nArguments.
    DWORD dwErr,        // Error code, or zero if not needed.
    PVOID * rgpvArgs,   // array of pointers/values for substitution in the nMessageId string.
    int nArguments,     // count of pointers in string array.
    BOOL fTryADSiErrors,// If the failure is the result of an ADSI call, see if an ADSI extended error.
    PWSTR * ppwzMsg,    // The returned error string, free with LocalFree.
    HWND hWnd = NULL    // owning window, can be NULL.
    );
#endif // defined(DSADMIN)

//
// Predefined table-driven page auxiliary functions
//

//
// For these, set the bit you want in pAttrMap->pData.
// You can "reverse the sense" of the checkbox by providing the inverse of the bit.
//
HRESULT
FirstSharedBitField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
          LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
SubsequentSharedBitField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
          LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
HideBasedOnBitField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
          LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);

// Sets the context help ID to pAttrMap->pData on fInit/fObjChanged
// This is particularly useful for static text controls which cannot set
// context help ID in the resource file.
HRESULT
SetContextHelpIdAttrFn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
          LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);

HRESULT
DsQuerySite(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DsQueryInterSiteTransport(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DsQueryPolicy(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DsReplicateListbox(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
/*
HRESULT
DsQueryFrsPrimaryMember(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
*/
HRESULT
GeneralPageIcon(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                DLG_OP DlgOp);

//
// Duelling listbox functions
//
// DuellingListbox can be used for all "out" listboxes,
// and DuellingListboxButton can be used for all Add and Remove buttons.
// Only the In listbox needs an individual handler.
// The control IDs for the four controls in a duelling listbox set are constrained;
// they must be in sequence OUT, ADD, REMOVE, IN, with the ID for OUT divisible by 4.
//
HRESULT
DuellingListbox(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DuellingListboxButton(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DsQuerySiteList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DsQuerySiteLinkList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);
HRESULT
DsQueryBridgeheadList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);


HRESULT IntegerAsBoolDefOn(CDsPropPageBase *, PATTR_MAP, PADS_ATTR_INFO,
                           LPARAM, PATTR_DATA, DLG_OP);

HRESULT VolumeUNCpath(CDsPropPageBase *, PATTR_MAP, PADS_ATTR_INFO,
                      LPARAM, PATTR_DATA, DLG_OP);

//  Flags for Validate Unc Path

#define VUP_mskfAllowEmptyPath  0x0001  // Empty path is valid
#define VUP_mskfAllowUNCPath    0x0002  // UNC path is valid

BOOL FIsValidUncPath(LPCTSTR pszPath, UINT uFlags = 0);

void ShowHelp(PCWSTR pwzHelpFile);

//+----------------------------------------------------------------------------
//
//  Class:      CPageInfo
//
//  Purpose:    Holds the HWNDs of all proppages and the errors associated with
//              them from the apply
//
//-----------------------------------------------------------------------------
class CPageInfo
{
public:
  CPageInfo() : m_hWnd(NULL), m_ptzTitle(NULL), m_ApplyStatus(notAttempted) {}
  ~CPageInfo() 
  {
    if (m_ptzTitle != NULL)
    {
      delete[] m_ptzTitle;
      m_ptzTitle = NULL;
    }
  }

  typedef enum
  {
    notAttempted = 0,
    success,
    failed,
  } APPLYSTATUS;

  HWND             m_hWnd;
  CADsApplyErrors  m_ApplyErrors;
  APPLYSTATUS      m_ApplyStatus;
  PTSTR            m_ptzTitle;
};

//+----------------------------------------------------------------------------
//
//  Class:      CNotifyObj
//
//  Purpose:    Handles inter-page and inter-sheet syncronization.
//
//-----------------------------------------------------------------------------
class CNotifyObj
{
#ifdef _DEBUG
    char szClass[32];
#endif

    friend VOID __cdecl NotifyThreadFcn(PVOID);
    friend VOID RegisterNotifyClass(void);

public:

    CNotifyObj(LPDATAOBJECT pDataObj, PPROPSHEETCFG pSheetCfg);
    ~CNotifyObj(void);

    //
    // Creation function to create an instance of the object.
    //
    static HRESULT Create(LPDATAOBJECT pAppThdDataObj, PWSTR pwzADsObjName,
                          HWND * phNotifyObj);
    //
    // Pages call this at their object init time to retreive DS object info.
    //
    static BOOL GetInitInfo(HWND hNotifyObj, PADSPROPINITPARAMS pInitParams);
    //
    // Pages call this at their dialog init time to send their hwnd.
    //
    static BOOL SetHwnd(HWND hNotifyObj, HWND hPage, PTSTR ptzTitle = NULL);
    //
    //  Static WndProc to be passed as class address.
    //
    static LRESULT CALLBACK StaticNotifyProc(HWND hWnd, UINT uMsg,
                                             WPARAM wParam, LPARAM lParam);
    //
    // Instance window procedure.
    //
    LRESULT CALLBACK NotifyProc(HWND hWnd, UINT uMsg, WPARAM wParam,
                                LPARAM lParam);
    //
    //  Member functions, called by WndProc
    //
    LRESULT OnCreate(void);

    //
    //  Data members
    //
    HWND                m_hWnd;
    DWORD               m_cPages;
    DWORD               m_cApplies;
    LPDATAOBJECT        m_pAppThdDataObj;
    UINT                m_nPageInfoArraySize;
    CPageInfo*          m_pPageInfoArray;

private:
//    HWND                m_hWnd;
    HWND                m_hPropSheet;
//    DWORD               m_cPages;
//    DWORD               m_cApplies;
//    LPDATAOBJECT        m_pAppThdDataObj;
    LPSTREAM            m_pStrmMarshalledDO;
    PROPSHEETCFG        m_sheetCfg;
    HANDLE              m_hInitEvent;
    BOOL                m_fBeingDestroyed;
    BOOL                m_fSheetDirty;
    HRESULT             m_hr;
    PWSTR               m_pwzObjDN;
    IDirectoryObject  * m_pDsObj;
    PWSTR               m_pwzCN;
    PADS_ATTR_INFO      m_pWritableAttrs;
    PADS_ATTR_INFO      m_pAttrs;
    CDllRef             m_DllRef;
    
//    UINT                m_nPageInfoArraySize;
//    CPageInfo*          m_pPageInfoArray;
};

//+----------------------------------------------------------------------------
//
//  Class:      CMultiStringAttr
//
//  Purpose:    Read, edit, and write a multi-valued, string property.
//
//-----------------------------------------------------------------------------
class CMultiStringAttr
{
public:
    CMultiStringAttr(CDsPropPageBase * pPage);
    ~CMultiStringAttr();

    HRESULT Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                 BOOL fWritable = TRUE, int nLimit = 0,
                 BOOL fCommaList = FALSE,
                 BOOL fAppend = FALSE);
    HRESULT Write(PADS_ATTR_INFO pAttr);

    BOOL    DoDlgInit(HWND hDlg);
    int     DoCommand(HWND hDlg, int id, int code);
    BOOL    DoNotify(HWND hDlg, NMHDR * pNmHdr);

    BOOL    HasValues(void) {return m_AttrInfo.dwNumValues > 0;};
    void    EnableControls(HWND hDlg, BOOL fEnable);
    void    SetDirty(HWND hDlg);
    BOOL    IsDirty(void) {return m_fDirty;};
    void    ClearDirty(void) {m_fDirty = FALSE;};
    BOOL    IsWritable(void) {return m_fWritable;};
    void    ToggleDefaultBtn(HWND hDlg, BOOL fOK);

private:
    void                ClearAttrInfo(void);

    CDsPropPageBase   * m_pPage;
    ADS_ATTR_INFO       m_AttrInfo;
    PWSTR               m_pAttrLDAPname;
    int                 m_nMaxLen;
    int                 m_nCurDefCtrl;
    BOOL                m_fListHasSel;
    int                 m_nLimit;
    int                 m_cValues;
    BOOL                m_fWritable;
    BOOL                m_fCommaList;
    BOOL                m_fDirty;
    BOOL                m_fAppend;
};

//+----------------------------------------------------------------------------
//
//  Class:      CMultiStringAttrDlg
//
//  Purpose:    Read, edit, and write a multi-valued, string property. This
//              is a dialog that hosts the CMultiStringAttr class.
//
//-----------------------------------------------------------------------------
class CMultiStringAttrDlg
{
public:
    CMultiStringAttrDlg(CDsPropPageBase * pPage);
    ~CMultiStringAttrDlg() {};
    //
    //  Static WndProc for multi-valued edit dialog.
    //
    static INT_PTR CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg,
                                          WPARAM wParam, LPARAM lParam);
    HRESULT Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                 BOOL fWritable = TRUE, int nLimit = 0,
                 BOOL fCommaList = FALSE,
                 BOOL fMultiselectPage = FALSE);
    INT_PTR Edit(void);
    HRESULT Write(PADS_ATTR_INFO pAttr);

private:
    //
    // Dialog proc.
    //
    INT_PTR CALLBACK MultiValDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);

    void                ClearAttrInfo(void);

    CMultiStringAttr    m_MSA;
    CDsPropPageBase   * m_pPage;
};

// Attribute function invoked by Other values button, manipulates the
// CMultiStringAttr class.
//
HRESULT
OtherValuesBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp);

//+----------------------------------------------------------------------------
//
//  Class:      CDsIconCtrl
//
//  Purpose:    sub-class window proc for icon control.
//
//-----------------------------------------------------------------------------
class CDsIconCtrl
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsIconCtrl(HWND hCtrl, HICON hIcon);
    ~CDsIconCtrl(void);

    //
    //  Static WndProc to be passed as subclass address.
    //
    static LRESULT CALLBACK StaticCtrlProc(HWND hWnd, UINT uMsg,
                                           WPARAM wParam, LPARAM lParam);
    //
    //  Member functions, called by WndProc
    //
    LRESULT OnPaint(void);

    //
    //  Data members
    //

protected:
    HWND                m_hCtrl;
    HWND                m_hDlg;
    WNDPROC             m_pOldProc;
    HICON               m_hIcon;
};

//+----------------------------------------------------------------------------
//
//  Template:   CSmartPtr
//
//  Purpose:    A simple smart pointer template that does cleanup with
//              the delete operator.
//
//-----------------------------------------------------------------------------
template <class T>
class CSmartPtr
{
public:
    CSmartPtr(void) {m_ptr = NULL; m_fDetached = FALSE;}
    CSmartPtr(DWORD dwSize) {m_ptr = new T[dwSize]; m_fDetached = FALSE;}
    ~CSmartPtr(void) {if (!m_fDetached) DO_DEL(m_ptr);}

    T* operator=(const CSmartPtr& src) {return src.m_ptr;}
    void operator=(const T* src) {if (!m_fDetached) DO_DEL(m_ptr); m_ptr = src;}
    operator const T*() {return m_ptr;}
    operator T*() {return m_ptr;}
    T* operator->() {dspAssert(m_ptr); return m_ptr;}
    T** operator&() {if (!m_fDetached) DO_DEL(m_ptr); return &m_ptr;}
    operator BOOL() const {return m_ptr != NULL;}
    BOOL operator!() {return m_ptr == NULL;}

    T* Detach() {m_fDetached = TRUE; return m_ptr;}

private:
    T     * m_ptr;
    BOOL    m_fDetached;
};

//+----------------------------------------------------------------------------
//
//  class:      CSmartPtr for character string pointers.
//
//  Purpose:    Simple types don't allow the -> operator, so specialize the
//              template.
//
//-----------------------------------------------------------------------------
#if !defined(UNICODE)
template <> class CSmartPtr <TCHAR>
{
public:
    CSmartPtr(void) {m_ptr = NULL; m_fDetached = FALSE;}
    CSmartPtr(DWORD dwSize) {m_ptr = new TCHAR[dwSize]; m_fDetached = FALSE;}
    ~CSmartPtr(void) {if (!m_fDetached) DO_DEL(m_ptr);}

    TCHAR* operator=(const CSmartPtr& src) {return src.m_ptr;}
    void operator=(TCHAR* src) {if (!m_fDetached) DO_DEL(m_ptr); m_ptr = src;}
    operator const TCHAR*() {return m_ptr;}
    operator TCHAR*() {return m_ptr;}
    TCHAR** operator&() {if (!m_fDetached) DO_DEL(m_ptr); return &m_ptr;}
    operator BOOL() const {return m_ptr != NULL;}
    BOOL operator!() {return m_ptr == NULL;}

    TCHAR* Detach() {m_fDetached = TRUE; return m_ptr;}

private:
    TCHAR * m_ptr;
    BOOL    m_fDetached;
};
#endif
template <> class CSmartPtr <WCHAR>
{
public:
    CSmartPtr(void) {m_ptr = NULL; m_fDetached = FALSE;}
    CSmartPtr(DWORD dwSize) {m_ptr = new WCHAR[dwSize]; m_fDetached = FALSE;}
    ~CSmartPtr(void) {if (!m_fDetached) DO_DEL(m_ptr);}

    WCHAR* operator=(const CSmartPtr& src) {return src.m_ptr;}
    void operator=(WCHAR* src) {if (!m_fDetached) DO_DEL(m_ptr); m_ptr = src;}
    operator const WCHAR*() {return m_ptr;}
    operator WCHAR*() {return m_ptr;}
    WCHAR** operator&() {if (!m_fDetached) DO_DEL(m_ptr); return &m_ptr;}
    operator BOOL() const {return m_ptr != NULL;}
    BOOL operator!() {return m_ptr == NULL;}

    WCHAR* Detach() {m_fDetached = TRUE; return m_ptr;}

private:
    WCHAR * m_ptr;
    BOOL    m_fDetached;
};

#define CSmartWStr CSmartPtr <WCHAR>

template <> class CSmartPtr <PVOID>
{
public:
    CSmartPtr(void) {m_ptr = NULL; m_fDetached = FALSE;}
    CSmartPtr(DWORD dwSize) {m_ptr = new BYTE[dwSize]; m_fDetached = FALSE;}
    ~CSmartPtr(void) 
    {
      if (!m_fDetached) 
        DO_DEL(m_ptr);
    }

    PVOID operator=(const CSmartPtr& src) {return src.m_ptr;}
    void operator=(PVOID src) {if (!m_fDetached) DO_DEL(m_ptr); m_ptr = src;}
    operator const PVOID() {return m_ptr;}
    operator PVOID() {return m_ptr;}
    PVOID* operator&() {if (!m_fDetached) DO_DEL(m_ptr); return &m_ptr;}
    operator BOOL() const {return m_ptr != NULL;}
    BOOL operator!() {return m_ptr == NULL;}

    PVOID Detach() {m_fDetached = TRUE; return m_ptr;}

private:
    PVOID   m_ptr;
    BOOL    m_fDetached;
};

class CSmartBytePtr
{
public:
    CSmartBytePtr(void) {m_ptr = NULL; m_fDetached = FALSE;}
    CSmartBytePtr(DWORD dwSize) {m_ptr = new BYTE[dwSize]; m_fDetached = FALSE;}
    ~CSmartBytePtr(void) {if (!m_fDetached) DO_DEL(m_ptr);}

    BYTE* operator=(const CSmartBytePtr& src) {return src.m_ptr;}
    void operator=(BYTE* src) {if (!m_fDetached) DO_DEL(m_ptr); m_ptr = src;}
    operator const BYTE*() {return m_ptr;}
    operator BYTE*() {return m_ptr;}
    BYTE** operator&() {if (!m_fDetached) DO_DEL(m_ptr); return &m_ptr;}
    operator BOOL() const {return m_ptr != NULL;}
    BOOL operator!() {return m_ptr == NULL;}

    BYTE* Detach() {m_fDetached = TRUE; return m_ptr;}

private:
    BYTE  * m_ptr;
    BOOL    m_fDetached;
};

class CSimpleSecurityDescriptorHolder
{
public:
  CSimpleSecurityDescriptorHolder()
  {
    m_pSD = NULL;
  }

  ~CSimpleSecurityDescriptorHolder()
  {
    if (m_pSD != NULL)
    {
      ::LocalFree(m_pSD);
      m_pSD = NULL;
    }
  }

  PSECURITY_DESCRIPTOR m_pSD;
private:
  CSimpleSecurityDescriptorHolder(const CSimpleSecurityDescriptorHolder&)
  {}

  CSimpleSecurityDescriptorHolder& operator=(const CSimpleSecurityDescriptorHolder&) {}
};

class CSimpleAclHolder
{
public:
  CSimpleAclHolder()
  {
    m_pAcl = NULL;
  }
  ~CSimpleAclHolder()
  {
    if (m_pAcl != NULL)
      ::LocalFree(m_pAcl);
  }

  PACL m_pAcl;
};

extern ATTR_MAP GenIcon;

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Class:      CMultiSelectErrorDialog
//
//  Purpose:    Error Message box when multi-select proppages fail to apply all
//              properties.  Each object is listed with each failure
//
//-----------------------------------------------------------------------------
class CMultiSelectErrorDialog
{
public:
  CMultiSelectErrorDialog(HWND hNotifyObj, HWND hParent);
  ~CMultiSelectErrorDialog() 
  {
    if (m_pDataObj != NULL)
    {
      m_pDataObj->Release();
    }
  }

  static INT_PTR CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  HRESULT Init(CPageInfo* pPageInfoArray, UINT nPageCount, IDataObject* pDataObj);
  virtual int DoModal();
  virtual BOOL OnInitDialog(HWND hDlg);
  virtual void OnCopyButton();
  virtual void OnClose();
  virtual void ListItemActivate(LPNMHDR pnmh);
  virtual void ListItemClick(LPNMHDR pnmh);
  HRESULT InitializeListBox(HWND hDlg);
  virtual BOOL ShowWindow();

  BOOL ShowListViewItemProperties();

  HWND             m_hWnd;
  BOOL             m_bModal;

private:
  HWND             m_hNotifyObj;
  HWND             m_hParent;
  BOOL             m_bInit;
  HWND             m_hList;

  IDataObject*     m_pDataObj;
  UINT             m_nPageCount;
  CPageInfo*       m_pPageInfoArray;
};

#endif // DSADMIN
#endif // _PROPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\tablpage.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       tablpage.cxx
//
//  Contents:   CDsTableDrivenPage, the class that implements table-driven
//              property pages
//
//  History:    1-April-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include <stdio.h>
#include "proppage.h"

//+----------------------------------------------------------------------------
//
//  Member:     CDsTableDrivenPage::CDsTableDrivenPage
//
//-----------------------------------------------------------------------------
CDsTableDrivenPage::CDsTableDrivenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                       HWND hNotifyWnd, DWORD dwFlags) :
    m_pData(NULL),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyWnd, dwFlags)
{
    TRACE(CDsTableDrivenPage,CDsTableDrivenPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsTableDrivenPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsTableDrivenPage::~CDsTableDrivenPage
//
//-----------------------------------------------------------------------------
CDsTableDrivenPage::~CDsTableDrivenPage()
{
    TRACE(CDsTableDrivenPage,~CDsTableDrivenPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateTableDrivenPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateTableDrivenPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                      PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyWnd,
                      DWORD dwFlags, 
                      const CDSSmartBasePathsInfo& basePathsInfo,
                      HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateTableDrivenPage);

    CDsTableDrivenPage * pPageObj = new CDsTableDrivenPage(pDsPage, pDataObj,
                                                           hNotifyWnd, dwFlags);

    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CDsTableDrivenPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (uMsg == g_uChangeMsg)
    {
        return OnAttrChanged(wParam);
    }

    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case PSM_QUERYSIBLINGS:
        return OnQuerySibs(wParam, lParam);

    case WM_ADSPROP_NOTIFY_CHANGE:
        return OnObjChanged();

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return FALSE;
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsTableDrivenPage::OnInitDialog(LPARAM)
{
    TRACE(CDsTableDrivenPage,OnInitDialog);

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    if (SUCCEEDED(m_hrInit))
    {
        return ReadAttrsSetCtrls(fInit);
    }
    else
    {
        // error page is posted automatically.
        return 0;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnApply(void)
{
    TRACE(CDsTableDrivenPage,OnApply);
    HRESULT hr = S_OK;
    LPTSTR ptsz;
    LPWSTR pwszValue;
    PADSVALUE pADsValue;
    DWORD cAttrs = 0;

    if (m_fReadOnly)
    {
        return PSNRET_NOERROR;
    }

    PADS_ATTR_INFO pAttrs = new ADS_ATTR_INFO[m_cAttrs];
    CHECK_NULL_REPORT(pAttrs, GetHWnd(), return -1);

    memset(pAttrs, 0, sizeof(ADS_ATTR_INFO) * m_cAttrs);

    for (DWORD i = 0; i < m_cAttrs; i++)
    {
        if (m_rgpAttrMap[i]->fIsReadOnly ||
            (!m_rgpAttrMap[i]->pAttrFcn && 
             (!ATTR_DATA_IS_WRITABLE(m_rgAttrData[i]) || 
              !ATTR_DATA_IS_DIRTY(m_rgAttrData[i]))))
        {
            // If the map defines it to be read-only or no attr function is
            // defined and the attribute is not writable or not dirty, then
            // skip it.
            //
            continue;
        }

        pAttrs[cAttrs] = m_rgpAttrMap[i]->AttrInfo;

        if (m_rgpAttrMap[i]->pAttrFcn)
        {
            // Handle special-case attribute.
            //
            hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i],
                                              &pAttrs[cAttrs], 0,
                                              &m_rgAttrData[i], fApply);
            CHECK_HRESULT(hr, goto Cleanup);

            if (hr == ADM_S_SKIP)
            {
                // Don't write the attribute.
                //
                continue;
            }

            if (hr != S_FALSE)
            {
                // If the attr fcn didn't return S_FALSE, that means that it
                // handled the value. If it did return S_FALSE, then let the
                // standard edit control processing below handle the value.
                //
                cAttrs++;

                continue;
            }
        }

        if (m_rgpAttrMap[i]->AttrInfo.dwADsType == ADSTYPE_BOOLEAN)
        {
            // Handle boolean checkbox attributes.
            //

            pADsValue = new ADSVALUE;
            CHECK_NULL_REPORT(pADsValue, GetHWnd(), goto Cleanup);

            pAttrs[cAttrs].pADsValues = pADsValue;
            pAttrs[cAttrs].dwNumValues = 1;
            pADsValue->dwType = m_rgpAttrMap[i]->AttrInfo.dwADsType;

            pADsValue->Boolean = 
                        IsDlgButtonChecked(m_hPage, m_rgpAttrMap[i]->nCtrlID)
                            == BST_CHECKED;
            cAttrs++;

            continue;
        }

        // Assumes that all non-special-case attributes,
        // if single-valued and not boolean, come from a text control.
        //
        ptsz = new TCHAR[m_rgpAttrMap[i]->nSizeLimit + 1];
        CHECK_NULL_REPORT(ptsz, GetHWnd(), goto Cleanup);

        GetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, ptsz,
                       m_rgpAttrMap[i]->nSizeLimit + 1);

        CStr csValue = ptsz;

        csValue.TrimLeft();
        csValue.TrimRight();

        if (_tcslen(ptsz) != (size_t)csValue.GetLength())
        {
            // the length is different, it must have been trimmed. Write trimmed
            // value back to the control.
            //
            SetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, const_cast<PTSTR>((LPCTSTR)csValue));
        }
        delete [] ptsz;

        if (csValue.IsEmpty())
        {
            // An empty control means remove the attribute value from the
            // object.
            //
            pAttrs[cAttrs].dwControlCode = ADS_ATTR_CLEAR;
            pAttrs[cAttrs].dwNumValues = 0;
            pAttrs[cAttrs].pADsValues = NULL;

            cAttrs++;
            continue;
        }

        if (!TcharToUnicode(const_cast<PTSTR>((LPCTSTR)csValue), &pwszValue))
        {
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
        }

        pADsValue = new ADSVALUE;
        CHECK_NULL_REPORT(pADsValue, GetHWnd(), goto Cleanup);

        pAttrs[cAttrs].pADsValues = pADsValue;
        pAttrs[cAttrs].dwNumValues = 1;
        pADsValue->dwType = m_rgpAttrMap[i]->AttrInfo.dwADsType;

        switch (pADsValue->dwType)
        {
        case ADSTYPE_DN_STRING:
            pADsValue->DNString = pwszValue;
            break;
        case ADSTYPE_CASE_EXACT_STRING:
            pADsValue->CaseExactString = pwszValue;
            break;
        case ADSTYPE_CASE_IGNORE_STRING:
            pADsValue->CaseIgnoreString = pwszValue;
            break;
        case ADSTYPE_PRINTABLE_STRING:
            pADsValue->PrintableString = pwszValue;
            break;
        case ADSTYPE_NUMERIC_STRING:
            pADsValue->NumericString = pwszValue;
            break;
        case ADSTYPE_INTEGER:
            pADsValue->Integer = _wtoi(pwszValue);
            break;
        default:
            dspDebugOut((DEB_ERROR, "OnApply: Unknown ADS Type %x\n",
                         pADsValue->dwType));
        }
        cAttrs++;
    }

    // cAttrs could be zero if a page was read-only. Don't call ADSI if so.
    //
    if (cAttrs < 1)
    {
        goto Cleanup;
    }

    dspDebugOut((DEB_USER1, "TablePage, about to write %d attrs.\n", cAttrs));
    //
    // Write the changes.
    //
    DWORD cModified;

    hr = m_pDsObj->SetObjectAttributes(pAttrs, cAttrs, &cModified);

    CHECK_ADS_HR(&hr, m_hPage);

Cleanup:

    for (i = 0; i < cAttrs; i++)
        HelperDeleteADsValues( &(pAttrs[i]) );

    delete [] pAttrs;

    if (SUCCEEDED(hr) && cAttrs > 0)
    {
        for (i = 0; i < m_cAttrs; i++)
        {
            ATTR_DATA_CLEAR_DIRTY(m_rgAttrData[i]);
        }
    }

    return SUCCEEDED(hr) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

void HelperDeleteADsValues( ADS_ATTR_INFO* pAttrs )
{
    if (pAttrs)
    {
       if (pAttrs->pADsValues)
       {
         for (DWORD j = 0; j < pAttrs->dwNumValues; j++)
         {
               LPWSTR pwszValue = NULL;
               switch (pAttrs->dwADsType)
               {
               case ADSTYPE_DN_STRING:
                  pwszValue = pAttrs->pADsValues[j].DNString;
                  break;
               case ADSTYPE_CASE_EXACT_STRING:
                  pwszValue = pAttrs->pADsValues[j].CaseExactString;
                  break;
               case ADSTYPE_CASE_IGNORE_STRING:
                  pwszValue = pAttrs->pADsValues[j].CaseIgnoreString;
                  break;
               case ADSTYPE_PRINTABLE_STRING:
                  pwszValue = pAttrs->pADsValues[j].PrintableString;
                  break;
               case ADSTYPE_NUMERIC_STRING:
                  pwszValue = pAttrs->pADsValues[j].NumericString;
                  break;
               }
               if (pwszValue)
                  delete [] pwszValue;
         }
         delete [] pAttrs->pADsValues;
      }
      pAttrs->pADsValues = NULL;
      pAttrs->dwNumValues = 0;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      Standard multi-valued attribute handling assumes that the
//              "modify" button has an ID that is one greater than the
//              corresponding combo box.
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }

    HRESULT hr;
    DWORD i;

    for (i = 0; i < m_cAttrs; i++)
    {
        if (id == m_rgpAttrMap[i]->nCtrlID)
        {
            // Give attr functions first crack at the command notification.
            //
            if (m_rgpAttrMap[i]->pAttrFcn)
            {
                hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i], NULL,
                                                  codeNotify, &m_rgAttrData[i],
                                                  fOnCommand);

                if (hr == S_FALSE)
                {
                    // If the attr function returns S_FALSE, then don't return
                    // to the base class OnCommand.
                    //
                    return 0;
                }
                else
                {
                    continue;
                }
            }
            if (codeNotify == BN_CLICKED &&
                m_rgpAttrMap[i]->AttrInfo.dwADsType == ADSTYPE_BOOLEAN)
            {
                // NOTE: Must do this to allow saving from the WAB-hosted sheet.
                EnableWindow(GetDlgItem(GetParent(m_hPage), IDOK), TRUE);
                // NOTE: end hack.

                // The check box was clicked.
                //
                SetDirty(i);

                return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
            }
            if (codeNotify == EN_CHANGE)
            {
                // NOTE: Must do this to allow saving from the WAB-hosted sheet.
                EnableWindow(GetDlgItem(GetParent(m_hPage), IDOK), TRUE);
                // Note: End Hack.

                SetDirty(i);
            }
        }
    }

    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnObjChanged
//
//  Synopsis:   Object Change notification for inter-sheet syncronization.
//              Handles the private WM_ADSPROP_NOTIFY_CHANGE message.
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnObjChanged(void)
{
    TRACE(CDsTableDrivenPage,OnObjChanged);
    return ReadAttrsSetCtrls(fObjChanged);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::ReadAttrsSetCtrls
//
//  Synopsis:   Refreshes the UI.
//
//-----------------------------------------------------------------------------
HRESULT
CDsTableDrivenPage::ReadAttrsSetCtrls(DLG_OP DlgOp)
{
    HRESULT hr = S_OK;
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0, i, j;
    CWaitCursor wait;

    PWSTR * rgpwszAttrNames = new LPWSTR[m_cAttrs];
    CHECK_NULL_REPORT(rgpwszAttrNames, GetHWnd(), return E_OUTOFMEMORY);

    if (fInit == DlgOp)
    {
        // Check what attributes are writable.
        //
        CheckIfPageAttrsWritable();
    }

    // Build the list of attribute names.
    //
    for (i = 0; i < m_cAttrs; i++)
    {
        // If the attr name in the table is null, then don't try to do a
        // fetch on that attr. Attr table entries of that sort are used for
        // special purposes such as push buttons or check boxes. If the
        // attr name is set to null, then the attr must be declared as read-
        // only.
        //
        if (m_rgpAttrMap[i]->AttrInfo.pszAttrName)
        {
            // If the attribute already appears in the attribute list
            // then don't add it again
            bool fAlreadyPresent = false;
            for (j = 0; j < cAttrs; j++)
            {
                if ( _wcsicmp(m_rgpAttrMap[i]->AttrInfo.pszAttrName,
                              rgpwszAttrNames[j] ) == 0 )
                {
                    fAlreadyPresent = true;
                    break;
                }
            }
            if (!fAlreadyPresent)
            {
                rgpwszAttrNames[cAttrs] = m_rgpAttrMap[i]->AttrInfo.pszAttrName;
                cAttrs++;
            }
        }
    }

    // Get the attribute values.
    //
    hr = m_pDsObj->GetObjectAttributes(rgpwszAttrNames, cAttrs, &pAttrs,
                                       &cAttrs);
    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, m_hPage))
    {
        goto ExitCleanup;
    }

    // The returned values are a subset of the requested values. Loop over
    // both sets, checking for matches.
    //
    // JonN 5/5/98 Removed assumption that returned values are in same order,
    // added support for multiple table entries for same attribute (all but
    // one must be read-only)
    //
    for (i = 0; i < m_cAttrs; i++)
    {
        if (!ATTR_DATA_IS_WRITABLE(m_rgAttrData[i]) &&
            !m_rgpAttrMap[i]->fIsReadOnly &&
            !m_rgpAttrMap[i]->pAttrFcn)
        {
            // If user does not have write permission for the attribute and
            // the control is not already read-only and there is no attr
            // function then disable the control.
            //
            if (ADSTYPE_CASE_IGNORE_STRING == m_rgpAttrMap[i]->AttrInfo.dwADsType &&
                !m_rgpAttrMap[i]->fIsMultiValued)
            {
               // If it is a single-valued text attribute, make its edit box
               // read only.
               //
               SendDlgItemMessage(m_hPage, m_rgpAttrMap[i]->nCtrlID, EM_SETREADONLY, (WPARAM)TRUE, 0);
            }
            else
            {
               EnableWindow(GetDlgItem(m_hPage, m_rgpAttrMap[i]->nCtrlID), FALSE);
            }
        }
        BOOL fFound = FALSE;
        for (j = 0; j < cAttrs; j++)
        {
            if (m_rgpAttrMap[i]->AttrInfo.pszAttrName &&
                _wcsicmp(m_rgpAttrMap[i]->AttrInfo.pszAttrName,
                         pAttrs[j].pszAttrName) == 0)
            {
                dspAssert(!fFound);
                fFound = TRUE;

                if (m_rgpAttrMap[i]->AttrInfo.dwADsType != pAttrs[j].dwADsType)
                {
                    dspDebugOut((DEB_ITRACE,
                                 "ADsType: from table = %d, returned = %d.\n",
                                 m_rgpAttrMap[i]->AttrInfo.dwADsType,
                                 pAttrs[j].dwADsType));
                    m_rgpAttrMap[i]->AttrInfo.dwADsType = pAttrs[j].dwADsType;
                }

                if (m_rgpAttrMap[i]->pAttrFcn)
                {
                    // Handle special-case attribute
                    //
                    hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i],
                                                      &pAttrs[j], 0,
                                                      &m_rgAttrData[i], DlgOp);
                    if (hr != S_FALSE)
                    {
                        // If the attr function returns S_FALSE, that means
                        // let the standard text control processing below
                        // display the value.
                        //
                        break;
                    }
                }

                dspAssert(pAttrs[j].dwNumValues > 0);

                if (m_rgpAttrMap[i]->AttrInfo.dwADsType == ADSTYPE_BOOLEAN)
                {
                    // Handle boolean attribute, initialize the checkbox.
                    //
                    if (pAttrs[j].pADsValues->Boolean)
                    {
                        CheckDlgButton(m_hPage, m_rgpAttrMap[i]->nCtrlID,
                                       BST_CHECKED);
                    }
                    break;
                }

                // Assumes that all non-special-case attributes, if
                // single-valued and not boolean, go into a text control.
                //
                SendDlgItemMessage(m_hPage, m_rgpAttrMap[i]->nCtrlID,
                                   EM_LIMITTEXT, m_rgpAttrMap[i]->nSizeLimit,
                                   0);
                LPTSTR ptszValue = NULL;
                LPWSTR pwszValue;
                WCHAR wszNum[64];
                switch (pAttrs[j].dwADsType)
                {
                case ADSTYPE_DN_STRING:
                    pwszValue = pAttrs[j].pADsValues->DNString;
                    break;
                case ADSTYPE_CASE_EXACT_STRING:
                    pwszValue = pAttrs[j].pADsValues->CaseExactString;
                    break;
                case ADSTYPE_CASE_IGNORE_STRING:
                    pwszValue = pAttrs[j].pADsValues->CaseIgnoreString;
                    break;
                case ADSTYPE_PRINTABLE_STRING:
                    pwszValue = pAttrs[j].pADsValues->PrintableString;
                    break;
                case ADSTYPE_NUMERIC_STRING:
                    pwszValue = pAttrs[j].pADsValues->NumericString;
                    break;
                case ADSTYPE_INTEGER:
                    wsprintfW(wszNum, L"%d", pAttrs[j].pADsValues->Integer);
                    pwszValue = wszNum;
                    break;
                case ADSTYPE_LARGE_INTEGER:
                    __int64 i64;
                    memcpy(&i64, &pAttrs[j].pADsValues->LargeInteger,
                           sizeof(pAttrs[j].pADsValues->LargeInteger));
                    swprintf(wszNum, L"%I64d", i64);
                    pwszValue = wszNum;
                    break;
                default:
                    dspDebugOut((DEB_ERROR, "Unknown ADS Type %x\n",
                                 pAttrs[j].dwADsType));
                    pwszValue = L"";
                }

                if (!UnicodeToTchar(pwszValue, &ptszValue))
                {
                    goto ExitCleanup;
                }

                SetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, ptszValue);

                delete [] ptszValue;

                break;
            }
        }
        if (!fFound)
        {
            if (m_rgpAttrMap[i]->pAttrFcn)
            {
                (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i], NULL,
                                             0, &m_rgAttrData[i], DlgOp);
                continue;
            }
            if (!m_rgpAttrMap[i]->fIsMultiValued)
            {
                SendDlgItemMessage(m_hPage, m_rgpAttrMap[i]->nCtrlID,
                                   EM_LIMITTEXT, m_rgpAttrMap[i]->nSizeLimit,
                                   0);
                switch (m_rgpAttrMap[i]->AttrInfo.dwADsType)
                {
                case ADSTYPE_DN_STRING:
                case ADSTYPE_CASE_EXACT_STRING:
                case ADSTYPE_CASE_IGNORE_STRING:
                case ADSTYPE_PRINTABLE_STRING:
                case ADSTYPE_NUMERIC_STRING:
                    SetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, TEXT(""));
                    break;
                }
            }
        }
    }

ExitCleanup:

    if (pAttrs)
    {
        FreeADsMem(pAttrs);
    }

    delete [] rgpwszAttrNames;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnAttrChanged
//
//  Synopsis:   Attribute Change notification for inter-page syncronization.
//              Handles the private DSPROP_ATTRCHANGED_MSG message.
//
//  Arguments:  wParam - contains a pointer to an ADS_ATTR_INFO that contains
//                       the changed attribute value. The attribute is named
//                       in this struct, so it is self-describing.
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnAttrChanged(WPARAM wParam)
{
    if (m_fInInit)
    {
        return 0;
    }

    for (DWORD i = 0; i < m_cAttrs; i++)
    {
        // Call attr functions.
        //
        if (m_rgpAttrMap[i]->pAttrFcn)
        {
            (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i],
                                         (PADS_ATTR_INFO)wParam, 0,
                                         &m_rgAttrData[i], fAttrChange);
        }
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnQuerySibs
//
//  Synopsis:   Inter-page communication. Handles the PSM_QUERYSIBLINGS msg.
//
//  Arguments:  wParam - pointer to the name of the attribute in question.
//              lParam - HWND of the page that wants to know if the attr has
//                       changed.
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnQuerySibs(WPARAM wParam, LPARAM lParam)
{
    if (m_fInInit)
    {
        return 0;
    }

    LRESULT ret = 0;
    HRESULT hr;

    for (DWORD i = 0; i < m_cAttrs; i++)
    {
        // Call attr functions.
        //
        if (m_rgpAttrMap[i]->pAttrFcn)
        {
            hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i],
                                              (PADS_ATTR_INFO)wParam, lParam,
                                              &m_rgAttrData[i], fQuerySibling);
            if (hr != S_OK)
            {
                ret = hr;
            }
        }
    }
    return ret;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnNotify
//
//  Synopsis:   Handles notification messages
//
//  Arguments:  [lParam] - a pointer to a NMHDR structure.
//              [wParam] - the control ID.
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    DWORD i;
    HRESULT hr = S_OK;

    switch (((LPNMHDR)lParam)->code)
    {
    case PSN_SETACTIVE:
    case PSN_KILLACTIVE:
        if (m_fInInit)
        {
            return 0;
        }

        for (i = 0; i < m_cAttrs; i++)
        {
            // Call attr functions.
            //
            if (m_rgpAttrMap[i]->pAttrFcn)
            {
                hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i], NULL,
                                                  lParam,
                                                  &m_rgAttrData[i],
                                                  (PSN_SETACTIVE == ((LPNMHDR)lParam)->code) ?
                                                  fOnSetActive : fOnKillActive);

                if (PSNRET_INVALID_NOCHANGEPAGE == HRESULT_CODE(hr))
                {
                    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT,
                                     (LONG_PTR)PSNRET_INVALID_NOCHANGEPAGE);
                    return PSNRET_INVALID_NOCHANGEPAGE;
                }
            }
        }
        break;

    default:
        if (!m_fInInit)
        {
            for (i = 0; i < m_cAttrs; i++)
            {
                // Call attr functions.
                //
                if (m_rgpAttrMap[i]->pAttrFcn)
                {
                    (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i], NULL,
                                                 lParam,
                                                 &m_rgAttrData[i], fOnNotify);
                }
            }
        }
        break;
    }

    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsTableDrivenPage::OnDestroy(void)
{
    if (FAILED(m_hrInit))
    {
        return 0;
    }
    //
    // Allow attr functions to do control cleanup.
    //
    for (DWORD i = 0; i < m_cAttrs; i++)
    {
        if (m_rgpAttrMap[i]->pAttrFcn)
        {
            (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i], NULL,
                                         0, &m_rgAttrData[i], fOnDestroy);
        }
    }
    // If an application processes this message, it should return zero.
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTableDrivenPage::SetNamedAttrDirty
//
//  Synopsis:   Set a specific attribute dirty
//
//-----------------------------------------------------------------------------
BOOL CDsTableDrivenPage::SetNamedAttrDirty( LPCWSTR pszAttrName )
{
    for (DWORD i = 0; i < m_cAttrs; i++)
    {
        if (   NULL != m_rgpAttrMap[i]->AttrInfo.pszAttrName
            && !_wcsicmp(pszAttrName, m_rgpAttrMap[i]->AttrInfo.pszAttrName)
            && !m_rgpAttrMap[i]->fIsReadOnly
           )
        {
            SetDirty(i);
            return TRUE;
        }
    }
    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:   GeneralPageIcon
//
//  Synopsis:   Fetches the icon for the object class from the display spec
//              cache and draws it on the page. The GenIcon ATTR_MAP uses the
//              control ID IDC_DS_ICON. To use this, add an icon control to
//              your page sized appropriately (20 x 20) and labeled
//              IDC_DS_ICON, then add GenIcon to your ATTR_MAP array.
//
//-----------------------------------------------------------------------------
HRESULT GeneralPageIcon(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                        PADS_ATTR_INFO, LPARAM, PATTR_DATA pAttrData,
                        DLG_OP DlgOp)
{
    HRESULT hr;
    HICON hIcon;
    HWND hIconCtrl;
    CDsIconCtrl * pIconCtrl;

    switch (DlgOp)
    {
    case fInit:
        IDsDisplaySpecifier * pDispSpec;

        hr = pPage->GetIDispSpec(&pDispSpec);

        CHECK_HRESULT(hr, return hr);

        hIconCtrl = GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID);

        hIcon = pDispSpec->GetIcon(pPage->GetObjClass(),
                                   DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON,
                                   32, 32);

        // NULL return puts up a default icon
        CHECK_NULL(hIcon, return S_OK);

        pIconCtrl = new CDsIconCtrl(hIconCtrl, hIcon);

        CHECK_NULL_REPORT(pIconCtrl, pPage->GetHWnd(), return E_OUTOFMEMORY);

        pAttrData->pVoid = reinterpret_cast<LPARAM>(pIconCtrl);

        break;

    case fOnDestroy:
        if (pAttrData->pVoid)
        {
            pIconCtrl = (CDsIconCtrl *)pAttrData->pVoid;
            DO_DEL(pIconCtrl);
        }
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Class:      CDsIconCtrl
//
//  Synopsis:   Icon control window subclass object, so we can paint a class-
//              specific icon.
//
//-----------------------------------------------------------------------------
CDsIconCtrl::CDsIconCtrl(HWND hCtrl, HICON hIcon) :
    m_hCtrl(hCtrl),
    m_hIcon(hIcon),
    m_pOldProc(NULL)
{
    SetWindowLongPtr(hCtrl, GWLP_USERDATA, (LONG_PTR)this);
    m_pOldProc = (WNDPROC)SetWindowLongPtr(hCtrl, GWLP_WNDPROC, (LONG_PTR)StaticCtrlProc);
    m_hDlg = GetParent(hCtrl);
}

CDsIconCtrl::~CDsIconCtrl(void)
{
    SetWindowLongPtr(m_hCtrl, GWLP_WNDPROC, (LONG_PTR)m_pOldProc);
    DestroyIcon(m_hIcon);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsIconCtrl::StaticCtrlProc
//
//  Synopsis:   control sub-proc
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CDsIconCtrl::StaticCtrlProc(HWND hCtrl, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDsIconCtrl * pCCtrl = (CDsIconCtrl*)GetWindowLongPtr(hCtrl, GWLP_USERDATA);

    if (pCCtrl != NULL)
    {
        if (uMsg == WM_PAINT)
        {
            if (!pCCtrl->OnPaint())
            {
                return FALSE;
            }
        }
        return CallWindowProc(pCCtrl->m_pOldProc, hCtrl, uMsg, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hCtrl, uMsg, wParam, lParam);
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsIconCtrl::OnPaint
//
//  Synopsis:   Paint the DS specified icon.
//
//-----------------------------------------------------------------------------
LRESULT
CDsIconCtrl::OnPaint(void)
{
    HDC hDC;
    PAINTSTRUCT ps;

    hDC = BeginPaint(m_hCtrl, &ps);

    CHECK_NULL_REPORT(hDC, m_hDlg, return FALSE);

    if (!DrawIcon(hDC, 0, 0, m_hIcon))
    {
        REPORT_ERROR(GetLastError(), m_hDlg);
        return FALSE;
    }

    EndPaint(m_hCtrl, &ps);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\behaviorversion.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       BehaviorVersion.h
//
//  Contents:   AD behavior version viewing/modification dialogs and fcns.
//
//  Classes:    
//
//  History:    6-April-01 EricB created
//
//-----------------------------------------------------------------------------

#ifndef BEHAVIOR_VERSION_H_GUARD
#define BEHAVIOR_VERSION_H_GUARD

#include <list>
#include "dlgbase.h"

// Definitions of levels.
//
#define DC_VER_WIN2K              (DS_BEHAVIOR_WIN2000)
#define DC_VER_XP_BETA            (DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
#define DC_VER_XP                 (DS_BEHAVIOR_WIN2003)

#define DOMAIN_VER_WIN2K_MIXED    (DS_BEHAVIOR_WIN2000)
#define DOMAIN_VER_WIN2K_NATIVE   (DS_BEHAVIOR_WIN2000)
#define DOMAIN_VER_XP_BETA_MIXED  (DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
#define DOMAIN_VER_XP_BETA_NATIVE (DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
#define DOMAIN_VER_XP_NATIVE      (DS_BEHAVIOR_WIN2003)
#define DOMAIN_VER_UNKNOWN        (0xffffffff)

#define FOREST_VER_WIN2K          (DS_BEHAVIOR_WIN2000)
#define FOREST_VER_XP_BETA        (DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
#define FOREST_VER_XP             (DS_BEHAVIOR_WIN2003)
#define FOREST_VER_ERROR          (0xffffffff)

//+----------------------------------------------------------------------------
//
//  Class:     CDcListItem
//
//-----------------------------------------------------------------------------
class CDcListItem
{
public:
   CDcListItem(PCWSTR pwzDomainName, PCWSTR pwzDcName,
               PCWSTR pwzCompObjDN, UINT nCurVer) :
      _strDomainName(pwzDomainName),
      _strDcName(pwzDcName),
      _strComputerObjDN(pwzCompObjDN),
      _nCurVer(nCurVer) {};
   ~CDcListItem() {};

   PCWSTR GetDomainName(void) const {return _strDomainName;};
   PCWSTR GetDcName(void) const {return _strDcName;};
   PCWSTR GetCompObjDN(void) const {return _strComputerObjDN;};
   UINT   GetVersion(void) const {return _nCurVer;};

private:
   CStrW    _strDomainName;
   CStrW    _strDcName;
   CStrW    _strComputerObjDN;
   UINT     _nCurVer;
};

//+----------------------------------------------------------------------------
//
//  Class:     CVersionBase
//
//-----------------------------------------------------------------------------
class CVersionBase
{
public:
   CVersionBase(void) :
      _fReadOnly(true),
      _fCanRaiseBehaviorVersion(true),
      _nMinDcVerFound(0),
      _hDlg(NULL) {};
   virtual ~CVersionBase(void);

   void    InitHelp(void);
   bool    IsReadOnly(void) const {return _fReadOnly;};
   HRESULT BuildDcListString(CStrW & strList);
   PCWSTR  GetDC(void) const {return _strDC;};
   void    SetDlgHwnd(HWND hDlg) {_hDlg = hDlg;};
   HWND    GetDlgHwnd(void) const {return _hDlg;};
   HRESULT ReadDnsSrvName(PCWSTR pwzNTDSDSA, CComPtr<IADs> & spServer,
                          CComVariant & varSrvDnsName);
   HRESULT EnumDsaObjs(PCWSTR pwzSitesPath, PCWSTR pwzFilterClause,
                       PCWSTR pwzDomainDnsName, UINT nMinVer);

   typedef std::list<CDcListItem *> DC_LIST;

protected:
   bool                    _fReadOnly;
   bool                    _fCanRaiseBehaviorVersion;
   CStrW                   _strDC;
   DC_LIST                 _DcLogList;
   UINT                    _nMinDcVerFound;

private:
   HWND     _hDlg;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDomainVersion
//
//  Purpose:    Manages the interpretation of the domain version value.
//
//-----------------------------------------------------------------------------
class CDomainVersion : public CVersionBase
{
public:
   CDomainVersion() :
      _nCurVer(0),
      _fMixed(true),
      _fInitialized(false),
      _fPDCfound(false),
      _eHighest(WhistlerNative) {};
   CDomainVersion(PCWSTR pwzDomPath, PCWSTR pwzDomainDnsName) :
      _strFullDomainPath(pwzDomPath),
      _strDomainDnsName(pwzDomainDnsName),
      _nCurVer(0),
      _fMixed(true),
      _fInitialized(false),
      _fPDCfound(false),
      _eHighest(WhistlerNative) {};
   ~CDomainVersion(void) {};

   enum eDomVer {
      Win2kMixed = 0,
      Win2kNative,
      WhistlerBetaMixed,
      WhistlerBetaNative,
      WhistlerNative,
      VerHighest = WhistlerNative,
      unknown,
      error
   };

   HRESULT  Init(void);
   HRESULT  Init(PCWSTR pwzDcName, HWND hWnd);
   UINT     GetCurVer(void) const {return _nCurVer;};
   eDomVer  MapVersion(UINT nVer, bool fMixed) const;
   eDomVer  GetVer(void) const {return MapVersion(_nCurVer, _fMixed);};
   eDomVer  Highest(void) const {return VerHighest;};
   eDomVer  HighestCanGoTo(void) const {return _eHighest;};
   bool     IsHighest(void) const {return GetVer() == Highest();};
   bool     GetString(eDomVer ver, CStrW & strVersion) const;
   bool     GetString(UINT nVer, bool fMixed, CStrW & strVersion) const;
   bool     IsPDCfound(void) {return _fPDCfound;};
   bool     CanRaise(void) const {return _fCanRaiseBehaviorVersion || _fMixed;};
   HRESULT  GetMode(bool & fMixed);
   HRESULT  CheckHighestPossible(void);
   HRESULT  SetNativeMode(void);
   HRESULT  RaiseVersion(eDomVer NewVer);

private:
   CStrW    _strDomainDnsName;
   CStrW    _strFullDomainPath;
   CStrW    _strDomainDN;
   UINT     _nCurVer;
   bool     _fMixed;
   bool     _fInitialized;
   bool     _fPDCfound;
   eDomVer  _eHighest;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDomainVersionDlg
//
//  Purpose:    Posts a dialog to display and manipulate the domain version.
//
//-----------------------------------------------------------------------------
class CDomainVersionDlg : public CModalDialog
{
public:
   CDomainVersionDlg(HWND hParent, PCWSTR pwzDomDNS, CDomainVersion & DomVer,
                     int nTemplateID);
   ~CDomainVersionDlg(void) {};

private:
   LRESULT OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnOK(void);
   //LRESULT OnHelp(LPHELPINFO pHelpInfo);
   void    OnSaveLog(void);

   void    InitCombobox(void);
   CDomainVersion::eDomVer ReadComboSel(void);

   CStrW             _strDomainDnsName;
   CDomainVersion &  _DomainVer;
};

//+----------------------------------------------------------------------------
//
//  Class:     CDomainListItem
//
//-----------------------------------------------------------------------------
class CDomainListItem
{
public:
   CDomainListItem(PCWSTR pwzDnsDomainName, UINT nVer, bool fMixed) :
      _strDnsDomainName(pwzDnsDomainName), _nCurVer(nVer), _fMixed(fMixed) {};
   ~CDomainListItem() {};

   PCWSTR   GetDnsDomainName(void) const {return _strDnsDomainName;};
   UINT     GetVer(void) const {return _nCurVer;};
   bool     GetMode(void) const {return _fMixed;}

private:
   UINT  _nCurVer;
   bool  _fMixed;
   CStrW _strDnsDomainName;
};

//+----------------------------------------------------------------------------
//
//  Class:      CForestVersion
//
//  Purpose:    Manages the interpretation of the forest version value.
//
//-----------------------------------------------------------------------------
class CForestVersion : public CVersionBase
{
public:
   CForestVersion() :
      _fInitialized(false),
      _fFsmoDcFound(true),
      _nCurVer(0) {};
   ~CForestVersion();

   HRESULT  Init(PCWSTR pwzDC);
   HRESULT  Init(PCWSTR pwzConfigPath, PCWSTR pwzPartitionsPath,
                 PCWSTR pwzSchemaPath);
   HRESULT  FindSchemaMasterReadVersion(PCWSTR pwzSchemaPath);
   UINT     GetVer(void) const {dspAssert(_fInitialized); return _nCurVer;};
   bool     GetString(UINT nVer, CStrW & strVer);
   bool     CanRaise(void) const {return _fCanRaiseBehaviorVersion;};
   bool     IsHighest(void) const {return FOREST_VER_XP == _nCurVer;};
   bool     IsFsmoDcFound(void) const {return _fFsmoDcFound;};
   PCWSTR   GetFsmoDcName(void) const {return _strFsmoDC;};
   HRESULT  CheckHighestPossible(void);
   HRESULT  CheckDomainVersions(PCWSTR pwzPartitionsPath);
   HRESULT  BuildMixedModeList(CStrW & strMsg);
   HRESULT  RaiseVersion(UINT nVer);

   typedef std::list<CDomainListItem *> DOMAIN_LIST;

private:
   bool        _fInitialized;
   bool        _fFsmoDcFound;
   UINT        _nCurVer;
   CStrW       _strConfigPath;
   CStrW       _strPartitionsPath;
   CStrW       _strFsmoDC;
   DOMAIN_LIST _DomainLogList;
};

//+----------------------------------------------------------------------------
//
//  Class:      CForestVersionDlg
//
//  Purpose:    
//
//-----------------------------------------------------------------------------
class CForestVersionDlg : public CModalDialog
{
public:
   CForestVersionDlg(HWND hParent, PCWSTR pwzRootDnsName,
                     CForestVersion & ForestVer, int nTemplateID);
   ~CForestVersionDlg(void) {};

private:
   LRESULT OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnOK(void);
   //LRESULT OnHelp(LPHELPINFO pHelpInfo);
   void    OnSaveLog(void);

   void    InitCombobox(void);
   UINT    ReadComboSel(void);

   CStrW            _strRootDnsName;
   CForestVersion & _ForestVer;
   UINT             _nTemplateID;
};

#endif // BEHAVIOR_VERSION_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\attrfcns.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       attrfcns.cxx
//
//  Contents:   Various attribute functions for table-driven pages.
//
//  History:    2-April-98 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#if defined(DSADMIN)
#   include "trust.h"
#endif

//+----------------------------------------------------------------------------
//
//  Function:   ADsIntegerToCheckbox
//
//  Synopsis:   Handles an integer attribute and display its boolean value
//              in a checkbox control.
//
//  Remarks:    There are cases where an attribute is stored as an
//              integer while the UI wants to display the integer as
//              a boolean flag.
//
//-----------------------------------------------------------------------------
/* unused
HRESULT
ADsIntegerToCheckbox(
    CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
    PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
    DLG_OP DlgOp)
{
    dspAssert(pPage != NULL);
    dspAssert(pAttrMap != NULL);

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        //
        // If pAttrInfo is NULL, this means the attribute is not set. Treat
        // that the same as FALSE (i.e. don't check the box).
        //
        if (pAttrInfo)
        {
            dspAssert(pAttrInfo->pADsValues != NULL);
            dspAssert(pAttrInfo->dwADsType == ADSTYPE_INTEGER);
            dspAssert(pAttrInfo->dwNumValues == 1);
            dspAssert(pAttrInfo->pADsValues->dwType == ADSTYPE_INTEGER);
            dspAssert(IsWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID)));
            // Initialize the checkbox with the boolean value
            if (pAttrInfo->pADsValues->Integer != 0)
            {
                CheckDlgButton(pPage->GetHWnd(), pAttrMap->nCtrlID, BST_CHECKED);
                #ifdef _DEBUG
                if (pAttrInfo->pADsValues->Integer != TRUE)
                {
                    dspDebugOut((DEB_ERROR, "WRN: ADsIntegerToCheckbox() - Integer is NOT boolean."));
                }
                #endif
            }
        }
        if (!PATTR_DATA_IS_WRITABLE(pAttrData))
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }
        return S_OK;

    case fOnCommand:
        if (BN_CLICKED == lParam)
        {
            pPage->SetDirty();  // Page has been modified
            PATTR_DATA_SET_DIRTY(pAttrData); // Attribute has been modified.
        }
        return S_FALSE;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        dspAssert(pAttrInfo != NULL);
        dspAssert(pAttrInfo->dwADsType == ADSTYPE_INTEGER);
        dspAssert(pAttrInfo->pADsValues == NULL && "Memory Leak");
        dspAssert(pAttrInfo->dwNumValues == 0);
        dspAssert(IsWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID)));
        pAttrInfo->pADsValues = new ADSVALUE;
        if (pAttrInfo->pADsValues == NULL)
			return E_OUTOFMEMORY;
        pAttrInfo->dwNumValues = 1;
        pAttrInfo->pADsValues->dwType = ADSTYPE_INTEGER;
        pAttrInfo->pADsValues->Integer =
            (IsDlgButtonChecked(pPage->GetHWnd(), pAttrMap->nCtrlID)
                == BST_CHECKED);
        return S_OK;
    } // switch

    return S_FALSE;
}
*/

//+----------------------------------------------------------------------------
//
//  Function:   IntegerAsBoolDefOn
//
//  Synopsis:   Handles an integer attribute that is functioning as a BOOL to
//              set a check box.
//
//  Notes:      If the attribute is unset, the default is set to TRUE (the
//              checkbox is checked).
//
//-----------------------------------------------------------------------------
HRESULT
IntegerAsBoolDefOn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                   PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                   DLG_OP DlgOp)
{
    HRESULT hr = S_OK;
    BOOL fSet = TRUE;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        if (pAttrInfo && pAttrInfo->dwNumValues)
        {
            fSet = pAttrInfo->pADsValues->Integer;
        }
        CheckDlgButton(pPage->GetHWnd(), pAttrMap->nCtrlID,
                       (fSet) ? BST_CHECKED : BST_UNCHECKED);

        if (!PATTR_DATA_IS_WRITABLE(pAttrData))
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        PADSVALUE pADsValue;
        pADsValue = new ADSVALUE;
        CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

        pAttrInfo->pADsValues = pADsValue;
        pAttrInfo->dwNumValues = 1;
        pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        pADsValue->dwType = pAttrInfo->dwADsType;
        pADsValue->Integer = IsDlgButtonChecked(pPage->GetHWnd(), pAttrMap->nCtrlID) == BST_CHECKED;
        break;

    case fOnCommand:
        if (BN_CLICKED == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData); // Attribute has been modified.
        }
        break;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetAcctName
//
//  Synopsis:   Get the account name using the SID.
//
//-----------------------------------------------------------------------------
HRESULT
GetAcctName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO, LPARAM, PATTR_DATA,
            DLG_OP DlgOp)
{
    HRESULT hr = S_OK;

    if (DlgOp != fInit)
    {
        return S_OK;
    }

#ifdef YANK // If the object is in another domain, we would need to supply a
            // valid DC name to LookupAccountSid. CrackNames already does that,
            // so use it instead.

    PSID pSid = NULL;
    TCHAR tzName[MAX_PATH], tzDomain[MAX_PATH], tzFullName[MAX_PATH+MAX_PATH];
    TCHAR tzErr[] = TEXT("Name not found");
    PTSTR ptzName;
    DWORD cchName = MAX_PATH-1, cchDomain = MAX_PATH-1;

    dspAssert(pAttrData);
    if (pAttrInfo && pAttrInfo->dwNumValues)
    {
        pSid = pAttrInfo->pADsValues->OctetString.lpValue;
        SID_NAME_USE sne;

        if (!LookupAccountSid(NULL, pSid, tzName, &cchName, tzDomain, &cchDomain, &sne))
        {
            DWORD dwErr = GetLastError();
            dspDebugOut((DEB_ITRACE, "LookupAccountSid failed with error %d\n", dwErr));
            ptzName = tzErr;
        }
        else
        {
            _tcscpy(tzFullName, tzDomain);
            _tcscat(tzFullName, TEXT("\\"));
            _tcscat(tzFullName, tzName);

            ptzName = tzFullName;
        }
    }
    else
    {
        ptzName = tzErr;
    }
#endif // YANK

    PWSTR pwzPath, pwzDNSname;

    hr = pPage->SkipPrefix(pPage->GetObjPathName(), &pwzPath);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    hr = CrackName(pwzPath, &pwzDNSname, GET_OBJ_CAN_NAME, pPage->GetHWnd());

    delete pwzPath;

    CHECK_HRESULT(hr, return hr);

    if (DS_NAME_ERROR_NO_MAPPING == HRESULT_CODE(hr))
    {
        MsgBox(IDS_FPO_NO_NAME_MAPPING, pPage->GetHWnd());
    }
    PTSTR ptszPath;

    if (!UnicodeToTchar(pwzDNSname, &ptszPath))
    {
        LocalFreeStringW(&pwzDNSname);
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    LocalFreeStringW(&pwzDNSname);

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptszPath);

    delete ptszPath;

    return hr;
}

#ifdef REMOVE_SPN_SUFFIX_CODE

#define MAX_SPN_LEN 4096

//+----------------------------------------------------------------------------
//
//  Class:      CSPNSuffixEdit
//
//  Purpose:    Read, edit, and write the multi-valued SPN Suffix string property.
//
//-----------------------------------------------------------------------------
CSPNSuffixEdit::CSPNSuffixEdit(CDsPropPageBase * pPage, PATTR_DATA pAttrData) :
    m_pPage(pPage),
    m_pAttrData(pAttrData),
    m_fListHasSel(FALSE),
    m_cValues(0)
{
}

CSPNSuffixEdit::~CSPNSuffixEdit()
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNSuffixEdit::Init
//
//  Synopsis:   Do initialization where failures can occur and then be
//              returned. Can be only called once as written.
//
//  Arguments:  [pAttrMap]   - contains the attr type.
//              [pAttrInfo]  - place to store the values.
//-----------------------------------------------------------------------------
HRESULT
CSPNSuffixEdit::Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo)
{
    // Limit the entry length of the edit control.
    //
    SendDlgItemMessage(m_pPage->GetHWnd(), IDC_EDIT, EM_LIMITTEXT, MAX_SPN_LEN, 0);

    //
    // Disable the Add, Change, and Remove buttons.
    //
    EnableWindow(GetDlgItem(m_pPage->GetHWnd(), IDC_ADD_BTN), FALSE);
    EnableWindow(GetDlgItem(m_pPage->GetHWnd(), IDC_DELETE_BTN), FALSE);
    EnableWindow(GetDlgItem(m_pPage->GetHWnd(), IDC_EDIT_BTN), FALSE);

    //
    // Initialize the list view.
    //
    RECT rect;
    LV_COLUMN lvc;
    HWND hList = GetDlgItem(m_pPage->GetHWnd(), IDC_LIST);
    ListView_SetExtendedListViewStyle(hList, LVS_EX_FULLROWSELECT);

    GetClientRect(hList, &rect);
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rect.right;
    lvc.iSubItem = 0;

    ListView_InsertColumn(hList, 0, &lvc);

    if (NULL == pAttrInfo)
    {
        return S_OK;
    }

    // Load the list view.
    //
    LPTSTR ptz;
    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT;
    lvi.iSubItem = 0;

    for (LONG i = 0; (DWORD)i < pAttrInfo->dwNumValues; i++)
    {
        if (!UnicodeToTchar(pAttrInfo->pADsValues[i].CaseIgnoreString, &ptz))
        {
            ReportError(E_OUTOFMEMORY, 0, m_pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
        lvi.pszText = ptz;
        lvi.iItem = i;
        ListView_InsertItem(hList, &lvi);
        m_cValues++;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNSuffixEdit::Write
//
//  Synopsis:   Return the ADS_ATTR_INFO array of values to be Applied.
//
//-----------------------------------------------------------------------------
HRESULT
CSPNSuffixEdit::Write(PADS_ATTR_INFO pAttrInfo)
{
    pAttrInfo->dwNumValues = 0;

    HWND hList = GetDlgItem(m_pPage->GetHWnd(), IDC_LIST);
    int nItems = ListView_GetItemCount(hList);

    if (nItems == 0)
    {
        pAttrInfo->pADsValues = NULL;
        pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        return S_OK;
    }

    pAttrInfo->pADsValues = new ADSVALUE[nItems];

    CHECK_NULL_REPORT(pAttrInfo->pADsValues, m_pPage->GetHWnd(), return -1);

    LPTSTR ptz = new TCHAR[MAX_SPN_LEN + 1];

    CHECK_NULL_REPORT(ptz, m_pPage->GetHWnd(), return -1);

    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT;
    lvi.iSubItem = 0;
    lvi.pszText = ptz;
    lvi.cchTextMax = MAX_SPN_LEN + 1;

    for (LONG i = 0; i < nItems; i++)
    {
        lvi.iItem = i;
        if (!ListView_GetItem(hList, &lvi))
        {
            DWORD dwErr = GetLastError();
            REPORT_ERROR(dwErr, m_pPage->GetHWnd());
            return HRESULT_FROM_WIN32(dwErr);
        }
        if (!TcharToUnicode(ptz, &pAttrInfo->pADsValues[i].CaseIgnoreString))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
        pAttrInfo->pADsValues[i].dwType = pAttrInfo->dwADsType;
        pAttrInfo->dwNumValues++;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNSuffixEdit::EnableControls
//
//  Synopsis:   Enable or disable all of the controls.
//
//-----------------------------------------------------------------------------
void
CSPNSuffixEdit::EnableControls(HWND hDlg, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hDlg, IDC_EDIT), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDC_LIST), fEnable);
    if (!fEnable)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_ADD_BTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), FALSE);
        m_fListHasSel = FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNSuffixEdit::DoCommand
//
//  Synopsis:   WM_COMMAND code.
//
//-----------------------------------------------------------------------------
HRESULT
CSPNSuffixEdit::DoCommand(HWND hDlg, int id, int code)
{
    LPTSTR ptz;
    LONG i;
    HWND hList;
    LV_ITEM lvi;
    switch (code)
    {
    case BN_CLICKED:
        switch (id)
        {
        case IDC_ADD_BTN:
            int nLen;

            nLen = (int)SendDlgItemMessage(hDlg, IDC_EDIT, WM_GETTEXTLENGTH, 0, 0);
            ptz = new TCHAR[++nLen];

            CHECK_NULL_REPORT(ptz, hDlg, return E_OUTOFMEMORY);

            if (GetWindowText(GetDlgItem(hDlg, IDC_EDIT), ptz, nLen))
            {
                hList = GetDlgItem(hDlg, IDC_LIST);
                i = ListView_GetItemCount(hList);
                lvi.mask = LVIF_TEXT;
                lvi.iSubItem = 0;
                lvi.pszText = ptz;
                lvi.iItem = i;
                ListView_InsertItem(hList, &lvi);
                m_cValues++;

                SetWindowText(GetDlgItem(hDlg, IDC_EDIT), TEXT(""));
                m_pPage->SetDirty();
                PATTR_DATA_SET_DIRTY(m_pAttrData);
                SetFocus(GetDlgItem(hDlg, IDC_EDIT));
            }

            delete ptz;

            return S_OK;

        case IDC_DELETE_BTN:
        case IDC_EDIT_BTN:
            hList = GetDlgItem(hDlg, IDC_LIST);

            i = ListView_GetNextItem(hList, -1, LVNI_SELECTED);
            dspDebugOut((DEB_ITRACE, "List element %d selected\n", i));

            if (i >= 0)
            {
                if (id == IDC_DELETE_BTN)
                {
                    ListView_DeleteItem(hList, i);
                    EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), FALSE);
                    EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), FALSE);
                    SetFocus(GetDlgItem(hDlg, IDC_EDIT));
                    m_fListHasSel = FALSE;
                    m_cValues--;
                    m_pPage->SetDirty();
                    PATTR_DATA_SET_DIRTY(m_pAttrData);
                }
                else
                {
                    SetFocus(GetDlgItem(hDlg, IDC_LIST));
                    ListView_EditLabel(hList, i);
                }
            }

            return S_OK;
        }
        break;

    case EN_CHANGE:
        if (id == IDC_EDIT)
        {
            BOOL fHasChars = 0 != SendDlgItemMessage(hDlg, IDC_EDIT,
                                                     WM_GETTEXTLENGTH,
                                                     0, 0);

            EnableWindow(GetDlgItem(hDlg, IDC_ADD_BTN), fHasChars);

            // Return S_FALSE to skip default processing so that merely adding
            // text to the edit control won't set the dirty state. The page
            // isn't dirty until the Add button is clicked.
            //
            return S_FALSE;
        }
        break;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNSuffixEdit::DoNotify
//
//  Synopsis:   WM_NOTIFY code.
//
//-----------------------------------------------------------------------------
BOOL
CSPNSuffixEdit::DoNotify(HWND hDlg, NMHDR * pNmHdr)
{
    if (pNmHdr->idFrom != IDC_LIST)
    {
        return TRUE;
    }

    LV_DISPINFO * pldi = (LV_DISPINFO *)pNmHdr;

    switch (pNmHdr->code)
    {
    case LVN_ENDLABELEDIT:
        if (pldi->item.pszText)
        {
            dspDebugOut((DEB_ITRACE, "Editing item %d, new value %S\n",
                         pldi->item.iItem, pldi->item.pszText));
            ListView_SetItemText(pldi->hdr.hwndFrom, pldi->item.iItem, 0,
                                 pldi->item.pszText);
            m_pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(m_pAttrData);
        }
        break;

    case NM_SETFOCUS:
        dspDebugOut((DEB_ITRACE, "NM_SETFOCUS received\n"));
        if (pldi->hdr.idFrom == IDC_LIST)
        {
            //
            // If the list control gets the focus by tabbing and no item
            // is selected, then set the selection to the first item.
            //
            if (!m_fListHasSel)
            {
                dspDebugOut((DEB_ITRACE, "setting the list selection\n"));
                m_fListHasSel = TRUE;
                ListView_SetItemState(GetDlgItem(hDlg, IDC_LIST), 0, 
                                      LVIS_FOCUSED | LVIS_SELECTED,
                                      LVIS_FOCUSED | LVIS_SELECTED);
                EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), TRUE);
                EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), TRUE);
            }
        }
        return 1;

    case LVN_ITEMCHANGED:
        if (pldi->hdr.idFrom == IDC_LIST)
        {
            m_fListHasSel = TRUE;
            EnableWindow(GetDlgItem(hDlg, IDC_DELETE_BTN), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_EDIT_BTN), TRUE);
        }
        return 1;
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustSPNEdit
//
//  Synopsis:   Attr function for the SPN page Edit control.
//
//-----------------------------------------------------------------------------
HRESULT
TrustSPNEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp)
{
    HRESULT hr = S_OK;
    CSPNSuffixEdit * pCSPN = (CSPNSuffixEdit *)((CDsTableDrivenPage *)pPage)->m_pData;

    switch (DlgOp)
    {
    case fInit:
        pCSPN = new CSPNSuffixEdit(pPage, pAttrData);

        CHECK_NULL_REPORT(pCSPN, pPage->GetHWnd(), return E_OUTOFMEMORY);

        ((CDsTableDrivenPage *)pPage)->m_pData = pCSPN;

        hr = pCSPN->Init(pAttrMap, pAttrInfo);

        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        hr = pCSPN->Write(pAttrInfo);

        break;

    case fOnCommand:
        if (pCSPN)
        {
            return pCSPN->DoCommand(pPage->GetHWnd(), IDC_EDIT, (int)lParam);
        }
        break;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustSPNList
//
//  Synopsis:   Attr function for the SPN page List control.
//
//-----------------------------------------------------------------------------
HRESULT
TrustSPNList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp)
{
    CSPNSuffixEdit * pCSPN = (CSPNSuffixEdit *)((CDsTableDrivenPage *)pPage)->m_pData;

    if (DlgOp == fOnNotify && pCSPN)
    {
        pCSPN->DoNotify(pPage->GetHWnd(), reinterpret_cast<LPNMHDR>(lParam));
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustSPNAdd
//
//  Synopsis:   Attr function for the SPN page Add button.
//
//-----------------------------------------------------------------------------
HRESULT
TrustSPNAdd(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    CSPNSuffixEdit * pCSPN = (CSPNSuffixEdit *)((CDsTableDrivenPage *)pPage)->m_pData;

    if (DlgOp == fOnCommand && pCSPN)
    {
        pCSPN->DoCommand(pPage->GetHWnd(), IDC_ADD_BTN, (int)lParam);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustSPNRemove
//
//  Synopsis:   Attr function for the SPN page Remove button.
//
//-----------------------------------------------------------------------------
HRESULT
TrustSPNRemove(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp)
{
    CSPNSuffixEdit * pCSPN = (CSPNSuffixEdit *)((CDsTableDrivenPage *)pPage)->m_pData;

    if (DlgOp == fOnCommand && pCSPN)
    {
        pCSPN->DoCommand(pPage->GetHWnd(), IDC_DELETE_BTN, (int)lParam);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustSPNChange
//
//  Synopsis:   Attr function for the SPN page Edit button.
//
//-----------------------------------------------------------------------------
HRESULT
TrustSPNChange(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp)
{
    CSPNSuffixEdit * pCSPN = (CSPNSuffixEdit *)((CDsTableDrivenPage *)pPage)->m_pData;

    if (DlgOp == fOnCommand && pCSPN)
    {
        return pCSPN->DoCommand(pPage->GetHWnd(), IDC_EDIT_BTN, (int)lParam);
    }

    return S_OK;
}
#endif //REMOVE_SPN_SUFFIX_CODE

//+----------------------------------------------------------------------------
//
//  Function:   VolumeUNCpath
//
//  Synopsis:   Attr function for the UNC path.
//
//-----------------------------------------------------------------------------
HRESULT
VolumeUNCpath(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
              DLG_OP DlgOp)
{
    int cch;

    switch (DlgOp)
    {
    case fInit:
        // NTRAID#NTBUG9-488674-2001/11/01-JeffJon
        // Since this causes us to miss setting the field readonly
        // we need to do that now

        if (!PATTR_DATA_IS_WRITABLE(pAttrData))
        {
          SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID, EM_SETREADONLY, (WPARAM)TRUE, 0);
        }
        return S_FALSE; // let the tablepage code display the value.
        break;

    case fOnCommand:
        if (EN_CHANGE == lParam)
        {
            cch = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                          WM_GETTEXTLENGTH, 0, 0);
            if (0 == cch)
            {
                // UNC name is a required property, so disable the
                // apply button if blank.
                //
                dspDebugOut((DEB_ITRACE, "no characters, disabling Apply.\n"));
                //
                // Gotta set the dirty state here cause returning S_FALSE
                // means that the base class will not be called. The page needs
                // to be dirty because PropSheet_UnChanged does not disable the
                // OK button and if it is pressed the sheet will be closed
                // without the warning to the user that the UNC field is empty.
                // This is actually benign because the OnApply is skipped because
                // the page isn't dirty. However its appearance is deceptive;
                // it looke like a save is made when in fact it isn't.
                //
                pPage->SetDirty(FALSE);
                //
                // Now disable the Apply button.
                //
                PropSheet_UnChanged(GetParent(pPage->GetHWnd()), pPage->GetHWnd());
                return S_FALSE;
            }
        }
        break;

    case fApply:
        cch = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      WM_GETTEXTLENGTH, 0, 0);
        if (0 == cch)
        {
            // UNC name is a required property
            //
            ErrMsg(IDS_ERRMSG_NO_VOLUME_PATH, pPage->GetHWnd());
            SetFocus(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID));
            return E_INVALIDARG;  // Path is not valid
        }

        PTSTR ptz = new TCHAR[++cch];

        CHECK_NULL_REPORT(ptz, pPage->GetHWnd(), return E_OUTOFMEMORY);

        GetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptz, cch);

        if (!FIsValidUncPath(ptz, VUP_mskfAllowUNCPath))
        {
            ErrMsg(IDS_ERRMSG_INVALID_VOLUME_PATH, pPage->GetHWnd());
            SetFocus(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID));
            return E_INVALIDARG;  // Path is not valid
        }

        PWSTR pwz;

        if (!TcharToUnicode(ptz, &pwz))
        {
            delete [] ptz;
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
        }
        delete [] ptz;

        PADSVALUE pADsValue;
        pADsValue = new ADSVALUE;
        CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

        pAttrInfo->pADsValues = pADsValue;
        pAttrInfo->dwNumValues = 1;
        pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        pADsValue->dwType = pAttrInfo->dwADsType;
        pADsValue->CaseIgnoreString = pwz;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\behaviorversion.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      BehaviorVersion.cxx
//
//  Contents:  Supporting code for displaying and raising the domain and
//             forest version.
//
//  History:   5-April-01 EricB created
//
//
//-----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "proppage.h"
#include "qrybase.h"
#include "BehaviorVersion.h"

//+----------------------------------------------------------------------------
//
//  Class:     CVersionBase
//
//  Purpose:   Base class for version management.
//
//-----------------------------------------------------------------------------

CVersionBase::~CVersionBase(void)
{
   TRACE(CVersionBase,~CVersionBase);

   for (DC_LIST::iterator i = _DcLogList.begin(); i != _DcLogList.end(); ++i)
   {
      delete *i;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CVersionBase::ReadDnsSrvName
//
//  Synopsis:  Given the DN of an nTDSDSA object, backing up one path element
//             should give the name of the Server object that contained the
//             nTDSDSA object. Read the DNSHostName off of the server object.
//
//-----------------------------------------------------------------------------
HRESULT
CVersionBase::ReadDnsSrvName(PCWSTR pwzNTDSDSA,
                             CComPtr<IADs> & spServer,
                             CComVariant & varSrvDnsName)
{
   HRESULT hr = S_OK;
   if (!pwzNTDSDSA)
   {
      dspAssert(FALSE);
      return E_INVALIDARG;
   }
   CPathCracker PathCrack;

   hr = PathCrack.Set(const_cast<BSTR>(pwzNTDSDSA), ADS_SETTYPE_DN);

   CHECK_HRESULT(hr, return hr);

   hr = PathCrack.RemoveLeafElement();

   CHECK_HRESULT(hr, return hr);

   hr = PathCrack.Set(_strDC, ADS_SETTYPE_SERVER);

   CHECK_HRESULT(hr, return hr);
   CComBSTR bstrServer;

   hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrServer);

   CHECK_HRESULT(hr, return hr);

   hr = DSAdminOpenObject(bstrServer, 
                          __uuidof(IADs), 
                          (void **)&spServer);

   CHECK_HRESULT(hr, return hr);

   hr = spServer->Get(CComBSTR(L"dNSHostName"), &varSrvDnsName);

   CHECK_HRESULT(hr, return hr);
   dspAssert(VT_BSTR == varSrvDnsName.vt);
   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVersionBase::EnumDsaObjs
//
//  Synopsis:  Enumerate the nTDSDSA objects which represent the DCs and check
//             the version on each. Build a list of DCs whose version is too low.
//
//  Arguments: [pwzSitesPath] - ADSI path to the Sites container.
//             [pwzFilterClause] - optional search filter expression to be
//                combined with the objectCategory clause to narrow the search.
//             [pwzDomainDnsName] - optional name of the domain for whose DC
//                objects we're searching.
//             [nMinVer] - the minimum DC behavior version needed for the
//                domain or forest version upgrade.
//
//  Notes:  If searching for a domain's DC objects, the search filter clause
//          parameter will request those objects whose hasMasterNCs contains
//          the domain's DN. The pwzDomainDnsName value will be passed to the
//          log list elements.
//          If searching for a forest's DCs, then the search filter param is
//          NULL so as to get all nTDSDSA objects and the domain name param is
//          NULL since we want the objects for all domains.
//
// 2002/04/01 JonN 531591 use msDS-hasMasterNCs if available
//
//-----------------------------------------------------------------------------
HRESULT
CVersionBase::EnumDsaObjs(PCWSTR pwzSitesPath, PCWSTR pwzFilterClause,
                          PCWSTR pwzDomainDnsName, UINT nMinVer)
{
   if (!pwzSitesPath)
   {
      dspAssert(FALSE);
      return E_INVALIDARG;
   }
   dspDebugOut((DEB_ITRACE, "Searching for nTDSDSA objects under %ws\n",
                pwzSitesPath));
   CDSSearch Search;

   HRESULT hr = Search.Init(pwzSitesPath);

   CHECK_HRESULT(hr, return hr);
   PWSTR rgwzAttrs[] = {g_wzBehaviorVersion, g_wzDN,
                        g_wzMsDsHasMasterNCs, g_wzHasMasterNCs,
                        g_wzServerRefBL, g_wzLastKnownParent};

   Search.SetAttributeList(rgwzAttrs, ARRAYLENGTH(rgwzAttrs));

   hr = Search.SetSearchScope(ADS_SCOPE_SUBTREE);

   CHECK_HRESULT(hr, return hr);
   CStrW strSearchFilter;

   if (pwzFilterClause)
   {
      WCHAR wzSearchFormat[] = L"(&(objectCategory=nTDSDSA)%s)";

      strSearchFilter.Format(wzSearchFormat, pwzFilterClause);
   }
   else
   {
      strSearchFilter = L"(objectCategory=nTDSDSA)";
   }

   Search.SetFilterString(const_cast<LPWSTR>((LPCWSTR)strSearchFilter));

   hr = Search.DoQuery();

   CHECK_HRESULT(hr, return hr);
   CStrW strUnknown;
   PWSTR pwzServer = NULL;

   while (SUCCEEDED(hr))
   {
      hr = Search.GetNextRow();

      if (hr == S_ADS_NOMORE_ROWS)
      {
         hr = S_OK;
         break;
      }

      CHECK_HRESULT(hr, return hr);
      ADS_SEARCH_COLUMN Column = {0};
      UINT nVer = 0;

      hr = Search.GetColumn(g_wzBehaviorVersion, &Column);

      if (E_ADS_COLUMN_NOT_SET != hr)
      {
         // If hr == E_ADS_COLUMN_NOT_SET then it is a Win2k domain. nVer is
         // initialized to zero for this case.
         //
         CHECK_HRESULT(hr, return hr);

         nVer = Column.pADsValues->Integer;

         Search.FreeColumn(&Column);
      }

      if (nVer < nMinVer)
      {
         // Found a DC that prevents raising the domain version. Read its DNS
         // name off of the Server object which contains this nTDSDSA object.
         //
         hr = Search.GetColumn(g_wzDN, &Column);

         CHECK_HRESULT(hr, return hr);
         CStrW strNtDsDsaDn;
         dspAssert(Column.pADsValues);
         dspAssert(Column.pADsValues->CaseIgnoreString);

         strNtDsDsaDn = Column.pADsValues->CaseIgnoreString;

         Search.FreeColumn(&Column);

         CComVariant varDcDnsName, varSrvRef;
         CComPtr<IADs> spServer;

         hr = ReadDnsSrvName(strNtDsDsaDn, spServer, varDcDnsName);

         if (E_ADS_PROPERTY_NOT_FOUND == hr ||
             ERROR_OBJECT_NOT_FOUND == HRESULT_CODE(hr) ||
             ERROR_DS_NO_SUCH_OBJECT == HRESULT_CODE(hr))
         {
            // If an nTDSDSA object is found in the LostAndFoundConfig container,
            // it may not have an associated server object. Report this to the
            // user.
            //
            CComBSTR bstrSrv;

            // The nTDSDSA object may have a serverReferenceBL attribute whose
            // leaf element will name the DC. Try to read that so it can be
            // added to the error message. If not found, try to read the
            // lastKnownParent attribute which would also have the DC name as
            // the leaf element.
            //
            hr = Search.GetColumn(g_wzServerRefBL, &Column);

            if (FAILED(hr))
            {
               hr = Search.GetColumn(g_wzLastKnownParent, &Column);
            }

            if (SUCCEEDED(hr))
            {
               CPathCracker PathCrack;
               hr = PathCrack.Set(CComBSTR(Column.pADsValues->CaseIgnoreString), ADS_SETTYPE_DN);
               Search.FreeColumn(&Column);
               if (SUCCEEDED(hr))
               {
                  PathCrack.SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
                  PathCrack.GetElement(0, &bstrSrv);
               }
            }
            if (bstrSrv.Length() == 0)
            {
               if (strUnknown.IsEmpty())
               {
                  // NOTICE-2002/02/12-ericb - SecurityPush: CStrW::LoadString on
                  // failure creates an empty string rather than a null string.
                  strUnknown.LoadString(g_hInstance, IDS_UNKNOWN);
               }
               bstrSrv = strUnknown.GetBuffer(0);
            }
            PCWSTR rgpwzNames[] = {strNtDsDsaDn.GetBuffer(0), bstrSrv};

            SuperMsgBox(_hDlg, IDS_LOSTANDFOUND_NTDSDSA, 0,
                        MB_OK | MB_ICONEXCLAMATION, 0,
                        (PVOID *)rgpwzNames, 2, FALSE, __FILE__, __LINE__);

            _fCanRaiseBehaviorVersion = false;

            _nMinDcVerFound = min(_nMinDcVerFound, nVer);

            hr = S_OK;

            continue;
         }

         CHECK_HRESULT(hr, return hr);

         hr = spServer->Get(CComBSTR(g_wzServerRef), &varSrvRef);

         if (FAILED(hr))
         {
            // Unable to read the server reference property. This will cause a failure
            // when producing the log file in CVersionBase::BuildDcListString; it will
            // be unable to bind to the computer object to obtain the OS version. The
            // code there will handle this situation.
            //
            if (strUnknown.IsEmpty())
            {
               strUnknown.LoadString(g_hInstance, IDS_UNKNOWN);
            }
            pwzServer = strUnknown.GetBuffer(0);
            hr = S_OK;
         }
         else
         {
            dspAssert(VT_BSTR == varSrvRef.vt);
            pwzServer = varSrvRef.bstrVal;
         }
         bool fFreeDnsName = false;

         if (!pwzDomainDnsName)
         {
            // Get domain to which the DC belongs. The hasMasterNCs attribute
            // is multi-valued and includes the DN of the domain. Check the
            // class of each DN to see which is Domain-DNS.
            //

            // 531591 JonN 2002/04/01 .NET Server domains use msDs-HasMasterNCs
            hr = Search.GetColumn(g_wzMsDsHasMasterNCs, &Column);
            if (FAILED(hr))
            {
                // 531591 JonN 2002/04/01 W2K domains fallback to hasMasterNCs
                hr = Search.GetColumn(g_wzHasMasterNCs, &Column);
            }

            CHECK_HRESULT(hr, return hr);
            WCHAR wzErr[] = L"error";
            pwzDomainDnsName = wzErr;

            for (DWORD i = 0; i < Column.dwNumValues; i++)
            {
               dspAssert(Column.pADsValues[i].CaseIgnoreString);
               CComPtr<IADs> spNC;
               CStrW strPath = g_wzLDAPPrefix;
               strPath += _strDC;
               strPath += L"/";
               strPath += Column.pADsValues[i].CaseIgnoreString;

               hr = DSAdminOpenObject(strPath, 
                                      __uuidof(IADs), 
                                      (void **)&spNC);

               CHECK_HRESULT(hr, return hr);
               CComBSTR bstrClass;

               hr = spNC->get_Class(&bstrClass);

               CHECK_HRESULT(hr, return hr);

               // NOTICE-2002/02/12-ericb - SecurityPush: Check if the class name
               // is "domainDNS" (length of 9). Check the length first to prevent
               // problems if get_Class returns a null string.
               if ((bstrClass.Length() == 9) &&
                   (_wcsicmp(bstrClass, L"domainDNS") == 0))
               {
                  // Found it.
                  //
                  hr = CrackName(Column.pADsValues[i].CaseIgnoreString,
                                 const_cast<PWSTR *>(&pwzDomainDnsName),
                                 GET_DNS_DOMAIN_NAME, GetDlgHwnd());

                  CHECK_HRESULT(hr, return hr);
                  fFreeDnsName = true;
                  break;
               }
            }
         }

         dspDebugOut((DEB_ITRACE, "Found DC %ws, ver: %d, for domain %ws\n",
                      varDcDnsName.bstrVal, nVer, pwzDomainDnsName));

         CDcListItem * pDcItem = new CDcListItem(pwzDomainDnsName,
                                                 varDcDnsName.bstrVal,
                                                 pwzServer,
                                                 nVer);

         if (fFreeDnsName)
         {
            LocalFreeStringW(const_cast<PWSTR *>(&pwzDomainDnsName));
            pwzDomainDnsName = NULL;
         }

         CHECK_NULL(pDcItem, return E_OUTOFMEMORY;);

         _DcLogList.push_back(pDcItem);

         _fCanRaiseBehaviorVersion = false;

         _nMinDcVerFound = min(_nMinDcVerFound, nVer);
      }
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVersionBase::BuildDcListString
//
//-----------------------------------------------------------------------------
HRESULT
CVersionBase::BuildDcListString(CStrW & strList)
{
   HRESULT hr = S_FALSE; // return S_FALSE if no downlevel DCs.
   CPathCracker PathCrack;

   for (DC_LIST::iterator i = _DcLogList.begin(); i != _DcLogList.end(); ++i)
   {
      strList += (*i)->GetDomainName();
      strList += L"\t";
      strList += (*i)->GetDcName();
      strList += L"\t";

      hr = PathCrack.Set(const_cast<BSTR>((*i)->GetCompObjDN()), ADS_SETTYPE_DN);

      CHECK_HRESULT(hr, return hr);

      hr = PathCrack.Set(_strDC, ADS_SETTYPE_SERVER);

      CHECK_HRESULT(hr, return hr);
      CComBSTR bstrDC;

      hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrDC);

      CHECK_HRESULT(hr, return hr);

      CComPtr<IADs> spDC;
      CComVariant varOS, varOsVer;

      hr = DSAdminOpenObject(bstrDC, 
                             __uuidof(IADs), 
                             (void **)&spDC);

      if (SUCCEEDED(hr))
      {
         hr = spDC->Get(CComBSTR(L"operatingSystem"), &varOS);

         if (SUCCEEDED(hr))
         {
            dspAssert(VT_BSTR == varOS.vt);

            strList += varOS.bstrVal;
         }
         else
         {
            CHECK_HRESULT(hr, ;);
         }

         strList += L" ";

         hr = spDC->Get(CComBSTR(L"operatingSystemVersion"), &varOsVer);

         if (SUCCEEDED(hr))
         {
            dspAssert(VT_BSTR == varOsVer.vt);

            strList += varOsVer.bstrVal;
         }
      }
      else
      {
         CHECK_HRESULT(hr, ;);
      }

      if (FAILED(hr))
      {
         // Unable to read the OS version from the computer object,
         // substitute an error message.
         CStrW strErr;
         strErr.LoadString(g_hInstance, IDS_ERR_NO_COMPUTER_OBJECT);
         strList += strErr;
         hr = S_OK;
      }

      strList += g_wzCRLF;
   }

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:   CVersionBase::ShowHelp
//
//-----------------------------------------------------------------------------
void
ShowHelp(PCWSTR pwzHelpFile)
{
   TRACE_FUNCTION(ShowHelp);
   if (!pwzHelpFile)
   {
      dspAssert(FALSE);
      return;
   }
   CStrW strHelpPath;

   PWSTR pwz = strHelpPath.GetBufferSetLength(MAX_PATH + MAX_PATH + 1);

   if (!GetWindowsDirectory(pwz, MAX_PATH + MAX_PATH))
   {
      dspAssert(false);
      return;
   }

   if (strHelpPath.IsEmpty())
   {
      dspAssert(false);
      return;
   }

   // NOTICE-2002/02/12-ericb - SecurityPush: This usage of wcslen is safe
   // because GetBufferSetLength above null terminates the end of the buffer
   // and GetWindowsDirectory also null terminates the returned string.
   //
   strHelpPath.GetBufferSetLength((int)wcslen(pwz));

   strHelpPath += L"\\help\\";

   strHelpPath += pwzHelpFile;

   dspDebugOut((DEB_ITRACE, "Help topic is: %ws\n", strHelpPath.GetBuffer(0)));

   HRESULT hr = MMCPropertyHelp(strHelpPath);

   CHECK_HRESULT(hr, ;);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\bitfield.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       bitfield.cxx
//
//  Contents:
//
//  History:    07-May-97 JonN  copied from user.cxx
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "user.h"

//
// If you want to reverse the sense of a checkbox, provide a reverse mask.
// The checkbox is reversed if more than 16 of the bits are set.
//
BOOL IsPositiveMask( DWORD dwMask )
{
	int nBitsSet = 0;
	while (0 != dwMask)
	{
		if (1 & dwMask)
			nBitsSet++;
		dwMask /= 2;
	}
	return (nBitsSet <= 16);
}

BOOL BitField_IsChecked( DWORD dwValue, DWORD dwMask )
{
	if (IsPositiveMask(dwMask))
		return !!(dwValue & dwMask);
	else
		return !(dwValue & ~dwMask);
}

DWORD BitField_SetChecked( DWORD dwOldValue, DWORD dwMask, BOOL fChecked )
{
	if (!IsPositiveMask(dwMask))
	{
		fChecked = !fChecked;
		dwMask = ~dwMask;
	}
	if (fChecked)
		return dwOldValue | dwMask;
	else
		return dwOldValue & ~dwMask;
}

// only use this for the first shared bit control on a table-driven page.  It uses the
// shared CDsTableDrivenPage.m_pData rather than the per-attribute pAttrData->pVoid.
HRESULT
FirstSharedBitField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
	switch (DlgOp)
	{
	case fInit:
    //
    // Save the address of this function's instance of pAttrData in the
    // page's m_pData member so that SubsequentSharedBitField can access it.
    //
    ((CDsTableDrivenPage*)pPage)->m_pData = reinterpret_cast<LPARAM>(pAttrData);
    // fall through.
	case fObjChanged:
		DBG_OUT("BitField: fInit or fObjChanged");
		//
		// See if the bitfield is currently turned on
		//
		// We just save the integer value in *pInitialValue, not a pointer to anything
		//
		if (pAttrInfo && (pAttrInfo->dwNumValues == 1))
		{
			ASSERT( NULL != pAttrInfo->pADsValues );
      pAttrData->pVoid = static_cast<LPARAM>(pAttrInfo->pADsValues->Integer);
		}
		else
		{
      pAttrData->pVoid = NULL;
		}
		// fall through to SubsequentSharedBitField
		break;

	case fApply:
		DBG_OUT("BitField: fApply");
    if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
		{
      return ADM_S_SKIP;
		}
    PADSVALUE pADsValue;
    pADsValue = new ADSVALUE;
		CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
		pAttrInfo->pADsValues = pADsValue;
		pAttrInfo->dwNumValues = 1;
		pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
		pADsValue->dwType = pAttrInfo->dwADsType;
		pADsValue->Integer = (ADS_INTEGER)((DWORD_PTR)pAttrData->pVoid);
		break;

	case fOnCommand:
		DBG_OUT("BitField: fOnCommand");
		// fall through to SubsequentSharedBitField
		break;
	}

	return SubsequentSharedBitField(pPage,pAttrMap,pAttrInfo,lParam,pAttrData,DlgOp);
}

// only use this for subsequent shared bit controls on a table-driven page.  It uses the
// shared CDsTableDrivenPage.m_pData rather than the per-attribute pAttrData->pVoid.
HRESULT
SubsequentSharedBitField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO,
                         LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
  PATTR_DATA pData = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage*)pPage)->m_pData);
  DWORD* pInitialValue = reinterpret_cast<DWORD*>(&pData->pVoid);
	ASSERT( NULL != pData );
	switch (DlgOp)
	{
	case fInit:
	case fObjChanged:
		DBG_OUT("SubsequentSharedBitField: fInit or fObjChanged");

		// JonN 7/2/99: disable if attribute not writable
		if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
			EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);

		//
		// See if the bitfield is currently turned on
		//
		SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID, BM_SETCHECK,
			(WPARAM)((BitField_IsChecked(*pInitialValue, pAttrMap->nSizeLimit))
				? TRUE : FALSE), 0);
		break;

	case fOnCommand:
		DBG_OUT("SubsequentSharedBitField: fOnCommand");
		if (lParam == BN_CLICKED)
		{
			BOOL fChecked = (BOOL)SendDlgItemMessage(
				pPage->GetHWnd(), pAttrMap->nCtrlID, BM_GETCHECK, 0, 0);
			ASSERT( 0 == fChecked || 1 == fChecked );
			*pInitialValue = BitField_SetChecked( *pInitialValue, pAttrMap->nSizeLimit, fChecked );
			pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pData);
		}
		break;
	}

	return S_OK;
}

// Hide and disable the control if this bit is set (reverse flag for not-set)
HRESULT
HideBasedOnBitField(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                    LPARAM, PATTR_DATA, DLG_OP DlgOp)
{
	switch (DlgOp)
	{
	case fInit:
	case fObjChanged:
		{
			//
			// See if the bitfield is currently turned on
			//
			ADS_INTEGER nValue = 0;
			if (pAttrInfo && (pAttrInfo->dwNumValues == 1))
			{
				ASSERT( NULL != pAttrInfo->pADsValues );
				nValue = pAttrInfo->pADsValues->Integer;
			}
			BOOL fSet = BitField_IsChecked(nValue, pAttrMap->nSizeLimit);
			HWND hwnd = ::GetDlgItem( pPage->GetHWnd(), pAttrMap->nCtrlID );
			ASSERT( NULL != hwnd );
			(void)::ShowWindow( hwnd, (fSet) ? SW_SHOW : SW_HIDE );
			(void)::EnableWindow( hwnd, fSet );
		}
		break;
	default:
		break;
	}

	return S_OK;
}

// Sets the context help ID to pAttrMap->pData on fInit/fObjChanged
// This is particularly useful for static text controls which cannot set
// context help ID in the resource file.
HRESULT
SetContextHelpIdAttrFn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP DlgOp)
{
	switch (DlgOp)
	{
	case fInit:
	case fObjChanged:
		{
			HWND hwnd = ::GetDlgItem( pPage->GetHWnd(), pAttrMap->nCtrlID );
			ASSERT( NULL != hwnd );
			::SetWindowContextHelpId( hwnd, pAttrMap->nSizeLimit );
		}
		break;
	default:
		break;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\certifct.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       Certifct.cpp
//
//  Contents:   Implementation of CCertmgrApp and DLL registration.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "pages.h"
#include "proppage.h"
#include "Certifct.h"

#ifdef DSADMIN

/////////////////////////////////////////////////////////////////////////////
//
enum {
	FIELD_CAN_DELETE = 0x00000001
};

CCertificate::CCertificate(const PCCERT_CONTEXT pCertContext,
		HCERTSTORE hCertStore) 
:	m_pCertContext (::CertDuplicateCertificateContext (pCertContext)),
	m_pCertInfo (0),
	m_hCertStore (::CertDuplicateStore (hCertStore)),
	m_szEnhancedKeyUsage (0),
	m_szAltSubjectName (0),
	m_szAltIssuerName (0),
	m_szValidNotAfter (0),
	m_szSubjectName (0),
	m_szIssuerName (0),
	m_bCertContextFreed (false),
	m_fieldChecked (0),
	m_bCanDelete (false)
{
	dspAssert (m_pCertContext);
	if ( m_pCertContext )
		m_pCertInfo = m_pCertContext->pCertInfo;
}



CCertificate::~CCertificate()
{
	if ( m_szEnhancedKeyUsage )
		delete [] m_szEnhancedKeyUsage;
	if ( m_szAltSubjectName )
		delete [] m_szAltSubjectName;
	if ( m_szAltIssuerName )
		delete [] m_szAltIssuerName;
	if ( m_szValidNotAfter )
		delete [] m_szValidNotAfter;
	if ( m_szSubjectName )
		delete [] m_szSubjectName;
	if ( m_szIssuerName )
		delete [] m_szIssuerName;
	if ( m_pCertContext && !m_bCertContextFreed )
		::CertFreeCertificateContext (m_pCertContext);

	if ( m_hCertStore )
		::CertCloseStore (m_hCertStore, 0);
}


HRESULT CCertificate::GetIssuerName (PWSTR *ppszIssuerName)
{
	HRESULT	hResult = S_OK;

	dspAssert (m_pCertInfo && ppszIssuerName);
	if ( m_pCertInfo && ppszIssuerName )
	{
		// Decode issuer name if not already present
		if ( !m_szIssuerName )
		{
			hResult = GetNameString (CERT_NAME_ISSUER_FLAG, &m_szIssuerName);
		}
		if ( SUCCEEDED (hResult) )
		{
			if ( *ppszIssuerName )
				delete [] *ppszIssuerName;
			*ppszIssuerName = new WCHAR[wcslen (m_szIssuerName) + 1];
			if ( *ppszIssuerName )
			{
				wcscpy (*ppszIssuerName, m_szIssuerName);
			}
			else
				hResult = E_OUTOFMEMORY;
		}
	}
	else
		hResult = E_POINTER;


	return hResult;
}

///////////////////////////////////////////////////////////////////////////
//	GetSubjectName ()
//
//	pszName (IN / OPTIONAL)	 - returns the alternate issuer name.  An empty 
//								string is a valid return value
//	cbName	(IN / OUT)		 - If pszName is NULL, then the required length
//								of pszName is returned.  
//								Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::GetSubjectName(PWSTR *ppszSubjectName)
{
	HRESULT	hResult = S_OK;

	dspAssert (m_pCertInfo && ppszSubjectName);
	if ( m_pCertInfo && ppszSubjectName )
	{
		// Decode issuer name if not already present
		if ( !m_szSubjectName )
		{
			hResult = GetNameString (0, &m_szSubjectName);
		}
		if ( SUCCEEDED (hResult) )
		{
			if ( *ppszSubjectName )
				delete [] *ppszSubjectName;
			*ppszSubjectName = new WCHAR[wcslen (m_szSubjectName) + 1];
			if ( *ppszSubjectName )
			{
				wcscpy (*ppszSubjectName, m_szSubjectName);
			}
			else
				hResult = E_OUTOFMEMORY;
		}
	}
	else
		hResult = E_POINTER;


	return hResult;
}


///////////////////////////////////////////////////////////////////////////
//	GetValidNotAfter ()
//
//	pszDateTime (IN / OPTIONAL)	 - returns the formatted date and time.
//	cbDateTime	(IN / OUT)		 - If pszDateTime is NULL, then the required length
//								of pszDateTime is returned.  
//								Otherwise, contains the length of pszDateTime.
///////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::GetValidNotAfter (PWSTR* ppszValidNotAfter)
{
	HRESULT	hResult = S_OK;

	dspAssert (m_pCertInfo && ppszValidNotAfter);
	if ( m_pCertInfo && ppszValidNotAfter )
	{
		// Format date/time string if not already present
		if ( !m_szValidNotAfter )
		{
			hResult = FormatDate (m_pCertInfo->NotAfter, &m_szValidNotAfter);
			if ( SUCCEEDED (hResult) )
			{
				if ( *ppszValidNotAfter )
					delete [] *ppszValidNotAfter;
				*ppszValidNotAfter = new WCHAR[wcslen (m_szValidNotAfter)+1];
				if ( *ppszValidNotAfter )
				{
					wcscpy (*ppszValidNotAfter, m_szValidNotAfter);
				}
				else
					hResult = E_OUTOFMEMORY;
			}
		}
	}
	else
		hResult = E_POINTER;

	return hResult;
}


HRESULT CCertificate::GetEnhancedKeyUsage (PWSTR* ppszUsages)
{
	HRESULT	hResult = S_OK;

	dspAssert (m_pCertInfo && ppszUsages);
	if ( m_pCertInfo && ppszUsages )
	{
		// Format date/time string if not already present
		if ( !m_szEnhancedKeyUsage )
		{
			hResult = FormatEnhancedKeyUsagePropertyString ();
			if ( SUCCEEDED (hResult) && m_szEnhancedKeyUsage )
			{
				if ( *ppszUsages )
					delete [] *ppszUsages;
				*ppszUsages = new WCHAR[wcslen (m_szEnhancedKeyUsage)+1];
				if ( *ppszUsages )
				{
					wcscpy (*ppszUsages, m_szEnhancedKeyUsage);
				}
				else
					hResult = E_OUTOFMEMORY;
			}
		}
	}
	else
		hResult = E_POINTER;

	return hResult;
}


HRESULT CCertificate::FormatEnhancedKeyUsagePropertyString ()
{
	HRESULT	hResult = S_OK;
	DWORD	cbUsage = 0;
	DWORD	dwErr = 0;
	BOOL	bReturn = ::CertGetEnhancedKeyUsage (m_pCertContext,  0, // get extension and property
			NULL, &cbUsage);
	if ( bReturn )
	{
		PCERT_ENHKEY_USAGE pUsage = (PCERT_ENHKEY_USAGE) new BYTE[cbUsage];
		if ( pUsage )
		{
			bReturn = ::CertGetEnhancedKeyUsage (m_pCertContext,  0, // get extension and property
					pUsage, &cbUsage);
			if ( bReturn )
			{
				size_t	dwLen = 0;
				PWSTR	pszComma = _T(", ");
				size_t	dwCommaLen = wcslen (pszComma);
				PWSTR	pszUsageName = 0;


				// Get accumulated lengths first
				for (DWORD dwIndex = 0; dwIndex < pUsage->cUsageIdentifier; dwIndex++)
				{
					hResult = GetOIDInfo (&pszUsageName, pUsage->rgpszUsageIdentifier[dwIndex]);
					if ( SUCCEEDED (hResult) )
					{
						// add delimeter if not first iteration
						if ( dwIndex != 0 )
							dwLen += dwCommaLen;
						dwLen += wcslen (pszUsageName);
						delete [] pszUsageName;
						pszUsageName = 0;
					}
					else
						break;
				}

				// Allocate buffer and get strings
				if ( m_szEnhancedKeyUsage )
				{
					delete [] m_szEnhancedKeyUsage;
				}
				m_szEnhancedKeyUsage = new WCHAR[dwLen+1];
				if ( m_szEnhancedKeyUsage )
				{
					::ZeroMemory (m_szEnhancedKeyUsage, (dwLen+1)* sizeof (WCHAR));
					for (DWORD dwIndex = 0; dwIndex < pUsage->cUsageIdentifier; dwIndex++)
					{
						hResult = GetOIDInfo (&pszUsageName, pUsage->rgpszUsageIdentifier[dwIndex]);
						if ( SUCCEEDED (hResult) )
						{
							// add delimeter if not first iteration
							if ( dwIndex != 0 )
								wcscat (m_szEnhancedKeyUsage, pszComma);
							wcscat (m_szEnhancedKeyUsage, pszUsageName);
							dspAssert (wcslen (m_szEnhancedKeyUsage) <= dwLen);
							delete [] pszUsageName;
							pszUsageName = 0;
						}
						else
							break;
					}
				}
				else
					hResult = E_OUTOFMEMORY;
			}
			else
			{
				dwErr = GetLastError ();
				dspAssert (dwErr == CRYPT_E_NOT_FOUND);
				if ( dwErr == CRYPT_E_NOT_FOUND )
				{
					if ( !LoadStringToTchar (IDS_ANY, &m_szEnhancedKeyUsage) )
						hResult = E_UNEXPECTED;
				}
				else
				{
					hResult = HRESULT_FROM_WIN32 (GetLastError ());
				}
			}
			delete [] pUsage;
		}
		else
			hResult = E_OUTOFMEMORY;
	}
	else
	{
		dwErr = GetLastError ();
		dspAssert (dwErr == CRYPT_E_NOT_FOUND);
		if ( dwErr != CRYPT_E_NOT_FOUND )
			hResult = HRESULT_FROM_WIN32 (GetLastError ());
	}
    return hResult;
}

///////////////////////////////////////////////////////////////////////////
//	GetAlternateIssuerName ()
//
//	pszName (IN / OPTIONAL)	 - returns the alternate issuer name.  An empty 
//								string is a valid return value
//	cbName	(IN / OUT)		 - If pszName is NULL, then the required length
//								of pszName is returned.  
//								Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::GetAlternateIssuerName (PWSTR* ppszAltIssuerName)
{
	HRESULT	hResult = S_OK;

	dspAssert (m_pCertInfo && ppszAltIssuerName);
	if ( m_pCertInfo && ppszAltIssuerName )
	{
		if ( !m_szAltIssuerName )
		{
			hResult = ConvertAltNameToString (_T(szOID_ISSUER_ALT_NAME),
					CERT_ALT_NAME_URL, &m_szAltIssuerName);
			dspAssert (SUCCEEDED (hResult));
			if ( SUCCEEDED (hResult) )
			{
				if ( *ppszAltIssuerName )
					delete [] *ppszAltIssuerName;
				*ppszAltIssuerName = new WCHAR[wcslen (m_szAltIssuerName)+1];
				if ( *ppszAltIssuerName )
				{
					wcscpy (*ppszAltIssuerName, m_szAltIssuerName);
				}
				else
					hResult = E_OUTOFMEMORY;
			}
		}
	}
	else
		hResult = E_POINTER;
	
	return hResult;
}

///////////////////////////////////////////////////////////////////////////
//	GetAlternateSubjectName ()
//
//	pszName (IN / OPTIONAL)	 - returns the alternate issuer name.  An empty 
//								string is a valid return value
//	cbName	(IN / OUT)		 - If pszName is NULL, then the required length
//								of pszName is returned.  
//								Otherwise, contains the length of pszName.
///////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::GetAlternateSubjectName (PWSTR* ppszAltSubjectName)
{
	HRESULT	hResult = S_OK;
	dspAssert (m_pCertInfo && ppszAltSubjectName);
	if ( m_pCertInfo && ppszAltSubjectName )
	{
		if ( !m_szAltSubjectName )
		{
			hResult = ConvertAltNameToString (_T(szOID_SUBJECT_ALT_NAME),
					CERT_ALT_NAME_URL, &m_szAltSubjectName);
			dspAssert (SUCCEEDED (hResult));
			if ( SUCCEEDED (hResult) )
			{
				if ( *ppszAltSubjectName )
					delete [] *ppszAltSubjectName;
				*ppszAltSubjectName = new WCHAR[wcslen (m_szAltSubjectName)+1];
				if ( *ppszAltSubjectName )
				{
					wcscpy (*ppszAltSubjectName, m_szAltSubjectName);
				}
				else
					hResult = E_OUTOFMEMORY;
			}
		}
	}
	else
		hResult = E_POINTER;
	
	return hResult;
}


//////////////////////////////////////////////////////////////////////////////
//	ConvertAltNameToString ()
//
//  szOID (IN)			- The OID of the alternate name to retrieve
//	dwNameChoice (IN)	- The type of alternate name to return
//	altName (OUT)		- The version of the desired alternate name indicated
//							by dwNameChoice
//////////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::ConvertAltNameToString (PWSTR szOID, const DWORD dwNameChoice, PWSTR* ppszAltName)
{
	HRESULT	hResult = S_OK;
	dspAssert (ppszAltName && szOID);
	if ( !ppszAltName || !szOID )
		return E_POINTER;

	// Iterate through the extensions until the one indicated by the
	// passed-in szOID is found.
	for (DWORD	index = 0; index < m_pCertInfo->cExtension; index++)
	{
		dspAssert (m_pCertInfo->rgExtension);
		size_t	len = strlen (m_pCertInfo->rgExtension[index].pszObjId);
		LPTSTR	wcsObjId = new WCHAR[len];
		if ( !wcsObjId )
		{
			hResult = E_OUTOFMEMORY;
			break;
		}
		mbstowcs (wcsObjId,  m_pCertInfo->rgExtension[index].pszObjId, len);

		if ( !wcscmp (wcsObjId, szOID) )
		{
			CERT_ALT_NAME_INFO	nameInfo;
			DWORD				cbNameInfo = sizeof (CERT_ALT_NAME_INFO);

			BOOL	bResult = CryptDecodeObject(
					MY_ENCODING_TYPE,
					X509_ALTERNATE_NAME,	// in
					m_pCertInfo->rgExtension[index].Value.pbData,	// in
					m_pCertInfo->rgExtension[index].Value.cbData,	// in
					0,	// in
					(void *) &nameInfo,	// out
					&cbNameInfo);	// in/out
			dspAssert (bResult);
			if ( bResult )
			{
				//  We've found the right extension, now iterate through
				//	the alternate names until we find the desired type.
				for (DWORD	dwIndex = 0; dwIndex < nameInfo.cAltEntry; dwIndex++)
				{
					if ( nameInfo.rgAltEntry[dwIndex].dwAltNameChoice ==
							dwNameChoice )
					{
						if ( *ppszAltName )
							delete [] *ppszAltName;
						*ppszAltName = 
								new WCHAR[wcslen (nameInfo.rgAltEntry[dwIndex].pwszURL)+1];
						if ( *ppszAltName )
						{
							wcscpy (*ppszAltName, 
									nameInfo.rgAltEntry[dwIndex].pwszURL);
						}
						else
							hResult = E_OUTOFMEMORY;
						break;
					}
				}
			}
			else
				hResult = E_UNEXPECTED;
			break;
		}
		delete [] wcsObjId;
	}

	return hResult;
}



HCERTSTORE CCertificate::GetCertStore() const	
{
	return m_hCertStore;
}

PCCERT_CONTEXT CCertificate::GetCertContext() const
{
	return m_pCertContext;
}


HRESULT CCertificate::GetNameString (DWORD dwFlag, PWSTR* ppszNameOut)
{
	HRESULT	hResult = S_OK;
	dspAssert (ppszNameOut);
	if ( ppszNameOut )
	{
		DWORD	dwTypePara = CERT_SIMPLE_NAME_STR;
		DWORD	cchNameString = 0;
		DWORD	dwResult = ::CertGetNameString (m_pCertContext,
						CERT_NAME_SIMPLE_DISPLAY_TYPE, 
						dwFlag,
						&dwTypePara,
						NULL,
						cchNameString);
		if ( dwResult > 1 )
		{
			cchNameString = dwResult;
			if ( *ppszNameOut )
				delete [] *ppszNameOut;
			*ppszNameOut = new TCHAR[cchNameString];
			if ( *ppszNameOut )
			{
				dwResult = ::CertGetNameString (m_pCertContext,
								CERT_NAME_SIMPLE_DISPLAY_TYPE,
								dwFlag,
								&dwTypePara,
								*ppszNameOut,
								cchNameString);
				dspAssert (dwResult > 1);
				if ( dwResult <= 1 )
				{
					if ( !LoadStringToTchar (IDS_NOT_AVAILABLE, ppszNameOut) )
						hResult = E_FAIL;
				}
			}
			else 
				hResult = E_OUTOFMEMORY;
		}
		else
		{
			dwResult = ::CertGetNameString (m_pCertContext,
							CERT_NAME_EMAIL_TYPE,
							dwFlag,
							NULL,
							NULL,
							cchNameString);
			if ( dwResult > 1 )
			{
				cchNameString = dwResult;
		        if ( *ppszNameOut )
			        delete [] *ppszNameOut;
				*ppszNameOut = new TCHAR[cchNameString];
				if ( *ppszNameOut )
				{
					dwResult = ::CertGetNameString (m_pCertContext,
									CERT_NAME_EMAIL_TYPE,
									dwFlag,
									NULL,
									*ppszNameOut,
									cchNameString);
					dspAssert (dwResult > 1);
					if ( dwResult <= 1 )
					{
						if ( !LoadStringToTchar (IDS_NOT_AVAILABLE, ppszNameOut) )
							hResult = E_FAIL;
					}
				}
				else 
					hResult = E_OUTOFMEMORY;
			}
			else
			{
				if ( !LoadStringToTchar (IDS_NOT_AVAILABLE, ppszNameOut) )
					hResult = E_FAIL;
			}
		}
	}
	else
		hResult = E_POINTER;

	return hResult;
}


int CCertificate::CompareExpireDate(const CCertificate & cert) const
{
	int	compVal = 0;

	dspAssert (m_pCertInfo && cert.m_pCertInfo);
	if ( m_pCertInfo && cert.m_pCertInfo )
	{
		compVal = ::CompareFileTime (&m_pCertInfo->NotAfter, 
				&cert.m_pCertInfo->NotAfter);
	}

	return compVal;
}

HRESULT CCertificate::GetOIDInfo (PWSTR* ppszString, PSTR pszObjId)
{   
	HRESULT	hResult = S_OK;
	dspAssert (pszObjId && ppszString);
	if ( pszObjId && ppszString )
	{
		PCCRYPT_OID_INFO	pOIDInfo;
            
		pOIDInfo = ::CryptFindOIDInfo (CRYPT_OID_INFO_OID_KEY, (void *) pszObjId, 0);

		if ( pOIDInfo )
		{
			if ( *ppszString )
				delete [] *ppszString;
			*ppszString = new WCHAR[wcslen (pOIDInfo->pwszName)+1];
			if ( *ppszString )
			{
				wcscpy (*ppszString, pOIDInfo->pwszName);
			}
			else
				hResult = E_OUTOFMEMORY;
		}
		else
		{
			int nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, NULL, 0);
			dspAssert (nLen);
			if ( nLen )
			{
				if ( *ppszString )
					delete [] *ppszString;
				*ppszString = new WCHAR[nLen];
				if ( *ppszString )
				{
					nLen = ::MultiByteToWideChar (CP_ACP, 0, pszObjId, -1, 
							*ppszString, nLen);
					dspAssert (nLen);
					if ( !nLen )
						hResult = E_UNEXPECTED;
				}
				else
					hResult = E_OUTOFMEMORY;
			}
			else
				hResult = E_FAIL;
		}
	}
	else
		hResult = E_POINTER;

	return hResult;
}


///////////////////////////////////////////////////////////////////////////////
//	FormatDate ()
//
//	utcDateTime (IN)	-	A FILETIME in UTC format.
//	pszDateTime (OUT)	-	A string containing the local date and time 
//							formatted by locale and user preference
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CCertificate::FormatDate (FILETIME utcDateTime, PWSTR* ppszDateTime)
{
    dspAssert (ppszDateTime);
    if ( !ppszDateTime )
        return E_POINTER;
    //	Time is returned as UTC, will be displayed as local.  
    //	Use FileTimeToLocalFileTime () to make it local, 
    //	then call FileTimeToSystemTime () to convert to system time, then 
    //	format with GetDateFormat () and GetTimeFormat () to display 
    //	according to user and locale preferences	
    HRESULT		hResult = S_OK;
    FILETIME	localDateTime;


    BOOL bResult = FileTimeToLocalFileTime (
            &utcDateTime, // pointer to UTC file time to convert 
            &localDateTime); // pointer to converted file time 
    dspAssert (bResult);
    if ( bResult )
    {
        SYSTEMTIME	sysTime;

        bResult = FileTimeToSystemTime (
                &localDateTime, // pointer to file time to convert 
                &sysTime); // pointer to structure to receive system time 
        if ( bResult )
        {
            // Get date
            // Get length to allocate buffer of sufficient size
            int iLen = GetDateFormat (
                    LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
                    0, // flags specifying function options 
                    &sysTime, // date to be formatted 
                    0, // date format string 
                    0, // buffer for storing formatted string 
                    0); // size of buffer - 0 causes func to return required 
                        // buf len in TCHAR, inc. null terminator
            dspAssert (iLen > 0);
            if ( iLen > 0 )
            {
                *ppszDateTime = new WCHAR[iLen];
                if ( *ppszDateTime )
                {
                    int iResult = GetDateFormat (
                            LOCALE_USER_DEFAULT, // locale for which date is to be formatted 
                            0, // flags specifying function options 
                            &sysTime, // date to be formatted 
                            0, // date format string 
                            *ppszDateTime, // buffer for storing formatted string 
                            iLen); // size of buffer 
                    dspAssert (iResult);
                    if ( !iResult )
                        hResult = HRESULT_FROM_WIN32 (GetLastError ());
                }
                else
                    hResult = E_OUTOFMEMORY;
            }
            else
            {
                hResult = HRESULT_FROM_WIN32 (GetLastError ());
            }
        }
        else
        {
            hResult = HRESULT_FROM_WIN32 (GetLastError ());
        }
    }
    else
    {
        hResult = HRESULT_FROM_WIN32 (GetLastError ());
    }

    return hResult;
}


void CCertificate::Refresh()
{
	if ( m_szEnhancedKeyUsage )
    {
        delete [] m_szEnhancedKeyUsage;
        m_szEnhancedKeyUsage = 0;
    }
	if ( m_szAltSubjectName )
    {
        delete [] m_szAltSubjectName;
        m_szAltSubjectName = 0;
    }
	if ( m_szAltIssuerName )
    {
        delete [] m_szAltIssuerName;
        m_szAltIssuerName = 0;
    }
	if ( m_szValidNotAfter )
    {
        delete [] m_szValidNotAfter;
        m_szValidNotAfter = 0;
    }
	if ( m_szSubjectName )
    {
        delete [] m_szSubjectName;
        m_szSubjectName = 0;
    }
	if ( m_szIssuerName )
    {
        delete [] m_szIssuerName;
        m_szIssuerName = 0;
    }
}

HRESULT CCertificate::WriteToFile(HANDLE hFile)
{
	dspAssert (hFile && hFile != INVALID_HANDLE_VALUE && m_pCertContext);
	HRESULT	hResult = S_OK;

	if ( hFile && hFile != INVALID_HANDLE_VALUE && m_pCertContext )
	{
		DWORD	dwBytesWritten = 0;
		BOOL	bResult = ::WriteFile (hFile, 
					m_pCertContext->pbCertEncoded,  
					m_pCertContext->cbCertEncoded,  
					&dwBytesWritten,
					NULL);
		dspAssert (bResult && (dwBytesWritten == m_pCertContext->cbCertEncoded));
		if ( !bResult )
			hResult = E_FAIL;
	}
	else
		hResult = E_FAIL;

	return hResult;
}

BOOL CCertificate::DeleteFromStore()
{
	BOOL bResult = ::CertDeleteCertificateFromStore (m_pCertContext);
	if ( bResult )
	{
		// NB: PhilH says "CertDeleteCertificateFromStore (), always does an 
		// implicit CertFreeCertificateContext."
		// Can't set m_pCertContext to 0 because it is const - set this flag instead
		m_bCertContextFreed = true;
	}

	return bResult;
}

#endif // DSADMIN


bool CCertificate::CanDelete()
{
	if ( m_pCertContext && !(m_fieldChecked & FIELD_CAN_DELETE) )
	{	
		DWORD	dwAccessFlags = 0;
		DWORD	cbData = sizeof (DWORD);
		BOOL bResult = ::CertGetCertificateContextProperty (
				m_pCertContext,
				CERT_ACCESS_STATE_PROP_ID,
				&dwAccessFlags,
				&cbData);
		if ( bResult )
		{
			if ( dwAccessFlags & CERT_ACCESS_STATE_WRITE_PERSIST_FLAG )
				m_bCanDelete = true;
		}
		m_fieldChecked |= FIELD_CAN_DELETE;
    }

	return m_bCanDelete;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\chklist.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chklist.cxx
//
//--------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////
// CHKLIST.CXX
//
// This file contains the implementation of the CheckList control.
//
// HISTORY
// 26-Sep-96	JefferyS	Creation of chklist.cpp.
// 23-Jul-97	t-danm		Copied from \nt\private\windows\shell\security\aclui\chklist.cpp
//							and adapted to MFC project.
// 27-Jul-97	t-danm		Created all CheckList_* wrappers.
// 28-Jul-97	t-danm		Added CLS_LEFTALIGN and CLS_EXTENDEDTEXT styles.
// 30-Nov-99  JeffJon   Added CLS_3STATE style
//
/////////////////////////////////////////////////////////////////////

#include "pch.h"
#include "chklist.h"

// The following are wrappers to make the code compile
#define TraceEnter(f, sz)
#define TraceLeaveVoid()
#define TraceLeaveValue(v)	return v
#define TraceAssert(f)		dspAssert(f)

extern HINSTANCE g_hInstance;

//
// Default dimensions for child controls. All are in dialog units.
// Currently only the column width is user-adjustable (via the
// CLM_SETCOLUMNWIDTH message).
//
#define DEFAULT_COLUMN_WIDTH    28
#define DEFAULT_CHECK_WIDTH     8
#define DEFAULT_HORZ_SPACE      7
#define DEFAULT_VERTICAL_SPACE  3
#define DEFAULT_ITEM_HEIGHT     8


//
// 16 bits are used for the control ID's, divided into n bits for
// the subitem (least significant) and 16-n bits for the item index.
//
// ID_SUBITEM_BITS can be adjusted to control the maximum number of
// items and subitems. For example, to allow up to 7 subitems and 8k
// items, set ID_SUBITEM_BITS to 3.
// 

// Use the low 2 bits for the subitem index, the rest for the item index.
// (4 subitems max, 16k items max)
#define ID_SUBITEM_BITS         2

#define ID_SUBITEM_MASK         ((1 << ID_SUBITEM_BITS) - 1)
#define GET_ITEM(id)            ((id) >> ID_SUBITEM_BITS)
#define GET_SUBITEM(id)         ((id) & ID_SUBITEM_MASK)

#define MAKE_CTRL_ID(i, s)      (0xffff & (((i) << ID_SUBITEM_BITS) | ((s) & ID_SUBITEM_MASK)))
#define MAKE_LABEL_ID(i)        MAKE_CTRL_ID(i, 0)
// Note that the subitem (column) index is one-based for the checkboxes
// (the zero column is the label).  The item (row) index is zero-based.

#define MAX_CHECK_COLUMNS       ID_SUBITEM_MASK

/////////////////////////////////////////////////////////////////////
// Compute the number extra pixel to set the position of the
// checkbox to provide a better UI.
int ComputeCheckboxExtraCy(DWORD dwStyle)
	{
	if (dwStyle & CLS_LEFTALIGN)
		return 0;
	return 2;
	}

/////////////////////////////////////////////////////////////////////
class CCheckList
{
private:
    LONG m_cItems;
    LONG m_cSubItems;
    RECT m_rcItemLabel;
    LONG m_rgxCheckPos[MAX_CHECK_COLUMNS];
    LONG m_cxCheckBox;	// Width of a checkbox item
	LONG m_cyCheckBox;	// Height of a checkbox item

    HWND    m_hwndCheckFocus;
    HBRUSH  m_hbrCheckPattern;
    HFONT   m_hFont;

private:
    CCheckList(HWND hWnd, LPCREATESTRUCT lpcs);
    ~CCheckList();

    LRESULT MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl);
    void MsgPaint(HWND hWnd, HDC hdc);
    void MsgVScroll(HWND hWnd, int nCode, int nPos);
    void MsgEnable(HWND hWnd, BOOL fEnabled);

    LONG AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam);
    void SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState);
    LONG GetState(HWND hWnd, WORD iItem, WORD iSubItem);
    void SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn);
    void ResetContent(HWND hWnd);
    LONG GetVisibleCount(HWND hWnd);
    LONG GetTopIndex(HWND hWnd);
    void SetTopIndex(HWND hWnd, LONG nIndex)
    { MsgVScroll(hWnd, SB_THUMBPOSITION, nIndex * m_rcItemLabel.bottom); }
    void EnsureVisible(HWND hWnd, LONG nIndex);
    void DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw = FALSE);

public:
    static LRESULT CALLBACK WindowProc(HWND hWnd,
                                       UINT uMsg,
                                       WPARAM wParam,
                                       LPARAM lParam);
}; // CCheckList


/////////////////////////////////////////////////////////////////////
void RegisterCheckListWndClass()
{
	WNDCLASS wc = { 0 };
    wc.lpfnWndProc      = CCheckList::WindowProc;
    wc.hInstance        = g_hInstance;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH)(COLOR_3DFACE + 1);
    wc.lpszClassName    = WC_CHECKLIST;
    (void)::RegisterClass(&wc);
}


/////////////////////////////////////////////////////////////////////
CCheckList::CCheckList(HWND hWnd, LPCREATESTRUCT lpcs)
{
    TraceEnter(TRACE_CHECKLIST, "CCheckList::CCheckList");
    TraceAssert(hWnd != NULL);
    TraceAssert(lpcs != NULL);

	memset(OUT this, 0, sizeof(*this));	// Initialize everything to zeroes

    //
    // Create a pattern brush to use for drawing a focus rect
    // around the check boxes.  This is a checkerboard pattern
    // with every other pixel turned on.
    //
    static const BYTE bits[] = {
					0x55, 0x00,
                    0xaa, 0x00,
                    0x55, 0x00,
                    0xaa, 0x00,
                    0x55, 0x00,
                    0xaa, 0x00,
                    0x55, 0x00,
                    0xaa, 0x00 };

    HBITMAP hbm = CreateBitmap(8, 8, 1, 1, bits);
    if (hbm)
    {
        m_hbrCheckPattern = CreatePatternBrush(hbm);
        DeleteObject(hbm);
    }

    //
    // Get number of check columns
    //
    m_cSubItems = lpcs->style & CLS_3CHECK;

    // If only 1 column, don't allow radio button style.
    if (m_cSubItems == 1)
		{
        lpcs->style &= ~(CLS_RADIOBUTTON | CLS_AUTORADIOBUTTON);
		}

    //
    // Convert default coordinates from dialog units to pixels
    //
    RECT rc;
    rc.left = DEFAULT_CHECK_WIDTH;
    rc.right = DEFAULT_COLUMN_WIDTH;
	rc.top = 0;
	rc.bottom = DEFAULT_ITEM_HEIGHT;
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_cxCheckBox = rc.left;
	m_cyCheckBox = rc.bottom;
    LONG cxCheckColumn = rc.right;

    rc.left = DEFAULT_HORZ_SPACE;
    rc.top = DEFAULT_VERTICAL_SPACE;
    rc.bottom = DEFAULT_VERTICAL_SPACE + DEFAULT_ITEM_HEIGHT;
	if (lpcs->style & CLS_EXTENDEDTEXT)
		rc.bottom += DEFAULT_ITEM_HEIGHT;	// Add one more item height
    MapDialogRect(lpcs->hwndParent, &rc);

    // Save the converted values
    m_rcItemLabel = rc;

    // SetColumnWidth calculates m_rgxCheckPos and m_rcItemLabel.right.
    // Note that it makes use of m_cSubItems, m_cxCheckBox (set above)
    // and also uses the other m_rcItemLabel values if m_cItems is
    // nonzero (it's 0 here).
    SetColumnWidth(hWnd, lpcs->cx, cxCheckColumn);

    // Hide the scroll bar (no controls yet)
    SetScrollRange(hWnd, SB_VERT, 0, 0, FALSE);

    TraceLeaveVoid();
}


CCheckList::~CCheckList()
{
    if (m_hbrCheckPattern != NULL)
        DeleteObject(m_hbrCheckPattern);
}


LRESULT CCheckList::MsgCommand(HWND hWnd, WORD idCmd, WORD wNotify, HWND hwndCtrl)
{
  DWORD dwStyle;
  DWORD dwState;

  TraceEnter(TRACE_CHECKLIST, "CCheckList::MsgCommand");

  // Should only get notifications from visible, enabled, check boxes
  TraceAssert(GET_ITEM(idCmd) < m_cItems);
  TraceAssert(0 < GET_SUBITEM(idCmd) && GET_SUBITEM(idCmd) <= m_cSubItems);
  TraceAssert(hwndCtrl && IsWindowEnabled(hwndCtrl));

  switch (wNotify)
  {
    case BN_CLICKED:
      dwStyle = (DWORD)GetWindowLongPtr(hWnd, GWL_STYLE);
      dwState = (DWORD)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);

      if (dwStyle & CLS_RADIOBUTTON)
      {
        // Toggle the check state of non-automatic radio buttons here.
        // This overrides the normal radio button behavior to allow
        // unchecking them.
        dwState ^= CLST_CHECKED;
        SendMessage(hwndCtrl, BM_SETCHECK, dwState & CLST_CHECKED, 0);
      }
      else if (dwStyle & CLS_3STATE)
      {
        if (dwState & BST_INDETERMINATE)
        {
          dwState ^= BST_INDETERMINATE;
        }
        dwState ^= CLST_CHECKED;
        SendMessage(hwndCtrl, BM_SETCHECK, dwState, 0);
      }
      {
        NM_CHECKLIST nmc;
        nmc.hdr.hwndFrom = hWnd;
        nmc.hdr.idFrom = GetDlgCtrlID(hWnd);
        nmc.hdr.code = CLN_CLICK;
        nmc.iItem = GET_ITEM(idCmd);
        nmc.iSubItem = GET_SUBITEM(idCmd);
        nmc.dwState = dwState;
        if (!IsWindowEnabled(hwndCtrl))
            nmc.dwState |= CLST_DISABLED;
        nmc.dwItemData = GetWindowLongPtr(GetDlgItem(hWnd, MAKE_LABEL_ID(nmc.iItem)),
                                       GWLP_USERDATA);

	// Notify the parent about the event
        SendMessage(GetParent(hWnd),
                    WM_NOTIFY,
                    nmc.hdr.idFrom,
                    (LPARAM)&nmc);
      }
      break;

    case BN_SETFOCUS:
      if (m_hwndCheckFocus != hwndCtrl)   // Has the focus moved?
      {
        // Remember where the focus is
        m_hwndCheckFocus = hwndCtrl;
        // Make sure the row is scrolled into view
        EnsureVisible(hWnd, GET_ITEM(idCmd));
      }
      // Always draw the focus rect
      DrawCheckFocusRect(hWnd, hwndCtrl, TRUE);
      break;

    case BN_KILLFOCUS:
      // Remove the focus rect
      m_hwndCheckFocus = NULL;
      DrawCheckFocusRect(hWnd, hwndCtrl);
      break;
  }

  TraceLeaveValue(0);
}


void
CCheckList::MsgPaint(HWND hWnd, HDC hdc)
{
    if (hdc == NULL && m_hwndCheckFocus != NULL)
    {
        // This will cause a focus rect to be drawn after the window and
        // all checkboxes have been painted.
        PostMessage(hWnd,
                    WM_COMMAND,
                    GET_WM_COMMAND_MPS(GetDlgCtrlID(m_hwndCheckFocus), m_hwndCheckFocus, BN_SETFOCUS));
    }

    // Default paint
    DefWindowProc(hWnd, WM_PAINT, (WPARAM)hdc, 0);
}


void
CCheckList::MsgVScroll(HWND hWnd, int nCode, int nPos)
{
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;

    if (!GetScrollInfo(hWnd, SB_VERT, &si))
        return;

    // One page is always visible, so adjust the range to a more useful value
    si.nMax -= si.nPage - 1;

    switch (nCode)
    {
    case SB_LINEUP:
        // "line" is the height of one item (includes the space in between)
        nPos = si.nPos - m_rcItemLabel.bottom;
        break;

    case SB_LINEDOWN:
        nPos = si.nPos + m_rcItemLabel.bottom;
        break;

    case SB_PAGEUP:
        nPos = si.nPos - si.nPage;
        break;

    case SB_PAGEDOWN:
        nPos = si.nPos + si.nPage;
        break;

    case SB_TOP:
        nPos = si.nMin;
        break;

    case SB_BOTTOM:
        nPos = si.nMax;
        break;

    case SB_ENDSCROLL:
        nPos = si.nPos;     // don't go anywhere
        break;

    case SB_THUMBTRACK:
        // Do nothing here to allow tracking
        // nPos = si.nPos;    // Do this to prevent tracking
    case SB_THUMBPOSITION:
        // nothing to do here... nPos is passed in
        break;
    }

    // Make sure the new position is within the range
    if (nPos < si.nMin)
        nPos = si.nMin;
    else if (nPos > si.nMax)
        nPos = si.nMax;

    if (nPos != si.nPos)  // are we moving?
    {
        SetScrollPos(hWnd, SB_VERT, nPos, TRUE);
        ScrollWindow(hWnd, 0, si.nPos - nPos, NULL, NULL);
    }
}


void CCheckList::MsgEnable(HWND hWnd, BOOL fEnabled)
{
  for (LONG i = 0; i < m_cItems; i++)
  {
    for (LONG j = 0; j <= m_cSubItems; j++)
    {
      EnableWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)), fEnabled);
    }
  }
	DWORD_PTR dwStyle = GetWindowLongPtr(hWnd, GWL_STYLE);
	dwStyle &= ~WS_DISABLED;	// Turn off the disabled style
	SetWindowLongPtr(hWnd, GWL_STYLE, (LONG_PTR)dwStyle);
}


LONG CCheckList::AddItem(HWND hWnd, LPCTSTR pszLabel, LPARAM lParam)
{
  DWORD dwChkListStyle;
  DWORD dwButtonStyle = WS_CHILD | WS_VISIBLE | WS_TABSTOP | BS_NOTIFY;
  HWND hwndNew;
  HWND hwndPrev;
  RECT rc;
  LONG cyOffset;

  TraceEnter(TRACE_CHECKLIST, "CCheckList::AddItem");
  TraceAssert(hWnd != NULL);
  TraceAssert(pszLabel != NULL && !IsBadStringPtr(pszLabel, MAX_PATH));

  dwChkListStyle = (DWORD)GetWindowLongPtr(hWnd, GWL_STYLE);

  if (dwChkListStyle & CLS_AUTORADIOBUTTON)
    dwButtonStyle |= BS_AUTORADIOBUTTON;
  else if (dwChkListStyle & CLS_RADIOBUTTON)
    dwButtonStyle |= BS_RADIOBUTTON;
  else if (dwChkListStyle & CLS_3STATE)
    dwButtonStyle |= BS_3STATE;
  else
    dwButtonStyle |= BS_AUTOCHECKBOX;

  // Calculate the position of the new static label
  rc = m_rcItemLabel;
  cyOffset = m_cItems * rc.bottom;
  OffsetRect(&rc, 0, cyOffset);

  INT_PTR intPtr = static_cast<INT_PTR>(MAKE_LABEL_ID(m_cItems));
  HMENU hMenu = reinterpret_cast<HMENU>(intPtr);

  // Create a new label control
  hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                             TEXT("STATIC"),
                             pszLabel,
                             WS_CHILD | WS_VISIBLE | WS_GROUP | SS_NOPREFIX,
                             rc.left,
                             rc.top,
                             rc.right - rc.left,
                             rc.bottom - rc.top,
                             hWnd,
                             hMenu,
                             g_hInstance,
                             NULL);
  if (!hwndNew)
  {
    TraceLeaveValue(-1);
  }

  // Save item data
  SetWindowLongPtr(hwndNew, GWLP_USERDATA, lParam);

  // Set the font if we have one
  if (m_hFont)
  {
    SendMessage(hwndNew, WM_SETFONT, (WPARAM)m_hFont, 0);
  }

  // Set Z-order position just after the last checkbox. This keeps
  // tab order correct.
  if (m_cItems > 0)
  {
    hwndPrev = GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems - 1, m_cSubItems));
//        hwndPrev = GetWindow(hwndNew, GW_HWNDLAST);
//        if (hwndPrev != hwndNew)
        SetWindowPos(hwndNew,
                     hwndPrev,
                     0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
  }

  // Create new checkboxes
  for (LONG j = 0; j < m_cSubItems; j++)
  {
    INT_PTR intPtrToo = static_cast<INT_PTR>(MAKE_CTRL_ID(m_cItems, j + 1));
    HMENU hMenuToo = reinterpret_cast<HMENU>(intPtrToo);

    hwndPrev = hwndNew;
    hwndNew = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                             TEXT("BUTTON"),
                             NULL,
                             dwButtonStyle,
                             m_rgxCheckPos[j],
                             rc.top + ComputeCheckboxExtraCy(dwChkListStyle),
                             m_cxCheckBox,
						                 m_cyCheckBox,
                             hWnd,
                             hMenuToo,
                             g_hInstance,
                             NULL);
    if (!hwndNew)
    {
      while (j >= 0)
      {
        DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(m_cItems, j)));
        j--;
      }

      TraceLeaveValue(-1);
    }

    SetWindowPos(hwndNew,
                 hwndPrev,
                 0, 0, 0, 0,
                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
  }

  //
  // The last thing is to calculate the scroll range
  //
  GetClientRect(hWnd, &rc);

  if (m_rcItemLabel.bottom + cyOffset > rc.bottom) // Is the bottom control visible?
  {
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    si.nMin = 0;
    si.nMax = m_rcItemLabel.bottom + cyOffset + m_rcItemLabel.top;
    si.nPage = rc.bottom;                       // ^^^^^^^^^ extra space
    si.nPos = 0;

    SetScrollInfo(hWnd, SB_VERT, &si, FALSE);
  }

  TraceLeaveValue(m_cItems++);
}


void
CCheckList::SetState(HWND hWnd, WORD iItem, WORD iSubItem, LONG lState)
{
  TraceEnter(TRACE_CHECKLIST, "CCheckList::SetState");
  TraceAssert(hWnd != NULL);
  TraceAssert(iItem < m_cItems);
  TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

  HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));
  if (hwndCtrl != NULL)
  {
    LONG_PTR dwStyle = GetWindowLongPtr(hWnd, GWL_STYLE);
    if ((dwStyle & CLS_AUTORADIOBUTTON)
        && (lState & CLST_CHECKED))
    {
      CheckRadioButton(hWnd,
                       MAKE_CTRL_ID(iItem, 1),
                       MAKE_CTRL_ID(iItem, m_cSubItems),
                       MAKE_CTRL_ID(iItem, iSubItem));
      EnableWindow(hwndCtrl, !(lState & CLST_DISABLED));
    }
    else if (dwStyle & CLS_3STATE)
    {
      SendMessage(hwndCtrl, BM_SETCHECK, lState, 0);
    }
    else
    {
      SendMessage(hwndCtrl, BM_SETCHECK, lState & CLST_CHECKED, 0);
      EnableWindow(hwndCtrl, !(lState & CLST_DISABLED));
    }
  }

//    TraceLeaveValue(lPrevState);
  TraceLeaveVoid();
}


LONG CCheckList::GetState(HWND hWnd, WORD iItem, WORD iSubItem)
{
  LONG lState = 0;

  TraceEnter(TRACE_CHECKLIST, "CCheckList::GetState");
  TraceAssert(hWnd != NULL);
  TraceAssert(iItem < m_cItems);
  TraceAssert(0 < iSubItem && iSubItem <= m_cSubItems);

  HWND hwndCtrl = GetDlgItem(hWnd, MAKE_CTRL_ID(iItem, iSubItem));

  if (hwndCtrl != NULL)
  {
    lState = (LONG)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);

    if (!IsWindowEnabled(hwndCtrl))
      lState |= CLST_DISABLED;
  }
  TraceLeaveValue(lState);
}


void
CCheckList::SetColumnWidth(HWND hWnd, LONG cxDialog, LONG cxColumn)
	{
    LONG j;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::SetColumnWidth");
    TraceAssert(hWnd != NULL);
    TraceAssert(cxColumn > 10);

	DWORD dwChkListStyle = (DWORD)GetWindowLongPtr(hWnd, GWL_STYLE);
    if (m_cSubItems > 0)
		{
		if (dwChkListStyle & CLS_LEFTALIGN)
			{
			// Put the checkboxes at the left of the text
			int xSubItem = m_rcItemLabel.left;
			for (j = 0; j < m_cSubItems; j++, xSubItem += cxColumn)
				m_rgxCheckPos[j] = xSubItem;
			m_rcItemLabel.left = xSubItem - (cxColumn + m_cxCheckBox)/2;
			m_rcItemLabel.right = cxDialog - m_rcItemLabel.left;
			}
		else
			{
			// Put the checkboxes at the right of the text
			m_rgxCheckPos[m_cSubItems-1] = cxDialog                       // dlg width
										- m_rcItemLabel.left            // right margin
										- (cxColumn + m_cxCheckBox)/2;  // 1/2 col & 1/2 checkbox
			for (j = m_cSubItems - 1; j > 0; j--)
				m_rgxCheckPos[j-1] = m_rgxCheckPos[j] - cxColumn;
			//              (leftmost check pos) - (horz margin)
			m_rcItemLabel.right = m_rgxCheckPos[0] - m_rcItemLabel.left;
			} // if...else
		}
    else
		{
        m_rcItemLabel.right = cxDialog - m_rcItemLabel.left;
		}

    LONG nTop = m_rcItemLabel.top;
    LONG nBottom = m_rcItemLabel.bottom;

	// Move each item in the checklist
    for (LONG i = 0; i < m_cItems; i++)
		{
        MoveWindow(GetDlgItem(hWnd, MAKE_LABEL_ID(i)),
                   m_rcItemLabel.left,
                   nTop,
                   m_rcItemLabel.right - m_rcItemLabel.left,
                   nBottom - nTop,
                   FALSE);

		// Move each checkbox
        for (j = 0; j < m_cSubItems; j++)
			{
		    MoveWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j + 1)),
                       m_rgxCheckPos[j],
                       nTop + ComputeCheckboxExtraCy(dwChkListStyle),
                       m_cxCheckBox,
                       m_cyCheckBox,
                       FALSE);
			}
        nTop += m_rcItemLabel.bottom;
        nBottom += m_rcItemLabel.bottom;
		} // for
    TraceLeaveVoid();
	} // SetColumnWidth()


void
CCheckList::ResetContent(HWND hWnd)
{
    for (LONG i = 0; i < m_cItems; i++)
        for (LONG j = 0; j <= m_cSubItems; j++)
            DestroyWindow(GetDlgItem(hWnd, MAKE_CTRL_ID(i, j)));

    // Hide the scroll bar
    SetScrollRange(hWnd, SB_VERT, 0, 0, FALSE);
    m_cItems = 0;
}


LONG
CCheckList::GetVisibleCount(HWND hWnd)
{
    LONG nCount = 1;
    RECT rc;

    if (GetClientRect(hWnd, &rc) && m_rcItemLabel.bottom > 0)
        nCount = max(1, rc.bottom / m_rcItemLabel.bottom);

    return nCount;
}


LONG
CCheckList::GetTopIndex(HWND hWnd)
{
    LONG nIndex = 0;
    SCROLLINFO si;
    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;

    if (GetScrollInfo(hWnd, SB_VERT, &si) && m_rcItemLabel.bottom > 0)
        nIndex = max(0, si.nPos / m_rcItemLabel.bottom);

    return nIndex;
}


void
CCheckList::EnsureVisible(HWND hWnd, LONG nItemIndex)
{
    LONG nTopIndex = GetTopIndex(hWnd);

    if (nItemIndex < nTopIndex)
    {
        SetTopIndex(hWnd, nItemIndex);
    }
    else
    {
        LONG nVisible = GetVisibleCount(hWnd);

        if (nItemIndex >= nTopIndex + nVisible)
            SetTopIndex(hWnd, nItemIndex - nVisible + 1);
    }
}


void
CCheckList::DrawCheckFocusRect(HWND hWnd, HWND hwndCheck, BOOL fDraw)
{
    RECT rcCheck;
    HDC hdc;

    TraceEnter(TRACE_CHECKLIST, "CCheckList::DrawCheckFocusRect");
    TraceAssert(hWnd != NULL);
    TraceAssert(hwndCheck != NULL);

    GetWindowRect(hwndCheck, &rcCheck);
    MapWindowPoints(NULL, hWnd, (LPPOINT)&rcCheck, 2);
    InflateRect(&rcCheck, 2, 2);    // draw *outside* the checkbox

    hdc = GetDC(hWnd);
    if (hdc)
    {
        // Always erase before drawing, since we may already be
        // partially visible and drawing is an XOR operation.
        // (Don't want to leave any turds on the screen.)

        FrameRect(hdc, &rcCheck, GetSysColorBrush(COLOR_3DFACE));

        if (fDraw)
        {
            if (m_hbrCheckPattern)
            {
                COLORREF crText = SetTextColor(hdc, RGB(0,0,0));
                COLORREF crBack = SetBkColor(hdc, GetSysColor(COLOR_3DFACE));
                FrameRect(hdc, &rcCheck, m_hbrCheckPattern);
                SetTextColor(hdc, crText);
                SetBkColor(hdc, crBack);
            }
            else
                DrawFocusRect(hdc, &rcCheck);
        }
        ReleaseDC(hWnd, hdc);
    }

    TraceLeaveVoid();
}


LRESULT
CALLBACK
CCheckList::WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    CCheckList *pThis = (CCheckList*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    TraceEnter(TRACE_CHECKLIST, "CCheckList::WindowProc");
    TraceAssert(hWnd != NULL);

    switch (uMsg)
    {
    case WM_NCCREATE:
        pThis = new CCheckList(hWnd, (LPCREATESTRUCT)lParam);
        if (pThis != NULL)
        {
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pThis);
            lResult = TRUE;
        }
        break;

    case WM_NCDESTROY:
        delete pThis;
        break;

    case WM_COMMAND:
        TraceAssert(pThis != NULL);
        lResult = pThis->MsgCommand(hWnd,
                                    GET_WM_COMMAND_ID(wParam, lParam),
                                    GET_WM_COMMAND_CMD(wParam, lParam),
                                    GET_WM_COMMAND_HWND(wParam, lParam));
        break;

    case WM_PAINT:
        TraceAssert(pThis != NULL);
        pThis->MsgPaint(hWnd, (HDC)wParam);
        break;

    case WM_VSCROLL:
        TraceAssert(pThis != NULL);
        pThis->MsgVScroll(hWnd,
                          (int)(short)GET_WM_VSCROLL_CODE(wParam, lParam),
                          (int)(short)GET_WM_VSCROLL_POS(wParam, lParam));
        break;

    case WM_ENABLE:
        TraceAssert(pThis != NULL);
        pThis->MsgEnable(hWnd, (BOOL)wParam);
        break;

    case WM_SETFONT:
        TraceAssert(pThis != NULL);
        pThis->m_hFont = (HFONT)wParam;
        {
            for (LONG i = 0; i < pThis->m_cItems; i++)
                SendDlgItemMessage(hWnd,
                                   MAKE_LABEL_ID(i),
                                   WM_SETFONT,
                                   wParam,
                                   lParam);
        }
        break;

    case WM_GETFONT:
        TraceAssert(pThis != NULL);
        lResult = (LRESULT)pThis->m_hFont;
        break;

    case CLM_ADDITEM:
        TraceAssert(pThis != NULL);
        lResult = pThis->AddItem(hWnd, (LPCTSTR)wParam, lParam);
        break;

    case CLM_GETITEMCOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->m_cItems;
        break;

    case CLM_SETSTATE:
        TraceAssert(pThis != NULL);
        pThis->SetState(hWnd, LOWORD(wParam), HIWORD(wParam), (LONG)lParam);
        break;

    case CLM_GETSTATE:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetState(hWnd, LOWORD(wParam), HIWORD(wParam));
        break;

    case CLM_SETCOLUMNWIDTH:
        TraceAssert(pThis != NULL);
        {
            RECT rc;
            LONG cxDialog;

            GetClientRect(hWnd, &rc);
            cxDialog = rc.right;

            rc.right = (LONG)lParam;
            MapDialogRect(GetParent(hWnd), &rc);

            pThis->SetColumnWidth(hWnd, cxDialog, rc.right);
        }
        break;

    case CLM_SETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        SetWindowLongPtr(GetDlgItem(hWnd, (int)MAKE_LABEL_ID(wParam)),
                      GWLP_USERDATA,
                      lParam);
        break;

    case CLM_GETITEMDATA:
        TraceAssert(GET_ITEM(wParam) < (ULONG)pThis->m_cItems);
        lResult = GetWindowLongPtr(GetDlgItem(hWnd, (int)MAKE_LABEL_ID(wParam)),
                                GWLP_USERDATA);
        break;

    case CLM_RESETCONTENT:
        TraceAssert(pThis != NULL);
        pThis->ResetContent(hWnd);
        break;

    case CLM_GETVISIBLECOUNT:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetVisibleCount(hWnd);
        break;

    case CLM_GETTOPINDEX:
        TraceAssert(pThis != NULL);
        lResult = pThis->GetTopIndex(hWnd);
        break;

    case CLM_SETTOPINDEX:
        TraceAssert(pThis != NULL);
        pThis->SetTopIndex(hWnd, (LONG)wParam);
        break;

    case CLM_ENSUREVISIBLE:
        TraceAssert(pThis != NULL);
        pThis->EnsureVisible(hWnd, (LONG)wParam);
        break;

    default:
        lResult = DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    TraceLeaveValue(lResult);
}


/////////////////////////////////////////////////////////////////////
//	CheckList_AddItem()
//
//	Add one item to the checklist control and optionally
//	check the checkbox of that item.
//
//	Returns the index of the new item if successful or -1 otherwise.
//
int
CheckList_AddItem(HWND hwndChecklist, LPCTSTR pszLabel, LPARAM lParam, BOOL fCheckItem)
{
	dspAssert(::IsWindow(hwndChecklist));
	int iItem = (int)::SendMessage(hwndChecklist, CLM_ADDITEM, (WPARAM)pszLabel, lParam);
	dspAssert(iItem >= 0);
	if (fCheckItem)
	{
		CheckList_SetItemCheck(hwndChecklist, iItem, fCheckItem);
	}
	return iItem;
} // CheckList_AddItem()


/////////////////////////////////////////////////////////////////////
//	CheckList_AddString()
//
//	Load a string from the resource and add it to the checklist control.
//
//	Returns the index of the new item if successful or -1 otherwise.
//
//	REMARKS
//	The routine will set the lParam to the string Id.
//
int
CheckList_AddString(HWND hwndChecklist, UINT uStringId, BOOL fCheckItem)
	{
	dspAssert(::IsWindow(hwndChecklist));
	TCHAR szT[1024];
	int cch = ::LoadString(g_hInstance, uStringId, OUT szT, ARRAYLENGTH(szT));
	dspAssert(cch > 0 && "String not found");
	dspAssert((cch < ARRAYLENGTH(szT) - 10) && "Buffer too small");
	int iItem = (int)::SendMessage(hwndChecklist, CLM_ADDITEM, (WPARAM)szT, uStringId);
	dspAssert(iItem >= 0);
	if (fCheckItem)
		{
		CheckList_SetItemCheck(hwndChecklist, iItem, fCheckItem);
		}
	return iItem;
	} // CheckList_AddString()


/////////////////////////////////////////////////////////////////////
//	CheckList_SetItemCheck()
//
//	Set the state of a checkbox item.
//		fCheckItem == TRUE => Check the checkbox item
//		fCheckItem == FALSE => Uncheck the checkbox item
//		fCheckItem == BST_INDETERMINATE => Checkbox is grayed, indicating an indeterminate state.
//
void
CheckList_SetItemCheck(HWND hwndChecklist, int iItem, BOOL fCheckItem, int iColumn)
	{
	dspAssert(::IsWindow(hwndChecklist));
	dspAssert(iItem >= 0);
	dspAssert(iColumn >= 1);
	(void)::SendMessage(hwndChecklist, CLM_SETSTATE, MAKELONG(iItem, iColumn), fCheckItem);
	} // CheckList_SetItemCheck()


/////////////////////////////////////////////////////////////////////
//	CheckList_GetItemCheck()
//
//	Return the state of the checkbox item.
//		BST_UNCHECKED == 0
//		BST_CHECKED == 1
//		BST_INDETERMINATE == 2
//
int
CheckList_GetItemCheck(HWND hwndChecklist, int iItem, int iColumn)
	{
	dspAssert(::IsWindow(hwndChecklist));
	dspAssert(iItem >= 0);
	dspAssert(iColumn >= 1);
	return (int)::SendMessage(hwndChecklist, CLM_GETSTATE, MAKELONG(iItem, iColumn), 0);
	} // CheckList_GetItemCheck()


/////////////////////////////////////////////////////////////////////
//	CheckList_GetLParamCheck()
//
//	Searches the list of items for the matching lParam and return
//	the state of that item.
//
//	Return -1 if no matching lParam.
//
int CheckList_GetLParamCheck(HWND hwndChecklist, LPARAM lParam, int iColumn)
{
	dspAssert(::IsWindow(hwndChecklist));
	dspAssert(iColumn >= 1);
	int iItem = CheckList_FindLParamItem(hwndChecklist, lParam);
	if (iItem < 0)
  {
		dspAssert(FALSE && "Item not found");
		return -1;
	}
	return (int)::SendMessage(hwndChecklist, CLM_GETSTATE, MAKELONG(iItem, iColumn), 0);
} // CheckList_GetLParamCheck()


/////////////////////////////////////////////////////////////////////
//	CheckList_SetLParamCheck()
//
//	Searches the list of items for the matching lParam and set
//	the state of that item.
//
void
CheckList_SetLParamCheck(HWND hwndChecklist, LPARAM lParam, BOOL fCheckItem, int iColumn)
	{
	dspAssert(::IsWindow(hwndChecklist));
	dspAssert(iColumn >= 1);
	int iItem = CheckList_FindLParamItem(hwndChecklist, lParam);
	dspAssert(iItem >= 0);
	(void)::SendMessage(hwndChecklist, CLM_SETSTATE, MAKELONG(iItem, iColumn), fCheckItem);
	} // CheckList_SetLParamCheck()


/////////////////////////////////////////////////////////////////////
//	CheckList_FindLParamItem()
//
//	Return the index of the item matching lParam.
//	If no matches found return -1.
//
//	REMARKS
//	Each item should have a unique lParam, otherwise the search
//	will return the first matching lParam.
//
int
CheckList_FindLParamItem(HWND hwndChecklist, LPARAM lParam)
	{
	dspAssert(::IsWindow(hwndChecklist));
	int cItemCount = (int)::SendMessage(hwndChecklist, CLM_GETITEMCOUNT, 0, 0);
	dspAssert(cItemCount >= 0);
	for (int iItem = 0; iItem < cItemCount; iItem++)
		{
		if (lParam == ::SendMessage(hwndChecklist, CLM_GETITEMDATA, iItem, 0))
			{
			return iItem;
			}
		}
	return -1;
	} // CheckList_FindLParamItem()


/////////////////////////////////////////////////////////////////////
//	CheckList_EnableWindow()
//
//	Send a WM_ENABLE message to the checklist control.
//
//	REMARKS
//	The user should NOT use EnableWindow() to disable the checklist
//	control because it will prevent the checklist control to scroll
//	when disable.
//	The routine CheckList_EnableWindow() will disable all the
//	checkboxes inside the control but will allow the control to scroll.
//
void
CheckList_EnableWindow(HWND hwndChecklist, BOOL fEnableWindow)
	{
	dspAssert(::IsWindow(hwndChecklist));
	(void)::SendMessage(hwndChecklist, WM_ENABLE, fEnableWindow, 0);
	} // CheckList_EnableWindow()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\certifct.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       certifct.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#ifndef __CERTIFICT_H
#define __CERTIFICT_H

#include "wincrypt.h"

#define MY_ENCODING_TYPE (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING)

/////////////////////////////////////////////////////////////////////////////
// CCertificate

class CCertificate
{
public:
	CCertificate(const PCCERT_CONTEXT pCertContext, HCERTSTORE hCertStore);
	virtual ~CCertificate();


public:
	bool CanDelete();
	BOOL DeleteFromStore ();
	HRESULT WriteToFile (HANDLE hFile);
	void Refresh ();
	int CompareExpireDate (const CCertificate& cert) const;
	BOOL IsMyStore () const;
	PCCERT_CONTEXT GetCertContext () const;
	HCERTSTORE GetCertStore () const;
	HRESULT GetAlternateSubjectName (PWSTR* ppszAltIssuerName);
	HRESULT GetAlternateIssuerName (PWSTR* ppszAltIssuerName);
	HRESULT GetEnhancedKeyUsage (PWSTR* ppszUsages);
	HRESULT GetValidNotAfter (PWSTR* pszValidNotAfter);
	HRESULT GetSubjectName (PWSTR *ppszSubjectName);
	HRESULT GetIssuerName (PWSTR *ppszIssuerName);

private:
	HRESULT FormatEnhancedKeyUsagePropertyString ();
	HRESULT ConvertAltNameToString (PWSTR szOID, const DWORD dwNameChoice, PWSTR* ppszAltName);

private:	// data
	bool					m_bCanDelete;
	DWORD					m_fieldChecked;
	bool					m_bCertContextFreed;
	PWSTR					m_szEnhancedKeyUsage;
	HCERTSTORE				m_hCertStore;
	PWSTR					m_szAltSubjectName;
	PWSTR					m_szAltIssuerName;
	PWSTR					m_szValidNotAfter;
	PWSTR					m_szSubjectName;
	PWSTR					m_szIssuerName;
	PCERT_INFO				m_pCertInfo;
	const PCCERT_CONTEXT	m_pCertContext;
protected:
	HRESULT GetNameString (DWORD dwFlag, PWSTR* ppszNameOut);
	HRESULT GetOIDInfo (PWSTR* string, PSTR pszObjId);
	HRESULT FormatDate (FILETIME utcDateTime, PWSTR* ppszDateTime);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\computer.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       computer.h
//
//  Contents:   DS computer object property pages header
//
//  History:    07-July-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _COMPUTER_H_
#define _COMPUTER_H_

HRESULT
ComputerRole(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
ComputerDnlvlName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp);
HRESULT
PuterCanDelegateChk(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                    PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                    DLG_OP DlgOp);
//HRESULT
//ADsIntegerToCheckbox(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
//             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
//             DLG_OP DlgOp);
HRESULT
ShComputerRole(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp);

#endif // _COMPUTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\chklist.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chklist.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////
// CHKLIST.H
//
// This file contains the definitions of the CheckList control.
//
/////////////////////////////////////////////////////////////////////

#ifndef __CHKLIST_H_INCLUDED__
#define __CHKLIST_H_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#define ARRAYLENGTH(x)	(sizeof(x)/sizeof((x)[0]))

/////////////////////////////////////////////////////////////////////
//
// CheckList window class name
//
#ifdef RC_INVOKED
#define WC_CHECKLIST        "CHECKLIST"
#else
#define WC_CHECKLIST        TEXT("CHECKLIST")
#endif

/////////////////////////////////////////////////////////////////////
//
// CheckList window styles
//
// TIP
// When creating a control on a dialog template, here are the
// styles to use:
//		Class =		CHECKLIST
//		Style =		0x500000c1
//		ExStyle =	0x00010204
//
#define CLS_1CHECK          0x0001		// One column of checkboxes
#define CLS_2CHECK          0x0002		// Two columns of checkboxes
#define CLS_3CHECK			0x0003		// Three columns of checkboxes
#define CLS_3STATE          0x0004    // Three state checkbox
#define CLS_RADIOBUTTON     0x0010
#define CLS_AUTORADIOBUTTON 0x0020
#define CLS_LEFTALIGN		0x0040		// Align the checkboxes at the left of the text (default = right)
#define CLS_EXTENDEDTEXT	0x0080		// Create the static controls to have enough room for two lines of text


/////////////////////////////////////////////////////////////////////
//
// CheckList check states
//
#define CLST_UNCHECKED      0   // == BST_UNCHECKED
#define CLST_CHECKED        1   // == BST_CHECKED
#define CLST_DISABLED       2   // == BST_INDETERMINATE
#define CLST_CHECKDISABLED  (CLST_CHECKED | CLST_DISABLED)


/////////////////////////////////////////////////////////////////////
// CheckList messages
//
// INTERFACE NOTES
// row is 0-based
// column is 1-based
//
#define CLM_SETCOLUMNWIDTH  (WM_USER + 1)   // lParam = width (dlg units) of a check column (default=32)
#define CLM_ADDITEM         (WM_USER + 2)   // wParam = pszName, lParam = item data, return = row
#define CLM_GETITEMCOUNT    (WM_USER + 3)   // no parameters
#define CLM_SETSTATE        (WM_USER + 4)   // wParam = row/column, lParam = state
#define CLM_GETSTATE        (WM_USER + 5)   // wParam = row/column, return = state
#define CLM_SETITEMDATA     (WM_USER + 6)   // wParam = row, lParam = item data
#define CLM_GETITEMDATA     (WM_USER + 7)   // wParam = row, return = item data
#define CLM_RESETCONTENT    (WM_USER + 8)   // no parameters
#define CLM_GETVISIBLECOUNT (WM_USER + 9)   // no parameters, return = # of visible rows
#define CLM_GETTOPINDEX     (WM_USER + 10)  // no parameters, return = index of top row
#define CLM_SETTOPINDEX     (WM_USER + 11)  // wParam = index of new top row
#define CLM_ENSUREVISIBLE   (WM_USER + 12)  // wParam = index of item to make fully visible


/////////////////////////////////////////////////
typedef struct _NM_CHECKLIST
{
    NMHDR hdr;
    int iItem;                              // row (0-based)
    int iSubItem;                           // column (1-based)
    DWORD dwState;							// BST_CHECKED or BST_UNCHECKED
    DWORD_PTR dwItemData;						// lParam of the checklist item
} NM_CHECKLIST, *PNM_CHECKLIST;


/////////////////////////////////////////////////
//	CLN_CLICK
//
//	This message is sent when a checkbox item has been clicked.
//
//		uMsg = WM_NOTIFY;
//		idControl = (int)wParam;	// Id of the checklist control sending the message
//		pNmChecklist = (NM_CHECKLIST *)lParam;	// Pointer to notification structure
//
#define CLN_CLICK           (0U-1000U)


/////////////////////////////////////////////////////////////////////
void RegisterCheckListWndClass();

/////////////////////////////////////////////////////////////////////
//
//	Handy Wrappers
//
int  CheckList_AddItem(HWND hwndCheckList, LPCTSTR pszLabel, LPARAM lParam = 0, BOOL fCheckItem = FALSE);
int  CheckList_AddString(HWND hwndCheckList, UINT uStringId, BOOL fCheckItem = FALSE);
void CheckList_SetItemCheck(HWND hwndChecklist, int iItem, BOOL fCheckItem, int iColumn = 1);
int  CheckList_GetItemCheck(HWND hwndChecklist, int iItem, int iColumn = 1);
void CheckList_SetLParamCheck(HWND hwndChecklist, LPARAM lParam, BOOL fCheckItem, int iColumn = 1);
int  CheckList_GetLParamCheck(HWND hwndChecklist, LPARAM lParam, int iColumn = 1);
int  CheckList_FindLParamItem(HWND hwndChecklist, LPARAM lParam);
void CheckList_EnableWindow(HWND hwndChecklist, BOOL fEnableWindow);


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* __CHKLIST_H_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\dlgbase.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       dlgbase.cxx
//
//  Contents:   base classes for dialog boxes.
//
//  Classes:    CModalDialog
//
//  History:    29-Nov-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "dlgbase.h"

//+----------------------------------------------------------------------------
//
//  Method:    CModalDialog::StaticDlgProc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CModalDialog::StaticDlgProc(HWND hDlg, UINT uMsg,
                            WPARAM wParam, LPARAM lParam)
{
   CModalDialog * pDlg = (CModalDialog *)GetWindowLongPtr(hDlg, DWLP_USER);

   if (uMsg == WM_INITDIALOG)
   {
      pDlg = (CModalDialog *)lParam;

      pDlg->_hDlg = hDlg;

      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pDlg);

      return pDlg->DlgProc(hDlg, uMsg, wParam, lParam);
   }

   if (pDlg != NULL)
   {
      return pDlg->DlgProc(hDlg, uMsg, wParam, lParam);
   }

   return FALSE;
}


//+----------------------------------------------------------------------------
//
//  Method:    CModalDialog::DlgProc
//
//  Synopsis:  Instance specific wind proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CModalDialog::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   LRESULT lr;

   switch (uMsg)
   {
   case WM_INITDIALOG:
      _fInInit = TRUE;
      lr = OnInitDialog(lParam);
      _fInInit = FALSE;
      return (lr == S_OK) ? TRUE : FALSE;

   case WM_NOTIFY:
      return OnNotify(wParam, lParam);

   case WM_HELP:
      return OnHelp((LPHELPINFO)lParam);

   case WM_COMMAND:
      if (_fInInit)
      {
         return TRUE;
      }
      return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                       GET_WM_COMMAND_HWND(wParam, lParam),
                       GET_WM_COMMAND_CMD(wParam, lParam)));
   case WM_DESTROY:
      return OnDestroy();

   default:
      return FALSE;
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CModalDialog::DoModal
//
//  Synopsis:  Launch the dialog.
//
//-----------------------------------------------------------------------------
INT_PTR
CModalDialog::DoModal(void)
{
   INT_PTR nRet = DialogBoxParam(g_hInstance,
                                 MAKEINTRESOURCE(_nID),
                                 _hParent,
                                 StaticDlgProc,
                                 (LPARAM)this);
   return nRet;
}

//+----------------------------------------------------------------------------
//
//  CLightweightPropPageBase: Lightweight Trust Page object
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member: CLightweightPropPageBase::CLightweightPropPageBase
//
//-----------------------------------------------------------------------------
CLightweightPropPageBase::CLightweightPropPageBase(HWND hParent) :
   _hParent(hParent),
   _hPage(NULL),
   _fInInit(FALSE),
   _fPageDirty(false)
{
   TRACER(CLightweightPropPageBase,CLightweightPropPageBase);
#ifdef _DEBUG
   // NOTICE-2002/02/12-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
   strcpy(szClass, "CLightweightPropPageBase");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CLightweightPropPageBase::~CLightweightPropPageBase
//
//-----------------------------------------------------------------------------
CLightweightPropPageBase::~CLightweightPropPageBase()
{
   TRACER(CLightweightPropPageBase,~CLightweightPropPageBase);
}

//+----------------------------------------------------------------------------
//
//  Method:     CLightweightPropPageBase::Init
//
//  Synopsis:   Create the page.
//
//-----------------------------------------------------------------------------
HRESULT
CLightweightPropPageBase::Init(PCWSTR pwzDomainDnsName,
                               PCWSTR pwzTrustPartnerName,
                               PCWSTR pwzDcName,
                               int nDlgID,
                               int nTitleID,
                               LPFNPSPCALLBACK CallBack,
                               BOOL fReadOnly)
{
   HRESULT hr = S_OK;

   _strDomainDnsName = pwzDomainDnsName;
   if (_strDomainDnsName.IsEmpty())
      return E_OUTOFMEMORY;
   _strTrustPartnerDnsName = pwzTrustPartnerName;
   if (_strTrustPartnerDnsName.IsEmpty())
      return E_OUTOFMEMORY;
   _strUncDC = pwzDcName;
   if (_strUncDC.IsEmpty())
      return E_OUTOFMEMORY;

   _fReadOnly = fReadOnly;

   CStrW strTitle;
   // NOTICE-2002/02/12-ericb - SecurityPush: CStrW::LoadString always returns a null-terminated string.
   strTitle.LoadString(g_hInstance, nTitleID);
   if (strTitle.IsEmpty())
   {
      return E_OUTOFMEMORY;
   }

   PROPSHEETPAGE   psp;

   psp.dwSize      = sizeof(PROPSHEETPAGE);
   psp.dwFlags     = PSP_USECALLBACK | PSP_USETITLE;
   psp.pszTemplate = MAKEINTRESOURCE(nDlgID);
   psp.pfnDlgProc  = StaticDlgProc;
   psp.pfnCallback = CallBack;
   psp.pcRefParent = NULL; // do not set PSP_USEREFPARENT
   psp.lParam      = (LPARAM) this;
   psp.hInstance   = g_hInstance;
   psp.pszTitle    = strTitle;

   HPROPSHEETPAGE hpsp;

   hpsp = CreatePropertySheetPage(&psp);

   if (hpsp == NULL)
   {
       return HRESULT_FROM_WIN32(GetLastError());
   }

   // Send PSM_ADDPAGE
   //
   if (!PropSheet_AddPage(_hParent, hpsp))
   {
      return HRESULT_FROM_WIN32(GetLastError());
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CLightweightPropPageBase::StaticDlgProc
//
//  Synopsis:   static dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CLightweightPropPageBase::StaticDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   CLightweightPropPageBase * pPage = (CLightweightPropPageBase *)GetWindowLongPtr(hDlg, DWLP_USER);

   if (uMsg == WM_INITDIALOG)
   {
      if (!lParam)
      {
         dspAssert(FALSE && "lParam NULL!");
         return 0;
      }
      LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)lParam;

      pPage = (CLightweightPropPageBase *) ppsp->lParam;
      pPage->_hPage = hDlg;

      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pPage);

      return pPage->DlgProc(hDlg, uMsg, wParam, lParam);
   }

   if (pPage != NULL)
   {
      return pPage->DlgProc(hDlg, uMsg, wParam, lParam);
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CLightweightPropPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CLightweightPropPageBase::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   switch (uMsg)
   {
   case WM_INITDIALOG:
      _fInInit = TRUE;
      LRESULT lr;
      lr = OnInitDialog(lParam);
      _fInInit = FALSE;
      return lr;

   case WM_NOTIFY:
      return OnNotify(wParam, lParam);

   case WM_HELP:
      return OnHelp((LPHELPINFO)lParam);

   case WM_COMMAND:
      if (_fInInit)
      {
         return TRUE;
      }
      return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                       GET_WM_COMMAND_HWND(wParam, lParam),
                       GET_WM_COMMAND_CMD(wParam, lParam)));
   case WM_DESTROY:
      return OnDestroy();

   default:
      return FALSE;
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CLightweightPropPageBase::OnHelp
//
//  Synopsis:   Put up popup help for the control.
//
//-----------------------------------------------------------------------------
LRESULT
CLightweightPropPageBase::OnHelp(LPHELPINFO pHelpInfo)
{
    if (!pHelpInfo)
    {
        dspAssert(FALSE && "pHelpInfo NULL!");
        return 0;
    }
    dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                 pHelpInfo->iCtrlId, pHelpInfo->dwContextId));
    if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
    {
        return 0;
    }
    WinHelp(_hPage, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CLightweightPropPageBase::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CLightweightPropPageBase::OnDestroy(void)
{
   // If an application processes this message, it should return zero.
   return 1;
}

//+----------------------------------------------------------------------------
//
//  Function:  FormatWindowText
//
//  Synopsis:  Read the window text string as a format string, insert the
//             pwzInsert parameter at the %s replacement param in the string,
//             and write it back to the window.
//             Assumes that the window text contains a %s replacement param.
//
//-----------------------------------------------------------------------------
void
FormatWindowText(HWND hWnd, PCWSTR pwzInsert)
{
   CStrW strMsg, strFormat;
   int nLen;

   nLen = GetWindowTextLength(hWnd) + 1;

   // NOTICE-2002/02/12-ericb - SecurityPush: GetBufferSetLength will
   // null terminate the buffer.
   PWSTR pwz = strFormat.GetBufferSetLength(nLen + 1);

   GetWindowText(hWnd, strFormat, nLen);

   strMsg.Format(strFormat, pwzInsert);

   SetWindowText(hWnd, strMsg);
}

//+----------------------------------------------------------------------------
//
//  Function:  UseOneOrTwoLine
//
//  Synopsis:  Read the label text string and see if it exceeds the length
//             of the label control. If it does, hide the label control,
//             show the big label control, and insert the text in it.
//
//-----------------------------------------------------------------------------
void
UseOneOrTwoLine(HWND hDlg, int nID, int nIdLarge)
{
   /* This doesn't work, so don't use it yet.
   CStrW strMsg;
   int nLen;
   HWND hLabel = GetDlgItem(hDlg, nID);

   nLen = GetWindowTextLength(hLabel) + 1;

   strMsg.GetBufferSetLength(nLen);

   // NOTICE-2002/02/12-ericb - SecurityPush: this code not used. Review usage if uncommented.
   GetDlgItemText(hDlg, nID, strMsg, nLen);

   RECT rc;
   SIZE size;

   GetClientRect(hLabel, &rc);
   MapDialogRect(hDlg, &rc);

   HDC hdc = GetDC(hLabel);

   GetTextExtentPoint32(hdc, strMsg, strMsg.GetLength(), &size);

   ReleaseDC(hLabel, hdc);

   if (size.cx > rc.right)
   {
      EnableWindow(hLabel, FALSE);
      ShowWindow(hLabel, SW_HIDE);
      hLabel = GetDlgItem(hDlg, nIdLarge);
      EnableWindow(hLabel, TRUE);
      ShowWindow(hLabel, SW_SHOW);
      SetWindowText(hLabel, strMsg);
   }
   */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\computer.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       computer.cxx
//
//  Contents:   Computer object functionality.
//
//  History:    07-July-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "computer.h"

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Function:   PuterCanDelegateChk
//
//  Synopsis:   Handles the computer can delegate checkbox value.
//
//-----------------------------------------------------------------------------
HRESULT
PuterCanDelegateChk(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                    PADS_ATTR_INFO pAttrInfo, LPARAM lParam,
                    PATTR_DATA pAttrData, DLG_OP DlgOp)
{
    TRACE_FUNCTION(PuterCanDelegateChk);

    switch (DlgOp)
    {
    case fInit:
      {
        dspAssert(pAttrData);
        //
        // Check the delegation value. The user may not have the rights to
        // read the User-Account-Control attribute, so handle that case.
        //
        if (!pAttrInfo || !pAttrInfo->dwNumValues || !pAttrInfo->pADsValues)
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
            ((CDsTableDrivenPage *)pPage)->m_pData = NULL;
            PATTR_DATA_CLEAR_WRITABLE(pAttrData);
            break;
        }

        // Save the original user-account-control value.
        // This must be done even if we are not showing the UI because
        // the m_pData member is used by ComputerRole below
        //
        ((CDsTableDrivenPage *)pPage)->m_pData = (LPARAM)pAttrInfo->pADsValues->Integer;

        //
        // If this is a Whistler domain, then don't show the delegation check
        // because we will handle delegation from the scope of delegation page
        //

        UINT domainBehaviorVersion = pPage->GetBasePathsInfo()->GetDomainBehaviorVersion();
        bool bShowCheck = domainBehaviorVersion < DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS;

        if (domainBehaviorVersion >= DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
        {
           EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
           EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_WARNING_ICON), FALSE);
           EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_WARNING_STATIC), FALSE);
           ShowWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), SW_HIDE);
           ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_WARNING_ICON), SW_HIDE);
           ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_WARNING_STATIC), SW_HIDE);

           break;
        }

        if (pAttrInfo->pADsValues->Integer & UF_TRUSTED_FOR_DELEGATION)
        {
            CheckDlgButton(pPage->GetHWnd(), pAttrMap->nCtrlID, BST_CHECKED);
        }

        if (!PATTR_DATA_IS_WRITABLE(pAttrData))
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }

        break;
      }

    case fOnCommand:
        if (lParam == BN_CLICKED)
        {
          if( IsDlgButtonChecked(pPage->GetHWnd(), pAttrMap->nCtrlID ) )
          {
            SuperMsgBox(pPage->GetHWnd(),
                    IDS_COMPUTER_DELEGATE, 0,
                    MB_OK ,
                    0, NULL, 0,
                    FALSE, __FILE__, __LINE__);
          }

            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData); // Attribute has been modified.
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        HRESULT hr;
        PADSVALUE pADsValue;
        pADsValue = new ADSVALUE;
        CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

        pAttrInfo->pADsValues = pADsValue;
        pAttrInfo->dwNumValues = 1;
        pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        pADsValue->dwType = pAttrInfo->dwADsType;
        pAttrInfo->pADsValues->Integer = (ADS_INTEGER)(ULONG_PTR)(((CDsTableDrivenPage *)pPage)->m_pData);

        if (IsDlgButtonChecked(pPage->GetHWnd(), pAttrMap->nCtrlID) == BST_CHECKED)
        {
            pAttrInfo->pADsValues->Integer |= UF_TRUSTED_FOR_DELEGATION;
        }
        else
        {
            pAttrInfo->pADsValues->Integer &= ~(UF_TRUSTED_FOR_DELEGATION);
        }

        DWORD cModified;

        hr = pPage->m_pDsObj->SetObjectAttributes(pAttrInfo, 1, &cModified);

        if (FAILED(hr))
        {
            DWORD dwErr;
            WCHAR wszErrBuf[MAX_PATH+1];
            WCHAR wszNameBuf[MAX_PATH+1];
            ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);

            if (dwErr)
            {
                dspDebugOut((DEB_ERROR,
                             "Extended Error 0x%x: %ws %ws <%s @line %d>.\n", dwErr,
                             wszErrBuf, wszNameBuf, __FILE__, __LINE__));

                if (ERROR_PRIVILEGE_NOT_HELD == dwErr)
                {
                    // Whoda thunk that a single bit in UAC has an access check on
                    // it. Do special case error checking and reporting for the
                    // delegate bit.
                    //
                    CheckDlgButton(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                   (pAttrInfo->pADsValues->Integer & UF_TRUSTED_FOR_DELEGATION) ?
                                        BST_UNCHECKED : BST_CHECKED);
                    ErrMsg(IDS_ERR_CANT_DELEGATE, pPage->GetHWnd());
                }
                else
                {
                    ReportError(dwErr, IDS_ADS_ERROR_FORMAT, pPage->GetHWnd());
                }
            }
            else
            {
                dspDebugOut((DEB_ERROR, "Error %08lx <%s @line %d>\n", hr, __FILE__, __LINE__));
                ReportError(hr, IDS_ADS_ERROR_FORMAT, pPage->GetHWnd());
            }
            return hr;
        }

        return ADM_S_SKIP;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   ComputerRole
//
//  Synopsis:   Handles the computer Role value.
//
//-----------------------------------------------------------------------------
HRESULT
ComputerRole(CDsPropPageBase * pPage, PATTR_MAP,
             PADS_ATTR_INFO, LPARAM, PATTR_DATA,
             DLG_OP DlgOp)
{
    TRACE_FUNCTION(ComputerRole);

    if (DlgOp != fInit)
    {
        return S_OK;
    }
    //
    // Set the computer role value. It was stored by the PuterCanDelegateChk
    // which means that it must be called before this attr function.
    //
    int id;
    PTSTR ptz;

    id = IDS_ROLE_WKS;  // UF_WORKSTATION_TRUST_ACCOUNT

    if ((ULONG_PTR)((CDsTableDrivenPage *)pPage)->m_pData & UF_SERVER_TRUST_ACCOUNT)
    {
        id = IDS_ROLE_SVR;
    }

    if (!LoadStringToTchar(id, &ptz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    SetDlgItemText(pPage->GetHWnd(), IDC_ROLE_EDIT, ptz);

    delete ptz;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   ComputerDnlvlName
//
//  Synopsis:   Handles the computer SAM account name value.
//
//-----------------------------------------------------------------------------
HRESULT
ComputerDnlvlName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp)
{
    TRACE_FUNCTION(ComputerDnlvlName);
    PTSTR ptz;
    size_t len;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        //
        // Strip the dollar sign off of the SAM account name value. This is a
        // must-have attribute, so it is expected to exist although the user
        // may not have read permission. If the latter, ADSI returns no value.
        //
        if (!pAttrInfo || !pAttrInfo->dwNumValues || !pAttrInfo->pADsValues)
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
            PATTR_DATA_CLEAR_WRITABLE(pAttrData);
            break;
        }

        if (!UnicodeToTchar(pAttrInfo->pADsValues->CaseIgnoreString, &ptz))
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }

        len = _tcslen(ptz);

        if (ptz[len - 1] == TEXT('$'))
        {
            ptz[len - 1] = TEXT('\0');
        }
        //
        // Set the max edit control length to one less than the max attr length
        // to allow for the $ that we stripped off.
        //
        SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                           EM_LIMITTEXT, pAttrMap->nSizeLimit - 1, 0);

        SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptz);

        delete ptz;

        if (!PATTR_DATA_IS_WRITABLE(pAttrData))
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }

        break;

    }
    return S_OK;
}

#endif  //DSADMIN

//+----------------------------------------------------------------------------
//
//  Function:   ShComputerRole
//
//  Synopsis:   Handles the computer Role value for the shell computer general
//              page.
//
//-----------------------------------------------------------------------------
HRESULT
ShComputerRole(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
             DLG_OP DlgOp)
{
    TRACE_FUNCTION(ComputerRole);

    if (DlgOp != fInit)
    {
        return S_OK;
    }
    //
    // Set the computer role value.
    //
    PTSTR ptz;

    int id = IDS_ROLE_WKS;  // UF_WORKSTATION_TRUST_ACCOUNT

    if (pAttrInfo && pAttrInfo->dwNumValues && pAttrInfo->pADsValues &&
        (pAttrInfo->pADsValues->Integer & UF_SERVER_TRUST_ACCOUNT))
    {
        id = IDS_ROLE_SVR;
    }

    if (!LoadStringToTchar(id, &ptz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptz);

    delete ptz;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\dlgbase.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       dlgbase.h
//
//  Contents:   base classes for dialog boxes.
//
//  Classes:    CModalDialog
//
//  History:    29-Nov-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef DLGBASE_H_GUARD
#define DLGBASE_H_GUARD

//+----------------------------------------------------------------------------
//
//  Class:      CModalDialog
//
//  Purpose:    Base class for modal dialogs.
//
//-----------------------------------------------------------------------------
class CModalDialog
{
public:
#ifdef _DEBUG
   char szClass[32];
#endif

   CModalDialog(HWND hParent, int nTemplateID) :
      _nID(nTemplateID), _hParent(hParent), _fInInit(FALSE), _hDlg(NULL) {};
   virtual ~CModalDialog(void) {};

   //
   //  Static WndProc to be passed to CreateWindow
   //
   static INT_PTR CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg,
                                         WPARAM wParam, LPARAM lParam);
   //
   //  Instance specific wind proc
   //
   INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

   INT_PTR DoModal(void);

protected:
   HWND     _hDlg;
   BOOL     _fInInit;

   virtual LRESULT OnInitDialog(LPARAM lParam) = 0;
   virtual LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify) = 0;
   virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam) {return 0;};
   virtual LRESULT OnHelp(LPHELPINFO pHelpInfo) {return 0;};
   virtual LRESULT OnDestroy(void) {return 1;};

private:
   HWND     _hParent;
   int      _nID;
};

//+----------------------------------------------------------------------------
//
//  Class:      CLightweightPropPageBase
//
//  Purpose:    Property page object base class for lightweight (non-DS object,
//              non-refcounted) trust pages.
//
//-----------------------------------------------------------------------------
class CLightweightPropPageBase
{
public:
#ifdef _DEBUG
   char szClass[32];
#endif

   CLightweightPropPageBase(HWND hParent);
   virtual ~CLightweightPropPageBase(void);

   //
   //  Static WndProc to be passed to CreateWindow
   //
   static INT_PTR CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg,
                                         WPARAM wParam, LPARAM lParam);
   //
   //  Instance specific wind proc
   //
   INT_PTR  CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
   virtual  LRESULT  OnInitDialog(LPARAM lParam) = 0;
   virtual  LRESULT  OnApply(void) = 0;
   virtual  LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify) = 0;
   virtual  LRESULT  OnNotify(WPARAM wParam, LPARAM lParam) {return 0;};
   LRESULT  OnHelp(LPHELPINFO pHelpInfo);
   LRESULT  OnDestroy(void);
   void     SetDirty(void) {
               _fPageDirty = true;
               PropSheet_Changed(GetParent(_hPage), _hPage);
               EnableWindow(GetDlgItem(GetParent(_hPage), IDCANCEL), TRUE);
            };
   bool     IsDirty(void) {return _fPageDirty;};
   void     ClearDirty(void) {_fPageDirty = false;};

public:
   HRESULT  Init(PCWSTR pwzDomainDnsName, PCWSTR pwzTrustPartnerName,
                 PCWSTR pwzDcName, int nDlgID, int nTitleID,
                 LPFNPSPCALLBACK CallBack,BOOL fReadOnly);
   BOOL     IsReadOnly(void) {return _fReadOnly;};

   //
   //  Data members
   //
protected:
   CStrW             _strDomainDnsName;
   CStrW             _strTrustPartnerDnsName;
   CStrW             _strUncDC;
   HWND              _hParent;
   HWND              _hPage;
   BOOL              _fInInit;
   BOOL              _fReadOnly;
   bool              _fPageDirty;

   // not implemented to disallow copying.
   CLightweightPropPageBase(const CLightweightPropPageBase&);
   const CLightweightPropPageBase& operator=(const CLightweightPropPageBase&);
};

//+----------------------------------------------------------------------------
//
//  Function:  FormatWindowText
//
//  Synopsis:  Read the window text string as a format string, insert the
//             pwzInsert parameter at the %s replacement param in the string,
//             and write it back to the window.
//             Assumes that the window text contains a %s replacement param.
//
//-----------------------------------------------------------------------------
void
FormatWindowText(HWND hWnd, PCWSTR pwzInsert);

//+----------------------------------------------------------------------------
//
//  Function:  UseOneOrTwoLine
//
//  Synopsis:  Read the label text string and see if it exceeds the length
//             of the label control. If it does, hide the label control,
//             show the big label control, and insert the text in it.
//
//-----------------------------------------------------------------------------
void
UseOneOrTwoLine(HWND hDlg, int nID, int nIdLarge);

#endif // DLGBASE_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\dllmisc.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       dllmisc.cxx
//
//  Contents:   DS property pages class objects handler DLL fcn strings.
//
//  History:    21-Mar-97 EricB created
//              25-Mar-01 EricB split out admin version for adprop.dll.
//
//-----------------------------------------------------------------------------

#include "pch.h"

WCHAR const c_szDsProppagesProgID[] = L"ADPropertyPages.";
WCHAR const c_szDsProppagesDllName[] = L"adprop.dll";

#define DSPROP_ADMIN
#include "misc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\domain.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       domain.h
//
//  Contents:   DS domain object and policy object property pages header
//
//  Classes:    CDsDomainGenPage, CDsDomPolicyGenPage, CDsDomPwPolicyPage,
//              CDsLockoutPolicyPage, CDsDomainTrustPage
//
//  History:    16-May-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef __DOMAIN_H__
#define __DOMAIN_H__

HRESULT DomainDNSname(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                      LPARAM, PATTR_DATA, DLG_OP);

HRESULT DownlevelName(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                      LPARAM, PATTR_DATA, DLG_OP);

HRESULT GetDomainName(CDsPropPageBase * pPage, CRACK_NAME_OPR RequestedOpr,
                      PWSTR * pptz);

#endif // __DOMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\domain.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       domain.cxx
//
//  Contents:   Domain object support
//
//  History:    16-May-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "domain.h"
#include "BehaviorVersion.h"

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Function:   DomainDNSname
//
//  Synopsis:   Get the domain DNS name.
//
//-----------------------------------------------------------------------------
HRESULT
DomainDNSname(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO, LPARAM, PATTR_DATA,
              DLG_OP DlgOp)
{
   if (DlgOp != fInit)
   {
      return S_OK;
   }
   PWSTR pwzDnsName = NULL;

   HRESULT hr = GetDomainName(pPage, GET_OBJ_CAN_NAME, &pwzDnsName);

   CHECK_HRESULT(hr, return hr);

   SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pwzDnsName);

   //
   // Get the domain and forest versions.
   //
   CDomainVersion DomainVersion(pPage->GetObjPathName(), pwzDnsName);
   delete [] pwzDnsName;
   pwzDnsName = NULL;

   hr = DomainVersion.Init();

   CHECK_HRESULT(hr, return hr);
   CStrW strDomVer;

   DomainVersion.GetString(DomainVersion.GetVer(), strDomVer);

   SetDlgItemText(pPage->GetHWnd(), IDC_DOMAIN_VERSION_STATIC, strDomVer);

   CStrW strDC, strForestVer;
   hr = GetLdapServerName(pPage->m_pDsObj, strDC);

   CHECK_HRESULT(hr, return hr);
   
   CForestVersion ForestVersion;

   hr = ForestVersion.Init(strDC);

   CHECK_HRESULT(hr, return hr);

   ForestVersion.GetString(ForestVersion.GetVer(), strForestVer);

   SetDlgItemText(pPage->GetHWnd(), IDC_FOREST_VERSION_STATIC, strForestVer);

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   DownlevelName
//
//  Synopsis:   Get the domain downlevel name.
//
//-----------------------------------------------------------------------------
HRESULT
DownlevelName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO, LPARAM, PATTR_DATA,
              DLG_OP DlgOp)
{
    if (DlgOp != fInit)
    {
        return S_OK;
    }
    PWSTR pwzNbName = NULL;

    HRESULT hr = GetDomainName(pPage, GET_NT4_DOMAIN_NAME, &pwzNbName);

    CHECK_HRESULT(hr, return hr);

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pwzNbName);

    delete [] pwzNbName;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetDomainName
//
//  Synopsis:   Get the indicated domain name.
//
//-----------------------------------------------------------------------------
HRESULT
GetDomainName(CDsPropPageBase * pPage, CRACK_NAME_OPR RequestedOpr,
              PWSTR * ppwz)
{
    CSmartWStr pwz1779;
    PWSTR pwzDNSname;
    HRESULT hr = pPage->SkipPrefix(pPage->GetObjPathName(), &pwz1779);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    hr = CrackName(pwz1779, &pwzDNSname, RequestedOpr, pPage->GetHWnd());

    CHECK_HRESULT(hr, return hr);

    if (!AllocWStr(pwzDNSname, ppwz))
    {
        LocalFreeStringW(&pwzDNSname);
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }
    LocalFreeStringW(&pwzDNSname);

    if (RequestedOpr == GET_OBJ_CAN_NAME)
    {
        // This code checks to see if the last character is a forward slash and
        // if so replaces it with a null.
        //
        // NOTICE-2002/02/18-ericb - SecurityPush: *ppwz is always a valid
        // null-terminated string if AllocWStr succeeds. 
        //
        if ((*ppwz)[wcslen(*ppwz) - 1] == TEXT('/'))
        {
            (*ppwz)[wcslen(*ppwz) - 1] = TEXT('\0');
        }
    }

    return S_OK;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\dscmn.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dscmn.cxx
//
//  Contents:   Shared functionality between DSPROP and DSADMIN
//
//  History:    02-Mar-98 JonN created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "siterepl.h"

#ifdef DSADMIN

#define BREAK_ON_TRUE(b) if (b) { ASSERT(FALSE); break; }
#define BREAK_ON_FAIL BREAK_ON_TRUE(FAILED(hr))
#define RETURN_IF_FAIL CHECK_HRESULT(hr, return hr);

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    01-13-1999   JonN       Copied from DavidMun sample code
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForComputers(
    LPCWSTR lpcwszTarget,
    IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType =   DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = lpcwszTarget;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}


HRESULT ExtractServerName(
	IN LPCWSTR lpcwszRootPath, // only the server name is used
	OUT BSTR* pbstrServerName )
{
	ASSERT( NULL != pbstrServerName && NULL == *pbstrServerName );

	if (NULL == lpcwszRootPath)
		return S_OK;

	HRESULT hr = S_OK;
	CComPtr<IADsPathname> spPathCracker;
	do
	{
        hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
		                              IID_IADsPathname, (PVOID *)&spPathCracker);
		BREAK_ON_FAIL;
		ASSERT( !!spPathCracker );

		hr = spPathCracker->Set(CComBSTR(lpcwszRootPath), ADS_SETTYPE_FULL);
		BREAK_ON_FAIL;

		hr = spPathCracker->Retrieve(ADS_FORMAT_SERVER, pbstrServerName);
		BREAK_ON_FAIL;

		// CODEWORK so what happens if this is still NULL?
	} while (false); // false loop

	return hr;
}


HRESULT DSPROP_PickComputer(
	IN HWND hwndParent,
	IN LPCWSTR lpcwszRootPath, // only the server name is used
	OUT BSTR* pbstrADsPath )
{
	ASSERT( NULL != pbstrADsPath && NULL == *pbstrADsPath );

	HRESULT hr = S_OK;
	FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};
	PDS_SELECTION_LIST pDsSelList = NULL;
	bool fGotStgMedium = false;

	do
	{
		CComBSTR sbstrTarget;
		hr = ExtractServerName( lpcwszRootPath, &sbstrTarget );
		BREAK_ON_FAIL;

		CComPtr<IDsObjectPicker> spDsObjectPicker;
		hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER,
		                      IID_IDsObjectPicker, (PVOID *)&spDsObjectPicker);
		BREAK_ON_FAIL;
		ASSERT( !!spDsObjectPicker );

		hr = InitObjectPickerForComputers(sbstrTarget, spDsObjectPicker);
		BREAK_ON_FAIL;

		CComPtr<IDataObject> pdoSelections;
		hr = spDsObjectPicker->InvokeDialog(hwndParent, &pdoSelections);
		BREAK_ON_FAIL;

		if (hr == S_FALSE || !pdoSelections)
		{
			hr = S_FALSE;
			break;
		}

		hr = pdoSelections->GetData(&fmte, &medium);
		BREAK_ON_FAIL;

		fGotStgMedium = true;

		pDsSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

		if (   NULL == pDsSelList
		    || 1 != pDsSelList->cItems
		    || NULL == pDsSelList->aDsSelection[0].pwzADsPath
		    || L'\0' == *(pDsSelList->aDsSelection[0].pwzADsPath)
		   )
		{
		  hr = E_FAIL;
		  BREAK_ON_FAIL;
		}

		*pbstrADsPath = ::SysAllocString(pDsSelList->aDsSelection[0].pwzADsPath);
		ASSERT( NULL != *pbstrADsPath );

	} while (false); // false loop

	if (pDsSelList)
		GlobalUnlock( pDsSelList );
	if (fGotStgMedium)
		ReleaseStgMedium( &medium );

	return hr;
}

HRESULT DSPROP_DSQuery(
	IN HWND hwndParent,
	IN LPCWSTR lpcwszRootPath,
	IN CLSID* pclsidDefaultForm,
	OUT BSTR* pbstrADsPath )
{
	ASSERT( NULL != hwndParent
		 // && NULL != lpcwszRootPath  JonN 3/23/99 this is actually OK
		 && NULL != pclsidDefaultForm
		 && NULL != pbstrADsPath );
	CComPtr<ICommonQuery> spCommonQuery;
	CComPtr<IDataObject> spDataObject;
	CComBSTR sbstrADsPath;
	HRESULT hr = S_OK;

	hr = ::CoCreateInstance(
		CLSID_CommonQuery,
		NULL,
		CLSCTX_INPROC_SERVER,
		IID_ICommonQuery,
		(LPVOID*)&spCommonQuery );
	RETURN_IF_FAIL;

	// 373849 JonN 7/28/99
	CComBSTR sbstrTarget;
	hr = ExtractServerName( lpcwszRootPath, &sbstrTarget );
	RETURN_IF_FAIL;

	DSQUERYINITPARAMS dqip;
	::ZeroMemory(&dqip,sizeof(dqip));
	dqip.cbStruct = sizeof(dqip);
	dqip.dwFlags =   DSQPF_SHOWHIDDENOBJECTS
	               | DSQPF_ENABLEADMINFEATURES
	               | DSQPF_NOSAVE
	               | DSQPF_HASCREDENTIALS; // 373849 JonN 7/28/99

	// 122519 JonN 11/06/00
	// If you remove a column in CLSID_DsFindDomainController, you can't
	// restore it.  This is due to a weakness in Display Specifiers, but a
	// fix there will have to wait until Blackcomb.  I would also prefer to
	// change the DSPROP_DSQuery() signature, but this is the lightest-touch
	// option at this stage.
	if (CLSID_DsFindDomainController == *pclsidDefaultForm)
		dqip.dwFlags |= DSQPF_NOCHOOSECOLUMNS;

	dqip.pDefaultScope = const_cast<LPWSTR>(lpcwszRootPath); // use selected server
	dqip.pServer = sbstrTarget; // 373849 JonN 7/28/99

	OPENQUERYWINDOW oqw;
	::ZeroMemory(&oqw,sizeof(oqw));
	oqw.cbStruct = sizeof(oqw);
	oqw.dwFlags = OQWF_OKCANCEL |
				  OQWF_SINGLESELECT |
				  OQWF_DEFAULTFORM |
				  OQWF_REMOVESCOPES |
				  OQWF_REMOVEFORMS |
				  OQWF_ISSUEONOPEN;
	oqw.clsidHandler = CLSID_DsQuery;
	oqw.pHandlerParameters = &dqip;
	oqw.clsidDefaultForm = *pclsidDefaultForm;
	oqw.pPersistQuery = NULL;

	hr = spCommonQuery->OpenQueryWindow(hwndParent, &oqw, &spDataObject);
	if (S_FALSE == hr) // user hit cancel
		return S_FALSE;
	RETURN_IF_FAIL;
	ASSERT( spDataObject );

	static CLIPFORMAT cfDsObjectNames = 0;
	if ( 0 == cfDsObjectNames )
	{
		cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
		ASSERT( 0 != cfDsObjectNames );
	}

	FORMATETC fmte = {cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = { TYMED_NULL, NULL, NULL };
	hr = spDataObject->GetData(&fmte, &medium);
	if( FAILED(hr) )
		return S_FALSE;

	// CODEWORK does this have to be freed?
	LPDSOBJECTNAMES pDsObjects = (LPDSOBJECTNAMES)medium.hGlobal;
	ASSERT( NULL != pDsObjects );
	if (0 == pDsObjects->cItems)
   {
      ReleaseStgMedium(&medium);
		return S_FALSE;
   }
	ASSERT( 1 == pDsObjects->cItems );

	*pbstrADsPath = ::SysAllocString(
		(LPTSTR)ByteOffset(pDsObjects, pDsObjects->aObjects[0].offsetName) );

   ReleaseStgMedium(&medium);
	return hr;
}


HRESULT DSPROP_PickNTDSDSA(
	IN HWND hwndParent,
	IN LPCWSTR lpcwszRootPath,
	OUT BSTR* pbstrADsPath )
{
	return DSPROP_DSQuery(
		hwndParent,
		lpcwszRootPath,
		const_cast<CLSID*>(&CLSID_DsFindDomainController),
		pbstrADsPath );
}


HRESULT DSPROP_IsFrsObject( IN LPWSTR pszClassName, OUT bool* pfIsFrsObject )
{
	if (NULL == pszClassName || NULL == pfIsFrsObject)
	{
		ASSERT(FALSE);
		return E_POINTER;
	}
	*pfIsFrsObject = false;
	if ( !lstrcmp( L"nTDSDSA", pszClassName ) )
	{
		// nothing
	}
	else if (   !lstrcmp( L"nTFRSMember", pszClassName )
			 || !lstrcmp( L"nTFRSReplicaSet", pszClassName ) )
	{
		*pfIsFrsObject = true;
	}
	else
	{
		ASSERT(FALSE);
	}
	return S_OK;
}

HRESULT DSPROP_RemoveX500LeafElements(
    IN unsigned int nElements,
    IN OUT BSTR* pbstrADsPath )
{
    ASSERT( NULL != pbstrADsPath );
    CComPtr<IADsPathname> spADsPath;
    HRESULT hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                      IID_IADsPathname, (PVOID *)&spADsPath);
    RETURN_IF_FAIL;
    hr = spADsPath->Set( *pbstrADsPath, ADS_SETTYPE_FULL );
    RETURN_IF_FAIL;
    for (unsigned int i = 0; i < nElements; i++)
    {
        hr = spADsPath->RemoveLeafElement();
        RETURN_IF_FAIL;
    }
    hr = spADsPath->SetDisplayType( ADS_DISPLAY_FULL );
    RETURN_IF_FAIL;
    CComBSTR sbstr;
    // determine whether a servername is present, if so preserve  it
    hr = spADsPath->Retrieve( ADS_FORMAT_SERVER, &sbstr );
    bool fNoServer = ( FAILED(hr) || !sbstr || *sbstr == L'\0');
    ::SysFreeString( *pbstrADsPath );
    *pbstrADsPath = NULL;
    hr = spADsPath->Retrieve(
        (fNoServer) ? ADS_FORMAT_X500_NO_SERVER : ADS_FORMAT_X500,
        pbstrADsPath );
    RETURN_IF_FAIL;
    return hr;
}


HRESULT DSPROP_TweakADsPath(
    IN     LPCWSTR       lpcwszInitialADsPath,
    IN     int           iTargetLevelsUp,
    IN     PWCHAR*       ppwszTargetLevelsBack,
    OUT    BSTR*         pbstrResultDN
    )
{
    ASSERT( NULL != lpcwszInitialADsPath
         && NULL != pbstrResultDN
         && NULL == *pbstrResultDN );

    CComPtr<IADsPathname> spIADsPathname;
    HRESULT hr = CoCreateInstance(
        CLSID_Pathname,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IADsPathname,
        (PVOID *)&spIADsPathname );
    RETURN_IF_FAIL;
    ASSERT( !!spIADsPathname );

    hr = spIADsPathname->Set(CComBSTR(lpcwszInitialADsPath),
        ADS_SETTYPE_FULL );
    RETURN_IF_FAIL;
    for (int i = 0; i < iTargetLevelsUp; i++)
    {
        hr = spIADsPathname->RemoveLeafElement();
        RETURN_IF_FAIL;
    }
    if ( NULL != ppwszTargetLevelsBack )
    {
        for (int i = 0; NULL != ppwszTargetLevelsBack[i]; i++)
        {
            hr = spIADsPathname->AddLeafElement(CComBSTR(ppwszTargetLevelsBack[i]));
            RETURN_IF_FAIL;
        }
    }
    hr = spIADsPathname->Retrieve( ADS_FORMAT_X500, pbstrResultDN );
    RETURN_IF_FAIL;
    ASSERT( NULL != pbstrResultDN );

    return S_OK;
}

HRESULT DSPROP_RetrieveRDN(
    IN     LPCWSTR         lpcwszDN,
    OUT    BSTR*           pbstrRDN
    )
{
    ASSERT( NULL != lpcwszDN
         && NULL != pbstrRDN
         && NULL == *pbstrRDN );

    CComPtr<IADsPathname> spIADsPathname;
    HRESULT hr = CoCreateInstance(
        CLSID_Pathname,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IADsPathname,
        (PVOID *)&spIADsPathname );
    RETURN_IF_FAIL;
    ASSERT( !!spIADsPathname );

    hr = spIADsPathname->Set(CComBSTR(lpcwszDN),
        ADS_SETTYPE_DN );
    RETURN_IF_FAIL;
    hr = spIADsPathname->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
    RETURN_IF_FAIL;
    hr = spIADsPathname->put_EscapedMode( ADS_ESCAPEDMODE_OFF_EX );
    RETURN_IF_FAIL;
    hr = spIADsPathname->GetElement( 0L, pbstrRDN );
    RETURN_IF_FAIL;
    ASSERT( NULL != *pbstrRDN );

    return S_OK;
}

/* currently unused.
//
// lifted from uacct.cxx CDsUserAcctPage::OnApply -- JonN 4/21/98
// Obtains an instance of IDirectorySearch against a GC
// returns S_FALSE if no GC was found
//
HRESULT DSPROP_GetGCSearch(
    IN  REFIID iid,
    OUT void** ppvObject )
{
    ASSERT( NULL != ppvObject && NULL == *ppvObject );

    CComPtr <IADsContainer> spGCRoot;
    HRESULT hr = DSAdminOpenObject(L"GC:", 
                               IID_IADsContainer, (PVOID *)&spGCRoot);
    RETURN_IF_FAIL;
    IEnumVARIANT * pEnum = NULL;
    hr = ADsBuildEnumerator(spGCRoot, &pEnum);
    RETURN_IF_FAIL;
    CComVariant varEnum;
    ULONG fetched = 0L;
    hr = ADsEnumerateNext(pEnum, 1, &varEnum, &fetched);
    ADsFreeEnumerator(pEnum);
    RETURN_IF_FAIL;
    if (S_FALSE == hr)
      return hr; // no GC found
    if (1 != fetched || VT_DISPATCH != varEnum.vt || NULL == varEnum.pdispVal)
    {
      ASSERT(FALSE);
      return E_FAIL;
    }
    hr = varEnum.pdispVal->QueryInterface(iid,ppvObject);
    RETURN_IF_FAIL;
    return S_OK;
}
*/

#endif // DSADMIN

//
// Smartpointer functions for PADS_ATTR_INFO pointers and for DsBind handles
// JonN 4/7/98
//

void Smart_DsHandle__Empty( HANDLE* phDs )
{
  if (NULL != *phDs)
  {
    DsUnBind( phDs );
    dspAssert( NULL == *phDs );
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\forestversion.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      ForestVersion.cxx
//
//  Contents:  Dialogs and supporting code for displaying and raising the
//             forest version.
//
//  History:   14-April-01 EricB created
//
//
//-----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ntdsadef.h>
#include "proppage.h"
#include "qrybase.h"
#include "BehaviorVersion.h"

//+----------------------------------------------------------------------------
//
//  Function:  DSPROP_ForestVersionDlg
//
//  Synopsis:  Puts up a dialog that allows the user to view the forest version
//             levels available and if not at the highest level, to raise the
//             forest version.
//
//  Arguments: [pwzConfigPath] - The full ADSI path to the configuration container.
//             [pwzPartitionsPath] - The full ADSI path to the partitions container.
//             [pwzSchemaPath] - The full ADSI path to the schema container.
//             [pwzRootDnsName] - The DNS name of the enterprise root domain.
//             [hWndParent] - The caller's top level window handle.
//
//  Notes:     This function is called only from Domains & Trusts. If the
//             snapin is running on a child domain, the DC named in the ADSI
//             path will be for the child domain. In that case will need to
//             get the PDC (if possible) for the root domain.
//
//-----------------------------------------------------------------------------
void
DSPROP_ForestVersionDlg(PCWSTR pwzConfigPath,
                        PCWSTR pwzPartitionsPath,
                        PCWSTR pwzSchemaPath,
                        PCWSTR pwzRootDnsName,
                        HWND hWndParent)
{
   dspDebugOut((DEB_ITRACE, "DSPROP_ForestVersionDlg, config: %ws\n", pwzPartitionsPath));
   if (!pwzConfigPath || !pwzPartitionsPath || !pwzSchemaPath ||
       !pwzRootDnsName || !hWndParent || !IsWindow(hWndParent))
   {
      dspAssert(FALSE);
      return;
   }

   CForestVersion ForestVer;

   HRESULT hr = ForestVer.Init(pwzConfigPath, pwzPartitionsPath, pwzSchemaPath);

   if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
   {
      ErrMsgParam(IDS_ERR_NO_DC, (LPARAM)pwzRootDnsName, hWndParent);
      return;
   }
   if (HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN) == hr)
   {
      ErrMsgParam(IDS_ERR_DC_NOT_WORKING, (LPARAM)ForestVer.GetDC(), hWndParent);
      return;
   }
   if (S_FALSE == hr)
   {
      // Error already reported.
      return;
   }

   CHECK_HRESULT_REPORT(hr, hWndParent, return);

   hr = ForestVer.CheckHighestPossible();

   CHECK_HRESULT_REPORT(hr, hWndParent, return);

   int nTemplateID = IDD_RAISE_FOREST_VERSION;

   if (!ForestVer.IsFsmoDcFound())
   {
      nTemplateID = IDD_CANT_RAISE_FOREST;
   }
   else if (!ForestVer.CanRaise())
   {
      nTemplateID = (ForestVer.IsHighest()) ?
                         IDD_HIGHEST_FOREST_VERSION : IDD_CANT_RAISE_FOREST;
   }

   CForestVersionDlg dialog(hWndParent, pwzRootDnsName, ForestVer, nTemplateID);

   dialog.DoModal();
}

//+----------------------------------------------------------------------------
//
//  Class:     CForestVersionDlg
//
//  Purpose:   Raise the forest behavior version.
//
//-----------------------------------------------------------------------------
CForestVersionDlg::CForestVersionDlg(HWND hParent,
                                     PCWSTR pwzRootDNS,
                                     CForestVersion & ForestVer,
                                     int nTemplateID) :
   _strRootDnsName(pwzRootDNS),
   _ForestVer(ForestVer),
   _nTemplateID(nTemplateID),
   CModalDialog(hParent, nTemplateID)
{
    TRACE(CForestVersionDlg,CForestVersionDlg);
#ifdef _DEBUG
    // NOTICE-2002/02/12-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
    strcpy(szClass, "CForestVersionDlg");
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::OnInitDialog
//
//  Synopsis:  Set the initial control values.
//
//-----------------------------------------------------------------------------
LRESULT
CForestVersionDlg::OnInitDialog(LPARAM lParam)
{
   TRACE(CForestVersionDlg,OnInitDialog);

   SetDlgItemText(_hDlg, IDC_VER_NAME_STATIC, _strRootDnsName);

   CStrW strVersion;
   _ForestVer.GetString(_ForestVer.GetVer(), strVersion);

   SetDlgItemText(_hDlg, IDC_CUR_VER_STATIC, strVersion);

   _ForestVer.SetDlgHwnd(_hDlg);

   if (!_ForestVer.IsFsmoDcFound())
   {
      ShowWindow(GetDlgItem(_hDlg, IDC_FOR_CANT_RAISE_DETAILS), SW_HIDE);
      ShowWindow(GetDlgItem(_hDlg, IDC_SAVE_LOG), SW_HIDE);
      CStrW strFormat, strMsg;
      // NOTICE-2002/02/12-ericb - SecurityPush: CStrW::LoadString sets the
      // string to an empty string on failure.
      strFormat.LoadString(g_hInstance, IDS_FOREST_CANT_RAISE_FSMO);
      strMsg.Format(strFormat, _ForestVer.GetFsmoDcName());
      SetDlgItemText(_hDlg, IDC_FOR_CANT_RAISE_STATIC, strMsg);
   }
   else if (_ForestVer.CanRaise())
   {
      dspAssert(IDD_RAISE_FOREST_VERSION == _nTemplateID);
      InitCombobox();

      if (_ForestVer.IsReadOnly())
      {
         EnableWindow(GetDlgItem(_hDlg, IDOK), FALSE);
         CStrW strMsg;
         // NOTICE-2002/02/12-ericb - SecurityPush: see LoadString note above.
         strMsg.LoadString(g_hInstance, IDS_FOREST_CANT_RAISE_ACCESS);
         SetDlgItemText(_hDlg, IDC_CANT_RAISE_STATIC, strMsg);
      }
   }
   else if (IDD_CANT_RAISE_FOREST == _nTemplateID)
   {
      CStrW strCantRaise;
      // NOTICE-2002/02/12-ericb - SecurityPush: see LoadString note above.
      strCantRaise.LoadString(g_hInstance, IDS_FOR_CANT_RAISE_STATIC);
      SetDlgItemText(_hDlg, IDC_FOR_CANT_RAISE_STATIC, strCantRaise);
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::OnCommand
//
//  Synopsis:  Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CForestVersionDlg::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   switch (codeNotify)
   {
   case BN_CLICKED:
      switch (id)
      {
      case IDOK:
         OnOK();
         break;

      case IDCANCEL:
         EndDialog(_hDlg, IDCANCEL);
         break;

      case IDC_HELP_BTN:
         ShowHelp(L"ADConcepts.chm::/sag_levels.htm");
         break;

      case IDC_SAVE_LOG:
         OnSaveLog();
         break;
      }
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::OnOK
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
void
CForestVersionDlg::OnOK(void)
{
   UINT nVer = ReadComboSel();

   dspDebugOut((DEB_ITRACE, "Combobox selection was %d\n", nVer));

   if (FOREST_VER_ERROR == nVer)
   {
      // No user selection. Set one and return.
      SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_SETCURSEL, 0, 0);
      return;
   }

   int iRet = IDCANCEL;
   CStrW strTitle, strMsg;
   // NOTICE-2002/02/12-ericb - SecurityPush: see LoadString note above.
   strTitle.LoadString(g_hInstance, IDS_RAISE_FOR_VER_TITLE);
   strMsg.LoadString(g_hInstance, IDS_CONFIRM_FOR_RAISE);

   iRet = MessageBox(_hDlg, strMsg, strTitle, MB_OKCANCEL | MB_ICONEXCLAMATION | MB_DEFBUTTON2);

   if (iRet == IDOK)
   {
      HRESULT hr = _ForestVer.RaiseVersion(nVer);

      if (SUCCEEDED(hr))
      {
         // NOTICE-2002/02/12-ericb - SecurityPush: see LoadString note above.
         strMsg.LoadString(g_hInstance, IDS_FOREST_MODE_CHANGED);
         MessageBox(_hDlg, strMsg, strTitle, MB_OK | MB_ICONINFORMATION);
      }
      else
      {
         if (HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM) == hr)
         {
            ErrMsg(IDS_VERSION_UNWILLING_TO_RAISE, _hDlg);
         }
         else
         {
            REPORT_ERROR_FORMAT(hr, IDS_VERSION_ERROR_FORMAT, _hDlg);
         }
      }

      EndDialog(_hDlg, IDOK);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::OnHelp
//
//  Synopsis:  Put up popup help for the control.
//
//-----------------------------------------------------------------------------
/* LRESULT
CForestVersionDlg::OnHelp(LPHELPINFO pHelpInfo)
{
   if (!pHelpInfo)
   {
      dspAssert(FALSE);
      return 0;
   }
   dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                pHelpInfo->iCtrlId, pHelpInfo->dwContextId));

   if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
   {
      return 0;
   }
   WinHelp(_hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

   return 0;
} */

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::OnSaveLog
//
//  Synopsis:  Prompts the user for a file name to save the DC log.
//
//-----------------------------------------------------------------------------
void
CForestVersionDlg::OnSaveLog(void)
{
   TRACE(CForestVersionDlg,OnSaveLog);
   HRESULT hr = S_OK;
   OPENFILENAME ofn = {0};
   WCHAR wzFilter[MAX_PATH + 1] = {0}, wzFileName[MAX_PATH + MAX_PATH + 1] = {0};
   CStrW strFilter, strExt, strMsg;
   CWaitCursor Wait;

   // NOTICE-2002/02/12-ericb - SecurityPush: wzFileName is initialized to be all
   // nulls and is one char longer than the length passed to wcsncpy so that the
   // result is always null terminated even if _strDomainDnsName were longer than
   // MAX_PATH + MAX_PATH. The calls to wcsncat are correct because they pass
   // in the remaining buffer capacity, not the total buffer length.
   //
   wcsncpy(wzFileName, _strRootDnsName, MAX_PATH + MAX_PATH);
   strExt.LoadString(g_hInstance, IDS_FTFILE_SUFFIX);
   wcsncat(wzFileName, strExt, MAX_PATH + MAX_PATH - wcslen(wzFileName));
   wcsncat(wzFileName, L".", MAX_PATH + MAX_PATH - wcslen(wzFileName));
   strExt.LoadString(g_hInstance, IDS_FTFILE_CSV_EXT);
   wcsncat(wzFileName, strExt, MAX_PATH + MAX_PATH - wcslen(wzFileName));

   // NOTICE-2002/02/12-ericb - SecurityPush: wzFilter is initialized to all
   // zeros and is one char longer than the length passed to LoadString.
   //
   LoadString(g_hInstance, IDS_FTFILE_FILTER, wzFilter, MAX_PATH);

   ofn.lStructSize = sizeof(ofn);
   ofn.hwndOwner = _hDlg;
   ofn.lpstrFile = wzFileName;
   ofn.nMaxFile = MAX_PATH + MAX_PATH + 1;
   ofn.Flags = OFN_OVERWRITEPROMPT;
   ofn.lpstrDefExt = strExt;
   ofn.lpstrFilter = wzFilter;

   if (GetSaveFileName(&ofn))
   {
      dspDebugOut((DEB_ITRACE, "Saving forest DC version info to %ws\n", ofn.lpstrFile));
      PWSTR pwzErr = NULL;
      BOOL fSucceeded = TRUE;

      HANDLE hFile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0,
                                NULL, CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL, NULL);

      if (INVALID_HANDLE_VALUE != hFile)
      {
         CStrW str, strFormat;
         strMsg = g_wzBOM; // start with ByteOrderMark
         // NOTICE-2002/02/12-ericb - SecurityPush: see LoadString note above.
         strFormat.LoadString(g_hInstance, IDS_FOR_VER_LOG_PREFIX);
         str.Format(strFormat, _strRootDnsName);
         strMsg += str;
         _ForestVer.GetString(_ForestVer.GetVer(), str);
         strMsg += str;
         strMsg += g_wzCRLF;
         strMsg += g_wzCRLF;
         // NOTICE-2002/02/12-ericb - SecurityPush: see LoadString note above.
         str.LoadString(g_hInstance, IDS_FOR_VER_LOG_HDR);
         strMsg += str;
         strMsg += g_wzCRLF;

         hr = _ForestVer.BuildDcListString(strMsg);

         if (SUCCEEDED(hr))
         {
            strMsg += g_wzCRLF;
            strMsg += g_wzCRLF;

            // BuildDcListString returns S_FALSE if there are no downlevel DCs.
            // Don't show the mixed mode domain list if there are downlevel DCs
            // because the AD won't replicate the nTMixedDomain attrib to the
            // cross-refs if there are downlevel DCs. Thus, if there are
            // downlevel DCs then the mixed domain info on the cross-refs will
            // not be accurate so don't show it. The presence of downlevel DCs
            // is sufficient information to show what needs to be upgraded to
            // unblock raising the forest version.
            //
            if (S_FALSE == hr)
            {
               // NOTICE-2002/02/12-ericb - SecurityPush: see LoadString note above.
               str.LoadString(g_hInstance, IDS_FOR_VER_LOG_MODE_HDR);
               strMsg += str;
               strMsg += g_wzCRLF;

               hr = _ForestVer.BuildMixedModeList(strMsg);
            }

            if (SUCCEEDED(hr))
            {
               strMsg += g_wzCRLF;

               DWORD dwWritten;

               // NOTICE-2002/02/12-ericb - SecurityPush: see the note for
               // CDomainVersionDlg::OnSaveLog in DomainVersion.cxx.
               //
               fSucceeded = WriteFile(hFile, strMsg.GetBuffer(0),
                                      strMsg.GetLength() * sizeof(WCHAR),
                                      &dwWritten, NULL);
            }
         }
         CloseHandle(hFile);
      }
      else
      {
         fSucceeded = FALSE;
      }


      if (!fSucceeded || FAILED(hr))
      {
         CStrW strTitle;
         // NOTICE-2002/02/12-ericb - SecurityPush: see LoadString note above.
         // string on failure.
         strTitle.LoadString(g_hInstance, IDS_DNT_MSG_TITLE);
         LoadErrorMessage(FAILED(hr) ? hr : GetLastError(), 0, &pwzErr);
         if (pwzErr)
         {
            // NOTICE-2002/02/12-ericb - SecurityPush: CStrW::FormatMessage sets
            // the string to an empty string on failure.
            strMsg.FormatMessage(g_hInstance, IDS_LOGFILE_CREATE_FAILED, pwzErr);
            delete [] pwzErr;
         }
         MessageBox(_hDlg, strMsg, strTitle, MB_ICONERROR);
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::InitCombobox
//
//  Synopsis:  Fills the combobox with levels appropriate for the current
//             state.
//
//-----------------------------------------------------------------------------
void
CForestVersionDlg::InitCombobox(void)
{
   CStrW strVersion;

   switch (_ForestVer.GetVer())
   {
   case FOREST_VER_WIN2K:
   case FOREST_VER_XP_BETA:
      //
      // Can go to Whistler.
      //
      _ForestVer.GetString(FOREST_VER_XP, strVersion);
      SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_INSERTSTRING, 0,
                         (LPARAM)(PCWSTR)strVersion);
      break;

   case FOREST_VER_XP:
      break;

   default:
      dspAssert(FALSE);
      return;
   }

   SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_SETCURSEL, 0, 0);
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersionDlg::ReadComboSel
//
//  Synopsis:  Read the current selection of the combobox.
//
//  Notes:     Currently only one choice for the new version which is why the
//             value of lRet is not used.
//
//-----------------------------------------------------------------------------
UINT
CForestVersionDlg::ReadComboSel(void)
{
   LONG_PTR lRet = SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_GETCURSEL, 0, 0);

   if (CB_ERR == lRet)
   {
      return FOREST_VER_ERROR;
   }

   dspAssert(0 == lRet);

   return FOREST_VER_XP;
}

//+----------------------------------------------------------------------------
//
//  Class:     CForestVersion
//
//  Purpose:   Manages the interpretation of the forest version value.
//
//-----------------------------------------------------------------------------

CForestVersion::~CForestVersion(void)
{
   TRACE(CForestVersion,~CForestVersion);

   for (DOMAIN_LIST::iterator i = _DomainLogList.begin();
        i != _DomainLogList.end();
        ++i)
   {
      delete *i;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::Init
//
//  Synopsis:  Called from the Domain General property page. Use the local DC
//             to read the partitiona and schema paths.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::Init(PCWSTR pwzDC)
{
   TRACE(CForestVersion,Init);
   HRESULT hr = S_OK;
   CWaitCursor Wait;

   _strDC = pwzDC;

   CDSBasePathsInfo BasePaths;

   hr = BasePaths.InitFromName(_strDC);

   CHECK_HRESULT(hr, return hr);
   CSmartPtr<WCHAR> spwzPartitionsPath, spwzSchemaPath, spwzConfigPath;

   if (!BasePaths.GetPartitionsPath(&spwzPartitionsPath))
   {
      CHECK_HRESULT(E_OUTOFMEMORY, return E_OUTOFMEMORY);
   }

   _strPartitionsPath = spwzPartitionsPath;

   if (!BasePaths.GetConfigPath(&spwzConfigPath))
   {
      CHECK_HRESULT(E_OUTOFMEMORY, return E_OUTOFMEMORY);
   }

   _strConfigPath = spwzConfigPath;

   if (!BasePaths.GetSchemaPath(&spwzSchemaPath))
   {
      CHECK_HRESULT(E_OUTOFMEMORY, return E_OUTOFMEMORY);
   }

   hr = FindSchemaMasterReadVersion(spwzSchemaPath);

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::Init
//
//  Synopsis:  Called from DSPROP_ForestVersionDlg.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::Init(PCWSTR pwzConfigPath, PCWSTR pwzPartitionsPath,
                     PCWSTR pwzSchemaPath)
{
   TRACE(CForestVersion,Init);
   CWaitCursor Wait;

   _strConfigPath = pwzConfigPath;
   _strPartitionsPath = pwzPartitionsPath;

   //
   // Save the local DC name in case the FSMO role holder is unavailable.
   //
   CPathCracker PathCrack;
   HRESULT hr = PathCrack.Set(_strConfigPath, ADS_SETTYPE_FULL);

   CHECK_HRESULT(hr, return hr);
   CComBSTR bstrDC;

   hr = PathCrack.Retrieve(ADS_FORMAT_SERVER, &bstrDC);

   CHECK_HRESULT(hr, return hr);

   _strDC = bstrDC;

   //
   // Locate the Schema FSMO role holder.
   //
   hr = FindSchemaMasterReadVersion(pwzSchemaPath);

   if (S_FALSE == hr)
   {
      return hr;
   }
   CHECK_HRESULT(hr, return hr);

   //
   // Check if the caller has write access.
   //

   CComPtr<IDirectoryObject> spPartitions;

   hr = DSAdminOpenObject(_strPartitionsPath, 
                          __uuidof(IDirectoryObject), 
                          (void **)&spPartitions);

   CHECK_HRESULT(hr, return hr);

   Smart_PADS_ATTR_INFO pAttrs;
   DWORD cAttrs = 0;
   PWSTR rgwzNames[] = {g_wzAllowed};

   hr = spPartitions->GetObjectAttributes(rgwzNames, ARRAYLENGTH(rgwzNames),
                                          &pAttrs, &cAttrs);

   if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, NULL))
   {
      return hr;
   }

   for (DWORD j = 0; cAttrs && j < pAttrs->dwNumValues; j++)
   {
      // NOTICE-2002/02/12-ericb - SecurityPush: after verifying the pointer is
      // non-null, compare it with a static string.
      if (pAttrs->pADsValues[j].CaseIgnoreString)
      {
         size_t cch = 0;
         hr = StringCchLength(pAttrs->pADsValues[j].CaseIgnoreString, wcslen(g_wzBehaviorVersion)+1, &cch);
         if (SUCCEEDED(hr) &&
             _wcsnicmp(pAttrs->pADsValues[j].CaseIgnoreString, g_wzBehaviorVersion, cch) == 0)
         {
            _fReadOnly = false;
            break;
         }
      }
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::FindSchemaMasterReadVersion
//
//  Synopsis:  Discover which DC is the schema master by reading the
//             fSMORoleOwner attribute on the schema container. It lists the
//             nTDSDSA object for that DC. Strip off the nTDSDSA object CN,
//             bind to the Server object and read its dNSHostName value for
//             the name of the FSMO role holder DC.
//             Then using the DC bind to the partitions container to read the
//             forest version.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::FindSchemaMasterReadVersion(PCWSTR pwzSchemaPath)
{
   HRESULT hr = S_OK;
   CComPtr<IADs> spSchema;

   hr = DSAdminOpenObject(pwzSchemaPath,
                          __uuidof(IADs), 
                          (void **)&spSchema);

   CHECK_HRESULT(hr, return hr);
   CComVariant var;

   hr = spSchema->Get(CComBSTR(L"fSMORoleOwner"), &var);

   CHECK_HRESULT(hr, return hr);
   CComVariant varSrvDnsName;
   CComPtr<IADs> spServer;

   hr = ReadDnsSrvName(var.bstrVal, spServer, varSrvDnsName);

   if (E_ADS_PROPERTY_NOT_FOUND == hr)
   {
      ErrMsg(IDS_PROMOTION_STILL_REPLICATING, GetDlgHwnd());
      _fCanRaiseBehaviorVersion = false;
      return S_FALSE;
   }

   _strFsmoDC = varSrvDnsName.bstrVal;

   CHECK_HRESULT(hr, return hr);
   CPathCracker PathCrack;

   hr = PathCrack.Set(_strPartitionsPath, ADS_SETTYPE_FULL);

   CHECK_HRESULT(hr, return hr);

   hr = PathCrack.Set(varSrvDnsName.bstrVal, ADS_SETTYPE_SERVER);

   CHECK_HRESULT(hr, return hr);
   CComBSTR bstrPartitionsPath;

   hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrPartitionsPath);

   CHECK_HRESULT(hr, return hr);

   CComPtr<IADs> spPartitions;

   hr = DSAdminOpenObject(bstrPartitionsPath, 
                          __uuidof(IADs), 
                          (void **)&spPartitions);
   if (FAILED(hr))
   {
      CHECK_HRESULT(hr, ;);
      //
      // Perhaps the FSMO holder is offline, try with the local DC.
      //
      hr = PathCrack.Set(_strDC, ADS_SETTYPE_SERVER);

      CHECK_HRESULT(hr, return hr);

      hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrPartitionsPath);

      CHECK_HRESULT(hr, return hr);

      hr = DSAdminOpenObject(bstrPartitionsPath,
                             __uuidof(IADs), 
                             (void **)&spPartitions);

      CHECK_HRESULT(hr, return hr);

      _fFsmoDcFound = false;
   }
   else
   {
      // Save the FSMO DC name.
      //
      _strDC = _strFsmoDC;

      // Set the server name on the saved paths to the new DC.
      //
      hr = PathCrack.Set(_strConfigPath, ADS_SETTYPE_FULL);

      CHECK_HRESULT(hr, return hr);

      hr = PathCrack.Set(varSrvDnsName.bstrVal, ADS_SETTYPE_SERVER);

      CHECK_HRESULT(hr, return hr);
      CComBSTR bstrConfigPath;

      hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrConfigPath);

      CHECK_HRESULT(hr, return hr);

      _strConfigPath = bstrConfigPath;
      _strPartitionsPath = bstrPartitionsPath;
   }

   CComVariant varVer;

   hr = spPartitions->Get(CComBSTR(g_wzBehaviorVersion), &varVer);

   if (E_ADS_PROPERTY_NOT_FOUND == hr)
   {
      _nCurVer = FOREST_VER_WIN2K;
      hr = S_OK;
   }
   else
   {
      CHECK_HRESULT(hr, return hr);

      _nCurVer = varVer.lVal;
   }

   _fInitialized = true;

   dspDebugOut((DEB_ITRACE, "Forest version on %ws is %u\n",
                _strPartitionsPath.GetBuffer(0), _nCurVer));
   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::GetString
//
//  Synopsis:  Return the string representation of the behavior version.
//
//-----------------------------------------------------------------------------
bool
CForestVersion::GetString(UINT nVer, CStrW & strVer)
{
   UINT nID = 0;

   switch (nVer)
   {
   case FOREST_VER_WIN2K:
      nID = IDS_FOR_VER_W2K;
      break;

   case FOREST_VER_XP_BETA:
      nID = IDS_FOR_VER_XP_BETA;
      break;

   case FOREST_VER_XP:
      nID = IDS_FOR_VER_XP;
      break;

   default:
      dspAssert(FALSE);
      return false;
   }
   // NOTICE-2002/02/12-ericb - SecurityPush: see LoadString note above.
   strVer.LoadString(g_hInstance, nID);

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::RaiseVersion
//
//  Synopsis:  Raise the forest behavior version.
//
//  Notes:     Currently only one choice for the new version which is why the
//             nVer parameter is not used.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::RaiseVersion(UINT nVer)
{
   TRACE(CForestVersion,RaiseVersion);
   UNREFERENCED_PARAMETER(nVer);
   if (!_fInitialized)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   HRESULT hr = S_OK;
   CComPtr<IADs> spPartitions;

   hr = DSAdminOpenObject(_strPartitionsPath,
                          __uuidof(IADs), 
                          (void **)&spPartitions);

   CHECK_HRESULT(hr, return hr);
   CComVariant var;

   var.vt = VT_I4;
   var.lVal = FOREST_VER_XP;

   hr = spPartitions->Put(CComBSTR(g_wzBehaviorVersion), var);

   CHECK_HRESULT(hr, return hr);

   hr = spPartitions->SetInfo();

   CHECK_HRESULT(hr, return hr);

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::CheckHighestPossible
//
//  Synopsis:  Enumerate all of the DCs to find the lowest version which thus
//             imposes a constraint on the highest version to which the forest
//             can be raised.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::CheckHighestPossible(void)
{
   TRACE(CForestVersion,CheckHighestPossible);
   if (!_fInitialized)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   if (IsHighest())
   {
      // We are already at the highest version, it can't be raised any further.
      //
      _fCanRaiseBehaviorVersion = false;
      return S_OK;
   }

   dspAssert(!_DcLogList.size());
   HRESULT hr = S_OK;
   CWaitCursor Wait;
   CPathCracker PathCrack;

   //
   // Search for the nTDSDSA objects. See if any DCs are running a downlevel
   // version of the OS.
   //
   hr = EnumDsaObjs(_strConfigPath, NULL, NULL, DOMAIN_VER_XP_NATIVE);

   CHECK_HRESULT(hr, return hr);

   // Don't check domain version unless all DCs are running .Net. This is
   // because the domain version check looks for the ntMixedDomain attribute
   // on the crossRef. There won't be one there until all forest DCs are
   // running .Net.
   //
   if (CanRaise())
   {
      //
      // Check the domain versions.
      //
      hr = CheckDomainVersions(_strPartitionsPath);

      CHECK_HRESULT(hr, return hr);
   }

   return S_OK;
}

WCHAR wzNcName[] = L"nCName";
WCHAR wzFlags[] = L"systemFlags";
WCHAR wzDnsRoot[] = L"dnsRoot";

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::CheckDomainVersions
//
//  Synopsis:  Enumerate the domains by enumerating the cross-refs and check
//             the version and mode on each. Build a list of mixed mode domains.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::CheckDomainVersions(PCWSTR pwzPartitionsPath)
{
   dspDebugOut((DEB_ITRACE, "Searching for crossRef objects under %ws\n",
                pwzPartitionsPath));
   CDSSearch Search;

   HRESULT hr = Search.Init(pwzPartitionsPath);

   CHECK_HRESULT(hr, return hr);
   PWSTR rgwzAttrs[] = {wzNcName, wzFlags, g_wzBehaviorVersion, g_wzDomainMode,
                        wzDnsRoot};

   Search.SetAttributeList(rgwzAttrs, ARRAYLENGTH(rgwzAttrs));

   hr = Search.SetSearchScope(ADS_SCOPE_SUBTREE);

   CHECK_HRESULT(hr, return hr);

   Search.SetFilterString(L"(objectCategory=crossRef)");

   hr = Search.DoQuery();

   CHECK_HRESULT(hr, return hr);
   CPathCracker PathCrack;

   while (SUCCEEDED(hr))
   {
      hr = Search.GetNextRow();

      if (hr == S_ADS_NOMORE_ROWS)
      {
         hr = S_OK;
         break;
      }

      CHECK_HRESULT(hr, return hr);
      ADS_SEARCH_COLUMN Column = {0};

      hr = Search.GetColumn(wzFlags, &Column);

      if (E_ADS_COLUMN_NOT_SET == hr)
      {
         continue;
      }
      CHECK_HRESULT(hr, return hr);

      DWORD dwFlags = Column.pADsValues->Integer;

      Search.FreeColumn(&Column);

      if (!(FLAG_CR_NTDS_DOMAIN & dwFlags))
      {
         // Only domain cross-refs have the FLAG_CR_NTDS_DOMAIN bit set.
         //
         continue;
      }

      CStrW strNcName;

      hr = Search.GetColumn(wzNcName, &Column);

      CHECK_HRESULT(hr, return hr);

      strNcName = Column.pADsValues->CaseIgnoreString;

      Search.FreeColumn(&Column);

      hr = PathCrack.Set(strNcName, ADS_SETTYPE_DN);

      CHECK_HRESULT(hr, return hr);

      hr = PathCrack.Set(_strDC, ADS_SETTYPE_SERVER);

      CHECK_HRESULT(hr, return hr);
      CComBSTR bstrDomain;

      hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrDomain);

      CHECK_HRESULT(hr, return hr);

      bool fMixed = true;

      hr = Search.GetColumn(g_wzDomainMode, &Column);

      if (E_ADS_PROPERTY_NOT_FOUND == hr ||
          E_ADS_COLUMN_NOT_SET == hr)
      {
         // E_ADS_PROPERTY_NOT_FOUND: W2K forest won't have the mixed-mode
         // attribute on the cross-ref.
         // E_ADS_COLUMN_NOT_SET: Whistler domain still in mixed mode.
         // fMixed initialized to true above.
         //
         hr = S_OK;
      }
      else
      {
         CHECK_HRESULT(hr, return hr);

         fMixed = Column.pADsValues->Integer != 0;

         Search.FreeColumn(&Column);
      }

      DWORD dwVersion = 0;

      hr = Search.GetColumn(g_wzBehaviorVersion, &Column);

      if (E_ADS_PROPERTY_NOT_FOUND == hr ||
          E_ADS_COLUMN_NOT_SET == hr)
      {
         // E_ADS_PROPERTY_NOT_FOUND: W2K forest won't have the behavior version
         // attribute.
         // E_ADS_COLUMN_NOT_SET: Whistler domain still has BV = 0.
         // dwVersion initialized to zero above.
         //
         hr = S_OK;
      }
      else
      {
         CHECK_HRESULT(hr, return hr);

         dwVersion = Column.pADsValues->Integer;

         Search.FreeColumn(&Column);
      }

      if (dwVersion < DOMAIN_VER_XP_NATIVE && fMixed)
      {
         // The domain is still in mixed mode, can't do a forest behavior
         // version upgrade.
         //
         hr = Search.GetColumn(wzDnsRoot, &Column);

         CHECK_HRESULT(hr, return hr);
         CStrW strDnsDomainName;

         strDnsDomainName = Column.pADsValues->CaseIgnoreString;

         Search.FreeColumn(&Column);

         CDomainListItem * pDomainItem = new CDomainListItem(strDnsDomainName,
                                                             dwVersion,
                                                             true);
         CHECK_NULL(pDomainItem, return E_OUTOFMEMORY);

         _DomainLogList.push_back(pDomainItem);

         _fCanRaiseBehaviorVersion = false;
      }
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CForestVersion::BuildMixedModeList
//
//  Synopsis:  Build the display string for the log file.
//
//  Notes:     Using the domain object to get domain version strings. The
//             domain object does not need to be initialized in this case.
//
//-----------------------------------------------------------------------------
HRESULT
CForestVersion::BuildMixedModeList(CStrW & strList)
{
   CDomainVersion DomVer;

   for (DOMAIN_LIST::iterator i = _DomainLogList.begin();
        i != _DomainLogList.end();
        ++i)
   {
      strList += (*i)->GetDnsDomainName();

      strList += L"\t";

      CStrW strVer;

      DomVer.GetString((*i)->GetVer(), (*i)->GetMode(), strVer);

      strList += strVer;

      strList += g_wzCRLF;
   }
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\domainversion.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      DomainVersion.cxx
//
//  Contents:  Dialogs and supporting code for displaying and raising the
//             domain version.
//
//  History:   14-April-01 EricB created
//
//
//-----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "proppage.h"
#include "BehaviorVersion.h"

//+----------------------------------------------------------------------------
//
//  Function:  DSPROP_DomainVersionDlg
//
//  Synopsis:  Puts up a dialog that allows the user to view the domain version
//             levels available and if not at the highest level, to raise the
//             domain version.
//
//  Arguments: [pwzDomainPath] - The full ADSI path to the Domain-DNS object.
//             [pwzDomainDnsName] - The DNS name of the domain.
//             [hWndParent] - The caller's top level window handle.
//
//-----------------------------------------------------------------------------
void
DSPROP_DomainVersionDlg(PCWSTR pwzDomainPath,
                        PCWSTR pwzDomainDnsName,
                        HWND hWndParent)
{
   dspDebugOut((DEB_ITRACE, "DSPROP_DomainVersionDlg, domain: %ws\n", pwzDomainPath));
   if (!pwzDomainPath || !pwzDomainDnsName || !hWndParent || !IsWindow(hWndParent))
   {
      dspAssert(FALSE);
      return;
   }
   HRESULT hr = S_OK;

   CDomainVersion DomVer(pwzDomainPath, pwzDomainDnsName);

   //
   // Call CDomainVersion::Init to locate a PDC and read the intial state.
   //
   hr = DomVer.Init();

   if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
   {
      ErrMsgParam(IDS_ERR_NO_DC, (LPARAM)pwzDomainDnsName, hWndParent);
      return;
   }
   CHECK_HRESULT_REPORT(hr, hWndParent, return);

   hr = DomVer.CheckHighestPossible();

   if (E_ADS_PROPERTY_NOT_FOUND == hr)
   {
      ErrMsg(IDS_DOM_VER_NOT_FOUND, hWndParent);
      return;
   }
   CHECK_HRESULT_REPORT(hr, hWndParent, return);

   int nTemplateID = IDD_RAISE_DOMAIN_VERSION;
   if (!DomVer.CanRaise())
   {
      nTemplateID = (DomVer.IsHighest()) ?
                         IDD_HIGHEST_DOMAIN_VERSION : IDD_CANT_RAISE_DOMAIN;
   }

   CDomainVersionDlg dialog(hWndParent, pwzDomainDnsName, DomVer, nTemplateID);

   dialog.DoModal();
}

//+----------------------------------------------------------------------------
//
//  Class:     CDomainVersionDlg
//
//  Purpose:   Raise the domain behavior version and/or mode.
//
//-----------------------------------------------------------------------------
CDomainVersionDlg::CDomainVersionDlg(HWND hParent,
                                     PCWSTR pwzDomDNS,
                                     CDomainVersion & DomVer,
                                     int nTemplateID) :
   _strDomainDnsName(pwzDomDNS),
   _DomainVer(DomVer),
   CModalDialog(hParent, nTemplateID)
{
    TRACE(CDomainVersionDlg,CDomainVersionDlg);
#ifdef _DEBUG
    // NOTICE-2002/02/12-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
    strcpy(szClass, "CDomainVersionDlg");
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::OnInitDialog
//
//  Synopsis:  Set the initial control values.
//
//-----------------------------------------------------------------------------
LRESULT
CDomainVersionDlg::OnInitDialog(LPARAM lParam)
{
   TRACE(CDomainVersionDlg,OnInitDialog);

   SetDlgItemText(_hDlg, IDC_VER_NAME_STATIC, _strDomainDnsName);

   _DomainVer.SetDlgHwnd(_hDlg);

   CStrW strVersion;
   _DomainVer.GetString(_DomainVer.GetVer(), strVersion);

   SetDlgItemText(_hDlg, IDC_CUR_VER_STATIC, strVersion);

   if (_DomainVer.CanRaise())
   {
      InitCombobox();

      if (!_DomainVer.IsPDCfound() || _DomainVer.IsReadOnly())
      {
         EnableWindow(GetDlgItem(_hDlg, IDOK), FALSE);
         CStrW strMsg;
         // NOTICE-2002/02/12-ericb - SecurityPush: CStrW::LoadString sets the
         // string to an empty string on failure.
         strMsg.LoadString(g_hInstance, _DomainVer.IsReadOnly() ?
                              IDS_CANT_RAISE_ACCESS : IDS_CANT_RAISE_PDC);
         SetDlgItemText(_hDlg, IDC_CANT_RAISE_STATIC, strMsg);
      }
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::OnCommand
//
//  Synopsis:  Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDomainVersionDlg::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   switch (codeNotify)
   {
   case BN_CLICKED:
      switch (id)
      {
      case IDOK:
         OnOK();
         break;

      case IDCANCEL:
         EndDialog(_hDlg, IDCANCEL);
         break;

      case IDC_HELP_BTN:
         ShowHelp(L"ADConcepts.chm::/sag_levels.htm");
         break;

      case IDC_SAVE_LOG:
         OnSaveLog();
         break;
      }
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::OnOK
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
void
CDomainVersionDlg::OnOK(void)
{
   CDomainVersion::eDomVer Ver = ReadComboSel();

   dspDebugOut((DEB_ITRACE, "Combobox selection was %d\n", Ver));

   if (CDomainVersion::error == Ver)
   {
      // No user selection. Set one and return.
      SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_SETCURSEL, 0, 0);
      return;
   }

   int iRet = IDCANCEL;
   CStrW strTitle, strMsg;
   // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::Loadstring notice
   strTitle.LoadString(g_hInstance, IDS_RAISE_DOM_VER_TITLE);
   strMsg.LoadString(g_hInstance, IDS_CONFIRM_DOM_RAISE);

   iRet = MessageBox(_hDlg, strMsg, strTitle, MB_OKCANCEL | MB_ICONEXCLAMATION | MB_DEFBUTTON2);

   if (iRet == IDOK)
   {
      HRESULT hr = _DomainVer.RaiseVersion(Ver);

      if (SUCCEEDED(hr))
      {
         // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::Loadstring notice
         strMsg.LoadString(g_hInstance, IDS_DOMAIN_MODE_CHANGED);
         MessageBox(_hDlg, strMsg, strTitle, MB_OK | MB_ICONINFORMATION);
      }
      else
      {
         REPORT_ERROR_FORMAT(hr, IDS_VERSION_ERROR_FORMAT, _hDlg);
      }

      EndDialog(_hDlg, IDOK);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::OnSaveLog
//
//  Synopsis:  Prompts the user for a file name to save the DC log.
//
//-----------------------------------------------------------------------------
void
CDomainVersionDlg::OnSaveLog(void)
{
   TRACE(CDomainVersionDlg,OnSaveLog);
   HRESULT hr = S_OK;
   OPENFILENAME ofn = {0};
   WCHAR wzFilter[MAX_PATH + 1] = {0}, wzFileName[MAX_PATH + MAX_PATH + 1] = {0};
   CStrW strFilter, strExt, strMsg;
   CWaitCursor Wait;

   // NOTICE-2002/02/12-ericb - SecurityPush: wzFileName is initialized to be all
   // nulls and is one char longer than the length passed to wcsncpy so that the
   // result is always null terminated even if _strDomainDnsName were longer than
   // MAX_PATH + MAX_PATH. The calls to wcsncat are correct because they pass
   // in the remaining buffer capacity, not the total buffer length.
   //
   wcsncpy(wzFileName, _strDomainDnsName, MAX_PATH + MAX_PATH);
   // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::LoadString note
   strExt.LoadString(g_hInstance, IDS_FTFILE_SUFFIX);
   wcsncat(wzFileName, strExt, MAX_PATH + MAX_PATH - wcslen(wzFileName));
   wcsncat(wzFileName, L".", MAX_PATH + MAX_PATH - wcslen(wzFileName));
   strExt.LoadString(g_hInstance, IDS_FTFILE_CSV_EXT);
   wcsncat(wzFileName, strExt, MAX_PATH + MAX_PATH - wcslen(wzFileName));

   // NOTICE-2002/02/12-ericb - SecurityPush: wzFilter is initialized to all
   // zeros and is one char longer than the length passed to LoadString.
   //
   LoadString(g_hInstance, IDS_FTFILE_FILTER, wzFilter, MAX_PATH);

   ofn.lStructSize = sizeof(ofn);
   ofn.hwndOwner = _hDlg;
   ofn.lpstrFile = wzFileName;
   ofn.nMaxFile = MAX_PATH + MAX_PATH + 1;
   ofn.Flags = OFN_OVERWRITEPROMPT;
   ofn.lpstrDefExt = strExt;
   ofn.lpstrFilter = wzFilter;

   if (GetSaveFileName(&ofn))
   {
      dspDebugOut((DEB_ITRACE, "Saving domain DC version info to %ws\n", ofn.lpstrFile));
      PWSTR pwzErr = NULL;
      BOOL fSucceeded = TRUE;

      HANDLE hFile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0,
                                NULL, CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL, NULL);

      if (INVALID_HANDLE_VALUE != hFile)
      {
         CStrW str, strFormat;
         strMsg = g_wzBOM; // start with ByteOrderMark
         // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::LoadString note
         strFormat.LoadString(g_hInstance, IDS_DOM_VER_LOG_PREFIX);
         str.Format(strFormat, _strDomainDnsName);
         strMsg += str;
         _DomainVer.GetString(_DomainVer.GetVer(), str);
         strMsg += str;
         strMsg += g_wzCRLF;
         strMsg += g_wzCRLF;
         str.LoadString(g_hInstance, IDS_DOM_VER_LOG_HDR);
         strMsg += str;
         strMsg += g_wzCRLF;

         hr = _DomainVer.BuildDcListString(strMsg);

         if (SUCCEEDED(hr))
         {
            strMsg += g_wzCRLF;

            DWORD dwWritten;

            // NOTICE-2002/02/12-ericb - SecurityPush: WriteFile takes the number
            // of bytes to write as its third parameter which in this case is the
            // length of the UNICODE string times the size of a UNICODE character.
            //
            fSucceeded = WriteFile(hFile, strMsg.GetBuffer(0),
                                   strMsg.GetLength() * sizeof(WCHAR),
                                   &dwWritten, NULL);
         }
         CloseHandle(hFile);
      }
      else
      {
         fSucceeded = FALSE;
      }


      if (!fSucceeded || FAILED(hr))
      {
         CStrW strTitle;
         // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::Loadstring notice
         strTitle.LoadString(g_hInstance, IDS_DNT_MSG_TITLE);
         LoadErrorMessage(FAILED(hr) ? hr : GetLastError(), 0, &pwzErr);
         if (pwzErr)
         {
            // NOTICE-2002/02/12-ericb - SecurityPush: if CStrW::FormatMessage
            // fails it sets the string value to an empty string.
            strMsg.FormatMessage(g_hInstance, IDS_LOGFILE_CREATE_FAILED, pwzErr);
            delete [] pwzErr;
         }
         MessageBox(_hDlg, strMsg, strTitle, MB_ICONERROR);
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::InitCombobox
//
//  Synopsis:  Fills the combobox with levels appropriate for the current
//             state.
//
//-----------------------------------------------------------------------------
void
CDomainVersionDlg::InitCombobox(void)
{
   CStrW strVersion;

   switch (_DomainVer.GetVer())
   {
   case CDomainVersion::Win2kMixed:
      //
      // Can go to Win2kNative.
      //
      _DomainVer.GetString(CDomainVersion::Win2kNative, strVersion);
      SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_INSERTSTRING, 0,
                         (LPARAM)(PCWSTR)strVersion);
      if (_DomainVer.HighestCanGoTo() == CDomainVersion::WhistlerNative)
      {
         //
         // Can also go all the way to Whistler.
         //
         _DomainVer.GetString(CDomainVersion::WhistlerNative, strVersion);
         SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_INSERTSTRING, 1,
                            (LPARAM)(PCWSTR)strVersion);
      }
      break;

   case CDomainVersion::Win2kNative:
   case CDomainVersion::WhistlerBetaMixed:
   case CDomainVersion::WhistlerBetaNative:
      //
      // Can only go to Whistler.
      //
      _DomainVer.GetString(CDomainVersion::WhistlerNative, strVersion);
      SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_INSERTSTRING, 0,
                         (LPARAM)(PCWSTR)strVersion);
      break;

   default:
      dspAssert(FALSE);
      return;
   }

   SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_SETCURSEL, 0, 0);
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersionDlg::ReadComboSel
//
//  Synopsis:  Read the current selection of the combobox.
//
//-----------------------------------------------------------------------------
CDomainVersion::eDomVer
CDomainVersionDlg::ReadComboSel(void)
{
   LONG_PTR lRet = SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_GETCURSEL, 0, 0);

   if (CB_ERR == lRet)
   {
      return CDomainVersion::error;
   }

   switch (_DomainVer.GetVer())
   {
   case CDomainVersion::Win2kMixed:
      return (0 == lRet) ? CDomainVersion::Win2kNative : CDomainVersion::WhistlerNative;

   case CDomainVersion::WhistlerBetaMixed:
   case CDomainVersion::Win2kNative:
   case CDomainVersion::WhistlerBetaNative:
      dspAssert(1 == SendDlgItemMessage(_hDlg, IDC_VER_COMBO, CB_GETCOUNT, 0, 0));
      return CDomainVersion::WhistlerNative;

   default:
      dspAssert(FALSE);
      return CDomainVersion::error;
   }
}

//+----------------------------------------------------------------------------
//
//  Class:     CDomainVersion
//
//  Purpose:   Manages the interpretation of the domain version value.
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::Init
//
//  Synopsis:  Locate a PDC and set up the initial state. This version of Init
//             assumes that the domain FQDN is not known and attempts to
//             determine it.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainVersion::Init(PCWSTR pwzDcName, HWND hWnd)
{
   CWaitCursor Wait;
   HRESULT hr = S_OK;
   dspAssert(_strFullDomainPath.IsEmpty());

   if (_strDomainDnsName.IsEmpty() || !pwzDcName)
   {
      dspAssert(false);
      return E_INVALIDARG;
   }

   // Get the FQDN for the domain object. Pass the domain's cannonical name by
   // appending a forward slash.
   //
   CStrW strDomainCannonicalName = _strDomainDnsName;
   strDomainCannonicalName += L"/";

   HANDLE           hDs = NULL;
   PDS_NAME_RESULT  pCrackResult = NULL;
   LPWSTR           rnames[] = { (PWSTR) strDomainCannonicalName };

   hr = DsBind(pwzDcName, NULL, &hDs);
   CHECK_HRESULT(hr, return hr);

   hr = DsCrackNames (   
                        hDs, 
                        DS_NAME_NO_FLAGS, 
                        DS_UNKNOWN_NAME, 
                        DS_FQDN_1779_NAME,
                        1,
                        rnames, 
                        &pCrackResult
                     );

   DsUnBind ( &hDs );

   if ( FAILED (hr) )
   {
       if ( pCrackResult )
           DsFreeNameResult( pCrackResult );
   }
   CHECK_HRESULT(hr, return hr);

   if ( pCrackResult && pCrackResult->cItems > 0 )
   {
        _strFullDomainPath = pCrackResult->rItems[0].pName;
        DsFreeNameResult( pCrackResult );
   }
   else 
   {
       if ( pCrackResult )
           DsFreeNameResult( pCrackResult );

       CHECK_HRESULT( ERROR_DS_NAME_ERROR_NO_MAPPING, return ERROR_DS_NAME_ERROR_NO_MAPPING);
   }

   CPathCracker PathCrack;

   hr = PathCrack.Set(CComBSTR(_strFullDomainPath.GetBuffer(0)), ADS_SETTYPE_DN);

   CHECK_HRESULT(hr, return hr);

   hr = PathCrack.Set(CComBSTR(pwzDcName), ADS_SETTYPE_SERVER);

   CHECK_HRESULT(hr, return hr);

   CComBSTR bstrFullPath;

   hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrFullPath);

   CHECK_HRESULT(hr, return hr);

   _strFullDomainPath = bstrFullPath;

   return Init();
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::Init
//
//  Synopsis:  Locate a PDC and set up the initial state.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainVersion::Init(void)
{
   TRACE(CDomainVersion,Init);
   CWaitCursor Wait;
   HRESULT hr = S_OK;
   DWORD dwErr;
   PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
   CComBSTR bstrPath;
   CPathCracker PathCrack;

   if (_strDomainDnsName.IsEmpty())
   {
      dspAssert(false);
      return E_INVALIDARG;
   }
   if (_strFullDomainPath.IsEmpty())
   {
      dspAssert(false);
      return E_INVALIDARG;
   }

   hr = PathCrack.Set(CComBSTR(_strFullDomainPath.GetBuffer(0)), ADS_SETTYPE_FULL);

   CHECK_HRESULT(hr, return hr);

   CComBSTR bstrDC;

   hr = PathCrack.Retrieve(ADS_FORMAT_SERVER, &bstrDC);

   CHECK_HRESULT(hr, return hr);

   //
   // Get the PDC's name.
   //
   dwErr = DsGetDcNameW(NULL, _strDomainDnsName, NULL, NULL, 
                        DS_PDC_REQUIRED, &pDCInfo);

   if (dwErr != ERROR_SUCCESS)
   {
      dspDebugOut((DEB_ERROR, "DsGetDcName failed with error 0x%08x in domain %ws\n",
                   dwErr, _strDomainDnsName.GetBuffer(0)));

      _fPDCfound = false;

      //
      // PDC is not online. Check to see if any DC is available.
      //
      dwErr = DsGetDcNameW(NULL, _strDomainDnsName, NULL, NULL, 
                           DS_DIRECTORY_SERVICE_REQUIRED, &pDCInfo);

      CHECK_WIN32(dwErr, return HRESULT_FROM_WIN32(dwErr));
      NetApiBufferFree(pDCInfo);

      _strDC = bstrDC; // continue to use the DC the snapin is bound to.
   }
   else
   {
      _fPDCfound = true;

      _strDC = pDCInfo->DomainControllerName + 2; // skip the backslashes

      NetApiBufferFree(pDCInfo);

      //
      // Reset the domain path to include the PDC name.
      //
      if (_strDC.CompareNoCase(bstrDC))
      {
         hr = PathCrack.Set(CComBSTR(_strDC.GetBuffer(0)), ADS_SETTYPE_SERVER);         

         CHECK_HRESULT(hr, return hr);

         hr = PathCrack.Retrieve(ADS_FORMAT_X500, &bstrPath);

         CHECK_HRESULT(hr, return hr);

         _strFullDomainPath = bstrPath;

         dspDebugOut((DEB_ITRACE, "new path: %ws\n", _strFullDomainPath.GetBuffer(0)));
      }
   }

   //
   // Get the base DN for the domain;
   //
   hr = PathCrack.Retrieve(ADS_FORMAT_X500_DN, &bstrPath);

   CHECK_HRESULT(hr, return hr);

   _strDomainDN = bstrPath;

   //
   // Check if the user has write access to the behavior version and mode
   // attrs. Read the mode and version.
   //
   CComPtr<IDirectoryObject> spDomain;

   hr = DSAdminOpenObject(_strFullDomainPath, 
                          __uuidof(IDirectoryObject), 
                          (void **)&spDomain);

   CHECK_HRESULT(hr, return hr);

   Smart_PADS_ATTR_INFO pAttrs;
   DWORD cAttrs = 0;
   PWSTR rgwzNames[] = {g_wzAllowed, g_wzDomainMode, g_wzBehaviorVersion};

   hr = spDomain->GetObjectAttributes(rgwzNames, ARRAYLENGTH(rgwzNames),
                                      &pAttrs, &cAttrs);

   if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, NULL))
   {
      return hr;
   }
   bool fBVfound = false, fModeFound = false;

   // NOTICE-2002/02/12-ericb - SecurityPush: _wcsicmp is comparing ADSI data
   // with static strings. Check to make sure the ADSI pointers are valid before
   // doing the comparisons.
   size_t cch = 0;
   for (UINT i = 0; i < cAttrs; i++)
   {
      if (pAttrs[i].pszAttrName)
      {
         if (SUCCEEDED(StringCchLength(pAttrs[i].pszAttrName, wcslen(g_wzAllowed)+1, &cch)) &&
             _wcsnicmp(pAttrs[i].pszAttrName, g_wzAllowed, cch) == 0)
         {
            for (DWORD j = 0; j < pAttrs[i].dwNumValues && !(fBVfound && fModeFound); j++)
            {
               if (pAttrs[i].pADsValues[j].CaseIgnoreString)
               {
                  if (SUCCEEDED(StringCchLength(pAttrs[i].pADsValues[j].CaseIgnoreString,
                                wcslen(g_wzBehaviorVersion)+1, &cch)) &&
                      _wcsnicmp(pAttrs[i].pADsValues[j].CaseIgnoreString, g_wzBehaviorVersion, cch) == 0)
                  {
                     fBVfound = true;
                     continue;
                  }
               }
               if (pAttrs[i].pADsValues[j].CaseIgnoreString)
               {
                  if (SUCCEEDED(StringCchLength(pAttrs[i].pADsValues[j].CaseIgnoreString,
                                wcslen(g_wzDomainMode)+1, &cch)) &&
                      _wcsnicmp(pAttrs[i].pADsValues[j].CaseIgnoreString, g_wzDomainMode, cch) == 0)
                  {
                     fModeFound = true;
                  }
               }
            }
            continue;
         }
         if (SUCCEEDED(StringCchLength(pAttrs[i].pszAttrName, wcslen(g_wzBehaviorVersion)+1, &cch)) &&
             _wcsnicmp(pAttrs[i].pszAttrName, g_wzBehaviorVersion, cch) == 0)
         {
            _nCurVer = (UINT)pAttrs[i].pADsValues->Integer;
            continue;
         }
         if (SUCCEEDED(StringCchLength(pAttrs[i].pszAttrName, wcslen(g_wzDomainMode)+1, &cch)) &&
             _wcsnicmp(pAttrs[i].pszAttrName, g_wzDomainMode, cch) == 0)
         {
            _fMixed = pAttrs[i].pADsValues->Integer != 0;
         }
      }
   }

   if (fBVfound && fModeFound)
   {
      _fReadOnly = false;
   }

   if (0 == _nCurVer && fModeFound)
   {
      // Pure Win2k domains don't have a behavior version attribute.
      //
      _fReadOnly = false;
   }

   _fInitialized = true;

   dspDebugOut((DEB_ITRACE, "mode on %ws is %s, version is %u\n", _strFullDomainPath.GetBuffer(0),
                _fMixed ? "mixed" : "native", _nCurVer));

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::CheckHighestPossible
//
//  Synopsis:  Check what version is the highest allowable: query those nTDSDSA
//             objects whose hasMasterNCs includes the DN of the domain. Calc
//             the min version of the result set.
//
// 2002/04/01 JonN 531591 use msDS-hasMasterNCs if available
//
//-----------------------------------------------------------------------------
HRESULT
CDomainVersion::CheckHighestPossible(void)
{
   TRACE(CDomainVersion,CheckHighestPossible);
   if (!_fInitialized)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   if (IsHighest())
   {
      // We are already at the highest version, it can't be raised any further.
      //
      dspAssert(!_fMixed);
      _fCanRaiseBehaviorVersion = false;
      return S_OK;
   }

   dspAssert(!_DcLogList.size());
   HRESULT hr = S_OK;
   CWaitCursor Wait;
   //
   // Get the config container path from the RootDSE and then build the path to
   // the Sites container.
   //
   CComPtr<IADs> spRoot;
   CStrW strRootPath = g_wzLDAPPrefix;
   strRootPath += _strDC;
   strRootPath += L"/";
   strRootPath += g_wzRootDSE;

   hr = DSAdminOpenObject(strRootPath,
                          __uuidof(IADs), 
                          (void **)&spRoot);

   CHECK_HRESULT(hr, return hr);

   CComVariant var;

   hr = spRoot->Get(CComBSTR(g_wzConfigNamingContext), &var);

   CHECK_HRESULT(hr, return hr);
   dspAssert(VT_BSTR == var.vt);

   CStrW strSitesPath = g_wzLDAPPrefix;
   strSitesPath += _strDC;
   strSitesPath += L"/CN=Sites,";
   strSitesPath += var.bstrVal;

   //
   // Search for the nTDSDSA objects that belong to this domain.
   //
   // 531591 JonN 2002/04/01 .NET Server domains use msDS-hasMasterNCs
   WCHAR wzSearchClauseFormat[] = L"(|(msDS-hasMasterNCs=%s)(hasMasterNCs=%s))";
   CStrW strFilterClause;
   strFilterClause.Format(wzSearchClauseFormat,
                          _strDomainDN.GetBuffer(0),
                          _strDomainDN.GetBuffer(0));

   hr = EnumDsaObjs(strSitesPath, strFilterClause, _strDomainDnsName, _nCurVer + 1);

   CHECK_HRESULT(hr, return hr);

   if (!_fCanRaiseBehaviorVersion)
   {
      // Non-conforming DCs were found, set the max version.
      //
      _eHighest = Win2kNative;
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::MapVersion
//
//  Synopsis:  Returns an enum value for the legal combinations of version and
//             mode.
//
//-----------------------------------------------------------------------------
CDomainVersion::eDomVer
CDomainVersion::MapVersion(UINT nVer, bool fMixed) const
{
   switch (nVer)
   {
   case DOMAIN_VER_WIN2K_MIXED: // and DOMAIN_VER_WIN2K_NATIVE:
      return (fMixed) ? Win2kMixed : Win2kNative;

   case DOMAIN_VER_XP_BETA_MIXED: // and DOMAIN_VER_XP_BETA_NATIVE:
      return (fMixed) ? WhistlerBetaMixed : WhistlerBetaNative;

   case DOMAIN_VER_XP_NATIVE:
      if (fMixed)
      {
         dspAssert(FALSE);
         return error;
      }
      return WhistlerNative;

   case DOMAIN_VER_UNKNOWN:
      return unknown;
   }
   return error;
}


//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::GetString
//
//  Synopsis:  Returns the string description of the domain version.
//
//  Note:      The GetString methods can be called without having called Init
//             first.
//
//-----------------------------------------------------------------------------
bool
CDomainVersion::GetString(UINT nVer, bool fMixed, CStrW & strVersion) const
{
   return GetString(MapVersion(nVer, fMixed), strVersion);
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::GetString
//
//-----------------------------------------------------------------------------
bool
CDomainVersion::GetString(eDomVer ver, CStrW & strVersion) const
{
   UINT nID = 0;

   switch (ver)
   {
   case Win2kMixed:
      nID = IDS_DOM_VER_W2K_MIXED;
      break;

   case Win2kNative:
      nID = IDS_DOM_VER_W2K_NATIVE;
      break;

   case WhistlerBetaMixed:
      nID = IDS_DOM_VER_XP_BETA_MIXED;
      break;

   case WhistlerBetaNative:
      nID = IDS_DOM_VER_XP_BETA_NATIVE;
      break;

   case WhistlerNative:
      nID = IDS_DOM_VER_XP;
      break;

   case unknown:
      nID = IDS_REL_UNKNOWN;
      break;

   default:
      dspAssert(FALSE);
      return false;
   }

   // NOTICE-2002/02/12-ericb - SecurityPush: see the above CStrW::LoadString notice.
   return strVersion.LoadString(g_hInstance, nID) == TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::GetMode
//
//  Synopsis:  Return the domain mode. Read it from the nTMixedDomain attribute
//             if not yet checked.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainVersion::GetMode(bool & fMixed)
{
   TRACE(CDomainVersion,GetMode);

   if (!_fInitialized)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   fMixed = _fMixed;

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::SetNativeMode
//
//  Synopsis:  Set the domain into native mode.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainVersion::SetNativeMode(void)
{
   TRACE(CDomainVersion,SetNativeMode);
   if (!_fInitialized)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   HRESULT hr = S_OK;
   CComPtr<IADs> spDomain;

   hr = DSAdminOpenObject(_strFullDomainPath,
                          __uuidof(IADs), 
                          (void **)&spDomain);

   CHECK_HRESULT(hr, return hr);
   CComVariant var;

   var.vt = VT_I4;
   var.lVal = 0;

   hr = spDomain->Put(CComBSTR(g_wzDomainMode), var);

   CHECK_HRESULT(hr, return hr);

   hr = spDomain->SetInfo();

   CHECK_HRESULT(hr, return hr);

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDomainVersion::RaiseVersion
//
//  Synopsis:  Raise the domain version. If needed, set the domain mode to
//             native.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainVersion::RaiseVersion(eDomVer NewVer)
{
   TRACE(CDomainVersion,RaiseVersion);
   if (!_fInitialized)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   CWaitCursor Wait;
   HRESULT hr = S_OK;
   CComPtr<IADs> spDomain;

   hr = DSAdminOpenObject(_strFullDomainPath,
                          __uuidof(IADs), 
                          (void **)&spDomain);

   CHECK_HRESULT(hr, return hr);

   CComVariant var;

   switch (NewVer)
   {
   case Win2kNative:
      dspAssert(MapVersion(_nCurVer, _fMixed) == Win2kMixed);
      hr = SetNativeMode();
      CHECK_HRESULT(hr, ;);
      return hr;

   case WhistlerBetaMixed:
   case WhistlerBetaNative:
      //
      // Should never be requesting these versions.
      //
      dspAssert(FALSE);
      return E_INVALIDARG;

   case WhistlerNative:
      if (_fMixed)
      {
         hr = SetNativeMode();
         CHECK_HRESULT(hr, return hr);
      }
      var.vt = VT_I4;
      var.lVal = DOMAIN_VER_XP_NATIVE;
      break;

   default:
      dspAssert(FALSE);
      return E_INVALIDARG;
   }

   hr = spDomain->Put(CComBSTR(g_wzBehaviorVersion), var);

   CHECK_HRESULT(hr, return hr);

   hr = spDomain->SetInfo();

   CHECK_HRESULT(hr, return hr);

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\fpnw.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       fpnw.cxx
//
//--------------------------------------------------------------------------

////////////////////////////////////////////////////////////
// fpnw.cxx : 
//  Handles the FPNW page on the user object property sheet
//

#include "pch.h"
#include "proppage.h"
#include "pages.h"
#include "fpnw.h"
#include "fpnwcomm.h"
extern "C" {
#include "usrprop.h"
#include "icanon.h" // NetpPathType
}
#include "lmerr.h" // NERR_Success
#include "lmaccess.h" // USER_MODALS_INFO_0
#include "netlibnt.h" // NetpNtStatusToApiStatus 

// CODEWORK net\ui\admin\user\h\nwlb.hxx
#define NETWORKSIZE  8
#define NODESIZE     12

#define SZ_ALL_NODES_ADDR             _T("ffffffffffff")

#define SZ_FPNWCLNT_DLL               _T("fpnwclnt.dll")
#define SZ_MAPRIDTOOBJECTID           "MapRidToObjectId"
#define SZ_SWAPOBJECTID               "SwapObjectId"
#define SZ_RETURNNETWAREFORM          "ReturnNetwareForm"
#define SZ_FPNWVOLUMEGETINFO          "FpnwVolumeGetInfo"
#define SZ_FPNWAPIBUFFERFREE          "FpnwApiBufferFree"

#define MIN_PASS_LEN_MAX                14 // from net\ui\admin\user\user\secset.cxx
#define SZ_MAIL_DIR                     _T("MAIL\\")  // from net\ui\admin\user\user\ncp.cxx
#define SZ_LOGIN_FILE                   _T("\\LOGIN") // from net\ui\admin\user\user\ncp.cxx
#define NO_GRACE_LOGIN_LIMIT            0xFF      // from net\ui\admin\user\user\ncp.cxx
#define NT_TIME_RESOLUTION_IN_SECOND    10000000  // from net\ui\admin\user\user\nwuser.cxx

#define FPNW_FIELDS_NWPASSWORD          0x00000001
#define FPNW_FIELDS_NWTIMEPASSWORDSET   0x00000002
#define FPNW_FIELDS_GRACELOGINALLOWED   0x00000004
#define FPNW_FIELDS_GRACELOGINREMAINING 0x00000008
#define FPNW_FIELDS_MAXCONNECTIONS      0x00000010
#define FPNW_FIELDS_NWHOMEDIR           0x00000020
#define FPNW_FIELDS_LOGONFROM           0x00000040

#define ATTR_USERPARMS                  L"userParameters"
#define ATTR_USERACCOUNTCONTROL         L"userAccountControl"
#define ATTR_OBJECTSID                  L"objectSid"
#define ATTR_SAMACCOUNTNAME             L"sAMAccountName"
#define ATTR_FSMOROLEOWNER              L"fSMORoleOwner"

#define LOGIN_SCRIPT_FILE_READ          0
#define LOGIN_SCRIPT_FILE_WRITE         1

#define FPNW_CHECK_RETURN(bVal, idError, nStr, hWnd, returnVal) \
if (!(bVal)) \
{if (hWnd) ReportError((idError), (nStr), (hWnd)); \
return (returnVal);}

// globals

extern Cache g_FPNWCache;

static WNDPROC g_fnOldEditCtrlProc;

///////////////////////////////////////////
// Implementation for class CFPNWLinkList 
//

void FreeFPNWCacheElem(PFPNWCACHE p)
{
  if (p) {
    if (p->pwzPDCName)
      LocalFree(p->pwzPDCName);
    LocalFree(p);
  }

  return;
}

//////////////////////////////////////////
// Implementation for class CDsFPNWPage
//

CDsFPNWPage::CDsFPNWPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                         HWND hNotifyObj, DWORD dwFlags) 
  : CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsFPNWPage,CDsFPNWPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsFPNWPage");
#endif

  m_cstrUserParms = _T("");
  m_pwzPDCName = NULL;
  m_pwzSecretKey = NULL;
  m_bMaintainNetwareLogin = false;
  m_bNetwarePasswordExpired = DEFAULT_NWPASSWORDEXPIRED;
  m_bLimitGraceLogins = true;
  m_bLimitConnections = false;
  m_ushGraceLoginLimit = DEFAULT_GRACELOGINALLOWED;
  m_ushGraceLoginsRemaining = DEFAULT_GRACELOGINREMAINING;
  m_ushConnectionLimit = DEFAULT_MAXCONNECTIONS;
  m_cstrHmDirRelativePath = _T("");

  m_hFPNWClntDll = NULL;
  m_pfnMapRidToObjectId = NULL;
  m_pfnSwapObjectId = NULL;
  m_pfnReturnNetwareForm = NULL;
  m_pfnFPNWVolumeGetInfo = NULL;
  m_pfnFpnwApiBufferFree = NULL;

  m_dwMinPasswdLen = 0;
  m_dwMaxPasswdAge = static_cast<DWORD>(-1);

  m_cstrUserName = _T("");
  m_dwObjectID = 0;
  m_dwSwappedObjectID = 0;
  m_cstrNWPassword = _T("");
  m_cstrLogonFrom = _T("");
  m_cstrNewLogonFrom = _T("");

  m_cstrLoginScriptFileName = _T("");
  m_pLoginScriptBuffer = NULL;
  m_dwBytesToWrite = 0;
  m_bLoginScriptChanged = false;
}

CDsFPNWPage::~CDsFPNWPage()
{
  if (m_pLoginScriptBuffer)
    LocalFree(m_pLoginScriptBuffer);
  
  if (m_hFPNWClntDll) 
    FreeLibrary(m_hFPNWClntDll);

}

INT_PTR CALLBACK
CDsFPNWPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);
    case WM_NOTIFY:
        return OnNotify(wParam, lParam);
    case WM_SHOWWINDOW:
        return OnShowWindow();
    case WM_SETFOCUS:
        return OnSetFocus(reinterpret_cast<HWND>(wParam));
    case WM_HELP:
        return OnHelp(reinterpret_cast<LPHELPINFO>(lParam));
    case WM_COMMAND:
        if (m_fInInit)
            return TRUE;
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();
    default:
        return(FALSE);
    }

    return(TRUE);
}

HRESULT CDsFPNWPage::OnInitDialog(LPARAM)
{
    HWND currWindow;

    ADsPropSetHwnd(m_hNotifyObj, m_hPage);

    if (m_bMaintainNetwareLogin)
        CheckDlgButton(m_hPage, IDC_NETWARE_ENABLE, BST_CHECKED);

    EnableWindow(GetDlgItem(m_hPage, IDC_NWPWEXPIRED),
                 m_bMaintainNetwareLogin);
    if (m_bNetwarePasswordExpired)
        CheckDlgButton(m_hPage, IDC_NWPWEXPIRED, BST_CHECKED);

    EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_LOGINS),
                 m_bMaintainNetwareLogin);
    EnableWindow(GetDlgItem(m_hPage, IDC_UNLIMITED_GRACELOGINS),
                 m_bMaintainNetwareLogin);
    EnableWindow(GetDlgItem(m_hPage, IDC_LIMIT_GRACELOGINS),
                 m_bMaintainNetwareLogin);
    CheckRadioButton( m_hPage,
                      IDC_UNLIMITED_GRACELOGINS,
                      IDC_LIMIT_GRACELOGINS,
                      m_bLimitGraceLogins ? IDC_LIMIT_GRACELOGINS : IDC_UNLIMITED_GRACELOGINS );

    EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_LIMIT),
                 m_bMaintainNetwareLogin && m_bLimitGraceLogins);
    EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_SPIN),
                 m_bMaintainNetwareLogin && m_bLimitGraceLogins);
    EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING),
                 m_bMaintainNetwareLogin && m_bLimitGraceLogins);
    EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING_TEXT),
                 m_bMaintainNetwareLogin && m_bLimitGraceLogins);
    EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING_SPIN),
                 m_bMaintainNetwareLogin && m_bLimitGraceLogins);
    currWindow = GetDlgItem(m_hPage, IDC_GRACE_SPIN);

    // JonN 5/25/00 92903: dsadmin: fpnw5 : should allow user to set Grace Logins Remaining to 0
    SendMessage( currWindow, UDM_SETRANGE, 0, MAKELONG(0xFF, 0));
    SendMessage( currWindow, UDM_SETPOS, 0, MAKELONG( m_ushGraceLoginLimit, 0));
    currWindow = GetDlgItem(m_hPage, IDC_GRACE_REMAINING_SPIN);
    SendMessage( currWindow, UDM_SETRANGE, 0, MAKELONG( m_ushGraceLoginLimit, 0));

    SendMessage( currWindow, UDM_SETPOS, 0, MAKELONG( min(m_ushGraceLoginLimit, m_ushGraceLoginsRemaining), 0));

    EnableWindow(GetDlgItem(m_hPage, IDC_CONCURRENT_CONNECTIONS),
                 m_bMaintainNetwareLogin);
    EnableWindow(GetDlgItem(m_hPage, IDC_UNLIMITED_CONNECTIONS),
                 m_bMaintainNetwareLogin);
    EnableWindow(GetDlgItem(m_hPage, IDC_LIMIT_CONNECTIONS),
                 m_bMaintainNetwareLogin);
    CheckRadioButton( m_hPage,
                      IDC_UNLIMITED_CONNECTIONS,
                      IDC_LIMIT_CONNECTIONS,
                      m_bLimitConnections ? IDC_LIMIT_CONNECTIONS : IDC_UNLIMITED_CONNECTIONS );

    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECTION_LIMIT),
                 m_bMaintainNetwareLogin && m_bLimitConnections);
    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECTION_SPIN),
                 m_bMaintainNetwareLogin && m_bLimitConnections);
    currWindow = GetDlgItem(m_hPage, IDC_CONNECTION_SPIN);
    SendMessage( currWindow, UDM_SETRANGE, 0, MAKELONG(0xFF, 1));
    SendMessage( currWindow, UDM_SETPOS, 0, MAKELONG( m_ushConnectionLimit, 0));

    EnableWindow(GetDlgItem(m_hPage, IDC_SCRIPT_BUTTON),
                 m_bMaintainNetwareLogin && IsServiceRunning(m_pwzPDCName, NW_SERVER_SERVICE));
    EnableWindow(GetDlgItem(m_hPage, IDC_ADVANCED_BUTTON),
                 m_bMaintainNetwareLogin);

    EnableWindow(GetDlgItem(m_hPage, IDC_OBJECTID_TEXT),
                 m_bMaintainNetwareLogin);
    EnableWindow(GetDlgItem(m_hPage, IDC_OBJECT_ID),
                 m_bMaintainNetwareLogin);
    CStr cstrObjectID;
    cstrObjectID.Format(_T("%08x"), m_dwSwappedObjectID);
    SetWindowText(GetDlgItem(m_hPage, IDC_OBJECT_ID), cstrObjectID);

    EnableWindow(GetDlgItem(m_hPage, IDC_NWHMDIR_RELPATH_TEXT),
                 m_bMaintainNetwareLogin);
    EnableWindow(GetDlgItem(m_hPage, IDC_NWHMDIR_RELPATH),
                 m_bMaintainNetwareLogin);
    SetWindowText(GetDlgItem(m_hPage, IDC_NWHMDIR_RELPATH), m_cstrHmDirRelativePath);

    return S_OK;
}

LRESULT
CDsFPNWPage::OnApply() 
{
    bool bValue;
    DWORD dwFPNWFields = 0;
    TCHAR szPath[MAX_PATH] = {0};

    //
    // validate the NetWare Relative Home Directory
    //
    if (GetWindowText(GetDlgItem(m_hPage, IDC_NWHMDIR_RELPATH), szPath, MAX_PATH)) {
      DWORD dwPathType = 0;
      LONG err = NetpPathType(NULL, szPath, &dwPathType, 0);

      if ( (err != NERR_Success) || (dwPathType != ITYPE_PATH_RELND) ) {
        CStr cstrFormat, cstrMsg, cstrTitle;
        cstrFormat.LoadString(g_hInstance, IDS_INVALID_RELPATH);
        cstrTitle.LoadString(g_hInstance, IDS_MSG_TITLE);
        cstrMsg.Format(cstrFormat, szPath);
        MessageBox(m_hPage, cstrMsg, cstrTitle, MB_OK | MB_ICONINFORMATION);
        return TRUE;
      }
    }

    //
    // collect all the input
    //
    if (m_cstrHmDirRelativePath.CompareNoCase(szPath)) {
      m_cstrHmDirRelativePath = szPath;
      dwFPNWFields |= FPNW_FIELDS_NWHOMEDIR;
    }

    bValue = 
      (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_NETWARE_ENABLE));
    if (m_bMaintainNetwareLogin != bValue) {
      m_bMaintainNetwareLogin = bValue;
      dwFPNWFields |= FPNW_FIELDS_NWPASSWORD;
    }

    bValue = 
      (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_NWPWEXPIRED));
    if (m_bNetwarePasswordExpired != bValue) {
      m_bNetwarePasswordExpired = bValue;
      dwFPNWFields |= FPNW_FIELDS_NWTIMEPASSWORDSET;
    }

    bValue = 
      (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_LIMIT_GRACELOGINS));
    if (m_bLimitGraceLogins != bValue) {
      m_bLimitGraceLogins = bValue;
      if (!m_bLimitGraceLogins) {
        m_ushGraceLoginLimit = DEFAULT_GRACELOGINALLOWED;
        m_ushGraceLoginsRemaining = NO_GRACE_LOGIN_LIMIT;
      }
      dwFPNWFields |= ( FPNW_FIELDS_GRACELOGINALLOWED |
                        FPNW_FIELDS_GRACELOGINREMAINING );
    }
    if (m_bLimitGraceLogins) {
      USHORT ushAllowed = (USHORT)SendDlgItemMessage(
                                      m_hPage, 
                                      IDC_GRACE_SPIN, 
                                      UDM_GETPOS, 0, 0);
      USHORT ushRemaining = (USHORT)SendDlgItemMessage(
                                        m_hPage, 
                                        IDC_GRACE_REMAINING_SPIN, 
                                        UDM_GETPOS, 0, 0);
      if (m_ushGraceLoginLimit != ushAllowed) {
        m_ushGraceLoginLimit = ushAllowed;
        dwFPNWFields |= FPNW_FIELDS_GRACELOGINALLOWED;
      }
      if (m_ushGraceLoginsRemaining != ushRemaining) {
        m_ushGraceLoginsRemaining = ushRemaining;
        dwFPNWFields |= FPNW_FIELDS_GRACELOGINREMAINING;
      }
    }

    bValue = 
      (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_LIMIT_CONNECTIONS));
    if (m_bLimitConnections != bValue) {
      m_bLimitConnections = bValue;
      if (!m_bLimitConnections)
        m_ushConnectionLimit = NO_LIMIT; 
      dwFPNWFields |= FPNW_FIELDS_MAXCONNECTIONS;
    }
    if (m_bLimitConnections) {
      USHORT ushConnections = (USHORT)SendDlgItemMessage(
                                          m_hPage, 
                                          IDC_CONNECTION_SPIN, 
                                          UDM_GETPOS, 0, 0);
      if (m_ushConnectionLimit != ushConnections) {
        m_ushConnectionLimit = ushConnections;
        dwFPNWFields |= FPNW_FIELDS_MAXCONNECTIONS;
      }
    }

    if (m_cstrLogonFrom.CompareNoCase(m_cstrNewLogonFrom)) {
      m_cstrLogonFrom = m_cstrNewLogonFrom;
      dwFPNWFields |= FPNW_FIELDS_LOGONFROM;
    }

    //
    // apply any change
    //
    if (dwFPNWFields) {
      //
      // Re-get the toxic waste dump from DS
      // Update it
      // Write it back to the DS
      //
      HRESULT hr = S_OK;
      hr = ReadUserParms(m_pDsObj, m_cstrUserParms);
      if (SUCCEEDED(hr))
      {
        if (UpdateUserParms(dwFPNWFields))
        {
          hr = WriteUserParms(m_pDsObj, m_cstrUserParms);
          if (FAILED(hr)) {
            ReportError(hr, IDS_FAILED_TO_WRITE_NWPARMS, m_hPage);
            ParseUserParms(); // re-store the member values
            return TRUE;
          }
        } else {
          ParseUserParms(); // re-store the member values
          return TRUE;
        }
      }
    }

    //
    // if user has updated his login script, 
    // write the new scripts to the file
    //
    if (m_pLoginScriptBuffer) {
      LONG err = UpdateLoginScriptFile(
          m_cstrLoginScriptFileName, 
          m_pLoginScriptBuffer, 
          m_dwBytesToWrite);
      if (err != ERROR_SUCCESS) {
        ReportError(err, IDS_FAILED_TO_UPDATE_LOGINSCRIPTS, m_hPage);
        ParseUserParms(); // re-store the member values
        return TRUE;
      }
      LocalFree(m_pLoginScriptBuffer);
      m_pLoginScriptBuffer = NULL;
      m_dwBytesToWrite = 0;
    //
    // JonN 5/25/00 93137 Create the directory when the user becomes
    //     FPNW-enabled, regardless of whether the logon script has
    //     been edited.
    //
    } else if ( (dwFPNWFields & FPNW_FIELDS_NWPASSWORD)
             && m_bMaintainNetwareLogin
             && !m_cstrLoginScriptFileName.IsEmpty()) {
      TCHAR *p = _tcsrchr(m_cstrLoginScriptFileName, _T('\\'));
      if (p) {
        *p = _T('\0');

        if (!CreateDirectory(m_cstrLoginScriptFileName, NULL)) {
          LONG dwErr = GetLastError() ;
          int nMsgId = IDS_FPNW_HOME_DIR_CREATE_OTHER;
          switch (dwErr)
          {
          case ERROR_ALREADY_EXISTS:
            break; // no error message in this case
          case ERROR_PATH_NOT_FOUND:
            nMsgId = IDS_FPNW_HOME_DIR_CREATE_NO_PARENT;
            break;
          case ERROR_LOGON_FAILURE:
          case ERROR_ACCESS_DENIED:
          case ERROR_NOT_AUTHENTICATED:
            nMsgId = IDS_FPNW_HOME_DIR_CREATE_NO_ACCESS;
            break;
          default:
            break;
          }
          if (dwErr != ERROR_ALREADY_EXISTS)
          {
                //
                // Report a warning
                //
                SuperMsgBox(m_hPage,
                  nMsgId,
                  0, MB_OK | MB_ICONEXCLAMATION,
                  dwErr,
                  (PVOID *)&m_cstrLoginScriptFileName, 1,
                  FALSE, __FILE__, __LINE__);
          }
        }

        *p = _T('\\'); // restore the '\'
      }
    }

    //
    // clean the dirty flag
    //
    m_fPageDirty = FALSE;

    return FALSE;
}

LRESULT
CDsFPNWPage::OnCommand(int id, HWND, UINT codeNotify) 
{
    if (codeNotify == BN_CLICKED) {
      bool bMaintainNetwareLogin, bLimitGraceLogins, bLimitConnections;

      switch (id) {
      case IDC_NETWARE_ENABLE:
        {
          bMaintainNetwareLogin = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_NETWARE_ENABLE));
          if (!bMaintainNetwareLogin) {
            m_cstrNWPassword.Empty();
          } else {
            if (!m_bMaintainNetwareLogin && m_cstrNWPassword.IsEmpty() ) {
              //
              // ask user for the Netware password
              //
              if (IDCANCEL == DoFPNWPasswordDlg()) {
                CheckDlgButton(m_hPage, IDC_NETWARE_ENABLE, BST_UNCHECKED);
                bMaintainNetwareLogin = 
                  (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_NETWARE_ENABLE));
              }
            }
          }
            
          bLimitGraceLogins = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_LIMIT_GRACELOGINS));
          bLimitConnections = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_LIMIT_CONNECTIONS));

          EnableWindow(GetDlgItem(m_hPage, IDC_NWPWEXPIRED), 
                       bMaintainNetwareLogin);

          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_LOGINS),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_UNLIMITED_GRACELOGINS), 
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_LIMIT_GRACELOGINS), 
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_LIMIT), 
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_SPIN), 
                       bMaintainNetwareLogin && bLimitGraceLogins);

          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING),
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING_TEXT),
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING_SPIN),
                       bMaintainNetwareLogin && bLimitGraceLogins);

          EnableWindow(GetDlgItem(m_hPage, IDC_CONCURRENT_CONNECTIONS),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_UNLIMITED_CONNECTIONS),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_LIMIT_CONNECTIONS),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_CONNECTION_LIMIT),
                       bMaintainNetwareLogin && bLimitConnections);
          EnableWindow(GetDlgItem(m_hPage, IDC_CONNECTION_SPIN),
                       bMaintainNetwareLogin && bLimitConnections);

          EnableWindow(GetDlgItem(m_hPage, IDC_SCRIPT_BUTTON),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_ADVANCED_BUTTON),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_OBJECTID_TEXT),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_OBJECT_ID),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_NWHMDIR_RELPATH_TEXT),
                       bMaintainNetwareLogin);
          EnableWindow(GetDlgItem(m_hPage, IDC_NWHMDIR_RELPATH),
                       bMaintainNetwareLogin);

          SetDirty();
        }
        break;
      case IDC_NWPWEXPIRED:
        {
          SetDirty();
        }
        break;
      case IDC_LIMIT_GRACELOGINS:
      case IDC_UNLIMITED_GRACELOGINS:
        {
          bMaintainNetwareLogin = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_NETWARE_ENABLE));
          bLimitGraceLogins = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_LIMIT_GRACELOGINS));

          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_LIMIT),
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_SPIN),
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING),
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING_TEXT),
                       bMaintainNetwareLogin && bLimitGraceLogins);
          EnableWindow(GetDlgItem(m_hPage, IDC_GRACE_REMAINING_SPIN),
                       bMaintainNetwareLogin && bLimitGraceLogins);

          SetDirty();
        }
        break;
      case IDC_LIMIT_CONNECTIONS:
      case IDC_UNLIMITED_CONNECTIONS:
        {
          bMaintainNetwareLogin = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_NETWARE_ENABLE));
          bLimitConnections = 
            (BST_CHECKED == IsDlgButtonChecked(m_hPage, IDC_LIMIT_CONNECTIONS));

          EnableWindow(GetDlgItem(m_hPage, IDC_CONNECTION_LIMIT),
                       bMaintainNetwareLogin && bLimitConnections);
          EnableWindow(GetDlgItem(m_hPage, IDC_CONNECTION_SPIN),
                       bMaintainNetwareLogin && bLimitConnections);

          SetDirty();
        }
        break;
      case IDC_SCRIPT_BUTTON:
        {
          DoFPNWLoginScriptDlg();
          if (m_pLoginScriptBuffer)
            SetDirty();
        }
        break;
      case IDC_ADVANCED_BUTTON:
        {
          DoFPNWLogonDlg();
          if (m_cstrLogonFrom.CompareNoCase(m_cstrNewLogonFrom))
            SetDirty();
        }
        break;
      default:
        break;
      } // end of switch statement
    } else if ((codeNotify == EN_CHANGE) && !m_fInInit) {
      if (id == IDC_GRACE_LIMIT) {
        //
        // adjust the Remaining Grace Logins value accordingly
        //
        USHORT ushCurrLimit = (USHORT)SendDlgItemMessage(
                                          m_hPage, 
                                          IDC_GRACE_SPIN, 
                                          UDM_GETPOS, 0, 0);
        HWND currWindow = GetDlgItem(m_hPage, IDC_GRACE_REMAINING_SPIN);
        SendMessage( currWindow, UDM_SETRANGE, 0, MAKELONG( ushCurrLimit, 1));
        SendMessage( currWindow, UDM_SETPOS, 0, MAKELONG( ushCurrLimit, 0));
      }

      SetDirty();
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::LoadFPNWClntDll
//
//  Synopsis:   Load fpnwclnt.dll into memory.
//
//-----------------------------------------------------------------------------
DWORD
CDsFPNWPage::LoadFPNWClntDll()
{
  DWORD dwErr = 0;

  if (m_hFPNWClntDll) 
    return dwErr;

  m_hFPNWClntDll = LoadLibrary(SZ_FPNWCLNT_DLL);
  m_pfnMapRidToObjectId = reinterpret_cast<PMapRidToObjectId>(GetProcAddress(m_hFPNWClntDll, SZ_MAPRIDTOOBJECTID));
  m_pfnSwapObjectId = reinterpret_cast<PSwapObjectId>(GetProcAddress(m_hFPNWClntDll, SZ_SWAPOBJECTID));
  m_pfnReturnNetwareForm = reinterpret_cast<PReturnNetwareForm>(GetProcAddress(m_hFPNWClntDll, SZ_RETURNNETWAREFORM));
  m_pfnFPNWVolumeGetInfo = reinterpret_cast<PFPNWVolumeGetInfo>(GetProcAddress(m_hFPNWClntDll, SZ_FPNWVOLUMEGETINFO));
  m_pfnFpnwApiBufferFree = reinterpret_cast<PFpnwApiBufferFree>(GetProcAddress(m_hFPNWClntDll, SZ_FPNWAPIBUFFERFREE));

  if (!m_hFPNWClntDll ||
      !m_pfnMapRidToObjectId ||
      !m_pfnSwapObjectId ||
      !m_pfnReturnNetwareForm ||
      !m_pfnFPNWVolumeGetInfo ||
      !m_pfnFpnwApiBufferFree)
  {
    dwErr = GetLastError();
  }

  return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::InitFPNWUser
//
//  Synopsis:   Initiate information related to this user. 
//              If the initialization fails, don't put up the FPNW property page.
//
//-----------------------------------------------------------------------------
bool
CDsFPNWPage::InitFPNWUser()
{
  if (!IsServiceRunning(m_pwzPDCName, NW_SERVER_SERVICE))
    return FALSE;

  HRESULT hr = S_OK;
  DWORD dwErr = 0;

  HWND hwndFrame = NULL;
  // CODEWORK: get the window handle to the mmc main frame
  // use this handle in error reporting

  //
  // load fpnwclnt.dll
  //
  dwErr = LoadFPNWClntDll();
  if (dwErr)
  {
    ReportError(dwErr, IDS_FAILED_TO_LOADFPNWCLNTDLL, hwndFrame);
    return FALSE;
  }

  //
  // get account policy on minimum pwd length and maximum pwd age
  //
  GetAccountPolicyInfo(m_pwzPDCName, &m_dwMinPasswdLen, &m_dwMaxPasswdAge);

  //
  // get user name and NetWare-style object id
  //
  hr = GetNWUserInfo(
            m_pDsObj,
            m_cstrUserName,       // OUT
            m_dwObjectID,         // OUT
            m_dwSwappedObjectID,  // OUT
            m_pfnMapRidToObjectId,
            m_pfnSwapObjectId
            );

  if (FAILED(hr))
  {
    ReportError(dwErr, IDS_FAILED_TO_GETNWUSERINFO, hwndFrame);
    return FALSE;
  }

  //
  // get the path of user's NetWare login script file
  //
  LONG lErr = GetLoginScriptFilePath(m_cstrLoginScriptFileName);
  if (lErr != NERR_Success)
  {
    ReportError(lErr, IDS_FAILED_TO_GETNWLOGINSCRIPTFILE, hwndFrame);
    return FALSE;
  }

  //
  // get the toxic waste dump string from the user object, and parse it
  //
  hr = ReadUserParms(m_pDsObj, m_cstrUserParms);
  if (FAILED(hr))
  {
    ReportError(hr, IDS_FAILED_TO_GETUSERPARMS, hwndFrame);
    return FALSE;
  }

  ParseUserParms();

  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::GetLoginScriptFilePath
//
//  Synopsis:   Calculate the path of user's login script file. 
//
//-----------------------------------------------------------------------------
LONG
CDsFPNWPage::GetLoginScriptFilePath(
    OUT CStr&   cstrLoginScriptFilePath
)
{
  LONG err = NERR_Success;
  PFPNWVOLUMEINFO lpnwVolumeInfo ;

  cstrLoginScriptFilePath.Empty();

  err = m_pfnFPNWVolumeGetInfo(
                          m_pwzPDCName,
                          SYSVOL_NAME_STRING,
                          1,
                          reinterpret_cast<LPBYTE *>(&lpnwVolumeInfo));

  if (NERR_Success == err) {

    CStr cstrSysVol = lpnwVolumeInfo->lpPath;
    m_pfnFpnwApiBufferFree(lpnwVolumeInfo);

    if (cstrSysVol.Right(1) != _T('\\'))
      cstrSysVol += _T("\\");

    if ( !m_pwzPDCName || !(*m_pwzPDCName) ) {
      cstrLoginScriptFilePath.Format(
        _T("%s%s%x%s"),
        static_cast<LPCTSTR>(cstrSysVol), 
        SZ_MAIL_DIR, 
        m_dwSwappedObjectID,
        SZ_LOGIN_FILE);
    } else {
      cstrLoginScriptFilePath.Format(
        _T("%s\\%s%s%x%s"),
        m_pwzPDCName,
        static_cast<LPCTSTR>(cstrSysVol), 
        SZ_MAIL_DIR, 
        m_dwSwappedObjectID,
        SZ_LOGIN_FILE);

      int index = cstrLoginScriptFilePath.Find(_T(':'));
      if (-1 != index)
        cstrLoginScriptFilePath.SetAt(index, _T('$'));
    }
  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::ParseUserParms
//
//  Synopsis:   Parse each field of the waste dump string, 
//              and assign values to appropriate members in the class instance. 
//
//-----------------------------------------------------------------------------
void
CDsFPNWPage::ParseUserParms()
{
  if (!m_cstrUserParms.IsEmpty()) {
    PVOID pBuffer = NULL;
    WORD  nLength = 0;
    bool  fFound = false;

    QueryUserProperty(m_cstrUserParms, 
                      NWPASSWORD, 
                      &pBuffer, 
                      &nLength, 
                      &m_bMaintainNetwareLogin);
    
    if (m_bMaintainNetwareLogin) {
      LocalFree(pBuffer);

      QueryNWPasswordExpired(m_cstrUserParms, m_dwMaxPasswdAge, &m_bNetwarePasswordExpired);

      fFound = false;
      if (NERR_Success == QueryUserProperty(m_cstrUserParms, 
                                            GRACELOGINALLOWED, 
                                            &pBuffer, 
                                            &nLength, 
                                            &fFound)) {
        m_ushGraceLoginLimit = (USHORT)(fFound? 
                               (*(static_cast<USHORT *>(pBuffer))) : 
                               DEFAULT_GRACELOGINALLOWED);
        if (fFound)
          LocalFree(pBuffer);
      }

      fFound = false;
      if (NERR_Success == QueryUserProperty(m_cstrUserParms, 
                                            GRACELOGINREMAINING, 
                                            &pBuffer, 
                                            &nLength, 
                                            &fFound)) {
        m_ushGraceLoginsRemaining = (USHORT)(fFound? 
                                    (*(static_cast<USHORT *>(pBuffer))) : 
                                    DEFAULT_GRACELOGINREMAINING);
        if (fFound)
          LocalFree(pBuffer);
      }
      m_bLimitGraceLogins = (m_ushGraceLoginsRemaining != NO_GRACE_LOGIN_LIMIT);

      fFound = false;
      if (NERR_Success == QueryUserProperty(m_cstrUserParms, 
                                            MAXCONNECTIONS, 
                                            &pBuffer, 
                                            &nLength, 
                                            &fFound)) {
        m_ushConnectionLimit = (USHORT)(fFound? 
                               (*(static_cast<USHORT *>(pBuffer))) : 
                               NO_LIMIT);
        if (fFound)
          LocalFree(pBuffer);
      }
      m_bLimitConnections = (m_ushConnectionLimit != NO_LIMIT);

      fFound = false;
      if (NERR_Success == QueryUserProperty(m_cstrUserParms, 
                                            NWHOMEDIR, 
                                            &pBuffer, 
                                            &nLength, 
                                            &fFound)) {
        if (fFound) {
          //
          // NWHOMEDIR is in single CHAR format, convert it to WCHAR
          //
          m_cstrHmDirRelativePath = static_cast<LPCSTR>(pBuffer);
          LocalFree(pBuffer);
        }
      }

      fFound = false;
      if (NERR_Success == QueryUserProperty(m_cstrUserParms, 
                                            NWLOGONFROM, 
                                            &pBuffer, 
                                            &nLength, 
                                            &fFound)) {
        if (fFound) {
          //
          // NWLOGONFROM is in single CHAR format, convert it to WCHAR
          //
          m_cstrLogonFrom = static_cast<LPCSTR>(pBuffer);
          m_cstrNewLogonFrom = m_cstrLogonFrom;
          LocalFree(pBuffer);
        }
      }

    }
  }

}



HRESULT
WideCharToMultiByteHelper(
   const CStr& str,
   char*       buffer,
   int         bufferSize,
   int&        result)
{
   ASSERT(!str.IsEmpty());

   HRESULT hr = S_OK;

   result = 
      ::WideCharToMultiByte(
         CP_ACP,
         0,
         str,
         str.GetLength(),
         buffer,
         static_cast<int>(bufferSize),
         0,
         0);
   if (!result)
   {
      DWORD err = ::GetLastError();
      hr = HRESULT_FROM_WIN32(err);
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



// Caller must call delete[] on the result

HRESULT
ConvertWideStringToAnsiString(
   const CStr& wide,
   PSTR&       ansi,
   int&        ansiLengthInBytes)
{
   ansi              = 0;
   ansiLengthInBytes = 0;

   HRESULT hr = S_OK;      

   do
   {
      if (wide.IsEmpty())
      {
         break;
      }

      hr =
         WideCharToMultiByteHelper(
            wide,
            0,
            0,
            ansiLengthInBytes);
      if (FAILED(hr))
      {
         break;
      }

      ansiLengthInBytes++;

      ansi = new CHAR[ansiLengthInBytes];
      if (!ansi)
      {
         hr = E_OUTOFMEMORY;
         break;
      }

      memset(ansi, 0, ansiLengthInBytes);

      // convert unicode value to ansi

      int written = 0;
      hr =
         ::WideCharToMultiByteHelper(
            wide,
            ansi,
            ansiLengthInBytes,
            written);
      if (FAILED(hr))
      {
         break;
      }

      ASSERT(written == ansiLengthInBytes - 1);
   }
   while (0);

   return hr;
}



// Helper for UpdateUserParams.

HRESULT
CDsFPNWPage::UpdateUserParamsStringValue(
   PCWSTR      propertyName,
   const CStr& propertyValue)
{
   ASSERT(propertyName);

   HRESULT hr = S_OK;

   // Convert the unicode value into ansi, then stuff the result into a
   // UNICODE_STRING structure, where the Length field is the length in bytes
   // of the ansi representation.

   char* ansiValue = 0;

   do
   {
      // determine length of ansi representation, in bytes.

      int byteLength = 0;
      hr =
         ConvertWideStringToAnsiString(
            propertyValue,
            ansiValue,
            byteLength);
      if (FAILED(hr))
      {
         break;
      }

      UNICODE_STRING us;
      us.Buffer        = reinterpret_cast<PWSTR>(ansiValue);
      us.Length        = static_cast<USHORT>(byteLength);   
      us.MaximumLength = static_cast<USHORT>(byteLength);

      LONG err = SetUserProperty(m_cstrUserParms, propertyName, us);
      hr = HRESULT_FROM_WIN32(err);
   }
   while (0);

   delete[] ansiValue;

   return hr;
}




//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::UpdateUserParms
//
//  Synopsis:   Update the waste dump string with the new values 
//              user has specified on the FPNW property page 
//
//-----------------------------------------------------------------------------
bool
CDsFPNWPage::UpdateUserParms(IN DWORD dwFPNWFields)
{
  HRESULT hr = S_OK;
  LONG err = NERR_Success;
  UNICODE_STRING uniPropertyValue;

  uniPropertyValue.Buffer = NULL;
  uniPropertyValue.Length = 0;
  uniPropertyValue.MaximumLength = 0;

  if (dwFPNWFields & FPNW_FIELDS_NWPASSWORD) {
    if (!m_bMaintainNetwareLogin) {
      //
      // remove all FPNW fields from the waste dump, and return
      //
      if ( ((err = RemoveUserProperty(m_cstrUserParms, NWPASSWORD)) != NERR_Success) ||
           ((err = RemoveUserProperty(m_cstrUserParms, NWTIMEPASSWORDSET)) != NERR_Success) ||
           ((err = RemoveUserProperty(m_cstrUserParms, GRACELOGINALLOWED)) != NERR_Success) ||
           ((err = RemoveUserProperty(m_cstrUserParms, GRACELOGINREMAINING)) != NERR_Success) ||
           ((err = RemoveUserProperty(m_cstrUserParms, MAXCONNECTIONS)) != NERR_Success) ||
           ((err = RemoveUserProperty(m_cstrUserParms, NWHOMEDIR)) != NERR_Success) ||
           ((err = RemoveUserProperty(m_cstrUserParms, NWLOGONFROM)) != NERR_Success) )
      {
        FPNW_CHECK_RETURN(FALSE, err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
      }

      SetUserFlag(m_pDsObj, FALSE, UF_MNS_LOGON_ACCOUNT);

      return (err == NERR_Success);

    } else {

      hr = SetUserPassword(m_pDsObj, m_cstrNWPassword);
      
      if (SUCCEEDED(hr))
        hr = SetUserFlag(m_pDsObj, TRUE, UF_MNS_LOGON_ACCOUNT);

      if (FAILED(hr)) {
        ReportError(hr, IDS_FAILED_TO_ENABLE_NWUSER, m_hPage);
        return FALSE;
      } else {
        //
        // Encrypt the Netware password user has typed in,
        // set it in the waste dump, and reset the expired flag
        // to be FALSE
        //

        err = SetNetWareUserPassword(
                  m_cstrUserParms,
                  m_pwzSecretKey,
                  m_dwObjectID,
                  m_cstrNWPassword,
                  m_pfnReturnNetwareForm);

        FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);

        // JonN 5/24/00 101819
        // only set this to false if the user did not explicitly request true
        if ( !(FPNW_FIELDS_NWTIMEPASSWORDSET & dwFPNWFields) )
        {
          m_bNetwarePasswordExpired = false;
          dwFPNWFields |= FPNW_FIELDS_NWTIMEPASSWORDSET;
        }
      }

    }
  }

  if (dwFPNWFields & FPNW_FIELDS_NWTIMEPASSWORDSET) {
    err = ResetNetWareUserPasswordTime(
              m_cstrUserParms,
              m_bNetwarePasswordExpired);

    FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
  }
  
  if (dwFPNWFields & FPNW_FIELDS_GRACELOGINALLOWED) {
    uniPropertyValue.Buffer = &m_ushGraceLoginLimit;
    uniPropertyValue.Length = sizeof(m_ushGraceLoginLimit);
    uniPropertyValue.MaximumLength = sizeof(m_ushGraceLoginLimit);
    err = SetUserProperty(m_cstrUserParms, GRACELOGINALLOWED, uniPropertyValue);
    FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
  }

  if (dwFPNWFields & FPNW_FIELDS_GRACELOGINREMAINING) {
    uniPropertyValue.Buffer = &m_ushGraceLoginsRemaining;
    uniPropertyValue.Length = sizeof(m_ushGraceLoginsRemaining);
    uniPropertyValue.MaximumLength = sizeof(m_ushGraceLoginsRemaining);
    err = SetUserProperty(m_cstrUserParms, GRACELOGINREMAINING, uniPropertyValue);
    FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
  }

  if (dwFPNWFields & FPNW_FIELDS_MAXCONNECTIONS) {
    uniPropertyValue.Buffer = &m_ushConnectionLimit;
    uniPropertyValue.Length = sizeof(m_ushConnectionLimit);
    uniPropertyValue.MaximumLength = sizeof(m_ushConnectionLimit);
    err = SetUserProperty(m_cstrUserParms, MAXCONNECTIONS, uniPropertyValue);
    FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
  }

  if (dwFPNWFields & FPNW_FIELDS_NWHOMEDIR) {
    if (m_cstrHmDirRelativePath.IsEmpty()) {
      err = RemoveUserProperty(m_cstrUserParms, NWHOMEDIR);
      FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
    } else {

      hr = UpdateUserParamsStringValue(NWHOMEDIR, m_cstrHmDirRelativePath);
      if (FAILED(hr))
      {
        ReportError(hr, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage);
        return FALSE;
      }
    }
  }

  if (dwFPNWFields & FPNW_FIELDS_LOGONFROM) {
    if (m_cstrLogonFrom.IsEmpty()) {
      err = RemoveUserProperty(m_cstrUserParms, NWLOGONFROM);
      FPNW_CHECK_RETURN((err==NERR_Success), err, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage, FALSE);
    } else {

      hr = UpdateUserParamsStringValue(NWLOGONFROM, m_cstrLogonFrom);
      if (FAILED(hr))
      {
        ReportError(hr, IDS_FAILED_TO_UPDATE_NWPARMS, m_hPage);
        return FALSE;
      }
    }
  }

  return (err == NERR_Success);
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::DoFPNWPasswordDlg
//
//  Synopsis:   Pop up a dialog for specifying the Password for 
//              NetWare Compatible User. 
//
//-----------------------------------------------------------------------------
int
CDsFPNWPage::DoFPNWPasswordDlg()
{
  return( (int)DialogBoxParam(
              g_hInstance,
              MAKEINTRESOURCE(IDD_FPNW_PASSWORD), 
              m_hPage, 
              FPNWPasswordDlgProc, 
              reinterpret_cast<LPARAM>(this)) );
}

//+----------------------------------------------------------------------------
//
//  Function:   FPNWPasswordDlgProc
//
//  Synopsis:   The password dialog callback procedure. 
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
FPNWPasswordDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
  CDsFPNWPage * pPage = reinterpret_cast<CDsFPNWPage *>(GetWindowLongPtr(hDlg, DWLP_USER));

  switch (uMsg)
  {
  case WM_INITDIALOG:
    SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    pPage = reinterpret_cast<CDsFPNWPage *>(lParam);
    SetWindowText(GetDlgItem(hDlg, IDC_FPNWPASSWORD_USERNAME), pPage->m_cstrUserName);
    SendDlgItemMessage(hDlg, IDC_FPNWPASSWORD_EDIT1, 
                       EM_LIMITTEXT, MIN_PASS_LEN_MAX, 0);
    SendDlgItemMessage(hDlg, IDC_FPNWPASSWORD_EDIT2, 
                       EM_LIMITTEXT, MIN_PASS_LEN_MAX, 0);
    return TRUE;
  case WM_HELP:
      return pPage->OnHelp(reinterpret_cast<LPHELPINFO>(lParam));
  case WM_COMMAND:
    if ( BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam) ) {
      switch (GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
        {
          TCHAR szPW1[MIN_PASS_LEN_MAX + 1], szPW2[MIN_PASS_LEN_MAX + 1];

          ZeroMemory(szPW1, sizeof(szPW1));
          ZeroMemory(szPW2, sizeof(szPW2));

          UINT cchPW1 = GetDlgItemText(hDlg, 
                                       IDC_FPNWPASSWORD_EDIT1, 
                                       szPW1, 
                                       MIN_PASS_LEN_MAX);
          UINT cchPW2 = GetDlgItemText(hDlg, 
                                       IDC_FPNWPASSWORD_EDIT2, 
                                       szPW2, 
                                       MIN_PASS_LEN_MAX);

          if ( (cchPW1 < pPage->m_dwMinPasswdLen) || 
               (cchPW2 < pPage->m_dwMinPasswdLen) || 
               _tcscmp(szPW1, szPW2) ) {
            ErrMsg(IDS_ERRMSG_PW_MATCH, hDlg);
            SetDlgItemText(hDlg, IDC_FPNWPASSWORD_EDIT1, _T(""));
            SetDlgItemText(hDlg, IDC_FPNWPASSWORD_EDIT2, _T(""));
            SetFocus(GetDlgItem(hDlg, IDC_FPNWPASSWORD_EDIT1));
          } else {
            pPage->m_cstrNWPassword = szPW1;
            EndDialog(hDlg, IDOK);
          }
        }
        break;
      case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;
      default:
        break;
      }
    }
    break;
  default:
    return(FALSE);
  }

  return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::DoFPNWLoginScriptDlg
//
//  Synopsis:   Pop up the dialog once the Login Script button is clicked 
//
//-----------------------------------------------------------------------------
int
CDsFPNWPage::DoFPNWLoginScriptDlg()
{
  return( (int)DialogBoxParam(
              g_hInstance,
              MAKEINTRESOURCE(IDD_FPNW_LOGIN_SCRIPT), 
              m_hPage, 
              FPNWLoginScriptDlgProc, 
              reinterpret_cast<LPARAM>(this)) );
}

//+----------------------------------------------------------------------------
//
//  Function:   FPNWLoginScriptDlgProc
//
//  Synopsis:   The Login Script dialog callback procedure. 
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK 
FPNWLoginScriptDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
  CDsFPNWPage * pPage = reinterpret_cast<CDsFPNWPage *>(GetWindowLongPtr(hDlg, DWLP_USER));

  switch (uMsg)
  {
  case WM_INITDIALOG:
    {
      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lParam);
      pPage = reinterpret_cast<CDsFPNWPage *>(lParam);

      pPage->m_bLoginScriptChanged = false; // reset this flag

      HWND hEdit = GetDlgItem(hDlg, IDC_FPNWLOGINSCRIPT_EDIT);
      if (pPage->m_pLoginScriptBuffer) {
        SetWindowText(hEdit, static_cast<LPCTSTR>(pPage->m_pLoginScriptBuffer));
      } else {
        LoadLoginScriptTextFromFile(hEdit, pPage->m_cstrLoginScriptFileName);
      }

      return FALSE;
    }
  case WM_HELP:
      return pPage->OnHelp(reinterpret_cast<LPHELPINFO>(lParam));
  case WM_COMMAND:
    switch (GET_WM_COMMAND_CMD(wParam, lParam)) {
    case BN_CLICKED:
      {
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDOK:
          {
            if (pPage->m_bLoginScriptChanged) {
              //
              // get the new login script text into the buffer
              //
              if (pPage->m_pLoginScriptBuffer)
                LocalFree(pPage->m_pLoginScriptBuffer);

              HWND hEdit = GetDlgItem(hDlg, IDC_FPNWLOGINSCRIPT_EDIT);
              int nTextLength = GetWindowTextLength(hEdit) + 1;
              pPage->m_pLoginScriptBuffer = LocalAlloc(LPTR, nTextLength * sizeof(WCHAR));
                
              if (pPage->m_pLoginScriptBuffer)
              {
                nTextLength = GetWindowText(
                                  hEdit, 
                                  static_cast<LPTSTR>(pPage->m_pLoginScriptBuffer), 
                                  nTextLength);
                pPage->m_dwBytesToWrite = (nTextLength + 1)* sizeof(WCHAR);
              } else {
                ReportError(ERROR_NOT_ENOUGH_MEMORY, 0, hDlg);
              }
            }

            EndDialog(hDlg, IDOK);
          }
          break;
        case IDCANCEL:
          EndDialog(hDlg, IDCANCEL);
          break;
        default:
          break;
        }
        break;
      }
    case EN_SETFOCUS:
      {
        SendMessage (reinterpret_cast<HWND>(lParam), EM_SETSEL, 0, 0);
      }
      break;
    case EN_CHANGE:
      {
        pPage->m_bLoginScriptChanged = TRUE; // raise the flag
      }
      break;
    default:
      break;
    }
    break;
  default:
    return(FALSE);
  }

  return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::DoFPNWLogonDlg
//
//  Synopsis:   Pop up the dialog once the Advanced button is clicked 
//
//-----------------------------------------------------------------------------
int
CDsFPNWPage::DoFPNWLogonDlg()
{
  return( (int)DialogBoxParam(
              g_hInstance,
              MAKEINTRESOURCE(IDD_FPNW_LOGON), 
              m_hPage, 
              FPNWLogonDlgProc, 
              reinterpret_cast<LPARAM>(this)) );
}

//+----------------------------------------------------------------------------
//
//  Function:   FPNWLogonDlgProc
//
//  Synopsis:   The Logon dialog callback procedure. 
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK 
FPNWLogonDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
  CDsFPNWPage * pPage = reinterpret_cast<CDsFPNWPage *>(GetWindowLongPtr(hDlg, DWLP_USER));
  HWND hlvAddress = GetDlgItem(hDlg, IDC_FPNWLOGON_ADDRESS);

  switch (uMsg)
  {
  case WM_INITDIALOG:
    {
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)lParam);
    pPage = reinterpret_cast<CDsFPNWPage *>(lParam);
    SetWindowText(GetDlgItem(hDlg, IDC_FPNWLOGON_USERNAME), pPage->m_cstrUserName);
    
    BOOL bLogonFromIsEmpty = pPage->m_cstrNewLogonFrom.IsEmpty();
    CheckRadioButton( hDlg, 
                      IDC_FPNWLOGON_ALL, 
                      IDC_FPNWLOGON_SELECTED,
                      bLogonFromIsEmpty ? IDC_FPNWLOGON_ALL : IDC_FPNWLOGON_SELECTED );
    EnableWindow(hlvAddress, !bLogonFromIsEmpty);

    LV_COLUMN col;
    RECT      rect;
    LONG      width;
    CStr      cstrText;

    ZeroMemory(&rect, sizeof(rect));
    GetWindowRect(hlvAddress, &rect);
    width = rect.right - rect.left - 4; // -4 to prevent the horizontal scrollbar from appearing

    ZeroMemory(&col, sizeof(col));
    col.mask = LVCF_TEXT | LVCF_WIDTH;
    col.cx = width/2;
    cstrText.LoadString(g_hInstance, IDS_FPNWLOGON_NETWORKADDR);
    col.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrText));
    ListView_InsertColumn(hlvAddress, 0, &col);
    col.cx = width/2;
    cstrText.LoadString(g_hInstance, IDS_FPNWLOGON_NODEADDR);
    col.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrText));
    ListView_InsertColumn(hlvAddress, 1, &col);

    DisplayFPNWLogonSelected(hlvAddress, pPage->m_cstrNewLogonFrom);

    EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_ADD), !bLogonFromIsEmpty);
    EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_REMOVE), !bLogonFromIsEmpty);

    return TRUE;
    }
  case WM_HELP:
      return pPage->OnHelp(reinterpret_cast<LPHELPINFO>(lParam));
  case WM_COMMAND:
    if ( BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam) ) {
      switch (GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
        {
          // update pPage->m_cstrNewLogonFrom
          pPage->m_cstrNewLogonFrom.Empty();

          if (BST_CHECKED == IsDlgButtonChecked(hDlg, IDC_FPNWLOGON_SELECTED))
          {
            CStr cstrAllNodes;
            cstrAllNodes.LoadString(g_hInstance, IDS_ALL_NODES);

            TCHAR szBuffer[MAX_PATH + 1];
          
            int count = ListView_GetItemCount(hlvAddress);

            LV_ITEM item;
            ZeroMemory(&item, sizeof(item));
            item.mask = LVIF_TEXT;
            item.pszText = szBuffer;
            item.cchTextMax = sizeof(szBuffer);
            for (int i=0; i < count; i++) {
              item.iItem = i;
              item.iSubItem = 0;
              if (ListView_GetItem(hlvAddress, &item)) {
                pPage->m_cstrNewLogonFrom += CStr(szBuffer, NETWORKSIZE);

                item.iSubItem = 1;
                if (ListView_GetItem(hlvAddress, &item)) {
                  if (cstrAllNodes.CompareNoCase(szBuffer)) {
                    pPage->m_cstrNewLogonFrom += CStr(szBuffer, NODESIZE);
                  } else {
                    pPage->m_cstrNewLogonFrom += SZ_ALL_NODES_ADDR;
                  }
                }
              }
            }
          }

          EndDialog(hDlg, IDOK);
        }
        break;
      case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;
      case IDC_FPNWLOGON_ADD:
        {
          if (IDOK == pPage->DoFPNWLogonAddDlg(hDlg, hlvAddress)) {
            EnableWindow(
                GetDlgItem(hDlg, IDC_FPNWLOGON_REMOVE), 
                ListView_GetItemCount(hlvAddress) );
          }
          break;
        }
      case IDC_FPNWLOGON_REMOVE:
        {
          int index = ListView_GetNextItem(
                          hlvAddress,
                          -1,
                          LVNI_SELECTED);
          if (index != -1) {
            ListView_DeleteItem(hlvAddress, index);

            if (ListView_GetItemCount(hlvAddress)) {
              //
              // set focus to the previous item
              //
              if (index)
                index--;

              ListView_SetItemState(hlvAddress, index, 
                LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED );
              ListView_RedrawItems(hlvAddress, index, index);
              SetFocus(hlvAddress);
              UpdateWindow(hlvAddress);
            } else {
              EnableWindow( GetDlgItem(hDlg, IDC_FPNWLOGON_REMOVE), FALSE );
            }
          }

          break;
        }
      case IDC_FPNWLOGON_ALL:
        {
          CheckRadioButton( hDlg, 
                            IDC_FPNWLOGON_ALL, 
                            IDC_FPNWLOGON_SELECTED,
                            IDC_FPNWLOGON_ALL );
          EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_ADDRESS), FALSE);
          EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_ADD), FALSE);
          EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_REMOVE), FALSE);
          break;
        }
      case IDC_FPNWLOGON_SELECTED:
        {
          CheckRadioButton( hDlg, 
                            IDC_FPNWLOGON_ALL, 
                            IDC_FPNWLOGON_SELECTED,
                            IDC_FPNWLOGON_SELECTED );
          EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_ADDRESS), TRUE);
          EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_ADD), TRUE);
          EnableWindow(GetDlgItem(hDlg, IDC_FPNWLOGON_REMOVE), 
              ListView_GetItemCount(GetDlgItem(hDlg, IDC_FPNWLOGON_ADDRESS)));
          break;
        }
      default:
        break;
      }
    }
    break;
  default:
    return(FALSE);
  }

  return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsFPNWPage::DoFPNWLogonAddDlg
//
//  Synopsis:   Pop up the dialog once the ADD button is clicked 
//
//-----------------------------------------------------------------------------
int
CDsFPNWPage::DoFPNWLogonAddDlg(HWND hwndParent, HWND hlvAddress)
{
  return( (int)DialogBoxParam(
              g_hInstance,
              MAKEINTRESOURCE(IDD_FPNW_LOGON_ADDDLG), 
              hwndParent, 
              FPNWLogonAddDlgProc, 
              reinterpret_cast<LPARAM>(hlvAddress)) );
}

//+----------------------------------------------------------------------------
//
//  Function:   FPNWLogonAddDlgProc
//
//  Synopsis:   The Logon Add dialog callback procedure. 
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK 
FPNWLogonAddDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
  HWND hlvAddress = (HWND)GetWindowLongPtr(hDlg, DWLP_USER);

  switch (uMsg)
  {
  case WM_INITDIALOG:
    {
      SetWindowLongPtr(hDlg, DWLP_USER, lParam);

      SendMessage(GetDlgItem(hDlg, IDC_FPNWLOGONADD_NETWORKADDR), 
                  EM_LIMITTEXT, NETWORKSIZE, 0);
      SendMessage(GetDlgItem(hDlg, IDC_FPNWLOGONADD_NODEADDR), 
                  EM_LIMITTEXT, NODESIZE, 0);

      //
      // both edit controls use the same wndproc
      //
      g_fnOldEditCtrlProc = reinterpret_cast<WNDPROC>(
                                SetWindowLongPtr(
                                         GetDlgItem(hDlg, IDC_FPNWLOGONADD_NETWORKADDR),
                                         GWLP_WNDPROC, 
                                         reinterpret_cast<LONG_PTR>(HexEditCtrlProc)));
      SetWindowLongPtr(
          GetDlgItem(hDlg, IDC_FPNWLOGONADD_NODEADDR),
          GWLP_WNDPROC, 
          reinterpret_cast<LONG_PTR>(HexEditCtrlProc));

      return TRUE;
    }
  case WM_HELP:
    {
      LPHELPINFO pHelpInfo = reinterpret_cast<LPHELPINFO>(lParam);
      if (pHelpInfo->iCtrlId >= 1)
          WinHelp(hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

      return TRUE;
    }
  case WM_COMMAND:
    if ( BN_CLICKED == GET_WM_COMMAND_CMD(wParam, lParam) ) {
      switch (GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
        {
          TCHAR tchNetworkAddr[NETWORKSIZE + 1], tchNodeAddr[NODESIZE + 1];
          int nNetworkAddr = 0, nNodeAddr = 0;

          ZeroMemory(tchNetworkAddr, sizeof(tchNetworkAddr));
          ZeroMemory(tchNodeAddr, sizeof(tchNodeAddr));

          nNetworkAddr = GetDlgItemText(
                             hDlg, 
                             IDC_FPNWLOGONADD_NETWORKADDR, 
                             tchNetworkAddr,
                             NETWORKSIZE+1);
          if (0 == nNetworkAddr) {
            // network address is required
            ErrMsg(IDS_ERRMSG_NETWORKADDR_REQUIRED, hDlg);
            break;
          } else {
            InsertZerosToHexString(tchNetworkAddr, NETWORKSIZE - nNetworkAddr);
          }

          nNodeAddr = GetDlgItemText(
                          hDlg, 
                          IDC_FPNWLOGONADD_NODEADDR, 
                          tchNodeAddr,
                          NODESIZE+1);
          
          if (nNodeAddr) {
            InsertZerosToHexString(tchNodeAddr, NODESIZE - nNodeAddr);
          } else {
            _tcsncpy(tchNodeAddr, SZ_ALL_NODES_ADDR, NODESIZE);
          }

          InsertLogonAddress(hlvAddress, tchNetworkAddr, tchNodeAddr);

          EndDialog(hDlg, IDOK);
          break;
        }
      case IDCANCEL:
        EndDialog(hDlg, IDCANCEL);
        break;
      default:
        break;
      }
    }
    break;
  default:
    return(FALSE);
  }

  return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   HexEditCtrlProc
//
//  Synopsis:   The subclassed edit control callback procedure. 
//              This edit control only allows hex input, paste is disabled. 
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK 
HexEditCtrlProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
  switch (uMsg)
  {
  case WM_PASTE:
    {
      ::MessageBeep (0);
      return TRUE;
    }
  case WM_CHAR:
    {
      TCHAR chKey = static_cast<TCHAR>(wParam);
      if ((!iswxdigit(chKey)) &&
          (chKey != VK_BACK) &&
          (chKey != VK_DELETE) &&
          (chKey != VK_END) &&
          (chKey != VK_HOME) )
      {
          ::MessageBeep (0);
          return TRUE;
      }
    }
    break;
  default:
    break;
  }

  return CallWindowProc(g_fnOldEditCtrlProc, hwnd, uMsg, wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateFPNWPage
//
//  Synopsis:   Creates an instance of a page window for a user object.
//              This page is enabled if FPNW Global LsaSecret is defined in 
//              the domain where the user object belongs to. 
//
//-----------------------------------------------------------------------------

HRESULT
CreateFPNWPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
              PWSTR pwzADsPath, LPWSTR pwzClass, HWND hNotifyObj,
              DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
              HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CreateFPNWPage);

  LPWSTR pwzPDCName = NULL, pwzSecretKey = NULL;
  PWSTR pwzPath = NULL;
  HRESULT hr = S_OK;

  hr = SkipLDAPPrefix(pwzADsPath, pwzPath);
  if (FAILED(hr))
    goto cleanup;

  hr = GetPDCInfo(pwzPath, pwzPDCName, pwzSecretKey);
  if (FAILED(hr))
    goto cleanup;

  if (pwzSecretKey && *pwzSecretKey) {
    CDsFPNWPage * pPageObj = new CDsFPNWPage(pDsPage,
                                             pDataObj,
                                             hNotifyObj,
                                             dwFlags);
    if (!pPageObj) {
      hr = E_OUTOFMEMORY;
    } else {
      pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo);
      pPageObj->InitPDCInfo(pwzPDCName, pwzSecretKey);
      if (pPageObj->InitFPNWUser()) {
        hr = pPageObj->CreatePage(phPage);
      } else {
        hr = S_FALSE;
      }
    }
  } else {
    hr = S_FALSE;
  }

cleanup:
  if (pwzPath)
    delete pwzPath;

  return hr;
}

/////////////////////////////////////////////////////////////////////
// Helper functions
//

//+----------------------------------------------------------------------------
//
//  Function:   ReadUserParms
//
//  Synopsis:   Retrieve the waste dump string from the user object
//
//-----------------------------------------------------------------------------
HRESULT
ReadUserParms(
    IN IDirectoryObject *pDsObj,
    OUT CStr&           cstrUserParms
)
{
  HRESULT hr = S_OK;
  PADS_ATTR_INFO pAttrs = NULL;
  DWORD cAttrs = 0;
  LPWSTR rgpwszAttrNames[] = {ATTR_USERPARMS};

  cstrUserParms.Empty();

  hr = pDsObj->GetObjectAttributes(
                  rgpwszAttrNames, 
                  sizeof(rgpwszAttrNames)/sizeof(rgpwszAttrNames[0]), 
                  &pAttrs, 
                  &cAttrs);

  if (FAILED(hr))
    return hr;

  if ( (cAttrs == 1) &&
       (pAttrs->dwADsType == ADSTYPE_CASE_IGNORE_STRING) ) {
    cstrUserParms = pAttrs->pADsValues->CaseIgnoreString;
  }

  if (pAttrs) 
    FreeADsMem(pAttrs);

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   WriteUserParms
//
//  Synopsis:   Write the waste dump string back into the user object
//
//-----------------------------------------------------------------------------
HRESULT
WriteUserParms(
    IN IDirectoryObject *pDsObj,
    IN const CStr&      cstrUserParms
)
{
  DWORD         cModifiedIgnored = 0;
  ADS_ATTR_INFO aAttrs[1];
  ADSVALUE      Value;

  ZeroMemory(&Value, sizeof(Value));
  Value.dwType = ADSTYPE_CASE_IGNORE_STRING;
  Value.CaseIgnoreString = const_cast<LPWSTR>(static_cast<LPCWSTR>(cstrUserParms));

  ZeroMemory(&(aAttrs[0]), sizeof(aAttrs[0]));
  aAttrs[0].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
  aAttrs[0].pszAttrName = ATTR_USERPARMS;
  aAttrs[0].pADsValues = &Value;
  aAttrs[0].dwNumValues = 1;
  aAttrs[0].dwControlCode = ADS_ATTR_UPDATE;

  HRESULT hr = pDsObj->SetObjectAttributes(
                    aAttrs, 
                    sizeof(aAttrs)/sizeof(aAttrs[0]), 
                    &cModifiedIgnored);

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   SetUserFlag
//
//  Synopsis:   Set userAccountControl on an user object. 
//              Add/remove bits specified in dwFlag.
//
//-----------------------------------------------------------------------------
HRESULT
SetUserFlag(
    IN IDirectoryObject *pDsObj,
    IN bool             bAction,
    IN DWORD            dwFlag
)
{
  HRESULT         hr = S_OK;
  PADS_ATTR_INFO  pAttrs = NULL;
  DWORD           cAttrs = 0;
  LPWSTR          rgpwszAttrNames[] = {ATTR_USERACCOUNTCONTROL};
  DWORD           dwValue = 0;
  DWORD           cModifiedIgnored = 0;
  PADSVALUE       pADsValue = NULL;

  hr = pDsObj->GetObjectAttributes(
                  rgpwszAttrNames, 
                  sizeof(rgpwszAttrNames)/sizeof(rgpwszAttrNames[0]), 
                  &pAttrs, 
                  &cAttrs);

  if (FAILED(hr))
    return hr;

  if ( (cAttrs != 1) ||
       (pAttrs->dwADsType != ADSTYPE_INTEGER) )
  {
    hr = E_FAIL;
    goto cleanup;
  }
  
  dwValue = pAttrs->pADsValues->Integer;

  if (bAction)
    dwValue |= dwFlag;
  else
    dwValue &= ~dwFlag;

  pADsValue = pAttrs->pADsValues;

  ZeroMemory(pADsValue, sizeof(*pADsValue));
  pADsValue->dwType = ADSTYPE_INTEGER;
  pADsValue->Integer = dwValue;

  ZeroMemory(pAttrs, sizeof(*pAttrs));
  pAttrs->dwADsType = ADSTYPE_INTEGER;
  pAttrs->pszAttrName = ATTR_USERACCOUNTCONTROL;
  pAttrs->pADsValues = pADsValue;
  pAttrs->dwNumValues = 1;
  pAttrs->dwControlCode = ADS_ATTR_UPDATE;

  hr = pDsObj->SetObjectAttributes(
                    pAttrs, 
                    1, 
                    &cModifiedIgnored);

cleanup:

  if (pAttrs) 
    FreeADsMem(pAttrs);

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   QueryUserProperty
//
//  Synopsis:   Query the field in the waste dump string
//              The caller needs to call LocalFree() on the buffer afterwards.
//
//-----------------------------------------------------------------------------
LONG
QueryUserProperty(
    IN  LPCTSTR       lpszUserParms,
    IN  LPCTSTR       lpszPropertyName,
    OUT PVOID         *ppBuffer,
    OUT WORD          *pnLength,
    OUT bool          *pbFound
)
{
  ASSERT (lpszPropertyName != NULL);

  *pbFound = false;

  WCHAR PropertyFlag;
  UNICODE_STRING PropertyValue;

  PropertyValue.Buffer = NULL;
  PropertyValue.Length = 0;
  PropertyValue.MaximumLength = 0;

  LONG err = NERR_Success;
  NTSTATUS status = NetpParmsQueryUserProperty(
                        const_cast<LPWSTR>(lpszUserParms),
                        const_cast<LPWSTR>(lpszPropertyName),
                        &PropertyFlag,
                        &PropertyValue
                    );
  if (!NT_SUCCESS(status)) {
    err = NetpNtStatusToApiStatus(status);
  } else if (PropertyValue.Length) {
    *pbFound = TRUE;
    *ppBuffer = PropertyValue.Buffer; // the caller needs to call LocalFree()
    *pnLength = PropertyValue.Length;
  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   SetUserProperty
//
//  Synopsis:   Set the field in the waste dump string
//
//-----------------------------------------------------------------------------
LONG
SetUserProperty(
    IN OUT CStr&       cstrUserParms,
    IN LPCTSTR         lpszPropertyName,
    IN UNICODE_STRING  uniPropertyValue
)
{
  ASSERT (lpszPropertyName != NULL);
  LONG err = NERR_Success;

  LPWSTR  lpNewUserParms = NULL;
  BOOL    fUpdate = false;
  NTSTATUS status = NetpParmsSetUserProperty (
                       const_cast<LPWSTR>(static_cast<LPCWSTR>(cstrUserParms)),
                       const_cast<LPWSTR>(lpszPropertyName),
                       uniPropertyValue,
                       USER_PROPERTY_TYPE_ITEM,
                       &lpNewUserParms,
                       &fUpdate
                   );

  if (!NT_SUCCESS(status)) {
    err = NetpNtStatusToApiStatus(status);
  } else if (fUpdate) {
    cstrUserParms = lpNewUserParms;
  }

  if (lpNewUserParms)
    NetpParmsUserPropertyFree(lpNewUserParms);

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveUserProperty
//
//  Synopsis:   Remove the field from the waste dump string
//
//-----------------------------------------------------------------------------
LONG
RemoveUserProperty(
    IN OUT CStr& cstrUserParms, 
    IN LPCTSTR   lpszPropertyName
)
{
  UNICODE_STRING uniPropertyValue;

  uniPropertyValue.Buffer = NULL;
  uniPropertyValue.Length = 0;
  uniPropertyValue.MaximumLength = 0;

  return SetUserProperty(cstrUserParms, lpszPropertyName, uniPropertyValue);
}

//+----------------------------------------------------------------------------
//
//  Function:   QueryNWPasswordExpired
//
//  Synopsis:   Calculate whether the password expires or not
//
//-----------------------------------------------------------------------------
LONG
QueryNWPasswordExpired(
    IN LPCTSTR lpszUserParms, 
    IN DWORD   dwMaxPasswordAge,
    OUT bool   *pbExpired
)
{
  bool fFound = false;
  PVOID pBuffer = NULL;
  WORD nLength = 0;
  DWORD dwNWPasswordAge = 0;

  //
  // Query the current password age
  //
  LONG err = QueryUserProperty(
                           lpszUserParms, 
                           NWTIMEPASSWORDSET, 
                           &pBuffer, 
                           &nLength, 
                           &fFound);

  if ((NERR_Success == err) && fFound)
  {
    LARGE_INTEGER oldTime = *(reinterpret_cast<LARGE_INTEGER*>(pBuffer));

    LocalFree(pBuffer);

    if ((oldTime.LowPart == 0xffffffff) && 
        (oldTime.HighPart == 0xffffffff))
    {
      dwNWPasswordAge = 0xffffffff;
    } else {
      LARGE_INTEGER currentTime;
      NtQuerySystemTime (&currentTime);
      LARGE_INTEGER deltaTime ;

      deltaTime.QuadPart = currentTime.QuadPart - oldTime.QuadPart ;
      deltaTime.QuadPart /= NT_TIME_RESOLUTION_IN_SECOND;

      dwNWPasswordAge = deltaTime.LowPart;
    }
  }

  //
  // decide if the password expired
  //
  *pbExpired = (dwNWPasswordAge >= dwMaxPasswordAge);
  
  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   QueryDCforNCPLSASecretKey
//
//  Synopsis:   Query a domain controller for the Netware secret key
//
//-----------------------------------------------------------------------------
DWORD
QueryDCforNCPLSASecretKey(
    IN PCWSTR   pwzMachineName, 
    OUT LPWSTR& pwzNWSecretKey
)
{
  DWORD err = ERROR_SUCCESS;
  LSA_HANDLE hlsaPolicy = NULL;
  OBJECT_ATTRIBUTES oa;
  SECURITY_QUALITY_OF_SERVICE sqos;
  LSA_HANDLE hlsaSecret = NULL;
  UNICODE_STRING uMachineName, uSecretName;

  RtlInitUnicodeString( &uMachineName, pwzMachineName );
  RtlInitUnicodeString( &uSecretName, NCP_LSA_SECRET_KEY );

  ZeroMemory(&sqos, sizeof(sqos));
  sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
  sqos.ImpersonationLevel = SecurityImpersonation;
  sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
  sqos.EffectiveOnly = FALSE;

  InitializeObjectAttributes( &oa, NULL, 0L, NULL, NULL );
  oa.SecurityQualityOfService = &sqos;

  err = RtlNtStatusToDosError(
          LsaOpenPolicy(&uMachineName, &oa, STANDARD_RIGHTS_READ, &hlsaPolicy) );

  if (ERROR_SUCCESS == err)
  {
    UNICODE_STRING *puSecretValue = NULL;
    err = RtlNtStatusToDosError(
            LsaRetrievePrivateData(hlsaPolicy, &uSecretName, &puSecretValue) );

    if (ERROR_SUCCESS == err && puSecretValue)
    {
	  //NTRAID#NTBUG9-572000-2002/03/10-jmessec   Possible buffer overrun: no length specified for pwzNWSecretKey
      memcpy(pwzNWSecretKey, puSecretValue->Buffer, NCP_LSA_SECRET_LENGTH);
      LsaFreeMemory( puSecretValue );
    }

    LsaClose( hlsaPolicy );
  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetPDCInfo
//
//  Synopsis:   Given a user object path, get PDC in the domain and 
//              query it for the Netware secret key. 
//              Store the PDC name and the secret key in a cache
//              for efficiency reason.
//
//-----------------------------------------------------------------------------
HRESULT
GetPDCInfo(
    IN  PCWSTR  pwzPath,
    OUT LPWSTR& pwzPDCName,
    OUT LPWSTR& pwzSecretKey
)
{
  HRESULT hr = S_OK;
  DWORD dwErr = ERROR_SUCCESS;
  bool bRetry = false;
  PWSTR pwzDomain = NULL;
  PFPNWCACHE pElem = NULL;
  PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
  pwzSecretKey = NULL;
  Cache::iterator i;

  //
  // get the domain name where the user object belongs to
  //
  hr = CrackName(const_cast<PWSTR>(pwzPath), &pwzDomain, GET_DNS_DOMAIN_NAME);
  if (FAILED(hr))
    goto cleanup;

  ASSERT(pwzDomain);

  //
  // Lookup the secret key in the cache first
  //
  i = g_FPNWCache.find(pwzDomain);
  if (i != g_FPNWCache.end()) {
    pElem = (*i).second;
    if (pElem->dwError == ERROR_SUCCESS &&
       (pElem->pwzPDCName && pElem->pwzPDCName[0]) &&
       (pElem->wzSecretKey && pElem->wzSecretKey[0]) ) {
      pwzPDCName = pElem->pwzPDCName;
      pwzSecretKey = pElem->wzSecretKey;
      goto cleanup;
    } else {
      bRetry = true;
    }
  }

  //
  // not found in the cache or need to re-get it because of previous error
  //
  if (!bRetry)
  {
    pElem = static_cast<PFPNWCACHE>(LocalAlloc(LPTR, sizeof(FPNWCACHE)));
    if (!pElem)
    {
      hr = E_OUTOFMEMORY;
      goto cleanup;
    }
  }

  pwzSecretKey = pElem->wzSecretKey;
  dwErr = DsGetDcName(NULL, pwzDomain, NULL, NULL, 
              0, &pDCInfo);   // sburns for richardw: don't hit the PDC
  if (ERROR_SUCCESS == dwErr) 
  {
    ASSERT(pDCInfo);
    dwErr = QueryDCforNCPLSASecretKey(
                pDCInfo->DomainControllerName, 
                pwzSecretKey);
  
    pElem->pwzPDCName = static_cast<PWSTR>(LocalAlloc(LPTR, (lstrlen(pDCInfo->DomainControllerName) + 1) * sizeof(WCHAR)));
    if (pElem->pwzPDCName) 
    {
      _tcscpy(pElem->pwzPDCName, pDCInfo->DomainControllerName);
    }
    NetApiBufferFree(pDCInfo);

    if (pElem->pwzPDCName) {
      pwzPDCName = pElem->pwzPDCName;
      dwErr = QueryDCforNCPLSASecretKey(
                  pElem->pwzPDCName, 
                  pwzSecretKey);
    } else {
      FreeFPNWCacheElem(pElem);
      hr = E_OUTOFMEMORY;
      goto cleanup;
    }
  }
  pElem->dwError = dwErr;

  //
  // store the result in the cache
  //
  if (!bRetry)
    g_FPNWCache.insert(Cache::value_type(CStr(pwzDomain), pElem));

  hr = HRESULT_FROM_WIN32(dwErr);

cleanup:

  if (pwzDomain)
    LocalFreeStringW(&pwzDomain);

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   SkipLDAPPrefix
//
//  Synopsis:   Drop the "LDAP://server" prefix of an object path 
//
//-----------------------------------------------------------------------------
HRESULT
SkipLDAPPrefix(
    IN PCWSTR   pwzObj, 
    OUT PWSTR&  pwzResult
)
{
    CComPtr<IADsPathname> pADsPath;

    HRESULT hr = CoCreateInstance(
                     CLSID_Pathname, 
                     NULL, 
                     CLSCTX_INPROC_SERVER,
                     IID_IADsPathname, 
                     reinterpret_cast<void **>(&pADsPath));

    if (SUCCEEDED(hr)) {
      hr = pADsPath->Set(CComBSTR(pwzObj), ADS_SETTYPE_FULL);
      if (SUCCEEDED(hr)) {
        BSTR bstr;
        hr = pADsPath->Retrieve(ADS_FORMAT_X500_DN, &bstr);
        if (SUCCEEDED(hr)) {
          if (!AllocWStr(bstr, &pwzResult))
            hr = E_OUTOFMEMORY;
          SysFreeString(bstr);
        }
      }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   InsertZerosToHexString
//
//  Synopsis:   Insert nTimes of 0's at the beginning of the hex string. 
//
//-----------------------------------------------------------------------------
void
InsertZerosToHexString(
    IN OUT LPTSTR lpszBuffer, 
    IN UINT       nTimes
)
{
  if (nTimes > 0) {
    TCHAR *pTmp, *pDest = NULL;

    for (pTmp = lpszBuffer + _tcslen(lpszBuffer); pTmp >= lpszBuffer; pTmp--) {
      pDest = pTmp + nTimes;
      *pDest = *pTmp;   
    }

    pTmp++;

    for ( ; pTmp < pDest; pTmp++) {
      *pTmp = _T('0');
    }
  }
}

//+----------------------------------------------------------------------------
//
//  Function:   InsertLogonAddress
//
//  Synopsis:   Insert the network/node address pair into the list view box. 
//
//-----------------------------------------------------------------------------
void
InsertLogonAddress(
    IN HWND     hlvAddress, 
    IN LPCTSTR  lpszNetworkAddr,
    IN LPCTSTR  lpszNodeAddr
)
{
  LV_ITEM item;

  ZeroMemory(&item, sizeof(item));
  item.mask = LVIF_TEXT;
  item.pszText = const_cast<LPTSTR>(lpszNetworkAddr);

  int index = ListView_InsertItem(hlvAddress, &item);

  if (index != -1) {
    if (_tcsicmp(lpszNodeAddr, SZ_ALL_NODES_ADDR)) {
      ListView_SetItemText(hlvAddress, index, 1, const_cast<LPTSTR>(lpszNodeAddr));
    } else {
      CStr cstrAllNodes;
      cstrAllNodes.LoadString(g_hInstance, IDS_ALL_NODES);
      ListView_SetItemText(hlvAddress, index, 1, const_cast<LPTSTR>(static_cast<LPCTSTR>(cstrAllNodes)));
    }
  }

}

//+----------------------------------------------------------------------------
//
//  Function:   DisplayFPNWLogonSelected
//
//  Synopsis:   Parse the NWLOGONFROM string and insert 
//              each network/node address pair into the 
//              list view box. 
//
//-----------------------------------------------------------------------------
void
DisplayFPNWLogonSelected(
    IN HWND     hlvAddress,
    IN LPCTSTR  lpszLogonFrom
)
{
  LPTSTR ptr = NULL, tail = NULL;
  TCHAR szNetworkAddr[NETWORKSIZE + 1], szNodeAddr[NODESIZE + 1];

  ZeroMemory(szNetworkAddr, sizeof(szNetworkAddr));
  ZeroMemory(szNodeAddr, sizeof(szNodeAddr));

  ptr = const_cast<LPTSTR>(lpszLogonFrom);
  tail = ptr + _tcslen(ptr);

  while (ptr < tail) {
    //NTRAID#NTBUG9-572001-2002/03/10-jmessec    apparently this function takes a certain (undocumented) formatted string,
	  //and this loop trusts that; need to check we aren't copying past the end of lpszLogonFrom 
	_tcsncpy(szNetworkAddr, ptr, NETWORKSIZE);
    ptr += NETWORKSIZE;
    _tcsncpy(szNodeAddr, ptr, NODESIZE);
    ptr += NODESIZE;

    InsertLogonAddress(hlvAddress, szNetworkAddr, szNodeAddr);
  }
}

//+----------------------------------------------------------------------------
//
//  Function:   IsServiceRunning
//
//  Synopsis:   Return TRUE if the specified service is running on the machine. 
//
//-----------------------------------------------------------------------------
bool
IsServiceRunning(
    IN LPCTSTR lpMachineName,
    IN LPCTSTR lpServiceName
)
{
    DWORD dwStatus = 0;
    SC_HANDLE hScManager = NULL, hService = NULL;
    SERVICE_STATUS svcStatus;

    hScManager = OpenSCManager(lpMachineName, NULL, GENERIC_READ);
    hService = OpenService(hScManager, lpServiceName, GENERIC_READ);
    int iServiceStatus = QueryServiceStatus(hService, &svcStatus);

    if (hScManager && hService && iServiceStatus)
    {
      dwStatus = svcStatus.dwCurrentState;
    }

    if (hService)
      CloseServiceHandle(hService);
    if (hScManager)
      CloseServiceHandle(hScManager);

    return (SERVICE_RUNNING == dwStatus);
}

//+----------------------------------------------------------------------------
//
//  Function:   ReadFileToBuffer
//
//  Synopsis:   Read a MBCS file to a MBCS or UNICODE buffer.
//              The caller needs to invoke LocalFree() on the buffer after use.
//
//-----------------------------------------------------------------------------
LONG
ReadFileToBuffer(
    IN  HANDLE hFile,
    IN  bool   bWideBuffer,
    OUT LPVOID *ppBuffer,    
    OUT DWORD  *pdwBytesRead
)
{
  LONG err = ERROR_SUCCESS;

  *ppBuffer = NULL;
  *pdwBytesRead = 0;
  
  do {
    DWORD dwFileSize = GetFileSize (hFile, NULL);
    if (dwFileSize == -1)
    {
        err = GetLastError();
        break;
    }

    if (dwFileSize == 0)
        break;

    LPSTR lpFile = static_cast<LPSTR>(LocalAlloc (LPTR, dwFileSize));
    if (!lpFile)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        break;
    }

    DWORD dwBytesRead;
    if (!ReadFile (hFile,
                   lpFile,
                   dwFileSize,
                   &dwBytesRead,
                   NULL))
    {
        err = GetLastError();
        LocalFree(lpFile);
        break;
    }

    ASSERT (dwBytesRead == dwFileSize);

    // Remove special end of file character added by editor.
    if (*(lpFile+dwBytesRead-2) == 13) {
      *(lpFile+dwBytesRead-2) = 0;
    }

    if (!bWideBuffer) {

      *ppBuffer = lpFile;
      *pdwBytesRead = dwBytesRead;
 
    } else {
  
      DWORD dwWideBuffer = (dwBytesRead+1)*sizeof (WCHAR);
      LPWSTR lpWideBuffer = static_cast<LPWSTR>(LocalAlloc (LPTR, dwWideBuffer));
    
      if (!lpWideBuffer) {
        err = ERROR_NOT_ENOUGH_MEMORY;
      } else {
        if (MultiByteToWideChar (CP_ACP,
                                  0,
                                  lpFile,
                                  dwBytesRead,
                                  lpWideBuffer,
                                  dwWideBuffer)) {
            *ppBuffer = lpWideBuffer;
            *pdwBytesRead = dwWideBuffer;
        } else {
            err = GetLastError();
        }
      }

      LocalFree (lpFile);
    }

  } while (FALSE);

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   WriteBufferToFile
//
//  Synopsis:   Write a MBCS or UNICODE buffer to a MBCS file.
//
//-----------------------------------------------------------------------------
LONG
WriteBufferToFile(
    IN HANDLE hFile,
    IN bool   bWideBuffer,
    IN LPVOID pBuffer,    
    IN DWORD  dwBytesToWrite
)
{
  LONG err = ERROR_SUCCESS;
  LPSTR lpFile = static_cast<LPSTR>(pBuffer);

  do {
    if (bWideBuffer) {

      lpFile    = 0;
      int bytes = 0;
      HRESULT hr =
         ConvertWideStringToAnsiString(

            // 99721 
            // this will create a temporary CStr from pBuffer, which is a
            // waste, but is necessary to get the correct byte count for
            // the ansi form of the text (without changing the call
            // signatures of the functions leading to this point, which
            // seemed not worth it) 

            static_cast<PCWSTR>(pBuffer),
            lpFile,
            bytes);
      if (FAILED(hr))
      {
         err = HRESULT_CODE(hr);
         break;
      }

      dwBytesToWrite = bytes;
    }

    DWORD dwBytesWritten;
    if (!WriteFile (hFile,
                    lpFile,
                    dwBytesToWrite-1,  //don't write the last null character.
                    &dwBytesWritten,
                    NULL))
        err = GetLastError();

    ASSERT (dwBytesWritten == dwBytesToWrite-1);
  
    if (bWideBuffer)
    {
      delete[] lpFile;
    }

  } while (FALSE);

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   OpenLoginScriptFileHandle
//
//  Synopsis:   Open the login script file handle appropriately.
//              The caller needs to call CloseHandle() afterwards.
//
//-----------------------------------------------------------------------------
LONG
OpenLoginScriptFileHandle(
    IN  LPTSTR lpszFileName,
    IN  int    iDirection,
    OUT HANDLE *phFile
)
{
  LONG err = ERROR_SUCCESS;
  HANDLE hFile = INVALID_HANDLE_VALUE;

  if (LOGIN_SCRIPT_FILE_READ == iDirection) { 
    //
    // open for read
    //
    hFile = CreateFile(lpszFileName, 
                              GENERIC_READ, 
                              FILE_SHARE_READ | FILE_SHARE_WRITE, 
                              NULL, 
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
      err = GetLastError();
      if ((err == ERROR_PATH_NOT_FOUND) || (err == ERROR_FILE_NOT_FOUND))
        err = NERR_Success; // this is ok, we'll create this file later
    } else {
      *phFile = hFile;
    }

  } else { 
    //
    // open for write
    //
    hFile = CreateFile(lpszFileName, 
                              GENERIC_WRITE, 
                              FILE_SHARE_WRITE, 
                              NULL, 
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    if (INVALID_HANDLE_VALUE == hFile) {
      err = GetLastError();
      if ((err == ERROR_PATH_NOT_FOUND) || (err == ERROR_FILE_NOT_FOUND)) {
        //
        // path not found. create dir now- strip off last component first.
        //
        TCHAR *p = _tcsrchr(lpszFileName, _T('\\'));
        if (p) {
          *p = _T('\0');

          if (!CreateDirectory(lpszFileName, NULL)) {
            err = GetLastError() ;

            *p = _T('\\'); // restore the '\'

          } else {
            
            *p = _T('\\'); // restore the '\'

            //
            // try again to create the file
            //
            hFile = CreateFile (lpszFileName,
                               GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);
            err = (hFile == INVALID_HANDLE_VALUE) ? GetLastError() : ERROR_SUCCESS;

          }
        }
      }
    }

    if (ERROR_SUCCESS == err)
      *phFile = hFile;

  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   LoadLoginScriptTextFromFile
//
//  Synopsis:   Read the login script file into the edit box. 
//
//-----------------------------------------------------------------------------
LONG
LoadLoginScriptTextFromFile(
    IN HWND     hEdit,
    IN LPCTSTR  lpszFileName
)
{
  LONG err = ERROR_SUCCESS;
  HANDLE hFile = INVALID_HANDLE_VALUE;

  err = OpenLoginScriptFileHandle(
            const_cast<LPTSTR>(lpszFileName), 
            LOGIN_SCRIPT_FILE_READ, 
            &hFile);

  if ((ERROR_SUCCESS == err) && 
      (INVALID_HANDLE_VALUE != hFile)) 
  {
    PVOID pBuffer = NULL;
    DWORD dwBytesRead = 0;
    err = ReadFileToBuffer(hFile, TRUE, &pBuffer, &dwBytesRead);

    if ((ERROR_SUCCESS == err) && pBuffer) {
      SetWindowText(hEdit, static_cast<LPCTSTR>(pBuffer));
      LocalFree(pBuffer);
    }

    CloseHandle(hFile);
  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   UpdateLoginScriptFile
//
//  Synopsis:   Write the buffer contents into the login script file.
//
//-----------------------------------------------------------------------------
LONG
UpdateLoginScriptFile(
    IN LPCTSTR   lpszFileName,
    IN PVOID    pBuffer,
    IN DWORD    dwBytesToWrite
)
{
  LONG err = ERROR_SUCCESS;
  HANDLE hFile = INVALID_HANDLE_VALUE;

  err = OpenLoginScriptFileHandle(
            const_cast<LPTSTR>(lpszFileName), 
            LOGIN_SCRIPT_FILE_WRITE, 
            &hFile);

  if ((ERROR_SUCCESS == err) && 
      (INVALID_HANDLE_VALUE != hFile)) 
  {
    err = WriteBufferToFile(hFile, TRUE, pBuffer, dwBytesToWrite);

    CloseHandle(hFile);
  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   SetUserPassword
//
//  Synopsis:   Set user's password.
//
//-----------------------------------------------------------------------------
HRESULT
SetUserPassword(
    IN IDirectoryObject *pDsObj,
    IN PCWSTR           pwszPassword
)
{
  CComPtr<IADsUser> pADsUser;

  HRESULT hr = pDsObj->QueryInterface(IID_IADsUser, reinterpret_cast<void **>(&pADsUser));
  
  if (SUCCEEDED(hr))
    hr = pADsUser->SetPassword(CComBSTR(pwszPassword));

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetAccountPolicyInfo
//
//  Synopsis:   Get allowed minimum password length and maximum password age.
//
//-----------------------------------------------------------------------------
void
GetAccountPolicyInfo(
    IN  PCTSTR pszServer,
    OUT PDWORD pdwMinPasswdLen,
    OUT PDWORD pdwMaxPasswdAge
)
{
  USER_MODALS_INFO_0 *pModals = NULL;

  *pdwMinPasswdLen = 0;
  *pdwMaxPasswdAge = static_cast<DWORD>(-1);

  if ( NERR_Success == NetUserModalsGet(pszServer, 0, reinterpret_cast<PBYTE *>(&pModals) ) )
  {
    *pdwMinPasswdLen = pModals->usrmod0_min_passwd_len;
    *pdwMaxPasswdAge = pModals->usrmod0_max_passwd_age;
  }
  
  if (pModals)
    NetApiBufferFree( reinterpret_cast<LPVOID>(pModals) );

  return;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetNWUserInfo
//
//  Synopsis:   Get the user name and its NW style objectId. 
//
//-----------------------------------------------------------------------------
HRESULT
GetNWUserInfo(
    IN IDirectoryObject*    pDsObj,
    OUT CStr&               cstrUserName,
    OUT DWORD&              dwObjectID,
    OUT DWORD&              dwSwappedObjectID,
    IN  PMapRidToObjectId&  pfnMapRidToObjectId,
    IN  PSwapObjectId       pfnSwapObjectId
)
{
  ASSERT(pDsObj);

  HRESULT hr = S_OK;
  PADS_ATTR_INFO pAttrs = NULL;
  DWORD cAttrs = 0;
  LPWSTR rgpwszAttrNames[] = {ATTR_SAMACCOUNTNAME, ATTR_OBJECTSID};
  PADS_ATTR_INFO pAttrAccount = NULL, pAttrObjSid = NULL;
  PUCHAR psaCount = NULL;
  PDWORD pRid = NULL;
  PSID pObjSID = NULL;

  hr = pDsObj->GetObjectAttributes(
                  rgpwszAttrNames, 
                  sizeof(rgpwszAttrNames)/sizeof(rgpwszAttrNames[0]), 
                  &pAttrs, 
                  &cAttrs);

  if ( FAILED(hr) )
    return hr;

  if (cAttrs != 2)
  {
    hr = E_FAIL;
    goto cleanup;
  }

  if (_tcscmp(pAttrs[0].pszAttrName, rgpwszAttrNames[0]) == 0)
  {
    pAttrAccount = pAttrs; 
    pAttrObjSid = pAttrs + 1;
  } else {
    pAttrAccount = pAttrs + 1;
    pAttrObjSid = pAttrs;
  }

  if ( (pAttrAccount->dwADsType != ADSTYPE_CASE_IGNORE_STRING) ||
       (pAttrObjSid->dwADsType != ADSTYPE_OCTET_STRING) )
  {
    hr = E_FAIL;
    goto cleanup;
  }

  cstrUserName = pAttrAccount->pADsValues->CaseIgnoreString;

  pObjSID = new BYTE[pAttrObjSid->pADsValues->OctetString.dwLength];
  if (!pObjSID) {
    hr = E_OUTOFMEMORY;
    goto cleanup;
  }

  memcpy(pObjSID, 
         pAttrObjSid->pADsValues->OctetString.lpValue,
         pAttrObjSid->pADsValues->OctetString.dwLength);

  psaCount = GetSidSubAuthorityCount(pObjSID);
  pRid = GetSidSubAuthority(pObjSID, *psaCount - 1);
  if ( psaCount && pRid)
  {
    dwObjectID = pfnMapRidToObjectId(
                    *pRid, 
                    const_cast<LPWSTR>(static_cast<LPCWSTR>(cstrUserName)), 
                    TRUE, // TRUE in dsadmin snapin; FALSE in local usrmgr
                    FALSE // always pass in FALSE
                    );

    dwSwappedObjectID = (SUPERVISOR_USERID == dwObjectID) ? SUPERVISOR_USERID : (pfnSwapObjectId(dwObjectID));

  } else {
    hr = HRESULT_FROM_WIN32(GetLastError());
  }

  delete [] pObjSID;

cleanup:
  if (pAttrs) 
    FreeADsMem(pAttrs);

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   SetNetWareUserPassword
//
//  Synopsis:   encrypt the pwd, and change NWPASSWORD field in userParms
//
//-----------------------------------------------------------------------------
LONG
SetNetWareUserPassword(
    IN OUT  CStr&           cstrUserParms,
    IN PCWSTR               pwzSecretKey,
    IN DWORD                dwObjectID,
    IN PCWSTR               pwzNewPassword,
    IN PReturnNetwareForm   pfnReturnNetwareForm
)
{
  LONG err = NERR_Success;
  TCHAR szEncryptedNWPassword[NWENCRYPTEDPASSWORDLENGTH];
  char pszNWSecretKey[NCP_LSA_SECRET_LENGTH + 1];

  ZeroMemory(pszNWSecretKey, sizeof(pszNWSecretKey));
  memcpy(pszNWSecretKey, pwzSecretKey, NCP_LSA_SECRET_LENGTH);
  NTSTATUS status = pfnReturnNetwareForm(
                        pszNWSecretKey,
                        dwObjectID,
                        pwzNewPassword,
                        reinterpret_cast<UCHAR *>(szEncryptedNWPassword)
                        );

  if (!NT_SUCCESS( status)) {
    err = NetpNtStatusToApiStatus(status);
  } else {
    UNICODE_STRING uniPropertyValue;
    uniPropertyValue.Buffer = szEncryptedNWPassword;
    uniPropertyValue.Length = NWENCRYPTEDPASSWORDLENGTH * sizeof(WCHAR);
    uniPropertyValue.MaximumLength = NWENCRYPTEDPASSWORDLENGTH * sizeof(WCHAR);
    err = SetUserProperty(cstrUserParms, NWPASSWORD, uniPropertyValue);
  }

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   ResetNetWareUserPasswordTime
//
//  Synopsis:   change NWTIMEPASSWORDSET field in userParms
//
//-----------------------------------------------------------------------------
LONG
ResetNetWareUserPasswordTime(
    IN OUT  CStr&  cstrUserParms,
    IN      bool   bNetwarePasswordExpired
)
{
  LONG err = NERR_Success;

  LARGE_INTEGER currentTime;
  if (bNetwarePasswordExpired) {
      currentTime.HighPart = 0xffffffff;
      currentTime.LowPart = 0xffffffff;
  } else {
      NtQuerySystemTime (&currentTime);
  }

  UNICODE_STRING uniPropertyValue;
  uniPropertyValue.Buffer = reinterpret_cast<PWSTR>(&currentTime);
  uniPropertyValue.Length = sizeof(currentTime);
  uniPropertyValue.MaximumLength = sizeof(currentTime);
  err = SetUserProperty(cstrUserParms, NWTIMEPASSWORDSET, uniPropertyValue);

  return err;
}

//+----------------------------------------------------------------------------
//
//  Function:   ModifyNetWareUserPassword
//
//  Synopsis:   Exported in dsprop.lib
//      Called by dsadmin.dll to set NetWare enabled user's password
//      when NT password changes.
//
//-----------------------------------------------------------------------------
HRESULT
ModifyNetWareUserPassword(
    IN IADsUser*          pADsUser,
    IN PCWSTR             pwzADsPath,
    IN PCWSTR             pwzNewPassword
)
{
  CComPtr<IDirectoryObject> spDsObj;
  HRESULT hr = pADsUser->QueryInterface(IID_IDirectoryObject, reinterpret_cast<void **>(&spDsObj));
  if (FAILED(hr))
    return hr;

  // make sure the waste dump for fpnw user exist
  CStr cstrUserParms;
  hr = ReadUserParms(spDsObj, cstrUserParms);
  if (SUCCEEDED(hr))
  {
    PVOID pBuffer = NULL;
    WORD  nLength = 0;
    bool  bFound = FALSE;
    QueryUserProperty(cstrUserParms,
                      NWPASSWORD,
                      &pBuffer,
                      &nLength,
                      &bFound);
    if (bFound)
      LocalFree(pBuffer);

    hr = bFound ? S_OK : S_FALSE;
  }
  if (FAILED(hr))
    return hr;

  if (S_OK == hr)
  {
    // This is a NetWare enabled user

    // load fpnwclnt.dll
    HINSTANCE           hFPNWClntDll = NULL;
    PMapRidToObjectId   pfnMapRidToObjectId = NULL;
    PSwapObjectId       pfnSwapObjectId = NULL;
    PReturnNetwareForm  pfnReturnNetwareForm = NULL;
    
    hFPNWClntDll = LoadLibrary(SZ_FPNWCLNT_DLL);
    pfnMapRidToObjectId = reinterpret_cast<PMapRidToObjectId>(GetProcAddress(hFPNWClntDll, SZ_MAPRIDTOOBJECTID));
    pfnSwapObjectId = reinterpret_cast<PSwapObjectId>(GetProcAddress(hFPNWClntDll, SZ_SWAPOBJECTID));
    pfnReturnNetwareForm = reinterpret_cast<PReturnNetwareForm>(GetProcAddress(hFPNWClntDll, SZ_RETURNNETWAREFORM));

    if (!hFPNWClntDll || !pfnMapRidToObjectId || !pfnSwapObjectId || !pfnReturnNetwareForm)
    {
      hr = HRESULT_FROM_WIN32( GetLastError() );
    } 
    else 
    {

      // get secret key
      PWSTR pwzPath = NULL;
      hr = SkipLDAPPrefix(pwzADsPath, pwzPath);
      if (SUCCEEDED(hr))
      {
        PWSTR pwzPDCName = NULL, pwzSecretKey = NULL;
        hr = GetPDCInfo(pwzPath, pwzPDCName, pwzSecretKey);

        if (SUCCEEDED(hr))
        {
          // get object id
          CStr cstrUserName;
          DWORD dwObjectID = 0, dwSwappedObjectID = 0;
          hr = GetNWUserInfo(
                  spDsObj,
                  cstrUserName,       // OUT
                  dwObjectID,         // OUT
                  dwSwappedObjectID,  // OUT
                  pfnMapRidToObjectId,
                  pfnSwapObjectId
                  );

          if (SUCCEEDED(hr))
          {
            // change password in the userParms
            LONG err = SetNetWareUserPassword(
                      cstrUserParms,
                      pwzSecretKey,
                      dwObjectID,
                      pwzNewPassword,
                      pfnReturnNetwareForm);

            if (NERR_Success == err)
              err = ResetNetWareUserPasswordTime(cstrUserParms, false); // clear the expire flag

            hr = HRESULT_FROM_WIN32(err);

            // write userParms back to DS
            if (SUCCEEDED(hr))
              hr = WriteUserParms(spDsObj, cstrUserParms);
          }
        }
        if (pwzPath)
          delete pwzPath;
      }
    }

    if (hFPNWClntDll)
      FreeLibrary(hFPNWClntDll);
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\dsquery.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dsquery.cxx
//
//  Contents:
//
//  History:    07-May-97 JonN  copied from bitfield.cxx
//              31-Dec-97 JonN  Revamped using IADsPathname
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"

#include "qrybase.h" // CDSSearch

#ifdef DSADMIN

#define BreakOnFail(hr)  if ( FAILED(hr) ) { dspAssert( FALSE ); break; }
#define ReturnOnFail(hr) if ( FAILED(hr) ) { dspAssert( FALSE ); return hr; }


//+----------------------------------------------------------------------------
//
//  Function:   FillDNDropdown
//
//  Synopsis:   Fills in the dropdown listbox for DsQueryAttributeDN.
//
//  Notes:      For each entry in the dropdown listbox, the ItemData points to
//              a BSTR containing the X500 DN for this selection.  If the admin
//              chooses this item, just set the DN attribute to this value.
//              If this pointer is NULL then clear the attribute instead.
//
//              When you're finished with the combobox you will have to
//              free these strings.
//
//-----------------------------------------------------------------------------

HRESULT
FillDNDropdown( HWND hwnd,
                LPCWSTR lpcwszADsPathDirectory,
                LPCWSTR lpcwszTargetDesiredClass,
                LPCWSTR lpcwszCurrentDNValue,
                int     residBlankEntryDisplay)
{
	HRESULT hr = S_OK;

	PTSTR ptsz = NULL;

	if ( 0 != residBlankEntryDisplay )
	{
		if ( !LoadStringToTchar (residBlankEntryDisplay, &ptsz) )
		{
			ReportError(GetLastError(), 0, hwnd);
			return E_OUTOFMEMORY;
		}
	}

	// first add the empty string (attribute clear)
	int iIndex = ComboBox_AddString( hwnd, (NULL != ptsz) ? ptsz : L"" );
	if ( NULL != ptsz )
		delete [] ptsz;
	if ( 0 > iIndex )
	{
		hr = E_FAIL;
		ReturnOnFail(hr);
	}
	int iRetval = ComboBox_SetItemData(
		hwnd,
		iIndex,
		NULL );
	dspAssert( CB_ERR != iRetval );

	// now add the current setting if the attribute is not clear
	if ( NULL != lpcwszCurrentDNValue && L'\0' != *lpcwszCurrentDNValue )
	{
    CComBSTR sbstrRDN;
    hr = DSPROP_RetrieveRDN( lpcwszCurrentDNValue, &sbstrRDN );
    ReturnOnFail(hr);
		ASSERT( !!sbstrRDN );

		iIndex = ComboBox_AddString( hwnd, sbstrRDN );
		if ( 0 > iIndex )
		{
			hr = E_FAIL;
			ReturnOnFail(hr);
		}
		iRetval = ComboBox_SetItemData(
			hwnd,
			iIndex,
			::SysAllocString( lpcwszCurrentDNValue ) );
		dspAssert( CB_ERR != iRetval );
	}

	// Set initial selection
	iRetval = ComboBox_SetCurSel( hwnd, iIndex );
	dspAssert( CB_ERR != iRetval );

	// now add all of the objects of the specified class
	// in the specified container
	CDSSearch Search;
	Search.Init(lpcwszADsPathDirectory);
	CStr strFilterString;
	strFilterString.Format(L"(&(objectClass=%s))", lpcwszTargetDesiredClass);
	Search.SetFilterString(const_cast<LPWSTR>((LPCTSTR)strFilterString));
	LPWSTR pAttrs[2] = {L"name",
	                    L"distinguishedName"};
	Search.SetAttributeList(pAttrs, 2);
	Search.SetSearchScope(ADS_SCOPE_ONELEVEL);
	hr = Search.DoQuery();
	while (SUCCEEDED(hr)) {
		hr = Search.GetNextRow();
		if (S_ADS_NOMORE_ROWS == hr)
		{
			hr = S_OK;
			break;
		}
		BreakOnFail(hr);

		ADS_SEARCH_COLUMN NameColumn, DistinguishedNameColumn;
		::ZeroMemory( &NameColumn, sizeof(NameColumn) );
		::ZeroMemory( &DistinguishedNameColumn, sizeof(DistinguishedNameColumn) );
		hr = Search.GetColumn (pAttrs[0], &NameColumn);
		BreakOnFail(hr);
		hr = Search.GetColumn (pAttrs[1], &DistinguishedNameColumn);
		BreakOnFail(hr);
		dspAssert( ADSTYPE_CASE_IGNORE_STRING == NameColumn.pADsValues->dwType );
		dspAssert( ADSTYPE_DN_STRING == DistinguishedNameColumn.pADsValues->dwType );

		// if the current value has already been added, don't add it twice
		if ( !lpcwszCurrentDNValue // 645078-2002/06/17-JonN check for NULL
		  || lstrcmpi( lpcwszCurrentDNValue,
		               DistinguishedNameColumn.pADsValues->DNString ) )
		{
			iIndex = ComboBox_AddString(
				hwnd, NameColumn.pADsValues->CaseIgnoreString );
			if ( 0 > iIndex )
			{
				hr = E_FAIL;
				BreakOnFail(hr);
			}
			iRetval = ComboBox_SetItemData(
				hwnd,
				iIndex,
				::SysAllocString( DistinguishedNameColumn.pADsValues->DNString ) );
			dspAssert( CB_ERR != iRetval );
		}
		Search.FreeColumn (&NameColumn);
		Search.FreeColumn (&DistinguishedNameColumn);
	}
	return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DsQueryAttributeDN
//
//  Synopsis:   Handles single-valued DN pointer to arbitrary object in a known
//              container.  Uses dropdown listbox.
//
//  Notes:      This function adds three parameters to the usual button-handler pfn.
//
//              iTargetLevelsUp and ppwszTargetLevelsBack are used to
//              locate the known container relative to the current container
//              if the attribute is currently clear.  DsQueryAttributeDN starts
//              with the current container, counts back iTargetLevelsUp containers,
//              then looks for subcontainer ppwszTargetLevelsBack.
//              CODEWORK It might be possible to simplify this mechanism by
//              starting at the naming context root if it is available.
//
//              pwzTargetClass is the class of the object to which the DN
//              pointer should be made to point.
//
//-----------------------------------------------------------------------------

HRESULT
DsQueryAttributeDN(CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                   LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp,
                   int iTargetLevelsUp, PWCHAR* ppwszTargetLevelsBack,
                   PWCHAR pwszTargetClass, int residBlankEntryDisplay)
{
	dspAssert( NULL != pPropPage && NULL != pAttrMap );

	HRESULT hr = S_OK;
	switch (DlgOp)
	{
	case fInit:
		DBG_OUT("DsQueryAttributeDN: fInit");
		{
			HWND hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID);
			dspAssert( NULL != hwndCtrl );

			// JonN 7/2/99: disable if attribute not writable
			if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
				EnableWindow(hwndCtrl, FALSE);

			//
			// Determine the initial attribute value if any
			//
			LPWSTR pszCurrentDN = NULL;
			if (pAttrInfo && (pAttrInfo->dwNumValues == 1))
			{
				dspAssert( NULL != pAttrInfo->pADsValues
						 && NULL != pAttrInfo->pADsValues->DNString );
				pszCurrentDN = pAttrInfo->pADsValues->DNString;
			}

			LPWSTR pcwstrThisObject = pPropPage->GetObjPathName();
			dspAssert(NULL != pcwstrThisObject);

			CComBSTR sbstr;
			hr = DSPROP_TweakADsPath(
			          pcwstrThisObject,
			          iTargetLevelsUp,
			          ppwszTargetLevelsBack,
			          &sbstr );
			BreakOnFail(hr);

			hr = FillDNDropdown( hwndCtrl,
			                     sbstr,
			                     pwszTargetClass,
			                     pszCurrentDN,
			                     residBlankEntryDisplay );
		}
		break;

	case fApply:
		DBG_OUT("DsQueryAttributeDN: fApply");
		{
			// 645078-2002/06/17-JonN: disable if attribute not writable
			if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
				return ADM_S_SKIP;

			HWND hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID);
			dspAssert( NULL != hwndCtrl );

			int iIndex = ComboBox_GetCurSel( hwndCtrl );
			if (0 > iIndex)
			{
				hr = E_FAIL;
				BreakOnFail(hr);
			}
			BSTR bstrTargetPath = (BSTR)ComboBox_GetItemData( hwndCtrl, iIndex );
			if ( NULL == bstrTargetPath || L'\0' == *bstrTargetPath )
			{
				pAttrInfo->pADsValues = NULL;
				pAttrInfo->dwNumValues = 0;
				pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
				break;
			}

			// transfer it to a "new"-allocated string
			LPWSTR pwszFinal = new WCHAR[ wcslen(bstrTargetPath)+1 ];
      if (pwszFinal != NULL)
      {
			  wcscpy( pwszFinal, bstrTargetPath );

			  PADSVALUE pADsValue;
			  pADsValue = new ADSVALUE;
			  if (NULL == pADsValue)
			  {
				  dspAssert(FALSE);
				  hr = E_OUTOFMEMORY;
				  break;
			  }
			  pAttrInfo->pADsValues = pADsValue;
			  pAttrInfo->dwNumValues = 1;
			  pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
			  pADsValue->dwType = pAttrInfo->dwADsType;
			  pADsValue->DNString = pwszFinal;
      }
      else
      {
        dspAssert(FALSE);
        hr = E_OUTOFMEMORY;
        break;
      }
		}
        break;

    case fOnCommand:
        DBG_OUT("DsQueryAttributeDN: fOnCommand");
        if (lParam == CBN_SELCHANGE)
            pPropPage->SetDirty();
        break;

    case fOnDestroy:
	DBG_OUT("DsQueryAttributeDN: fOnDestroy");
	// release itemdata associated with combobox items
	{
		HWND hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID);
		dspAssert( NULL != hwndCtrl );
		while (0 < ComboBox_GetCount( hwndCtrl ))
		{
			BSTR bstrFirstItem = (BSTR)ComboBox_GetItemData( hwndCtrl, 0 );
			if (NULL != bstrFirstItem)
				::SysFreeString( bstrFirstItem );
			int iRetval = ComboBox_DeleteString( hwndCtrl, 0 );
			dspAssert( CB_ERR != iRetval );
		}
	}
	break;

    case fOnCallbackRelease:
	DBG_OUT("DsQueryAttributeDN: fOnCallbackRelease");
	break;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DsQuerySite
//
//  Synopsis:   Handles single-valued DN pointer from Subnet to Site object,
//              or from SiteSettings to Site object.
//
//-----------------------------------------------------------------------------
HRESULT
DsQuerySite(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
    // JonN 1/25/02 use "<Default>" for default site
    return DsQueryAttributeDN( pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
                               2, NULL, L"site", static_cast<int>((INT_PTR)pAttrMap->pData) );
}


//+----------------------------------------------------------------------------
//
//  Function:   DsQueryInterSiteTransport
//
//  Synopsis:   Handles single-valued DN pointer from NTDS-Connection to
//              Inter-Site-Transport object
//
//-----------------------------------------------------------------------------
HRESULT
DsQueryInterSiteTransport(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
    static WCHAR* apwszLevelsBack[2] = {
        L"CN=Inter-Site Transports",
        (WCHAR*)NULL };
    return DsQueryAttributeDN( pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
                               5, apwszLevelsBack, L"interSiteTransport", IDS_RPC );
}


//+----------------------------------------------------------------------------
//
//  Function:   DsQueryPolicy
//
//  Synopsis:  Handles single-valued DN pointer to Domain Policy object
//             Uses edit field for now
//
//-----------------------------------------------------------------------------
HRESULT
DsQueryPolicy(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
    static WCHAR* apwszLevelsBack[5] = {
        L"CN=Services",
        L"CN=Windows NT",
        L"CN=Directory Service",
        L"CN=Query-Policies",
        (WCHAR*)NULL };
    return DsQueryAttributeDN( pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
                               5, apwszLevelsBack, L"queryPolicy", 0 );
}


/*
//+----------------------------------------------------------------------------
//
//  Function:   DsQueryFrsPrimaryMember
//
//  Synopsis:  Handles single-valued DN pointer to NTFRS-Member object
//             Uses edit field for now
//
//-----------------------------------------------------------------------------
HRESULT
DsQueryFrsPrimaryMember(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
    return DsQueryAttributeDN( pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
                               0, NULL, L"nTFRSMember" );
}
*/

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\fpnw.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       fpnw.h
//
//--------------------------------------------------------------------------

#ifndef _FPNW_H_
#define _FPNW_H_

#include "crypt.h" // USER_SESSION_KEY_LENGTH
#include "fpnwapi.h" // FPNWVOLUMEINFO
#include <map>
using namespace std;

typedef struct _FPNWCACHE {
  DWORD             dwError;
  PWSTR             pwzPDCName;
  WCHAR             wzSecretKey[NCP_LSA_SECRET_LENGTH + 1];
} FPNWCACHE, * PFPNWCACHE;

typedef map<CStr, PFPNWCACHE> Cache;

typedef ULONG (* PMapRidToObjectId)(
    IN  DWORD   dwRid,
    IN  LPWSTR  pszUserName,
    IN  BOOL    fNTAS,
    IN  BOOL    fBuiltin );

typedef ULONG (* PSwapObjectId)(
    IN  ULONG   ulObjectId );

typedef NTSTATUS (* PReturnNetwareForm)(
    IN  LPCSTR  pszSecretValue,
    IN  DWORD   dwUserId,
    IN  LPCWSTR pchNWPassword,
    OUT UCHAR   *pchEncryptedNWPassword
    );

typedef DWORD (* PFPNWVolumeGetInfo)(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppVolumeInfo
);

typedef DWORD (* PFpnwApiBufferFree)(
    IN  LPVOID pBuffer
);

/////////////////////////////////////////////////////////////////////////////
// CDsFPNWPage dialog

class CDsFPNWPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
  char szClass[32];
#endif

public:
  CDsFPNWPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags);
  ~CDsFPNWPage();

public:
  INT_PTR CALLBACK DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
  HRESULT OnInitDialog(LPARAM lParam);
  virtual LRESULT OnApply(void);
  LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
  int     DoFPNWPasswordDlg();
  int     DoFPNWLoginScriptDlg();
  int     DoFPNWLogonDlg();
  int     DoFPNWLogonAddDlg(HWND hwndParent, HWND hlvAddress);

  bool    InitFPNWUser();
  DWORD   LoadFPNWClntDll();
  LONG    GetLoginScriptFilePath(
      OUT CStr&   cstrLoginScriptFilePath
  );

  inline void InitPDCInfo(
      IN LPCWSTR lpszPDCName, 
      IN LPCWSTR lpwzSecretKey
  )
  { 
    m_pwzPDCName = (LPWSTR)lpszPDCName;
    m_pwzSecretKey = (LPWSTR)lpwzSecretKey; 
  };
  void    ParseUserParms();
  bool    UpdateUserParms(DWORD dwFPNWFields);

  HRESULT
  UpdateUserParamsStringValue(
    PCWSTR      propertyName,
    const CStr& propertyValue);

protected:
  CStr    m_cstrUserParms;
  LPWSTR  m_pwzPDCName;
  LPWSTR  m_pwzSecretKey;

  bool    m_bMaintainNetwareLogin;
  bool    m_bNetwarePasswordExpired;
  bool    m_bLimitGraceLogins;
  bool    m_bLimitConnections;
  USHORT  m_ushGraceLoginLimit;
  USHORT  m_ushGraceLoginsRemaining;
  USHORT  m_ushConnectionLimit;
  CStr    m_cstrHmDirRelativePath;

  HINSTANCE           m_hFPNWClntDll;
  PMapRidToObjectId   m_pfnMapRidToObjectId;
  PSwapObjectId       m_pfnSwapObjectId;
  PReturnNetwareForm  m_pfnReturnNetwareForm;
  PFPNWVolumeGetInfo  m_pfnFPNWVolumeGetInfo;
  PFpnwApiBufferFree  m_pfnFpnwApiBufferFree;

public:
  DWORD   m_dwMinPasswdLen;
  DWORD   m_dwMaxPasswdAge;

  CStr    m_cstrUserName;
  DWORD   m_dwObjectID;
  DWORD   m_dwSwappedObjectID;
  CStr    m_cstrNWPassword;
  CStr    m_cstrLogonFrom;
  CStr    m_cstrNewLogonFrom;

  CStr    m_cstrLoginScriptFileName;
  LPVOID  m_pLoginScriptBuffer;
  DWORD   m_dwBytesToWrite;
  bool    m_bLoginScriptChanged;
};

INT_PTR CALLBACK 
FPNWPasswordDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
);

INT_PTR CALLBACK 
FPNWLoginScriptDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
);

INT_PTR CALLBACK
FPNWLogonDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
);

INT_PTR CALLBACK
FPNWLogonAddDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
);

LRESULT CALLBACK 
HexEditCtrlProc(
    HWND    hwnd,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam
);

HRESULT
CreateFPNWPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
              PWSTR pwzADsPath, LPWSTR pwzClass, HWND hNotifyObj,
              DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
              HPROPSHEETPAGE * phPage);

// Helper functions
void
FreeFPNWCacheElem(
    PFPNWCACHE p
);

HRESULT
ReadUserParms(
    IN IDirectoryObject *pDsObj,
    OUT CStr&           cstrUserParms
);

HRESULT
WriteUserParms(
    IN IDirectoryObject *pDsObj,
    IN const CStr&      cstrUserParms
);

HRESULT
SetUserFlag(
    IN IDirectoryObject *pDsObj,
    IN bool             bAction,
    IN DWORD            dwFlag
);

LONG
QueryUserProperty(
    IN  LPCTSTR       lpszUserParms,
    IN  LPCTSTR       lpszPropertyName,
    OUT PVOID         *ppBuffer,
    OUT WORD          *pnLength,
    OUT bool          *pbFound
);

LONG
SetUserProperty(
    IN OUT CStr&       cstrUserParms,
    IN LPCTSTR         lpszPropertyName,
    IN UNICODE_STRING  uniPropertyValue
);

LONG
RemoveUserProperty (
    IN OUT CStr& cstrUserParms, 
    IN LPCTSTR   lpszPropertyName
);

LONG
QueryNWPasswordExpired(
    IN LPCTSTR lpszUserParms, 
    IN DWORD   dwMaxPasswordAge,
    OUT bool   *pbExpired
);

DWORD
QueryDCforNCPLSASecretKey(
    IN PCWSTR   pwzMachineName, 
    OUT LPWSTR& pwzSecretKey
);

HRESULT
GetPDCInfo(
    IN  PCWSTR  pwzPath,
    OUT LPWSTR& pwzPDCName,
    OUT LPWSTR& pwzSecretKey
);

HRESULT
SkipLDAPPrefix(
    IN PCWSTR   pwzObj, 
    OUT PWSTR&  pwzResult
);

void
InsertZerosToHexString(
    IN OUT LPTSTR lpszBuffer, 
    IN UINT       nTimes
);

void
InsertLogonAddress(
    IN HWND     hlvAddress, 
    IN LPCTSTR  lpszNetworkAddr,
    IN LPCTSTR  lpszNodeAddr
);

void
DisplayFPNWLogonSelected(
    IN HWND     hlvAddress,
    IN LPCTSTR  lpszLogonFrom
);

bool
IsServiceRunning(
    IN LPCTSTR lpMachineName,
    IN LPCTSTR lpServiceName
);

LONG
ReadFileToBuffer(
    IN  HANDLE hFile,
    IN  bool   bWideBuffer,
    OUT LPVOID *ppBuffer,    
    OUT DWORD  *pdwBytesRead
);

LONG
WriteBufferToFile(
    IN HANDLE hFile,
    IN bool   bWideBuffer,
    IN LPVOID pBuffer,    
    IN DWORD  dwBytesToWrite
);

LONG
OpenLoginScriptFileHandle(
    IN  LPTSTR lpszFileName,
    IN  int    iDirection,
    OUT HANDLE *phFile
);

LONG
LoadLoginScriptTextFromFile(
    IN HWND     hEdit,
    IN LPCTSTR  lpszFileName
);

LONG
UpdateLoginScriptFile(
    IN LPCTSTR  lpszFileName,
    IN PVOID    pBuffer,
    IN DWORD    dwBytesToWrite
);

HRESULT
SetUserPassword(
    IN IDirectoryObject *pDsObj,
    IN PCWSTR           pwszPassword
);

void
GetAccountPolicyInfo(
    IN  PCTSTR pszServer,
    OUT PDWORD pdwMinPasswdLen,
    OUT PDWORD pdwMaxPasswdAge
);

HRESULT
GetNWUserInfo(
    IN IDirectoryObject*    pDsObj,
    OUT CStr&               cstrUserName,
    OUT DWORD&              dwObjectID,
    OUT DWORD&              dwSwappedObjectID,
    IN  PMapRidToObjectId&  pfnMapRidToObjectId,
    IN  PSwapObjectId       pfnSwapObjectId
);

LONG
SetNetWareUserPassword(
    IN OUT  CStr&           cstrUserParms,
    IN PCWSTR               pwzSecretKey,
    IN DWORD                dwObjectID,
    IN PCWSTR               pwzNewPassword,
    IN PReturnNetwareForm   pfnReturnNetwareForm
);

LONG
ResetNetWareUserPasswordTime(
    IN OUT  CStr&  cstrUserParms,
    IN      bool   bNetwarePasswordExpired
);

#endif // _FPNW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\ftinfo.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       ftinfo.h
//
//  Contents:   AD cross-forest trust pages.
//
//  Classes:    CFTInfo, CFTCollisionInfo
//
//  History:    05-Dec-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef FTINFO_H_GUARD
#define FTINFO_H_GUARD

//#ifdef __cplusplus
//extern "C" {
//#endif

// Exported entrypoints used by netdom to view/manipulate forest trust infos.
//
extern "C" INT_PTR WINAPI
DSPROP_DumpFTInfos(PCWSTR pwzLocalDomain, PCWSTR pwzTrust,
                   PCWSTR pwzUser, PCWSTR pwzPw);

extern "C" INT_PTR WINAPI
DSPROP_ToggleFTName(PCWSTR pwzLocalDc, PWSTR pwzTrust, ULONG iSel,
                    PCWSTR pwzUser, PCWSTR pwzPW);
//#ifdef __cplusplus
//}
//#endif // __cplusplus


//+----------------------------------------------------------------------------
//
//  Class:     FT_EXTRA_INFO
//
//  Purpose:   The PLSA_FOREST_TRUST_INFORMATION structure maintained by
//             CFTInfo is passed to LSA and cannot be extended. Hence this
//             class as a separate, parallel extension for storing state
//             internal to the trust admin tools.
//
//-----------------------------------------------------------------------------
class FT_EXTRA_INFO
{
public:
   FT_EXTRA_INFO(void) : _Status(Enabled), _fWasInConflict(false) {}
   ~FT_EXTRA_INFO(void) {}

   enum STATUS {
      Enabled,
      DisabledViaParentTLNDisabled,
      DisabledViaMatchingTLNEx,
      DisabledViaParentMatchingTLNEx,
      TLNExMatchesExistingDomain,
      Invalid
   };

   STATUS   _Status;
   bool     _fWasInConflict;
};

//+----------------------------------------------------------------------------
//
//  Class:     CFTInfo
//
//  Purpose:   Encapsulate the forest trust naming information.
//
//-----------------------------------------------------------------------------
class CFTInfo
{
public:
#ifdef _DEBUG
   char szClass[32];
#endif

   CFTInfo(void);
   CFTInfo(PLSA_FOREST_TRUST_INFORMATION pFTInfo);
   CFTInfo(CFTInfo & FTInfo);
   ~CFTInfo(void);

   const CFTInfo & operator= (const PLSA_FOREST_TRUST_INFORMATION pFTInfo);
   bool  SetFTInfo(PLSA_FOREST_TRUST_INFORMATION pFTInfo);
   bool  CreateDefault(PCWSTR pwzForestRoot, PCWSTR pwzNBName, PSID Sid);
   void  DeleteFTInfo(void);
   ULONG GetCount(void) {return (_pFTInfo) ? _pFTInfo->RecordCount : 0;}
   ULONG GetTLNCount(void) const;
   bool  GetIndex(PCWSTR pwzName, ULONG & index) const;
   bool  GetDnsName(ULONG index, CStrW & strName) const;
   bool  GetNbName(ULONG index, CStrW & strName) const;
   bool  GetType(ULONG index, LSA_FOREST_TRUST_RECORD_TYPE & type) const;
   ULONG GetFlags(ULONG index) const;
   PLSA_FOREST_TRUST_INFORMATION GetFTInfo(void) {return _pFTInfo;}
   void  SetDomainState(void);
   bool  IsInConflict(void) const;
   void  ClearAnyConflict(void);
   void  ClearConflict(ULONG index);
   bool  IsConflictFlagSet(ULONG index) const;
   bool  SetAdminDisable(ULONG index);
   bool  SetConflictDisable(ULONG index);
   void  SetUsedToBeInConflict(ULONG index);
   bool  WasInConflict(ULONG index);
   bool  IsEnabled(ULONG index) const;
   void  ClearDisableFlags(ULONG index);
   bool  SetSidAdminDisable(ULONG index);
   bool  AnyChildDisabled(ULONG index);
   bool  IsParentDisabled(ULONG index) const;
   bool  IsTlnExclusion(ULONG index) const;
   bool  IsMatchingDomain(ULONG iTLN, ULONG index) const;
   bool  IsChildDomain(ULONG iParent, ULONG index) const;
   bool  IsChildName(ULONG iParent, PCWSTR pwzName) const;
   bool  GetTlnEditStatus(ULONG index, TLN_EDIT_STATUS & status) const;
   bool  AddNewExclusion(PCWSTR pwzName, ULONG & NewIndex);
   bool  RemoveExclusion(ULONG index);
   bool  IsNameTLNExChild(PCWSTR pwzName) const;
   bool  DisableDomain(ULONG index);
   bool  EnableDomain(ULONG index);
   FT_EXTRA_INFO::STATUS GetExtraStatus(ULONG index) const;
   bool  FindMatchingExclusion(ULONG index, ULONG & iExclusion, bool CheckParent = false) const;
   bool  IsDomainMatch(ULONG index) const;
   bool  FindSID(PCWSTR pwzSID, ULONG & index) const;
   bool  IsForestRootTLN(ULONG index, PCWSTR pwzForestRoot) const;
   bool  AddNewTLN ( PCWSTR pwzName, ULONG &NewIndex );
   bool  RemoveTLN ( ULONG index );

private:

   PLSA_FOREST_TRUST_INFORMATION _pFTInfo;
   FT_EXTRA_INFO               * _pExtraInfo;

   bool AddNewRecord ( PCWSTR pwzName, ULONG &NewIndex, LSA_FOREST_TRUST_RECORD_TYPE RecordType );
   bool RemoveRecord ( ULONG index, LSA_FOREST_TRUST_RECORD_TYPE RecordType );
};

//+----------------------------------------------------------------------------
//
//  Class:     CFTCollisionInfo
//
//  Purpose:   Encapsulate the forest trust collision information.
//
//-----------------------------------------------------------------------------
class CFTCollisionInfo
{
public:
#ifdef _DEBUG
   char szClass[32];
#endif

   CFTCollisionInfo(void);
   CFTCollisionInfo(PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo);
   ~CFTCollisionInfo(void);

   //operator PLSA_FOREST_TRUST_COLLISION_INFORMATION() {return _pFTCollisionInfo};
   const CFTCollisionInfo & operator= (const PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo);
   void  SetCollisionInfo(PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo);
   bool  IsInCollisionInfo(PCWSTR pwzName) const {return false;}
   bool  IsInCollisionInfo(ULONG index) const;
   bool  GetCollisionName(ULONG index, CStrW & strName) const;
   bool  IsInConflict(void) const {return _pFTCollisionInfo != NULL;}

private:
   PLSA_FOREST_TRUST_COLLISION_INFORMATION _pFTCollisionInfo;
};

typedef void (*LINE_COMPOSER)(CStrW & strOut, ULONG ulLineNum, PCWSTR pwzCol1,
                              PCWSTR pwzCol2, PCWSTR pwzCol3, PCWSTR pwzCol4);

//+----------------------------------------------------------------------------
//
//  Function:  FormatFTNames
//
//-----------------------------------------------------------------------------
void
FormatFTNames(CFTInfo & FTInfo, CFTCollisionInfo & ColInfo,
              LINE_COMPOSER pLineFcn, CStrW & strMsg);

//+----------------------------------------------------------------------------
//
//  Function:  SaveFTInfoAs
//
//  Synopsis:  Prompt the user for a file name and then save the FTInfo as a
//             text file.
//
//-----------------------------------------------------------------------------
void
SaveFTInfoAs(HWND hWnd, PCWSTR wzFlatName, PCWSTR wzDnsName,
             CFTInfo & FTInfo, CFTCollisionInfo & ColInfo);

void AddAsteriskPrefix(CStrW & strName);
void RemoveAsteriskPrefix(CStrW & strName);

#endif // FTINFO_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\guids.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       guids.cxx
//
//  Contents:   guid allocations - guids are defined in propuuid.h
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"

// initguid.h requires this.
//
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>

#include <propuuid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\ftinfo.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       ftinfo.cxx
//
//  Contents:   Domain trust support, forest trust name information.
//
//  History:    03-Dec-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include <stdio.h>
#include <lmerr.h>
#include <dnsapi.h>
#include "proppage.h"
#include "trust.h"
#include "trustwiz.h"

#ifdef DSADMIN

void FormatSID(PSID Sid, CStrW & str);

//+----------------------------------------------------------------------------
//
//  Class:     CFTInfo
//
//  Purpose:   Wrap an LSA_FOREST_TRUST_INFORMATION structure.
//
//-----------------------------------------------------------------------------

CFTInfo::CFTInfo(void) :
   _pFTInfo(NULL),
   _pExtraInfo(NULL)
{
   TRACER(CFTInfo,CFTInfo);
#ifdef _DEBUG
   // NOTICE-2002/02/14-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
   strcpy(szClass, "CFTInfo");
#endif
}

CFTInfo::CFTInfo(PLSA_FOREST_TRUST_INFORMATION pFTInfo) :
   _pFTInfo(NULL),
   _pExtraInfo(NULL)
{
   TRACER(CFTInfo,CFTInfo pointer copy ctor);
#ifdef _DEBUG
   // NOTICE-2002/02/14-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
   strcpy(szClass, "CFTInfo");
#endif

   bool fOK = SetFTInfo(pFTInfo);
   dspAssert(fOK);
}

CFTInfo::CFTInfo(CFTInfo & FTInfo) :
   _pFTInfo(NULL),
   _pExtraInfo(NULL)
{
   TRACER(CFTInfo,CFTInfo obj copy ctor);
#ifdef _DEBUG
   // NOTICE-2002/02/14-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
   strcpy(szClass, "CFTInfo");
#endif

   bool fOK = SetFTInfo(FTInfo.GetFTInfo());
   dspAssert(fOK);
}

CFTInfo::~CFTInfo(void)
{
   DeleteFTInfo();
}

const CFTInfo &
CFTInfo::operator= (const PLSA_FOREST_TRUST_INFORMATION pFTInfo)
{
   bool fOK = SetFTInfo(pFTInfo);
   dspAssert(fOK);
   return *this;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::SetFTInfo
//
//  Synopsis:  Copy the FTInfo data.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::SetFTInfo(PLSA_FOREST_TRUST_INFORMATION pFTInfo)
{
   TRACER(CFTInfo,SetFTInfo);
   dspAssert(pFTInfo);
   if (!pFTInfo)
   {
      return false;
   }

   DeleteFTInfo();

   _pFTInfo = new LSA_FOREST_TRUST_INFORMATION;

   CHECK_NULL(_pFTInfo, return false);

   // NOTICE-2002/02/14-ericb - SecurityPush: zeroing a struct.
   ZeroMemory(_pFTInfo, sizeof(LSA_FOREST_TRUST_INFORMATION));

   if (!pFTInfo->RecordCount)
   {
      DBG_OUT("RecordCount is zero.\n");
      return true;
   }
   dspDebugOut((DEB_ITRACE, "RecordCount is %d\n", pFTInfo->RecordCount));

   _pFTInfo->Entries = new PLSA_FOREST_TRUST_RECORD[pFTInfo->RecordCount];

   CHECK_NULL(_pFTInfo->Entries, return false);

   // NOTICE-2002/02/14-ericb - SecurityPush: zeroing an array of pointers.
   ZeroMemory(_pFTInfo->Entries, sizeof(PLSA_FOREST_TRUST_RECORD) * pFTInfo->RecordCount);

   PWSTR pwz = NULL;
   size_t cch = 0;

   for (ULONG i = 0; i < pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pRec = pFTInfo->Entries[i], pCopyRec;
      dspAssert(pRec);

      _pFTInfo->Entries[i] = pCopyRec = new LSA_FOREST_TRUST_RECORD;

      CHECK_NULL(pCopyRec, return false);

      // NOTICE-2002/02/14-ericb - SecurityPush: zeroing a struct.
      ZeroMemory(pCopyRec, sizeof(LSA_FOREST_TRUST_RECORD));

      _pFTInfo->RecordCount++;
      pCopyRec->ForestTrustType = pRec->ForestTrustType;
      pCopyRec->Flags = pRec->Flags;
      pCopyRec->Time = pRec->Time;

      switch (pRec->ForestTrustType)
      {
      case ForestTrustTopLevelName:
      case ForestTrustTopLevelNameEx:
         cch = pRec->ForestTrustData.TopLevelName.Length / sizeof(WCHAR);
         pwz = new WCHAR[cch + 1];
         CHECK_NULL(pwz, return false);
         // NOTICE-2002/02/14-ericb - SecurityPush: passing in one char less than the size of the
         // buffer for the copy length and then explicitly null terminating
         // afterwards.
         wcsncpy(pwz, pRec->ForestTrustData.TopLevelName.Buffer, cch);
         pwz[cch] = L'\0';
         RtlInitUnicodeString(&pCopyRec->ForestTrustData.TopLevelName, pwz);
         dspDebugOut((DEB_USER1, "%s: %ws, Flags 0x%x\n",
                      (ForestTrustTopLevelName == pCopyRec->ForestTrustType) ?
                      "ForestTrustTopLevelName" : "ForestTrustTopLevelNameEx",
                      pwz, pCopyRec->Flags));
         break;

      case ForestTrustDomainInfo:
         cch = pRec->ForestTrustData.DomainInfo.DnsName.Length / sizeof(WCHAR);
         pwz = new WCHAR[cch + 1];
         CHECK_NULL(pwz, return false);
         // NOTICE-2002/02/14-ericb - SecurityPush: see above.
         wcsncpy(pwz, pRec->ForestTrustData.DomainInfo.DnsName.Buffer, cch);
         pwz[cch] = L'\0';
         RtlInitUnicodeString(&pCopyRec->ForestTrustData.DomainInfo.DnsName, pwz);
         dspDebugOut((DEB_USER1, "ForestTrustDomainInfo: %ws, Flags 0x%x\n",
                     pwz, pCopyRec->Flags));

         cch = pRec->ForestTrustData.DomainInfo.NetbiosName.Length / sizeof(WCHAR);
         pwz = new WCHAR[cch + 1];
         CHECK_NULL(pwz, return false);
         // NOTICE-2002/02/14-ericb - SecurityPush: see above.
         wcsncpy(pwz, pRec->ForestTrustData.DomainInfo.NetbiosName.Buffer, cch);
         pwz[cch] = L'\0';
         RtlInitUnicodeString(&pCopyRec->ForestTrustData.DomainInfo.NetbiosName, pwz);

         if (!pRec->ForestTrustData.DomainInfo.Sid ||
             !IsValidSid(pRec->ForestTrustData.DomainInfo.Sid))
         {
            // NOTICE-2002/02/14-ericb - SecurityPush: check for a valid sid.
            dspAssert(false);
            return false;
         }
         pCopyRec->ForestTrustData.DomainInfo.Sid = new BYTE[GetLengthSid(pRec->ForestTrustData.DomainInfo.Sid)];
         CHECK_NULL(pCopyRec->ForestTrustData.DomainInfo.Sid, return false);
         // NOTICE-2002/02/14-ericb - SecurityPush: GetLengthSid returns the number of bytes of the SID.
         CopyMemory(pCopyRec->ForestTrustData.DomainInfo.Sid,
                    pRec->ForestTrustData.DomainInfo.Sid,
                    GetLengthSid(pRec->ForestTrustData.DomainInfo.Sid));
         break;

      default:
         if (!pRec->ForestTrustData.Data.Length ||
             !pRec->ForestTrustData.Data.Buffer ||
             IsBadReadPtr(pRec->ForestTrustData.Data.Buffer,
                          pRec->ForestTrustData.Data.Length))
         {
            // NOTICE-2002/02/14-ericb - SecurityPush: check for valid data.
            dspAssert(false);
            return false;
         }
         pCopyRec->ForestTrustData.Data.Buffer = new UCHAR[pRec->ForestTrustData.Data.Length];
         CHECK_NULL(pCopyRec->ForestTrustData.Data.Buffer, return false);
         // NOTICE-2002/02/14-ericb - SecurityPush: the Length value is the size of the binary data.
         CopyMemory(pCopyRec->ForestTrustData.Data.Buffer,
                    pRec->ForestTrustData.Data.Buffer,
                    pRec->ForestTrustData.Data.Length);
         dspDebugOut((DEB_USER1, "Unknown type: Flags 0x%x\n", pCopyRec->Flags));
         break;
      }
   }

   _pExtraInfo = new FT_EXTRA_INFO[pFTInfo->RecordCount];

   CHECK_NULL(_pExtraInfo, return false);

   SetDomainState();

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::CreateDefault
//
//-----------------------------------------------------------------------------
bool
CFTInfo::CreateDefault(PCWSTR pwzForestRoot, PCWSTR pwzNBName, PSID pSid)
{
   TRACER(CFTInfo,CreateDefault);
   dspAssert(pwzForestRoot && pwzNBName && pSid);
   if (!pwzForestRoot || !pwzNBName || !pSid)
   {
      return false;
   }

   LSA_FOREST_TRUST_INFORMATION FTInfoDefault = {0};

   FTInfoDefault.RecordCount = 2;

   LSA_FOREST_TRUST_RECORD Record1 = {0}, Record2 = {0};

   Record1.ForestTrustType = ForestTrustTopLevelName;
   RtlInitUnicodeString(&Record1.ForestTrustData.TopLevelName, pwzForestRoot);

   Record2.ForestTrustType = ForestTrustDomainInfo;
   RtlInitUnicodeString(&Record2.ForestTrustData.DomainInfo.DnsName,
                        pwzForestRoot);
   RtlInitUnicodeString(&Record2.ForestTrustData.DomainInfo.NetbiosName,
                        pwzNBName);
   Record2.ForestTrustData.DomainInfo.Sid = pSid;

   PLSA_FOREST_TRUST_RECORD pRecs[2] = {&Record1, &Record2};
   FTInfoDefault.Entries = pRecs;

   return SetFTInfo(&FTInfoDefault);
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::AddNewRecord
//
//-----------------------------------------------------------------------------
bool
CFTInfo::AddNewRecord ( PCWSTR pwzName, ULONG &NewIndex, LSA_FOREST_TRUST_RECORD_TYPE RecordType )
{
   PLSA_FOREST_TRUST_RECORD * rgpNewEntries;
   ULONG nEntries = _pFTInfo->RecordCount;

   rgpNewEntries = new PLSA_FOREST_TRUST_RECORD[nEntries + 1];

   CHECK_NULL(rgpNewEntries, return false);

   // NOTICE-2002/02/14-ericb - SecurityPush: zeroing an array of pointers.
   ZeroMemory(rgpNewEntries, sizeof(PLSA_FOREST_TRUST_RECORD) * (nEntries + 1));
   // NOTICE-2002/02/14-ericb - SecurityPush: copying an array of pointers.
   if ( nEntries )
   {
       CopyMemory(rgpNewEntries, _pFTInfo->Entries, nEntries * sizeof(PLSA_FOREST_TRUST_RECORD));
   }

   rgpNewEntries[nEntries] = new LSA_FOREST_TRUST_RECORD;

   CHECK_NULL(rgpNewEntries[nEntries], return false);

   // Note that the constructor for FT_EXTRA_INFO will initialize the fields.
   //
   FT_EXTRA_INFO * pNewExtraInfo = new FT_EXTRA_INFO[nEntries + 1];

   CHECK_NULL(pNewExtraInfo, return false);

   // Flags and Time both implicitly set to zero.
   // NOTICE-2002/02/14-ericb - SecurityPush: zero the new struct whose pointer is at the end of the
   // array of struct pointers.
   //
   ZeroMemory(rgpNewEntries[nEntries], sizeof(LSA_FOREST_TRUST_RECORD));

   _pFTInfo->RecordCount++;

   rgpNewEntries[nEntries]->ForestTrustType = RecordType;

   // NOTICE-2002/02/14-ericb - SecurityPush: pwzName verified above.
   PWSTR pwz = new WCHAR[wcslen(pwzName) + 1];
   CHECK_NULL(pwz, return false);
   wcscpy(pwz, pwzName);

   RtlInitUnicodeString(&rgpNewEntries[nEntries]->ForestTrustData.TopLevelName,
                        pwz);

   if ( _pFTInfo->Entries )
   {
        delete [] _pFTInfo->Entries;
   }

   _pFTInfo->Entries = rgpNewEntries;

   NewIndex = nEntries;

   // NOTICE-2002/02/14-ericb - SecurityPush: zeroing an array of structs.
   ZeroMemory(pNewExtraInfo, (nEntries + 1) * sizeof(FT_EXTRA_INFO));
   
   // NOTICE-2002/02/14-ericb - SecurityPush: copying the original array of structs into the new
   // array. The last element is left in its as-initialized state.

   // This step is skipped if there were no records in FTInfo hence no 
   // ExtraInfo entries
   if ( _pExtraInfo )
   {      
        CopyMemory(pNewExtraInfo, _pExtraInfo, nEntries * sizeof(FT_EXTRA_INFO));
        delete [] _pExtraInfo;
   }

   _pExtraInfo = pNewExtraInfo;

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::RemoveRecord
//
//-----------------------------------------------------------------------------
bool 
CFTInfo::RemoveRecord ( ULONG index, LSA_FOREST_TRUST_RECORD_TYPE RecordType )
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }
   PLSA_FOREST_TRUST_RECORD pRec = _pFTInfo->Entries[index];

   if (RecordType != pRec->ForestTrustType)
   {
      dspAssert(FALSE);
      return false;
   }

   delete [] pRec->ForestTrustData.TopLevelName.Buffer;

   delete pRec;

   for (ULONG i = index; i < _pFTInfo->RecordCount - 1; i++)
   {
      _pFTInfo->Entries[i] = _pFTInfo->Entries[i + 1];
   }

   _pFTInfo->RecordCount--;

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::AddNewExclusion
//
//-----------------------------------------------------------------------------
bool
CFTInfo::AddNewExclusion(PCWSTR pwzName, ULONG & NewIndex)
{
   // NOTICE-2002/02/14-ericb - SecurityPush: pwzName checked for length after verifying it non-null.
   if (!_pFTInfo || !pwzName || wcslen(pwzName) < 3) // to be subordinate to something requires at least 3 chars.
   {
      dspAssert(FALSE);
      return false;
   }
   dspDebugOut((DEB_ITRACE, "CFTInfo::AddNewExclusion for name %ws\n", pwzName));
   return AddNewRecord ( pwzName, NewIndex, ForestTrustTopLevelNameEx );
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::RemoveExclusion
//
//-----------------------------------------------------------------------------
bool
CFTInfo::RemoveExclusion(ULONG index )
{
    return RemoveRecord ( index, ForestTrustTopLevelNameEx );
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::DeleteFTInfo
//
//-----------------------------------------------------------------------------
void
CFTInfo::DeleteFTInfo(void)
{
   if (!_pFTInfo)
   {
      return;
   }

   PLSA_FOREST_TRUST_INFORMATION pFTInfo = _pFTInfo;

   _pFTInfo = NULL;

   for (ULONG i = 0; i < pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pRec = pFTInfo->Entries[i];

      if (!pRec)
      {
         return;
      }

      switch (pRec->ForestTrustType)
      {
      case ForestTrustTopLevelName:
      case ForestTrustTopLevelNameEx:
         if (pRec->ForestTrustData.DomainInfo.DnsName.Buffer)
         {
            delete [] pRec->ForestTrustData.DomainInfo.DnsName.Buffer;
         }
         break;

      case ForestTrustDomainInfo:
         if (pRec->ForestTrustData.DomainInfo.DnsName.Buffer)
         {
            delete [] pRec->ForestTrustData.DomainInfo.DnsName.Buffer;
         }
         if (pRec->ForestTrustData.DomainInfo.NetbiosName.Buffer)
         {
            delete [] pRec->ForestTrustData.DomainInfo.NetbiosName.Buffer;
         }
         if (pRec->ForestTrustData.DomainInfo.Sid)
         {
            delete [] pRec->ForestTrustData.DomainInfo.Sid;
         }
         break;

      default:
         if (pRec->ForestTrustData.Data.Buffer)
         {
            delete [] pRec->ForestTrustData.Data.Buffer;
         }
         break;
      }

      delete pRec;
   }

   delete [] pFTInfo->Entries;

   delete pFTInfo;

   if (_pExtraInfo)
   {
      delete [] _pExtraInfo;
      _pExtraInfo = NULL;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsForestRootTLN
//
//  Synopsis:  See if the indicated record is the forest root TLN.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsForestRootTLN(ULONG index, PCWSTR pwzForestRoot) const
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount || !pwzForestRoot)
   {
      dspAssert(FALSE);
      return false;
   }

   if (ForestTrustTopLevelName != _pFTInfo->Entries[index]->ForestTrustType)
   {
      return false;
   }

   CStrW strTLNName;

   if (!GetDnsName(index, strTLNName))
   {
      dspAssert(FALSE);
      return false;
   }

   DNS_NAME_COMPARE_STATUS compare;
   
   compare = DnsNameCompareEx_W(strTLNName, pwzForestRoot, 0);

   if (compare == DnsNameCompareLeftParent || compare == DnsNameCompareEqual)
   {
      return true;
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetTLNCount
//
//  Synopsis:  Return the count of TLNs.
//
//-----------------------------------------------------------------------------
ULONG
CFTInfo::GetTLNCount(void) const
{
   ULONG cTLN = 0;

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      if (ForestTrustTopLevelName == _pFTInfo->Entries[i]->ForestTrustType)
      {
         cTLN++;
      }
   }
   return cTLN;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetIndex
//
//  Synopsis:  Return the index that matches the passed in name.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::GetIndex(PCWSTR pwzName, ULONG & index) const
{
   if (!_pFTInfo || !pwzName)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strName;

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[i];

      dspAssert(pFTRec);

      switch (pFTRec->ForestTrustType)
      {
      case ForestTrustTopLevelName:
      case ForestTrustTopLevelNameEx:
         strName = pFTRec->ForestTrustData.TopLevelName;
         break;

      case ForestTrustDomainInfo:
         strName = pFTRec->ForestTrustData.DomainInfo.DnsName;
         break;

      default:
         dspAssert(FALSE);
         break;
      }

      if (!strName.IsEmpty())
      {
         // NOTICE-2002/02/14-ericb - SecurityPush: both params are checked for null before the call.
         if (wcscmp(strName, pwzName) == 0)
         {
            index = i;
            return true;
         }
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::FindSID
//
//  Synopsis:  Return the index if the passed in string SID is found.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::FindSID(PCWSTR pwzSID, ULONG & index) const
{
   if (!_pFTInfo || !pwzSID)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strSID;

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pRec = _pFTInfo->Entries[i];

      dspAssert(pRec);

      if (ForestTrustDomainInfo == pRec->ForestTrustType)
      {
         FormatSID(pRec->ForestTrustData.DomainInfo.Sid, strSID);

         if (!strSID.IsEmpty())
         {
            if (strSID.CompareNoCase(pwzSID) == 0)
            {
               index = i;
               return true;
            }
         }
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsDomainMatch
//
//  Synopsis:  Is there a domain whose name matches the passed-in TLNEx?
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsDomainMatch(ULONG index) const
{
   if (!_pFTInfo)
   {
      dspAssert(FALSE);
      return false;
   }

   LSA_FOREST_TRUST_RECORD_TYPE type;

   if (!GetType(index, type))
   {
      dspAssert(FALSE);
      return false;
   }

   if (ForestTrustTopLevelNameEx != type)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strTlnEx, strDomain;

   if (!GetDnsName(index, strTlnEx))
   {
      dspAssert(FALSE);
      return false;
   }

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pRec = _pFTInfo->Entries[i];

      dspAssert(pRec);

      if (ForestTrustDomainInfo == pRec->ForestTrustType)
      {
         strDomain = pRec->ForestTrustData.DomainInfo.DnsName;

         if (strDomain.CompareNoCase(strTlnEx) == 0)
         {
            return true;
         }
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetDnsName
//
//  Synopsis:  Return the name for the passed in index.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::GetDnsName(ULONG index, CStrW & strName) const
{
   strName.Empty();

   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   dspAssert(pFTRec);

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustTopLevelName:
   case ForestTrustTopLevelNameEx:
      strName = pFTRec->ForestTrustData.TopLevelName;
      return true;

   case ForestTrustDomainInfo:
      strName = pFTRec->ForestTrustData.DomainInfo.DnsName;
      return true;

   default:
      dspAssert(FALSE);
      break;
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetNbName
//
//  Synopsis:  Return the NetBIOS name for the passed in index.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::GetNbName(ULONG index, CStrW & strName) const
{
   strName.Empty();

   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   dspAssert(pFTRec);

   if (ForestTrustDomainInfo == pFTRec->ForestTrustType)
   {
      strName = pFTRec->ForestTrustData.DomainInfo.NetbiosName;
      return true;
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetType
//
//-----------------------------------------------------------------------------
bool
CFTInfo::GetType(ULONG index, LSA_FOREST_TRUST_RECORD_TYPE & type) const
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   type = _pFTInfo->Entries[index]->ForestTrustType;

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetFlags
//
//-----------------------------------------------------------------------------
ULONG
CFTInfo::GetFlags(ULONG index) const
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return 0;
   }

   return _pFTInfo->Entries[index]->Flags;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::SetDomainState
//
//  Synopsis:  Set the extra-info flags to indicate status based on relation-
//             ships between TLN exclusion records and domain records..
//
//-----------------------------------------------------------------------------
void
CFTInfo::SetDomainState(void)
{
   if (!_pFTInfo || !_pExtraInfo)
   {
      return;
   }

   LSA_FOREST_TRUST_RECORD_TYPE type;

   for (ULONG iTLNEx = 0; iTLNEx < _pFTInfo->RecordCount; iTLNEx++)
   {
      // Scan FTInfos for TLNEx records.
      //
      if (IsTlnExclusion(iTLNEx))
      {
         CStrW strTLNEx;

         if (!GetDnsName(iTLNEx, strTLNEx))
         {
            dspAssert(FALSE);
            continue;
         }
         // Search for a matching domain record.
         //
         for (ULONG jDomain = 0; jDomain < _pFTInfo->RecordCount; jDomain++)
         {
            if (!GetType(jDomain, type))
            {
               dspAssert(FALSE);
               continue;
            }
            if (ForestTrustDomainInfo != type)
            {
               continue;
            }
            CStrW strDNS;

            if (!GetDnsName(jDomain, strDNS))
            {
               dspAssert(FALSE);
               continue;
            }

            if (strTLNEx == strDNS)
            {
               // If there is a matching domain record, mark it as
               // disabled-via-matching-TLNEx in the extra info.
               //
               _pExtraInfo[jDomain]._Status = FT_EXTRA_INFO::STATUS::DisabledViaMatchingTLNEx;

               // Set the status on the TLNEx as well.
               //
               _pExtraInfo[iTLNEx]._Status = FT_EXTRA_INFO::STATUS::TLNExMatchesExistingDomain;

               // Search for children of the domain and mark each as
               // disabled-via-parent-matching-TLNEx in the extra info.
               //
               for (ULONG kChild = 0; kChild < _pFTInfo->RecordCount; kChild++)
               {
                  if (kChild == jDomain || kChild == iTLNEx)
                  {
                     continue;
                  }
                  if (IsChildDomain(jDomain, kChild))
                  {
                     _pExtraInfo[kChild]._Status = FT_EXTRA_INFO::STATUS::DisabledViaParentMatchingTLNEx;
                  }
               }
               // Only one domain record can match the exclusion.
               //
               break;
            }
         }
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsInConflict
//
//  Synopsis:  Are any of the FTInfo records in confict.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsInConflict(void) const
{
   if (!_pFTInfo)
   {
      return false;
   }

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      if (IsConflictFlagSet(i))
      {
         return true;
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsConflictFlagSet
//
//  Synopsis:  Is the FTInfo record in confict.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsConflictFlagSet(ULONG index) const
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   dspAssert(pFTRec);

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustTopLevelName:
      if (LSA_TLN_DISABLED_CONFLICT & pFTRec->Flags)
      {
         return true;
      }
      break;

   case ForestTrustDomainInfo:
      if (LSA_SID_DISABLED_CONFLICT & pFTRec->Flags ||
          LSA_NB_DISABLED_CONFLICT & pFTRec->Flags)
      {
         return true;
      }
      break;

   default:
      break;
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::SetAdminDisable
//
//  Synopsis:  Admin-disables the name. Returns false if not a name record.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::SetAdminDisable(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustTopLevelName:
      pFTRec->Flags = LSA_TLN_DISABLED_ADMIN;
      break;

   case ForestTrustDomainInfo:
      pFTRec->Flags = LSA_NB_DISABLED_ADMIN;
      break;

   default:
      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::SetConflictDisable
//
//  Synopsis:  Sets the conflict-disabled flag. Returns false if not a name record.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::SetConflictDisable(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustTopLevelName:
      pFTRec->Flags = LSA_TLN_DISABLED_CONFLICT;
      break;

   case ForestTrustDomainInfo:
      pFTRec->Flags = LSA_NB_DISABLED_CONFLICT;
      break;

   default:
      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::SetSidAdminDisable
//
//  Synopsis:  Admin-disables the SID, returns false if not a domain record.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::SetSidAdminDisable(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   dspAssert(pFTRec);

   if (!pFTRec || ForestTrustDomainInfo != pFTRec->ForestTrustType)
   {
      dspAssert(FALSE);
      return false;
   }

   pFTRec->Flags = LSA_SID_DISABLED_ADMIN;

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsEnabled
//
//  Synopsis:  
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsEnabled(ULONG index) const
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount || !_pExtraInfo)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustDomainInfo:
      if (FT_EXTRA_INFO::STATUS::Enabled == _pExtraInfo[index]._Status)
      {
         return true;
      }
      break;

   case ForestTrustTopLevelName:
      if (!(pFTRec->Flags & (LSA_TLN_DISABLED_NEW | LSA_TLN_DISABLED_ADMIN | LSA_TLN_DISABLED_CONFLICT)))
      {
         return true;
      }
      break;

   default:
      break;
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::DisableDomain
//
//  Synopsis:  Disable a domain subtree rooted at the domain named by index.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::DisableDomain(ULONG index)
{
   TRACER(CFTInfo,DisableDomain);
   if (!_pFTInfo || index >= _pFTInfo->RecordCount || !_pExtraInfo)
   {
      dspAssert(FALSE);
      return false;
   }

   if (ForestTrustDomainInfo != _pFTInfo->Entries[index]->ForestTrustType)
   {
      dspAssert(false);
      return false;
   }

   CStrW strDomainName;

   if (!GetDnsName(index, strDomainName))
   {
      dspAssert(false);
      return false;
   }

   // Add an exclusion record for the domain's DNS name.
   //
   ULONG iNewTLNEx;

   if (!AddNewExclusion(strDomainName, iNewTLNEx))
   {
      dspAssert(false);
      return false;
   }

   _pExtraInfo[iNewTLNEx]._Status = FT_EXTRA_INFO::STATUS::TLNExMatchesExistingDomain;

   // Mark the domain and all of its children as disabled.
   //
   _pExtraInfo[index]._Status = FT_EXTRA_INFO::STATUS::DisabledViaMatchingTLNEx;

   for (ULONG j = 0; j < _pFTInfo->RecordCount; j++)
   {
      if (j == index || j == iNewTLNEx)
      {
         continue;
      }

      if (IsChildDomain(index, j))
      {
         _pExtraInfo[j]._Status = FT_EXTRA_INFO::STATUS::DisabledViaParentMatchingTLNEx;
      }
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::EnableDomain
//
//  Synopsis:  Enable a domain subtree rooted at the domain named by index.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::EnableDomain(ULONG index)
{
   TRACER(CFTInfo,EnableDomain);
   if (!_pFTInfo || index >= _pFTInfo->RecordCount || !_pExtraInfo)
   {
      dspAssert(FALSE);
      return false;
   }

   if (ForestTrustDomainInfo != _pFTInfo->Entries[index]->ForestTrustType)
   {
      dspAssert(false);
      return false;
   }

   // Remove the exclusion record.
   //
   ULONG iExclusion;

   if (!FindMatchingExclusion(index, iExclusion))
   {
      dspAssert(false);
      return false;
   }

   if (!RemoveExclusion(iExclusion))
   {
      dspAssert(false);
      return false;
   }

   // Mark the domain and all of its children as enabled.
   //
   _pExtraInfo[index]._Status = FT_EXTRA_INFO::STATUS::Enabled;

   for (ULONG j = 0; j < _pFTInfo->RecordCount; j++)
   {
      if (j == index || j == iExclusion)
      {
         continue;
      }

      if (IsChildDomain(index, j))
      {
         _pExtraInfo[j]._Status = FT_EXTRA_INFO::STATUS::Enabled;
      }
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::SetUsedToBeInConflict
//
//-----------------------------------------------------------------------------
void
CFTInfo::SetUsedToBeInConflict(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount || !_pExtraInfo)
   {
      dspAssert(FALSE);
      return;
   }

   _pExtraInfo[index]._fWasInConflict = true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::WasInConflict
//
//-----------------------------------------------------------------------------
bool
CFTInfo::WasInConflict(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount || !_pExtraInfo)
   {
      dspAssert(FALSE);
      return false;
   }

   return _pExtraInfo[index]._fWasInConflict;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::ClearAnyConflict
//
//-----------------------------------------------------------------------------
void
CFTInfo::ClearAnyConflict(void)
{
   if (!_pFTInfo)
   {
      dspAssert(FALSE);
      return;
   }

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      ClearConflict(i);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::ClearConflict
//
//-----------------------------------------------------------------------------
void
CFTInfo::ClearConflict(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   dspAssert(pFTRec);

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustTopLevelName:
      if (LSA_TLN_DISABLED_CONFLICT & pFTRec->Flags)
      {
         pFTRec->Flags &= ~(LSA_TLN_DISABLED_CONFLICT);
      }
      break;

   case ForestTrustDomainInfo:
      if (LSA_SID_DISABLED_CONFLICT & pFTRec->Flags)
      {
         pFTRec->Flags &= ~(LSA_SID_DISABLED_CONFLICT);
      }
      if (LSA_NB_DISABLED_CONFLICT & pFTRec->Flags)
      {
         pFTRec->Flags &= ~(LSA_NB_DISABLED_CONFLICT);
      }
      break;

   default:
      break;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::ClearDisableFlags
//
//-----------------------------------------------------------------------------
void
CFTInfo::ClearDisableFlags(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   pFTRec->Flags = 0;

   if (_pExtraInfo)
   {
      _pExtraInfo[index]._fWasInConflict = false;
   }

   return;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::AnyChildDisabled
//
//  Synopsis:  Are any matching or child domain names disabled.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::AnyChildDisabled(ULONG index)
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount ||
       _pFTInfo->Entries[index]->ForestTrustType != ForestTrustTopLevelName)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strTLN, strDNS;

   GetDnsName(index, strTLN);

   dspAssert(!strTLN.IsEmpty());

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pRec = _pFTInfo->Entries[i];
      dspAssert(pRec);

      strDNS.Empty();

      // See if any subordinate names are disabled.
      //
      if (pRec->ForestTrustType == ForestTrustTopLevelName)
      {
         // No need to check the passed in or other TLNs.
         //
         continue;
      }

      bool fIsException = false;

      switch (pRec->ForestTrustType)
      {
         case ForestTrustDomainInfo:
            strDNS = pRec->ForestTrustData.DomainInfo.DnsName;
            break;

         case ForestTrustTopLevelNameEx:
            strDNS = pRec->ForestTrustData.TopLevelName;
            fIsException = true;
            break;

         default:
            continue;
      }

      if (!strDNS.IsEmpty())
      {
         DNS_NAME_COMPARE_STATUS compare;

         compare = DnsNameCompareEx_W(strDNS, strTLN, 0);

         if ((DnsNameCompareRightParent == compare ||
              DnsNameCompareEqual == compare) &&
             (fIsException || pRec->Flags))
         {
            return true;
         }
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsTlnExclusion
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsTlnExclusion(ULONG index) const
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   return _pFTInfo->Entries[index]->ForestTrustType == ForestTrustTopLevelNameEx;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::FindMatchingExclusion
//
//  Synopsis:  Search for an exclusion record that matches the indicated
//             record. If CheckParents is true, will look for parent matches.
//             CheckParents defaults to false.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::FindMatchingExclusion(ULONG index, ULONG & iExclusion,
                               bool CheckParents) const
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   LSA_FOREST_TRUST_RECORD_TYPE type;

   if (!GetType(index, type) || ForestTrustDomainInfo != type)
   {
      dspAssert(false);
      return false;
   }

   CStrW strDomain, strExclusion;

   if (!GetDnsName(index, strDomain))
   {
      dspAssert(false);
      return false;
   }

   for (ULONG j = 0; j < _pFTInfo->RecordCount; j++)
   {
      if (!GetType(j, type))
      {
         dspAssert(false);
         return false;
      }

      if (ForestTrustTopLevelNameEx != type)
      {
         continue;
      }

      if (!GetDnsName(j, strExclusion))
      {
         dspAssert(false);
         return false;
      }

      if (strDomain == strExclusion)
      {
         iExclusion = j;
         return true;
      }

      if (CheckParents && (DnsNameCompareEx_W(strDomain, strExclusion, 0) == DnsNameCompareRightParent))
      {
         iExclusion = j;
         return true;
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsMatchingDomain
//
//  Synopsis:  Is the name of 'index' the domain with the same name as the
//             top level name iTLN.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsMatchingDomain(ULONG iTLN, ULONG index) const
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   if (iTLN == index)
   {
      return false;
   }

   if (ForestTrustTopLevelName != _pFTInfo->Entries[iTLN]->ForestTrustType ||
       ForestTrustDomainInfo != _pFTInfo->Entries[index]->ForestTrustType)
   {
      return false;
   }

   CStrW strTLN, strDomain;

   if (!GetDnsName(iTLN, strTLN))
   {
      dspAssert(FALSE);
      return false;
   }

   if (!GetDnsName(index, strDomain))
   {
      dspAssert(FALSE);
      return false;
   }

   if (strTLN == strDomain)
   {
      return true;
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsChildDomain
//
//  Synopsis:  Is the name of 'index' a child of the iParent DNS names.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsChildDomain(ULONG iParent, ULONG index) const
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strName;

   if (!GetDnsName(index, strName))
   {
      return false;
   }

   return IsChildName(iParent, strName);
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsChildName
//
//  Synopsis:  Is the name pwzName a child of the iParent DNS names.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsChildName(ULONG iParent, PCWSTR pwzName) const
{
   if (!_pFTInfo || iParent >= _pFTInfo->RecordCount || !pwzName)
   {
      dspAssert(FALSE);
      return false;
   }

   // NOTICE-2002/02/14-ericb - SecurityPush: pwzName verified non-null above
   if (wcslen(pwzName) < 3)
   {
      return false;
   }

   CStrW strParent;

   if (!GetDnsName(iParent, strParent))
   {
      return false;
   }

   return DnsNameCompareEx_W(strParent, pwzName, 0) == DnsNameCompareLeftParent;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsNameTLNExChild
//
//  Synopsis:  Is the name a child of a TLN exclusion.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsNameTLNExChild(PCWSTR pwzName) const
{
   // NOTICE-2002/02/14-ericb - SecurityPush: pwzName checked for length after verifying it non-null.
   if (!_pFTInfo || !pwzName || wcslen(pwzName) < 3)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strTLNEx;

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      if (ForestTrustTopLevelNameEx == _pFTInfo->Entries[i]->ForestTrustType)
      {
         if (!GetDnsName(i, strTLNEx))
         {
            dspAssert(FALSE);
            return false;
         }
         if (DnsNameCompareEx_W(strTLNEx, pwzName, 0) == DnsNameCompareLeftParent)
         {
            return true;
         }
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::IsParentDisabled
//
//-----------------------------------------------------------------------------
bool
CFTInfo::IsParentDisabled(ULONG index) const
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   CStrW strTLN, strDNS;

   GetDnsName(index, strDNS);

   dspAssert(!strDNS.IsEmpty());

   for (ULONG i = 0; i < _pFTInfo->RecordCount; i++)
   {
      PLSA_FOREST_TRUST_RECORD pRec = _pFTInfo->Entries[i];
      dspAssert(pRec);

      if (pRec->ForestTrustType != ForestTrustTopLevelName)
      {
         // Check only TLNs.
         //
         continue;
      }

      strTLN = pRec->ForestTrustData.TopLevelName;

      if (DnsNameCompareEx_W(strDNS, strTLN, 0) == DnsNameCompareRightParent &&
          pRec->Flags)
      {
         return true;
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetExtraStatus
//
//  Synopsis:  Return the extra-info status of the item.
//
//-----------------------------------------------------------------------------
FT_EXTRA_INFO::STATUS
CFTInfo::GetExtraStatus(ULONG index) const
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount || !_pExtraInfo)
   {
      dspAssert(FALSE);
      return FT_EXTRA_INFO::STATUS::Invalid;
   }

   return _pExtraInfo[index]._Status;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::GetTlnEditStatus
//
//  Synopsis:  Return the routing status of the item.
//
//-----------------------------------------------------------------------------
bool
CFTInfo::GetTlnEditStatus(ULONG index, TLN_EDIT_STATUS & status) const
{
   if (!_pFTInfo || index >= _pFTInfo->RecordCount)
   {
      dspAssert(FALSE);
      return false;
   }

   PLSA_FOREST_TRUST_RECORD pFTRec = _pFTInfo->Entries[index];

   dspAssert(pFTRec);

   status = Enabled;

   switch (pFTRec->ForestTrustType)
   {
   case ForestTrustTopLevelName:
      if (pFTRec->Flags)
      {
         status = Disabled;
      }
      break;

   case ForestTrustDomainInfo:
      //
      // Find the parent. If the parent is disabled, then so is this DNS name.
      //
      if (IsParentDisabled(index))
      {
         status = Disabled;
      }
      else
      {
         switch (pFTRec->Flags)
         {
         case LSA_SID_DISABLED_ADMIN:
         case LSA_SID_DISABLED_CONFLICT:
            //
            // The SID is disabled but the NB name is enabled. The DNS
            // name is disabled by virtue of the SID being disabled. NB
            // names will still route though.
            //
            status = Disabled_Exceptions;
            break;

         case LSA_NB_DISABLED_ADMIN:
         case LSA_NB_DISABLED_CONFLICT:
            //
            // SID enabled means DNS name enabled. Only NB names disabled.
            //
            status = Enabled_Exceptions;
            break;

         case LSA_SID_DISABLED_ADMIN | LSA_NB_DISABLED_ADMIN:
         case LSA_SID_DISABLED_CONFLICT | LSA_NB_DISABLED_ADMIN:
         case LSA_SID_DISABLED_ADMIN | LSA_NB_DISABLED_CONFLICT:
         case LSA_SID_DISABLED_CONFLICT | LSA_NB_DISABLED_CONFLICT:
            //
            // If both NB and SID disabled, then no routing.
            //
            status = Disabled;
            break;

         default:
            // already enabled above.
            break;
         }
      }
      break;

   default:
      break;
   }
   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::AddNewTLN
//
//  Synopsis:  Adds a new TLN Record to this FTInfo and returns TRUE on success
//
//-----------------------------------------------------------------------------
bool
CFTInfo::AddNewTLN ( PCWSTR pwzName, ULONG &NewIndex )
{
   if (!_pFTInfo || !pwzName )
   {
      dspAssert(FALSE);
      return false;
   }

   dspDebugOut((DEB_ITRACE, "CFTInfo::AddNewTLN for name %ws\n", pwzName));

   return AddNewRecord ( pwzName, NewIndex, ForestTrustTopLevelName );
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTInfo::RemoveTLN
//
//  Synopsis:  Removes the TLN record at the specified index
//
//-----------------------------------------------------------------------------
bool
CFTInfo::RemoveTLN ( ULONG index )
{
    return RemoveRecord ( index, ForestTrustTopLevelName );
}

//+----------------------------------------------------------------------------
//
//  Class:     CFTCollisionInfo
//
//  Purpose:   Encapsulate the forest trust naming information.
//
//-----------------------------------------------------------------------------

CFTCollisionInfo::CFTCollisionInfo(void) :
   _pFTCollisionInfo(NULL)
{
   TRACER(CFTCollisionInfo,CFTCollisionInfo);
#ifdef _DEBUG
   strcpy(szClass, "CFTCollisionInfo");
#endif
}

CFTCollisionInfo::CFTCollisionInfo(PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo) :
   _pFTCollisionInfo(NULL)
{
   TRACER(CFTCollisionInfo,CFTCollisionInfo);
#ifdef _DEBUG
   strcpy(szClass, "CFTCollisionInfo");
#endif

   SetCollisionInfo(pColInfo);
}

CFTCollisionInfo::~CFTCollisionInfo(void)
{
   if (_pFTCollisionInfo)
   {
      // The collision info is allocated by LsaSetForestTrustInformation
      //
      LsaFreeMemory(_pFTCollisionInfo);
   }
}

const CFTCollisionInfo &
CFTCollisionInfo::operator = (const PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo)
{
   SetCollisionInfo(pColInfo);
   return *this;
}

void
CFTCollisionInfo::SetCollisionInfo(PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo)
{
   TRACER(CFTCollisionInfo,SetCollisionInfo);
   if (_pFTCollisionInfo)
   {
      // The collision info is allocated by LsaSetForestTrustInformation
      //
      LsaFreeMemory(_pFTCollisionInfo);
   }
   _pFTCollisionInfo = pColInfo;
#if DBG
   if (_pFTCollisionInfo)
   {
      dspDebugOut((DEB_ITRACE, "pCollisionInfo->RecordCount = %d\n",
                   _pFTCollisionInfo->RecordCount));
   }
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTCollisionInfo::IsInCollisionInfo
//
//  Synopsis:  Is the FTRecord index found on a collision record?
//
//-----------------------------------------------------------------------------
bool
CFTCollisionInfo::IsInCollisionInfo(ULONG index) const
{
   if (!_pFTCollisionInfo)
   {
      return false;
   }

   for (ULONG i = 0; i < _pFTCollisionInfo->RecordCount; i++)
   {
      if (_pFTCollisionInfo->Entries[i]->Index == index)
      {
         return true;
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CFTCollisionInfo::GetCollisionName
//
//  Synopsis:  Return the name of the source of the collision.
//
//-----------------------------------------------------------------------------
bool
CFTCollisionInfo::GetCollisionName(ULONG index, CStrW & strName) const
{
   strName.Empty();

   if (!_pFTCollisionInfo)
   {
      return false;
   }

   for (ULONG i = 0; i < _pFTCollisionInfo->RecordCount; i++)
   {
      if (_pFTCollisionInfo->Entries[i]->Index == index)
      {
         strName = _pFTCollisionInfo->Entries[i]->Name;
         return true;
      }
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Function:  ComposeLineTabSep
//
//  Synopsis:  Format a line of tab-separated-values.
//
//  D&Ts Write-to-File functionality uses tabs as delimiters because
//  Excel treats unicode CSV files as unknown format but it will
//  nevertheless properly parse fields separated by tabs (but not commas).
//
//  ulLineNum is ignored.
//
//-----------------------------------------------------------------------------
void
ComposeLineTabSep(CStrW & strOut, ULONG ulLineNum, PCWSTR pwzCol1,
                  PCWSTR pwzCol2, PCWSTR pwzCol3, PCWSTR pwzCol4)
{
   dspAssert(pwzCol1 && pwzCol2);

   strOut += pwzCol1;
   strOut += L"\t";
   strOut += pwzCol2;
   if (pwzCol3 && *pwzCol3)
   {
      strOut += L"\t";
      strOut += pwzCol3;
   }
   if (pwzCol4 && *pwzCol4)
   {
      strOut += L"\t";
      strOut += pwzCol4;
   }
   strOut += g_wzCRLF;
}

//+----------------------------------------------------------------------------
//
//  Function:  ComposeNumberedLine
//
//  Synopsis:  Format a line of comma-separated-values.
//
//  Used by netdom to list names to stdout.
//
//-----------------------------------------------------------------------------
void
ComposeNumberedLine(CStrW & strOut, ULONG ulLineNum, PCWSTR pwzCol1,
                    PCWSTR pwzCol2, PCWSTR pwzCol3, PCWSTR pwzCol4)
{
   dspAssert(pwzCol1 && pwzCol2);

   if (ulLineNum > 0)
   {
      CStrW strNumber;
      strNumber.Format(L"%d. ", ulLineNum);
      strOut += strNumber;
   }
   else
   {
      strOut += L"   ";
   }

   strOut += pwzCol1;
   strOut += L", ";
   strOut += pwzCol2;
   if (pwzCol3 && *pwzCol3)
   {
      strOut += L", ";
      strOut += pwzCol3;
   }
   if (pwzCol4 && *pwzCol4)
   {
      strOut += L", ";
      strOut += pwzCol4;
   }
   strOut += g_wzCRLF;
}

//+----------------------------------------------------------------------------
//
//  Function:  SaveFTInfoAs
//
//  Synopsis:  Prompt the user for a file name and then save the FTInfo as a
//             CSV text file.
//
//-----------------------------------------------------------------------------
void
SaveFTInfoAs(HWND hWnd, PCWSTR pwzFlatName, PCWSTR pwzDnsName,
             CFTInfo & FTInfo, CFTCollisionInfo & ColInfo)
{
   TRACE_FUNCTION(SaveFTInfoAs);
   if (!pwzFlatName || !pwzDnsName)
   {
      dspAssert(FALSE);
      return;
   }

   OPENFILENAME ofn = {0};
   WCHAR wzFilter[MAX_PATH + 1] = {0}, wzFileName[MAX_PATH + MAX_PATH + 1];
   CStrW strFilter, strExt, strMsg = g_wzBOM; // start with ByteOrderMark

   (void)StringCchCopy(wzFileName, MAX_PATH + MAX_PATH, pwzFlatName);
   // NOTICE-2002/02/14-ericb - SecurityPush: CStrW::LoadString sets the string
   // to an empty string on failure.
   strExt.LoadString(g_hInstance, IDS_FTFILE_SUFFIX);
   (void)StringCchCat(wzFileName, MAX_PATH + MAX_PATH - wcslen(wzFileName), strExt);
   (void)StringCchCat(wzFileName, MAX_PATH + MAX_PATH - wcslen(wzFileName), L".");
   strExt.LoadString(g_hInstance, IDS_FTFILE_CSV_EXT);
   (void)StringCchCat(wzFileName, MAX_PATH + MAX_PATH - wcslen(wzFileName), strExt);

   // NOTICE-2002/02/14-ericb - SecurityPush: wzFilter is initialized to all
   // zeros and is one char longer than the length passed to LoadString.
   LoadString(g_hInstance, IDS_FTFILE_FILTER, wzFilter, MAX_PATH);

   ofn.lStructSize = sizeof(ofn);
   ofn.hwndOwner = hWnd;
   ofn.lpstrFile = wzFileName;
   ofn.nMaxFile = MAX_PATH + MAX_PATH + 1;
   ofn.Flags = OFN_OVERWRITEPROMPT;
   ofn.lpstrDefExt = strExt;
   ofn.lpstrFilter = wzFilter;

   if (GetSaveFileName(&ofn))
   {
      dspDebugOut((DEB_ITRACE, "Saving FTInfo to %ws\n", ofn.lpstrFile));
      PWSTR pwzErr;
      BOOL fSucceeded = TRUE;

      HANDLE hFile = CreateFile(ofn.lpstrFile, GENERIC_WRITE, 0,
                                NULL, CREATE_ALWAYS,
                                FILE_ATTRIBUTE_NORMAL, NULL);

      if (INVALID_HANDLE_VALUE != hFile)
      {
         CStrW strPrefix;
         strPrefix.LoadString(g_hInstance, IDS_LOG_PREFIX);

         ComposeLineTabSep(strMsg, 0, strPrefix, pwzDnsName, NULL, NULL);

         strMsg += g_wzCRLF;

         FormatFTNames(FTInfo, ColInfo, ComposeLineTabSep, strMsg);

         strMsg += g_wzCRLF;

         DWORD dwWritten;

         fSucceeded = WriteFile(hFile, strMsg.GetBuffer(0),
                                strMsg.GetLength() * sizeof(WCHAR),
                                &dwWritten, NULL);
         CloseHandle(hFile);
      }
      else
      {
         fSucceeded = FALSE;
      }


      if (!fSucceeded)
      {
         CStrW strTitle;
         strTitle.LoadString(g_hInstance, IDS_DNT_MSG_TITLE);
         LoadErrorMessage(GetLastError(), 0, &pwzErr);
         if (pwzErr)
         {
            // NOTICE-2002/02/14-ericb - SecurityPush: CStrW::FormatMessage sets the string to an empty
            // string on failure.
            strMsg.FormatMessage(g_hInstance, IDS_LOGFILE_CREATE_FAILED, pwzErr);
            delete [] pwzErr;
         }
         MessageBox(hWnd, strMsg, strTitle, MB_ICONERROR);
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Function:  FormatFTNames
//
//-----------------------------------------------------------------------------
void
FormatFTNames(CFTInfo & FTInfo, CFTCollisionInfo & ColInfo,
              LINE_COMPOSER pLineFcn, CStrW & strMsg)
{
   TRACE_FUNCTION(FormatFTNames);
   PLSA_FOREST_TRUST_RECORD pRec = NULL;
   CStrW strName, strType, strStatus, strNotes, strDnsName,
         strAdminDisabled, strNewDisabled, strEnabled, strTlnExMatch,
         strExclusion, strTypeSuffix, strTypeDnsDomain, strTypeNBDomain,
         strConflict, strTypeSID, strWith, strFor, strUnknown;

   strName.LoadString(g_hInstance, IDS_COL_TITLE_OBJNAME);
   strType.LoadString(g_hInstance, IDS_LOG_TYPE);
   strStatus.LoadString(g_hInstance, IDS_LOG_STATUS);
   strNotes.LoadString(g_hInstance, IDS_LOG_NOTES);

   (*pLineFcn)(strMsg, 0, strName, strType, strStatus, strNotes);

   if (!FTInfo.GetCount())
   {
      return;
   }

   strTypeSuffix.LoadString(g_hInstance, IDS_LOG_NAME_SUFFIX);
   strTypeDnsDomain.LoadString(g_hInstance, IDS_LOG_DOM_DNS_NAME);
   strTypeNBDomain.LoadString(g_hInstance, IDS_LOG_DOM_FLAT_NAME);
   strTypeSID.LoadString(g_hInstance, IDS_LOG_SID);
   strEnabled.LoadString(g_hInstance, IDS_LOG_ENABLED);
   strAdminDisabled.LoadString(g_hInstance, IDS_LOG_ADMIN_DISABLED);
   strNewDisabled.LoadString(g_hInstance, IDS_LOG_NEW_DISABLED);
   strExclusion.LoadString(g_hInstance, IDS_LOG_EXCLUSION);
   strTlnExMatch.LoadString(g_hInstance, IDS_LOG_MATCHING_EXCLUSION);
   strConflict.LoadString(g_hInstance, IDS_LOG_CONFLICT);
   strWith.LoadString(g_hInstance, IDS_LOG_WITH);
   strFor.LoadString(g_hInstance, IDS_LOG_FOR);
   strUnknown.LoadString(g_hInstance, IDS_LOG_UNKNOWN);

   CStrW strCollisionName;
   ULONG j = 1;

   for (UINT i = 0; i < FTInfo.GetCount(); i++)
   {
      bool fCollision = false;
      bool fExcluded = false;

      pRec = FTInfo.GetFTInfo()->Entries[i];

      dspAssert(pRec);

      if (ColInfo.IsInCollisionInfo(i))
      {
         fCollision = true;
         ColInfo.GetCollisionName(i, strCollisionName);
      }

      strNotes.Empty();
      strStatus.Empty();

      switch (pRec->ForestTrustType)
      {
      case ForestTrustTopLevelName:
         strName = pRec->ForestTrustData.TopLevelName;
         AddAsteriskPrefix(strName);
         if (pRec->Flags)
         {
            if (LSA_TLN_DISABLED_NEW & pRec->Flags)
            {
               strStatus = strNewDisabled;
            }
            if (LSA_TLN_DISABLED_ADMIN & pRec->Flags)
            {
               strStatus = strAdminDisabled;
            }
            if (LSA_TLN_DISABLED_CONFLICT & pRec->Flags)
            {
               strStatus = strConflict;
            }
         }
         else
         {
            strStatus = strEnabled;
         }
         if (fCollision)
         {
            strStatus = strConflict;
            strNotes = strWith;
            strNotes += strCollisionName;
         }
         (*pLineFcn)(strMsg, j++, strName, strTypeSuffix, strStatus, strNotes);
         break;

      case ForestTrustTopLevelNameEx:
         strName = pRec->ForestTrustData.TopLevelName;
         AddAsteriskPrefix(strName);
         (*pLineFcn)(strMsg, j++, strName,
                     FTInfo.IsDomainMatch(i) ? strTlnExMatch : strExclusion,
                     NULL, NULL);
         break;

      case ForestTrustDomainInfo:
         strDnsName = pRec->ForestTrustData.DomainInfo.DnsName;
         strStatus = strEnabled;
         ULONG iExclusion;
         if (FTInfo.FindMatchingExclusion(i, iExclusion, true))
         {
            strStatus = strAdminDisabled;
            strType.LoadString(g_hInstance, IDS_LOG_HAS_EXCLUSION);
            strNotes = strType;
            fExcluded = true;
         }
         (*pLineFcn)(strMsg, j++, strDnsName, strTypeDnsDomain, strStatus, strNotes);

         strName = pRec->ForestTrustData.DomainInfo.NetbiosName;
         strNotes = strFor;
         strNotes += strDnsName;
         if (fCollision)
         {
            strStatus = strConflict;
            strNotes += ", ";
            strNotes += strWith;
            strNotes += strCollisionName;
         }
         if (fExcluded)
         {
            strStatus = strAdminDisabled;
            strNotes += ", ";
            strNotes += strType;
         }
         else
         {
            if (LSA_NB_DISABLED_ADMIN & pRec->Flags)
            {
               strStatus = strAdminDisabled;
            }
            else if (LSA_NB_DISABLED_CONFLICT & pRec->Flags)
            {
               strStatus = strConflict;
            }
            else
            {
               strStatus = strEnabled;
            }
         }
         (*pLineFcn)(strMsg, j++, strName, strTypeNBDomain, strStatus, strNotes);

         FormatSID(pRec->ForestTrustData.DomainInfo.Sid, strName);
         strNotes = strFor;
         strNotes += strDnsName;
         if (fCollision)
         {
            strStatus = strConflict;
            strNotes += ", ";
            strNotes += strWith;
            strNotes += strCollisionName;
         }
         if (fExcluded)
         {
            strStatus = strAdminDisabled;
            strNotes += ", ";
            strNotes += strType;
         }
         else
         {
            if (LSA_SID_DISABLED_ADMIN & pRec->Flags)
            {
               strStatus = strAdminDisabled;
            }
            else if (LSA_SID_DISABLED_CONFLICT & pRec->Flags)
            {
               strStatus = strConflict;
            }
            else
            {
               strStatus = strEnabled;
            }
         }
         (*pLineFcn)(strMsg, j++, strName, strTypeSID, strStatus, strNotes);
         break;

      default:
         (*pLineFcn)(strMsg, j++, strUnknown, L"", NULL, NULL);
         break;
      }
   }
   return;
}

//+----------------------------------------------------------------------------
//
//  Function:  FormatSID
//
//-----------------------------------------------------------------------------
void
FormatSID(PSID Sid, CStrW & str)
{
   TRACE_FUNCTION(FormatSID);
   SID_IDENTIFIER_AUTHORITY * sia;
   ULONG i = 0;
   CStrW strTmp;

   dspAssert(Sid);

   sia = RtlIdentifierAuthoritySid(Sid);

   str = L"s-1-";

   for (i = 0; i < 5; i++)
   {
      if (sia->Value[i])
      {
         strTmp.Format(L"%d", sia->Value[i]);
         str += strTmp;
      }
   }

   strTmp.Format(L"%d", sia->Value[5]);
   str += strTmp;

   for (i = 0; i < *RtlSubAuthorityCountSid(Sid); i++)
   {
      strTmp.Format(L"-%ld", *RtlSubAuthoritySid(Sid, i));
      str += strTmp;
   }
}

void AddAsteriskPrefix(CStrW & strName)
{
   CStrW strTemp = L"*.";
   strTemp += strName;
   strName = strTemp;
}

void RemoveAsteriskPrefix(CStrW & strName)
{
   CStrW strTemp;
   strTemp = strName.Left(2);
   if (strTemp != L"*.")
   {
      return;
   }
   strTemp = strName.Right(strName.GetLength() - 2);
   strName = strTemp;
}

//+----------------------------------------------------------------------------
//
//  Function:  NDReadFTNames
//
//  Synopsis:  Reads the forest trust names claimed by the trust partner and
//             stored on the TDO. No attempt is made to contact the other
//             domain to refresh the names.
//
//  Note:      This function is called from Netdom.exe. It should not be called
//             from a windows app since it writes to the console.
//-----------------------------------------------------------------------------
DWORD
NDReadFTNames(PCWSTR pwzLocalDc, PCWSTR pwzTrust, CFTInfo & FTInfo,
              CFTCollisionInfo & ColInfo)
{
   DWORD dwRet = NO_ERROR;
   NTSTATUS status = STATUS_SUCCESS;
   LSA_UNICODE_STRING TrustPartner = {0};
   PLSA_FOREST_TRUST_INFORMATION pFTInfo = NULL;

   if (!pwzLocalDc || !pwzTrust)
   {
      return ERROR_INVALID_PARAMETER;
   }

   RtlInitUnicodeString(&TrustPartner, pwzTrust);

   CPolicyHandle cPolicy(pwzLocalDc);

   dwRet = cPolicy.OpenNoAdmin();

   if (NO_ERROR != dwRet)
   {
      return dwRet;
   }

   status = LsaQueryForestTrustInformation(cPolicy,
                                           &TrustPartner,
                                           &pFTInfo);
   if (STATUS_NOT_FOUND == status)
   {
      // no FT info stored yet, which can occur on a new trust.
      //
      CStrW strErr;
      strErr.LoadString(g_hInstance, IDS_NETDOM_NO_FTINFOS);
      // NOTICE-2002/02/14-ericb - SecurityPush: strErr is valid and being written to the console.
      printf("%ws\n", strErr.GetBuffer(0));
      return LsaNtStatusToWinError(status);
   }

   if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
   {
      if (ERROR_INVALID_DOMAIN_STATE == dwRet)
      {
         CStrW strMsg;
         strMsg.LoadString(g_hInstance, IDS_NETDOM_NOT_FOREST);
         // NOTICE-2002/02/14-ericb - SecurityPush: strMsg is valid and being written to the console.
         printf("%ws\n", strMsg.GetBuffer(0));
         return ERROR_INVALID_PARAMETER;
      }
      if (ERROR_NO_SUCH_DOMAIN == dwRet)
      {
         CStrW strMsg;
         // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
         strMsg.FormatMessage(g_hInstance, IDS_NETDOM_NO_TRUST, pwzTrust);
         // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
         printf("%ws\n", strMsg.GetBuffer(0));
         return ERROR_INVALID_PARAMETER;
      }
      return dwRet;
   }

   dspAssert(pFTInfo);

   FTInfo = pFTInfo;

   LsaFreeMemory(pFTInfo);

   // Make a temp copy and clear the conflict bit before submitting to LSA.
   // This will return current conflict info.
   //
   CFTInfo TempFTInfo(FTInfo);

   TempFTInfo.ClearAnyConflict();

   // Now check the data. On return from the call the pColInfo struct
   // will contain current collision data.
   //
   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo = NULL;

   status = LsaSetForestTrustInformation(cPolicy,
                                         &TrustPartner,
                                         TempFTInfo.GetFTInfo(),
                                         TRUE, // check only, don't write to TDO
                                         &pColInfo);

   if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
   {
      if (ERROR_INVALID_DOMAIN_STATE == dwRet)
      {
         CStrW strMsg;
         strMsg.LoadString(g_hInstance, IDS_NETDOM_NOT_FOREST);
         // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
         printf("%ws\n", strMsg.GetBuffer(0));
         return ERROR_INVALID_PARAMETER;
      }
      return dwRet;
   }

   ColInfo = pColInfo;

   // Look for names that used to be or are now in conflict.
   //
   for (ULONG i = 0; i < FTInfo.GetCount(); i++)
   {
      // Any names that used to be in conflict but aren't now are marked as
      // admin-disabled.
      //
      if (FTInfo.IsConflictFlagSet(i))
      {
         if (!ColInfo.IsInCollisionInfo(i))
         {
            FTInfo.SetAdminDisable(i);
            FTInfo.SetUsedToBeInConflict(i);
            continue;
         }
      }
      // If a name is in the collision info, then set the conflict flag.
      //
      if (ColInfo.IsInCollisionInfo(i))
      {
         FTInfo.SetConflictDisable(i);
      }
   }

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Function:  NDWriteFTNames
//
//  Synopsis:  Writes the forest trust names to the TDO.
//
//  Note:      This function is called from Netdom.exe.
//-----------------------------------------------------------------------------
DWORD
NDWriteFTNames(PCWSTR pwzLocalDc, PCWSTR pwzTrust, CFTInfo & FTInfo)
{
   DWORD dwRet = NO_ERROR;
   NTSTATUS status = STATUS_SUCCESS;
   LSA_UNICODE_STRING TrustPartner = {0};
   PLSA_FOREST_TRUST_INFORMATION pFTInfo = NULL;

   if (!pwzLocalDc || !pwzTrust || !FTInfo.GetCount())
   {
      return ERROR_INVALID_PARAMETER;
   }

   RtlInitUnicodeString(&TrustPartner, pwzTrust);

   CPolicyHandle cPolicy(pwzLocalDc);

   dwRet = cPolicy.OpenNoAdmin();

   if (NO_ERROR != dwRet)
   {
      return dwRet;
   }

   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo = NULL;

   status = LsaSetForestTrustInformation(cPolicy,
                                         &TrustPartner,
                                         FTInfo.GetFTInfo(),
                                         FALSE,
                                         &pColInfo);

   if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
   {
      return dwRet;
   }

   if (pColInfo)
   {
      LsaFreeMemory(pColInfo);
   }

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Function:  DSPROP_DumpFTInfos
//
//  Synopsis:  Exported function that netdom can use to dump the FTInfos for a
//             forest trust.
//
//  Note:      This function is called from Netdom.exe. It should not be called
//             from a windows app since it writes to the console.
//-----------------------------------------------------------------------------
extern "C" INT_PTR WINAPI 
DSPROP_DumpFTInfos(PCWSTR pwzLocalDc, PCWSTR pwzTrust,
                   PCWSTR pwzUser, PCWSTR pwzPw)
{
   TRACE_FUNCTION(DSPROP_DumpFTInfos);

   if (!pwzLocalDc || !pwzTrust)
   {
      return ERROR_INVALID_PARAMETER;
   }

   //
   // Read the FTInfos, using the creds if needed.
   //
   DWORD dwRet = NO_ERROR;

   CCreds Creds;

   if (pwzUser && *pwzUser)
   {
      dwRet = Creds.SetUserAndPW(pwzUser, pwzPw, NULL);

      if (ERROR_SUCCESS != dwRet)
      {
         return dwRet;
      }

      dwRet = Creds.Impersonate();

      if (ERROR_SUCCESS != dwRet)
      {
         return dwRet;
      }
   }

   CFTInfo FTInfo;
   CFTCollisionInfo ColInfo;

   dwRet = NDReadFTNames(pwzLocalDc, pwzTrust, FTInfo, ColInfo);

   if (NO_ERROR != dwRet)
   {
      return dwRet;
   }

   CStrW strMsg;

   FormatFTNames(FTInfo, ColInfo, ComposeNumberedLine, strMsg);

   // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
   printf("%ws\n", strMsg.GetBuffer(0));

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Function:  DSPROP_ToggleFTName
//
//  Synopsis:  Exported function that netdom can use to toggle the state of an
//             FTInfo name for a forest trust.
//
//  Note:      This function is called from Netdom.exe. It should not be called
//             from a windows app since it writes to the console.
//-----------------------------------------------------------------------------
extern "C" INT_PTR WINAPI
DSPROP_ToggleFTName(PCWSTR pwzLocalDc, PWSTR pwzTrust, ULONG iSel,
                    PCWSTR pwzUser, PCWSTR pwzPW)
{
   dspDebugOut((DEB_ITRACE, "DSPROP_ToggleFTName, TDO: %ws, name: %d\n",
                pwzTrust, iSel));

   if (!pwzLocalDc || !pwzTrust)
   {
      return ERROR_INVALID_PARAMETER;
   }

   //
   // Read the FTInfos, using the creds if needed.
   //
   DWORD dwRet = NO_ERROR;
   NTSTATUS status = 0;

   CCreds Creds;

   if (pwzUser && *pwzUser)
   {
      dwRet = Creds.SetUserAndPW(pwzUser, pwzPW, NULL);

      if (ERROR_SUCCESS != dwRet)
      {
         return dwRet;
      }

      dwRet = Creds.Impersonate();

      if (ERROR_SUCCESS != dwRet)
      {
         return dwRet;
      }
   }

   CFTInfo FTInfo;
   CFTCollisionInfo ColInfo;
   CStrW strMsg, strName, strCollisionName;

   dwRet = NDReadFTNames(pwzLocalDc, pwzTrust, FTInfo, ColInfo);

   if (NO_ERROR != dwRet)
   {
      return dwRet;
   }

   PLSA_FOREST_TRUST_RECORD pRec = NULL;
   ULONG j = 1;
   bool fFound = false;

   for (UINT i = 0; i < FTInfo.GetCount() && !fFound; i++)
   {
      pRec = FTInfo.GetFTInfo()->Entries[i];
      dspAssert(pRec);
      bool fExcluded = false;

      switch (pRec->ForestTrustType)
      {
      case ForestTrustTopLevelName:
         if (iSel == j)
         {
            if (pRec->Flags)
            {
               if (pRec->Flags & (LSA_TLN_DISABLED_NEW | LSA_TLN_DISABLED_ADMIN))
               {
                  pRec->Flags = 0;
               }
               if ((LSA_TLN_DISABLED_CONFLICT & pRec->Flags) ||
                   ColInfo.IsInCollisionInfo(i))
               {
                  strName = pRec->ForestTrustData.TopLevelName;
                  if (ColInfo.GetCollisionName(i, strCollisionName))
                  {
                     // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
                     strMsg.FormatMessage(g_hInstance, IDS_NETDOM_CONFLICT_NAME,
                                          strName.GetBuffer(0),
                                          strCollisionName.GetBuffer(0));
                  }
                  else
                  {
                     // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
                     strMsg.FormatMessage(g_hInstance, IDS_NETDOM_CONFLICT,
                                          strName.GetBuffer(0));
                  }
                  // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
                  printf("%ws\n", strMsg.GetBuffer(0));
                  return ERROR_INVALID_PARAMETER;
               }
            }
            else
            {
               pRec->Flags = LSA_TLN_DISABLED_ADMIN;
            }
            fFound = true;
            break;
         }
         j++;
         break;

      case ForestTrustTopLevelNameEx:
         if (iSel == j)
         {
            strName = pRec->ForestTrustData.TopLevelName;
            // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
            strMsg.FormatMessage(g_hInstance, 
                                 FTInfo.IsDomainMatch(i) ? IDS_NETDOM_MATCHING_TLNEX :
                                                           IDS_NETDOM_TLNEX,
                                 strName.GetBuffer(0));
            // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
            printf("%ws\n", strMsg.GetBuffer(0));
            return ERROR_INVALID_PARAMETER;
         }
         j++;
         break;

      case ForestTrustDomainInfo:
         ULONG iExclusion;
         fExcluded = FTInfo.FindMatchingExclusion(i, iExclusion, true);
         if (iSel == j)
         {
            strName = pRec->ForestTrustData.DomainInfo.DnsName;
            // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
            strMsg.FormatMessage(g_hInstance, 
                                 (fExcluded) ? IDS_NETDOM_ENABLE_DOMAIN :
                                               IDS_NETDOM_DISABLE_DOMAIN,
                                 strName.GetBuffer(0));
            // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
            printf("%ws\n", strMsg.GetBuffer(0));
            return ERROR_INVALID_PARAMETER;
         }
         j++;

         if (iSel == j)
         {
            strName = pRec->ForestTrustData.DomainInfo.NetbiosName;
            if ((LSA_NB_DISABLED_CONFLICT & pRec->Flags) ||
                ColInfo.IsInCollisionInfo(i))
            {
               if (ColInfo.GetCollisionName(i, strCollisionName))
               {
                  // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
                  strMsg.FormatMessage(g_hInstance, IDS_NETDOM_CONFLICT_NAME,
                                       strName.GetBuffer(0),
                                       strCollisionName.GetBuffer(0));
               }
               else
               {
                  // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
                  strMsg.FormatMessage(g_hInstance, IDS_NETDOM_CONFLICT,
                                       strName.GetBuffer(0));
               }
               // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
               printf("%ws\n", strMsg.GetBuffer(0));
               return ERROR_INVALID_PARAMETER;
            }
            if (fExcluded)
            {
               // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
               strMsg.FormatMessage(g_hInstance, IDS_NETDOM_EXCLUDED,
                                    strName.GetBuffer(0));
               // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
               printf("%ws\n", strMsg.GetBuffer(0));
               return ERROR_INVALID_PARAMETER;
            }
            if (LSA_NB_DISABLED_ADMIN & pRec->Flags)
            {
               pRec->Flags &= ~LSA_NB_DISABLED_ADMIN;
            }
            else
            {
               pRec->Flags |= LSA_NB_DISABLED_ADMIN;
            }
            fFound = true;
            break;
         }
         j++;

         if (iSel == j)
         {
            FormatSID(pRec->ForestTrustData.DomainInfo.Sid, strName);
            if ((LSA_SID_DISABLED_CONFLICT & pRec->Flags) ||
                ColInfo.IsInCollisionInfo(i))
            {
               if (ColInfo.GetCollisionName(i, strCollisionName))
               {
                  // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
                  strMsg.FormatMessage(g_hInstance, IDS_NETDOM_SID_CONFLICT_NAME,
                                       strName.GetBuffer(0),
                                       strCollisionName.GetBuffer(0));
               }
               else
               {
                  // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
                  strMsg.FormatMessage(g_hInstance, IDS_NETDOM_SID_CONFLICT,
                                       strName.GetBuffer(0));
               }
            }
            if (fExcluded)
            {
               // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
               strMsg.FormatMessage(g_hInstance, IDS_NETDOM_EXCLUDED,
                                    strName.GetBuffer(0));
               // NOTICE-2002/02/14-ericb - SecurityPush: strMsg is valid and being written to the console.
               printf("%ws\n", strMsg.GetBuffer(0));
               return ERROR_INVALID_PARAMETER;
            }
            if (LSA_SID_DISABLED_ADMIN & pRec->Flags)
            {
               pRec->Flags &= ~LSA_SID_DISABLED_ADMIN;
            }
            else
            {
               pRec->Flags |= LSA_SID_DISABLED_ADMIN;
            }
            fFound = true;
            break;
         }
         j++;
         break;

      default:
         if (iSel == j)
         {
            return ERROR_INVALID_PARAMETER;
         }
         j++;
         break;
      }
   }

   if (!fFound)
   {
      // NOTICE-2002/02/14-ericb - SecurityPush: see earlier note.
      strMsg.FormatMessage(g_hInstance, IDS_NETDOM_RANGE_ERROR, --j);
      // NOTICE-2002/02/14-ericb - SecurityPush: strMsg is valid and being written to the console.
      printf("%ws\n", strMsg.GetBuffer(0));
      return ERROR_INVALID_PARAMETER;
   }

   //
   // Save the updated FTInfo.
   //
   dwRet = NDWriteFTNames(pwzLocalDc, pwzTrust, FTInfo);

   if (NO_ERROR != dwRet)
   {
      // NOTICE-2002/02/14-ericb - SecurityPush: CStrW::LoadString sets the string to an empty
      // string on failure.
      strMsg.LoadString(g_hInstance, IDS_NETDOM_WRITE_FTINFO_FAILED);
      // NOTICE-2002/02/14-ericb - SecurityPush: strMsg is valid and being written to the console.
      printf("%ws\n", strMsg.GetBuffer(0));
      return dwRet;
   }

   //
   // Print out the changes for the user.
   //
   FormatFTNames(FTInfo, ColInfo, ComposeNumberedLine, strMsg);

   // NOTICE-2002/02/14-ericb - SecurityPush: strMsg is valid and being written to the console.
   printf("%ws\n", strMsg.GetBuffer(0));

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Function:  NDGetFTInfo
//
//  Synopsis:  Gets the forest trust info from the TDO.
//
//  Note:      This function is called from Netdom.exe.
//-----------------------------------------------------------------------------
DWORD
NDGetFTInfo ( PCWSTR pwzLocalDc, PCWSTR pwzTrust, CFTInfo & FTInfo )
{
   DWORD dwRet = NO_ERROR;
   NTSTATUS status = STATUS_SUCCESS;
   LSA_UNICODE_STRING TrustPartner = {0};
   PLSA_FOREST_TRUST_INFORMATION pFTInfo = NULL;

   if (!pwzLocalDc || !pwzTrust)
   {
      return ERROR_INVALID_PARAMETER;
   }

   RtlInitUnicodeString(&TrustPartner, pwzTrust);

   CPolicyHandle cPolicy(pwzLocalDc);

   dwRet = cPolicy.OpenNoAdmin();
   if (NO_ERROR != dwRet)
   {
      return dwRet;
   }

   status = LsaQueryForestTrustInformation(cPolicy,
                                           &TrustPartner,
                                           &pFTInfo);

   if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
   {
       cPolicy.Close ();
       return dwRet;
   }

   dspAssert(pFTInfo);
   FTInfo = pFTInfo;

   cPolicy.Close ();
   return NO_ERROR;
}


//+----------------------------------------------------------------------------
//
//  Function:  NDSetFTInfo
//
//  Synopsis:  Writes the forest trust info to the TDO. If fCheckOnly is TRUE
//             then just test the operation without modifiying the TDO.
//
//  Note:      This function is called from Netdom.exe.
//-----------------------------------------------------------------------------
DWORD
NDSetFTInfo ( PCWSTR pwzLocalDc, PCWSTR pwzTrust, bool fCheckOnly, CFTInfo FTInfo, CFTCollisionInfo &ColInfo )
{
    DWORD dwRet = NO_ERROR;
    NTSTATUS status = STATUS_SUCCESS;
    LSA_UNICODE_STRING TrustPartner = {0};
    PLSA_FOREST_TRUST_INFORMATION pFTInfo = NULL;

    if (!pwzLocalDc || !pwzTrust )
    {
        return ERROR_INVALID_PARAMETER;
    }

    RtlInitUnicodeString(&TrustPartner, pwzTrust);

    CPolicyHandle cPolicy(pwzLocalDc);

    dwRet = cPolicy.OpenNoAdmin();

    if (NO_ERROR != dwRet)
    {
        return dwRet;
    }

    PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo = NULL;

    status = LsaSetForestTrustInformation(cPolicy,
                                         &TrustPartner,
                                         FTInfo.GetFTInfo(),
                                         fCheckOnly,
                                         &pColInfo);

    if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
    {
        return dwRet;
    }

    ColInfo = pColInfo;
    return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Function:  DSPROP_AddTLName
//
//  Synopsis:  Exported function that netdom can use to add a TLN or TLNEx to
//             the FTInfo for a forest trust.
//
//  Note:      This function is called from Netdom.exe. It should not be called
//             from a windows app since it writes to the console.
//-----------------------------------------------------------------------------
extern "C" INT_PTR WINAPI
DSPROP_AddTLName(PCWSTR pwzLocalDc, PWSTR pwzTrust, PCWSTR pwzTLN, bool fExclusion,
                    PCWSTR pwzUser, PCWSTR pwzPw)
{
    TRACE_FUNCTION(DSPROP_AddTLName);

    if (!pwzLocalDc || !pwzTrust || !pwzTLN )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Read the FTInfos, using the creds if needed.
    //
    DWORD dwRet = NO_ERROR;
    CStrW strMsg;

    CCreds Creds;

    if (pwzUser && *pwzUser)
    {
        dwRet = Creds.SetUserAndPW(pwzUser, pwzPw, NULL);

        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }

        dwRet = Creds.Impersonate();

        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }
    }

    CFTInfo FTInfo;

    dwRet = NDGetFTInfo (pwzLocalDc, pwzTrust, FTInfo);

    if ( (NO_ERROR != dwRet) && ( dwRet != LsaNtStatusToWinError ( STATUS_NOT_FOUND ) ) )
    {
        strMsg.LoadString(g_hInstance, IDS_NETDOM_FTINFO_READ_FAILED );
        printf ( "%ws\n", strMsg.GetBuffer(0) );

        if  ( dwRet == LsaNtStatusToWinError (STATUS_INVALID_PARAMETER) )
            strMsg.LoadString ( g_hInstance, IDS_NETDOM_FTINFO_INVALID_PARAMETER );
        else 
        if  ( dwRet == LsaNtStatusToWinError (STATUS_NO_SUCH_DOMAIN) )
            strMsg.LoadString ( g_hInstance, IDS_NETDOM_FTINFO_NO_TDO );
        else
        if  ( dwRet == LsaNtStatusToWinError (STATUS_INVALID_DOMAIN_STATE) )
            strMsg.LoadString ( g_hInstance, IDS_NETDOM_FTINFO_INVALID_STATE );
        else
            strMsg.Empty ();

        if ( !strMsg.IsEmpty () )
        {
            printf ( "%ws\n", strMsg.GetBuffer(0) );
        }

        Creds.Revert ();
        return ERROR_INVALID_PARAMETER;
    }

    //If no FTInfo is stored for this TDO create a new one
    if ( dwRet == LsaNtStatusToWinError ( STATUS_NOT_FOUND ) )
    {
        dwRet = NO_ERROR;
        PLSA_FOREST_TRUST_INFORMATION pFTInfoDefault = new LSA_FOREST_TRUST_INFORMATION;
        ZeroMemory ( pFTInfoDefault, sizeof (LSA_FOREST_TRUST_INFORMATION) );
        pFTInfoDefault->RecordCount = 0;
        FTInfo.SetFTInfo ( pFTInfoDefault );
    }

    ULONG index = 0;
    ULONG iEx = 0;

    // If we're adding an exclusion
    if ( fExclusion )
    {
        // Check if this TLN already exists
        if (  FTInfo.GetIndex ( pwzTLN, index ) && FTInfo.IsTlnExclusion (index) )
        {
            //The exclusion already exists return with appropriate mesg
            strMsg.LoadString(g_hInstance, IDS_NETDOM_ADD_TLN_ALREADY_EXISTS );
            printf ( "%ws\n", strMsg.GetBuffer(0) );
            Creds.Revert ();
            return NO_ERROR;
        }
        else
        {
            if (!FTInfo.AddNewExclusion ( pwzTLN, index ) )
            {
                strMsg.LoadString(g_hInstance, IDS_NETDOM_ADD_TLN_FAILED );
                printf ( "%ws\n", strMsg.GetBuffer (0) );
                Creds.Revert ();
                return ERROR_INVALID_PARAMETER;
            }
        }
    }
    else
    {
        // Adding a TLN 

        // Check if a TLN or Exclusion with the same name already exists
        if (  FTInfo.GetIndex ( pwzTLN, index ) && !FTInfo.IsTlnExclusion (index) )
        {
                strMsg.LoadString(g_hInstance, IDS_NETDOM_ADD_TLN_ALREADY_EXISTS );
                printf ( "%ws\n", strMsg.GetBuffer (0) );
                Creds.Revert ();
                return NO_ERROR;
        }
        else
        {
            // just add the TLN
            if ( !FTInfo.AddNewTLN ( pwzTLN, index ) )
            {
                strMsg.LoadString(g_hInstance, IDS_NETDOM_ADD_TLN_FAILED );
                printf ( "%ws\n", strMsg.GetBuffer (0) );
                Creds.Revert ();
                return ERROR_INVALID_PARAMETER;
            }
        }
    }

    CFTCollisionInfo ColInfo;
    
    // Write the FTInfo on the TDO
    dwRet = NDSetFTInfo (pwzLocalDc, pwzTrust, FALSE, FTInfo, ColInfo );

    if ( dwRet != NO_ERROR )
    {
        strMsg.LoadString(g_hInstance, IDS_NETDOM_FTINFO_WRITE_FAILED );
        printf ( "%ws\n", strMsg.GetBuffer(0) );
        Creds.Revert ();
        return dwRet;
    }

    if ( ColInfo.IsInConflict() )
    {
        if ( ColInfo.IsInCollisionInfo (index) )
        {
            CStrW strName;
            ColInfo.GetCollisionName ( index, strName );
            strMsg.FormatMessage ( g_hInstance, IDS_NETDOM_ADDED_TLN_CONFLICTS, pwzTLN, strName );
            printf ( "%ws\n", strMsg.GetBuffer (0) );
        }
    }
  
    strMsg.LoadString(g_hInstance, IDS_NETDOM_ADD_TLN_SUCCEEDED );
    printf ( "%ws\n", strMsg.GetBuffer(0) );
    Creds.Revert ();
    return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Function:  DSPROP_RemoveTLName
//
//  Synopsis:  Exported function that netdom can use to Remove a TLN or TLNEx 
//             from the FTInfo for a forest trust.
//
//  Note:      This function is called from Netdom.exe. It should not be called
//             from a windows app since it writes to the console.
//-----------------------------------------------------------------------------
extern "C" INT_PTR WINAPI
DSPROP_RemoveTLName(PCWSTR pwzLocalDc, PWSTR pwzTrust, PCWSTR pwzTLN, bool fExclusion,
                    PCWSTR pwzUser, PCWSTR pwzPw)
{
    TRACE_FUNCTION(DSPROP_RemoveTLName);

    if (!pwzLocalDc || !pwzTrust || !pwzTLN )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Read the FTInfos, using the creds if needed.
    //
    DWORD dwRet = NO_ERROR;
    CStrW strMsg;

    CCreds Creds;

    if (pwzUser && *pwzUser)
    {
        dwRet = Creds.SetUserAndPW(pwzUser, pwzPw, NULL);

        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }

        dwRet = Creds.Impersonate();

        if (ERROR_SUCCESS != dwRet)
        {
            return dwRet;
        }
    }

    CFTInfo FTInfo;
    dwRet = NDGetFTInfo (pwzLocalDc, pwzTrust, FTInfo);

    if ( dwRet != NO_ERROR )
    {
        strMsg.LoadString(g_hInstance, IDS_NETDOM_FTINFO_READ_FAILED );
        printf ( "%ws\n", strMsg.GetBuffer(0) );

        if  ( dwRet == LsaNtStatusToWinError (STATUS_INVALID_PARAMETER) )
            strMsg.LoadString ( g_hInstance, IDS_NETDOM_FTINFO_INVALID_PARAMETER );
        else 
        if   ( dwRet == LsaNtStatusToWinError (STATUS_NOT_FOUND) )
            strMsg.LoadString ( g_hInstance, IDS_NETDOM_FTINFO_NO_FTINFO );
        else
        if  ( dwRet == LsaNtStatusToWinError (STATUS_NO_SUCH_DOMAIN) )
            strMsg.LoadString ( g_hInstance, IDS_NETDOM_FTINFO_NO_TDO );
        else
        if  ( dwRet == LsaNtStatusToWinError (STATUS_INVALID_DOMAIN_STATE) )
            strMsg.LoadString ( g_hInstance, IDS_NETDOM_FTINFO_INVALID_STATE );
        else
            strMsg.Empty ();

        if ( !strMsg.IsEmpty () )
        {
            printf ( "%ws\n", strMsg.GetBuffer(0) );
        }

        Creds.Revert ();
        return ERROR_INVALID_PARAMETER;
    }
    
    ULONG index;
    if ( !FTInfo.GetIndex ( pwzTLN, index ) )
    {
        strMsg.LoadString(g_hInstance, IDS_NETDOM_TLN_NOT_FOUND );
        printf ( "%ws\n", strMsg.GetBuffer(0) );
        Creds.Revert ();
        return ERROR_INVALID_PARAMETER;
    }

    if ( 
         ( FTInfo.IsTlnExclusion (index) &&  !fExclusion ) ||
         (!FTInfo.IsTlnExclusion (index) &&  fExclusion )
       )


    {
        strMsg.LoadString(g_hInstance, IDS_NETDOM_TLN_WRONG_TYPE );
        printf ( "%ws\n", strMsg.GetBuffer(0) );
        Creds.Revert ();
        return ERROR_INVALID_PARAMETER;
    }

    bool fOpSucceeded = false;

    if ( fExclusion )
    {
        fOpSucceeded = FTInfo.RemoveExclusion (index);
    }
    else
    {
        fOpSucceeded = FTInfo.RemoveTLN ( index );
    }

    if ( !fOpSucceeded )
    {
        strMsg.LoadString(g_hInstance, IDS_NETDOM_REMOVE_TLN_FAILED );
        printf ( "%ws\n", strMsg.GetBuffer(0) );
        Creds.Revert ();
        return ERROR_INVALID_PARAMETER;
    }

    //Write the FTInfo the TDO
    CFTCollisionInfo ColInfo;
    dwRet = NDSetFTInfo ( pwzLocalDc, pwzTrust, FALSE, FTInfo, ColInfo );

    if ( dwRet != NO_ERROR )
    {
        strMsg.LoadString(g_hInstance, IDS_NETDOM_REMOVE_TLN_FAILED );
        printf ( "%ws\n", strMsg.GetBuffer(0) );
        Creds.Revert ();
        return dwRet;
    }

    strMsg.LoadString(g_hInstance, IDS_NETDOM_REMOVE_TLN_SUCCEEDED );
    printf ( "%ws\n", strMsg.GetBuffer(0) );
    Creds.Revert ();
    return NO_ERROR;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\managdby.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       managdby.h
//
//  Contents:   DS object Managed-By property page definitions
//
//  History:    21-Oct-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _MANAGEDBY_H_
#define _MANAGEDBY_H_

#include "proppage.h"
#include "pages.h"

extern WCHAR g_wszUserClass[];
extern WCHAR g_wszContactClass[];

HRESULT ManagedByEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ChangeButton(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ViewButton(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ClearButton(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT UpdateListCheck(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                        LPARAM, PATTR_DATA, DLG_OP);

HRESULT OfficeEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT StreetEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT CityEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT StateEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT CountryEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT PhoneEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT FaxEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

class CManagedByPage
{
public:
    CManagedByPage(CDsPropPageBase * pPage);
    ~CManagedByPage(void);

    HRESULT             SetObj(PWSTR pwzObjDN);
    void                SetNameCtrlID(int nCtrl) {m_nNameCtlID = nCtrl;};
    HRESULT             SetEditCtrl(PATTR_MAP pAttrMap);
    void                Clear(void);
    HRESULT             RefreshCtrls(void);
    IDirectoryObject  * Obj(void) {return m_pDsObj;};
    IDirectoryObject  * PreviousObj(void) { return m_pPrevDsObj;}
    PWSTR               Name(void) {return m_pwzObjName;};
    PWSTR               PreviousName(void) {return m_pwzPrevObjName;}
    BOOL                IsValid(void) {return m_pDsObj && m_pwzObjName;};
    BOOL                IsUser(void) {return m_fIsUser;};
    void                SetWritable(BOOL fWritable) {m_fWritable = fWritable;};
    BOOL                IsWritable(void) {return m_fWritable;};
    void                SetMembershipWritable(BOOL fWritable) {m_fWritableMembership = fWritable;}
    BOOL                IsMembershipWritable(void) { return m_fWritableMembership; }
    void                SetUpdateListCheckEnable(BOOL fEnable) {m_fUpdateListCheckEnable = fEnable;}
    BOOL                IsUpdateCheckEnable(void) { return m_fUpdateListCheckEnable; }
    void                SetCanonicalDACL(BOOL fCanonicalDACL);
    BOOL                IsCanonicalDACL(void) { return m_fCanonicalDACL; }
   
private:
    IDirectoryObject  * m_pDsObj;
    CDsPropPageBase   * m_pPage;
    PWSTR               m_pwzObjName;
    BOOL                m_fIsUser;
    int                 m_nNameCtlID;
    BOOL                m_fWritable;
    BOOL                m_fWritableMembership;
    BOOL                m_fUpdateListCheckEnable;
    BOOL                m_fCanonicalDACL;

public:
    IDirectoryObject  * m_pPrevDsObj;
    PWSTR               m_pwzPrevObjName;
    int                 m_nViewBtnID;
    int                 m_nClearBtnID;
    int                 m_nUpdateListChkID;
    PATTR_MAP           m_pOfficeAttrMap;
    PATTR_MAP           m_pStreetAttrMap;
    PATTR_MAP           m_pCityAttrMap;
    PATTR_MAP           m_pStateAttrMap;
    PATTR_MAP           m_pCountryAttrMap;
    PATTR_MAP           m_pPhoneAttrMap;
    PATTR_MAP           m_pFaxAttrMap;
};

#endif // _MANAGEDBY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\listview.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       listview.cxx
//
//  Contents:   Classes for list view controls.
//
//  Classes:    CListViewBase, CSuffixesList
//
//  History:    01-Dec-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "trust.h"
#include "listview.h"

//+----------------------------------------------------------------------------
//
//  Method:    CListViewBase::CListViewBase
//
//-----------------------------------------------------------------------------
CListViewBase::CListViewBase(void) :
   _nID(0),
   _hParent(NULL),
   _hList(NULL)
{
}

//+----------------------------------------------------------------------------
//
//  Method:    CListViewBase::SetStyles
//
//-----------------------------------------------------------------------------
void
CListViewBase::SetStyles(DWORD dwStyles, DWORD dwExtStyles)
{
   if (dwStyles)
   {
   }

   if (dwExtStyles)
   {
      ListView_SetExtendedListViewStyle(_hList, dwExtStyles);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CListViewBase::AddColumn
//
//-----------------------------------------------------------------------------
void
CListViewBase::AddColumn(int textID, int cx, int nID)
{
   CStrW strText;

   // NOTICE-2002/02/19-ericb - SecurityPush: CStrW::LoadString sets the
   // string to an empty string on failure.
   strText.LoadString(g_hInstance, textID);

   LV_COLUMN lvc;
   lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
   lvc.fmt = LVCFMT_LEFT;
   lvc.cx = cx;
   lvc.pszText = strText;
   lvc.iSubItem = nID;

   ListView_InsertColumn(_hList, nID, &lvc);
}

//+----------------------------------------------------------------------------
//
//  Method:    CListViewBase::Clear
//
//-----------------------------------------------------------------------------
void
CListViewBase::Clear(void)
{
   dspAssert(_hList);
   ListView_DeleteAllItems(_hList);
}

//+----------------------------------------------------------------------------
//
//  Class:      CTLNList
//
//  Purpose:    TLN list on the Name Suffix Routing property page.
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Method:    CTLNList::CTLNList
//
//-----------------------------------------------------------------------------
CTLNList::CTLNList(void) :
   _nItem(0),
   CListViewBase()
{
   TRACE(CTLNList,CTLNList);
#ifdef _DEBUG
   // NOTICE-2002/02/19-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
   strcpy(szClass, "CTLNList");
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:    CTLNList::Init
//
//-----------------------------------------------------------------------------
void
CTLNList::Init(HWND hParent, int nControlID)
{
   _nID = nControlID;
   _hParent = hParent;

   _hList = GetDlgItem(hParent, nControlID);
   dspAssert(_hList);

   SetStyles(0, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP | LVS_EX_INFOTIP);

   AddColumn(IDS_COL_TITLE_SUFFIX, 117, IDX_SUFFIXNAME_COL);
   AddColumn(IDS_COL_TITLE_ROUTING, 118, IDX_ROUTINGENABLED_COL);
   AddColumn(IDS_COL_TITLE_STATUS, 118, IDX_STATUS_COL);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTLNList::AddItem
//
//-----------------------------------------------------------------------------
void
CTLNList::AddItem(PCWSTR pwzName, ULONG i, PCWSTR pwzEnabled, PCWSTR pwzStatus)
{
   if (!pwzName)
   {
      dspAssert(false);
      pwzName = L"AddItem passed a null name string pointer!";
   }
   if (!pwzEnabled)
   {
      dspAssert(false);
      pwzEnabled = L"AddItem passed a null enable-value string pointer!";
   }
   LV_ITEM lvi;
   lvi.mask = LVIF_TEXT | LVIF_PARAM;
   lvi.iSubItem = IDX_SUFFIXNAME_COL;
   lvi.lParam = i; // the lParam stores the index of the item in pFTInfo
   CStrW strName, strEnabled;
   // ISSUE-2002/02/19-ericb - Remove cast when StringCchLength is fixed.
   if (FAILED(StringCchLength(const_cast<PWSTR>(pwzName), DNS_MAX_NAME_LENGTH+1, NULL)))
   {
      PWSTR pwz = strName.GetBufferSetLength(DNS_MAX_NAME_BUFFER_LENGTH);
      if (strName.GetLength() < DNS_MAX_NAME_BUFFER_LENGTH)
      {
         pwz = L"AddItem out of memory!";
      }
      else
      {
         (void)StringCchCopy(pwz, DNS_MAX_NAME_BUFFER_LENGTH, pwzName); // not checking return code because it is expected to be a failure.
      }
      lvi.pszText = pwz;
   }
   else
   {
      lvi.pszText = const_cast<PWSTR>(pwzName);
   }
   lvi.iItem = _nItem++;

   int iItem = ListView_InsertItem(_hList, &lvi);

   PWSTR pwzItem = NULL;
   if (FAILED(StringCchLength(const_cast<PWSTR>(pwzEnabled), DNS_MAX_NAME_LENGTH+1, NULL)))
   {
      PWSTR pwz = strEnabled.GetBufferSetLength(DNS_MAX_NAME_BUFFER_LENGTH);
      if (strEnabled.GetAllocLength() < DNS_MAX_NAME_BUFFER_LENGTH)
      {
         pwz = L"AddItem out of memory!";
      }
      else
      {
         (void)StringCchCopy(pwz, DNS_MAX_NAME_BUFFER_LENGTH, pwzEnabled); // not checking return code because it is expected to be a failure.
      }
      pwzItem = pwz;
   }
   else
   {
      pwzItem = const_cast<PWSTR>(pwzEnabled);
   }
   ListView_SetItemText(_hList, iItem, IDX_ROUTINGENABLED_COL, pwzItem);

   if (pwzStatus && *pwzStatus != 0)
   {
      WCHAR wzStatus[DNS_MAX_NAME_BUFFER_LENGTH] = {0};
      if (FAILED(StringCchLength(const_cast<PWSTR>(pwzStatus), DNS_MAX_NAME_LENGTH+1, NULL)))
      {
         (void)StringCchCopy(wzStatus, DNS_MAX_NAME_BUFFER_LENGTH, pwzStatus); // not checking return code because it is expected to be a failure.
         pwzItem = wzStatus;
      }
      else
      {
         pwzItem = const_cast<PWSTR>(pwzStatus);
      }
      ListView_SetItemText(_hList, iItem, IDX_STATUS_COL, pwzItem);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CTLNList::GetSelection
//
//-----------------------------------------------------------------------------
int
CTLNList::GetSelection(void)
{
   return ListView_GetNextItem(_hList, -1, LVNI_ALL | LVIS_SELECTED);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTLNList::GetFTInfoIndex
//
//-----------------------------------------------------------------------------
ULONG
CTLNList::GetFTInfoIndex(int iSel)
{
   LV_ITEM lvi;
   lvi.mask = LVIF_PARAM;
   lvi.iItem = iSel;
   lvi.iSubItem = IDX_SUFFIXNAME_COL;

   if (!ListView_GetItem(_hList, &lvi))
   {
       dspAssert(FALSE);
       return (ULONG)-1;
   }

   return static_cast<ULONG>(lvi.lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTLNList::Clear
//
//-----------------------------------------------------------------------------
void
CTLNList::Clear(void)
{
   _nItem = 0;
   CListViewBase::Clear();
}


//+----------------------------------------------------------------------------
//
//  Class:      CSuffixesList
//
//  Purpose:    TLN subnames edit dialog list.
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Method:    CSuffixesList::CSuffixesList
//
//-----------------------------------------------------------------------------
CSuffixesList::CSuffixesList(void) :
   CListViewBase()
{
   TRACE(CSuffixesList,CSuffixesList);
#ifdef _DEBUG
   strcpy(szClass, "CSuffixesList");
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:    CSuffixesList::Init
//
//-----------------------------------------------------------------------------
void
CSuffixesList::Init(HWND hParent, int nControlID)
{
   _nID = nControlID;
   _hParent = hParent;

   _hList = GetDlgItem(hParent, nControlID);
   dspAssert(_hList);

   SetStyles(0, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

   AddColumn(IDS_TLNEDIT_NAME_COL, 222, IDX_NAME_COL);
   AddColumn(IDS_TLNEDIT_STATUS_COL, 196, IDX_STATUS_COL);
}

//+----------------------------------------------------------------------------
//
//  Method:    CSuffixesList::AddItem
//
//-----------------------------------------------------------------------------
void
CSuffixesList::AddItem(PCWSTR pwzName, ULONG i, TLN_EDIT_STATUS Status)
{
   if (!pwzName)
   {
      dspAssert(false);
      pwzName = L"AddItem passed a null name string param!";
   }
   LV_ITEM lvi;
   lvi.mask = LVIF_TEXT | LVIF_PARAM;
   lvi.iSubItem = IDX_NAME_COL;
   lvi.lParam = i; // the lParam stores the index of the item in pFTInfo
   // ISSUE-2002/02/19-ericb - remove cast when StringCchLength is fixed.
   CStrW strName;
   if (FAILED(StringCchLength(const_cast<PWSTR>(pwzName), DNS_MAX_NAME_LENGTH+1, NULL)))
   {
      PWSTR pwz = strName.GetBufferSetLength(DNS_MAX_NAME_BUFFER_LENGTH);
      if (strName.GetAllocLength() < DNS_MAX_NAME_BUFFER_LENGTH)
      {
         pwz = L"AddItem out of memory!";
      }
      else
      {
         (void)StringCchCopy(pwz, DNS_MAX_NAME_BUFFER_LENGTH, pwzName); // not checking return code because it is expected to be a failure.
      }
      lvi.pszText = pwz;
   }
   else
   {
      lvi.pszText = const_cast<PWSTR>(pwzName);
   }
   lvi.iItem = _nItem++;

   int iItem = ListView_InsertItem(_hList, &lvi);

   CStrW strStatus;

   // NOTICE-2002/02/19-ericb - SecurityPush: see above CStrW::Loadstring notice
   strStatus.LoadString(g_hInstance, 
                        (Enabled == Status) ? IDS_ROUTING_ENABLED :
                        (Disabled == Status) ? IDS_ROUTING_DISABLED :
                        (Enabled_Exceptions == Status) ? IDS_ROUTING_EXCEPT_ENABLE :
                           IDS_ROUTING_EXCEPT_DISABLE);

   ListView_SetItemText(_hList, iItem, IDX_STATUS_COL, strStatus);
}

//+----------------------------------------------------------------------------
//
//  Method:    CSuffixesList::UpdateItemStatus
//
//-----------------------------------------------------------------------------
void
CSuffixesList::UpdateItemStatus(int item, TLN_EDIT_STATUS Status)
{
   CStrW strStatus;

   // NOTICE-2002/02/19-ericb - SecurityPush: see above CStrW::Loadstring notice
   strStatus.LoadString(g_hInstance, 
                        (Enabled == Status) ? IDS_ROUTING_ENABLED :
                        (Disabled == Status) ? IDS_ROUTING_DISABLED :
                        (Enabled_Exceptions == Status) ? IDS_ROUTING_EXCEPT_ENABLE :
                           IDS_ROUTING_EXCEPT_DISABLE);

   ListView_SetItemText(_hList, item, IDX_STATUS_COL, strStatus);
}

//+----------------------------------------------------------------------------
//
//  Method:    CSuffixesList::GetFTInfoIndex
//
//-----------------------------------------------------------------------------
ULONG
CSuffixesList::GetFTInfoIndex(int iSel)
{
   LV_ITEM lvi;
   lvi.mask = LVIF_PARAM;
   lvi.iItem = iSel;
   lvi.iSubItem = IDX_NAME_COL;

   if (!ListView_GetItem(_hList, &lvi))
   {
       dspAssert(FALSE);
       return (ULONG)-1;
   }

   return static_cast<ULONG>(lvi.lParam);
}

/*
//+----------------------------------------------------------------------------
//
//  Method:    CSuffixesList::
//
//-----------------------------------------------------------------------------

CSuffixesList::
{
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\listview.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      listview.h
//
//  Contents:  classes for listview controls.
//
//  Classes:   CListViewBase, CTLNList, CSuffixesList
//
//  History:   01-Dec-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef LISTVIEW_H_GUARD
#define LISTVIEW_H_GUARD

//+----------------------------------------------------------------------------
//
//  Class:     CListViewBase
//
//  Purpose:   Base class for list view controls.
//
//-----------------------------------------------------------------------------
class CListViewBase
{
public:
#ifdef _DEBUG
   char szClass[32];
#endif

   CListViewBase(void);
   virtual ~CListViewBase(void) {};

   void  SetStyles(DWORD dwStyles, DWORD dwExtStyles);

   virtual void AddColumn(int textID, int cx, int nID);

   virtual void Init(HWND hParent, int nControlID) = 0;
   virtual void Clear(void);

protected:
   HWND     _hParent;
   HWND     _hList;
   int      _nID;
};

//+----------------------------------------------------------------------------
//
//  Class:     CTLNList
//
//  Purpose:   TLN list on the Name Suffix Routing property page.
//
//-----------------------------------------------------------------------------
class CTLNList : public CListViewBase
{
public:

   CTLNList(void);
   virtual ~CTLNList(void) {};

   void  Init(HWND hParent, int nControlID);
   void  AddItem(PCWSTR pwzName, ULONG i, PCWSTR pwzEnabled, PCWSTR pwzStatus);
   //BOOL  RmItem(LV_ITEM * pItem);
   int   GetSelection(void);
   ULONG GetFTInfoIndex(int iSel);
   //void  SetSelection(int nItem);
   void  Clear(void);

private:
   static const int IDX_SUFFIXNAME_COL = 0;
   static const int IDX_ROUTINGENABLED_COL = 1;
   static const int IDX_STATUS_COL = 2;

   int   _nItem;
};

//+----------------------------------------------------------------------------
//
//  Class:     CSuffixesList
//
//  Purpose:   TLN subnames edit dialog list.
//
//-----------------------------------------------------------------------------
class CSuffixesList : public CListViewBase
{
public:

   CSuffixesList(void);
   virtual ~CSuffixesList(void) {};

   void  Init(HWND hParent, int nControlID);
   void  AddItem(PCWSTR pwzName, ULONG i, TLN_EDIT_STATUS Status);
   void  UpdateItemStatus(int item, TLN_EDIT_STATUS Status);
   int   GetSelection(void) {return ListView_GetNextItem(_hList, -1, LVNI_ALL | LVIS_SELECTED);};
   ULONG GetFTInfoIndex(int iSel);
   //void  SetSelection(int nItem);

private:
   static const int IDX_NAME_COL = 0;
   static const int IDX_STATUS_COL = 1;

   int   _nItem;
};

#endif // LISTVIEW_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\managdby.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       managdby.cxx
//
//  Contents:   Managed-By property page implementation
//
//  History:    21-Oct-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "user.h"
#include "managdby.h"

#include <ntsam.h>
#include <aclapi.h>

WCHAR g_wszUserClass[] = L"user";
WCHAR g_wszContactClass[] = L"contact";

extern const GUID GUID_MemberAttribute = 
   { 0xbf9679c0, 0x0de6, 0x11d0,  { 0xa2, 0x85, 0x00,0xaa, 0x00, 0x30, 0x49, 0xe2}};

CManagedByPage::CManagedByPage(CDsPropPageBase * pPage) :
    m_pDsObj(NULL),
    m_pPrevDsObj(NULL),
    m_pPage(pPage),
    m_pwzObjName(NULL),
    m_pwzPrevObjName(NULL),
    m_fIsUser(FALSE),
    m_fWritable(FALSE),
    m_fWritableMembership(FALSE),
    m_fUpdateListCheckEnable(FALSE),
    m_fCanonicalDACL(TRUE),
    m_nNameCtlID(0),
    m_pOfficeAttrMap(NULL),
    m_pStreetAttrMap(NULL),
    m_pCityAttrMap(NULL),
    m_pStateAttrMap(NULL),
    m_pCountryAttrMap(NULL),
    m_pPhoneAttrMap(NULL),
    m_pFaxAttrMap(NULL)
{
}

CManagedByPage::~CManagedByPage()
{
    if (m_pDsObj != m_pPrevDsObj)
    {
       DO_RELEASE(m_pPrevDsObj);
    }

    DO_RELEASE(m_pDsObj);
    if (m_pwzPrevObjName && 
        m_pwzObjName &&
        0 != _wcsicmp(m_pwzPrevObjName, m_pwzObjName))
    {
       delete[] m_pwzPrevObjName;
    }

    if (m_pwzObjName)
    {
        delete[] m_pwzObjName;
    }

}

//+----------------------------------------------------------------------------
//
//  Method:     CManagedByPage::SetObj
//
//  Synopsis:   Initialize the CManagedBy class and set the edit control value.
//
//-----------------------------------------------------------------------------
HRESULT CManagedByPage::SetObj(PWSTR pwzObjDN)
{
    HRESULT hr;
    PWSTR pwzCanonical = NULL;

    Clear();

    // Save the Managed-By object DN.
    //
    if (!AllocWStr(pwzObjDN, &m_pwzObjName))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    //
    // Save the name as a previous value if the previous value isn't already set
    //
    if (!m_pwzPrevObjName)
    {
       m_pwzPrevObjName = m_pwzObjName;
    }

    // Put the "friendly" name into the edit control.
    //
    hr = CrackName(m_pwzObjName, &pwzCanonical, GET_OBJ_CAN_NAME,
                   m_pPage->GetHWnd());
    if (FAILED(hr))
    {
        return hr;
    }
    PTSTR ptsz;
    if (!UnicodeToTchar(pwzCanonical, &ptsz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
        LocalFreeStringW(&pwzCanonical);
        return E_OUTOFMEMORY;
    }
    LocalFreeStringW(&pwzCanonical);
    SetDlgItemText(m_pPage->GetHWnd(), m_nNameCtlID, ptsz);
    delete ptsz;

    // Bind to the Managed-By object.
    //
    CStrW strADsPath;
    IDirectoryObject * pObj;

    hr = AddLDAPPrefix(m_pPage, m_pwzObjName, strADsPath);

    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return hr);

    hr = DSAdminOpenObject(const_cast<PWSTR>((LPCWSTR)strADsPath),
                           IID_IDirectoryObject,
                           (PVOID *)&pObj);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            ErrMsg(IDS_ERRMSG_NO_LONGER_EXISTS, m_pPage->GetHWnd());
            return S_OK;
        }
        else
        {
            REPORT_ERROR(hr, m_pPage->GetHWnd());
            return hr;
        }
    }

    m_pDsObj = pObj;
    if (m_pPrevDsObj == NULL)
    {
       m_pPrevDsObj = m_pDsObj;
       m_pPrevDsObj->AddRef();
    }

    // Determine if the Managed-By object is of class user or contact.
    //
    BSTR bstr;
    IADs * pADs;

    hr = m_pDsObj->QueryInterface(IID_IADs, (PVOID *)&pADs);

    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return hr;);

    hr = pADs->get_Class(&bstr);

    pADs->Release();

    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return hr;);

    m_fIsUser = (_wcsicmp(bstr, g_wszUserClass) == 0 ||
                 _wcsicmp(bstr, g_wszContactClass) == 0 || 
                 _wcsicmp(bstr, g_wzInetOrgPerson) == 0
                 );

    SysFreeString(bstr);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CManagedByPage::SetEditCtrl
//
//  Synopsis:   If a user or contact object, fetch the corresponding value and
//              put it in the control. Otherwise, clear the control.
//
//-----------------------------------------------------------------------------
HRESULT
CManagedByPage::SetEditCtrl(PATTR_MAP pAttrMap)
{
    HRESULT hr = S_OK;

    if (!IsUser())
    {
        // No user values, so clear the control.
        //
        SetDlgItemText(m_pPage->GetHWnd(), pAttrMap->nCtrlID, TEXT(""));
        return S_OK;
    }

    PADS_ATTR_INFO pAttr = NULL;
    DWORD cAttrs = 0;
    hr = m_pDsObj->GetObjectAttributes(&pAttrMap->AttrInfo.pszAttrName, 1,
                                       &pAttr, &cAttrs);
    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, m_pPage->GetHWnd()))
    {
        return hr;
    }
    if (!cAttrs)
    {
        // Attribute not present.
        //
        SetDlgItemText(m_pPage->GetHWnd(), pAttrMap->nCtrlID, TEXT(""));
        return S_OK;
    }

    PTSTR ptsz;
    if (!UnicodeToTchar(pAttr->pADsValues->CaseIgnoreString, &ptsz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_pPage->GetHWnd());
        FreeADsMem(pAttr);
        return E_OUTOFMEMORY;
    }
    SetDlgItemText(m_pPage->GetHWnd(), pAttrMap->nCtrlID, ptsz);
    delete ptsz;
    FreeADsMem(pAttr);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CManagedByPage::Clear
//
//  Synopsis:   Return to the base state.
//
//-----------------------------------------------------------------------------
void CManagedByPage::Clear(void)
{
    DO_RELEASE(m_pDsObj);
    
    if (!m_pwzPrevObjName)
    {
       m_pwzPrevObjName = m_pwzObjName;
    }
    else
    {
       if (m_pwzPrevObjName && m_pwzObjName && 0 != _wcsicmp(m_pwzPrevObjName, m_pwzObjName))
       {
         DO_DEL(m_pwzObjName);
       }
       m_pwzObjName = NULL;
    }

    m_fIsUser = FALSE;
    SetDlgItemText(m_pPage->GetHWnd(), m_nNameCtlID, TEXT(""));

    // Set the focus and the default button to the Change button

    SetFocus(GetDlgItem(m_pPage->GetHWnd(), IDC_CHANGE_BTN));

    SendMessage(
       GetParent(m_pPage->GetHWnd()), 
       DM_SETDEFID, 
       (WPARAM)IDC_CHANGE_BTN, 
       0);

    SendDlgItemMessage(
       m_pPage->GetHWnd(),
       IDC_CLEAR_BTN,
       BM_SETSTYLE,
       BS_PUSHBUTTON,
       MAKELPARAM(TRUE, 0));

    SendDlgItemMessage(
       m_pPage->GetHWnd(),
       IDC_CHANGE_BTN,
       BM_SETSTYLE,
       BS_DEFPUSHBUTTON,
       MAKELPARAM(TRUE, 0));
}

//+----------------------------------------------------------------------------
//
//  Method:     CManagedByPage::RefreshCtrls
//
//  Synopsis:   Update the dependent controls.
//
//-----------------------------------------------------------------------------
HRESULT CManagedByPage::RefreshCtrls(void)
{
    EnableWindow(GetDlgItem(m_pPage->GetHWnd(), m_nViewBtnID), IsValid());
    EnableWindow(GetDlgItem(m_pPage->GetHWnd(), m_nClearBtnID), IsValid() && IsWritable());

    HRESULT hr;

    hr = UpdateListCheck(m_pPage, NULL, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = OfficeEdit(m_pPage, m_pOfficeAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = StreetEdit(m_pPage, m_pStreetAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = CityEdit(m_pPage, m_pCityAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = StateEdit(m_pPage, m_pStateAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = CountryEdit(m_pPage, m_pCountryAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = PhoneEdit(m_pPage, m_pPhoneAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    hr = FaxEdit(m_pPage, m_pFaxAttrMap, NULL, 0, NULL, fObjChanged);

    CHECK_HRESULT(hr, return hr);

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Attr Function:  CManagedByPage::SetCanonicalDACL
//
//  Synopsis:   If the DACL is not in canonical form, remember that so that we
//              can disable the checkbox.
//
//-----------------------------------------------------------------------------
void CManagedByPage::SetCanonicalDACL(BOOL fCanonicalDACL)
{
    if (m_fCanonicalDACL && !fCanonicalDACL)
    {
        m_fCanonicalDACL = fCanonicalDACL;
    }
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  ManagedByEdit
//
//  Synopsis:   If the Managed-By attribute is non-empty, binds to the named
//              object and stores the ADSI pointer in the page object.
//
//  WARNING:    This MUST be the first ATTR_FCN called because it creates the
//              CManagedByPage object.
//-----------------------------------------------------------------------------
HRESULT
ManagedByEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
              DLG_OP DlgOp)
{
    CManagedByPage * pManagedBy;
    HRESULT hr = S_OK;

    switch (DlgOp)
    {
    case fInit:
    case fObjChanged:
        if (DlgOp == fInit)
        {
            pManagedBy = new CManagedByPage(pPage);

            ((CDsTableDrivenPage *)pPage)->m_pData = reinterpret_cast<LPARAM>(pManagedBy);

            CHECK_NULL_REPORT(pManagedBy, pPage->GetHWnd(), return E_OUTOFMEMORY);

            pManagedBy->SetNameCtrlID(pAttrMap->nCtrlID);
            pManagedBy->SetWritable(PATTR_DATA_IS_WRITABLE(pAttrData));
        }
        else
        {
            pManagedBy = reinterpret_cast<CManagedByPage*>(((CDsTableDrivenPage *)pPage)->m_pData);
            if (!pManagedBy)
            {
                return E_FAIL;
            }
        }
        if (pAttrInfo && pAttrInfo->dwNumValues)
        {
            hr = pManagedBy->SetObj(pAttrInfo->pADsValues->DNString);
            if (FAILED(hr))
            {
                return hr;
            }
        }
        break;

    case fOnCommand:
        if (EN_CHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData); // Attribute has been modified.
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

        if (pManagedBy)
        {
            if (pManagedBy->IsValid())
            {
                PADSVALUE pADsValue;
                pADsValue = new ADSVALUE;
                CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);
                PWSTR pwz;
                if (!AllocWStr(pManagedBy->Name(), &pwz))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                    return E_OUTOFMEMORY;
                }
                pAttrInfo->pADsValues = pADsValue;
                pAttrInfo->dwNumValues = 1;
                pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
                pADsValue->dwType = pAttrInfo->dwADsType;
                pADsValue->DNString = pwz;
            }
            else
            {
                pAttrInfo->pADsValues = NULL;
                pAttrInfo->dwNumValues = 0;
                pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
            }
        }
        break;

    case fOnDestroy:
        pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;
        DO_DEL(pManagedBy);
        break;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  ChangeButton
//
//  Synopsis:   Handles the Change Managed-By button.
//
//-----------------------------------------------------------------------------
HRESULT
ChangeButton(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
             DLG_OP DlgOp)
{
    if (fInit == DlgOp)
    {
        CManagedByPage * pManagedBy;
        pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;
        dspAssert(pManagedBy);
        if (!pManagedBy->IsWritable())
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }
    }

    if (!(DlgOp == fOnCommand && lParam == BN_CLICKED))
    {
        return S_OK;
    }
    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    HRESULT hr = S_OK;
    LPWSTR cleanstr = NULL;
    CWaitCursor WaitCursor;
    IDsObjectPicker * pObjSel;
    BOOL fIsObjSelInited;

    hr = pPage->GetObjSel(&pObjSel, &fIsObjSelInited);

    CHECK_HRESULT(hr, return hr);

    if (!fIsObjSelInited)
    {
        CStrW cstrDC;
        CComPtr<IDirectoryObject> spDsObj;
        if (pPage->m_pDsObj == NULL)
        {
          //
          // For the retrieval of the DS Object names
          //
          FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
          STGMEDIUM objMedium;
          hr = pPage->m_pWPTDataObj->GetData(&fmte, &objMedium);
          CHECK_HRESULT(hr, return hr);

          LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

          LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                                   pDsObjectNames->aObjects[0].offsetName);

          //
          // Bind to the object
          //
          hr = DSAdminOpenObject(pwzObjADsPath, 
                                 IID_IDirectoryObject, 
                                 (PVOID*)&spDsObj);

          ReleaseStgMedium(&objMedium);

          CHECK_HRESULT(hr, return hr);
        }
        else
        {
          spDsObj = pPage->m_pDsObj;
        }
        hr = GetLdapServerName(spDsObj, cstrDC);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        DSOP_SCOPE_INIT_INFO rgScopes[3];
        DSOP_INIT_INFO InitInfo;

        ZeroMemory(rgScopes, sizeof(rgScopes));
        ZeroMemory(&InitInfo, sizeof(InitInfo));

        rgScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
        rgScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
        rgScopes[0].pwzDcName = cstrDC;
        rgScopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS |
                                                      DSOP_FILTER_CONTACTS;

        rgScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[1].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
        rgScopes[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS |
                                                      DSOP_FILTER_CONTACTS;

        rgScopes[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
        rgScopes[2].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS |
                                                      DSOP_FILTER_CONTACTS;

        InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
        InitInfo.cDsScopeInfos = 3;
        InitInfo.aDsScopeInfos = rgScopes;
        InitInfo.pwzTargetComputer = cstrDC;

        hr = pObjSel->Initialize(&InitInfo);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        pPage->ObjSelInited();
    }

    IDataObject * pdoSelections = NULL;

    hr = pObjSel->InvokeDialog(pPage->GetHWnd(), &pdoSelections);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    if (hr == S_FALSE || !pdoSelections)
    {
        return S_OK;
    }

    FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};

    hr = pdoSelections->GetData(&fmte, &medium);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

    if (!pSelList || !pSelList->cItems || !pSelList->aDsSelection->pwzADsPath)
    {
        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);
        pdoSelections->Release();
        return S_OK;
    }

    WaitCursor.SetWait();

    hr = pPage->SkipPrefix(pSelList->aDsSelection->pwzADsPath, &cleanstr);

    GlobalUnlock(medium.hGlobal);
    ReleaseStgMedium(&medium);
    pdoSelections->Release();

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), goto Cleanup);

    hr = pManagedBy->SetObj(cleanstr);

    CHECK_HRESULT(hr, goto Cleanup);

    pPage->SetDirty();

    pManagedBy->RefreshCtrls();

Cleanup:

    DO_DEL(cleanstr);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  ViewButton
//
//  Synopsis:   Handles the View button.
//
//-----------------------------------------------------------------------------
HRESULT
ViewButton(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
           DLG_OP DlgOp)
{
    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pManagedBy);
        //
        // Save the control ID.
        //
        pManagedBy->m_nViewBtnID = pAttrMap->nCtrlID;
        // fall through
    case fObjChanged:
        //
        // Enable/Disable as appropriate.
        //
        EnableWindow(GetDlgItem(pPage->GetHWnd(), pManagedBy->m_nViewBtnID),
                     pManagedBy->IsValid());
        break;

    case fOnCommand:
        CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

        if (lParam == BN_CLICKED && pManagedBy->IsValid())
        {
            PostPropSheet(pManagedBy->Name(), pPage);
        }
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  ClearButton
//
//  Synopsis:   Handles the Clear pushbutton.
//
//-----------------------------------------------------------------------------
HRESULT
ClearButton(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
            DLG_OP DlgOp)
{
    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pManagedBy);
        //
        // Save the control ID.
        //
        pManagedBy->m_nClearBtnID = pAttrMap->nCtrlID;
        // fall through
    case fObjChanged:
        //
        // Enable/Disable as appropriate.
        //
        EnableWindow(GetDlgItem(pPage->GetHWnd(), pManagedBy->m_nClearBtnID),
                     pManagedBy->IsValid() && pManagedBy->IsWritable());
        break;

    case fOnCommand:
        if (lParam == BN_CLICKED)
        {
            CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

            pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;
            pManagedBy->Clear();
            pManagedBy->RefreshCtrls();
            
            pPage->SetDirty();
        }
        break;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetSecurityInfoMask
//
//  Synopsis:   Reads the security descriptor from the specied DS object
//
//  Arguments:  [IN  punk]          --  IUnknown from IDirectoryObject
//              [IN  si]            --  SecurityInformation
////  History:  25-Dec-2000         --  Hiteshr Created
//----------------------------------------------------------------------------
HRESULT
SetSecurityInfoMask(LPUNKNOWN punk, SECURITY_INFORMATION si)
{
    HRESULT hr = E_INVALIDARG;
    if (punk)
    {
        IADsObjectOptions *pOptions;
        hr = punk->QueryInterface(IID_IADsObjectOptions, (void**)&pOptions);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            VariantInit(&var);
            V_VT(&var) = VT_I4;
            V_I4(&var) = si;
            hr = pOptions->SetOption(ADS_OPTION_SECURITY_MASK, var);
            pOptions->Release();
        }
    }
    return hr;
}

WCHAR const c_szSDProperty[]        = L"nTSecurityDescriptor";


//+---------------------------------------------------------------------------
//
//  Function:   DSReadObjectSecurity
//
//  Synopsis:   Reads the Dacl from the specied DS object
//
//  Arguments:  [in pDsObject]      -- IDirettoryObject for dsobject
//              [psdControl]        -- Control Setting for SD
//                                     They can be returned when calling
//                                      DSWriteObjectSecurity                 
//              [OUT ppDacl]        --  DACL returned here
//              
//
//  History     25-Oct-2000         -- hiteshr created
//
//  Notes:  If Object Doesn't have DACL, function will succeed but *ppDacl will
//          be NULL. 
//          Caller must free *ppDacl, if not NULL, by calling LocalFree
//
//----------------------------------------------------------------------------
HRESULT 
DSReadObjectSecurity(IN IDirectoryObject *pDsObject,
                     OUT SECURITY_DESCRIPTOR_CONTROL * psdControl,
                     OUT PACL *ppDacl)
{
   HRESULT hr = S_OK;

   PADS_ATTR_INFO pSDAttributeInfo = NULL;

   do // false loop
   {
      LPWSTR pszSDProperty = (LPWSTR)c_szSDProperty;
      DWORD dwAttributesReturned;
      PSECURITY_DESCRIPTOR pSD = NULL;
      PACL pAcl = NULL;

      if(!pDsObject || !ppDacl)
      {
         hr = E_INVALIDARG;
         break;
      }

      *ppDacl = NULL;

      // Set the SECURITY_INFORMATION mask
      hr = SetSecurityInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
      {
         break;
      }

      //
      // Read the security descriptor
      //
      hr = pDsObject->GetObjectAttributes(&pszSDProperty,
                                         1,
                                         &pSDAttributeInfo,
                                         &dwAttributesReturned);
      if (SUCCEEDED(hr) && !pSDAttributeInfo)    
         hr = E_ACCESSDENIED;    // This happens for SACL if no SecurityPrivilege

      if(FAILED(hr))
      {
         break;
      }                

      ASSERT(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->dwADsType);
      ASSERT(ADSTYPE_NT_SECURITY_DESCRIPTOR == pSDAttributeInfo->pADsValues->dwType);

      pSD = (PSECURITY_DESCRIPTOR)pSDAttributeInfo->pADsValues->SecurityDescriptor.lpValue;


      //
      //Get the security descriptor control
      //
      if(psdControl)
      {
         DWORD dwRevision;
         if(!GetSecurityDescriptorControl(pSD, psdControl, &dwRevision))
         {
             hr = HRESULT_FROM_WIN32(GetLastError());
             break;
         }
      }

      //
      //Get pointer to DACL
      //
      BOOL bDaclPresent, bDaclDefaulted;
      if(!GetSecurityDescriptorDacl(pSD, 
                                   &bDaclPresent,
                                   &pAcl,
                                   &bDaclDefaulted))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         break;
      }

      if(!bDaclPresent || !pAcl)
         break;

      dspAssert(IsValidAcl(pAcl));

      //
      //Make a copy of the DACL
      //
      *ppDacl = (PACL)LocalAlloc(LPTR,pAcl->AclSize);
      if(!*ppDacl)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
      CopyMemory(*ppDacl,pAcl,pAcl->AclSize);

    }while(0);


    if (pSDAttributeInfo)
        FreeADsMem(pSDAttributeInfo);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   DSWriteObjectSecurity
//
//  Synopsis:   Writes the Dacl to the specied DS object
//
//  Arguments:  [in pDsObject]      -- IDirettoryObject for dsobject
//              [sdControl]         -- control for security descriptor
//              [IN  pDacl]         --  The DACL to be written
//
//  History     25-Oct-2000         -- hiteshr created
//----------------------------------------------------------------------------
HRESULT 
DSWriteObjectSecurity(IN IDirectoryObject *pDsObject,
                      IN SECURITY_DESCRIPTOR_CONTROL sdControl,
                      PACL pDacl)
{
   HRESULT hr = S_OK;
   PISECURITY_DESCRIPTOR pSD = NULL;
   PSECURITY_DESCRIPTOR psd = NULL;

   do // false loop
   {
      ADSVALUE attributeValue;
      ADS_ATTR_INFO attributeInfo;
      DWORD dwAttributesModified;
      DWORD dwSDLength;

      if(!pDsObject || !pDacl)
      {
         dspAssert(FALSE);
         hr = E_INVALIDARG;
         break;
      }

      dspAssert(IsValidAcl(pDacl));

      // Set the SECURITY_INFORMATION mask
      hr = SetSecurityInfoMask(pDsObject, DACL_SECURITY_INFORMATION);
      if(FAILED(hr))
      {
         break;
      }


      //
      //Build the Security Descriptor
      //
      pSD = (PISECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);
      if (pSD == NULL)
      {
         hr = E_OUTOFMEMORY;
         break;
      }
        
	  //NTRAID#NTBUG9-571268-2002/03/10-jmessec    Not checking return value of InitializeSecurityDescriptor
      InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);

      //
      // Finally, build the security descriptor
      //
      pSD->Control |= SE_DACL_PRESENT | SE_DACL_AUTO_INHERIT_REQ
                     | (sdControl & (SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED));

      if(pDacl->AclSize)
      {
         pSD->Dacl = pDacl;
      }

      //
      // Need the total size
      //
      dwSDLength = GetSecurityDescriptorLength(pSD);

      //
      // If necessary, make a self-relative copy of the security descriptor
      //
      psd = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDLength);

      if (psd == NULL ||
          !MakeSelfRelativeSD(pSD, psd, &dwSDLength))
      {
         hr = HRESULT_FROM_WIN32(GetLastError());
         break;
      }


      attributeValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
      attributeValue.SecurityDescriptor.dwLength = dwSDLength;
      attributeValue.SecurityDescriptor.lpValue = (LPBYTE)psd;

      attributeInfo.pszAttrName = (LPWSTR)c_szSDProperty;
      attributeInfo.dwControlCode = ADS_ATTR_UPDATE;
      attributeInfo.dwADsType = ADSTYPE_NT_SECURITY_DESCRIPTOR;
      attributeInfo.pADsValues = &attributeValue;
      attributeInfo.dwNumValues = 1;

      // Write the security descriptor
      hr = pDsObject->SetObjectAttributes(&attributeInfo,
                                         1,
                                         &dwAttributesModified);
   } while (false);
    
   if (psd != NULL)
   {
      LocalFree(psd);
   }

   if(pSD != NULL)
   {
      LocalFree(pSD);
   }

   return hr;
}

/*******************************************************************

    NAME:       IsDACLCanonical

    SYNOPSIS:   Checks a DACL for canonical ordering

    ENTRY:      pDacl - points to DACL to check

    EXIT:

    RETURNS:    Nonzero if DACL is in canonical order, zero otherwise

    NOTES:

    HISTORY:
        JeffJon		15-Oct-2001     Copied from HiteshR 
		                            %sdxroot%\shell\osshell\security\aclui\misc.cpp

********************************************************************/

enum ACELEVEL
{
    alNonInheritAccessDenied,
    alNonInheritAccessAllowed,
    alInheritedAces,
};

BOOL
IsDACLCanonical(PACL pDacl)
{
    PACE_HEADER pAce = 0;
    ACELEVEL currentAceLevel;
    DWORD dwAceCount = 0;

    if (pDacl == NULL)
        return TRUE;

    currentAceLevel = alNonInheritAccessDenied;
    dwAceCount = pDacl->AceCount;

    if (dwAceCount == 0)
        return TRUE;

    for (pAce = (PACE_HEADER)FirstAce(pDacl);
         dwAceCount > 0;
         --dwAceCount, pAce = (PACE_HEADER)NextAce(pAce))
    {
        ACELEVEL aceLevel;

        //
        // NOTE: We do not skip INHERIT_ONLY aces because we want them in
        // canonical order too.
        //

        if (pAce->AceFlags & INHERITED_ACE)
        {
            aceLevel = alInheritedAces;      // don't check order here
        }
        else
        {
            switch(pAce->AceType)
            {
            case ACCESS_DENIED_ACE_TYPE:
            case ACCESS_DENIED_OBJECT_ACE_TYPE:
                aceLevel = alNonInheritAccessDenied;
                break;

            case ACCESS_ALLOWED_ACE_TYPE:
            case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
            case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
                aceLevel = alNonInheritAccessAllowed;
                break;

            default:
                return FALSE;
            }
        }

        //
        // If the ace type is less than the level we are currently at,
        // then it is not canonical.
        //
        if (aceLevel < currentAceLevel)
            return FALSE;

        //
        // Update the current ace level.
        //
        currentAceLevel = aceLevel;
    }

    //
    // If we get here, then the DACL is in canonical order.
    //
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Helper Attr Function:  GetMembershipPermsFor
//
//  Synopsis:   Checks the ACL for the group to determine if the manager has
//              rights to write group membership.
//
//-----------------------------------------------------------------------------
HRESULT
GetMembershipPermsFor(IDirectoryObject* pManagerObject,
                      IDirectoryObject* pGroupObject,
                      BOOL* pbHasWritePerms,
                      BOOL* pbIsSecurityPrinciple,
                      BOOL* pbIsCanonicalDACL)
{
  HRESULT hr = S_OK;

  //
  // Validate parameters
  //
  if (!pManagerObject ||
      !pGroupObject ||
      !pbHasWritePerms ||
      !pbIsSecurityPrinciple ||
      !pbIsCanonicalDACL)
  {
     return E_INVALIDARG;
  }

  *pbHasWritePerms = FALSE;
  *pbIsSecurityPrinciple = FALSE;
  *pbIsCanonicalDACL = TRUE;

  //
  // Get the SID of the manager
  //
  static DWORD dwAttrCount = 1;
  PWSTR pszAttrs[] = { g_wzObjectSID };
  PADS_ATTR_INFO pAttrInfo = NULL;
  DWORD dwAttrRet = 0;
  hr = pManagerObject->GetObjectAttributes(pszAttrs,
                                           dwAttrCount,
                                           &pAttrInfo,
                                           &dwAttrRet);
  if (FAILED(hr))
  {
     *pbIsSecurityPrinciple = FALSE;
     return S_OK;
  }

  PSID pManagerSID = NULL;
  if (pAttrInfo && dwAttrRet == 1)
  {
     if (_wcsicmp(pAttrInfo->pszAttrName, g_wzObjectSID) == 0 &&
         pAttrInfo->pADsValues)
     {
        pManagerSID = pAttrInfo->pADsValues->OctetString.lpValue;
     }
  }

  if (pManagerSID == NULL)
  {
     if (pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     *pbIsSecurityPrinciple = FALSE;
     return S_FALSE;
  }

  *pbIsSecurityPrinciple = TRUE;

  //
  // Now get the Security Descriptor from the group
  //
  SECURITY_DESCRIPTOR_CONTROL sdControl = {0};
  CSimpleAclHolder Dacl;

  hr = DSReadObjectSecurity(pGroupObject,
                            &sdControl,
                            &(Dacl.m_pAcl));
  if (FAILED(hr))
  {
     if (pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     return hr;
  }

  // NTRAID#NTBUG9-476623-2001/10/15-JeffJon
  // First verify that the DACL is canonical.

  *pbIsCanonicalDACL = IsDACLCanonical(Dacl.m_pAcl);

  ULONG ulCount = 0, j = 0;
  PEXPLICIT_ACCESS rgEntries = NULL;
  DWORD dwErr = GetExplicitEntriesFromAcl(Dacl.m_pAcl, &ulCount, &rgEntries);
  if (ERROR_SUCCESS != dwErr)
  {
     if (pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     hr = HRESULT_FROM_WIN32(dwErr);
     return hr;
  }

  bool bManagerAllowWrite = false;

  //
  // Loop through looking for the can change password ACE for the manager SID
  //
  for (j = 0; j < ulCount; j++)
  {
    //
    // Look for allow ACEs
    //
    OBJECTS_AND_SID* pObjectsAndSid = NULL;
    pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;
    if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                    GUID_MemberAttribute))
    {
      if ((rgEntries[j].grfAccessPermissions & ACTRL_DS_WRITE_PROP) &&
          rgEntries[j].grfAccessMode == GRANT_ACCESS)
      {
        //
        // See if it is for the manager SID
        //
        if (EqualSid(pObjectsAndSid->pSid, pManagerSID))
        {
          //
          // Allow manager found
          //
          bManagerAllowWrite = true;
          break;
        }
      }
    }
  }

  *pbHasWritePerms = bManagerAllowWrite;

  if (pAttrInfo)
  {
     FreeADsMem(pAttrInfo);
     pAttrInfo = NULL;
  }

  LocalFree(rgEntries);
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Helper Attr Function:  WriteMembershipPermsFor
//
//  Synopsis:   Updates the ACL for the group to with the manager has
//              rights to write group membership.
//
//-----------------------------------------------------------------------------
HRESULT
WriteMembershipPermsFor(IDirectoryObject* pManagerObject,
                        IDirectoryObject* pGroupObject,
                        BOOL bGiveWritePerms)
{
  HRESULT hr = S_OK;

  //
  // Validate parameters
  //
  if (!pManagerObject ||
      !pGroupObject)
  {
     return E_INVALIDARG;
  }

  //
  // Get the SID of the manager
  //
  static DWORD dwAttrCount = 1;
  PWSTR pszAttrs[] = { g_wzObjectSID };
  PADS_ATTR_INFO pAttrInfo = NULL;
  DWORD dwAttrRet = 0;
  hr = pManagerObject->GetObjectAttributes(pszAttrs,
                                           dwAttrCount,
                                           &pAttrInfo,
                                           &dwAttrRet);
  if (FAILED(hr))
  {
     //
     // Not a Security principle, just return
     //
     return S_OK;
  }

  PSID pManagerSID = NULL;
  if (pAttrInfo && dwAttrRet == 1)
  {
     if (_wcsicmp(pAttrInfo->pszAttrName, g_wzObjectSID) == 0 &&
         pAttrInfo->pADsValues)
     {
        pManagerSID = pAttrInfo->pADsValues->OctetString.lpValue;
     }
  }

  if (pManagerSID == NULL)
  {
     //
     // Not a Security principle, just return
     //
     if (pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     return S_OK;
  }


  //
  // Now get the Security Descriptor from the group
  //
  SECURITY_DESCRIPTOR_CONTROL sdControl = {0};
  CSimpleAclHolder Dacl;

  hr = DSReadObjectSecurity(pGroupObject,
                            &sdControl,
                            &(Dacl.m_pAcl));
  if (FAILED(hr))
  {
     if (pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     return hr;
  }

  ULONG ulCount = 0, j = 0;
  PEXPLICIT_ACCESS rgEntries = NULL;
  DWORD dwErr = GetExplicitEntriesFromAcl(Dacl.m_pAcl, &ulCount, &rgEntries);
  if (ERROR_SUCCESS != dwErr)
  {
     if (pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     hr = HRESULT_FROM_WIN32(dwErr);
     return hr;
  }

  PEXPLICIT_ACCESS rgNewEntries = NULL;
  ULONG ulNewCount = 0;

  //
  // At the most we will add an Allow ACE so allocate enough space for that
  //
  rgNewEntries = (PEXPLICIT_ACCESS)LocalAlloc(LPTR, sizeof(EXPLICIT_ACCESS)*(ulCount + 1));
  if (!rgNewEntries)
  {
     if(pAttrInfo)
     {
        FreeADsMem(pAttrInfo);
        pAttrInfo = NULL;
     }
     return E_OUTOFMEMORY;
  }

  bool bManagerAllowWrite = false;

  //
  // Loop through looking for the can change password ACE for the manager SID
  //
  for (j = 0; j < ulCount; j++)
  {
    bool bCopyACE = true;
    //
    // Look for allow ACEs
    //
    OBJECTS_AND_SID* pObjectsAndSid = NULL;
    pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;
    if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                    GUID_MemberAttribute))
    {
      if ((rgEntries[j].grfAccessPermissions & ACTRL_DS_WRITE_PROP) &&
          rgEntries[j].grfAccessMode == GRANT_ACCESS)
      {
        //
        // See if it is for the manager SID
        //
        if (EqualSid(pObjectsAndSid->pSid, pManagerSID))
        {
          //
          // Allow manager found
          //
          bManagerAllowWrite = true;

          if (!bGiveWritePerms)
          {
             bCopyACE = false;
          }
        }
      }
    }

    if (bCopyACE)
    {
      rgNewEntries[ulNewCount] = rgEntries[j];
      ulNewCount++;
    }
  }

  //
  // If we want the manager to have write perms but we didn't
  // find an Allow ACE add one now
  //
  if (bGiveWritePerms && !bManagerAllowWrite)
  {
    rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_WRITE_PROP;
    rgNewEntries[ulNewCount].grfAccessMode = GRANT_ACCESS;
    rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;

    //
    // build the trustee structs for change password
    //
    OBJECTS_AND_SID rgObjectsAndSid = {0};
    BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                  &rgObjectsAndSid,
                                  const_cast<GUID *>(&GUID_MemberAttribute),
                                  NULL, // inherit guid
                                  pManagerSID);
    ulNewCount++;
  }

  CSimpleAclHolder NewDacl;
  //NTRAID#NTBUG9-573437-2002/03/10-jmessec   Not checking return value of SetEntriesInAcl
  dwErr = SetEntriesInAcl(ulNewCount, rgNewEntries, NULL, &(NewDacl.m_pAcl));
  dspAssert(IsValidAcl(NewDacl.m_pAcl));

  hr = DSWriteObjectSecurity(pGroupObject,
                             sdControl,
                             NewDacl.m_pAcl);
 
  if (pAttrInfo)
  {
     FreeADsMem(pAttrInfo);
     pAttrInfo = NULL;
  }

  LocalFree(rgNewEntries);
  LocalFree(rgEntries);
  return hr;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  UpdateListCheck
//
//  Synopsis:   Handles the allow manager to update membership list checkbox
//
//-----------------------------------------------------------------------------
HRESULT
UpdateListCheck(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
                DLG_OP DlgOp)
{
    CManagedByPage* pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pManagedBy);
        //
        // Save the control ID.
        //
        pManagedBy->m_nUpdateListChkID = pAttrMap->nCtrlID;

        // fall through
    case fObjChanged:
      {
        // NTRAID#NTBUG9-464733-2001/10/17-JeffJon
        // Should only show the checkbox for group objects

        if (_wcsicmp(pPage->GetObjClass(), g_wzGroup) == 0)
        {
           //
           // See if the object is a security principle and if so then see
           // if it has permission to write group membership
           //
           BOOL bHasWritePerms = FALSE;
           BOOL bIsSecurityPrinciple = FALSE;
           BOOL bIsCanonicalDACL = TRUE;

           HRESULT hr = GetMembershipPermsFor(pManagedBy->Obj(),
                                              pPage->m_pDsObj,
                                              &bHasWritePerms,
                                              &bIsSecurityPrinciple,
                                              &bIsCanonicalDACL);

           //
           // Ignore failures and use the defaults
           //
           pManagedBy->SetMembershipWritable(bHasWritePerms);
           pManagedBy->SetCanonicalDACL(bIsCanonicalDACL);
           pManagedBy->SetUpdateListCheckEnable(bIsSecurityPrinciple && bIsCanonicalDACL);

           hr = S_OK;

           //
           // Enable/Disable as appropriate.
           //
           EnableWindow(GetDlgItem(pPage->GetHWnd(), pManagedBy->m_nUpdateListChkID),
                        pManagedBy->IsUpdateCheckEnable());
           SendDlgItemMessage(pPage->GetHWnd(), 
                              pManagedBy->m_nUpdateListChkID,
                              BM_SETCHECK, 
                              (WPARAM)(pManagedBy->IsMembershipWritable()) ? BST_CHECKED : BST_UNCHECKED,
                              0);
        }
        else
        {
           ShowWindow(
              GetDlgItem(pPage->GetHWnd(), pManagedBy->m_nUpdateListChkID),
              SW_HIDE);
        }
      }
      break;

    case fOnCommand:
        if (lParam == BN_CLICKED)
        {
            CHECK_NULL(pManagedBy, return ADM_S_SKIP);

            pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;
            pPage->SetDirty();
        }
        break;

    case fApply:
        if (pManagedBy)
        {
           // NTRAID#NTBUG9-773232-2003/02/04-JeffJon
           // We don't want to touch the DACL if its not in canonical form.
           // This means that Exchange touched the DACL to hide the membership.
           // In this case it makes no sense to give the owner the right to
           // modify group membership because the deny will override the right
           // anyway. Plus the manager wouldn't be able to see who is the group
           // to start with.

           if (pManagedBy->IsCanonicalDACL())
           {
              //
              // Set the ownership of the group to the new manager
              //
              HRESULT hr = S_OK;
              if ((pManagedBy->PreviousName() && pManagedBy->Name() && 
                   _wcsicmp(pManagedBy->Name(), pManagedBy->PreviousName()) != 0) ||
                  !pManagedBy->Name())
              {
                 //
                 // The new name and the old name are different so we need to update
                 // the ACL
                 //
 
                 //
                 // First remove the old manager from the ACL
                 //
                 hr = WriteMembershipPermsFor(pManagedBy->PreviousObj(),
                                              pPage->m_pDsObj,
                                              FALSE);
              }
              //
              // Now add the new manager to the ACL if checkbox is checked
              //
              BOOL bAddGrantACE = (SendDlgItemMessage(pPage->GetHWnd(), 
                                                      pManagedBy->m_nUpdateListChkID,
                                                      BM_GETCHECK, 
                                                      0, 
                                                      0) == BST_CHECKED);
              hr = WriteMembershipPermsFor(pManagedBy->Obj(),
                                           pPage->m_pDsObj,
                                           bAddGrantACE);

           }
           DO_RELEASE(pManagedBy->m_pPrevDsObj);
           pManagedBy->m_pPrevDsObj = pManagedBy->Obj();
           if (pManagedBy->m_pPrevDsObj)
           {
             pManagedBy->m_pPrevDsObj->AddRef();
           }

           if (pManagedBy->PreviousName() && pManagedBy->Name() &&
               _wcsicmp(pManagedBy->Name(), pManagedBy->PreviousName()) != 0)
           {
              DO_DEL(pManagedBy->m_pwzPrevObjName);
           }
           pManagedBy->m_pwzPrevObjName = pManagedBy->Name();
        }
        break;

    }

    return ADM_S_SKIP;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  OfficeEdit
//
//-----------------------------------------------------------------------------
HRESULT
OfficeEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pOfficeAttrMap == NULL)
    {
        // Save the attr map pointer so that it can be used later.
        //
        pManagedBy->m_pOfficeAttrMap = pAttrMap;
    }

    return pManagedBy->SetEditCtrl(pManagedBy->m_pOfficeAttrMap);
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  StreetEdit
//
//-----------------------------------------------------------------------------
HRESULT
StreetEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pStreetAttrMap == NULL)
    {
        // Save the attr map pointer so that it can be used later.
        //
        pManagedBy->m_pStreetAttrMap = pAttrMap;
    }

    return pManagedBy->SetEditCtrl(pManagedBy->m_pStreetAttrMap);
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  CityEdit
//
//-----------------------------------------------------------------------------
HRESULT
CityEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pCityAttrMap == NULL)
    {
        // Save the attr map pointer so that it can be used later.
        //
        pManagedBy->m_pCityAttrMap = pAttrMap;
    }

    return pManagedBy->SetEditCtrl(pManagedBy->m_pCityAttrMap);
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  StateEdit
//
//-----------------------------------------------------------------------------
HRESULT
StateEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pStateAttrMap == NULL)
    {
        // Save the attr map pointer so that it can be used later.
        //
        pManagedBy->m_pStateAttrMap = pAttrMap;
    }

    return pManagedBy->SetEditCtrl(pManagedBy->m_pStateAttrMap);
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  CountryEdit
//
//-----------------------------------------------------------------------------
HRESULT
CountryEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
            DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pCountryAttrMap == NULL)
    {
        pManagedBy->m_pCountryAttrMap = pAttrMap;
    }

    if (pManagedBy->IsUser())
    {
        HRESULT hr;
        PADS_ATTR_INFO pAttr = NULL;
        DWORD cAttrs = 0;
        hr = pManagedBy->Obj()->GetObjectAttributes(&pManagedBy->m_pCountryAttrMap->AttrInfo.pszAttrName,
                                                    1, &pAttr, &cAttrs);
        if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, pPage->GetHWnd()))
        {
            return hr;
        }
        ATTR_DATA AttrData = {0};

        hr = CountryName(pPage, pManagedBy->m_pCountryAttrMap, pAttr, lParam,
                         &AttrData, DlgOp);
        if (pAttr)
            FreeADsMem(pAttr);

        return hr;
    }
    else
    {
        SetDlgItemText(pPage->GetHWnd(), pManagedBy->m_pCountryAttrMap->nCtrlID,
                       TEXT(""));
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  PhoneEdit
//
//-----------------------------------------------------------------------------
HRESULT
PhoneEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pPhoneAttrMap == NULL)
    {
        // Save the attr map pointer so that it can be used later.
        //
        pManagedBy->m_pPhoneAttrMap = pAttrMap;
    }

    return pManagedBy->SetEditCtrl(pManagedBy->m_pPhoneAttrMap);
}

//+----------------------------------------------------------------------------
//
//  Attr Function:  FaxEdit
//
//-----------------------------------------------------------------------------
HRESULT
FaxEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp && fObjChanged != DlgOp)
    {
        return S_OK;
    }

    CManagedByPage * pManagedBy;

    pManagedBy = (CManagedByPage *)((CDsTableDrivenPage *)pPage)->m_pData;

    CHECK_NULL(pManagedBy, return E_OUTOFMEMORY);

    if (pManagedBy->m_pFaxAttrMap == NULL)
    {
        // Save the attr map pointer so that it can be used later.
        //
        pManagedBy->m_pFaxAttrMap = pAttrMap;
    }

    return pManagedBy->SetEditCtrl(pManagedBy->m_pFaxAttrMap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\membship.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       membship.cxx
//
//  Contents:   Membership page for showing the groups to which an object has
//              membership (a.k.a. reverse membeship).
//
//  History:    27-July-98 EricB copied from user.cxx.
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "objlist.h"
#include "user.h"
#include "group.h"
#include "qrybase.h"

void ReportNoGroupAccess(PTSTR ptzCanName, HWND hPage);
void ReportNoGroupAccessSignSeal(PTSTR ptzCanName, HWND hPage);

static const PWSTR g_wzMembership = L"memberOf"; // ADSTYPE_DN_STRING Multi-valued
static const PWSTR g_wzPrimaryGroup = L"primaryGroupID"; // ADSTYPE_INTEGER

//+----------------------------------------------------------------------------
//
//  Member:     CDsMembershipPage::CDsMembershipPage
//
//-----------------------------------------------------------------------------
CDsMembershipPage::CDsMembershipPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                     HWND hNotifyObj, DWORD dwFlags,
                                     BOOL fSecPrinciple) :
    m_pList(NULL),
    m_pwzObjDomain(NULL),
    m_bstrDomPath(NULL),
    m_pObjSID(NULL),
    m_pPriGrpLI(NULL),
    m_dwOriginalPriGroup(0),
    m_fSecPrinciple(fSecPrinciple),
    m_fMixed(TRUE),
    m_dwGrpType(0),
    m_fPriGrpWritable(FALSE),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsMembershipPage,CDsMembershipPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsMembershipPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsMembershipPage::~CDsMembershipPage
//
//-----------------------------------------------------------------------------
CDsMembershipPage::~CDsMembershipPage()
{
  TRACE(CDsMembershipPage,~CDsMembershipPage);
  DO_DEL(m_pList);
  DO_DEL(m_pwzObjDomain);
  if (m_bstrDomPath)
  {
    SysFreeString(m_bstrDomPath);
  }
  DO_DEL(m_pObjSID);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateMembershipPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateMembershipPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                     PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                     DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
                     HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateMembershipPage);

    CDsMembershipPage * pPageObj = new CDsMembershipPage(pDsPage, pDataObj,
                                                         hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo);

    return pPageObj->CreatePage(phPage);
    

}

//+----------------------------------------------------------------------------
//
//  Function:   CreateNonSecMembershipPage
//
//  Synopsis:   Creates an instance of a reverse membership page for non-
//              security-principles (like Contact).
//
//-----------------------------------------------------------------------------
HRESULT
CreateNonSecMembershipPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                           PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                           DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
                           HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateNonSecMembershipPage);

    CDsMembershipPage * pPageObj = new CDsMembershipPage(pDsPage, pDataObj,
                                                         hNotifyObj, dwFlags,
                                                         FALSE);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CDsMembershipPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsMembershipPage::OnInitDialog(LPARAM)
{
    TRACE(CDsMembershipPage,OnInitDialog);
    HRESULT hr = S_OK;
    Smart_PADS_ATTR_INFO spAttrs;
    PWSTR rgpwzAttrNames[] = {g_wzObjectSID, g_wzPrimaryGroup};
    DWORD cAttrs = 0, i;
    CWaitCursor WaitCursor;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    if (_wcsicmp(GetObjClass(), g_wzGroup) == 0)
    {
        GetGroupType(this, &m_dwGrpType);
        GetDomainMode(this, &m_fMixed);

        if (m_dwGrpType & (GROUP_TYPE_ACCOUNT_GROUP | GROUP_TYPE_UNIVERSAL_GROUP))
        {
            // If a Global or Universal group, it can be a member of an
            // external, uplevel domain, for which we need the SID.
            //
            cAttrs = 1;
        }
    }

    if (m_fSecPrinciple)
    {
        cAttrs = 2;
    }

    //
    // Initialize the membership list.
    //
    m_pList = new CDsMembershipList(m_hPage, IDC_MEMBER_LIST);

    CHECK_NULL_REPORT(m_pList, m_hPage, return S_OK);

    hr = m_pList->Init();

    CHECK_HRESULT(hr, return S_OK);

    if (cAttrs)
    {
        //
        // Get the SID and perhaps the Primary Group attribute values.
        //
        hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, cAttrs, &spAttrs, &cAttrs);

        if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, m_hPage))
        {
            return S_OK;
        }

        for (i = 0; i < cAttrs; i++)
        {
            if (_wcsicmp(spAttrs[i].pszAttrName, g_wzPrimaryGroup) == 0)
            {
                m_dwOriginalPriGroup = spAttrs[i].pADsValues->Integer;

                continue;
            }

            if (_wcsicmp(spAttrs[i].pszAttrName, g_wzObjectSID) == 0)
            {
                m_pObjSID = new BYTE[spAttrs[i].pADsValues->OctetString.dwLength];

                CHECK_NULL_REPORT(m_pObjSID, m_hPage, return S_OK);

                memcpy(m_pObjSID, spAttrs[i].pADsValues->OctetString.lpValue,
                       spAttrs[i].pADsValues->OctetString.dwLength);
            }
        }
    }

    if (m_fSecPrinciple)
    {
        m_fPriGrpWritable = CheckIfWritable(g_wzPrimaryGroup);

        PWSTR pwzPath;

        hr = GetDomainScope(this, &m_bstrDomPath);

        CHECK_HRESULT(hr, return S_OK);
        dspDebugOut((DEB_ITRACE, "Object's domain: %ws\n", m_bstrDomPath));

        if (m_dwOriginalPriGroup)
        {
            PTSTR ptzName, ptzCanEx;
            PWSTR pwzCanEx, pwzCleanDN;

            hr = ConvertRIDtoName(m_dwOriginalPriGroup, &ptzName, &pwzPath);

            if (hr == S_FALSE)
            {
                // No group found, must have been deleted.
                //
                m_dwOriginalPriGroup = 0;
                goto SetBtns;
            }
            CHECK_HRESULT(hr, return S_OK);

            SetDlgItemText(m_hPage, IDC_PRI_GRP_STATIC, ptzName);
        
            hr = SkipPrefix(pwzPath, &pwzCleanDN);

            delete[] ptzName;
            delete[] pwzPath;
            CHECK_HRESULT_REPORT(hr, m_hPage, return S_OK);

            hr = CrackName(pwzCleanDN, &pwzCanEx, GET_OBJ_CAN_NAME_EX, m_hPage);

            CHECK_HRESULT(hr, delete pwzCleanDN; return S_OK);

            if (!UnicodeToTchar(pwzCanEx, &ptzCanEx))
            {
                delete pwzCleanDN;
                LocalFreeStringW(&pwzCanEx);
                hr = E_OUTOFMEMORY;
                REPORT_ERROR(hr, m_hPage);
                return S_OK;
            }
            LocalFreeStringW(&pwzCanEx);

            CMemberListItem * pListItem;

            pListItem = new CMemberListItem;

            CHECK_NULL_REPORT(pListItem, m_hPage, return S_OK);

            pListItem->m_pwzDN = pwzCleanDN;
            pListItem->m_fIsPrimary = TRUE;
            pListItem->m_ptzName = ptzCanEx;
            pListItem->m_fIsAlreadyMember = TRUE;

            hr = m_pList->InsertIntoList(ptzCanEx, pListItem);

            if (FAILED(hr))
            {
                delete pListItem;
                delete ptzCanEx;
                return S_OK;
            }

            m_pPriGrpLI = pListItem;
        }
        if (!m_fPriGrpWritable)
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN), FALSE);
        }
    }
    else
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN), FALSE);
        ShowWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN), SW_HIDE);
        ShowWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_LABEL), SW_HIDE);
        ShowWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_STATIC), SW_HIDE);
        ShowWindow(GetDlgItem(m_hPage, IDC_PRI_GROUP_WARN_STATIC), SW_HIDE);
        ShowWindow(GetDlgItem(m_hPage, IDC_DIVIDING_LINE), SW_HIDE);
        if (_wcsicmp(GetObjClass(), g_wzGroup) == 0)
        {
            ShowWindow(GetDlgItem(m_hPage, IDC_GROUP_NOTE_STATIC), SW_SHOW);

            if ((m_dwGrpType & GROUP_TYPE_BUILTIN_LOCAL_GROUP) ||
                (m_dwGrpType & GROUP_TYPE_RESOURCE_GROUP))
            {
                if (m_dwGrpType & GROUP_TYPE_BUILTIN_LOCAL_GROUP)
                {
                    // Since builtin groups cannot be added to other groups,
                    // disable the add button and add a note to that effect.
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BTN), FALSE);
                }

                PTSTR ptz;

                if (!LoadStringToTchar((m_dwGrpType & GROUP_TYPE_BUILTIN_LOCAL_GROUP) ?
                                       IDS_BUILTIN_NO_NEST : IDS_LOCAL_GROUP_ONLY,
                                       &ptz))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                    return S_OK;
                }

                SetDlgItemText(m_hPage, IDC_GROUP_NOTE_STATIC, ptz);

                delete ptz;
            }
        }
    }

SetBtns:
    EnableWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN), FALSE);

    hr = FillMembershipList();

    //Set the focus on first item in the list
    ListView_SetItemState(GetDlgItem(m_hPage, IDC_MEMBER_LIST), 0,
                          LVIS_SELECTED,LVIS_SELECTED);


    CHECK_HRESULT(hr, return S_OK);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsMembershipPage::OnApply(void)
{
    TRACE(CDsMembershipPage,OnApply);
    HRESULT hr = S_OK;
    IDirectoryObject * pIADObj = NULL;
    IADsGroup * pIADGroup = NULL;
    IUnknown * pUnknown;
    ADSVALUE PriGrpValue = {ADSTYPE_INTEGER, 0};
    PADSVALUE pPriGrpValues = &PriGrpValue;
    ADS_ATTR_INFO PriGrpInfo = {g_wzPrimaryGroup, ADS_ATTR_UPDATE,
                                ADSTYPE_INTEGER, pPriGrpValues, 1};
    ADSVALUE MemberValue = {ADSTYPE_DN_STRING, NULL};
    PADSVALUE pMemberValues = &MemberValue;
    ADS_ATTR_INFO MemberInfo = {g_wzMemberAttr, ADS_ATTR_APPEND,
                                ADSTYPE_DN_STRING, pMemberValues, 1};
    PADS_ATTR_INFO pAttr = &MemberInfo;
    DWORD cModified;
    BOOL fBindFailed;
    CWaitCursor WaitCursor;

    //
    // Read the list of groups and do additions. Note that additions must be
    // done before setting primary which in turn must be done before deletions.
    //
    int i = 0, cGroups = m_pList->GetCount();
    CMemberListItem * pItem, * pPriGrp = NULL;
    CSmartWStr csCleanObjName;
    CStrW strSIDname, strNT4name;

    hr = SkipPrefix(m_pwszObjPathName, &csCleanObjName);

    CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

    if (cGroups > 0)
    {
        while (i < cGroups)
        {
            if (FAILED(m_pList->GetItem(i, &pItem)))
            {
                dspAssert(FALSE && "List Error");
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
            if (!pItem)
            {
                dspAssert(pItem);
                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            if (pItem->m_fIsPrimary)
            {
                pPriGrp = pItem;
            }

            if (pItem->m_fIsAlreadyMember)
            {
                i++;
                continue;
            }

            dspAssert(pItem->m_pwzDN);

            hr = BindToGroup(pItem, TRUE, &pUnknown, &fBindFailed);

            if (fBindFailed)
            {
                // Error not reported in BindToGroup.
                //
                if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                {
                    ErrMsg(IDS_ERRMSG_NO_LONGER_EXISTS, m_hPage);
                    m_pList->RemoveListItem(i);
                    cGroups--;
                    hr = S_OK;
                    continue;
                }
                if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr ||
                    HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
                {
                    dspDebugOut((DEB_ERROR, "group open failed with error 0x%x\n", hr));
                    ReportNoGroupAccess(pItem->m_ptzName, m_hPage);
                    m_pList->RemoveListItem(i);
                    cGroups--;
                    hr = S_OK;
                    continue;
                }

                // NTRAID#NTBUG9-639525-2002/06/18-JeffJon
                // With sign/seal turned on connecting to a pre-SP3 W2K server
                // may fail with one of these errors. If so, then show a special
                // error message.

                if (HRESULT_CODE(hr) == ERROR_DS_UNWILLING_TO_PERFORM ||
                    HRESULT_CODE(hr) == ERROR_DS_SERVER_DOWN ||
                    HRESULT_CODE(hr) == ERROR_DS_UNAVAILABLE)
                {
                    dspDebugOut((DEB_ERROR, "group open failed with error 0x%x\n", hr));
                    ReportNoGroupAccessSignSeal(pItem->m_ptzName, m_hPage);
                    m_pList->RemoveListItem(i);
                    cGroups--;
                    hr = S_OK;
                    continue;
                }

                REPORT_ERROR(hr, m_hPage);
                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            if (FAILED(hr))
            {
                // Error was reported in BindToGroup.
                //
                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            if (DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN == pItem->m_ulScopeType)
            {
                if (strNT4name.IsEmpty())
                {
                    // Convert this group's name to NT4 style and then do the
                    // add using the WINNT provider.
                    //
                    PWSTR pwzGrpNT4name;

                    hr = CrackName(csCleanObjName, &pwzGrpNT4name, GET_OBJ_NT4_NAME, m_hPage);

                    CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

                    // Make the NT path an ADSI path. The path cracker doesn't
                    // work for WINNT provider paths.
                    //
                    PWSTR pwzSlash = wcschr(pwzGrpNT4name, L'\\');

                    if (pwzSlash)
                    {
                        *pwzSlash = L'/';
                    }

                    strNT4name = g_wzWINNTPrefix;
                    strNT4name += pwzGrpNT4name;

                    LocalFreeStringW(&pwzGrpNT4name);
                }

                dspDebugOut((DEB_ITRACE, "Adding this group as %ws\n", const_cast<LPWSTR>((LPCWSTR)strNT4name)));

                pIADGroup = (IADsGroup *)pUnknown;

                hr = pIADGroup->Add(CComBSTR((LPCWSTR)strNT4name));

                DO_RELEASE(pIADGroup);
            }
            else
            {
                if (DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN == pItem->m_ulScopeType)
                {
                    // Convert this group's SID to string form.
                    //
                    if (strSIDname.IsEmpty())
                    {
                        dspAssert(m_pObjSID);
                        if (!m_pObjSID)
                        {
                            continue;
                        }

                        ConvertSidToPath(m_pObjSID, strSIDname);
                    }

                    MemberValue.DNString = const_cast<LPWSTR>((LPCWSTR)strSIDname);
                }
                else
                {
                    MemberValue.DNString = csCleanObjName;
                }

                dspDebugOut((DEB_ITRACE, "Adding this group as %ws\n", MemberValue.DNString));

                pIADObj = (IDirectoryObject *)pUnknown;

                hr = pIADObj->SetObjectAttributes(pAttr, 1, &cModified);

                DO_RELEASE(pIADObj);
            }

            if (HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) == hr ||
                HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr)
            {
                dspDebugOut((DEB_ERROR, "group add failed with error 0x%x\n", hr));
                ReportNoGroupAccess(pItem->m_ptzName, m_hPage);
                m_pList->RemoveListItem(i);
                cGroups--;
                hr = S_OK;
                continue;
            }
            if (!CheckGroupUpdate(hr, m_hPage))
            {
                m_pList->RemoveListItem(i);
                cGroups--;
                continue;
            }

            pItem->m_fIsAlreadyMember = TRUE;

            i++;
        }
    }

    //
    // Set the primary group.
    //
    if (pPriGrp)
    {
        Smart_PADS_ATTR_INFO spAttrs;
        PWSTR rgpwzAttrNames[] = {g_wzObjectSID};
        DWORD cAttrs = 0;
        PSID pGroupSID = NULL;
        PUCHAR saCount;
        PULONG pGroupRID;

        if (!pPriGrp->IsSidSet())
        {
            CStrW strADsPath;

            hr = AddLDAPPrefix(pPriGrp->m_pwzDN, strADsPath);

            CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

            hr = DSAdminOpenObject(const_cast<PWSTR>((LPCWSTR)strADsPath), 
                                   IID_IDirectoryObject, 
                                   (PVOID *)&pIADObj);

            CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

            hr = pIADObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);

            DO_RELEASE(pIADObj);
            CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);
            dspAssert(spAttrs);

            pGroupSID = spAttrs->pADsValues->OctetString.lpValue;

            if (!IsValidSid(pGroupSID))
            {
                REPORT_ERROR(E_FAIL, m_hPage);
                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            if (!pPriGrp->SetSid(pGroupSID))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
        }
        else
        {
            pGroupSID = pPriGrp->GetSid();
        }

        // find RID part of SID
        //
        saCount = GetSidSubAuthorityCount(pGroupSID);
        pGroupRID = GetSidSubAuthority(pGroupSID, (ULONG)*saCount - 1);

        //        if ((m_dwOriginalPriGroup != *pGroupRID) && m_fPriGrpWritable)
        if (m_fPriGrpWritable)
        {
            PriGrpValue.Integer = *pGroupRID;

            pAttr = &PriGrpInfo;

            //
            // Write the changed primary group.
            //
            hr = m_pDsObj->SetObjectAttributes(pAttr, 1, &cModified);

            if (!CheckGroupUpdate(hr, m_hPage))
            {
                return PSNRET_INVALID_NOCHANGEPAGE;
            }
            EnableWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN), FALSE);
        }
    }

    //
    // Do the removals.
    //
    CMemberListItem * pDelItem = m_DelList.RemoveFirstItem();

    while (pDelItem)
    {
        PWSTR pwzItem = NULL;

        hr = BindToGroup(pDelItem, FALSE, (IUnknown **)&pIADGroup, &fBindFailed);

        if (fBindFailed)
        {
            WaitCursor.SetOld();
            //
            // Error not reported in BindToGroup.
            //
            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                ErrMsg(IDS_ERRMSG_NO_LONGER_EXISTS, m_hPage);
                delete pDelItem;
                pDelItem = m_DelList.RemoveFirstItem();
                hr = S_OK;
                continue;
            }

            // NTRAID#NTBUG9-639525-2002/06/18-JeffJon
            // With sign/seal turned on connecting to a pre-SP3 W2K server
            // may fail with one of these errors. If so, then show a special
            // error message.

            if (HRESULT_CODE(hr) == ERROR_DS_UNWILLING_TO_PERFORM ||
                HRESULT_CODE(hr) == ERROR_DS_SERVER_DOWN ||
                HRESULT_CODE(hr) == ERROR_DS_UNAVAILABLE)
            {
                dspDebugOut((DEB_ERROR, "group open failed with error 0x%x\n", hr));
                ReportNoGroupAccessSignSeal(pDelItem->m_ptzName, m_hPage);
                delete pDelItem;
                pDelItem = m_DelList.RemoveFirstItem();
                hr = S_OK;
                continue;
            }

            REPORT_ERROR(hr, m_hPage);
            return PSNRET_INVALID_NOCHANGEPAGE;
        }

        if (FAILED(hr))
        {
            WaitCursor.SetOld();
            //
            // Error was reported in BindToGroup.
            //
            return PSNRET_INVALID_NOCHANGEPAGE;
        }

        CStrW strADPath;

        if (DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN == pDelItem->m_ulScopeType)
        {
            if (strNT4name.IsEmpty())
            {
                // Convert this group's name to NT4 style and then do the
                // remove using the WINNT provider.
                //
                PWSTR pwzGrpNT4name;

                hr = CrackName(csCleanObjName, &pwzGrpNT4name, GET_OBJ_NT4_NAME, m_hPage);

                CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

                // Make the NT path an ADSI path. The path cracker doesn't
                // work for WINNT provider paths.
                //
                PWSTR pwzSlash = wcschr(pwzGrpNT4name, L'\\');

                if (pwzSlash)
                {
                    *pwzSlash = L'/';
                }

                strNT4name = g_wzWINNTPrefix;
                strNT4name += pwzGrpNT4name;

                LocalFreeStringW(&pwzGrpNT4name);
            }

            pwzItem = const_cast<LPWSTR>((LPCWSTR)strNT4name);
        }
        else
        {
            if (DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN == pDelItem->m_ulScopeType)
            {
                // Find the FPO DN for this group.
                //
                CComBSTR cbstrDomain;
                CStrW strFPO, strDC;

                hr = GetObjectsDomain(this, pDelItem->m_pwzDN, &cbstrDomain);

                CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

                dspAssert(m_pObjSID);

                hr = FindFPO(m_pObjSID, cbstrDomain, strFPO);

                CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

                hr = GetLdapServerName(pIADGroup, strDC);

                strADPath = g_wzLDAPPrefix;
                strADPath += strDC;
                strADPath += L"/";
                strADPath += strFPO;

                pwzItem = const_cast<LPWSTR>((LPCWSTR)strADPath);
            }
            else
            {
                pwzItem = m_pwszObjPathName;
            }
        }

        dspDebugOut((DEB_ITRACE, "Removing member: %S from group %S\n",
                     pwzItem, pDelItem->m_pwzDN));

        hr = pIADGroup->Remove(CComBSTR(pwzItem));

        DO_RELEASE(pIADGroup);
        if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            WaitCursor.SetOld();
            ReportNoGroupAccess(pDelItem->m_ptzName, m_hPage);
        }
        else
        {
            CheckGroupUpdate(hr, m_hPage, FALSE, pDelItem->m_pwzDN);
        }
        hr = S_OK;

        delete pDelItem;

        pDelItem = m_DelList.RemoveFirstItem();
    }

    return (SUCCEEDED(hr)) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsMembershipPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (codeNotify == BN_CLICKED)
    {
        if (id == IDC_ADD_BTN)
        {
            InvokeGroupQuery();
        }
        if (id == IDC_RM_GRP_BTN)
        {
            RemoveMember();
        }
        if (id == IDC_PRI_GRP_BTN)
        {
            SetPrimaryGroup();
        }
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::OnNotify
//
//  Synopsis:   Handles list notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsMembershipPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    if (m_fInInit)
    {
        return 0;
    }
    switch (((LPNMHDR)lParam)->code)
    {
    case LVN_ITEMCHANGED:
        if (m_pList->GetSelectedCount() > 0)
        {
           EnableWindow(GetDlgItem(m_hPage, IDC_RM_GRP_BTN), TRUE);
        }
        else
        {
           EnableWindow(GetDlgItem(m_hPage, IDC_RM_GRP_BTN), FALSE);
        }

        if (m_fPriGrpWritable && m_pList->GetSelectedCount() == 1)
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN),
                         SelectionCanBePrimaryGroup());
        }
        else
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_PRI_GRP_BTN),
                         FALSE);
        }

        break;

    case NM_DBLCLK:
        //
        // Display properties for the selected item. First, find out
        // which item is selected.
        //
        CMemberListItem * pItem;

        if (!m_pList->GetCurListItem(NULL, NULL, &pItem))
        {
            break;
        }

        dspAssert(pItem);

        if (pItem->m_ulScopeType & DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN)
        {
          //
          // We cannot show the properties for downlevel users
          //
          // Put a useful message up
          PTSTR ptzTitle, ptzMsg;
          if (!LoadStringToTchar(IDS_MSG_NO_DOWNLEVEL_PROPERTIES, &ptzMsg))
          {
            break;
          }
          if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
          {
            break;
          }
          MessageBox(m_hPage, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);
          delete[] ptzTitle;
          delete[] ptzMsg;

          break;
        }
        PostPropSheet(pItem->m_pwzDN, this);
        break;
    }

    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsMembershipPage::OnDestroy(void)
{
    if (m_pList)
    {
        m_pList->ClearList();
    }

    CDsPropPageBase::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::IsSPInSameDomain
//
//  Synopsis:   Cracks the group DN to a domain name and compares it to the
//              domain name that was passed in.  Returns true if they are the
//              same or false otherwise.
//
//-----------------------------------------------------------------------------
bool
CDsMembershipPage::IsSPInSameDomain(PCWSTR pszGroupDN, PCWSTR pszDomainName)
{
   // Default to true because we want to show more information than
   // not enough

   bool result = true;

   PWSTR pszGroupDomainName = 0;

   do
   {
      // Validate parameters

      if (!pszGroupDN ||
          !pszDomainName)
      {
         dspAssert(pszGroupDN);
         dspAssert(pszDomainName);

         result = false;
         break;
      }


      // Crack the group DN to get it's domain name

      HRESULT hr = 
         CrackName(
            (PWSTR)pszGroupDN,
            &pszGroupDomainName,
            GET_FQDN_DOMAIN_NAME,
            GetHWnd());

      if (FAILED(hr) ||
          !pszGroupDomainName)
      {
         result = false;
         break;
      }

      // Now compare the group domain name to the current domain name

      result = _wcsicmp(pszGroupDomainName, pszDomainName) == 0;

   } while (false);

   if (pszGroupDomainName)
   {
      LocalFreeStringW(&pszGroupDomainName);
   }

   return result;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::FillMembershipList
//
//  Synopsis:   Read the membership attribute and fill the list view control.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipPage::FillMembershipList(void)
{
    HRESULT hr = S_OK;
    Smart_PADS_ATTR_INFO spAttrs;
    DWORD i, cAttrs = 0;
    WCHAR wzMembershipAttr[MAX_PATH] = L"memberOf;range=0-*";
    const WCHAR wcSep = L'-';
    const WCHAR wcEnd = L'*';
    const WCHAR wzFormat[] = L"memberOf;range=%ld-*";
    BOOL fMoreRemain = FALSE;
    PWSTR rgpwzAttrNames[] = {wzMembershipAttr};

    // NTRAID#NTBUG9-755716-2002/12/17-JeffJon
    // Get the domain name of the member so that we only show groups within
    // the same domain.

    CStr cstrDomainName;
    PWSTR pszDomainName = 0;
    PWSTR pszDN = 0;

    hr = SkipPrefix(m_pwszObjPathName, &pszDN);

    if (SUCCEEDED(hr) && pszDN)
    {
      hr = 
         CrackName(
            pszDN,
            &pszDomainName,
            GET_FQDN_DOMAIN_NAME,
            GetHWnd());

      // This should always succeed because it is 
      // just a syntactical crack of the name

      dspAssert(SUCCEEDED(hr));

      if (FAILED(hr))
      {
         dspAssert(!pszDomainName);
         if (pszDomainName)
         {
            LocalFreeStringW(&pszDomainName);
            pszDomainName = 0;
         }
      }
      else
      {
         cstrDomainName = pszDomainName;

         LocalFreeStringW(&pszDomainName);
      }

      delete[] pszDN;
    }

    //
    // Read the membership list from the object. First read the attribute off
    // of the actual object which will give all memberships in the object's
    // domain (including local groups which are not replicated to the GC).
    //
    do
    {
      hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);

      if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, m_hPage))
      {
          return hr;
      }

      if (cAttrs > 0 && spAttrs != NULL)
      {
        for (i = 0; i < spAttrs->dwNumValues; i++)
        {
            if (!cstrDomainName.IsEmpty() &&
                IsSPInSameDomain(spAttrs->pADsValues[i].CaseIgnoreString, cstrDomainName))
            {
               hr = m_pList->InsertIntoNewList(spAttrs->pADsValues[i].CaseIgnoreString);

               CHECK_HRESULT(hr, break);
            }
        }
        //
        // Check to see if there is more data. If the last char of the
        // attribute name string is an asterisk, then we have everything.
        //
        size_t cchEnd = wcslen(spAttrs->pszAttrName);

        fMoreRemain = spAttrs->pszAttrName[cchEnd - 1] != wcEnd;

        if (fMoreRemain)
        {
            PWSTR pwz = wcsrchr(spAttrs->pszAttrName, wcSep);
            if (!pwz)
            {
                dspAssert(FALSE && spAttrs->pszAttrName);
                fMoreRemain = FALSE;
            }
            else
            {
                pwz++; // move past the hyphen to the range end value.
                dspAssert(*pwz);
                long lEnd = _wtol(pwz);
                lEnd++; // start with the next value.
                wsprintfW(wzMembershipAttr, wzFormat, lEnd);
                dspDebugOut((DEB_ITRACE,
                             "Range returned is %ws, now asking for %ws\n",
                             spAttrs->pszAttrName, wzMembershipAttr));
            }
        }
      }
    } while (fMoreRemain);

    if (m_pList->GetCount() < 1)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_RM_GRP_BTN), FALSE);
    }

    //
    // If a group, but not a local group, then bind to the GC copy of the
    // object in order to obtain the universal group memberships outside of the
    // object's domain (and discard duplicates from the object's domain).
    //
    if (_wcsicmp(GetObjClass(), g_wzGroup) == 0 &&
        !(m_dwGrpType & GROUP_TYPE_RESOURCE_GROUP))
    {
        CComPtr <IDirectoryObject> spGcObj;
        spAttrs.Empty();

        hr = BindToGCcopyOfObj(this, m_pwszObjPathName, &spGcObj);

        if (SUCCEEDED(hr))
        {
            hr = spGcObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);
        }
        else
        {
            switch (hr)
            {
            case HRESULT_FROM_WIN32(ERROR_DS_OBJ_NOT_FOUND):
            case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
                MsgBox(IDS_MEMBERSHIP_OBJ_NOT_IN_GC, m_hPage);
                return S_OK;

            case HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN):
                MsgBox(IDS_NO_GC_FOR_MEMBERSHIP, m_hPage);
                return S_OK;

            default:
                {
                DWORD dwErr;
                WCHAR wszErrBuf[MAX_PATH+1];
                WCHAR wszNameBuf[MAX_PATH+1];

                ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);

                if (SEC_E_LOGON_DENIED == dwErr)
                {
                    MsgBox(IDS_NO_ACCESS_GC_FOR_MEMBERSHIP, m_hPage);
                    return S_OK;
                }
                else
                {
                    if (dwErr)
                    {
                        dspDebugOut((DEB_ERROR,
                                     "Extended Error 0x%x: %ws %ws <%s @line %d>.\n",
                                     dwErr, wszErrBuf, wszNameBuf, __FILE__, __LINE__));
                        ReportError(dwErr, IDS_ADS_ERROR_FORMAT, m_hPage);
                    }
                    else
                    {
                        dspDebugOut((DEB_ERROR, "Error %08lx <%s @line %d>\n",
                                     hr, __FILE__, __LINE__));
                        ReportError(hr, IDS_ADS_ERROR_FORMAT, m_hPage);
                    }
                }
                return hr;
                }
            }
        }

        if (cAttrs == 0 || spAttrs == NULL)
        {
            return S_OK;
        }

        for (i = 0; i < spAttrs->dwNumValues; i++)
        {
            hr = m_pList->MergeIntoList(spAttrs->pADsValues[i].CaseIgnoreString);

            CHECK_HRESULT(hr, break);
        }
    }

    if (m_pList->GetCount() < 1)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_RM_GRP_BTN), FALSE);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::InvokeGroupQuery
//
//  Synopsis:   Bring up the query dialog to search for groups.
//
//-----------------------------------------------------------------------------
void CDsMembershipPage::InvokeGroupQuery(void)
{
  HRESULT hr;
  CSmartWStr swzCleanDN;
  UINT i;
  CComBSTR cbstrDomain;
  CWaitCursor WaitCursor;

  hr = GetDomainScope(this, &cbstrDomain);

  CHECK_HRESULT_REPORT(hr, m_hPage, return);

  IDsObjectPicker * pObjSel;
  BOOL fIsObjSelInited;

  hr = GetObjSel(&pObjSel, &fIsObjSelInited);

  CHECK_HRESULT_REPORT(hr, m_hPage, return);

  if (!fIsObjSelInited)
  {
    CStrW strDC;
    hr = GetLdapServerName(m_pDsObj, strDC);

    CHECK_HRESULT_REPORT(hr, m_hPage, return);
    dspDebugOut((DEB_ITRACE, "ObjSel targetted to %ws\n", (LPCWSTR)strDC));

    DSOP_SCOPE_INIT_INFO rgScopes[5];
    DSOP_INIT_INFO InitInfo;

    ZeroMemory(rgScopes, sizeof(rgScopes));
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    // The first scope is the local domain.
    //
    rgScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    rgScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
    rgScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;
    rgScopes[0].pwzDcName = strDC;

    // The second scope is the local forest.
    //
    rgScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    rgScopes[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    rgScopes[1].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

    // The third scope is the GC.
    //
    rgScopes[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    rgScopes[2].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
    rgScopes[2].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

    // The fourth scope is uplevel external trusted domains.
    //
    rgScopes[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    rgScopes[3].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN;
    rgScopes[3].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

    // The fifth scope is downlevel external trusted domains.
    //
    rgScopes[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    rgScopes[4].flType = DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
    rgScopes[4].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                          DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS;

    if ((_wcsicmp(GetObjClass(), g_wzContact) == 0) ||
        (_wcsicmp(GetObjClass(), g_wzUser) == 0) ||
        (_wcsicmp(GetObjClass(), g_wzComputer) == 0) || 
        (_wcsicmp(GetObjClass(), g_wzInetOrgPerson) == 0)
        )
    {
        // The membership list for non-groups only shows group
        // memberships from the object's local domain. Thus, we
        // only show the local domain scope in the object picker.
        //
        InitInfo.cDsScopeInfos = 1;
        rgScopes[0].FilterFlags.Uplevel.flBothModes =
            DSOP_FILTER_UNIVERSAL_GROUPS_DL    |
            DSOP_FILTER_GLOBAL_GROUPS_DL       |
            DSOP_FILTER_GLOBAL_GROUPS_SE       |
            DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
            DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
            DSOP_FILTER_BUILTIN_GROUPS;
        rgScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
            DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }
    else if (_wcsicmp(GetObjClass(), g_wzFPO) == 0)
    {
        // FPOs can only be members of local groups.
        //
        InitInfo.cDsScopeInfos = 1;
        rgScopes[0].FilterFlags.Uplevel.flBothModes =
            DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
            DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
            DSOP_FILTER_BUILTIN_GROUPS;
        //rgScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
        //    DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    }
    else if (_wcsicmp(GetObjClass(), g_wzGroup) == 0)
    {
        // The membership list for groups only shows group memberships
        // from the object's local domain and from universal groups in
        // the forest. However, we show all permissible scopes in the
        // object picker.
        //
        switch (m_dwGrpType & (~GROUP_TYPE_SECURITY_ENABLED))
        {
        case GROUP_TYPE_ACCOUNT_GROUP: // Global group
            rgScopes[0].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_UNIVERSAL_GROUPS_DL    |
                DSOP_FILTER_GLOBAL_GROUPS_DL       |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
                DSOP_FILTER_BUILTIN_GROUPS;
            rgScopes[1].FilterFlags.Uplevel.flBothModes =
            rgScopes[2].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_UNIVERSAL_GROUPS_DL    |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
                DSOP_FILTER_BUILTIN_GROUPS;
            rgScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
                DSOP_FILTER_GLOBAL_GROUPS_SE;
            if (!m_fMixed)
            {
                rgScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
                    DSOP_FILTER_GLOBAL_GROUPS_SE |
                    DSOP_FILTER_UNIVERSAL_GROUPS_SE;
                rgScopes[1].FilterFlags.Uplevel.flNativeModeOnly =
                rgScopes[2].FilterFlags.Uplevel.flNativeModeOnly =
                    DSOP_FILTER_UNIVERSAL_GROUPS_SE;
            }
            rgScopes[3].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
                DSOP_FILTER_BUILTIN_GROUPS;
            if (m_dwGrpType & GROUP_TYPE_SECURITY_ENABLED)
            {
                rgScopes[4].FilterFlags.flDownlevel =
                    DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;
                InitInfo.cDsScopeInfos = 5; // all trusted domains.
            }
            else
            {                               // no downlevel domains for
                InitInfo.cDsScopeInfos = 4; // global distribution groups.
            }
            break;

        case GROUP_TYPE_RESOURCE_GROUP: // Local group.
            InitInfo.cDsScopeInfos = 1; // Only the local domain scope.
            rgScopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL;
            rgScopes[0].FilterFlags.Uplevel.flNativeModeOnly = DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
            break;

        case GROUP_TYPE_UNIVERSAL_GROUP:
            InitInfo.cDsScopeInfos = 4; // No downlevel external domains.
            rgScopes[0].FilterFlags.Uplevel.flBothModes =
            rgScopes[1].FilterFlags.Uplevel.flBothModes =
            rgScopes[2].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_UNIVERSAL_GROUPS_DL    |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
                DSOP_FILTER_BUILTIN_GROUPS;
            if (!m_fMixed)
            {
                rgScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
                rgScopes[1].FilterFlags.Uplevel.flNativeModeOnly =
                rgScopes[2].FilterFlags.Uplevel.flNativeModeOnly =
                    DSOP_FILTER_UNIVERSAL_GROUPS_SE;
            }
            rgScopes[3].FilterFlags.Uplevel.flBothModes =
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE |
                DSOP_FILTER_BUILTIN_GROUPS;
            break;
        }
    }
    else
    {
      // any other object class

      // set all the scopes to get all we can
      InitInfo.cDsScopeInfos = 5; 

      rgScopes[0].FilterFlags.Uplevel.flBothModes =
      rgScopes[1].FilterFlags.Uplevel.flBothModes =
      rgScopes[2].FilterFlags.Uplevel.flBothModes =
      rgScopes[3].FilterFlags.Uplevel.flBothModes =
      rgScopes[4].FilterFlags.Uplevel.flBothModes =
          DSOP_FILTER_INCLUDE_ADVANCED_VIEW  |
          DSOP_FILTER_BUILTIN_GROUPS         |
          DSOP_FILTER_UNIVERSAL_GROUPS_DL    |
          DSOP_FILTER_UNIVERSAL_GROUPS_SE    |
          DSOP_FILTER_GLOBAL_GROUPS_DL       |
          DSOP_FILTER_GLOBAL_GROUPS_SE       |
          DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
          DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
    }

    InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
    InitInfo.aDsScopeInfos = rgScopes;
    InitInfo.pwzTargetComputer = strDC;
    InitInfo.flOptions = DSOP_FLAG_MULTISELECT;

    hr = pObjSel->Initialize(&InitInfo);

    CHECK_HRESULT_REPORT(hr, m_hPage, return);

    ObjSelInited();
  }

  IDataObject * pdoSelections = NULL;

  hr = pObjSel->InvokeDialog(m_hPage, &pdoSelections);

  CHECK_HRESULT_REPORT(hr, m_hPage, return);

  if (hr == S_FALSE || !pdoSelections)
  {
    return;
  }

  CSmartWStr swzCleanGroup;
  CStr strWinNtName;
  FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
STGMEDIUM medium = {TYMED_NULL, NULL, NULL};

  hr = pdoSelections->GetData(&fmte, &medium);

  CHECK_HRESULT_REPORT(hr, m_hPage, return);

  PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

  if (!pSelList)
  {
    goto ExitCleanup;
  }

  WaitCursor.SetWait();

  // See if this object is a group. If so, don't allow it to be added to
  // itself.
  //
  if (_wcsicmp(m_pwszObjClass, g_wzGroup) == 0)
  {
    // Clean the group name so it can be compared with those returned by the
    // user's selection.
    //
    hr = SkipPrefix(m_pwszObjPathName, &swzCleanGroup);

    CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);
  }

  for (i = 0 ; i < pSelList->cItems; i++)
  {
      if (!pSelList->aDsSelection[i].pwzADsPath) continue;

      BOOL fExternal = FALSE;

      //
      // See if the group is from an external domain and flag it if so.
      //
      if (pSelList->aDsSelection[i].flScopeType == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN)
      {
          fExternal = TRUE;
      }

      if (pSelList->aDsSelection[i].flScopeType == DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN)
      {
          fExternal = TRUE;
          hr = SkipPrefix(pSelList->aDsSelection[i].pwzADsPath, &swzCleanDN, FALSE);
      }
      else
      {
          hr = SkipPrefix(pSelList->aDsSelection[i].pwzADsPath, &swzCleanDN);
      }

      CHECK_HRESULT_REPORT(hr, m_hPage, goto ExitCleanup);

      if ((BOOL)swzCleanGroup)
      {
          // See if the user is trying to add the group to itself.
          //
          if (_wcsicmp(swzCleanDN, swzCleanGroup) == 0)
          {
              if (pSelList->cItems == 1)
              {
                  ErrMsg(IDS_ERROR_GRP_SELF, m_hPage);
                  goto ExitCleanup;
              }
              continue;
          }
      }
      //
      // Check if the item is in the delete list, if so remove it.
      //
      CMemberListItem * pItem;

      pItem = m_DelList.FindItemRemove(swzCleanDN);

      if (pItem)
      {
          hr = m_pList->InsertIntoList(pItem);
      }
      else
      {
          if (fExternal)
          {
              hr = m_pList->InsertExternalIntoList(swzCleanDN,
                                                   pSelList->aDsSelection[i].flScopeType);
          }
          else
          {
              hr = m_pList->InsertIntoList(swzCleanDN);
          }
      }

      if (hr == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS))
      {
          continue;
      }
      CHECK_HRESULT(hr, goto ExitCleanup);
  }

  SetDirty();
ExitCleanup:
  GlobalUnlock(medium.hGlobal);
  ReleaseStgMedium(&medium);
  pdoSelections->Release();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::RemoveMember
//
//  Synopsis:   Remove the user from the currently selected group.
//
//-----------------------------------------------------------------------------
void
CDsMembershipPage::RemoveMember(void)
{
    if (!m_pList)
    {
        return;
    }
    int* pIndex;
    CMemberListItem ** ppItem;
    int nSelected = 0;

    //
    // Compose the confirmation message and post it.
    //
    PTSTR ptzMsg = NULL, ptzUserName = NULL;

    if (!UnicodeToTchar(m_pwszRDName, &ptzUserName))
    {
        return;
    }

    TCHAR szMsgFormat[160];
    if (!LoadStringReport(IDS_RM_USR_FROM_GRP, szMsgFormat, 160, m_hPage))
    {
        delete ptzUserName;
        return;
    }

	//NTRAID#NTBUG9-571996-2002/03/10-jmessec   Can't use _tcslen(szMsgFormat) in buffer length calculation; %25s could be passed
    size_t len = _tcslen(szMsgFormat) + _tcslen(ptzUserName);

    ptzMsg = new TCHAR[len + 1];
    CHECK_NULL_REPORT(ptzMsg, m_hPage, delete ptzUserName; return;);
    wsprintf(ptzMsg, szMsgFormat, ptzUserName);

    DO_DEL(ptzUserName);

    TCHAR szTitle[80];
    if (!LoadStringReport(IDS_RM_USR_TITLE, szTitle, 80, m_hPage))
    {
        delete[] ptzMsg;
        return;
    }

    LONG iRet;
    iRet = MessageBox(m_hPage, ptzMsg, szTitle, MB_YESNO | MB_ICONWARNING|MB_DEFBUTTON2);
    if (ptzMsg)
    {
       delete[] ptzMsg;
       ptzMsg = 0;
    }

    if (iRet == IDNO)
    {
        //
        // The user declined, so go home.
        //
        return;
    }

    CWaitCursor cWait;
    
    if (!m_pList->GetCurListItems(&pIndex, NULL, &ppItem, &nSelected))
    {
        return;
    }

    for (int idx = 0; idx < nSelected; idx++)
    {
      if (!ppItem[idx])
      {
          delete[] pIndex;
          delete[] ppItem;
          return;
      }

      if (ppItem[idx]->IsPrimary())
      {
          ErrMsg(IDS_RM_PRI_GRP, m_hPage);
          continue;
      }

      //
      // Put the item into the delete list and remove it from the list box.
      //
      if (!m_DelList.AddItem(ppItem[idx]))
      {
          REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
          delete[] pIndex;
          delete[] ppItem;
          return;
      }

      m_pList->RemoveListItem(pIndex[idx]);

      for (int idx2 = idx; idx2 < nSelected; idx2++)
      {
        if (pIndex[idx2] > pIndex[idx])
        {
          pIndex[idx2]--;
        }
      }

      SetDirty();
    }
    //
    // Disable the Remove button, since nothing in the list box should have
    // the selection at this point.
    //
    //Since Remove Button has focus now, set focus to add button
    //before disabling and make it the default button

    SetFocus(GetDlgItem(m_hPage,IDC_ADD_BTN));
    PostMessage(GetDlgItem(m_hPage, IDC_ADD_BTN), BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));

    PostMessage(GetDlgItem(m_hPage, IDC_RM_GRP_BTN), BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
    EnableWindow(GetDlgItem(m_hPage, IDC_RM_GRP_BTN), FALSE);

    delete[] pIndex;
    delete[] ppItem;

}


//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::SelectionCanBePrimaryGroup
//
//  Synopsis:   Evaluate the current selection and return true if
//              is a candidate for primary group (i.e. is it in the
//              same domain as the user object and is a security-enabled
//              account (global) or universal type?)
//
//-----------------------------------------------------------------------------
BOOL
CDsMembershipPage::SelectionCanBePrimaryGroup(void)
{
    if (!m_pObjSID || !m_pList)
    {
        return FALSE;
    }
    HRESULT hr;
    Smart_PADS_ATTR_INFO spAttrs;
    PWSTR rgpwzAttrNames[] = {g_wzGroupType, g_wzObjectSID};
    DWORD cAttrs = 0;
    PSID pGroupSID = NULL;
    CComPtr <IDirectoryObject> pGroup;

    CMemberListItem * pItem;

    if (!m_pList->GetCurListItem(NULL, NULL, &pItem))
    {
        return FALSE;
    }

    if (!pItem)
    {
        REPORT_ERROR(E_FAIL, m_hPage);
        return FALSE;
    }

    if (pItem->IsPrimary())
    {
        // Item already primary group.
        //
        return FALSE;
    }

    if (!pItem->IsSidSet() || !pItem->IsCanBePrimarySet())
    {
        CStrW strADsPath;
        //
        // If either is unset, get both. Note that this is checked here (on
        // demand, so to speak) rather than at list filling time because to
        // have to bind to each group member at that point would significantly
        // slow list filling.
        //
        hr = AddLDAPPrefix(pItem->m_pwzDN, strADsPath);

        CHECK_HRESULT_REPORT(hr, m_hPage, return FALSE);

        hr = DSAdminOpenObject(const_cast<PWSTR>((LPCWSTR)strADsPath), 
                               IID_IDirectoryObject,
                               (PVOID *)&pGroup);

        if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            ErrMsg(IDS_ERRMSG_NO_LONGER_EXISTS, m_hPage);
            return FALSE;
        }
        if (hr == 0x80070051)
        {
            // On subsequent network failures, ADSI returns this error code which
            // is not documented anywhere. I'll turn it into a documented error
            // code which happens to be the code returned on the first failure.
            //
            hr = HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP);
        }
        if (hr == HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP))
        {
            ErrMsg(IDS_ERRMSG_NO_DC_RESPONSE, m_hPage);
            return FALSE;
        }
        CHECK_HRESULT_REPORT(hr, m_hPage, return FALSE);

        hr = pGroup->GetObjectAttributes(rgpwzAttrNames, 2, &spAttrs, &cAttrs);

        CHECK_HRESULT_REPORT(hr, m_hPage, return FALSE);

        dspAssert(cAttrs == 2 && spAttrs && spAttrs[0].pADsValues && spAttrs[1].pADsValues);

        for (DWORD i = 0; i < 2; i++)
        {
            if (_wcsicmp(spAttrs[i].pszAttrName, g_wzGroupType) == 0)
            {
                if ((spAttrs[i].pADsValues->Integer & GROUP_TYPE_SECURITY_ENABLED) &&
                    (spAttrs[i].pADsValues->Integer & (GROUP_TYPE_ACCOUNT_GROUP | GROUP_TYPE_UNIVERSAL_GROUP)))
                {
                    pItem->SetCanBePrimary(TRUE);
                }
                else
                {
                    pItem->SetCanBePrimary(FALSE);
                }
                continue;
            }
            if (_wcsicmp(spAttrs[i].pszAttrName, g_wzObjectSID) == 0)
            {
                pGroupSID = spAttrs[i].pADsValues->OctetString.lpValue;

                if (!IsValidSid(pGroupSID))
                {
                    REPORT_ERROR(E_FAIL, m_hPage);
                    return FALSE;
                }

                if (!pItem->SetSid(pGroupSID))
                {
                    REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                    return FALSE;
                }
                continue;
            }
        }
    }
    else
    {
        pGroupSID = pItem->GetSid();
    }

    return(EqualPrefixSid(pGroupSID, m_pObjSID) && pItem->CanBePrimary());
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::SetPrimaryGroup
//
//  Synopsis:   Designate currently selected group as the primary.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipPage::SetPrimaryGroup(void)
{
    HRESULT hr;
    IDirectoryObject * pGroup = NULL;
    Smart_PADS_ATTR_INFO spAttrs;
    PWSTR rgpwzAttrNames[] = {g_wzObjectSID};
    DWORD cAttrs = 0;
    PSID pGroupSID = NULL;

    CMemberListItem* pItem = NULL;
    CSmartPtr <TCHAR> sptzName;

    if (!m_pList->GetCurListItem(NULL, &sptzName, &pItem))
    {
        return E_FAIL;
    }

    if (!pItem)
    {
        REPORT_ERROR(E_FAIL, m_hPage);
        return E_FAIL;
    }

    if (pItem->IsPrimary())
    {
        // It is already set, nothing to do.
        //
        return S_OK;
    }

    if (!pItem->IsSidSet())
    {
        CStrW strADsPath;

        hr = AddLDAPPrefix(pItem->m_pwzDN, strADsPath);

        CHECK_HRESULT_REPORT(hr, m_hPage, return FALSE;);

        hr = DSAdminOpenObject(const_cast<PWSTR>((LPCWSTR)strADsPath), 
                               IID_IDirectoryObject,
                               (PVOID *)&pGroup);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = pGroup->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);
        DO_RELEASE(pGroup);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        pGroupSID = spAttrs->pADsValues->OctetString.lpValue;

        if (!IsValidSid(pGroupSID))
        {
            REPORT_ERROR(E_FAIL, m_hPage);
            return E_FAIL;
        }

        if (!pItem->SetSid(pGroupSID))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        pGroupSID = pItem->GetSid();
    }

    if (m_pPriGrpLI)
    {
        m_pPriGrpLI->m_fIsPrimary = FALSE;
    }

    pItem->m_fIsPrimary = TRUE;

    m_pPriGrpLI = pItem;

    // Update the text field that displays the prim. group.
    //
    SetDlgItemText(m_hPage, IDC_PRI_GRP_STATIC, sptzName);

    SetDirty();

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::ConvertRIDtoName
//
//  Synopsis:   Convert the RID to the object DN.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipPage::ConvertRIDtoName(DWORD priGroupRID, PTSTR * pptzName,
                                    PWSTR * ppwzDN)
{
    if (!m_pObjSID)
    {
        return E_FAIL;
    }
    HRESULT hr = S_OK;
    UCHAR * psaCount, i;
    PSID pSID = NULL;
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD rgRid[8];

    psaCount = GetSidSubAuthorityCount(m_pObjSID);

    if (psaCount == NULL)
    {
        REPORT_ERROR(GetLastError(), m_hPage);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    dspAssert(*psaCount <= 8);
    if (*psaCount > 8)
    {
        return E_FAIL;
    }

    for (i = 0; i < (*psaCount - 1); i++)
    {
        PDWORD pRid = GetSidSubAuthority(m_pObjSID, (DWORD)i);
        if (pRid == NULL)
        {
            REPORT_ERROR(GetLastError(), m_hPage);
            return HRESULT_FROM_WIN32(GetLastError());
        }
        rgRid[i] = *pRid;
    }

    rgRid[*psaCount - 1] = priGroupRID;

    for (i = *psaCount; i < 8; i++)
    {
        rgRid[i] = 0;
    }

    psia = GetSidIdentifierAuthority(m_pObjSID);

    if (psia == NULL)
    {
        REPORT_ERROR(GetLastError(), m_hPage);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (!AllocateAndInitializeSid(psia, *psaCount, rgRid[0], rgRid[1],
                                  rgRid[2], rgRid[3], rgRid[4],
                                  rgRid[5], rgRid[6], rgRid[7], &pSID))
    {
        REPORT_ERROR(GetLastError(), m_hPage);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    PWSTR rgpwzAttrNames[] = {g_wzName, g_wzADsPath};
    const WCHAR wzSearchFormat[] = L"(&(objectCategory=group)(objectSid=%s))";
    PWSTR pwzSID;
    CStr strSearchFilter;

    hr = ADsEncodeBinaryData((PBYTE)pSID, GetLengthSid(pSID), &pwzSID);

    FreeSid(pSID);
    CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

    strSearchFilter.Format(wzSearchFormat, pwzSID);

    FreeADsMem(pwzSID);

    CDSSearch Search;
    hr = Search.Init(m_bstrDomPath);

    CHECK_HRESULT_REPORT(hr, m_hPage, return hr;);

    Search.SetFilterString(const_cast<LPWSTR>((LPCTSTR)strSearchFilter));

    Search.SetAttributeList(rgpwzAttrNames, 2);
    Search.SetSearchScope(ADS_SCOPE_SUBTREE);

    hr = Search.DoQuery();

    if (!CHECK_ADS_HR(&hr, m_hPage))
    {
        return hr;
    }

    hr = Search.GetNextRow();

    if (hr == S_ADS_NOMORE_ROWS)
    {
        // No object has a matching RID, the primary group must have been
        // deleted. Return S_FALSE to denote this condition.
        //
        hr = S_FALSE;
        return hr;
    }
    CHECK_HRESULT_REPORT(hr, m_hPage, return hr);
    PWSTR pwzPriGroupPath;
    PTSTR ptzPriGroupName;
    ADS_SEARCH_COLUMN Column;

    hr = Search.GetColumn(g_wzADsPath, &Column);

    CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

    if (!AllocWStr(Column.pADsValues->CaseIgnoreString, &pwzPriGroupPath))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        Search.FreeColumn(&Column);
        return hr;
    }

    Search.FreeColumn(&Column);

    hr = Search.GetColumn(g_wzName, &Column);

    CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

    if (!UnicodeToTchar(Column.pADsValues->CaseIgnoreString, &ptzPriGroupName))
    {
        REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        Search.FreeColumn(&Column);
        return hr;
    }

    Search.FreeColumn(&Column);

    *pptzName = ptzPriGroupName;
    *ppwzDN = pwzPriGroupPath;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMembershipPage::BindToGroup
//
//  Synopsis:   Derive the correct name and then bind to the group for the
//              add or remove operation.
//
//-----------------------------------------------------------------------------
HRESULT
CDsMembershipPage::BindToGroup(CMemberListItem * pItem,
                               BOOL fAdd,
                               IUnknown ** ppUnk,
                               PBOOL pfBindFailed)
{
    HRESULT hr;
    CStrW strOtherGrpPath;
    CComPtr<IADsPathname> spPathCracker;

    *pfBindFailed = FALSE;

    hr = GetADsPathname(spPathCracker);

    CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

    if (DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN == pItem->m_ulScopeType)
    {
        PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
        DWORD dwErr;

        hr = spPathCracker->Set(CComBSTR(L"WinNT"),ADS_SETTYPE_PROVIDER);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = spPathCracker->Set(CComBSTR(pItem->m_pwzDN), ADS_SETTYPE_DN);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);
#ifdef _DEBUG
        long nElem;
        hr = spPathCracker->GetNumElements(&nElem);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);
        dspAssert(2 == nElem);
#endif // _DEBUG
        CComBSTR bstrObject;

        hr = spPathCracker->GetElement(0, &bstrObject);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = spPathCracker->RemoveLeafElement();

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);
        CComBSTR bstrDomain;

        hr = spPathCracker->GetElement(0, &bstrDomain);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        dwErr = DsGetDcNameW(NULL, bstrDomain, NULL, NULL, DS_RETURN_FLAT_NAME,
                             &pDCInfo);

        CHECK_WIN32_REPORT(dwErr, m_hPage, return hr);

        hr = spPathCracker->AddLeafElement(CComBSTR(pDCInfo->DomainControllerName + 2));

        NetApiBufferFree(pDCInfo);
        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = spPathCracker->AddLeafElement(bstrObject);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);
        CComBSTR bstrPath;

        hr = spPathCracker->Retrieve(ADS_FORMAT_WINDOWS, &bstrPath);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        strOtherGrpPath = bstrPath;
        strOtherGrpPath += L",";        // Appending the object class
        strOtherGrpPath += g_wzGroup;   // speeds things up

        hr = 
           DSAdminOpenObject(
              const_cast<PWSTR>((LPCWSTR)strOtherGrpPath),
              IID_IADsGroup, 
              (PVOID *)ppUnk);
    }
    else if (DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN == pItem->m_ulScopeType)
    {
        PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
        DWORD dwErr = 0;
        PWSTR pwzDomain;

        hr = spPathCracker->Set(CComBSTR(L"LDAP"), ADS_SETTYPE_PROVIDER);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = CrackName(pItem->m_pwzDN, &pwzDomain, GET_DNS_DOMAIN_NAME, m_hPage);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        dwErr = DsGetDcNameW(NULL, pwzDomain, NULL, NULL, DS_RETURN_DNS_NAME,
                             &pDCInfo);

        LocalFreeStringW(&pwzDomain);
        CHECK_WIN32_REPORT(dwErr, m_hPage, return hr);

        CHECK_NULL_REPORT(pDCInfo->DomainControllerName, m_hPage, return E_FAIL);

        dspDebugOut((DEB_ITRACE, "Setting group path servername: %S\n",
                     pDCInfo->DomainControllerName + 2));
        hr = spPathCracker->Set(CComBSTR(pDCInfo->DomainControllerName + 2), ADS_SETTYPE_SERVER);

        NetApiBufferFree(pDCInfo);
        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = spPathCracker->Set(CComBSTR(pItem->m_pwzDN), ADS_SETTYPE_DN);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);
        CComBSTR bstrPath;

        hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &bstrPath);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        dspDebugOut((DEB_ITRACE, "Opening external group: %S\n",
                     bstrPath));
        hr = DSAdminOpenObject(bstrPath, 
                               (fAdd) ? IID_IDirectoryObject : IID_IADsGroup,
                               (PVOID *)ppUnk);
    }
    else
    {
        hr = AddLDAPPrefix(pItem->m_pwzDN, strOtherGrpPath, TRUE);

        CHECK_HRESULT_REPORT(hr, m_hPage, return hr);

        hr = DSAdminOpenObject(const_cast<PWSTR>((LPCWSTR)strOtherGrpPath),
                               (fAdd) ? IID_IDirectoryObject : IID_IADsGroup,
                               (PVOID *)ppUnk);
    }

    if (FAILED(hr))
    {
        // If here, the failure is from DSAdminOpenObject.
        //
        *pfBindFailed = TRUE;
        return hr;
    }

    dspDebugOut((DEB_ITRACE, "Adding this group to group %ws\n", strOtherGrpPath));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   ReportNoGroupAccessError
//
//  Synopsis:   Posts the access-denied error message. The nMessageID
//              must specify a string resource that has exactly one string
//              format token.
//
//-----------------------------------------------------------------------------
void
ReportNoGroupAccessError(PTSTR ptzCanName, HWND hPage, UINT nMessageID)
{
    PTSTR ptzTitle, ptzFormat, ptzMsg, ptzReturn;
    CStr csName = ptzCanName;

    if (nMessageID == 0)
    {
        goto FatalError;
    }

    if (!LoadStringToTchar(IDS_MSG_TITLE, &ptzTitle))
    {
        goto FatalError;
    }
    if (!LoadStringToTchar(nMessageID, &ptzFormat))
    {
        delete ptzTitle;
        goto FatalError;
    }

    ptzReturn = _tcschr(csName, TEXT('\n'));

    if (ptzReturn) *ptzReturn = TEXT('/');

	//NTRAID#NTBUG9-571996-2002/03/10-jmessec   Can't use lstrlen(ptzFormat) in buffer length computation; %25s could be passed in
    ptzMsg = new TCHAR[lstrlen(ptzCanName) + lstrlen(ptzFormat) + 1];

    CHECK_NULL_REPORT(ptzMsg, hPage, return);

    wsprintf(ptzMsg, ptzFormat, csName);

    MessageBox(hPage, ptzMsg, ptzTitle, MB_OK | MB_ICONEXCLAMATION);

    delete ptzFormat;
    delete ptzTitle;
    delete[] ptzMsg;

    return;

FatalError:
    MessageBoxA(hPage, "A Fatal Error has occured!", "Active Directory Error",
                MB_OK | MB_ICONEXCLAMATION);
}

//+----------------------------------------------------------------------------
//
//  Function:   ReportNoGroupAccess
//
//  Synopsis:   Posts the access-denied error message.
//
//-----------------------------------------------------------------------------
void
ReportNoGroupAccess(PTSTR ptzCanName, HWND hPage)
{
    ReportNoGroupAccessError(ptzCanName, hPage, IDS_ERRMSG_NO_GROUP_ACCESS);
}

//+----------------------------------------------------------------------------
//
//  Function:   ReportNoGroupAccessSignSeal
//
//  Synopsis:   Posts the sign/seal error message.
//
//-----------------------------------------------------------------------------
void
ReportNoGroupAccessSignSeal(PTSTR ptzCanName, HWND hPage)
{
    ReportNoGroupAccessError(ptzCanName, hPage, IDS_ERRMSG_NO_GROUP_ACCESS_SIGN_SEAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\multi.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       multi.h
//
//  Contents:   DS multi-select object property pages header
//
//  Classes:    CDsMultiPageBase, CDsGenericMultiPage
//
//  History:    16-Nov-99 JeffJon created
//
//-----------------------------------------------------------------------------

#ifndef __MULTI_H_
#define __MULTI_H_

#include "proppage.h"
#include "user.h"


HRESULT CreateGenericMultiPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                               DWORD, const CDSSmartBasePathsInfo& basePathsInfo,
                               HPROPSHEETPAGE *);
HRESULT CreateMultiUserPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                               DWORD, const CDSSmartBasePathsInfo& basePathsInfo,
                               HPROPSHEETPAGE *);
HRESULT CreateMultiGeneralUserPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                                    DWORD, const CDSSmartBasePathsInfo& basePathsInfo,
                                    HPROPSHEETPAGE *);
HRESULT CreateMultiOrganizationUserPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                                        DWORD, const CDSSmartBasePathsInfo& basePathsInfo,
                                        HPROPSHEETPAGE*);
HRESULT CreateMultiAddressUserPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                                        DWORD, const CDSSmartBasePathsInfo& basePathsInfo,
                                        HPROPSHEETPAGE*);

//+----------------------------------------------------------------------------
//
//  Struct:     ATTR_MAP
//
//  Purpose:    For each attribute on a property page, relates the control
//              ID, the attribute name and the attribute type.
//
//  Notes:      The standard table-driven processing assumes that nCtrlID is
//              valid unless pAttrFcn is defined, in which case the attr
//              function may choose to hard code the control ID.
//
//-----------------------------------------------------------------------------
typedef struct _APPLY_MAP {
    int             nCtrlID;        // Control resource ID
    UINT            nCtrlCount;
    int*            pMappedCtrls;
    int*            pCtrlFlags;
    int*            pLimitText;
} APPLY_MAP, * PAPPLY_MAP;

//+----------------------------------------------------------------------------
//
//  Class:      CDsMultiPageBase
//
//  Purpose:    base class for multi-select property pages
//
//-----------------------------------------------------------------------------
class CDsMultiPageBase : public CDsTableDrivenPage
{
public:
  CDsMultiPageBase(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                      DWORD dwFlags);
  ~CDsMultiPageBase(void);

  //
  //  Instance specific wind proc
  //
  INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
  void    Init(PWSTR pszClass);

protected:
  HRESULT OnInitDialog(LPARAM lParam);
  virtual LRESULT OnApply(void);

  PAPPLY_MAP m_pApplyMap;

private:
  virtual LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
};


//+----------------------------------------------------------------------------
//
//  Class:      CDsGenericMultiPage
//
//  Purpose:    property page object class for the generic multi-select page.
//
//-----------------------------------------------------------------------------
class CDsGenericMultiPage : public CDsMultiPageBase
{
public:
  CDsGenericMultiPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                      DWORD dwFlags);
  ~CDsGenericMultiPage(void);

private:
  HRESULT OnInitDialog(LPARAM lParam);
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsUserMultiPage
//
//  Purpose:    property page object class for the user address multi-select page.
//
//-----------------------------------------------------------------------------
class CDsUserMultiPage : public CDsMultiPageBase
{
public:
  CDsUserMultiPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                      DWORD dwFlags);
  ~CDsUserMultiPage(void);
};

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Class:      CDsGeneralMultiUserPage
//
//  Purpose:    property page object class for the general user multi-select page.
//
//-----------------------------------------------------------------------------
class CDsGeneralMultiUserPage : public CDsUserMultiPage
{
public:  
  CDsGeneralMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags);

  virtual LRESULT OnApply();
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsOrganizationMultiUserPage
//
//  Purpose:    property page object class for the organization user multi-select page.
//
//-----------------------------------------------------------------------------
class CDsOrganizationMultiUserPage : public CDsUserMultiPage
{
public:  
  CDsOrganizationMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags);
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsAddressMultiUserPage
//
//  Purpose:    property page object class for the address user multi-select page.
//
//-----------------------------------------------------------------------------
class CDsAddressMultiUserPage : public CDsUserMultiPage
{
public:  
  CDsAddressMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags);
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsMultiUserAcctPage
//
//  Purpose:    multi-select user account page
//
//-----------------------------------------------------------------------------
class CDsMultiUserAcctPage : public CDsPropPageBase
{
public:
  CDsMultiUserAcctPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                  DWORD dwFlags);
  ~CDsMultiUserAcctPage(void);

  //
  //  Instance specific wind proc
  //
  INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  void    Init(PWSTR pwzClass);

private:
  HRESULT OnInitDialog(LPARAM lParam);
  LRESULT OnApply(void);
  LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	LRESULT OnNotify(WPARAM wParam, LPARAM lParam);

  BOOL FillSuffixCombo();

  //
  //  Data members
  //
  DWORD           m_dwUsrAcctCtrl;
  BOOL            m_fOrigCantChangePW;
  LARGE_INTEGER   m_PwdLastSet;
  BYTE *          m_pargbLogonHours;  // Pointer to allocated array of bytes for the logon hours (array length=21 bytes)
  PSID            m_pSelfSid;
  PSID            m_pWorldSid;
  BOOL            m_fAcctCtrlChanged;
  BOOL            m_fAcctExpiresChanged;
  BOOL            m_fLogonHoursChanged;
  BOOL            m_fIsAdmin;
  CLogonWkstaDlg        * m_pWkstaDlg;
};

HRESULT CreateUserMultiAcctPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND, DWORD,
                                const CDSSmartBasePathsInfo& basePathsInfo, HPROPSHEETPAGE *);



/////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
HRESULT CreateMultiUsrProfilePage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND, DWORD,
                                  const CDSSmartBasePathsInfo& basePathsInfo, HPROPSHEETPAGE *);

//+----------------------------------------------------------------------------
//
//  Class:      CDsMultiUsrProfilePage
//
//  Purpose:    property page object class for the user object profile page.
//
//-----------------------------------------------------------------------------
class CDsMultiUsrProfilePage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
  char szClass[32];
#endif

  CDsMultiUsrProfilePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                         DWORD dwFlags);
  ~CDsMultiUsrProfilePage(void);

  //
  //  Instance specific wind proc
  //
  INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  void    Init(PWSTR pwzClass);

private:
  HRESULT OnInitDialog(LPARAM lParam);
  LRESULT OnApply(void);
  LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
  LRESULT OnDestroy(void);
  BOOL    ExpandUsername(PWSTR & pwzValue, BOOL & fExpanded, PADSPROPERROR pError);

  //
  //  Data members
  //
  PTSTR       m_ptszLocalHomeDir;
  PTSTR       m_ptszRemoteHomeDir;
  PWSTR       m_pwzSamName;
  int         m_nDrive;
  int         m_idHomeDirRadio;
  BOOL        m_fProfilePathWritable;
  BOOL        m_fScriptPathWritable;
  BOOL        m_fHomeDirWritable;
  BOOL        m_fHomeDriveWritable;
  BOOL        m_fProfilePathChanged;
  BOOL        m_fLogonScriptChanged;
  BOOL        m_fHomeDirChanged;
  BOOL        m_fHomeDriveChanged;
  BOOL        m_fSharedDirChanged;
  PSID        m_pObjSID;
};


#endif // DSADMIN

#endif // __MULTI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\pagetable.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       pagetable.cxx
//
//  Contents:   Tables and definitions for table-driven DS property pages
//
//  History:    24-March-97 EricB created
//
//  Note:       Attribute LDAP display names, types, upper ranges, and so
//              forth, have been manually copied from schema.ini. Thus,
//              consistency is going to be difficult to maintain. If you know
//              of schema.ini changes that affect any of the attributes in
//              this file, then please make any necessary corrections here.
//
//  Note:       Some attr table entries are used to handle the processing of
//              buttons and check boxes by declaring attr functions. If an
//              attr map entry of this sort is not going to read or write an
//              actual DS attribute, then the attr name must be NULL and the
//              read-only element must be set to TRUE.
//
//              Attr functions can store data between DLG_OP calls by the
//              use of the second to last param, a PVOID * value, which has
//              a unique instance allocated for each attr function. If
//              different attr functions (on the same page) need to share data,
//              they can all use the pPage->m_pData member. This datum is a
//              member of the CDsTableDrivenPage class rather than the base
//              class, so you will need to cast pPage to CDsTableDrivenPage to
//              access m_pData.
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "user.h"
#include "group.h"
#include "domain.h"
#include "computer.h"
#include "trust.h"
#include "siterepl.h"
#include "managdby.h"
#include "UserCert.h"
#include "fpnw.h"
#include "multi.h"
#include "ScopeDelegation.h"
#include "pages.hm" // HIDC_*
#include <ntdsadef.h>

#include "dsprop.cxx"

//+----------------------------------------------------------------------------
// User Object.
//-----------------------------------------------------------------------------

//
// General page, first name
//
ATTR_MAP UGFirstName = {IDC_FIRST_NAME_EDIT, FALSE, FALSE, 64,
                        {L"givenName", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, first name
//
ATTR_MAP UGInitials = {IDC_INITIALS_EDIT, FALSE, FALSE, 6,
                       {L"initials", ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, last name
//
ATTR_MAP UGLastName = {IDC_LAST_NAME_EDIT, FALSE, FALSE, 64,
                       {L"sn", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                        NULL, 0}, NULL, NULL};
//
// General page, display name
//
ATTR_MAP UGDisplayName = {IDC_DISPLAYNAME_EDIT, FALSE, FALSE, 256,
                          {L"displayName", ADS_ATTR_UPDATE,
                           ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, office
//
ATTR_MAP UGOffice = {IDC_OFFICE_EDIT, FALSE, FALSE, 128,
                     {L"physicalDeliveryOfficeName", ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, phone number
//
ATTR_MAP UGPhone = {IDC_PHONE_EDIT, FALSE, FALSE, 64,
                    {L"telephoneNumber", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, other phone numbers
//
ATTR_MAP UGOtherPhone = {IDC_OTHER_PHONE_BTN, FALSE, TRUE, 64,
                         {L"otherTelephone", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// General page, email
//
ATTR_MAP UGEMail = {IDC_EMAIL_EDIT, FALSE, FALSE, 256,
                    {L"mail", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                     NULL, 0}, MailAttr, NULL};

//
// General page, user's home page
//
ATTR_MAP UGURL = {IDC_HOME_PAGE_EDIT, FALSE, FALSE, 2048,
                  {L"wWWHomePage", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                   NULL, 0}, NULL, NULL};
//
// General page, other home pages
//
ATTR_MAP UGOtherURL = {IDC_OTHER_URL_BTN, FALSE, TRUE, 2048,
                       {L"url", ADS_ATTR_UPDATE,
                       ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// The list of attributes on the User General page.
//
PATTR_MAP rgpUGAttrMap[] = {{&GenIcon}, {&AttrName}, {&UGFirstName},
                            {&UGInitials},
                            {&UGLastName}, {&UGDisplayName}, {&Description},
                            {&UGOffice}, {&UGPhone}, {&UGOtherPhone},
                            {&UGEMail}, {&UGURL}, {&UGOtherURL}};
//
// The User General page description.
//
DSPAGE UserGeneral = {IDS_TITLE_GENERAL, IDD_USER, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpUGAttrMap)/sizeof(PATTR_MAP), rgpUGAttrMap};

//----------------------------------------------
// The User Account page description.
//
DSPAGE UserAccount = {IDS_USER_TITLE_ACCT, IDD_ACCOUNT, 0, 0, NULL,
                      CreateUserAcctPage, 0, NULL};

//----------------------------------------------
// The User Profile page description.
//
DSPAGE UserProfile = {IDS_USER_TITLE_PROFILE, IDD_USR_PROFILE, 0, 0, NULL,
                      CreateUsrProfilePage, 0, NULL};

//----------------------------------------------
// Phone/Notes page, Home phone primary/other
//
ATTR_MAP UPhHomePhone = {IDC_HOMEPHONE_EDIT, FALSE, FALSE, 64,
                         {L"homePhone", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

ATTR_MAP UPhHomeOther = {IDC_OTHER_HOME_BTN, FALSE, TRUE, 64,
                         {L"otherHomePhone", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Phone/Notes page, Pager
//
ATTR_MAP UPhPager = {IDC_PAGER_EDIT, FALSE, FALSE, 64,
                     {L"pager", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                      NULL, 0}, NULL, NULL};

ATTR_MAP UPhOtherPager = {IDC_OTHER_PAGER_BTN, FALSE, TRUE, 64,
                          {L"otherPager", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Phone/Notes page, Mobile
//
ATTR_MAP UPhMobile = {IDC_MOBILE_EDIT, FALSE, FALSE, 64,
                      {L"mobile", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                       NULL, 0}, NULL, NULL};

ATTR_MAP UPhOtherMobile = {IDC_OTHER_MOBLE_BTN, FALSE, TRUE, 64,
                          {L"otherMobile", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Phone/Notes page, FAX
//
ATTR_MAP UPhFax = {IDC_FAX_EDIT, FALSE, FALSE, 64,
                   {L"facsimileTelephoneNumber", ADS_ATTR_UPDATE,
                    ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

ATTR_MAP UPhOtherFax = {IDC_OTHER_FAX_BTN, FALSE, TRUE, 64,
                        {L"otherFacsimileTelephoneNumber", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Phone/Notes page, IP phone
//
ATTR_MAP UPhIP = {IDC_IP_EDIT, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                   {L"ipPhone", ADS_ATTR_UPDATE,
                    ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

ATTR_MAP UPhOtherIP = {IDC_OTHER_IP_BTN, FALSE, TRUE, ATTR_LEN_UNLIMITED,
                        {L"otherIpPhone", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Phone/Notes page, Comments (the size limit is arbitrary; the schema doesn't
// specify an absolute limit).
//
ATTR_MAP UPhComments = {IDC_COMMENT_EDIT, FALSE, FALSE, 1024,
                        {L"info", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// The list of attributes on the Phone/Notes page.
//
PATTR_MAP rgpUPhoneAttrMap[] = {{&UPhHomePhone}, {&UPhHomeOther}, {&UPhPager},
                                {&UPhOtherPager}, {&UPhMobile}, {&UPhOtherMobile},
                                {&UPhOtherFax}, {&UPhFax}, {&UPhIP},
                                {&UPhOtherIP}, {&UPhComments}};
//
// The Phone/Notes page description.
//
DSPAGE PhoneNotes = {IDS_PHONE_NOTES, IDD_PHONE, 0, 0, NULL,
                     CreateTableDrivenPage,
                     sizeof(rgpUPhoneAttrMap)/sizeof(PATTR_MAP),
                     rgpUPhoneAttrMap};

//----------------------------------------------
// Organization page, Title
//
ATTR_MAP UOrgTitle = {IDC_TITLE_EDIT, FALSE, FALSE, 64,
                      {L"title", ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Organization page, Department
//
ATTR_MAP UOrgDept = {IDC_DEPT_EDIT, FALSE, FALSE, 64,
                     {L"department", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Organization page, Company
//
ATTR_MAP UOrgCo = {IDC_COMPANY_EDIT, FALSE, FALSE, 64,
                   {L"company", ADS_ATTR_UPDATE,
                   ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Organization page, Manager
//
ATTR_MAP UOrgMgr = {IDC_MANAGER_EDIT, FALSE, FALSE,
                    ATTR_LEN_UNLIMITED, {L"manager", ADS_ATTR_UPDATE,
                    ADSTYPE_DN_STRING, NULL, 0}, ManagerEdit, NULL};
//
// Organization page, Manager Change Button
//
ATTR_MAP UOrgChgBtn = {IDC_MGR_CHANGE_BTN, TRUE, FALSE, 0,
                       {NULL, ADS_ATTR_UPDATE,
                       ADSTYPE_INVALID, NULL, 0}, ManagerChangeBtn, NULL};
//
// Organization page, View Manager Properties Button
//
ATTR_MAP UOrgPropBtn = {IDC_PROPPAGE_BTN, TRUE, FALSE, 0,
                        {NULL, ADS_ATTR_UPDATE,
                        ADSTYPE_INVALID, NULL, 0}, MgrPropBtn, NULL};
//
// Organization page, Clear Manager Button
//
ATTR_MAP UOrgClrMgrBtn = {IDC_MGR_CLEAR_BTN, TRUE, FALSE, 0,
                          {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_INVALID, NULL, 0}, ClearMgrBtn, NULL};
//
// Organization page, Direct Reports
//
ATTR_MAP UOrgReports = {IDC_REPORTS_LIST, TRUE /* fReadOnly */, TRUE, 0,
                        {L"directReports", ADS_ATTR_UPDATE,
                        ADSTYPE_DN_STRING, NULL, 0}, DirectReportsList, NULL};
//
// Organization page, Add Direct Reports Button (NOT IMPLEMENTED)
//
ATTR_MAP UOrgAddReportsBtn = {IDC_ADD_BTN, TRUE /* fReadOnly */, FALSE, 0,
                              {NULL, ADS_ATTR_UPDATE, ADSTYPE_INVALID, NULL, 0},
                              AddReportsBtn, NULL};
//
// Organization page, Remove Direct Reports Button (NOT IMPLEMENTED)
//
ATTR_MAP UOrgRmReportsBtn = {IDC_REMOVE_BTN, TRUE, FALSE, 0,
                             {NULL, ADS_ATTR_UPDATE, ADSTYPE_INVALID, NULL, 0},
                             RmReportsBtn, NULL};
//
// The list of attributes on the Organization page.
//
PATTR_MAP rgpUOrgAttrMap[] = {{&UOrgTitle}, {&UOrgDept}, {&UOrgCo},
                              {&UOrgMgr}, {&UOrgChgBtn}, {&UOrgPropBtn},
                              {&UOrgClrMgrBtn}, {&UOrgReports}};
                              //{&UOrgAddReportsBtn}, {&UOrgRmReportsBtn}};
//
// The Organization page description.
//
DSPAGE UserOrg = {IDS_USER_TITLE_ORG, IDD_USER_ORG, 0, 0, NULL,
                  CreateTableDrivenPage,
                  sizeof(rgpUOrgAttrMap)/sizeof(PATTR_MAP), rgpUOrgAttrMap};

//+----------------------------------------------------------------------------
// Delegation Page.
//-----------------------------------------------------------------------------
//
// The Computer Delegation page
//
DSPAGE UserDelegationPage = { IDS_TITLE_DELEGATION, IDD_COMPUTER_DELEGATION, 0, 0, NULL,
                                  CreateUserDelegationPage,
                                  0, NULL };

//+----------------------------------------------------------------------------
// Membership Page.
//-----------------------------------------------------------------------------

//
// The Membership page description.
//
DSPAGE MemberPage = {IDS_USER_TITLE_MBR_OF, IDD_MEMBER, 0, 0, NULL,
                     CreateMembershipPage, 0, NULL};

//
// The Membership page description for non-security-principle objects.
//
DSPAGE NonSecMemberPage = {IDS_USER_TITLE_MBR_OF, IDD_MEMBER, 0, 0, NULL,
                           CreateNonSecMembershipPage, 0, NULL};
//
// The list of Membership pages.
//
PDSPAGE rgMemberPages[] = {{&MemberPage}};

//
// The Membership class description.
//
DSCLASSPAGES MemberCls = {&CLSID_DsMemberOfPropPages, TEXT("Membership"),
                          sizeof(rgMemberPages)/sizeof(PDSPAGE),
                          rgMemberPages};

//+----------------------------------------------------------------------------
// Published Certificates Page.
//-----------------------------------------------------------------------------

//
// The Published Certificates page description.
//
DSPAGE PubCertPage = {IDS_USER_TITLE_PUBLISHED_CERTS, IDD_USER_CERTIFICATES,
                      DSPROVIDER_ADVANCED, 0, NULL, CreateUserCertPage,
                      0, NULL};
//
// Note that this page uses CreateFPNWPage rather than
// CreateTableDrivenPage.  See fpnw.cxx for more details.
//

DSPAGE FPNWPage = {IDS_FPNWPAGE_TITLE, IDD_FPNW_PROPERTIES,
                  0, 0, NULL, CreateFPNWPage,
                  0, NULL};

//----------------------------------------------
// The list of User pages.
//
PDSPAGE rgUserPages[] = {{&UserGeneral}, {&UserAddress}, {&UserAccount},
                         {&UserProfile}, {&PhoneNotes}, {&UserDelegationPage},
                         {&FPNWPage}, {&UserOrg}, {&PubCertPage}, 
                         {&MemberPage}};

//
// The User class description.
//
DSCLASSPAGES UserCls = {&CLSID_DsUserPropPages, TEXT("User"),
                        sizeof(rgUserPages)/sizeof(PDSPAGE),
                        rgUserPages};

//
// The inetOrgPerson class description.
//

DSCLASSPAGES inetOrgPersonCls = {&CLSID_DsUserPropPages, TEXT("inetOrgPerson"),
                                  sizeof(rgUserPages)/sizeof(PDSPAGE),
                                  rgUserPages};

//+----------------------------------------------------------------------------
// Contact Object.
//-----------------------------------------------------------------------------

//
// The list of Contact pages. It uses the user general and organization pages.
//
PDSPAGE rgContactPages[] = {{&UserGeneral}, {&UserAddress}, {&PhoneNotes},
                            {&UserOrg}, {&NonSecMemberPage}};

//
// The Contact class description.
//
DSCLASSPAGES ContactCls = {&CLSID_DsContactPropPages, TEXT("Contact"),
                           sizeof(rgContactPages)/sizeof(PDSPAGE),
                           rgContactPages};

//+----------------------------------------------------------------------------
// Group Object.
//-----------------------------------------------------------------------------

//
// Group General page, downlevel name
//
ATTR_MAP GrpGenSAMname = {IDC_SAM_NAME_EDIT, FALSE, FALSE, 256,
                          {L"sAMAccountName", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Group General page.
//
ATTR_MAP GrpGenEmail = {IDC_EMAIL_EDIT, FALSE, FALSE, 1123,
                        {L"mail", ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, MailAttr, NULL};
//
// Group General page, Comment
//
ATTR_MAP GrpGenComment = {IDC_EDIT_COMMENT, FALSE, FALSE, 1024,
                          {L"info", ADS_ATTR_UPDATE,
                           ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// The list of attributes on the Group General page.
//
PATTR_MAP rgpGroupGenAttrMap[] = {{&Description}, {&GrpGenSAMname},
                                  {&GrpGenEmail}, {&GrpGenComment}};
//
// The Group General page description.
//
DSPAGE GroupGeneral = {IDS_TITLE_GENERAL, IDD_GROUP_GEN, 0, 0, NULL,
                       CreateGroupGenObjPage,
                       ARRAYLENGTH(rgpGroupGenAttrMap), rgpGroupGenAttrMap};
//
// The Group Members page description.
//
DSPAGE GroupMembers = {IDS_TITLE_GROUP, IDD_GROUP, 0, 0, NULL,
                       CreateGroupMembersPage, 0, NULL};
//
// The list of Group pages.
//
PDSPAGE rgGroupPages[] = {{&GroupGeneral},{&GroupMembers}, {&NonSecMemberPage}};

//
// The Group class description.
//
DSCLASSPAGES GroupCls = {&CLSID_DsGroupPropPages, TEXT("Group"),
                         ARRAYLENGTH(rgGroupPages), rgGroupPages};

//+----------------------------------------------------------------------------
// Organizational-Unit Object.
//-----------------------------------------------------------------------------
//
// OU General page, Address (Street)
//
ATTR_MAP OuGenAddress = {IDC_ADDRESS_EDIT, FALSE, FALSE, 1024,
                         {L"street", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// OU General page, City (Locality-Name)
//
ATTR_MAP OuGenCity = {IDC_CITY_EDIT, FALSE, FALSE, 128,
                      {L"l", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                       NULL, 0}, NULL, NULL};
//
// OU General page, State (State-Or-Provence-Name)
//
ATTR_MAP OuGenState = {IDC_STATE_EDIT, FALSE, FALSE, 128,
                       {L"st", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                        NULL, 0}, NULL, NULL};
//
// OU General page, ZIP (Postal-Code)
//
ATTR_MAP OuGenZIP = {IDC_ZIP_EDIT, FALSE, FALSE, 40,
                     {L"postalCode", ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Address page, CountryName
//
ATTR_MAP OuGenCntryName = {IDC_COUNTRY_COMBO, FALSE, FALSE, 3,
                         {g_wzCountryName, ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                         NULL, 0}, CountryName, NULL};
//
// Address page, CountryCode. Thus MUST be after UAddrCntryName.
//
ATTR_MAP OuGenCntryCode = {IDC_COUNTRY_COMBO, FALSE, FALSE, 3,
                         {g_wzCountryCode, ADS_ATTR_UPDATE, ADSTYPE_INTEGER,
                         NULL, 0}, CountryCode, NULL};
//
// Address page, Text-Country
//
ATTR_MAP OuGenTextCntry = {IDC_COUNTRY_COMBO, FALSE, FALSE, 128,
                     {g_wzTextCountry, ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TextCountry, NULL};

//
// The list of attributes on the OU General page.
//
PATTR_MAP rgpOuGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}, {&OuGenAddress},
                               {&OuGenCity}, {&OuGenState}, {&OuGenZIP}
                              , {&OuGenCntryName},{&OuGenCntryCode},{&OuGenTextCntry}
                               };
//
// The OU General page description.
//
DSPAGE OUGeneral = {IDS_TITLE_GENERAL, IDD_OU_GEN, 0, 0, NULL,
                    CreateTableDrivenPage,
                    sizeof(rgpOuGenAttrMap)/sizeof(PATTR_MAP),
                    rgpOuGenAttrMap};
//
// The list of OU pages.
//
PDSPAGE rgOUPages[] = {{&OUGeneral}};

//
// The OU class description.
//
DSCLASSPAGES OUCls = {&CLSID_DsOuGenPropPage, TEXT("OU"),
                      sizeof(rgOUPages)/sizeof(PDSPAGE),
                      rgOUPages};

//+----------------------------------------------------------------------------
// Domain Object.
//-----------------------------------------------------------------------------

//
// DNS Name
//
ATTR_MAP DomAttrName = {IDC_CN, TRUE, FALSE, 64,
                        {L"dc", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                        NULL, 0}, DomainDNSname, NULL};
//
// Downlevel Name
//
ATTR_MAP DownlevelAttrName = {IDC_DOWNLEVEL_NAME, TRUE, FALSE, 64,
                              {L"dc", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                              NULL, 0}, DownlevelName, NULL};
//
// The list of attributes on the Domain General page.
//
PATTR_MAP rgpDomainGenAttrMap[] = {{&GenIcon}, {&DomAttrName}, {&Description},
                                   {&DownlevelAttrName}};

//
// The Domain General page description.
//
DSPAGE DomainGeneral = {IDS_TITLE_GENERAL, IDD_DOMAIN, 0, 0, NULL,
                        CreateTableDrivenPage,
                        sizeof(rgpDomainGenAttrMap)/sizeof(PATTR_MAP),
                        rgpDomainGenAttrMap};
//----------------------------------------------
//
// Trust Page: Flat-Name
//
ATTR_MAP AttrTrustName = {0, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                          {L"flatName", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Trust Page: Trust-Attributes
//
ATTR_MAP AttrTrustAttr = {0, FALSE, FALSE, 0,
                          {L"trustAttributes", ADS_ATTR_UPDATE,
                          ADSTYPE_INTEGER, NULL, 0}, NULL, NULL};
//
// Trust Page: Trust-Direction
//
ATTR_MAP AttrTrustDir = {0, FALSE, FALSE, 0,
                         {L"trustDirection", ADS_ATTR_UPDATE,
                         ADSTYPE_INTEGER, NULL, 0}, NULL, NULL};
//
// Trust Page: Trust-Type
//
ATTR_MAP AttrTrustType = {0, FALSE, FALSE, 0,
                          {L"trustType", ADS_ATTR_UPDATE,
                          ADSTYPE_INTEGER, NULL, 0}, NULL, NULL};
//
// Trust Page: Trust Partner (the uplevel trusted domain name).
//
ATTR_MAP AttrTrustPartner = {0, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                             {L"trustPartner", ADS_ATTR_UPDATE,
                              ADSTYPE_DN_STRING, NULL, 0}, NULL, NULL};
//
// Trust Page: Domain-Cross-Ref
//
//ATTR_MAP AttrCrossRef = {0, FALSE, FALSE, ATTR_LEN_UNLIMITED,
//                         {L"domainCrossRef", ADS_ATTR_UPDATE,
//                         ADSTYPE_DN_STRING, NULL, 0}, NULL};
//
// The list of attributes on the Domain Trust page.
//
PATTR_MAP rgpDomTrustAttrMap[] = {{&AttrTrustName}, {&AttrTrustAttr},
                                  {&AttrTrustDir}, {&AttrTrustType},
                                  {&AttrTrustPartner}};
//                                  {&AttrCrossRef}};
//
// The Domain Trust page description.
//
DSPAGE DomainTrust = {IDS_TITLE_TRUST, IDD_DOMAIN_TRUST, 0, 1,
                      &CLSID_DomainAdmin, CreateDomTrustPage,
                      sizeof(rgpDomTrustAttrMap)/sizeof(PATTR_MAP),
                      rgpDomTrustAttrMap};
//
// The list of Domain pages.
//
PDSPAGE rgDomainPages[] = {{&DomainGeneral}, {&DomainTrust}};

//
// The Domain class description.
//
DSCLASSPAGES DomainCls = {&CLSID_DsDomainPropPages, TEXT("Domain"),
                          sizeof(rgDomainPages)/sizeof(PDSPAGE),
                          rgDomainPages};

//+----------------------------------------------------------------------------
// Trusted-Domain Object.
//-----------------------------------------------------------------------------
//
// Trusted Domain General page: current domain name
// Warning:    This must be the first attr function called as it allocates
//             the class object.
//
ATTR_MAP TDomGenCurDomAttr = {IDC_DOMAIN_NAME_EDIT, TRUE, FALSE, 0,
                              {L"flatName", ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, CurDomainText, NULL};
//
// Trusted Domain General page: Peer Domain name.
//
ATTR_MAP TDomGenPeerAttr = {IDC_PEER_NAME_EDIT, TRUE, FALSE, 0,
                            {L"trustPartner", ADS_ATTR_UPDATE,
                            ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, PeerDomain, NULL};
//
// Trusted Domain General page: TrustType
// Note, this attr function fetches the trust-type value which is used
// by the trust-attributes attr function. Thus, this function must be called
// before the TransitiveTextOrButton function.
//
ATTR_MAP TDomTrustTypeAttr = {IDC_TRUST_TYPE_EDIT, TRUE, FALSE, 0,
                              {L"trustType", ADS_ATTR_UPDATE,
                              ADSTYPE_INTEGER, NULL, 0}, TrustType, NULL};
//
// Trusted Domain General page: Trust Direction
//
ATTR_MAP TDomTrustDirAttr = {IDC_TRUST_DIR_EDIT, TRUE, FALSE, 0,
                             {L"trustDirection", ADS_ATTR_UPDATE,
                             ADSTYPE_INTEGER, NULL, 0}, TrustDirection, NULL};
//
// Trusted Domain General page: Transitive Textbox or Yes button.
//
ATTR_MAP TDomTransAttrYes = {IDC_TRANS_YES_RADIO, FALSE, FALSE, 0,
                             {L"trustAttributes", ADS_ATTR_UPDATE,
                             ADSTYPE_INTEGER, NULL, 0}, TransitiveTextOrButton, NULL};
//
// Trusted Domain General page: Trust Transistivity No Radio Button.
//
ATTR_MAP TDomTransAttrNo = {IDC_TRANS_NO_RADIO, FALSE, FALSE, 0,
                            {NULL, ADS_ATTR_UPDATE,
                            ADSTYPE_INTEGER, NULL, 0}, TrustTransNo, NULL};

//
// Trusted Domain General page: Text next to the Verify/Reset trust button
//
ATTR_MAP TDomResetText = {IDC_VERIFY_STATIC, TRUE, FALSE, 0,
                         {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TrustVerifyText, NULL};

//
// Trusted Domain General page: Verify/Reset trust button
//
ATTR_MAP TDomResetBtn = {IDC_TRUST_RESET_BTN, TRUE, FALSE, 0,
                         {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_INTEGER, NULL, 0}, TrustVerifyBtn, NULL};
//
// Trusted Domain General page: Save FTInfo button
//
ATTR_MAP TDomFTSaveBtn = {IDC_SAVE_FOREST_NAMES_BTN, TRUE, FALSE, 0,
                         {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_INTEGER, NULL, 0}, SaveFTInfoBtn, NULL};

//
// Trusted Domain General page: Quarantine State text
//
ATTR_MAP TDomQStateText = {IDC_QUARANTINE_STATIC, TRUE, FALSE, 0,
                         {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TrustQStateText, NULL};

#if DBG == 1 // TRUSTBREAK
ATTR_MAP TDomBreakBtn = {IDC_BUTTON1, TRUE, FALSE, 0,
                         {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_INTEGER, NULL, 0}, TrustBreakBtn, NULL};
#endif
//
// The list of attributes on the Trusted Domain General page.
//
PATTR_MAP rgpTrustDomGenAttrMap[] = {{&TDomGenCurDomAttr}, {&TDomGenPeerAttr},
                                     {&TDomTrustTypeAttr}, {&TDomTrustDirAttr},
                                     {&TDomTransAttrYes}, {&TDomResetText},
                                     {&TDomTransAttrNo}, {&TDomResetBtn}, {&TDomFTSaveBtn}, 
                                     {&TDomQStateText}
#if DBG == 1 // TRUSTBREAK
,{&TDomBreakBtn}
#endif
};
//
// The Trusted Domain General page description.
//
DSPAGE TrustDomGen = {IDS_TITLE_GENERAL, IDD_TRUSTED_DOM_GEN, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpTrustDomGenAttrMap)/sizeof(PATTR_MAP),
                      rgpTrustDomGenAttrMap};
#ifdef REMOVE_SPN_SUFFIX_CODE
//----------------------------------------------
//
// Trust Domain SPN Suffix Page: Edit control
//
ATTR_MAP TrustSPNAttrEdit = {IDC_EDIT, FALSE, TRUE, ATTR_LEN_UNLIMITED,
                             {L"additionalTrustedServiceNames", ADS_ATTR_UPDATE,
                             ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TrustSPNEdit, NULL};
//
// Trust Domain SPN Suffix Page: List control
//
ATTR_MAP TrustSPNAttrList = {IDC_LIST, TRUE, TRUE, ATTR_LEN_UNLIMITED,
                             {NULL, ADS_ATTR_UPDATE,
                             ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TrustSPNList, NULL};
//
// Trust Domain SPN Suffix Page: Add button
//
ATTR_MAP TrustSPNAttrAdd = {IDC_ADD_BTN, TRUE, TRUE, ATTR_LEN_UNLIMITED,
                            {NULL, ADS_ATTR_UPDATE,
                            ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TrustSPNAdd, NULL};
//
// Trust Domain SPN Suffix Page: Remove button
//
ATTR_MAP TrustSPNAttrRemove = {IDC_DELETE_BTN, TRUE, TRUE, ATTR_LEN_UNLIMITED,
                               {NULL, ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TrustSPNRemove, NULL};
//
// Trust Domain SPN Suffix Page: Edit button
//
ATTR_MAP TrustSPNAttrChange = {IDC_EDIT_BTN, TRUE, TRUE, ATTR_LEN_UNLIMITED,
                               {NULL, ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, TrustSPNChange, NULL};
//
// The list of attributes on the Trusted Domain SPN Suffix page.
//
PATTR_MAP rgpTrustDomSPNAttrMap[] = {{&TrustSPNAttrEdit}, {&TrustSPNAttrList},
                                     {&TrustSPNAttrAdd}, {&TrustSPNAttrRemove},
                                     {&TrustSPNAttrChange}};
//
// The Trusted Domain Suffix Page description.
//
DSPAGE TrustDomSPNpage = {IDS_ADVANCED, IDD_SPN_SUFFIX, 0, 0, NULL,
                          CreateTableDrivenPage,
                          sizeof(rgpTrustDomSPNAttrMap)/sizeof(PATTR_MAP),
                          rgpTrustDomSPNAttrMap};

PDSPAGE rgTrustedDomainPages[] = {{&TrustDomGen}, {&TrustDomSPNpage}};
#endif //REMOVE_SPN_SUFFIX_CODE
//
// The list of Trusted Domain pages.
//
PDSPAGE rgTrustedDomainPages[] = {{&TrustDomGen}};
//
// The Trusted Domain class description.
//
DSCLASSPAGES TrustedDomainCls = {&CLSID_DsTrustedDomainPropPages,
                                 TEXT("TrustedDomain"),
                                 sizeof(rgTrustedDomainPages)/sizeof(PDSPAGE),
                                 rgTrustedDomainPages};

//+----------------------------------------------------------------------------
// Domain Policy Object.
//-----------------------------------------------------------------------------

//
// The list of attributes on the Domain Policy General page.
//
PATTR_MAP rgpDomPolGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}};

//
// The Domain Policy General page description.
//
DSPAGE DomainPolicyGeneral = {IDS_TITLE_GENERAL, IDD_DOMAINPOLICY, 0, 0, NULL,
                              CreateTableDrivenPage,
                              sizeof(rgpDomPolGenAttrMap)/sizeof(PATTR_MAP),
                              rgpDomPolGenAttrMap};
//
// The list of Domain Policy pages.
//
PDSPAGE rgDomainPolicyPages[] = {{&DomainPolicyGeneral}};

//
// The Domain Policy class description.
//
DSCLASSPAGES DomainPolicyCls = {&CLSID_DsDomainPolicyPropPages,
                                TEXT("DomainPolicy"),
                                sizeof(rgDomainPolicyPages)/sizeof(PDSPAGE),
                                rgDomainPolicyPages};

//+----------------------------------------------------------------------------
// Local Policy Object.
//-----------------------------------------------------------------------------

//
// The list of attributes on the Local Policy General page.
//
PATTR_MAP rgpLocPolGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}};

//
// The Local Policy General page description.
//
DSPAGE LocalPolicyGeneral = {IDS_TITLE_GENERAL, IDD_LOCALPOLICY_GEN, 0, 0, NULL,
                             CreateTableDrivenPage,
                             sizeof(rgpLocPolGenAttrMap)/sizeof(PATTR_MAP),
                             rgpLocPolGenAttrMap};
//
// The list of Local Policy pages.
//
PDSPAGE rgLocalPolicyPages[] = {{&LocalPolicyGeneral}};
//
// The Local Policy class description.
//
DSCLASSPAGES LocalPolicyCls = {&CLSID_DsLocalPolicyPropPages,
                               TEXT("LocalPolicy"),
                               sizeof(rgLocalPolicyPages)/sizeof(PDSPAGE),
                               rgLocalPolicyPages};

//+----------------------------------------------------------------------------
// Managed-By Page.
//-----------------------------------------------------------------------------

//
// Managed-by page, Managed-By DN. THIS MUST BE THE FIRST Managed-By ATTR_MAP!
//
ATTR_MAP MgdByDN = {IDC_MANAGEDBY_EDIT, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                    {L"managedBy", ADS_ATTR_UPDATE,
                     ADSTYPE_DN_STRING, NULL, 0}, ManagedByEdit, NULL};
//
// Managed-by page, Change button.
//
ATTR_MAP MgdByChange = {IDC_CHANGE_BTN, TRUE, FALSE, 0,
                        {NULL, ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, ChangeButton, NULL};
//
// Managed-by page, View button.
//
ATTR_MAP MgdByView = {IDC_VIEW_BTN, TRUE, FALSE, 0,
                      {NULL, ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, ViewButton, NULL};
//
// Managed-by page, Clear button.
//
ATTR_MAP MgdByClear = {IDC_CLEAR_BTN, TRUE, FALSE, 0,
                       {NULL, ADS_ATTR_UPDATE,
                       ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, ClearButton, NULL};

//
// Managed-by page, Can update list check box
//
ATTR_MAP MgdByUpdateCheck = {IDC_UPDATE_LIST_CHECK, FALSE, FALSE, 0,
                              {NULL, ADS_ATTR_UPDATE,
                              ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, UpdateListCheck, NULL};

//
// Managed-by page, Office.
//
ATTR_MAP MgdByOffice = {IDC_OFFICE_EDIT, TRUE, FALSE, 128,
                        {L"physicalDeliveryOfficeName", ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OfficeEdit, NULL};
//
// Managed-by page, Street.
//
ATTR_MAP MgdByStreet = {IDC_STREET_EDIT, TRUE, FALSE, 128,
                        {L"streetAddress", ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, StreetEdit, NULL};
//
// Managed-by page, City (locality).
//
ATTR_MAP MgdByCity = {IDC_CITY_EDIT, TRUE, FALSE, 128,
                      {L"l", ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, CityEdit, NULL};
//
// Managed-by page, State.
//
ATTR_MAP MgdByState = {IDC_STATE_EDIT, TRUE, FALSE, 128,
                       {L"st", ADS_ATTR_UPDATE,
                       ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, StateEdit, NULL};
//
// Managed-by page, Country.
//
ATTR_MAP MgdByCountry = {IDC_COUNTRY_EDIT, TRUE, FALSE, 3,
                         {L"c", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, CountryEdit, NULL};
//
// Managed-by page, Phone.
//
ATTR_MAP MgdByPhone = {IDC_PHONE_EDIT, TRUE, FALSE, 32,
                       {L"telephoneNumber", ADS_ATTR_UPDATE,
                       ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, PhoneEdit, NULL};
//
// Managed-by page, Fax.
//
ATTR_MAP MgdByFax = {IDC_FAX_EDIT, TRUE, FALSE, 64,
                     {L"facsimileTelephoneNumber", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, FaxEdit, NULL};
//
// The list of attributes on the Managed-by page.
//
PATTR_MAP rgpManagedByAttrMap[] = {{&MgdByDN}, {&MgdByChange}, {&MgdByView},
                                   {&MgdByClear}, {&MgdByUpdateCheck}, {&MgdByOffice},
                                   {&MgdByStreet}, {&MgdByCity}, {&MgdByState},
                                   {&MgdByCountry}, {&MgdByPhone}, {&MgdByFax}};
//
// The Managed-by page description.
//
DSPAGE ManagedByPage = {IDS_MANAGED_BY_TITLE, IDD_MANAGEDBY, 0, 0, NULL,
                        CreateTableDrivenPage,
                        sizeof(rgpManagedByAttrMap)/sizeof(PATTR_MAP),
                        rgpManagedByAttrMap};
//
// The list of Managed-by pages.
//
PDSPAGE rgManagedByPages[] = {{&ManagedByPage}};

//
// The Managed-by class description.
//
DSCLASSPAGES ManagedByCls = {&CLSID_DsManageableObjPropPages,
                             TEXT("Managed-By"),
                             sizeof(rgManagedByPages)/sizeof(PDSPAGE),
                             rgManagedByPages};

//+----------------------------------------------------------------------------
// Computer Object.
//-----------------------------------------------------------------------------

//
// Computer General page, DNS Name.
//
ATTR_MAP ComputerDnsName = {IDC_NET_ADDR_EDIT, TRUE, FALSE, 2048,
                            {L"dNSHostName", ADS_ATTR_UPDATE,
                            ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Computer General page, Downlevel Name. The length includes the $ at the end.
// The attr function will limit the edit control to one less than this.
//
ATTR_MAP ComputerDwnlvlName = {IDC_DOWNLEVEL_EDIT, TRUE, FALSE, 16,
                               {L"sAMAccountName", ADS_ATTR_UPDATE,
                                ADSTYPE_CASE_IGNORE_STRING, NULL, 0},
                                ComputerDnlvlName, NULL};
//
// Computer General page, Delegation checkbox. This attr function must be
// called before ComputerRoleAttr because it uses a values fetched by this
// function and stored in the page's m_pData element.
//
ATTR_MAP ComputerDelegateChk = {IDC_DELEGATION_CHK, FALSE, FALSE, 0,
                               {g_wzUserAccountControl, ADS_ATTR_UPDATE,
                                ADSTYPE_INTEGER, NULL, 0},
                                PuterCanDelegateChk, NULL};
//
// Computer General page, Role, from User-Account-Control.
// Note that there is a machineRole attribute, but it is not used.
// Note also that this attribute is used by two different controls (this and
// the delegation checkbox). However, a last-writer-wins situation is avoided
// because the Role edit control is read-only.
//
ATTR_MAP ComputerRoleAttr = {IDC_ROLE_EDIT, TRUE, FALSE, 0,
                             {NULL /* L"userAccountControl" */, ADS_ATTR_UPDATE,
                             ADSTYPE_INTEGER, NULL, 0}, ComputerRole, NULL};
//
// The list of attributes on the Computer General page.
//
PATTR_MAP rgpComputerGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description},
                                     {&ComputerDnsName}, {&ComputerDwnlvlName},
                                     {&ComputerDelegateChk}, {&ComputerRoleAttr}};
//
// The Computer General page description.
//
DSPAGE ComputerGeneral = {IDS_TITLE_GENERAL, IDD_COMPUTER, 0, 0, NULL,
                          CreateTableDrivenPage,
                          sizeof(rgpComputerGenAttrMap)/sizeof(PATTR_MAP),
                          rgpComputerGenAttrMap};
//
// Computer OS page, OS Name.
//
ATTR_MAP ComputerOsName = {IDC_OS_EDIT, TRUE, FALSE, 2048,
                           {L"operatingSystem", ADS_ATTR_UPDATE,
                           ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Computer OS page, OS Version.
//
ATTR_MAP ComputerOsVer = {IDC_OS_VER_EDIT, TRUE, FALSE, 2048,
                          {L"operatingSystemVersion", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Computer OS page, OS Service Pack Level.
//
ATTR_MAP ComputerSvcPack = {IDC_SVC_PACK_EDIT, TRUE, FALSE, 2048,
                            {L"operatingSystemServicePack", ADS_ATTR_UPDATE,
                            ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// The list of attributes on the Computer OS page.
//
PATTR_MAP rgpComputerOSAttrMap[] = {{&ComputerOsName}, {&ComputerOsVer},
                                     {&ComputerSvcPack}};
//
// The Computer OS page description.
//
DSPAGE ComputerOSPage = {IDS_TITLE_OS, IDD_COMPUTER_OS, 0, 0, NULL,
                         CreateTableDrivenPage,
                         sizeof(rgpComputerOSAttrMap)/sizeof(PATTR_MAP),
                         rgpComputerOSAttrMap};

//
// The Computer Delegation page
//
DSPAGE ComputerDelegationPage = { IDS_TITLE_DELEGATION, IDD_COMPUTER_DELEGATION, 0, 0, NULL,
                                  CreateComputerDelegationPage,
                                  0, NULL };
//
// The list of Computer pages.
//
PDSPAGE rgComputerPages[] = {{&ComputerGeneral}, {&ComputerOSPage}, {&MemberPage},
                             {&ComputerDelegationPage}};

//
// The Computer class description.
//
DSCLASSPAGES ComputerCls = {&CLSID_DsComputerPropPages, TEXT("Computer"),
                            sizeof(rgComputerPages)/sizeof(PDSPAGE),
                            rgComputerPages};

//+----------------------------------------------------------------------------
// Volume Object.
//-----------------------------------------------------------------------------

//
// Volume General page, UNC path.
//
ATTR_MAP VolumeUNC = {IDC_UNC_NAME_EDIT, FALSE, FALSE, 260,
                      {L"uNCName", ADS_ATTR_UPDATE,
                       ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, VolumeUNCpath, NULL};
//
// Volume General page, Browse for UNC path button.
//
ATTR_MAP VolKeywords = {IDC_KEYWORDS_BTN, FALSE, TRUE, 256,
                        {L"keywords", ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// The list of attributes on the Volume General page.
//
PATTR_MAP rgpVolumeGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description},
                                   {&VolumeUNC}, {&VolKeywords}
                                  };
//
// The Volume General page description.
//
DSPAGE VolumeGeneral = {IDS_TITLE_GENERAL, IDD_VOLUME, 0, 0, NULL,
                        CreateTableDrivenPage,
                        sizeof(rgpVolumeGenAttrMap)/sizeof(PATTR_MAP),
                        rgpVolumeGenAttrMap};
//
// The list of Volume pages.
//
PDSPAGE rgVolumePages[] = {{&VolumeGeneral}};

//
// The Volume class description.
//
DSCLASSPAGES VolumeCls = {&CLSID_DsVolumePropPages, TEXT("Volume"),
                          sizeof(rgVolumePages)/sizeof(PDSPAGE),
                          rgVolumePages};

//+----------------------------------------------------------------------------
// Subnet Object.
//-----------------------------------------------------------------------------

//
// Subnet General page, siteObject attribute
//
ATTR_MAP USiteTarget = {IDC_DS_SITE_IN_SUBNET, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                          {L"siteObject", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                          NULL, 0}, DsQuerySite, 0};
ATTR_MAP USubnetAddress = {IDC_SUBNET_ADDRESS, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                          {g_wzName, ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                          NULL, 0}, SubnetExtractAddress, NULL};
ATTR_MAP USubnetMask = {IDC_SUBNET_MASK, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                          {g_wzName, ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                          NULL, 0}, SubnetExtractMask, NULL};

//
// The list of attributes on the Subnet General page.
//
PATTR_MAP rgpSubnetGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
                          ,{&USiteTarget}
                          ,{&USubnetAddress}
                          ,{&USubnetMask}
                          };

//
// The Subnet General page description.
//
DSPAGE SubnetGeneral = {IDS_TITLE_GENERAL, IDD_SUBNET_GENERAL, 0, 0, NULL,
                        CreateTableDrivenPage,
                        sizeof(rgpSubnetGenAttrMap)/sizeof(PATTR_MAP),
                        rgpSubnetGenAttrMap};
//
// The list of Subnet pages.
//
PDSPAGE rgSubnetPages[] = {{&SubnetGeneral}};

//
// The Subnet class description.
//
DSCLASSPAGES SubnetCls = {&CLSID_DsReplSubnetPropPages, TEXT("Subnet"),
                          sizeof(rgSubnetPages)/sizeof(PDSPAGE),
                          rgSubnetPages};

//+----------------------------------------------------------------------------
// Site Object.
//-----------------------------------------------------------------------------

ATTR_MAP USubnetList = {IDC_SUBNET_LIST, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                          {NULL, ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                          NULL, 0}, SiteExtractSubnetList, NULL};

//
// Schedule button (shared between several SITEREPL pages).
//
ATTR_MAP UScheduleBtn_11_Default = {IDC_SCHEDULE_BTN, FALSE, FALSE, SchedDlg_Connection,
                          {L"schedule", ADS_ATTR_UPDATE, ADSTYPE_OCTET_STRING, NULL, 0},
                          ScheduleChangeBtn_11_Default, NULL};
ATTR_MAP UScheduleBtn_FF_Default = {IDC_SCHEDULE_BTN, FALSE, FALSE, SchedDlg_Connection,
                          {L"schedule", ADS_ATTR_UPDATE, ADSTYPE_OCTET_STRING, NULL, 0},
                          ScheduleChangeBtn_FF_Default, NULL};
ATTR_MAP UReplicationScheduleBtn = {IDC_SCHEDULE_BTN, FALSE, FALSE, SchedDlg_Replication,
                          {L"schedule", ADS_ATTR_UPDATE, ADSTYPE_OCTET_STRING, NULL, 0},
                          ScheduleChangeBtn_FF_Default, NULL};
#ifdef CUSTOM_SCHEDULE
ATTR_MAP UScheduleCheckbox = {IDC_SCHEDULE_CHECKBOX, TRUE /* read-only */, FALSE, NULL,
                          {L"schedule", ADS_ATTR_UPDATE, ADSTYPE_OCTET_STRING, NULL, 0},
                          ScheduleChangeCheckbox, NULL};
#endif
//
// The list of attributes on the Site General page.
//
PATTR_MAP rgpSiteGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
    ,{&USubnetList}
    // ,{&UScheduleBtn}
};

//
// The Site General page description.
//
DSPAGE SiteGeneral = {IDS_TITLE_GENERAL, IDD_SITE_GENERAL, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpSiteGenAttrMap)/sizeof(PATTR_MAP),
                      rgpSiteGenAttrMap};

//
// The list of Site pages.
//
PDSPAGE rgSitePages[] = {{&SiteGeneral}};

//
// The Site class description.
//
DSCLASSPAGES SiteCls = {&CLSID_DsReplSitePropPages, TEXT("Site"),
                        sizeof(rgSitePages)/sizeof(PDSPAGE),
                        rgSitePages};

//+----------------------------------------------------------------------------
// DS Site Settings Object.
//-----------------------------------------------------------------------------

//
// Topology buttons (shares the "options" attribute).
//
ATTR_MAP USiteSettingsTopologyIcon = {IDC_EDIT1, TRUE /* read-only */, FALSE,
                            NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED,
                            {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            HideBasedOnBitField, NULL};
ATTR_MAP USiteSettingsTopologyText = {IDC_EDIT2, TRUE /* read-only */, FALSE,
                            NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED,
                            {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            HideBasedOnBitField, NULL};
ATTR_MAP USiteSettingsTopologyHelpId = {IDC_EDIT2, TRUE /* read-only */, FALSE,
                            HIDC_SITESETTINGS_INTRA_NO_AUTOGEN,
                            {NULL, ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            SetContextHelpIdAttrFn, NULL};
ATTR_MAP USiteSettingsSiteTopologyIcon = {IDC_EDIT3, TRUE /* read-only */, FALSE,
                            NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED,
                            {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            HideBasedOnBitField, NULL};
ATTR_MAP USiteSettingsSiteTopologyText = {IDC_EDIT4, TRUE /* read-only */, FALSE,
                            NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED,
                            {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            HideBasedOnBitField, NULL};
ATTR_MAP USiteSettingsSiteTopologyHelpId = {IDC_EDIT4, TRUE /* read-only */, FALSE,
                            HIDC_SITESETTINGS_INTER_NO_AUTOGEN,
                            {NULL, ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            SetContextHelpIdAttrFn, NULL};
//
// Change Server button
// note that IDC_SERVER_BTN does not actually exist in the dialog
//
ATTR_MAP UTopoGenerator = {IDC_SERVER_BTN, FALSE, FALSE, 0,
                          {L"intersiteTopologyGenerator", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          nTDSDSAChangeBtn, NULL};

//
// JonN 7/21/00 New Site Settings fields for GC-less logon
//
// Global Catalog bit in [options] attribute
ATTR_MAP UCacheMemb = {IDC_SITESETTINGS_CACHE_MEMB, FALSE, FALSE,
                          NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED,
                          {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER,
                          NULL, 0}, FirstSharedBitField, NULL};
// Preferred site for GC-less logon
ATTR_MAP UGCSite = {IDC_SITESETTINGS_PREFERRED_SITE, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                             {L"msDS-Preferred-GC-Site", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                             NULL, 0}, DsQuerySite, (PVOID)IDS_DEFAULT_SITE};

//
// The list of attributes on the DS Site Settings General page.
//
PATTR_MAP rgpDsSiteSettingsGenAttrMap[] = {{&GenIcon}, {&AttrName}
            ,{&Description}
            ,{&USiteSettingsTopologyIcon}
            ,{&USiteSettingsTopologyText}
            ,{&USiteSettingsTopologyHelpId}
            ,{&USiteSettingsSiteTopologyIcon}
            ,{&USiteSettingsSiteTopologyText}
            ,{&USiteSettingsSiteTopologyHelpId}
#ifdef CUSTOM_SCHEDULE
            ,{&UScheduleCheckbox}
#endif
            ,{&UScheduleBtn_11_Default}
            ,{&UTopoGenerator}
            ,{&UCacheMemb}
            ,{&UGCSite}
            };

//
// The DS Site Settings General page description.
//
DSPAGE DsSiteSettingsGeneral = {IDS_TITLE_DS_SITE_SETTINGS, IDD_DS_SITE_SETTINGS_GENERAL,
                            0, 0, NULL, CreateTableDrivenPage,
                            sizeof(rgpDsSiteSettingsGenAttrMap)/sizeof(PATTR_MAP),
                            rgpDsSiteSettingsGenAttrMap};
//
// The list of DS Site Settings pages.
//
PDSPAGE rgDsSiteSettingsPages[] = {{&DsSiteSettingsGeneral}};

//
// The DS Site Settings class description.
//
DSCLASSPAGES DsSiteSettingsCls = {&CLSID_DsReplSiteSettingsPropPages, TEXT("NTDS-Site-Settings"),
                              sizeof(rgDsSiteSettingsPages)/sizeof(PDSPAGE),
                              rgDsSiteSettingsPages};

//+----------------------------------------------------------------------------
// Site License Settings Object.
//-----------------------------------------------------------------------------

//
// Change Server button
//
ATTR_MAP USiteServerBtn = {IDC_COMPUTER_BTN, FALSE, FALSE, 0,
                          {L"siteServer", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          ComputerChangeBtn, NULL};
//
// The list of attributes on the Site License Settings General page.
//
PATTR_MAP rgpDsSiteLicenseSettingsGenAttrMap[] = {{&GenIcon}, {&AttrName},
            {&USiteServerBtn},
            {&Description}};

//
// The Site License Settings General page description.
//
DSPAGE DsSiteLicenseSettingsGeneral = {IDS_TITLE_DS_SITE_LICENSE_SETTINGS,
                            IDD_DS_SITE_LICENSE_SETTINGS_GENERAL,
                            0, 0, NULL, CreateTableDrivenPage,
                            sizeof(rgpDsSiteLicenseSettingsGenAttrMap)/sizeof(PATTR_MAP),
                            rgpDsSiteLicenseSettingsGenAttrMap};
//
// The list of DS Site Settings pages.
//
PDSPAGE rgDsSiteLicenseSettingsPages[] = {{&DsSiteLicenseSettingsGeneral}};

//
// The DS Site Settings class description.
//
DSCLASSPAGES DsSiteLicenseSettingsCls = {&CLSID_DsReplSiteLicenseSettingsPropPages, TEXT("Licensing-Site-Settings"),
                              sizeof(rgDsSiteLicenseSettingsPages)/sizeof(PDSPAGE),
                              rgDsSiteLicenseSettingsPages};

//+----------------------------------------------------------------------------
// NTDS-DSA Object.
//-----------------------------------------------------------------------------

//
// NTDS-DSA General page, Global Catalog bit in [options] attribute
//
ATTR_MAP UGlobalCatalog = {IDC_NTDSDSA_GLOBAL_CATALOG, FALSE, FALSE, 0x1,
                          {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER,
                          NULL, 0}, FirstSharedBitField, NULL};
//
// NTDS-DSA General page, Query policy edit field
//
ATTR_MAP UQueryPolicy = {IDC_NTDSDSA_QUERY_POLICY, FALSE, FALSE, 3,
                          {L"queryPolicyObject", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                          NULL, 0}, DsQueryPolicy, NULL};
//
// NTDS-DSA General page, Query policy edit field
//
ATTR_MAP UNTDSDSA_DNSAlias = {IDC_EDIT1, TRUE /* read-only */, FALSE, 0,
                          {L"objectGUID", ADS_ATTR_UPDATE, ADSTYPE_OCTET_STRING,
                          NULL, 0}, NTDSDSA_DNSAlias, NULL};
//
// The list of attributes on the NTDS-DSA General page.
//
PATTR_MAP rgpNTDS_DSAGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
            ,{&UQueryPolicy}
            ,{&UGlobalCatalog}
            ,{&UNTDSDSA_DNSAlias}
            // ,{&UScheduleBtn_FF_Default}
            };

//
// The NTDS-DSA General page description.
//
DSPAGE NTDS_DSAGeneral = {IDS_TITLE_GENERAL, IDD_NTDSDSA_GENERAL,
                      0, 0, NULL, CreateTableDrivenPage,
                      sizeof(rgpNTDS_DSAGenAttrMap)/sizeof(PATTR_MAP),
                      rgpNTDS_DSAGenAttrMap};

//
// NTDS-DSA General page, Replicate From/To listviews
//
ATTR_MAP UReplicateFrom = {IDC_NTDSDSA_REPLICATE_FROM, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                           {NULL, ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                           NULL, 0}, DsReplicateListbox, NULL};
ATTR_MAP UReplicateTo = {IDC_NTDSDSA_REPLICATE_TO, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                           {NULL, ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                           NULL, 0}, DsReplicateListbox, (PVOID)1};

//
// The list of attributes on the NTDS-DSA Connections page.
//
PATTR_MAP rgpNTDS_DSAConnAttrMap[] = {{&UReplicateFrom},{&UReplicateTo}};

//
// The NTDS-DSA Connections page description.
//
DSPAGE NTDS_DSAConn = {IDS_TITLE_NTDSDSA_CONN, IDD_NTDSDSA_CONN,
                            0, 0, NULL, CreateTableDrivenPage,
                            sizeof(rgpNTDS_DSAConnAttrMap)/sizeof(PATTR_MAP),
                            rgpNTDS_DSAConnAttrMap};
//
// The list of NTDS-DSA pages.
//
PDSPAGE rgNTDS_DSAPages[] = {{&NTDS_DSAGeneral},{&NTDS_DSAConn}};

//
// The NTDS-DSA class description.
//
DSCLASSPAGES NTDS_DSACls = {&CLSID_DsReplDSAPropPages, TEXT("NTDS-DSA"),
                        sizeof(rgNTDS_DSAPages)/sizeof(PDSPAGE),
                        rgNTDS_DSAPages};

//+----------------------------------------------------------------------------
// DS Server Object.
//-----------------------------------------------------------------------------

//
// Used by various pages which use duelling listboxes
//
ATTR_MAP DuellingAttr_Add = {IDC_DUELLING_RB_ADD, TRUE,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_DN_STRING,
                          NULL, 0}, DuellingListboxButton, NULL};
ATTR_MAP DuellingAttr_Remove = {IDC_DUELLING_RB_REMOVE, TRUE,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {NULL, ADS_ATTR_UPDATE,
                          ADSTYPE_DN_STRING,
                          NULL, 0}, DuellingListboxButton, NULL};

//
// DS Server General page, Bridgehead For listbox
//
ATTR_MAP UBridgeheadList_In = {IDC_DUELLING_LB_IN, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                               {L"bridgeheadTransportList", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                                NULL, 0},
                               DsQueryBridgeheadList, NULL};
ATTR_MAP UBridgeheadList_Out = {IDC_DUELLING_LB_OUT, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                                {L"bridgeheadTransportList", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                                 NULL, 0},
                                DuellingListbox, NULL};
//
// Server General page, Change Computer button
//
// JonN 4/17/01 275336
// DS Sites Snapin - dssite.msc - NTDS Settings object will never need to switch servers
// We leave this in place to populate the text fields, and disable the button itself.
ATTR_MAP UChangeComputer = {IDC_COMPUTER_BTN, FALSE, FALSE, 0,
                          {g_wzServerRef, ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          ComputerChangeBtn, NULL};

//
// The list of attributes on the DS Server General page.
//
PATTR_MAP rgpDsServerGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
       ,{&UBridgeheadList_In}
       ,{&DuellingAttr_Add}
       ,{&DuellingAttr_Remove}
       ,{&UBridgeheadList_Out}
       ,{&UChangeComputer}
    // ,{&UScheduleBtn}
    };

//
// The DS Server General page description.
//
DSPAGE DsServerGeneral = {IDS_TITLE_GENERAL, IDD_DS_SERVER_GENERAL,
                            0, 0, NULL, CreateTableDrivenPage,
                            sizeof(rgpDsServerGenAttrMap)/sizeof(PATTR_MAP),
                            rgpDsServerGenAttrMap};
//
// The list of DS Server pages.
//
PDSPAGE rgDsServerPages[] = {{&DsServerGeneral}};

//
// The DS Server class description.
//
DSCLASSPAGES DsServerCls = {&CLSID_DsReplServerPropPages, TEXT("Server"),
                              sizeof(rgDsServerPages)/sizeof(PDSPAGE),
                              rgDsServerPages};

//+----------------------------------------------------------------------------
// DS Connection Object.
//-----------------------------------------------------------------------------

//
// DS Connection General page, From Server edit field
//

//
// Change Server button
//
ATTR_MAP UFromServerBtn = {IDC_SERVER_BTN, FALSE, FALSE, 0,
                          {L"fromServer", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          nTDSDSAAndDomainChangeBtn, NULL};

ATTR_MAP UConnectionOptions = {0, FALSE, FALSE, 0,
                     {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER,
                      NULL, 0}, nTDSConnectionOptions, NULL};

//
// DS Connection General page, siteObject attribute
//
// 01/28/98 JonN: Note that this is transportType rather than
//   overSiteConnector (as of the upcoming IDS)
//
ATTR_MAP UInterSiteTarget = {IDC_DS_INTERSITE_IN_CONNECTION, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                             {L"transportType", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING,
                             NULL, 0}, DsQueryInterSiteTransport, NULL};

//
// The list of attributes on the DS Connection General page.
//
PATTR_MAP rgpDsConnectionGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
            ,{&UConnectionOptions}
            ,{&UInterSiteTarget}
#ifdef CUSTOM_SCHEDULE
            ,{&UScheduleCheckbox}
#endif
            ,{&UScheduleBtn_FF_Default}
            ,{&UFromServerBtn}
			};

//
// Note that this page is not in the main table-driven array; rather, it is substituted
// for DsConnectionGeneral when the parent is an NTFRS object.
// See siterepl.cxx for more details.
//
DSPAGE DsConnectionGeneral = {IDS_TITLE_GENERAL, IDD_DS_CONNECTION_GENERAL,
                      0, 0, NULL, NULL,
                      sizeof(rgpDsConnectionGenAttrMap)/sizeof(PATTR_MAP),
                      rgpDsConnectionGenAttrMap};

//
// Note that this page uses CreateDsOrFrsConnectionPage rather than
// CreateTableDrivenPage.  See siterepl.cxx for more details.
//

DSPAGE DsOrFrsConnectionGeneral = {0, 0,
                      0, 0, NULL, CreateDsOrFrsConnectionPage,
                      0,
                      NULL};

//
// The list of DS Connection pages.
//
PDSPAGE rgDsConnectionPages[] = {{&DsOrFrsConnectionGeneral}};

//
// The DS Connection class description.
//
DSCLASSPAGES DsConnectionCls = {&CLSID_DsReplConnectionPropPages, TEXT("NTDS-Connection"),
                        sizeof(rgDsConnectionPages)/sizeof(PDSPAGE),
                        rgDsConnectionPages};

//+----------------------------------------------------------------------------
// FRS Objects.
//-----------------------------------------------------------------------------

//
// FRS Root Path edit field
//
ATTR_MAP UFrsRootPath = {IDC_FRS_ROOT_PATH, TRUE /* read-only */,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {L"fRSRootPath", ADS_ATTR_UPDATE,
						  ADSTYPE_CASE_IGNORE_STRING,
                          NULL, 0}, NULL, NULL};
ATTR_MAP UFrsStagingPath = {IDC_FRS_STAGING_PATH, TRUE /* read-only */,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {L"fRSStagingPath", ADS_ATTR_UPDATE,
						  ADSTYPE_CASE_IGNORE_STRING,
                          NULL, 0}, NULL, NULL};
ATTR_MAP UFrsDirectoryFilter = {IDC_EDIT1, FALSE,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {L"fRSDirectoryFilter", ADS_ATTR_UPDATE,
						  ADSTYPE_CASE_IGNORE_STRING,
                          NULL, 0}, NULL, NULL};
ATTR_MAP UFrsFileFilter = {IDC_EDIT2, FALSE,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {L"fRSFileFilter", ADS_ATTR_UPDATE,
						  ADSTYPE_CASE_IGNORE_STRING,
                          NULL, 0}, NULL, NULL};
/*
ATTR_MAP UFrsPrimaryMember = {IDC_EDIT3, FALSE,
                          FALSE, ATTR_LEN_UNLIMITED,
                          {L"fRSPrimaryMember", ADS_ATTR_UPDATE,
                          ADSTYPE_DN_STRING,
                          NULL, 0}, DsQueryFrsPrimaryMember};
*/
ATTR_MAP UFrsComputerBtn = {IDC_COMPUTER_BTN, TRUE /* read-only */, FALSE, 0,
                          {L"frsComputerReference", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          ComputerChangeBtn, NULL};
//
// Change Member button, any FRS-Member
//
ATTR_MAP UFromAnyMemberBtn = {IDC_SERVER_BTN, TRUE /* read-only */, FALSE, 0,
                          {L"fRSMemberReference", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          FRSAnyMemberChangeBtn, NULL};

PATTR_MAP rgpFrsReplicaSetAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description},
            {&UFrsDirectoryFilter},
            {&UFrsFileFilter},
//            {&UFrsPrimaryMember},
#ifdef CUSTOM_SCHEDULE
            {&UScheduleCheckbox},
#endif
            {&UReplicationScheduleBtn}};
PATTR_MAP rgpFrsMemberAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description},
            {&UFrsComputerBtn} };
PATTR_MAP rgpFrsSubscriberAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description},
			{&UFrsRootPath},
			{&UFrsStagingPath},
			{&UFromAnyMemberBtn}};
DSPAGE FrsReplicaSetPage = {IDS_TITLE_NTFRS_REPLICA_SET, IDD_NTFRS_REPLICA_SET_GENERAL, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpFrsReplicaSetAttrMap)/sizeof(PATTR_MAP),
                      rgpFrsReplicaSetAttrMap};
DSPAGE FrsMemberPage = {IDS_TITLE_NTFRS_MEMBER, IDD_NTFRS_MEMBER_GENERAL, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpFrsMemberAttrMap)/sizeof(PATTR_MAP),
                      rgpFrsMemberAttrMap};
DSPAGE FrsSubscriberPage = {IDS_TITLE_NTFRS_SUBSCRIBER, IDD_NTFRS_SUBSCRIBER_GENERAL, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpFrsSubscriberAttrMap)/sizeof(PATTR_MAP),
                      rgpFrsSubscriberAttrMap};
PDSPAGE rgFrsReplicaSetPages[] = {{&FrsReplicaSetPage}};
PDSPAGE rgFrsMemberPages[] = {{&FrsMemberPage}};
PDSPAGE rgFrsSubscriberPages[] = {{&FrsSubscriberPage}};
DSCLASSPAGES FrsReplicaSetCls = {&CLSID_DsFrsReplicaSet, TEXT("NTFRS-Replica-Set"),
                        sizeof(rgFrsReplicaSetPages)/sizeof(PDSPAGE),
                        rgFrsReplicaSetPages};
DSCLASSPAGES FrsMemberCls = {&CLSID_DsFrsMember, TEXT("NTFRS-Member"),
                        sizeof(rgFrsMemberPages)/sizeof(PDSPAGE),
                        rgFrsMemberPages};
DSCLASSPAGES FrsSubscriberCls = {&CLSID_DsFrsSubscriber, TEXT("NTFRS-Subscriber"),
                        sizeof(rgFrsSubscriberPages)/sizeof(PDSPAGE),
                        rgFrsSubscriberPages};

//
// The FRS Connection General page description.
//
// Note that this page is not in the main table-driven array; rather, it is substituted
// for DsConnectionGeneral when the parent is an NTFRS object.
// See siterepl.cxx for more details.

//
// Change Member button, limited to members in this same replica
//
ATTR_MAP UFromMemberInReplicaBtn = {IDC_SERVER_BTN, FALSE, FALSE, 0,
                          {L"fromServer", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                          FRSMemberInReplicaChangeBtn, NULL};
PATTR_MAP rgpFrsConnectionGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description},
        {&UFromMemberInReplicaBtn },
#ifdef CUSTOM_SCHEDULE
        {&UScheduleCheckbox},
#endif
        {&UReplicationScheduleBtn}};
// CODEWORK change this to reflect FRS-Connection specifics
DSPAGE FrsConnectionGeneral = {IDS_TITLE_FRS_CONNECTION, IDD_FRS_CONNECTION_GENERAL,
                      0, 0, NULL, NULL,
                      sizeof(rgpFrsConnectionGenAttrMap)/sizeof(PATTR_MAP),
                      rgpFrsConnectionGenAttrMap};

//+----------------------------------------------------------------------------
// Container General Page.
//-----------------------------------------------------------------------------

//
// The list of attributes on the Container General page.
//
PATTR_MAP rgpContainerGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}};

//
// The Container General page description.
//
DSPAGE ContainerGeneral = {IDS_TITLE_GENERAL, IDD_CONTAINER_GENERAL, 0, 0, NULL,
                           CreateTableDrivenPage,
                           sizeof(rgpContainerGenAttrMap)/sizeof(PATTR_MAP),
                           rgpContainerGenAttrMap};
//
// The list of Container pages.
//
PDSPAGE rgContainerPages[] = {{&ContainerGeneral}};

//
// The Container class description.
//
DSCLASSPAGES ContainerCls = {&CLSID_DsContainerGeneralPage, TEXT("Container"),
                             sizeof(rgContainerPages)/sizeof(PDSPAGE),
                             rgContainerPages};
//+----------------------------------------------------------------------------
// RPC Container General Page.
//-----------------------------------------------------------------------------

//
// RPC Container General page, Flags attribute
//
ATTR_MAP RpcFlags = {IDC_COMPAT_CHK, FALSE, FALSE, 0, {L"nameServiceFlags",
                     ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0}, IntegerAsBoolDefOn, NULL};
//
// The list of attributes on the Rpc General page.
//
PATTR_MAP rgpRpcGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&RpcFlags}};

//
// The Rpc General page description.
//
DSPAGE RpcGeneral = {IDS_TITLE_GENERAL, IDD_RPC_GEN, 0, 0, NULL,
                     CreateTableDrivenPage,
                     sizeof(rgpRpcGenAttrMap)/sizeof(PATTR_MAP),
                     rgpRpcGenAttrMap};
//
// The list of Rpc pages.
//
PDSPAGE rgRpcPages[] = {{&RpcGeneral}};

//
// The Rpc Container class description.
//
DSCLASSPAGES RpcCls = {&CLSID_DsRpcContainer, TEXT("Rpc Container"),
                       sizeof(rgRpcPages)/sizeof(PDSPAGE), rgRpcPages};

//+----------------------------------------------------------------------------
// FPO General Page
//-----------------------------------------------------------------------------

//
// Object Name: derived from SID.
//
ATTR_MAP FPOrealName = {IDC_CN, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                        {NULL, ADS_ATTR_UPDATE,
						 ADSTYPE_CASE_IGNORE_STRING, NULL, 0},
                        GetAcctName, NULL};
//
// The list of attributes on the FPO General page.
//
PATTR_MAP rgpFPOGenAttrMap[] = {{&GenIcon}, {&FPOrealName}, {&Description}};

//
// The FPO page description.
//
DSPAGE FPOGeneral = {IDS_TITLE_GENERAL, IDD_FPO_GENERAL, 0, 0, NULL,
                     CreateTableDrivenPage,
                     sizeof(rgpFPOGenAttrMap)/sizeof(PATTR_MAP),
                     rgpFPOGenAttrMap};
//
// The list of FPO pages.
//
PDSPAGE rgFPOPages[] = {{&FPOGeneral}, {&NonSecMemberPage}};

//
// The FPO class description.
//
DSCLASSPAGES FPOCls = {&CLSID_DsFSPOPropPages, TEXT("FPO"),
                       sizeof(rgFPOPages)/sizeof(PDSPAGE), rgFPOPages};

//+----------------------------------------------------------------------------
// Default General Page (for the default display specifier).
//-----------------------------------------------------------------------------

//
// The list of attributes on the Default General page.
//
PATTR_MAP rgpDefaultGenAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}};

//
// The Default General page description.
//
DSPAGE DefaultGeneral = {IDS_TITLE_GENERAL, IDD_DEFAULT_GENERAL, 0, 0, NULL,
                         CreateTableDrivenPage,
                         sizeof(rgpDefaultGenAttrMap)/sizeof(PATTR_MAP),
                         rgpDefaultGenAttrMap};
//
// The list of Default pages.
//
PDSPAGE rgDefaultPages[] = {{&DefaultGeneral}};

//
// The Default class description.
//
DSCLASSPAGES DefaultCls = {&CLSID_DsDefaultGeneralPage, TEXT("Default"),
                           sizeof(rgDefaultPages)/sizeof(PDSPAGE),
                           rgDefaultPages};

//+----------------------------------------------------------------------------
// Default General Multi-select Page (for the default display specifier).
//-----------------------------------------------------------------------------

//
// The list of attributes on the Default General page.
//
PATTR_MAP rgpDefaultGenMultiAttrMap[] = {{&Description}};

//
// The Default General page description.
//
DSPAGE DefaultMultiGeneral = {IDS_TITLE_GENERAL, IDD_DEFAULT_MULTI_GENERAL, 0, 0, NULL,
                              CreateGenericMultiPage,
                              sizeof(rgpDefaultGenMultiAttrMap)/sizeof(PATTR_MAP),
                              rgpDefaultGenMultiAttrMap};
//
// The list of Default pages.
//
PDSPAGE rgDefaultMultiPages[] = {{&DefaultMultiGeneral}};

//
// The Default class description.
//
DSCLASSPAGES DefaultMultiCls = {&CLSID_DsDefaultMultiGeneralPage, TEXT("Default"),
                                sizeof(rgDefaultMultiPages)/sizeof(PDSPAGE),
                                rgDefaultMultiPages};

//----------------------------------------------
// Multi-select Address page, Address
//

//----------------------------------------------

//
// The list of attributes on the User General page.
//
PATTR_MAP rgpUGenAttrMap[] = {{&GenIcon}, {&Description},
                              {&UGOffice}, {&UGPhone},
                              {&UGEMail}, {&UGURL},
                              {&UPhFax} };

//
// The User General page
//
DSPAGE UserMultiGeneral = {IDS_TITLE_GENERAL, IDD_MULTI_USER_GENERAL, 0, 0, NULL,
                           CreateMultiGeneralUserPage, sizeof(rgpUGenAttrMap)/sizeof(PATTR_MAP),
                           rgpUGenAttrMap};

//
// The User Account page description.
//
DSPAGE UserMultiAccount = {IDS_USER_TITLE_ACCT, IDD_MULTI_ACCOUNT, 0, 0, NULL,
                            CreateUserMultiAcctPage, 0, NULL};

//
// Address page description.
//
DSPAGE UserMultiAddress = {IDS_TITLE_ADDRESS, IDD_MULTI_USER_ADDRESS, 0, 0, NULL,
                            CreateMultiAddressUserPage,
                            sizeof(rgpUAddrAttrMap)/sizeof(PATTR_MAP),
                            rgpUAddrAttrMap};

//
// The Organization page description.
//
DSPAGE UserMultiOrg = {IDS_USER_TITLE_ORG, IDD_MULTI_USER_ORG, 0, 0, NULL,
                        CreateMultiOrganizationUserPage,
                        sizeof(rgpUOrgAttrMap)/sizeof(PATTR_MAP), rgpUOrgAttrMap};

//----------------------------------------------
// The User Profile page description.
//
DSPAGE UserMultiProfile = {IDS_USER_TITLE_PROFILE, IDD_MULTI_USER_PROFILE, 0, 0, NULL,
                           CreateMultiUsrProfilePage, 0, NULL};



PDSPAGE rgUserMultiPages[] = {{&UserMultiGeneral}, {&UserMultiAccount}, {&UserMultiAddress}, /*{&MultiPhoneNotes},*/
                              {&UserMultiProfile}, {&UserMultiOrg}};
//                        {{&UserGeneral}, {&UserAddress}, 
//                         {&UserProfile}, {&PhoneNotes}, {&FPNWPage},
//                         {&UserOrg}, {&PubCertPage}, {&MemberPage}};

//
// The User class description.
//
DSCLASSPAGES UserMultiCls = {&CLSID_DsUserMultiPropPages, TEXT("User"),
                              sizeof(rgUserMultiPages)/sizeof(PDSPAGE),
                              rgUserMultiPages};

//+----------------------------------------------------------------------------
// Inter-Site Transport Objects.
//-----------------------------------------------------------------------------

// CODEWORK this should support (lower priority) read-only Bridgehead-Transport-List-BL
ATTR_MAP UIntersiteIgnoreSchedules = {IDC_CHECK1, FALSE, FALSE,
                            NTDSTRANSPORT_OPT_IGNORE_SCHEDULES,
                            {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            FirstSharedBitField, NULL};
ATTR_MAP UIntersiteSitelinksBridged = {IDC_CHECK2, TRUE /* read-only */, FALSE,
                            ~((DWORD)NTDSTRANSPORT_OPT_BRIDGES_REQUIRED),
                            {L"options", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                            SubsequentSharedBitField, NULL};
PATTR_MAP rgpIntersiteGeneralAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
                        , {&UIntersiteIgnoreSchedules}
                        , {&UIntersiteSitelinksBridged}
                        };
DSPAGE IntersiteGeneral = {IDS_TITLE_GENERAL, IDD_INTERSITE_GENERAL, 0, 0, NULL,
                      CreateTableDrivenPage,
                      sizeof(rgpIntersiteGeneralAttrMap)/sizeof(PATTR_MAP),
                      rgpIntersiteGeneralAttrMap};
PDSPAGE rgIntersiteGeneralPages[] = {{&IntersiteGeneral}};
DSCLASSPAGES IntersiteSettingsCls = {&CLSID_DsIntersitePropPages, TEXT("Inter-Site-Transport"),
                        sizeof(rgIntersiteGeneralPages)/sizeof(PDSPAGE),
                        rgIntersiteGeneralPages};


ATTR_MAP AttrSiteList_In= {IDC_DUELLING_LB_IN, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                           {L"siteList", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                           DsQuerySiteList, NULL};
ATTR_MAP AttrSiteList_Out = {IDC_DUELLING_LB_OUT, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                             {L"siteList", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                             DuellingListbox, NULL};
ATTR_MAP AttrCostEdit = {IDC_EDIT1, FALSE, FALSE, IDC_SPIN /* spinbutton ID */,
                          {L"cost", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                          EditNumber, NULL};
ATTR_MAP AttrCostSpin = {IDC_SPIN, TRUE /* read-only */, FALSE, 99999,
                          {L"cost", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                          SpinButton, (PVOID)1};
ATTR_MAP AttrReplIntervalEdit = {IDC_EDIT2, FALSE, FALSE, IDC_SPIN2 /* spinbutton ID */,
                          {L"replInterval", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                          EditNumber, NULL};
ATTR_MAP AttrReplIntervalSpin = {IDC_SPIN2, TRUE /* read-only */, FALSE, 7*24*60,
                          {L"replInterval", ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                          SpinButton, (PVOID)15};
ATTR_MAP AttrReplIntervalIncrement = {IDC_SPIN2, TRUE /* read-only */, FALSE, 15,
                          {NULL, ADS_ATTR_UPDATE, ADSTYPE_INTEGER, NULL, 0},
                          SpinButtonExtendIncrement, NULL};
PATTR_MAP rgpSiteLinkAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
                        , {&AttrSiteList_In}
                        , {&DuellingAttr_Add}
                        , {&DuellingAttr_Remove}
                        , {&AttrSiteList_Out}
                        , {&AttrCostEdit}
                        , {&AttrCostSpin}
                        , {&AttrReplIntervalEdit}
                        , {&AttrReplIntervalSpin}
                        , {&AttrReplIntervalIncrement}
#ifdef CUSTOM_SCHEDULE
                        , {&UScheduleCheckbox}
#endif
                        , {&UReplicationScheduleBtn}
                        };
DSPAGE DsSiteLinkGeneral = {IDS_TITLE_GENERAL, IDD_SITELINK_GENERAL,
                      0, 0, NULL, CreateTableDrivenPage,
                      sizeof(rgpSiteLinkAttrMap)/sizeof(PATTR_MAP),
                      rgpSiteLinkAttrMap};

ATTR_MAP AttrSiteLinkList_In= {IDC_DUELLING_LB_IN, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                               {L"siteLinkList", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                                DsQuerySiteLinkList, NULL};
ATTR_MAP AttrSiteLinkList_Out = {IDC_DUELLING_LB_OUT, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                                 {L"siteLinkList", ADS_ATTR_UPDATE, ADSTYPE_DN_STRING, NULL, 0},
                                 DuellingListbox, NULL};
PATTR_MAP rgpSiteLinkBridgeAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}
                        , {&AttrSiteLinkList_In}
                        , {&DuellingAttr_Add}
                        , {&DuellingAttr_Remove}
                        , {&AttrSiteLinkList_Out}
                        };
DSPAGE DsSiteLinkBridgeGeneral = {IDS_TITLE_GENERAL, IDD_SITELINKBRIDGE_GENERAL,
                      0, 0, NULL, CreateTableDrivenPage,
                      sizeof(rgpSiteLinkBridgeAttrMap)/sizeof(PATTR_MAP), // temporary
                      rgpSiteLinkBridgeAttrMap};

PDSPAGE rgDsSiteLinkPages[] = {{&DsSiteLinkGeneral}};
PDSPAGE rgDsSiteLinkBridgePages[] = {{&DsSiteLinkBridgeGeneral}};

DSCLASSPAGES DsSiteLinkCls = {&CLSID_DsReplSiteLink, TEXT("Site-Link"),
                        sizeof(rgDsSiteLinkPages)/sizeof(PDSPAGE),
                        rgDsSiteLinkPages};
DSCLASSPAGES DsSiteLinkBridgeCls = {&CLSID_DsReplSiteLinkBridge, TEXT("Site-Link-Bridge"),
                        sizeof(rgDsSiteLinkBridgePages)/sizeof(PDSPAGE),
                        rgDsSiteLinkBridgePages};

//+----------------------------------------------------------------------------
// Object Page (Top properties).
//-----------------------------------------------------------------------------

//
// Object Path.
//
ATTR_MAP ObjectPath = {IDC_PATH_FIELD, TRUE, FALSE, 0,
                       {g_wzADsPath, ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, ObjectPathField, NULL};
//
// Object class.
//
ATTR_MAP ObjectClass = {IDC_CLASS_STATIC, TRUE, FALSE, 0,
                        {g_wzClass, ADS_ATTR_UPDATE,
                         ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, GetObjectClass, NULL};
//
// Timestamp Created.
//
ATTR_MAP TimeCreated = {IDC_CREATED_TIME_STATIC, TRUE, FALSE, 0,
                        {L"whenCreated", ADS_ATTR_UPDATE,
                        ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, GetObjectTimestamp, NULL};
//
// Timestamp Last Modified.
//
ATTR_MAP TimeModified = {IDC_MODIFIED_TIME_STATIC, TRUE, FALSE, 0,
                         {L"whenChanged", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, GetObjectTimestamp, NULL};
//
// USN Created.
//
ATTR_MAP USNCreated = {IDC_USN_CREATED_STATIC, TRUE, FALSE, 0,
                       {L"uSNCreated", ADS_ATTR_UPDATE,
                        ADSTYPE_LARGE_INTEGER, NULL, 0}, NULL, NULL};
//
// USN Changed.
//
ATTR_MAP USNChanged = {IDC_USN_MODIFIED_STATIC, TRUE, FALSE, 0,
                       {L"uSNChanged", ADS_ATTR_UPDATE,
                        ADSTYPE_LARGE_INTEGER, NULL, 0}, NULL, NULL};
//
// The list of attributes on the Top page.
//
PATTR_MAP rgpTopAttrMap[] = {{&ObjectPath}, {&ObjectClass}, {&TimeCreated},
                             {&TimeModified}, {&USNCreated}, {&USNChanged}};

//
// The Top page description.
//
DSPAGE TopPage = {IDS_OBJECT, IDD_OBJECT, DSPROVIDER_ADVANCED, 0, NULL,
                  CreateTableDrivenPage,
                  sizeof(rgpTopAttrMap)/sizeof(PATTR_MAP), rgpTopAttrMap};
//
// The list of Top pages.
//
PDSPAGE rgTopPages[] = {{&TopPage}};

//
// The Top class description.
//
DSCLASSPAGES TopCls = {&CLSID_DsTopPropPages, TEXT("Top"),
                       sizeof(rgTopPages)/sizeof(PDSPAGE),
                       rgTopPages};

//+----------------------------------------------------------------------------
// Printer Queue Object.
//-----------------------------------------------------------------------------

//
// PrintQueueName.
//
ATTR_MAP PrintQueueName = {IDC_CN, TRUE, FALSE,
                               1024, {L"printerName", ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Description.
//
ATTR_MAP PrintQueueDesc = {IDC_DESC_EDIT, FALSE, FALSE,
                           1024, {L"description", ADS_ATTR_UPDATE,
                                  ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Location.
//
ATTR_MAP PrintQueueLocation = {IDC_LOCATION_EDIT, FALSE, FALSE,
                               1024, {L"location", ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

//
// Model. 
//
ATTR_MAP PrintQueueModel = {IDC_MODEL_EDIT, FALSE, FALSE,
                               1024, {L"driverName", ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

//
// color.
//
ATTR_MAP PrintQueueColor = {IDC_CHECK_COLOR, FALSE, FALSE,
                               1024, {L"printColor", ADS_ATTR_UPDATE,
                               ADSTYPE_BOOLEAN, NULL, 0}, NULL, NULL};

//
// staple.
//
ATTR_MAP PrintQueueStaple = {IDC_CHECK_STAPLE, FALSE, FALSE,
                               1024, {L"printStaplingSupported", ADS_ATTR_UPDATE,
                               ADSTYPE_BOOLEAN, NULL, 0}, NULL, NULL};

//
// Speed.
//
ATTR_MAP PrintQueueSpeed = {IDC_EDIT_SPEED, FALSE, FALSE,
                               10, {L"printRate", ADS_ATTR_UPDATE,
                               ADSTYPE_INTEGER, 0}, NULL, NULL};

//
// Resolution.
//
ATTR_MAP PrintQueueResolution = {IDC_EDIT_RESOLUTION, FALSE, FALSE,
                               10, {L"printMaxResolutionSupported", ADS_ATTR_UPDATE,
                               ADSTYPE_INTEGER, NULL, 0}, NULL, NULL};

//
// Duplex.
//
ATTR_MAP PrintQueueDuplex = {IDC_CHECK_DOUBLE_SIDED, FALSE, FALSE,
                               1024, {L"printDuplexSupported", ADS_ATTR_UPDATE,
                               ADSTYPE_BOOLEAN, NULL, 0}, NULL, NULL};

//
// The list of attributes on the Printer Queue General page.
//
PATTR_MAP rgpPrintQGenAttrMap[] = {{&GenIcon}, {&PrintQueueName}, {&PrintQueueDesc},
                                   {&PrintQueueLocation}, {&PrintQueueModel},
                                   {&PrintQueueColor}, {&PrintQueueStaple},
                                   {&PrintQueueDuplex}, {&PrintQueueSpeed},
                                   {&PrintQueueResolution}};

//
// The Printer Queue General page description.
//
DSPAGE PrinterQueueGen = {IDS_TITLE_GENERAL, IDD_GENERAL_PRINTQ, 0, 0, NULL,
                          CreateTableDrivenPage,
                          sizeof(rgpPrintQGenAttrMap)/sizeof(PATTR_MAP),
                          rgpPrintQGenAttrMap};
//
// The list of Printer Queue pages.
//
PDSPAGE rgPrintQPages[] = {{&PrinterQueueGen}, {&ManagedByPage}};

//
// The DS Print Queue class description.
//
DSCLASSPAGES PrinterQCls = {&CLSID_DsPrinterPropPages, TEXT("Printer-Queue"),
                            sizeof(rgPrintQPages)/sizeof(PDSPAGE),
                            rgPrintQPages};

//+----------------------------------------------------------------------------
// The list of classes.
//-----------------------------------------------------------------------------

PDSCLASSPAGES rgClsPages[] = {
    &UserCls,
    &inetOrgPersonCls,
    &MemberCls,
    &ContactCls,
    &GroupCls,
    &OUCls,
    &ContainerCls,
    &DomainCls,
    &DomainPolicyCls,
    &LocalPolicyCls,
    &TrustedDomainCls,
    &ManagedByCls,
    &SiteCls,
    &DsSiteSettingsCls,
    &DsSiteLicenseSettingsCls,
    &DsServerCls,
    &NTDS_DSACls,
    &DsConnectionCls,
    &FrsReplicaSetCls,
    &FrsMemberCls,
    &FrsSubscriberCls,
    &IntersiteSettingsCls,
    &DsSiteLinkCls,
    &DsSiteLinkBridgeCls,
    &SubnetCls,
    &VolumeCls,
    &ComputerCls,
    &TopCls,
    &PrinterQCls,
    &RpcCls,
    &FPOCls,
    &DefaultCls,
    &DefaultMultiCls,
    &UserMultiCls,
};


//+----------------------------------------------------------------------------
// The global struct containing the list of classes.
//-----------------------------------------------------------------------------
RGDSPPCLASSES g_DsPPClasses = {sizeof(rgClsPages)/sizeof(PDSCLASSPAGES),
                               rgClsPages};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\multi.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       multi.cxx
//
//  Contents:   CDsMultiPageBase, the class that implements the generic
//              multi-select property page.
//
//  History:    16-Nov-99 JeffJon created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "multi.h"

#include "uacct.h"
#include "chklist.h"
#include "user.h"   // ExpandUsername

#include <aclapi.h>

extern ATTR_MAP LogonWkstaBtn;
extern const GUID GUID_CONTROL_UserChangePassword;

#ifdef DSADMIN

//
// Attr map flags
//
#define DISABLE_ON_EMPTY      0x80000000  // Ctrl is enabled/disabled based on the contents of another control
#define ALWAYS_DISABLED       0x40000000  // Ctrl is always disabled  
#define CLEAR_FIELD           0x20000000  // Clear the window text of the control when the apply check is removed
#define SELECT_CB_ON_ENABLE   0x10000000  // Select the first item in the associated combobox when the checkbox is checked

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiPageBase::CDsMultiPageBase
//
//-----------------------------------------------------------------------------
CDsMultiPageBase::CDsMultiPageBase(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                         HWND hNotifyObj, DWORD dwFlags) 
  : CDsTableDrivenPage(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  TRACE(CDsMultiPageBase,CDsMultiPageBase);
  m_pApplyMap = NULL;
  m_fMultiselectPage = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiPageBase::~CDsMultiPageBase
//
//-----------------------------------------------------------------------------
CDsMultiPageBase::~CDsMultiPageBase()
{
    TRACE(CDsMultiPageBase,~CDsMultiPageBase);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateGenericMultiPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT CreateGenericMultiPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                               PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                               const CDSSmartBasePathsInfo& /*basePathsInfo*/, 
                               HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateGenericMultiPage);

    CDsGenericMultiPage * pPageObj = new CDsGenericMultiPage(pDsPage, pDataObj,
                                                              hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzClass);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateMultiUserPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT CreateMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                               PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                               const CDSSmartBasePathsInfo& /*basePathsInfo*/, 
                               HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CDsUserMultiPage);

  CDsUserMultiPage * pPageObj = new CDsUserMultiPage(pDsPage, pDataObj,
                                                     hNotifyObj, dwFlags);
  CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

  pPageObj->Init(pwzClass);

  return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateMultiGeneralUserPage
//
//  Synopsis:   Creates an instance of the multi-select general user page
//
//-----------------------------------------------------------------------------
HRESULT CreateMultiGeneralUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                               PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                               const CDSSmartBasePathsInfo& /*basePathsInfo*/, 
                               HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CreateMultiGeneralUserPage);

  CDsGeneralMultiUserPage * pPageObj = new CDsGeneralMultiUserPage(pDsPage, pDataObj,
                                                     hNotifyObj, dwFlags);
  CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

  pPageObj->Init(pwzClass);

  return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateMultiOrganizationUserPage
//
//  Synopsis:   Creates an instance of the multi-select general user page
//
//-----------------------------------------------------------------------------
HRESULT CreateMultiOrganizationUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                               PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                               const CDSSmartBasePathsInfo& /*basePathsInfo*/,
                               HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CreateMultiOrganizationUserPage);

  CDsOrganizationMultiUserPage* pPageObj = new CDsOrganizationMultiUserPage(pDsPage, pDataObj,
                                                     hNotifyObj, dwFlags);
  CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

  pPageObj->Init(pwzClass);

  return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateMultiAddressUserPage
//
//  Synopsis:   Creates an instance of the multi-select address user page
//
//-----------------------------------------------------------------------------
HRESULT CreateMultiAddressUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                               PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                               const CDSSmartBasePathsInfo& /*basePathsInfo*/,
                               HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CreateMultiAddressUserPage);

  CDsAddressMultiUserPage* pPageObj = new CDsAddressMultiUserPage(pDsPage, pDataObj,
                                                     hNotifyObj, dwFlags);
  CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

  pPageObj->Init(pwzClass);

  return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiPageBase::Init
//
//  Synopsis:   Initialize the page object. This is the second part of a two
//              phase creation where operations that could fail are located.
//              Failures here are recorded in m_hrInit and then an error page
//              is substituted in CreatePage.
//
//-----------------------------------------------------------------------------
void CDsMultiPageBase::Init(PWSTR pszClass)
{
  TRACE(CDsMultiPageBase,Init);
  CWaitCursor cWait;

  if (!AllocWStr(pszClass, &m_pwszObjClass))
  {
      m_hrInit = E_OUTOFMEMORY;
      return;
  }

  //
  // Allocate memory for the attribute data.
  //
  m_rgAttrData = new ATTR_DATA[m_cAttrs];
  CHECK_NULL(m_rgAttrData, m_hrInit = E_OUTOFMEMORY; return);

  memset(m_rgAttrData, 0, m_cAttrs * sizeof(ATTR_DATA));

  //
  // Marshall the data object pointer for passing to the window proc thread.
  //
  HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, m_pDataObj,
                                             &m_pDataObjStrm);
  m_pDataObj = NULL; // to make sure no one calls here
  CHECK_HRESULT(hr, m_hrInit = hr; return);
}
  
//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CDsMultiPageBase::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return SUCCEEDED(InitDlg(lParam));

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiPageBase::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsMultiPageBase::OnInitDialog(LPARAM)
{
  TRACE(CDsMultiPageBase,OnInitDialog);
  HRESULT hr = S_OK;

  TCHAR szTitle[MAX_PATH];
  if (!LoadStringReport(m_nPageTitle, szTitle, MAX_PATH, NULL))
  {
      return HRESULT_FROM_WIN32(GetLastError());
  }

  ADsPropSetHwndWithTitle(m_hNotifyObj, m_hPage, szTitle);

  //
  // Mark all the attrs as writable since we are in the multiselect state
  //
  for (DWORD iAttrs = 0; iAttrs < m_cAttrs; iAttrs++)
  {
    ATTR_DATA_SET_WRITABLE(m_rgAttrData[iAttrs]);
    if (m_rgpAttrMap[iAttrs]->pAttrFcn)
    {
      (*m_rgpAttrMap[iAttrs]->pAttrFcn)(this, m_rgpAttrMap[iAttrs], NULL,
                                        0, &m_rgAttrData[iAttrs], fInit);
    }
  }

  //
  // Set the limit text for edit boxes based on the table
  //
  PAPPLY_MAP pMapEntry = m_pApplyMap;
  while (pMapEntry != NULL && pMapEntry->nCtrlID != NULL)
  {
     if (pMapEntry->pLimitText)
     {
        for (UINT idx = 0; idx < pMapEntry->nCtrlCount; ++idx)
        {
           if (pMapEntry->pLimitText[idx] > 0)
           {
              SendDlgItemMessage(
                 m_hPage, 
                 pMapEntry->pMappedCtrls[idx],
                 EM_SETLIMITTEXT,
                 (WPARAM)pMapEntry->pLimitText[idx],
                 0);
           }
        }
     }
     pMapEntry++;
  }

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiPageBase::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiPageBase::OnApply(void)
{
  TRACE(CDsMultiPageBase,OnApply);

  HRESULT hr = S_OK;
  LPTSTR ptsz;
  LPWSTR pwszValue;
  PADSVALUE pADsValue;
  DWORD cAttrs = 0;
  BOOL bErrorOccurred = FALSE;
  UINT idx = 0;
  PWSTR pszTitle = NULL;
  ADSPROPERROR adsPropError = {0};

  //
  // For the retrieval of the DS Object names
  //
  FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM objMedium;
  ZeroMemory(&objMedium, sizeof(STGMEDIUM));

  LPDSOBJECTNAMES pDsObjectNames;

  if (m_fReadOnly)
  {
    return PSNRET_NOERROR;
  }

  PADS_ATTR_INFO pAttrs = new ADS_ATTR_INFO[m_cAttrs];
  CHECK_NULL_REPORT(pAttrs, GetHWnd(), return -1);

  memset(pAttrs, 0, sizeof(ADS_ATTR_INFO) * m_cAttrs);

  //
  // Retrieve the DS object names
  //
  //
  // Get the path to the DS object from the data object.
  // Note: This call runs on the caller's main thread. The pages' window
  // procs run on a different thread, so don't reference the data object
  // from a winproc unless it is first marshalled on this thread.
  //

  if (m_pWPTDataObj == NULL)
  {
    bErrorOccurred = TRUE;
    goto Cleanup;
  }

  hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
  CHECK_HRESULT(hr, bErrorOccurred = TRUE; goto Cleanup);

  pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

  if (pDsObjectNames->cItems < 2)
  {
      DBG_OUT("Not enough objects in DSOBJECTNAMES structure");
      bErrorOccurred = TRUE;
      goto Cleanup;
  }


  //
  // Prepare the error structure
  //
  LoadStringToTchar(m_nPageTitle, &pszTitle);
  adsPropError.hwndPage = m_hPage;
  adsPropError.pszPageTitle = pszTitle;

  //
  // Resort to the single select manner for applying
  //
  for (DWORD i = 0; i < m_cAttrs; i++)
  {
    if (m_rgpAttrMap[i]->fIsReadOnly ||
        (!m_rgpAttrMap[i]->pAttrFcn && 
          (!ATTR_DATA_IS_WRITABLE(m_rgAttrData[i]))))
    {
      // If the map defines it to be read-only or no attr function is
      // defined and the attribute is not writable, then
      // skip it.
      // NOTE: we ignore the dirty flag because we key off the checkbox
      //
      continue;
    }

    //
    // Now lets see if the apply check box is checked
    //
    BOOL bCanApply = FALSE;
    PAPPLY_MAP pMapEntry = m_pApplyMap;
    while (pMapEntry != NULL && pMapEntry->nCtrlID != NULL)
    {
      if (pMapEntry->nCtrlID == IDC_ALWAYS_APPLY)
      {
        bCanApply = TRUE;
      }
      else
      {
        LRESULT lRes = SendDlgItemMessage(m_hPage, pMapEntry->nCtrlID, BM_GETCHECK, 0, 0);
        if (lRes == BST_CHECKED)
        {
          for (UINT nIDCount = 0; nIDCount < pMapEntry->nCtrlCount; nIDCount++)
          {
            if (m_rgpAttrMap[i]->nCtrlID == pMapEntry->pMappedCtrls[nIDCount])
            {
              bCanApply = TRUE;
            }
          }
        }
      }
      if (bCanApply)
      {
        break;
      }
      pMapEntry++;
    }

    if (!bCanApply)
    {
      //
      // The apply check wasn't checked
      //
      continue;
    }

    pAttrs[cAttrs] = m_rgpAttrMap[i]->AttrInfo;

    if (m_rgpAttrMap[i]->pAttrFcn)
    {
      // Handle special-case attribute.
      //
      hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i],
                                        &pAttrs[cAttrs], 0,
                                        &m_rgAttrData[i], fApply);
      if (FAILED(hr))
      {
        goto Cleanup;
      }

      if (hr == ADM_S_SKIP)
      {
        // Don't write the attribute.
        //
        continue;
      }

      if (hr != S_FALSE)
      {
        //
        // If the attr fcn didn't return S_FALSE, that means that it
        // handled the value. If it did return S_FALSE, then let the
        // standard edit control processing below handle the value.
        //
        cAttrs++;

        continue;
      }
    }

    if (m_rgpAttrMap[i]->AttrInfo.dwADsType == ADSTYPE_BOOLEAN)
    {
      //
      // Handle boolean checkbox attributes.
      //

      pADsValue = new ADSVALUE;
      CHECK_NULL_REPORT(pADsValue, GetHWnd(), goto Cleanup);

      pAttrs[cAttrs].pADsValues = pADsValue;
      pAttrs[cAttrs].dwNumValues = 1;
      pADsValue->dwType = m_rgpAttrMap[i]->AttrInfo.dwADsType;

      pADsValue->Boolean = IsDlgButtonChecked(m_hPage, m_rgpAttrMap[i]->nCtrlID) == BST_CHECKED;
      cAttrs++;

      continue;
    }

    // Assumes that all non-special-case attributes,
    // if single-valued and not boolean, come from a text control.
    //
    ptsz = new TCHAR[m_rgpAttrMap[i]->nSizeLimit + 1];
    CHECK_NULL_REPORT(ptsz, GetHWnd(), goto Cleanup);

    GetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, ptsz,
                   m_rgpAttrMap[i]->nSizeLimit + 1);

    CStr csValue = ptsz;

    csValue.TrimLeft();
    csValue.TrimRight();

    if (_tcslen(ptsz) != (size_t)csValue.GetLength())
    {
      // the length is different, it must have been trimmed. Write trimmed
      // value back to the control.
      //
      SetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, const_cast<PTSTR>((LPCTSTR)csValue));
    }
    delete[] ptsz;

    if (csValue.IsEmpty())
    {
      // An empty control means remove the attribute value from the
      // object.
      //
      pAttrs[cAttrs].dwControlCode = ADS_ATTR_CLEAR;
      pAttrs[cAttrs].dwNumValues = 0;
      pAttrs[cAttrs].pADsValues = NULL;

      cAttrs++;
      continue;
    }

    if (!TcharToUnicode(const_cast<PTSTR>((LPCTSTR)csValue), &pwszValue))
    {
      CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
    }

    pADsValue = new ADSVALUE;
    CHECK_NULL_REPORT(pADsValue, GetHWnd(), goto Cleanup);

    pAttrs[cAttrs].pADsValues = pADsValue;
    pAttrs[cAttrs].dwNumValues = 1;
    pADsValue->dwType = m_rgpAttrMap[i]->AttrInfo.dwADsType;

    switch (pADsValue->dwType)
    {
      case ADSTYPE_DN_STRING:
        pADsValue->DNString = pwszValue;
        break;
      case ADSTYPE_CASE_EXACT_STRING:
        pADsValue->CaseExactString = pwszValue;
        break;
      case ADSTYPE_CASE_IGNORE_STRING:
        pADsValue->CaseIgnoreString = pwszValue;
        break;
      case ADSTYPE_PRINTABLE_STRING:
        pADsValue->PrintableString = pwszValue;
        break;
      case ADSTYPE_NUMERIC_STRING:
        pADsValue->NumericString = pwszValue;
        break;
      case ADSTYPE_INTEGER:
        pADsValue->Integer = _wtoi(pwszValue);
        break;
      default:
        dspDebugOut((DEB_ERROR, "OnApply: Unknown ADS Type %x\n",
                     pADsValue->dwType));
    }
    cAttrs++;
  }

  // cAttrs could be zero if a page was read-only. Don't call ADSI if so.
  //
  if (cAttrs < 1)
  {
    goto Cleanup;
  }

  dspDebugOut((DEB_USER1, "TablePage, about to write %d attrs.\n", cAttrs));

  
  

  for (; idx < pDsObjectNames->cItems; idx++)
  {
    hr = S_OK;
    //
    // Get the objects path
    //
    LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                             pDsObjectNames->aObjects[idx].offsetName);

    LPWSTR pwzObjClass = (PWSTR)ByteOffset(pDsObjectNames,
                                           pDsObjectNames->aObjects[idx].offsetClass);

    adsPropError.pszObjPath = pwzObjADsPath;
    adsPropError.pszObjClass = pwzObjClass;

    //
    // Bind to the object
    //
    CComPtr<IDirectoryObject> spDirObject;
    hr = DSAdminOpenObject(pwzObjADsPath, 
                           IID_IDirectoryObject, 
                           (PVOID*)&spDirObject);
    if (FAILED(hr))
    {
      DBG_OUT("Failed to bind to a multi-select object for Apply.");
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      continue;
    }
  
    //
    // Write the changes.
    //
    DWORD cModified;

    hr = spDirObject->SetObjectAttributes(pAttrs, cAttrs, &cModified);
    if (FAILED(hr))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
    }
  }

Cleanup:

  //
  // Cleanup medium
  //
  ReleaseStgMedium(&objMedium);

  for (i = 0; i < cAttrs; i++)
  {
    if (pAttrs[i].pADsValues)
    {
      for (DWORD j = 0; j < pAttrs[i].dwNumValues; j++)
      {
        pwszValue = NULL;
        switch (pAttrs[i].dwADsType)
        {
          case ADSTYPE_DN_STRING:
            pwszValue = pAttrs[i].pADsValues[j].DNString;
            break;
          case ADSTYPE_CASE_EXACT_STRING:
            pwszValue = pAttrs[i].pADsValues[j].CaseExactString;
            break;
          case ADSTYPE_CASE_IGNORE_STRING:
            pwszValue = pAttrs[i].pADsValues[j].CaseIgnoreString;
            break;
          case ADSTYPE_PRINTABLE_STRING:
            pwszValue = pAttrs[i].pADsValues[j].PrintableString;
            break;
          case ADSTYPE_NUMERIC_STRING:
            pwszValue = pAttrs[i].pADsValues[j].NumericString;
            break;
        }
        if (pwszValue)
        {
          delete pwszValue;
        }
      }
    }
    delete pAttrs[i].pADsValues;
  }
  delete[] pAttrs;

  if (pszTitle != NULL)
  {
    delete pszTitle;
    pszTitle = NULL;
  }

  if (!bErrorOccurred && cAttrs > 0)
  {
    for (i = 0; i < m_cAttrs; i++)
    {
      ATTR_DATA_CLEAR_DIRTY(m_rgAttrData[i]);
    }

    PAPPLY_MAP pMapEntry = m_pApplyMap;
    while (pMapEntry != NULL && pMapEntry->nCtrlID != NULL)
    {
      SendDlgItemMessage(m_hPage, pMapEntry->nCtrlID, BM_SETCHECK, BST_UNCHECKED, 0);
      //
      // Loop through the mapped controls
      //
      for (UINT iCount = 0; iCount < pMapEntry->nCtrlCount; iCount++)
      {
        HWND hwndCtrl = GetDlgItem(m_hPage, (pMapEntry->pMappedCtrls[iCount]));
        if (hwndCtrl != NULL)
        {
          EnableWindow(hwndCtrl, FALSE);
        }
      }
      pMapEntry++;
    }
  }

  if (bErrorOccurred)
  {
    ADsPropShowErrorDialog(m_hNotifyObj, m_hPage);
  }
  return (bErrorOccurred) ? PSNRET_INVALID_NOCHANGEPAGE : PSNRET_NOERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiPageBase::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiPageBase::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
  if (m_fInInit)
  {
    return 0;
  }

  HRESULT hr;
  DWORD i;

  for (i = 0; i < m_cAttrs; i++)
  {
    if (id == m_rgpAttrMap[i]->nCtrlID)
    {
      // Give attr functions first crack at the command notification.
      //
      if (m_rgpAttrMap[i]->pAttrFcn)
      {
        hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i], NULL,
                                          codeNotify, &m_rgAttrData[i],
                                          fOnCommand);

        if (hr == S_FALSE)
        {
          // If the attr function returns S_FALSE, then don't return
          // to the base class OnCommand.
          //
          return 0;
        }
        else
        {
          continue;
        }
      }
      if (codeNotify == BN_CLICKED &&
          m_rgpAttrMap[i]->AttrInfo.dwADsType == ADSTYPE_BOOLEAN)
      {
        // NOTE: Must do this to allow saving from the WAB-hosted sheet.
        EnableWindow(GetDlgItem(GetParent(m_hPage), IDOK), TRUE);
        // NOTE: end hack.

        // The check box was clicked.
        //
        SetDirty(i);

        return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
      }
      if (codeNotify == EN_CHANGE)
      {
        // NOTE: Must do this to allow saving from the WAB-hosted sheet.
        EnableWindow(GetDlgItem(GetParent(m_hPage), IDOK), TRUE);
        // NOTE: End Hack.

        SetDirty(i);
      }
    }
  }

  //
  // Since it wasn't an attribute control see if it was a apply check box
  // then we should enable/disable the associated controls
  //
  if (m_pApplyMap != NULL)
  {
    PAPPLY_MAP pNextMap = m_pApplyMap;
    while (pNextMap != NULL && pNextMap->nCtrlID != NULL)
    {
      if (id == pNextMap->nCtrlID)
      {
        //
        // Get the state of the apply check
        //
        LRESULT lRes = SendDlgItemMessage(m_hPage, id, BM_GETCHECK, 0, 0);
        if (lRes != BST_INDETERMINATE)
        {
          //
          // Enable or disable the control as appropriate
          //
          BOOL bEnable = FALSE;
          if (lRes == BST_CHECKED)
          {
            bEnable = TRUE;
          }

          //
          // Loop through the mapped controls
          //
          for (UINT iCount = 0; iCount < pNextMap->nCtrlCount; iCount++)
          {
            HWND hwndCtrl = GetDlgItem(m_hPage, (pNextMap->pMappedCtrls[iCount]));
            if (hwndCtrl != NULL)
            {
              if (0 == static_cast<int>(pNextMap->pCtrlFlags[iCount] & (ALWAYS_DISABLED | DISABLE_ON_EMPTY)))
              {
                EnableWindow(hwndCtrl, bEnable);
              }

              //
              // Clear the window text if the CLEAR_FIELD flag is present
              //
              if (!bEnable && 0 != static_cast<int>(pNextMap->pCtrlFlags[iCount] & CLEAR_FIELD))
              {
                SetDlgItemText(m_hPage, pNextMap->pMappedCtrls[iCount], L"");
              }

              if (pNextMap->pCtrlFlags[iCount] & SELECT_CB_ON_ENABLE)
              {
                SendDlgItemMessage(
                   m_hPage, 
                   pNextMap->pMappedCtrls[iCount], 
                   CB_SETCURSEL, 
                   0, 
                   0);
              }

              //
              // There are some controls that should be disabled if the edit box they
              // are associated with is empty
              //
              if (pNextMap->pCtrlFlags[iCount] & DISABLE_ON_EMPTY)
              {
                int nCtrlID = pNextMap->pCtrlFlags[iCount] & ~DISABLE_ON_EMPTY;
                if (nCtrlID != 0)
                {
                  LRESULT lLen = SendDlgItemMessage(m_hPage, nCtrlID, WM_GETTEXTLENGTH, 0, 0);
                  if (lLen > 0)
                  {
                    EnableWindow(GetDlgItem(m_hPage, pNextMap->pMappedCtrls[iCount]), bEnable);
                  }
                  else
                  {
                    EnableWindow(GetDlgItem(m_hPage, pNextMap->pMappedCtrls[iCount]), FALSE);
                  }
                }
              }
            }

            //
            // Mark the associated control as dirty
            //
            for (UINT nCtrlIdx = 0; nCtrlIdx < m_cAttrs; nCtrlIdx++)
            {
              if (pNextMap->pMappedCtrls[iCount] == m_rgpAttrMap[nCtrlIdx]->nCtrlID)
              {
                SetDirty(nCtrlIdx);
              }
            }            
          }
        }
      }
      pNextMap++;
    } // while
  }
  return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiPageBase::OnNotify
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiPageBase::OnNotify(WPARAM wParam, LPARAM lParam)
{
  LRESULT lResult = CDsPropPageBase::OnNotify(wParam, lParam);
  //
  // The base class will take care of notifying the console if there wasn't
  // an error, but for the multiselect pages we also have to do the notification
  // if there was an error so that objects that didn't fail can be updated
  //
  if (((LPNMHDR)lParam)->code == PSN_APPLY &&
      (lResult == PSNRET_INVALID ||
       lResult == PSNRET_INVALID_NOCHANGEPAGE))
  {
    //
    // Signal the change notification. Note that the notify-apply
    // message must be sent even if the page is not dirty so that the
    // notify ref-counting will properly decrement.
    //
    SendMessage(m_hNotifyObj, WM_ADSPROP_NOTIFY_APPLY, TRUE, (LPARAM)m_hPage);
  }
  return lResult;
}



//////////////////////////////////////////////////////////////////////////////////

int gDescGenericIDs[] = { IDC_DESC_STATIC,  IDC_DESCRIPTION_EDIT };
int gDescFlags[]      = { 0,                CLEAR_FIELD          };
int gDescLimitText[]  = { 0, 1024 };

APPLY_MAP gpGenericPageMap[] = 
{ 
  { IDC_APPLY_DESC_CHK, sizeof(gDescGenericIDs)/sizeof(int), gDescGenericIDs, gDescFlags, gDescLimitText },
  { NULL, NULL, NULL }
};


//+----------------------------------------------------------------------------
//
//  Member:     CDsGenericMultiPage::CDsGenericMultiPage
//
//-----------------------------------------------------------------------------
CDsGenericMultiPage::CDsGenericMultiPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                         HWND hNotifyObj, DWORD dwFlags) :
    CDsMultiPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  TRACE(CDsGenericMultiPage,CDsGenericMultiPage);
  m_pApplyMap = gpGenericPageMap;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsGenericMultiPage::~CDsGenericMultiPage
//
//-----------------------------------------------------------------------------
CDsGenericMultiPage::~CDsGenericMultiPage()
{
  TRACE(CDsGenericMultiPage,~CDsGenericMultiPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsGenericMultiPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsGenericMultiPage::OnInitDialog(LPARAM lParam)
{
  TRACE(CDsGenericMultiPage,OnInitDialog);
  HRESULT hr = S_OK;

  hr = CDsMultiPageBase::OnInitDialog(lParam);

  //
  // Retrieve the DS object names
  //
  FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM objMedium;

  LPDSOBJECTNAMES pDsObjectNames;
  //
  // Get the path to the DS object from the data object.
  // Note: This call runs on the caller's main thread. The pages' window
  // procs run on a different thread, so don't reference the data object
  // from a winproc unless it is first marshalled on this thread.
  //

  if (m_pWPTDataObj == NULL)
  {
    return E_FAIL;
  }

  hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
  CHECK_HRESULT(hr, return hr);

  pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

  if (pDsObjectNames->cItems < 2)
  {
    DBG_OUT("Not enough objects in DSOBJECTNAMES structure");
    ReleaseStgMedium(&objMedium);
    return ERROR_INVALID_DATA;
  }

  UINT nTotalCount = 0, nOUCount = 0, nUserCount = 0, nGroupCount = 0, nContactCount = 0;
  UINT nOtherCount = 0, nComputerCount = 0;

  for (UINT idx = 0; idx < pDsObjectNames->cItems; idx++)
  {
    LPWSTR pwzClass = (PWSTR)ByteOffset(pDsObjectNames,
                                        pDsObjectNames->aObjects[idx].offsetClass);
    
    if (_wcsicmp(pwzClass, L"user") == 0)
    {
      nUserCount++;
    }
    else if (_wcsicmp(pwzClass, L"organizationalUnit") == 0)
    {
      nOUCount++;
    }
    else if (_wcsicmp(pwzClass, L"group") == 0)
    {
      nGroupCount++;
    }
    else if (_wcsicmp(pwzClass, L"Contact") == 0)
    {
      nContactCount++;
    }
    else if (_wcsicmp(pwzClass, L"Computer") == 0)
    {
      nComputerCount++;
    }
    else
    {
      nOtherCount++;
    }
    nTotalCount++;
  }
  dspAssert(nTotalCount == nOtherCount + nContactCount + nGroupCount + nOUCount + nUserCount + nComputerCount);

  //
  // Cleanup medium
  //
  ReleaseStgMedium(&objMedium);

  //
  // REVIEW_JEFFJON_PORT : hardcoded 
  //
  TCHAR ptzTotal[MAX_PATH]    = {0}, 
        ptzOU[MAX_PATH]       = {0}, 
        ptzUser[MAX_PATH]     = {0}, 
        ptzGroup[MAX_PATH]    = {0}, 
        ptzComputer[MAX_PATH] = {0}, 
        ptzContact[MAX_PATH]  = {0}, 
        ptzOther[MAX_PATH]    = {0};
  
  if (nTotalCount > 0)
  {
    wsprintf(ptzTotal, _T("%d"), nTotalCount);
  }

  if (nOUCount > 0)
  {
    wsprintf(ptzOU, _T("%d"), nOUCount);
  }

  if (nUserCount > 0)
  {
    wsprintf(ptzUser, _T("%d"), nUserCount);
  }

  if (nGroupCount > 0)
  {
    wsprintf(ptzGroup, _T("%d"), nGroupCount);
  }

  if (nComputerCount > 0)
  {
    wsprintf(ptzComputer, _T("%d"), nComputerCount);
  }

  if (nContactCount > 0)
  {
    wsprintf(ptzContact, _T("%d"), nContactCount);
  }

  if (nOtherCount > 0)
  {
    wsprintf(ptzOther, _T("%d"), nOtherCount);
  }

  ::SendDlgItemMessage(m_hPage, IDC_SUMMARY_STATIC, WM_SETTEXT, 0, (LPARAM)ptzTotal);
  ::SendDlgItemMessage(m_hPage, IDC_OU_COUNT_STATIC, WM_SETTEXT, 0, (LPARAM)ptzOU);
  ::SendDlgItemMessage(m_hPage, IDC_USER_COUNT_STATIC, WM_SETTEXT, 0, (LPARAM)ptzUser);
  ::SendDlgItemMessage(m_hPage, IDC_GROUP_COUNT_STATIC, WM_SETTEXT, 0, (LPARAM)ptzGroup);
  ::SendDlgItemMessage(m_hPage, IDC_COMPUTER_COUNT_STATIC, WM_SETTEXT, 0, (LPARAM)ptzComputer);
  ::SendDlgItemMessage(m_hPage, IDC_CONTACT_COUNT_STATIC, WM_SETTEXT, 0, (LPARAM)ptzContact);
  ::SendDlgItemMessage(m_hPage, IDC_OTHER_COUNT_STATIC, WM_SETTEXT, 0, (LPARAM)ptzOther);

  return hr;
}


/////////////////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Member:     CDsUserMultiPage::CDsUserMultiPage
//
//-----------------------------------------------------------------------------
CDsUserMultiPage::CDsUserMultiPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                         HWND hNotifyObj, DWORD dwFlags) :
    CDsMultiPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  TRACE(CDsUserMultiPage,CDsUserMultiPage);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsUserMultiPage::~CDsUserMultiPage
//
//-----------------------------------------------------------------------------
CDsUserMultiPage::~CDsUserMultiPage()
{
  TRACE(CDsUserMultiPage,~CDsUserMultiPage);
}

//////////////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Member:     CDsGeneralMultiUserPage::CDsGeneralMultiUserPage
//
//-----------------------------------------------------------------------------
int gDescGenIDs[]       = { IDC_DESCRIPTION_EDIT };
int gDescGenFlags[]     = { CLEAR_FIELD };
int gDescGenLimitText[] = { 1024 };
int gOfficeGenIDs[]     = { IDC_OFFICE_EDIT };
int gOfficeFlags[]      = { CLEAR_FIELD };
int gOfficeLimitText[]  = { 128 };
int gPhoneGenIDs[]      = { IDC_PHONE_EDIT };
int gPhoneFlags[]       = { CLEAR_FIELD };
int gPhoneLimitText[]   = { 64 };
int gEmailGenIDs[]      = { IDC_EMAIL_EDIT };
int gEmailFlags[]       = { CLEAR_FIELD };
int gEmailLimitText[]   = { 256 };
int gWebGenIDs[]        = { IDC_HOME_PAGE_EDIT };
int gWebFlags[]         = { CLEAR_FIELD };
int gWebLimitText[]     = { 2048, 0 };
int gFaxGenIDs[]        = { IDC_FAX_EDIT };
int gFaxFlags[]         = { CLEAR_FIELD };
int gFaxLimitText[]     = { 64, 0 };

APPLY_MAP gpGeneralPageMap[] = 
{ 
  { IDC_APPLY_DESC_CHK, sizeof(gDescGenIDs)/sizeof(int), gDescGenIDs, gDescGenFlags, gDescGenLimitText },
  { IDC_APPLY_OFFICE_CHK, sizeof(gOfficeGenIDs)/sizeof(int), gOfficeGenIDs, gOfficeFlags, gOfficeLimitText },
  { IDC_APPLY_PHONE_CHK, sizeof(gPhoneGenIDs)/sizeof(int), gPhoneGenIDs, gPhoneFlags, gPhoneLimitText },
  { IDC_APPLY_EMAIL_CHK, sizeof(gEmailGenIDs)/sizeof(int), gEmailGenIDs, gEmailFlags, gEmailLimitText },
  { IDC_APPLY_WEB_CHK, sizeof(gWebGenIDs)/sizeof(int), gWebGenIDs, gWebFlags, gWebLimitText },
  { IDC_APPLY_FAX_CHK, sizeof(gFaxGenIDs)/sizeof(int), gFaxGenIDs, gFaxFlags, gFaxLimitText },
  { NULL, NULL, NULL, NULL }
};


CDsGeneralMultiUserPage::CDsGeneralMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags)
  : CDsUserMultiPage(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  m_pApplyMap = gpGeneralPageMap;
}

LRESULT CDsGeneralMultiUserPage::OnApply()
{
  TRACE(CDsGeneralMultiUserPage,OnApply);

  HRESULT hr = S_OK;
  LPTSTR ptsz;
  LPWSTR pwszValue;
  PADSVALUE pADsValue;
  DWORD cAttrs = 0;
  BOOL bErrorOccurred = FALSE;
  UINT idx = 0;
  PWSTR pszTitle = NULL;

  CStrW strUserToken;
  strUserToken.LoadString(g_hInstance, IDS_PROFILE_USER_TOKEN);
  
  LPWSTR rgpwzAttrNames[] = {wzSAMname};
  Smart_PADS_ATTR_INFO spAttrs;
  ULONG nCount = 0;

  //
  // Do nothing if none of the checkboxes are checked
  //
  LRESULT lDescCheck   = SendDlgItemMessage(GetHWnd(), IDC_APPLY_DESC_CHK, BM_GETCHECK, 0, 0);
  LRESULT lOfficeCheck = SendDlgItemMessage(GetHWnd(), IDC_APPLY_OFFICE_CHK, BM_GETCHECK, 0, 0);
  LRESULT lPhoneCheck  = SendDlgItemMessage(GetHWnd(), IDC_APPLY_PHONE_CHK, BM_GETCHECK, 0, 0);
  LRESULT lFaxCheck    = SendDlgItemMessage(GetHWnd(), IDC_APPLY_FAX_CHK, BM_GETCHECK, 0, 0);
  LRESULT lWebCheck    = SendDlgItemMessage(GetHWnd(), IDC_APPLY_WEB_CHK, BM_GETCHECK, 0, 0);
  LRESULT lEmailCheck  = SendDlgItemMessage(GetHWnd(), IDC_APPLY_EMAIL_CHK, BM_GETCHECK, 0, 0);

  if (lDescCheck   != BST_CHECKED &&
      lOfficeCheck != BST_CHECKED &&
      lPhoneCheck  != BST_CHECKED &&
      lFaxCheck    != BST_CHECKED &&
      lWebCheck    != BST_CHECKED &&
      lEmailCheck  != BST_CHECKED)
  {
     // Nothing checked to apply, just short circuit the operation
   
     return PSNRET_NOERROR;
  }

  //
  // For the retrieval of the DS Object names
  //
  FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM objMedium;
  LPDSOBJECTNAMES pDsObjectNames;

  if (m_fReadOnly)
  {
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  //
  // Retrieve the DS object names
  //
  //
  // Get the path to the DS object from the data object.
  // Note: This call runs on the caller's main thread. The pages' window
  // procs run on a different thread, so don't reference the data object
  // from a winproc unless it is first marshalled on this thread.
  //

  if (m_pWPTDataObj == NULL)
  {
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
  CHECK_HRESULT(hr, return hr);

  pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

  if (pDsObjectNames->cItems < 2)
  {
      DBG_OUT("Not enough objects in DSOBJECTNAMES structure");
      ReleaseStgMedium(&objMedium);
      return PSNRET_INVALID_NOCHANGEPAGE;
  }


  //
  // Prepare the error structure
  //
  LoadStringToTchar(m_nPageTitle, &pszTitle);
  ADSPROPERROR adsPropError = {0};
  adsPropError.hwndPage = m_hPage;
  adsPropError.pszPageTitle = pszTitle;

  PADS_ATTR_INFO pAttrs = new ADS_ATTR_INFO[m_cAttrs];
  CHECK_NULL_REPORT(pAttrs, GetHWnd(), return -1);

  memset(pAttrs, 0, sizeof(ADS_ATTR_INFO) * m_cAttrs);


  for (; idx < pDsObjectNames->cItems; idx++)
  {
    cAttrs = 0;
    hr = S_OK;
    PWSTR pwzSamName = NULL;
    //
    // Get the objects path
    //
    LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                             pDsObjectNames->aObjects[idx].offsetName);

    LPWSTR pwzObjClass = (PWSTR)ByteOffset(pDsObjectNames,
                                           pDsObjectNames->aObjects[idx].offsetClass);

    adsPropError.pszObjPath = pwzObjADsPath;
    adsPropError.pszObjClass = pwzObjClass;

    //
    // Bind to the object
    //
    CComPtr<IDirectoryObject> spDirObject;
    hr = DSAdminOpenObject(pwzObjADsPath,  
                           IID_IDirectoryObject, 
                           (PVOID*)&spDirObject);
    if (FAILED(hr))
    {
      DBG_OUT("Failed to bind to a multi-select object for Apply.");
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      goto Cleanup;
    }

    hr = spDirObject->GetObjectAttributes(rgpwzAttrNames,
                                          ARRAYLENGTH(rgpwzAttrNames),
                                          &spAttrs, &nCount);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      goto Cleanup;
    }

    if (nCount > 0 && spAttrs)
    {
      pwzSamName = spAttrs->pADsValues->CaseIgnoreString;
    }

    //
    // Resort to the single select manner for applying
    //

    for (DWORD i = 0; i < m_cAttrs; i++)
    {
      if (m_rgpAttrMap[i]->fIsReadOnly ||
          (!m_rgpAttrMap[i]->pAttrFcn && 
            (!ATTR_DATA_IS_WRITABLE(m_rgAttrData[i]))))
      {
        // If the map defines it to be read-only or no attr function is
        // defined and the attribute is not writable or not dirty, then
        // skip it.
        // NOTE: we ignore the dirty flag because we key off the check box
        //
        continue;
      }

      //
      // Now lets see if the apply check box is checked
      //
      BOOL bCanApply = FALSE;
      PAPPLY_MAP pMapEntry = m_pApplyMap;
      while (pMapEntry != NULL && pMapEntry->nCtrlID != NULL)
      {
        LRESULT lRes = SendDlgItemMessage(m_hPage, pMapEntry->nCtrlID, BM_GETCHECK, 0, 0);
        if (lRes == BST_CHECKED)
        {
          for (UINT nIDCount = 0; nIDCount < pMapEntry->nCtrlCount; nIDCount++)
          {
            if (m_rgpAttrMap[i]->nCtrlID == static_cast<int>(pMapEntry->pMappedCtrls[nIDCount])) 
            {
              bCanApply = TRUE;
            }
          }
        }
        if (bCanApply)
        {
          break;
        }
        pMapEntry++;
      }

      if (!bCanApply)
      {
        //
        // The apply check wasn't checked
        //
        continue;
      }

      pAttrs[cAttrs] = m_rgpAttrMap[i]->AttrInfo;

      if (m_rgpAttrMap[i]->pAttrFcn)
      {
        //
        // Special case the email field because we need to provide the
        // error handling the correct way for multiselect
        //
        if (m_rgpAttrMap[i]->pAttrFcn == MailAttr)
        {
          SendMessage(GetParent(GetHWnd()), PSM_QUERYSIBLINGS,
                      (WPARAM)m_rgpAttrMap[i]->AttrInfo.pszAttrName,
                      (LPARAM)GetHWnd());

          PWSTR pwz = NULL;
          int cch = (int)SendDlgItemMessage(GetHWnd(), m_rgpAttrMap[i]->nCtrlID,
                                            WM_GETTEXTLENGTH, 0, 0);
          if (cch)
          {
            cch++;
            pwz = new WCHAR[cch];
            if (pwz == NULL)
            {
              adsPropError.hr = E_OUTOFMEMORY;
              SendErrorMessage(&adsPropError);
              bErrorOccurred = TRUE;
              continue;
            }

            GetDlgItemText(GetHWnd(), m_rgpAttrMap[i]->nCtrlID, pwz, cch);
          }
          if (pwz)
          {
            BOOL fExpanded = FALSE;
            ExpandUsername(pwz, pwzSamName, fExpanded, strUserToken);

            if (!FValidSMTPAddress(pwz))
            {
              PTSTR ptzError = NULL;
              if (LoadStringToTchar(IDS_INVALID_MAIL_ADDR, &ptzError))
              {
                adsPropError.hr = 0;
                adsPropError.pszError = ptzError;
                SendErrorMessage(&adsPropError);
                bErrorOccurred = TRUE;

                delete[] pwz;
                pwz = NULL;
                continue;
              }
            }
            else
            {
              if (!pAttrs[cAttrs].pADsValues)
              {
                pADsValue = new ADSVALUE;
                if (pADsValue == NULL)
                {
                  adsPropError.hr = E_OUTOFMEMORY;
                  SendErrorMessage(&adsPropError);
                  bErrorOccurred = TRUE;

                  delete[] pwz;
                  pwz = NULL;
                  continue;
                }
                else
                {
                  pAttrs[cAttrs].pADsValues = pADsValue;
                }
              }

              pAttrs[cAttrs].dwNumValues = 1;
              pAttrs[cAttrs].dwControlCode = ADS_ATTR_UPDATE;
              pAttrs[cAttrs].pADsValues->dwType = pAttrs[cAttrs].dwADsType;
              pAttrs[cAttrs].pADsValues->CaseIgnoreString = pwz;
            }
          }
          else
          {
            pAttrs[cAttrs].pADsValues = NULL;
            pAttrs[cAttrs].dwNumValues = 0;
            pAttrs[cAttrs].dwControlCode = ADS_ATTR_CLEAR;
          }
          cAttrs++;
          continue;
        }
        else
        {
          // Handle special-case attribute.
          //
          hr = (*m_rgpAttrMap[i]->pAttrFcn)(this, m_rgpAttrMap[i],
                                            &pAttrs[cAttrs], (LPARAM)pwzSamName,
                                            &m_rgAttrData[i], fApply);
          if (FAILED(hr))
          {
            continue;
          }

          if (hr == ADM_S_SKIP)
          {
            // Don't write the attribute.
            //
            continue;
          }

          if (hr != S_FALSE)
          {
            //
            // If the attr fcn didn't return S_FALSE, that means that it
            // handled the value. If it did return S_FALSE, then let the
            // standard edit control processing below handle the value.
            //
            cAttrs++;

            continue;
          }
        }
      }

      if (m_rgpAttrMap[i]->AttrInfo.dwADsType == ADSTYPE_BOOLEAN)
      {
        //
        // Handle boolean checkbox attributes.
        //

        if (!pAttrs[cAttrs].pADsValues)
        {
          pADsValue = new ADSVALUE;
          CHECK_NULL_REPORT(pADsValue, GetHWnd(), goto Cleanup);

          pAttrs[cAttrs].pADsValues = pADsValue;
        }

        pAttrs[cAttrs].dwNumValues = 1;
        pAttrs[cAttrs].pADsValues->dwType = m_rgpAttrMap[i]->AttrInfo.dwADsType;

        pAttrs[cAttrs].pADsValues->Boolean = IsDlgButtonChecked(m_hPage, m_rgpAttrMap[i]->nCtrlID) == BST_CHECKED;
        cAttrs++;

        continue;
      }

      if (!pAttrs[cAttrs].pADsValues)
      {
        // Assumes that all non-special-case attributes,
        // if single-valued and not boolean, come from a text control.
        //
        ptsz = new TCHAR[m_rgpAttrMap[i]->nSizeLimit + 1];
        CHECK_NULL_REPORT(ptsz, GetHWnd(), goto Cleanup);

        GetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, ptsz,
                       m_rgpAttrMap[i]->nSizeLimit + 1);

        CStr csValue = ptsz;

        csValue.TrimLeft();
        csValue.TrimRight();

        if (_tcslen(ptsz) != (size_t)csValue.GetLength())
        {
          // the length is different, it must have been trimmed. Write trimmed
          // value back to the control.
          //
          SetDlgItemText(m_hPage, m_rgpAttrMap[i]->nCtrlID, const_cast<PTSTR>((LPCTSTR)csValue));
        }
        delete[] ptsz;

        if (csValue.IsEmpty())
        {
          // An empty control means remove the attribute value from the
          // object.
          //
          pAttrs[cAttrs].dwControlCode = ADS_ATTR_CLEAR;
          pAttrs[cAttrs].dwNumValues = 0;
          pAttrs[cAttrs].pADsValues = NULL;

          cAttrs++;
          continue;
        }

        if (!TcharToUnicode(const_cast<PTSTR>((LPCTSTR)csValue), &pwszValue))
        {
          CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
        }

        pADsValue = new ADSVALUE;
        CHECK_NULL_REPORT(pADsValue, GetHWnd(), goto Cleanup);

        pAttrs[cAttrs].pADsValues = pADsValue;
        pAttrs[cAttrs].dwNumValues = 1;
        pADsValue->dwType = m_rgpAttrMap[i]->AttrInfo.dwADsType;

        switch (pADsValue->dwType)
        {
          case ADSTYPE_DN_STRING:
            pADsValue->DNString = pwszValue;
            break;
          case ADSTYPE_CASE_EXACT_STRING:
            pADsValue->CaseExactString = pwszValue;
            break;
          case ADSTYPE_CASE_IGNORE_STRING:
            pADsValue->CaseIgnoreString = pwszValue;
            break;
          case ADSTYPE_PRINTABLE_STRING:
            pADsValue->PrintableString = pwszValue;
            break;
          case ADSTYPE_NUMERIC_STRING:
            pADsValue->NumericString = pwszValue;
            break;
          case ADSTYPE_INTEGER:
            pADsValue->Integer = _wtoi(pwszValue);
            break;
          default:
            dspDebugOut((DEB_ERROR, "OnApply: Unknown ADS Type %x\n",
                         pADsValue->dwType));
        }
        cAttrs++;
      }
      else
      {
        cAttrs++;
      }
    }

    // cAttrs could be zero if a page was read-only. Don't call ADSI if so.
    //
    if (cAttrs < 1)
    {
      continue;
    }

    dspDebugOut((DEB_USER1, "TablePage, about to write %d attrs.\n", cAttrs));

  
    //
    // Write the changes.
    //
    DWORD cModified;

    hr = spDirObject->SetObjectAttributes(pAttrs, cAttrs, &cModified);
    if (FAILED(hr))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
    }
  }

Cleanup:

  //
  // Cleanup medium
  //

  for (DWORD i = 0; i < cAttrs; i++)
  {
    if (pAttrs[i].pADsValues)
    {
      for (DWORD j = 0; j < pAttrs[i].dwNumValues; j++)
      {
        pwszValue = NULL;
        switch (pAttrs[i].dwADsType)
        {
          case ADSTYPE_DN_STRING:
            pwszValue = pAttrs[i].pADsValues[j].DNString;
            break;
          case ADSTYPE_CASE_EXACT_STRING:
            pwszValue = pAttrs[i].pADsValues[j].CaseExactString;
            break;
          case ADSTYPE_CASE_IGNORE_STRING:
            pwszValue = pAttrs[i].pADsValues[j].CaseIgnoreString;
            break;
          case ADSTYPE_PRINTABLE_STRING:
            pwszValue = pAttrs[i].pADsValues[j].PrintableString;
            break;
          case ADSTYPE_NUMERIC_STRING:
            pwszValue = pAttrs[i].pADsValues[j].NumericString;
            break;
        }
        if (pwszValue)
        {
          delete pwszValue;
        }
      }
    }
    delete pAttrs[i].pADsValues;
  }
  delete[] pAttrs;

  if (pszTitle != NULL)
  {
    delete pszTitle;
    pszTitle = NULL;
  }

  if (!bErrorOccurred && cAttrs > 0)
  {
    for (UINT i = 0; i < m_cAttrs; i++)
    {
      ATTR_DATA_CLEAR_DIRTY(m_rgAttrData[i]);
    }

    //
    // Uncheck the Apply checkboxes
    //
    PAPPLY_MAP pMapEntry = m_pApplyMap;
    while (pMapEntry != NULL && pMapEntry->nCtrlID != NULL)
    {
      SendDlgItemMessage(m_hPage, pMapEntry->nCtrlID, BM_SETCHECK, BST_UNCHECKED, 0);
      //
      // Loop through the mapped controls
      //
      for (UINT iCount = 0; iCount < pMapEntry->nCtrlCount; iCount++)
      {
        HWND hwndCtrl = GetDlgItem(m_hPage, (pMapEntry->pMappedCtrls[iCount]));
        if (hwndCtrl != NULL)
        {
          EnableWindow(hwndCtrl, FALSE);
        }
      }

      pMapEntry++;
    }

  }
  if (bErrorOccurred)
  {
    ADsPropShowErrorDialog(m_hNotifyObj, m_hPage);
  }

  // NTRAID#NTBUG9-522281-2002/01/18-JeffJon
  // We have to release the medium after showing the error dialog
  // (ADsPropShowErrorDialog) because the error structures
  // contain pointers to the class names that are stored in the medium

  ReleaseStgMedium(&objMedium);

  return (bErrorOccurred) ? PSNRET_INVALID_NOCHANGEPAGE : PSNRET_NOERROR;
}

////////////////////////////////////////////////////////////////////////////////////


//+----------------------------------------------------------------------------
//
//  Member:     CDsOrganizationMultiUserPage::CDsOrganizationMultiUserPage
//
//-----------------------------------------------------------------------------
int gTitleOrgIDs[]         = { IDC_TITLE_EDIT };
int gTitleFlags[]          = { CLEAR_FIELD };
int gTitleLimitText[]      = { 64 };
int gDeptOrgIDs[]          = { IDC_DEPT_EDIT };
int gDeptFlags[]           = { CLEAR_FIELD };
int gDeptLimitText[]       = { 64 };
int gCompanyOrgIDs[]       = { IDC_COMPANY_EDIT };
int gCompanyFlags[]        = { CLEAR_FIELD };
int gCompanyLimitText[]    = { 64 };
int gManagerOrgIDs[]       = { IDC_NAME_STATIC, IDC_MANAGER_EDIT, IDC_MGR_CHANGE_BTN, IDC_PROPPAGE_BTN,                    IDC_MGR_CLEAR_BTN };
int gManagerFlags[]        = { 0,               CLEAR_FIELD,      0,                  DISABLE_ON_EMPTY | IDC_MANAGER_EDIT, DISABLE_ON_EMPTY | IDC_MANAGER_EDIT };
int gManagerLimitText[]    = { 0,               0,                0,                  0,                                   0 };

APPLY_MAP gpOrganizationPageMap[] = 
{ 
  { IDC_APPLY_TITLE_CHK, sizeof(gTitleOrgIDs)/sizeof(int), gTitleOrgIDs, gTitleFlags, gTitleLimitText },
  { IDC_APPLY_DEPT_CHK, sizeof(gDeptOrgIDs)/sizeof(int), gDeptOrgIDs, gDeptFlags, gDeptLimitText },
  { IDC_APPLY_COMPANY_CHK, sizeof(gCompanyOrgIDs)/sizeof(int), gCompanyOrgIDs, gCompanyFlags, gCompanyLimitText },
  { IDC_APPLY_MANAGER_CHK, sizeof(gManagerOrgIDs)/sizeof(int), gManagerOrgIDs, gManagerFlags, gManagerLimitText },
  { NULL, NULL, NULL }
};


CDsOrganizationMultiUserPage::CDsOrganizationMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags)
  : CDsUserMultiPage(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  m_pApplyMap = gpOrganizationPageMap;
}

////////////////////////////////////////////////////////////////////////////////////


//+----------------------------------------------------------------------------
//
//  Member:     CDsAddressMultiUserPage::CDsAddressMultiUserPage
//
//-----------------------------------------------------------------------------
int gStreetAddrIDs[]  = { IDC_ADDRESS_EDIT };
int gStreetFlags[]    = { CLEAR_FIELD };
int gStreetLimitText[]= { 1024 };
int gPOBoxAddrIDs[]   = { IDC_POBOX_EDIT };
int gPOBoxFlags[]     = { CLEAR_FIELD };
int gPOBoxLimitText[] = { 40 };
int gCityAddrIDs[]    = { IDC_CITY_EDIT };
int gCityFlags[]      = { CLEAR_FIELD };
int gCityLimitText[]  = { 128 };
int gStateAddrIDs[]   = { IDC_STATE_EDIT };
int gStateFlags[]     = { CLEAR_FIELD };
int gStateLimitText[] = { 128 };
int gZipAddrIDs[]     = { IDC_ZIP_EDIT };
int gZipFlags[]       = { CLEAR_FIELD };
int gZipLimitText[]   = { 40 };
int gCountryAddrIDs[] = { IDC_COUNTRY_COMBO };
int gCountryFlags[]   = { SELECT_CB_ON_ENABLE };
int gCountryLimitText[] = { 0 };

APPLY_MAP gpAddressPageMap[] = 
{ 
  { IDC_APPLY_STREET_CHK, sizeof(gStreetAddrIDs)/sizeof(int),   gStreetAddrIDs, gStreetFlags,  gStreetLimitText  },
  { IDC_APPLY_POBOX_CHK,  sizeof(gPOBoxAddrIDs)/sizeof(int),    gPOBoxAddrIDs,  gPOBoxFlags,   gPOBoxLimitText   },
  { IDC_APPLY_CITY_CHK,   sizeof(gCityAddrIDs)/sizeof(int),     gCityAddrIDs,   gCityFlags,    gCityLimitText    },
  { IDC_APPLY_STATE_CHK,  sizeof(gStateAddrIDs)/sizeof(int),    gStateAddrIDs,  gStateFlags,   gStateLimitText   },
  { IDC_APPLY_ZIP_CHK,    sizeof(gZipAddrIDs)/sizeof(int),      gZipAddrIDs,    gZipFlags,     gZipLimitText     },
  { IDC_APPLY_COUNTRY_CHK,sizeof(gCountryAddrIDs)/sizeof(int),  gCountryAddrIDs,gCountryFlags, gCountryLimitText },
  { NULL, NULL, NULL }
};


CDsAddressMultiUserPage::CDsAddressMultiUserPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj, DWORD dwFlags)
  : CDsUserMultiPage(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  m_pApplyMap = gpAddressPageMap;
}

////////////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiUserAcctPage::CDsMultiUserAcctPage
//
//-----------------------------------------------------------------------------
CDsMultiUserAcctPage::CDsMultiUserAcctPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                           HWND hNotifyObj, DWORD dwFlags) :
    m_dwUsrAcctCtrl(0),
    m_pargbLogonHours(NULL),
    m_pWkstaDlg(NULL),
    m_fOrigCantChangePW(FALSE),
    m_pSelfSid(NULL),
    m_pWorldSid(NULL),
    m_fAcctCtrlChanged(FALSE),
    m_fAcctExpiresChanged(FALSE),
    m_fLogonHoursChanged(FALSE),
    m_fIsAdmin(FALSE),
    
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  TRACE(CDsMultiUserAcctPage,CDsMultiUserAcctPage);
  m_PwdLastSet.HighPart = m_PwdLastSet.LowPart = 0;
  m_fMultiselectPage = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiUserAcctPage::~CDsMultiUserAcctPage
//
//-----------------------------------------------------------------------------
CDsMultiUserAcctPage::~CDsMultiUserAcctPage()
{
  TRACE(CDsMultiUserAcctPage,~CDsMultiUserAcctPage);
  if (m_pargbLogonHours != NULL)
  {
    LocalFree(m_pargbLogonHours);
  }
  if (m_pSelfSid)
  {
    FreeSid(m_pSelfSid);
  }
  if (m_pWorldSid)
  {
    FreeSid(m_pWorldSid);
  }
  DO_DEL(m_pWkstaDlg);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateUserMultiAcctPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT CreateUserMultiAcctPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                                PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                                const CDSSmartBasePathsInfo& /*basePathsInfo*/,
                                HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CDsMultiUserAcctPage);

  CDsMultiUserAcctPage * pPageObj = new CDsMultiUserAcctPage(pDsPage, pDataObj,
                                                             hNotifyObj, dwFlags);
  CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

  pPageObj->Init(pwzClass);

  return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUserAcctPage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CDsMultiUserAcctPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch (uMsg)
  {
  case WM_INITDIALOG:
    return InitDlg(lParam);

  case WM_NOTIFY:
    return OnNotify(wParam, lParam);

  case WM_SHOWWINDOW:
    return OnShowWindow();

  case WM_SETFOCUS:
    return OnSetFocus((HWND)wParam);

  case WM_HELP:
    return OnHelp((LPHELPINFO)lParam);

  case WM_COMMAND:
    if (m_fInInit)
    {
      return TRUE;
    }
    return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                     GET_WM_COMMAND_HWND(wParam, lParam),
                     GET_WM_COMMAND_CMD(wParam, lParam)));
  case WM_DESTROY:
    return OnDestroy();

  default:
    return(FALSE);
  }

  return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUserAcctPage::Init
//
//  Synopsis:   Initialize the page object. This is the second part of a two
//              phase creation where operations that could fail are located.
//              Failures here are recorded in m_hrInit and then an error page
//              is substituted in CreatePage.
//
//-----------------------------------------------------------------------------
void CDsMultiUserAcctPage::Init(PWSTR pwzClass)
{
  TRACE(CDsMultiPageBase,Init);
  CWaitCursor cWait;

  if (!AllocWStr(pwzClass, &m_pwszObjClass))
  {
      m_hrInit = E_OUTOFMEMORY;
      return;
  }

  //
  // Allocate memory for the attribute data.
  //
  m_rgAttrData = new ATTR_DATA[m_cAttrs];
  CHECK_NULL(m_rgAttrData, m_hrInit = E_OUTOFMEMORY; return);

  memset(m_rgAttrData, 0, m_cAttrs * sizeof(ATTR_DATA));

  //
  // Marshall the data object pointer for passing to the window proc thread.
  //
  HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, m_pDataObj,
                                             &m_pDataObjStrm);
//  m_pDataObj = NULL; // to make sure no one calls here
  CHECK_HRESULT(hr, m_hrInit = hr; return);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUserAcctPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsMultiUserAcctPage::OnInitDialog(LPARAM)
{
  TRACE(CDsMultiUserAcctPage,OnInitDialog);
  HRESULT hr = S_OK;
  DWORD i, cAttrs = 0, iLogonWksta, iUPN, iLoghrs, iUAC, iLastSet,
        iExpires, iSid;
  CWaitCursor wait;

  TCHAR szTitle[MAX_PATH];
  if (!LoadStringReport(m_nPageTitle, szTitle, MAX_PATH, NULL))
  {
      return HRESULT_FROM_WIN32(GetLastError());
  }

  if (!ADsPropSetHwndWithTitle(m_hNotifyObj, m_hPage, szTitle))
  {
    m_pWritableAttrs = NULL;
  }

  //
  // Add the check boxes to the scrolling checkbox list.
  //
  TCHAR tzList[161];
  HWND hChkList = GetDlgItem(m_hPage, IDC_CHECK_LIST);
  UINT rgIDS[] = {IDS_MUST_CHANGE_PW, IDS_CANT_CHANGE_PW, IDS_NO_PW_EXPIRE,
                  IDS_CLEAR_TEXT_PW, IDS_ACCT_DISABLED, IDS_SMARTCARD_REQ,
                  IDS_DELEGATION_OK, IDS_NOT_DELEGATED, IDS_DES_KEY_ONLY,
                  IDS_DONT_REQ_PREAUTH};
  for (i = 0; i < ARRAYLENGTH(rgIDS); i++)
  {
    LOAD_STRING(rgIDS[i], tzList, 160, return E_OUTOFMEMORY);
    int iItem = CheckList_AddItem(hChkList, tzList, rgIDS[i], BST_UNCHECKED);
    if (iItem != -1)
    {
      CheckList_SetItemCheck(hChkList, iItem, CLST_DISABLED, 2);
    }
  }

  iLogonWksta = iUPN = iLoghrs = iUAC = iLastSet = iExpires = iSid = cAttrs; // set to a flag value.

  //
  // Set default expiration
  //
  LARGE_INTEGER li;
  SYSTEMTIME st;
  GetSystemTime(&st);
  SystemTimeToFileTime(&st, (LPFILETIME)&li);

  //
  // The default account expiration time is 30 days from today.
  //
  li.QuadPart += DSPROP_FILETIMES_PER_MONTH;
  FILETIME ft;
  
  //
  // Convert the GMT time to Local time
  //
  FileTimeToLocalFileTime((LPFILETIME)&li, &ft);
  FileTimeToSystemTime(&ft, &st);

  //  
  // Initialize datepicker to expiration date
  //
  HWND hctlDateTime = GetDlgItem(m_hPage, IDC_ACCT_EXPIRES);

  DateTime_SetSystemtime(hctlDateTime, GDT_VALID, &st);
  EnableWindow(hctlDateTime, FALSE);

  SendDlgItemMessage(m_hPage, IDC_ACCT_NEVER_EXPIRES_RADIO, BM_SETCHECK, BST_CHECKED, 0);

  //
  // Logon Workstations.
  //
  m_pWkstaDlg = new CLogonWkstaDlg(this);
  CHECK_NULL_REPORT(m_pWkstaDlg, m_hPage, return E_OUTOFMEMORY);

  if (iLogonWksta < cAttrs)
  {
    // User-Workstations is a comma-separated list of workstation names.
    // It is a single-valued attribute. We are using the Multi-valued
    // attribute edit dialog for updating this attribue but by setting the
    // last parameter to TRUE it will accept the the comma list.
    //
    hr = m_pWkstaDlg->Init(&LogonWkstaBtn, NULL,
                           TRUE,
                           MAX_LOGON_WKSTAS, TRUE);
  }
  else
  {
    hr = m_pWkstaDlg->Init(&LogonWkstaBtn, NULL,
                           TRUE,
                           MAX_LOGON_WKSTAS, TRUE);
  }
  CHECK_HRESULT(hr, return hr);

  //
  // Logon Hours.
  //
  if (iLoghrs < cAttrs)
  {
    ASSERT(m_pargbLogonHours == NULL && "Memory Leak");
    m_pargbLogonHours = (BYTE *)LocalAlloc(0, cbLogonHoursArrayLength); // Allocate 21 bytes
  }

  //
  // User Can't change password.
  //
  // Allocate Self and World (Everyone) SIDs.
  //
  {
    SID_IDENTIFIER_AUTHORITY NtAuth    = SECURITY_NT_AUTHORITY,
                             WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
    if (!AllocateAndInitializeSid(&NtAuth,
                                  1,
                                  SECURITY_PRINCIPAL_SELF_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &m_pSelfSid))
    {
      DBG_OUT("AllocateAndInitializeSid failed!");
      ReportError(GetLastError(), 0, m_hPage);
      return HRESULT_FROM_WIN32(GetLastError());
    }
    if (!AllocateAndInitializeSid(&WorldAuth,
                                  1,
                                  SECURITY_WORLD_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &m_pWorldSid))
    {
      DBG_OUT("AllocateAndInitializeSid failed!");
      ReportError(GetLastError(), 0, m_hPage);
      return HRESULT_FROM_WIN32(GetLastError());
    }
  }

  FillSuffixCombo();

  return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiUserAcctPage::FillSuffixCombo
//
//  Synopsis:   Put the UPN suffixes into the combo box.
//
//-----------------------------------------------------------------------------
BOOL CDsMultiUserAcctPage::FillSuffixCombo()
{
  HRESULT hr;
  int iCurSuffix = -1;
  PWSTR pwzDomain;
  DWORD cAttrs, i;
  CComPtr <IDirectoryObject> spOU;
  Smart_PADS_ATTR_INFO spAttrs;


  //
  // For the retrieval of the DS Object names
  //
  FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM objMedium;
  LPDSOBJECTNAMES pDsObjectNames;

  //
  // Retrieve the DS object names
  //
  //
  // Get the path to the DS object from the data object.
  // Note: This call runs on the caller's main thread. The pages' window
  // procs run on a different thread, so don't reference the data object
  // from a winproc unless it is first marshalled on this thread.
  //

  if (m_pWPTDataObj == NULL)
  {
    return FALSE;
  }

  hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
  CHECK_HRESULT(hr, return FALSE);

  pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;
  dspAssert(pDsObjectNames != NULL);

  CStrW strServer;

  for (UINT idx = 0; idx < pDsObjectNames->cItems; idx++)
  {
    BOOL fFoundInOU = FALSE;
    hr = S_OK;
    //
    // Get the objects path
    //
    LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                             pDsObjectNames->aObjects[idx].offsetName);

    //
    // See if there is a UPN Suffixes attribute set on the containing OU and
    // use that if found.
    //

    CComPtr<IADs> spIADs;
    CComPtr<IDirectoryObject> spDirObj;
    CComBSTR sbParentPath;
    Smart_PADS_ATTR_INFO pAttrs;
    PWSTR pwzUsrSuffix = NULL;

    hr = DSAdminOpenObject(pwzObjADsPath, 
                           IID_IDirectoryObject, 
                           (PVOID*)&spDirObj);
    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); return FALSE;);

    //
    // Retrieve the user's suffix
    //
    PWSTR rgpwzAttrNames[] = {wzUPN};

    hr = spDirObj->GetObjectAttributes(rgpwzAttrNames,
                                       ARRAYLENGTH(rgpwzAttrNames),
                                       &pAttrs, &cAttrs);
    if (!CHECK_ADS_HR(&hr, GetHWnd()))
    {
        ReleaseStgMedium(&objMedium);
        return FALSE;
    }

    for (i = 0; i < cAttrs; i++)
    {
      dspAssert(pAttrs[i].dwNumValues);
      dspAssert(pAttrs[i].pADsValues);

      if (_wcsicmp(pAttrs[i].pszAttrName, wzUPN) == 0)
      {
        pwzUsrSuffix = wcsrchr(pAttrs[i].pADsValues->CaseIgnoreString, L'@');
      }
    }

    hr = spDirObj->QueryInterface(IID_IADs, (PVOID *)&spIADs);
    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); return FALSE;);

    hr = spIADs->get_Parent(&sbParentPath);
    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); return FALSE;);

    hr = DSAdminOpenObject(sbParentPath, 
                           IID_IDirectoryObject, 
                           (void **)&spOU);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); return FALSE;);

    //
    // Store the server
    //
    hr = GetLdapServerName(spOU, strServer);
    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); return FALSE;);

    PWSTR rgAttrs[] = {L"uPNSuffixes"};

    hr = spOU->GetObjectAttributes(rgAttrs, 1, &spAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
      ReleaseStgMedium(&objMedium);
      return FALSE;
    }

    if (cAttrs)
    {
      dspAssert(spAttrs && spAttrs->pADsValues && spAttrs->pADsValues->CaseIgnoreString);

      for (i = 0; i < spAttrs->dwNumValues; i++)
      {
        CStr csSuffix = L"@";
        csSuffix += spAttrs->pADsValues[i].CaseIgnoreString;

        if (SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_FINDSTRINGEXACT,
                               (WPARAM)-1, (LPARAM)(LPCTSTR)csSuffix) == CB_ERR)
        {
          int pos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                            CB_ADDSTRING, 0,
                                            (LPARAM)(LPCTSTR)csSuffix);

          if (pwzUsrSuffix && !wcscmp(csSuffix, pwzUsrSuffix))
          {
            iCurSuffix = pos;
          }
        }
      }

      SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_SETCURSEL,
                         (iCurSuffix > -1) ? iCurSuffix : 0, 0);
      fFoundInOU = TRUE;
    }

    if (fFoundInOU)
    {
      continue;
    }

    //
    // Add the user's suffix if it isn't already there
    //
    if (pwzUsrSuffix)
    {
      // User's UPN suffix does not match any of the defaults, so put
      // the user's into the combobox and select it.
      //
      if (SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_FINDSTRINGEXACT,
                             (WPARAM)-1, (LPARAM)pwzUsrSuffix) == CB_ERR)
      {
        iCurSuffix = (int)SendDlgItemMessage(GetHWnd(),
                                             IDC_UPN_SUFFIX_COMBO,
                                             CB_ADDSTRING, 0,
                                             (LPARAM)pwzUsrSuffix);
      }
    }

    //
    // No UPN suffixes on the OU, get those for the domain.
    //

    // Get the name of the user's domain.
    //
    CSmartWStr spwzUserDN;

    hr = SkipPrefix(pwzObjADsPath, &spwzUserDN);
    CHECK_HRESULT(hr, ReleaseStgMedium(&objMedium); return FALSE;);

    //
    // Get the name of the root domain.
    //
    CComPtr <IDsBrowseDomainTree> spDsDomains;

    hr = CoCreateInstance(CLSID_DsDomainTreeBrowser,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsBrowseDomainTree,
                          (LPVOID*)&spDsDomains);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); return FALSE;);

    dspAssert(!strServer.IsEmpty());
    hr = spDsDomains->SetComputer(strServer, NULL, NULL);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); return FALSE;);

    int pos;
    CStr csRootDomain = L"@";
    PDOMAIN_TREE pDomTree = NULL;

    hr = spDsDomains->GetDomains(&pDomTree, 0);

    CHECK_HRESULT(hr,;);

    hr = CrackName(spwzUserDN, &pwzDomain, GET_DNS_DOMAIN_NAME, GetHWnd());

    CHECK_HRESULT(hr, ReleaseStgMedium(&objMedium); return FALSE;);

    if (pDomTree)
    {
      for (UINT index = 0; index < pDomTree->dwCount; index++)
      {
        if (pDomTree->aDomains[index].pszTrustParent == NULL)
        {
          // Add the root domain only if it is a substring of the current
          // domain.
          //
          size_t cchRoot = wcslen(pDomTree->aDomains[index].pszName);
          PWSTR pRoot = pwzDomain + wcslen(pwzDomain) - cchRoot;

          if (!_wcsicmp(pRoot, pDomTree->aDomains[index].pszName))
          {
            csRootDomain += pDomTree->aDomains[index].pszName;

            if (SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_FINDSTRINGEXACT,
                                   (WPARAM)-1, (LPARAM)(LPCTSTR)csRootDomain) == CB_ERR)
            {
              pos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                            CB_ADDSTRING, 0,
                                            (LPARAM)(LPCTSTR)csRootDomain);

              if (pwzUsrSuffix && !_wcsicmp(csRootDomain, pwzUsrSuffix))
              {
                iCurSuffix = pos;
              }
            }
            break;
          }
        }
      }

      spDsDomains->FreeDomains(&pDomTree);
    }

    // If the local domain is not the root, add it as well.
    //
    CStr csLocalDomain = L"@";
    csLocalDomain += pwzDomain;

    LocalFreeStringW(&pwzDomain);

    if (_wcsicmp(csRootDomain, csLocalDomain))
    {
      if (SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_FINDSTRINGEXACT,
                             (WPARAM)-1, (LPARAM)(LPCTSTR)csLocalDomain) == CB_ERR)
      {
        pos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                      CB_ADDSTRING, 0,
                                      (LPARAM)(LPCTSTR)csLocalDomain);

        if (pwzUsrSuffix && !_wcsicmp(csLocalDomain, pwzUsrSuffix))
        {
          iCurSuffix = pos;
        }
      }
    }

    // Get UPN suffixes
    //
    CComBSTR bstrPartitions;
    //
    // get config path from main object
    //
    CComPtr<IADsPathname> spPathCracker;
    CDSBasePathsInfo CPaths;
    PWSTR pwzConfigPath;
    PDSDISPLAYSPECOPTIONS pDsDispSpecOptions;
    STGMEDIUM ObjMedium = {TYMED_NULL};
    FORMATETC fmteDispSpec = {g_cfDsDispSpecOptions, NULL, DVASPECT_CONTENT, -1,
                              TYMED_HGLOBAL};

    hr = m_pWPTDataObj->GetData(&fmteDispSpec, &ObjMedium);

    if (RPC_E_SERVER_DIED_DNE == hr)
    {
      hr = CPaths.InitFromName(strServer);

      CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); ReleaseStgMedium(&ObjMedium); return FALSE);

      pwzConfigPath = (PWSTR)CPaths.GetConfigNamingContext();
    }
    else
    {
      CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); ReleaseStgMedium(&ObjMedium); return FALSE;);

      pDsDispSpecOptions = (PDSDISPLAYSPECOPTIONS)ObjMedium.hGlobal;

      if (pDsDispSpecOptions->offsetServerConfigPath)
      {
        pwzConfigPath = (PWSTR)ByteOffset(pDsDispSpecOptions,
                                          pDsDispSpecOptions->offsetServerConfigPath);
      }
      else
      {
        hr = CPaths.InitFromName(strServer);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); ReleaseStgMedium(&ObjMedium); return FALSE);

        pwzConfigPath = (PWSTR)CPaths.GetConfigNamingContext();
      }
    }
    dspDebugOut((DEB_USER1, "Config path: %ws\n", pwzConfigPath));

    hr = GetADsPathname(spPathCracker);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); ReleaseStgMedium(&ObjMedium); return FALSE);

    hr = spPathCracker->Set(CComBSTR(pwzConfigPath), ADS_SETTYPE_FULL);

    ReleaseStgMedium(&ObjMedium);
    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); return FALSE;);

    hr = spPathCracker->AddLeafElement(CComBSTR(g_wzPartitionsContainer));

    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); return FALSE;);

    hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &bstrPartitions);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); return FALSE;);
    dspDebugOut((DEB_ITRACE, "Config path: %ws\n", bstrPartitions));

    CComPtr <IDirectoryObject> spPartitions;

    hr = DSAdminOpenObject(bstrPartitions, 
                           IID_IDirectoryObject, 
                           (void **)&spPartitions);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&objMedium); return FALSE;);

    spAttrs.Empty();

    hr = spPartitions->GetObjectAttributes(rgAttrs, 1, &spAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
      ReleaseStgMedium(&objMedium);
      return FALSE;
    }

    if (cAttrs)
    {
      dspAssert(spAttrs && spAttrs->pADsValues && spAttrs->pADsValues->CaseIgnoreString);

      for (i = 0; i < spAttrs->dwNumValues; i++)
      {
        CStr csSuffix = L"@";
        csSuffix += spAttrs->pADsValues[i].CaseIgnoreString;

        if (SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                               CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)(LPCTSTR)csSuffix) == CB_ERR)
        {
          int suffixPos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                            CB_ADDSTRING, 0,
                                            (LPARAM)(LPCTSTR)csSuffix);

          if (pwzUsrSuffix && !wcscmp(csSuffix, pwzUsrSuffix))
          {
            iCurSuffix = suffixPos;
          }
        }
      }
    }

    SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_SETCURSEL,
                       (iCurSuffix > -1) ? iCurSuffix : 0, 0);
  } // for

  // NTRAID#NTBUG9-699678-2002/09/05-artm
  UpdateComboBoxDropWidth(::GetDlgItem(GetHWnd(), IDC_UPN_SUFFIX_COMBO));

  ReleaseStgMedium(&objMedium);
  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUserAcctPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUserAcctPage::OnApply(void)
{
  TRACE(CDsMultiUserAcctPage,OnApply);
  HRESULT hr = S_OK;
  BOOL fWritePwdLastSet = FALSE;
  BOOL bErrorOccurred = FALSE;

  //
  // For the retrieval of the DS Object names
  //
  FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM objMedium;
  LPDSOBJECTNAMES pDsObjectNames;

  //
  // Retrieve the DS object names
  //
  //
  // Get the path to the DS object from the data object.
  // Note: This call runs on the caller's main thread. The pages' window
  // procs run on a different thread, so don't reference the data object
  // from a winproc unless it is first marshalled on this thread.
  //

  if (m_pWPTDataObj == NULL)
  {
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
  CHECK_HRESULT(hr, return PSNRET_INVALID_NOCHANGEPAGE);

  pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

  if (pDsObjectNames->cItems < 2)
  {
    DBG_OUT("Not enough objects in DSOBJECTNAMES structure");
    ReleaseStgMedium(&objMedium);
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  //
  // Prepare the error structure
  //
  PWSTR pszTitle = NULL;
  LoadStringToTchar(m_nPageTitle, &pszTitle);
  ADSPROPERROR adsPropError = {0};
  adsPropError.hwndPage = m_hPage;
  adsPropError.pszPageTitle = pszTitle;

  ADSVALUE ADsValueAcctCtrl = {ADSTYPE_INTEGER, 0};
  ADS_ATTR_INFO AttrInfoAcctCtrl = {g_wzUserAccountControl, ADS_ATTR_UPDATE,
                                    ADSTYPE_INTEGER, &ADsValueAcctCtrl, 1};
  ADSVALUE ADsValueAcctExpires = {ADSTYPE_LARGE_INTEGER, 0};
  ADS_ATTR_INFO AttrInfoAcctExpires = {wzAcctExpires, ADS_ATTR_UPDATE,
                                       ADSTYPE_LARGE_INTEGER,
                                       &ADsValueAcctExpires, 1};
  ADSVALUE ADsValuePwdLastSet = {ADSTYPE_LARGE_INTEGER, NULL};
  ADS_ATTR_INFO AttrInfoPwdLastSet = {wzPwdLastSet, ADS_ATTR_UPDATE,
                                     ADSTYPE_LARGE_INTEGER,
                                     &ADsValuePwdLastSet, 1};
  ADSVALUE ADsValueLogonHours = {ADSTYPE_OCTET_STRING, NULL};
  ADS_ATTR_INFO AttrInfoLogonHours = {wzLogonHours, ADS_ATTR_UPDATE,
                                      ADSTYPE_OCTET_STRING,
                                      &ADsValueLogonHours, 1};
  ADS_ATTR_INFO AttrInfoLogonWksta = {wzUserWksta, ADS_ATTR_UPDATE,
                                      ADSTYPE_CASE_IGNORE_STRING,
                                      NULL, 1};
  ADSVALUE ADsValueUPN = {ADSTYPE_CASE_IGNORE_STRING, NULL};
  ADS_ATTR_INFO AttrInfoUPN = {wzUPN, ADS_ATTR_UPDATE,
                               ADSTYPE_CASE_IGNORE_STRING, &ADsValueUPN, 1};

  // Array of attributes to write
  ADS_ATTR_INFO rgAttrs[6];
  DWORD cAttrs = 0;  // Number of attributes to write


  BOOL fDelegationChanged = FALSE;
  HWND hChkList = GetDlgItem(m_hPage, IDC_CHECK_LIST);
  //
  // User-Account-Control check boxes.
  //
  int dwNoPWExpire      = 0;
  int dwAcctDisabled    = 0;
  int dwClearTextPW     = 0;
  int dwSmartCardReq    = 0;
  int dwDelegOK         = 0;
  int dwNotDelegated    = 0;
  int dwDesKeyOnly      = 0;
  int dwDontReqPreAuth  = 0;

  DWORD dwUsrAcctCtrl   = 0;

  BOOL fApplyNoPWExpire     = FALSE;
  BOOL fApplyAcctDisabled   = FALSE;
  BOOL fApplyClearTextPW    = FALSE;
  BOOL fApplySmartCardReq   = FALSE;
  BOOL fApplyDelegOK        = FALSE;
  BOOL fApplyNotDelegated   = FALSE;
  BOOL fApplyDesKeyOnly     = FALSE;
  BOOL fApplyDontReqPreAuth = FALSE;

  if (m_fAcctCtrlChanged)
  {
    fApplyNoPWExpire = CheckList_GetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, 1);
    dwNoPWExpire = CheckList_GetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, 2);

    fApplyAcctDisabled = CheckList_GetLParamCheck(hChkList, IDS_ACCT_DISABLED, 1);
    dwAcctDisabled = CheckList_GetLParamCheck(hChkList, IDS_ACCT_DISABLED, 2);

    fApplyClearTextPW = CheckList_GetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, 1);
    dwClearTextPW = CheckList_GetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, 2);

    fApplySmartCardReq = CheckList_GetLParamCheck(hChkList, IDS_SMARTCARD_REQ, 1);
    dwSmartCardReq = CheckList_GetLParamCheck(hChkList, IDS_SMARTCARD_REQ, 2);

    fApplyDelegOK = CheckList_GetLParamCheck(hChkList, IDS_DELEGATION_OK, 1);
    dwDelegOK = CheckList_GetLParamCheck(hChkList, IDS_DELEGATION_OK, 2);

    fApplyNotDelegated = CheckList_GetLParamCheck(hChkList, IDS_NOT_DELEGATED, 1);
    dwNotDelegated = CheckList_GetLParamCheck(hChkList, IDS_NOT_DELEGATED, 2);

    fApplyDesKeyOnly = CheckList_GetLParamCheck(hChkList, IDS_DES_KEY_ONLY, 1);
    dwDesKeyOnly = CheckList_GetLParamCheck(hChkList, IDS_DES_KEY_ONLY, 2);

    fApplyDontReqPreAuth = CheckList_GetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, 1);
    dwDontReqPreAuth = CheckList_GetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, 2);

    ADsValueAcctCtrl.Integer = dwUsrAcctCtrl;
    rgAttrs[cAttrs++] = AttrInfoAcctCtrl;
  }

  //
  // Account Expires
  //
  LRESULT fApplyAcctExpires = SendDlgItemMessage(m_hPage, IDC_APPLY_EXPIRES_CHK, BM_GETCHECK, 0, 0);
  if (fApplyAcctExpires == BST_CHECKED)
  {
    ADsValueAcctExpires.LargeInteger.LowPart = 0;
    ADsValueAcctExpires.LargeInteger.HighPart = 0;
    if (IsDlgButtonChecked(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO) == BST_CHECKED)
    {
      //
      // Get the expire date from the control
      //
      HWND hctlDateTime = GetDlgItem(m_hPage, IDC_ACCT_EXPIRES);
      SYSTEMTIME st;   // Local time in a human-readable format

      LRESULT lResult = DateTime_GetSystemtime(hctlDateTime, &st);
      dspAssert(lResult == GDT_VALID); // The control should always have a valid time

      //
      // Zero the time part of the struct.
      //
      st.wHour = st.wMinute = st.wSecond = st.wMilliseconds = 0;
      FILETIME ftLocal;   // Local filetime
      FILETIME ftGMT;     // GMT filetime

      //
      // Convert the human-readable time to a cryptic local filetime format
      //
      SystemTimeToFileTime(&st, &ftLocal);

      //
      // Add a day since it expires at the beginning of the next day.
      //
      ADS_LARGE_INTEGER liADsExpiresDate;
      liADsExpiresDate.LowPart = ftLocal.dwLowDateTime;
      liADsExpiresDate.HighPart = ftLocal.dwHighDateTime;
      liADsExpiresDate.QuadPart += DSPROP_FILETIMES_PER_DAY;
      ftLocal.dwLowDateTime = liADsExpiresDate.LowPart;
      ftLocal.dwHighDateTime = liADsExpiresDate.HighPart;

      FileTimeToSystemTime(&ftLocal,&st);

      //
      //Convert time to UTC time
      //
      SYSTEMTIME stGMT;
      TzSpecificLocalTimeToSystemTime(NULL,&st,&stGMT);
      SystemTimeToFileTime(&stGMT,&ftGMT);

      //
      // Store the GMT time into the ADs value
      //
      ADsValueAcctExpires.LargeInteger.LowPart = ftGMT.dwLowDateTime;
      ADsValueAcctExpires.LargeInteger.HighPart = ftGMT.dwHighDateTime;
      dspDebugOut((DEB_ITRACE, "Setting Account-Expires to 0x%x,%08x\n",
                   ADsValueAcctExpires.LargeInteger.HighPart,
                   ADsValueAcctExpires.LargeInteger.LowPart));
    }
    rgAttrs[cAttrs++] = AttrInfoAcctExpires;
  }

  //
  // Logon hours
  //
  LRESULT fApplyLogonHours = SendDlgItemMessage(m_hPage, IDC_APPLY_HOURS_CHK, BM_GETCHECK, 0, 0);
  if (fApplyLogonHours == BST_CHECKED && m_pargbLogonHours != NULL && m_fLogonHoursChanged)
  {
    ADsValueLogonHours.OctetString.dwLength = cbLogonHoursArrayLength;
    ADsValueLogonHours.OctetString.lpValue = m_pargbLogonHours;
    ASSERT(cAttrs < ARRAYLENGTH(rgAttrs));
    rgAttrs[cAttrs++] = AttrInfoLogonHours;
  }

  //
  // Get PW check box values.
  //
  BOOL fApplyMustChangePW = CheckList_GetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, 1);
  BOOL fMustChangePW = CheckList_GetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, 2);

  BOOL fApplyCantChangePW = CheckList_GetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, 1);
  BOOL fNewCantChangePW = CheckList_GetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, 2);

  //
  // Enforce PW combination rules.
  //
  if (fApplyMustChangePW && fMustChangePW && 
      fApplyCantChangePW && fNewCantChangePW)
  {
    ErrMsg(IDS_ERR_BOTH_PW_BTNS, m_hPage);
    ReleaseStgMedium(&objMedium);
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  if ((fApplyNoPWExpire && dwNoPWExpire) && (fApplyMustChangePW && fMustChangePW))
  {
    ErrMsg(IDS_PASSWORD_MUTEX, m_hPage);
    CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, FALSE, 2);
    ReleaseStgMedium(&objMedium);
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  //
  // Logon Workstations.
  //
  LRESULT fApplyLogonComputers = SendDlgItemMessage(m_hPage, IDC_APPLY_COMPUTERS_CHK, BM_GETCHECK, 0, 0);
  if (fApplyLogonComputers == BST_CHECKED && m_pWkstaDlg && m_pWkstaDlg->IsDirty())
  {
    hr = m_pWkstaDlg->Write(&AttrInfoLogonWksta);

    CHECK_HRESULT(hr, ReleaseStgMedium(&objMedium); return PSNRET_INVALID_NOCHANGEPAGE);

    rgAttrs[cAttrs++] = AttrInfoLogonWksta;
  }

  LRESULT fApplyUPN = SendDlgItemMessage(m_hPage, IDC_APPLY_UPN_CHK, BM_GETCHECK, 0, 0);

  if (!cAttrs &&
      fApplyUPN == BST_UNCHECKED)
  {
    ReleaseStgMedium(&objMedium);
    // NTRAID#NTBUG9-510198-2002/01/15-ronmart-return noerror if bErrorOccured is false
    return (bErrorOccurred) ? PSNRET_INVALID_NOCHANGEPAGE : PSNRET_NOERROR;
  }

  for (UINT idx = 0; idx < pDsObjectNames->cItems; idx++)
  {
    DWORD dwNumAttrs = cAttrs;
    CStr UPNPrefix;
    CStr completeUPN;

    hr = S_OK;
    //
    // Get the objects path
    //
    LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                             pDsObjectNames->aObjects[idx].offsetName);

    LPWSTR pwzObjClass = (PWSTR)ByteOffset(pDsObjectNames,
                                           pDsObjectNames->aObjects[idx].offsetClass);

    adsPropError.pszObjPath = pwzObjADsPath;
    adsPropError.pszObjClass = pwzObjClass;

    //
    // Bind to the object
    //
    CComPtr<IDirectoryObject> spDirObject;
    hr = DSAdminOpenObject(pwzObjADsPath, 
                           IID_IDirectoryObject, 
                           (PVOID*)&spDirObject);
    if (FAILED(hr))
    {
      DBG_OUT("Failed to bind to a multi-select object for Apply.");
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      continue;
    }

    //
    // Get the current user account control attribute value.
    //
    PADS_ATTR_INFO pAttrs = NULL;
    ULONG cUACAttrs = 0;
    PWSTR rgpwzAttrNames[] = {g_wzUserAccountControl, wzPwdLastSet, wzUPN};

    hr = spDirObject->GetObjectAttributes(rgpwzAttrNames,
                                          ARRAYLENGTH(rgpwzAttrNames),
                                          &pAttrs, 
                                          &cUACAttrs);
    if (FAILED(hr))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      continue;
    }

    if (pAttrs == NULL || cUACAttrs < 1)
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      continue;
    }

    for (UINT iCount = 0; iCount < cUACAttrs; iCount++)
    {
      if (_wcsicmp(pAttrs[iCount].pszAttrName, g_wzUserAccountControl) == 0)
      {
        dwUsrAcctCtrl = pAttrs[iCount].pADsValues->Integer;
      }

      if (_wcsicmp(pAttrs[iCount].pszAttrName, wzPwdLastSet) == 0)
      {
        m_PwdLastSet.HighPart = pAttrs[iCount].pADsValues->LargeInteger.HighPart;
        m_PwdLastSet.LowPart = pAttrs[iCount].pADsValues->LargeInteger.LowPart;
      }

      if (_wcsicmp(pAttrs[iCount].pszAttrName, wzUPN) == 0)
      {
         CStr upn = pAttrs[iCount].pADsValues->CaseIgnoreString;

         int atIndex = upn.Find(L"@");
         if (atIndex != -1)
         {
            UPNPrefix = upn.Left(atIndex);
         }
         else
         {
            UPNPrefix = upn;
         }
      }
    }

    //
    // Set the new user account control value
    //
    if (fApplyNoPWExpire && (dwNoPWExpire == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_DONT_EXPIRE_PASSWD;
    }
    else if (fApplyNoPWExpire && dwNoPWExpire == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_DONT_EXPIRE_PASSWD);
    }

    if (fApplyAcctDisabled && (dwAcctDisabled == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_ACCOUNTDISABLE;
    }
    else if (fApplyAcctDisabled && dwAcctDisabled == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_ACCOUNTDISABLE);
    }

    if (fApplyClearTextPW && (dwClearTextPW == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
    }
    else if (fApplyClearTextPW && dwClearTextPW == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED);
    }

    if (fApplySmartCardReq && (dwSmartCardReq == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_SMARTCARD_REQUIRED;
    }
    else if (fApplySmartCardReq && dwSmartCardReq == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_SMARTCARD_REQUIRED);
    }

    if (fApplyDelegOK && (dwDelegOK == BST_CHECKED))
    {
      if (!(dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION))
      {
        dwUsrAcctCtrl |= UF_TRUSTED_FOR_DELEGATION;
        fDelegationChanged = TRUE;
      }
    }
    else if (fApplyDelegOK && dwDelegOK == BST_UNCHECKED)
    {
      if (dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION)
      {
        dwUsrAcctCtrl &= ~(UF_TRUSTED_FOR_DELEGATION);
        fDelegationChanged = TRUE;
      }
    }

    if (fApplyNotDelegated && (dwNotDelegated == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_NOT_DELEGATED;
    }
    else if (fApplyNotDelegated && dwNotDelegated == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_NOT_DELEGATED);
    }

    if (fApplyDesKeyOnly && (dwDesKeyOnly == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_USE_DES_KEY_ONLY;
    }
    else if (fApplyDesKeyOnly && dwDesKeyOnly == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_USE_DES_KEY_ONLY);
    }

    if (fApplyDontReqPreAuth && (dwDontReqPreAuth == BST_CHECKED))
    {
      dwUsrAcctCtrl |= UF_DONT_REQUIRE_PREAUTH;
    }
    else if (fApplyDontReqPreAuth && dwDontReqPreAuth == BST_UNCHECKED)
    {
      dwUsrAcctCtrl &= ~(UF_DONT_REQUIRE_PREAUTH);
    }

    ADsValueAcctCtrl.Integer = dwUsrAcctCtrl;
    
    if (fApplyMustChangePW && fMustChangePW)
    {
      if ((m_PwdLastSet.HighPart != 0) || (m_PwdLastSet.LowPart != 0))
      {
        ADsValuePwdLastSet.LargeInteger.LowPart = 0;
        ADsValuePwdLastSet.LargeInteger.HighPart = 0;
        fWritePwdLastSet = TRUE;
      }

      //
      // Make sure "User can't change password..." isn't set
      //
      CSimpleSecurityDescriptorHolder SDHolder;
      PACL pDacl = NULL;

      DWORD dwErr = 
         GetDsObjectSD(
            pwzObjADsPath,
            &pDacl,
            &(SDHolder.m_pSD));

      dspAssert(IsValidAcl(pDacl));

      if (dwErr == ERROR_SUCCESS)
      {
        ULONG ulCount, j;
        PEXPLICIT_ACCESS rgEntries;

        dwErr = GetExplicitEntriesFromAcl(pDacl, &ulCount, &rgEntries);
        if (dwErr == ERROR_SUCCESS)
        {
          if (ulCount > 0)
          {
            BOOL fDenyAceFound = FALSE;

            for (j = 0; j < ulCount; j++)
            {
              if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
                  (rgEntries[j].grfAccessMode == DENY_ACCESS))
              {
                OBJECTS_AND_SID * pObjectsAndSid;
                pObjectsAndSid = (OBJECTS_AND_SID *)rgEntries[j].Trustee.ptstrName;

                if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                                GUID_CONTROL_UserChangePassword) &&
                    (EqualSid(pObjectsAndSid->pSid, m_pSelfSid) ||
                     EqualSid(pObjectsAndSid->pSid, m_pWorldSid)))
                {
                  fDenyAceFound = TRUE;
                  break;
                }
              }
            }

            if (fDenyAceFound)
            {
              if (!fApplyCantChangePW)
              {
                PTSTR ptzError = NULL;
                if (LoadStringToTchar(IDS_ERR_BOTH_PW_BTNS, &ptzError))
                {
                  adsPropError.hr = 0;
                  adsPropError.pszError = ptzError;
                  SendErrorMessage(&adsPropError);
                  bErrorOccurred = TRUE;
                  delete ptzError;

                  continue;
                }
              }
            }
          }
        }
      }
    }
    else if (fApplyMustChangePW && !fMustChangePW)
    {
      if ((m_PwdLastSet.HighPart == 0) && (m_PwdLastSet.LowPart == 0))
      {
        ADsValuePwdLastSet.LargeInteger.LowPart = 0xffffffff;
        ADsValuePwdLastSet.LargeInteger.HighPart = 0xffffffff;
        fWritePwdLastSet = TRUE;
      }
    }

    if (fWritePwdLastSet)
    {
      //
      // User-must-change-PW.
      //
      AttrInfoPwdLastSet.dwNumValues = 1;
      ASSERT(dwNumAttrs < ARRAYLENGTH(rgAttrs));
      rgAttrs[dwNumAttrs++] = AttrInfoPwdLastSet;
    }

    //
    // Check to see if we need to set the UPN and then add it to the array
    //
    
    // 2002/07/05-ArtM --- no need to redeclare fApplyUPN in this scope (thanks PREFast)
    fApplyUPN = SendDlgItemMessage(m_hPage, IDC_APPLY_UPN_CHK, BM_GETCHECK, 0, 0);
    if (fApplyUPN == BST_CHECKED)
    {
      // Get the UPN suffix from the combo

      CStr csUPNSuffix;

      int iCurSuffix;
      iCurSuffix = (int)SendDlgItemMessage(m_hPage, IDC_UPN_SUFFIX_COMBO, CB_GETCURSEL, 0, 0);
      if (iCurSuffix != CB_ERR)
      {
         int cchDomain = 
            (int)SendDlgItemMessage(
               m_hPage, 
               IDC_UPN_SUFFIX_COMBO,
               CB_GETLBTEXTLEN, 
               iCurSuffix, 
               0);

         csUPNSuffix.GetBufferSetLength(cchDomain);

         if ((LPCWSTR)csUPNSuffix == NULL)
         {
            adsPropError.hr = E_OUTOFMEMORY;
            SendErrorMessage(&adsPropError);
            bErrorOccurred = TRUE;

            continue;
         }

         SendDlgItemMessage(
            m_hPage, 
            IDC_UPN_SUFFIX_COMBO, 
            CB_GETLBTEXT,
            iCurSuffix, 
            (LPARAM)(LPCWSTR)csUPNSuffix);

         completeUPN = UPNPrefix;
         completeUPN += csUPNSuffix;
      }

      if (!completeUPN.IsEmpty())
      {
         AttrInfoUPN.dwNumValues = 1;
         ADsValueUPN.CaseIgnoreString = (PWSTR)(PCWSTR)completeUPN;
         ASSERT(dwNumAttrs < ARRAYLENGTH(rgAttrs));
         rgAttrs[dwNumAttrs++] = AttrInfoUPN;
      }
    }

    //
    // Check to be sure the user doesn't have "Password doesn't expire..." and
    // "User must change password..." set
    //
    if (((m_PwdLastSet.LowPart == 0 &&
          m_PwdLastSet.HighPart == 0 &&
          !fWritePwdLastSet) ||
         (ADsValuePwdLastSet.LargeInteger.LowPart == 0 &&
          ADsValuePwdLastSet.LargeInteger.HighPart == 0 &&
          fWritePwdLastSet)) &&
        (dwUsrAcctCtrl & UF_DONT_EXPIRE_PASSWD))
    {
      PTSTR ptzError = NULL;
      if (LoadStringToTchar(IDS_ERR_BOTH_MUST_EXPIRES, &ptzError))
      {
        adsPropError.hr = 0;
        adsPropError.pszError = ptzError;
        SendErrorMessage(&adsPropError);
        bErrorOccurred = TRUE;
        delete ptzError;

        continue;
      }
    }



    //
    // Write the changes.
    //
    DWORD cModified;

    hr = spDirObject->SetObjectAttributes(rgAttrs, dwNumAttrs, &cModified);

    if (FAILED(hr))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;

      DWORD dwErr;
      WCHAR wszErrBuf[MAX_PATH+1];
      WCHAR wszNameBuf[MAX_PATH+1];
      ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);

      if (dwErr)
      {
        dspDebugOut((DEB_ERROR,
                     "Extended Error 0x%x: %ws %ws <%s @line %d>.\n", dwErr,
                     wszErrBuf, wszNameBuf, __FILE__, __LINE__));

        if ((ERROR_PRIVILEGE_NOT_HELD == dwErr) && fDelegationChanged)
        {
          // Whoda thunk that a single bit in UAC has an access check on
          // it. Do special case error checking and reporting for the
          // delegate bit.
          //
          if (dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION)
          {
            dwUsrAcctCtrl &= ~(UF_TRUSTED_FOR_DELEGATION);
            CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_UNCHECKED);
          }
          else
          {
            dwUsrAcctCtrl |= UF_TRUSTED_FOR_DELEGATION;
            CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_CHECKED);
          }
        }
      }
      else
      {
        dspDebugOut((DEB_ERROR, "Error %08lx <%s @line %d>\n", hr, __FILE__, __LINE__));
      }
      continue;
    }


    //
    // User-can't change password
    //
    if (fApplyCantChangePW)
    {

      //
      // Check to see if the user already had "User must change password..."
      // enabled outside the ui and warn the admin if it was and we are trying
      // to set "Can't change password..."
      //
      if (m_PwdLastSet.LowPart == 0 &&
          m_PwdLastSet.HighPart == 0)
      {
        if (!fApplyMustChangePW)
        {
          PTSTR ptzError = NULL;
          if (LoadStringToTchar(IDS_ERR_BOTH_PW_BTNS, &ptzError))
          {
            adsPropError.hr = hr;
            adsPropError.pszError = ptzError;
            SendErrorMessage(&adsPropError);
            bErrorOccurred = TRUE;
            delete ptzError;

            continue;
          }
        }
      }

      CSimpleSecurityDescriptorHolder SDHolder;
      PACL pDacl = NULL;
      CSimpleAclHolder NewDacl;

      DWORD dwErr = 
         GetDsObjectSD(
            pwzObjADsPath,
            &pDacl,
            &(SDHolder.m_pSD));

      dspAssert(IsValidAcl(pDacl));
      CHECK_WIN32_REPORT(dwErr, m_hPage, adsPropError.hr = HRESULT_FROM_WIN32(dwErr); SendErrorMessage(&adsPropError); bErrorOccurred = TRUE; continue;);

      if (fNewCantChangePW)
      {
        //
        // Revoke the user's change password right by writing DENY ACEs.
        // Note that this can be an inherited right (which is the default
        // case), so attempting to remove GRANT ACEs is not sufficient.
        //

	    //NTRAID#NTBUG9-569720-2002/03/10-jmessec    Use a #define instead of '2'; '2' is interspersed throughout the following code, which could
		  //lead to badness if a code maintenance change changes this length and misses 1 hardcoded '2'
        EXPLICIT_ACCESS rgAccessEntry[2] = {0};
        OBJECTS_AND_SID rgObjectsAndSid[2] = {0};

        //
        // initialize the new entries (DENY ACE's)
        //
        rgAccessEntry[0].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
        rgAccessEntry[0].grfAccessMode = DENY_ACCESS;
        rgAccessEntry[0].grfInheritance = NO_INHERITANCE;

        rgAccessEntry[1].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
        rgAccessEntry[1].grfAccessMode = DENY_ACCESS;
        rgAccessEntry[1].grfInheritance = NO_INHERITANCE;

        // build the trustee structs for change password
        //
        BuildTrusteeWithObjectsAndSid(&(rgAccessEntry[0].Trustee),
                                      &(rgObjectsAndSid[0]),
                                      const_cast<GUID *>(&GUID_CONTROL_UserChangePassword),
                                      NULL, // inherit guid
                                      m_pSelfSid);

        BuildTrusteeWithObjectsAndSid(&(rgAccessEntry[1].Trustee),
                                      &(rgObjectsAndSid[1]),
                                      const_cast<GUID *>(&GUID_CONTROL_UserChangePassword),
                                      NULL, // inherit guid
                                      m_pWorldSid);
        // add the entries to the ACL
        //
        DBG_OUT("calling SetEntriesInAcl()");

        dwErr = SetEntriesInAcl(2, rgAccessEntry, pDacl, &(NewDacl.m_pAcl));
      }
      else
      {
        // Restore the user's change password right by removing any DENY ACEs.
        // If the GRANT ACEs are not present then we will add them back.
        // Bug #435315
        //
        ULONG ulCount, ulNewCount = 0, ulOldCount = 0, j;
        PEXPLICIT_ACCESS rgEntries, rgNewEntries;

        dwErr = GetExplicitEntriesFromAcl(pDacl, &ulCount, &rgEntries);

        if (dwErr != ERROR_SUCCESS) 
        {
          adsPropError.hr = HRESULT_FROM_WIN32(dwErr);
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE;
          continue;
        }

        if (!ulCount)
        {
          adsPropError.hr = HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE; 
          continue;
        }


        //
        // Add to the count for the Allow ACEs if they are not there
        //
        ulOldCount = ulCount;
        ulCount += 2;

        rgNewEntries = (PEXPLICIT_ACCESS)LocalAlloc(LPTR, (ulCount) * sizeof(EXPLICIT_ACCESS));

        if (rgNewEntries == NULL)
        {
          LocalFree(rgEntries); 
          adsPropError.hr = E_OUTOFMEMORY;
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE;
          ReleaseStgMedium(&objMedium);
          return PSNRET_INVALID_NOCHANGEPAGE;
        }

        for (j = 0; j < ulOldCount; j++)
        {
          BOOL fDenyAceFound = FALSE;

          if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
              (rgEntries[j].grfAccessMode == DENY_ACCESS))
          {
            OBJECTS_AND_SID * pObjectsAndSid;
            pObjectsAndSid = (OBJECTS_AND_SID *)rgEntries[j].Trustee.ptstrName;

            if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                            GUID_CONTROL_UserChangePassword) &&
                (EqualSid(pObjectsAndSid->pSid, m_pSelfSid) ||
                 EqualSid(pObjectsAndSid->pSid, m_pWorldSid)))
            {
              fDenyAceFound = TRUE;
            }
          }

          if (!fDenyAceFound)
          {
            rgNewEntries[ulNewCount] = rgEntries[j];
            ulNewCount++;
          }
        }

        //
        // Add the allow aces
        //
        OBJECTS_AND_SID rgObjectsAndSid = {0};
        rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
        rgNewEntries[ulNewCount].grfAccessMode = GRANT_ACCESS;
        rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;

        BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                      &(rgObjectsAndSid),
                                      const_cast<GUID*>(&GUID_CONTROL_UserChangePassword),
                                      NULL, // inherit guid
                                      m_pSelfSid);
        ulNewCount++;

        memset(&rgObjectsAndSid, 0, sizeof(OBJECTS_AND_SID));
        rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
        rgNewEntries[ulNewCount].grfAccessMode = GRANT_ACCESS;
        rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;

        BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                      &(rgObjectsAndSid),
                                      const_cast<GUID*>(&GUID_CONTROL_UserChangePassword),
                                      NULL, // inherit guid
                                      m_pWorldSid);
        ulNewCount++;


        ACL EmptyAcl;
        InitializeAcl(&EmptyAcl, sizeof(ACL), ACL_REVISION_DS);

        //
        // Create a new ACL without the DENY entries.
        //
        DBG_OUT("calling SetEntriesInAcl()");

        dwErr = SetEntriesInAcl(ulNewCount, rgNewEntries, &EmptyAcl, &(NewDacl.m_pAcl));

        dspAssert(IsValidAcl(NewDacl.m_pAcl));
        LocalFree(rgEntries);
        LocalFree(rgNewEntries);
      }

      if (dwErr != ERROR_SUCCESS)
      {
        adsPropError.hr = HRESULT_FROM_WIN32(dwErr);
        SendErrorMessage(&adsPropError);
        bErrorOccurred = TRUE;
        continue;
      }

      dwErr = 
         SetDsObjectDacl(
            pwzObjADsPath,
            NewDacl.m_pAcl);

      if (dwErr != ERROR_SUCCESS)
      {
        adsPropError.hr = HRESULT_FROM_WIN32(dwErr);
        SendErrorMessage(&adsPropError);
        bErrorOccurred = TRUE;
        continue;
      }
    }
  }  // for

  if (!bErrorOccurred)
  {
    //
    // Clean the changed flags for the controls and the workstation dialog
    //
    m_fAcctCtrlChanged = FALSE;
    m_fAcctExpiresChanged = FALSE;
    m_fLogonHoursChanged = FALSE;

    if (m_pWkstaDlg && m_pWkstaDlg->IsDirty())
    {
      m_pWkstaDlg->ClearDirty();
    }

    SendDlgItemMessage(m_hPage, IDC_APPLY_UPN_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_UPN_SUFFIX_COMBO), FALSE);
    SendDlgItemMessage(m_hPage, IDC_APPLY_HOURS_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_HOURS_BTN), FALSE);
    SendDlgItemMessage(m_hPage, IDC_APPLY_COMPUTERS_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_TO_BTN), FALSE);
    SendDlgItemMessage(m_hPage, IDC_APPLY_EXPIRES_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_NEVER_EXPIRES_RADIO), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES), FALSE);

    CheckList_SetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_ACCT_DISABLED, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_ACCT_DISABLED, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_ACCT_DISABLED, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_SMARTCARD_REQ, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_SMARTCARD_REQ, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_SMARTCARD_REQ, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_NOT_DELEGATED, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_NOT_DELEGATED, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_NOT_DELEGATED, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_DES_KEY_ONLY, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_DES_KEY_ONLY, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_DES_KEY_ONLY, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, CLST_DISABLED, 2);
    CheckList_SetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, FALSE, 1);
    CheckList_SetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, FALSE, 2);
    CheckList_SetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, CLST_DISABLED, 2);
  }

  if (AttrInfoLogonWksta.pADsValues)
  {
    DO_DEL(AttrInfoLogonWksta.pADsValues->CaseIgnoreString);
    delete AttrInfoLogonWksta.pADsValues;
  }

  if (bErrorOccurred)
  {
    ADsPropShowErrorDialog(m_hNotifyObj, m_hPage);
  }
  ReleaseStgMedium(&objMedium);
  return (bErrorOccurred) ? PSNRET_INVALID_NOCHANGEPAGE : PSNRET_NOERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUserAcctPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      Standard multi-valued attribute handling assumes that the
//              "modify" button has an ID that is one greater than the
//              corresponding combo box.
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUserAcctPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
  if (m_fInInit)
  {
    return 0;
  }

  switch (id)
  {
    case IDC_LOGON_HOURS_BTN:
      if (codeNotify == BN_CLICKED)
      {
        if (m_fIsAdmin)
        {
          MsgBox2(IDS_ADMIN_NOCHANGE, IDS_LOGON_HOURS, m_hPage);
          break;
        }

        LPCWSTR pszRDN = GetObjRDName();
        HRESULT hr = DllScheduleDialog(m_hPage,
                                       &m_pargbLogonHours,
                                       (NULL != pszRDN)
                                           ? IDS_s_LOGON_HOURS_FOR
                                           : IDS_LOGON_HOURS,
                                       pszRDN );
        if (hr == S_OK)
        {
          m_fLogonHoursChanged = TRUE;
          SetDirty();
        }
      }
      break;

    case IDC_LOGON_TO_BTN:
      if (codeNotify == BN_CLICKED)
      {
        if (m_fIsAdmin)
        {
          MsgBox2(IDS_ADMIN_NOCHANGE, IDS_LOGON_WKSTA, m_hPage);
          break;
        }
        if (m_pWkstaDlg && (m_pWkstaDlg->Edit() == IDOK))
        {
          if (m_pWkstaDlg->IsDirty())
          {
            SetDirty();
          }
        }
      }
      break;

    case IDC_ACCT_NEVER_EXPIRES_RADIO:
    case IDC_ACCT_EXPIRES_ON_RADIO:
      if (codeNotify == BN_CLICKED)
      {
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES), id == IDC_ACCT_EXPIRES_ON_RADIO);
        m_fAcctExpiresChanged = TRUE;
        SetDirty();
      }
      return 1;

    case IDC_APPLY_UPN_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyUPN = SendDlgItemMessage(m_hPage, IDC_APPLY_UPN_CHK, BM_GETCHECK, 0, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_UPN_SUFFIX_COMBO), lApplyUPN == BST_CHECKED);
        SetDirty();
      }
      break;

    case IDC_APPLY_HOURS_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyHours = SendDlgItemMessage(m_hPage, IDC_APPLY_HOURS_CHK, BM_GETCHECK, 0, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_HOURS_BTN), lApplyHours == BST_CHECKED);
        SetDirty();
      }
      break;

    case IDC_APPLY_COMPUTERS_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyComputers = SendDlgItemMessage(m_hPage, IDC_APPLY_COMPUTERS_CHK, BM_GETCHECK, 0, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_TO_BTN), lApplyComputers == BST_CHECKED);
        SetDirty();
      }
      break;

    case IDC_APPLY_EXPIRES_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyExpires = SendDlgItemMessage(m_hPage, IDC_APPLY_EXPIRES_CHK, BM_GETCHECK, 0, 0);
        LRESULT lExpiresOn = SendDlgItemMessage(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO, BM_GETCHECK, 0, 0);

        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_NEVER_EXPIRES_RADIO), lApplyExpires == BST_CHECKED);
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO), lApplyExpires == BST_CHECKED);

        if (lApplyExpires == BST_CHECKED)
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES), lExpiresOn == BST_CHECKED);
        }
        else
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES), false);
        }
        SetDirty();
      }
      break;
  }
  return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUserAcctPage::OnNotify
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUserAcctPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    NMHDR * pNmHdr = (NMHDR *)lParam;
    int codeNotify = pNmHdr->code;
    switch (wParam)
    {
    case IDC_CHECK_LIST:
      if (codeNotify == CLN_CLICK)
      {
        m_fAcctCtrlChanged = TRUE;
        SetDirty();

        NM_CHECKLIST* pnmc = reinterpret_cast<NM_CHECKLIST*>(lParam);
        if (pnmc != NULL)
        {
          int iResult = CheckList_GetItemCheck(pnmc->hdr.hwndFrom, pnmc->iItem);
          if (iResult == CLST_CHECKED)
          {
            int iCurrState = CheckList_GetItemCheck(pnmc->hdr.hwndFrom, pnmc->iItem, 2);
            iCurrState = iCurrState & ~(CLST_DISABLED);
            CheckList_SetItemCheck(pnmc->hdr.hwndFrom, pnmc->iItem, iCurrState, 2);
          }
          else if (iResult == CLST_UNCHECKED)
          {
            int iCurrState = CheckList_GetItemCheck(pnmc->hdr.hwndFrom, pnmc->iItem, 2);
            iCurrState = (iCurrState | CLST_DISABLED) & ~CLST_CHECKED;
            CheckList_SetItemCheck(pnmc->hdr.hwndFrom, pnmc->iItem, iCurrState, 2);
          }
        }
      }
      break;

    case IDC_ACCT_EXPIRES:
      dspDebugOut((DEB_ITRACE,
                   "OnNotify, id = IDC_ACCT_EXPIRES, code = 0x%x\n",
                   codeNotify));
      if (codeNotify == DTN_DATETIMECHANGE)
      {
        m_fAcctExpiresChanged = TRUE;
        SetDirty();
      }
      break;
    }
    return CDsPropPageBase::OnNotify(wParam, lParam);
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiUsrProfilePage::CDsMultiUsrProfilePage
//
//-----------------------------------------------------------------------------
CDsMultiUsrProfilePage::CDsMultiUsrProfilePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                               HWND hNotifyObj, DWORD dwFlags) :
    m_ptszLocalHomeDir(NULL),
    m_ptszRemoteHomeDir(NULL),
    m_pwzSamName(NULL),
    m_nDrive(COMBO_Z_DRIVE),
    m_idHomeDirRadio(IDC_LOCAL_PATH_RADIO),
    m_fProfilePathWritable(FALSE),
    m_fScriptPathWritable(FALSE),
    m_fHomeDirWritable(FALSE),
    m_fHomeDriveWritable(FALSE),
    m_fProfilePathChanged(FALSE),
    m_fLogonScriptChanged(FALSE),
    m_fHomeDirChanged(FALSE),
    m_fHomeDriveChanged(FALSE),
    m_fSharedDirChanged(FALSE),
    m_pObjSID(NULL),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
  TRACE(CDsUsrProfilePage,CDsUsrProfilePage);
#ifdef _DEBUG
  strcpy(szClass, "CDsUsrProfilePage");
#endif
  m_fMultiselectPage = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsMultiUsrProfilePage::~CDsMultiUsrProfilePage
//
//-----------------------------------------------------------------------------
CDsMultiUsrProfilePage::~CDsMultiUsrProfilePage()
{
  TRACE(CDsMultiUsrProfilePage,~CDsMultiUsrProfilePage);
  if (m_ptszLocalHomeDir)
  {
    delete m_ptszLocalHomeDir;
  }
  if (m_ptszRemoteHomeDir)
  {
    delete m_ptszRemoteHomeDir;
  }
  if (m_pwzSamName)
  {
    delete[] m_pwzSamName;
  }
  DO_DEL(m_pObjSID);
}

//+----------------------------------------------------------------------------
//
//  Function:   CDsMultiUsrProfilePage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateMultiUsrProfilePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR,
                          PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                          const CDSSmartBasePathsInfo& /*basePathsInfo*/,
                          HPROPSHEETPAGE * phPage)
{
  TRACE_FUNCTION(CreateMultiUsrProfilePage);

  CDsMultiUsrProfilePage * pPageObj = new CDsMultiUsrProfilePage(pDsPage, pDataObj,
                                                       hNotifyObj, dwFlags);
  CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

  pPageObj->Init(pwzClass);

  return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CDsMultiUsrProfilePage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch (uMsg)
  {
  case WM_INITDIALOG:
    return InitDlg(lParam);

  case WM_NOTIFY:
    return OnNotify(wParam, lParam);

  case WM_SHOWWINDOW:
    return OnShowWindow();

  case WM_SETFOCUS:
    return OnSetFocus((HWND)wParam);

  case WM_HELP:
    return OnHelp((LPHELPINFO)lParam);

  case WM_COMMAND:
    if (m_fInInit)
    {
      return TRUE;
    }
    return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                     GET_WM_COMMAND_HWND(wParam, lParam),
                     GET_WM_COMMAND_CMD(wParam, lParam)));
  case WM_DESTROY:
    return OnDestroy();

  default:
    return(FALSE);
  }

  return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsMultiUsrProfilePage::OnInitDialog(LPARAM)
{
  TRACE(CDsMultiUsrProfilePage,OnInitDialog);
  CWaitCursor wait;

  TCHAR szTitle[MAX_PATH];
  if (!LoadStringReport(m_nPageTitle, szTitle, MAX_PATH, NULL))
  {
      return HRESULT_FROM_WIN32(GetLastError());
  }

  if (!ADsPropSetHwndWithTitle(m_hNotifyObj, m_hPage, szTitle))
  {
    m_pWritableAttrs = NULL;
  }

  m_fProfilePathWritable  = TRUE;
  m_fScriptPathWritable   = TRUE;
  m_fHomeDirWritable      = TRUE;
  m_fHomeDriveWritable    = TRUE;

  //
  // Set edit control length limits.
  //
  SendDlgItemMessage(m_hPage, IDC_PROFILE_PATH_EDIT, EM_LIMITTEXT,
                     MAX_PATH+MAX_PATH, 0);
  SendDlgItemMessage(m_hPage, IDC_LOGON_SCRIPT_EDIT, EM_LIMITTEXT,
                     MAX_PATH+MAX_PATH, 0);
  SendDlgItemMessage(m_hPage, IDC_LOCAL_PATH_EDIT, EM_LIMITTEXT,
                     MAX_PATH+MAX_PATH, 0);
  SendDlgItemMessage(m_hPage, IDC_CONNECT_TO_PATH_EDIT, EM_LIMITTEXT,
                     MAX_PATH+MAX_PATH, 0);

  //
  // Set the default radio to Local Path
  //
  SendDlgItemMessage(m_hPage, IDC_LOCAL_PATH_RADIO, BM_SETCHECK, BST_CHECKED, 0);

  //
  // Fill the home drive combobox.
  //
  TCHAR szDrive[3];
  _tcscpy(szDrive, TEXT("C:"));
  for (int i = 0; i <= COMBO_Z_DRIVE; i++)
  {
    szDrive[0]++;
    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_ADDSTRING, 0,
                       (LPARAM)szDrive);
  }

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUsrProfilePage::OnApply(void)
{
  TRACE(CDsMultiUsrProfilePage,OnApply);
  HRESULT hr = S_OK;
  BOOL bErrorOccurred = FALSE;
  UINT idx = 0;
  UINT i = 0;
  PADS_ATTR_INFO pAttrs = NULL;
  ULONG nCount = 0;
  LPWSTR rgpwzAttrNames[] = {g_wzObjectSID, wzSAMname};
  PWSTR pszTitle = NULL;

  LRESULT lApplyProfile = SendDlgItemMessage(m_hPage, IDC_APPLY_PROFILE_CHK, BM_GETCHECK, 0, 0);
  LRESULT lApplyScript  = SendDlgItemMessage(m_hPage, IDC_APPLY_SCRIPT_CHK, BM_GETCHECK, 0, 0);
  LRESULT lApplyHomeDir = SendDlgItemMessage(m_hPage, IDC_APPLY_HOMEDIR_CHK, BM_GETCHECK, 0, 0);

  if (lApplyProfile != BST_CHECKED &&
      lApplyScript  != BST_CHECKED &&
      lApplyHomeDir != BST_CHECKED)
  {
    //
    // Nothing is marked for apply
    //
    return PSNRET_NOERROR;
  }

  //
  // For the retrieval of the DS Object names
  //
  FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
  STGMEDIUM objMedium;
  LPDSOBJECTNAMES pDsObjectNames;

  //
  // Retrieve the DS object names
  //
  //
  // Get the path to the DS object from the data object.
  // Note: This call runs on the caller's main thread. The pages' window
  // procs run on a different thread, so don't reference the data object
  // from a winproc unless it is first marshalled on this thread.
  //

  if (m_pWPTDataObj == NULL)
  {
    return PSNRET_INVALID_NOCHANGEPAGE;
  }

  hr = m_pWPTDataObj->GetData(&fmte, &objMedium);
  CHECK_HRESULT(hr, return PSNRET_INVALID_NOCHANGEPAGE);

  pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

  if (pDsObjectNames->cItems < 2)
  {
      DBG_OUT("Not enough objects in DSOBJECTNAMES structure");
      ReleaseStgMedium(&objMedium);
      return PSNRET_INVALID_NOCHANGEPAGE;
  }

  //
  // Prepare the error structure
  //
  LoadStringToTchar(m_nPageTitle, &pszTitle);
  ADSPROPERROR adsPropError = {0};
  adsPropError.hwndPage = m_hPage;
  adsPropError.pszPageTitle = pszTitle;

  ADSVALUE ADsValueProfilePath = {ADSTYPE_CASE_IGNORE_STRING, NULL};
  ADS_ATTR_INFO AttrInfoProfilePath = {wzProfilePath, ADS_ATTR_UPDATE,
                                       ADSTYPE_CASE_IGNORE_STRING,
                                       &ADsValueProfilePath, 1};
  ADSVALUE ADsValueScriptPath = {ADSTYPE_CASE_IGNORE_STRING, NULL};
  ADS_ATTR_INFO AttrInfoScriptPath = {wzScriptPath, ADS_ATTR_UPDATE,
                                      ADSTYPE_CASE_IGNORE_STRING,
                                      &ADsValueScriptPath, 1};
  ADSVALUE ADsValueHomeDir = {ADSTYPE_CASE_IGNORE_STRING, NULL};
  ADS_ATTR_INFO AttrInfoHomeDir = {wzHomeDir, ADS_ATTR_UPDATE,
                                   ADSTYPE_CASE_IGNORE_STRING,
                                   &ADsValueHomeDir};
  ADSVALUE ADsValueHomeDrive = {ADSTYPE_CASE_IGNORE_STRING, NULL};
  ADS_ATTR_INFO AttrInfoHomeDrive = {wzHomeDrive, ADS_ATTR_UPDATE,
                                     ADSTYPE_CASE_IGNORE_STRING,
                                     &ADsValueHomeDrive};
  // Array of attributes to write
  ADS_ATTR_INFO rgAttrs[4];
  DWORD cAttrs = 0, cDynamicAttrs = 0;
  TCHAR tsz[MAX_PATH+MAX_PATH+1];
  PTSTR ptsz;
  PWSTR pwzValue;
  BOOL bDirExist = FALSE;
  BOOL bDirIsRootShare = FALSE;
  BOOL bCreateDirFailed = FALSE;
  BOOL fExpanded = FALSE;

  //
  // Logon Script
  //
  if (lApplyScript == BST_CHECKED && m_fScriptPathWritable && m_fLogonScriptChanged)
  {
    if (GetDlgItemText(m_hPage, IDC_LOGON_SCRIPT_EDIT, tsz,
                       MAX_PATH+MAX_PATH) == 0)
    {
      // An empty control means remove the attribute value from the object.
      //
      AttrInfoScriptPath.dwControlCode = ADS_ATTR_CLEAR;
      AttrInfoScriptPath.dwNumValues = 0;
      AttrInfoScriptPath.pADsValues = NULL;
    }
    else
    {
      if (!TcharToUnicode(tsz, &pwzValue))
      {
        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
      }
      ADsValueScriptPath.CaseIgnoreString = pwzValue;
    }
    rgAttrs[cAttrs++] = AttrInfoScriptPath;
  }


  for (; idx < pDsObjectNames->cItems; idx++)
  {
    cDynamicAttrs = 0;
    hr = S_OK;
    //
    // Get the objects path
    //
    LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                             pDsObjectNames->aObjects[idx].offsetName);

    LPWSTR pwzObjClass = (PWSTR)ByteOffset(pDsObjectNames,
                                           pDsObjectNames->aObjects[idx].offsetClass);

    adsPropError.pszObjPath = pwzObjADsPath;
    adsPropError.pszObjClass = pwzObjClass;

    //
    // Bind to the object
    //
    CComPtr<IDirectoryObject> spDirObject;
    hr = DSAdminOpenObject(pwzObjADsPath, 
                           IID_IDirectoryObject, 
                           (PVOID*)&spDirObject);
    if (FAILED(hr))
    {
      DBG_OUT("Failed to bind to a multi-select object for Apply.");
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
      continue;
    }

    // We only need to get the sAMAccountName or the objectSID
    // if we are changing the profilePath or the homeDirectory

    if (lApplyProfile == BST_CHECKED ||
        lApplyHomeDir == BST_CHECKED)
    {

      //
      // Get the object SID
      //
      hr = spDirObject->GetObjectAttributes(rgpwzAttrNames,
                                            ARRAYLENGTH(rgpwzAttrNames),
                                            &pAttrs, &nCount);

      if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
      {
        adsPropError.hr = hr;
        SendErrorMessage(&adsPropError);
        bErrorOccurred = TRUE;
        continue;
      }

      //
      // Retrieve the current values
      //
      for (i = 0; i < nCount; i++)
      {
        if (_wcsicmp(pAttrs[i].pszAttrName, g_wzObjectSID) == 0)
        {
          if (IsValidSid(pAttrs[i].pADsValues->OctetString.lpValue))
          {
            if (m_pObjSID != NULL)
            {
              delete[] m_pObjSID;
            }

            m_pObjSID = new BYTE[pAttrs[i].pADsValues->OctetString.dwLength];
            if (m_pObjSID == NULL)
            {
              adsPropError.hr = E_OUTOFMEMORY;
              SendErrorMessage(&adsPropError);
              bErrorOccurred = TRUE;
              continue;
            }

            memcpy(m_pObjSID, pAttrs[i].pADsValues->OctetString.lpValue,
                   pAttrs[i].pADsValues->OctetString.dwLength);
          }
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzSAMname) == 0)
        {
          if (m_pwzSamName != NULL)
          {
            delete[] m_pwzSamName;
            m_pwzSamName = NULL;
          }

          if (!AllocWStr(pAttrs[i].pADsValues->CaseIgnoreString, &m_pwzSamName))
          {
            adsPropError.hr = E_OUTOFMEMORY;
            SendErrorMessage(&adsPropError);
            bErrorOccurred = TRUE;
          }
          continue;
        }
      }
    }

    //
    // Profile Path
    //
    if (lApplyProfile == BST_CHECKED && m_fProfilePathWritable && m_fProfilePathChanged)
    {
      if (GetDlgItemText(m_hPage, IDC_PROFILE_PATH_EDIT, tsz,
                         MAX_PATH+MAX_PATH) == 0)
      {
        //
        // An empty control means remove the attribute value from the object.
        //
        AttrInfoProfilePath.dwControlCode = ADS_ATTR_CLEAR;
        AttrInfoProfilePath.dwNumValues = 0;
        AttrInfoProfilePath.pADsValues = NULL;
      }
      else
      {
        if (!TcharToUnicode(tsz, &pwzValue))
        {
          adsPropError.hr = E_OUTOFMEMORY;
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE;
          continue;
        }

        if (!ExpandUsername(pwzValue, fExpanded, &adsPropError))
        {
          continue;
        }
        if (fExpanded)
        {
          if (!UnicodeToTchar(pwzValue, &ptsz))
          {
            adsPropError.hr = E_OUTOFMEMORY;
            SendErrorMessage(&adsPropError);
            bErrorOccurred = TRUE;
            continue;
          }
          delete [] ptsz;
        }
        ADsValueProfilePath.CaseIgnoreString = pwzValue;
      }
      rgAttrs[cAttrs + cDynamicAttrs] = AttrInfoProfilePath;
      cDynamicAttrs++;
    }

    //
    // Home Directory, Drive.
    //
    int nDirCtrl;
    if (lApplyHomeDir == BST_CHECKED && m_fHomeDirWritable && m_fHomeDriveWritable &&
        (m_fHomeDirChanged || m_fHomeDriveChanged))
    {
      LONG iSel;
      if (IsDlgButtonChecked(m_hPage, IDC_LOCAL_PATH_RADIO) == BST_CHECKED)
      {
        nDirCtrl = IDC_LOCAL_PATH_EDIT;

        AttrInfoHomeDrive.dwControlCode = ADS_ATTR_CLEAR;
        AttrInfoHomeDrive.dwNumValues = 0;
        AttrInfoHomeDrive.pADsValues = NULL;
        rgAttrs[cAttrs + cDynamicAttrs] = AttrInfoHomeDrive;
        cDynamicAttrs++;
      }
      else
      {
        nDirCtrl = IDC_CONNECT_TO_PATH_EDIT;

        iSel = (int)SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_GETCURSEL, 0, 0);

        dspAssert(iSel >= 0);

        if (iSel >= 0)
        {
          GetDlgItemText(m_hPage, IDC_DRIVES_COMBO, tsz, MAX_PATH+MAX_PATH);
        }
        else
        {
          _tcscpy(tsz, TEXT("Z:"));
        }

        if (!TcharToUnicode(tsz, &pwzValue))
        {
          if (pwzValue == NULL)
          {
            adsPropError.hr = E_OUTOFMEMORY;
            SendErrorMessage(&adsPropError);
            bErrorOccurred = TRUE;
            continue;
          }
        }

        AttrInfoHomeDrive.dwControlCode = ADS_ATTR_UPDATE;
        AttrInfoHomeDrive.dwNumValues = 1;
        AttrInfoHomeDrive.pADsValues = &ADsValueHomeDrive;
        ADsValueHomeDrive.CaseIgnoreString = pwzValue;
        rgAttrs[cAttrs + cDynamicAttrs] = AttrInfoHomeDrive;
        cDynamicAttrs++;
      }

      int cch;
      cch = GetDlgItemText(m_hPage, nDirCtrl, tsz, MAX_PATH+MAX_PATH);

      if (!FIsValidUncPath(tsz, (nDirCtrl == IDC_LOCAL_PATH_EDIT) ? VUP_mskfAllowEmptyPath : VUP_mskfAllowUNCPath))
      {
        PTSTR ptzError = NULL;
        UINT nStringID = (nDirCtrl == IDC_LOCAL_PATH_EDIT) ? IDS_ERRMSG_INVALID_PATH : IDS_ERRMSG_INVALID_UNC_PATH;
        if (LoadStringToTchar(nStringID, &ptzError))
        {
          adsPropError.hr = 0;
          adsPropError.pszError = ptzError;
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE;
          delete ptzError;
          continue;
        }
      }

      if (cch == 0)
      {
        // An empty control means remove the attribute value from the object.
        //
        AttrInfoHomeDir.dwControlCode = ADS_ATTR_CLEAR;
        AttrInfoHomeDir.dwNumValues = 0;
        AttrInfoHomeDir.pADsValues = NULL;
      }
      else
      {
        if (!TcharToUnicode(tsz, &pwzValue))
        {
          adsPropError.hr = E_OUTOFMEMORY;
          SendErrorMessage(&adsPropError);
          bErrorOccurred = TRUE;
          continue;
        }

        if (!ExpandUsername(pwzValue, fExpanded, &adsPropError))
        {
          bErrorOccurred = TRUE;
          continue;
        }
        if (fExpanded)
        {
          if (!UnicodeToTchar(pwzValue, &ptsz))
          {
            adsPropError.hr = E_OUTOFMEMORY;
            SendErrorMessage(&adsPropError);
            bErrorOccurred = TRUE;
            continue;
          }
          if (nDirCtrl == IDC_LOCAL_PATH_EDIT)
          {
            if (m_ptszLocalHomeDir)
            {
              delete [] m_ptszLocalHomeDir;
            }
            m_ptszLocalHomeDir = new TCHAR[_tcslen(ptsz) + 1];
            if (m_ptszLocalHomeDir == NULL)
            {
              adsPropError.hr = E_OUTOFMEMORY;
              SendErrorMessage(&adsPropError);
              bErrorOccurred = TRUE;
              delete[] ptsz;
              continue;
            }
            _tcscpy(m_ptszLocalHomeDir, ptsz);
          }
          else
          {
            if (m_ptszRemoteHomeDir)
            {
              delete [] m_ptszRemoteHomeDir;
            }
            m_ptszRemoteHomeDir = new TCHAR[_tcslen(ptsz) + 1];
            if (m_ptszRemoteHomeDir == NULL)
            {
              adsPropError.hr = E_OUTOFMEMORY;
              SendErrorMessage(&adsPropError);
              bErrorOccurred = TRUE;
              delete[] ptsz;
              continue;
            }
            _tcscpy(m_ptszRemoteHomeDir, ptsz);
          }
          delete [] ptsz;
        }

        AttrInfoHomeDir.dwControlCode = ADS_ATTR_UPDATE;
        AttrInfoHomeDir.dwNumValues = 1;
        AttrInfoHomeDir.pADsValues = &ADsValueHomeDir;
        ADsValueHomeDir.CaseIgnoreString = pwzValue;
      }
      rgAttrs[cAttrs + cDynamicAttrs] = AttrInfoHomeDir;
      cDynamicAttrs++;

      if (nDirCtrl == IDC_CONNECT_TO_PATH_EDIT)
      {
        dspAssert(m_pObjSID != NULL);

        //
        // attempt to create the directory.
        //  
        DWORD dwErr = ERROR_SUCCESS;             
        if(!fExpanded)        
        {   
            //If directory doesn't exist try to create it
            if(!bDirExist)
            {
                dwErr = DSPROP_CreateHomeDirectory(m_pObjSID, ADsValueHomeDir.CaseIgnoreString);
                if(dwErr != ERROR_SUCCESS)
                {
                    PWSTR* ppwzHomeDirName = &(ADsValueHomeDir.CaseIgnoreString);
                    switch(dwErr)
                    {
                        case ERROR_ALREADY_EXISTS:
                        {
                           bDirExist = TRUE;


                           if (PathIsUNCServerShare(ADsValueHomeDir.CaseIgnoreString))
                           {
                              // We cannot modify the ACL at the root of a share or else
                              // all inheritance will be lost. Instead, give the admin
                              // a warning that they must set the permissions manually

                              SuperMsgBox(GetHWnd(),
                                          IDS_HOME_DIR_IS_ROOT_MULTI, 
                                          0, 
                                          MB_OK | MB_ICONEXCLAMATION,
                                          hr, 
                                          (PVOID *)ppwzHomeDirName, 
                                          1,
                                          FALSE, 
                                          __FILE__, 
                                          __LINE__);
                              dwErr = ERROR_SUCCESS;

                              bDirIsRootShare = TRUE;
                           }
                           else
                           {
                              // Report a warning but continue
                              //
                              SuperMsgBox(GetHWnd(),
                                          IDS_ALL_USERS_GIVEN_FULL_CONTROL, 
                                          0, 
                                          MB_OK | MB_ICONEXCLAMATION,
                                          hr, 
                                          (PVOID *)ppwzHomeDirName, 
                                          1,
                                          FALSE, 
                                          __FILE__, 
                                          __LINE__);
                              dwErr = ERROR_SUCCESS;
                              dwErr = AddFullControlForUser(m_pObjSID, ADsValueHomeDir.CaseIgnoreString);
                           }
                        }
                        break;

                        case ERROR_PATH_NOT_FOUND:
                        case ERROR_BAD_NETPATH:
                        case ERROR_LOGON_FAILURE:
                        case ERROR_NOT_AUTHENTICATED:
                        case ERROR_INVALID_PASSWORD:
                        case ERROR_PASSWORD_EXPIRED:
                        case ERROR_ACCOUNT_DISABLED:
                        case ERROR_ACCOUNT_LOCKED_OUT:
                        case ERROR_ACCESS_DENIED:
                        {
                           // Report a warning but continue
                           //
                           SuperMsgBox(GetHWnd(),
                                       IDS_CREATE_DIR_MULTI_FAILED_ACCESS_DENIED_BUT_CONTINUE, 
                                       0, 
                                       MB_OK | MB_ICONEXCLAMATION,
                                       0, 
                                       (PVOID *)ppwzHomeDirName, 
                                       1,
                                       FALSE, 
                                       __FILE__, 
                                       __LINE__);
                           dwErr = ERROR_SUCCESS;

                           // This is really used to fake it out so that we don't show
                           // the message above multiple times

                           bDirExist = TRUE;

                           // Remember that the create failed for some other
                           // reason than the directory already exists

                           bCreateDirFailed = TRUE;
                        }
                        break;

                        default:
                        {
                           // Report a warning but continue
                           //
                           SuperMsgBox(GetHWnd(),
                                       IDS_CREATE_DIR_MULTI_FAILED_BUT_CONTINUE, 
                                       0, 
                                       MB_OK | MB_ICONEXCLAMATION,
                                       dwErr, 
                                       (PVOID *)ppwzHomeDirName, 
                                       1,
                                       FALSE, 
                                       __FILE__, 
                                       __LINE__);
                           dwErr = ERROR_SUCCESS;

                           // This is really used to fake it out so that we don't show
                           // the message above multiple times

                           bDirExist = TRUE;

                           // Remember that the create failed for some other
                           // reason than the directory already exists

                           bCreateDirFailed = TRUE;
                        }
                        break;
                    }
                }
                else
                {
                    bDirExist = TRUE;

                    CComBSTR sbstrName;
                    CComPtr<IADsPathname> spPathCracker;
                    hr = GetADsPathname(spPathCracker);
                    if (SUCCEEDED(hr))
                    {
                      hr = spPathCracker->Set(CComBSTR(pwzObjADsPath), ADS_SETTYPE_FULL);
                      if (SUCCEEDED(hr))
                      {
                        hr = spPathCracker->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
                        if (SUCCEEDED(hr))
                        {
                          hr = spPathCracker->Retrieve(ADS_FORMAT_LEAF, &sbstrName);
                        }
                      }
                    }

                    if (sbstrName.Length() == 0)
                    {
                      sbstrName = pwzObjADsPath;
                    }

                    // Report a warning but continue
                    //
                    PVOID pvArgs[2] = {(PVOID)(ADsValueHomeDir.CaseIgnoreString),
                                        (PVOID)(PWSTR)sbstrName};

                    SuperMsgBox(GetHWnd(),
                                IDS_FIRST_USER_OWNER_ALL_FULL_CONTROL, 
                                0, 
                                MB_OK | MB_ICONEXCLAMATION,
                                hr, 
                                pvArgs,
                                2,
                                FALSE, 
                                __FILE__, 
                                __LINE__);
    
                }

            }
            else
            {
               if (!bDirIsRootShare &&
                   !bCreateDirFailed)
               {
                  dwErr = AddFullControlForUser(m_pObjSID, ADsValueHomeDir.CaseIgnoreString);
               }
            }

            if (dwErr != ERROR_SUCCESS)
            {
               PTSTR ptzMsg = NULL;
               LoadErrorMessage(dwErr, IDS_ERR_CREATE_DIR, &ptzMsg);

               adsPropError.hr = 0;

               if (NULL == ptzMsg)
               {
                  TCHAR tzBuf[80];
                  //NTRAID#NTBUG9-572004-2002/03/10-jmessec   Unlocalized text; after fixing, buffer size must be calculated

                  // This is not a localization bug because this is only used if we fail to load
                  // the localized string from the resource.

                  wsprintf(tzBuf, TEXT("Active Directory failure with code '0x%08x'!"), hr);
                  adsPropError.pszError = tzBuf;
                  SendErrorMessage(&adsPropError);
               }
               else
               {
                  adsPropError.pszError = ptzMsg;

                  // Make sure to send the error message before
                  // deleting the string so that the text can
                  // be copied

                  SendErrorMessage(&adsPropError);
                  delete ptzMsg;
               }

               bErrorOccurred = TRUE;
            }
        }                        
        else
        {
           dwErr = DSPROP_CreateHomeDirectory(m_pObjSID, ADsValueHomeDir.CaseIgnoreString);

           if(dwErr != ERROR_SUCCESS)
           {
             switch(dwErr)
             {
               case ERROR_PATH_NOT_FOUND:
               case ERROR_BAD_NETPATH:
               case ERROR_ALREADY_EXISTS:
               case ERROR_LOGON_FAILURE:
               case ERROR_NOT_AUTHENTICATED:
               case ERROR_INVALID_PASSWORD:
               case ERROR_PASSWORD_EXPIRED:
               case ERROR_ACCOUNT_DISABLED:
               case ERROR_ACCOUNT_LOCKED_OUT:
               {
                  UINT nStringID = (ERROR_PATH_NOT_FOUND == dwErr) ? IDS_HOME_DIR_CREATE_FAILED :
                                                   IDS_HOME_DIR_CREATE_NO_ACCESS;
                  PTSTR ptzError = NULL;
                  if (LoadStringToTchar(nStringID, &ptzError))
                  {
                        adsPropError.hr = 0;
                        adsPropError.pszError = ptzError;
                        SendErrorMessage(&adsPropError);
                        bErrorOccurred = TRUE;
                        delete ptzError;
                  }
               }
               break;

               default:
               {
                  PTSTR ptzMsg = NULL;
                  LoadErrorMessage(dwErr, IDS_ERR_CREATE_DIR, &ptzMsg);

                  adsPropError.hr = 0;
                  
                  if (NULL == ptzMsg)
                  {
                    TCHAR tzBuf[80];
					  //NTRAID#NTBUG9-572004-2002/03/10-jmessec   Unlocalized text; after fixing, buffer size must be calculated

                    // This is not a localization bug because this string is only used if we failed
                    // to load the localized string from the resource.

                    wsprintf(tzBuf, TEXT("Active Directory failure with code '0x%08x'!"), hr);
                    adsPropError.pszError = tzBuf;
                    SendErrorMessage(&adsPropError);
                  }
                  else
                  {
                     adsPropError.hr = 0;
                     adsPropError.pszError = ptzMsg;

                     // Be sure to send the error message before deleting the string
                     // so that it can be copied.

                     SendErrorMessage(&adsPropError);
                     delete ptzMsg;
                  }
                  bErrorOccurred = TRUE;
               }
            }
          }
        }
      }
    }

    //
    // Write the changes.
    //
    DWORD cModified;

    hr = spDirObject->SetObjectAttributes(rgAttrs, cAttrs + cDynamicAttrs, &cModified);
    
    if (FAILED(hr))
    {
      adsPropError.hr = hr;
      SendErrorMessage(&adsPropError);
      bErrorOccurred = TRUE;
    }

    //
    // Cleanup allocated values
    //
    if (ADsValueProfilePath.CaseIgnoreString)
    {
      delete ADsValueProfilePath.CaseIgnoreString;
      ADsValueProfilePath.CaseIgnoreString = NULL;
    }
    if (ADsValueHomeDir.CaseIgnoreString)
    {
      delete ADsValueHomeDir.CaseIgnoreString;
      ADsValueHomeDir.CaseIgnoreString = NULL;
    }
    if (ADsValueHomeDrive.CaseIgnoreString)
    {
      delete ADsValueHomeDrive.CaseIgnoreString;
      ADsValueHomeDrive.CaseIgnoreString = NULL;
    }
  }

  //Clean Up this after the for loop
  if (ADsValueScriptPath.CaseIgnoreString)
  {
    delete ADsValueScriptPath.CaseIgnoreString;
    ADsValueScriptPath.CaseIgnoreString = NULL;
  }

  if (!bErrorOccurred)
  {
    m_fProfilePathChanged = FALSE;
    m_fLogonScriptChanged = FALSE;
    m_fHomeDirChanged = FALSE;
    m_fHomeDriveChanged = FALSE;
    m_fSharedDirChanged = FALSE;

    //
    // Uncheck the Apply checkboxes
    //
    SendDlgItemMessage(m_hPage, IDC_APPLY_PROFILE_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_PROFILE_PATH_EDIT), FALSE);
    SendDlgItemMessage(m_hPage, IDC_APPLY_SCRIPT_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_SCRIPT_EDIT), FALSE);
    SendDlgItemMessage(m_hPage, IDC_APPLY_HOMEDIR_CHK, BM_SETCHECK, BST_UNCHECKED, 0);
    EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_RADIO), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_RADIO), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), FALSE);
    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), FALSE);
  }

Cleanup:

  if (ADsValueProfilePath.CaseIgnoreString)
  {
    delete ADsValueProfilePath.CaseIgnoreString;
  }
  if (ADsValueScriptPath.CaseIgnoreString)
  {
    delete ADsValueScriptPath.CaseIgnoreString;
  }
  if (ADsValueHomeDir.CaseIgnoreString)
  {
    delete ADsValueHomeDir.CaseIgnoreString;
  }
  if (ADsValueHomeDrive.CaseIgnoreString)
  {
    delete ADsValueHomeDrive.CaseIgnoreString;
  }

  if (bErrorOccurred)
  {
    ADsPropShowErrorDialog(m_hNotifyObj, m_hPage);
  }

  ReleaseStgMedium(&objMedium);

  return (bErrorOccurred) ? PSNRET_INVALID_NOCHANGEPAGE : PSNRET_NOERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::ExpandUsername
//
//  Synopsis:   If the %username% token is found in the string, substitute
//              the SAM account name.
//
//-----------------------------------------------------------------------------
BOOL CDsMultiUsrProfilePage::ExpandUsername(PWSTR & pwzValue, BOOL & fExpanded, PADSPROPERROR pError)
{
  dspAssert(pwzValue);

  CStrW strUserToken;

  strUserToken.LoadString(g_hInstance, IDS_PROFILE_USER_TOKEN);

  unsigned int TokenLength = strUserToken.GetLength();

  if (!TokenLength)
  {
    if (pError == NULL)
    {
      CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
    }
    else
    {
      pError->hr = E_OUTOFMEMORY;
      SendErrorMessage(pError);
      return FALSE;
    }
  }

  PWSTR pwzTokenStart = wcschr(pwzValue, strUserToken.GetAt(0));

  if (pwzTokenStart)
  {
    if (!m_pwzSamName)
    {
      TCHAR szMsg[MAX_ERRORMSG+1];
      PTSTR ptzFormatString = NULL;
      if (LoadStringToTchar(IDS_NO_SAMNAME_FOR_PROFILE, &ptzFormatString))
      {
		//NTRAID#NTBUG9-572005-2002/03/10-jmessec   Unverified format string which could overrun buffer
        wsprintf(szMsg, ptzFormatString, strUserToken);
        pError->hr = 0;
        pError->pszError = szMsg;
        SendErrorMessage(pError);
        return FALSE;
      }
      return FALSE;
    }
    if ((wcslen(pwzTokenStart) >= TokenLength) &&
        (_wcsnicmp(pwzTokenStart, strUserToken, TokenLength) == 0))
    {
      fExpanded = TRUE;
    }
    else
    {
      fExpanded = FALSE;
      return TRUE;
    }
  }
  else
  {
    fExpanded = FALSE;
    return TRUE;
  }

  CStrW strValue, strAfterToken;

  while (pwzTokenStart)
  {
    *pwzTokenStart = L'\0';

    strValue = pwzValue;

    if ((L'\0' != *pwzValue) && !strValue.GetLength())
    {
      pError->hr = E_OUTOFMEMORY;
      SendErrorMessage(pError);
      return FALSE;
    }

    PWSTR pwzAfterToken = pwzTokenStart + TokenLength;

    strAfterToken = pwzAfterToken;

    if ((L'\0' != *pwzAfterToken) && !strAfterToken.GetLength())
    {
      pError->hr = E_OUTOFMEMORY;
      SendErrorMessage(pError);
      return FALSE;
    }

    delete pwzValue;

    strValue += m_pwzSamName;

    if (!strValue.GetLength())
    {
      pError->hr = E_OUTOFMEMORY;
      SendErrorMessage(pError);
      return FALSE;
    }

    strValue += strAfterToken;

    if (!strValue.GetLength())
    {
      pError->hr = E_OUTOFMEMORY;
      SendErrorMessage(pError);
      return FALSE;
    }

    if (!AllocWStr((PWSTR)(LPCWSTR)strValue, &pwzValue))
    {
      pError->hr = E_OUTOFMEMORY;
      SendErrorMessage(pError);
      return FALSE;
    }

    pwzTokenStart = wcschr(pwzValue, strUserToken.GetAt(0));

    if (!(pwzTokenStart &&
          (wcslen(pwzTokenStart) >= TokenLength) &&
          (_wcsnicmp(pwzTokenStart, strUserToken, TokenLength) == 0)))
    {
      return TRUE;
    }
  }

  return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      Standard multi-valued attribute handling assumes that the
//              "modify" button has an ID that is one greater than the
//              corresponding combo box.
//
//-----------------------------------------------------------------------------
LRESULT
CDsMultiUsrProfilePage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }

    TCHAR tsz[MAX_PATH+MAX_PATH+1];
    int idNewHomeDirRadio = -1;

    switch (id)
    {
    case IDC_LOCAL_PATH_EDIT:
        if (codeNotify == EN_KILLFOCUS)
        {
            // Save any edit control changes.
            //
            if (GetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, tsz,
                               MAX_PATH+MAX_PATH) == 0)
            {
                if (m_ptszLocalHomeDir)
                {
                    delete m_ptszLocalHomeDir;
                    m_ptszLocalHomeDir = NULL;
                }
            }
            else
            {
                if (!m_ptszLocalHomeDir || _tcscmp(tsz, m_ptszLocalHomeDir))
                {
                    if (m_ptszLocalHomeDir)
                    {
                        delete m_ptszLocalHomeDir;
                    }

                    m_ptszLocalHomeDir = new TCHAR[_tcslen(tsz) + 1];

                    if (!m_ptszLocalHomeDir)
                    {
                        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
                    }

                    _tcscpy(m_ptszLocalHomeDir, tsz);
                }
            }
            break;
        }
        // fall through
    case IDC_CONNECT_TO_PATH_EDIT:
    case IDC_DRIVES_COMBO:
        if ((codeNotify == EN_KILLFOCUS) || (codeNotify == CBN_KILLFOCUS))
        {
            // Save any edit control changes.
            //
            if (GetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, tsz,
                               MAX_PATH+MAX_PATH) == 0)
            {
                if (m_ptszRemoteHomeDir)
                {
                    delete m_ptszRemoteHomeDir;
                    m_ptszRemoteHomeDir = NULL;
                }
            }
            else
            {
                if (!m_ptszRemoteHomeDir || _tcscmp(tsz, m_ptszRemoteHomeDir))
                {
                    if (m_ptszRemoteHomeDir)
                    {
                        delete m_ptszRemoteHomeDir;
                    }

                    m_ptszRemoteHomeDir = new TCHAR[_tcslen(tsz) + 1];

                    if (!m_ptszRemoteHomeDir)
                    {
                        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
                    }

                    _tcscpy(m_ptszRemoteHomeDir, tsz);
                }
            }
            break;
        }

        if ((codeNotify == EN_SETFOCUS) || (codeNotify == CBN_SETFOCUS))
        {
            // Toggle the radio buttons if needed.
            //
            if (id == IDC_LOCAL_PATH_EDIT)
            {
                if (IsDlgButtonChecked(m_hPage, IDC_CONNECT_TO_RADIO) == BST_CHECKED)
                {
                    idNewHomeDirRadio = IDC_LOCAL_PATH_RADIO;

                    CheckDlgButton(m_hPage, IDC_LOCAL_PATH_RADIO, BST_CHECKED);

                    CheckDlgButton(m_hPage, IDC_CONNECT_TO_RADIO, BST_UNCHECKED);
                }
            }
            else
            {
                if (IsDlgButtonChecked(m_hPage, IDC_LOCAL_PATH_RADIO) == BST_CHECKED)
                {
                    idNewHomeDirRadio = IDC_CONNECT_TO_RADIO;

                    CheckDlgButton(m_hPage, IDC_CONNECT_TO_RADIO, BST_CHECKED);

                    CheckDlgButton(m_hPage, IDC_LOCAL_PATH_RADIO, BST_UNCHECKED);
                }
            }
            //
            // Restore the incoming edit control and clear the other if needed.
            // Also set or clear the drives combo as appropiate.
            //
            if (id == IDC_LOCAL_PATH_EDIT)
            {
                if (idNewHomeDirRadio == IDC_LOCAL_PATH_RADIO)
                {
                    if (m_ptszLocalHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT,
                                       m_ptszLocalHomeDir);
                    }
                    SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, TEXT(""));
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)-1, 0);
                }
            }
            else
            {
                if (idNewHomeDirRadio == IDC_CONNECT_TO_RADIO)
                {
                    SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, TEXT(""));
                    if (m_ptszRemoteHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT,
                                       m_ptszRemoteHomeDir);
                    }
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)m_nDrive, 0);
                }
            }
            if (idNewHomeDirRadio != -1)
            {
                m_idHomeDirRadio = idNewHomeDirRadio;
            }
            break;
        }

        if (id == IDC_DRIVES_COMBO && codeNotify == CBN_SELCHANGE)
        {
            m_nDrive = (int)SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO,
                                               CB_GETCURSEL, 0, 0);
            SetDirty();
            m_fHomeDriveChanged = TRUE;
            break;
        }
        if ((id == IDC_LOCAL_PATH_EDIT || IDC_CONNECT_TO_PATH_EDIT == id)
            && codeNotify == EN_CHANGE)
        {
            SetDirty();
            m_fHomeDirChanged = TRUE;
        }
        break;

    case IDC_PROFILE_PATH_EDIT:
        if (codeNotify == EN_CHANGE)
        {
            SetDirty();
            m_fProfilePathChanged = TRUE;
        }
        break;

    case IDC_LOGON_SCRIPT_EDIT:
        if (codeNotify == EN_CHANGE)
        {
            SetDirty();
            m_fLogonScriptChanged = TRUE;
        }
        break;

    case IDC_LOCAL_PATH_RADIO:
    case IDC_CONNECT_TO_RADIO:
        if (codeNotify == BN_CLICKED)
        {
            if (id == IDC_LOCAL_PATH_RADIO)
            {
                if (m_idHomeDirRadio != IDC_LOCAL_PATH_RADIO)
                {
                    if (m_ptszLocalHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT,
                                       m_ptszLocalHomeDir);
                    }
                    SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, TEXT(""));
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)-1, 0);

                    //
                    // Enable the associated controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), TRUE);

                    //
                    // Disable to connect to controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), FALSE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), FALSE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), FALSE);
                }
            }
            else
            {
                if (m_idHomeDirRadio != IDC_CONNECT_TO_RADIO)
                {
                    SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, TEXT(""));
                    if (m_ptszRemoteHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT,
                                       m_ptszRemoteHomeDir);
                    }
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)m_nDrive, 0);

                    //
                    // Enable the associated controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), TRUE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), TRUE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), TRUE);

                    //
                    // Disable to connect to controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), FALSE);
                }
            }
            if (m_idHomeDirRadio != id)
            {
                m_idHomeDirRadio = id;
                SetDirty();
                m_fHomeDriveChanged = TRUE;
                m_fHomeDirChanged = TRUE;
            }
        }
        return 1;
    case IDC_APPLY_PROFILE_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyProfile = SendDlgItemMessage(m_hPage, IDC_APPLY_PROFILE_CHK, BM_GETCHECK, 0, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_PROFILE_PATH_EDIT), lApplyProfile == BST_CHECKED);
        if (lApplyProfile == BST_UNCHECKED)
        {
          SetDlgItemText(m_hPage, IDC_PROFILE_PATH_EDIT, L"");
        }
        else
        {
          //This is to allow NULL value for Profile.
          m_fProfilePathChanged = TRUE;
        }
        SetDirty();
      }
      break;

    case IDC_APPLY_SCRIPT_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyScript = SendDlgItemMessage(m_hPage, IDC_APPLY_SCRIPT_CHK, BM_GETCHECK, 0, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_SCRIPT_EDIT), lApplyScript == BST_CHECKED);
        if (lApplyScript == BST_UNCHECKED)
        {
          SetDlgItemText(m_hPage, IDC_LOGON_SCRIPT_EDIT, L"");
        }
        else
        {
            m_fLogonScriptChanged = TRUE;
        }
        SetDirty();
      }
      break;
        
    case IDC_APPLY_HOMEDIR_CHK:
      if (codeNotify == BN_CLICKED)
      {
        LRESULT lApplyHomeDir = SendDlgItemMessage(m_hPage, IDC_APPLY_HOMEDIR_CHK, BM_GETCHECK, 0, 0);
        LRESULT lLocalPathChk = SendDlgItemMessage(m_hPage, IDC_LOCAL_PATH_RADIO, BM_GETCHECK, 0, 0);

        EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_RADIO), lApplyHomeDir == BST_CHECKED);
        EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_RADIO), lApplyHomeDir == BST_CHECKED);

        EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), lApplyHomeDir == BST_CHECKED && lLocalPathChk == BST_CHECKED);
        EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), lApplyHomeDir == BST_CHECKED && lLocalPathChk != BST_CHECKED);
        EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), lApplyHomeDir == BST_CHECKED && lLocalPathChk != BST_CHECKED);
        EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), lApplyHomeDir == BST_CHECKED && lLocalPathChk != BST_CHECKED);
        if (lApplyHomeDir == BST_UNCHECKED)
        {
          SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, L"");
          SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, L"");
        }
        else
        {
            m_fHomeDirChanged = TRUE;
        }
        SetDirty();
      }
      break;

    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::Init
//
//  Synopsis:   Initialize the page object. This is the second part of a two
//              phase creation where operations that could fail are located.
//              Failures here are recorded in m_hrInit and then an error page
//              is substituted in CreatePage.
//
//-----------------------------------------------------------------------------
void CDsMultiUsrProfilePage::Init(PWSTR pwzClass)
{
  TRACE(CDsMultiUsrProfilePage,Init);
  CWaitCursor cWait;

  if (!AllocWStr(pwzClass, &m_pwszObjClass))
  {
    m_hrInit = E_OUTOFMEMORY;
    return;
  }

  //
  // Allocate memory for the attribute data.
  //
  m_rgAttrData = new ATTR_DATA[m_cAttrs];
  CHECK_NULL(m_rgAttrData, m_hrInit = E_OUTOFMEMORY; return);

  memset(m_rgAttrData, 0, m_cAttrs * sizeof(ATTR_DATA));

  //
  // Marshall the data object pointer for passing to the window proc thread.
  //
  HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, m_pDataObj,
                                             &m_pDataObjStrm);
//  m_pDataObj = NULL; // to make sure no one calls here
  CHECK_HRESULT(hr, m_hrInit = hr; return);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::OnNotify
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUsrProfilePage::OnNotify(WPARAM wParam, LPARAM lParam)
{
  return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsMultiUsrProfilePage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT CDsMultiUsrProfilePage::OnDestroy(void)
{
  if (m_ptszLocalHomeDir)
  {
    delete m_ptszLocalHomeDir;
    m_ptszLocalHomeDir = NULL;
  }
  if (m_ptszRemoteHomeDir)
  {
    delete m_ptszRemoteHomeDir;
    m_ptszRemoteHomeDir = NULL;
  }
  CDsPropPageBase::OnDestroy();
  // If an application processes this message, it should return zero.
  return 0;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\routing.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       routing.h
//
//  Contents:   AD cross-forest trust name editing pages.
//
//  Classes:    CDsForestNameRoutingPage, CEditTLNDialog, CExcludeTLNDialog
//
//  History:    29-Nov-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef ROUTING_H_GUARD
#define ROUTING_H_GUARD

#include "dlgbase.h"
#include "ftinfo.h"
#include "listview.h"

//+----------------------------------------------------------------------------
//
//  Class:      CDsForestNameRoutingPage
//
//  Purpose:    Property page object class for the forest trust name routing page.
//
//-----------------------------------------------------------------------------
class CDsForestNameRoutingPage : public CLightweightPropPageBase
{
public:
#ifdef _DEBUG
   char szClass[32];
#endif

   CDsForestNameRoutingPage(HWND hParent);
   ~CDsForestNameRoutingPage(void);

private:
   LRESULT  OnInitDialog(LPARAM lParam);
   LRESULT  OnApply(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   LRESULT  OnNotify(WPARAM wParam, LPARAM lParam);
   LRESULT  OnDestroy(void);
   static   UINT CALLBACK PageCallback(HWND hwnd, UINT uMsg,
                                       LPPROPSHEETPAGE ppsp);
   void     CheckDomainForConflict(CWaitCursor & Wait);
   void     EnableButtons(void);
   void     OnEnableClick(void);
   void     OnDisableClick(void);
   void     OnEditClick(void);

public:
   HRESULT  Init(PCWSTR pwzDomainDnsName, PCWSTR pwzTrustPartnerName,
                 PCWSTR pwzPartnerFlatName, PCWSTR pwzDcName,
                 ULONG nTrustDirection, BOOL fReadOnly, PCWSTR pwzForestName,
                 CDsTrustedDomainPage *pParentPage);
   void     CheckForNameChanges(BOOL fReport = TRUE);
   CFTInfo & GetFTInfo(void) {return _FTInfo;};
   CFTCollisionInfo & GetCollisionInfo(void) {return _CollisionInfo;};
   PCWSTR   GetTrustPartnerDnsName(void) const {return _strTrustPartnerDnsName;};
   PCWSTR   GetTrustPartnerFlatName(void) const {return _strTrustPartnerFlatName;};
   DWORD    WriteTDO(void);
   void     RefreshList(void);
   bool     AnyForestNameChanges(PLSA_FOREST_TRUST_INFORMATION pLocalFTInfo,
                                 PLSA_FOREST_TRUST_INFORMATION pRemoteFTInfo);

   //
   //  Data members
   //
private:
   CStrW             _strTrustPartnerFlatName;
   CStrW             _strForestName;
   ULONG             _nTrustDirection;
   CTLNList          _TLNList;
   CFTInfo           _FTInfo;
   CFTCollisionInfo  _CollisionInfo;
   CCreds            _LocalCreds;
   
   //Reference to parent PropertyPage
   CDsTrustedDomainPage *_pParentPage;

   // not implemented to disallow copying.
   CDsForestNameRoutingPage(const CDsForestNameRoutingPage&);
   const CDsForestNameRoutingPage& operator=(const CDsForestNameRoutingPage&);
};

class CExcludeTLNDialog;

//+----------------------------------------------------------------------------
//
//  Class:      CEditTLNDialog
//
//  Purpose:    Change the settings of names derived from TLNs.
//
//-----------------------------------------------------------------------------
class CEditTLNDialog : public CModalDialog
{
friend CExcludeTLNDialog;
public:
   CEditTLNDialog(HWND hParent, int nTemplateID, CFTInfo & FTInfo,
                  CFTCollisionInfo & ColInfo,
                  CDsForestNameRoutingPage * pRoutingPage);
   ~CEditTLNDialog(void) {};

   INT_PTR  DoModal(ULONG iSel);

private:
   LRESULT  OnInitDialog(LPARAM lParam);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   LRESULT  OnNotify(WPARAM wParam, LPARAM lParam);
   LRESULT  OnHelp(LPHELPINFO pHelpInfo);
   void     OnAddExclusion(void);
   void     OnRemoveExclusion(void);
   void     OnEnableName(void);
   void     OnDisableName(void);
   void     OnSave(void);
   void     OnOK(void);
   void     EnableExRmButton(void);
   void     EnableSuffixListButtons(void);
   CFTInfo            & _FTInfo;
   CFTCollisionInfo   & _CollisionInfo;
   ULONG                _iSel;
   bool                 _fIsDirty;
   CDsForestNameRoutingPage * _pRoutingPage;

protected:
   void     FillSuffixList(void);
   ULONG    GetTlnSelectionIndex(void) {return _iSel;};
   void     SetNewExclusionIndex(ULONG index) {_iNewExclusion = index;};
   void     SetDirty(void) {_fIsDirty = true;};

   CSuffixesList        _SuffixList;
   ULONG                _iNewExclusion;

private:
   // not implemented to disallow copying.
   CEditTLNDialog(const CEditTLNDialog&);
   const CEditTLNDialog& operator=(const CEditTLNDialog&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CExcludeTLNDialog
//
//  Purpose:    Add TLN exclusion records.
//
//-----------------------------------------------------------------------------
class CExcludeTLNDialog : public CModalDialog
{
public:
   CExcludeTLNDialog(HWND hParent, int nTemplateID, CFTInfo & FTInfo,
                     CEditTLNDialog * pEditDlg);
   ~CExcludeTLNDialog(void) {};

private:
   LRESULT OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnOK(void);
   LRESULT OnHelp(LPHELPINFO pHelpInfo);

   CEditTLNDialog  * _pEditDlg;
   CFTInfo &         _FTInfo;

   // not implemented to disallow copying.
   CExcludeTLNDialog(const CExcludeTLNDialog&);
   const CExcludeTLNDialog& operator=(const CExcludeTLNDialog&);
};

#endif // ROUTING_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\routing.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       routing.cxx
//
//  Contents:   Domain trust support, forest trust name routing property page.
//
//  History:    20-Nov-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "trust.h"
#include "trustwiz.h"
#include "routing.h"
#include <lmerr.h>

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  CDsForestNameRoutingPage: Trust Routed Names Page object
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member: CDsForestNameRoutingPage::CDsForestNameRoutingPage
//
//-----------------------------------------------------------------------------
CDsForestNameRoutingPage::CDsForestNameRoutingPage(HWND hParent) :
   _nTrustDirection(0),
   _pParentPage(0),
   CLightweightPropPageBase(hParent)
{
   TRACER(CDsForestNameRoutingPage,CDsForestNameRoutingPage);
#ifdef _DEBUG
   // NOTICE-2002/02/15-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
   strcpy(szClass, "CDsForestNameRoutingPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsForestNameRoutingPage::~CDsForestNameRoutingPage
//
//-----------------------------------------------------------------------------
CDsForestNameRoutingPage::~CDsForestNameRoutingPage()
{
   TRACER(CDsForestNameRoutingPage,~CDsForestNameRoutingPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::Init
//
//  Synopsis:   Create the page.
//
//-----------------------------------------------------------------------------
HRESULT
CDsForestNameRoutingPage::Init(PCWSTR pwzDomainDnsName,
                               PCWSTR pwzTrustPartnerName,
                               PCWSTR pwzPartnerFlatName,
                               PCWSTR pwzDcName,
                               ULONG nTrustDirection,
                               BOOL fReadOnly,
                               PCWSTR pwzForestName,
                               CDsTrustedDomainPage *pParentPage)
{
   HRESULT hr = S_OK;

   _strTrustPartnerFlatName = pwzPartnerFlatName;
   if (_strTrustPartnerFlatName.IsEmpty())
      return E_OUTOFMEMORY;

   _nTrustDirection = nTrustDirection;

   _strForestName = pwzForestName;
   if ( _strForestName.IsEmpty () )
       return E_OUTOFMEMORY;

   _pParentPage = pParentPage;
   return CLightweightPropPageBase::Init(pwzDomainDnsName, pwzTrustPartnerName,
                                         pwzDcName, IDD_FOREST_ROUTING,
                                         IDS_ROUTING_PAGE_TITLE, 
                                         PageCallback, fReadOnly);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
LRESULT
CDsForestNameRoutingPage::OnInitDialog(LPARAM)
{
   TRACER(CDsForestNameRoutingPage, OnInitDialog);

   // Set the list label, checking text length first. Use a two line label if
   // the text is too long for a single line.
   //

   FormatWindowText(GetDlgItem(_hPage, IDC_SUFFIXES_STATIC), _strTrustPartnerDnsName);

   UseOneOrTwoLine(_hPage, IDC_SUFFIXES_STATIC, IDC_SUFFIXES_STATIC_BIG);

   _TLNList.Init(_hPage, IDC_SUFFIXES_LIST);

   CheckForNameChanges();

   RefreshList();

   if (_fReadOnly)
   {
      CStrW strView;
      // NOTICE-2002/02/15-ericb - SecurityPush: CStrW::LoadString sets the
      // string to an empty string on failure.                                             
      strView.LoadString(g_hInstance, IDS_VIEW);
      SetDlgItemText(_hPage, IDC_EDIT_BTN, strView);
   }

   EnableButtons();

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::CheckForNameChanges
//
//  Synopsis:   The new info is read from the trust partner.
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::CheckForNameChanges(BOOL fReport)
{
   TRACE(CDsForestNameRoutingPage, CheckForNameChanges);

   PWSTR pwzServer = _strUncDC, pwzDomain = _strTrustPartnerDnsName;
   DWORD dwRet = NO_ERROR;
   PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
   BOOL fNewInfoRead = TRUE;
   CWaitCursor Wait;

   if (TRUST_DIRECTION_INBOUND == _nTrustDirection)
   {
      // If trust is inbound-only, query must be remoted to other domain.
      //
      dwRet = DsGetDcNameW(NULL, _strTrustPartnerDnsName, NULL, NULL,
                           DS_DS_FLAG, &pDCInfo);

      if (ERROR_SUCCESS != dwRet || !pDCInfo)
      {
         ErrMsgParam(IDS_ROUTING_ERR_NO_DC,
                     (LPARAM)_strTrustPartnerDnsName.GetBuffer(0),
                     _hPage);
         return;
      }

      pwzServer = pDCInfo->DomainControllerName;
      pwzDomain = NULL;
   }

   CPolicyHandle cPolicy(_strUncDC);

   dwRet = cPolicy.OpenWithPrompt(_LocalCreds, Wait,
                                  _strDomainDnsName, _hPage);
   if (NO_ERROR != dwRet)
   {
      SuperMsgBox(_hPage, IDS_RNSPAGE_ACCESS, IDS_DNT_MSG_TITLE, MB_OK | MB_ICONINFORMATION,
                  dwRet, NULL, 0, FALSE, __FILE__, __LINE__);
      EnableWindow(GetDlgItem(_hPage, IDC_SUFFIXES_LIST), FALSE);
      return;
   }

   // Read the FT name info from the trust partner to discover any changes.
   // If the trust partner is not available, then don't do the merge.
   //
   PLSA_FOREST_TRUST_INFORMATION pNewFTInfo = NULL;

   if (TRUST_DIRECTION_OUTBOUND & _nTrustDirection)
   {
      _LocalCreds.Impersonate();
   }

   dwRet = DsGetForestTrustInformationW(pwzServer,
                                        pwzDomain,
                                        0,
                                        &pNewFTInfo);
   _LocalCreds.Revert();

   if (ERROR_ACCESS_DENIED == dwRet &&
       TRUST_DIRECTION_INBOUND == _nTrustDirection)
   {
      // Prompt for creds for the other domain.
      //
      CCreds RemoteCreds;

      dwRet = RemoteCreds.PromptForCreds(_strTrustPartnerDnsName, _hPage);

      if (ERROR_CANCELLED == dwRet)
      {
         dwRet = ERROR_ACCESS_DENIED;
      }
      else
      {
         if (NO_ERROR == dwRet)
         {
            RemoteCreds.Impersonate();

            dwRet = DsGetForestTrustInformationW(pwzServer,
                                                 pwzDomain,
                                                 0,
                                                 &pNewFTInfo);
            RemoteCreds.Revert();
         }
      }
   }

   if (NO_ERROR != dwRet && fReport)
   {
      int nID = IDS_ERR_FT_CONTACT_DOMAIN;
      if (ERROR_NO_TRUST_SAM_ACCOUNT == dwRet ||
          ERROR_NO_SUCH_DOMAIN == dwRet)
      {
         nID = IDS_ERR_FT_TRUST_MISSING;
      }
      if (ERROR_INVALID_FUNCTION == dwRet)
      {
         nID = IDS_ERR_NOT_FORESTTRUST;
      }
      SuperMsgBox(_hPage, nID, IDS_DNT_MSG_TITLE, MB_OK | MB_ICONINFORMATION,
                  dwRet, NULL, 0, FALSE, __FILE__, __LINE__);
      fNewInfoRead = FALSE;
   }

   if (pDCInfo)
   {
      NetApiBufferFree(pDCInfo);
   }

   NTSTATUS status;
   LSA_UNICODE_STRING TrustPartner;
   PLSA_FOREST_TRUST_INFORMATION pFTInfo = NULL, pMergedFTInfo;

   RtlInitUnicodeString(&TrustPartner, _strTrustPartnerDnsName);

   // Read the local FT info to get the admin-disabled state.
   //
   status = LsaQueryForestTrustInformation(cPolicy,
                                           &TrustPartner,
                                           &pFTInfo);

   if (STATUS_NOT_FOUND == status)
   {
      DBG_OUT("No FTInfos found on the local TDO!\n");
      //
      // no FT info stored yet.
      //
      status = STATUS_SUCCESS;

      if (fNewInfoRead)
      {
         //
         // Set the page dirty bit so the user has a chance to save the FTInfo.
         //
         SetDirty();
      }
   }

   if (STATUS_NO_SUCH_DOMAIN == status)
   {
      ErrMsg(IDS_ERR_TRUST_NOT_FOUND, _hPage);
      return;
   }
   CHECK_LSA_STATUS_REPORT(status, _hPage, return);

   if (fNewInfoRead && pNewFTInfo)
   {
      if (pFTInfo)
      {
         if (AnyForestNameChanges(pFTInfo, pNewFTInfo))
         {
            dspDebugOut((DEB_ITRACE, "Claimed forest names have changed, setting dirty state.\n"));
            SetDirty();
         }
         //
         // Merge the two.
         //
         dwRet = DsMergeForestTrustInformationW(_strTrustPartnerDnsName,
                                                pNewFTInfo,
                                                pFTInfo,
                                                &pMergedFTInfo);
         NetApiBufferFree(pNewFTInfo);

         CHECK_WIN32_REPORT(dwRet, _hPage, return);

         dspAssert(pMergedFTInfo);

         _FTInfo = pMergedFTInfo;

         LsaFreeMemory(pMergedFTInfo);
         pMergedFTInfo = NULL;
         LsaFreeMemory(pFTInfo);
         pFTInfo = NULL;
      }
      else
      {
         _FTInfo = pNewFTInfo;
         NetApiBufferFree(pNewFTInfo);
      }
   }
   else
   {
      if (pFTInfo)
      {
         _FTInfo = pFTInfo;
         LsaFreeMemory(pFTInfo);
         pFTInfo = NULL;
      }
      else
      {
         // This case is reached if the trust on the other side is of the
         // wrong type (external rather than forest) and the TDO on this
         // side has no forest trust information (which it wouldn't have
         // if the other side is incapable of supplying it). The error
         // message above for ERROR_INVALID_FUNCTION will have explained
         // the situation.
         //
         return;
      }
   }

   // Make a temp copy and clear the conflict bit before submitting to LSA.
   // This will return current conflict info.
   //
   CFTInfo TempFTInfo(_FTInfo);

   TempFTInfo.ClearAnyConflict();

   // Now check the data. On return from the call the pColInfo struct
   // will contain current collision data.
   //
   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo;

   status = LsaSetForestTrustInformation(cPolicy,
                                         &TrustPartner,
                                         TempFTInfo.GetFTInfo(),
                                         TRUE, // check only, don't write to TDO
                                         &pColInfo);

   CHECK_LSA_STATUS_REPORT(status, _hPage, return);

   _CollisionInfo = pColInfo;

   // Look for names that used to be or are now in conflict.
   //
   for (ULONG i = 0; i < _FTInfo.GetCount(); i++)
   {
      // Any names that used to be in conflict but aren't now are marked as
      // admin-disabled.
      //
      if (_FTInfo.IsConflictFlagSet(i))
      {
         if (!_CollisionInfo.IsInCollisionInfo(i))
         {
            _FTInfo.SetAdminDisable(i);
            _FTInfo.SetUsedToBeInConflict(i);
            continue;
         }
      }
      // If a name is in the collision info, then set the conflict flag.
      //
      if (_CollisionInfo.IsInCollisionInfo(i))
      {
         _FTInfo.SetConflictDisable(i);
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::RefreshList
//
//  Synopsis:   Read the name suffixes and add them to the list.
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::RefreshList(void)
{
   TRACER(CDsForestNameRoutingPage, RefreshList);
   CWaitCursor Wait;

   _TLNList.Clear();

   BOOL fCollision, fAdminDisabled, fNewDisabled;
   CStrW strName;

   dspDebugOut((DEB_ITRACE, "There are %d FTInfo records.\n", _FTInfo.GetCount()));

   for (ULONG i = 0; i < _FTInfo.GetCount(); i++)
   {
      LSA_FOREST_TRUST_RECORD_TYPE type;

      if (!_FTInfo.GetType(i, type))
      {
         dspAssert(FALSE);
         return;
      }

      if (type != ForestTrustTopLevelName)
      {
         // Only TLNs go into the list.
         //
         continue;
      }

      fCollision = fAdminDisabled = fNewDisabled = FALSE;

      _FTInfo.GetDnsName(i, strName);

      AddAsteriskPrefix(strName);

      if (LSA_TLN_DISABLED_CONFLICT & _FTInfo.GetFlags(i))
      {
         dspDebugOut((DEB_ITRACE, "Collision record found for %ws\n", strName.GetBuffer(0)));
         fCollision = TRUE;
      }
      if (LSA_TLN_DISABLED_NEW & _FTInfo.GetFlags(i))
      {
         fNewDisabled = TRUE;
      }
      if (LSA_TLN_DISABLED_ADMIN & _FTInfo.GetFlags(i))
      {
         fAdminDisabled = TRUE;
      }

      CStrW strEnabled, strCollisionName, strStatus;

      if (fAdminDisabled || fNewDisabled)
      {
         // NOTICE-2002/02/12-ericb - SecurityPush: see above notice
         strEnabled.LoadString(g_hInstance, IDS_ROUTING_DISABLED);

         if (fAdminDisabled && _FTInfo.WasInConflict(i))
         {
            strStatus.LoadString(g_hInstance, IDS_STATUS_CONFLICT_GONE);
         }

         if (fNewDisabled)
         {
            strStatus.LoadString(g_hInstance, IDS_STATUS_NEW);
         }
      }
      else
      {
         // Find if there is a conflict record for this name.
         //
         if (_CollisionInfo.IsInCollisionInfo(i))
         {
            fCollision = TRUE;
            strEnabled.LoadString(g_hInstance, IDS_ROUTING_DISABLED);
            // NOTICE-2002/02/12-ericb - SecurityPush: see above notice
            strStatus.LoadString(g_hInstance, IDS_ROUTING_CONFLICT);
            _CollisionInfo.GetCollisionName(i, strCollisionName);
            strStatus += strCollisionName;
         }

         if (!fCollision)
         {
            strEnabled.LoadString(g_hInstance, IDS_ROUTING_ENABLED);

            if (_FTInfo.AnyChildDisabled(i))
            {
               strStatus.LoadString(g_hInstance, IDS_STATUS_EXCEPTIONS);
            }
         }
      }

      _TLNList.AddItem(strName, i, strEnabled, strStatus);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CDsForestNameRoutingPage::CheckDomainForConflict
//
//  Synopsis:  If a domain was disable and has been changed to enabled by the
//             user, check if the domain is in conflict. The only way to do
//             this is to submit the entire FTInfo to LSA.
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::CheckDomainForConflict(CWaitCursor & Wait)
{
   TRACER(CDsForestNameRoutingPage,CheckDomainForConflict);
   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo;
   NTSTATUS status;
   LSA_UNICODE_STRING TrustPartner;
   DWORD dwRet;
   CPolicyHandle cPolicy(_strUncDC);

   dwRet = cPolicy.OpenWithPrompt(_LocalCreds, Wait,
                                  _strDomainDnsName, _hPage);

   CHECK_WIN32_REPORT(dwRet, _hPage, return);

   RtlInitUnicodeString(&TrustPartner, _strTrustPartnerDnsName);

   CFTInfo TempFTInfo(_FTInfo);

   TempFTInfo.ClearAnyConflict();

   status = LsaSetForestTrustInformation(cPolicy,
                                         &TrustPartner,
                                         TempFTInfo.GetFTInfo(),
                                         TRUE, // check only, don't write to TDO
                                         &pColInfo);

   if (STATUS_NO_SUCH_DOMAIN == status)
   {
      ErrMsg(IDS_ERR_TRUST_NOT_FOUND, _hPage);
      return;
   }
   CHECK_LSA_STATUS_REPORT(status, _hPage, return);

   // Save the collision info.
   //
   _CollisionInfo = pColInfo;

   // Look for names that are now in conflict.
   //
   for (ULONG i = 0; i < _FTInfo.GetCount(); i++)
   {
      // If a name is in the collision info but it is marked as enabled, then
      // set the conflict flag.
      //
      if (_CollisionInfo.IsInCollisionInfo(i))
      {
         if (_FTInfo.IsEnabled(i))
         {
            _FTInfo.SetConflictDisable(i);
            continue;
         }
      }
      // Any names that used to be in conflict but aren't now are marked as
      // admin-disabled.
      //
      if (_FTInfo.IsConflictFlagSet(i))
      {
         if (!_CollisionInfo.IsInCollisionInfo(i))
         {
            _FTInfo.SetAdminDisable(i);
            _FTInfo.SetUsedToBeInConflict(i);
         }
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::EnableButtons
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::EnableButtons(void)
{
   TRACER(CDsForestNameRoutingPage, EnableButtons);
   BOOL fEnableEnable = TRUE, fEnableDisable = TRUE, fEnableEdit = TRUE;

   int item = _TLNList.GetSelection();

   if (item < 0)
   {
      fEnableEnable = fEnableDisable = fEnableEdit = FALSE;
   }
   else
   {
      if (_fReadOnly)
      {
         fEnableEnable = fEnableDisable = FALSE;
      }
      else
      {
         // What is the state of the selected item.
         //
         ULONG i = _TLNList.GetFTInfoIndex(item);

         dspAssert(i < _FTInfo.GetCount());

         // Only TLNs show up in the list, so only need to check TLN flags.
         //
         if (LSA_TLN_DISABLED_NEW & _FTInfo.GetFlags(i))
         {
            fEnableDisable = FALSE;
         }
         else
         if (LSA_TLN_DISABLED_ADMIN & _FTInfo.GetFlags(i))
         {
            fEnableDisable = FALSE;
         }
         else
         if (LSA_TLN_DISABLED_CONFLICT & _FTInfo.GetFlags(i) ||
             _CollisionInfo.IsInCollisionInfo(i))
         {
            fEnableEnable = fEnableDisable = FALSE;
         }
         else
         {
            fEnableEnable = FALSE;
         }
      }
   }

   EnableWindow(GetDlgItem(_hPage, IDC_ENABLE_BTN), fEnableEnable);
   EnableWindow(GetDlgItem(_hPage, IDC_DISABLE_BTN), fEnableDisable);
   EnableWindow(GetDlgItem(_hPage, IDC_EDIT_BTN), fEnableEdit);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsForestNameRoutingPage::OnApply(void)
{
   TRACE(CDsForestNameRoutingPage, OnApply);
   DWORD dwRet;
   LRESULT lResult = PSNRET_INVALID_NOCHANGEPAGE;

   // Write the new data to the TDO.
   //
   dwRet = WriteTDO();

   if (NO_ERROR == dwRet)
   {
      ClearDirty();
      lResult = PSNRET_NOERROR;
   }
   else
   {
      if (ERROR_NO_SUCH_DOMAIN == dwRet)
      {
         ErrMsg(IDS_ERR_WRITE_FTI_TRUST_NOT_FOUND, _hPage);
      }
      else
      {
         ReportError(dwRet, IDS_ERR_WRITE_FTI_TO_TDO, _hPage);
      }
   }

   return lResult;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsForestNameRoutingPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (_fInInit)
   {
       return 0;
   }
   if (BN_CLICKED == codeNotify)
   {
      switch (id)
      {
      case IDC_ENABLE_BTN:
         OnEnableClick();
         break;

      case IDC_DISABLE_BTN:
         OnDisableClick();
         break;

      case IDC_EDIT_BTN:
         OnEditClick();
         break;
      }
   }
   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::OnNotify
//
//  Synopsis:   Handles notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsForestNameRoutingPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    dspDebugOut((DEB_USER6, "DsProp listview id %d code %d\n",
                 ((LPNMHDR)lParam)->code));
    HWND hList;
    LRESULT lResult;

    if (_fInInit)
    {
        return 0;
    }
    switch (((LPNMHDR)lParam)->code)
    {
    case LVN_ITEMCHANGED:
        EnableButtons();
        break;

    case NM_SETFOCUS:
        hList = GetDlgItem(_hPage, (int)((LPNMHDR)lParam)->idFrom);

        if (ListView_GetItemCount(hList))
        {
            int item = ListView_GetNextItem(hList, -1, LVNI_ALL | LVIS_SELECTED);

            if (item < 0)
            {
                // If nothing is selected, set the focus to the first item.
                //
                LV_ITEM lvi = {0};
                lvi.mask = LVIF_STATE;
                lvi.stateMask = LVIS_FOCUSED;
                lvi.state = LVIS_FOCUSED;
                ListView_SetItem(hList, &lvi);
            }
        }
        EnableButtons();
        break;

    case NM_KILLFOCUS:
        EnableButtons();
        break;

    case PSN_APPLY:
        lResult = PSNRET_NOERROR;
        if (IsDirty())
        {
            lResult = OnApply();
        }
        // Store the result into the dialog
        SetWindowLongPtr(_hPage, DWLP_MSGRESULT, (LONG_PTR)lResult);
        return lResult;
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::PageCallback
//
//  Synopsis:   Callback used to free the CDsForestNameRoutingPage object when the
//              property sheet has been destroyed.
//
//-----------------------------------------------------------------------------
UINT CALLBACK
CDsForestNameRoutingPage::PageCallback(HWND hDlg, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
   TRACE_FUNCTION(CDsForestNameRoutingPage::PageCallback);

   if (uMsg == PSPCB_RELEASE)
   {
      //
      // Determine instance that invoked this static function
      //
      CDsForestNameRoutingPage * pPage = (CDsForestNameRoutingPage *) ppsp->lParam;

      if (pPage->IsDirty())
      {
         // User never clicked Apply, so write name changes out now.
         //
         DWORD dwRet = pPage->WriteTDO();

         if (NO_ERROR != dwRet)
         {
            if (ERROR_NO_SUCH_DOMAIN == dwRet)
            {
               ErrMsg(IDS_ERR_WRITE_FTI_TRUST_NOT_FOUND, hDlg);
            }
            else
            {
               ReportError(dwRet, IDS_ERR_WRITE_FTI_TO_TDO, hDlg);
            }
         }
      }

      delete pPage;

      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDsForestNameRoutingPage::OnEnableClick
//
//  Synopsis:  Enable the TLN. The change is not persisted until the user
//             Applies the page.
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::OnEnableClick(void)
{
   TRACER(CDsForestNameRoutingPage,OnEnableClick);
   CWaitCursor Wait;

   int item = _TLNList.GetSelection();

   if (item < 0)
   {
      dspAssert(FALSE);
      return;
   }

   ULONG i = _TLNList.GetFTInfoIndex(item);

   dspAssert(i < _FTInfo.GetCount());

   _FTInfo.ClearDisableFlags(i);

   SetDirty();
   CheckDomainForConflict(Wait);
   RefreshList();
   EnableButtons();
}

//+----------------------------------------------------------------------------
//
//  Method:    CDsForestNameRoutingPage::OnDisableClick
//
//  Synopsis:  Set the admin-disable flag on the selected TLN. The change is
//             not persisted until the user Applies the page.
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::OnDisableClick(void)
{
   TRACER(CDsForestNameRoutingPage,OnDisableClick);
   CWaitCursor Wait;

   int item = _TLNList.GetSelection();

   if (item < 0)
   {
      dspAssert(FALSE);
      return;
   }

   ULONG i = _TLNList.GetFTInfoIndex(item);

   dspAssert(i < _FTInfo.GetCount());

   _FTInfo.SetAdminDisable(i);

   SetDirty();
   CheckDomainForConflict(Wait);
   RefreshList();
   EnableButtons();
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::OnEditClick
//
//  Synopsis:   The user wishes to change the state of names derived from the
//              selected TLN.
//
//-----------------------------------------------------------------------------
void
CDsForestNameRoutingPage::OnEditClick(void)
{
   int item = _TLNList.GetSelection();

   if (item < 0)
   {
      dspAssert(FALSE);
      return;
   }

   ULONG i = _TLNList.GetFTInfoIndex(item);

   dspAssert(i < _FTInfo.GetCount());

   //Check if the Name Suffix is in conflict
   if ( ! _FTInfo.IsConflictFlagSet (i) )
   {
       // If not in conflict show the Edit dlg
        CEditTLNDialog EditDlg(_hPage, IDD_TLN_EDIT, _FTInfo, _CollisionInfo, this);

        INT_PTR nRet = EditDlg.DoModal(i);

        if (IDOK != nRet && IDCANCEL != nRet)
        {
            REPORT_ERROR((HRESULT)((nRet < 0) ? GetLastError() : nRet), _hPage);
        }

        if (IDOK == nRet)
        {
            CWaitCursor Wait;
            CheckDomainForConflict(Wait);
            RefreshList();
            EnableButtons();
        }
   }
   else
   {
       dspAssert ( _CollisionInfo.IsInCollisionInfo(i) );
       if ( _CollisionInfo.IsInCollisionInfo(i) )
       {
           CStrW strCollisionSrcName;
           _CollisionInfo.GetCollisionName ( i, strCollisionSrcName );

            // There are 2 ways that a conflict can occur
           if ( strCollisionSrcName.CompareNoCase ( _strForestName) == 0 )
           {
                // Case 1: Local UPN Case:           
                CStrW strConflictMesg, strTitle;
                strTitle.LoadString ( g_hInstance, IDS_MSG_TITLE );
                strConflictMesg.FormatMessage ( g_hInstance, IDS_FOREST_LOCALUPN_SUFFIX_CONFLICT, (LPCWSTR)_strForestName, (LPCWSTR) _strTrustPartnerDnsName );
                MessageBox ( _hPage, strConflictMesg, strTitle, MB_OK );
            }
            else
            {
                // Case 2: Other Forest Case:
                CStrW strMesg, strTitle;
                strTitle.LoadString ( g_hInstance, IDS_MSG_TITLE );
                strMesg.FormatMessage ( g_hInstance, IDS_FOREST_OTHER_SUFFIX_CONFLICT, (LPCWSTR) strCollisionSrcName, (LPCWSTR) _strTrustPartnerDnsName );
                int retValue = MessageBox ( _hPage, strMesg, strTitle, MB_YESNO );
                if ( retValue == IDYES )
                {
                    CStrW strTDOPath;
                    _pParentPage->GetStrTDO ( strCollisionSrcName, strTDOPath );

                    if ( !strTDOPath.IsEmpty () )
                        PostPropSheet(strTDOPath, _pParentPage->GetPage (), FALSE );
                }
            }       
       }
   }
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsForestNameRoutingPage::WriteTDO
//
//  Synopsis:   Write the new data to the TDO.
//
//-----------------------------------------------------------------------------
DWORD
CDsForestNameRoutingPage::WriteTDO(void)
{
   TRACE(CDsForestNameRoutingPage,WriteTDO);
   NTSTATUS status;
   LSA_UNICODE_STRING TrustPartner;
   CPolicyHandle cPolicy(_strUncDC);
   CWaitCursor Wait;
   PLSA_FOREST_TRUST_INFORMATION pFTInfo = _FTInfo.GetFTInfo();

   if (!pFTInfo)
   {
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }

   DWORD dwRet = cPolicy.OpenWithPrompt(_LocalCreds, Wait,
                                        _strDomainDnsName, _hPage);

   CHECK_WIN32(dwRet, return dwRet);

   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo;

   RtlInitUnicodeString(&TrustPartner, _strTrustPartnerDnsName);

   status = LsaSetForestTrustInformation(cPolicy,
                                         &TrustPartner,
                                         pFTInfo,
                                         FALSE,
                                         &pColInfo);

   CHECK_LSA_STATUS(status, return LsaNtStatusToWinError(status));

   _CollisionInfo = pColInfo;

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDsForestNameRoutingPage::AnyForestNameChanges
//
//  Synopsis:  Check to see if there are any differences between the two
//             sets of names. Local exception records are ignored.
//
//  Notes:     Should the NetBIOS domain names be compared? IOW, is there
//             any likelyhood of domains being able to change their NetBIOS
//             names in the future?
//-----------------------------------------------------------------------------
bool
CDsForestNameRoutingPage::AnyForestNameChanges(
                                 PLSA_FOREST_TRUST_INFORMATION pLocalFTInfo,
                                 PLSA_FOREST_TRUST_INFORMATION pRemoteFTInfo)
{
   ULONG ulNamesFound = 0;

   for (ULONG i = 0; i < pLocalFTInfo->RecordCount; i++)
   {
      CStrW strLocalName, strRemoteName;

      switch (pLocalFTInfo->Entries[i]->ForestTrustType)
      {
      case ForestTrustTopLevelNameEx:
         //
         // The remote names returned by DsGetForestTrustInformation will
         // never contain exception records.
         //
         continue;

      case ForestTrustTopLevelName:
         strLocalName = pLocalFTInfo->Entries[i]->ForestTrustData.TopLevelName;
         break;

      case ForestTrustDomainInfo:
         strLocalName = pLocalFTInfo->Entries[i]->ForestTrustData.DomainInfo.DnsName;
         break;

      default:
         dspAssert(FALSE);
         continue;
      }

      bool fFound = false;

      if (strLocalName.IsEmpty())
      {
         dspAssert(FALSE);
         continue;
      }

      for (ULONG j = 0; j < pRemoteFTInfo->RecordCount; j++)
      {
         if (pRemoteFTInfo->Entries[j]->ForestTrustType !=
             pLocalFTInfo->Entries[i]->ForestTrustType)
         {
            continue;
         }

         strRemoteName = (ForestTrustTopLevelName == pRemoteFTInfo->Entries[j]->ForestTrustType) ?
                           pRemoteFTInfo->Entries[j]->ForestTrustData.TopLevelName : 
                           pRemoteFTInfo->Entries[j]->ForestTrustData.DomainInfo.DnsName;

         if (strRemoteName.IsEmpty())
         {
            dspAssert(FALSE);
            continue;
         }

         if (strLocalName == strRemoteName)
         {
            fFound = true;
            ulNamesFound++;
            break;
         }
      }

      if (!fFound)
      {
         return true;
      }
   }

   if (ulNamesFound < pRemoteFTInfo->RecordCount)
   {
      // There are more remote names than local names.
      //
      return true;
   }

   return false;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\schedule.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       schedule.cxx
//
//  Contents:   Schedule Page functionality.
//
//  History:    27-Aug-98 JonN split schedule.cxx from siterepl.cxx
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "siterepl.h"
#include "user.h" // DllScheduleDialog

#ifdef DSADMIN
extern "C"
{
#include <schedule.h>
}

//
// The schedule block has been redefined to have 1 byte for every hour.
// CODEWORK These should be defined in SCHEDULE.H.  JonN 2/9/98
//
#define INTERVAL_MASK       0x0F
#define RESERVED            0xF0
#define FIRST_15_MINUTES    0x01
#define SECOND_15_MINUTES   0x02
#define THIRD_15_MINUTES    0x04
#define FOURTH_15_MINUTES   0x08


// The dialog has one bit per hour, the DS schedule has one byte per hour
#ifdef OLD_SCHED_BLOCK
const int cbDSScheduleArrayLength = (cbScheduleArrayLength * 4);
#else
const int cbDSScheduleArrayLength = (24*7);
#endif

inline ULONG HeadersSizeNum(ULONG NumberOfSchedules)
{
    return sizeof(SCHEDULE) + ((NumberOfSchedules)-1)*sizeof(SCHEDULE_HEADER);
}

inline ULONG HeadersSize(SCHEDULE* psched)
{
    return HeadersSizeNum(psched->NumberOfSchedules);
}

//+----------------------------------------------------------------------------
//
//  Function:   ValidateScheduleBlock
//
//  Synopsis:   This function assumes that the SCHEDULE block has already been
//              validated by ValidateScheduleAttribute.  If a valid
//              interval schedule is found in the SCHEDULE block is it returned
//              in *ppDSSchedule.
//
//  CODEWORK JonN 7/17/01 This code should perform IsBadReadPtr checks before
//                        accessing pScheduleBlock
//
//-----------------------------------------------------------------------------

BOOL ValidateScheduleBlock( PSCHEDULE pScheduleBlock, PBYTE* ppDSSchedule )
{
    ASSERT( ppDSSchedule == NULL || *ppDSSchedule == NULL );

    BOOL fFoundInterval  = FALSE;
    BOOL fFoundBandwidth = FALSE;
    BOOL fFoundPriority  = FALSE;
    DWORD iSched;
    for (iSched = 0; iSched < pScheduleBlock->NumberOfSchedules; iSched++)
    {
        PSCHEDULE_HEADER pHeader = &(pScheduleBlock->Schedules[iSched]);
        ULONG ulMinimumBlockSize = 0;
        switch (pHeader->Type)
        {
        case SCHEDULE_INTERVAL:
            if (fFoundInterval)
                return FALSE; // two interval blocks
            fFoundInterval = TRUE;
            ulMinimumBlockSize = cbDSScheduleArrayLength;
            if (NULL != ppDSSchedule)
                *ppDSSchedule = ((PBYTE)pScheduleBlock) + pHeader->Offset;
            break;
        case SCHEDULE_BANDWIDTH:
            if (fFoundBandwidth)
                return FALSE; // two bandwidth blocks
            fFoundBandwidth = TRUE;
            break;
        case SCHEDULE_PRIORITY:
            if (fFoundPriority)
                return FALSE; // two priority blocks
            fFoundPriority = TRUE;
            break;
        default:
            // some other, currently unknown type, just let it go
            break;
        }
        if (   pHeader->Offset + ulMinimumBlockSize > pScheduleBlock->Size
            || pHeader->Offset < HeadersSize(pScheduleBlock) )
        {
            // does not fit in schedule block
            return FALSE;
        }
        if (    iSched < pScheduleBlock->NumberOfSchedules-1 &&
                pHeader->Offset + ulMinimumBlockSize > pScheduleBlock->Schedules[iSched+1].Offset )
            return FALSE; // collides with next item
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   ValidateScheduleAttribute
//
//  Synopsis:   If a valid SCHEDULE is found is it returned in *ppScheduleBlock.
//
//-----------------------------------------------------------------------------

// This returns TRUE iff the schedule block appears to be valid, regardless of
// whether it contains a schedule
BOOL ValidateScheduleAttribute(
        PADS_ATTR_INFO pAttrInfo,
        PSCHEDULE* ppScheduleBlock,
        PBYTE* ppDSSchedule )
{
    // CODEWORK should NULL==pAttrInfo return FALSE?
    if (NULL == pAttrInfo ||
        IsBadReadPtr(pAttrInfo,sizeof(ADS_ATTR_INFO)) ||
        1 != pAttrInfo->dwNumValues ||
        NULL == pAttrInfo->pADsValues ||
        IsBadReadPtr(pAttrInfo->pADsValues,sizeof(ADSVALUE)) ||
        ADSTYPE_OCTET_STRING != pAttrInfo->pADsValues[0].dwType )
    {
        return FALSE; // attribute is invalid or of wrong type
    }
    DWORD dwAttrLength = pAttrInfo->pADsValues[0].OctetString.dwLength;
    if (dwAttrLength < HeadersSizeNum(0))
        return FALSE; // attribute is too small to contain even skeleton SCHEDULE
    PSCHEDULE pScheduleBlock = reinterpret_cast<PSCHEDULE>
                            (pAttrInfo->pADsValues[0].OctetString.lpValue);
    if (NULL == pScheduleBlock || IsBadReadPtr(pScheduleBlock, dwAttrLength))
        return FALSE; // schedule data is missing
    if (dwAttrLength < pScheduleBlock->Size || 0x10000 < pScheduleBlock->Size)
        return FALSE; // Schedule internal size marker is too large
    if (pScheduleBlock->Size < HeadersSize(pScheduleBlock))
        return FALSE; // schedule is too small to contain even schedule headers
    if (NULL != ppScheduleBlock)
        *ppScheduleBlock = pScheduleBlock;
    return ValidateScheduleBlock( pScheduleBlock, ppDSSchedule );
}


//+----------------------------------------------------------------------------
//
//  Function:   TranslateScheduleBlockToHours, MergeHoursIntoScheduleBlock
//
//  Synopsis:   The schedule control only handles 24x7 bits, whereas the schedules
//              understood by the DS are 24*7 bytes (one byte per hour).
//              We can't display that large a schedule block, so instead we
//              turn on the hour if any of the 15-minute units are on,
//              and we turn on all of the 15-minute units if the hour is on.
//              These APIs allocate a new block of memory if needed,
//              using LocalAlloc.
//
//-----------------------------------------------------------------------------

bool ReadHourInDSScheduleBlock( BYTE* pDSSchedule, int nHour )
{
#ifdef OLD_SCHED_BLOCK
    return (0 != (pDSSchedule[nHour/2] & (0xf<<(4*(nHour%2)))));
#else
    return (0 != (pDSSchedule[nHour] & INTERVAL_MASK));
#endif
}

void SetHourInDSScheduleBlock( BYTE* pDSSchedule, int nHour, BYTE mask )
{
#ifdef OLD_SCHED_BLOCK
    if (fSet)
        pDSSchedule[nHour/2] |= (0xf<<(4*(nHour%2)));
    else
        pDSSchedule[nHour/2] &= ~(0xf<<(4*(nHour%2)));
#else
    pDSSchedule[nHour] &= RESERVED;    // clear out the side of interest to us
    pDSSchedule[nHour] |= mask;        // put in the new settings
#endif
}


// allocates a new hours block
BYTE* TranslateScheduleBlockToHours( PSCHEDULE pSchedule )
{
    if (NULL == pSchedule)
        return NULL;
    BYTE* pDSSchedule = NULL;
    if ( !ValidateScheduleBlock( pSchedule, &pDSSchedule ) || NULL == pDSSchedule )
        return NULL; // not currently defined

    // we found a schedule already defined
    BYTE* pHours = (BYTE*) LocalAlloc (LMEM_ZEROINIT, SCHEDULE_DATA_ENTRIES);
    ASSERT( NULL != pHours );
#if (24*7) != SCHEDULE_DATA_ENTRIES
#error
#endif
    if ( pHours )
    {
        for (INT nHour = 0; nHour < SCHEDULE_DATA_ENTRIES; nHour++)
        {
            pHours[nHour] = pDSSchedule[nHour]; // TODO: Is OLD_SCHED_BLOCK ever defined?
        }
    }

    return pHours;
}

PSCHEDULE NewScheduleBlock(
    PSCHEDULE pCopyScheduleBlock,
    bool fAddIntervalSchedule,
    BYTE byteNewScheduleDefault )
{
    UINT cbBytes = (NULL == pCopyScheduleBlock)
        ? (HeadersSizeNum(0)) : pCopyScheduleBlock->Size;
    if (fAddIntervalSchedule)
        cbBytes += (sizeof(SCHEDULE_HEADER) + cbDSScheduleArrayLength);
    PSCHEDULE pNewScheduleBlock = (PSCHEDULE)
        LocalAlloc( LMEM_ZEROINIT, cbBytes );
    ASSERT(NULL != pNewScheduleBlock);
    if ( pNewScheduleBlock )
    {
        if (NULL == pCopyScheduleBlock)
        {
            // create completely new schedule block
            if (fAddIntervalSchedule)
            {
                pNewScheduleBlock->Size = cbBytes;
                pNewScheduleBlock->NumberOfSchedules = 1;
                pNewScheduleBlock->Schedules[0].Type = SCHEDULE_INTERVAL;
                pNewScheduleBlock->Schedules[0].Offset = HeadersSizeNum(1);
                memset( ((BYTE*)pNewScheduleBlock)+pNewScheduleBlock->Schedules[0].Offset,
                         byteNewScheduleDefault,
                         cbDSScheduleArrayLength );
            }
            else
            {
                pNewScheduleBlock->NumberOfSchedules = 0;
            }
        }
        else if (!fAddIntervalSchedule)
        {
            // create exact copy of existing schedule block
            memcpy( pNewScheduleBlock,
                    pCopyScheduleBlock,
                    pCopyScheduleBlock->Size );
        }
        else
        {
            // create copy of existing schedule block with one added SCHEDULE_INTERVAL

            // copy existing SCHEDULE and SCHEDULE_BLOCKs
            memcpy( pNewScheduleBlock,
                    pCopyScheduleBlock,
                    HeadersSize(pCopyScheduleBlock)
                  );
            pNewScheduleBlock->Size = cbBytes;

            // change offsets for current data to add one more SCHEDULE_HEADER
            ULONG iSched;
            for (iSched = 0; iSched < pCopyScheduleBlock->NumberOfSchedules; iSched++)
            {
                pNewScheduleBlock->Schedules[iSched].Offset += sizeof(SCHEDULE_HEADER);
            }

            // add one more SCHEDULE_HEADER, put new data at end of new block
            pNewScheduleBlock->NumberOfSchedules += 1;
            pNewScheduleBlock->Schedules[pNewScheduleBlock->NumberOfSchedules-1].Type
                = SCHEDULE_INTERVAL;
            pNewScheduleBlock->Schedules[pNewScheduleBlock->NumberOfSchedules-1].Offset
                = pNewScheduleBlock->Size - cbDSScheduleArrayLength;

            // copy existing data
            memcpy( ((PBYTE)pNewScheduleBlock) + HeadersSize(pNewScheduleBlock),
                    ((PBYTE)pCopyScheduleBlock) + HeadersSize(pCopyScheduleBlock),
                    (pCopyScheduleBlock->Size - HeadersSize(pCopyScheduleBlock))
                  );

            // turn on all intervals
            memset( ((BYTE*)pNewScheduleBlock) + pNewScheduleBlock->Schedules[
                                pNewScheduleBlock->NumberOfSchedules-1].Offset,
                     INTERVAL_MASK,
                     cbDSScheduleArrayLength );
        }
    }

    return pNewScheduleBlock;
}

// allocates a new schedule block
PSCHEDULE MergeHoursIntoScheduleBlock(
    PSCHEDULE pOldScheduleBlock,
    BYTE* pHoursArray,
    BYTE byteNewScheduleDefault )
{
    ASSERT( pHoursArray != NULL );
    PSCHEDULE pNewScheduleBlock = NULL;
    PBYTE pOldDSSchedule = NULL;
    if (   NULL == pOldScheduleBlock
        || !ValidateScheduleBlock( pOldScheduleBlock, &pOldDSSchedule ) )
    {
        pNewScheduleBlock = NewScheduleBlock( NULL, true, byteNewScheduleDefault );
    }
    else if ( NULL == pOldDSSchedule )
    {
        pNewScheduleBlock = NewScheduleBlock( pOldScheduleBlock, true, byteNewScheduleDefault );
    }
    else
    {
        pNewScheduleBlock = NewScheduleBlock( pOldScheduleBlock, false, byteNewScheduleDefault );
    }
    ASSERT( NULL != pNewScheduleBlock );
    if ( !pNewScheduleBlock )
        return 0;

    PBYTE pNewDSSchedule = NULL;
    if (   (!ValidateScheduleBlock( pNewScheduleBlock, &pNewDSSchedule ))
        || (NULL == pNewDSSchedule) )
    {
        ASSERT( FALSE );
        if (NULL != pNewScheduleBlock)
            LocalFree( pNewScheduleBlock );
        return NULL;
    }

#if (24*7) != (SCHEDULE_DATA_ENTRIES)
#error
#endif
    for (INT nHour = 0; nHour < SCHEDULE_DATA_ENTRIES; nHour++)
    {
        SetHourInDSScheduleBlock( pNewDSSchedule, nHour, pHoursArray[nHour]);
    }

    return pNewScheduleBlock;
}



//+----------------------------------------------------------------------------
//
//  Function:   ScheduleChangeBtn
//
//  Synopsis:   Handles the schedule Change button.
//
//  JonN 4/26/00
//  22835: DCR: SITEREPL needs a way to delete custom schedules on nTDSConnection objects.
//
//-----------------------------------------------------------------------------
HRESULT
ScheduleChangeBtnBase(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp, BYTE byteNewScheduleDefault)
{
    TRACE_FUNCTION(ScheduleChangeBtn);

    switch (DlgOp)
    {
    case fObjChanged:
        if ( NULL != pAttrData && NULL != pAttrData->pVoid )
        {
          PVOID pVoid = reinterpret_cast<PVOID>(pAttrData->pVoid);
          if (pVoid != NULL)
          {
            LocalFree( pVoid );
            pAttrData->pVoid = NULL;
          }
        }
        // fall through
    case fInit:
        {
            ASSERT(NULL != pAttrData && NULL == pAttrData->pVoid);
            if (NULL != pAttrData && NULL == pAttrData->pVoid)
            {
                PSCHEDULE pScheduleBlock = NULL;
                PBYTE pDSSchedule = NULL;
                if ( ValidateScheduleAttribute( pAttrInfo, &pScheduleBlock, &pDSSchedule ) )
                {
                    pAttrData->pVoid = reinterpret_cast<LPARAM>(LocalAlloc(0, pScheduleBlock->Size));
                    CHECK_NULL(pAttrData->pVoid, return E_OUTOFMEMORY);
                    // Copy the data into the variable
                    memcpy(OUT reinterpret_cast<PVOID>(pAttrData->pVoid),
                        IN  pScheduleBlock,
                        pScheduleBlock->Size);
                }
                else
                {
                    // set new schedule to default
                    pAttrData->pVoid = reinterpret_cast<LPARAM>(NewScheduleBlock( NULL, TRUE, byteNewScheduleDefault ));
                }

    #ifdef CUSTOM_SCHEDULE
                // JonN 4/26/00: if the schedule is not set, clear the checkbox
                if (NULL == pDSSchedule) {
                    EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
                } else {
                    CheckDlgButton(pPage->GetHWnd(), IDC_SCHEDULE_CHECKBOX, BST_CHECKED);
                }
    #endif

                // JonN 7/2/99: disable if attribute not writable
                if ( pAttrMap &&
                    (pAttrMap->fIsReadOnly || !PATTR_DATA_IS_WRITABLE(pAttrData)) )
                {
    #ifdef CUSTOM_SCHEDULE
                    EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_SCHEDULE_CHECKBOX), FALSE);
    #endif
                    LPWSTR pszMsg = NULL;
                    if ( !LoadStringToTchar (IDS_VIEW_SCHEDULE, &pszMsg) )
                    {
                        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                        return E_OUTOFMEMORY;
                    }
                    HWND hwndCtrl = ::GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID);
                    ASSERT( NULL != hwndCtrl );
                    Static_SetText( hwndCtrl, pszMsg );
                    delete [] pszMsg;
                }
            }
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        // JonN 4/26/00 22835: clear schedule if checkbox unchecked
        // CODEWORK I still don't completely differentiate between
        // CODEWORK "NULL attribute" and "attribute present but no schedule".
        ASSERT( pAttrInfo != NULL );
        if (   NULL == pAttrData
            || NULL == pAttrData->pVoid
#ifdef CUSTOM_SCHEDULE
            || IsDlgButtonChecked(pPage->GetHWnd(), IDC_SCHEDULE_CHECKBOX) != BST_CHECKED
#endif
           )
        {
            // If the Schedule attribute was not set and the user hasn't
            // changed it from the default, then there is no need to write
            // anything.
            pAttrInfo->dwNumValues = 0;
            pAttrInfo->pADsValues = NULL;
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->OctetString.dwLength = ((PSCHEDULE)(pAttrData->pVoid))->Size;
            pADsValue->OctetString.lpValue = reinterpret_cast<BYTE*>(pAttrData->pVoid);
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        }
        break;

    case fOnCommand:
        if (lParam == BN_CLICKED)
        {
            // JonN 12/12/01 334382
            WCHAR awchDisplayedName[MAX_PATH];
            ::ZeroMemory( awchDisplayedName, sizeof(awchDisplayedName) );
            LPCWSTR pszRDN = awchDisplayedName;
            if (!GetDlgItemText(pPage->GetHWnd(),
                                IDC_CN,
                                awchDisplayedName,
                                ARRAYLENGTH(awchDisplayedName)))
            {
                pszRDN = pPage->GetObjRDName();
            }

            BYTE* pHoursArray = TranslateScheduleBlockToHours( (PSCHEDULE)pAttrData->pVoid );
            if ( pHoursArray )
            {
                HRESULT hr = DllScheduleDialog(pPage->GetHWnd(),
                                               &pHoursArray,
                                               (NULL != pszRDN)
                                                   ? IDS_s_SCHEDULE_FOR
                                                   : IDS_SCHEDULE,
                                               pszRDN,
                                               pPage->GetObjClass (),
                                               (((pAttrMap && (pAttrMap->fIsReadOnly))
    			    // JonN 7/2/99: disable if attribute not writable
                                               || (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData)))
                                                   ? SCHED_FLAG_READ_ONLY : 0 ),
                                               ((pAttrMap)
                                                 ? (ScheduleDialogType)(pAttrMap->nSizeLimit)
                                                 : SchedDlg_Logon)
                                               );
                if ( S_OK == hr
                    && !IsBadReadPtr(pHoursArray, SCHEDULE_DATA_ENTRIES) )
                {
                    PSCHEDULE pOldSchedule = reinterpret_cast<PSCHEDULE>(pAttrData->pVoid);
                    PSCHEDULE pNewSchedule = MergeHoursIntoScheduleBlock(
                                pOldSchedule, pHoursArray, byteNewScheduleDefault );

                    //
                    // JonN 4/30/01 340777
                    // Change confirmation msg appears though
                    // no change was made to a Connection object
                    //
                    bool fChangedSchedule = (NULL == pOldSchedule)
                                         != (NULL == pNewSchedule);
                    // JonN 7/17/01 437775
                    // PSCHEDULE is longer than SCHEDULE_DATA_ENTRIES,
                    // it also has a header
                    do
                    {
                        if (fChangedSchedule || NULL == pNewSchedule)
                            break;
                        // Old and new schedules are both non-NULL
                        if ( IsBadReadPtr((void*)pNewSchedule, sizeof(ULONG))
                          || IsBadReadPtr((void*)pNewSchedule, pNewSchedule->Size) )
                        {
                            // new schedule is corrupt, do not replace schedule
                            break;
                        }
                        if ( IsBadReadPtr((void*)pOldSchedule, sizeof(ULONG))
                          || IsBadReadPtr((void*)pOldSchedule, pOldSchedule->Size) )
                        {
                            // old schedule is corrupt, definitely replace schedule
                            fChangedSchedule = true;
                            break;
                        }
                        fChangedSchedule =
                             pOldSchedule->Size != pNewSchedule->Size
                          || 0 != memcmp(pOldSchedule,
                                         pNewSchedule,
                                         pNewSchedule->Size);
                    } while (FALSE);
                    if (fChangedSchedule)
                    {
                        PVOID pVoid = reinterpret_cast<PVOID>(pAttrData->pVoid);
                        if (pVoid != NULL)
                        {
                            LocalFree( pVoid );
                        }
                        pAttrData->pVoid = reinterpret_cast<LPARAM>(pNewSchedule);
                        pPage->SetDirty();
                        PATTR_DATA_SET_DIRTY(pAttrData);
                    }
                }
                LocalFree( pHoursArray );
            }
        }
        break;

    case fOnDestroy:
        if ( NULL != pAttrData && NULL != pAttrData->pVoid )
        {
          PVOID pVoid = reinterpret_cast<PVOID>(pAttrData->pVoid);
          if (pVoid != NULL)
          {
            LocalFree( pVoid );
          }
          pAttrData->pVoid = NULL;
        }

        break;
    }

    return S_OK;
}

// exactly once per hour, this is the meaning of attribute not set
HRESULT
ScheduleChangeBtn_11_Default(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp )
{
    return ScheduleChangeBtnBase( pPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
        0x11 );
}

// turn on all intervals, this is the meaning of attribute not set
HRESULT
ScheduleChangeBtn_FF_Default(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp )
{
    return ScheduleChangeBtnBase( pPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
        0xFF );
}

#ifdef CUSTOM_SCHEDULE
HRESULT
ScheduleChangeCheckbox(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
                  DLG_OP DlgOp )
{
    if (fOnCommand == DlgOp && BN_CLICKED == lParam)
    {
        EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_SCHEDULE_BTN),
                     IsDlgButtonChecked(pPage->GetHWnd(), pAttrMap->nCtrlID));
        ((CDsTableDrivenPage*)pPage)->SetNamedAttrDirty(pAttrMap->AttrInfo.pszAttrName);
    }
    return S_OK;
}
#endif

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\scopedelegation.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       ScopeDelegation.cxx
//
//  Contents:   CDsScopeDelegationPage, the class that implements the Delegation
//              property page for user and computer object
//              
//
//  History:    06-April-2001 JeffJon created
//
//-----------------------------------------------------------------------------

#include "pch.h"

#include "ScopeDelegation.h"
#include "pcrack.h"

extern "C"
{
   #include <ntdsapip.h>   // DsCrackSpn3W
}
#include <dnsapi.h>

#ifdef DSADMIN

// This filter will be passed to Object Picker to search for all users and computers that
// have a value for the servicePrincipalName

static PCWSTR g_pszOPSPNFilter = 
   L"(&(servicePrincipalName=*)(|(samAccountType=805306368)(samAccountType=805306369)))";


// Index for each column in list

static const int IDX_SERVICE_TYPE_COLUMN = 0;
static const int IDX_USER_OR_COMPUTER_COLUMN = 1;
static const int IDX_PORT_COLUMN = 2;
static const int IDX_SERVICE_NAME_COLUMN = 3;
static const int IDX_DOMAIN_COLUMN = 4;

// Default width for each column in list

static const int SERVICE_TYPE_COLWIDTH = 80;
static const int USER_OR_COMPUTER_COLWIDTH = 120;
static const int PORT_COLWIDTH = 35;
static const int SERVICE_NAME_COLWIDTH = 80;
static const int DOMAIN_COLWIDTH = 80;


CServiceAllowedToDelegate::~CServiceAllowedToDelegate()
{
   if (HasDuplicates())
   {
      for (AllowedServicesContainer::iterator itr = duplicateServices.begin();
           itr != duplicateServices.end();
           ++itr)
      {
         delete *itr;
      }
      duplicateServices.clear();
   }
}

//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::CServiceAllowedToDelegate
//
//  Synopsis:   Copy constructor
//
//-----------------------------------------------------------------------------
CServiceAllowedToDelegate::CServiceAllowedToDelegate(const CServiceAllowedToDelegate& ref)
   : m_pMasterService(0)
{
   if (this == &ref)
   {
      dspAssert(this != &ref);
      return;
   }

   Assign(ref);
}

//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::operator=
//
//  Synopsis:   Assignment operator
//
//-----------------------------------------------------------------------------
const CServiceAllowedToDelegate& 
CServiceAllowedToDelegate::operator=(const CServiceAllowedToDelegate& ref)
{
   if (this == &ref)
   {
      dspAssert(this != &ref);
      return *this;
   }

   Assign(ref);
   return *this;
}

//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::Assign
//
//  Synopsis:   Actually does the assignment for the operator= 
//              and copy constructor
//
//-----------------------------------------------------------------------------
void CServiceAllowedToDelegate::Assign(const CServiceAllowedToDelegate& ref)
{
   m_strADSIValue = ref.m_strADSIValue;
   m_strServiceType = ref.m_strServiceType;
   m_strUserOrComputer = ref.m_strUserOrComputer;
   m_strPort = ref.m_strPort;
   m_strServiceName = ref.m_strServiceName;
   m_strRealm = ref.m_strRealm;
}

//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::Initialize
//
//  Synopsis:   Initializes the CServiceAllowedToDelegate object with the value
//              from the msDS-AllowedToDelegateTo attribute
//
//-----------------------------------------------------------------------------

HRESULT CServiceAllowedToDelegate::Initialize(PCWSTR pszADSIValue)
{
   HRESULT hr = S_OK;

   dspAssert(pszADSIValue);

   m_strADSIValue = pszADSIValue;
   
   WCHAR pszHostName[DNS_MAX_NAME_LENGTH + 1];
   WCHAR pszInstanceName[DNS_MAX_NAME_LENGTH + 1];
   WCHAR pszDomainName[DNS_MAX_NAME_LENGTH + 1];
   WCHAR pszRealmName[DNS_MAX_NAME_LENGTH + 1];

   ZeroMemory(pszHostName, sizeof(WCHAR) * (DNS_MAX_NAME_LENGTH + 1));
   ZeroMemory(pszInstanceName, sizeof(WCHAR) * (DNS_MAX_NAME_LENGTH + 1));
   ZeroMemory(pszDomainName, sizeof(WCHAR) * (DNS_MAX_NAME_LENGTH + 1));
   ZeroMemory(pszRealmName, sizeof(WCHAR) * (DNS_MAX_NAME_LENGTH + 1));

   DWORD dwHostNameCount = DNS_MAX_NAME_LENGTH + 1;
   DWORD dwInstanceNameCount = DNS_MAX_NAME_LENGTH + 1;
   DWORD dwDomainNameCount = DNS_MAX_NAME_LENGTH + 1;
   DWORD dwRealmNameCount = DNS_MAX_NAME_LENGTH + 1;
   USHORT portNumber = 0;

   DWORD result = DsCrackSpn3W(m_strADSIValue,
                               m_strADSIValue.GetLength(),
                               &dwHostNameCount,
                               pszHostName,
                               &dwInstanceNameCount,
                               pszInstanceName,
                               &portNumber,
                               &dwDomainNameCount,
                               pszDomainName,
                               &dwRealmNameCount,
                               pszRealmName);

   if (ERROR_SUCCESS == result)
   {
      m_strServiceType = pszHostName;
      m_strUserOrComputer = pszInstanceName;
      m_strServiceName = pszDomainName;
      m_strRealm = pszRealmName;

      if (0 != portNumber)
      {
         m_strPort.Format(L"%d", portNumber);
      }
   }
   else
   {
      hr = HRESULT_FROM_WIN32(result);
   }

   return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::operator==
//
//  Synopsis:   Checks for equality of the SPN by the following rules
//                1. By full ADSI value
//                2. If ALL of the following are true
//                     a. Service type are equal
//                     b. User/Computer name are equal or derivates
//                        of each other (i.e. DNS name and Netbios name for
//                        the same computer)
//
//-----------------------------------------------------------------------------
bool
CServiceAllowedToDelegate::operator==(const CServiceAllowedToDelegate& rhs) const
{
   bool result = false;

   do
   {
      if (_wcsicmp(m_strADSIValue, rhs.m_strADSIValue) == 0)
      {
         result = true;
         break;
      }

      if (_wcsicmp(m_strServiceType, rhs.m_strServiceType) != 0)
      {
         // Service types are not the same so they couldn't be equal

         result = false;
         break;
      }

      // if ports are not equal or realms are not equal, then the SPNs
      // are not equal

      if (_wcsicmp(m_strPort, rhs.m_strPort) != 0 ||
          _wcsicmp(m_strRealm, rhs.m_strRealm) != 0)
      {
         result = false;
         break;
      }

      if (_wcsicmp(m_strUserOrComputer, rhs.m_strUserOrComputer) == 0)
      {
         result = true;
         break;
      }

      // Now we have to check derivations of the computer/user names

      WCHAR szComputerNameThis[MAX_COMPUTERNAME_LENGTH + 1];
      ZeroMemory(szComputerNameThis, sizeof(WCHAR) * (MAX_COMPUTERNAME_LENGTH + 1));

      WCHAR szComputerNameRHS[MAX_COMPUTERNAME_LENGTH + 1];
      ZeroMemory(szComputerNameRHS, sizeof(WCHAR) * (MAX_COMPUTERNAME_LENGTH + 1));

      DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
      BOOL bComputerNameThis = DnsHostnameToComputerName(m_strUserOrComputer, 
                                                         szComputerNameThis,
                                                         &dwSize);
      dwSize = MAX_COMPUTERNAME_LENGTH + 1;
      BOOL bComputerNameRHS = DnsHostnameToComputerName(rhs.m_strUserOrComputer,
                                                        szComputerNameRHS,
                                                        &dwSize);

      if (bComputerNameThis)
      {
         // Compare this services NetBIOS name to the others name as given by the SPN

         if (_wcsicmp(szComputerNameThis, rhs.m_strUserOrComputer) == 0)
         {
            result = true;
            break;
         }

         // Compare this services NetBIOS name to the NetBIOS name of the other service

         if (bComputerNameRHS &&
             _wcsicmp(szComputerNameThis, szComputerNameRHS) == 0)
         {
            result = true;
            break;
         }
      }

      // Compare the name given in the SPN for this service with the NetBios name of
      // the other service

      if (bComputerNameRHS &&
          _wcsicmp(m_strUserOrComputer, szComputerNameRHS) == 0)
      {
         result = true;
         break;
      }
   } while (false);

   return result;
}
//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::GetColumn
//
//  Synopsis:   Returns a string that will be placed in the specified column
//              in the list
//
//-----------------------------------------------------------------------------
PCWSTR CServiceAllowedToDelegate::GetColumn(int column) const
{
   if (IDX_SERVICE_TYPE_COLUMN == column)
   {
      return m_strServiceType;
   }
   
   if (IDX_USER_OR_COMPUTER_COLUMN == column)
   {
      return m_strUserOrComputer;
   }

   if (IDX_PORT_COLUMN == column)
   {
      return m_strPort;
   }

   if (IDX_SERVICE_NAME_COLUMN == column)
   {
      return m_strServiceName;
   }

   if (IDX_DOMAIN_COLUMN == column)
   {
      return m_strRealm;
   }

   return L"";
}

//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::SetServiceType
//
//  Synopsis:   Changes the service type and recreates the m_strADSIValue
//              to match
//
//-----------------------------------------------------------------------------
void CServiceAllowedToDelegate::SetServiceType(PCWSTR pszServiceType)
{
   if (!pszServiceType)
   {
      dspAssert(pszServiceType);
      return;
   }

   // Pull off everything before the first / and replace it with the new value

   int iFind = m_strADSIValue.Find(L'/');
   if (iFind != -1)
   {
      CStr strTemp = m_strADSIValue.Right(m_strADSIValue.GetLength() - iFind);
      m_strADSIValue = pszServiceType;
      m_strADSIValue += strTemp;
   }

   // Also replace the old service type with the new one

   m_strServiceType = pszServiceType;
}

//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::AddDuplicate
//
//  Synopsis:   Adds a service to the duplicates list
//
//-----------------------------------------------------------------------------
void CServiceAllowedToDelegate::AddDuplicate(CServiceAllowedToDelegate* pService)
{
   pService->SetDuplicate(this);
   duplicateServices.push_back(pService);
}

//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::SetDuplicate
//
//  Synopsis:   Makes this service a duplicate of the master service which is
//              passed in
//
//-----------------------------------------------------------------------------
void CServiceAllowedToDelegate::SetDuplicate(CServiceAllowedToDelegate* pMasterService)
{
   m_pMasterService = pMasterService;
}

//+----------------------------------------------------------------------------
//
//  Function:   CServiceAllowedToDelegate::RemoveDuplicate
//
//  Synopsis:   Removes the service from the duplicates list
//
//-----------------------------------------------------------------------------
void CServiceAllowedToDelegate::RemoveDuplicate(CServiceAllowedToDelegate* pService)
{
   duplicateServices.remove(pService);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNListView::~CSPNListView
//
//-----------------------------------------------------------------------------
CSPNListView::~CSPNListView()
{
   ClearUnSelectedServices();
   m_AllServices.clear();
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::Initialize
//
//  Synopsis:   Initializes the list view by adding columns etc.
//
//-----------------------------------------------------------------------------
HRESULT CSPNListView::Initialize(HWND hwnd, bool bShowDuplicateEntries)
{
   if (!hwnd ||
       !IsWindow(hwnd))
   {
      dspAssert(hwnd);
      dspAssert(IsWindow(hwnd));

      return E_INVALIDARG;
   }

   m_bShowDuplicateEntries = bShowDuplicateEntries;

   HRESULT hr = S_OK;
   m_hWnd = hwnd;

   ListView_SetExtendedListViewStyle(m_hWnd, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

   //
   // Set the column headings.
   //
   PTSTR ptsz = 0;

   if (!LoadStringToTchar(IDS_SERVICE_TYPE_COLUMN, &ptsz))
   {
      return E_OUTOFMEMORY;
   }

   LV_COLUMN lvc = {0};
   lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
   lvc.fmt = LVCFMT_LEFT;
   lvc.cx = SERVICE_TYPE_COLWIDTH;
   lvc.pszText = ptsz;
   lvc.iSubItem = IDX_SERVICE_TYPE_COLUMN;

   ListView_InsertColumn(m_hWnd, IDX_SERVICE_TYPE_COLUMN, &lvc);

   delete[] ptsz;

   if (!LoadStringToTchar(IDS_USER_OR_COMPUTER_COLUMN, &ptsz))
   {
      return E_OUTOFMEMORY;
   }

   lvc.cx = USER_OR_COMPUTER_COLWIDTH;
   lvc.pszText = ptsz;
   lvc.iSubItem = IDX_USER_OR_COMPUTER_COLUMN;

   ListView_InsertColumn(m_hWnd, IDX_USER_OR_COMPUTER_COLUMN, &lvc);

   delete[] ptsz;

   if (!LoadStringToTchar(IDS_PORT_COLUMN, &ptsz))
   {
      return E_OUTOFMEMORY;
   }

   lvc.cx = PORT_COLWIDTH;
   lvc.pszText = ptsz;
   lvc.iSubItem = IDX_PORT_COLUMN;

   ListView_InsertColumn(m_hWnd, IDX_PORT_COLUMN, &lvc);

   delete[] ptsz;

   if (!LoadStringToTchar(IDS_SERVICE_NAME_COLUMN, &ptsz))
   {
      return E_OUTOFMEMORY;
   }

   // Service Name

   lvc.cx = SERVICE_NAME_COLWIDTH;
   lvc.pszText = ptsz;
   lvc.iSubItem = IDX_SERVICE_NAME_COLUMN;

   ListView_InsertColumn(m_hWnd, IDX_SERVICE_NAME_COLUMN, &lvc);

   delete[] ptsz;

   if (!LoadStringToTchar(IDS_DOMAIN_COLUMN, &ptsz))
   {
      return E_OUTOFMEMORY;
   }

   // Realm

   lvc.cx = DOMAIN_COLWIDTH;
   lvc.pszText = ptsz;
   lvc.iSubItem = IDX_DOMAIN_COLUMN;

   ListView_InsertColumn(m_hWnd, IDX_DOMAIN_COLUMN, &lvc);

   delete[] ptsz;

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::SetShowDuplicateEntries
//
//  Synopsis:   Refreshes the list and either shows all entries or 
//              collapses similar entries into one
//
//-----------------------------------------------------------------------------
void CSPNListView::SetShowDuplicateEntries(bool bShowDuplicates)
{
   m_bShowDuplicateEntries = bShowDuplicates;

   // Refresh the list view

   ListView_DeleteAllItems(m_hWnd);

   // Remove all items from the selected and unselected lists

   m_UnSelectedServices.clear();
   m_SelectedServices.clear();

   // Now add back all services from the All service list

   for (AllowedServicesContainer::iterator itr = m_AllServices.begin();
        itr != m_AllServices.end();
        ++itr)
   {
      // Add the service to the UI

      int newIndex = AddServiceToUI(*itr);
      dspAssert(newIndex != -1);

      // Add the duplicates if necessary

      if (m_bShowDuplicateEntries &&
          (*itr)->HasDuplicates())
      {
         AllowedServicesContainer& duplicates = (*itr)->GetDuplicates();
         for (AllowedServicesContainer::iterator dupitr = duplicates.begin();
              dupitr != duplicates.end();
              ++dupitr)
         {
            newIndex = AddServiceToUI(*dupitr);
            dspAssert(newIndex != -1);
         }
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::ClearSelectedServices
//
//  Synopsis:   Clears all the values out of the selected services list
//
//-----------------------------------------------------------------------------
void CSPNListView::ClearSelectedServices()
{
   for (AllowedServicesContainer::iterator itr = m_SelectedServices.begin();
        itr != m_SelectedServices.end();
        ++itr)
   {
      m_AllServices.remove(*itr);
      delete *itr;
   }

   m_SelectedServices.clear();
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::ClearUnSelectedServices
//
//  Synopsis:   Clears all the values out of the unselected services list
//
//-----------------------------------------------------------------------------
void CSPNListView::ClearUnSelectedServices()
{
   for (AllowedServicesContainer::iterator itr = m_UnSelectedServices.begin();
        itr != m_UnSelectedServices.end();
        ++itr)
   {
      m_AllServices.remove(*itr);
      delete *itr;
   }

   m_UnSelectedServices.clear();
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::ClearAll
//
//  Synopsis:   Clears all the values out of the list view and from the containers
//
//-----------------------------------------------------------------------------
void CSPNListView::ClearAll()
{
   ListView_DeleteAllItems(m_hWnd);

   for (AllowedServicesContainer::iterator itr = m_AllServices.begin();
        itr != m_AllServices.end();
        ++itr)
   {
      delete *itr;
   }

   m_AllServices.clear();
   m_SelectedServices.clear();
   m_UnSelectedServices.clear();
}

//+----------------------------------------------------------------------------
//
//  Member:     CSPNListView::SelectAll
//
//  Synopsis:   Selects all the items in the list and then forces a redraw
//
//-----------------------------------------------------------------------------
void CSPNListView::SelectAll()
{
   LRESULT lCount = SendMessage(m_hWnd, LVM_GETITEMCOUNT, 0, 0);

   LVITEM lvi;
   ZeroMemory(&lvi, sizeof(LVITEM));

   lvi.mask = LVIF_STATE;
   lvi.stateMask = LVIS_SELECTED;
   lvi.state = LVIS_SELECTED;

   LRESULT lSuccess = SendMessage(m_hWnd, LVM_SETITEMSTATE, (WPARAM)-1, (LPARAM)&lvi);
   dspAssert(lSuccess);

   SetFocus(m_hWnd);
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::FindService
//
//  Synopsis:   Looks for a specific service in the current list.  It compares
//
//
//-----------------------------------------------------------------------------
CServiceAllowedToDelegate* 
CSPNListView::FindService(CServiceAllowedToDelegate* pService, bool& isExactDuplicate)
{
   if (!pService)
   {
      dspAssert(pService);
      return 0;
   }

   isExactDuplicate = false;
   CServiceAllowedToDelegate* result = 0;

   for (AllowedServicesContainer::iterator itr = m_AllServices.begin();
        itr != m_AllServices.end();
        ++itr)
   {
      if (_wcsicmp((*itr)->GetADSIValue(), pService->GetADSIValue()) == 0)
      {
         isExactDuplicate = true;
         result = *itr;
         break;
      }

      if (**itr == *pService)
      {
         result = *itr;
         break;
      }
   }
   return result;
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::AddServiceToUI
//
//  Synopsis:   Adds a service to the list view
//
//-----------------------------------------------------------------------------
int CSPNListView::AddServiceToUI(CServiceAllowedToDelegate* pService, bool selected)
{
   if (!pService)
   {
      dspAssert(pService);
      return -1;
   }

   int NewIndex = -1;

   // Add the value to the list

   LV_ITEM lvi = {0};
   lvi.mask = LVIF_TEXT | LVIF_PARAM;
   lvi.iSubItem = IDX_SERVICE_TYPE_COLUMN;

   lvi.lParam = (LPARAM)pService;
   lvi.pszText = (PWSTR)(PCWSTR)pService->GetColumn(IDX_SERVICE_TYPE_COLUMN);

   // Insert at the end of the list
   lvi.iItem = ListView_GetItemCount(m_hWnd) + 1;

   if (selected)
   {
      lvi.mask |= LVIF_STATE;
      lvi.stateMask = LVIS_SELECTED;
      lvi.state = LVIS_SELECTED;
   }

   //
   // Insert the new item
   //
   NewIndex = ListView_InsertItem(m_hWnd, &lvi);
   dspAssert(NewIndex != -1);
   if (NewIndex == -1)
   {
      return NewIndex;
   }

   // Add each additional column

   for (int column = IDX_USER_OR_COMPUTER_COLUMN; column <= IDX_DOMAIN_COLUMN; ++column)
   {
      ListView_SetItemText(m_hWnd, NewIndex, column, (PWSTR)pService->GetColumn(column));
   }
   return NewIndex;
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::AddService
//
//  Synopsis:   Adds a service to the list view and the internal data containers
//              Returns the new index of the item added
//
//-----------------------------------------------------------------------------
int CSPNListView::AddService(CServiceAllowedToDelegate* pService, bool selected)
{
   if (!pService)
   {
      dspAssert(pService);
      return -1;
   }

   int NewIndex = -1;

   bool isExactDuplicate = false;
   CServiceAllowedToDelegate* pFoundService = FindService(pService, isExactDuplicate);
   if (isExactDuplicate)
   {
      // Don't add any exact duplicates because the server will reject the Set operation
   }
   else if (pFoundService && 
            !m_bShowDuplicateEntries)
   {
      pFoundService->AddDuplicate(pService);
      NewIndex = 0;
   }
   else if (pFoundService && 
            m_bShowDuplicateEntries)
   {
      pFoundService->AddDuplicate(pService);
      NewIndex = AddServiceToUI(pService, selected);
   }
   else
   {
      NewIndex = AddServiceToUI(pService, selected);

      m_AllServices.push_back(pService);
   
      if (selected)
      {
         m_SelectedServices.push_back(pService);
      }
      else
      {
         m_UnSelectedServices.push_back(pService);
      }
   }
   return NewIndex;
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::AddServices
//
//  Synopsis:   Adds a list of services to the list view 
//              and the internal data containers
//
//-----------------------------------------------------------------------------
void CSPNListView::AddServices(const AllowedServicesContainer& servicesToAdd, 
                               bool selected,
                               bool toUIOnly)
{
   for (AllowedServicesContainer::iterator itr = servicesToAdd.begin();
        itr != servicesToAdd.end();
        ++itr)
   {
      if (toUIOnly)
      {
         AddServiceToUI(*itr, selected);
      }
      else
      {
         AddService(*itr, selected);
         if (m_bShowDuplicateEntries && (*itr)->HasDuplicates())
         {
            AddServices((*itr)->GetDuplicates(), selected, true);
         }
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::RemoveSelectedServices
//
//  Synopsis:   Removes the selected services from the list and the containers
//
//-----------------------------------------------------------------------------
void CSPNListView::RemoveSelectedServices()
{
   // Loop through the selected items in the list
   int nSelectedItem = ListView_GetNextItem(m_hWnd, -1, LVNI_SELECTED);
   int nFirstSelection = nSelectedItem;

   while (nSelectedItem != -1)
   {
      // Extract the pointer from the LPARAM

      LVITEM lvi = {0};
      lvi.iItem = nSelectedItem;
      lvi.mask = LVIF_PARAM;

      if (ListView_GetItem(m_hWnd, &lvi))
      {
         // Add the item to the selected services container
         CServiceAllowedToDelegate* pService = reinterpret_cast<CServiceAllowedToDelegate*>(lvi.lParam);
         if (pService)
         {
            // remove it from the services container
            m_AllServices.remove(pService);
            m_UnSelectedServices.remove(pService);
            m_SelectedServices.remove(pService);

            if (pService->IsDuplicate())
            {
               pService->GetMasterService()->RemoveDuplicate(pService);
            }

            if (pService->HasDuplicates() &&
                m_bShowDuplicateEntries)
            {
               // Since we are removing the service that contained the duplicates
               // we have promote one of the duplicates to the container and then
               // make all the other duplicates of that service

               CServiceAllowedToDelegate* pNewContainerService = 0;

               AllowedServicesContainer& duplicateContainer = pService->GetDuplicates();
               for (AllowedServicesContainer::iterator itr = duplicateContainer.begin();
                    itr != duplicateContainer.end();
                    ++itr)
               {
                  if (!pNewContainerService)
                  {
                     // Promote the first duplicate to the new container

                     pNewContainerService = *itr;
                     m_AllServices.push_back(pNewContainerService);
                     pNewContainerService->SetDuplicate(0);
                  }
                  else
                  {
                     // Add all others as duplicates to the first

                     pNewContainerService->AddDuplicate(*itr);
                  }
               }

               // Now clear out the old duplicate container so that
               // the remaining duplicates don't get deleted

               duplicateContainer.clear();
            }

            delete pService;

            // remove it from the UI
            ListView_DeleteItem(m_hWnd, nSelectedItem);
         }
         else
         {
            // There should be no reason to have an LPARAM that isn't
            // a CServiceAllowedToDelegate
            dspAssert(pService);
         }
      }

      // Always start at the beginning since we are removing.  That will guarantee
      // that we get everything

      nSelectedItem = ListView_GetNextItem(m_hWnd, -1, LVNI_SELECTED);
   }

   // Now select the item that replaced the first selected item in the list

   LVITEM lvi;
   ZeroMemory(&lvi, sizeof(LVITEM));

   lvi.mask = LVIF_STATE;
   lvi.stateMask = LVIS_SELECTED;
   lvi.state = LVIS_SELECTED;

   ListView_SetItemState(m_hWnd, nFirstSelection, LVIS_SELECTED, LVIS_SELECTED);
}

//+----------------------------------------------------------------------------
//
//  Method:     CSPNListView::SetContainersFromSelection
//
//  Synopsis:   Reads the selection from the list and rearranges the internal
//              containers as necessary.
//
//-----------------------------------------------------------------------------
void CSPNListView::SetContainersFromSelection()
{
   // Clear out the selected container
   m_SelectedServices.clear();

   // Loop through the selected items in the list
   int nSelectedItem = ListView_GetNextItem(m_hWnd, -1, LVNI_SELECTED);
   while (nSelectedItem != -1)
   {
      // Extract the pointer from the LPARAM

      LVITEM lvi = {0};
      lvi.iItem = nSelectedItem;
      lvi.mask = LVIF_PARAM;

      if (ListView_GetItem(m_hWnd, &lvi))
      {
         // Add the item to the selected services container
         CServiceAllowedToDelegate* pService = reinterpret_cast<CServiceAllowedToDelegate*>(lvi.lParam);
         if (pService)
         {
            // Remove the service from the unselected container
            m_UnSelectedServices.remove(pService);

            // Add the service to the selected services container
            m_SelectedServices.push_back(pService);
         }
         else
         {
            dspAssert(pService);
         }
      }

      nSelectedItem = ListView_GetNextItem(m_hWnd, nSelectedItem, LVNI_SELECTED);
   }
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsScopeDelegationPage::CDsScopeDelegationPage
//
//-----------------------------------------------------------------------------
CDsScopeDelegationPage::CDsScopeDelegationPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                               HWND hNotifyObj, DWORD dwFlags,
                                               SCOPE_DELEGATION_TYPE scopeDelegationType) :
    m_hList(0),
    m_scopeDelegationType(scopeDelegationType),
    m_fUACWritable(FALSE),
    m_fA2D2Writable(FALSE),
    m_oldUserAccountControl(0),
    m_newUserAccountControl(0),
    m_bA2D2Dirty(false),
    m_bContainsSPNs(false),
    m_bIsTrustedForDelegation(false),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsScopeDelegationPage,CDsScopeDelegationPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsScopeDelegationPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsScopeDelegationPage::~CDsScopeDelegationPage
//
//-----------------------------------------------------------------------------
CDsScopeDelegationPage::~CDsScopeDelegationPage()
{
  TRACE(CDsScopeDelegationPage,~CDsScopeDelegationPage);

  for (FreebiesContainer::iterator itr = m_FreebiesList.begin();
       itr != m_FreebiesList.end();
       ++itr)
  {
     delete *itr;
  }
}

//+----------------------------------------------------------------------------
//
//  Function:   UserAccountContainsSPNsOrIsTrusted
//
//  Synopsis:   Queries the DS to see if the user account contains any SPNs or
//              the UF_TRUSTED_FOR_DELEGATION bit in the userAccountControl
//
//-----------------------------------------------------------------------------
bool UserAccountContainsSPNsOrIsTrusted(PCWSTR pwzADsPath, bool& hasSPNs, bool& isTrusted)
{
   TRACE_FUNCTION(UserAccountContainsSPNsOrIsTrusted);

   bool result = false;

   do
   {
      if (!pwzADsPath)
      {
         ASSERT(pwzADsPath);
         result = false;
         break;
      }

      CComPtr<IDirectoryObject> spObject;
      HRESULT hr = DSAdminOpenObject(pwzADsPath,
                                     IID_IDirectoryObject,
                                     (void**)&spObject);
      if (FAILED(hr))
      {
         break;
      }

      PWSTR ppszAttrs[] = { g_wzSPN, g_wzUserAccountControl };
      PADS_ATTR_INFO pAttrInfo = 0;
      DWORD dwNumAttrs = 0;

      hr = spObject->GetObjectAttributes(ppszAttrs,
                                         2,
                                         &pAttrInfo,
                                         &dwNumAttrs);
      if (FAILED(hr) || !dwNumAttrs)
      {
         break;
      }

      for (DWORD idx = 0; idx < dwNumAttrs; ++idx)
      {
         if (_wcsicmp(pAttrInfo[idx].pszAttrName, g_wzUserAccountControl) == 0)
         {
            if (pAttrInfo[idx].pADsValues &&
                pAttrInfo[idx].pADsValues->Integer & UF_TRUSTED_FOR_DELEGATION)
            {
               isTrusted = true;
               continue;
            }
         }

         if (_wcsicmp(pAttrInfo[idx].pszAttrName, g_wzSPN) == 0)
         {
            if (pAttrInfo[idx].dwNumValues > 0)
            {
               hasSPNs = true;
               continue;
            }
         }
      }

      FreeADsMem(pAttrInfo);

      if (hasSPNs || isTrusted)
      {
         result = true;
      }

   } while (false);

   return result;
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateUserDelegationPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateUserDelegationPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR pwzADsPath,
                         PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                         const CDSSmartBasePathsInfo& basePathsInfo, HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateUserDelegationPage);

    // This page will only be added if the domain version is Whistler or greater
    // and the user account contains SPNs
    // NOTE : default to not showing the page unless we can prove this is a
    //        a Whislter or greater domain

    HRESULT hr = S_OK;

    bool hasSPNs = false;
    bool isTrusted = false;

    if (basePathsInfo->GetDomainBehaviorVersion() >= DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS &&
        UserAccountContainsSPNsOrIsTrusted(pwzADsPath, hasSPNs, isTrusted))
    {
       CDsScopeDelegationPage * pPageObj = new CDsScopeDelegationPage(pDsPage, pDataObj,
                                                                      hNotifyObj, dwFlags,
                                                                      SCOPE_DELEGATION_USER);
       CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

       pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo, hasSPNs, isTrusted);

       hr = pPageObj->CreatePage(phPage);
    }
    else
    {
       // Don't show the page

       hr = S_FALSE;
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateComputerDelegationPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateComputerDelegationPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR pwzADsPath,
                             PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                             const CDSSmartBasePathsInfo& basePathsInfo, HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateComputerDelegationPage);

    // This page will only be added if the domain version is Whistler or greater
    // NOTE : default to not showing the page unless we can prove this is a
    //        a Whislter or greater domain

    HRESULT hr = S_OK;

    if (basePathsInfo->GetDomainBehaviorVersion() >= DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
    {
       CDsScopeDelegationPage * pPageObj = new CDsScopeDelegationPage(pDsPage, pDataObj,
                                                                      hNotifyObj, dwFlags,
                                                                      SCOPE_DELEGATION_COMPUTER);
       CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

       pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo);

       hr = pPageObj->CreatePage(phPage);
    }
    else
    {
       // Don't show the page

       hr = S_FALSE;
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::Init
//
//  Synopsis:   Initialization function that calls the base class Init
//
//-----------------------------------------------------------------------------
void 
CDsScopeDelegationPage::Init(PWSTR pwzADsPath, 
                             PWSTR pwzClass, 
                             const CDSSmartBasePathsInfo& basePathsInfo,
                             bool hasSPNs,
                             bool isTrusted)
{
    TRACE(CDsScopeDelegationPage,Init);

    m_bContainsSPNs = hasSPNs;
    m_bIsTrustedForDelegation = isTrusted;

    CDsPropPageBase::Init(pwzADsPath, pwzClass, basePathsInfo);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CDsScopeDelegationPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsScopeDelegationPage::OnInitDialog(LPARAM)
{
    TRACE(CDsScopeDelegationPage,OnInitDialog);

    HRESULT hr = S_OK;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    m_fUACWritable = CheckIfWritable(g_wzUserAccountControl);
    m_fA2D2Writable = CheckIfWritable(g_wzA2D2);

    // Get Freebies list

    GetFreebiesList();

    // Remove button should be disabled until something is selected
    // in the list
    EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), FALSE);

    SetPageTextForType();
    m_ServicesList.Initialize(GetDlgItem(m_hPage, IDC_SERVICES_LIST), false);
    SendDlgItemMessage(m_hPage, IDC_EXPAND_CHECK, BM_SETCHECK, BST_UNCHECKED, 0);

    LoadDataFromObject();
    SetUIFromData();

    // NTRAID#NTBUG9-525269-2002/01/29-ronmart-If user can't write then delegation items should be disabled
    if(!m_fUACWritable && !m_fA2D2Writable)
    {
          EnableWindow(GetDlgItem(m_hPage, IDC_NO_TRUST_RADIO), FALSE);
          EnableWindow(GetDlgItem(m_hPage, IDC_ANY_SERVICE_RADIO), FALSE);
          EnableWindow(GetDlgItem(m_hPage, IDC_SPECIFIED_SERVICES_RADIO), FALSE);
          EnableWindow(GetDlgItem(m_hPage, IDC_EXPAND_CHECK), FALSE);
    }

    OnUpdateRadioSelection();

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::GetFreebiesList
//
//  Synopsis:   Reads the freebies list from the following DS container
//              CN=Directory Service,CN=Windows NT,CN=Services,CN=Configuration...
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::GetFreebiesList()
{
   // Make sure the list is clear

   m_FreebiesList.clear();

   PWSTR pszDSPath = 0;
   PADS_ATTR_INFO pAttrInfo = 0;

   do
   {
      // Compose the path to the DS node in the config container

      CStr configDN = GetBasePathsInfo()->GetConfigNamingContext();
      CStr directoryServiceDN = L"CN=Directory Service,CN=Windows NT,CN=Services,";
      directoryServiceDN += configDN;

      GetBasePathsInfo()->ComposeADsIPath(&pszDSPath, directoryServiceDN);
      if (!pszDSPath)
      {
         break;
      }

      CComPtr<IDirectoryObject> spDirObject;
      HRESULT hr = DSAdminOpenObject(pszDSPath,
                                     IID_IDirectoryObject,
                                     (void**)&spDirObject);
      if (FAILED(hr))
      {
         break;
      }

      DWORD dwNumAttributes = 1;
      PWSTR ppszAttributes[] = { g_wzSPNMappings };
      DWORD dwReturned = 0;

      hr = spDirObject->GetObjectAttributes(ppszAttributes,
                                            dwNumAttributes,
                                            &pAttrInfo,
                                            &dwReturned);
      if (FAILED(hr) ||
          !pAttrInfo ||
          !dwReturned)
      {
         break;
      }

      // Add the values to the freebies list
      dspAssert(_wcsicmp(pAttrInfo->pszAttrName, g_wzSPNMappings) == 0);
      
      for (DWORD idx = 0; idx < pAttrInfo->dwNumValues; ++idx)
      {
         // Value should be in the form service=alias,alias,alias,...
         // so break it apart

         CStr value = pAttrInfo->pADsValues[idx].CaseIgnoreString;
         int iFind = value.Find(L'=');
         if (iFind != -1)
         {
            CStr temp = value.Left(iFind);
            CFreebieService* pFreebieService = new CFreebieService(temp);
            if (!pFreebieService)
            {
               break;
            }

            CStr remaining = value;
            do
            {
               remaining = remaining.Right(remaining.GetLength() - iFind - 1);
               iFind = remaining.Find(L',');
               if (iFind != -1)
               {
                  temp = remaining.Left(iFind);
                  pFreebieService->AddFreebie(temp);
               }

               if (iFind == -1 &&
                   remaining.GetLength())
               {
                  pFreebieService->AddFreebie(remaining);
               }
            } while (iFind != -1);

            m_FreebiesList.push_back(pFreebieService);
         }
      }

   } while (false);

   if (pszDSPath)
   {
      delete[] pszDSPath;
   }

   if (pAttrInfo)
   {
      FreeADsMem(pAttrInfo);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::LoadDataFromObject
//
//  Synopsis:   Reads the userAccountControl and A2D2 from the object
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::LoadDataFromObject()
{
   HRESULT hr = S_OK;
   PADS_ATTR_INFO pAttrs = 0;

   do
   {
      PWSTR rgpwzAttrNames[] = { g_wzUserAccountControl, g_wzA2D2 };

      DWORD cAttrs = 0;

      hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames,
                                         ARRAYLENGTH(rgpwzAttrNames),
                                         &pAttrs, 
                                         &cAttrs);
      if (!CHECK_ADS_HR(&hr, GetHWnd()))
      {
         break;
      }

      if (!cAttrs ||
          !pAttrs)
      {
         break;
      }

      for (DWORD idx = 0; idx < cAttrs; idx++)
      {
         dspAssert(pAttrs[idx].dwNumValues);
         dspAssert(pAttrs[idx].pADsValues);

         if (_wcsicmp(pAttrs[idx].pszAttrName, g_wzUserAccountControl) == 0)
         {
            m_oldUserAccountControl = pAttrs[idx].pADsValues->Integer;
            m_newUserAccountControl = m_oldUserAccountControl;
            continue;
         }

         if (_wcsicmp(pAttrs[idx].pszAttrName, g_wzA2D2) == 0)
         {
            // Create a service object for each entry

            for (DWORD valueIdx = 0; valueIdx < pAttrs[idx].dwNumValues; ++valueIdx)
            {
               // This is added to m_ServicesList which gets cleared out and each
               // entry deleted when the property page is destroyed

               CServiceAllowedToDelegate* pService = new CServiceAllowedToDelegate();
               if (pService)
               {
                  // Initialize the entry with the value from A2D2

                  hr = pService->Initialize(pAttrs[idx].pADsValues[valueIdx].CaseIgnoreString);
                  if (SUCCEEDED(hr))
                  {
                     // Add the new value to the container

                     int newIndex = m_ServicesList.AddService(pService);
                     if (newIndex == -1)
                     {
                        // We either failed to add the service to the list 
                        // or it was an exact duplicate

                        delete pService;
                        pService = 0;
                     }
                  }
                  else
                  {
                     // Note: this means that entries that are not the proper format will
                     //       not be added to the list and no error will be given.

                     dspAssert(SUCCEEDED(hr));
                     delete pService;
                     pService = 0;
                  }
               }
            }

         }
      }

   } while (false);

   if (pAttrs)
   {
      FreeADsMem(pAttrs);
   }
}
   
//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::SetUIFromData
//
//  Synopsis:   Sets the UI controls based on the data read from the object
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::SetUIFromData()
{
   bool bTrustForDelegation = (m_oldUserAccountControl & UF_TRUSTED_FOR_DELEGATION) != 0;
   bool bAnyProtocol = (m_oldUserAccountControl & UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION) != 0;

   const AllowedServicesContainer& A2D2Values = m_ServicesList.GetAllServices();

   if (!bTrustForDelegation &&
       A2D2Values.size() == 0)
   {
      SendDlgItemMessage(m_hPage, IDC_NO_TRUST_RADIO, BM_SETCHECK, BST_CHECKED, 0);
      SendDlgItemMessage(m_hPage, IDC_ANY_SERVICE_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
      SendDlgItemMessage(m_hPage, IDC_SPECIFIED_SERVICES_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
   }
   else if (bTrustForDelegation &&
            A2D2Values.size() == 0)
   {
      SendDlgItemMessage(m_hPage, IDC_ANY_SERVICE_RADIO, BM_SETCHECK, BST_CHECKED, 0);
      SendDlgItemMessage(m_hPage, IDC_NO_TRUST_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
      SendDlgItemMessage(m_hPage, IDC_SPECIFIED_SERVICES_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
   }
   else
   {
      SendDlgItemMessage(m_hPage, IDC_SPECIFIED_SERVICES_RADIO, BM_SETCHECK, BST_CHECKED, 0);
      SendDlgItemMessage(m_hPage, IDC_NO_TRUST_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
      SendDlgItemMessage(m_hPage, IDC_ANY_SERVICE_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
   }

   if (bAnyProtocol)
   {
     SendDlgItemMessage(m_hPage, IDC_ANY_RADIO, BM_SETCHECK, BST_CHECKED, 0);
     SendDlgItemMessage(m_hPage, IDC_KERBEROS_ONLY_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
   }
   else
   {
     SendDlgItemMessage(m_hPage, IDC_KERBEROS_ONLY_RADIO, BM_SETCHECK, BST_CHECKED, 0);
     SendDlgItemMessage(m_hPage, IDC_ANY_RADIO, BM_SETCHECK, BST_UNCHECKED, 0);
   }

}


//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::SetPageTextForType
//
//  Synopsis:   Alters the page text for the type of object (user or computer)
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::SetPageTextForType()
{
   // Computer is the default and is embedded in the page resource so the only
   // modifications needed are for user

   if (m_scopeDelegationType == SCOPE_DELEGATION_USER)
   {
      CStr szNoTrustRadio;
      szNoTrustRadio.LoadString(g_hInstance, IDS_NO_TRUST_USER_RADIO);
      SetDlgItemText(m_hPage, IDC_NO_TRUST_RADIO, szNoTrustRadio);

      CStr szAnyServiceRadio;
      szAnyServiceRadio.LoadString(g_hInstance, IDS_ANY_SERVICE_USER_RADIO);
      SetDlgItemText(m_hPage, IDC_ANY_SERVICE_RADIO, szAnyServiceRadio);

      CStr szSpecifiedServiceRadio;
      szSpecifiedServiceRadio.LoadString(g_hInstance, IDS_SPECIFIED_SERVICES_USER_RADIO);
      SetDlgItemText(m_hPage, IDC_SPECIFIED_SERVICES_RADIO, szSpecifiedServiceRadio);
      
   }
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnUpdateRadioSelection
//
//  Synopsis:   Enable/Disable some controls based on the radio selection
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::OnUpdateRadioSelection()
{
   TRACE(CDsScopeDelegationPage,OnUpdateRadioSelection);

   if (m_fA2D2Writable && m_fUACWritable && m_bContainsSPNs)
   {
      if (BST_CHECKED == SendDlgItemMessage(m_hPage, 
                                            IDC_SPECIFIED_SERVICES_RADIO,
                                            BM_GETCHECK,
                                            0,
                                            0))
      {
         // Enable the services specific controls

         EnableWindow(GetDlgItem(m_hPage, IDC_KERBEROS_ONLY_RADIO), TRUE);
         EnableWindow(GetDlgItem(m_hPage, IDC_ANY_RADIO), TRUE);
         EnableWindow(GetDlgItem(m_hPage, IDC_LIST_STATIC), TRUE);
         EnableWindow(GetDlgItem(m_hPage, IDC_SERVICES_LIST), TRUE);
         EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BUTTON), TRUE);

         UINT nSelectedCount = m_ServicesList.GetSelectedCount();
         if (nSelectedCount > 0)
         {
            EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), TRUE);
         }
         else
         {
            EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), FALSE);
         }
      }
      else
      {
         // Disable the services specific controls

         EnableWindow(GetDlgItem(m_hPage, IDC_KERBEROS_ONLY_RADIO), FALSE);
         EnableWindow(GetDlgItem(m_hPage, IDC_ANY_RADIO), FALSE);
         EnableWindow(GetDlgItem(m_hPage, IDC_LIST_STATIC), FALSE);
         EnableWindow(GetDlgItem(m_hPage, IDC_SERVICES_LIST), FALSE);
         EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BUTTON), FALSE);
         EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), FALSE);
      }
   }
   else if ((!m_fA2D2Writable || !m_bContainsSPNs) && 
            m_fUACWritable)
   {
      // Disable the services specific controls

      EnableWindow(GetDlgItem(m_hPage, IDC_NO_TRUST_RADIO), TRUE);
      EnableWindow(GetDlgItem(m_hPage, IDC_ANY_SERVICE_RADIO), TRUE);
      EnableWindow(GetDlgItem(m_hPage, IDC_SPECIFIED_SERVICES_RADIO), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_KERBEROS_ONLY_RADIO), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_ANY_RADIO), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_LIST_STATIC), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_SERVICES_LIST), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BUTTON), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), FALSE);
   }
   else
   {
      // User does not have rights to write either the userAccountControl or 
      // msDS-AllowedToDelegateTo attribute

      EnableWindow(GetDlgItem(m_hPage, IDC_KERBEROS_ONLY_RADIO), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_ANY_RADIO), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_LIST_STATIC), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_SERVICES_LIST), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_ADD_BUTTON), FALSE);
      EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), FALSE);
   }
}

//+----------------------------------------------------------------------------
//
//  Function:   GetServicesCountWithDuplicates
//
//  Synopsis:   Gets the count of all the services in the container including
//              duplicates
//
//-----------------------------------------------------------------------------
DWORD GetServicesCountWithDuplicates(const AllowedServicesContainer& container)
{
   DWORD result = 0;
   for (AllowedServicesContainer::iterator itr = container.begin();
        itr != container.end();
        ++itr)
   {
      if (*itr)
      {
         ++result;

         if ((*itr)->HasDuplicates())
         {
            result += GetServicesCountWithDuplicates((*itr)->GetDuplicates());
         }
      }
   }
   return result;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsScopeDelegationPage::OnApply(void)
{
   TRACE(CDsScopeDelegationPage,OnApply);

   ADSVALUE ADsValueAcctCtrl = {ADSTYPE_INTEGER, 0};
   ADS_ATTR_INFO AttrInfoAcctCtrl = {g_wzUserAccountControl, ADS_ATTR_UPDATE,
                                     ADSTYPE_INTEGER, &ADsValueAcctCtrl, 1};

   ADS_ATTR_INFO AttrInfoA2D2 = {g_wzA2D2, ADS_ATTR_UPDATE,
                                 ADSTYPE_CASE_IGNORE_STRING, 0, 0};

   ADS_ATTR_INFO AttrsToSet[2];
   DWORD dwAttrsToSetCount = 0;

   const AllowedServicesContainer& newA2D2Values = m_ServicesList.GetAllServices();

   if (BST_CHECKED == SendDlgItemMessage(m_hPage, 
                                         IDC_NO_TRUST_RADIO,
                                         BM_GETCHECK,
                                         0,
                                         0))
   {
      // Remove the trusted for delegation bit

      m_newUserAccountControl &= ~(UF_TRUSTED_FOR_DELEGATION);

      // Put the default back to Kerberos only

      m_newUserAccountControl &= ~(UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION);

      if (m_newUserAccountControl != m_oldUserAccountControl)
      {
         AttrsToSet[dwAttrsToSetCount] = AttrInfoAcctCtrl;
         ADsValueAcctCtrl.Integer = m_newUserAccountControl;

         ++dwAttrsToSetCount;
      }

      if (m_bA2D2Dirty || newA2D2Values.size())
      {
         // Must clear the value for msDS-AllowedToDelegateTo

         AttrInfoA2D2.dwControlCode = ADS_ATTR_CLEAR;
         AttrsToSet[dwAttrsToSetCount] = AttrInfoA2D2;
         ++dwAttrsToSetCount;
      }

      // Clear out the listview too since there will be no values after this

      m_ServicesList.ClearAll();
   }
   else if (BST_CHECKED == SendDlgItemMessage(m_hPage,
                                              IDC_ANY_SERVICE_RADIO,
                                              BM_GETCHECK,
                                              0,
                                              0))
   {
      // Set the trusted for delegation bit

      m_newUserAccountControl |= UF_TRUSTED_FOR_DELEGATION;

      // Put the default back to Kerberos only

      m_newUserAccountControl &= ~(UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION);

      if (m_newUserAccountControl != m_oldUserAccountControl)
      {
         AttrsToSet[dwAttrsToSetCount] = AttrInfoAcctCtrl;
         ADsValueAcctCtrl.Integer = m_newUserAccountControl;

         ++dwAttrsToSetCount;
      }

      if (m_bA2D2Dirty || newA2D2Values.size())
      {
         // Must clear the value for msDS-AllowedToDelegateTo

         AttrInfoA2D2.dwControlCode = ADS_ATTR_CLEAR;
         AttrsToSet[dwAttrsToSetCount] = AttrInfoA2D2;
         ++dwAttrsToSetCount;
      }

      // Clear out the listview too since there will be no values after this

      m_ServicesList.ClearAll();
   }
   else
   {
      // Before doing anything, make sure the user added at least one SPN
      // to the list
      if (newA2D2Values.size() == 0)
      {
         ReportError(S_OK, IDS_ERROR_MUST_HAVE_SPN, m_hPage);
         return PSNRET_INVALID_NOCHANGEPAGE;
      }

      // Remove the trusted for delegation bit

      m_newUserAccountControl &= ~(UF_TRUSTED_FOR_DELEGATION);

      if (BST_CHECKED == SendDlgItemMessage(m_hPage,
                                            IDC_KERBEROS_ONLY_RADIO,
                                            BM_GETCHECK,
                                            0,
                                            0))
      {
         m_newUserAccountControl &= ~(UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION);
      }
      else
      {
         m_newUserAccountControl |= UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION;
      }

      if (m_newUserAccountControl != m_oldUserAccountControl)
      {
         AttrsToSet[dwAttrsToSetCount] = AttrInfoAcctCtrl;
         ADsValueAcctCtrl.Integer = m_newUserAccountControl;

         ++dwAttrsToSetCount;
      }

      if (m_bA2D2Dirty)
      {
         // Get the count of all the services including the duplicates

         DWORD A2D2count = GetServicesCountWithDuplicates(newA2D2Values);

         // Set the values for msDS-AllowedToDelegateTo

         AttrInfoA2D2.dwNumValues = A2D2count;
         AttrInfoA2D2.pADsValues = new ADSVALUE[A2D2count];
         if (AttrInfoA2D2.pADsValues)
         {

            DWORD dwValueCount = 0;
            for (AllowedServicesContainer::iterator itr = newA2D2Values.begin();
                 itr != newA2D2Values.end();
                 ++itr)
            {
               AttrInfoA2D2.pADsValues[dwValueCount].dwType = ADSTYPE_CASE_IGNORE_STRING;
               AttrInfoA2D2.pADsValues[dwValueCount].CaseIgnoreString = (PWSTR)(*itr)->GetADSIValue();
               ++dwValueCount;

               // Now add the duplicates

               if ((*itr)->HasDuplicates())
               {
                  AllowedServicesContainer& duplicateServices = (*itr)->GetDuplicates();
                  for (AllowedServicesContainer::iterator dupitr = duplicateServices.begin();
                       dupitr != duplicateServices.end();
                       ++dupitr)
                  {
                     AttrInfoA2D2.pADsValues[dwValueCount].dwType = ADSTYPE_CASE_IGNORE_STRING;
                     AttrInfoA2D2.pADsValues[dwValueCount].CaseIgnoreString = (PWSTR)(*dupitr)->GetADSIValue();
                     ++dwValueCount;
                  }
               }
            }

            dspAssert(dwValueCount == AttrInfoA2D2.dwNumValues);

            AttrsToSet[dwAttrsToSetCount] = AttrInfoA2D2;
            ++dwAttrsToSetCount;
         }
         else
         {
            dspAssert(AttrInfoA2D2.pADsValues);
         }
      }
   }

   if (dwAttrsToSetCount)
   {
      DWORD dwNumModified = 0;
      HRESULT hr = m_pDsObj->SetObjectAttributes(AttrsToSet,
                                                 dwAttrsToSetCount,
                                                 &dwNumModified);
      // Cleanup

      if (AttrInfoA2D2.pADsValues)
      {
         delete[] AttrInfoA2D2.pADsValues;
      }

      // Report any errors

      if (FAILED(hr))
      {
         ReportError(hr, IDS_ADS_ERROR_FORMAT, m_hPage);

         return PSNRET_INVALID_NOCHANGEPAGE;
      }

      dspAssert(dwNumModified == dwAttrsToSetCount);
   }

   m_oldUserAccountControl = m_newUserAccountControl;
   SetUIFromData();

   return PSNRET_NOERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      
//
//-----------------------------------------------------------------------------
LRESULT
CDsScopeDelegationPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }

    if (BN_CLICKED == codeNotify)
    {
       switch (id)
       {
       case IDC_NO_TRUST_RADIO:
       case IDC_ANY_SERVICE_RADIO:
       case IDC_SPECIFIED_SERVICES_RADIO:
          OnUpdateRadioSelection();
          SetDirty();
          break;

       case IDC_KERBEROS_ONLY_RADIO:
       case IDC_ANY_RADIO:
          SetDirty();
          break;

       case IDC_ADD_BUTTON:
          OnAddServices();
          break;

       case IDC_REMOVE_BUTTON:
          OnRemoveServices();
          break;

       case IDC_EXPAND_CHECK:
          OnExpandCheck();
          break;
       }
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnRemoveServices
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::OnRemoveServices()
{
   m_ServicesList.RemoveSelectedServices();
   m_bA2D2Dirty = true;
   SetDirty();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnExpandCheck
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::OnExpandCheck()
{
   LRESULT lExpanded = SendDlgItemMessage(m_hPage,
                                          IDC_EXPAND_CHECK,
                                          BM_GETCHECK,
                                          0,
                                          0);

   m_ServicesList.SetShowDuplicateEntries(lExpanded == BST_CHECKED);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnAddServices
//
//-----------------------------------------------------------------------------
void CDsScopeDelegationPage::OnAddServices()
{
   CPathCracker pathcracker;
   HRESULT hr = pathcracker.Set(CComBSTR(GetObjPathName()), ADS_SETTYPE_FULL);
   if (SUCCEEDED(hr))
   {
      CComBSTR sbstrServer;
      hr = pathcracker.Retrieve(ADS_FORMAT_SERVER, &sbstrServer);
      if (SUCCEEDED(hr))
      {
         CSelectServicesDialog dlg(sbstrServer, m_hPage, m_FreebiesList);

         if (IDOK == dlg.DoModal())
         {
            // m_A2D2Container has taken over ownership of the
            // selected services from the dialog and will cleanup
            // during destruction

            m_ServicesList.AddServices(dlg.GetSelectedServices(), true);
            m_bA2D2Dirty = true;
            SetDirty();
         }
         else
         {
            // Have to clean up data from selected services container

            dlg.ClearSelectedServices();
         }
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnNotify
//
//-----------------------------------------------------------------------------
LRESULT
CDsScopeDelegationPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
   int idCtrl = (int)wParam;
   LPNMHDR pnmh = reinterpret_cast<LPNMHDR>(lParam);
   if (idCtrl == IDC_SERVICES_LIST)
   {
      switch (pnmh->code)
      {
         case LVN_ITEMCHANGED:
         case NM_CLICK:
            {
               UINT nSelectedCount = m_ServicesList.GetSelectedCount();
               if (nSelectedCount > 0)
               {
                  EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), TRUE);
               }
               else
               {
                  EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_BUTTON), FALSE);
               }
            }
            break;
         default:
            break;
      }
   }
    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsScopeDelegationPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsScopeDelegationPage::OnDestroy(void)
{
    CDsPropPageBase::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}



//+----------------------------------------------------------------------------
//
//  Method:     CSelectServicesDialog::CSelectServicesDialog
//
//  Synopsis:   Dialog that allows user to select services from users or computers
//
//-----------------------------------------------------------------------------
CSelectServicesDialog::CSelectServicesDialog(PCWSTR pszDC, 
                                             HWND hParent, 
                                             const FreebiesContainer& freebies)
  : m_hWnd(NULL),
    m_strDC(pszDC),
    m_FreebiesList(freebies),
    m_hParent(hParent)
{

}
    
//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::StaticDlgProc
//
//  Synopsis:   The static dialog proc for displaying errors for multi-select pages
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK CSelectServicesDialog::StaticDlgProc(HWND hDlg, 
                                                      UINT uMsg, 
                                                      WPARAM wParam,
                                                      LPARAM lParam)
{
  CSelectServicesDialog* dlg = NULL;

  UINT code;
  UINT id;
  switch (uMsg)
  {
    case WM_INITDIALOG:
      dlg = reinterpret_cast<CSelectServicesDialog*>(lParam);
      dspAssert(dlg != NULL);
      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)dlg);
      SetForegroundWindow(hDlg);
      return dlg->OnInitDialog(hDlg);

    case WM_COMMAND:
      code = GET_WM_COMMAND_CMD(wParam, lParam);
      id   = GET_WM_COMMAND_ID(wParam, lParam);

      dlg = reinterpret_cast<CSelectServicesDialog*>(GetWindowLongPtr(hDlg, DWLP_USER));

      if (dlg)
      {
         switch (id)
         {
           case IDOK:
             if (code == BN_CLICKED)
             {
               dlg->OnOK();
               dlg->OnClose(IDOK);
             }
             break;

           case IDCANCEL:
             if (code == BN_CLICKED)
             {
               dlg->OnClose(IDCANCEL);
             }
             break;

           case IDC_USERS_COMPUTERS_BUTTON:
             dlg->OnGetNewProvider();
             break;

           case IDC_SELECT_ALL_BUTTON:
             dlg->OnSelectAll();
             break;
         }
      }
      break;

    case WM_NOTIFY:
      {
        dlg = reinterpret_cast<CSelectServicesDialog*>(GetWindowLongPtr(hDlg, DWLP_USER));

        if (dlg)
        {
           int idCtrl = (int)wParam;
           LPNMHDR pnmh = reinterpret_cast<LPNMHDR>(lParam);
           if (idCtrl == IDC_SERVICES_LIST)
           {
             switch (pnmh->code)
             {
               case LVN_ITEMCHANGED:
               case NM_CLICK:
                 {
                   dlg->ListItemClick(pnmh);
                 }
                 break;
               default:
                 break;
             }
           }
        }
        break;
      }

    case WM_HELP:
      {
        LPHELPINFO pHelpInfo = reinterpret_cast<LPHELPINFO>(lParam);
        if (!pHelpInfo || pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
        {
          return FALSE;
        }
        WinHelp(hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);
        break;
      }
  }
  return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::Init
//
//  Synopsis:   Initializes the member variables
//
//-----------------------------------------------------------------------------
BOOL CSelectServicesDialog::OnInitDialog(HWND hDlg)
{
  m_hWnd = hDlg;

  HRESULT hr = m_ServicesList.Initialize(GetDlgItem(m_hWnd, IDC_SERVICES_LIST), false);


  EnableWindow(
     GetDlgItem(m_hWnd, IDC_SELECT_ALL_BUTTON),
     FALSE);

  return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::ListItemClick
//
//  Synopsis:   Enables/Disables the OK button when an item is selected
//
//-----------------------------------------------------------------------------
void CSelectServicesDialog::ListItemClick(LPNMHDR)
{
  UINT nSelectedCount = m_ServicesList.GetSelectedCount();
  if (nSelectedCount > 0)
  {
    EnableWindow(GetDlgItem(m_hWnd, IDOK), TRUE);
  }
  else
  {
    EnableWindow(GetDlgItem(m_hWnd, IDOK), FALSE);
  }
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::OnGetNewProvider
//
//  Synopsis:   Uses object picker to select users or computers that contain
//              SPNs
//
//-----------------------------------------------------------------------------
void CSelectServicesDialog::OnGetNewProvider()
{
   BOOL fIsObjSelInited = FALSE;
   CComPtr<IDsObjectPicker> spObjSel;

   HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER,
                                 IID_IDsObjectPicker, (PVOID *)&spObjSel);
   if (FAILED(hr))
   {
      REPORT_ERROR(hr, m_hWnd);
      return;
   }

   // Use object picker to select a new user or computer

   DSOP_SCOPE_INIT_INFO rgScopes[3];
   DSOP_INIT_INFO InitInfo;

   ZeroMemory(rgScopes, sizeof(rgScopes));
   ZeroMemory(&InitInfo, sizeof(InitInfo));

   // The first scope is the local domain. 

   rgScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   rgScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
   rgScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE |
                        DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                        DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS;

   rgScopes[0].pwzDcName = m_strDC;
   rgScopes[0].FilterFlags.Uplevel.flBothModes =
      DSOP_FILTER_USERS | DSOP_FILTER_COMPUTERS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS;

/* Changes to the KDC will prevent anything but local domain SPNs from working
   // The second scope is the local forest.
   //
   rgScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   rgScopes[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
   rgScopes[1].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                        DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS;
   rgScopes[1].FilterFlags.Uplevel.flBothModes =
      DSOP_FILTER_USERS | DSOP_FILTER_COMPUTERS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS;

   // The third scope is the GC.
   //
   rgScopes[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   rgScopes[2].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
   rgScopes[2].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                        DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS;
   rgScopes[2].FilterFlags.Uplevel.flBothModes =
      DSOP_FILTER_USERS | DSOP_FILTER_COMPUTERS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS;

   Can't use the DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN because it implies direct
   trust as well as forest trust.  If the trust is a direct trust and we pick an
   SPN from the trusted domain there is very little chance the KDC will be able
   to resolve it.  We need a forest specific flag from Object Picker

   // The fourth scope is uplevel external trusted domains.
   //
   rgScopes[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
   rgScopes[3].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN;
   rgScopes[3].flScope = DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS |
                        DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS;
   rgScopes[3].FilterFlags.Uplevel.flBothModes =
      DSOP_FILTER_USERS | DSOP_FILTER_COMPUTERS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS;
*/

   InitInfo.cDsScopeInfos = 1;
   InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
   InitInfo.aDsScopeInfos = rgScopes;
   InitInfo.pwzTargetComputer = m_strDC;
   InitInfo.flOptions = DSOP_FLAG_MULTISELECT;
   InitInfo.cAttributesToFetch = 1;
   LPCWSTR rgAttrNames[] = {g_wzSPN};
   InitInfo.apwzAttributeNames = rgAttrNames;

   hr = spObjSel->Initialize(&InitInfo);
   CHECK_HRESULT_REPORT(hr, m_hWnd, return);


   CComPtr<IDataObject> pdoSelections;

   CComPtr<IDsObjectPickerEx> spObjPickerEx;
   hr = spObjSel->QueryInterface(IID_IDsObjectPickerEx, (void**)&spObjPickerEx);
   CHECK_HRESULT_REPORT(hr, m_hWnd, return);

   hr = spObjPickerEx->InvokeDialogEx(m_hWnd, this, &pdoSelections);

   CHECK_HRESULT_REPORT(hr, m_hWnd, return);

   if (hr == S_FALSE || !pdoSelections)
   {
      return;
   }

   ProcessResults(pdoSelections);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::AddNewServiceObjectToList
//
//  Synopsis:   Creates a service object from an SPN string and adds it to
//              the list. Freebie expansion is done if required
//
//-----------------------------------------------------------------------------
bool CSelectServicesDialog::AddNewServiceObjectToList(PCWSTR pszSPN)
{
   bool objectAdded = false;

   if (!pszSPN)
   {
      return objectAdded;
   }

   // This is added to m_ServicesList which gets cleared out and each
   // entry deleted when the dialog is closed or is propogated back
   // to the property page which will then handle deleting this object

   CServiceAllowedToDelegate* pService = new CServiceAllowedToDelegate();
   if (!pService)
   {
      return objectAdded;
   }

   HRESULT hr = pService->Initialize(pszSPN);
   if (SUCCEEDED(hr))
   {
      for (FreebiesContainer::iterator itr = m_FreebiesList.begin();
           itr != m_FreebiesList.end();
           ++itr)
      {
         bool bAddExpanded = false;

         dspAssert(*itr);
         if (_wcsicmp(pService->GetColumn(0), (*itr)->GetAlias()) == 0)
         {
            // We have to expand out the HOST SPN to all the freebies

            const CStrList& aliasServiceNames = (*itr)->GetFreebies();
            for (CStrList::iterator freebie = aliasServiceNames.begin();
                 freebie != aliasServiceNames.end();
                 ++freebie)
            {
               // First make a copy of the Host service entry

               // This is added to m_ServicesList which gets cleared out and each
               // entry deleted when the dialog is closed or is propogated back
               // to the property page which will then handle deleting this object

               CServiceAllowedToDelegate* pFreebieService = 
                  new CServiceAllowedToDelegate(*pService);
               if (!pFreebieService)
               {
                  break;
               }

               // Now replace the service type with the freebie

               dspAssert(*freebie);
               pFreebieService->SetServiceType(*(*freebie));

               // Add the service, if it is added as a duplicate
               // the return value will be zero

               int newIndex = m_ServicesList.AddService(pFreebieService);

               if (newIndex == -1)
               {
                  // Failed to add the service into the list or as a duplicate

                  dspAssert(newIndex != -1);
                  delete pFreebieService;
                  pFreebieService = 0;
               }
               else
               {
                  objectAdded = true;
               }
            }

            // Always add the HOST service as well as its expanded services

            int newIndex = m_ServicesList.AddService(pService);

            if (newIndex == -1)
            {
               // We either failed to add the service into the list 
               // or it was an exact duplicate

               delete pService;
               pService = 0;
            }
            else
            {
               objectAdded = true;
            }
         }
         else
         {
            int newIndex = m_ServicesList.AddService(pService);
            if (newIndex == -1)
            {
               // We either failed to add the service into the list 
               // or it was an exact duplicate

               delete pService;
               pService = 0;
            }
            else
            {
               objectAdded = true;
            }
         }
      }
   }

   return objectAdded;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::ProcessResults
//
//  Synopsis:   Set the data from the results returned from Object Picker
//
//-----------------------------------------------------------------------------
void CSelectServicesDialog::ProcessResults(IDataObject* pdoSelections)
{
   if (!pdoSelections)
   {
      ASSERT(pdoSelections);
      return;
   }

   m_ServicesList.ClearAll();

   // Since there are no items in the list disable the select all button

   EnableWindow(
      GetDlgItem(m_hWnd, IDC_SELECT_ALL_BUTTON),
      FALSE);

   FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};

   HRESULT hr = pdoSelections->GetData(&fmte, &medium);

   CHECK_HRESULT_REPORT(hr, m_hWnd, return);

   PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

   if (!pSelList)
   {
      ReleaseStgMedium(&medium);
      return;
   }

   bool bAtLeastOneObjectHasSPN = false;
   for (DWORD idx = 0; idx < pSelList->cItems; ++idx)
   {
      // Unpack each set of SPN values
      if (pSelList->aDsSelection[idx].pvarFetchedAttributes[0].vt == (VT_ARRAY | VT_VARIANT))
      {

         // Unpack the safe array and create a CServiceAllowedToDelegate for each SPN

         SAFEARRAY* psa = V_ARRAY(&(pSelList->aDsSelection[idx].pvarFetchedAttributes[0]));

         do
         {
            ASSERT(psa);
            ASSERT(psa != (SAFEARRAY*)-1);

            if (!psa || psa == (SAFEARRAY*)-1)
            {
               break;
            }

            if (::SafeArrayGetDim(psa) != 1)
            {
               break;
            }

            VARTYPE vt = VT_EMPTY;
            hr = ::SafeArrayGetVartype(psa, &vt);
            if (FAILED(hr) || vt != VT_VARIANT)
            {
               break;
            }

            long lower = 0;
            long upper = 0;
     
            hr = ::SafeArrayGetLBound(psa, 1, &lower);
            if (FAILED(hr))
            {
               break;
            }

            hr = ::SafeArrayGetUBound(psa, 1, &upper);
            if (FAILED(hr))
            {
               break;
            }
      
            for (long i = lower; i <= upper; ++i)
            {
               CComVariant item;
               hr = ::SafeArrayGetElement(psa, &i, &item);
               if (FAILED(hr))
               {
                  continue;
               }

               if (item.vt == VT_BSTR &&
                   item.bstrVal)
               {
                  if (AddNewServiceObjectToList(item.bstrVal))
                  {
                     bAtLeastOneObjectHasSPN = true;
                  }
               }
            }
         } while (false);
      }
      else if (pSelList->aDsSelection[idx].pvarFetchedAttributes[0].vt == VT_BSTR)
      {
         if (AddNewServiceObjectToList(
                pSelList->aDsSelection[idx].pvarFetchedAttributes[0].bstrVal))
         {
            bAtLeastOneObjectHasSPN = true;
         }
      }
   } // for loop

   ReleaseStgMedium(&medium);
   if (!bAtLeastOneObjectHasSPN)
   {
      ReportError(S_OK, IDC_NO_OBJECT_WITH_SPN, m_hWnd);
      EnableWindow(
         GetDlgItem(m_hWnd, IDC_SELECT_ALL_BUTTON),
         FALSE);
   }
   else
   {
      EnableWindow(
         GetDlgItem(m_hWnd, IDC_SELECT_ALL_BUTTON),
         TRUE);
   }
}


//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::OnSelectAll
//
//  Synopsis:   Selects all the items in the list and then forces a redraw
//
//-----------------------------------------------------------------------------
void CSelectServicesDialog::OnSelectAll()
{
   m_ServicesList.SelectAll();
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::OnOK
//
//  Synopsis:   Puts all selected services in the selected services container
//
//-----------------------------------------------------------------------------
void CSelectServicesDialog::OnOK()
{
   // Use this time to rebuild the internal containers such that the selections
   // are represented correctly. 

   m_ServicesList.SetContainersFromSelection();
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::OnClose
//
//  Synopsis:   Closes the modal dialog
//
//-----------------------------------------------------------------------------
void CSelectServicesDialog::OnClose(int result)
{
  EndDialog(m_hWnd, result);
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::DoModal
//
//  Synopsis:   Displays the modal dialog
//
//-----------------------------------------------------------------------------
int CSelectServicesDialog::DoModal()
{
  dspAssert(IsWindow(m_hParent));
  return (int)DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_SELECT_SERVICES_DIALOG),
                             m_hParent, StaticDlgProc, (LPARAM)this);
}


//+----------------------------------------------------------------------------
//
//  Method:     CSelectServicesDialog::GetQueryInfoByScope
//
//  Synopsis:   Called by the Object Picker UI to get a specialized query filter
//
//-----------------------------------------------------------------------------
HRESULT CSelectServicesDialog::GetQueryInfoByScope(IDsObjectPickerScope*,
                                                   PDSQUERYINFO *ppdsqi) 
{ 
   HRESULT hr = S_OK;

   PDSQUERYINFO pQueryInfo = (PDSQUERYINFO)CoTaskMemAlloc(sizeof(DSQUERYINFO));
   if (pQueryInfo)
   {
      ::ZeroMemory(pQueryInfo, sizeof(DSQUERYINFO));
      pQueryInfo->cbSize = sizeof(DSQUERYINFO);
      pQueryInfo->pwzLdapQuery = (PWSTR) CoTaskMemAlloc(sizeof(WCHAR) *
                                     (wcslen(g_pszOPSPNFilter) + 1));
      if (pQueryInfo->pwzLdapQuery)
      {
         wcscpy((PWSTR)pQueryInfo->pwzLdapQuery, g_pszOPSPNFilter);
      }
      else
      {
         hr = E_OUTOFMEMORY;
         CoTaskMemFree(pQueryInfo);
      }
   }
   else
   {
      hr = E_OUTOFMEMORY;
   }

   return hr;
}


//+----------------------------------------------------------------------------
//
//  Method:     CSelectServicesDialog::ApproveObjects
//
//  Synopsis:   Called by the Object Picker UI to approve objects that were
//              found by the supplied query filter
//
//-----------------------------------------------------------------------------
HRESULT CSelectServicesDialog::ApproveObjects(IDsObjectPickerScope* pScope,
                                              IDataObject* pDataObject,
                                              PBOOL bApprovalArray)
{
   HRESULT hrRet = S_OK;
   HRESULT hr = S_OK;

   FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};

   hr = pDataObject->GetData(&fmte, &medium);

   CHECK_HRESULT(hr, return hr);

   PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

   if (!pSelList)
   {
      ReleaseStgMedium(&medium);
      return E_INVALIDARG;
   }

   for (DWORD idx = 0; idx < pSelList->cItems; ++idx)
   {
      // We will default to letting the object pass since we will only
      // show SPNs that actually exist in the UI.  
      bApprovalArray[idx] = TRUE;

      PWSTR pwzADsPath = pSelList->aDsSelection[idx].pwzADsPath;

      if (pwzADsPath)
      {
         CComPtr<IADs> spIADs;
         hr = DSAdminOpenObject(pwzADsPath,
                                IID_IADs,
                                (void**)&spIADs);
         if (FAILED(hr))
         {
            continue;
         }

         CComVariant var;
         hr = spIADs->Get(CComBSTR(g_wzSPN), &var);
         if (hr == E_ADS_PROPERTY_NOT_FOUND)
         {
            bApprovalArray[idx] = FALSE;
            hrRet = S_FALSE;
            continue;
         }

         if (FAILED(hr))
         {
            continue;
         }

         if (var.vt == VT_EMPTY)
         {
            bApprovalArray[idx] = FALSE;
            hrRet = S_FALSE;
            continue;
         }

         if (var.vt == (VT_ARRAY | VT_VARIANT))
         {
            // Unpack the safe array and validate the data

            SAFEARRAY* psa = V_ARRAY(&var);

            if (!psa || 
                psa == (SAFEARRAY*)-1 ||
                ::SafeArrayGetDim(psa) != 1)
            {
               bApprovalArray[idx] = FALSE;
               hrRet = S_FALSE;
               continue;
            }

            VARTYPE vt = VT_EMPTY;
            hr = ::SafeArrayGetVartype(psa, &vt);
            if (FAILED(hr) || vt != VT_VARIANT)
            {
               bApprovalArray[idx] = FALSE;
               hrRet = S_FALSE;
               continue;
            }

            long lower = 0;
            long upper = 0;
  
            hr = ::SafeArrayGetLBound(psa, 1, &lower);
            if (FAILED(hr))
            {
               bApprovalArray[idx] = FALSE;
               hrRet = S_FALSE;
               continue;
            }

            hr = ::SafeArrayGetUBound(psa, 1, &upper);
            if (FAILED(hr))
            {
               bApprovalArray[idx] = FALSE;
               hrRet = S_FALSE;
               continue;
            }

            if (lower >= upper)
            {
               // No values!!!
               bApprovalArray[idx] = FALSE;
               hrRet = S_FALSE;
               continue;
            }
         }
      }
   }

   if (pSelList!=NULL)
   {
       GlobalUnlock(medium.hGlobal);
   }

   ReleaseStgMedium(&medium);

   return hrRet;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSelectServicesDialog::QueryInterface(REFIID riid, void ** ppvObject)
{
  TRACE2(CSelectServicesDialog,QueryInterface);
  if (IID_ICustomizeDsBrowser == riid)
  {
    *ppvObject = (ICustomizeDsBrowser*)this;
  }
  AddRef();
  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CSelectServicesDialog::AddRef(void)
{
    dspDebugOut((DEB_USER2, "CDsGrpMembersPage::AddRef refcount going in %d\n", m_uRefs));
    
    return ++m_uRefs;
}

//+----------------------------------------------------------------------------
//
//  Member:     CSelectServicesDialog::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CSelectServicesDialog::Release(void)
{
  dspDebugOut((DEB_USER2, "CSelectServicesDialog::Release ref count going in %d\n", m_uRefs));
  return --m_uRefs;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\scopedelegation.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       ScopeDelegation.h
//
//  Contents:   Delegation page declarations
//
//  Classes:    
//
//  History:    06-April-2001 JeffJon created
//
//-----------------------------------------------------------------------------

#ifndef __SCOPEDELEGATION_H_
#define __SCOPEDELEGATION_H_

#include "pch.h"
#include "proppage.h"

#include <list>

#ifdef DSADMIN

// Forware Declaration

class CServiceAllowedToDelegate;

typedef std::list<CServiceAllowedToDelegate*> AllowedServicesContainer;

//+----------------------------------------------------------------------------
//
//  Class:      CServiceAllowedToDelegate
//
//  Purpose:    Holds the data for each line in the Service to be delegate list
//
//-----------------------------------------------------------------------------
class CServiceAllowedToDelegate
{
public:
    
   // Constructor

   CServiceAllowedToDelegate() : m_pMasterService(0) {}

   // Destructor

   ~CServiceAllowedToDelegate();

   // Copy and assignment will be allowed

   CServiceAllowedToDelegate(const CServiceAllowedToDelegate& ref);
   
   // operators

   const CServiceAllowedToDelegate& 
   operator=(const CServiceAllowedToDelegate&);

   void 
   Assign(const CServiceAllowedToDelegate& ref);

   bool
   operator==(const CServiceAllowedToDelegate& rhs) const;


   // Initializer

   HRESULT Initialize(PCWSTR pszADSIValue);

   // Accessors

   PCWSTR GetColumn(int column) const;
   PCWSTR GetADSIValue() const { return m_strADSIValue; }

   void SetServiceType(PCWSTR pszServiceType);

   void AddDuplicate(CServiceAllowedToDelegate* pService);

   bool HasDuplicates() const { return !duplicateServices.empty(); }
   void SetDuplicate(CServiceAllowedToDelegate* pMasterService);
   bool IsDuplicate() { return m_pMasterService != 0; }
   CServiceAllowedToDelegate* GetMasterService() { return m_pMasterService; }
   void RemoveDuplicate(CServiceAllowedToDelegate* pService);
   AllowedServicesContainer& GetDuplicates() { return duplicateServices; }

private:

   CStr m_strADSIValue;
   CStr m_strServiceType;
   CStr m_strUserOrComputer;
   CStr m_strPort;
   CStr m_strServiceName;
   CStr m_strRealm;

   CServiceAllowedToDelegate* m_pMasterService;
   AllowedServicesContainer duplicateServices;
};

typedef std::list<CStr*> CStrList;

//+----------------------------------------------------------------------------
//
//  Class:      CFreebieService
//
//  Purpose:    Contains a mapping from aliased SPNs to the service name
//              which they are aliasing
//
//-----------------------------------------------------------------------------
class CFreebieService
{
public:

   // Constructor

   CFreebieService(PCWSTR pszAlias) : m_strAlias(pszAlias) {}

   // Desctructor

   ~CFreebieService() 
   { 
      for (CStrList::iterator itr = m_FreebiesList.begin();
           itr != m_FreebiesList.end();
           ++itr)
      {
         delete *itr;
      }
   }


   const CStrList&
   GetFreebies() { return m_FreebiesList; }

   void
   AddFreebie(PCWSTR pszFreebie) 
   { 
      CStr* pcstrAlias = new CStr(pszFreebie);
      if (pcstrAlias)
      {
         m_FreebiesList.push_back(pcstrAlias);
      }
   }

   PCWSTR
   GetAlias() { return m_strAlias; }

private:

   CStr m_strAlias;
   CStrList m_FreebiesList;
};

typedef std::list<CFreebieService*> FreebiesContainer;


class CSPNListView
{
public:

   // Constructor
   
   CSPNListView() : m_hWnd(0) {}

   // Desctructor

   ~CSPNListView();

   HRESULT 
   Initialize(HWND hwnd, bool bShowDuplicateEntries);

   const AllowedServicesContainer&
   GetSelectedServices() { return m_SelectedServices; }

   const AllowedServicesContainer&
   GetUnSelectedServices() { return m_UnSelectedServices; }

   const AllowedServicesContainer&
   GetAllServices() { return m_AllServices; }

   HWND
   GetHwnd() const { return m_hWnd; }

   UINT
   GetSelectedCount() const { return ListView_GetSelectedCount(m_hWnd); }

   void
   ClearSelectedServices();

   void
   ClearAll();

   void
   SelectAll();

   CServiceAllowedToDelegate* 
   FindService(CServiceAllowedToDelegate* pService, bool& isExactDuplicate);

   int
   AddServiceToUI(CServiceAllowedToDelegate* pService, bool selected = false);

   int 
   AddService(CServiceAllowedToDelegate* pService, bool selected = false);

   void
   AddServices(
      const AllowedServicesContainer& servicesToAdd, 
      bool selected = false,
      bool toUIOnly = false);

   void
   RemoveSelectedServices();

   void
   SetContainersFromSelection();

   void
   SetShowDuplicateEntries(bool bShowDuplicates);

private:

   void
   ClearUnSelectedServices();

   HWND m_hWnd;

   // If this is true all SPNs will be shown even if they are
   // a duplicate in another form. If it is false, the duplicates
   // will be added to a list of duplicates for the entry that is 
   // shown.

   bool m_bShowDuplicateEntries;

  // The dialog caller must clean up this container
  // and anything it contains

  AllowedServicesContainer m_SelectedServices;

  // The contents of these containers will be maintained
  // by this class

  AllowedServicesContainer m_UnSelectedServices;
  AllowedServicesContainer m_AllServices;
};

typedef enum
{
   SCOPE_DELEGATION_COMPUTER,
   SCOPE_DELEGATION_USER
} SCOPE_DELEGATION_TYPE;

HRESULT CreateUserDelegationPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                                 DWORD, const CDSSmartBasePathsInfo& basePathsInfo,
                                 HPROPSHEETPAGE *);

HRESULT CreateComputerDelegationPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                                     DWORD, const CDSSmartBasePathsInfo& basePathsInfo,
                                     HPROPSHEETPAGE *);

//+----------------------------------------------------------------------------
//
//  Class:      CDsScopeDelegationPage
//
//  Purpose:    property page object class for the computer and user delegaion page.
//
//-----------------------------------------------------------------------------
class CDsScopeDelegationPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsScopeDelegationPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                           DWORD dwFlags, SCOPE_DELEGATION_TYPE scopeDelegationType);
    ~CDsScopeDelegationPage(void);

    //
    //  Instance specific wind proc
    //
    virtual INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    void Init(PWSTR pwzADsPath, 
              PWSTR pwzClass, 
              const CDSSmartBasePathsInfo& basePathsInfo,
              bool hasSPNs = true,
              bool isTrusted = true);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	 LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(void);

    void OnUpdateRadioSelection();
    void OnAddServices();
    void OnRemoveServices();
    void OnExpandCheck();
    void GetFreebiesList();
    void InitializeListColumns();
    void SetPageTextForType();
    void LoadDataFromObject();
    void SetUIFromData();
    void ResetUIFromData();
    void AddServicesToListViewFromData();

    HWND m_hList;
    SCOPE_DELEGATION_TYPE m_scopeDelegationType;

    BOOL m_fUACWritable;
    BOOL m_fA2D2Writable;

    DWORD m_oldUserAccountControl;
    DWORD m_newUserAccountControl;
    bool  m_bA2D2Dirty;

    bool m_bContainsSPNs;
    bool m_bIsTrustedForDelegation;

    CSPNListView m_ServicesList;
    FreebiesContainer m_FreebiesList;
};


//+----------------------------------------------------------------------------
//
//  Class:      CSelectServicesDialog
//
//  Purpose:    Dialog box that allows the admin to select services from
//              users or computers
//
//-----------------------------------------------------------------------------
class CSelectServicesDialog : public ICustomizeDsBrowser
{
public:
  CSelectServicesDialog(PCWSTR pszDC, HWND hParent, const FreebiesContainer& freebies);

  ~CSelectServicesDialog() {}

   //
   // IUknown methods
   //
   STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
   STDMETHOD_(ULONG, AddRef)(void);
   STDMETHOD_(ULONG, Release)(void);

   //
   // ICustomizeDsBrowser methods 
   //
   STDMETHOD(Initialize)(THIS_
                       HWND         hwnd,
                       PCDSOP_INIT_INFO pInitInfo,
                       IBindHelper *pBindHelper) { return S_OK; }

   STDMETHOD(GetQueryInfoByScope)(THIS_
             IDsObjectPickerScope *pDsScope,
             PDSQUERYINFO *ppdsqi);

   STDMETHOD(AddObjects)(THIS_
             IDsObjectPickerScope *pDsScope,
             IDataObject **ppdo) { return E_NOTIMPL; }

   STDMETHOD(ApproveObjects)(THIS_
             IDsObjectPickerScope*,
             IDataObject*,
             PBOOL);

   STDMETHOD(PrefixSearch)(THIS_
             IDsObjectPickerScope *pDsScope,
             PCWSTR pwzSearchFor,
             IDataObject **pdo) { return E_NOTIMPL; }

   STDMETHOD_(PSID, LookupDownlevelName)(THIS_
              PCWSTR) { return NULL; }


  static INT_PTR CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

  virtual int 
  DoModal();
  
  virtual BOOL 
  OnInitDialog(HWND hDlg);
  
  virtual void 
  OnClose(int result);
  
  virtual void 
  OnOK();
  
  virtual void 
  ListItemClick(LPNMHDR pnmh);
  
  void 
  OnSelectAll();
  
  void 
  OnGetNewProvider();
  
  void 
  ProcessResults(IDataObject* pdoSelections);

  bool 
  AddNewServiceObjectToList(PCWSTR pszSPN);

  const AllowedServicesContainer& 
  GetSelectedServices() { return m_ServicesList.GetSelectedServices(); }

  void
  ClearSelectedServices() { m_ServicesList.ClearSelectedServices(); }

  HWND             m_hWnd;

private:
  HWND             m_hParent;

  CSPNListView m_ServicesList;
  const FreebiesContainer& m_FreebiesList;

  CStr m_strDC;

  // Reference counting
  ULONG m_uRefs;
};


#endif // DSADMIN

#endif // __SCOPEDELEGATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\siterepl.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       siterepl.h
//
//  Contents:   Site and Replication object property pages header
//
//  History:    16-Sep-97 JonN templated from computer.h
//
//-----------------------------------------------------------------------------

#ifndef _SITEREPL_H_
#define _SITEREPL_H_


HRESULT
ScheduleChangeBtn_11_Default(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
ScheduleChangeBtn_FF_Default(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
#ifdef CUSTOM_SCHEDULE
HRESULT
ScheduleChangeCheckbox(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
#endif
//
// nTDSDSAAndDomainChangeBtn also updates the Replicated Domain readonly edit field in IDC_EDIT1
//
HRESULT
nTDSDSAChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
nTDSDSAAndDomainChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
FRSMemberInReplicaChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
FRSAnyMemberChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
ComputerChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
nTDSConnectionOptions(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
SiteExtractSubnetList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);

HRESULT
CreateDsOrFrsConnectionPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                      PWSTR pwzADsPath, LPWSTR pwzClass, HWND hNotifyObj,
                      DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
                      HPROPSHEETPAGE * phPage);

#endif // _SITEREPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\siterepl.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       siterepl.cxx
//
//  Contents:   Site and Replication object functionality.
//
//  History:    16-Sep-97 JonN templated from computer.h
//              06-Nov-97 JonN new SCHEDULE structure
//              27-Aug-98 JonN split schedule.cxx from siterepl.cxx
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "siterepl.h"

#ifdef DSADMIN

#include "qrybase.h" // CDSSearch
#include "pcrack.h"  // CPathCracker


//+----------------------------------------------------------------------------
//
//  Function:   ServerChangeBtn and ComputerChangeBtn
//
//  Synopsis:   Handle the Change Server and Change Computer buttons.
//
//  Change Server requires IDC_SERVER_EDIT and IDC_SITE_EDIT.
//
//  Change Computer requires IDC_COMPUTER_EDIT and IDC_DOMAIN_EDIT.
//
//-----------------------------------------------------------------------------

#define BREAK_IF_FAIL if ( FAILED(hr) ) { ASSERT(FALSE); break; }
#define RETURN_IF_FAIL if ( FAILED(hr) ) { ASSERT(FALSE); return hr; }


//
// JonN 3/8/99: check for LostAndFound[Config]
// only sets *pfIsLostAndFound to true, never to false
//
HRESULT IsLostAndFound( IN HWND hwnd, IN LPWSTR pwszDN, OUT bool* pfIsLostAndFound )
{
    PWSTR pwszCanonicalName = NULL;
    HRESULT hr = CrackName( pwszDN, &pwszCanonicalName, GET_OBJ_CAN_NAME, hwnd );
    RETURN_IF_FAIL;
    LPTSTR pszCanonicalNameWithoutDomain = wcschr( pwszCanonicalName, L'/' );
    if (pszCanonicalNameWithoutDomain)
    {
        pszCanonicalNameWithoutDomain++;
        if ( !_wcsnicmp( pszCanonicalNameWithoutDomain,
                         L"LostAndFound/", 13 ) )
            *pfIsLostAndFound = true;
        else if ( !_wcsnicmp( pszCanonicalNameWithoutDomain,
                              L"Configuration/LostAndFoundConfig/", 33 ) )
            *pfIsLostAndFound = true;
    }
    LocalFreeStringW(&pwszCanonicalName);

    // JonN 12/5/01 432074 DSAdmin: Tombstone objects are shown in the UI
    if (!*pfIsLostAndFound)
    {
        if (   DsIsMangledDn( pwszDN,
                              DS_MANGLE_OBJECT_RDN_FOR_DELETION )
            || DsIsMangledDn( pwszDN,
                              DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT ) )
        {
            *pfIsLostAndFound = true;
        }
    }

    return S_OK;
}

HRESULT ExtractRDNs(
    IN LPWSTR pwszDN,
    IN long lnElementIndex1,
    OUT BSTR* pbstrRDN1,
    IN long lnElementIndex2 = 0,
    OUT BSTR* pbstrRDN2 = NULL );

HRESULT ExtractRDNs(
    IN LPWSTR pwszDN,
    IN long lnElementIndex1,
    OUT BSTR* pbstrRDN1,
    IN long lnElementIndex2,
    OUT BSTR* pbstrRDN2 )
{
    CPathCracker pathcracker;
    HRESULT hr = pathcracker.Set( CComBSTR(pwszDN), ADS_SETTYPE_DN );
    RETURN_IF_FAIL;
    hr = pathcracker.SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
    RETURN_IF_FAIL;
    // CODEWORK escaped mode off?
    if (NULL != pbstrRDN1)
    {
        hr = pathcracker.GetElement( lnElementIndex1, pbstrRDN1 );
        RETURN_IF_FAIL;
    }
    if (NULL != pbstrRDN2)
    {
        hr = pathcracker.GetElement( lnElementIndex2, pbstrRDN2 );
        RETURN_IF_FAIL;
    }

    return S_OK;
}

HRESULT ExtractComputerAndDomainName(
    IN LPWSTR pwszDN,
    OUT BSTR* pbstrComputerName,
    OUT BSTR* pbstrDomainName,
    IN HWND hwndDlg )
{
    *pbstrComputerName = NULL;
    *pbstrDomainName = NULL;
    if ( NULL == pwszDN || L'\0' == *pwszDN )
        return S_OK;

    HRESULT hr = ExtractRDNs( pwszDN, 0, pbstrComputerName );
    RETURN_IF_FAIL;
    PWSTR pwszDomainName = NULL;
    hr = CrackName( pwszDN, &pwszDomainName, GET_DNS_DOMAIN_NAME, hwndDlg );
    RETURN_IF_FAIL;
    *pbstrDomainName = ::SysAllocString( pwszDomainName );
    ASSERT( NULL != *pbstrDomainName );
    LocalFreeStringW(&pwszDomainName);

    return S_OK;
}

typedef struct _EXTRACT_TWO_PARAM
{
    int nIDDlgItem1;
    long lnElementIndex1;
    int nIDDlgItem2;
    long lnElementIndex2;
} EXTRACT_TWO_PARAM, *PEXTRACT_TWO_PARAM;

void DisplayTwoFields(
    IN CDsPropPageBase * pPage,
    IN const EXTRACT_TWO_PARAM* pe2,
    bool fInvalid,
    bool fMultivalued,
    IN LPWSTR pwszField1 = NULL,
    IN LPWSTR pwszField2 = NULL );

void DisplayTwoFields(
    IN CDsPropPageBase * pPage,
    IN const EXTRACT_TWO_PARAM* pe2,
    bool fInvalid,
    bool fMultivalued,
    IN LPWSTR pwszField1,
    IN LPWSTR pwszField2 )
{
    if (NULL == pPage || NULL == pe2)
    {
        ASSERT(FALSE);
        return;
    }

    LPWSTR pszMsg = NULL;
    if (fInvalid || fMultivalued)
    {
        if ( !LoadStringToTchar (
                (fMultivalued) ? IDS_MULTIVALUED : IDS_INVALID,
                &pszMsg) )
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return;
        }
        pwszField1 = pszMsg;
        pwszField2 = pszMsg;
    }

    if (0 != pe2->nIDDlgItem1)
    {
        SetDlgItemText( pPage->GetHWnd(), pe2->nIDDlgItem1, pwszField1 );
    }
    if (0 != pe2->nIDDlgItem2)
    {
        SetDlgItemText( pPage->GetHWnd(), pe2->nIDDlgItem2, pwszField2 );
    }

    if ( NULL != pszMsg )
        delete [] pszMsg;
}

HRESULT UpdateComputerAndDomainFields(
    IN CDsPropPageBase * pPage,
    IN LPWSTR pwszDN,
    IN PVOID pvDNUpdateParam,
    bool fInvalid,
    bool fMultivalued)
{
    PEXTRACT_TWO_PARAM pe2 = reinterpret_cast<PEXTRACT_TWO_PARAM>(pvDNUpdateParam);
    if (fInvalid || fMultivalued)
    {
        DisplayTwoFields( pPage, pe2, fInvalid, fMultivalued );
        return S_OK;
    }
    CComBSTR sbstrComputerName;
    CComBSTR sbstrDomainName;
    HRESULT hr = ExtractComputerAndDomainName(
        pwszDN, &sbstrComputerName, &sbstrDomainName, pPage->GetHWnd() );
    RETURN_IF_FAIL;
    DisplayTwoFields( pPage, pe2, false, false, sbstrComputerName, sbstrDomainName );
    return hr;
}


HRESULT UpdateConfigurationRDNFields(
    IN CDsPropPageBase * pPage,
    IN LPWSTR pwszDN,
    IN PVOID pvDNUpdateParam,
    bool fInvalid,
    bool fMultivalued)
{
    PEXTRACT_TWO_PARAM pe2 = reinterpret_cast<PEXTRACT_TWO_PARAM>(pvDNUpdateParam);
    if (fInvalid || fMultivalued)
    {
        DisplayTwoFields( pPage, pe2, fInvalid, fMultivalued );
        return S_OK;
    }

    CComBSTR sbstrRDN1;
    CComBSTR sbstrRDN2;
    if (NULL != pwszDN)
    {
        HRESULT hr = ExtractRDNs( pwszDN,
                                  pe2->lnElementIndex1,
                                  (0 == pe2->nIDDlgItem1) ? NULL : &sbstrRDN1,
                                  pe2->lnElementIndex2,
                                  (0 == pe2->nIDDlgItem2) ? NULL : &sbstrRDN2 );
        RETURN_IF_FAIL;
    }

    DisplayTwoFields( pPage, pe2, false, false, sbstrRDN1, sbstrRDN2 );

    return S_OK;
}

HRESULT UpdateNamingContextFields(
    IN CDsPropPageBase* pPropPage, IN LPWSTR pwszFromServer, bool fInvalid );

HRESULT UpdateNTDSDSAAndDomainFields(
    IN CDsPropPageBase * pPage,
    IN LPWSTR pwszDN,
    IN PVOID pvDNUpdateParam,
    bool fInvalid,
    bool fMultivalued)
{
    HRESULT hr = UpdateConfigurationRDNFields( pPage,
                                               pwszDN,
                                               pvDNUpdateParam,
                                               fInvalid,
                                               fMultivalued);
    if ( SUCCEEDED(hr) )
        hr = UpdateNamingContextFields( pPage, pwszDN, fInvalid || fMultivalued );
    return hr;
}

HRESULT DoPickComputer( IN CDsPropPageBase * pPage, OUT BSTR* pbstrADsPath, PVOID )
{
    return DSPROP_PickComputer( pPage->GetHWnd(), pPage->GetObjPathName(), pbstrADsPath );
}

HRESULT DoPickNTDSDSA( IN CDsPropPageBase * pPage, OUT BSTR* pbstrADsPath, PVOID )
{
    // We extract the path to the Sites container from the path to
    // this object
    ASSERT( NULL != pPage );
    CComBSTR sbstr;
    HRESULT hr = DSPROP_TweakADsPath( pPage->GetObjPathName(), 5, NULL, &sbstr );
    RETURN_IF_FAIL;
    return DSPROP_PickNTDSDSA( pPage->GetHWnd(), sbstr, pbstrADsPath );
}

HRESULT DoPickNTDSDSARestricted( IN CDsPropPageBase * pPage, OUT BSTR* pbstrADsPath, PVOID )
{
    ASSERT( pbstrADsPath);
    if (!pbstrADsPath)
    {
      return S_FALSE;
    }
    
    HRESULT hr = DoPickNTDSDSA( pPage, pbstrADsPath, 0 );
    RETURN_IF_FAIL;

    // JonN 12/5/01 449718
    if (S_FALSE == hr)
    {
        return S_FALSE;
    }

    // Idea: if the pick result is the parent of the object we're editing,
    // then reject it.  That would create a circular reference, as the
    // fromServer would be the same as the "to server".
    // NTRAID#NTBUG9-298682-2001/05/15-sburns
    
    // crack the result path to get the DN of the replicate-from server
       
    CPathCracker pathcracker;
    hr = pathcracker.Set( *pbstrADsPath, ADS_SETTYPE_FULL );
    RETURN_IF_FAIL;
    CComBSTR bstrReplicateFromDn;
    hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &bstrReplicateFromDn );
    RETURN_IF_FAIL;
    
    // crack the connection path to get the DN of the connection

    hr = pathcracker.Set( CComBSTR(pPage->GetObjPathName()), ADS_SETTYPE_FULL );
    RETURN_IF_FAIL;

    // remove a leaf to get the parent DN of the connection
    
    hr = pathcracker.RemoveLeafElement();
    RETURN_IF_FAIL;

    CComBSTR bstrParentDn;
    hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &bstrParentDn );
    RETURN_IF_FAIL;

    // compare the two DNs. If they're the same, then gripe.

    if (_wcsicmp(bstrParentDn, bstrReplicateFromDn) == 0)
    {
      // it's a bird, it's a plane, it's...
      
      SuperMsgBox(
         pPage->GetHWnd(),
         IDS_SITE_REPL_CIRCULAR_REFERENCE,
         0,
         MB_ICONWARNING,
         0,
         NULL,
         0,
         FALSE,
         __FILE__,
         __LINE__);
         
      // S_FALSE will cause the pick result to be ignored.
         
      hr = S_FALSE;
    }
    
    return hr;
}

HRESULT DoPickFrsMember( IN CDsPropPageBase * pPage, OUT BSTR* pbstrADsPath, PVOID pvDNChangeParam )
{
    LPWSTR lpszObjPathName = reinterpret_cast<LPWSTR>(pvDNChangeParam);
    ASSERT( NULL != pPage );
    HRESULT hr = S_OK;

    CComBSTR sbstr = lpszObjPathName;
    if (NULL != lpszObjPathName)
    {
       // remove the two leaf elements from the path
        hr = DSPROP_RemoveX500LeafElements( 2, &sbstr );
        RETURN_IF_FAIL;
    }

    return DSPROP_DSQuery(
        pPage->GetHWnd(),
        sbstr,
        const_cast<CLSID*>(&CLSID_DsFindFrsMembers),
        pbstrADsPath );
}

typedef HRESULT (*PFN_DNUpdate)(
    IN CDsPropPageBase * pPage,
    IN LPWSTR pwszDN,
    PVOID pvDNUpdateParam,
    bool fInvalid,
    bool fMultivalued);
typedef HRESULT (*PFN_DNChange)(
    IN CDsPropPageBase * pPage,
    OUT BSTR* pbstrADsPath,
    PVOID pvDNChangeParam);

HRESULT
DNChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp,
                  PFN_DNUpdate pfnDNUpdate, PVOID pvDNUpdateParam,
                  PFN_DNChange pfnDNChange, PVOID pvDNChangeParam)
{
    TRACE_FUNCTION(DNChangeBtn);

    HRESULT hr = S_OK;

    switch (DlgOp)
    {
    case fObjChanged:
        if ( NULL != pAttrData && NULL != pAttrData->pVoid )
        {
            SysFreeString( (BSTR)pAttrData->pVoid );
            pAttrData->pVoid = NULL;
        }
        // fall through
    case fInit:
    {
        // JonN 7/2/99: disable if attribute not writable
        if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);

        bool fInvalid = false;
        bool fMultivalued = false;
        if (NULL == pAttrInfo ||
            IsBadReadPtr(pAttrInfo,sizeof(ADS_ATTR_INFO)) )
        {
            // attribute is not set
        }
        else
        if (1 != pAttrInfo->dwNumValues ||
            NULL == pAttrInfo->pADsValues ||
            IsBadReadPtr(pAttrInfo->pADsValues,sizeof(ADSVALUE)) ||
            ADSTYPE_DN_STRING != pAttrInfo->pADsValues[0].dwType )
        {
            if (2 <= pAttrInfo->dwNumValues)
                fMultivalued = true; // attribute is multivalued
            if (1 <= pAttrInfo->dwNumValues)
                fInvalid = true; // attribute is multivalued or of wrong type
        }
        else
        if ( FAILED( hr = IsLostAndFound( pPage->GetHWnd(),
                                          pAttrInfo->pADsValues[0].DNString,
                                          &fInvalid ) ) )
        {
            break;
        }
        else
        if ( !fInvalid )
        {
            pAttrData->pVoid = reinterpret_cast<LPARAM>(SysAllocString( pAttrInfo->pADsValues[0].DNString ));
            CHECK_NULL(pAttrData->pVoid, return E_OUTOFMEMORY);
        }
        ASSERT( NULL != pfnDNUpdate );
        hr = (*pfnDNUpdate)( pPage,
                             (ADS_DN_STRING)pAttrData->pVoid,
                             pvDNUpdateParam,
                             fInvalid,
                             fMultivalued );
        if ( FAILED(hr) )
            break; // no assertion
    }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        ASSERT( pAttrInfo != NULL );
        if (NULL == pAttrData || NULL == pAttrData->pVoid)
        {
            // If the DN attribute was not set and the user hasn't
            // changed it from the default, then there is no need to write
            // anything.
            //
            pAttrInfo->dwNumValues = 0;
            pAttrInfo->pADsValues = NULL;
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
            pADsValue->dwType = pAttrInfo->dwADsType;
            PWSTR pwsz = NULL;
            if ( !AllocWStr( reinterpret_cast<ADS_DN_STRING>(pAttrData->pVoid), &pwsz ) )
            {
                delete pADsValue; // JonN 03/07/00: PREFIX 49354
                hr = E_OUTOFMEMORY;
                break;
            }
            pADsValue->DNString = pwsz;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        }
        break;

    case fOnCommand:
        if (lParam == BN_CLICKED)
        {
            CComBSTR sbstrTargetPath;
            ASSERT( NULL != pfnDNChange );
            hr = (*pfnDNChange)( pPage, &sbstrTargetPath, pvDNChangeParam );
            if (S_FALSE == hr)
                break;

            CPathCracker pathcracker;
            hr = pathcracker.Set( sbstrTargetPath, ADS_SETTYPE_FULL );
            RETURN_IF_FAIL;
            sbstrTargetPath.Empty();
            hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrTargetPath );
            RETURN_IF_FAIL;

            if ( NULL != pAttrData && NULL != pAttrData->pVoid )
            {
                SysFreeString( (BSTR)pAttrData->pVoid );
            }
            pAttrData->pVoid = reinterpret_cast<LPARAM>(sbstrTargetPath.Detach());
            ASSERT( NULL != pfnDNUpdate );
            bool fInvalid = false;
            hr = IsLostAndFound( pPage->GetHWnd(),
                                 (ADS_DN_STRING)pAttrData->pVoid,
                                 &fInvalid );
            RETURN_IF_FAIL;
            hr = (*pfnDNUpdate)( pPage,
                                 (ADS_DN_STRING)pAttrData->pVoid,
                                 pvDNUpdateParam,
                                 fInvalid,
                                 false );
            BREAK_IF_FAIL;
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fOnDestroy:
        if ( NULL != pAttrData && NULL != pAttrData->pVoid )
        {
            SysFreeString( (BSTR)pAttrData->pVoid );
            pAttrData->pVoid = NULL;
        }

        break;
    }

    return hr;
}


const EXTRACT_TWO_PARAM g_e2pNTDSDSA = {
    IDC_SERVER_EDIT,
    1,
    IDC_SITE_EDIT,
    3
};

const EXTRACT_TWO_PARAM g_e2pNTFRSMemberInReplica = {
    IDC_SERVER_EDIT,
    0,
    0,
    0
};
const EXTRACT_TWO_PARAM g_e2pNTFRSMemberAny = {
    IDC_SERVER_EDIT,
    0,
    IDC_SITE_EDIT,
    1
};

const EXTRACT_TWO_PARAM g_e2pComputer = {
    IDC_COMPUTER_EDIT,
    0,
    IDC_DOMAIN_EDIT,
    0
};

HRESULT
nTDSDSAChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp)
{
    return DNChangeBtn(pPage,pAttrMap,pAttrInfo,lParam,pAttrData,DlgOp,
        UpdateConfigurationRDNFields, (PVOID)(&g_e2pNTDSDSA),
        DoPickNTDSDSA, NULL );
}

HRESULT
nTDSDSAAndDomainChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp)
{
    return DNChangeBtn(pPage,pAttrMap,pAttrInfo,lParam,pAttrData,DlgOp,
        UpdateNTDSDSAAndDomainFields, (PVOID)(&g_e2pNTDSDSA),
        DoPickNTDSDSARestricted, NULL );
}

HRESULT
FRSMemberInReplicaChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp)
{
    return DNChangeBtn(pPage,pAttrMap,pAttrInfo,lParam,pAttrData,DlgOp,
        UpdateConfigurationRDNFields, (PVOID)(&g_e2pNTFRSMemberInReplica),
        DoPickFrsMember, (PVOID)pPage->GetObjPathName() );
}

HRESULT
FRSAnyMemberChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp)
{
    return DNChangeBtn(pPage,pAttrMap,pAttrInfo,lParam,pAttrData,DlgOp,
        UpdateConfigurationRDNFields, (PVOID)(&g_e2pNTFRSMemberAny),
        DoPickFrsMember, NULL );
}

HRESULT
ComputerChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                  DLG_OP DlgOp)
{
    return DNChangeBtn(pPage,pAttrMap,pAttrInfo,lParam,pAttrData,DlgOp,
        UpdateComputerAndDomainFields, (PVOID)(&g_e2pComputer),
        DoPickComputer, NULL );
}

HRESULT HrBuildADsValueArray(
    OUT PADSVALUE* ppADsValue,
    IN CStrListItem* pList,
    IN int nItems
    )
{
    HRESULT hr = S_OK;
    *ppADsValue = new ADSVALUE[nItems];
    CHECK_NULL(*ppADsValue, return E_OUTOFMEMORY);
    CStrListItem* pItem = pList;
    for (int i = 0; i < nItems; i++, pItem = pItem->pnext)
    {
        if (NULL == pItem)
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
        (*ppADsValue)[i].dwType = ADSTYPE_DN_STRING;
        if ( !AllocWStr(
            const_cast<LPTSTR>((LPCTSTR)pItem->str),
            &((*ppADsValue)[i].DNString) ) )
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    ASSERT( NULL == pItem );
    return hr;
}


/*
JonN 04/04/00
90719: S&S UI should add/remove individual values from multi-valued attributes

We prepend the character 'I' or 'O' to each ItemData, corresponding to
whether the item started in the IN or OUT listbox.  Later, at fApply time,
we only add or remove values, rather than resetting the attribute.
*/
typedef enum _WHICHLB
{
    WHICHLB_IN = 0,
    WHICHLB_OUT,
    WHICHLB_NONE
} WHICHLB;

int AddItemToListbox(
    IN HWND hwnd,
    IN LPCTSTR lpszDN,
    IN WHICHLB whichlb = WHICHLB_NONE,
    OUT int* piIndex = NULL );

int AddItemToListbox(
    IN HWND hwnd,
    IN LPCTSTR lpszDN,
    IN WHICHLB whichlb,
    OUT int* piIndex )
{
    CComBSTR sbstrRDN;
    HRESULT hr = DSPROP_RetrieveRDN( lpszDN, &sbstrRDN );
    RETURN_IF_FAIL;
    int iIndex = ListBox_AddString( hwnd, sbstrRDN );
    if ( 0 > iIndex )
    {
        hr = E_FAIL;
        RETURN_IF_FAIL;
    }
    ASSERT( !!sbstrRDN );
    BSTR bstr = NULL;
    if (WHICHLB_NONE != whichlb)
    {
        bstr = ::SysAllocStringLen( NULL, static_cast<UINT>(1+wcslen(lpszDN) ));
        bstr[0] = (WHICHLB_IN == whichlb) ? TEXT('I') : TEXT('O');
        wcscpy( bstr+1, lpszDN );
    } else {
        bstr = ::SysAllocString( lpszDN );
    }
    int iRetval = ListBox_SetItemData(
        hwnd,
        iIndex,
        bstr ); // now don't free this
    ASSERT( LB_ERR != iRetval );
    if (piIndex != NULL)
        *piIndex = iIndex;
    return S_OK;
}

HRESULT AddItemsToListbox(
    IN HWND hwnd,
    IN PADS_ATTR_INFO pAttrInfo,
    IN WHICHLB whichlb = WHICHLB_NONE
    );

HRESULT AddItemsToListbox(
    IN HWND hwnd,
    IN PADS_ATTR_INFO pAttrInfo,
    IN WHICHLB whichlb
    )
{
    ASSERT( NULL != hwnd );

    if (NULL == pAttrInfo)
        return S_OK;

    HRESULT hr = S_OK;
    for (DWORD i = 0; i < pAttrInfo->dwNumValues; i++)
    {
        ASSERT( ADSTYPE_DN_STRING == pAttrInfo->pADsValues[i].dwType );
        hr = AddItemToListbox( hwnd, pAttrInfo->pADsValues[i].DNString, whichlb );
        RETURN_IF_FAIL;
    }
    DSPROP_HScrollStringListbox( hwnd );
    return hr;
}

// release itemdata associated with listbox items
// caller should call DSPROP_HScrollStringListbox if listbox is not being released
void DSPROP_Duelling_ClearListbox( HWND hwndListbox )
{
    ASSERT( NULL != hwndListbox );
    while (0 < ListBox_GetCount( hwndListbox ))
    {
        BSTR bstrFirstItem = (BSTR)ListBox_GetItemData( hwndListbox, 0 );
        if (NULL != bstrFirstItem)
            ::SysFreeString( bstrFirstItem );
        int iRetval = ListBox_DeleteString( hwndListbox, 0 );
        ASSERT( LB_ERR != iRetval );
    }
}

HRESULT HrGetItemsFromListbox(
    IN HWND hwnd,
    OUT CStrListItem** pplistDNs,
    OUT int& cDNs,
    IN WHICHLB whichlbFilter = WHICHLB_NONE );

// only retrieve entries from specified LB if any
HRESULT HrGetItemsFromListbox(
    IN HWND hwnd,
    OUT CStrListItem** pplistDNs,
    OUT int& cDNs,
    IN WHICHLB whichlbFilter )
{
    ASSERT( NULL != hwnd && NULL != pplistDNs && NULL == *pplistDNs );

    cDNs = 0;
    int cItems = ListBox_GetCount( hwnd );
    if (cItems < 0)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }

    // build list of DNs of selected items
    for (int i = cItems-1; i >= 0; i--)
    {
        BSTR bstrDN = (BSTR)ListBox_GetItemData( hwnd, i );
        ASSERT( NULL != bstrDN );

        if (WHICHLB_IN == whichlbFilter)
        {
            if (L'I' != bstrDN[0])
                continue;
        } else if (WHICHLB_OUT == whichlbFilter) {
            if (L'O' != bstrDN[0])
                continue;
        }
        bstrDN++;
        cDNs++;

        CStrListItem* pNewItem = new CStrListItem;
        if (NULL == pNewItem)
        {
            ASSERT(FALSE);
            return E_OUTOFMEMORY;
        }
        pNewItem->str = bstrDN;
        pNewItem->pnext = *pplistDNs;
        *pplistDNs = pNewItem;
    }
    return S_OK;
}

void MarkItemsFromListbox(
    IN HWND hwnd,
    IN WHICHLB whichlbFilter )
{
    ASSERT( NULL != hwnd );

    int cItems = ListBox_GetCount( hwnd );
    if (cItems < 0)
    {
        ASSERT(FALSE);
        return;
    }

    for (int i = cItems-1; i >= 0; i--)
    {
        BSTR bstrDN = (BSTR)ListBox_GetItemData( hwnd, i );
        if ( NULL != bstrDN && L'\0' != bstrDN[0] )
        {
            bstrDN[0] = (WHICHLB_IN == whichlbFilter)
                ? TEXT('I')
                : TEXT('O');
        } else {
            ASSERT(FALSE);
        }
    }
}

void MoveSelectedItems( IN HWND hwndFrom, IN HWND hwndTo )
{
    ASSERT( NULL != hwndFrom && NULL != hwndTo );

    // get list of indexes to selected items
    int cSelectedItems = ListBox_GetSelCount( hwndFrom );
    if (cSelectedItems <= 0)
        return;
    int* pSelectedItems = new int[cSelectedItems];
    if (!pSelectedItems)
    {
      ASSERT(FALSE);
      return;
    }

    int nRetval = ListBox_GetSelItems( hwndFrom, cSelectedItems, pSelectedItems );
    if ( nRetval != cSelectedItems )
    {
        delete[] pSelectedItems;
        pSelectedItems = 0;
        ASSERT(FALSE);
        return;
    }

    // move items from one listbox to another
    for (int iIndexIntoSelectedItemArray = cSelectedItems-1;
         iIndexIntoSelectedItemArray >= 0;
         iIndexIntoSelectedItemArray--)
    {
        int iSelectedItem = pSelectedItems[iIndexIntoSelectedItemArray];
        BSTR bstrItem = (BSTR)ListBox_GetItemData( hwndFrom, iSelectedItem );
        ASSERT( NULL != bstrItem );
        int iNewIndex = 0;
        HRESULT hr = AddItemToListbox( hwndTo, bstrItem, WHICHLB_NONE, &iNewIndex );
        ASSERT( SUCCEEDED(hr) );
        nRetval = ListBox_SelItemRange( hwndTo, true, iNewIndex, iNewIndex );
        ASSERT( LB_ERR != nRetval );
        nRetval = ListBox_DeleteString( hwndFrom, iSelectedItem );
        ASSERT( LB_ERR != nRetval );
    }
    DSPROP_HScrollStringListbox( hwndFrom );
    DSPROP_HScrollStringListbox( hwndTo );

    delete[] pSelectedItems;
    pSelectedItems = 0;
}

// enable/disable Add and Remove buttons
void DSPROP_Duelling_UpdateButtons( HWND hwndDlg, int nAnyCtrlid )
{
    int nOutCtrlid = nAnyCtrlid - (nAnyCtrlid%4);
    HWND hwndOutListbox   = ::GetDlgItem(hwndDlg,nOutCtrlid  );
    HWND hwndAddButton    = ::GetDlgItem(hwndDlg,nOutCtrlid+1);
    HWND hwndRemoveButton = ::GetDlgItem(hwndDlg,nOutCtrlid+2);
    HWND hwndInListbox    = ::GetDlgItem(hwndDlg,nOutCtrlid+3);
    ASSERT( NULL != hwndOutListbox
         && NULL != hwndAddButton
         && NULL != hwndRemoveButton
         && NULL != hwndInListbox );
    int cSelectedItemsOut = ListBox_GetSelCount( hwndOutListbox );
    int cSelectedItemsIn  = ListBox_GetSelCount( hwndInListbox );
    (void) ::EnableWindow( hwndAddButton,    (cSelectedItemsOut > 0) );
    (void) ::EnableWindow( hwndRemoveButton, (cSelectedItemsIn  > 0) );
}

bool FIsInDNList(
    IN LPCWSTR lpcszDN,
    IN PADS_ATTR_INFO pAttrInfo
    )
{
    ASSERT( NULL != lpcszDN && NULL != pAttrInfo );
    for (DWORD i = 0; i < pAttrInfo->dwNumValues; i++)
    {
        ASSERT( ADSTYPE_DN_STRING == pAttrInfo->pADsValues[i].dwType );
        if ( !lstrcmpi( lpcszDN, pAttrInfo->pADsValues[i].DNString ) )
        {
            return true;
        }
    }
    return false;
}


bool DSPROP_BSTR_BLOCK__SetCount( DSPROP_BSTR_BLOCK& block, int cItems )
{
    ASSERT( 0 <= cItems );
    if ( NULL != block.m_abstrItems )
    {
        for (int iItem = 0; iItem < block.QueryCount(); iItem++)
        {
            if ( NULL != block[iItem] )
                ::SysFreeString( block[iItem] );
        }
        ::SysFreeString( (BSTR)(block.m_abstrItems) );
        block.m_abstrItems = NULL;
    }
    block.m_cItems = 0;
    if ( 0 < cItems )
    {
        block.m_abstrItems =
            (BSTR*)::SysAllocStringByteLen( NULL, cItems * sizeof(BSTR) );
        if ( NULL == block.m_abstrItems )
            return false;
        ::ZeroMemory( block.m_abstrItems, cItems * sizeof(BSTR) );
        block.m_cItems = cItems;
    }
    return true;
}

BSTR& DSPROP_BSTR_BLOCK__Reference( DSPROP_BSTR_BLOCK& block, int iItem )
{
    ASSERT( 0 <= iItem && block.QueryCount() > iItem );
    return block.m_abstrItems[iItem];
}


// Enumerate the items of class lpcwszTargetDesiredClass in container
// lpcwszADsPathDirectory, except for those in pAttrInfoExclusions.
HRESULT DSPROP_ShallowSearch2(
    IN OUT DSPROP_BSTR_BLOCK* pbstrblock,
    IN LPCTSTR lpcwszADsPathDirectory,
    IN LPCTSTR lpcwszFilterString,
    IN PADS_ATTR_INFO pAttrInfoExclusions
    )
{
    ASSERT( NULL != pbstrblock );
    HRESULT hr = S_OK;
    CStrListItem* pstrlist = NULL;
    // now add all of the objects of the specified class
    // in the specified container
    CDSSearch Search;
    Search.Init(lpcwszADsPathDirectory);
    Search.SetFilterString(const_cast<LPWSTR>(lpcwszFilterString));
    LPWSTR pAttrs[1] = {L"distinguishedName"};
    Search.SetAttributeList(pAttrs, 1);
    Search.SetSearchScope(ADS_SCOPE_ONELEVEL);
    hr = Search.DoQuery();
    while (SUCCEEDED(hr)) {
        hr = Search.GetNextRow();
        if (S_ADS_NOMORE_ROWS == hr)
        {
            hr = S_OK;
            break;
        }
        BREAK_IF_FAIL;

        ADS_SEARCH_COLUMN DistinguishedNameColumn;
        ::ZeroMemory( &DistinguishedNameColumn, sizeof(DistinguishedNameColumn) );
        hr = Search.GetColumn (pAttrs[0], &DistinguishedNameColumn);
        BREAK_IF_FAIL;
        ASSERT( ADSTYPE_DN_STRING == DistinguishedNameColumn.pADsValues->dwType );

        // if the current value has already been added to the In listbox,
        // don't add it to the Out listbox
        if (    NULL == pAttrInfoExclusions
            || !FIsInDNList( DistinguishedNameColumn.pADsValues->DNString, pAttrInfoExclusions ) )
        {
            CStrListAdd(&pstrlist, DistinguishedNameColumn.pADsValues->DNString);
        }
        Search.FreeColumn (&DistinguishedNameColumn);
    }

    // transfer CStrList to DSPROP_BSTR_BLOCK -- could be in own routine
    int cItems = CountCStrList( &pstrlist );
    if ( 0 < cItems )
    {
        if ( !pbstrblock->SetCount( cItems ) )
            hr = STATUS_NO_MEMORY;
        else
        {
            int iItem = 0;
        	for (CStrListItem* pList = pstrlist;
                 NULL != pList;
                 pList = pList->pnext, iItem++)
    	    {
                if ( !pbstrblock->Set( CComBSTR((LPCTSTR)(pList->str)), iItem ) )
                {
                    hr = STATUS_NO_MEMORY;
                    break;
                }
            }
	    }
    }
    FreeCStrList( &pstrlist );
    return hr;
}

HRESULT DSPROP_ShallowSearch(
    IN OUT DSPROP_BSTR_BLOCK* pbstrblock,
    IN LPCTSTR lpcwszADsPathDirectory,
    IN LPCTSTR lpcwszTargetDesiredClass,
    IN PADS_ATTR_INFO pAttrInfoExclusions
    )
{
    CStr strFilterString;
    strFilterString.Format(L"(&(objectClass=%s))", lpcwszTargetDesiredClass);
    return DSPROP_ShallowSearch2( pbstrblock,
                                  lpcwszADsPathDirectory,
                                  strFilterString,
                                  pAttrInfoExclusions );
}


//
// JonN 4/8/99: add code to enable horizontal scrolling where appropriate
//
HRESULT DSPROP_HScrollStringListbox(
    HWND hwndListbox
    )
{
    HRESULT hr = S_OK;
    LONG cxLongestTextExtent = 0L;

    // get a DC for the listbox
    HDC hdc = ::GetDC( hwndListbox );
    if ( NULL == hdc )
    {
        ASSERT(FALSE);
        return HRESULT_FROM_WIN32( ::GetLastError() );
    }
    // now don't return before releasing it

    CStrListItem* pList = NULL;
    SIZE sizeTextExtent;
    ::ZeroMemory( &sizeTextExtent, sizeof(sizeTextExtent) );
    do { // false loop

        int cDNs = 0;
        hr = HrGetItemsFromListbox( hwndListbox, &pList, cDNs );
        BREAK_IF_FAIL;
        // don't return before releasing this

        // determine the longest text extent of the strings in the listbox
        for (CStrListItem* pItem = pList; pItem != NULL; pItem = pItem->pnext)
        {
            LPTSTR ptzText = const_cast<LPTSTR>((LPCTSTR)pItem->str);
            CComBSTR sbstrRDN;
            hr = DSPROP_RetrieveRDN( ptzText, &sbstrRDN );
            BREAK_IF_FAIL;
            if ( !::GetTextExtentPoint32( hdc,
                                          sbstrRDN,
                                          sbstrRDN.Length(),
                                          &sizeTextExtent ) )
            {
                hr = HRESULT_FROM_WIN32( ::GetLastError() );
                BREAK_IF_FAIL; // don't return without releasing hdc
            }
            if ( sizeTextExtent.cx > cxLongestTextExtent )
                cxLongestTextExtent = sizeTextExtent.cx;
        }

    } while (false); // false loop
    (void) ::ReleaseDC( hwndListbox, hdc );
    if (NULL != pList)
        FreeCStrList( &pList );

    // set the horizontal scroll bar
    // don't bother with GetSystemMetrics(SM_CXHSCROLL) or listbox width
    ListBox_SetHorizontalExtent( hwndListbox, cxLongestTextExtent );

    return hr;
}


HRESULT DSPROP_Duelling_Populate2(
    IN HWND hwndListbox,
    IN const DSPROP_BSTR_BLOCK& bstrblock,
    IN WHICHLB whichlb
    )
{
    HRESULT hr = S_OK;
    for (int iItem = 0; iItem < bstrblock.QueryCount(); iItem++)
    {
        ASSERT( NULL != bstrblock[iItem] );
        hr = AddItemToListbox( hwndListbox, bstrblock[iItem], whichlb );
        BREAK_IF_FAIL;
    }
    DSPROP_HScrollStringListbox( hwndListbox );
    return hr;
}


// Enumerate the items of class lpcwszTargetDesiredClass in container
// lpcwszADsPathDirectory.  Add them to the specified listbox, except for
// those in pAttrInfoExclusions.
HRESULT DSPROP_Duelling_Populate(
    IN HWND hwndListbox,
    IN const DSPROP_BSTR_BLOCK& bstrblock
    )
{
    return DSPROP_Duelling_Populate2( hwndListbox, bstrblock, WHICHLB_NONE );
}


//
// These attribute functions is meant to handle four controls on the same page,
// where their attribute IDs are in sequence from
// ctrlidOut    (where ctrlidOut%4 = 0)
// ctrlidAdd    = ctrlidOut+1
// ctrlidRemove = ctrlidOut+2
// ctrlidIn     = ctrlidOut+3
//
inline bool IsOutListbox(  int ctrlid) { return (0 == (ctrlid%4)); }
inline bool IsAddButton(   int ctrlid) { return (1 == (ctrlid%4)); }
inline bool IsRemoveButton(int ctrlid) { return (2 == (ctrlid%4)); }
inline bool IsInListbox(   int ctrlid) { return (3 == (ctrlid%4)); }
inline bool IsListbox(     int ctrlid)
    { return IsOutListbox(ctrlid) || IsInListbox(ctrlid); }
inline bool IsButton(      int ctrlid)
    { return IsAddButton(ctrlid) || IsRemoveButton(ctrlid); }

void
DSPROP_Duelling_ButtonClick(
		HWND hwndDlg,
		int nButtonCtrlid
		)
{
    ASSERT( IsButton(nButtonCtrlid) );
    int ctrlidFrom = (IsAddButton(nButtonCtrlid))
        ? nButtonCtrlid - 1
        : nButtonCtrlid + 1;
    int ctrlidTo   = (IsAddButton(nButtonCtrlid))
        ? nButtonCtrlid + 2
        : nButtonCtrlid - 2;
    HWND hwndTo = ::GetDlgItem(hwndDlg,ctrlidTo);
    HWND hwndFrom = ::GetDlgItem(hwndDlg,ctrlidFrom);
    ASSERT( NULL != hwndTo && NULL != ctrlidFrom );
    MoveSelectedItems( hwndFrom, hwndTo );
    DSPROP_Duelling_UpdateButtons( hwndDlg, nButtonCtrlid );

    // set focus to hwndTo
    (void) ::SendMessage( hwndDlg, WM_NEXTDLGCTL, (WPARAM)hwndTo, 1L );
}

HRESULT
DuellingListboxButton(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO,
    LPARAM lParam, PATTR_DATA, DLG_OP DlgOp
    )
{
    HRESULT hr = S_OK;
    switch (DlgOp)
    {
    case fOnCommand:
        if ( BN_CLICKED == lParam )
        {
            DSPROP_Duelling_ButtonClick( pPropPage->GetHWnd(),
                                         pAttrMap->nCtrlID );
            pPropPage->SetDirty();

            PATTR_DATA_SET_DIRTY(((PATTR_DATA)((CDsTableDrivenPage *)pPropPage)->m_pData));
        }
        break;
    }

    return hr;
}

// also called by DuellingInListbox
HRESULT
DuellingListbox(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp
    )
{
    HRESULT hr = S_OK;
    switch (DlgOp)
    {
    case fOnCommand:
        DBG_OUT("DuellingListbox: fOnCommand");
        ASSERT( IsListbox(pAttrMap->nCtrlID) );
        // JonN 7/2/99: disable Add and Remove if attribute not writable
        if ( LBN_SELCHANGE == lParam
          && !(pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData)) )
            DSPROP_Duelling_UpdateButtons( pPropPage->GetHWnd(), pAttrMap->nCtrlID );
        break;

    case fOnDestroy:
        DBG_OUT("DuellingListbox: fOnDestroy");
        ASSERT( IsListbox(pAttrMap->nCtrlID) );
        DSPROP_Duelling_ClearListbox(
            ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID) );
    }

    return hr;
}

HRESULT
DuellingInListbox(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp,
    int iTargetLevelsUp, PWCHAR* ppwszTargetLevelsBack,
    PWCHAR pwszTargetClass,
    int nMinimumRDNs = 0,       // What is the minimum allowed number of references?
    int idsNotEnoughRDNs = 0    // What message to display if there are not enough
    );


HRESULT
DuellingInListbox(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp,
    int iTargetLevelsUp, PWCHAR* ppwszTargetLevelsBack,
    PWCHAR pwszTargetClass,
    int nMinimumRDNs,
    int idsNotEnoughRDNs
    )
{
    HRESULT hr = S_OK;
    CStrListItem* pList = NULL;
    switch (DlgOp)
    {
    case fInit:
    case fObjChanged:
        ASSERT( IsInListbox(pAttrMap->nCtrlID) );
        DBG_OUT("DuellingInListbox: fInit or fObjChanged");
        {
            //
            // Fill in the initial value of the In listbox
            // note that pAttrInfo could be NULL
            //
            HWND hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID);
            ASSERT( NULL != hwndCtrl );
            hr = AddItemsToListbox( hwndCtrl, pAttrInfo, WHICHLB_IN );
            BREAK_IF_FAIL;

            //
            // Fill in the initial value of the Out listbox
            //
            hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID-3);
            ASSERT( NULL != hwndCtrl );
            CComBSTR sbstrRDN;
            hr = DSPROP_TweakADsPath(
                pPropPage->GetObjPathName(),
                iTargetLevelsUp,
                ppwszTargetLevelsBack,
                &sbstrRDN );
            BREAK_IF_FAIL;
            DSPROP_BSTR_BLOCK bstrblock;
            hr = DSPROP_ShallowSearch(
                &bstrblock, 
                sbstrRDN,
                pwszTargetClass,
                pAttrInfo );
            if (FAILED(hr)) break;
            hr = DSPROP_Duelling_Populate2(
                hwndCtrl,
                bstrblock,
                WHICHLB_OUT );
            BREAK_IF_FAIL;
            //
            // Save the pAttrData pointer so that the button proc can set the
            // dirty state.
            //
            ((CDsTableDrivenPage *)pPropPage)->m_pData = reinterpret_cast<LPARAM>(pAttrData);

            // JonN 7/2/99: disable Add and Remove if attribute not writable
            if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
            {
                for (int i = 1; i <= 2; i++)
                    EnableWindow(GetDlgItem(pPropPage->GetHWnd(), pAttrMap->nCtrlID-i), FALSE);
            }
            break;

        }
        break;

    case fApply:
        DBG_OUT("DuellingInListbox: fApply");
        ASSERT( IsInListbox(pAttrMap->nCtrlID) );
        if (PATTR_DATA_IS_DIRTY(pAttrData))
        {
            //
            // Display an error message if the attribute is not pointing to
            // at least the minimum number of target objects, except when it is
            // pointing to all of the possible choices.
            //
            HWND hwndCtrlIn = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID);
            HWND hwndCtrlOut = ::GetDlgItem(pPropPage->GetHWnd(),pAttrMap->nCtrlID-3);
            ASSERT( NULL != hwndCtrlIn && NULL != hwndCtrlOut );
            int cItems = ListBox_GetCount( hwndCtrlIn );
            int cItemsOut = ListBox_GetCount( hwndCtrlOut );
            if (0 > cItems || 0 > cItemsOut)
            {
                ASSERT(FALSE);
                return E_FAIL;
            }
            if ( nMinimumRDNs > cItems && 0 != cItemsOut )
            {
                (void) SuperMsgBox(
                    pPropPage->GetHWnd (),
                    idsNotEnoughRDNs,
                    0,
                    MB_ICONWARNING,
                    0,
                    NULL, 0,
                    FALSE, __FILE__, __LINE__);

                return E_FAIL; // TableDriven will not display an error box
            }

            int cDNs = 0;
            hr = HrGetItemsFromListbox( hwndCtrlIn, &pList, cDNs, WHICHLB_OUT );
            BREAK_IF_FAIL;
            if (0 < cDNs)
            {
                hr = HrBuildADsValueArray( &(pAttrInfo->pADsValues), pList, cDNs );
                BREAK_IF_FAIL;
                pAttrInfo->dwNumValues = cDNs;
                pAttrInfo->dwControlCode = ADS_ATTR_APPEND;
                ASSERT( NULL != pPropPage->m_pDsObj );
                DWORD dwDummy = 0;
                hr = pPropPage->m_pDsObj->SetObjectAttributes(pAttrInfo,1,&dwDummy);
                if (FAILED(hr)) break;
                MarkItemsFromListbox( hwndCtrlIn, WHICHLB_IN );
                FreeCStrList( &pList );
                HelperDeleteADsValues( pAttrInfo );
            }

            hr = HrGetItemsFromListbox( hwndCtrlOut, &pList, cDNs, WHICHLB_IN );
            BREAK_IF_FAIL;
            if (0 < cDNs)
            {
                hr = HrBuildADsValueArray( &(pAttrInfo->pADsValues), pList, cDNs );
                BREAK_IF_FAIL;
                pAttrInfo->dwNumValues = cDNs;
                pAttrInfo->dwControlCode = ADS_ATTR_DELETE;
                ASSERT( NULL != pPropPage->m_pDsObj );
                DWORD dwDummy = 0;
                hr = pPropPage->m_pDsObj->SetObjectAttributes(pAttrInfo,1,&dwDummy);
                if (FAILED(hr)) break;
                MarkItemsFromListbox( hwndCtrlOut, WHICHLB_OUT );
                FreeCStrList( &pList );
                HelperDeleteADsValues( pAttrInfo );
            }
            return ADM_S_SKIP;
        }
        else
        {
            return ADM_S_SKIP;
        }
        break;

    case fOnCommand:
    case fOnDestroy:
        return DuellingListbox( pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp );
    }

    //
    // JonN 5/7/01 386954
    // dssite.msc: Moving server object after opening properties page
    // breaks OK and Apply buttons
    //
    // We were just failing to display anything on these errors
    //
    (void) CHECK_ADS_HR(&hr, pPropPage->GetHWnd());

    if (NULL != pList)
        FreeCStrList( &pList );

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   DsQuerySiteList
//
//  Synopsis:  Handles multi-valued DN pointer from Site-Link to Site objects
//
//-----------------------------------------------------------------------------
HRESULT
DsQuerySiteList(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp )
{
    return DuellingInListbox(
        pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
        3, NULL, L"site", 2, IDS_SITELINK_NEEDS_TWO_SITES );
}

//+----------------------------------------------------------------------------
//
//  Function:   DsQuerySiteLinkList
//
//  Synopsis:  Handles multi-valued DN pointer from Site-Link-Bridge to Site-Link objects
//
//-----------------------------------------------------------------------------
HRESULT
DsQuerySiteLinkList(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp )
{
    return DuellingInListbox(
        pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
        1, NULL, L"siteLink", 2, IDS_SITELINKBRIDGE_NEEDS_TWO_SITELINKS );
}

//+----------------------------------------------------------------------------
//
//  Function:   DsQueryBridgeheadList
//
//  Synopsis:  Handles multi-valued DN pointer from NTDS-DSA to Inter-Site-Transport objects
//
//-----------------------------------------------------------------------------
HRESULT
DsQueryBridgeheadList(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp )
{
    static WCHAR* apwszLevelsBack[2] = {
        L"CN=Inter-Site Transports",
        (WCHAR*)NULL };
    return DuellingInListbox(
        pPropPage, pAttrMap, pAttrInfo, lParam, pAttrData, DlgOp,
        3, apwszLevelsBack, L"interSiteTransport" );
}


//+----------------------------------------------------------------------------
//
//  Function:   GetReplicatedDomainInfo
//
//  Synopsis:  Returns information about the domains stored by this replica
//
// 531591 JonN 2002/04/03 Rebuilt to use msDS-hasMasterNCs when available
//   and also to use hasPartialReplicaNCs
//
//-----------------------------------------------------------------------------
HRESULT
GetReplicatedDomainInfo(
    IN LPWSTR pwszADsPathDC,
    OUT Smart_PADS_ATTR_INFO& spMasterNCs,
    OUT Smart_PADS_ATTR_INFO& spPartialNCs,
    OUT bool* pfGlobalCatalog)
{
    if (   NULL == pwszADsPathDC
           || !!spMasterNCs
           || !!spPartialNCs
           || NULL == pfGlobalCatalog )
    {
        ASSERT(FALSE);
        return E_POINTER;
    }
    CComPtr<IADs> spIADs;
    HRESULT hr = DSAdminOpenObject(
        pwszADsPathDC,
        IID_IDirectoryObject,
        (PVOID *)&spIADs);
    if ( FAILED(hr) )
        return hr; // no assertion

    hr = GetAttr( spIADs, L"msDS-hasMasterNCs", &spMasterNCs );
    // BUGBUG Do we need the 0 == dwNumValues check?
    if (FAILED(hr) || !spMasterNCs || 0 == spMasterNCs->dwNumValues)
    {
        spMasterNCs.Empty();
        hr = GetAttr( spIADs, L"hasMasterNCs", &spMasterNCs );
    }
    if (FAILED(hr))
        return hr;
    ASSERT( !spMasterNCs
         || !_wcsicmp( L"msDS-hasMasterNCs", spMasterNCs->pszAttrName )
         || !_wcsicmp( L"hasMasterNCs", spMasterNCs->pszAttrName ) );

    hr = GetAttr( spIADs, L"hasPartialReplicaNCs", &spPartialNCs );
    if (FAILED(hr)) // 0 == dwNumValues is OK
        hr = S_OK; // GetAttr() fails if there are no values
    ASSERT( !spPartialNCs
         || !_wcsicmp( L"hasPartialReplicaNCs", spPartialNCs->pszAttrName ) );

    Smart_PADS_ATTR_INFO spOptions;
    hr = GetAttr( spIADs, L"options", &spOptions );
    if ( FAILED(hr) // GetAttr fails if the value is 0
        || !spOptions
        || _wcsicmp( L"options", spOptions->pszAttrName )
        || 1 != spOptions->dwNumValues
        || NULL == spOptions->pADsValues
        || ADSTYPE_INTEGER != spOptions->dwADsType
       )
    {
        hr = S_OK;
        *pfGlobalCatalog = false;
    }
    else
    {
        *pfGlobalCatalog = !!(0x1 & spOptions[0].pADsValues[0].Integer);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   CopyMatchesToString
//
//  Synopsis:   Helper function for UpdateNamingContextFields
//
// 531591 JonN 2002/04/03 created
//
//-----------------------------------------------------------------------------
void
CopyMatchesToString( OUT CStr& strDomains,
                     IN  Smart_PADS_ATTR_INFO& spTargetNCs,
                     IN  Smart_PADS_ATTR_INFO& spSourceNCs,
                     HWND hwndDlg )
{
    if (   !spTargetNCs
        || 0 == spTargetNCs->dwNumValues
        || ADSTYPE_DN_STRING != spTargetNCs->dwADsType
        || NULL == spTargetNCs->pADsValues
        || !spSourceNCs
        || 0 == spSourceNCs->dwNumValues
        || ADSTYPE_DN_STRING != spSourceNCs->dwADsType
        || NULL == spSourceNCs->pADsValues
       )
    {
        return; // no matches
    }

    for (DWORD i = 0; i < spTargetNCs->dwNumValues; i++)
    {
        LPWSTR pszTargetNC = spTargetNCs->pADsValues[i].DNString;
        if (NULL == pszTargetNC)
        {
            ASSERT(FALSE);
            continue;
        }
        
        for (DWORD j = 0; j < spSourceNCs->dwNumValues; j++)
        {
            LPCWSTR pszSourceNC = spSourceNCs->pADsValues[j].DNString;
            if (NULL == pszSourceNC)
            {
                ASSERT(FALSE);
                continue;
            }
            if (!_wcsicmp(pszTargetNC, pszSourceNC))
            {
                // skip "CN=Configuration" and "CN=Schema"
                CPathCracker pathcracker;
                HRESULT hr = pathcracker.Set(
                    CComBSTR(pszTargetNC), ADS_SETTYPE_DN );
                BREAK_IF_FAIL;
                CComBSTR sbstr;
                hr = pathcracker.GetElement( 0L, &sbstr );
                BREAK_IF_FAIL;
                ASSERT( !!sbstr );
                if ( !sbstr || _wcsnicmp( L"DC=", sbstr, 3 ) )
                    break; // not a domain naming context

                // extract the DNS domain name from the NC
                PWSTR pwszDomainName = NULL;
                if (FAILED(CrackName( pszTargetNC,
                                      &pwszDomainName,
                                      GET_DNS_DOMAIN_NAME,
                                      hwndDlg )))
                {
                    ASSERT(FALSE);
                    break;
                }

                // add the DNS domain name to the output string
                if ( !strDomains.IsEmpty() )
                    strDomains += L", ";
                strDomains += pwszDomainName;
                LocalFreeStringW(&pwszDomainName);
                break;
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   UpdateNamingContextFields
//
//  Synopsis:   Retrieves the names of the naming contexts common between the two
//              DCs linked by a connection, and saves this in two dialog controls
//
// 531591 JonN 2002/04/03 Rebuilt to use msDS-hasMasterNCs when available
//   and also to use hasPartialNCs
//
//-----------------------------------------------------------------------------
HRESULT
UpdateNamingContextFields(
    IN CDsPropPageBase* pPropPage, IN LPWSTR pwszFromServer, bool fInvalid )
{
    HRESULT hr = S_OK;
    DBG_OUT("UpdateNamingContextFields");

    // if a particular string should be displayed instead of a domain
    // name, it will be stored here
    int idsDisplayString = 0;

    // these are the actual messages to put in the readonly edit fields
    CStr strDomains;
    CStr strPartialDomains;

    Smart_PADS_ATTR_INFO spTargetMasterNCs;
    Smart_PADS_ATTR_INFO spTargetPartialNCs;
    Smart_PADS_ATTR_INFO spSourceMasterNCs;
    Smart_PADS_ATTR_INFO spSourcePartialNCs;
    bool fTargetIsGC = false;
    bool fSourceIsGC = false;

    do { // false loop

        if ( fInvalid )
        {
            idsDisplayString = IDS_INVALID;
            break;
        }
        else if ( NULL == pwszFromServer )
        {
            idsDisplayString = IDS_SHAREDNC_NO_FROM_SERVER;
            break;
        }

        // get path to target DC
        ASSERT( NULL != pPropPage->GetObjPathName() );
        CComBSTR sbstrTargetDC = pPropPage->GetObjPathName();
        ASSERT( !!sbstrTargetDC );
        hr = DSPROP_RemoveX500LeafElements( 1, &sbstrTargetDC );
        BREAK_IF_FAIL;

        // get path to source DC by combining the DN from the fromServer attribute
        // with the rest of the ADsPath from pPropPage->GetObjPathName()
        CPathCracker pathcracker;
        hr = pathcracker.Set( CComBSTR(pPropPage->GetObjPathName()), ADS_SETTYPE_FULL );
        BREAK_IF_FAIL;
        hr = pathcracker.Set( CComBSTR(pwszFromServer), ADS_SETTYPE_DN );
        BREAK_IF_FAIL;
        CComBSTR sbstrSourceDC;
        hr = pathcracker.Retrieve( ADS_FORMAT_X500, &sbstrSourceDC );
        BREAK_IF_FAIL;

        CComBSTR sbstrTargetMasterDNSDomain;
        hr = GetReplicatedDomainInfo(
            sbstrTargetDC,
            spTargetMasterNCs,
            spTargetPartialNCs,
            &fTargetIsGC );
        if ( FAILED(hr) )
            break; // no assertion
        CComBSTR sbstrSourceMasterDNSDomain;
        hr = GetReplicatedDomainInfo(
            sbstrSourceDC,
            spSourceMasterNCs,
            spSourcePartialNCs,
            &fSourceIsGC );
        if ( FAILED(hr) )
            break; // no assertion

        CopyMatchesToString( strDomains,
                             spTargetMasterNCs,
                             spSourceMasterNCs,
                             pPropPage->GetHWnd() );
        CopyMatchesToString( strPartialDomains,
                             spTargetPartialNCs,
                             spSourceMasterNCs,
                             pPropPage->GetHWnd() );
        CopyMatchesToString( strPartialDomains,
                             spTargetPartialNCs,
                             spSourcePartialNCs,
                             pPropPage->GetHWnd() );

        if ( strDomains.IsEmpty() )
        {
            idsDisplayString = IDS_SHAREDNC_NONE;
            break;
        }

    } while (false); // false loop

    //
    // Fill in the readonly edit fields
    //
    if ( FAILED(hr) )
    {
        PTSTR ptzMsg = NULL;
        LoadErrorMessage( hr, IDS_ADS_ERROR_FORMAT, &ptzMsg );
        strDomains = ptzMsg;
        strPartialDomains.Empty();
        delete ptzMsg;
    }
    else if (0 != idsDisplayString)
    {
        LPWSTR pszMsg = NULL;
        if ( !LoadStringToTchar (idsDisplayString, &pszMsg) )
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPropPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
        strDomains = pszMsg;
        if (IDS_SHAREDNC_NONE != idsDisplayString)
            strPartialDomains.Empty();
        delete [] pszMsg;
    }
    else if (fTargetIsGC && fSourceIsGC)
    {
        // if both replicas are GCs then all other domains are replicated,
        // say so explicitly rather than listing them
        LPWSTR pszMsg = NULL;
        if ( !LoadStringToTchar (IDS_SHAREDNC_BOTH_GCS, &pszMsg) )
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPropPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
        strPartialDomains = pszMsg;
        delete [] pszMsg;
    }

    // now we can finally write this to the dialog
    HWND hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),IDC_EDIT1);
    ASSERT( NULL != hwndCtrl );
    Edit_SetText( hwndCtrl, strDomains );
    hwndCtrl = ::GetDlgItem(pPropPage->GetHWnd(),IDC_EDIT2);
    ASSERT( NULL != hwndCtrl );
    Edit_SetText( hwndCtrl, strPartialDomains );

    return hr;
}



//+----------------------------------------------------------------------------
//
//  Function:   CreateDsOrFrsConnectionPage
//
//  Synopsis:   Creates an instance of a page window for an NTDS-Connection object.
//              This object has two different pages depending on whether its parent
//              is an NTDS-DSA or an NTFRS-Member.
//
//-----------------------------------------------------------------------------

extern DSPAGE DsConnectionGeneral;
extern DSPAGE FrsConnectionGeneral;

HRESULT
CreateDsOrFrsConnectionPage(PDSPAGE, LPDATAOBJECT pDataObj,
                      PWSTR pwzADsPath, LPWSTR pwzClass, HWND hNotifyObj,
                      DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
                      HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateNTDSConnectionPage);

    // generate path to parent
    CComBSTR sbstr = pwzADsPath;
    HRESULT hr = DSPROP_RemoveX500LeafElements( 1, &sbstr );
    RETURN_IF_FAIL;

    // open parent and get its classname
    {
        CComPtr<IADs> spIADsParent;
        hr = DSAdminOpenObject(sbstr, 
                               IID_IADs, 
                               (PVOID*)&spIADsParent );
        RETURN_IF_FAIL;
        sbstr.Empty();
        hr = spIADsParent->get_Class( &sbstr );
        RETURN_IF_FAIL;
    }

    // determine whether parent is an FRS object
    bool fParentIsFrs = false;
    hr = DSPROP_IsFrsObject( sbstr, &fParentIsFrs );
    RETURN_IF_FAIL;

    // now create the page
    return CreateTableDrivenPage(
        (fParentIsFrs) ? (&FrsConnectionGeneral) : (&DsConnectionGeneral),
        pDataObj,
        pwzADsPath,
        pwzClass,
        hNotifyObj,
        dwFlags,
        basePathsInfo,
        phPage );
}


// Bit flags for options attribute on NTDS-Connection objects.
// CODEWORK these are defined in ds\src\inc\ntdsa.h
#define NTDSCONN_OPT_IS_GENERATED       ( 1 << 0 )  /* object generated by DS, not admin */

HRESULT
nTDSConnectionOptions(CDsPropPageBase * pPage, PATTR_MAP,
             PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA pAttrData,
             DLG_OP DlgOp)
{
  switch (DlgOp)
  {
  case fInit:
    if ( 1 == pAttrInfo->dwNumValues
      && NULL != pAttrInfo->pADsValues 
      && ADSTYPE_INTEGER == pAttrInfo->pADsValues[0].dwType
      && NTDSCONN_OPT_IS_GENERATED & pAttrInfo->pADsValues[0].Integer)
    {
      LPWSTR pszMsg = NULL;
      if ( LoadStringToTchar (IDS_CONNECTION_KCC_GENERATED, &pszMsg) )
      {
        SetDlgItemText( pPage->GetHWnd(), IDC_CN, pszMsg );
      }
      if ( pszMsg )
        delete [] pszMsg;

//
// 146897: RC2SS: Site&Rep:  Change Schedule on Connection does not make it Admin Controlled
//
// If this is a KCC-generated function, we set this attribute to "dirty" but not
// the page.  If some other attrfn sets the page dirty, ask the user whether he/she
// wants to save changes and mark the connection as no longer KCC-generated.
// Note that this is marked dirty even if the attribute is not writable.
//
// JonN 7/6/99
//
      PATTR_DATA_SET_DIRTY(pAttrData);
    }

    // remember attribute value in case this flag must be cleared
    if (pAttrInfo && (pAttrInfo->dwNumValues == 1))
    {
      ASSERT( NULL != pAttrInfo->pADsValues && ADSTYPE_INTEGER == pAttrInfo->dwADsType );
      pAttrData->pVoid = static_cast<LPARAM>(pAttrInfo->pADsValues->Integer);
    }
    else
    {
      pAttrData->pVoid = NULL;
    }
    break;

  case fApply:
    {
      ASSERT( pPage->IsDirty() );

      if (!PATTR_DATA_IS_DIRTY(pAttrData))
      {
        return ADM_S_SKIP;
      }

      int nResponse = SuperMsgBox(pPage->GetHWnd(),
                                  (PATTR_DATA_IS_WRITABLE(pAttrData))
                                    ? IDS_CONNECTION_WARNING_MARK
                                    : IDS_CONNECTION_WARNING_CANNOT_MARK,
                                  0,
                                  MB_YESNO | MB_ICONEXCLAMATION,
                                  0,
                                  NULL, 0,
                                  FALSE, __FILE__, __LINE__);
      if (IDYES != nResponse)
        return E_FAIL; // cancel apply/OK action
      else if (!PATTR_DATA_IS_WRITABLE(pAttrData))
        return ADM_S_SKIP; // continue but skip the options attribute

      PADSVALUE pADsValue;
      pADsValue = new ADSVALUE;
      CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
      pAttrInfo->pADsValues = pADsValue;
      pAttrInfo->dwNumValues = 1;
      pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
      ASSERT( ADSTYPE_INTEGER == pAttrInfo->dwADsType );
      pADsValue->dwType = pAttrInfo->dwADsType;
      pADsValue->Integer =
          ((ADS_INTEGER)((DWORD_PTR)pAttrData->pVoid)) & ~NTDSCONN_OPT_IS_GENERATED;
    }
    break;
  }

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   EditNumber
//
//  Synopsis:
//              Special-purpose attribute function for ES_NUMBER edit controls
//              with associated spin button.  Supports up to 5 digits.  This
//              must always be accompanied by a "msctls_updown32" control with
//              the SpinButton attribute function. Set ATTR_MAP.pData to the
//              controlID of the associated spin button.
//
//-----------------------------------------------------------------------------
HRESULT
EditNumber(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp )
{
    HRESULT hr = S_OK;
    switch (DlgOp)
    {
    case fInit:
    {
        // JonN 7/2/99: disable if attribute not writable

        HWND editCtrl = GetDlgItem(pPropPage->GetHWnd(), pAttrMap->nCtrlID);
        
        if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
            EnableWindow(editCtrl, FALSE);

        // setting value handled by the accompanying SpinButton

        // NTRAID#NTBUG9-356257-2001/05/15-sburns
        ::SendMessage(editCtrl, EM_LIMITTEXT, 5, 0);
        
        break;
    }
    case fApply:
        DBG_OUT("EditNumber: fApply");
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        if ( NULL == pPropPage || NULL == pAttrMap || NULL == pAttrInfo )
        {
            ASSERT(FALSE);
            break;
        }
        {
            BOOL fError = FALSE;
            ADS_INTEGER initialvalue = (ADS_INTEGER)::SendDlgItemMessage(
                    pPropPage->GetHWnd(),
                    pAttrMap->nSizeLimit, // ID of associated spin button
                    UDM_GETPOS32, 0, (LPARAM)&fError);
            //
            // JonN 12/7/99 434967:
            // UI writes bad value to the DS if replinterval
            // on the sitelink is less than 15 min (DSLAB)
            //
            if ( fError )
            {
                // set focus to proper control
                HWND hwndThis = ::GetDlgItem(
                    pPropPage->GetHWnd(),
                    pAttrMap->nCtrlID);
                ASSERT( NULL != hwndThis );
                (void) ::SendMessage(
                    pPropPage->GetHWnd(),
                    WM_NEXTDLGCTL,
                    (WPARAM)hwndThis,
                    1L );
                // display error message
                INT iLow = 0, iHigh = 0;
                (void) ::SendDlgItemMessage(
                    pPropPage->GetHWnd(),
                    pAttrMap->nSizeLimit, // ID of associated spin button
                    UDM_GETRANGE32, (WPARAM)&iLow, (LPARAM)&iHigh);
                PVOID pvArgs[2] = {
                    reinterpret_cast<PVOID>((unsigned __int64)((UINT)iLow)),
                    reinterpret_cast<PVOID>((unsigned __int64)((UINT)iHigh)) };
                (void) SuperMsgBox(
                    pPropPage->GetHWnd (),
                    IDS_OUT_OF_RANGE,
                    0,
                    MB_ICONWARNING,
                    0,
                    pvArgs, 2,
                    FALSE, __FILE__, __LINE__);
                hr = E_FAIL;
                break;
            }
            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->Integer = initialvalue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        }
        break;

    case fOnCommand:
        if (EN_CHANGE == lParam)
        {
            pPropPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   SpinButton
//
//  Synopsis:   General-purpose READONLY attribute function for spin buttons
//              accompaying EditNumber edit controls.  If you wish to limit
//              the spinbutton range, set ATTR_MAP.nSizeLimit to the high end
//              of the range and ATTR_MAP.pData to the low end of the range.
//
//-----------------------------------------------------------------------------
HRESULT
SpinButton(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
    LPARAM, PATTR_DATA pAttrData, DLG_OP DlgOp )
{
    HRESULT hr = S_OK;
    switch (DlgOp)
    {
    case fInit:
        DBG_OUT("SpinButton: fInit");
        if (NULL == pAttrMap ||
            NULL == pPropPage )
        {
            ASSERT(FALSE);
            break; // attribute is invalid or of wrong type
        }
        if (0 != pAttrMap->nSizeLimit)
        {
            ::SendDlgItemMessage( pPropPage->GetHWnd(),
                                  pAttrMap->nCtrlID,
                                  UDM_SETRANGE32,
                                  (WPARAM)pAttrMap->pData,
                                  (LPARAM)pAttrMap->nSizeLimit);
        }

        // JonN 7/2/99: disable if attribute not writable
        if (pAttrData && !PATTR_DATA_IS_WRITABLE(pAttrData))
            EnableWindow(GetDlgItem(pPropPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);

        if (NULL == pAttrInfo ||
            IsBadReadPtr(pAttrInfo,sizeof(ADS_ATTR_INFO)) ||
            1 != pAttrInfo->dwNumValues ||
            NULL == pAttrInfo->pADsValues ||
            IsBadReadPtr(pAttrInfo->pADsValues,sizeof(ADSVALUE)) ||
            ADSTYPE_INTEGER != pAttrInfo->pADsValues[0].dwType )
        {
            break; // attribute is invalid or of wrong type
        }
        ::SendDlgItemMessage( pPropPage->GetHWnd(),
                              pAttrMap->nCtrlID,
                              UDM_SETPOS32,
                              0,
                              pAttrInfo->pADsValues[0].Integer );
        break;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Function:   SpinButtonExtendIncrement
//
//  Synopsis:   Special-purpose attribute function for spin buttons to change
//              accelerator increment.  Use this as READONLY for controls which
//              already have a SpinButton attribute function.  Set ATTR_MAP.pData
//              to the integer multiple, e.g. 15 to move in increments of 15.
//
//-----------------------------------------------------------------------------
HRESULT
SpinButtonExtendIncrement(
    CDsPropPageBase* pPropPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO,
    LPARAM, PATTR_DATA, DLG_OP DlgOp )
{
    HRESULT hr = S_OK;
    switch (DlgOp)
    {
    case fInit:
        DBG_OUT("SpinButtonExtendIncrement: fInit");
        if (NULL == pAttrMap ||
            NULL == pPropPage )
        {
            ASSERT(FALSE);
            break; // attribute is invalid or of wrong type
        }
        if (0 >= pAttrMap->nSizeLimit)
        {
            ASSERT(FALSE);
            break; // invalid increment
        }
        {
            LRESULT nAccels =
                ::SendDlgItemMessage( pPropPage->GetHWnd(),
                                      pAttrMap->nCtrlID,
                                      UDM_GETACCEL,
                                      (WPARAM)0,
                                      (LPARAM)NULL);

            if (nAccels == 0)
            {
              ASSERT( 0L <= nAccels );
              break;
            }

            LPUDACCEL aAccels = new UDACCEL[nAccels];
            if (!aAccels)
            {
              ASSERT(FALSE);
              hr = E_OUTOFMEMORY;
              break;
            }

            LRESULT nAccelsRetrieved =
                ::SendDlgItemMessage( pPropPage->GetHWnd(),
                                      pAttrMap->nCtrlID,
                                      UDM_GETACCEL,
                                      (WPARAM)nAccels,
                                      (LPARAM)aAccels);
            ASSERT( nAccelsRetrieved == nAccels );

            DWORD dwAccelMultiplier = pAttrMap->nSizeLimit;
            ASSERT( 0 < dwAccelMultiplier );
            for (LRESULT iAccel = 0; iAccel < nAccels; iAccel++)
            {
#define MAX_ACCEL_INTERVAL 10000
                if (aAccels[iAccel].nInc <= (MAX_ACCEL_INTERVAL/dwAccelMultiplier) )
                    aAccels[iAccel].nInc *= dwAccelMultiplier;
                else
                    aAccels[iAccel].nInc = MAX_ACCEL_INTERVAL;
            }
            BOOL fSuccess =
                (BOOL)::SendDlgItemMessage( pPropPage->GetHWnd(),
                                            pAttrMap->nCtrlID,
                                            UDM_SETACCEL,
                                            (WPARAM)nAccels,
                                            (LPARAM)aAccels);
            ASSERT( fSuccess );
            if (aAccels)
            {
              delete[] aAccels;
              aAccels = 0;
            }
        }

        break;
    }

    return hr;
}


int GetOctet( LPTSTR* ppszAddress )
{
    if ( NULL == ppszAddress || NULL == *ppszAddress )
    {
        ASSERT(FALSE);
        return 0;
    }
    LPTSTR pszOctet = *ppszAddress;
    LPTSTR pszDot = _tcschr(pszOctet, TEXT('.'));
    if (NULL != pszDot)
    {
        *pszDot = TEXT('\0');
        *ppszAddress = pszDot+1;
    }
    return _wtoi(pszOctet);
}

int GetMask( int* piCount )
{
    if ( NULL == piCount || 0 > *piCount || 32 < *piCount )
    {
        ASSERT(FALSE);
        return 0;
    }
    int iMask = 0xff;
    int iShiftCount = (8 - min(8, *piCount));
    iMask = iMask << iShiftCount;
    iMask = iMask & 0xff;
    *piCount = max( 0, (*piCount)-8 );
    return iMask;
}

HRESULT ExtractSubnetAddressAndMask(
    IN  LPCTSTR strSubnetName,
    OUT LPARAM* pdwAddress,
    OUT LPARAM* pdwMask )
{
  CComBSTR sbstrTemp = strSubnetName;
  LPTSTR pszAddress = sbstrTemp;

  if (pszAddress != NULL )
  {
    LPTSTR pszCount = _tcschr(pszAddress, TEXT('/'));
    if (NULL == pszCount)
        return S_OK; // bad subnet name
    *pszCount = TEXT('\0');
    pszCount++;

    if (NULL != pdwAddress)
    {
      int Octet1 = GetOctet( &pszAddress );
      int Octet2 = GetOctet( &pszAddress );
      int Octet3 = GetOctet( &pszAddress );
      int Octet4 = GetOctet( &pszAddress );
      *pdwAddress = MAKEIPADDRESS(Octet1,Octet2,Octet3,Octet4);
    }
    if (NULL != pdwMask)
    {
      int iCount = _wtoi( pszCount );
      int Octet1 = GetMask( &iCount );
      int Octet2 = GetMask( &iCount );
      int Octet3 = GetMask( &iCount );
      int Octet4 = GetMask( &iCount );
      *pdwMask = MAKEIPADDRESS(Octet1,Octet2,Octet3,Octet4);
    }
  }
  return S_OK;
}

HRESULT
SubnetExtractAddress(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit == DlgOp)
    {
        HWND hwnd = ::GetDlgItem( pPage->GetHWnd(), pAttrMap->nCtrlID );
        ASSERT( NULL != hwnd );
        (void) ::EnableWindow( hwnd, FALSE );
        if (NULL == pAttrInfo ||
            IsBadReadPtr(pAttrInfo,sizeof(ADS_ATTR_INFO)) ||
            1 != pAttrInfo->dwNumValues ||
            NULL == pAttrInfo->pADsValues ||
            IsBadReadPtr(pAttrInfo->pADsValues,sizeof(ADSVALUE)) ||
            ADSTYPE_CASE_IGNORE_STRING != pAttrInfo->pADsValues[0].dwType )
        {
            // attribute is invalid or of wrong type
        }
        else
        {
            LPARAM dwAddress = 0;
            ExtractSubnetAddressAndMask(
                pAttrInfo->pADsValues[0].CaseIgnoreString,
                &dwAddress,
                NULL );
            (void) ::SendMessage( hwnd, IPM_SETADDRESS, 0, dwAddress );
        }
    }
    return S_OK;
}

HRESULT
SubnetExtractMask(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit == DlgOp)
    {
        HWND hwnd = ::GetDlgItem( pPage->GetHWnd(), pAttrMap->nCtrlID );
        ASSERT( NULL != hwnd );
        (void) ::EnableWindow( hwnd, FALSE );
        if (NULL == pAttrInfo ||
            IsBadReadPtr(pAttrInfo,sizeof(ADS_ATTR_INFO)) ||
            1 != pAttrInfo->dwNumValues ||
            NULL == pAttrInfo->pADsValues ||
            IsBadReadPtr(pAttrInfo->pADsValues,sizeof(ADSVALUE)) ||
            ADSTYPE_CASE_IGNORE_STRING != pAttrInfo->pADsValues[0].dwType )
        {
            // attribute is invalid or of wrong type
        }
        else
        {
            LPARAM dwMask = 0;
            ExtractSubnetAddressAndMask(
                pAttrInfo->pADsValues[0].CaseIgnoreString,
                NULL,
                &dwMask );
            (void) ::SendMessage( hwnd, IPM_SETADDRESS, 0, dwMask );
        }
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   SiteExtractSubnetList
//
//  Synopsis:   Handle the Subnets listview in Site Properties
//
//  The HIMAGELIST should be destroyed automatically since I did not define
//  LVS_SHAREIMAGELIST.
//
//  History:
//  02/29/00    JonN        created
//
//-----------------------------------------------------------------------------

HRESULT
SiteExtractSubnetList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp)
        return S_OK;

    // add column to listview
    HWND hList = ::GetDlgItem( pPage->GetHWnd(), pAttrMap->nCtrlID );
    ASSERT( NULL != hList );
    ListView_SetExtendedListViewStyle(hList, LVS_EX_FULLROWSELECT);
    RECT rect;
    ::ZeroMemory( &rect, sizeof(rect) );
    if ( !GetClientRect(hList, &rect) )
    {
        ASSERT(FALSE);
        return S_OK;
    }
    LV_COLUMN lvc;
    ::ZeroMemory( &lvc, sizeof(lvc) );
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rect.right;
    lvc.iSubItem = 0;
    if (-1 == ListView_InsertColumn(hList, 0, &lvc) )
    {
        ASSERT(FALSE);
        return S_OK;
    }

    // add subnet icon to listview
    HIMAGELIST hImageList = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK, 1, 1);
    HICON hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, L"subnet", 16, 16);
    int iIcon = -1;
    if (NULL != hImageList && NULL != hIcon)
    {
        iIcon = ImageList_AddIcon(hImageList, hIcon);
        if (-1 != iIcon)
        {
            if (NULL != ListView_SetImageList( hList, hImageList, LVSIL_SMALL ))
            {
                ASSERT(FALSE);
            }
        }
    }

    if (NULL != hIcon && 0 == DestroyIcon(hIcon))
    {
        ASSERT(FALSE);
    }

    // generate path to subnetsContainer
    const LPWSTR lpszObjPathName = pPage->GetObjPathName();
    if ( NULL == lpszObjPathName )
    {
        ASSERT(FALSE);
        return S_OK;
    }
    CPathCracker pathcracker;
    HRESULT hr = pathcracker.Set( CComBSTR(lpszObjPathName), ADS_SETTYPE_FULL );
    RETURN_IF_FAIL;
    CComBSTR sbstrSiteX500DN;
    hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrSiteX500DN );
    RETURN_IF_FAIL;
    hr = pathcracker.RemoveLeafElement();
    RETURN_IF_FAIL;
    hr = pathcracker.AddLeafElement( CComBSTR(L"CN=Subnets") );
    RETURN_IF_FAIL;
    CComBSTR sbstr;
    hr = pathcracker.Retrieve( ADS_FORMAT_X500, &sbstr );
    RETURN_IF_FAIL;

    // build search filter
    CStr strFilterString;
    strFilterString.Format(L"(&(objectClass=subnet)(siteObject=%s))", sbstrSiteX500DN);

    // read list of subnets
    DSPROP_BSTR_BLOCK bstrblock;
    hr = DSPROP_ShallowSearch2(
        &bstrblock, 
        sbstr,
        strFilterString,
        pAttrInfo );
    RETURN_IF_FAIL;
    hr = pathcracker.SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
    RETURN_IF_FAIL;
    // CODEWORK escaped mode off?  Would that affect Set?

    // add subnets to list
    LVITEM lvitem;
    ::ZeroMemory( &lvitem, sizeof(lvitem) );
    lvitem.mask = LVIF_TEXT | LVIF_IMAGE;
    lvitem.iImage = iIcon;
    for (int i = 0; i < bstrblock.QueryCount(); i++)
    {
        hr = pathcracker.Set( bstrblock[i], ADS_SETTYPE_DN );
        RETURN_IF_FAIL;
        hr = pathcracker.GetElement( 0, &sbstr );
        RETURN_IF_FAIL;
        lvitem.pszText = sbstr;
        if (-1 == ListView_InsertItem( hList, &lvitem ))
        {
            ASSERT(FALSE);
        }
    }

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   DsReplicateListbox
//
//  Synopsis:   Populate the listviews in the NTDS-DSA Connections page
//
//  CODEWORK    It would be nice if we could display failures to set up the
//              listbox or read its contents.  Sortable columns would also
//              be nice.
//
//  History:
//  04/20/00    JonN        created
//
//-----------------------------------------------------------------------------

bool PrepReplicateListbox(
    IN  HWND hwnd,
    OUT int& refIcon)
{
    if ( NULL == hwnd )
    {
        ASSERT(FALSE);
        return false;
    }
    ListView_SetExtendedListViewStyle(hwnd, LVS_EX_FULLROWSELECT);

    // add columns
    RECT rect;
    ::ZeroMemory( &rect, sizeof(rect) );
    if ( !GetClientRect(hwnd, &rect) )
    {
        ASSERT(FALSE);
        return false;
    }

    // reserve horizontal space for the vertical scrollbar
    int cxScrollbar = ::GetSystemMetrics( SM_CXVSCROLL );
    if (rect.right > 3*cxScrollbar)
        rect.right -= cxScrollbar;

    LV_COLUMN lvc;
    ::ZeroMemory( &lvc, sizeof(lvc) );
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = rect.right/2;
    CStrW strColTitle;
    strColTitle.LoadString( g_hInstance, IDS_COL_TITLE_OBJNAME );
    lvc.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(strColTitle));
    if ( -1 == ListView_InsertColumn(hwnd, 0, &lvc) )
    {
        ASSERT(FALSE);
    }
    lvc.cx = rect.right - lvc.cx;
    strColTitle.LoadString( g_hInstance, IDS_TITLE_SITE );
    lvc.pszText = const_cast<LPTSTR>(static_cast<LPCTSTR>(strColTitle));
    if ( -1 == ListView_InsertColumn(hwnd, 1, &lvc) )
    {
        ASSERT(FALSE);
    }

    // add NTDSDSA icon
    HIMAGELIST hImageList = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK, 1, 1);
    HICON hIcon = DsGetIcon(DSGIF_ISNORMAL | DSGIF_GETDEFAULTICON, L"nTDSDSA", 16, 16);
    if (NULL != hImageList && NULL != hIcon)
    {
        refIcon = ImageList_AddIcon(hImageList, hIcon);
        if (-1 != refIcon)
        {
            if (NULL != ListView_SetImageList( hwnd, hImageList, LVSIL_SMALL ))
            {
                ASSERT(FALSE);
            }
        }
    }

    if (NULL != hIcon && 0 == DestroyIcon(hIcon))
    {
        ASSERT(FALSE);
    }

    return true;
}

HRESULT
DsReplicateListbox(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp)
        return S_OK;

    HWND hwnd = ::GetDlgItem( pPage->GetHWnd(), pAttrMap->nCtrlID );
    int iIcon = -1;
    if ( NULL == hwnd || !PrepReplicateListbox( hwnd, iIcon ) )
    {
        return S_OK;
    }

    LVITEM lvitem;
    ::ZeroMemory( &lvitem, sizeof(lvitem) );
    lvitem.mask = LVIF_IMAGE | LVIF_TEXT;
    lvitem.iImage = iIcon;

    // prepare search parameters
    // fReplicateFrom : shallow search under nTDSDSA for all connection objects
    // !fReplicateFrom: deep search under sitesContainer for connection objects
    //                  pointing to nTDSDSA
    bool fReplicateFrom = (NULL == pAttrMap->pData);
    CComBSTR sbstrSearchPath = pPage->GetObjPathName();
    CStr strFilterString = L"(&(objectClass=nTDSConnection))";
    if (!fReplicateFrom) // ReplicateTo listbox
    {
        // search the subtree from the Sites container
        CPathCracker pathcracker;
        HRESULT hr = pathcracker.Set( CComBSTR(pPage->GetObjPathName()),
                                      ADS_SETTYPE_FULL );
        RETURN_IF_FAIL;
        CComBSTR sbstrFromServerDN;
        hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrFromServerDN );
        RETURN_IF_FAIL;
        for (int i = 0; i < 4; i++)
        {
            hr = pathcracker.RemoveLeafElement();
            RETURN_IF_FAIL;
        }
        sbstrSearchPath.Empty();
        hr = pathcracker.Retrieve( ADS_FORMAT_X500, &sbstrSearchPath );
        RETURN_IF_FAIL;

        // find only connections which point to this nTDSDSA
        strFilterString.Format(
            L"(&(objectClass=nTDSConnection)(fromServer=%s))",
            sbstrFromServerDN);

    }
    CDSSearch Search;
    Search.Init(sbstrSearchPath);
    Search.SetFilterString(const_cast<LPWSTR>((LPCTSTR)strFilterString));
    Search.SetSearchScope( (fReplicateFrom) ? ADS_SCOPE_ONELEVEL : ADS_SCOPE_SUBTREE );
    LPWSTR pAttrs[1] = {(fReplicateFrom) ? L"fromServer" : L"distinguishedName"};
    Search.SetAttributeList(pAttrs, 1);
    HRESULT hr = Search.DoQuery();
    while (SUCCEEDED(hr)) {
        hr = Search.GetNextRow();
        if (S_ADS_NOMORE_ROWS == hr)
        {
            hr = S_OK;
            break;
        }
        BREAK_IF_FAIL;

        ADS_SEARCH_COLUMN col;
        ::ZeroMemory( &col, sizeof(col) );
        hr = Search.GetColumn (pAttrs[0], &col);
        BREAK_IF_FAIL;
        ASSERT( ADSTYPE_DN_STRING == col.pADsValues->dwType );

        CPathCracker pathcracker;
        hr = pathcracker.Set( CComBSTR(col.pADsValues->DNString),
                                 ADS_SETTYPE_DN );
        Search.FreeColumn (&col);
        BREAK_IF_FAIL;
        hr = pathcracker.SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
        BREAK_IF_FAIL;
        // JonN 6/22/00
        hr = pathcracker.put_EscapedMode( ADS_ESCAPEDMODE_OFF_EX );
        BREAK_IF_FAIL;
        CComBSTR sbstrName;
        hr = pathcracker.GetElement( (fReplicateFrom) ? 1 : 2, &sbstrName );
        BREAK_IF_FAIL;
        CComBSTR sbstrSite;
        hr = pathcracker.GetElement( (fReplicateFrom) ? 3 : 4, &sbstrSite );
        BREAK_IF_FAIL;

        lvitem.iItem = ListView_GetItemCount(hwnd);
        lvitem.pszText = sbstrName;
        int iItem = ListView_InsertItem( hwnd, &lvitem );
        if (-1 == iItem)
        {
            ASSERT(FALSE);
            break;
        }
        ListView_SetItemText( hwnd, iItem, 0, sbstrName );
        ListView_SetItemText( hwnd, iItem, 1, sbstrSite );
    }

    // select first item if any
    if (0 < ListView_GetItemCount( hwnd ))
    {
        ListView_SetItemState( hwnd, 0, LVIS_SELECTED, 0xFF );
    }

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   NTDSDSA_DNSAlias
//
//  Synopsis:   Populate DNS Alias in the NTDS-DSA General page
//
//  History:
//  04/26/00    JonN        created
//
//-----------------------------------------------------------------------------

HRESULT
NTDSDSA_DNSAlias(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (fInit != DlgOp)
        return S_OK;

    if (   NULL == pAttrInfo
        || 1 != pAttrInfo->dwNumValues
        || NULL == pAttrInfo->pADsValues
        || pAttrInfo->pADsValues[0].dwType != ADSTYPE_OCTET_STRING
        || sizeof(GUID) != pAttrInfo->pADsValues[0].OctetString.dwLength
        || NULL == pAttrInfo->pADsValues[0].OctetString.lpValue
       )
    {
        ASSERT(FALSE);
        return S_OK;
    }

    LPOLESTR lpolestr = NULL;
    GUID* pguidObjID = (GUID*)pAttrInfo->pADsValues[0].OctetString.lpValue;
    HRESULT hr = ::StringFromIID( *pguidObjID, &lpolestr );
    if (FAILED(hr) || NULL == lpolestr || !(*lpolestr))
    {
        ASSERT(FALSE);
        return S_OK;
    }

    // remove leading ('{') and trailing ('}') characters
    lpolestr[wcslen(lpolestr)-1] = _T('\0');
    CStr str = lpolestr+1;
    CoTaskMemFree(lpolestr);

    // extract the domain name from the path to this object
    CPathCracker pathcracker;
    hr = pathcracker.Set( CComBSTR(pPage->GetObjPathName()), ADS_SETTYPE_FULL );
    RETURN_IF_FAIL;
    CComBSTR sbstrDN;
    hr = pathcracker.Retrieve( ADS_FORMAT_X500_DN, &sbstrDN );
    RETURN_IF_FAIL;
    PWSTR pwszDomainName = NULL;
    hr = CrackName( sbstrDN,
                    &pwszDomainName,
                    GET_DNS_DOMAIN_NAME,
                    pPage->GetHWnd() );
    RETURN_IF_FAIL;

    // construct the DNS alias
    str += _T("._msdcs.");
    str += pwszDomainName;
    LocalFreeStringW(&pwszDomainName);

    SetDlgItemText( pPage->GetHWnd(), pAttrMap->nCtrlID, str );

	return S_OK;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\subclass.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Domains and Trust
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       subclass.cxx
//
//  Contents:   Control subclassing support
//
//  History:    28-Nov-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "subclass.h"

//+----------------------------------------------------------------------------
//
//  Class:     ControlSubclasser
//
//  Purpose:   Class for hooking the window proc of a control.
//
//-----------------------------------------------------------------------------
ControlSubclasser::ControlSubclasser() :
   hwnd(0),
   originalWindowProc(0)
{
   TRACE(ControlSubclasser,ControlSubclasser);
}

ControlSubclasser::~ControlSubclasser()
{
   TRACE(ControlSubclasser,~ControlSubclasser);

   UnhookWindowProc();
}

HRESULT
ControlSubclasser::Init(HWND control)
{
   TRACE(ControlSubclasser,Init);
   dspAssert(IsWindow(control));

   // hwnd should not be set, nor originalWindowProc.  If they are, then
   // Init has been called already.

   dspAssert(!hwnd);
   dspAssert(!originalWindowProc);

   hwnd = control;

   // save our this pointer so we can find ourselves again when messages
   // are sent to the window.

   SetWindowLongPtr(hwnd,
                    GWLP_USERDATA,
                    reinterpret_cast<LONG_PTR>(this));

   // hook the windows procedure.

   LONG_PTR ptr = GetWindowLongPtr(hwnd, GWLP_WNDPROC);

   CHECK_NULL(ptr, return E_OUTOFMEMORY);

   originalWindowProc = reinterpret_cast<WNDPROC>(ptr);

   if (!originalWindowProc)
   {
      dspDebugOut((DEB_ERROR, "unable to hook winproc"));

      hwnd = 0;
      return E_FAIL;
   }

   SetWindowLongPtr(hwnd,
                    GWLP_WNDPROC,
                    reinterpret_cast<LONG_PTR>(ControlSubclasser::WindowProc));

   return S_OK;
}

void
ControlSubclasser::UnhookWindowProc()
{
   TRACE(ControlSubclasser,UnhookWindowProc);

   if (IsWindow(hwnd) && originalWindowProc)
   {
      // unhook the window proc

      SetWindowLongPtr(hwnd,
                       GWLP_WNDPROC,
                       reinterpret_cast<LONG_PTR>(originalWindowProc));
   }
}

LRESULT
ControlSubclasser::OnMessage(UINT message, WPARAM wparam, LPARAM lparam)
{
   // TRACE(ControlSubclasser,OnMessage);

   switch (message)
   {
      case WM_DESTROY:
      {
         UnhookWindowProc();
         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return ::CallWindowProc(originalWindowProc, hwnd, message, wparam, lparam);
}

LRESULT
CALLBACK
ControlSubclasser::WindowProc(HWND   window,
                              UINT   message,
                              WPARAM wparam,
                              LPARAM lparam)
{
   // TRACE(ControlSubclasser,WindowProc)

   LRESULT result = 0;

   LONG_PTR ptr = GetWindowLongPtr(window, GWLP_USERDATA);

   if (ptr)
   {
      ControlSubclasser* that =
         reinterpret_cast<ControlSubclasser*>(ptr);

      dspAssert(that);

      result = that->OnMessage(message, wparam, lparam);
   }
   else
   {
      dspAssert(false);
   }

   return result;
}

//+----------------------------------------------------------------------------
//
//  Class:     MultiLineEditBoxThatForwardsEnterKey
//
//-----------------------------------------------------------------------------

MultiLineEditBoxThatForwardsEnterKey::MultiLineEditBoxThatForwardsEnterKey()
{
   TRACE(MultiLineEditBoxThatForwardsEnterKey,MultiLineEditBoxThatForwardsEnterKey);
}

MultiLineEditBoxThatForwardsEnterKey::~MultiLineEditBoxThatForwardsEnterKey()
{
   TRACE(MultiLineEditBoxThatForwardsEnterKey,~MultiLineEditBoxThatForwardsEnterKey);
}

HRESULT
MultiLineEditBoxThatForwardsEnterKey::Init(HWND editControl)
{
   TRACE(MultiLineEditBoxThatForwardsEnterKey,Init);

   HRESULT hr = ControlSubclasser::Init(editControl);

   return hr;
}

LRESULT
MultiLineEditBoxThatForwardsEnterKey::OnMessage(
   UINT   message,
   WPARAM wparam,
   LPARAM lparam)
{
   // TRACE(MultiLineEditBoxThatForwardsEnterKey,OnMessage);

   switch (message)
   {
      case WM_KEYDOWN:
      {
          switch (wparam)
         {
            case VK_RETURN:
            {
               // Send the parent window a WM_COMMAND message with
               // FORWARDED_ENTER as the notification code.

               SendMessage(GetParent(hwnd),
                           WM_COMMAND,
                           MAKELONG(GetDlgCtrlID(hwnd), FORWARDED_ENTER),
                           reinterpret_cast<LPARAM>(hwnd));
               break;
            }

            default:
            {
               // do nothing

               break;
            }
         }

         break;
      }
      default:
      {
         // do nothing

         break;
      }
   }

   return ControlSubclasser::OnMessage(message, wparam, lparam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\tdoprop.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       tdoprop.cxx
//
//  Contents:   TDO trust page
//
//  History:    16-Nov-00 EricB split from trust.cxx
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "trust.h"
#include "routing.h"
#include "trustwiz.h"
#include <lmerr.h>

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Trusted-Domain object General page
//
//-----------------------------------------------------------------------------

PWSTR g_pwzErr = L"<error, no value!>";

//+----------------------------------------------------------------------------
//
//  Member: CDsTrustedDomainPage::CDsTrustedDomainPage
//
//-----------------------------------------------------------------------------
CDsTrustedDomainPage::CDsTrustedDomainPage() :
    m_ulTrustType(0),
    m_ulTrustAttrs(0),
    m_nTrustDirection(0),
    m_nRelationship(TRUST_REL_UNKNOWN),
    m_pwzTrustedDomDnsName(NULL),
    m_pwzTrustedDomFlatName(NULL),
    _pForestNamePage(NULL)
{
    TRACE(CDsTrustedDomainPage,CDsTrustedDomainPage);
#ifdef _DEBUG
    // NOTICE-2002/02/15-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
    strcpy(szClass, "CDsTrustedDomainPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsTrustedDomainPage::~CDsTrustedDomainPage
//
//-----------------------------------------------------------------------------
CDsTrustedDomainPage::~CDsTrustedDomainPage()
{
    TRACE(CDsTrustedDomainPage,~CDsTrustedDomainPage);
    DO_DEL(m_pwzTrustedDomDnsName);
    DO_DEL(m_pwzTrustedDomFlatName);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::Initialize
//
//  Synopsis:   Initialialization done at WM_INITDIALOG time.
//
//-----------------------------------------------------------------------------
HRESULT
CDsTrustedDomainPage::Initialize(CDsPropPageBase * pPage)
{
   TRACER(CDsTrustedDomainPage,Initialize);
   HRESULT hr = CTrustPropPageBase::Initialize(pPage);

   CHECK_HRESULT(hr, return hr);

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::ExtraTrustPages
//
//  Synopsis:   If forest trust, create the forest trust name routing page.
//
//-----------------------------------------------------------------------------
HRESULT
CDsTrustedDomainPage::ExtraTrustPages(BOOL fReadOnly)
{
   TRACER(CDsTrustedDomainPage,ExtraTrustPages);
   HRESULT hr = S_OK;

   if (IsForestTrust())
   {
      // Create the name routing page.
      //
      _pForestNamePage = new CDsForestNameRoutingPage(GetParent(m_pPage->GetHWnd()));

      CHECK_NULL(_pForestNamePage, return E_OUTOFMEMORY);

      hr = _pForestNamePage->Init(GetDnsDomainName(), GetTrustPartnerDnsName(),
                                  GetTrustPartnerFlatName(),
                                  GetUncDcName(), m_nTrustDirection,
                                  fReadOnly, GetForestName(), this );
   }

   if ((IsForestTrust() || IsExternalTrust()) && IsOutgoingTrust())
   {
      // Create the my-org authentication page.
      //
      CTrustAuthPropPage * pTrustAuthPage = new CTrustAuthPropPage(GetParent(m_pPage->GetHWnd()));

      CHECK_NULL(pTrustAuthPage, return E_OUTOFMEMORY);

      hr = pTrustAuthPage->Init(GetDnsDomainName(), GetTrustPartnerDnsName(),
                                GetUncDcName(), m_ulTrustAttrs,
                                m_nRelationship, fReadOnly);

      // NTRAID#NTBUG9-692708-2002/08/24-ericb If the initialization fails, then free
      // the object. Otherwise the object/page frees itself on prop sheet destruction.
      //
      if (FAILED(hr))
      {
          delete pTrustAuthPage;
      }
   }

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::SetFlatName
//
//-----------------------------------------------------------------------------
BOOL
CDsTrustedDomainPage::SetFlatName(PWSTR pwzFlatName)
{
    return AllocWStr(pwzFlatName, &m_pwzTrustedDomFlatName);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::SetDnsName
//
//-----------------------------------------------------------------------------
BOOL
CDsTrustedDomainPage::SetDnsName(PWSTR pwzDnsName)
{
    return AllocWStr(pwzDnsName, &m_pwzTrustedDomDnsName);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::TrustType
//
//  Synopsis:   Save the value and return the string name for the type of trust
//              and the state of transitivity.
//
//-----------------------------------------------------------------------------
HRESULT
CDsTrustedDomainPage::TrustType(int nType, CStrW& strType)
{
    strType = g_pwzErr;
    m_ulTrustType = (ULONG)nType;

    if (!GetTrustPartnerFlatName())
    {
        return E_OUTOFMEMORY;
    }

    for (ULONG i = 0; i < m_cTrusts; i++)
    {
        // NOTICE-2002/02/15-ericb - SecurityPush: these are both strings that
        // I have created elsewhere.
        if (_wcsicmp(m_rgTrustList[i].strFlatName, GetTrustPartnerFlatName()) == 0)
        {
            m_nRelationship = m_rgTrustList[i].nRelationship;
            break;
        }
    }

    int idRel;
    //
    // Get the relationship string.
    //
    switch (m_nRelationship)
    {
    case TRUST_REL_PARENT:
        idRel = IDS_REL_PARENT;
        break;

    case TRUST_REL_CHILD:
        idRel = IDS_REL_CHILD;
        break;

    case TRUST_REL_ROOT:
        idRel = IDS_REL_TREE_ROOT;
        break;

    case TRUST_REL_CROSSLINK:
        idRel = IDS_REL_CROSSLINK;
        break;

    case TRUST_REL_EXTERNAL:
        idRel = IDS_REL_EXTERNAL;
        break;

    case TRUST_REL_FOREST:
        idRel = IDS_REL_FOREST;
        break;

    case TRUST_REL_INDIRECT:
        idRel = IDS_REL_INDIRECT;
        break;

    case TRUST_REL_MIT:
        idRel = IDS_REL_MIT;
        break;

    default:
        idRel = IDS_REL_UNKNOWN;
        break;
    }

    // NOTICE-2002/02/15-ericb - SecurityPush: CStrW::LoadString sets the
    // string to an empty string on failure.
    strType.LoadString(g_hInstance, idRel);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::TrustDirection
//
//  Synopsis:   Return the string for the direction of trust.
//
//-----------------------------------------------------------------------------
void
CDsTrustedDomainPage::TrustDirection(int nDirection, CStrW& strDirection)
{
    m_nTrustDirection = nDirection;
    int idDir;

    switch (m_nTrustDirection)
    {
    case TRUST_DIRECTION_INBOUND:
        idDir = (m_nRelationship == TRUST_REL_CROSSLINK) ?
                IDS_TRUST_DIR_INBOUND_SHORTCUT : IDS_TRUST_DIR_INBOUND;
        break;

    case TRUST_DIRECTION_OUTBOUND:
        idDir = (m_nRelationship == TRUST_REL_CROSSLINK) ?
                IDS_TRUST_DIR_OUTBOUND_SHORTCUT : IDS_TRUST_DIR_OUTBOUND;
        break;

    case TRUST_DIRECTION_BIDIRECTIONAL:
        idDir = IDS_TRUST_DIR_BIDI;
        break;

    default:
        idDir = IDS_TRUST_DISABLED;
        break;
    }
    // NOTICE-2002/02/15-ericb - SecurityPush: see above CStrW::Loadstring notice
    strDirection.LoadString(g_hInstance, idDir);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::SetTransitive
//
//  Synopsis:   Turn transitivity on or off.
//
//-----------------------------------------------------------------------------
HRESULT
CDsTrustedDomainPage::SetTransitive(BOOL fTransitive)
{
    DWORD Win32Err;
    NTSTATUS Status;
    PTRUSTED_DOMAIN_INFORMATION_EX pTDIx = NULL;
    PLSA_UNICODE_STRING pName;
    LSA_UNICODE_STRING Name;
    CWaitCursor Wait;

    CPolicyHandle cPolicy(GetUncDcName());

    Win32Err = cPolicy.OpenWithPrompt(_CredMgr._LocalCreds, Wait,
                                      GetDnsDomainName(), m_pPage->GetHWnd());

    if (ERROR_CANCELLED == Win32Err)
    {
        // don't report error if user canceled.
        //
        return ADM_S_SKIP;
    }

    if (ERROR_ACCESS_DENIED == Win32Err)
    {
       // the user entered creds are no good.
       _CredMgr._LocalCreds.Clear();
    }

    CHECK_WIN32(Win32Err, return HRESULT_FROM_WIN32(Win32Err));

    RtlInitUnicodeString(&Name, GetTrustPartnerDnsName());
    pName = &Name;

    Status = LsaQueryTrustedDomainInfoByName(cPolicy,
                                             pName,
                                             TrustedDomainInformationEx,
                                             (PVOID *)&pTDIx);

    Win32Err = LsaNtStatusToWinError(Status);

    CHECK_WIN32(Win32Err, return HRESULT_FROM_WIN32(Win32Err));

    if (fTransitive)
    {
        pTDIx->TrustAttributes &= ~(TRUST_ATTRIBUTE_NON_TRANSITIVE);
    }
    else
    {
        pTDIx->TrustAttributes |= TRUST_ATTRIBUTE_NON_TRANSITIVE;
    }

    Status = LsaSetTrustedDomainInfoByName(cPolicy,
                                           pName,
                                           TrustedDomainInformationEx,
                                           pTDIx);
    LsaFreeMemory(pTDIx);
    Win32Err = LsaNtStatusToWinError(Status);

    CHECK_WIN32(Win32Err, return HRESULT_FROM_WIN32(Win32Err));

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CurDomainText
//
//  Synopsis:   Puts the name of the current domain in the corresponding text
//              box.
//
//  Warning:    This must be the first attr function called as it allocates
//              the class object. It also reads the trusted-domain flat-name
//              attribute.
//
//-----------------------------------------------------------------------------
HRESULT
CurDomainText(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
              DLG_OP DlgOp)
{
    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (DlgOp == fOnCallbackRelease)
    {
        DO_DEL(pTDPage);
        return S_OK;
    }
    if (DlgOp != fInit)
    {
        return S_OK;
    }
    HRESULT hr;

    pTDPage = new CDsTrustedDomainPage;

    CHECK_NULL_REPORT(pTDPage, pPage->GetHWnd(), return E_OUTOFMEMORY);

    hr = pTDPage->Initialize(pPage);

    CHECK_HRESULT(hr, return hr);

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pTDPage->GetDnsDomainName());

    reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData = reinterpret_cast<LPARAM>(pTDPage);

    dspAssert(pAttrInfo && pAttrInfo->dwNumValues);

    if (pAttrInfo && pAttrInfo->dwNumValues)
    {
        if (!pTDPage->SetFlatName(pAttrInfo->pADsValues->CaseIgnoreString))
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   PeerDomain
//
//  Synopsis:   Fills in the peer domain name, which is the DNS name of the
//              domain represented by the trusted-domain object. The
//              attribute is trustPartner.
//
//-----------------------------------------------------------------------------
HRESULT
PeerDomain(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
           DLG_OP DlgOp)
{
    if (DlgOp != fInit)
    {
        return S_OK;
    }
    PWSTR pwzTrustedDomDnsName = g_pwzErr;
    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
    {
        // This can happen if the page is canceled during initialization.
        //
        return S_OK;
    }

    dspAssert(pAttrInfo && pAttrInfo->dwNumValues);

    if (pAttrInfo && pAttrInfo->dwNumValues)
    {
        pwzTrustedDomDnsName = pAttrInfo->pADsValues->CaseIgnoreString;

        if (!pTDPage->SetDnsName(pwzTrustedDomDnsName))
        {
            REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
            return E_OUTOFMEMORY;
        }
    }

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pwzTrustedDomDnsName);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustType
//
//  Synopsis:   Fills in the trust type value. Also fills in the transitivity
//              value. If MIT trust, handles the apply for the transitivity.
//
//  Notes:      This attr function reads and stores the trust-type value
//              which is then used by the TransitiveTextOrButton function.
//              Therefore, this function must be called first.
//
//-----------------------------------------------------------------------------
HRESULT
TrustType(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
          PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
          DLG_OP DlgOp)
{
    if (DlgOp != fInit)
    {
        return S_OK;
    }
    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
    {
        // This can happen if the page is canceled during initialization.
        //
        return S_OK;
    }

    CStrW strType = g_pwzErr, strTrans = g_pwzErr;
    dspAssert(pAttrInfo && pAttrInfo->dwNumValues);

    if (pAttrInfo && pAttrInfo->dwNumValues)
    {
        pTDPage->TrustType(pAttrInfo->pADsValues->Integer, strType);

        if (pTDPage->IsParentChild())
        {
            CStrW strLabelFormat, strLabel;
    
            // NOTICE-2002/02/15-ericb - SecurityPush: see above CStrW::Loadstring notice
            strLabelFormat.LoadString(g_hInstance, IDS_TRUSTDOM_LABEL_FORMAT);

            strLabel.Format(strLabelFormat, strType);
    
            SetDlgItemText(pPage->GetHWnd(), IDC_PEER_LABEL, strLabel);

            strType.LoadString(g_hInstance, IDS_TRUST_PARENTCHILD);
        }
    }

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, strType);

    if (pTDPage->CantVerify())
    {
        ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_VERIFY_STATIC), SW_HIDE);
        HWND hCtrl = GetDlgItem(pPage->GetHWnd(), IDC_TRUST_RESET_BTN);
        ShowWindow(hCtrl, SW_HIDE);
        EnableWindow(hCtrl, FALSE);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TransitiveTextOrButton
//
//  Synopsis:   Handle processing for the transitivity text box/yes-radio
//              button.
//
//-----------------------------------------------------------------------------
HRESULT
TransitiveTextOrButton(CDsPropPageBase * pPage, PATTR_MAP,
                       PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                       DLG_OP DlgOp)
{
    // NTRAID#NTBUG9-750152-2002/12/17-shasan These are the only events we process in this function
    if ( ( DlgOp != fInit ) && 
         ( DlgOp != fOnCommand ) &&
         ( DlgOp != fApply )
       )
    {
        return S_OK;
    }

    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
    {
        // This can happen if the page is canceled during initialization.
        //
        return S_OK;
    }

    switch (DlgOp)
    {
    case fInit:
        if (pAttrInfo && pAttrInfo->dwNumValues)
        {
            pTDPage->SetTrustAttrs(pAttrInfo->pADsValues->Integer);

            if (pTDPage->IsMIT())
            {
                // If it is an MIT trust then show the yes/no radio buttons
                // rather than the read-only edit control.
                //
                ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_TRANS_STATIC), SW_HIDE);
                ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_TRUST_TRANS_EDIT), SW_HIDE);

                HWND hCtrl = GetDlgItem(pPage->GetHWnd(), IDC_TRANS_GROUPBOX);
                ShowWindow(hCtrl, SW_SHOW);
                hCtrl = GetDlgItem(pPage->GetHWnd(), IDC_TRANS_YES_RADIO);
                ShowWindow(hCtrl, SW_SHOW);
                EnableWindow(hCtrl, TRUE);
                hCtrl = GetDlgItem(pPage->GetHWnd(), IDC_TRANS_NO_RADIO);
                ShowWindow(hCtrl, SW_SHOW);
                EnableWindow(hCtrl, TRUE);
                CheckDlgButton(pPage->GetHWnd(),
                               pTDPage->IsNonTransitive() ? IDC_TRANS_NO_RADIO : IDC_TRANS_YES_RADIO,
                               BST_CHECKED);
            }
            else
            {
                CStrW strTrans;
                int idTrans = IDS_TRUST_TRANSITIVE;

                if (pTDPage->IsForestTrust())
                {
                   idTrans = IDS_TRUST_FOREST_TRANSITIVE;
                }
                else
                {
                   if (pTDPage->IsNonTransitive())
                   {
                       idTrans = IDS_TRUST_NON_TRANSITIVE;
                   }
                }
                // NOTICE-2002/02/15-ericb - SecurityPush: see above CStrW::Loadstring notice
                strTrans.LoadString(g_hInstance, idTrans);

                SetDlgItemText(pPage->GetHWnd(), IDC_TRUST_TRANS_EDIT, strTrans);
            }
        }
        //
        // Invoke the extra pages code here after all of the trust attributes
        // have been read and the member variables initialized. The order of
        // the attr functions in the PATTR_MAP array determines execution order.
        //
        pTDPage->ExtraTrustPages(pPage->IsReadOnly());

        break;

    case fOnCommand:
        if (BN_CLICKED == lParam)
        {
            if (pTDPage->IsMIT())
            {
                DBG_OUT("TrustTransYes BN_CLICKED\n");
                pPage->SetDirty();
            }
        }
        break;

    case fApply:
        dspAssert(pTDPage->IsMIT());
        HRESULT hr;

        hr = pTDPage->SetTransitive(IsDlgButtonChecked(pPage->GetHWnd(), IDC_TRANS_YES_RADIO));

        if (FAILED(hr))
        {
            // Restore the old state.
            //
            if (IsDlgButtonChecked(pPage->GetHWnd(), IDC_TRANS_YES_RADIO))
            {
                CheckDlgButton(pPage->GetHWnd(), IDC_TRANS_NO_RADIO, BST_CHECKED);
                CheckDlgButton(pPage->GetHWnd(), IDC_TRANS_YES_RADIO, BST_UNCHECKED);
            }
            else
            {
                CheckDlgButton(pPage->GetHWnd(), IDC_TRANS_YES_RADIO, BST_CHECKED);
                CheckDlgButton(pPage->GetHWnd(), IDC_TRANS_NO_RADIO, BST_UNCHECKED);
            }

            if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
            {
                ReportError(hr, IDS_ERR_CHANGE_TRANSITIVITY, pPage->GetHWnd());
            }
        }
        
        return ADM_S_SKIP;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustTransNo
//
//  Synopsis:   Handle processing for the transitivity No radiobutton.
//
//-----------------------------------------------------------------------------
HRESULT
TrustTransNo(CDsPropPageBase * pPage, PATTR_MAP,
             PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
             DLG_OP DlgOp)
{
    switch (DlgOp)
    {
    case fOnCommand:
        if (BN_CLICKED == lParam)
        {
            DBG_OUT("TrustTransNo BN_CLICKED\n");
            pPage->SetDirty();
        }
        break;

    case fApply:
        return ADM_S_SKIP;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustVerifyText
//
//  Synopsis:   Sets the text next to the Validate button
//
//-----------------------------------------------------------------------------

HRESULT
TrustVerifyText(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                DLG_OP DlgOp)
{
    if (DlgOp != fInit)
    {
        return S_OK;
    }
    CStrW strValidateText;
    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
    {
        // This can happen if the page is canceled during initialization.
        //
        return S_OK;
    }

    if ( pTDPage->IsForestTrust () )
    {
        strValidateText.LoadString( g_hInstance, IDS_TRUST_VERIFY_FOREST_TEXT );
    }
    else
    {
        strValidateText.LoadString( g_hInstance, IDS_TRUST_VERIFY_TEXT );
    }

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, strValidateText);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustDirection
//
//  Synopsis:   Direction-of-trust value.
//
//-----------------------------------------------------------------------------
HRESULT
TrustDirection(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
               DLG_OP DlgOp)
{
    if (DlgOp != fInit)
    {
        return S_OK;
    }
    CStrW strDirection;
    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
    {
        // This can happen if the page is canceled during initialization.
        //
        return S_OK;
    }

    dspAssert(pAttrInfo && pAttrInfo->dwNumValues);

    if (pAttrInfo && pAttrInfo->dwNumValues)
    {
        pTDPage->TrustDirection(pAttrInfo->pADsValues->Integer, strDirection);
    }

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, strDirection);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustVerifyBtn
//
//  Synopsis:   If the button is pressed, force new passwords into the trust
//              relationship.
//
//-----------------------------------------------------------------------------
HRESULT
TrustVerifyBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO, LPARAM, PATTR_DATA,
              DLG_OP DlgOp)
{
    // NTRAID#NTBUG9-750152-2002/12/17-shasan These are the only events we process in this function
    if ( ( DlgOp != fInit ) && 
         ( DlgOp != fOnCommand )
       )
    {
        return S_OK;
    }

    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
    {
        // This can happen if the parent page is canceled during initialization.
        //
        if (DlgOp == fInit)
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }
        return S_OK;
    }

    if (DlgOp == fInit && pPage->IsReadOnly())
    {
        EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        return S_OK;
    }

    if (DlgOp != fOnCommand)
    {
        return S_OK;
    }

    if (IDYES != pTDPage->OnVerifyTrustBtn())
    {
        return S_OK;
    }

    HRESULT hr = pTDPage->ResetTrust();

    if (SUCCEEDED(hr))
    {
        MsgBox(IDS_TRUST_RESET_DONE, pPage->GetHWnd());
    }
    else
    {
        // Don't post error message for ERROR_CANCELLED.
        //
        if (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr)
        {
            ReportError(hr, IDS_ERROR_TRUST_RESET, pPage->GetHWnd());
        }
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   SaveFTInfoBtn
//
//  Synopsis:   If the button is pressed, prompt the user for a file name and
//              then save the FTInfo as a text file.
//
//-----------------------------------------------------------------------------
HRESULT
SaveFTInfoBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
              DLG_OP DlgOp)
{
    // NTRAID#NTBUG9-750152-2002/12/17-shasan These are the only events we process in this function
    if ( ( DlgOp != fInit ) && 
         ( DlgOp != fOnCommand )
       )
    {
        return S_OK;
    }


   if (!pPage)
   {
      dspAssert(FALSE);
      return E_FAIL;
   }

   CDsTrustedDomainPage * pTDPage = 
      reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

   if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
   {
      // This can happen if the parent page is canceled during initialization.
      //
      return S_OK;
   }

   if (DlgOp == fInit && pTDPage->IsForestTrust())
   {
      // Show the Save-Names button & label
      //
      ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_SAVE_FOREST_NAMES_STATIC), SW_SHOW);
      HWND hBtn = GetDlgItem(pPage->GetHWnd(), IDC_SAVE_FOREST_NAMES_BTN);
      ShowWindow(hBtn, SW_SHOW);
      EnableWindow(hBtn, pPage->IsReadOnly() ? FALSE : TRUE);
      return S_OK;
   }

   if (DlgOp == fOnCommand)
   {
      pTDPage->OnSaveFTInfoBtn();
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TrustQStateText
//
//  Synopsis:   Sets the text describing the Quarantined state of a trust
//
//-----------------------------------------------------------------------------
HRESULT
TrustQStateText(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                DLG_OP DlgOp)
{
    if (DlgOp == fInit )
    {
        CDsTrustedDomainPage * pTDPage;

        pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

        if (IsBadReadPtr(pTDPage, sizeof(PVOID)))
        {
            // This can happen if the page is canceled during initialization.
            //
            return S_OK;
        }

        if ( pTDPage->IsExternalTrust() && pTDPage->IsOutgoingTrust () )
        {
            if ( pTDPage->IsQuarantinedTrust () )
            {
                ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_QUARANTINE_STATIC), SW_SHOW);
            }
            else
            {
                ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_WARNING_ICON), SW_SHOW);
                ShowWindow(GetDlgItem(pPage->GetHWnd(), IDC_NO_QUARANTINE_STATIC), SW_SHOW);
            }            

            return S_OK;
        }
        else
            return S_OK;
    }
    else 
    {
        if ( DlgOp == fOnNotify && 
             ( 
               (
                ((NMHDR FAR*)lParam)->idFrom == IDC_QUARANTINE_STATIC ||
                ((NMHDR FAR*)lParam)->idFrom == IDC_NO_QUARANTINE_STATIC
               )
               && 
               ( 
                ((NMHDR FAR*)lParam)->code == NM_CLICK ||
                ((NMHDR FAR*)lParam)->code == NM_RETURN
               )
             )
           )
        {
            ShowHelp ( L"adconcepts.chm::/domadmin_concepts_explicit.htm#SIDFiltering" );
            return S_OK;
        }
        else 
            return S_OK;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::OnVerifyTrustBtn
//
//  Synopsis:   Check the status of the trust link.
//
//  Returns:    IDYES - the trust verification failed and the user choose Yes
//                      to repair the trust.
//              IDNO  - don't repair the trust either because it verified OK
//                      or the user choose not to repair it.
//
//-----------------------------------------------------------------------------
int
CDsTrustedDomainPage::OnVerifyTrustBtn(void)
{
    TRACE(CDsTrustedDomainPage, OnVerifyTrustBtn);
    TD_DOM_INFO Remote;
    int nResponse = IDNO;
    HRESULT hr;
    BOOL fFailed = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    CWaitCursor Wait;

    // NOTICE-2002/02/15-ericb - SecurityPush: zeroing a struct.
    RtlZeroMemory(&Remote, sizeof(Remote));

    if (m_nTrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
       // See if the user has admin privileges. If not, get the creds.
       //
       CPolicyHandle cPolicy(GetUncDcName());

       dwErr = cPolicy.OpenWithPrompt(_CredMgr._LocalCreds, Wait,
                                      GetDnsDomainName(), m_pPage->GetHWnd());
       if (ERROR_CANCELLED == dwErr)
       {
           return IDNO;
       }

       if (ERROR_SUCCESS != dwErr)
       {
           Wait.SetOld();
           if (ERROR_NO_SUCH_DOMAIN == dwErr)
           {
               ErrMsgParam(IDS_TRUST_VERIFY_NO_DC, (LPARAM)GetDnsDomainName(),
                           m_pPage->GetHWnd());
           }
           else if (RPC_S_SERVER_UNAVAILABLE == dwErr)
           {
               ErrMsgParam(IDS_TRUST_LSAOPEN_NO_RPC, (LPARAM)GetDcName(),
                           m_pPage->GetHWnd());
           }
           else
           {
               PCWSTR pwzDomainName = GetDnsDomainName();
               SuperMsgBox(m_pPage->GetHWnd(), IDS_VERIFY_BAD_CREDS, 0, MB_OK |
                           MB_ICONEXCLAMATION, dwErr, (PVOID *)&pwzDomainName, 1,
                           FALSE, __FILE__, __LINE__);
               _CredMgr._LocalCreds.Clear();
           }
           return IDNO;
       }

       cPolicy.Close();
    }

    Wait.SetWait();

    Remote.ulTrustType = m_ulTrustType; // set the trust type, so that Getinfo.. 
                                        // knows what to do

    hr = GetInfoForRemoteDomain(GetTrustPartnerDnsName(), &Remote, _CredMgr,
                                m_pPage->GetHWnd());
    if (Remote.Policy)
    {
        LsaClose(Remote.Policy);
        Remote.Policy = NULL;
    }

    if (FAILED(hr))
    {
        Wait.SetOld();
        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr ||
            HRESULT_FROM_WIN32(ERROR_BAD_NETPATH) == hr)
        {
            ErrMsgParam(IDS_TRUST_VERIFY_NO_DC, (LPARAM)GetTrustPartnerDnsName(),
                        m_pPage->GetHWnd());
        }
        else if (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr &&
                 Remote.pwzUncDcName)
        {
            ErrMsgParam(IDS_TRUST_LSAOPEN_NO_RPC, (LPARAM)(Remote.pwzUncDcName + 2),
                        m_pPage->GetHWnd());
        }
        else
        {
            PWSTR * ppwzDomainName = &m_pwzTrustedDomDnsName;
            SuperMsgBox(m_pPage->GetHWnd(), IDS_TRUST_BAD_DOMAIN, 0, MB_OK |
                        MB_ICONEXCLAMATION, hr, (PVOID *)ppwzDomainName, 1,
                        FALSE, __FILE__, __LINE__);
        }
        return IDNO;
    }

    Wait.SetWait();

    PCWSTR pwzLocalDomainName = NULL;
    CStrW strRemoteDomainName;
    DWORD dwVerifyFlags = 0;

    if (TRUST_TYPE_DOWNLEVEL == Remote.ulTrustType)
    {
        // NOTICE-2002/03/07-ericb - SecurityPush: UNICODE_STRINGS don't have
        // to be NULL terminated. Assigning to a CStrW will convert it to a
        // NULL terminated string.
        strRemoteDomainName = Remote.pDownlevelDomainInfo->Name;
        pwzLocalDomainName = GetDomainFlatName();
        dwVerifyFlags |= DS_TRUST_VERIFY_DOWNLEVEL;
    }
    else
    {
        strRemoteDomainName = Remote.pDnsDomainInfo->DnsDomainName;
        pwzLocalDomainName = GetDnsDomainName();
    }

    PWSTR pwzRemoteDcUsed = NULL;
    bool fRemoteDcNeedsFreeing = false;
    CStrW strMsg;

    if (m_nTrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
        dwErr = VerifyTrustOneDirection(GetUncDcName(),
                                        GetDnsDomainName(),
                                        strRemoteDomainName,
                                        &pwzRemoteDcUsed,
                                        _CredMgr._LocalCreds,
                                        Wait,
                                        strMsg,
                                        dwVerifyFlags);
        _CredMgr.Revert();

        if (ERROR_SUCCESS == dwErr)
        {
           // NOTICE-2002/02/15-ericb - SecurityPush: see above CStrW::Loadstring notice
           strMsg.LoadString(g_hInstance, IDS_VERIFY_OUTBOUND);
           strMsg += g_wzCRLF;
           strMsg += g_wzCRLF;
        }
        else
        {
            if (ERROR_CANCELLED == dwErr || ERROR_LOGON_FAILURE == dwErr)
            {
               Wait.SetOld();
               goto ExitCleanup;
            }
            //
            // Set boolean to later prompt for repair.
            //
            fFailed = TRUE;
            //
            // try inbound even if outbound failed.
        }
    }

    DWORD dwErr2 = NO_ERROR;
    dwErr2 = 0;
    bool fInboundSkipped = false;

    if (m_nTrustDirection & TRUST_DIRECTION_INBOUND)
    {
        if (!_CredMgr._RemoteCreds.IsSet())
        {
           // If we don't have credentials for the trusting domain, ask the
           // user if they want to verify the inbound direction and get
           // creds if they answer yes.
           //
           CVerifyInboundDlg VerifyInboundDlg(m_pPage->GetHWnd(),
                                              _CredMgr._RemoteCreds,
                                              GetTrustPartnerDnsName());

           nResponse = (int)VerifyInboundDlg.DoModal();
        }
        else
        {
           // Since we have creds, just do the verify.
           //
           nResponse = IDYES;
        }

        if (IDYES == nResponse)
        {
           Wait.SetWait();

           if (!pwzRemoteDcUsed)
           {
              pwzRemoteDcUsed = Remote.pwzUncDcName;
           }
           else
           {
              fRemoteDcNeedsFreeing = true;
           }

           // First, check to see if the creds are valid.
           //
           bool fTryAgain = false;

           do
           {
              fTryAgain = false;

              _CredMgr.ImpersonateRemote();

              CPolicyHandle cPolicy(pwzRemoteDcUsed);

              dwErr2 = cPolicy.OpenReqAdmin();

              if (ERROR_SUCCESS != dwErr2)
              {
                 Wait.SetOld();
                 _CredMgr.Revert();

                 if (ERROR_NO_SUCH_DOMAIN == dwErr2)
                 {
                    ErrMsgParam(IDS_TRUST_VERIFY_NO_DC, (LPARAM)GetDnsDomainName(),
                                m_pPage->GetHWnd());
                 }
                 else
                 {
                    if (ERROR_ACCESS_DENIED == dwErr2)
                    {
                       // Prompt for creds again.
                       //
                       _CredMgr._RemoteCreds.Clear();

                       dwErr2 = _CredMgr._RemoteCreds.PromptForCreds(strRemoteDomainName,
                                                                     m_pPage->GetHWnd());
                       if (ERROR_SUCCESS == dwErr2)
                       {
                          fTryAgain = true;
                          continue;
                       }
                       if (ERROR_CANCELLED == dwErr2)
                       {
                          return IDNO;
                       }
                    }

                    if (ERROR_SUCCESS != dwErr2)
                    {
                       PCWSTR pwzDomainName = GetTrustPartnerDnsName();
                       SuperMsgBox(m_pPage->GetHWnd(), IDS_VERIFY_BAD_CREDS, 0,
                                   MB_OK | MB_ICONEXCLAMATION, dwErr2,
                                   (PVOID *)&pwzDomainName, 1,
                                   FALSE, __FILE__, __LINE__);
                       _CredMgr._RemoteCreds.Clear(); // does a revert.
                    }
                 }

                 if (fRemoteDcNeedsFreeing)
                 {
                    DO_DEL(pwzRemoteDcUsed);
                 }

                 return IDNO;
              }
              cPolicy.Close();

           } while (fTryAgain);

           // Now do the verification.
           //
           dwErr2 = VerifyTrustOneDirection(pwzRemoteDcUsed,
                                            strRemoteDomainName,
                                            pwzLocalDomainName,
                                            NULL,
                                            _CredMgr._RemoteCreds,
                                            Wait,
                                            strMsg,
                                            dwVerifyFlags);
           _CredMgr.Revert();

           if (ERROR_SUCCESS == dwErr2)
           {
              CStrW strOK;
              // NOTICE-2002/02/15-ericb - SecurityPush: see above CStrW::Loadstring notice
              strOK.LoadString(g_hInstance, IDS_VERIFY_INBOUND);
              strMsg += strOK;
              strMsg += g_wzCRLF;
              strMsg += g_wzCRLF;
           }
           else
           {
               Wait.SetOld();
               if (ERROR_CANCELLED == dwErr2 || ERROR_LOGON_FAILURE == dwErr2)
               {
                   dwErr = ERROR_CANCELLED;
                   if (fRemoteDcNeedsFreeing)
                   {
                      DO_DEL(pwzRemoteDcUsed);
                   }
                   goto ExitCleanup;
               }
               fFailed = TRUE;
           }
        }
        else
        {
           fInboundSkipped = true;
        }
    }

    if (fRemoteDcNeedsFreeing)
    {
       DO_DEL(pwzRemoteDcUsed);
    }
    Wait.SetOld();

    if (fFailed)
    {
       PCWSTR rgpwzDomainNames[] = {GetDnsDomainName(), GetTrustPartnerDnsName()};

       if (TRUST_TYPE_DOWNLEVEL == Remote.ulTrustType)
       {
          SuperMsgBox(m_pPage->GetHWnd(), IDS_VERIFY_DOWNLEVEL_TRUST_NOGOOD, 0,
                      MB_OK | MB_ICONEXCLAMATION, (dwErr) ? dwErr : dwErr2,
                      (PVOID *)rgpwzDomainNames, 2, FALSE, __FILE__, __LINE__);

          nResponse = IDNO;
       }
       else if (ERROR_DOMAIN_TRUST_INCONSISTENT == dwErr ||
                ERROR_DOMAIN_TRUST_INCONSISTENT == dwErr2)
       {
          // The trust attribute types don't match; one side is
          // forest but the other isn't.
          //
          CStrW strTitle, strMsg1, strFix;
          PWSTR pwzMsg = NULL;

          DspFormatMessage(IsForestTrust() ? IDS_VERIFY_MISMATCH_LF :
                           IDS_VERIFY_MISMATCH_RF, 0,
                           (PVOID *)rgpwzDomainNames, 2,
                           FALSE, &pwzMsg);
          if (pwzMsg)
          {
             strMsg1 = pwzMsg;
             strMsg1 += g_wzCRLF;
             strMsg1 += g_wzCRLF;

             LocalFree(pwzMsg);
          }

          // NOTICE-2002/02/15-ericb - SecurityPush: see above CStrW::Loadstring notice
          strTitle.LoadString(g_hInstance, IDS_DNT_MSG_TITLE);
          strFix.LoadString(g_hInstance, IDS_VERIFY_MISMATCH_FIX);
          strMsg1 += strFix;

          MessageBox(m_pPage->GetHWnd(), strMsg1, strTitle, MB_ICONEXCLAMATION);

          nResponse = IDNO;
       }
       else
       {
          CVerifyResultsQueryResetDlg ResultsQueryResetDlg(m_pPage->GetHWnd(),
                                                           strMsg,
                                                           _CredMgr._RemoteCreds,
                                                           GetTrustPartnerDnsName());

          nResponse = (int)ResultsQueryResetDlg.DoModal();
       }
    }
    else
    {
       if (TRUST_DIRECTION_INBOUND == m_nTrustDirection && fInboundSkipped)
       {
          // Nothing tested, return.
          //
          FreeDomainInfo(&Remote);
          return IDNO;
       }

       // If here, then the trust verified OK.
       //
       MsgBox(fInboundSkipped ? 
                 IDS_OUTBOUND_TRUST_VERIFY_DONE : IDS_TRUST_VERIFY_DONE,
              m_pPage->GetHWnd());

       // If this is a forest trust, then ask user if they want to update Name Suffix routing info
       if ( IsForestTrust () )
       {
           CStrW strMsg, strTitle;
           strTitle.LoadString ( g_hInstance, IDS_MSG_TITLE );
           strMsg.LoadString ( g_hInstance, IDS_TRUST_UPDATE_FTINFO );
           int nRet = MessageBox(m_pPage->GetHWnd(), strMsg, strTitle, MB_YESNO | MB_ICONINFORMATION);
           if ( IDYES == nRet )
           {
               _pForestNamePage->CheckForNameChanges();
               _pForestNamePage->RefreshList ();
           }
       }
      
       nResponse = IDNO;
    }

ExitCleanup:

    if (ERROR_CANCELLED == dwErr || ERROR_LOGON_FAILURE == dwErr)
    {
        // The user was prompted for credentials and either canceled or
        // gave invalid creds.
        //
        SuperMsgBox(m_pPage->GetHWnd(),
                    IDS_CANCEL_CANT_VERIFY, 0,
                    MB_OK | MB_ICONEXCLAMATION,
                    0, NULL, 0,
                    FALSE, __FILE__, __LINE__);
    }

    FreeDomainInfo(&Remote);
    return nResponse;
}

//+----------------------------------------------------------------------------
//
//  Method:    CQueryChoiceWCredsDlgBase::OnInitDialog
//
//-----------------------------------------------------------------------------
LRESULT
CQueryChoiceWCredsDlgBase::OnInitDialog(LPARAM lParam)
{
   CheckDlgButton(_hDlg, IDC_NO_RADIO, BST_CHECKED);

   if (_Creds.IsSet())
   {
      // Don't need to get them again.
      //
      ShowWindow(GetDlgItem(_hDlg, IDC_CREDMAN), SW_HIDE);
      ShowWindow(GetDlgItem(_hDlg, IDC_CRED_PROMPT), SW_HIDE);
   }
   else
   {
      SendDlgItemMessage(_hDlg, IDC_CREDMAN, CRM_SETUSERNAMEMAX, CREDUI_MAX_USERNAME_LENGTH, 0);
      SendDlgItemMessage(_hDlg, IDC_CREDMAN, CRM_SETPASSWORDMAX, CREDUI_MAX_PASSWORD_LENGTH, 0);
      EnableWindow(GetDlgItem(_hDlg, IDC_CRED_PROMPT), FALSE);
      EnableWindow(GetDlgItem(_hDlg, IDC_CREDMAN), FALSE);
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CQueryChoiceWCredsDlgBase
//
//-----------------------------------------------------------------------------
LRESULT
CQueryChoiceWCredsDlgBase::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   BOOL fNameEntered;

   if (BN_CLICKED == codeNotify)
   {
      switch (id)
      {
      case IDC_YES_RADIO:
         if (!_Creds.IsSet())
         {
            fNameEntered = SendDlgItemMessage(_hDlg, IDC_CREDMAN,
                                              CRM_GETUSERNAMELENGTH,
                                              0, 0) > 0;

            EnableWindow(GetDlgItem(_hDlg, IDOK), fNameEntered);
            EnableWindow(GetDlgItem(_hDlg, IDC_CREDMAN), TRUE);
            EnableWindow(GetDlgItem(_hDlg, IDC_CRED_PROMPT), TRUE);
         }
         break;

      case IDC_NO_RADIO:
         EnableWindow(GetDlgItem(_hDlg, IDOK), TRUE);
         if (!_Creds.IsSet())
         {
            EnableWindow(GetDlgItem(_hDlg, IDC_CREDMAN), FALSE);
            EnableWindow(GetDlgItem(_hDlg, IDC_CRED_PROMPT), FALSE);
         }
         break;

      case IDOK:
         if (IsDlgButtonChecked(_hDlg, IDC_YES_RADIO))
         {
            if (!_Creds.IsSet())
            {
               WCHAR wzName[CREDUI_MAX_USERNAME_LENGTH+1] = {0},
                     wzPw[CREDUI_MAX_PASSWORD_LENGTH+1] = {0};

               Credential_GetUserName(GetDlgItem(_hDlg, IDC_CREDMAN), wzName,
                                      CREDUI_MAX_USERNAME_LENGTH);

               Credential_GetPassword(GetDlgItem(_hDlg, IDC_CREDMAN), wzPw,
                                      CREDUI_MAX_PASSWORD_LENGTH);

               DWORD dwErr = _Creds.SetUserAndPW(wzName, wzPw, _pwzDomainName );

               // NOTICE-2002/02/15-ericb - SecurityPush: zero out the pw buffer
               // so that the pw isn't left on the stack.
               SecureZeroMemory(wzPw, CREDUI_MAX_PASSWORD_LENGTH * sizeof(WCHAR));

               CHECK_WIN32_REPORT(dwErr, _hDlg, ;);
            }
            EndDialog(_hDlg, IDYES);
         }
         else
         {
            EndDialog(_hDlg, IDNO);
         }
         break;

      case IDCANCEL:
         EndDialog(_hDlg, IDCANCEL);
         break;

      default:
         dspAssert(FALSE);
         break;
      }

      return 0;
   }

   if (IDC_CREDMAN == id && CRN_USERNAMECHANGE == codeNotify)
   {
      fNameEntered = SendDlgItemMessage(_hDlg, IDC_CREDMAN,
                                        CRM_GETUSERNAMELENGTH,
                                        0, 0) > 0;

      EnableWindow(GetDlgItem(_hDlg, IDOK), fNameEntered);
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CQueryChoiceWCredsDlgBase::OnHelp
//
//-----------------------------------------------------------------------------
LRESULT
CQueryChoiceWCredsDlgBase::OnHelp(LPHELPINFO pHelpInfo)
{
   dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                pHelpInfo->iCtrlId, pHelpInfo->dwContextId));

   if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
   {
      return 0;
   }
   WinHelp(_hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyInboundDlg::OnInitDialog
//
//-----------------------------------------------------------------------------
LRESULT
CVerifyInboundDlg::OnInitDialog(LPARAM lParam)
{
   if (_Creds.IsSet())
   {
      // Don't need to get them again.
      //
      CStrW strMsg;
      // NOTICE-2002/02/15-ericb - SecurityPush: see above CStrW::Loadstring notice
      strMsg.LoadString(g_hInstance, IDS_VERIFY_BOTH_SIDES_HAVE_CREDS);
      SetDlgItemText(_hDlg, IDC_MSG, strMsg);
   }
   else
   {
      FormatWindowText(GetDlgItem(_hDlg, IDC_MSG), _pwzDomainName);
   }

   CQueryChoiceWCredsDlgBase::OnInitDialog(lParam);

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyResultsQueryResetDlg::OnInitDialog
//
//-----------------------------------------------------------------------------
LRESULT
CVerifyResultsQueryResetDlg::OnInitDialog(LPARAM lParam)
{
   SetDlgItemText(_hDlg, IDC_VERIFY_FAILURES, _strResults);

   if (!_Creds.IsSet())
   {
      FormatWindowText(GetDlgItem(_hDlg, IDC_CRED_PROMPT), _pwzDomainName);
   }

   SetFocus(GetDlgItem(_hDlg, IDC_NO_RADIO));

   CQueryChoiceWCredsDlgBase::OnInitDialog(lParam);

   return 1; // this causes the base class to return FALSE so the focus will
}            // remain on the No button.

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::ResetTrust
//
//  Synopsis:   Resets the trust passwords. A new password is allocated for
//              each direction-pair and then assigned.
//
//-----------------------------------------------------------------------------
HRESULT
CDsTrustedDomainPage::ResetTrust(void)
{
    TRACE(CDsTrustedDomainPage, ResetTrust);
    CWaitCursor Wait;
    TD_DOM_INFO Remote;
    DWORD dwErr = ERROR_SUCCESS;
    NTSTATUS Status = ERROR_SUCCESS;
    CStrW strUncPDC, strMsg, strDnsDomainName;
    PTRUSTED_DOMAIN_FULL_INFORMATION pOldLocalTDFInfo = NULL,
                                     pOldRemoteTDFInfo = NULL;

    // NOTICE-2002/02/15-ericb - SecurityPush: zeroing a struct.
    RtlZeroMemory(&Remote, sizeof(Remote));

    HRESULT hr = DiscoverDC(GetDnsDomainName(), DS_PDC_REQUIRED);

    if (FAILED(hr) || !IsFound())
    {
        if (!IsFound() ||
            HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr ||
            HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE) == hr)
        {
            ErrMsgParam(IDS_TRUST_RESET_NO_DC, (LPARAM)GetDomainFlatName(),
                        m_pPage->GetHWnd());
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED); // don't report error again.
        }
        else
        {
            dspDebugOut((DEB_ERROR,
                         "**** ERROR RETURN <%s @line %d> -> %08lx\n",
                         __FILE__, __LINE__, hr));
        }
        return hr;
    }

    strUncPDC = GetUncDcName();

    CPolicyHandle cPolicy(strUncPDC);

    dwErr = cPolicy.OpenWithPrompt(_CredMgr._LocalCreds, Wait,
                                   GetDnsDomainName(), m_pPage->GetHWnd());

    CHECK_WIN32(dwErr, return HRESULT_FROM_WIN32(dwErr));

    Wait.SetWait();

    hr = GetInfoForRemoteDomain(GetTrustPartnerDnsName(), &Remote, _CredMgr,
                                m_pPage->GetHWnd(),
                                DS_TRUST_INFO_GET_PDC | DS_TRUST_INFO_ALL_ACCESS);
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr ||
            HRESULT_FROM_WIN32(ERROR_BAD_NETPATH) == hr)
        {
            Wait.SetOld();
            ErrMsgParam(IDS_TRUST_RESET_NO_DC, (LPARAM)GetTrustPartnerDnsName(),
                        m_pPage->GetHWnd());
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED); // don't report error again.
        }
        else if (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr &&
                 Remote.pwzUncDcName)
        {
            ErrMsgParam(IDS_TRUST_LSAOPEN_NO_RPC, (LPARAM)(Remote.pwzUncDcName + 2),
                        m_pPage->GetHWnd());
        }
        goto ExitCleanup;
    }

    Wait.SetWait();

    _CredMgr.ImpersonateLocal();

    Status = LsaQueryTrustedDomainInfo(cPolicy,
                                       Remote.pDnsDomainInfo->Sid,
                                       TrustedDomainFullInformation,
                                       (PVOID *)&pOldLocalTDFInfo);
    dwErr = LsaNtStatusToWinError(Status);

    CHECK_WIN32(dwErr, goto ExitCleanup);

    PPOLICY_PRIMARY_DOMAIN_INFO pDomInfo;

    Status = LsaQueryInformationPolicy(cPolicy,
                                       PolicyPrimaryDomainInformation,
                                       (PVOID *)&pDomInfo);

    _CredMgr.Revert();

    dwErr = LsaNtStatusToWinError(Status);

    CHECK_WIN32(dwErr, goto ExitCleanup);

    _CredMgr.ImpersonateRemote();

    Status = LsaQueryTrustedDomainInfo(Remote.Policy,
                                       pDomInfo->Sid,
                                       TrustedDomainFullInformation,
                                       (PVOID *)&pOldRemoteTDFInfo);
    _CredMgr.Revert();

    dwErr = LsaNtStatusToWinError(Status);

    LsaFreeMemory(pDomInfo);

    CHECK_WIN32(dwErr, goto ExitCleanup);

    TRUSTED_DOMAIN_FULL_INFORMATION NewLocalTDFInfo, NewRemoteTDFInfo;
    LSA_AUTH_INFORMATION InNewAuthInfo;
    WCHAR wzInPw[MAX_COMPUTERNAME_LENGTH], wzOutPw[MAX_COMPUTERNAME_LENGTH];
    LARGE_INTEGER ft;

    GetSystemTimeAsFileTime((PFILETIME)&ft);

    // NOTICE-2002/02/15-ericb - SecurityPush: zeroing two structs.
    ZeroMemory(&NewLocalTDFInfo, sizeof(TRUSTED_DOMAIN_FULL_INFORMATION));
    ZeroMemory(&NewRemoteTDFInfo, sizeof(TRUSTED_DOMAIN_FULL_INFORMATION));

    if (m_nTrustDirection & TRUST_DIRECTION_INBOUND)
    {
        //
        // Build a random password
        //
        _CredMgr.ImpersonateLocal();

        dwErr = GenerateRandomPassword(wzInPw, MAX_COMPUTERNAME_LENGTH);

        _CredMgr.Revert();

        if (NO_ERROR != dwErr)
        {
           goto ExitCleanup;
        }

        //
        // Set the current password data.
        //
        InNewAuthInfo.LastUpdateTime = ft;
        InNewAuthInfo.AuthType = TRUST_AUTH_TYPE_CLEAR;
        InNewAuthInfo.AuthInfoLength = (MAX_COMPUTERNAME_LENGTH-1) * sizeof(WCHAR);
        InNewAuthInfo.AuthInfo = (PUCHAR)wzInPw;

        NewLocalTDFInfo.AuthInformation.IncomingAuthInfos = 1;
        NewLocalTDFInfo.AuthInformation.IncomingAuthenticationInformation = &InNewAuthInfo;
        NewLocalTDFInfo.AuthInformation.IncomingPreviousAuthenticationInformation = NULL;
        NewLocalTDFInfo.Information = pOldLocalTDFInfo->Information;

        NewRemoteTDFInfo.AuthInformation.OutgoingAuthInfos = 1;
        NewRemoteTDFInfo.AuthInformation.OutgoingAuthenticationInformation = &InNewAuthInfo;
        NewRemoteTDFInfo.AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;
        NewRemoteTDFInfo.Information = pOldRemoteTDFInfo->Information;
    }

    LSA_AUTH_INFORMATION OutNewAuthInfo;

    if (m_nTrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
        //
        // Get another password.
        //
        _CredMgr.ImpersonateLocal();

        dwErr = GenerateRandomPassword(wzOutPw, MAX_COMPUTERNAME_LENGTH);

        _CredMgr.Revert();

        if (NO_ERROR != dwErr)
        {
           goto ExitCleanup;
        }

        //
        // Set the new password data.
        //
        OutNewAuthInfo.LastUpdateTime = ft;
        OutNewAuthInfo.AuthType = TRUST_AUTH_TYPE_CLEAR;
        OutNewAuthInfo.AuthInfoLength = (MAX_COMPUTERNAME_LENGTH-1) * sizeof(WCHAR);
        OutNewAuthInfo.AuthInfo = (PUCHAR)wzOutPw;

        NewLocalTDFInfo.AuthInformation.OutgoingAuthInfos = 1;
        NewLocalTDFInfo.AuthInformation.OutgoingAuthenticationInformation = &OutNewAuthInfo;
        NewLocalTDFInfo.AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;
        NewLocalTDFInfo.Information = pOldLocalTDFInfo->Information;

        NewRemoteTDFInfo.AuthInformation.IncomingAuthInfos = 1;
        NewRemoteTDFInfo.AuthInformation.IncomingAuthenticationInformation = &OutNewAuthInfo;
        NewRemoteTDFInfo.AuthInformation.IncomingPreviousAuthenticationInformation = NULL;
        NewRemoteTDFInfo.Information = pOldRemoteTDFInfo->Information;
    }

    // Save changes.
    //
    _CredMgr.ImpersonateLocal();

    Status = LsaSetTrustedDomainInfoByName(cPolicy,
                                           &Remote.pDnsDomainInfo->DnsDomainName,
                                           TrustedDomainFullInformation,
                                           &NewLocalTDFInfo);
    _CredMgr.Revert();

    dwErr = LsaNtStatusToWinError(Status);

    CHECK_WIN32(dwErr, goto ExitCleanup);
    UNICODE_STRING Server;
    RtlInitUnicodeString(&Server, GetDnsDomainName());

    _CredMgr.ImpersonateRemote();

    Status = LsaSetTrustedDomainInfoByName(Remote.Policy,
                                           &Server,
                                           TrustedDomainFullInformation,
                                           &NewRemoteTDFInfo);
    _CredMgr.Revert();

    dwErr = LsaNtStatusToWinError(Status);

    CHECK_WIN32(dwErr, goto ExitCleanup);

    //
    // Verify the repaired trust. Setting DS_TRUST_VERIFY_NEW_TRUST because we
    // want to force a reset of the secure channel.
    //

    // NOTICE-2002/03/07-ericb - SecurityPush: UNICODE_STRINGS don't have
    // to be NULL terminated. Assigning to a CStrW will convert it to a
    // NULL terminated string.
    strDnsDomainName = Remote.pDnsDomainInfo->DnsDomainName;

    if (m_nTrustDirection & TRUST_DIRECTION_INBOUND)
    {
        dwErr = VerifyTrustOneDirection(Remote.pwzUncDcName,
                                        strDnsDomainName,
                                        GetDnsDomainName(),
                                        NULL,
                                        _CredMgr._RemoteCreds,
                                        Wait,
                                        strMsg,
                                        DS_TRUST_VERIFY_NEW_TRUST);
        switch (dwErr)
        {
        case ERROR_ACCESS_DENIED:
            ErrMsg(IDS_ERR_TRUST_RESET_NOACCESS, m_pPage->GetHWnd());
            dwErr = ERROR_CANCELLED; // don't report error again.
            // fall through.
        case ERROR_CANCELLED:
            goto ExitCleanup;

        case ERROR_SUCCESS:
            break;

        default:
            goto ExitCleanup;
        }
    }

    if (m_nTrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
        dwErr = VerifyTrustOneDirection(strUncPDC,
                                        GetDnsDomainName(),
                                        strDnsDomainName,
                                        NULL,
                                        _CredMgr._LocalCreds,
                                        Wait,
                                        strMsg,
                                        DS_TRUST_VERIFY_NEW_TRUST);
        switch (dwErr)
        {
        case ERROR_ACCESS_DENIED:
            ErrMsg(IDS_ERR_TRUST_RESET_NOACCESS, m_pPage->GetHWnd());
            dwErr = ERROR_CANCELLED; // don't report error again.
            // fall through.
        case ERROR_CANCELLED:
            goto ExitCleanup;

        case ERROR_SUCCESS:
            break;

        default:
            goto ExitCleanup;
        }
    }

ExitCleanup:
    _CredMgr.Revert();
    if (pOldLocalTDFInfo)
        LsaFreeMemory(pOldLocalTDFInfo);
    if (pOldRemoteTDFInfo)
        LsaFreeMemory(pOldRemoteTDFInfo);
    FreeDomainInfo(&Remote);
    return HRESULT_FROM_WIN32(dwErr);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsTrustedDomainPage::OnSaveFTInfoBtn
//
//  Synopsis:   Save the FTInfo to a text file after prompting for a name.
//
//-----------------------------------------------------------------------------
void
CDsTrustedDomainPage::OnSaveFTInfoBtn(void)
{
   CFTInfo & FTInfo = _pForestNamePage->GetFTInfo();

   if (!FTInfo.GetCount())
   {
      _pForestNamePage->CheckForNameChanges();

      if (!FTInfo.GetCount())
      {
         ERR_MSG(IDS_NO_FTINFO, m_pPage->GetHWnd());
         return;
      }
   }

   CFTCollisionInfo & ColInfo = _pForestNamePage->GetCollisionInfo();

   SaveFTInfoAs(m_pPage->GetHWnd(),
                GetTrustPartnerFlatName(),
                GetTrustPartnerDnsName(),
                FTInfo, ColInfo);
}

//+----------------------------------------------------------------------------
//
//  CTrustAuthPropPage: Trust Organization Authorization Page object
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member: CTrustAuthPropPage::CTrustAuthPropPage
//
//-----------------------------------------------------------------------------
CTrustAuthPropPage::CTrustAuthPropPage(HWND hParent) :
   _TrustRelation(TRUST_REL_UNKNOWN),   
   _fOrigOtherOrg(false),
   _fNewOtherOrg(false),
   CLightweightPropPageBase(hParent)
{
   TRACER(CTrustAuthPropPage,CTrustAuthPropPage);
#ifdef _DEBUG
   // NOTICE-2002/02/15-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
   strcpy(szClass, "CTrustAuthPropPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrustAuthPropPage::~CTrustAuthPropPage
//
//-----------------------------------------------------------------------------
CTrustAuthPropPage::~CTrustAuthPropPage()
{
   TRACER(CTrustAuthPropPage,~CTrustAuthPropPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustAuthPropPage::Init
//
//  Synopsis:   Create the page.
//
//-----------------------------------------------------------------------------
HRESULT
CTrustAuthPropPage::Init(PCWSTR pwzDomainDnsName,
                         PCWSTR pwzTrustPartnerName,
                         PCWSTR pwzDcName,
                         ULONG nTrustAttrs,
                         TRUST_RELATION Relation,
                         BOOL fReadOnly)
{
   if (nTrustAttrs & TRUST_ATTRIBUTE_CROSS_ORGANIZATION)
   {
      _fNewOtherOrg = _fOrigOtherOrg = true;
   }

   _TrustRelation = Relation;

   return CLightweightPropPageBase::Init(pwzDomainDnsName, pwzTrustPartnerName,
                                         pwzDcName, IDD_TRUST_THIS_ORG_PAGE,
                                         IDS_ORG_PAGE_TITLE, 
                                         PageCallback, fReadOnly);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustAuthPropPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
LRESULT
CTrustAuthPropPage::OnInitDialog(LPARAM)
{
   TRACER(CTrustAuthPropPage, OnInitDialog);
   CStrW strMsg, strFormat;

   // NOTICE-2002/02/15-ericb - SecurityPush: for these uses of LoadString,
   // see above CStrW::LoadString notice
   strFormat.LoadString(g_hInstance,
                        TRUST_REL_FOREST == _TrustRelation ?
                           IDS_ORG_FOREST_LABEL : IDS_ORG_DOMAIN_LABEL);
   strMsg.Format(strFormat, _strTrustPartnerDnsName);
   SetWindowText(GetDlgItem(_hPage, IDC_TRUST_ORG_LABEL), strMsg);

   strMsg.LoadString(g_hInstance,
                     TRUST_REL_FOREST == _TrustRelation ?
                        IDS_THIS_ORG_RADIO_FOREST : IDS_THIS_ORG_RADIO_DOMAIN);
   SetWindowText(GetDlgItem(_hPage, IDC_MY_ORG_RADIO), strMsg);

   strFormat.LoadString(g_hInstance,
                        TRUST_REL_FOREST == _TrustRelation ?
                           IDS_OTHER_ORG_RADIO_FOREST : IDS_OTHER_ORG_RADIO_DOMAIN);
   strMsg.Format(strFormat, _strTrustPartnerDnsName);
   SetWindowText(GetDlgItem(_hPage, IDC_OTHER_ORG_RADIO), strMsg);

   CheckDlgButton(_hPage,
                  _fOrigOtherOrg ? IDC_OTHER_ORG_RADIO : IDC_MY_ORG_RADIO,
                  BST_CHECKED);

   if (_fReadOnly)
   {
      EnableWindow(GetDlgItem(_hPage, IDC_MY_ORG_RADIO), false);
      EnableWindow(GetDlgItem(_hPage, IDC_OTHER_ORG_RADIO), false);
   }

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustAuthPropPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CTrustAuthPropPage::OnApply(void)
{
   TRACE(CTrustAuthPropPage, OnApply);
   DWORD dwRet = NO_ERROR;
   LRESULT lResult = PSNRET_INVALID_NOCHANGEPAGE;

   if (IsOrgChanged())
   {
      // Write the new data to the TDO.
      //
      dwRet = SetOrgBit();
   }

   if (NO_ERROR == dwRet)
   {
      ClearDirty();
      lResult = PSNRET_NOERROR;
   }
   else
   {
      ReportError(dwRet, IDS_ERR_WRITE_ORG_TO_TDO, _hPage);
   }

   return lResult;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustAuthPropPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CTrustAuthPropPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (_fInInit)
   {
       return 0;
   }
   if (BN_CLICKED == codeNotify)
   {
      switch (id)
      {
      case IDC_MY_ORG_RADIO:
         _fNewOtherOrg = false;
         if (IsOrgChanged())
         {
            SetDirty();
         }
         break;

      case IDC_OTHER_ORG_RADIO:
         _fNewOtherOrg = true;
         if (IsOrgChanged())
         {
            SetDirty();
         }
         break;
      }
   }
   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustAuthPropPage::OnNotify
//
//  Synopsis:   Handles notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CTrustAuthPropPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult;

    if (_fInInit)
    {
        return 0;
    }

    switch (((LPNMHDR)lParam)->code)
    {
    case PSN_APPLY:
        lResult = PSNRET_NOERROR;
        if (IsDirty())
        {
            lResult = OnApply();
        }
        // Store the result into the dialog
        SetWindowLongPtr(_hPage, DWLP_MSGRESULT, (LONG_PTR)lResult);
        return lResult;
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustAuthPropPage::SetOrgBit
//
//  Synopsis:   Write the trust attributes property with the new org bit value.
//
//-----------------------------------------------------------------------------
DWORD
CTrustAuthPropPage::SetOrgBit(void)
{
   TRACER(CTrustAuthPropPage, SetOrgBit);
   DWORD Win32Err = NO_ERROR;
   NTSTATUS Status = STATUS_SUCCESS;
   PTRUSTED_DOMAIN_INFORMATION_EX pTDIx = NULL;
   PLSA_UNICODE_STRING pName = NULL;
   LSA_UNICODE_STRING Name;
   CWaitCursor Wait;

   CPolicyHandle cPolicy(_strUncDC);

   Win32Err = cPolicy.OpenWithPrompt(_LocalCreds, Wait,
                                     _strDomainDnsName, _hPage);

   if (ERROR_CANCELLED == Win32Err)
   {
       // don't report error if user canceled.
       //
       return NO_ERROR;
   }

   if (ERROR_ACCESS_DENIED == Win32Err)
   {
      // the user entered creds are no good.
      _LocalCreds.Clear();
   }

   CHECK_WIN32(Win32Err, return Win32Err);

   RtlInitUnicodeString(&Name, _strTrustPartnerDnsName);
   pName = &Name;

   Status = LsaQueryTrustedDomainInfoByName(cPolicy,
                                            pName,
                                            TrustedDomainInformationEx,
                                            (PVOID *)&pTDIx);

   Win32Err = LsaNtStatusToWinError(Status);

   CHECK_WIN32(Win32Err, return Win32Err);

   if (_fNewOtherOrg)
   {
       pTDIx->TrustAttributes |= TRUST_ATTRIBUTE_CROSS_ORGANIZATION;
   }
   else
   {
       pTDIx->TrustAttributes &= ~(TRUST_ATTRIBUTE_CROSS_ORGANIZATION);
   }

   Status = LsaSetTrustedDomainInfoByName(cPolicy,
                                          pName,
                                          TrustedDomainInformationEx,
                                          pTDIx);
   LsaFreeMemory(pTDIx);
   Win32Err = LsaNtStatusToWinError(Status);

   CHECK_WIN32(Win32Err, return Win32Err);

   _fOrigOtherOrg = _fNewOtherOrg;

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustAuthPropPage::PageCallback
//
//  Synopsis:   Callback used to free the CTrustAuthPropPage object when the
//              property sheet has been destroyed.
//
//-----------------------------------------------------------------------------
UINT CALLBACK
CTrustAuthPropPage::PageCallback(HWND hDlg, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
   TRACE_FUNCTION(CTrustAuthPropPage::PageCallback);

   if (uMsg == PSPCB_RELEASE)
   {
      //
      // Determine instance that invoked this static function
      //
      CTrustAuthPropPage * pPage = (CTrustAuthPropPage *) ppsp->lParam;

      delete pPage;

      SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
#if DBG == 1 // TRUSTBREAK
HRESULT
TrustBreakBtn(CDsPropPageBase * pPage, PATTR_MAP,
              PADS_ATTR_INFO, LPARAM, PATTR_DATA,
              DLG_OP DlgOp)
{
    // Set the 0x10000000 bit to get the trust break button
    //
    if (DlgOp == fInit && DsPropInfoLevel & DEB_USER13)
    {
        HWND hBtn = GetDlgItem(pPage->GetHWnd(), IDC_BUTTON1);
        ShowWindow(hBtn, SW_SHOW);
        EnableWindow(hBtn, TRUE);
        return S_OK;
    }

    CDsTrustedDomainPage * pTDPage;

    pTDPage = reinterpret_cast<CDsTrustedDomainPage *>(reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData);

    if (DlgOp != fOnCommand)
    {
        return S_OK;
    }

    pTDPage->BreakTrust();

    return S_OK;
}

VOID
CDsTrustedDomainPage::BreakTrust(void)
{
    TRACE(CDsTrustedDomainPage, BreakTrust);
    CWaitCursor Wait;
    TD_DOM_INFO Remote;
    DWORD dwErr;
    NTSTATUS Status = ERROR_SUCCESS;
    CStrW strUncPDC, strMsg;

    // NOTICE-2002/02/15-ericb - SecurityPush: zeroing a struct.
    RtlZeroMemory(&Remote, sizeof(Remote));

    HRESULT hr = DiscoverDC(GetDnsDomainName(), DS_PDC_REQUIRED);

    if (FAILED(hr) || !IsFound())
    {
        if (!IsFound() || HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr ||
            HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE) == hr)
        {
            ErrMsgParam(IDS_TRUST_RESET_NO_DC, (LPARAM)GetDomainFlatName(),
                        m_pPage->GetHWnd());
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED); // don't report error again.
        }
        else
        {
            dspDebugOut((DEB_ERROR,
                         "**** ERROR RETURN <%s @line %d> -> %08lx\n",
                         __FILE__, __LINE__, hr));
        }
        return;
    }

    strUncPDC = GetUncDcName();

    CPolicyHandle cPolicy(strUncPDC);

    dwErr = cPolicy.OpenWithPrompt(_CredMgr._LocalCreds, Wait,
                                   GetDnsDomainName(), m_pPage->GetHWnd());

    if (ERROR_SUCCESS != dwErr)
    {
        return;
    }

    hr = GetInfoForRemoteDomain(GetTrustPartnerDnsName(), &Remote, _CredMgr,
                                m_pPage->GetHWnd(),
                                DS_TRUST_INFO_GET_PDC | DS_TRUST_INFO_ALL_ACCESS);
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr ||
            HRESULT_FROM_WIN32(ERROR_BAD_NETPATH) == hr)
        {
            ErrMsgParam(IDS_ERR_DOMAIN_NOT_FOUND, (LPARAM)GetTrustPartnerDnsName(),
                        m_pPage->GetHWnd());
        }
        else if (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr &&
                 Remote.pwzUncDcName)
        {
            ErrMsgParam(IDS_TRUST_LSAOPEN_NO_RPC, (LPARAM)(Remote.pwzUncDcName + 2),
                        m_pPage->GetHWnd());
        }
        else
        {
            CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), ;);
        }
        return;
    }

    PCWSTR pwzLocalDomainName = NULL, pwzLocalDcName = NULL;
    CStrW strRemoteDomainName;
    PUNICODE_STRING pRemoteName;

    if (TRUST_TYPE_DOWNLEVEL == Remote.ulTrustType)
    {
        strRemoteDomainName = Remote.pDownlevelDomainInfo->Name;
        pRemoteName = &Remote.pDownlevelDomainInfo->Name;
        pwzLocalDomainName = GetDomainFlatName();
        pwzLocalDcName = NULL;
    }
    else
    {
        strRemoteDomainName = Remote.pDnsDomainInfo->DnsDomainName;
        pRemoteName = &Remote.pDnsDomainInfo->DnsDomainName;
        pwzLocalDomainName = GetDnsDomainName();
        pwzLocalDcName = strUncPDC;
    }

    dspDebugOut((DEB_ITRACE, "Reading Trusted Domain Full Info for %ws\n",
                 strRemoteDomainName.GetBuffer(0)));
    Wait.SetWait();
    PTRUSTED_DOMAIN_FULL_INFORMATION pOldLocalTDFInfo = NULL;

    Status = LsaQueryTrustedDomainInfoByName(cPolicy,
                                             pRemoteName,
                                             TrustedDomainFullInformation,
                                             (PVOID *)&pOldLocalTDFInfo);

    CHECK_LSA_STATUS_REPORT(Status, m_pPage->GetHWnd(), goto ExitCleanup);

    TRUSTED_DOMAIN_FULL_INFORMATION NewLocalTDFInfo;
    LSA_AUTH_INFORMATION InNewAuthInfo;
    WCHAR wzInPw[MAX_COMPUTERNAME_LENGTH], wzOutPw[MAX_COMPUTERNAME_LENGTH];

    // NOTICE-2002/02/15-ericb - SecurityPush: zeroing a struct.
    ZeroMemory(&NewLocalTDFInfo, sizeof(TRUSTED_DOMAIN_FULL_INFORMATION));

    if (m_nTrustDirection & TRUST_DIRECTION_INBOUND)
    {
        // Build a random password
        //
        _CredMgr.ImpersonateLocal();

        GenerateRandomPassword(wzInPw, MAX_COMPUTERNAME_LENGTH);

        _CredMgr.Revert();

        //
        // Set the current password data.
        //
        GetSystemTimeAsFileTime((PFILETIME)&InNewAuthInfo.LastUpdateTime);

        InNewAuthInfo.AuthType = TRUST_AUTH_TYPE_CLEAR;
        InNewAuthInfo.AuthInfoLength = (MAX_COMPUTERNAME_LENGTH-1) * sizeof(WCHAR);
        InNewAuthInfo.AuthInfo = (PUCHAR)wzInPw;

        NewLocalTDFInfo.AuthInformation.IncomingAuthInfos = 1;
        NewLocalTDFInfo.AuthInformation.IncomingAuthenticationInformation = &InNewAuthInfo;
        NewLocalTDFInfo.AuthInformation.IncomingPreviousAuthenticationInformation = NULL;
        NewLocalTDFInfo.Information = pOldLocalTDFInfo->Information;
    }

    LSA_AUTH_INFORMATION OutNewAuthInfo;

    if (m_nTrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
        // Get another password.
        //
        _CredMgr.ImpersonateLocal();

        GenerateRandomPassword(wzOutPw, MAX_COMPUTERNAME_LENGTH);

        _CredMgr.Revert();

        //
        // Set the new password data.
        //
        GetSystemTimeAsFileTime((PFILETIME)&OutNewAuthInfo.LastUpdateTime);

        OutNewAuthInfo.AuthType = TRUST_AUTH_TYPE_CLEAR;
        OutNewAuthInfo.AuthInfoLength = (MAX_COMPUTERNAME_LENGTH-1) * sizeof(WCHAR);
        OutNewAuthInfo.AuthInfo = (PUCHAR)wzOutPw;

        NewLocalTDFInfo.AuthInformation.OutgoingAuthInfos = 1;
        NewLocalTDFInfo.AuthInformation.OutgoingAuthenticationInformation = &OutNewAuthInfo;
        NewLocalTDFInfo.AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;
        NewLocalTDFInfo.Information = pOldLocalTDFInfo->Information;
    }

    dspDebugOut((DEB_ITRACE, "Writing new trust password(s) for %ws\n",
                 strRemoteDomainName.GetBuffer(0)));
    // Save changes.
    //
    Status = LsaSetTrustedDomainInfoByName(cPolicy,
                                           pRemoteName,
                                           TrustedDomainFullInformation,
                                           &NewLocalTDFInfo);
    CHECK_LSA_STATUS_REPORT(Status, m_pPage->GetHWnd(), goto ExitCleanup);
    dspDebugOut((DEB_ITRACE, "Trust password(s) successfully changed for %ws\n",
                 strRemoteDomainName.GetBuffer(0)));

    if (m_nTrustDirection & TRUST_DIRECTION_INBOUND)
    {
        VerifyTrustOneDirection(Remote.pwzUncDcName,
                                strRemoteDomainName,
                                pwzLocalDomainName,
                                NULL,
                                _CredMgr._RemoteCreds,
                                Wait,
                                strMsg);
    }

    if (m_nTrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
        VerifyTrustOneDirection(strUncPDC,
                                GetDnsDomainName(),
                                strRemoteDomainName,
                                NULL,
                                _CredMgr._LocalCreds,
                                Wait,
                                strMsg);
    }

ExitCleanup:
    if (pOldLocalTDFInfo)
        LsaFreeMemory(pOldLocalTDFInfo);
    FreeDomainInfo(&Remote);
}
#endif // DBG == 1 TRUSTBREAK

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\subclass.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       subclass.h
//
//  Contents:   Control subclassing support.
//
//  Classes:    ControlSubclasser, MultiLineEditBoxThatForwardsEnterKey.
//
//  History:    28-Nov-00 EricB created in collaboration with SBurns.
//
//-----------------------------------------------------------------------------

#ifndef SUBCLASS_H_GUARD
#define SUBCLASS_H_GUARD

//+----------------------------------------------------------------------------
//
//  Class:     ControlSubclasser
//
//  Purpose:   Class for hooking the window proc of a control.
//
//-----------------------------------------------------------------------------
class ControlSubclasser
{
protected:

   ControlSubclasser();

   // reverses the subclassing by calling UnhookWindowProc.

   virtual
   ~ControlSubclasser();

   // Hooks the window proc of the supplied window so that all future messages
   // are routed to the OnMessage method.  The OnInit of the parent dialog
   // where the control resides is a good place to call this method.
   //
   // The hook requires that that the GWLP_USERDATA portion of the window
   // be overwritten with the this pointer to this instance.  If you need
   // that data, then you could derive a class from this one, and add
   // members for your extra data.
   //
   // Your overrided Init method must call this base method.
   //
   // control - in, handle to the control to be hooked.

   virtual
   HRESULT
   Init(HWND editControl);

   // Invoked upon receipt of any window message.  The default implementation
   // calls the control's original window procedure.  When you derive a new
   // class from this one, be sure to call this base class method from your
   // derived method for any messages your derived method doesn't handle.
   //
   // message - in, the message code passed to the dialog window.
   //
   // wparam - in, the WPARAM parameter accompanying the message.
   //
   // lparam - in, the LPARAM parameter accompanying the message.

   virtual
   LRESULT
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   // the handle to the subclassed control.  Only valid after Init has
   // been called.

   HWND hwnd;

private:

   // restore the original window proc to the window

   void
   UnhookWindowProc();

   // a static Windows Proc that acts as a dispatcher to the non-static
   // OnMessage method.

   static
   LRESULT CALLBACK
   WindowProc(
      HWND   window,
      UINT   message,
      WPARAM wParam,
      LPARAM lParam);

   // not implemented: no copying allowed

   ControlSubclasser(const ControlSubclasser&);
   const ControlSubclasser& operator=(const ControlSubclasser&);

   WNDPROC originalWindowProc;
};

//+----------------------------------------------------------------------------
//
//  Class:     MultiLineEditBoxThatForwardsEnterKey
//
//  Purpose:   Class for hooking the window proc of a multi-line edit control
//             to cause it to forward enter keypresses to its parent window as
//             WM_COMMAND messages.
//
//-----------------------------------------------------------------------------
class MultiLineEditBoxThatForwardsEnterKey : public ControlSubclasser
{
public:

   static const WORD FORWARDED_ENTER = 1010;

   MultiLineEditBoxThatForwardsEnterKey();

   virtual
   ~MultiLineEditBoxThatForwardsEnterKey();

   // subclasses the edit control
   //
   // editControl - in, handle to the edit control to be hooked.  This must be
   // a handle to an edit control, or we assert and throw rotten eggs.

   HRESULT
   Init(HWND editControl);

   // Invoked upon receipt of any window message.
   //
   // message - in, the message code passed to the dialog window.
   //
   // wparam - in, the WPARAM parameter accompanying the message.
   //
   // lparam - in, the LPARAM parameter accompanying the message.

   LRESULT
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

private:

   // not implemented: no copying allowed

   MultiLineEditBoxThatForwardsEnterKey(const MultiLineEditBoxThatForwardsEnterKey&);
   const MultiLineEditBoxThatForwardsEnterKey&
      operator=(const MultiLineEditBoxThatForwardsEnterKey&);
};

#endif SUBCLASS_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\tlnedit.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       tlnedit.cxx
//
//  Contents:   Forest trust TLN edit dialogs.
//
//  History:    20-Nov-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include <dnsapi.h>
#include "proppage.h"
#include "trust.h"
#include "listview.h"
#include "routing.h"

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Class:     CEditTLNDialog
//
//  Purpose:   Change the settings of names derived from TLNs.
//
//-----------------------------------------------------------------------------
CEditTLNDialog::CEditTLNDialog(HWND hParent, int nTemplateID,
                               CFTInfo & FTInfo,
                               CFTCollisionInfo & ColInfo,
                               CDsForestNameRoutingPage * pRoutingPage) :
   _pRoutingPage(pRoutingPage),
   _FTInfo(FTInfo),
   _CollisionInfo(ColInfo),
   _iSel(0),
   _iNewExclusion(0),
   _fIsDirty(false),
   CModalDialog(hParent, nTemplateID)
{
    TRACE(CEditTLNDialog,CEditTLNDialog);
#ifdef _DEBUG
    // NOTICE-2002/02/15-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
    strcpy(szClass, "CEditTLNDialog");
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:     CEditTLNDialog::DoModal
//
//  Synopsis:   Launch the popup.
//
//-----------------------------------------------------------------------------
INT_PTR
CEditTLNDialog::DoModal(ULONG iSel)
{
   _iSel = iSel;

   return CModalDialog::DoModal();
}

//+----------------------------------------------------------------------------
//
//  Method:     CEditTLNDialog::OnInitDialog
//
//  Synopsis:   Set the initial control values.
//
//-----------------------------------------------------------------------------
LRESULT
CEditTLNDialog::OnInitDialog(LPARAM lParam)
{
   TRACE(CEditTLNDialog,OnInitDialog);

   if (_pRoutingPage->IsReadOnly())
   {
      EnableWindow(GetDlgItem(_hDlg, IDC_ADD_EXCLUSION_BTN), FALSE);
   }

   _SuffixList.Init(_hDlg, IDC_SUFFIXES_LIST);

   dspAssert(_iSel < _FTInfo.GetCount());

#if DBG
   LSA_FOREST_TRUST_RECORD_TYPE type;
   dspAssert(_FTInfo.GetType(_iSel, type) && type == ForestTrustTopLevelName);
#endif

   CStrW strValue;

   _FTInfo.GetDnsName(_iSel, strValue);

   FormatWindowText(_hDlg, strValue);

   //Test the dynamic label code by forcing a really long name.
   //strValue += L".foo.bar.really.longdnsnames.com";
   
   FormatWindowText(GetDlgItem(_hDlg, IDC_EXCLUDE_LABEL), strValue);
   UseOneOrTwoLine(_hDlg, IDC_EXCLUDE_LABEL, IDC_EXCLUDE_LABEL_LARGE);
   
   FormatWindowText(GetDlgItem(_hDlg, IDC_SUFFIXES_LABEL), strValue);
   UseOneOrTwoLine(_hDlg, IDC_SUFFIXES_LABEL, IDC_SUFFIX_LABEL_LARGE);

   // Fill the excluded names list.
   //
   for (ULONG i = 0; i < _FTInfo.GetCount(); i++)
   {
      if (_FTInfo.IsChildDomain(_iSel, i))
      {
         if (_FTInfo.IsTlnExclusion(i) &&
             FT_EXTRA_INFO::STATUS::Enabled == _FTInfo.GetExtraStatus(i))
         {
            if (!_FTInfo.GetDnsName(i, strValue))
            {
               dspAssert(FALSE);
               continue;
            }

            AddAsteriskPrefix(strValue);

            SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_ADDSTRING, 0,
                               (LPARAM)strValue.GetBuffer(0));
         }
      }
   }

   FillSuffixList();

   EnableExRmButton();
   EnableSuffixListButtons();

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:     CEditTLNDialog::FillSuffixList
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::FillSuffixList(void)
{
   // Fill the TLN subname list with the domain that matches the selected TLN
   // and all of its children. However, if a domain is disabled, then its
   // children are not shown. A domain is disabled by creating an exclusion
   // record with the same name. Disabled domains have a "*." prepended.
   //
   CStrW strName;

   for (ULONG i = 0; i < _FTInfo.GetCount(); i++)
   {
      if (_FTInfo.IsChildDomain(_iSel, i) && !_FTInfo.IsTlnExclusion(i))
      {
         if (!_FTInfo.GetDnsName(i, strName))
         {
            dspAssert(FALSE);
            continue;
         }

         TLN_EDIT_STATUS Status;

         switch (_FTInfo.GetExtraStatus(i))
         {
         case FT_EXTRA_INFO::STATUS::DisabledViaMatchingTLNEx:
            AddAsteriskPrefix(strName);
            Status = Disabled;
            _SuffixList.AddItem(strName, i, Status);
            break;

         case FT_EXTRA_INFO::STATUS::DisabledViaParentMatchingTLNEx:
            continue;

         default:
            if (!_FTInfo.GetTlnEditStatus(i, Status))
            {
               dspAssert(FALSE);
               continue;
            }
            _SuffixList.AddItem(strName, i, Status);
            break;
         }
      }
   }
}

//+----------------------------------------------------------------------------
//
//  Method:     CEditTLNDialog::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CEditTLNDialog::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (BN_CLICKED == codeNotify)
   {
      switch (id)
      {
      case IDC_ADD_EXCLUSION_BTN:
         OnAddExclusion();
         break;

      case IDC_REMOVE_EXCLUSION_BTN:
         OnRemoveExclusion();
         break;

      case IDC_ENABLE_BTN:
         OnEnableName();
         break;

      case IDC_DISABLE_BTN:
         OnDisableName();
         break;

      case IDC_SAVE_FOREST_NAMES_BTN:
         OnSave();
         break;

      case IDOK:
         OnOK();
         break;

      case IDCANCEL:
         EndDialog(_hDlg, IDCANCEL);
         break;

      default:
         dspAssert(FALSE);
         break;
      }

      return 0;
   }

   if (IDC_EXCLUDE_LIST == id && (LBN_SELCHANGE == codeNotify ||
        LBN_SETFOCUS == codeNotify || LBN_KILLFOCUS == codeNotify))
   {
      EnableExRmButton();
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CEditTLNDialog::OnNotify
//
//  Synopsis:   Handles notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CEditTLNDialog::OnNotify(WPARAM wParam, LPARAM lParam)
{
    HWND hList;

    if (_fInInit)
    {
        return 0;
    }

    switch (((LPNMHDR)lParam)->code)
    {
    case LVN_GETINFOTIP:
       NMLVGETINFOTIP * pInfoTip;
       pInfoTip = (LPNMLVGETINFOTIP)lParam;
       dspDebugOut((DEB_ITRACE, "Got LVN_GETINFOTIP, pszText is %ws\n", pInfoTip->pszText));
       break;

    case LVN_ITEMCHANGED:
        EnableSuffixListButtons();
        break;

    case NM_SETFOCUS:
        hList = GetDlgItem(_hDlg, (int)((LPNMHDR)lParam)->idFrom);

        if (ListView_GetItemCount(hList))
        {
            int item = ListView_GetNextItem(hList, -1, LVNI_ALL | LVIS_SELECTED);

            if (item < 0)
            {
                // If nothing is selected, set the focus to the first item.
                //
                LV_ITEM lvi = {0};
                lvi.mask = LVIF_STATE;
                lvi.stateMask = LVIS_FOCUSED;
                lvi.state = LVIS_FOCUSED;
                ListView_SetItem(hList, &lvi);
            }
        }
        EnableSuffixListButtons();
        break;

    case NM_KILLFOCUS:
        EnableSuffixListButtons();
        break;
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CEditTLNDialog::OnHelp
//
//  Synopsis:   Put up popup help for the control.
//
//-----------------------------------------------------------------------------
LRESULT
CEditTLNDialog::OnHelp(LPHELPINFO pHelpInfo)
{
    dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                 pHelpInfo->iCtrlId, pHelpInfo->dwContextId));

    if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
    {
        return 0;
    }
    WinHelp(_hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::OnAddExclusion
//
//  Synopsis:  Post the Add-Exclusions dialog.
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::OnAddExclusion(void)
{
   TRACE(CEditTLNDialog,OnAddExclusion);

   CExcludeTLNDialog ExcludeDlg(_hDlg, IDD_TLN_EXCLUDE, _FTInfo, this);

   INT_PTR nRet = ExcludeDlg.DoModal();

   CStrW strName;

   switch (nRet)
   {
   case IDOK:
      // Add the new exclusion to the list.
      dspAssert(_iNewExclusion);

      if (!_FTInfo.GetDnsName(_iNewExclusion, strName))
      {
         dspAssert(FALSE);
         return;
      }

      AddAsteriskPrefix(strName);

      SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_ADDSTRING, 0,
                         (LPARAM)strName.GetBuffer(0));
      _fIsDirty = true;
      break;
      
   case IDCANCEL:
      break;

   default:
      REPORT_ERROR((HRESULT)((nRet < 0) ? GetLastError() : nRet), _hDlg);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::OnRemoveExclusion
//
//  Synopsis:  
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::OnRemoveExclusion(void)
{
   TRACE(CEditTLNDialog,OnRemoveExclusion);

   int iSel = (int)SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_GETCURSEL, 0, 0);

   if (iSel < 0)
   {
      return;
   }

   CStrW strName;

   int nLen = (int)SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_GETTEXTLEN, (WPARAM)iSel, 0);

   strName.GetBufferSetLength(nLen + 1);

   SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_GETTEXT, (WPARAM)iSel, (LPARAM)strName.GetBuffer(0));

   RemoveAsteriskPrefix(strName);

   ULONG index;

   if (!_FTInfo.GetIndex(strName, index))
   {
      dspAssert(FALSE);
      return;
   }

   if (!_FTInfo.RemoveExclusion(index))
   {
      dspAssert(FALSE);
      return;
   }

   SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_DELETESTRING, (WPARAM)iSel, 0);

   _fIsDirty = true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::OnEnableName
//
//  Synopsis:  Save the names.
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::OnEnableName(void)
{
   TRACE(CEditTLNDialog,OnEnableName);

   int item = _SuffixList.GetSelection();

   if (item < 0)
   {
      dspAssert(FALSE);
      return;
   }

   ULONG i = _SuffixList.GetFTInfoIndex(item);

   dspAssert(i < _FTInfo.GetCount());

   _FTInfo.EnableDomain(i);

   _SuffixList.Clear();
   FillSuffixList();

   EnableSuffixListButtons();

   _fIsDirty = true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::OnDisableName
//
//  Synopsis:  Save the names.
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::OnDisableName(void)
{
   TRACE(CEditTLNDialog,OnDisableName);

   int item = _SuffixList.GetSelection();

   if (item < 0)
   {
      dspAssert(FALSE);
      return;
   }

   ULONG i = _SuffixList.GetFTInfoIndex(item);

   dspAssert(i < _FTInfo.GetCount());

   _FTInfo.DisableDomain(i);

   _SuffixList.Clear();
   FillSuffixList();

   EnableSuffixListButtons();

   _fIsDirty = true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::OnSave
//
//  Synopsis:  Save the names.
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::OnSave(void)
{
   TRACE(CEditTLNDialog,OnSave);

   SaveFTInfoAs(_hDlg,
                _pRoutingPage->GetTrustPartnerFlatName(),
                _pRoutingPage->GetTrustPartnerDnsName(),
                _FTInfo,
                _CollisionInfo);
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::OnOK
//
//  Synopsis:  
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::OnOK(void)
{
   TRACE(CEditTLNDialog,OnOK);

   if (_fIsDirty)
   {
      // Write out changes.
      //
      DWORD dwErr = _pRoutingPage->WriteTDO();

      if (NO_ERROR != dwErr)
      {
         ReportError(dwErr, IDS_ERR_WRITE_FTI_TO_TDO, _hDlg);
      }

      _fIsDirty = false;
   }

   EndDialog(_hDlg, IDOK);
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::EnableExRmButton
//
//  Synopsis:  
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::EnableExRmButton(void)
{
   TRACE(CEditTLNDialog,EnableExRmButton);
   bool fEnableRemove = false;

   int iSel = (int)SendDlgItemMessage(_hDlg, IDC_EXCLUDE_LIST, LB_GETCURSEL, 0, 0);

   if (iSel >= 0 && !_pRoutingPage->IsReadOnly())
   {
      fEnableRemove = true;
   }

   EnableWindow(GetDlgItem(_hDlg, IDC_REMOVE_EXCLUSION_BTN), fEnableRemove);
}

//+----------------------------------------------------------------------------
//
//  Method:    CEditTLNDialog::EnableSuffixListButtons
//
//  Synopsis:  
//
//-----------------------------------------------------------------------------
void
CEditTLNDialog::EnableSuffixListButtons(void)
{
   TRACE(CEditTLNDialog,EnableSuffixListButtons);

   bool fActivateEnable = false, fActivateDisable = false;

   int item = _SuffixList.GetSelection();

   if (item >= 0 && !_pRoutingPage->IsReadOnly())
   {
      ULONG i = _SuffixList.GetFTInfoIndex(item);

      dspAssert(i < _FTInfo.GetCount());

      if (!_FTInfo.IsParentDisabled(i))
      {
         if (_FTInfo.IsEnabled(i))
         {
            fActivateDisable = true;
         }
         else
         {
            fActivateEnable = true;
         }
      }
   }

   EnableWindow(GetDlgItem(_hDlg, IDC_ENABLE_BTN), fActivateEnable);
   EnableWindow(GetDlgItem(_hDlg, IDC_DISABLE_BTN), fActivateDisable);
}


//+----------------------------------------------------------------------------
//
//  Class:     CExcludeTLNDialog
//
//  Purpose:   Add TLN exclusion records.
//
//-----------------------------------------------------------------------------
CExcludeTLNDialog::CExcludeTLNDialog(HWND hParent, int nTemplateID,
                                     CFTInfo & FTInfo,
                                     CEditTLNDialog * pEditDlg) :
   _pEditDlg(pEditDlg),
   _FTInfo(FTInfo),
   CModalDialog(hParent, nTemplateID)
{
    TRACE(CExcludeTLNDialog,CExcludeTLNDialog);
#ifdef _DEBUG
    // NOTICE-2002/02/15-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
    strcpy(szClass, "CExcludeTLNDialog");
#endif
}

//+----------------------------------------------------------------------------
//
//  Method:     CExcludeTLNDialog::OnInitDialog
//
//  Synopsis:   Set the initial control values.
//
//-----------------------------------------------------------------------------
LRESULT
CExcludeTLNDialog::OnInitDialog(LPARAM lParam)
{
   TRACE(CExcludeTLNDialog,OnInitDialog);

   SendDlgItemMessage(_hDlg, IDC_EXCLUSION_EDIT, EM_LIMITTEXT, MAX_PATH, 0);

   EnableWindow(GetDlgItem(_hDlg, IDOK), false);

   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:     CExcludeTLNDialog::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CExcludeTLNDialog::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   switch (codeNotify)
   {
   case EN_CHANGE:
      if (IDC_EXCLUSION_EDIT == id)
      {
         bool fHasChars = 0 != SendDlgItemMessage(_hDlg,
                                                  IDC_EXCLUSION_EDIT,
                                                  WM_GETTEXTLENGTH,
                                                  0, 0);

         EnableWindow(GetDlgItem(_hDlg, IDOK), fHasChars);
      }
      break;

   case BN_CLICKED:
      switch (id)
      {
      case IDOK:
         OnOK();
         break;

      case IDCANCEL:
         EndDialog(_hDlg, IDCANCEL);
         break;
      }
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CExcludeTLNDialog::OnOK
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
void
CExcludeTLNDialog::OnOK(void)
{
   CStrW strExclusion;
   int nLen;

   nLen = GetWindowTextLength(GetDlgItem(_hDlg, IDC_EXCLUSION_EDIT)) + 1;

   strExclusion.GetBufferSetLength(nLen);

   // NOTICE-2002/02/12-ericb - SecurityPush: the text control length is read
   // above, the buffer allocated to include the null above, the allocation null
   // terminates the buffer in case the read below doesn't (but it shouldn't
   // because we are reading the actual length plus one).
   GetDlgItemText(_hDlg, IDC_EXCLUSION_EDIT, strExclusion, nLen);

   RemoveAsteriskPrefix(strExclusion);

   // Is this name subordinate to the TLN. If not, then report error.
   //
   if (!_FTInfo.IsChildName(_pEditDlg->GetTlnSelectionIndex(), strExclusion))
   {
      CStrW strTLN;
      _FTInfo.GetDnsName(_pEditDlg->GetTlnSelectionIndex(), strTLN);
      SuperMsgBox(_hDlg,
                  IDS_ERR_EXCLUSION_NOT_CHILD,
                  IDS_DNT_MSG_TITLE,
                  MB_OK | MB_ICONEXCLAMATION,
                  0,
                  (PVOID *)&strTLN,
                  1,
                  FALSE, __FILE__, __LINE__);
      SetFocus(GetDlgItem(_hDlg, IDC_EXCLUSION_EDIT));
      return;
   }

   // Does this name already exist in the FTInfo? If so, report the situation.
   //
   ULONG index = 0;

   if (_FTInfo.GetIndex(strExclusion, index))
   {
      ULONG iEx = 0;
      if (_FTInfo.IsTlnExclusion(index) || _FTInfo.FindMatchingExclusion(index, iEx))
      {
         // There is already an exclusion of this name.
         //
         ErrMsg(IDS_ERR_EXCLUSION_EXISTS, _hDlg);
         SetFocus(GetDlgItem(_hDlg, IDC_EXCLUSION_EDIT));
         return;
      }
      else
      {
         // The name is an existing name, disable it (by adding an exclusion).
         //
         CStrW strTitle, strMsg;

         // NOTICE-2002/02/15-ericb - SecurityPush: CStrW::LoadString sets the
         // string to an empty string on failure.
         strTitle.LoadString(g_hInstance, IDS_DNT_MSG_TITLE);
         strMsg.LoadString(g_hInstance, IDS_MAKE_EXISTING_EXCLUSION);

         MessageBox(_hDlg, strMsg, strTitle, MB_ICONEXCLAMATION);

         _FTInfo.DisableDomain(index);
         _pEditDlg->_SuffixList.Clear();
         _pEditDlg->FillSuffixList();
         _pEditDlg->SetDirty();
         EndDialog(_hDlg, IDCANCEL); // Don't add this to the exclusion list.
         return;
      }
   }

   // Is the name subordinate to an existing exclusion. If so, report error.
   //
   if (_FTInfo.IsNameTLNExChild(strExclusion))
   {
      ErrMsg(IDS_ERR_EXCLUSION_CHILD, _hDlg);
      SetFocus(GetDlgItem(_hDlg, IDC_EXCLUSION_EDIT));
      return;
   }

   if (!_FTInfo.AddNewExclusion(strExclusion, index))
   {
      ReportError(E_OUTOFMEMORY, 0, _hDlg);
      EndDialog(_hDlg, E_OUTOFMEMORY);
      return;
   }

   //
   // Send the index of the new exclusion record back to the TLN edit dialog
   // so it can be added to the list.
   //
   _pEditDlg->SetNewExclusionIndex(index);

   EndDialog(_hDlg, IDOK);
}

//+----------------------------------------------------------------------------
//
//  Method:     CExcludeTLNDialog::OnHelp
//
//  Synopsis:   Put up popup help for the control.
//
//-----------------------------------------------------------------------------
LRESULT
CExcludeTLNDialog::OnHelp(LPHELPINFO pHelpInfo)
{
    dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                 pHelpInfo->iCtrlId, pHelpInfo->dwContextId));

    if (pHelpInfo->iCtrlId < 1 || IDH_NO_HELP == pHelpInfo->dwContextId)
    {
        return 0;
    }
    WinHelp(_hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);

    return 0;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\trust.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       trust.cxx
//
//  Contents:   Domain trust support
//
//  History:    07-July-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "trust.h"
#include "trustwiz.h"
#include "domain.h"
#include <lmerr.h>
#include "BehaviorVersion.h"

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  CDsDomainTrustsPage: Domain Trust Page object
//
//-----------------------------------------------------------------------------

#define IDX_TRUST_FLAT_NAME 0
#define IDX_TRUST_ATTR_ATTR 1
#define IDX_TRUST_DIR_ATTR  2
#define IDX_TRUST_TYPE_ATTR 3
#define IDX_TRUST_PARTNER   4
#define NUM_TRUST_ATTR      5

//+----------------------------------------------------------------------------
//
//  Member: CTrustPropPageBase::CTrustPropPageBase
//
//-----------------------------------------------------------------------------
CTrustPropPageBase::CTrustPropPageBase() :
    m_rgTrustList(NULL),
    m_cTrusts(0),
    m_iDomain((ULONG)(-1)),
    _fIsInitialized(false)
{
    TRACE(CTrustPropPageBase,CTrustPropPageBase);
#ifdef _DEBUG
    // NOTICE-2002/02/18-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
    strcpy(szClass, "CTrustPropPageBase");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrustPropPageBase::~CTrustPropPageBase
//
//-----------------------------------------------------------------------------
CTrustPropPageBase::~CTrustPropPageBase()
{
   TRACE(CTrustPropPageBase,~CTrustPropPageBase);

   FreeTrustData();
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::Initialize
//
//  Synopsis:   Do initialialization common to all subclasses.
//
//-----------------------------------------------------------------------------
HRESULT
CTrustPropPageBase::Initialize(CDsPropPageBase * pPage)
{
   TRACE(CTrustPropPageBase, Initialize);
   HRESULT hr = S_OK;

   CWaitCursor Wait;

   m_pPage = pPage;

   //
   // Get the DC name.
   //
   CStrW strServer, strUncSvr;

   hr = GetLdapServerName(m_pPage->m_pDsObj, strServer);

   CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return hr);

   strUncSvr = L"\\\\";
   strUncSvr += strServer;
   SetDcName(strUncSvr);

   hr = InitAndReadDomNames();

   if (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr)
   {
      ErrMsgParam(IDS_TRUST_LSAOPEN_NO_RPC, (LPARAM)GetDcName(),
                  m_pPage->GetHWnd());
      return hr;
   }
   CHECK_WIN32_REPORT(hr, m_pPage->GetHWnd(), return hr);

   hr = QueryTrusts();

   if (SUCCEEDED(hr))
   {
      _fIsInitialized = true;
   }
   CHECK_WIN32_REPORT(hr, m_pPage->GetHWnd(), return hr);

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::GetStrTDO
//
//  Synopsis:   Search for the TDO that represents this trust.
//
//  Remarks:    This method takes the DNS Name of a trust and returns 
//              The TDO path of that TrustedDomain Object. This is needed
//              to be able to post the TrustedDomain Property Page.
//
//              This code is is almost identical to CDsDomainTrustsPage::OnViewTrustPage
//              It had to be duplicated because we need to be able to call it
//              from the NameSuffixRouting page of a Domain with conflicting NameSuffix.
//              
//              This code is only meant to be called from CDsForestNameRoutingPage::OnEditClick
//              but had to be placed here because of the way the Class hierarchy is defined
//              
//-----------------------------------------------------------------------------
void 
CTrustPropPageBase::GetStrTDO ( CStrW strTrustName, CStrW &strTDOPath )
{
    strTDOPath.Empty ();

    // Search for the TDO that represents this trust.
    //
    HRESULT hr;
    //
    // Compose the path to the System container where the Trusted-Domain
    // objects can be found.
    //
    CComPtr<IADsPathname> spADsPath;

    CComBSTR cbstrSysPath;
    CStrW strADsPath;
    hr = m_pPage->GetADsPathname(spADsPath);

    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return);

    hr = spADsPath->Set(CComBSTR(m_pPage->GetObjPathName ()), ADS_SETTYPE_FULL);

    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return);

    hr = spADsPath->RemoveLeafElement ( );

    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return);

    hr = spADsPath->Retrieve(ADS_FORMAT_X500, &cbstrSysPath);

    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return);

    CComPtr <IDirectorySearch> spDsSearch;
    ADS_SEARCH_HANDLE hSrch = NULL;
    PWSTR pwzAttrs[] = {g_wzADsPath};
    PCWSTR pwzDnsName = GetDnsDomainName();

    hr = DSAdminOpenObject(cbstrSysPath,  
                            IID_IDirectorySearch, 
                            (PVOID *)&spDsSearch);

    if (HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE) == hr)
    {
        SuperMsgBox(m_pPage->GetHWnd(),
                    IDS_TRUST_BROKEN, 0,
                    MB_OK | MB_ICONEXCLAMATION,
                    0, (PVOID *)&pwzDnsName, 1,
                    FALSE, __FILE__, __LINE__);
        return;
    }
    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return);

    ADS_SEARCHPREF_INFO SearchPref;
    ZeroMemory ( &SearchPref, sizeof ( SearchPref ) );

    SearchPref.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    SearchPref.vValue.Integer = ADS_SCOPE_ONELEVEL;
    SearchPref.vValue.dwType = ADSTYPE_INTEGER;

    hr = spDsSearch->SetSearchPreference(&SearchPref, 1);

    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return);

    CStrW cstrFilter;

    cstrFilter.Format(L"(&(objectCategory=trustedDomain)(name=%s))", strTrustName);

    //
    // Search for the matching trustedDomain object.
    //
    hr = spDsSearch->ExecuteSearch(cstrFilter,
                                    pwzAttrs, 1, &hSrch);

    CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return);

    hr = spDsSearch->GetNextRow(hSrch);

    if (hr == S_ADS_NOMORE_ROWS)
    {
        dspDebugOut((DEB_ITRACE, "DsProp: GetNextRow returned S_ADS_NOMORE_ROWS.\n"));
        CStr strMessage, strFormat;

        strFormat.LoadString(g_hInstance, IDS_TDO_NOT_FOUND);

        strMessage.Format(strFormat, strTrustName);

        ReportErrorWorker(m_pPage->GetHWnd(), (LPTSTR)(LPCTSTR)strMessage);

        if ( hSrch )
        {    
            spDsSearch->CloseSearchHandle( hSrch );
        }
        return;
    }

    if ( hr != NOERROR )
    {
        if ( hSrch )
        {    
            spDsSearch->CloseSearchHandle( hSrch );
        }
        CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return);
    }

    ADS_SEARCH_COLUMN Column;
    ZeroMemory ( &Column, sizeof (Column) );
    PWSTR pwzTrustObj = NULL;
    //
    // Get the full path name of the Trusted-Domain object.
    //
    hr = spDsSearch->GetColumn(hSrch, g_wzADsPath, &Column);

    if ( hr != NOERROR )
    {
        if ( hSrch )
        {    
            spDsSearch->CloseSearchHandle( hSrch );
        }
        CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return);
    }

    hr = m_pPage->SkipPrefix(Column.pADsValues->CaseIgnoreString, &pwzTrustObj);

    spDsSearch->FreeColumn(&Column);

    if ( hr != NOERROR )
    {
        if ( hSrch )
        {    
            spDsSearch->CloseSearchHandle( hSrch );
        }
        DO_DEL(pwzTrustObj);
        CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return);
    }

    // Store the result.
    //
    strTDOPath = pwzTrustObj;

    if ( hSrch )
    {    
        spDsSearch->CloseSearchHandle( hSrch );
    }
    DO_DEL(pwzTrustObj);
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::QueryTrusts
//
//  Synopsis:   Enumerate the trusts.
//
//-----------------------------------------------------------------------------
HRESULT
CTrustPropPageBase::QueryTrusts(void)
{
    TRACE(CTrustPropPageBase,QueryTrusts);
    HRESULT hr = S_OK;
    CStrW strServer;
    PDS_DOMAIN_TRUSTSW rgTrusts = NULL;
    DWORD dwRet = 0;
    ULONG cTrusts = 0, i = 0, j = 0;

    hr = GetLdapServerName(m_pPage->m_pDsObj, strServer);

    CHECK_HRESULT(hr, return hr);

    dspDebugOut((DEB_ITRACE, "Reading trusts from server: %ws\n", strServer));

    // All forest domains must be enumerated in order to get the local domain,
    // which is the primary domain wrt trust.
    //
    dwRet = DsEnumerateDomainTrusts(strServer,
                                    DS_DOMAIN_IN_FOREST |
                                    DS_DOMAIN_DIRECT_OUTBOUND | 
                                    DS_DOMAIN_DIRECT_INBOUND,
                                    &rgTrusts,
                                    &cTrusts);

    CHECK_WIN32_REPORT(dwRet, m_pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwRet));

    if (!cTrusts) return S_OK;

    dspAssert(rgTrusts);

    // First, get a count of directly trusted domains (+ local domain) so
    // that the correct array size is allocated.
    //
    for (i = 0; i < cTrusts; i++)
    {
        if (rgTrusts[i].Flags & (DS_DOMAIN_PRIMARY | 
                                 DS_DOMAIN_DIRECT_OUTBOUND | 
                                 DS_DOMAIN_DIRECT_INBOUND))
        {
            j++;
        }
    }

    dspDebugOut((DEB_ITRACE, "Total domains: %d, directly trusted: %d\n", cTrusts, j));

    m_cTrusts = j;

    m_rgTrustList = new CEnumDomainTrustItem[m_cTrusts];

    CHECK_NULL_REPORT(m_rgTrustList, m_pPage->GetHWnd(), return E_OUTOFMEMORY);

    // Now copy the trust data.
    //
    for (i = 0, j = 0; i < cTrusts; i++)
    {
        if (!(rgTrusts[i].Flags & (DS_DOMAIN_PRIMARY | 
                                   DS_DOMAIN_DIRECT_OUTBOUND | 
                                   DS_DOMAIN_DIRECT_INBOUND)))
        {
            // Not interested in indirectly trusted domains.
            //
            continue;
        }
        //
        // Copy the trust data
        //
        m_rgTrustList[j].ulFlags = rgTrusts[i].Flags;
        m_rgTrustList[j].ulTrustAttrs = rgTrusts[i].TrustAttributes;
        m_rgTrustList[j].ulTrustType = rgTrusts[i].TrustType;
        m_rgTrustList[j].ulOriginalIndex = i;
        m_rgTrustList[j].ulParentIndex = rgTrusts[i].ParentIndex;
        if (rgTrusts[i].DnsDomainName)
        {
           // NT4 trusts don't have a DNS domain name, so skip the copy if the
           // string is null.
           hr = StringCchLength(rgTrusts[i].DnsDomainName, DNS_MAX_NAME_LENGTH+1, NULL);
           if (FAILED(hr))
           {
              // NOTICE-2002/04/09-ericb - ntbug9 591535, this should pop up a specific error
              // message and then perhaps truncate the name. The best solution would be to try
              // to copy the full name in a try/catch block to handle the case of it not being
              // null terminated.
              dspAssert(false);
              CHECK_HRESULT_REPORT(hr, this->m_pPage->GetHWnd(), ;);
              hr = S_OK;
           }
           m_rgTrustList[j].strDNSname = rgTrusts[i].DnsDomainName;
        }
        hr = StringCchLength(rgTrusts[i].NetbiosDomainName, MAX_COMPUTERNAME_LENGTH+1, NULL);
        if (FAILED(hr) && TRUST_TYPE_MIT != rgTrusts[i].TrustType)
        {
           // Realm (MIT) trusts can have flat names longer than 15 chars.
           //
           // NOTICE-2002/04/09-ericb - ntbug9 591535, this should pop up a specific error
           // message and then perhaps truncate the name. The best solution would be to try
           // to copy the full name in a try/catch block to handle the case of it not being null
           // terminated.
           dspAssert(false);
           CHECK_HRESULT_REPORT(hr, this->m_pPage->GetHWnd(), ;);
           hr = S_OK;
        }
        else
        {
           hr = S_OK;
        }
        m_rgTrustList[j].strFlatName = rgTrusts[i].NetbiosDomainName;

        if (rgTrusts[i].Flags & DS_DOMAIN_PRIMARY)
        {
            // This is the local domain.
            //
            // NOTICE-2002/02/18-ericb - SecurityPush: both strings already validated
            dspAssert(_wcsicmp(GetDomainFlatName(), rgTrusts[i].NetbiosDomainName) == 0);

            m_iDomain = j;

            if (!(rgTrusts[i].Flags & DS_DOMAIN_TREE_ROOT))
            {
                // If not the root, then it has a parent.
                //
                dspAssert(rgTrusts[i].ParentIndex < m_cTrusts);

                m_strDomainParent = rgTrusts[rgTrusts[i].ParentIndex].DnsDomainName;
            }

            m_rgTrustList[j].nRelationship = TRUST_REL_SELF;
        }

        j++;
    }

    // Finally, set relationship value.
    //
    for (i = 0; i < m_cTrusts; i++)
    {
        if (i == m_iDomain)
        {
            // local domain already done.
            //
            continue;
        }

        // NOTICE-2002/02/18-ericb - SecurityPush: both strings already validated
        if (!m_strDomainParent.IsEmpty() && _wcsicmp(m_strDomainParent, m_rgTrustList[i].strDNSname) == 0)
        {
            // This is the parent domain.
            //
            m_rgTrustList[i].nRelationship = TRUST_REL_PARENT;

            continue;
        }

        if (m_rgTrustList[i].ulFlags & DS_DOMAIN_IN_FOREST)
        {
            if (m_rgTrustList[i].ulParentIndex == m_rgTrustList[m_iDomain].ulOriginalIndex)
            {
                m_rgTrustList[i].nRelationship = TRUST_REL_CHILD;
            }
            else if (m_rgTrustList[i].ulFlags & DS_DOMAIN_TREE_ROOT &&
                     m_rgTrustList[m_iDomain].ulFlags & DS_DOMAIN_TREE_ROOT &&
                     ( 
                        // One of the tree roots must be the forest root
                        IsForestRoot () ||      //check the local domain
                        _wcsicmp ( GetForestName(), m_rgTrustList[i].strDNSname ) == 0 //check the current domain
                     )
                    )
            {
                // If the local domain is a tree root, and the current domain
                // is a tree root, and one of them is also the forest root, 
                // Then it is a tree root relationship.                
                m_rgTrustList[i].nRelationship = TRUST_REL_ROOT;
            }
            else
            {
                // Otherwise it is a crosslink
                //
                m_rgTrustList[i].nRelationship = TRUST_REL_CROSSLINK;
            }

            continue;
        }

        // Only external trust now left.
        //
        switch (m_rgTrustList[i].ulTrustType)
        {
        case TRUST_TYPE_MIT:
            m_rgTrustList[i].nRelationship = TRUST_REL_MIT;
            break;

        default:
            dspDebugOut((DEB_ITRACE, "Unknown trust type %d\n", m_rgTrustList[i].ulTrustType));
            // fall through to external
        case TRUST_TYPE_DOWNLEVEL:
        case TRUST_TYPE_UPLEVEL:
            if (m_rgTrustList[i].ulTrustAttrs & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
            {
               m_rgTrustList[i].nRelationship = TRUST_REL_FOREST;
            }
            else
            {
               m_rgTrustList[i].nRelationship = TRUST_REL_EXTERNAL;
            }
        }
    }

    NetApiBufferFree(rgTrusts);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::FreeTrustData
//
//  Synopsis:   Frees the trust data.
//
//-----------------------------------------------------------------------------
void
CTrustPropPageBase::FreeTrustData(void)
{
    if (!m_rgTrustList) return;

    delete [] m_rgTrustList;

    m_rgTrustList = NULL;

    m_cTrusts = 0;
    m_iDomain = (ULONG)(-1);

    m_strDomainParent.Empty();

    return;
}

//+----------------------------------------------------------------------------
//
//  Member: CDsDomainTrustsPage::CDsDomainTrustsPage
//
//-----------------------------------------------------------------------------
CDsDomainTrustsPage::CDsDomainTrustsPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                         HWND hNotifyObj, DWORD dwFlags) :
   m_CtrlId(0),
   m_fIsAllWhistler(FALSE),
   m_fSetAllWhistler(FALSE),
   CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsDomainTrustsPage,CDsDomainTrustsPage);
#ifdef _DEBUG
    // NOTICE-2002/02/18-ericb - SecurityPush: szClass is 32 chars in size so this is safe.
    strcpy(szClass, "CDsDomainTrustsPage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsDomainTrustsPage::~CDsDomainTrustsPage
//
//-----------------------------------------------------------------------------
CDsDomainTrustsPage::~CDsDomainTrustsPage()
{
    TRACE(CDsDomainTrustsPage,~CDsDomainTrustsPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateDomTrustPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateDomTrustPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                   PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                   DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
                   HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateDomTrustPage);

    CDsDomainTrustsPage * pPageObj = new CDsDomainTrustsPage(pDsPage, pDataObj,
                                                             hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CDsDomainTrustsPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_ADSPROP_NOTIFY_CHANGE:
       {
        CWaitCursor Wait;
        ClearUILists();
        FreeTrustData();
        QueryTrusts();
        RefreshLists();
       }
        return TRUE;

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsDomainTrustsPage::OnInitDialog(LPARAM)
{
    TRACE(CDsDomainTrustsPage, OnInitDialog);
    HRESULT hr;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    //
    // Initialize the list view controls.
    //
    HWND hTrustedList = GetDlgItem(m_hPage, IDC_TRUSTED_LIST);
    HWND hTrustingList = GetDlgItem(m_hPage, IDC_TRUSTING_LIST);

    ListView_SetExtendedListViewStyle(hTrustedList, LVS_EX_FULLROWSELECT |
                                                    LVS_EX_LABELTIP);
    ListView_SetExtendedListViewStyle(hTrustingList, LVS_EX_FULLROWSELECT |
                                                     LVS_EX_LABELTIP);
    //
    // Set the column headings.
    //
    PTSTR ptsz;

    if (!LoadStringToTchar(IDS_COL_TITLE_DOMAIN, &ptsz))
    {
        REPORT_ERROR(GetLastError(), GetHWnd());
        return E_OUTOFMEMORY;
    }

    LV_COLUMN lvc;
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    lvc.cx = 134;
    lvc.pszText = ptsz;
    lvc.iSubItem = IDX_DOMNAME_COL;

    ListView_InsertColumn(hTrustedList, IDX_DOMNAME_COL, &lvc);
    ListView_InsertColumn(hTrustingList, IDX_DOMNAME_COL, &lvc);

    delete ptsz;

    if (!LoadStringToTchar(IDS_COL_TITLE_RELATION, &ptsz))
    {
        REPORT_ERROR(GetLastError(), GetHWnd());
        return E_OUTOFMEMORY;
    }

    lvc.cx = 70;
    lvc.pszText = ptsz;
    lvc.iSubItem = IDX_RELATION_COL;

    ListView_InsertColumn(hTrustedList, IDX_RELATION_COL, &lvc);
    ListView_InsertColumn(hTrustingList, IDX_RELATION_COL, &lvc);

    delete ptsz;

    if (!LoadStringToTchar(IDS_COL_TITLE_TRANSITIVE, &ptsz))
    {
        REPORT_ERROR(GetLastError(), GetHWnd());
        return E_OUTOFMEMORY;
    }

    lvc.cx = 65;
    lvc.pszText = ptsz;
    lvc.iSubItem = IDX_TRANSITIVE_COL;

    ListView_InsertColumn(hTrustedList, IDX_TRANSITIVE_COL, &lvc);
    ListView_InsertColumn(hTrustingList, IDX_TRANSITIVE_COL, &lvc);

    delete ptsz;

    EnableButtons(IDC_TRUSTED_LIST, FALSE);
    EnableButtons(IDC_TRUSTING_LIST, FALSE);
    if (m_fReadOnly)
    {
       EnableWindow(GetDlgItem(m_hPage, IDC_ADD_TRUST_BTN), FALSE);
    }

    hr = Initialize(this);

    if (FAILED(hr))
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_ADD_TRUST_BTN), FALSE);
        CHECK_HRESULT(hr, return hr);
    }

    RefreshLists();

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsDomainTrustsPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (m_fInInit)
   {
       return 0;
   }
   if (BN_CLICKED == codeNotify)
   {
      switch (id)
      {
      case IDC_ADD_TRUST_BTN:
         OnAddTrustClick(hwndCtl); //Raid #388023, Yanggao
         break;

      case IDC_REMOVE_TRUSTED_BTN:
         OnRemoveTrustClick(IDC_TRUSTED_LIST);
         break;

      case IDC_VIEW_TRUSTED_BTN:
         OnViewTrustClick(IDC_TRUSTED_LIST);
         break;

      case IDC_REMOVE_TRUSTING_BTN:
         OnRemoveTrustClick(IDC_TRUSTING_LIST);
         break;

      case IDC_VIEW_TRUSTING_BTN:
         OnViewTrustClick(IDC_TRUSTING_LIST);
         break;
      }
   }
   return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::OnNotify
//
//  Synopsis:   Handles notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsDomainTrustsPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    dspDebugOut((DEB_USER6, "DsProp listview id %d code %d\n",
                 ((LPNMHDR)lParam)->code));

    if (m_fInInit)
    {
        return 0;
    }
    switch (((LPNMHDR)lParam)->code)
    {
    case LVN_ITEMCHANGED:
        EnableButtons(((LPNMHDR)lParam)->idFrom, TRUE);
        break;

    case NM_SETFOCUS:
        {
           HWND hList = GetDlgItem(m_hPage, (int)((LPNMHDR)lParam)->idFrom);

           if (ListView_GetItemCount(hList))
           {
              int item = ListView_GetNextItem(hList, -1, LVNI_ALL | LVIS_SELECTED);

              if (item < 0)
              {
                 // If nothing is selected, set the focus to the first item.
                 //
                 LV_ITEM lvi = {0};
                 lvi.mask = LVIF_STATE;
                 lvi.stateMask = LVIS_FOCUSED;
                 lvi.state = LVIS_FOCUSED;
                 ListView_SetItem(hList, &lvi);
              }
           }
        }
        EnableButtons(((LPNMHDR)lParam)->idFrom, TRUE);
        break;

    case NM_KILLFOCUS:
        EnableButtons(((LPNMHDR)lParam)->idFrom, TRUE);
        break;
#ifdef NOTYET
        DEFAULT_UNREACHABLE
#endif
    }

    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:    CDsDomainTrustsPage::IsAllWhistler
//
//  Synopsis:  Call GetEnterpriseVer to check the msDS-Behavior-Version
//             attribute of the Partitions container. If the value exists
//             and is greater or equal to 1, then the function returns
//             TRUE. The value is cached for subsequent calls.
//
//-----------------------------------------------------------------------------
BOOL
CDsDomainTrustsPage::IsAllWhistler(void)
{
   TRACE(CDsDomainTrustsPage,IsAllWhistler)

   if (m_fSetAllWhistler)
   {
      return m_fIsAllWhistler;
   }

   m_fIsAllWhistler = FALSE;

   HRESULT hr = GetEnterpriseVer(GetDcName(), &m_fIsAllWhistler);

   CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return FALSE);

   m_fSetAllWhistler = TRUE;

   return m_fIsAllWhistler;
}

//+----------------------------------------------------------------------------
//
//  Function:  GetEnterpriseVer
//
//  Synopsis:  Checks the msDS-Behavior-Version attribute of the Partitions
//             container. If the value exists and is greater or equal to 1,
//             then the parameter boolean is set to TRUE.
//
// TODO: move to CDSBasePathsInfo and return a version number rather than the bool
//-----------------------------------------------------------------------------
HRESULT
GetEnterpriseVer(PCWSTR pwzDC, BOOL * pfAllWhistler)
{
   dspDebugOut((DEB_ITRACE, "GetEnterpriseVer checking %ws\n", pwzDC));
   dspAssert(pwzDC && *pwzDC != L'\\');

   //
   // Look in the AD for the V_forest value.
   //

   CDSBasePathsInfo cBase;

   HRESULT hr = cBase.InitFromName(pwzDC);

   if (HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN) == hr)
   {
      // Win2k DCs can return this error.
      //
      DBG_OUT("CDSBasePathsInfo::InitFromName returned ERROR_DS_SERVER_DOWN\n");
      *pfAllWhistler = FALSE;
      return S_OK;
   }
   CHECK_HRESULT(hr, return hr);

   CStrW strPath = cBase.GetConfigNamingContext();

   CComPtr<IADsPathname> spADsPath;

   hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                         IID_IADsPathname, (PVOID *)&spADsPath);

   CHECK_HRESULT(hr, return hr);

   hr = spADsPath->Set(strPath, ADS_SETTYPE_DN);

   CHECK_HRESULT(hr, return hr);

   hr = spADsPath->SetDisplayType(ADS_DISPLAY_FULL);

   CHECK_HRESULT(hr, return hr);

   hr = spADsPath->AddLeafElement(CComBSTR(g_wzPartitionsContainer));

   CHECK_HRESULT(hr, return hr);

   CComBSTR bstrPartitions;

   hr = spADsPath->Retrieve(ADS_FORMAT_X500, &bstrPartitions);

   CHECK_HRESULT(hr, return hr);

   dspDebugOut((DEB_ITRACE, "Binding to %ws\n", bstrPartitions));

   CComPtr<IADs> spPartitions;

   hr = DSAdminOpenObject(bstrPartitions, 
                          IID_IADs, 
                          (PVOID *)&spPartitions);

   CHECK_HRESULT(hr, return hr);

   CComVariant var;

   hr = spPartitions->Get(CComBSTR(g_wzBehaviorVersion), &var);

   if (E_ADS_PROPERTY_NOT_FOUND == hr)
   {
      // Win2K will return property-not-found.
      //
      hr = S_OK;

      *pfAllWhistler = FALSE;
   }
   else
   {
      CHECK_HRESULT(hr, return hr);

      *pfAllWhistler = var.iVal >= FOREST_VER_XP;
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::OnAddTrustClick
//
//  Synopsis:   Posts the Add-Trust Wizard.
//
//-----------------------------------------------------------------------------
void
CDsDomainTrustsPage::OnAddTrustClick(HWND CtlhWnd)
{
   TRACER(CDsDomainTrustsPage, OnAddTrustClick);

   //
   // Launch the New Trust Wizard.
   //

   CNewTrustWizard Wiz(this);

   HRESULT hr = Wiz.CreatePages();

   CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return);

   hr = Wiz.LaunchModalWiz();

   CHECK_HRESULT_REPORT(hr, m_pPage->GetHWnd(), return);

   hr = Wiz.GetCreationResult();

   if (HRESULT_FROM_WIN32(ERROR_DOMAIN_EXISTS) == hr)
   {
      // The wizard detected that the trust already exists in both directions.
      // Check to see if it is listed in both lists. If not (it was created
      // asyncronously), refresh the lists.
      //
      const CEnumDomainTrustItem * pTrust = NULL;

      pTrust = IsTrustListed(Wiz.OtherDomain.GetDnsDomainName(),
                             Wiz.OtherDomain.GetDomainFlatName());
      if (!pTrust ||
          (pTrust && !(pTrust->ulFlags & (DS_DOMAIN_DIRECT_OUTBOUND |
                                          DS_DOMAIN_DIRECT_INBOUND))))
      {
         // Trust not found in both lists. We want to refresh the list in this
         // case, so set hr to S_OK.
         //
         hr = S_OK;
      }
   }

   ::SetFocus(CtlhWnd); //Raid #388023, Yanggao
   
   if (SUCCEEDED(hr))
   {
      CWaitCursor Wait;
      ClearUILists();
      FreeTrustData();
      QueryTrusts();
      RefreshLists();
   }

   if ( Wiz.Trust.IsExternal() && Wiz.WasQuarantineSet () )
   {
       //Popup to warn about SID filtering      

       //First check to see if the user has not disabled pop-up
       HKEY hKey = NULL;
       DWORD regValue = 0x0;
       DWORD valueType = REG_DWORD;
       DWORD dataSize = sizeof ( DWORD );
       if ( RegOpenKeyEx ( HKEY_CURRENT_USER, 
                          L"Software\\Policies\\Microsoft\\Windows\\Directory UI",
                          NULL,
                          KEY_QUERY_VALUE,
                          &hKey
                          ) == ERROR_SUCCESS
           )
       {
            RegQueryValueEx(  hKey,
                              L"SIDFilterNoPopup",
                              NULL,
                              &valueType,
                              (BYTE *) &regValue,
                              &dataSize
                             );
            RegCloseKey ( hKey );
       }

       if ( ! (valueType == REG_DWORD && regValue == 0x1) )
       {
           CQuarantineWarnDlg QWarnDlg ( m_pPage->GetHWnd(), IDD_QUARANTINED_TRUST );
           QWarnDlg.DoModal ();
       }
   }

   if (Wiz.Trust.AreThereCollisions())
   {
      // If there are name collisions, ask if the user wants to save the
      // forest trust naming info to a file.
      //
      CStrW strTitle, strMsg;

      // NOTICE-2002/02/18-ericb - SecurityPush: CStrW::LoadString sets the
      // string to an empty string on failure.
      strTitle.LoadString(g_hInstance, IDS_DNT_MSG_TITLE);
      // NOTICE-2002/02/18-ericb - SecurityPush: if CStrW::FormatMessage
      // fails it sets the string value to an empty string.
      strMsg.FormatMessage(g_hInstance, IDS_COLLISIONS_MSG, Wiz.OtherDomain.GetDnsDomainName());

      int nRet = MessageBox(GetHWnd(), strMsg, strTitle, MB_YESNO | MB_ICONINFORMATION);

      if (IDYES == nRet)
      {
         SaveFTInfoAs(GetHWnd(),
                      Wiz.OtherDomain.GetDomainFlatName(),
                      Wiz.OtherDomain.GetDnsDomainName(),
                      Wiz.Trust.GetFTInfo(),
                      Wiz.Trust.GetCollisionInfo());
      }
   }

   if (Wiz.Trust.IsCreateBothSides() && Wiz.OtherDomain.AreThereCollisions())
   {
      // If there are name collisions, ask if the user wants to save the
      // forest trust naming info to a file.
      //
      CStrW strTitle, strMsg;

      // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::Loadstring notice
      strTitle.LoadString(g_hInstance, IDS_DNT_MSG_TITLE);
      // NOTICE-2002/02/18-ericb - SecurityPush: if CStrW::FormatMessage
      // fails it sets the string value to an empty string.
      strMsg.FormatMessage(g_hInstance, IDS_LOCAL_COLLISIONS_MSG, GetDnsDomainName());

      int nRet = MessageBox(GetHWnd(), strMsg, strTitle, MB_YESNO | MB_ICONINFORMATION);

      if (IDYES == nRet)
      {
         SaveFTInfoAs(GetHWnd(),
                      GetDomainFlatName(),
                      GetDnsDomainName(),
                      Wiz.OtherDomain.GetFTInfo(),
                      Wiz.OtherDomain.GetCollisionInfo());
      }
   }

   return;
}

//+----------------------------------------------------------------------------
//
//  Method:    CDsDomainTrustsPage::ConfirmRemove
//
//  Synopsis:  Post a dialog asking the user to confirm the trust removal.
//
//-----------------------------------------------------------------------------
int
CDsDomainTrustsPage::ConfirmRemove(PCWSTR pwzTrustedDomain, TRUST_OP DirToRm,
                                   bool fBothSides)
{
   //
   // Post a confirmation query.
   //
   int nID;
   CStr strTitle, strMsg, strFormat;

   if (REMOVE_TRUST_OUTBOUND == DirToRm)
   {
      nID = fBothSides ? IDS_REMOVE_OUT_CONFIRM_BOTH : IDS_REMOVE_OUT_CONFIRM;
   }
   else
   {
      nID = fBothSides ? IDS_REMOVE_IN_CONFIRM_BOTH : IDS_REMOVE_IN_CONFIRM;
   }

   // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::Loadstring notice
   if (!strTitle.LoadString(g_hInstance, IDS_MSG_TITLE))
   {
       REPORT_ERROR(GetLastError(), m_hPage);
       return IDNO;
   }
   // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::Loadstring notice
   if (!strFormat.LoadString(g_hInstance, nID))
   {
       REPORT_ERROR(GetLastError(), m_hPage);
       return IDNO;
   }

   strMsg.Format(strFormat, pwzTrustedDomain, pwzTrustedDomain);

   return MessageBox(m_hPage, strMsg, strTitle, MB_YESNO | MB_ICONWARNING);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::OnRemoveTrustClick
//
//  Synopsis:   Remove the direction of trust indicated by the current list
//              selection.
//
//-----------------------------------------------------------------------------
void
CDsDomainTrustsPage::OnRemoveTrustClick(int id)
{
   TRACE(CDsDomainTrustsPage, OnRemoveTrustClick);
   HRESULT hr = S_OK;
   int iRet = 0;

   //
   // Determine which list item was selected for deletion.
   //
   HWND hList = GetDlgItem(m_hPage, id);

   int i = ListView_GetNextItem(hList, -1, LVNI_SELECTED);

   if (i < 0)
   {
      dspDebugOut((DEB_ITRACE, "DsProp: no list selection.\n"));
      return;
   }

   WCHAR wzTrustedDomain[MAX_PATH + 1] = {0};

   ListView_GetItemText(hList, i, 0, wzTrustedDomain, MAX_PATH);

   // NOTICE-2002/02/18-ericb - SecurityPush: wzTrustedDomain is initialized to
   // all zeros and is one char longer than the size passed to ListView_GetItemText
   // so that even if this function truncates without null terminating, the
   // string will still be null terminated.
   dspAssert(wcslen(wzTrustedDomain) > 0);

   LV_ITEM lvi;
   lvi.mask = LVIF_PARAM;
   lvi.iItem = i;
   lvi.iSubItem = IDX_DOMNAME_COL;

   if (!ListView_GetItem(hList, &lvi))
   {
      dspAssert(FALSE);
      return;
   }
   PCEnumDomainTrustItem pTrust = (PCEnumDomainTrustItem)lvi.lParam;
   dspAssert(pTrust);
   bool fBothSides = false;
   DWORD dwErr = NO_ERROR;
   TRUST_OP DirToRm = (id == IDC_TRUSTED_LIST) ?  REMOVE_TRUST_OUTBOUND :
                                                  REMOVE_TRUST_INBOUND;

   dwErr = OpenLsaPolicyWithPrompt(_CredMgr._LocalCreds, m_hPage);

   if (ERROR_CANCELLED == dwErr)
   {
       // don't report error if user canceled.
       //
       return;
   }

   CHECK_WIN32_REPORT(dwErr, m_hPage, return);

   CRemoteDomain OtherDomain(wzTrustedDomain);
   CWaitCursor Wait;
   int nResponse = 0;
   bool fRefresh = false;

   do
   {
      if (TRUST_REL_MIT == pTrust->nRelationship)
      {
         if (IDYES != ConfirmRemove(wzTrustedDomain, DirToRm))
         {
            break;
         }

         Wait.SetWait();

         dwErr = RemoveLocalTrust(pTrust, OtherDomain, DirToRm);

         CHECK_WIN32_REPORT(dwErr, m_hPage, break);

         fRefresh = true;

         break;
      }

      // Need to check if the remote domain is uplevel; we don't do both sides
      // for downlevel domains.
      //
      Wait.SetWait();

      hr = OtherDomain.DiscoverDC(wzTrustedDomain);

      if (FAILED(hr) || !OtherDomain.IsFound())
      {
         if (!OtherDomain.IsFound() ||
             HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN) == hr ||
             HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr ||
             HRESULT_FROM_WIN32(RPC_S_INVALID_NET_ADDR) == hr ||
             HRESULT_FROM_WIN32(ERROR_BAD_NETPATH) == hr ||
             HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE) == hr)
         {            
            // Remote domain not found. Ask user if the trust should be
            // forcibly removed from this domain.
            //
            LSA_UNICODE_STRING Name = {0};

            RtlInitUnicodeString(&Name, wzTrustedDomain);

            hr = QueryDeleteTrust(&Name, NULL, _CredMgr._LocalCreds);

            if (S_OK == hr)
            {
               Wait.SetWait();
               fRefresh = true;
            }
         }
         else
         {
            CHECK_HRESULT_REPORT(hr, m_hPage, ;);
         }
         break;
      }

      hr = OtherDomain.InitAndReadDomNames();

      if (HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) == hr)
      {
          // NTRAID#NTBUG9-750822-2002/12/17-shasan 
          // Remote domain not found. Ask user if the trust should be
          // forcibly removed from this domain.
          //

          LSA_UNICODE_STRING Name = {0};

          RtlInitUnicodeString(&Name, wzTrustedDomain);

          hr = QueryDeleteTrust(&Name, NULL, _CredMgr._LocalCreds);

          if (S_OK == hr)
          {
              Wait.SetWait();
              fRefresh = true;
          }
          
          break;
      }

      CHECK_HRESULT_REPORT(hr, m_hPage, break);

      if (OtherDomain.IsUplevel())
      {
         if (_strLastRmDomain != wzTrustedDomain)
         {
            //
            // If removing a different trust, don't remember the remote creds
            // since there are probably different creds for each trust partner.
            //
            _strLastRmDomain = wzTrustedDomain;
            _CredMgr._RemoteCreds.Clear();
         }

         CRemoveBothSidesDlg RmBothSidesDlg(m_hPage, _CredMgr._RemoteCreds,
                                            wzTrustedDomain);

         nResponse = (int)RmBothSidesDlg.DoModal();

         if (IDCANCEL == nResponse)
         {
            break;
         }

         fBothSides = nResponse == IDYES;
      }

      if (IDYES != ConfirmRemove(wzTrustedDomain, DirToRm, fBothSides))
      {
         break;
      }

      Wait.SetWait();

      if (fBothSides)
      {
         // Remove the remote side first. Set the fRmAll flag if not currently
         // bi-di. Remove the opposite direction from the local trust. Set the
         // last param to true if it is an outbound-only forest trust.
         //
         dwErr = RemoveRemoteTrust(OtherDomain,
                                   !(pTrust->ulFlags & DS_DOMAIN_DIRECT_OUTBOUND &&
                                     pTrust->ulFlags & DS_DOMAIN_DIRECT_INBOUND),
                                   (REMOVE_TRUST_INBOUND == DirToRm) ?
                                       REMOVE_TRUST_OUTBOUND :
                                       REMOVE_TRUST_INBOUND,
                                   TRUST_REL_FOREST == pTrust->nRelationship &&
                                       DS_DOMAIN_DIRECT_OUTBOUND == pTrust->ulFlags);
         if (ERROR_ACCESS_DENIED == dwErr)
         {
            ErrMsgParam(IDS_RM_OTHER_NO_ACCESS, (LPARAM)wzTrustedDomain, m_hPage);
            _CredMgr._RemoteCreds.Clear();
            break;
         }
         if (ERROR_FILE_NOT_FOUND == dwErr)
         {
            nResponse = MsgBoxParam(IDS_RM_OTHER_NOT_FOUND,
                                    (LPARAM)wzTrustedDomain,
                                    m_hPage,
                                    MB_OKCANCEL | MB_ICONINFORMATION);
            if (IDOK != nResponse)
            {
               break;
            }
         }
         else
         {
            CHECK_WIN32_REPORT(dwErr, m_hPage, break);
         }
      }

      dwErr = RemoveLocalTrust(pTrust, OtherDomain, DirToRm);

      CHECK_WIN32_REPORT(dwErr, m_hPage, break);

      fRefresh = true;

   } while (false);

   if (fRefresh)
   {
      ClearUILists();
      FreeTrustData();
      QueryTrusts();
      RefreshLists();
      if (IDC_TRUSTED_LIST == id)
      {
         EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_TRUSTED_BTN), FALSE);
         EnableWindow(GetDlgItem(m_hPage, IDC_VIEW_TRUSTED_BTN), FALSE);
      }
      else
      {
         EnableWindow(GetDlgItem(m_hPage, IDC_REMOVE_TRUSTING_BTN), FALSE);
         EnableWindow(GetDlgItem(m_hPage, IDC_VIEW_TRUSTING_BTN), FALSE);
      }
      SetFocus(GetDlgItem(m_hPage, id));
   }

   CloseLsaPolicy();
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::RemoveLocalTrust
//
//  Synopsis:   Remove one direction of trust from the local TDO.
//
//-----------------------------------------------------------------------------
DWORD
CDsDomainTrustsPage::RemoveLocalTrust(PCEnumDomainTrustItem pTrust,
                                      CRemoteDomain & OtherDomain,
                                      TRUST_OP DirToRm)
{
   TRACE(CDsDomainTrustsPage,RemoveLocalTrust);
   if (!pTrust)
   {
      dspAssert(false);
      return ERROR_INVALID_PARAMETER;
   }
   //
   // Remove the trust.
   //
   CWaitCursor Wait;

   LSA_UNICODE_STRING Name = {0}, FlatName = {0};

   switch (pTrust->ulTrustType)
   {
   case TRUST_TYPE_UPLEVEL:
      RtlInitUnicodeString(&Name, OtherDomain.GetDnsDomainName());
      RtlInitUnicodeString(&FlatName, OtherDomain.GetDomainFlatName());
      break;

   case TRUST_TYPE_DOWNLEVEL:
      RtlInitUnicodeString(&Name, OtherDomain.GetDomainFlatName());
      break;

   case TRUST_TYPE_MIT:
      RtlInitUnicodeString(&Name, OtherDomain.GetUserEnteredName());
      break;

   default:
       dspAssert(FALSE);
       return LsaNtStatusToWinError(STATUS_INVALID_PARAMETER);
   }

   NTSTATUS Status;

   _CredMgr.ImpersonateLocal();

   if ((pTrust->ulFlags & DS_DOMAIN_DIRECT_OUTBOUND) &&
       (pTrust->ulFlags & DS_DOMAIN_DIRECT_INBOUND))
   {
      // Remove the trust in one direction only.
      //
      Status = RemoveTrustDirection(GetLsaPolicy(), &Name, &FlatName, OtherDomain.GetSid (),
                                    pTrust->ulTrustType, DirToRm);
   }
   else
   {
       // Remove all trust.
       //
       Status = DeleteTrust(GetLsaPolicy(), &Name, &FlatName, OtherDomain.GetSid (), pTrust->ulTrustType);
   }

   _CredMgr.Revert();

   if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
       Status == STATUS_NO_SUCH_DOMAIN)
   {
       Status = 0;
       //
       // Remote domain does not know about the trust (i.e. remote domain
       // was clean-reinstalled without having trust re-established) or the
       // remote domain no longer exists.
       // Ask user if the remnants of the trust should be removed on this
       // side.
       //

       HRESULT hr = QueryDeleteTrust(&Name, OtherDomain.GetSid(), _CredMgr._LocalCreds);

       CHECK_HRESULT(hr, Status = STATUS_UNSUCCESSFUL)
   }
   else
   {
       CHECK_LSA_STATUS_REPORT(Status, GetHWnd(), ;);
   }

   return LsaNtStatusToWinError(Status);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::RemoveRemoteTrust
//
//  Synopsis:   Remove one direction of trust from the remote TDO.
//
//-----------------------------------------------------------------------------
DWORD
CDsDomainTrustsPage::RemoveRemoteTrust(CRemoteDomain & OtherDomain,
                                       bool fRmAll, TRUST_OP DirToRm,
                                       bool fIsOutboundForest)
{
   TRACE(CDsDomainTrustsPage,RemoveRemoteTrust);
   //
   // Remove the trust.
   //
   CWaitCursor Wait;

   LSA_UNICODE_STRING Name = {0}, FlatName = {0};

   RtlInitUnicodeString(&Name, GetDnsDomainName());
   RtlInitUnicodeString(&FlatName, GetDomainFlatName());

   DWORD dwErr = NO_ERROR;
   NTSTATUS Status = STATUS_SUCCESS;

   _CredMgr.ImpersonateRemote();

   dwErr = OtherDomain.OpenLsaPolicy(_CredMgr._RemoteCreds,
                                     fIsOutboundForest ? 0 : POLICY_CREATE_SECRET);

   CHECK_WIN32(dwErr, return dwErr);

   if (fRmAll)
   {
       // Remove all trust.
       //
       Status = DeleteTrust(OtherDomain.GetLsaPolicy(), &Name, &FlatName, GetSid (),
                            TRUST_TYPE_UPLEVEL);
   }
   else
   {
      // Remove the trust in one direction only.
      //
      Status = RemoveTrustDirection(OtherDomain.GetLsaPolicy(), &Name,
                                    &FlatName, GetSid (),
                                    TRUST_TYPE_UPLEVEL, DirToRm);
   }

   _CredMgr.Revert();

   return LsaNtStatusToWinError(Status);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::OnViewTrustClick
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
void
CDsDomainTrustsPage::OnViewTrustClick(int id)
{
    TRACE(CDsDomainTrustsPage, OnViewTrustClick);
    HWND hList = GetDlgItem(m_hPage, id);

    int i = ListView_GetNextItem(hList, -1, LVNI_SELECTED);

    if (i < 0)
    {
        dspDebugOut((DEB_ITRACE, "DsProp: no list selection.\n"));
        return;
    }

    LV_ITEM lvi;
    lvi.mask = LVIF_PARAM;
    lvi.iItem = i;
    lvi.iSubItem = IDX_DOMNAME_COL;
    if (!ListView_GetItem(hList, &lvi))
    {
        dspAssert(FALSE);
        return;
    }
    PCEnumDomainTrustItem pTrust = (PCEnumDomainTrustItem)lvi.lParam;
    dspAssert(pTrust);

    if (pTrust->strTDOpath.IsEmpty())
    {
        // Search for the TDO that represents this trust.
        //

        // The code in CTrustPropPageBase::GetStrTDO is based on the following code
        // If changes are made to this, the code in CTrustPropPageBase::GetStrTDO
        // may also need to be modified.
        HRESULT hr;
        //
        // Compose the path to the System container where the Trusted-Domain
        // objects can be found.
        //
        CComPtr<IADsPathname> spADsPath;

        WCHAR wzSys[] = L"cn=system";
        CComBSTR cbstrSysPath;
        CStrW strADsPath;
        hr = GetADsPathname(spADsPath);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        hr = spADsPath->Set(CComBSTR(m_pwszObjPathName), ADS_SETTYPE_FULL);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        hr = spADsPath->AddLeafElement(CComBSTR(wzSys));

        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        hr = spADsPath->Retrieve(ADS_FORMAT_X500, &cbstrSysPath);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        CComPtr <IDirectorySearch> spDsSearch;
        ADS_SEARCH_HANDLE hSrch = NULL;
        PWSTR pwzAttrs[] = {g_wzADsPath};
        PCWSTR pwzDnsName = GetDnsDomainName();

        hr = DSAdminOpenObject(cbstrSysPath,  
                               IID_IDirectorySearch, 
                               (PVOID *)&spDsSearch);

        if (HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE) == hr)
        {
            SuperMsgBox(m_pPage->GetHWnd(),
                        IDS_TRUST_BROKEN, 0,
                        MB_OK | MB_ICONEXCLAMATION,
                        0, (PVOID *)&pwzDnsName, 1,
                        FALSE, __FILE__, __LINE__);
            return;
        }
        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        ADS_SEARCHPREF_INFO SearchPref;
        ZeroMemory ( &SearchPref, sizeof ( SearchPref ) );

        SearchPref.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        SearchPref.vValue.Integer = ADS_SCOPE_ONELEVEL;
        SearchPref.vValue.dwType = ADSTYPE_INTEGER;

        hr = spDsSearch->SetSearchPreference(&SearchPref, 1);

        CHECK_HRESULT_REPORT(hr, m_hPage, return);

        CStrW cstrFilter;

        cstrFilter.Format(L"(&(objectCategory=trustedDomain)(flatName=%s))", pTrust->strFlatName);

        //
        // Search for the matching trustedDomain object.
        //
        hr = spDsSearch->ExecuteSearch(cstrFilter,
                                       pwzAttrs, 1, &hSrch);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), return);

        hr = spDsSearch->GetNextRow(hSrch);

        if (hr == S_ADS_NOMORE_ROWS)
        {
            dspDebugOut((DEB_ITRACE, "DsProp: GetNextRow returned S_ADS_NOMORE_ROWS.\n"));
            CStr strMessage, strFormat;

            // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::Loadstring notice
            strFormat.LoadString(g_hInstance, IDS_TDO_NOT_FOUND);

            strMessage.Format(strFormat, pTrust->strFlatName);

            ReportErrorWorker(m_hPage, (LPTSTR)(LPCTSTR)strMessage);
            if ( hSrch )
            {    
                spDsSearch->CloseSearchHandle( hSrch );
            }
            return;
        }

        if ( hr != NOERROR )
        {
            if ( hSrch )
            {    
                spDsSearch->CloseSearchHandle( hSrch );
            }
            CHECK_HRESULT_REPORT(hr, GetHWnd(), return);
        }

        ADS_SEARCH_COLUMN Column;
        ZeroMemory ( &Column, sizeof ( Column ) );
        PWSTR pwzTrustObj = NULL;

        //
        // Get the full path name of the Trusted-Domain object.
        //
        hr = spDsSearch->GetColumn(hSrch, g_wzADsPath, &Column);

        if ( hr != NOERROR )
        {
            if ( hSrch )
            {    
                spDsSearch->CloseSearchHandle( hSrch );
            }
            CHECK_HRESULT_REPORT(hr, GetHWnd(), return);
        }

        hr = SkipPrefix(Column.pADsValues->CaseIgnoreString, &pwzTrustObj);

        spDsSearch->FreeColumn(&Column);
        if ( hr != NOERROR )
        {
            DO_DEL(pwzTrustObj);
            if ( hSrch )
            {    
                spDsSearch->CloseSearchHandle( hSrch );
            }
            CHECK_HRESULT_REPORT(hr, GetHWnd(), return);
        }


        // Store the result.
        //
        pTrust->strTDOpath = pwzTrustObj;
        if ( hSrch )
        {    
            spDsSearch->CloseSearchHandle( hSrch );
        }
        DO_DEL(pwzTrustObj);
    }

    PostPropSheet(pTrust->strTDOpath, this, m_fReadOnly);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::EnableButtons
//
//  Synopsis:   Enable/disable the buttons depending on the selection in the
//              corresponding list.
//
//-----------------------------------------------------------------------------
void
CDsDomainTrustsPage::EnableButtons(UINT_PTR id, BOOL fEnable)
{
    TRACE(CDsDomainTrustsPage, EnableButtons);
    BOOL fEnableViewEdit = FALSE, fEnableRemove = FALSE;
    int iViewEdit = IDC_VIEW_TRUSTED_BTN, iRemove = IDC_REMOVE_TRUSTED_BTN;

    if (id == IDC_TRUSTING_LIST)
    {
        iViewEdit = IDC_VIEW_TRUSTING_BTN;
        iRemove = IDC_REMOVE_TRUSTING_BTN;
    }
    if (fEnable)
    {
        //
        // Find out which item is selected and then get is relationship type.
        //
        HWND hList = GetDlgItem(m_hPage, (int)id);

        int item = ListView_GetNextItem(hList, -1, LVNI_ALL | LVIS_SELECTED);

        if (item < 0)
        {
            // disable the remove and edit controls.
            //
            fEnableViewEdit = fEnableRemove = FALSE;
        }
        else
        {
            LV_ITEM lvi;
            lvi.mask = LVIF_PARAM;
            lvi.iItem = item;
            lvi.iSubItem = IDX_DOMNAME_COL;
            if (!ListView_GetItem(hList, &lvi))
            {
                dspAssert(FALSE);
                return;
            }
            PCEnumDomainTrustItem pTrust = (PCEnumDomainTrustItem)lvi.lParam;
            dspAssert(pTrust);
            if ((pTrust->nRelationship == TRUST_REL_PARENT) ||
                (pTrust->nRelationship == TRUST_REL_CHILD)  ||
                (pTrust->nRelationship == TRUST_REL_ROOT))
            {
                fEnableRemove = FALSE;
            }
            else
            {
                fEnableRemove = TRUE;
            }
            fEnableViewEdit = TRUE;
        }
        if (m_fReadOnly)
        {
           fEnableRemove = FALSE;
        }
    }

    EnableWindow(GetDlgItem(m_hPage, iViewEdit), fEnableViewEdit);
    EnableWindow(GetDlgItem(m_hPage, iRemove), fEnableRemove);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::RefreshLists
//
//  Synopsis:   Enumerate the Trusted-Domain objects and populate the UI lists.
//
//-----------------------------------------------------------------------------
HRESULT
CDsDomainTrustsPage::RefreshLists(void)
{
    HRESULT hr = S_OK;
    int nInItem = 0, nOutItem = 0;
    HWND hTrustedList = GetDlgItem(m_hPage, IDC_TRUSTED_LIST);
    HWND hTrustingList = GetDlgItem(m_hPage, IDC_TRUSTING_LIST);
    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT | LVIF_PARAM;
    lvi.iSubItem = IDX_DOMNAME_COL;

    for (ULONG i = 0; i < m_cTrusts; i++)
    {
        int idRel;
        int idTrans = IDS_YES;
        CStrW strRel, strTrans;
        //
        // Get the relationship string.
        //
        switch (m_rgTrustList[i].nRelationship)
        {
        case TRUST_REL_SELF:
            // Don't put the local domain in the list.
            //
            continue;

        case TRUST_REL_PARENT:
            idRel = IDS_REL_PARENT;
            break;

        case TRUST_REL_CHILD:
            idRel = IDS_REL_CHILD;
            break;

        case TRUST_REL_ROOT:
            idRel = IDS_REL_TREE_ROOT;
            break;

        case TRUST_REL_CROSSLINK:
            idRel = IDS_REL_CROSSLINK;
            break;

        case TRUST_REL_EXTERNAL:
            idRel = IDS_REL_EXTERNAL;
            idTrans = IDS_NO;
            break;

        case TRUST_REL_FOREST:
            idRel = IDS_REL_FOREST;
            break;

        case TRUST_REL_INDIRECT:
            idRel = IDS_REL_INDIRECT;
            break;

        case TRUST_REL_MIT:
            idRel = IDS_REL_MIT;
            break;

        default:
            idRel = IDS_REL_UNKNOWN;
            break;
        }
        // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::Loadstring notice
        if (!strRel.LoadString(g_hInstance, idRel))
        {
            REPORT_ERROR(GetLastError(), GetHWnd());
            hr = E_OUTOFMEMORY;
            break;
        }

        if (m_rgTrustList[i].ulTrustAttrs & TRUST_ATTRIBUTE_NON_TRANSITIVE)
        {
            idTrans = IDS_NO;
        }
        // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::Loadstring notice
        if (!strTrans.LoadString(g_hInstance, idTrans))
        {
            REPORT_ERROR(GetLastError(), GetHWnd());
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Insert into the list control.
        //
        lvi.pszText = (m_rgTrustList[i].strDNSname.IsEmpty()) ?
                         const_cast<PWSTR>((LPCWSTR)m_rgTrustList[i].strFlatName) :
                         const_cast<PWSTR>((LPCWSTR)m_rgTrustList[i].strDNSname);
        lvi.lParam = (LPARAM)&m_rgTrustList[i];

        int iItem;

        if (m_rgTrustList[i].ulFlags & DS_DOMAIN_DIRECT_OUTBOUND)
        {
            lvi.iItem = nInItem;
            iItem = ListView_InsertItem(hTrustedList, &lvi);
            ListView_SetItemText(hTrustedList, iItem, IDX_RELATION_COL,
                                 const_cast<PWSTR>((LPCWSTR)strRel));
            ListView_SetItemText(hTrustedList, iItem, IDX_TRANSITIVE_COL,
                                 const_cast<PWSTR>((LPCWSTR)strTrans));
            nInItem++;
        }

        if (m_rgTrustList[i].ulFlags & DS_DOMAIN_DIRECT_INBOUND)
        {
            lvi.iItem = nOutItem;
            iItem = ListView_InsertItem(hTrustingList, &lvi);
            ListView_SetItemText(hTrustingList, iItem, IDX_RELATION_COL,
                                 const_cast<PWSTR>((LPCWSTR)strRel));
            ListView_SetItemText(hTrustingList, iItem, IDX_TRANSITIVE_COL,
                                 const_cast<PWSTR>((LPCWSTR)strTrans));
            nOutItem++;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::ClearUILists
//
//  Synopsis:   Empty the lists.
//
//-----------------------------------------------------------------------------
void
CDsDomainTrustsPage::ClearUILists(void)
{
    ListView_DeleteAllItems(GetDlgItem(m_hPage, IDC_TRUSTED_LIST));
    ListView_DeleteAllItems(GetDlgItem(m_hPage, IDC_TRUSTING_LIST));
}

//+----------------------------------------------------------------------------
//
//  Method:    CRemoveBothSidesDlg::OnInitDialog
//
//-----------------------------------------------------------------------------
LRESULT
CRemoveBothSidesDlg::OnInitDialog(LPARAM lParam)
{
   if (_Creds.IsSet())
   {
      // Don't need to get them again.
      //
      CStrW strMsg;
      // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::Loadstring notice
      strMsg.LoadString(g_hInstance, IDS_RM_BOTH_SIDES_HAVE_CREDS);
      SetDlgItemText(_hDlg, IDC_MSG, strMsg);
   }
   else
   {
      FormatWindowText(GetDlgItem(_hDlg, IDC_MSG), _pwzDomainName);
   }

   CQueryChoiceWCredsDlgBase::OnInitDialog(lParam);

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CPolicyHandle::Open
//
//  Synopsis:   Do an LsaOpenPolicy to get a policy handle.
//
//  Arguments:  [fModify] - defaults to TRUE. If TRUE, the open is asking
//              for trust creation/modification privilege, so admin privilege
//              is required of the caller in that case.
//
//-----------------------------------------------------------------------------
DWORD
CPolicyHandle::Open(BOOL fModify)
{
   TRACE(CPolicyHandle, Open);
   NTSTATUS Status = STATUS_SUCCESS;
   UNICODE_STRING Server;
   OBJECT_ATTRIBUTES ObjectAttributes;

   if (m_strUncDc.IsEmpty())
   {
      return ERROR_INVALID_PARAMETER;
   }

   RtlInitUnicodeString(&Server, m_strUncDc);
   // NOTICE-2002/02/18-ericb - SecurityPush: initializing a structure.
   RtlZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

   ACCESS_MASK mask = POLICY_VIEW_LOCAL_INFORMATION;

   if (fModify)
   {
      mask |= POLICY_CREATE_SECRET | POLICY_TRUST_ADMIN;
   }

   Status = LsaOpenPolicy(&Server,
                          &ObjectAttributes,
                          mask,
                          &m_hPolicy);

   if (!NT_SUCCESS(Status))
   {
      dspDebugOut((DEB_ITRACE, "CPolicyHandle::Open: LsaOpenPolicy failed with error 0x%x\n",
                   Status));
      return LsaNtStatusToWinError(Status);
   }

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:    CPolicyHandle::OpenWithPrompt
//
//  Synopsis:  Do an LsaOpenPolicy to get a policy handle. If the first
//             attempt returns access-denied and the credentials have not been
//             gathered yet, prompt for credentials.
//
//  Returns:   HRESULT_FROM_WIN32(ERROR_CANCELLED) if the user cancels the
//             prompt for creds, success or errors otherwise.
//
//  Note:      Always requests create/modify privileges.
//
//-----------------------------------------------------------------------------
DWORD
CPolicyHandle::OpenWithPrompt(CCreds & Creds, CWaitCursor & Wait,
                              PCWSTR pwzDomain, HWND hWnd)
{
   DWORD dwErr = OpenReqAdmin();

   if (ERROR_ACCESS_DENIED == dwErr)
   {
      if (Creds.IsSet())
      {
         dwErr = ERROR_SUCCESS;
      }
      else
      {
         Wait.SetOld();
         dwErr = Creds.PromptForCreds(pwzDomain, hWnd);
         Wait.SetWait();
      }

      if (ERROR_SUCCESS == dwErr)
      {
         dwErr = Creds.Impersonate();

         if (ERROR_SUCCESS == dwErr)
         {
            dwErr = OpenReqAdmin();
         }

         Creds.Revert();
      }
   }

   return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CPolicyHandle::OpenWithAnonymous
//
//  Synopsis:  Do an LsaOpenPolicy to get a policy handle. If the first
//             attempt returns access-denied, use the null token.
//
//-----------------------------------------------------------------------------
DWORD
CPolicyHandle::OpenWithAnonymous(CCredMgr & Creds)
{
   DWORD dwErr = Open(FALSE);

   if (ERROR_ACCESS_DENIED == dwErr)
   {
      dwErr = Creds._LocalCreds.ImpersonateAnonymous();

      if (ERROR_SUCCESS == dwErr)
      {
         dwErr = Open(FALSE);

         Creds.Revert();
      }
   }

   return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::GetInfoForRemoteDomain
//
//  Synopsis:   Get the trust information for the remote domain.
//
//  Note:       Errors are not reported in this routine; they are passed back
//              to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
HRESULT
CTrustPropPageBase::GetInfoForRemoteDomain(PCWSTR pwzDomainName,
                                           PTD_DOM_INFO pInfo,
                                           CCredMgr & Creds,
                                           HWND hWnd,
                                           DWORD dwFlags)
{
    TRACE(CTrustPropPageBase, GetInfoForRemoteDomain);
    NTSTATUS Status = STATUS_SUCCESS;
    HRESULT hr = S_OK;
    DWORD dwErr = NO_ERROR;
    UNICODE_STRING Server = {0};
    OBJECT_ATTRIBUTES ObjectAttributes = {0};
    PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
    ULONG ulDcFlags = DS_WRITABLE_REQUIRED;

    dspAssert(pwzDomainName && pInfo);

    if (dwFlags & DS_TRUST_INFO_GET_PDC)
    {
        ulDcFlags = DS_PDC_REQUIRED;
    }

    ACCESS_MASK mask = POLICY_VIEW_LOCAL_INFORMATION;

    if (DS_TRUST_INFO_ALL_ACCESS & dwFlags)
    {
        // POLICY_CREATE_SECRET causes LsaOpenPolicy to do an access check for
        // admin privilege.
        //
        mask |= POLICY_CREATE_SECRET;
    }

    // First, get a DC name.
    //
    dwErr = DsGetDcNameW(NULL, (LPCWSTR)pwzDomainName, NULL, NULL, 
                         ulDcFlags, &pDCInfo);

    if (dwErr != ERROR_SUCCESS)
    {
        dspDebugOut((DEB_ERROR, "DsGetDcName failed with error 0x%08x\n",
                     dwErr));
        return HRESULT_FROM_WIN32(dwErr);
    }

    if (!AllocWStr(pDCInfo->DomainControllerName, &pInfo->pwzUncDcName))
    {
        hr = E_OUTOFMEMORY;
        goto ExitCleanup;
    }

    // NOTICE-2002/02/18-ericb - SecurityPush: initializing a structure.
    RtlZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

    RtlInitUnicodeString(&Server, pDCInfo->DomainControllerName);

    //
    // Get an LSA policy handle (the RPC binding handle).
    //
    Status = LsaOpenPolicy(&Server,
                           &ObjectAttributes,
                           mask,
                           &pInfo->Policy);

    if (STATUS_ACCESS_DENIED == Status)
    {
       if (!(DS_TRUST_INFO_ALL_ACCESS & dwFlags))
       {
          // Try the null token for access.
          //
          dwErr = Creds._LocalCreds.ImpersonateAnonymous();

          CHECK_WIN32_REPORT(dwErr, hWnd, return HRESULT_FROM_WIN32(dwErr));

          Status = LsaOpenPolicy(&Server,
                                 &ObjectAttributes,
                                 mask,
                                 &pInfo->Policy);

          Creds.Revert();
       }

       if (STATUS_ACCESS_DENIED == Status)
       {
          // Must have restrict anonymous set or requesting admin access.
          //
          if (!Creds._RemoteCreds.IsSet())
          {
             // Try prompting for creds.
             //
             dwErr = Creds._RemoteCreds.PromptForCreds(pwzDomainName, hWnd);

             if (ERROR_CANCELLED == dwErr)
             {
                return ERROR_CANCELLED;
             }

             CHECK_WIN32_REPORT(dwErr, hWnd, return HRESULT_FROM_WIN32(dwErr));
          }

          Creds.ImpersonateRemote();

          Status = LsaOpenPolicy(&Server,
                                 &ObjectAttributes,
                                 mask,
                                 &pInfo->Policy);
          Creds.Revert();
       }
    }

    if (!NT_SUCCESS(Status))
    {
        // DsGetDcName can continue to return a DC name while the property
        // page is open even if the DC has become unavailable.
        // LsaOpenPolicy will then return the error RPC_S_INVALID_NET_ADDR.
        //
        dspDebugOut((DEB_ITRACE,
                     "GetInfoForRemoteDomain: LsaOpenPolicy failed, error 0x%08x\n",
                     Status));
        hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
        goto ExitCleanup;
    }

    //
    // Now read the domain info.
    //
    Status = LsaQueryInformationPolicy(pInfo->Policy,
                                       PolicyDnsDomainInformation,
                                       (PVOID *)&(pInfo->pDnsDomainInfo));
    
    if (Status == RPC_S_PROCNUM_OUT_OF_RANGE ||
        Status == RPC_NT_PROCNUM_OUT_OF_RANGE ||
        pInfo->ulTrustType == TRUST_TYPE_DOWNLEVEL)
    {
      // This is a downlevel DC.
      //
      Status = LsaQueryInformationPolicy(pInfo->Policy,
                                         PolicyPrimaryDomainInformation,
                                         (PVOID *)&(pInfo->pDownlevelDomainInfo));
      pInfo->ulTrustType = TRUST_TYPE_DOWNLEVEL;
      dspDebugOut((DEB_ITRACE, "Downlevel domain: %ws\n", pwzDomainName));
    }
    else
    {
      pInfo->ulTrustType = TRUST_TYPE_UPLEVEL;
    }
      
    if (!NT_SUCCESS(Status))
    {
      dspDebugOut((DEB_ERROR,
                   "GetInfoForRemoteDomain: LsaQueryInformationPolicy failed, error 0x%08x\n",
                   Status));
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
    }

ExitCleanup:

    NetApiBufferFree(pDCInfo);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveTrustDirection
//
//-----------------------------------------------------------------------------
NTSTATUS
RemoveTrustDirection(LSA_HANDLE hPolicy, PLSA_UNICODE_STRING pName,
                     PLSA_UNICODE_STRING pFlatName, PSID pSid, ULONG ulTrustType,
                     TRUST_OP Op)
{
    BOOL fSidUsed = false;
    TRACE_FUNCTION(RemoveTrustDirection);
    if (!pName || !pFlatName)
    {
       dspAssert(false);
       return STATUS_INVALID_PARAMETER;
    }
    NTSTATUS Status = STATUS_SUCCESS;
    PTRUSTED_DOMAIN_FULL_INFORMATION pFullInfo = NULL;

    Status = LsaQueryTrustedDomainInfoByName(hPolicy,
                                             pName,
                                             TrustedDomainFullInformation,
                                             (PVOID *)&pFullInfo);

    if (STATUS_OBJECT_NAME_NOT_FOUND == Status &&
        TRUST_TYPE_UPLEVEL == ulTrustType)
    {
        // Now try by flat name; can get here if a downlevel domain
        // is upgraded to NT5. The name used above was the DNS name
        // but the TDO would be named after the flat name.
        //
        dspDebugOut((DEB_ITRACE, "LsaQueryTDIBN: DNS name failed, trying flat name\n"));

        pName = pFlatName;

        Status = LsaQueryTrustedDomainInfoByName(hPolicy,
                                                 pFlatName,
                                                 TrustedDomainFullInformation,
                                                 (PVOID *)&pFullInfo);
    }

    if (STATUS_OBJECT_NAME_NOT_FOUND == Status &&
       pSid )
   {
       // Try the domin sid in case domain rename has been performed
      dspDebugOut((DEB_ITRACE, "LsaQueryTDI: flat name failed, trying domain sid\n"));

      Status = LsaQueryTrustedDomainInfo(hPolicy,
                                    pSid,
                                    TrustedDomainFullInformation,
                                    (PVOID *)&pFullInfo);    
      if (Status == STATUS_NO_SUCH_DOMAIN)
          Status = STATUS_OBJECT_NAME_NOT_FOUND;

      fSidUsed = true;
   }
    CHECK_LSA_STATUS(Status, return Status);

    switch (Op)
    {
    case REMOVE_TRUST_INBOUND:
        if (pFullInfo->AuthInformation.IncomingAuthInfos > 0)
        {
            pFullInfo->AuthInformation.IncomingAuthInfos = 0;
            pFullInfo->AuthInformation.IncomingAuthenticationInformation = NULL;
            pFullInfo->AuthInformation.IncomingPreviousAuthenticationInformation = NULL;
        }
        pFullInfo->Information.TrustDirection = TRUST_DIRECTION_OUTBOUND;
        break;

    case REMOVE_TRUST_OUTBOUND:
        if (pFullInfo->AuthInformation.OutgoingAuthInfos > 0)
        {
            pFullInfo->AuthInformation.OutgoingAuthInfos = 0;
            pFullInfo->AuthInformation.OutgoingAuthenticationInformation = NULL;
            pFullInfo->AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;
        }
        pFullInfo->Information.TrustDirection = TRUST_DIRECTION_INBOUND;
        pFullInfo->Information.TrustAttributes &= ~TRUST_ATTRIBUTE_QUARANTINED_DOMAIN;
        break;
    }

    if ( fSidUsed )
    {
        Status = LsaSetTrustedDomainInfoByName (hPolicy,
                                           &(pFullInfo->Information.Name),
                                           TrustedDomainFullInformation,
                                           pFullInfo);
    }
    else
    {
        Status = LsaSetTrustedDomainInfoByName(hPolicy,
                                           pName,
                                           TrustedDomainFullInformation,
                                           pFullInfo);
    }
    LsaFreeMemory(pFullInfo);

    CHECK_LSA_STATUS(Status, ;);

    return Status;
}

//+----------------------------------------------------------------------------
//
//  Function:   DeleteTrust
//
//  Synopsis:   Use the LSA API to delete the trust relationship/object.
//
//-----------------------------------------------------------------------------
NTSTATUS
DeleteTrust(LSA_HANDLE hPolicy, PLSA_UNICODE_STRING pName,
            PLSA_UNICODE_STRING pFlatName, PSID pSid, ULONG ulTrustType)
{
   if (!pName || !pFlatName)
   {
      dspAssert(false);
      return STATUS_INVALID_PARAMETER;
   }
   NTSTATUS Status = STATUS_SUCCESS;
   LSA_HANDLE hTrustedDomain = NULL;

   Status = LsaOpenTrustedDomainByName(hPolicy,
                                       pName,
                                       DELETE,
                                       &hTrustedDomain);

   if (STATUS_OBJECT_NAME_NOT_FOUND == Status &&
       TRUST_TYPE_UPLEVEL == ulTrustType)
   {
      // Now try by flat name; can get here if a downlevel domain
      // is upgraded to NT5. The name used above was the DNS name
      // but the TDO would be named after the flat name.
      //
      dspDebugOut((DEB_ITRACE, "LsaOpenTDBN: DNS name failed, trying flat name\n"));

      Status = LsaOpenTrustedDomainByName(hPolicy,
                                          pFlatName,
                                          DELETE,
                                          &hTrustedDomain);
   }

   if (STATUS_OBJECT_NAME_NOT_FOUND == Status &&
       pSid )
   {
       // Try the domin sid in case domain rename has been performed
      dspDebugOut((DEB_ITRACE, "LsaOpenTD: flat name failed, trying domain sid\n"));

      Status = LsaOpenTrustedDomain(hPolicy,
                                    pSid,
                                    DELETE,
                                    &hTrustedDomain);

      if (Status == STATUS_NO_SUCH_DOMAIN)
          Status = STATUS_OBJECT_NAME_NOT_FOUND;
   }

   if (NT_SUCCESS(Status))
   {
      dspAssert(hTrustedDomain);

      Status = LsaDelete(hTrustedDomain);

#if DBG == 1
      if (!NT_SUCCESS(Status))
      {
         dspDebugOut((DEB_ERROR, "LsaDelete failed with error 0x%08x\n",
                      Status));
      }
#endif

      // NTRAID#NTBUG9-737916-2002/12/17-shasan We dont need to close hTrustedDomain
   }

   return Status;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsDomainTrustsPage::QueryDeleteTrust
//
//  Synopsis:   When all else fails, directly delete the trust object. This is
//              necessary when the other domain no longer exists.
//
//-----------------------------------------------------------------------------
HRESULT
CDsDomainTrustsPage::QueryDeleteTrust(PLSA_UNICODE_STRING pName, PSID pSid,
                                      CCreds & Creds)
{
   if (!pName)
   {
      dspAssert(false);
      return STATUS_INVALID_PARAMETER;
   }

   int iRet = 0;
   CStrW strTitle, strMsg, strFormat;

   // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::Loadstring notice
   if (!strTitle.LoadString(g_hInstance, IDS_MSG_TITLE))
   {
       REPORT_ERROR(GetLastError(), GetHWnd());
       return E_OUTOFMEMORY;
   }
   if (!strFormat.LoadString(g_hInstance, IDS_MSG_FORCE_REMOVE_CONFIRM))
   {
       REPORT_ERROR(GetLastError(), GetHWnd());
       return E_OUTOFMEMORY;
   }

   strMsg.Format(strFormat, pName->Buffer);

   iRet = MessageBox(GetHWnd(), strMsg, strTitle, MB_YESNO | MB_ICONWARNING);

   if (iRet != IDYES)
   {
       return S_FALSE;
   }

   Creds.Impersonate();

   NTSTATUS Status = DeleteTrust(GetLsaPolicy(), pName, pName, pSid, 0);

   Creds.Revert();

   if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
   {
      CStr strMessage, strFormat;

      // NOTICE-2002/02/12-ericb - SecurityPush: see above CStrW::Loadstring notice
      strFormat.LoadString(g_hInstance, IDS_TDO_NOT_FOUND);

      strMessage.Format(strFormat, pName->Buffer);

      ReportErrorWorker(m_hPage, (LPTSTR)(LPCTSTR)strMessage);

      return S_OK;
   }

   CHECK_LSA_STATUS_REPORT(Status, GetHWnd(), return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status)));

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   FreeDomainInfo
//
//  Synopsis:   Release the previously aquired resources.
//
//-----------------------------------------------------------------------------
VOID
FreeDomainInfo(PTD_DOM_INFO pInfo)
{
    TRACE_FUNCTION(FreeDomainInfo);
    if (pInfo->pDnsDomainInfo)
    {
        LsaFreeMemory(pInfo->pDnsDomainInfo);
        pInfo->pDnsDomainInfo = NULL;
    }
    if (pInfo->pDownlevelDomainInfo)
    {
        LsaFreeMemory(pInfo->pDownlevelDomainInfo);
        pInfo->pDownlevelDomainInfo = NULL;
    }
    if (pInfo->Policy)
    {
        LsaClose(pInfo->Policy);
        pInfo->Policy = NULL;
    }
    if (pInfo->pwzUncDcName)
    {
        delete pInfo->pwzUncDcName;
        pInfo->pwzUncDcName = NULL;
    }
    if (pInfo->pwzDomainName)
    {
        delete pInfo->pwzDomainName;
        pInfo->pwzDomainName = NULL;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::VerifyTrustOneDirection
//
//  Synopsis:   Netlogon is called to query/reset the secure channel and the
//              result of that is returned.
//
//  Arguments:  [pwzTrustingDcName] - the DC on which to run the netlogon query.
//              [pwzTrustingDomName] - the outbound domain, needed only if
//                                    DS_TRUST_VERIFY_PROMPT_FOR_CREDS is set.
//              [pwzTrustedDomName] - the trusted (inbound) domain.
//              [ppwzTrustedDcUsed] - if non-NULL, returns the name of the DC
//                                    to which the secure channel is connected.
//              [Creds] - credential object to do impersonation for authorization.
//              [Wait] - wait cursor object.
//              [strMsg] - the results go here.
//              [dwFlags] - bit flags, can be a combination of the following:
//                          DS_TRUST_VERIFY_PROMPT_FOR_CREDS, prompt for
//                          creds if the query returns access denied.
//                          DS_TRUST_VERIFY_NEW_TRUST, don't show error here
//                          or attempt a reset if the query fails.
//                          Defaults to zero (no flags set).
//
// Returns:     ERROR_SUCCESS or error code.
//
// Notes:       An SC query is first done to see what netlogon thinks is the
//              current state of the trust. If OK, the query returns the DC to
//              which the secure channel is made. This same DC is then used as
//              the target of the reset. Since the query is cached info, it
//              may be stale; hence the reset. The reset is targetted to the
//              same DC so that the trust topology is not perturbed.
//
//-----------------------------------------------------------------------------
DWORD
CTrustPropPageBase::VerifyTrustOneDirection(PCWSTR pwzTrustingDcName,
                                            PCWSTR pwzTrustingDomName,
                                            PCWSTR pwzTrustedDomName,
                                            PWSTR * ppwzTrustedDcUsed,
                                            CCreds & Creds,
                                            CWaitCursor & Wait,
                                            CStrW & strMsg,
                                            DWORD dwFlags)
{
    TRACE(CTrustPropPageBase, VerifyTrustOneDirection);
    NET_API_STATUS NetStatus = NO_ERROR, ResetStatus = NO_ERROR;
    PNETLOGON_INFO_2 NetlogonInfo2 = NULL;
    BOOL fRetry = FALSE;
    BOOL fPromptForCreds = dwFlags & DS_TRUST_VERIFY_PROMPT_FOR_CREDS;
    DWORD dwRet = NO_ERROR;
    PDS_DOMAIN_TRUSTS rgDomains = NULL;
    ULONG DomainCount = 0;
    PWSTR pwzTrustedDcUsed = NULL;

    if (!pwzTrustingDcName || !pwzTrustingDomName || !pwzTrustedDomName)
    {
       dspAssert(pwzTrustingDcName);
       dspAssert(pwzTrustingDomName);
       dspAssert(pwzTrustedDomName);
       return ERROR_INVALID_PARAMETER;
    }

    // DsEnumerateDomainTrusts will block if there is a NetLogon trust
    // update in progress. Call it to insure that our trust changes are
    // known by NetLogon before we do the query/reset.
    //
    dwRet = DsEnumerateDomainTrusts(const_cast<PWSTR>(pwzTrustingDcName),
                                    DS_DOMAIN_DIRECT_OUTBOUND | DS_DOMAIN_DIRECT_INBOUND,
                                    &rgDomains, &DomainCount);
    if (ERROR_SUCCESS == dwRet)
    {
        NetApiBufferFree(rgDomains);
    }
    else
    {
        dspDebugOut((DEB_ERROR,
                     "**** DsEnumerateDomainTrusts ERROR <%s @line %d> -> %d\n",
                     __FILE__, __LINE__, dwRet));
    }

    DWORD dwFcn = (dwFlags & DS_TRUST_VERIFY_NEW_TRUST) ?
                     NETLOGON_CONTROL_REDISCOVER : NETLOGON_CONTROL_TC_VERIFY;
    if (dwFlags & DS_TRUST_VERIFY_DOWNLEVEL)
    {
       dwFcn = NETLOGON_CONTROL_TC_QUERY;
    }
    bool fRetriedWithCreds = false;
    //
    // Unless this is a new trust or a downlevel trust, first try a verify to
    // see if netlogon thinks the trust is OK. If the verify succeeds, it will
    // return the name of the DC to which the SC is connected.
    //
    do {
        fRetry = FALSE;
        Wait.SetWait();

        NetStatus = I_NetLogonControl2(pwzTrustingDcName,
                                       dwFcn,
                                       2,
                                       (LPBYTE)&pwzTrustedDomName,
                                       (LPBYTE *)&NetlogonInfo2);

        if (NERR_Success == NetStatus)
        {
            if (NETLOGON_CONTROL_TC_VERIFY == dwFcn)
            {
               if (NETLOGON_VERIFY_STATUS_RETURNED & NetlogonInfo2->netlog2_flags)
               {
                  // The status of the verification is in the
                  // netlog2_pdc_connection_status field.
                  //
                  NetStatus = NetlogonInfo2->netlog2_pdc_connection_status;

                  dspDebugOut((DEB_ITRACE,
                              "NetLogon SC verify for %ws on DC %ws gives verify status %d to DC %ws\n\n",
                               pwzTrustedDomName, pwzTrustingDcName, NetStatus,
                               NetlogonInfo2->netlog2_trusted_dc_name));

                  if (ERROR_DOMAIN_TRUST_INCONSISTENT == NetStatus)
                  {
                     // The trust attribute types don't match; one side is
                     // forest but the other isn't.
                     //
                     NetApiBufferFree(NetlogonInfo2);
                     return NetStatus;
                  }
               }
               else
               {
                  NetStatus = NetlogonInfo2->netlog2_tc_connection_status;

                  dspDebugOut((DEB_ITRACE,
                              "NetLogon SC verify for %ws on pre-2474 DC %ws gives conection status %d to DC %ws\n\n",
                               pwzTrustedDomName, pwzTrustingDcName, NetStatus,
                               NetlogonInfo2->netlog2_trusted_dc_name));
               }
            }
            else
            {
               NetStatus = NetlogonInfo2->netlog2_tc_connection_status;

               dspDebugOut((DEB_ITRACE,
                            "NetLogon SC query/reset for %ws on DC %ws gives status %d to DC %ws\n\n",
                            pwzTrustedDomName, pwzTrustingDcName, NetStatus,
                            NetlogonInfo2->netlog2_trusted_dc_name));
            }

            if (NERR_Success == NetStatus &&
                !(dwFlags & (DS_TRUST_VERIFY_DOWNLEVEL | DS_TRUST_VERIFY_NEW_TRUST)))
            {
                // Save the name of the DC used for the secure channel. Skip this
                // if trust is to a downlevel domain since NT4 NetLogon does not
                // support the domain\dc form of target name for secure channel
                // operations. Skip if a new trust because the reset has already
                // been done.
                //
                if (!AllocWStr(NetlogonInfo2->netlog2_trusted_dc_name, &pwzTrustedDcUsed))
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            NetApiBufferFree(NetlogonInfo2);
        }
        else
        {
            dspDebugOut((DEB_ITRACE,
                         (NETLOGON_CONTROL_REDISCOVER == dwFcn) ?
                         "NetLogon SC Reset for %ws on DC %ws returns error 0x%x\n\n" :
                         "NetLogon SC Verify for %ws on DC %ws returns error 0x%x\n\n",
                         pwzTrustedDomName, pwzTrustingDcName, NetStatus));

            if (fRetriedWithCreds)
            {
                fRetry = FALSE;
            }
            else
            {
                if (ERROR_ACCESS_DENIED == NetStatus)
                {
                    if (!Creds.IsSet() && fPromptForCreds)
                    {
                        if (Creds.PromptForCreds(pwzTrustingDomName, m_pPage->GetHWnd()))
                        {
                            return ERROR_CANCELLED;
                        }
                    }

                    dwRet = Creds.Impersonate();

                    if (ERROR_SUCCESS == dwRet)
                    {
                        fRetry = TRUE;
                        fRetriedWithCreds = true;
                    }
                    else
                    {
                        return dwRet;
                    }
                    fPromptForCreds = FALSE; // Only prompt once for creds.
                }
                if (ERROR_NOT_SUPPORTED == NetStatus)
                {
                    // Must be remoted to a Win2k DC that doesn't support SC verify.
                    //
                    dwFcn = NETLOGON_CONTROL_TC_QUERY;
                    fRetry = TRUE;
                }
            }
        }
    } while (fRetry);

    if (dwFlags & DS_TRUST_VERIFY_NEW_TRUST)
    {
        // If this is a newly repaired trust, return back to ResetTrust so
        // that it can display the appropriate message.
        //
        Creds.Revert();
        return NetStatus;
    }

    if (NERR_Success != NetStatus && ERROR_NO_LOGON_SERVERS != NetStatus)
    {
        // The SC verify on DC of domain x to domain y failed with error z,
        // an SC reset will now be attempted.
        // Ignore ERROR_NO_LOGON_SERVERS because that is often due to the SC
        // just not being set up yet.
        //
        PCWSTR rgwzArgs[] = {pwzTrustingDcName, pwzTrustingDomName, pwzTrustedDomName};
        PWSTR pwzMsg = NULL;

        DspFormatMessage(IDS_SC_QUERY_FAILED,
                         NetStatus, (PVOID *)rgwzArgs, 3,
                         FALSE, &pwzMsg);

        if (pwzMsg)
        {
            strMsg += pwzMsg;
            strMsg += g_wzCRLF;

            LocalFree(pwzMsg);
        }
    }

    PWSTR pwzTrusted = NULL;

    if (pwzTrustedDcUsed)
    {
        // Form the name "domain\DC" to pass to I_NetLogonControl2.
        //
        // NOTICE-2002/02/18-ericb - SecurityPush: the input strings are
        // validated at the begining of this function, so the following string
        // manupulations are safe.
        pwzTrusted = new WCHAR[wcslen(pwzTrustedDomName) +
                                wcslen(pwzTrustedDcUsed) + 3];

        CHECK_NULL(pwzTrusted, return ERROR_NOT_ENOUGH_MEMORY);

        DWORD dwSkip = 0;
        if (L'\\' == pwzTrustedDcUsed[1])
        {
            // skip leading forward slashes if found.
            //
            dwSkip = 2;
        }

        wcscpy(pwzTrusted, pwzTrustedDomName);
        wcscat(pwzTrusted, L"\\");
        wcscat(pwzTrusted, pwzTrustedDcUsed + dwSkip);
    }
    else
    {
        pwzTrusted = const_cast<PWSTR>(pwzTrustedDomName);
    }

    do {
        fRetry = FALSE;
        Wait.SetWait();

        ResetStatus = I_NetLogonControl2(pwzTrustingDcName,
                                         NETLOGON_CONTROL_REDISCOVER,
                                         2,
                                         (LPBYTE)&pwzTrusted,
                                         (LPBYTE *)&NetlogonInfo2);

        if (NERR_Success == ResetStatus)
        {
            ResetStatus = NetlogonInfo2->netlog2_tc_connection_status;

            dspDebugOut((DEB_ITRACE,
                         "NetLogon SC Reset for %ws on DC %ws gives status %d\n\n",
                         pwzTrusted, pwzTrustingDcName, ResetStatus));

            NetApiBufferFree(NetlogonInfo2);
        }
        else
        {
            dspDebugOut((DEB_ITRACE,
                         "NetLogon SC reset for %ws on DC %ws returns error 0x%x\n\n",
                         pwzTrusted, pwzTrustingDcName, ResetStatus));

            if ((ERROR_ACCESS_DENIED == ResetStatus) &&
                (NERR_Success == NetStatus))
            {
                if (!Creds.IsSet() && fPromptForCreds)
                {
                   // If the SC verify was successful but the reset gives access
                   // denied, then ask for creds if not already connected.
                   //
                   if (Creds.PromptForCreds(pwzTrustingDomName,
                                            m_pPage->GetHWnd()) != IDYES)
                   {
                      return ERROR_CANCELLED;
                   }
                }

                dwRet = Creds.Impersonate();

                if (ERROR_SUCCESS == dwRet)
                {
                    fRetry = TRUE;
                }
                else
                {
                    if (pwzTrustedDcUsed)
                    {
                        delete [] pwzTrusted;
                    }
                    return dwRet;
                }
                fPromptForCreds = FALSE; // Only prompt once for creds.
            }
        }
    
        NetStatus = ResetStatus;

    } while (fRetry);

    Creds.Revert();

    if (NERR_Success != NetStatus)
    {
        // The SC reset on DC of domain x to domain y failed with error z,
        //
        PCWSTR rgwzArgs[] = {pwzTrustingDcName, pwzTrustingDomName, pwzTrustedDomName};
        PWSTR pwzMsg = NULL;

        DspFormatMessage(IDS_SC_RESET_FAILED, NetStatus, (PVOID *)rgwzArgs, 3,
                         FALSE, &pwzMsg);

        if (pwzMsg)
        {
            strMsg += pwzMsg;
            strMsg += g_wzCRLF;

            LocalFree(pwzMsg);
        }
    }

    if (pwzTrustedDcUsed)
    {
        delete [] pwzTrusted;
    }
    if (ppwzTrustedDcUsed)
    {
        *ppwzTrustedDcUsed = pwzTrustedDcUsed;
    }
    else
    {
        DO_DEL(pwzTrustedDcUsed);
    }
    return NetStatus;
}

//+----------------------------------------------------------------------------
//
//  Method:     CTrustPropPageBase::IsTrustListed
//
//  Synopsis:   Check to see if the trust is listed in either list. Search
//              using both names.
//
//  Returns:    a pointer to the trust list item, or null if not found.
//
//-----------------------------------------------------------------------------
CEnumDomainTrustItem *
CTrustPropPageBase::IsTrustListed(PCWSTR pwzDnsName, PCWSTR pwzFlatName)
{
   TRACE(CTrustPropPageBase, IsTrustListed);
   if (!pwzDnsName && !pwzFlatName)
   {
      // One or the other can be null, but not both.
      dspAssert(FALSE);
      return NULL;
   }
   for (ULONG i = 0; i < m_cTrusts; i++)
   {
      if (pwzDnsName && m_rgTrustList[i].strDNSname == pwzDnsName)
      {
         return &m_rgTrustList[i];
      }
      if (pwzFlatName && m_rgTrustList[i].strFlatName == pwzFlatName)
      {
         return &m_rgTrustList[i];
      }
   }
   return NULL;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\trustdomaininfo.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Domains and Trust
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       TrustDomainInfo.cxx
//
//  Contents:   Trust domain info and management.
//
//  History:    18-May-01 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "dlgbase.h"
#include "trust.h"
#include "trustwiz.h"
#include "chklist.h"
#include <lmerr.h>
#include "BehaviorVersion.h"

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Class:  CDomainInfo
//
//-----------------------------------------------------------------------------
CDomainInfo::CDomainInfo(void) :
   _fIsForestRoot(false),
   _fNotFound(true),
   _fUplevel(true),
   _hPolicy(NULL),
   _pSid(NULL)
{
}

CDomainInfo::~CDomainInfo(void)
{
   if (_hPolicy)
   {
      LsaClose(_hPolicy);
      _hPolicy = NULL;
   }
   if (_pSid)
   {
      delete [] _pSid;
   }
}

void
CDomainInfo::Clear(void)
{
   _strDomainFlatName.Empty();
   _strDomainDnsName.Empty();
   _strUncDC.Empty();
   _fNotFound = true;
   _fIsForestRoot = false;
   _fUplevel = true;
   CloseLsaPolicy();
   if (_pSid)
   {
      delete [] _pSid;
      _pSid = NULL;
   }
}

void
CDomainInfo::CloseLsaPolicy(void)
{
   if (_hPolicy)
   {
      LsaClose(_hPolicy);
      _hPolicy = NULL;
   }
}

//+----------------------------------------------------------------------------
//
//  Member:    CDomainInfo::SetSid
//
//-----------------------------------------------------------------------------
bool
CDomainInfo::SetSid(PSID pSid)
{
   if (_pSid)
   {
      delete [] _pSid;
      _pSid = NULL;
   }
   int cb = GetLengthSid(pSid);
   dspAssert(cb);
   _pSid = new BYTE[cb];
   CHECK_NULL(_pSid, return false);
   // NOTICE-2002/02/18-ericb - SecurityPush: GetLengthSid returns cb, the
   // new SID buffer is allocated to cb bytes, and the memcpy is copying cb bytes.
   memcpy(_pSid, pSid, cb);
   return true;
}

//+----------------------------------------------------------------------------
//
// Method:     CDomainInfo::DiscoverDC
//
// Synopsis:   Get a DC for the domain.
//
// Note:       Errors are not reported in this routine; they are passed back
//             to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainInfo::DiscoverDC(PCWSTR pwzDomainName, ULONG ulDcFlags)
{
   TRACE(CDomainInfo, DiscoverDC);
   PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
   DWORD dwErr;

   if (!ulDcFlags)
   {
      ulDcFlags = DS_WRITABLE_REQUIRED;
   }

   if (!pwzDomainName)
   {
      dspAssert(FALSE && "pwzDomainName is empty!");
      return E_FAIL;
   }

   dwErr = DsGetDcNameW(NULL, pwzDomainName, NULL, NULL, ulDcFlags, &pDCInfo);

   if (dwErr != ERROR_SUCCESS)
   {
      dspDebugOut((DEB_ERROR, "DsGetDcName failed with error 0x%08x\n", dwErr));

      if ((ERROR_NO_SUCH_DOMAIN == dwErr) ||
          (ERROR_NETWORK_UNREACHABLE == dwErr) ||
          (ERROR_BAD_NETPATH == dwErr))
      {
         _fNotFound = true;
         return S_OK;
      }
      else
      {
         return HRESULT_FROM_WIN32(dwErr);
      }
   }

   _strUncDC = pDCInfo->DomainControllerName;

   dspDebugOut((DEB_ITRACE, "DC: %ws\n", (LPCWSTR)_strUncDC));

   if (_strUncDC.IsEmpty())
   {
      NetApiBufferFree(pDCInfo);
      return E_OUTOFMEMORY;
   }

   _fNotFound = false;

   NetApiBufferFree(pDCInfo);

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:    CDomainInfo::InitAndReadDomNames
//
//  Synopsis:  Read the domain naming information. The DC name must have been
//             set first.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainInfo::InitAndReadDomNames(void)
{
   if (_strUncDC.IsEmpty())
   {
      dspAssert(FALSE);
      return E_INVALIDARG;
   }
   CCreds Creds;

   DWORD dwErr = OpenLsaPolicy(Creds); // Open without modify privilege.

   CHECK_WIN32(dwErr, return HRESULT_FROM_WIN32(dwErr));

   HRESULT hr = ReadDomainInfo();

   CloseLsaPolicy();

   _fNotFound = false;

   return hr;
}

//+----------------------------------------------------------------------------
//
// Method:     CDomainInfo::OpenLsaPolicy
//
// Synopsis:   Get an LSA Policy handle for the domain.
//
// Note:       Errors are not reported in this routine; they are passed back
//             to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
DWORD
CDomainInfo::OpenLsaPolicy(CCreds & Creds, ACCESS_MASK AccessDesired)
{
   TRACE(CDomainInfo, OpenLsaPolicy);
   DWORD dwErr;
   NTSTATUS Status = STATUS_SUCCESS;
   UNICODE_STRING Server;
   OBJECT_ATTRIBUTES ObjectAttributes;

   if (_strUncDC.IsEmpty())
   {
      dspAssert(FALSE && "DC not set!");
      return ERROR_INVALID_PARAMETER;
   }

   if (_hPolicy)
   {
      LsaClose(_hPolicy);
      _hPolicy = NULL;
   }

   // NOTICE-2002/02/18-ericb - SecurityPush: zeroing a structure.
   RtlZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

   RtlInitUnicodeString(&Server, _strUncDC);

   Status = LsaOpenPolicy(&Server,
                          &ObjectAttributes,
                          AccessDesired,
                          &_hPolicy);

   if (STATUS_ACCESS_DENIED == Status &&
       POLICY_VIEW_LOCAL_INFORMATION == AccessDesired)
   {
      // Not asking for all access, so use an anonymous token and try again.
      //
      dwErr = Creds.ImpersonateAnonymous();
                                
      if (dwErr != ERROR_SUCCESS)
      {
         dspDebugOut((DEB_ERROR,
                      "CDomainInfo::OpenLsaPolicy: unable to impersonate anonymous, error %d\n",
                      dwErr));
         return dwErr;
      }

      Status = LsaOpenPolicy(&Server,
                             &ObjectAttributes,
                             AccessDesired,
                             &_hPolicy);
   }

   if (!NT_SUCCESS(Status))
   {
      dspDebugOut((DEB_ERROR,
                   "CDomainInfo::OpenLsaPolicy failed, error 0x%08x\n",
                   Status));
      return LsaNtStatusToWinError(Status);
   }

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
// Method:     CDomainInfo::OpenLsaPolicyWithPrompt
//
// Synopsis:   Get a write-access LSA Policy handle for the domain.
//
// Note:       Errors are not reported in this routine; they are passed back
//             to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
DWORD
CDomainInfo::OpenLsaPolicyWithPrompt(CCreds & Creds, HWND hWnd)
{
   TRACE(CDomainInfo,OpenLsaPolicyWithPrompt);

   DWORD dwErr = OpenLsaPolicy(Creds);

   if (ERROR_ACCESS_DENIED == dwErr)
   {
      if (Creds.IsSet())
      {
         dwErr = ERROR_SUCCESS;
      }
      else
      {
         PCWSTR pwzDomain = (!_strDomainDnsName.IsEmpty()) ?
                              _strDomainDnsName : _strDomainFlatName;

         dwErr = Creds.PromptForCreds(pwzDomain, hWnd);
      }

      if (ERROR_SUCCESS == dwErr)
      {
         dwErr = Creds.Impersonate();

         if (ERROR_SUCCESS == dwErr)
         {
            dwErr = OpenLsaPolicy(Creds);
         }
      }
   }

   return dwErr;
}

//+----------------------------------------------------------------------------
//
// Method:     CDomainInfo::ReadDomainInfo
//
// Synopsis:   Get the domain naming information for the domain.
//
// Note:       Errors are not reported in this routine; they are passed back
//             to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainInfo::ReadDomainInfo(void)
{
   TRACE(CDomainInfo, ReadDomainInfo);
   NTSTATUS Status = STATUS_SUCCESS;
   PPOLICY_DNS_DOMAIN_INFO pDnsDomainInfo = NULL;

   if (!_hPolicy)
   {
      dspAssert(FALSE && "_hPolicy not set!");
      return E_FAIL;
   }

   Status = LsaQueryInformationPolicy(_hPolicy,
                                      PolicyDnsDomainInformation,
                                      (PVOID *)&pDnsDomainInfo);
   
   if (Status == RPC_S_PROCNUM_OUT_OF_RANGE ||
       Status == RPC_NT_PROCNUM_OUT_OF_RANGE)
   {
      // This is a downlevel DC.
      //
      PPOLICY_PRIMARY_DOMAIN_INFO pDownlevelDomainInfo;

      Status = LsaQueryInformationPolicy(_hPolicy,
                                         PolicyPrimaryDomainInformation,
                                         (PVOID *)&pDownlevelDomainInfo);
      if (!NT_SUCCESS(Status))
      {
         dspDebugOut((DEB_ERROR,
                      "CDomainInfo::ReadDomainInfo: LsaQueryInformationPolicy for downlevel domain failed, error 0x%08x\n",
                      Status));
         return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
      }

      dspAssert(pDownlevelDomainInfo);

      _fUplevel = false; // TRUST_TYPE_DOWNLEVEL;

      // NOTICE-2002/03/07-ericb - SecurityPush: check for null pointers.
      // CStrW's UNICODE_STRING assignment operator will handle null pointers
      // correctly, but it is a data error if they are encountered here.
      if (!pDownlevelDomainInfo->Name.Buffer)
      {
         dspAssert(false);
         return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_SECURITY, ERROR_INVALID_DATA);
      }
      // NOTICE-2002/03/07-ericb - SecurityPush: CStrW has an assigment operator
      // for UNICODE_STRINGS that handles them correctly.
      _strDomainFlatName = _strDomainDnsName = pDownlevelDomainInfo->Name;
      if (!pDownlevelDomainInfo->Sid || !IsValidSid(pDownlevelDomainInfo->Sid))
      {
         dspAssert(false);
         return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_SECURITY, ERROR_INVALID_DATA);
      }
      SetSid(pDownlevelDomainInfo->Sid);
      dspDebugOut((DEB_ITRACE, "Downlevel domain: %ws\n", _strDomainFlatName));
   }
   else
   {
      // TRUST_TYPE_UPLEVEL
      // NOTICE-2002/03/07-ericb - SecurityPush: check for null pointers
      if (!pDnsDomainInfo || !pDnsDomainInfo->DnsDomainName.Buffer ||
          !pDnsDomainInfo->Name.Buffer || !pDnsDomainInfo->DnsForestName.Buffer)
      {
         dspAssert(pDnsDomainInfo);
         dspAssert(pDnsDomainInfo->DnsDomainName.Buffer);
         dspAssert(pDnsDomainInfo->Name.Buffer);
         dspAssert(pDnsDomainInfo->DnsForestName.Buffer);
         return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_SECURITY, ERROR_INVALID_DATA);
      }
      // NOTICE-2002/03/07-ericb - SecurityPush: CStrW has an assigment operator
      // for UNICODE_STRINGS that handles them correctly.
      _strDomainDnsName = pDnsDomainInfo->DnsDomainName;
      _strDomainFlatName = pDnsDomainInfo->Name;
      if (!pDnsDomainInfo->Sid || !IsValidSid(pDnsDomainInfo->Sid))
      {
         dspAssert(false);
         return MAKE_HRESULT(SEVERITY_ERROR, FACILITY_SECURITY, ERROR_INVALID_DATA);
      }
      SetSid(pDnsDomainInfo->Sid);
      dspDebugOut((DEB_ITRACE, "DNS name: %ws, flat name: %ws\n", (LPCWSTR)_strDomainDnsName, (LPCWSTR)_strDomainFlatName));
      _strForestName = pDnsDomainInfo->DnsForestName;
      _fIsForestRoot = _wcsicmp(_strDomainDnsName, _strForestName) == 0;
   }

   if (!NT_SUCCESS(Status))
   {
      dspDebugOut((DEB_ERROR,
                   "CDomainInfo::ReadDomainInfo: LsaQueryInformationPolicy failed, error 0x%08x\n",
                   Status));
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
   }

   return S_OK;
}

//+----------------------------------------------------------------------------
//
// Method:     CDomainInfo::GetDomainVersion
//
// Synopsis:   Read the behavior version for the domain.
//
//-----------------------------------------------------------------------------
HRESULT
CDomainInfo::GetDomainVersion(HWND hWnd, UINT * pulVer)
{
   TRACE(CDomainInfo, GetDomainVersion);
   if (!pulVer)
   {
      dspAssert(false);
      return E_INVALIDARG;
   }
   if (_strUncDC.IsEmpty() || _strDomainDnsName.IsEmpty())
   {
      dspAssert(false);
      return E_INVALIDARG;
   }
   HRESULT hr = S_OK;

   CDomainVersion DomainVer(L"", _strDomainDnsName);

   // Pass in the non-UNC DC name
   //
   dspAssert(_strUncDC.GetLength() > 3);

   hr = DomainVer.Init(_strUncDC.GetBuffer(0) + 2, hWnd);

   CHECK_HRESULT(hr, return hr);

   *pulVer = DomainVer.GetCurVer();

   return S_OK;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CRemoteDomain
//
//  Purpose:   Obtains information about a trust partner domain.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CRemoteDomain::CRemoteDomain() :
   _fUpdatedFromNT4(false),
   _fExists(false),
   _ulTrustType(0),
   _ulTrustDirection(0),
   _ulTrustAttrs(0),
   _fSetOtherOrgBit(false),
   _fQuarantineSet (false)
{
}

CRemoteDomain::CRemoteDomain(PCWSTR pwzDomainName) :
   _strUserEnteredName(pwzDomainName),
   _fUpdatedFromNT4(false),
   _fExists(false),
   _ulTrustType(0),
   _ulTrustDirection(0),
   _ulTrustAttrs(0),
   _fSetOtherOrgBit(false),
   _fQuarantineSet (false)
{
}

//+----------------------------------------------------------------------------
//
// Method:     CRemoteDomain::TrustExistCheck
//
// Synopsis:   See if the remote domain has a TDO for this trust. If so, read
//             its properties.
//
// Note:       Errors are not reported in this routine; they are passed back
//             to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
DWORD
CRemoteDomain::TrustExistCheck(bool fOneWayOutBoundForest,
                               CDsDomainTrustsPage * pTrustPage,
                               CCredMgr & CredMgr)
{
   DWORD dwErr = NO_ERROR;

   // Open a policy handle on the remote domain. If the trust there is to be
   // inbound-only cross-forest, don't request admin access.
   //
   dwErr = CredMgr.ImpersonateRemote();

   if (NO_ERROR != dwErr)
   {
      return dwErr;
   }

   ACCESS_MASK AccessDesired = POLICY_VIEW_LOCAL_INFORMATION | POLICY_TRUST_ADMIN;

   if (!fOneWayOutBoundForest)
   {
      // POLICY_CREATE_SECRET forces an admin access check.
      //
      AccessDesired |= POLICY_CREATE_SECRET;
   }

   dwErr = OpenLsaPolicy(CredMgr._RemoteCreds, AccessDesired);

   if (NO_ERROR != dwErr)
   {
      CredMgr.Revert();
      return dwErr;
   }

   PTRUSTED_DOMAIN_FULL_INFORMATION pFullInfo = NULL;
   NTSTATUS Status = STATUS_SUCCESS;

   Status = Query(pTrustPage, NULL, &pFullInfo);

   CredMgr.Revert();

   if (STATUS_SUCCESS != Status)
   {
      if (STATUS_OBJECT_NAME_NOT_FOUND != Status)
      {
         dspDebugOut((DEB_ITRACE, "CRemoteDomain::Query returned 0x%x\n", Status));
         return LsaNtStatusToWinError(Status);
      }
      // STATUS_OBJECT_NAME_NOT_FOUND is not an error, it means there is no TDO.
      //
      return NO_ERROR;
   }

   _fExists = true;

   _ulTrustType = pFullInfo->Information.TrustType;
   _ulTrustDirection = pFullInfo->Information.TrustDirection;
   _ulTrustAttrs = pFullInfo->Information.TrustAttributes;
   
   LsaFreeMemory(pFullInfo);

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CRemoteDomain::CreateDefaultFTInfo
//
//  Synopsis:  Create a default TDO with just the forest TLN and forest domain
//             entries for the case where the user has skipped the verification.
//
//-----------------------------------------------------------------------------
bool
CRemoteDomain::CreateDefaultFTInfo(PCWSTR pwzForestRoot, PCWSTR pwzNBName,
                                   PSID pSid)
{
   return _FTInfo.CreateDefault(pwzForestRoot, pwzNBName, pSid);
}

//+----------------------------------------------------------------------------
//
//  Method:    CRemoteDomain::Query
//
//  Synopsis:  Read the TDO.
//
//-----------------------------------------------------------------------------
NTSTATUS
CRemoteDomain::Query(CDsDomainTrustsPage * pTrustPage,
                     PLSA_UNICODE_STRING pName, // optional, can be NULL
                     PTRUSTED_DOMAIN_FULL_INFORMATION * ppFullInfo)
{
   NTSTATUS Status = STATUS_SUCCESS;
   LSA_UNICODE_STRING Name = {0};
   if (!_hPolicy)
   {
      dspAssert(false);
      return STATUS_INVALID_PARAMETER;
   }

   if (!pName)
   {
      pName = &Name;
   }

   if (_strTrustPartnerName.IsEmpty())
   {
      _strTrustPartnerName = _fUpdatedFromNT4 ? pTrustPage->GetDomainFlatName() :
                                                pTrustPage->GetDnsDomainName();
   }

   RtlInitUnicodeString(pName, _strTrustPartnerName);

   Status = LsaQueryTrustedDomainInfoByName(_hPolicy,
                                            pName,
                                            TrustedDomainFullInformation,
                                            (PVOID *)ppFullInfo);

   // NTBUG#NTRAID9-658659-2002/07/02-ericb
   if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
   {
      // If we haven't tried the flat name yet, try it now; can get here if a
      // downlevel domain is upgraded to NT5. The name used the first time
      // that Query is called would be the DNS name but the TDO would be
      // named after the flat name.
      //
      dspDebugOut((DEB_ITRACE, "LsaQueryTDIBN: DNS name failed, trying flat name\n"));

      RtlInitUnicodeString(pName, pTrustPage->GetDomainFlatName());

      Status = LsaQueryTrustedDomainInfoByName(_hPolicy,
                                               pName,
                                               TrustedDomainFullInformation,
                                               (PVOID *)ppFullInfo);
      if (STATUS_SUCCESS == Status)
      {
         // Remember the fact that the flat name had to be used.
         //
         _fUpdatedFromNT4 = true;
      }
   }

   return Status;
}

//+----------------------------------------------------------------------------
//
// Method:     CRemoteDomain::DoCreate
//
// Synopsis:   Create a TDO in the remote domain for this trust. It is created
//             in the complementary direction.
//
// Note:       Errors are not reported in this routine; they are passed back
//             to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
DWORD
CRemoteDomain::DoCreate(CTrust & Trust, CDsDomainTrustsPage * pTrustPage)
{
   TRACER(CRemoteDomain, DoCreate);
   NTSTATUS Status = STATUS_SUCCESS;
   TRUSTED_DOMAIN_INFORMATION_EX tdix = {0};
   LSA_AUTH_INFORMATION AuthData = {0};
   TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx = {0};
   bool fSetQuarantined = false;

   GetSystemTimeAsFileTime((PFILETIME)&AuthData.LastUpdateTime);

   AuthData.AuthType = TRUST_AUTH_TYPE_CLEAR;
   AuthData.AuthInfoLength = static_cast<ULONG>(Trust.GetTrustPWlen() * sizeof(WCHAR));
   AuthData.AuthInfo = (PUCHAR)Trust.GetTrustPW();

   if (TRUST_DIRECTION_BIDIRECTIONAL == Trust.GetNewTrustDirection())
   {
      tdix.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
   }
   else
   {
      // Create the trust in the opposite direction from the local trust.
      //
      if (TRUST_DIRECTION_INBOUND == Trust.GetNewTrustDirection())
      {
         tdix.TrustDirection = TRUST_DIRECTION_OUTBOUND;
      }
      else
      {
         tdix.TrustDirection = TRUST_DIRECTION_INBOUND;
      }
   }

   if (tdix.TrustDirection & TRUST_DIRECTION_INBOUND)
   {
      AuthInfoEx.IncomingAuthInfos = 1;
      AuthInfoEx.IncomingAuthenticationInformation = &AuthData;
      AuthInfoEx.IncomingPreviousAuthenticationInformation = NULL;
   }

   if (tdix.TrustDirection & TRUST_DIRECTION_OUTBOUND)
   {
      AuthInfoEx.OutgoingAuthInfos = 1;
      AuthInfoEx.OutgoingAuthenticationInformation = &AuthData;
      AuthInfoEx.OutgoingPreviousAuthenticationInformation = NULL;

      // Set quarantine bit by default on outgoing external trusts
      if ( Trust.IsExternal() && !Trust.IsXForest () && !Trust.IsRealm () )
      {
          fSetQuarantined = true;
      }
   }

   tdix.TrustAttributes = Trust.GetNewTrustAttr();
   if (_fSetOtherOrgBit)
   {
      tdix.TrustAttributes |= TRUST_ATTRIBUTE_CROSS_ORGANIZATION;
   }
   else
   {
      tdix.TrustAttributes &= ~(TRUST_ATTRIBUTE_CROSS_ORGANIZATION);
   }

   if ( fSetQuarantined )
   {
      tdix.TrustAttributes |= TRUST_ATTRIBUTE_QUARANTINED_DOMAIN;
      //Remember that we set this attribute
      _fQuarantineSet = true;
   }
   else
   {
       tdix.TrustAttributes &= ~(TRUST_ATTRIBUTE_QUARANTINED_DOMAIN);
   }

   dspAssert(TRUST_TYPE_UPLEVEL == Trust.GetTrustType());

   RtlInitUnicodeString(&tdix.Name, pTrustPage->GetDnsDomainName());
   
   RtlInitUnicodeString(&tdix.FlatName, pTrustPage->GetDomainFlatName());
   
   tdix.Sid = pTrustPage->GetSid();

   tdix.TrustType = TRUST_TYPE_UPLEVEL;

   LSA_HANDLE hTrustedDomain;

   Status = LsaCreateTrustedDomainEx(_hPolicy,
                                     &tdix,
                                     &AuthInfoEx,
                                     0,//TRUSTED_SET_AUTH | TRUSTED_SET_POSIX,
                                     &hTrustedDomain);
   if (NT_SUCCESS(Status))
   {
      LsaClose(hTrustedDomain);
   }
   else
   {
      dspDebugOut((DEB_ITRACE, "LsaCreateTrustedDomainEx failed with error 0x%x\n",
                   Status));
   }

   return LsaNtStatusToWinError(Status);
}

//+----------------------------------------------------------------------------
//
// Method:     CRemoteDomain::DoModify
//
// Synopsis:   Modify the remote domain TDO for this trust to be bi-directional.
//
// Note:       Errors are not reported in this routine; they are passed back
//             to the caller to be analyzed and reported there.
//
//-----------------------------------------------------------------------------
DWORD
CRemoteDomain::DoModify(CTrust & Trust, CDsDomainTrustsPage * pTrustPage)
{
   TRACER(CRemoteDomain,DoModify);
   NTSTATUS Status = STATUS_SUCCESS;
   PTRUSTED_DOMAIN_FULL_INFORMATION pFullInfo = NULL;
   LSA_UNICODE_STRING Name = {0};

   // ulNewDir is the direction of trust being added as seen from local side
   ULONG ulNewDir = Trust.GetNewDirAdded();

   // It has to be either incoming or outgoing cannot be both
   dspAssert ( ulNewDir != TRUST_DIRECTION_BIDIRECTIONAL );

   Status = Query(pTrustPage, &Name, &pFullInfo);

   if (STATUS_SUCCESS != Status)
   {
      dspDebugOut((DEB_ITRACE, "Trust.Query returned 0x%x\n", Status));
      return LsaNtStatusToWinError(Status);
   }

   dspAssert(pFullInfo);

   LSA_AUTH_INFORMATION AuthData = {0};
   BOOL fSidSet = FALSE;

   GetSystemTimeAsFileTime((PFILETIME)&AuthData.LastUpdateTime);

   AuthData.AuthType = TRUST_AUTH_TYPE_CLEAR;
   AuthData.AuthInfoLength = static_cast<ULONG>(Trust.GetTrustPWlen() * sizeof(WCHAR));
   AuthData.AuthInfo = (PUCHAR)Trust.GetTrustPW();

   if (TRUST_DIRECTION_OUTBOUND == ulNewDir)
   {
      // Adding outbound locally, add inbound on the other domain.
      //
      pFullInfo->AuthInformation.IncomingAuthInfos = 1;
      pFullInfo->AuthInformation.IncomingAuthenticationInformation = &AuthData;
      pFullInfo->AuthInformation.IncomingPreviousAuthenticationInformation = NULL;
   }
   else
   {
      // Adding inbound locally, add outbound remotely.
      //
      pFullInfo->AuthInformation.OutgoingAuthInfos = 1;
      pFullInfo->AuthInformation.OutgoingAuthenticationInformation = &AuthData;
      pFullInfo->AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;

      if ( Trust.IsExternal () && ! Trust.IsXForest ()&& !Trust.IsRealm() )
      {
          pFullInfo->Information.TrustAttributes |= TRUST_ATTRIBUTE_QUARANTINED_DOMAIN;
          //Remember that we set this attribute
          _fQuarantineSet = true;
      }
   }
   pFullInfo->Information.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
   //
   // Check for a NULL domain SID. The SID can be NULL if the inbound
   // trust was created when the domain was NT4.
   //
   if (!pFullInfo->Information.Sid)
   {
      pFullInfo->Information.Sid = pTrustPage->GetSid();
      fSidSet = TRUE;
   }

   Status = LsaSetTrustedDomainInfoByName(_hPolicy,
                                          &Name,
                                          TrustedDomainFullInformation,
                                          pFullInfo);
   if (fSidSet)
   {
      // the SID memory is owned by OtherDomain, so don't free it here.
      //
      pFullInfo->Information.Sid = NULL;
   }
   LsaFreeMemory(pFullInfo);

   return LsaNtStatusToWinError(Status);
}

//+----------------------------------------------------------------------------
//
//  Method:    CRemoteDomain::ReadFTInfo
//
//  Synopsis:  Read the forest trust name suffixes claimed by the trust
//             partner (the local domain) and save them on the remote TDO.
//
//  Arguments: [ulDir]      - the trust direction from the local point of view.
//             [pwzLocalDC] - the DC of the trust partner (the local domain).
//             [CredMgr]    - credentials obtained earlier.
//             [WizErr]     - reference to the error object.
//             [fCredErr]   - if true, then the return value is a page ID.
//
//  Returns:   Page ID or error code depending on the value of fCredErr.
//
//-----------------------------------------------------------------------------
DWORD
CRemoteDomain::ReadFTInfo(ULONG ulDir, PCWSTR pwzLocalDC, CCredMgr & CredMgr,
                          CWizError & WizErr, bool & fCredErr)
{
   TRACER(CRemoteDomain,ReadFTInfo);
   DWORD dwRet = NO_ERROR;

   if (!pwzLocalDC)
   {
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }

   PLSA_FOREST_TRUST_INFORMATION pNewFTInfo = NULL;

   if (TRUST_DIRECTION_OUTBOUND == ulDir)
   {
      // Outbound-only trust must have the names fetched from the local domain.
      //
      dwRet = CredMgr.ImpersonateLocal();

      if (ERROR_SUCCESS != dwRet)
      {
         fCredErr = true;
         WizErr.SetErrorString1(IDS_ERR_CANT_SAVE_CREDS);
         WizErr.SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      dwRet = DsGetForestTrustInformationW(pwzLocalDC,
                                           NULL,
                                           0,
                                           &pNewFTInfo);
      CredMgr.Revert();

      if (NO_ERROR != dwRet || !pNewFTInfo)
      {
         dspAssert(pNewFTInfo);
         return dwRet;
      }

      // Read the locally known names and then merge them with the names
      // discovered from the other domain.
      //
      NTSTATUS status = STATUS_SUCCESS;
      LSA_UNICODE_STRING TrustPartner = {0};
      PLSA_FOREST_TRUST_INFORMATION pKnownFTInfo = NULL, pMergedFTInfo = NULL;

      RtlInitUnicodeString(&TrustPartner, _strTrustPartnerName);

      dwRet = CredMgr.ImpersonateRemote();

      if (ERROR_SUCCESS != dwRet)
      {
         NetApiBufferFree(pNewFTInfo);
         fCredErr = true;
         WizErr.SetErrorString1(IDS_ERR_CANT_SAVE_CREDS);
         WizErr.SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      CPolicyHandle cPolicy(_strUncDC);

      dwRet = cPolicy.OpenNoAdmin();

      if (NO_ERROR != dwRet)
      {
         return dwRet;
      }

      status = LsaQueryForestTrustInformation(cPolicy,
                                              &TrustPartner,
                                              &pKnownFTInfo);
      if (STATUS_NOT_FOUND == status)
      {
         // no FT info stored yet, which is the expected state for a new trust.
         //
         status = STATUS_SUCCESS;
      }

      if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
      {
         NetApiBufferFree(pNewFTInfo);
         CredMgr.Revert();
         return dwRet;
      }

      if (pKnownFTInfo && pKnownFTInfo->RecordCount)
      {
         // Merge the two.
         //
         dwRet = DsMergeForestTrustInformationW(_strTrustPartnerName,
                                                pNewFTInfo,
                                                pKnownFTInfo,
                                                &pMergedFTInfo);
         NetApiBufferFree(pNewFTInfo);

         CHECK_WIN32(dwRet, return dwRet);

         dspAssert(pMergedFTInfo);

         _FTInfo = pMergedFTInfo;

         LsaFreeMemory(pKnownFTInfo);
         LsaFreeMemory(pMergedFTInfo);
      }
      else
      {
         _FTInfo = pNewFTInfo;

         NetApiBufferFree(pNewFTInfo);
      }

      // Now write the data. On return from the call the pColInfo struct
      // will contain current collision data.
      //
      PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo = NULL;

      status = LsaSetForestTrustInformation(cPolicy,
                                            &TrustPartner,
                                            _FTInfo.GetFTInfo(),
                                            FALSE,
                                            &pColInfo);
      CredMgr.Revert();

      if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
      {
         return dwRet;
      }

      _CollisionInfo = pColInfo;

      return NO_ERROR;
   }

   // Outbound or bi-di trust, call DsGetForestTrustInfo on the remote DC with
   // the flag set to update the TDO.
   //
   dwRet = CredMgr.ImpersonateRemote();

   if (ERROR_SUCCESS != dwRet)
   {
      fCredErr = true;
      WizErr.SetErrorString1(IDS_ERR_CANT_SAVE_CREDS);
      WizErr.SetErrorString2Hr(dwRet);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   dwRet = DsGetForestTrustInformationW(_strUncDC,
                                        _strTrustPartnerName,
                                        DS_GFTI_UPDATE_TDO,
                                        &pNewFTInfo);
   if (NO_ERROR != dwRet)
   {
      CredMgr.Revert();
      return dwRet;
   }

   _FTInfo = pNewFTInfo;

   NetApiBufferFree(pNewFTInfo);

   //
   // Check for name conflicts.
   //
   dwRet = WriteFTInfo(false);

   CredMgr.Revert();

   return dwRet;
}

//+----------------------------------------------------------------------------
//
//  Method:    CRemoteDomain::WriteFTInfo
//
//-----------------------------------------------------------------------------
DWORD
CRemoteDomain::WriteFTInfo(bool fWrite)
{
   TRACER(CRemoteDomain,WriteFTInfo);
   DWORD dwRet;

   if (!_FTInfo.GetCount())
   {
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }

   NTSTATUS status = STATUS_SUCCESS;
   LSA_UNICODE_STRING Name = {0};
   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo = NULL, pColInfo2 = NULL;

   RtlInitUnicodeString(&Name, _strTrustPartnerName);

   CPolicyHandle cPolicy(_strUncDC);

   dwRet = cPolicy.OpenNoAdmin();

   if (NO_ERROR != dwRet)
   {
      return dwRet;
   }

   status = LsaSetForestTrustInformation(cPolicy,
                                         &Name,
                                         _FTInfo.GetFTInfo(),
                                         TRUE,
                                         &pColInfo);
   if (STATUS_SUCCESS != status)
   {
      return LsaNtStatusToWinError(status);
   }

   if (pColInfo && pColInfo->RecordCount)
   {
      PLSA_FOREST_TRUST_COLLISION_RECORD pRec = NULL;
      PLSA_FOREST_TRUST_RECORD pFTRec = NULL;

      for (UINT i = 0; i < pColInfo->RecordCount; i++)
      {
         pRec = pColInfo->Entries[i];
         pFTRec = _FTInfo.GetFTInfo()->Entries[pRec->Index];

         dspDebugOut((DEB_ITRACE, "Collision on record %d, type %d, flags 0x%x, name %ws\n",
                      pRec->Index, pRec->Type, pRec->Flags, pRec->Name.Buffer));

         switch (pFTRec->ForestTrustType)
         {
         case ForestTrustTopLevelName:
         case ForestTrustTopLevelNameEx:
            dspDebugOut((DEB_ITRACE, "Referenced FTInfo: %ws, type: TLN\n",
                         pFTRec->ForestTrustData.TopLevelName.Buffer));
            pFTRec->Flags = pRec->Flags;
            break;

         case ForestTrustDomainInfo:
            dspDebugOut((DEB_ITRACE, "Referenced FTInfo: %ws, type: Domain\n",
                         pFTRec->ForestTrustData.DomainInfo.DnsName.Buffer));
            pFTRec->Flags = pRec->Flags;
            break;

         default:
            break;
         }
      }
   }

   status = LsaSetForestTrustInformation(cPolicy,
                                         &Name,
                                         _FTInfo.GetFTInfo(),
                                         !fWrite,
                                         &pColInfo2);
   if (STATUS_SUCCESS != status)
   {
      return LsaNtStatusToWinError(status);
   }

   if (pColInfo2)
   {
      _CollisionInfo = pColInfo2;

      if (pColInfo)
      {
         LsaFreeMemory(pColInfo);
      }
   }
   else
   {
      _CollisionInfo = pColInfo;
   }

#if DBG == 1
   if (pColInfo && pColInfo->RecordCount)
   {
      PLSA_FOREST_TRUST_COLLISION_RECORD pRec;

      for (UINT i = 0; i < pColInfo->RecordCount; i++)
      {
         pRec = pColInfo->Entries[i];

         dspDebugOut((DEB_ITRACE, "Collision on record %d, type %d, flags 0x%x, name %ws\n",
                      pRec->Index, pRec->Type, pRec->Flags, pRec->Name.Buffer));
      }
   }
#endif

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:    CRemoteDomain::AreThereCollisions
//
//-----------------------------------------------------------------------------
bool
CRemoteDomain::AreThereCollisions(void) const
{
   if (_CollisionInfo.IsInConflict() || _FTInfo.IsInConflict())
   {
      return TRUE;
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Function:  GenerateRandomPassword
//
//-----------------------------------------------------------------------------
DWORD
GenerateRandomPassword(PWSTR pwzPW, DWORD cchPW)
{
   if (!pwzPW)
   {
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }
   HCRYPTPROV  hCryptProv;

   BOOL fStatus = CryptAcquireContext(&hCryptProv,
                                      NULL,
                                      NULL,           // Default provider
                                      PROV_RSA_FULL,  // Default's type
                                      CRYPT_VERIFYCONTEXT); // don't look for a keyset container
   if (fStatus)
   {
      fStatus = CryptGenRandom(hCryptProv,
                               cchPW * sizeof(WCHAR),
                               (PUCHAR)pwzPW);
   
      CryptReleaseContext(hCryptProv, 0);
   }

   if (!fStatus)
   {
      DWORD dwErr = GetLastError();
      dspDebugOut((DEB_ITRACE, "Crypto function returned error 0x%08x\n", dwErr));
      return dwErr;
   }

   // Terminate the password
   cchPW--;
   pwzPW[cchPW] = L'\0';
   // Make sure there aren't any NULL's in the password
   for (DWORD i = 0; i < cchPW; i++)
   {
      if (pwzPW[i] == L'\0')
      {
          // arbitrary letter
          pwzPW[i] = L'c';
      }
   }
   return NO_ERROR;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\trust.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:       trust.h
//
//  Contents:   DS domain trust page and Trusted-Domain object header
//
//  Classes:    CTrustPropPageBase, CDsDomainTrustsPage, CDsTrustedDomainPage
//
//  History:    07-July-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef __TRUST_H__
#define __TRUST_H__

#include "dlgbase.h"

extern "C" {

//taken from netlibnt.h; resides in netapi32.dll

NTSTATUS NetpApiStatusToNtStatus(NET_API_STATUS NetStatus);

}

const WCHAR DSPROP_DC_ADMIN_SHARE[] = L"\\IPC$";

typedef struct _TD_DOM_INFO {
    LSA_HANDLE Policy;
    PPOLICY_DNS_DOMAIN_INFO pDnsDomainInfo;
    PPOLICY_PRIMARY_DOMAIN_INFO pDownlevelDomainInfo;
    PWSTR pwzUncDcName;
    PWSTR pwzDomainName; // used for an MIT trusted domain or an orphaned trust.
    ULONG ulTrustType;
} TD_DOM_INFO, *PTD_DOM_INFO;

typedef enum {
    TRUST_REL_ROOT,
    TRUST_REL_PARENT,
    TRUST_REL_CHILD,
    TRUST_REL_CROSSLINK,
    TRUST_REL_EXTERNAL,
    TRUST_REL_FOREST,
    TRUST_REL_INDIRECT,
    TRUST_REL_SELF,
    TRUST_REL_MIT,
    TRUST_REL_UNKNOWN
} TRUST_RELATION;

typedef enum _TLN_EDIT_STATUS {
   Enabled,
   Enabled_Exceptions,
   Disabled,
   Disabled_Exceptions
} TLN_EDIT_STATUS;

#define TRUST_TYPE_NO_DC    0xffffffff

//+----------------------------------------------------------------------------
//
//  Class:      CEnumDomainTrustItem
//
//  Purpose:    Holds information about a trust returned by the trust
//              enumeration.
//
//-----------------------------------------------------------------------------
class CEnumDomainTrustItem
{
public:
    CEnumDomainTrustItem() : ulFlags(0), ulTrustType(0), ulTrustAttrs(0),
                     ulParentIndex((ULONG)(-1)), ulOriginalIndex((ULONG)(-1)),
                     nRelationship(TRUST_REL_UNKNOWN) {}

    ~CEnumDomainTrustItem() {}

    ULONG               ulFlags;
    ULONG               ulTrustType;
    ULONG               ulTrustAttrs;
    ULONG               ulParentIndex;
    ULONG               ulOriginalIndex;
    TRUST_RELATION      nRelationship;
    CStrW               strTDOpath;
    CStrW               strDNSname;
    CStrW               strFlatName;
};

typedef CEnumDomainTrustItem * PCEnumDomainTrustItem;

typedef enum {
    REMOVE_TRUST_INBOUND,
    REMOVE_TRUST_OUTBOUND
} TRUST_OP;

const int IDX_DOMNAME_COL = 0;
const int IDX_RELATION_COL = 1;
const int IDX_TRANSITIVE_COL = 2;
const int IDX_ROUTING_COL = 3;

HRESULT
CreateDomTrustPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                   PWSTR pwzADsPath, PWSTR pwzClass, HWND hNotifyObj,
                   DWORD dwFlags, const CDSSmartBasePathsInfo& basePathsInfo,
                   HPROPSHEETPAGE * phPage);

INT_PTR CALLBACK CredPromptProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

class CNewTrustWizard;

//+----------------------------------------------------------------------------
//
//  Class:     CallMember and its derivatives
//
//  Purpose:   Allows a page to indicate what the next step of the creation
//             process should be. It is an abstraction of the process of passing
//             a function pointer.
//
//-----------------------------------------------------------------------------
class CallMember
{
public:
   CallMember(CNewTrustWizard * pWiz) {_pWiz = pWiz;}
   virtual ~CallMember() {}

   virtual HRESULT Invoke(void) = 0;

protected:
   CNewTrustWizard * _pWiz;
};

//+----------------------------------------------------------------------------
//
//  Class:     CCreds
//
//  Purpose:   Stores credentials and does the needed impersonation/reverting.
//
//-----------------------------------------------------------------------------
class CCreds
{
   friend INT_PTR CALLBACK CredPromptProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
public:
   CCreds(void) : _cbPW(0), _fImpersonating(false), _hToken(NULL), _fSet(false) {}
   ~CCreds(void) {Revert(); Clear();}

   int   PromptForCreds(PCWSTR pwzDomain, HWND hParent);
   DWORD SetUserAndPW(PCWSTR pwzUser, PCWSTR pwzPW, PCWSTR pwzDomain = NULL);
   void  Clear(void);
   DWORD Impersonate(void);
   DWORD ImpersonateAnonymous(void);
   void  Revert(void);
   bool  IsSet(void) const {return _fSet;}

private:
   CStrW    _strUser;
   CStrW    _strDomain;
   CStrW    _strPW;
   ULONG    _cbPW;
   HANDLE   _hToken;
   bool     _fImpersonating;
   bool     _fSet;

   // not implemented to disallow copying.
   CCreds(const CCreds&);
   const CCreds& operator=(const CCreds&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CCredMgr
//
//  Purpose:   Manages the credentials for both the local domain and the
//             remote domain. 
//             Allows a page to set information about the impersonation that is
//             needed and where to go after it is successfully made.
//
//  Options:   - local or other domain prompt
//             - domain name in prompt
//             - user or admin creds prompt
//             - next function/page
//
//-----------------------------------------------------------------------------
class CCredMgr
{
public:
   CCredMgr() : _fRemote(true), _fAdmin(true),
                _pNextFcn(NULL), _nNextPage(0), _fNewCall(false) {}
   ~CCredMgr() {if (_pNextFcn) delete _pNextFcn;}

   void   DoRemote(bool fRemote = true) {_fRemote = fRemote;}
   bool   IsRemote(void) const {return _fRemote;}
   void   SetAdmin(bool fAdmin = true) {_fAdmin = fAdmin;}
   bool   IsAdmin(void) const {return _fAdmin;}
   void   SetDomain(LPCWSTR pwzDomain) {_strDomain = pwzDomain;}
   bool   SetNextFcn(CallMember * pNext);
   PCWSTR GetPrompt(void);
   PCWSTR GetDomainPrompt(void);
   PCWSTR GetSubTitle(void);
   int    InvokeNext(void);
   DWORD  SaveCreds(HWND hWndCredCtrl);
   DWORD  Impersonate(void);
   DWORD  ImpersonateLocal(void) {return _LocalCreds.Impersonate();}
   DWORD  ImpersonateRemote(void) {return _RemoteCreds.Impersonate();}
   bool   IsLocalSet(void) const {return _LocalCreds.IsSet();}
   bool   IsRemoteSet(void) const {return _RemoteCreds.IsSet();}
   void   Revert(void);
   bool   IsNewCall(void) const {return _fNewCall;}
   void   ClearNewCall(void) {_fNewCall = false;}
   void   SetNextPage(int nNextPage) {_nNextPage = nNextPage; _fNewCall = true;}

   CCreds         _LocalCreds;
   CCreds         _RemoteCreds;

protected:
   CStrW          _strDomain;
   CStrW          _strSubTitle;
   CStrW          _strPrompt;
   CStrW          _strDomainPrompt;
   bool           _fRemote;
   bool           _fAdmin;
   CallMember   * _pNextFcn;
   int            _nNextPage;
   bool           _fNewCall;

   // not implemented to disallow copying.
   CCredMgr(const CCredMgr&);
   const CCredMgr& operator=(const CCredMgr&);
};

#define DS_TRUST_VERIFY_NEW_TRUST           1
#define DS_TRUST_VERIFY_PROMPT_FOR_CREDS    2
#define DS_TRUST_VERIFY_DOWNLEVEL           4

#define DS_TRUST_INFO_GET_PDC               1
#define DS_TRUST_INFO_ALL_ACCESS            2

//+----------------------------------------------------------------------------
//
//  Class:      CDomainInfo
//
//  Purpose:    Base class containing the description of a domain.
//
//-----------------------------------------------------------------------------
class CDomainInfo
{
public:
   CDomainInfo(void);
   virtual ~CDomainInfo(void);

   HRESULT DiscoverDC(PCWSTR pwzDomainName, ULONG ulDcFlags = 0);
   void    SetDcName(PCWSTR pwzDC) {_strUncDC = pwzDC;}
   PCWSTR  GetUncDcName(void) const {return _strUncDC;}
   PCWSTR  GetDcName(void) {return _strUncDC.GetBuffer(0) + 2;}
   DWORD   OpenLsaPolicy(CCreds & Creds,
                         ACCESS_MASK AccessDesired = POLICY_VIEW_LOCAL_INFORMATION);
   DWORD   OpenLsaPolicyWithPrompt(CCreds & Creds, HWND hWnd);
   const   LSA_HANDLE GetLsaPolicy(void) const {return _hPolicy;}
   void    CloseLsaPolicy(void);
   HRESULT GetInfo(PCWSTR pwzDomainName, CCredMgr & Creds, HWND hPage);
   HRESULT GetDomainVersion(HWND hWnd, UINT * pulVer);
   HRESULT InitAndReadDomNames(void);
   HRESULT ReadDomainInfo(void);
   PCWSTR  GetDnsDomainName(void) const {return _strDomainDnsName;}
   PCWSTR  GetDomainFlatName(void) const {return _strDomainFlatName;}
   PCWSTR  GetForestName(void) const {return _strForestName;}
   bool    SetSid(PSID pSid);
   const   PSID GetSid(void) const {return _pSid;}
   bool    IsFound(void) const {return !_fNotFound;}
   bool    IsUplevel(void) const {return _fUplevel;}
   bool    IsForestRoot(void) const {return _fIsForestRoot;}
protected:
   void Clear(void);

   CStrW       _strDomainDnsName;
   CStrW       _strDomainFlatName;
   CStrW       _strForestName;
   CStrW       _strUncDC;
   bool        _fNotFound;
   bool        _fIsForestRoot;
   bool        _fUplevel;
   LSA_HANDLE  _hPolicy;
   PSID        _pSid;

   // not implemented to disallow copying.
   CDomainInfo(const CDomainInfo&);
   const CDomainInfo& operator=(const CDomainInfo&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustPropPageBase
//
//  Purpose:    Base class for displaying/manipulating trust relationships.
//
//-----------------------------------------------------------------------------
class CTrustPropPageBase : public CDomainInfo
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CTrustPropPageBase();
    ~CTrustPropPageBase(void);

    void    GetStrTDO (CStrW strTrustName, CStrW &strTDOPath );
    CDsPropPageBase * GetPage (void) { return m_pPage;}

protected:
    virtual HRESULT Initialize(CDsPropPageBase * pPage);
    HRESULT QueryTrusts(void);
    void    FreeTrustData(void);
    HRESULT GetInfoForRemoteDomain(PCWSTR DomainName, PTD_DOM_INFO Info,
                                   CCredMgr & Creds, HWND hWnd,
                                   DWORD dwFlags = 0);
    DWORD   VerifyTrustOneDirection(PCWSTR pwzTrustingDcName,
                                    PCWSTR pwzTrustingDomName,
                                    PCWSTR pwzTrustedDomName,
                                    PWSTR * ppwzTrustedDcUsed,
                                    CCreds & Creds,
                                    CWaitCursor & Wait,
                                    CStrW & strMsg,
                                    DWORD dwFlags = 0);
   CEnumDomainTrustItem * IsTrustListed(PCWSTR pwzDnsName, PCWSTR pwzFlatName);
   //
   //  Data members
   //
   CDsPropPageBase * m_pPage;
   CStrW             m_strDomainParent;
   ULONG             m_cTrusts;
   ULONG             m_iDomain;
   CEnumDomainTrustItem * m_rgTrustList;

private:
   bool  _fIsInitialized;
};

class CNewTrustWizard; // forward declaration
class CRemoteDomain;

//+----------------------------------------------------------------------------
//
//  Class:      CDsDomainTrustsPage
//
//  Purpose:    Property page object class for the domain trusts page.
//
//-----------------------------------------------------------------------------
class CDsDomainTrustsPage : public CTrustPropPageBase, public CDsPropPageBase
{
friend CNewTrustWizard;

public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsDomainTrustsPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                       DWORD dwFlags);
    ~CDsDomainTrustsPage(void);

    //
    //  Instance specific wind proc
    //
    INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnApply(void) {return PSNRET_NOERROR;}

    static INT_PTR CALLBACK AddTrustProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                         LPARAM lParam);
    void    OnAddTrustClick(HWND CtlhWnd);
    void    OnRemoveTrustClick(int id);
    void    OnViewTrustClick(int id);
    void    EnableButtons(UINT_PTR id, BOOL fEnable);
    HRESULT RefreshLists(void);
    void    ClearUILists(void);
    DWORD   RemoveLocalTrust(PCEnumDomainTrustItem pTrust,
                             CRemoteDomain & OtherDomain, TRUST_OP DirToRm);
    DWORD   RemoveRemoteTrust(CRemoteDomain & OtherDomain, bool fRmAll,
                              TRUST_OP DirToRm,
                              bool fIsOutboundForest);
    HRESULT QueryDeleteTrust(PLSA_UNICODE_STRING pName, PSID pSid, CCreds & LocalCreds);
    int     ConfirmRemove(PCWSTR pwzTrustedDomain, TRUST_OP DirToRm,
                          bool fBothSides = false);
    BOOL    IsAllWhistler(void);

    //
    //  Data members
    //
public:
    BOOL    QualifiesForestTrust(void) {return IsForestRoot() && IsAllWhistler();}
    int     m_CtrlId;

private:
    CCredMgr      _CredMgr;
    BOOL          m_fSetAllWhistler;
    BOOL          m_fIsAllWhistler;
    CStrW         _strLastRmDomain;

   // not implemented to disallow copying.
   CDsDomainTrustsPage(const CDsDomainTrustsPage&);
   const CDsDomainTrustsPage& operator=(const CDsDomainTrustsPage&);
};

VOID FreeDomainInfo(PTD_DOM_INFO Info);

NTSTATUS RemoveTrustDirection(LSA_HANDLE hPolicy, PLSA_UNICODE_STRING pName,
                              PLSA_UNICODE_STRING pFlatName, PSID  pSid, ULONG ulTrustType,
                              TRUST_OP Op);

NTSTATUS DeleteTrust(LSA_HANDLE hPolicy, PLSA_UNICODE_STRING pName,
                     PLSA_UNICODE_STRING pFlatName, PSID pSid,
                     ULONG ulTrustType);

DWORD GenerateRandomPassword(PWSTR pwzPW, DWORD cchPW);

//+----------------------------------------------------------------------------
//
//  Class:      CTrustAuthPropPage
//
//  Purpose:    Property page object class for the forest trust name routing page.
//
//-----------------------------------------------------------------------------
class CTrustAuthPropPage : public CLightweightPropPageBase
{
public:
#ifdef _DEBUG
   char szClass[32];
#endif

   CTrustAuthPropPage(HWND hParent);
   ~CTrustAuthPropPage(void);

   //
   //  Instance specific wind proc
   //
   INT_PTR CALLBACK  DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
   LRESULT  OnInitDialog(LPARAM lParam);
   LRESULT  OnApply(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   LRESULT  OnNotify(WPARAM wParam, LPARAM lParam);
   static   UINT CALLBACK PageCallback(HWND hwnd, UINT uMsg,
                                       LPPROPSHEETPAGE ppsp);
   DWORD    SetOrgBit(void);
   bool     IsOrgChanged(void) const {return _fNewOtherOrg != _fOrigOtherOrg;};

public:
   HRESULT  Init(PCWSTR pwzDomainDnsName, PCWSTR pwzTrustPartnerName,
                 PCWSTR pwzDcName, ULONG nTrustAttrs,
                 TRUST_RELATION Relation, BOOL fReadOnly);
   //
   //  Data members
   //
private:
   TRUST_RELATION    _TrustRelation;
   bool              _fOrigOtherOrg;
   bool              _fNewOtherOrg;
   CCreds            _LocalCreds;

   // not implemented to disallow copying.
   CTrustAuthPropPage(const CTrustAuthPropPage&);
   const CTrustAuthPropPage& operator=(const CTrustAuthPropPage&);
};

class CDsForestNameRoutingPage;

//+----------------------------------------------------------------------------
//
//  Class:      CDsTrustedDomainPage
//
//  Purpose:    Class for the Trusted-Domain object general page.
//
//-----------------------------------------------------------------------------
class CDsTrustedDomainPage : public CTrustPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsTrustedDomainPage(void);
    ~CDsTrustedDomainPage(void);

    inline  HRESULT Initialize(CDsPropPageBase * pPage);
    HRESULT ExtraTrustPages(BOOL fReadOnly);
    PCWSTR  GetTrustPartnerDnsName(void) const {return m_pwzTrustedDomDnsName;}
    PCWSTR  GetTrustPartnerFlatName(void) const {return m_pwzTrustedDomFlatName;}
    HRESULT TrustType(int nType, CStrW& strType);
    TRUST_RELATION TrustRelation(void) {return m_nRelationship;}
    BOOL    IsParentChild(void) const {return m_nRelationship == TRUST_REL_PARENT ||
                                              m_nRelationship == TRUST_REL_CHILD;}
    void    SetTrustAttrs(ULONG ulTrustAttrs) {m_ulTrustAttrs = ulTrustAttrs;}
    BOOL    SetFlatName(PWSTR pwzFlatName);
    BOOL    SetDnsName(PWSTR pwzDnsName);
    void    TrustDirection(int nDirection, CStrW& strDirection);
    int     OnVerifyTrustBtn(void);
    void    OnSaveFTInfoBtn(void);
    BOOL    CantVerify(void) const {return TRUST_REL_MIT == m_nRelationship;}
    BOOL    IsMIT(void) const {return TRUST_REL_MIT == m_nRelationship;}
    BOOL    IsNonTransitive(void) const
                        {return TRUST_REL_EXTERNAL == m_nRelationship ||
                                m_ulTrustAttrs & TRUST_ATTRIBUTE_NON_TRANSITIVE;}
    HRESULT SetTransitive(BOOL fTransitive);
    bool    IsForestTrust(void) const {return TRUST_REL_FOREST == m_nRelationship;}
    bool    IsExternalTrust(void) const {return TRUST_REL_EXTERNAL == m_nRelationship;}
    bool    IsOutgoingTrust(void) const {return (TRUST_DIRECTION_OUTBOUND & m_nTrustDirection) != 0;};
    bool    IsQuarantinedTrust(void) const { return ( TRUST_ATTRIBUTE_QUARANTINED_DOMAIN & m_ulTrustAttrs ) != 0; };
    HRESULT ResetTrust(void);


#if DBG == 1 // TRUSTBREAK
    VOID    BreakTrust(void);
#endif

private:
    TRUST_RELATION      m_nRelationship;
    ULONG               m_ulTrustType;
    ULONG               m_ulTrustAttrs;
    ULONG               m_nTrustDirection;
    PWSTR               m_pwzTrustedDomFlatName;
    PWSTR               m_pwzTrustedDomDnsName;
    CDsForestNameRoutingPage * _pForestNamePage;
    CCredMgr            _CredMgr;

   // not implemented to disallow copying.
   CDsTrustedDomainPage(const CDsTrustedDomainPage&);
   const CDsTrustedDomainPage& operator=(const CDsTrustedDomainPage&);
};


//+----------------------------------------------------------------------------
//
//  Class:     CQuarantineWarnDlg
//
//  Purpose:   Dialog box to warn that SID filtering has been enabled by default
//             
//
//-----------------------------------------------------------------------------
class CQuarantineWarnDlg : public CModalDialog
{
public:
    CQuarantineWarnDlg ( HWND hParent,
                         int nTemplate):
                CModalDialog(hParent, nTemplate) {}
    virtual ~CQuarantineWarnDlg (void) {}

protected:
    virtual LRESULT OnInitDialog(LPARAM lParam) { return 0; };
    virtual LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify); 
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);

private:
   //Not implemented to disallow copying
   CQuarantineWarnDlg(const CQuarantineWarnDlg&);
   const CQuarantineWarnDlg& operator=(const CQuarantineWarnDlg&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CQueryChoiceWCredsDlgBase
//
//  Purpose:   Dialog box to ask if the user wants to do an operation that
//             requires credentials.
//
//-----------------------------------------------------------------------------
class CQueryChoiceWCredsDlgBase : public CModalDialog
{
public:
   CQueryChoiceWCredsDlgBase(HWND hParent,
                             CCreds & Creds,
                             PCWSTR pwzDomainName,
                             int nTemplate) :
            _Creds(Creds),
            _pwzDomainName(pwzDomainName),
            CModalDialog(hParent, nTemplate) {}
   virtual ~CQueryChoiceWCredsDlgBase(void) {}

protected:
   virtual LRESULT OnInitDialog(LPARAM lParam);

   CCreds & _Creds;
   PCWSTR   _pwzDomainName;

private:
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   LRESULT OnHelp(LPHELPINFO pHelpInfo);

   // not implemented to disallow copying.
   CQueryChoiceWCredsDlgBase(const CQueryChoiceWCredsDlgBase&);
   const CQueryChoiceWCredsDlgBase& operator=(const CQueryChoiceWCredsDlgBase&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CVerifyInboundDlg
//
//  Purpose:   Dialog box to ask if the user wants to verify the inbound trust.
//
//-----------------------------------------------------------------------------
class CVerifyInboundDlg : public CQueryChoiceWCredsDlgBase
{
public:
   CVerifyInboundDlg(HWND hParent,
                     CCreds & Creds,
                     PCWSTR pwzTrustingDomain) :
            CQueryChoiceWCredsDlgBase(hParent, Creds, pwzTrustingDomain,
                                      IDD_VERIFY_INBOUND) {}
   ~CVerifyInboundDlg(void) {}

protected:
   LRESULT OnInitDialog(LPARAM lParam);

private:
   // not implemented to disallow copying.
   CVerifyInboundDlg(const CVerifyInboundDlg&);
   const CVerifyInboundDlg& operator=(const CVerifyInboundDlg&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CVerifyResultsQueryResetDlg
//
//  Purpose:   Dialog box to present the verification failures and to prompt if
//             a password reset should be attempted.
//
//-----------------------------------------------------------------------------
class CVerifyResultsQueryResetDlg : public CQueryChoiceWCredsDlgBase
{
public:
   CVerifyResultsQueryResetDlg(HWND hParent,
                               CStrW & strResults,
                               CCreds & Creds,
                               PCWSTR pwzTrustingDomain) :
            _strResults(strResults),
            CQueryChoiceWCredsDlgBase(hParent, Creds, pwzTrustingDomain,
                                      IDD_TRUST_RESET) {}
   ~CVerifyResultsQueryResetDlg(void) {}

protected:
   LRESULT OnInitDialog(LPARAM lParam);

private:
   CStrW  & _strResults;

   // not implemented to disallow copying.
   CVerifyResultsQueryResetDlg(const CVerifyResultsQueryResetDlg&);
   const CVerifyResultsQueryResetDlg& operator=(const CVerifyResultsQueryResetDlg&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CRemoveBothSidesDlg
//
//  Purpose:   Dialog box to ask if the user wants to remove both sides of
//             the trust and to get the creds for the remote side.
//
//-----------------------------------------------------------------------------
class CRemoveBothSidesDlg : public CQueryChoiceWCredsDlgBase
{
public:
   CRemoveBothSidesDlg(HWND hParent,
                       CCreds & Creds,
                       PCWSTR pwzTrustPartner) :
            CQueryChoiceWCredsDlgBase(hParent, Creds, pwzTrustPartner,
                                      IDD_REMOVE_BOTH_SIDES) {}
   ~CRemoveBothSidesDlg(void) {}

protected:
   LRESULT OnInitDialog(LPARAM lParam);

private:
   // not implemented to disallow copying.
   CRemoveBothSidesDlg(const CRemoveBothSidesDlg&);
   const CRemoveBothSidesDlg& operator=(const CRemoveBothSidesDlg&);
};

//
// Attr functions for the trusted-domain General page.
//
HRESULT
CurDomainText(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
              DLG_OP DlgOp);
HRESULT
PeerDomain(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
           DLG_OP DlgOp);
HRESULT
TrustType(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
          PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
          DLG_OP DlgOp);
HRESULT
TrustDirection(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp);
HRESULT
TransitiveTextOrButton(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                       PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                       DLG_OP DlgOp);
HRESULT
TrustTransNo(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
             DLG_OP DlgOp);
HRESULT
TrustVerifyBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                DLG_OP DlgOp);

HRESULT
TrustVerifyText(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                DLG_OP DlgOp);

HRESULT
SaveFTInfoBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
              PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
              DLG_OP DlgOp);

HRESULT
TrustQStateText(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                DLG_OP DlgOp);

#if DBG == 1 // TRUSTBREAK
HRESULT
TrustBreakBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
                DLG_OP DlgOp);
#endif

//+----------------------------------------------------------------------------
//
//  Class:      CPolicyHandle
//
//  Purpose:    Class to manage a domain's LSA policy handle.
//
//  Notes:      The applicable DC name is passed in on the ctor.
//
//-----------------------------------------------------------------------------
class CPolicyHandle
{
public:
   CPolicyHandle(PCWSTR pwzDc) : m_hPolicy(NULL) { m_strUncDc = pwzDc; }
   ~CPolicyHandle() { if (m_hPolicy) LsaClose(m_hPolicy); }

   DWORD OpenNoAdmin(void) {return Open(FALSE);}
   DWORD OpenReqAdmin(void) {return Open();}
   DWORD OpenWithPrompt(CCreds & Creds, CWaitCursor & Wait,
                        PCWSTR pwzDomain, HWND hWnd);
   DWORD OpenWithAnonymous(CCredMgr & Creds);
   LSA_HANDLE Get(void) {return m_hPolicy;}
   LSA_HANDLE operator=(const CPolicyHandle& src) {return src.m_hPolicy;}
   void  Close(void) {if (m_hPolicy) LsaClose(m_hPolicy); m_hPolicy = NULL;}
   operator LSA_HANDLE () {return m_hPolicy;}

private:
   DWORD Open(BOOL fModify = TRUE);

   LSA_HANDLE m_hPolicy;
   CStrW m_strUncDc;
};

//+----------------------------------------------------------------------------
//
//  Function:  GetEnterpriseVer
//
//  Synopsis:  Checks the msDS-Behavior-Version attribute of the Partitions
//             container. If the value exists and is greater or equal to 2,
//             then the parameter boolean is set to TRUE.
//
//-----------------------------------------------------------------------------
HRESULT
GetEnterpriseVer(PCWSTR pwzDC, BOOL * pfAllWhistler);

#endif // __TRUST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\trustwiz.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Domains and Trust
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       trustwiz.cxx
//
//  Contents:   Domain trust creation wizard.
//
//  History:    04-Aug-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "dlgbase.h"
#include "trust.h"
#include "trustwiz.h"
#include "chklist.h"
#include <lmerr.h>
#pragma warning(push, 3)
#include <string>
#include <map>
#pragma warning (pop)

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CNewTrustWizard
//
//  Purpose:   New trust creation wizard.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

CNewTrustWizard::CNewTrustWizard(CDsDomainTrustsPage * pTrustPage) :
   _hTitleFont(NULL),
   _pTrustPage(pTrustPage),
   _fBacktracking(FALSE),
   _fHaveBacktracked(FALSE),
   _nPasswordStatus(0),
   _fQuarantineSet(false),
   _hr(S_OK)
{
   MakeBigFont();
}

CNewTrustWizard::~CNewTrustWizard()
{
   for (PAGELIST::iterator i = _PageList.begin(); i != _PageList.end(); ++i)
   {
      delete *i;
   }
   if (_hTitleFont)
   {
      DeleteObject(_hTitleFont);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::AddPage
//
//  Synopsis:  Add a page to the wizard. 
//
//-----------------------------------------------------------------------------
BOOL
CNewTrustWizard::AddPage(CTrustWizPageBase * pPage)
{
   if (pPage)
   {
      _PageList.push_back(pPage);
   }
   else
   {
      return FALSE;
   }
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::CreatePages
//
//  Synopsis:  Create the pages of the wizard. 
//
//-----------------------------------------------------------------------------
HRESULT
CNewTrustWizard::CreatePages(void)
{
   TRACER(CNewTrustWizard,CreatePages);

   // Intro page must be first!
   if (!AddPage(new CTrustWizIntroPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizNamePage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizSidesPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizPasswordPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizPwMatchPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizCredPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizMitOrWinPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizTransitivityPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizExternOrForestPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizDirectionPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizBiDiPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizOrganizationPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizOrgRemotePage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizSelectionsPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizStatusPage(this))) return E_OUTOFMEMORY; 
   if (!AddPage(new CTrustWizVerifyOutboundPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizVerifyInboundPage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizSaveSuffixesOnLocalTDOPage(this))) return E_OUTOFMEMORY; 
   if (!AddPage(new CTrustWizSaveSuffixesOnRemoteTDOPage(this))) return E_OUTOFMEMORY; 
   if (!AddPage(new CTrustWizDoneOKPage(this))) return E_OUTOFMEMORY; 
   if (!AddPage(new CTrustWizDoneVerErrPage(this))) return E_OUTOFMEMORY; 
   if (!AddPage(new CTrustWizFailurePage(this))) return E_OUTOFMEMORY;
   if (!AddPage(new CTrustWizAlreadyExistsPage(this))) return E_OUTOFMEMORY;

   return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::LaunchModalWiz
//
//  Synopsis:  Create the wizard.
//
//-----------------------------------------------------------------------------
HRESULT
CNewTrustWizard::LaunchModalWiz(void)
{
   TRACER(CNewTrustWizard,LaunchModalWiz);

   size_t nPages = _PageList.size();

   if (0 == nPages)
   {
      dspAssert(false);
      return E_FAIL;
   }
   HPROPSHEETPAGE * rgHPSP = new HPROPSHEETPAGE[nPages];
   CHECK_NULL(rgHPSP, return E_OUTOFMEMORY);
   // NOTICE-2002/02/18-ericb - SecurityPush: zeroing an array of page structures.
   memset(rgHPSP, 0, sizeof(HPROPSHEETPAGE) * nPages);

   BOOL fDeletePages = FALSE;
   int j = 0;
   for (PAGELIST::iterator i = _PageList.begin(); i != _PageList.end(); ++i, ++j)
   {
      if ((rgHPSP[j] = (*i)->Create()) == NULL)
      {
         fDeletePages = TRUE;
      }
   }

   PROPSHEETHEADER psh = {0};
   HRESULT hr = S_OK;

   psh.dwSize     = sizeof(PROPSHEETHEADER);
   psh.dwFlags    = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
   psh.hwndParent = _pTrustPage->m_pPage->GetHWnd();
   psh.hInstance  = g_hInstance;
   psh.nPages     = static_cast<UINT>(nPages);
   psh.phpage     = rgHPSP;

   HDC hDC = GetDC(NULL);
   BOOL fHiRes = GetDeviceCaps(hDC, BITSPIXEL) >= 8;
   ReleaseDC(NULL, hDC);

   psh.pszbmWatermark = fHiRes ? MAKEINTRESOURCE(IDB_TW_WATER256) :
                                 MAKEINTRESOURCE(IDB_TW_WATER16);
   psh.pszbmHeader    = fHiRes ? MAKEINTRESOURCE(IDB_TW_BANNER256) :
                                 MAKEINTRESOURCE(IDB_TW_BANNER16);
   if (PropertySheet(&psh) < 0)
   {
      dspDebugOut((DEB_ITRACE, "PropertySheet returned failure\n"));
      hr = HRESULT_FROM_WIN32(GetLastError());
      fDeletePages = TRUE;
   }

   if (fDeletePages)
   {
      // Couldn't create all of the pages or the wizard, so clean up.
      //
      for (size_t i = 0; i < nPages; i++)
      {
         if (rgHPSP[i])
         {
            DestroyPropertySheetPage(rgHPSP[i]);
         }
      }
   }

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::MakeBigFont
//
//  Synopsis:  Create the font for the title of the intro and completion pages.
//
//-----------------------------------------------------------------------------
void
CNewTrustWizard::MakeBigFont(void)
{
   NONCLIENTMETRICS ncm = {0};
   ncm.cbSize = sizeof(ncm);
   // NOTICE-2002/02/18-ericb - SecurityPush: passing the address of a properly
   // initialized NONCLIENTMETRICS structure.
   SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
   LOGFONT TitleLogFont = ncm.lfMessageFont;
   TitleLogFont.lfWeight = FW_BOLD;
   // NOTICE-2002/02/18-ericb - SecurityPush: lfFaceName is a 32 character
   // buffer (see wingdi.h) and "Verdana Bold" will fit with room to spare.
   if (FAILED(StringCchCopy(TitleLogFont.lfFaceName, LF_FACESIZE, TEXT("Verdana Bold"))))
   {
      dspAssert(false);
      return;
   }

   HDC hdc = GetDC(NULL);
   INT FontSize = 12;
   TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
   _hTitleFont = CreateFontIndirect(&TitleLogFont);
   ReleaseDC(NULL, hdc);
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::SetNextPageID
//
//-----------------------------------------------------------------------------
void
CNewTrustWizard::SetNextPageID(CTrustWizPageBase * pPage, int iNextPageID)
{
   if (iNextPageID != -1)
   {
      dspAssert(pPage);

      if (pPage)
      {
         _PageIdStack.push(pPage->GetDlgResID());
      }
   }

   _fBacktracking = false;
   if ( pPage )
   {
      SetWindowLongPtr(pPage->GetPageHwnd(), DWLP_MSGRESULT, iNextPageID);
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::BackTrack
//
//-----------------------------------------------------------------------------
void
CNewTrustWizard::BackTrack(HWND hPage)
{
   int topPage = -1;

   _fHaveBacktracked = _fBacktracking = true;

   dspAssert(_PageIdStack.size());

   if (_PageIdStack.size())
   {
      topPage = _PageIdStack.top();

      dspAssert(topPage > 0);

      _PageIdStack.pop();
   }

   SetWindowLongPtr(hPage, DWLP_MSGRESULT, static_cast<LONG_PTR>(topPage));
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::GetPage
//
//  Synopsis:  Find the page that has this dialog resource ID and return the
//             page object pointer.
//
//-----------------------------------------------------------------------------
CTrustWizPageBase *
CNewTrustWizard::GetPage(unsigned uDlgResId)
{
   for (PAGELIST::iterator i= _PageList.begin(); i != _PageList.end(); ++i)
   {
      if ((*i)->GetDlgResID() == uDlgResId)
      {
         return *i;
      }
   }

   return NULL;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::ShowStatus
//
//  Synopsis:  Place the details of the trust into the edit control.
//
//-----------------------------------------------------------------------------
void
CNewTrustWizard::ShowStatus(CStrW & strMsg, bool fNewTrust)
{
   CStrW strItem;

   // Trust partner name.
   //
   // NOTICE-2002/02/18-ericb - SecurityPush: CStrW::LoadString sets the
   // string to an empty string on failure.
   strItem.LoadString(g_hInstance, IDS_TW_SPECIFIED_DOMAIN);
   strItem += OtherDomain.GetUserEnteredName();

   strMsg += strItem;
   int nTransID = Trust.IsExternal() ? IDS_WZ_TRANS_NO : IDS_WZ_TRANS_YES;

   DWORD dwAttr = fNewTrust ? Trust.GetNewTrustAttr() : Trust.GetTrustAttr();

   // Direction
   //
   strMsg += g_wzCRLF;
   strMsg += g_wzCRLF;
   strItem.LoadString(g_hInstance, IDS_TW_DIRECTION_PREFIX);
   strMsg += strItem;
   strMsg += g_wzCRLF;

   strItem.LoadString(g_hInstance,
                      Trust.GetTrustDirStrID(fNewTrust ?
                                             Trust.GetNewTrustDirection() :
                                             Trust.GetTrustDirection()));
   strMsg += strItem;

   // Trust type and attribute
   //
   strMsg += g_wzCRLF;
   strMsg += g_wzCRLF;
   strItem.LoadString(g_hInstance, IDS_TW_TRUST_TYPE_PREFIX);
   strMsg += strItem;

   int nTypeID = 0;

   if (TRUST_TYPE_MIT == Trust.GetTrustType())
   {
      nTypeID = IDS_REL_MIT;
      nTransID = (dwAttr & TRUST_ATTRIBUTE_NON_TRANSITIVE) ?
                     IDS_WZ_TRANS_NO : IDS_WZ_TRANS_YES;
   }
   else
   {
      if (Trust.IsExternal())
      {
         nTypeID = IDS_REL_EXTERNAL;

         if (dwAttr & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
         {
            nTypeID = IDS_TW_ATTR_XFOREST;
            nTransID = IDS_WZ_TRANS_YES;
         }
      }
      else
      {
         nTypeID = IDS_REL_CROSSLINK;
      }
   }
   strItem.LoadString(g_hInstance, nTypeID);
   strMsg += strItem;
   strMsg += g_wzCRLF;

   if (IDS_REL_CROSSLINK != nTypeID &&
       IDS_REL_MIT != nTypeID)
   {
      // My org/other org. Doesn't apply to shortcuts or realm.
      //
      GetOrgText(Trust.IsCreateBothSides(),
                 Trust.IsXForest(),
                 (dwAttr & TRUST_ATTRIBUTE_CROSS_ORGANIZATION) != 0,
                 OtherDomain.IsSetOtherOrgBit(),
                 fNewTrust ? Trust.GetNewTrustDirection() :
                             Trust.GetTrustDirection(),
                 strMsg);
   }

   // Transitivity:
   // external is always non-transitive, cross-forest and intra-forest always
   // transitive, and realm (MIT) can be either.
   //
   strMsg += g_wzCRLF;
   strItem.LoadString(g_hInstance, nTransID);
   strMsg += strItem;
   strMsg += g_wzCRLF;

   if (fNewTrust)
   {
      strMsg += g_wzCRLF;
      strItem.LoadString(g_hInstance,
                         Trust.IsCreateBothSides() ?
                           IDS_TW_STATUS_BOTH_SIDES :
                           IDS_TW_STATUS_THIS_SIDE_ONLY);
      strMsg += strItem;
      strMsg += g_wzCRLF;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CWizError::SetErrorString2Hr
//
//  Synopsis:  Formats an error message for the error page and puts it in the
//             second page string/edit control. nID defaults to zero to use a
//             generic formatting string.
//
//-----------------------------------------------------------------------------
void
CWizError::SetErrorString2Hr(HRESULT hr, int nID)
{
   PWSTR pwz = NULL;
   if (!nID)
   {
      nID = IDS_FMT_STRING_ERROR_MSG;
   }
   LoadErrorMessage(hr, nID, &pwz);
   if (!pwz)
   {
      _strError2 = L"memory allocation failure";
      return;
   }
   // NOTICE-2002/02/18-ericb - SecurityPush: LoadErrorMessage will return either
   // NULL or a valid string. The NULL case is caught above.
   size_t cch = wcslen(pwz);
   if (2 > cch)
   {
      delete [] pwz;
      _strError2 = L"memory allocation failure";
   }
   else
   {
      if (L'\r' == pwz[cch - 3])
      {
         // Remove the trailing CR/LF.
         //
         pwz[cch - 3] = L'\'';
         pwz[cch - 2] = L'\0';
      }
      _strError2 = pwz;
      delete [] pwz;
   }
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizPageBase
//
//  Purpose:   Common base class for wizard pages.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------

CTrustWizPageBase::CTrustWizPageBase(CNewTrustWizard * pWiz,
                                     UINT uDlgID,
                                     UINT uTitleID,
                                     UINT uSubTitleID,
                                     BOOL fExteriorPage) :
   _hPage(NULL),
   _uDlgID(uDlgID),
   _uTitleID(uTitleID),
   _uSubTitleID(uSubTitleID),
   _fExteriorPage(fExteriorPage),
   _pWiz(pWiz),
   _dwWizButtons(PSWIZB_BACK),
   _fInInit(FALSE)
{
}

CTrustWizPageBase::~CTrustWizPageBase()
{
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPageBase::Create
//
//  Synopsis:  Create a wizard page. 
//
//-----------------------------------------------------------------------------
HPROPSHEETPAGE
CTrustWizPageBase::Create(void)
{
   PROPSHEETPAGE psp = {0};

   psp.dwSize      = sizeof(PROPSHEETPAGE);
   psp.dwFlags     = PSP_DEFAULT | PSP_USETITLE; // | PSP_USECALLBACK;
   if (_fExteriorPage)
   {
      psp.dwFlags |= PSP_HIDEHEADER;
   }
   else
   {
      psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
      psp.pszHeaderTitle    = MAKEINTRESOURCE(_uTitleID);
      psp.pszHeaderSubTitle = MAKEINTRESOURCE(_uSubTitleID);
   }
   psp.pszTitle    = MAKEINTRESOURCE(IDS_TW_TITLE);
   psp.pszTemplate = MAKEINTRESOURCE(_uDlgID);
   psp.pfnDlgProc  = CTrustWizPageBase::StaticDlgProc;
   psp.lParam      = reinterpret_cast<LPARAM>(this);
   psp.hInstance   = g_hInstance;

   HPROPSHEETPAGE hpsp = CreatePropertySheetPage(&psp);

   if (!hpsp)
   {
      dspDebugOut((DEB_ITRACE, "Failed to create page with template ID of %d\n",
                   _uDlgID));
      return NULL;
   }

   return hpsp;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPageBase::StaticDlgProc
//
//  Synopsis:  static dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CTrustWizPageBase::StaticDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CTrustWizPageBase * pPage = (CTrustWizPageBase *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)lParam;

        pPage = (CTrustWizPageBase *) ppsp->lParam;
        pPage->_hPage = hDlg;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pPage);
    }

    if (NULL != pPage) // && (SUCCEEDED(pPage->_hrInit)))
    {
        return pPage->PageProc(hDlg, uMsg, wParam, lParam);
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPageBase::PageProc
//
//  Synopsis:  Instance-specific page window procedure. 
//
//-----------------------------------------------------------------------------
LRESULT 
CTrustWizPageBase::PageProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   BOOL fRet;

   switch (uMsg)
   {
   case WM_INITDIALOG:
      _fInInit = TRUE;
      fRet = OnInitDialog(lParam);
      _fInInit = FALSE;
      return fRet;

   case WM_COMMAND:
      if (_fInInit)
      {
         return TRUE;
      }
      return OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                       GET_WM_COMMAND_HWND(wParam, lParam),
                       GET_WM_COMMAND_CMD(wParam, lParam));

   case WM_NOTIFY:
      {
         NMHDR * pNmHdr = reinterpret_cast<NMHDR *>(lParam);

         switch (pNmHdr->code)
         {
         case PSN_SETACTIVE:
            OnSetActive();
            break;

         case PSN_WIZBACK:
            OnWizBack();
            // to change default page order, call SetWindowLong the DWL_MSGRESULT value
            // set to the new page's dialog box resource ID and return TRUE.
            break;

         case PSN_WIZNEXT:
            OnWizNext();
            // to change default page order, call SetWindowLong the DWL_MSGRESULT value
            // set to the new page's dialog box resource ID and return TRUE.
            break;

         case PSN_WIZFINISH: // Finish button pressed.
            OnWizFinish();
            break;

         case PSN_RESET:     // Cancel button pressed.
            // can be ignored unless cleanup is needed.
            dspDebugOut((DEB_ITRACE, "WM_NOTIFY code = PSN_RESET\n"));
            OnWizReset();
            break;
         }
      }
      return TRUE;

   case WM_DESTROY:
      // Cleanup goes here...
      OnDestroy();
      return TRUE;

   default:
      break;
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPageBase::OnWizBack
//
//-----------------------------------------------------------------------------
void
CTrustWizPageBase::OnWizBack(void)
{
   Wiz()->BackTrack(_hPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPageBase::OnWizNext
//
//-----------------------------------------------------------------------------
void
CTrustWizPageBase::OnWizNext(void)
{
   TRACE(CTrustWizPageBase, OnWizNext);

   Wiz()->SetNextPageID(this, Validate());
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizIntroPage
//
//  Purpose:   Intro page for trust creation wizard.
//
//-----------------------------------------------------------------------------
//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizIntroPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizIntroPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizIntroPage,OnInitDialog);

   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_TITLE);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   if (TrustPage()->QualifiesForestTrust())
   {
      ShowWindow(GetDlgItem(_hPage, IDC_FOREST_BULLET), SW_SHOW);
      ShowWindow(GetDlgItem(_hPage, IDC_FOREST_TEXT), SW_SHOW);
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizIntroPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizIntroPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (IDC_HELP_BTN == id && BN_CLICKED == codeNotify)
   {
      ShowHelp(L"ADConcepts.chm::/ADHelpNewTrustIntro.htm");
      return true;
   }
   return false;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizNamePage
//
//  Purpose:   Name and pw page for trust creation wizard.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizNamePage::CTrustWizNamePage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_NAME_PAGE, IDS_TW_NAME_TITLE,
                     IDS_TW_NAME_SUBTITLE)
{
   TRACER(CTrustWizNamePage,CTrustWizNamePage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizNamePage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizNamePage::OnInitDialog(LPARAM lParam)
{
   SendDlgItemMessage(_hPage, IDC_DOMAIN_EDIT, EM_LIMITTEXT, MAX_PATH, 0);
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizNamePage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT 
CTrustWizNamePage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (IDC_DOMAIN_EDIT == id && EN_CHANGE == codeNotify)
   {
      BOOL fNameEntered = SendDlgItemMessage(_hPage, IDC_DOMAIN_EDIT,
                                             WM_GETTEXTLENGTH, 0, 0) > 0;
      if (fNameEntered)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
      }
      else
      {
         _dwWizButtons = PSWIZB_BACK;
      }

      PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);

      return TRUE;
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizNamePage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizNamePage::OnSetActive(void)
{
   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizNamePage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizNamePage::Validate(void)
{
   TRACER(CTrustWizNamePage,Validate);
   WCHAR wzRemoteDomain[MAX_PATH + 1] = {0};
   CWaitCursor Wait;

   Trust().Clear();

   //
   // Read the name of the remote domain.
   //
   // NOTICE-2002/02/18-ericb - SecurityPush: wzRemoteDomain is initialized to
   // all zeros and is one char longer than the size passed to GetDlgItemText
   // so that even if this function truncates without null terminating, the
   // string will still be null terminated.
   GetDlgItemText(_hPage, IDC_DOMAIN_EDIT, wzRemoteDomain, MAX_PATH);

   //
   // Save the Name.
   //
   OtherDomain().SetUserEnteredName(wzRemoteDomain);

   // 
   // Contact the domain, read its naming info, and continue with the trust
   // creation/modification.
   //
   return Wiz()->CollectInfo();
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizSidesPage
//
//  Purpose:   Prompt if one or both sides should be created.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizSidesPage::CTrustWizSidesPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_SIDES_PAGE, IDS_TW_SIDES_TITLE,
                     IDS_TW_SIDES_SUBTITLE)
{
   TRACER(CTrustWizSidesPage,CTrustWizSidesPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSidesPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizSidesPage::OnInitDialog(LPARAM lParam)
{
   CStrW strLabel;
   // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
   strLabel.LoadString(g_hInstance, IDS_TW_SIDES_STATIC);
   SetDlgItemText(_hPage, IDC_TW_SIDES_STATIC, strLabel);
   CheckDlgButton(_hPage, IDC_THIS_SIDE_ONLY_RADIO, BST_CHECKED);
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSidesPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizSidesPage::OnSetActive(void)
{
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_BACK | PSWIZB_NEXT);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSidesPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizSidesPage::Validate(void)
{
   TRACER(CTrustWizSidesPage,Validate);

   if (IsDlgButtonChecked(_hPage, IDC_BOTH_SIDES_RADIO))
   {
      Trust().CreateBothSides(true);

      // Make sure we have a PDC for the remote domain.
      //
      HRESULT hr = OtherDomain().DiscoverDC(OtherDomain().GetUserEnteredName(),
                                            DS_PDC_REQUIRED);

      if (FAILED(hr) || !OtherDomain().IsFound())
      {
         CHECK_HRESULT(hr, ;);
         WizErr().SetErrorString1(IDD_TW_ERR_NO_REMOTE_PDC);
         WizErr().SetErrorString2Hr(hr);
         Wiz()->SetCreationResult(hr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      //
      // Now prompt for the remote domain creds. If the trust is outbound-only,
      // don't ask for admin creds.
      //
      CredMgr().DoRemote();
      CredMgr().SetAdmin(!Trust().IsOneWayOutBoundForest());
      CredMgr().SetDomain(OtherDomain().GetUserEnteredName());
      if (!CredMgr().SetNextFcn(new CallCheckOtherDomainTrust(Wiz())))
      {
         WizErr().SetErrorString2Hr(E_OUTOFMEMORY);
         Wiz()->SetCreationResult(E_OUTOFMEMORY);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
      return IDD_TRUSTWIZ_CREDS_PAGE;
   }
   else
   {
      Trust().CreateBothSides(false);

      if (Trust().IsExternal() &&
          ((Trust().Exists() && TRUST_DIRECTION_INBOUND == Trust().GetTrustDirection()) ||
           TRUST_DIRECTION_OUTBOUND & Trust().GetNewTrustDirection()))
      {
         // Old direction is inbound, so adding outbound to a downlevel trust,
         // or creating a new, outbound trust, check if the user wants to set
         // the other-org bit.
         //
         return IDD_TRUSTWIZ_ORGANIZATION_ATTR_PAGE;
      }
      else
      {
         // If we aren't creating both sides, we need a trust password.
         //
         return IDD_TRUSTWIZ_PASSWORD_PAGE;
      }
   }
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizPasswordPage
//
//  Purpose:   Get the trust password for a one-side trust creation.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizPasswordPage::CTrustWizPasswordPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_PASSWORD_PAGE, IDS_TW_PW_TITLE,
                     IDS_TW_PW_SUBTITLE)
{
   TRACER(CTrustWizPasswordPage, CTrustWizPasswordPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPasswordPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizPasswordPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizPasswordPage, OnInitDialog)

   LPARAM nLen = MAX_PATH;

   if (!OtherDomain().IsUplevel())
   {
      nLen = LM20_PWLEN; // 14, the usrmgr pw length limit.
   }

   SendDlgItemMessage(_hPage, IDC_PW1_EDIT, EM_LIMITTEXT, nLen, 0);
   SendDlgItemMessage(_hPage, IDC_PW2_EDIT, EM_LIMITTEXT, nLen, 0);

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPasswordPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT 
CTrustWizPasswordPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if ((IDC_PW1_EDIT == id || IDC_PW2_EDIT == id) &&
       EN_CHANGE == codeNotify)
   {
      BOOL fPW1Entered = SendDlgItemMessage(_hPage, IDC_PW1_EDIT,
                                             WM_GETTEXTLENGTH, 0, 0) > 0;
      BOOL fPW2Entered = SendDlgItemMessage(_hPage, IDC_PW2_EDIT,
                                             WM_GETTEXTLENGTH, 0, 0) > 0;
      if (fPW1Entered && fPW2Entered)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
      }
      else
      {
         _dwWizButtons = PSWIZB_BACK;
      }

      PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);

      return TRUE;
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPasswordPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizPasswordPage::OnSetActive(void)
{
   TRACER(CTrustWizPasswordPage, OnSetActive)
   LPARAM nLen = MAX_PATH;

   if (Wiz()->HaveBacktracked())
   {
      Wiz()->ClearBacktracked();
   }
   else
   {
      SetDlgItemText(_hPage, IDC_PW1_EDIT, L"");
      SetDlgItemText(_hPage, IDC_PW2_EDIT, L"");

      if (!OtherDomain().IsUplevel())
      {
         nLen = LM20_PWLEN; // 14, the usrmgr pw length limit.
      }

      SendDlgItemMessage(_hPage, IDC_PW1_EDIT, EM_LIMITTEXT, nLen, 0);
      SendDlgItemMessage(_hPage, IDC_PW2_EDIT, EM_LIMITTEXT, nLen, 0);
   }

   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPasswordPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizPasswordPage::Validate(void)
{
   WCHAR wzPW[MAX_PATH + 1] = {0}, wzPW2[MAX_PATH + 1] = {0};
   UINT cchPW1 = 0, cchPW2 = 0;

   //
   // Read the passwords and verify that they match. If they don't match,
   // go to the reenter-passwords page.
   //

   // NOTICE-2002/02/18-ericb - SecurityPush: wzPW/wzPW2 are initialized to
   // all zeros and are one char longer than the size passed to GetDlgItemText
   // so that even if this function truncates without null terminating, the
   // string will still be null terminated.

   cchPW1 = GetDlgItemText(_hPage, IDC_PW1_EDIT, wzPW, MAX_PATH);

   cchPW2 = GetDlgItemText(_hPage, IDC_PW2_EDIT, wzPW2, MAX_PATH);

   if (cchPW1 == 0 || cchPW2 == 0)
   {
      if (cchPW1 != cchPW2)
      {
         return IDD_TRUSTWIZ_PW_MATCH_PAGE;
      }
   }
   else
   {
      if (wcscmp(wzPW, wzPW2) != 0)
      {
         return IDD_TRUSTWIZ_PW_MATCH_PAGE;
      }
   }

   //
   // ntbug9 552057, 2002/04/12 ericb: Validate the pw.
   //
   int nRet = Wiz()->ValidateTrustPassword(wzPW);

   if (nRet)
   {
      // The validation failed. Use the pw match page to display the password
      // validation failure and request a re-entry.
      //
      return nRet;
   }

   //
   // Save the PW.
   //

   Trust().SetTrustPW(wzPW);

   return IDD_TRUSTWIZ_SELECTIONS;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizPwMatchPage
//
//  Purpose:   Trust passwords entered don't match page for trust wizard. Also
//             used for password re-entry if the prior one failed to meet
//             domain password policy criteria.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizPwMatchPage::CTrustWizPwMatchPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_PW_MATCH_PAGE, IDS_TW_PWMATCH_TITLE,
                     IDS_TW_PWMATCH_SUBTITLE)
{
   TRACER(CTrustWizPwMatchPage, CTrustWizPwMatchPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPwMatchPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizPwMatchPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizPwMatchPage, OnInitDialog)
   LPARAM nLen = MAX_PATH;

   if (!OtherDomain().IsUplevel())
   {
      nLen = LM20_PWLEN; // 14, the usrmgr pw length limit.
   }

   SendDlgItemMessage(_hPage, IDC_PW1_EDIT, EM_LIMITTEXT, nLen, 0);
   SendDlgItemMessage(_hPage, IDC_PW2_EDIT, EM_LIMITTEXT, nLen, 0);

   SetText();

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPwMatchPage::SetText
//
//-----------------------------------------------------------------------------
void
CTrustWizPwMatchPage::SetText(void)
{
   int nTitle = IDS_TW_PW_INVALID_TITLE, nSubTitle = 0, nLabel = 0;

   switch (Wiz()->GetPasswordValidationStatus())
   {
   case 0:
      // The default: passwords don't match.
      //
      nTitle = IDS_TW_PWMATCH_TITLE;
      nSubTitle = IDS_TW_PWMATCH_SUBTITLE;
      nLabel = IDS_TW_PW_MATCH_TEXT;
      break;

   case NERR_PasswordTooShort:
      nSubTitle = IDS_TW_PWTOOSHORT_SUBTITLE;
      nLabel = IDS_TW_PWTOOSHORT_TEXT;
      break;

   case NERR_PasswordTooLong:
      nSubTitle = IDS_TW_PWTOOLONG_SUBTITLE;
      nLabel = IDS_TW_PWTOOLONG_TEXT;
      break;

   case NERR_PasswordNotComplexEnough:
      nSubTitle = IDS_TW_PWNOTSTRONG_SUBTITLE;
      nLabel = IDS_TW_PWNOTSTRONG_TEXT;
      break;

   case NERR_PasswordFilterError:
      nSubTitle = IDS_TW_PWNOTSTRONG_SUBTITLE;
      nLabel = IDS_TW_PWFILTERDLL_TEXT;
      break;

   default:
      // We've gotten an unexpected code. Treat it as a pw-mismatch.
      dspDebugOut((DEB_ERROR,
                   "NetValidatePasswordPolicy is returning the unexpected status %d!\n",
                   Wiz()->GetPasswordValidationStatus()));
      dspAssert(false && "NetValidatePasswordPolicy is returning an unexpected status");
      nTitle = IDS_TW_PWMATCH_TITLE;
      nSubTitle = IDS_TW_PWMATCH_SUBTITLE;
      nLabel = IDS_TW_PW_MATCH_TEXT;
      break;
   }

   CStrW strText;
   strText.LoadString(g_hInstance, nTitle);
   PropSheet_SetHeaderTitle(GetParent(GetPageHwnd()), 
                            PropSheet_IdToIndex(GetParent(GetPageHwnd()), IDD_TRUSTWIZ_PW_MATCH_PAGE),
                            strText.GetBuffer(0));
   strText.LoadString(g_hInstance, nSubTitle);
   PropSheet_SetHeaderSubTitle(GetParent(GetPageHwnd()), 
                               PropSheet_IdToIndex(GetParent(GetPageHwnd()), IDD_TRUSTWIZ_PW_MATCH_PAGE),
                               strText.GetBuffer(0));
   strText.LoadString(g_hInstance, nLabel);
   SetDlgItemText(_hPage, IDC_TW_PW_MATCH_TEXT, strText);
   return;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPwMatchPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT 
CTrustWizPwMatchPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if ((IDC_PW1_EDIT == id || IDC_PW2_EDIT == id) &&
       EN_CHANGE == codeNotify)
   {
      BOOL fPW1Entered = SendDlgItemMessage(_hPage, IDC_PW1_EDIT,
                                             WM_GETTEXTLENGTH, 0, 0) > 0;
      BOOL fPW2Entered = SendDlgItemMessage(_hPage, IDC_PW2_EDIT,
                                             WM_GETTEXTLENGTH, 0, 0) > 0;
      if (fPW1Entered && fPW2Entered)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
      }
      else
      {
         _dwWizButtons = PSWIZB_BACK;
      }

      PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);

      return TRUE;
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPwMatchPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizPwMatchPage::OnSetActive(void)
{
   TRACER(CTrustWizPwMatchPage, OnSetActive)
   LPARAM nLen = MAX_PATH;

   if (Wiz()->HaveBacktracked())
   {
      Wiz()->ClearBacktracked();
   }
   else
   {
      SetDlgItemText(_hPage, IDC_PW1_EDIT, L"");
      SetDlgItemText(_hPage, IDC_PW2_EDIT, L"");

      if (!OtherDomain().IsUplevel())
      {
         nLen = LM20_PWLEN; // 14, the usrmgr pw length limit.
      }

      SendDlgItemMessage(_hPage, IDC_PW1_EDIT, EM_LIMITTEXT, nLen, 0);
      SendDlgItemMessage(_hPage, IDC_PW2_EDIT, EM_LIMITTEXT, nLen, 0);

      SetText();
   }

   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPwMatchPage::OnWizNext
//
//  Synopsis:  Override the default so that the page's ID can be removed from
//             the page stack. This is done so that backtracking doesn't go
//             back to this page since it is an error page.
//
//-----------------------------------------------------------------------------
void
CTrustWizPwMatchPage::OnWizNext(void)
{
   TRACE(CTrustWizPwMatchPage, OnWizNext);

   Wiz()->SetNextPageID(this, Validate());
   //
   // Pop this page off of the page stack so the user won't backtrack here.
   //
   Wiz()->PopTopPage();
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizPwMatchPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizPwMatchPage::Validate(void)
{
   WCHAR wzPW[MAX_PATH + 1] = {0}, wzPW2[MAX_PATH + 1] = {0};
   UINT cchPW1 = 0, cchPW2 = 0;

   //
   // Read the passwords and verify that they match.
   //

   // NOTICE-2002/02/18-ericb - SecurityPush: wzPW/wzPW2 are initialized to
   // all zeros and are one char longer than the size passed to GetDlgItemText
   // so that even if this function truncates without null terminating, the
   // string will still be null terminated.

   cchPW1 = GetDlgItemText(_hPage, IDC_PW1_EDIT, wzPW, MAX_PATH);

   cchPW2 = GetDlgItemText(_hPage, IDC_PW2_EDIT, wzPW2, MAX_PATH);

   if (cchPW1 == 0 || cchPW2 == 0)
   {
      if (cchPW1 != cchPW2)
      {
         SetFocus(GetDlgItem(_hPage, IDC_PW1_EDIT));
         Wiz()->ClearPasswordValidationStatus();
         return IDD_TRUSTWIZ_PW_MATCH_PAGE;
      }
   }
   else
   {
      if (wcscmp(wzPW, wzPW2) != 0)
      {
         SetFocus(GetDlgItem(_hPage, IDC_PW1_EDIT));
         Wiz()->ClearPasswordValidationStatus();
         return IDD_TRUSTWIZ_PW_MATCH_PAGE;
      }
   }

   //
   // ntbug9 552057, 2002/04/12 ericb: Validate the pw.
   //
   int nRet = Wiz()->ValidateTrustPassword(wzPW);

   if (nRet)
   {
      // The validation failed. Use the pw match page to display the password
      // validation failure and request a re-entry.
      //
      return nRet;
   }

   //
   // Save the PW.
   //

   Trust().SetTrustPW(wzPW);

   //
   // Update the edit controls on the password page in case the user backtracks
   // to there.
   //

   CTrustWizPageBase * pPage = Wiz()->GetPage(IDD_TRUSTWIZ_PASSWORD_PAGE);

   dspAssert(pPage);

   if (pPage)
   {
      // NTRAID#NTBUG9-657795-2002/07/11-sburns
      
      HWND hPwPage = pPage->GetPageHwnd();

      SetDlgItemText(hPwPage, IDC_PW1_EDIT, wzPW);
      SetDlgItemText(hPwPage, IDC_PW2_EDIT, wzPW);
   }

   return IDD_TRUSTWIZ_SELECTIONS;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizCredPage
//
//  Purpose:   Credentials specification page for trust creation wizard.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizCredPage::CTrustWizCredPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_CREDS_PAGE, IDS_TW_CREDS_TITLE,
                     IDS_TW_CREDS_SUBTITLE_OTHER)
{
   TRACER(CTrustWizCredPage, CTrustWizCredPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizCredPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizCredPage::OnInitDialog(LPARAM lParam)
{
   SendDlgItemMessage(_hPage, IDC_CREDMAN, CRM_SETUSERNAMEMAX, CREDUI_MAX_USERNAME_LENGTH, 0);
   SendDlgItemMessage(_hPage, IDC_CREDMAN, CRM_SETPASSWORDMAX, CREDUI_MAX_PASSWORD_LENGTH, 0);

   SetText();

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizCredPage::SetText
//
//-----------------------------------------------------------------------------
void
CTrustWizCredPage::SetText(void)
{
   PropSheet_SetHeaderSubTitle(GetParent(GetPageHwnd()), 
                               PropSheet_IdToIndex(GetParent(GetPageHwnd()), IDD_TRUSTWIZ_CREDS_PAGE),
                               CredMgr().GetSubTitle());

   SetDlgItemText(GetPageHwnd(), IDC_TW_CREDS_PROMPT, CredMgr().GetPrompt());

   SetDlgItemText(GetPageHwnd(), IDC_CRED_DOMAIN, CredMgr().GetDomainPrompt());

   const WCHAR wzEmpty[] = L"";
   SendDlgItemMessage(_hPage, IDC_CREDMAN, CRM_SETUSERNAME, 0, (LPARAM)wzEmpty);
   SendDlgItemMessage(_hPage, IDC_CREDMAN, CRM_SETPASSWORD, 0, (LPARAM)wzEmpty);

   // Set or clear the smart card/cert style bits on the CredMan control.
   // Certs and smart cards only work for the local domain.
   //
   HWND hCredCtrl = GetDlgItem(GetPageHwnd(), IDC_CREDMAN);
   LONG_PTR lCtrlStyle = GetWindowLongPtr(hCredCtrl, GWL_STYLE);
   if (CredMgr().IsRemote())
   {
      lCtrlStyle &= ~(CRS_SMARTCARDS | CRS_CERTIFICATES);
   }
   else
   {
      lCtrlStyle |= CRS_SMARTCARDS | CRS_CERTIFICATES;
   }
   SetWindowLongPtr(hCredCtrl, GWL_STYLE, lCtrlStyle);
   SetWindowPos(hCredCtrl, NULL, 0,0,0,0,
                SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);

   CredMgr().ClearNewCall();

   return;
}


//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizCredPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT 
CTrustWizCredPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   // don't enable the Next button unless there is text in the user name field
   //
   if (IDC_CREDMAN == id && CRN_USERNAMECHANGE == codeNotify)
   {
      BOOL fNameEntered = SendDlgItemMessage(_hPage, IDC_CREDMAN,
                                             CRM_GETUSERNAMELENGTH, 0, 0) > 0;
      if (fNameEntered)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
      }
      else
      {
         _dwWizButtons = PSWIZB_BACK;
      }

      PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);

      return TRUE;
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizCredPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizCredPage::OnSetActive(void)
{
   if (CredMgr().IsNewCall())
   {
      SetText();
   }

   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizCredPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizCredPage::Validate(void)
{
   DWORD dwErr = CredMgr().SaveCreds(GetDlgItem(GetPageHwnd(), IDC_CREDMAN));

   if (ERROR_SUCCESS != dwErr)
   {
      Wiz()->SetCreationResult(HRESULT_FROM_WIN32(dwErr));
      WizErr().SetErrorString2Hr(dwErr);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   // If successfull, go to the next function.

   dwErr = CredMgr().Impersonate();

   if (ERROR_SUCCESS != dwErr)
   {
      Wiz()->SetCreationResult(HRESULT_FROM_WIN32(dwErr));
      WizErr().SetErrorString2Hr(dwErr);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   // Because the login uses the LOGON32_LOGON_NEW_CREDENTIALS flag, no
   // attempt is made to use the credentials until a remote resource is
   // accessed. Thus, we don't yet know if the user entered credentials are
   // valid at this point. Use LsaOpenPolicy to do a quick check.
   //
   PCWSTR pwzDC = CredMgr().IsRemote() ? OtherDomain().GetUncDcName() :
                                         TrustPage()->GetUncDcName();
   CPolicyHandle Policy(pwzDC);

   if (CredMgr().IsAdmin())
   {
      dwErr = Policy.OpenReqAdmin();
   }
   else
   {
      dwErr = Policy.OpenNoAdmin();
   }

   if (ERROR_SUCCESS != dwErr)
   {
      Wiz()->SetCreationResult(HRESULT_FROM_WIN32(dwErr));
      WizErr().SetErrorString2Hr(dwErr);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   return CredMgr().InvokeNext();
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizMitOrWinPage
//
//  Purpose:   Domain not found, query for Non-Windows trust wizard page.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizMitOrWinPage::CTrustWizMitOrWinPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_WIN_OR_MIT_PAGE, IDS_TW_TYPE_TITLE,
                     IDS_TW_WINORMIT_SUBTITLE)
{
   TRACER(CTrustWizMitOrWinPage, CTrustWizMitOrWinPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizMitOrWinPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizMitOrWinPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizMitOrWinPage, OnInitDialog);
   CStrW strFormat, strLabel;

   // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
   strFormat.LoadString(g_hInstance, IDS_TW_WIN_RADIO_LABEL);

   strLabel.Format(strFormat, OtherDomain().GetUserEnteredName());

   SetDlgItemText(_hPage, IDC_WIN_TRUST_RADIO, strLabel);
   SetDlgItemText(_hPage, IDC_DOMAIN_EDIT, OtherDomain().GetUserEnteredName());

   CheckDlgButton(_hPage, IDC_MIT_TRUST_RADIO, BST_CHECKED);

   SetFocus(GetDlgItem(_hPage, IDC_MIT_TRUST_RADIO));

   EnableWindow(GetDlgItem(_hPage, IDC_DOMAIN_EDIT), FALSE);

   return FALSE; // focus is set explicitly here.
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizMitOrWinPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizMitOrWinPage::OnSetActive(void)
{
   if (IsDlgButtonChecked(_hPage, IDC_WIN_TRUST_RADIO))
   {
      BOOL fNameEntered = SendDlgItemMessage(_hPage, IDC_DOMAIN_EDIT,
                                             WM_GETTEXTLENGTH, 0, 0) > 0;
      if (fNameEntered)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
      }
      else
      {
         _dwWizButtons = PSWIZB_BACK;
      }

   }
   else
   {
      _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
   }

   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);

   // If the user backtracked, the user-entered domain name could have changed.
   //
   if (Wiz()->HaveBacktracked())
   {
      Wiz()->ClearBacktracked();

      CStrW strFormat, strLabel;

      // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
      strFormat.LoadString(g_hInstance, IDS_TW_WIN_RADIO_LABEL);

      strLabel.Format(strFormat, OtherDomain().GetUserEnteredName());

      SetDlgItemText(_hPage, IDC_WIN_TRUST_RADIO, strLabel);
      SetDlgItemText(_hPage, IDC_DOMAIN_EDIT, OtherDomain().GetUserEnteredName()); //Raid #368030, Yanggao
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizMitOrWinPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizMitOrWinPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   BOOL fCheckEdit = FALSE, fRet = FALSE;

   if (IDC_DOMAIN_EDIT == id && EN_CHANGE == codeNotify)
   {
      fCheckEdit = TRUE;
   }

   if ((IDC_WIN_TRUST_RADIO == id || IDC_MIT_TRUST_RADIO == id)
       && BN_CLICKED == codeNotify)
   {
      fCheckEdit = IsDlgButtonChecked(_hPage, IDC_WIN_TRUST_RADIO);

      EnableWindow(GetDlgItem(_hPage, IDC_DOMAIN_EDIT), fCheckEdit);

      if (!fCheckEdit)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;

         PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
      }

      fRet = TRUE;
   }

   if (fCheckEdit)
   {
      BOOL fNameEntered = SendDlgItemMessage(_hPage, IDC_DOMAIN_EDIT,
                                             WM_GETTEXTLENGTH, 0, 0) > 0;
      if (fNameEntered)
      {
         _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
      }
      else
      {
         _dwWizButtons = PSWIZB_BACK;
      }

      PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);

      fRet = TRUE;
   }

   return fRet;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizMitOrWinPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizMitOrWinPage::Validate(void)
{
   if (IsDlgButtonChecked(_hPage, IDC_MIT_TRUST_RADIO))
   {
      Trust().SetTrustTypeRealm();

      return IDD_TRUSTWIZ_TRANSITIVITY_PAGE;
   }
   else
   {
      WCHAR wzRemoteDomain[MAX_PATH + 1] = {0};
      CWaitCursor Wait;

      Trust().Clear();

      // NOTICE-2002/02/18-ericb - SecurityPush: wzRemoteDomain is initialized to
      // all zeros and is one char longer than the size passed to GetDlgItemText
      // so that even if this function truncates without null terminating, the
      // string will still be null terminated.
      GetDlgItemText(_hPage, IDC_DOMAIN_EDIT, wzRemoteDomain, MAX_PATH);

      OtherDomain().SetUserEnteredName(wzRemoteDomain);

      int iNextPage = Wiz()->CollectInfo();

      if (IDD_TRUSTWIZ_WIN_OR_MIT_PAGE == iNextPage)
      {
         // Only one chance to re-enter a domain name. Go to failure page.
         //
         Wiz()->SetCreationResult(E_FAIL);
         WizErr().SetErrorString1(IDS_ERR_DOMAIN_NOT_FOUND1);
         WizErr().SetErrorString2(IDS_ERR_DOMAIN_NOT_FOUND2);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
      return iNextPage;
   }
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizTransitivityPage
//
//  Purpose:   Realm transitivity page.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizTransitivityPage::CTrustWizTransitivityPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_TRANSITIVITY_PAGE, IDS_TW_TRANS_TITLE,
                     IDS_TW_TRANS_SUBTITLE)
{
   TRACER(CTrustWizTransitivityPage, CTrustWizTransitivityPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizTransitivityPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizTransitivityPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizTransitivityPage, OnInitDialog);
   CheckDlgButton(_hPage, IDC_TRANS_NO_RADIO, BST_CHECKED);
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizTransitivityPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizTransitivityPage::OnSetActive(void)
{
   _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizTransitivityPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizTransitivityPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if (IDC_HELP_BTN == id && BN_CLICKED == codeNotify)
   {
      ShowHelp(L"ADConcepts.chm::/ADHelpTransitivityOfTrust.htm");
      return true;
   }
   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizTransitivityPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizTransitivityPage::Validate(void)
{
   Trust().SetNewTrustAttr(IsDlgButtonChecked(_hPage, IDC_TRANS_NO_RADIO) ?
                           TRUST_ATTRIBUTE_NON_TRANSITIVE : 0);

   return IDD_TRUSTWIZ_DIRECTION_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizExternOrForestPage
//
//  Purpose:   Domain not found, re-enter name trust wizard page.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizExternOrForestPage::CTrustWizExternOrForestPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_EXTERN_OR_FOREST_PAGE, IDS_TW_TYPE_TITLE,
                     IDW_TW_EXORFOR_SUBTITLE)
{
   TRACER(CTrustWizExternOrForestPage, CTrustWizExternOrForestPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizExternOrForestPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizExternOrForestPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizExternOrForestPage, OnInitDialog);
   CheckDlgButton(_hPage, IDC_EXTERNAL_RADIO, BST_CHECKED);
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizExternOrForestPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizExternOrForestPage::OnSetActive(void)
{
   _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizExternOrForestPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizExternOrForestPage::Validate(void)
{
   Trust().SetXForest(IsDlgButtonChecked(_hPage, IDC_FOREST_RADIO) == BST_CHECKED);

   return IDD_TRUSTWIZ_DIRECTION_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizDirectionPage
//
//  Purpose:   Trust direction trust wizard page.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizDirectionPage::CTrustWizDirectionPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_DIRECTION_PAGE, IDS_TW_DIRECTION_TITLE,
                     IDS_TW_DIRECTION_SUBTITLE)
{
   TRACER(CTrustWizDirectionPage, CTrustWizDirectionPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDirectionPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizDirectionPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizDirectionPage, OnInitDialog);

   CheckDlgButton(_hPage, IDC_TW_BIDI_RADIO, BST_CHECKED);
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDirectionPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizDirectionPage::OnSetActive(void)
{
   _dwWizButtons = PSWIZB_BACK | PSWIZB_NEXT;
   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDirectionPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizDirectionPage::Validate(void)
{
   if (IsDlgButtonChecked(_hPage, IDC_TW_BIDI_RADIO))
   {
      Trust().SetNewTrustDirection(TRUST_DIRECTION_BIDIRECTIONAL);
   }
   else
   {
      if (IsDlgButtonChecked(_hPage, IDC_TW_OUTBOUND_RADIO))
      {
         Trust().SetNewTrustDirection(TRUST_DIRECTION_OUTBOUND);
      }
      else
      {
         Trust().SetNewTrustDirection(TRUST_DIRECTION_INBOUND);
      }
   }

   if (TRUST_TYPE_MIT == Trust().GetTrustType())
   {
      // Need a trust password to add the new direction of MIT trust.
      //
      return IDD_TRUSTWIZ_PASSWORD_PAGE;
   }
   else
   {
      if (OtherDomain().IsUplevel())
      {
         // Uplevel trusts/domains can do both sides, ask about that.
         //
         return IDD_TRUSTWIZ_SIDES_PAGE;
      }
      else
      {
         if (TRUST_DIRECTION_OUTBOUND & Trust().GetNewTrustDirection())
         {
            // It is a downlevel trust with an outbound component,
            // check if the user wants to set the other-org bit.
            //
            return IDD_TRUSTWIZ_ORGANIZATION_ATTR_PAGE;
         }
         else
         {
            // For an inbound-only downlevel trust nothing to do but get the pw.
            //
            return IDD_TRUSTWIZ_PASSWORD_PAGE;
         }
      }
   }
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizBiDiPage
//
//  Purpose:   Ask to make a one way trust bidi trust wizard page.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizBiDiPage::CTrustWizBiDiPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_BIDI_PAGE, IDS_TW_BIDI_TITLE,
                     IDS_TW_BIDI_SUBTITLE)
{
   TRACER(CTrustWizBiDiPage, CTrustWizBiDiPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizBiDiPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizBiDiPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizBiDiPage, OnInitDialog);

   // Set appropriate subtitle.
   //
   SetSubtitle();

   CheckDlgButton(_hPage, IDC_NO_RADIO, BST_CHECKED);

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizBiDiPage::SetSubtitle
//
//-----------------------------------------------------------------------------
void
CTrustWizBiDiPage::SetSubtitle(void)
{
   CStrW strTitle;

   if (TRUST_TYPE_MIT == Trust().GetTrustType())
   {
      // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
      strTitle.LoadString(g_hInstance, IDS_TW_BIDI_SUBTITLE_REALM);
      PropSheet_SetHeaderSubTitle(GetParent(GetPageHwnd()), 
                                  PropSheet_IdToIndex(GetParent(GetPageHwnd()), IDD_TRUSTWIZ_BIDI_PAGE),
                                  strTitle.GetBuffer(0));
   }

   if (Trust().GetTrustAttr() & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
   {
      strTitle.LoadString(g_hInstance, IDS_TW_BIDI_SUBTITLE_FOREST);
      PropSheet_SetHeaderSubTitle(GetParent(GetPageHwnd()), 
                                  PropSheet_IdToIndex(GetParent(GetPageHwnd()), IDD_TRUSTWIZ_BIDI_PAGE),
                                  strTitle.GetBuffer(0));
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizBiDiPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizBiDiPage::OnSetActive(void)
{
   // If the user backtracked, the trust type could have changed.
   //
   if (Wiz()->HaveBacktracked())
   {
      Wiz()->ClearBacktracked();

      SetSubtitle();
   }

   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_BACK | PSWIZB_NEXT);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizBiDiPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizBiDiPage::Validate(void)
{
   if (IsDlgButtonChecked(_hPage, IDC_YES_RADIO))
   {
      Trust().SetNewTrustDirection(TRUST_DIRECTION_BIDIRECTIONAL);

      if (TRUST_TYPE_MIT == Trust().GetTrustType())
      {
         // Need a trust password to add the new direction of MIT trust.
         //
         return IDD_TRUSTWIZ_PASSWORD_PAGE;
      }
      else
      {
         if (OtherDomain().IsUplevel())
         {
            // See if the user wants to create both sides of the trust.
            //
            return IDD_TRUSTWIZ_SIDES_PAGE;
         }
         else
         {
            if (TRUST_DIRECTION_INBOUND == Trust().GetTrustDirection())
            {
               // Old direction is inbound, so adding outbound to a downlevel
               // trust, check if the user wants to set the other-org bit.
               //
               return IDD_TRUSTWIZ_ORGANIZATION_ATTR_PAGE;
            }
            else
            {
               // If an inbound-only downlevel trust, get the password.
               //
               return IDD_TRUSTWIZ_PASSWORD_PAGE;
            }
         }
      }
   }
   WizErr().SetErrorString1(IDS_TWERR_ALREADY_EXISTS);
   WizErr().SetErrorString2(IDS_TWERR_NO_CHANGES);
   Wiz()->SetCreationResult(E_FAIL);
   return IDD_TRUSTWIZ_FAILURE_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizOrganizationPage
//
//  Purpose:   Ask if the trust partner is part of the same organization.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizOrganizationPage::CTrustWizOrganizationPage(CNewTrustWizard * pWiz) :
   _fForest(false),
   _fBackTracked(false),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_ORGANIZATION_ATTR_PAGE,
                     IDS_ORGANIZATION_PAGE_TITLE,
                     IDS_ORG_PAGE_FOREST_SUBTITLE)
{
   TRACER(CTrustWizOrganizationPage, CTrustWizOrganizationPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizOrganizationPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizOrganizationPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizOrganizationPage, OnInitDialog);

   // Set appropriate page text.
   //
   SetText();

   CheckDlgButton(_hPage, IDC_MY_ORG_RADIO, BST_CHECKED);

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizOrganizationPage::SetText
//
//-----------------------------------------------------------------------------
void
CTrustWizOrganizationPage::SetText(bool fBackTracked)
{
   CStrW strText, strFormat;

   if (Trust().IsCreateBothSides())
   {
      // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
      strText.LoadString(g_hInstance,
                         Trust().IsXForest() ?
                           IDS_ORG_LOCAL_PAGE_TITLE : IDS_ORG_LOCAL_PAGE_TITLE_D);
      PropSheet_SetHeaderTitle(GetParent(GetPageHwnd()), 
                               PropSheet_IdToIndex(GetParent(GetPageHwnd()), IDD_TRUSTWIZ_ORGANIZATION_ATTR_PAGE),
                               strText.GetBuffer(0));
   }
   else
   {
      if (fBackTracked)
      {
         strText.LoadString(g_hInstance, IDS_ORGANIZATION_PAGE_TITLE);
         PropSheet_SetHeaderTitle(GetParent(GetPageHwnd()), 
                                  PropSheet_IdToIndex(GetParent(GetPageHwnd()), IDD_TRUSTWIZ_ORGANIZATION_ATTR_PAGE),
                                  strText.GetBuffer(0));
      }
   }

   if (fBackTracked && (Trust().IsXForest() == _fForest))
   {
      // The trust type didn't change while backtracking, so no need to
      // change the button labels. However, make sure the domain name is correct.
      //
      strFormat.LoadString(g_hInstance, 
                           Trust().IsXForest() ? IDS_TW_ORG_LOCAL_FOREST_LABEL :
                                                 IDS_TW_ORG_LOCAL_DOMAIN_LABEL);
      strText.Format(strFormat, OtherDomain().GetUserEnteredName());
      SetDlgItemText(_hPage, IDC_ORG_LABEL, strText.GetBuffer(0));
      return;
   }

   if (!Trust().IsXForest())
   {
      strText.LoadString(g_hInstance, IDS_ORG_PAGE_DOMAIN_SUBTITLE);
      PropSheet_SetHeaderSubTitle(GetParent(GetPageHwnd()), 
                                  PropSheet_IdToIndex(GetParent(GetPageHwnd()), IDD_TRUSTWIZ_ORGANIZATION_ATTR_PAGE),
                                  strText.GetBuffer(0));
   }

   strFormat.LoadString(g_hInstance, 
                        Trust().IsXForest() ? IDS_TW_ORG_LOCAL_FOREST_LABEL :
                                              IDS_TW_ORG_LOCAL_DOMAIN_LABEL);
   strText.Format(strFormat, OtherDomain().GetUserEnteredName());
   SetDlgItemText(_hPage, IDC_ORG_LABEL, strText.GetBuffer(0));

   strText.LoadString(g_hInstance, 
                      Trust().IsXForest() ? IDS_TW_ORG_LOCAL_FOREST_THIS :
                                            IDS_TW_ORG_LOCAL_DOMAIN_THIS);
   SetDlgItemText(_hPage, IDC_MY_ORG_RADIO, strText.GetBuffer(0));

   strText.LoadString(g_hInstance, 
                      Trust().IsXForest() ? IDS_TW_ORG_LOCAL_FOREST_OTHER:
                                            IDS_TW_ORG_LOCAL_DOMAIN_OTHER);
   SetDlgItemText(_hPage, IDC_OTHER_ORG_RADIO, strText.GetBuffer(0));

   _fForest = Trust().IsXForest();
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizOrganizationPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizOrganizationPage::OnSetActive(void)
{
   // If the user backtracked, the trust type could have changed.
   //
   if (_fBackTracked)
   {
      SetText(true);
      _fBackTracked = false;
   }
   if (Wiz()->HaveBacktracked())
   {
      Wiz()->ClearBacktracked();
      _fBackTracked = true;
   }

   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_BACK | PSWIZB_NEXT);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizOrganizationPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizOrganizationPage::Validate(void)
{
   DWORD dwAttr = Trust().GetNewTrustAttr();

   if (IsDlgButtonChecked(_hPage, IDC_OTHER_ORG_RADIO))
   {
      Trust().SetNewTrustAttr(dwAttr | TRUST_ATTRIBUTE_CROSS_ORGANIZATION);
   }
   else
   {
      Trust().SetNewTrustAttr(dwAttr & ~(TRUST_ATTRIBUTE_CROSS_ORGANIZATION));
   }

   if (Trust().IsCreateBothSides())
   {
      UINT ulDomainVer = 0;
      DWORD dwErr = CredMgr().ImpersonateRemote();

      if (NO_ERROR != dwErr)
      {
         WizErr().SetErrorString1(IDS_ERR_CREATE_BAD_CREDS);
         WizErr().SetErrorString2Hr(dwErr);
         Wiz()->SetCreationResult(HRESULT_FROM_WIN32(dwErr));
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      HRESULT hr = OtherDomain().GetDomainVersion(_hPage, &ulDomainVer);

      CredMgr().Revert();

      if (FAILED(hr))
      {
         WizErr().SetErrorString2Hr(hr);
         Wiz()->SetCreationResult(hr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      if (!Trust().Exists() &&
          TRUST_DIRECTION_INBOUND & Trust().GetNewTrustDirection() &&
          ulDomainVer >= DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
      {
         // The remote side is outbound, so ask about that.
         //
         return IDD_TRUSTWIZ_ORG_ATTR_REMOTE_PAGE;
      }
      else
      {
         return IDD_TRUSTWIZ_SELECTIONS;
      }
   }
   else
   {
      // Need a trust password to add the new direction of trust.
      //
      return IDD_TRUSTWIZ_PASSWORD_PAGE;
   }
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizOrgRemotePage
//
//  Purpose:   Ask if the trust partner is part of the same organization.
//             This page is posted if creating both sides and the remote side
//             has an outbound component.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizOrgRemotePage::CTrustWizOrgRemotePage(CNewTrustWizard * pWiz) :
   _fForest(false),
   _fBackTracked(false),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_ORG_ATTR_REMOTE_PAGE,
                     IDS_ORG_REMOTE_PAGE_TITLE,
                     IDS_ORG_REMOTE_PAGE_FOREST_SUBTITLE)
{
   TRACER(CTrustWizOrgRemotePage, CTrustWizOrgRemotePage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizOrgRemotePage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizOrgRemotePage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizOrgRemotePage, OnInitDialog);

   // Set appropriate page text.
   //
   SetText();

   CheckDlgButton(_hPage, IDC_MY_ORG_RADIO, BST_CHECKED);

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizOrgRemotePage::SetText
//
//-----------------------------------------------------------------------------
void
CTrustWizOrgRemotePage::SetText(bool fBackTracked)
{
   CStrW strText, strFormat;

   strFormat.LoadString(g_hInstance, 
                        Trust().IsXForest() ? IDS_TW_ORG_REMOTE_FOREST_THIS :
                                              IDS_TW_ORG_REMOTE_DOMAIN_THIS);
   strText.Format(strFormat, OtherDomain().GetUserEnteredName());
   SetDlgItemText(_hPage, IDC_MY_ORG_RADIO, strText.GetBuffer(0));

   strFormat.LoadString(g_hInstance, 
                        Trust().IsXForest() ? IDS_TW_ORG_REMOTE_FOREST_OTHER:
                                              IDS_TW_ORG_REMOTE_DOMAIN_OTHER);
   strText.Format(strFormat, OtherDomain().GetUserEnteredName());
   SetDlgItemText(_hPage, IDC_OTHER_ORG_RADIO, strText.GetBuffer(0));

   if (fBackTracked && (Trust().IsXForest() == _fForest))
   {
      // The trust type didn't change while backtracking, so no need to
      // change the other labels.
      //
      return;
   }

   if (!Trust().IsXForest())
   {
      strText.LoadString(g_hInstance, IDS_ORG_REMOTE_PAGE_TITLE_D);
      PropSheet_SetHeaderTitle(GetParent(GetPageHwnd()), 
                               PropSheet_IdToIndex(GetParent(GetPageHwnd()),
                                                   IDD_TRUSTWIZ_ORG_ATTR_REMOTE_PAGE),
                               strText.GetBuffer(0));
      strText.LoadString(g_hInstance, IDS_ORG_REMOTE_PAGE_DOMAIN_SUBTITLE);
      PropSheet_SetHeaderSubTitle(GetParent(GetPageHwnd()), 
                                  PropSheet_IdToIndex(GetParent(GetPageHwnd()),
                                                      IDD_TRUSTWIZ_ORG_ATTR_REMOTE_PAGE),
                                  strText.GetBuffer(0));
   }
   else if (fBackTracked)
   {
      strText.LoadString(g_hInstance, IDS_ORG_REMOTE_PAGE_TITLE);
      PropSheet_SetHeaderTitle(GetParent(GetPageHwnd()), 
                               PropSheet_IdToIndex(GetParent(GetPageHwnd()),
                                                   IDD_TRUSTWIZ_ORG_ATTR_REMOTE_PAGE),
                               strText.GetBuffer(0));
      strText.LoadString(g_hInstance, IDS_ORG_REMOTE_PAGE_FOREST_SUBTITLE);
      PropSheet_SetHeaderSubTitle(GetParent(GetPageHwnd()), 
                                  PropSheet_IdToIndex(GetParent(GetPageHwnd()),
                                                      IDD_TRUSTWIZ_ORG_ATTR_REMOTE_PAGE),
                                  strText.GetBuffer(0));
   }

   strText.LoadString(g_hInstance, 
                      Trust().IsXForest() ? IDS_TW_ORG_REMOTE_FOREST_LABEL :
                                            IDS_TW_ORG_REMOTE_DOMAIN_LABEL);
   SetDlgItemText(_hPage, IDC_ORG_LABEL, strText.GetBuffer(0));

   _fForest = Trust().IsXForest();
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizOrgRemotePage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizOrgRemotePage::OnSetActive(void)
{
   // If the user backtracked, the trust type could have changed.
   //
   if (_fBackTracked)
   {
      SetText(true);
      _fBackTracked = false;
   }
   if (Wiz()->HaveBacktracked())
   {
      Wiz()->ClearBacktracked();
      _fBackTracked = true;
   }

   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_BACK | PSWIZB_NEXT);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizOrgRemotePage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizOrgRemotePage::Validate(void)
{
   OtherDomain().SetOtherOrgBit(IsDlgButtonChecked(_hPage, IDC_OTHER_ORG_RADIO) != 0);

   return IDD_TRUSTWIZ_SELECTIONS;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizSelectionsPage
//
//  Purpose:   Show the settings that will be used for the trust.
//             When called, enough information has been gathered to create
//             the trust. All of this info is in the Trust member object.
//             Display the info to the user via the Selections page and ask
//             implicitly for confirmation by requiring that the Next button
//             be pressed to have the trust created.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizSelectionsPage::CTrustWizSelectionsPage(CNewTrustWizard * pWiz) :
   _fSelNeedsRemoving(FALSE),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_SELECTIONS, IDS_TW_SELECTIONS_TITLE,
                     IDS_TW_SELECTIONS_SUBTITLE)
{
   TRACER(CTrustWizSelectionsPage, CTrustWizSelectionsPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSelectionsPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizSelectionsPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizSelectionsPage, OnInitDialog);

   _multiLineEdit.Init(GetDlgItem(_hPage, IDC_EDIT));

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSelectionsPage::SetSelections
//
//-----------------------------------------------------------------------------
void
CTrustWizSelectionsPage::SetSelections(void)
{
   CStrW strMsg, strItem;

   // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
   strMsg.LoadString(g_hInstance, IDS_TW_THIS_DOMAIN);
   strMsg += TrustPage()->GetDnsDomainName();

   strItem.LoadString(g_hInstance, IDS_TW_SPECIFIED_DOMAIN);
   strItem += OtherDomain().GetUserEnteredName();

   strMsg += g_wzCRLF;
   strMsg += strItem;
   strMsg += g_wzCRLF;

   int nTypeID = 0, nTransID = 0;

   if (Trust().Exists())
   {
      strMsg += g_wzCRLF;
      strItem.LoadString(g_hInstance, IDS_TW_SELECTION_EXISTS);
      strMsg += strItem;
      strMsg += g_wzCRLF;
      strMsg += g_wzCRLF;

      strItem.LoadString(g_hInstance, IDS_TW_DIRECTION_PREFIX);
      strMsg += strItem;
      strMsg += g_wzCRLF;

      strItem.LoadString(g_hInstance,
                         Trust().GetTrustDirStrID(Trust().GetTrustDirection()));
      strMsg += strItem;
      strMsg += g_wzCRLF;
      strMsg += g_wzCRLF;

      if (Trust().GetTrustAttr() & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
      {
         strItem.LoadString(g_hInstance, IDS_TW_ATTR_XFOREST);
         strMsg += g_wzCRLF;
         strMsg += strItem;
      }
      // Trust type and attribute
      //
      strItem.LoadString(g_hInstance, IDS_TW_TRUST_TYPE_PREFIX);
      strMsg += strItem;

      if (TRUST_TYPE_MIT == Trust().GetTrustType())
      {
         nTypeID = IDS_REL_MIT;
         nTransID = (Trust().GetTrustAttr() & TRUST_ATTRIBUTE_NON_TRANSITIVE) ?
                        IDS_WZ_TRANS_NO : IDS_WZ_TRANS_YES;
      }
      else
      {
         if (Trust().IsExternal())
         {
            nTypeID = IDS_REL_EXTERNAL;
            nTransID = IDS_WZ_TRANS_NO;

            if (Trust().GetTrustAttr() & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
            {
               nTransID = IDS_WZ_TRANS_YES;
               nTypeID = IDS_TW_ATTR_XFOREST;
            }
         }
         else
         {
            nTransID = IDS_WZ_TRANS_YES;
            nTypeID = IDS_REL_CROSSLINK;
         }
      }
      strItem.LoadString(g_hInstance, nTypeID);
      strMsg += strItem;
      strMsg += g_wzCRLF;

      strMsg += g_wzCRLF;
      strItem.LoadString(g_hInstance, nTransID);
      strMsg += strItem;
      strMsg += g_wzCRLF;

      if (IDS_REL_CROSSLINK != nTypeID &&
          IDS_REL_MIT != nTypeID)
      {
         // My org/other org. Doesn't apply to shortcuts or realm.
         //
         GetOrgText(false,
                    Trust().IsXForest(),
                    (Trust().GetTrustAttr() & TRUST_ATTRIBUTE_CROSS_ORGANIZATION) != 0,
                    false,
                    Trust().GetTrustDirection(),
                    strMsg);
      }

      strMsg += g_wzCRLF;
      strItem.LoadString(g_hInstance, IDS_TW_SEL_ACTION);
      strMsg += strItem;
      strMsg += g_wzCRLF;
   }
   strMsg += g_wzCRLF;
   
   strItem.LoadString(g_hInstance, IDS_TW_DIRECTION_PREFIX);
   strMsg += strItem;
   strMsg += g_wzCRLF;

   strItem.LoadString(g_hInstance,
                      Trust().GetTrustDirStrID(Trust().GetNewTrustDirection()));
   strMsg += strItem;
   strMsg += g_wzCRLF;
   strMsg += g_wzCRLF;

   // Trust type and attribute
   //
   strItem.LoadString(g_hInstance, IDS_TW_TRUST_TYPE_PREFIX);
   strMsg += strItem;

   if (TRUST_TYPE_MIT == Trust().GetTrustType())
   {
      nTypeID = IDS_REL_MIT;
      nTransID = (Trust().GetNewTrustAttr() & TRUST_ATTRIBUTE_NON_TRANSITIVE) ?
                     IDS_WZ_TRANS_NO : IDS_WZ_TRANS_YES;
   }
   else
   {
      if (Trust().IsExternal())
      {
         nTypeID = IDS_REL_EXTERNAL;
         nTransID = IDS_WZ_TRANS_NO;

         if (Trust().GetNewTrustAttr() & TRUST_ATTRIBUTE_FOREST_TRANSITIVE)
         {
            nTransID = IDS_WZ_TRANS_YES;
            nTypeID = IDS_TW_ATTR_XFOREST;
         }
      }
      else
      {
         nTransID = IDS_WZ_TRANS_YES;
         nTypeID = IDS_REL_CROSSLINK;
      }
   }
   strItem.LoadString(g_hInstance, nTypeID);
   strMsg += strItem;
   strMsg += g_wzCRLF;

   strMsg += g_wzCRLF;
   strItem.LoadString(g_hInstance, nTransID);
   strMsg += strItem;
   strMsg += g_wzCRLF;

   if (IDS_REL_CROSSLINK != nTypeID &&
       IDS_REL_MIT != nTypeID)
   {
      // My org/other org. Doesn't apply to shortcuts or realm.
      //
      GetOrgText(Trust().IsCreateBothSides(),
                 Trust().IsXForest(),
                 (Trust().GetNewTrustAttr() & TRUST_ATTRIBUTE_CROSS_ORGANIZATION) != 0,
                 OtherDomain().IsSetOtherOrgBit(),
                 Trust().GetNewTrustDirection(),
                 strMsg);
   }

   strMsg += g_wzCRLF;

   strItem.LoadString(g_hInstance,
                      Trust().IsCreateBothSides() ?
                        IDS_TW_SELECTIONS_BOTH_SIDES :
                        IDS_TW_SELECTIONS_THIS_SIDE_ONLY);
   strMsg += strItem;
   strMsg += g_wzCRLF;

   SetWindowText(GetDlgItem(_hPage, IDC_EDIT), strMsg);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSelectionsPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizSelectionsPage::OnSetActive(void)
{
   SetSelections();

   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_BACK | PSWIZB_NEXT);
   _fSelNeedsRemoving = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSelectionsPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizSelectionsPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   switch (id)
   {
   case IDC_EDIT:
      switch (codeNotify)
      {
      case EN_SETFOCUS:
         if (_fSelNeedsRemoving)
         {
            // remove the selection.
            //
            SendDlgItemMessage(_hPage, IDC_EDIT, EM_SETSEL, 0, 0);
            _fSelNeedsRemoving = FALSE;
            return false;
         }
         break;

      case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
         {
            // our subclasses mutli-line edit control will send us
            // WM_COMMAND messages when the enter key is pressed.  We
            // reinterpret this message as a press on the default button of
            // the prop sheet.
            // This workaround from phellyar. NTRAID#NTBUG9-225773

            HWND propSheet = GetParent(_hPage);
            WORD defaultButtonId =
               LOWORD(SendMessage(propSheet, DM_GETDEFID, 0, 0));

            // we expect that there is always a default button on the prop sheet

            dspAssert(defaultButtonId);

            SendMessage(propSheet,
                        WM_COMMAND,
                        MAKELONG(defaultButtonId, BN_CLICKED),
                        0);
         }
         break;
      }
      break;

   case IDCANCEL:
      //
      // ESC gets trapped by the read-only edit control. Forward to the frame.
      //
      SendMessage(GetParent(_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                  LPARAM(hwndCtrl));

      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSelectionsPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizSelectionsPage::Validate(void)
{
   // Now create/modify the trust.
   //

   int nNextPage;

   CWaitCursor Wait;
   CStrW strMsg;
   // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
   strMsg.LoadString(g_hInstance, IDS_WZ_PROGRESS_MSG);
   SetDlgItemText(_hPage, IDC_WZ_PROGRESS_MSG, strMsg);

   nNextPage = Wiz()->CreateOrUpdateTrust();

   return nNextPage;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizVerifyOutboundPage
//
//  Purpose:   Ask to confirm the new outbound trust.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizVerifyOutboundPage::CTrustWizVerifyOutboundPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_VERIFY_OUTBOUND_PAGE,
                     IDS_TW_VERIFY_OUTBOUND_TITLE,
                     IDS_TW_VERIFY_SUBTITLE)
{
   TRACER(CTrustWizVerifyOutboundPage, CTrustWizVerifyOutboundPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyOutboundPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizVerifyOutboundPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizVerifyOutboundPage, OnInitDialog);
   CWaitCursor Wait;

   CheckDlgButton(_hPage, IDC_NO_RADIO, BST_CHECKED);

   _dwWizButtons = PSWIZB_NEXT;

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyOutboundPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizVerifyOutboundPage::OnSetActive(void)
{
   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_NEXT);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyOutboundPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizVerifyOutboundPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   if ((IDC_YES_RADIO == id || IDC_NO_RADIO == id) && BN_CLICKED == codeNotify)
   {
      if (IsDlgButtonChecked(_hPage, IDC_YES_RADIO))
      {
         ShowWindow(GetDlgItem(_hPage, IDC_CONFIRM_NEXT_HINT), SW_SHOW);
      }
      else
      {
         ShowWindow(GetDlgItem(_hPage, IDC_CONFIRM_NEXT_HINT), SW_HIDE);
      }
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyOutboundPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizVerifyOutboundPage::Validate(void)
{
   CWaitCursor Wait;
   DWORD dwErr = NO_ERROR;
   int nRet = 0;

   if (IsDlgButtonChecked(_hPage, IDC_YES_RADIO))
   {
      //Result of the Verification is stored in the Wizard object
      Wiz()->VerifyOutboundTrust();

      if (Trust().GetNewTrustDirection() & TRUST_DIRECTION_INBOUND)
      {
         // Now do the inbound side.
         //
         return IDD_TRUSTWIZ_VERIFY_INBOUND_PAGE;
      }

      if (!VerifyTrust().IsVerifiedOK() && Trust().IsXForest())
      {
         // The verification failed; put default FTInfos on the TDOs anyway.
         //
         CStrW strErr;

         nRet = Wiz()->CreateDefaultFTInfos(strErr, true);

         if (nRet)
         {
            VerifyTrust().AddExtra(strErr);
         }

         return IDD_TRUSTWIZ_COMPLETE_VER_ERR_PAGE;
      }

      if (Trust().IsXForest())
      {
         bool fCredErr = false;

         // Read the names claimed by the remote forest and save them on the
         // local TDO.
         //
         dwErr = Trust().ReadFTInfo(TrustPage()->GetUncDcName(),
                                    OtherDomain().GetDcName(),
                                    CredMgr(), WizErr(), fCredErr);
         if (NO_ERROR != dwErr)
         {
            if (fCredErr)
            {
               // If fCredErr is true, then the return code is the error page
               // ID and the error strings have already been set.
               //
               return dwErr;
            }
            else
            {
               REPORT_ERROR_FORMAT(dwErr, IDS_ERR_READ_FTINFO, _hPage);
            }
         }

         if (Trust().IsCreateBothSides())
         {
            // Read the names claimed by the local forest and save them on the
            // remote TDO.
            //
            dwErr = OtherDomain().ReadFTInfo(Trust().GetNewTrustDirection(),
                                             TrustPage()->GetUncDcName(),
                                             CredMgr(), WizErr(), fCredErr);
            if (NO_ERROR != dwErr)
            {
               if (fCredErr)
               {
                  // If fCredErr is true, then the return code is the error page
                  // ID and the error strings have already been set.
                  //
                  return dwErr;
               }
               else
               {
                  REPORT_ERROR_FORMAT(dwErr, IDS_ERR_READ_FTINFO, _hPage);
               }
            }
         }

         if (Trust().GetFTInfo().GetTLNCount() > 1)
         {
            // The forest root TLN is always enabled. If there are any other
            // TLNs, then show them to the user for approval.
            //
            return IDD_TRUSTWIZ_SUFFIX_FOR_LOCAL_PAGE;
         }
         else if (Trust().IsCreateBothSides() &&
                  OtherDomain().GetFTInfo().GetTLNCount() > 1)
         {
            // The forest root TLN is always enabled. If there are any other
            // TLNs claimed by the local forest, then show them to the user
            // for approval.
            //
            return IDD_TRUSTWIZ_SUFFIX_FOR_REMOTE_PAGE;
         }
      }
   }
   else
   {
      if (TRUST_DIRECTION_OUTBOUND == Trust().GetNewTrustDirection() &&
          Trust().IsXForest())
      {
         // Trust is one way and the user opted to not to verify; put
         // default FTInfos on the TDOs.
         //
         CStrW str;

         nRet = Wiz()->CreateDefaultFTInfos(str);

         if (nRet)
         {
            return nRet;
         }
      }
   }

   if (Trust().GetNewTrustDirection() & TRUST_DIRECTION_INBOUND)
       return IDD_TRUSTWIZ_VERIFY_INBOUND_PAGE;
   else
       return ( VerifyTrust().IsVerifiedOK () ) ?
            IDD_TRUSTWIZ_COMPLETE_OK_PAGE : 
            IDD_TRUSTWIZ_COMPLETE_VER_ERR_PAGE
            ;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizVerifyInboundPage
//
//  Purpose:   Ask to confirm the new inbound trust.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizVerifyInboundPage::CTrustWizVerifyInboundPage(CNewTrustWizard * pWiz) :
   _fNeedCreds(FALSE),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_VERIFY_INBOUND_PAGE,
                     IDS_TW_VERIFY_INBOUND_TITLE,
                     IDS_TW_VERIFY_SUBTITLE)
{
   TRACER(CTrustWizVerifyInboundPage, CTrustWizVerifyInboundPage);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyInboundPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizVerifyInboundPage::OnInitDialog(LPARAM lParam)
{
   TRACER(CTrustWizVerifyInboundPage, OnInitDialog);
   CWaitCursor Wait;

   CheckDlgButton(_hPage, IDC_NO_RADIO, BST_CHECKED);

   _dwWizButtons = PSWIZB_NEXT;

   // Determine if creds are needed. If local creds had been required, the
   // user would have been prompted to supply them before the trust was created.
   // Thus this check is for remote access.
   //
   // The check for inbound trust is remoted to the other domain. See
   // if we have access by trying to open the remote LSA.
   //
   CPolicyHandle Pol(OtherDomain().GetUncDcName());

   DWORD dwRet = Pol.OpenReqAdmin();

   if (ERROR_ACCESS_DENIED == dwRet)
   {
      if (CredMgr().IsRemoteSet())
      {
         dwRet = CredMgr().ImpersonateRemote();

         if (NO_ERROR == dwRet)
         {
            dwRet = Pol.OpenReqAdmin();

            if (ERROR_ACCESS_DENIED == dwRet)
            {
               // Creds aren't good enough, need to get them.
               //
               _fNeedCreds = TRUE;
            }
         }
      }
      else
      {
         _fNeedCreds = TRUE;
      }
   }

   if (_fNeedCreds)
   {
      HWND hPrompt = GetDlgItem(_hPage, IDC_TW_CREDS_PROMPT);
      FormatWindowText(hPrompt, OtherDomain().GetUserEnteredName());
      ShowWindow(hPrompt, SW_SHOW);
      EnableWindow(hPrompt, FALSE);
      HWND hCred = GetDlgItem(_hPage, IDC_CREDMAN);
      SendMessage(hCred, CRM_SETUSERNAMEMAX, CREDUI_MAX_USERNAME_LENGTH, 0);
      SendMessage(hCred, CRM_SETPASSWORDMAX, CREDUI_MAX_PASSWORD_LENGTH, 0);
      ShowWindow(hCred, SW_SHOW);
      EnableWindow(hCred, FALSE);
   }
   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyInboundPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizVerifyInboundPage::OnSetActive(void)
{
   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyInboundPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizVerifyInboundPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
   BOOL fCheckName = FALSE, fSetWizButtons = FALSE;

   if ((IDC_YES_RADIO == id || IDC_NO_RADIO == id) && BN_CLICKED == codeNotify)
   {
      fSetWizButtons = TRUE;

      if (IsDlgButtonChecked(_hPage, IDC_YES_RADIO))
      {
         if (_fNeedCreds)
         {
            EnableWindow(GetDlgItem(_hPage, IDC_TW_CREDS_PROMPT), TRUE);
            EnableWindow(GetDlgItem(_hPage, IDC_CREDMAN), TRUE);

            fCheckName = TRUE;
         }
         else
         {
            ShowWindow(GetDlgItem(_hPage, IDC_CONFIRM_NEXT_HINT), SW_SHOW);
         }
      }
      else
      {
         if (_fNeedCreds)
         {
            EnableWindow(GetDlgItem(_hPage, IDC_TW_CREDS_PROMPT), FALSE);
            EnableWindow(GetDlgItem(_hPage, IDC_CREDMAN), FALSE);

            _dwWizButtons = PSWIZB_NEXT;
         }

         ShowWindow(GetDlgItem(_hPage, IDC_CONFIRM_NEXT_HINT), SW_HIDE);
      }
   }

   if (IDC_CREDMAN == id && CRN_USERNAMECHANGE == codeNotify)
   {
      fCheckName = TRUE;
      fSetWizButtons = TRUE;
   }

   if (fCheckName)
   {
      if (SendDlgItemMessage(_hPage, IDC_CREDMAN,
                             CRM_GETUSERNAMELENGTH, 0, 0) > 0)
      {
         _dwWizButtons = PSWIZB_NEXT;
         ShowWindow(GetDlgItem(_hPage, IDC_CONFIRM_NEXT_HINT), SW_SHOW);
      }
      else
      {
         _dwWizButtons = 0;
         ShowWindow(GetDlgItem(_hPage, IDC_CONFIRM_NEXT_HINT), SW_HIDE);
      }
   }

   if (fSetWizButtons)
   {
      PropSheet_SetWizButtons(GetParent(_hPage), _dwWizButtons);
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizVerifyInboundPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizVerifyInboundPage::Validate(void)
{
   CWaitCursor Wait;
   DWORD dwErr = NO_ERROR;
   int nRet = 0;

   if (IsDlgButtonChecked(_hPage, IDC_YES_RADIO))
   {
      if (_fNeedCreds)
      {
         CredMgr().DoRemote();
         CredMgr().SetDomain(OtherDomain().GetUserEnteredName());

         dwErr = CredMgr().SaveCreds(GetDlgItem(GetPageHwnd(), IDC_CREDMAN));

         if (ERROR_SUCCESS != dwErr)
         {
            WizErr().SetErrorString1(IDS_ERR_CANT_VERIFY_CREDS);
            WizErr().SetErrorString2Hr(dwErr);
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
      }

      Wiz()->VerifyInboundTrust();

      if (!VerifyTrust().IsVerifiedOK() && Trust().IsXForest())
      {
         // The verification failed; put default FTInfos on the TDOs anyway.
         //
         CStrW strErr;

         nRet = Wiz()->CreateDefaultFTInfos(strErr, true);

         if (nRet)
         {
            VerifyTrust().AddExtra(strErr);
         }

         return IDD_TRUSTWIZ_COMPLETE_VER_ERR_PAGE;
      }

      if (Trust().IsXForest())
      {
         bool fCredErr = false;

         // Read the names claimed by the remote forest and save them on the
         // local TDO.
         //
         dwErr = Trust().ReadFTInfo(TrustPage()->GetUncDcName(),
                                    OtherDomain().GetDcName(),
                                    CredMgr(), WizErr(), fCredErr);
         if (NO_ERROR != dwErr)
         {
            if (fCredErr)
            {
               // If fCredErr is true, then the return code is the error page
               // ID and the error strings have already been set.
               //
               return dwErr;
            }
            else
            {
               REPORT_ERROR_FORMAT(dwErr, IDS_ERR_READ_FTINFO, _hPage);
            }
         }

         if (Trust().IsCreateBothSides())
         {
            // Read the names claimed by the local forest and save them on the
            // remote TDO.
            //
            dwErr = OtherDomain().ReadFTInfo(Trust().GetNewTrustDirection(),
                                             TrustPage()->GetUncDcName(),
                                             CredMgr(), WizErr(), fCredErr);
            if (NO_ERROR != dwErr)
            {
               if (fCredErr)
               {
                  // If fCredErr is true, then the return code is the error page
                  // ID and the error strings have already been set.
                  //
                  return dwErr;
               }
               else
               {
                  REPORT_ERROR_FORMAT(dwErr, IDS_ERR_READ_FTINFO, _hPage);
               }
            }
         }

         if (Trust().GetFTInfo().GetTLNCount() > 1)
         {
            // The forest root TLN is always enabled. If there are any other
            // TLNs claimed by the remote forest, then show them to the user
            // for approval.
            //
            return IDD_TRUSTWIZ_SUFFIX_FOR_LOCAL_PAGE;
         }
         else if (Trust().IsCreateBothSides() &&
                  OtherDomain().GetFTInfo().GetTLNCount() > 1)
         {
            // The forest root TLN is always enabled. If there are any other
            // TLNs claimed by the local forest, then show them to the user
            // for approval.
            //
            return IDD_TRUSTWIZ_SUFFIX_FOR_REMOTE_PAGE;
         }
      }
   }
   else 
   {
       // The user opted to not to verify
       // If we had performed ImpersonateRemote for verification,
       // revert it.
       CredMgr().Revert ();
       if (Trust().IsXForest())
       {
            //put default FTInfos on the TDOs.
            //
            CStrW str;

            nRet = Wiz()->CreateDefaultFTInfos(str);

            if (nRet)
            {
                return nRet;
            }
       }
   }

   if (!VerifyTrust().IsVerifiedOK())
   {
      // The outbound verification failed.
      //
      return IDD_TRUSTWIZ_COMPLETE_VER_ERR_PAGE;
   }

   return IDD_TRUSTWIZ_COMPLETE_OK_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizStatusPage
//
//  Purpose:   Forest trust has been created and verified, show the status.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizStatusPage::CTrustWizStatusPage(CNewTrustWizard * pWiz) :
   _fSelNeedsRemoving(FALSE),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_STATUS_PAGE, IDS_TW_STATUS_TITLE,
                     IDS_TW_STATUS_SUBTITLE)
{
   TRACER(CTrustWizStatusPage, CTrustWizStatusPage)
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizStatusPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizStatusPage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_COMPLETING);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   _multiLineEdit.Init(GetDlgItem(_hPage, IDC_EDIT));

   CStrW strMsg;

   // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
   strMsg.LoadString(g_hInstance,
                     (VerifyTrust().IsVerified()) ? IDS_TW_VERIFIED_OK : IDS_TW_CREATED_OK);
   strMsg += g_wzCRLF;

   Wiz()->ShowStatus(strMsg);

   SetWindowText(GetDlgItem(_hPage, IDC_EDIT), strMsg);

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizStatusPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizStatusPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   switch (id)
   {
   case IDC_EDIT:
      switch (codeNotify)
      {
      case EN_SETFOCUS:
         if (_fSelNeedsRemoving)
         {
            // remove the selection.
            //
            SendDlgItemMessage(_hPage, IDC_EDIT, EM_SETSEL, 0, 0);
            _fSelNeedsRemoving = FALSE;
            return false;
         }
         break;

      case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
         {
            // our subclasses mutli-line edit control will send us
            // WM_COMMAND messages when the enter key is pressed.  We
            // reinterpret this message as a press on the default button of
            // the prop sheet.
            // This workaround from phellyar. NTRAID#NTBUG9-225773

            HWND propSheet = GetParent(_hPage);
            WORD defaultButtonId =
               LOWORD(SendMessage(propSheet, DM_GETDEFID, 0, 0));

            // we expect that there is always a default button on the prop sheet

            dspAssert(defaultButtonId);

            SendMessage(propSheet,
                        WM_COMMAND,
                        MAKELONG(defaultButtonId, BN_CLICKED),
                        0);
         }
         break;
      }
      break;

   case IDCANCEL:
      //
      // ESC gets trapped by the read-only edit control. Forward to the frame.
      //
      SendMessage(GetParent(_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                  LPARAM(hwndCtrl));

      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizStatusPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizStatusPage::OnSetActive(void)
{
   _fSelNeedsRemoving = TRUE;

   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_NEXT);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizStatusPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizStatusPage::Validate(void)
{
   return (Trust().GetNewTrustDirection() & TRUST_DIRECTION_OUTBOUND) ?
         IDD_TRUSTWIZ_VERIFY_OUTBOUND_PAGE : IDD_TRUSTWIZ_VERIFY_INBOUND_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizSaveSuffixesOnLocalTDOPage
//
//  Purpose:   Forest name suffixes page for saving the remote domain's
//             claimed names on the local TDO.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizSaveSuffixesOnLocalTDOPage::CTrustWizSaveSuffixesOnLocalTDOPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_SUFFIX_FOR_LOCAL_PAGE,
                     IDS_TW_SUFFIX_FOR_LOCAL_TITLE,
                     IDS_TW_SUFFIX_FOR_LOCAL_SUBTITLE)
{
   TRACER(CTrustWizSaveSuffixesOnLocalTDOPage, CTrustWizSaveSuffixesOnLocalTDOPage)
}

typedef std::basic_string<wchar_t> String;
typedef std::multimap<String, UINT> TLNMAP;

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSaveSuffixesOnLocalTDOPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizSaveSuffixesOnLocalTDOPage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_COMPLETING);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   FormatWindowText(GetDlgItem(_hPage, IDC_TW_SUFFIX_FOREST),
                    OtherDomain().GetDnsDomainName());

   CFTInfo & FTInfo = Trust().GetFTInfo();

   if (!FTInfo.GetCount())
   {
      return TRUE;
   }

   // Add the TLNs to the scrolling check box control. This control doesn't do
   // sorting, so first add the TLNs to a multimap so they will be sorted.
   //
   TLNMAP TlnMap;

   for (UINT i = 0; i < FTInfo.GetCount(); i++)
   {
      LSA_FOREST_TRUST_RECORD_TYPE type;

      if (!FTInfo.GetType(i, type))
      {
         dspAssert(FALSE);
         return FALSE;
      }

      // If it is a top level name that isn't in conflict and isn't the
      // forest root TLN, then put it in the list.
      //
      if (ForestTrustTopLevelName == type &&
          !FTInfo.IsConflictFlagSet(i) &&
          !FTInfo.IsForestRootTLN(i, OtherDomain().GetDnsDomainName()))
      {
         CStrW strDnsName;

         FTInfo.GetDnsName(i, strDnsName);

         AddAsteriskPrefix(strDnsName);

         // Add a TLN to the map so it will be sorted.
         //
         TlnMap.insert(TLNMAP::value_type(strDnsName.GetBuffer(0), i));
      }
   }

   HWND hChkList = GetDlgItem(_hPage, IDC_CHECK_LIST);

   for (TLNMAP::iterator it = TlnMap.begin(); it != TlnMap.end(); ++it)
   {
      // Add a check item using the FTInfo array index as the item ID.
      // This array will not change between here and the validate
      // routine below so the indices will remain valid.
      //
      SendMessage(hChkList, CLM_ADDITEM, (WPARAM)it->first.c_str(), it->second);

      // Check the check box as if the item is enabled. If the user
      // leaves it checked, it will be enabled during Validation.
      //
      CheckList_SetLParamCheck(hChkList, it->second, CLST_CHECKED);
   }

   TlnMap.clear();

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSaveSuffixesOnLocalTDOPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizSaveSuffixesOnLocalTDOPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   if (IDC_HELP_BTN == id && BN_CLICKED == codeNotify)
   {
      ShowHelp(L"ADConcepts.chm::/ADHelpRoutedNameSufx.htm");
      return true;
   }
   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSaveSuffixesOnLocalTDOPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizSaveSuffixesOnLocalTDOPage::OnSetActive(void)
{
   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_NEXT);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSaveSuffixesOnLocalTDOPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizSaveSuffixesOnLocalTDOPage::Validate(void)
{
   CFTInfo & FTInfo = Trust().GetFTInfo();

   if (!FTInfo.GetCount())
   {
      WizErr().SetErrorString1(IDS_TWERR_LOGIC);
      WizErr().SetErrorString2(IDS_TWERR_CREATED_NO_NAMES);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   HWND hChkList = GetDlgItem(_hPage, IDC_CHECK_LIST);
   BOOL fChanged = FALSE;
   CWaitCursor Wait;

   for (UINT i = 0; i < FTInfo.GetCount(); i++)
   {
      LSA_FOREST_TRUST_RECORD_TYPE type;

      if (!FTInfo.GetType(i, type))
      {
         dspAssert(FALSE);
         return FALSE;
      }

      if (ForestTrustTopLevelName == type &&
          !FTInfo.IsConflictFlagSet(i) &&
          !FTInfo.IsForestRootTLN(i, OtherDomain().GetDnsDomainName()))
      {
         // clear the disabled-new flag.
         //
         FTInfo.ClearDisableFlags(i);

         fChanged = TRUE;

         if (!CheckList_GetLParamCheck(hChkList, i))
         {
            // If not checked, make it an admin disable.
            //
            FTInfo.SetAdminDisable(i);
         }
      }
   }

   if (fChanged)
   {
      DWORD dwRet = NO_ERROR;

      dwRet = CredMgr().ImpersonateLocal();

      if (ERROR_SUCCESS != dwRet)
      {
         WizErr().SetErrorString1(IDS_ERR_CANT_SAVE_CREDS);
         WizErr().SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      dwRet = Trust().WriteFTInfo(TrustPage()->GetUncDcName());

      CredMgr().Revert();

      if (NO_ERROR != dwRet)
      {
         WizErr().SetErrorString1(IDS_ERR_CANT_SAVE);
         WizErr().SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   if (Trust().IsCreateBothSides() &&
       OtherDomain().GetFTInfo().GetTLNCount() > 1)
   {
      // The forest root TLN is always enabled. If there are any other
      // TLNs claimed by the local forest, then show them to the user
      // for approval.
      //
      return IDD_TRUSTWIZ_SUFFIX_FOR_REMOTE_PAGE;
   }

   return IDD_TRUSTWIZ_COMPLETE_OK_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizSaveSuffixesOnRemoteTDOPage
//
//  Purpose:   Forest name suffixes page for saving the local domain's
//             claimed names on the remote TDO after creating both sides.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizSaveSuffixesOnRemoteTDOPage::CTrustWizSaveSuffixesOnRemoteTDOPage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_SUFFIX_FOR_REMOTE_PAGE,
                     IDS_TW_SUFFIX_FOR_REMOTE_TITLE,
                     IDS_TW_SUFFIX_FOR_REMOTE_SUBTITLE)
{
   TRACER(CTrustWizSaveSuffixesOnRemoteTDOPage, CTrustWizSaveSuffixesOnRemoteTDOPage)
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSaveSuffixesOnRemoteTDOPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizSaveSuffixesOnRemoteTDOPage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_COMPLETING);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   FormatWindowText(GetDlgItem(_hPage, IDC_TW_SUFFIX_FOREST),
                    TrustPage()->GetDnsDomainName());

   CFTInfo & FTInfo = OtherDomain().GetFTInfo();

   if (!FTInfo.GetCount())
   {
      return TRUE;
   }

   // Add the TLNs to the scrolling check box control. This control doesn't do
   // sorting, so first add the TLNs to a multimap so they will be sorted.
   //
   TLNMAP TlnMap;

   for (UINT i = 0; i < FTInfo.GetCount(); i++)
   {
      LSA_FOREST_TRUST_RECORD_TYPE type;

      if (!FTInfo.GetType(i, type))
      {
         dspAssert(FALSE);
         return FALSE;
      }

      // If it is a top level name that isn't in conflict and isn't the
      // forest root TLN, then put it in the list.
      //
      if (ForestTrustTopLevelName == type &&
          !FTInfo.IsConflictFlagSet(i) &&
          !FTInfo.IsForestRootTLN(i, OtherDomain().GetDnsDomainName()))
      {
         CStrW strDnsName;

         FTInfo.GetDnsName(i, strDnsName);

         AddAsteriskPrefix(strDnsName);

         // Add a TLN to the map so it will be sorted.
         //
         TlnMap.insert(TLNMAP::value_type(strDnsName.GetBuffer(0), i));
      }
   }

   HWND hChkList = GetDlgItem(_hPage, IDC_CHECK_LIST);

   for (TLNMAP::iterator it = TlnMap.begin(); it != TlnMap.end(); ++it)
   {
      // Add a check item using the FTInfo array index as the item ID.
      // This array will not change between here and the validate
      // routine below so the indices will remain valid.
      //
      SendMessage(hChkList, CLM_ADDITEM, (WPARAM)it->first.c_str(), it->second);

      // Check the check box as if the item is enabled. If the user
      // leaves it checked, it will be enabled during Validation.
      //
      CheckList_SetLParamCheck(hChkList, it->second, CLST_CHECKED);
   }

   TlnMap.clear();

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSaveSuffixesOnRemoteTDOPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizSaveSuffixesOnRemoteTDOPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   if (IDC_HELP_BTN == id && BN_CLICKED == codeNotify)
   {
      ShowHelp(L"ADConcepts.chm::/ADHelpRoutedNameSufx.htm");
      return true;
   }
   return false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSaveSuffixesOnRemoteTDOPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizSaveSuffixesOnRemoteTDOPage::OnSetActive(void)
{
   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_NEXT);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizSaveSuffixesOnRemoteTDOPage::Validate
//
//-----------------------------------------------------------------------------
int
CTrustWizSaveSuffixesOnRemoteTDOPage::Validate(void)
{
   CFTInfo & FTInfo = OtherDomain().GetFTInfo();

   if (!FTInfo.GetCount())
   {
      WizErr().SetErrorString1(IDS_TWERR_LOGIC);
      WizErr().SetErrorString2(IDS_TWERR_CREATED_NO_NAMES);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   HWND hChkList = GetDlgItem(_hPage, IDC_CHECK_LIST);
   BOOL fChanged = FALSE;
   CWaitCursor Wait;

   for (UINT i = 0; i < FTInfo.GetCount(); i++)
   {
      LSA_FOREST_TRUST_RECORD_TYPE type;

      if (!FTInfo.GetType(i, type))
      {
         dspAssert(FALSE);
         return FALSE;
      }

      if (ForestTrustTopLevelName == type &&
          !FTInfo.IsConflictFlagSet(i) &&
          !FTInfo.IsForestRootTLN(i, OtherDomain().GetDnsDomainName()))
      {
         // clear the disabled-new flag.
         //
         FTInfo.ClearDisableFlags(i);

         fChanged = TRUE;

         if (!CheckList_GetLParamCheck(hChkList, i))
         {
            // If not checked, make it an admin disable.
            //
            FTInfo.SetAdminDisable(i);
         }
      }
   }

   if (fChanged)
   {
      DWORD dwRet = CredMgr().ImpersonateRemote();

      if (ERROR_SUCCESS != dwRet)
      {
         WizErr().SetErrorString1(IDS_ERR_CANT_SAVE_CREDS);
         WizErr().SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      dwRet = OtherDomain().WriteFTInfo();

      CredMgr().Revert();

      if (NO_ERROR != dwRet)
      {
         WizErr().SetErrorString1(IDS_ERR_CANT_SAVE);
         WizErr().SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   return IDD_TRUSTWIZ_COMPLETE_OK_PAGE;
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizDoneOKPage
//
//  Purpose:   Completion page when there are no errors.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizDoneOKPage::CTrustWizDoneOKPage(CNewTrustWizard * pWiz) :
   _fSelNeedsRemoving(FALSE),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_COMPLETE_OK_PAGE, 0, 0, TRUE)
{
   TRACER(CTrustWizDoneOKPage, CTrustWizDoneOKPage)
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDoneOKPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizDoneOKPage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_COMPLETING);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   _multiLineEdit.Init(GetDlgItem(_hPage, IDC_EDIT));

   CStrW strMsg;

   // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
   strMsg.LoadString(g_hInstance,
                     (VerifyTrust().IsVerified()) ? IDS_TW_VERIFIED_OK : IDS_TW_CREATED_OK);
   strMsg += g_wzCRLF;

   if (Trust().IsXForest())
   {
      CStrW strLabel, strDnsName;
      strLabel.LoadString(g_hInstance, IDS_TW_DONE_ROUTED_TO_SPECIFIED);
      strMsg += g_wzCRLF;
      strMsg += strLabel;

      LSA_FOREST_TRUST_RECORD_TYPE type;
      CFTInfo & FTInfo = Trust().GetFTInfo();

      for (UINT i = 0; i < FTInfo.GetCount(); i++)
      {
         if (!FTInfo.GetType(i, type))
         {
            dspAssert(FALSE);
            return FALSE;
         }

         // If it is an enabled top level name add it to the list.
         //
         if (ForestTrustTopLevelName == type && FTInfo.IsEnabled(i))
         {
            FTInfo.GetDnsName(i, strDnsName);

            AddAsteriskPrefix(strDnsName);

            strMsg += g_wzCRLF;
            strMsg += strDnsName;
         }
      }
      strMsg += g_wzCRLF;

      if (Trust().IsCreateBothSides())
      {
         strLabel.LoadString(g_hInstance, IDS_TW_DONE_ROUTED_TO_LOCAL);
         strMsg += g_wzCRLF;
         strMsg += strLabel;

         CFTInfo & FTInfoOther = OtherDomain().GetFTInfo();

         for (i = 0; i < FTInfoOther.GetCount(); i++)
         {
            if (!FTInfoOther.GetType(i, type))
            {
               dspAssert(FALSE);
               return FALSE;
            }

            // If it is an enabled top level name add it to the list.
            //
            if (ForestTrustTopLevelName == type && FTInfoOther.IsEnabled(i))
            {
               FTInfoOther.GetDnsName(i, strDnsName);

               AddAsteriskPrefix(strDnsName);

               strMsg += g_wzCRLF;
               strMsg += strDnsName;
            }
         }
         strMsg += g_wzCRLF;
      }
   }

   if (Trust().IsRealm())
   {
      strMsg += g_wzCRLF;
      Wiz()->ShowStatus(strMsg);
   }

   SetWindowText(GetDlgItem(_hPage, IDC_EDIT), strMsg);

   if (VerifyTrust().IsVerified() || Trust().IsCreateBothSides())
   {
      // Trust exists on both sides, so no need for the other-side warning.
      //
      ShowWindow(GetDlgItem(_hPage, IDC_WARNING_ICON), SW_HIDE);
      ShowWindow(GetDlgItem(_hPage, IDC_WARN_CREATE_STATIC), SW_HIDE);
      //
      // Make the edit box twice as high.
      //
      RECT rc;
      HWND hWndEdit = GetDlgItem(_hPage, IDC_EDIT);
      GetWindowRect(hWndEdit, &rc);
      POINT ptTL = {rc.left, rc.top}, ptBR = {rc.right, rc.bottom};
      ScreenToClient(_hPage, &ptTL);
      ScreenToClient(_hPage, &ptBR);
      SetWindowPos(hWndEdit, NULL, 0, 0, ptBR.x - ptTL.x,
                   (ptBR.y - ptTL.y) * 2, SWP_NOMOVE | SWP_NOZORDER);
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDoneOKPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizDoneOKPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   switch (id)
   {
   case IDC_EDIT:
      switch (codeNotify)
      {
      case EN_SETFOCUS:
         if (_fSelNeedsRemoving)
         {
            // remove the selection.
            //
            SendDlgItemMessage(_hPage, IDC_EDIT, EM_SETSEL, 0, 0);
            _fSelNeedsRemoving = FALSE;
            return false;
         }
         break;

      case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
         {
            // our subclasses mutli-line edit control will send us
            // WM_COMMAND messages when the enter key is pressed.  We
            // reinterpret this message as a press on the default button of
            // the prop sheet.
            // This workaround from phellyar. NTRAID#NTBUG9-225773

            HWND propSheet = GetParent(_hPage);
            WORD defaultButtonId =
               LOWORD(SendMessage(propSheet, DM_GETDEFID, 0, 0));

            // we expect that there is always a default button on the prop sheet

            dspAssert(defaultButtonId);

            SendMessage(propSheet,
                        WM_COMMAND,
                        MAKELONG(defaultButtonId, BN_CLICKED),
                        0);
         }
         break;
      }
      break;

   case IDCANCEL:
      //
      // ESC gets trapped by the read-only edit control. Forward to the frame.
      //
      SendMessage(GetParent(_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                  LPARAM(hwndCtrl));

      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDoneOKPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizDoneOKPage::OnSetActive(void)
{
   _fSelNeedsRemoving = TRUE;

   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_FINISH);
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizDoneVerErrPage
//
//  Purpose:   Completion page for when the verification fails.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizDoneVerErrPage::CTrustWizDoneVerErrPage(CNewTrustWizard * pWiz) :
   _fSelNeedsRemoving(FALSE),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_COMPLETE_VER_ERR_PAGE, 0, 0, TRUE)
{
   TRACER(CTrustWizDoneVerErrPage, CTrustWizDoneVerErrPage)
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDoneVerErrPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizDoneVerErrPage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_COMPLETING);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   _multiLineEdit.Init(GetDlgItem(_hPage, IDC_EDIT));

   bool fTypeErrReported = false;
   CStrW strMsg, strItem;
   PCWSTR rgpwzDomainNames[] = {TrustPage()->GetDnsDomainName(), Trust().GetTrustpartnerName()};

   if (VerifyTrust().IsInboundVerified())
   {
      if (ERROR_DOMAIN_TRUST_INCONSISTENT == VerifyTrust().GetInboundResult())
      {
         // The trust attribute types don't match; one side is
         // forest but the other isn't.
         //
         fTypeErrReported = true;

         CStrW strFix;
         PWSTR pwzMsg = NULL;

         DspFormatMessage(Trust().IsXForest() ? IDS_WIZ_VERIFY_MISMATCH_LF :
                          IDS_WIZ_VERIFY_MISMATCH_RF, 0,
                          (PVOID *)rgpwzDomainNames, 2,
                          FALSE, &pwzMsg);
         if (pwzMsg)
         {
            strMsg = pwzMsg;
            LocalFree(pwzMsg);
         }

         strFix.LoadString(g_hInstance, IDS_VERIFY_MISMATCH_FIX);
         SetDlgItemText(_hPage, IDC_WARN_CREATE_STATIC, strFix);
      }
      else
      {
         if (NO_ERROR != VerifyTrust().GetInboundResult())
         {
            strMsg.LoadString(g_hInstance, IDS_TW_VERIFY_ERR_INBOUND);
            strMsg += g_wzCRLF;
         }

         strMsg += VerifyTrust().GetInboundResultString();

         if (VerifyTrust().IsOutboundVerified())
         {
            strMsg += g_wzCRLF;
         }
      }
   }

   if (VerifyTrust().IsOutboundVerified())
   {
      if (ERROR_DOMAIN_TRUST_INCONSISTENT == VerifyTrust().GetOutboundResult())
      {
         // The trust attribute types don't match; one side is
         // forest but the other isn't.
         //
         if (!fTypeErrReported)
         {
            CStrW strFix;
            PWSTR pwzMsg = NULL;

            DspFormatMessage(Trust().IsXForest() ? IDS_WIZ_VERIFY_MISMATCH_LF :
                             IDS_WIZ_VERIFY_MISMATCH_RF, 0,
                             (PVOID *)rgpwzDomainNames, 2,
                             FALSE, &pwzMsg);
            if (pwzMsg)
            {
               strMsg = pwzMsg;
               LocalFree(pwzMsg);
            }

            strFix.LoadString(g_hInstance, IDS_VERIFY_MISMATCH_FIX);
            SetDlgItemText(_hPage, IDC_WARN_CREATE_STATIC, strFix);
         }
      }
      else
      {
         if (NO_ERROR != VerifyTrust().GetOutboundResult())
         {
            strItem.LoadString(g_hInstance, IDS_TW_VERIFY_ERR_OUTBOUND);
            strMsg += strItem;
            strMsg += g_wzCRLF;
         }

         strMsg += VerifyTrust().GetOutboundResultString();;
      }
   }

   strMsg += VerifyTrust().GetExtra();

   SetWindowText(GetDlgItem(_hPage, IDC_EDIT), strMsg);

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDoneVerErrPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizDoneVerErrPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   switch (id)
   {
   case IDC_EDIT:
      switch (codeNotify)
      {
      case EN_SETFOCUS:
         if (_fSelNeedsRemoving)
         {
            // remove the selection.
            //
            SendDlgItemMessage(_hPage, IDC_EDIT, EM_SETSEL, 0, 0);
            _fSelNeedsRemoving = FALSE;
            return false;
         }
         break;

      case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
         {
            // our subclasses mutli-line edit control will send us
            // WM_COMMAND messages when the enter key is pressed.  We
            // reinterpret this message as a press on the default button of
            // the prop sheet.
            // This workaround from phellyar. NTRAID#NTBUG9-225773

            HWND propSheet = GetParent(_hPage);
            WORD defaultButtonId =
               LOWORD(SendMessage(propSheet, DM_GETDEFID, 0, 0));

            // we expect that there is always a default button on the prop sheet

            dspAssert(defaultButtonId);

            SendMessage(propSheet,
                        WM_COMMAND,
                        MAKELONG(defaultButtonId, BN_CLICKED),
                        0);
         }
         break;
      }
      break;

   case IDCANCEL:
      //
      // ESC gets trapped by the read-only edit control. Forward to the frame.
      //
      SendMessage(GetParent(_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                  LPARAM(hwndCtrl));

      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizDoneVerErrPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizDoneVerErrPage::OnSetActive(void)
{
   _fSelNeedsRemoving = TRUE;

   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_FINISH);
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizFailurePage
//
//  Purpose:   Failure page for trust creation wizard.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizFailurePage::CTrustWizFailurePage(CNewTrustWizard * pWiz) :
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_FAILURE_PAGE, 0, 0, TRUE)
{
   TRACER(CTrustWizFailurePage, CTrustWizFailurePage)
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizFailurePage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizFailurePage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_CANNOT_CONTINUE);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   if (!WizErr().GetErrorString1().IsEmpty())
   {
      SetDlgItemText(_hPage, IDC_FAILPAGE_EDIT1, WizErr().GetErrorString1());
   }
   if (!WizErr().GetErrorString2().IsEmpty())
   {
      SetDlgItemText(_hPage, IDC_FAILPAGE_EDIT2, WizErr().GetErrorString2());
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizFailurePage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizFailurePage::OnSetActive(void)
{
   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_FINISH);
}

//+----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
//
//  Class:     CTrustWizAlreadyExistsPage
//
//  Purpose:   Trust already exists page for trust creation wizard.
//
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
CTrustWizAlreadyExistsPage::CTrustWizAlreadyExistsPage(CNewTrustWizard * pWiz) :
   _fSelNeedsRemoving(FALSE),
   CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_ALREADY_EXISTS_PAGE, 0, 0, TRUE)
{
   TRACER(CTrustWizAlreadyExistsPage, CTrustWizAlreadyExistsPage)
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizAlreadyExistsPage::OnInitDialog
//
//-----------------------------------------------------------------------------
BOOL
CTrustWizAlreadyExistsPage::OnInitDialog(LPARAM lParam)
{
   HWND hTitle = GetDlgItem(_hPage, IDC_BIG_CANNOT_CONTINUE);

   SetWindowFont(hTitle, Wiz()->GetTitleFont(), TRUE);

   _multiLineEdit.Init(GetDlgItem(_hPage, IDC_EDIT));

   CStrW strMsg;

   Wiz()->ShowStatus(strMsg, false);

   SetWindowText(GetDlgItem(_hPage, IDC_EDIT), strMsg);

   if (!WizErr().GetErrorString1().IsEmpty())
   {
      SetDlgItemText(_hPage, IDC_FAILPAGE_EDIT1, WizErr().GetErrorString1());
   }
   if (!WizErr().GetErrorString2().IsEmpty())
   {
      SetDlgItemText(_hPage, IDC_FAILPAGE_EDIT2, WizErr().GetErrorString2());
   }

   return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizAlreadyExistsPage::OnSetActive
//
//-----------------------------------------------------------------------------
void
CTrustWizAlreadyExistsPage::OnSetActive(void)
{
   // The back button is never shown, thus the init in OnInitDialog can't
   // be invalidated by backtracking.
   //
   PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_FINISH);
   _fSelNeedsRemoving = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrustWizAlreadyExistsPage::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT
CTrustWizAlreadyExistsPage::OnCommand(int id, HWND hwndCtrl, UINT codeNotify)
{
   switch (id)
   {
   case IDC_EDIT:
      switch (codeNotify)
      {
      case EN_SETFOCUS:
         if (_fSelNeedsRemoving)
         {
            // remove the selection.
            //
            SendDlgItemMessage(_hPage, IDC_EDIT, EM_SETSEL, 0, 0);
            _fSelNeedsRemoving = FALSE;
            return false;
         }
         break;

      case MultiLineEditBoxThatForwardsEnterKey::FORWARDED_ENTER:
         {
            // our subclasses mutli-line edit control will send us
            // WM_COMMAND messages when the enter key is pressed.  We
            // reinterpret this message as a press on the default button of
            // the prop sheet.
            // This workaround from phellyar. NTRAID#NTBUG9-225773

            HWND propSheet = GetParent(_hPage);
            WORD defaultButtonId =
               LOWORD(SendMessage(propSheet, DM_GETDEFID, 0, 0));

            // we expect that there is always a default button on the prop sheet

            dspAssert(defaultButtonId);

            SendMessage(propSheet,
                        WM_COMMAND,
                        MAKELONG(defaultButtonId, BN_CLICKED),
                        0);
         }
         break;
      }
      break;

   case IDCANCEL:
      //
      // ESC gets trapped by the read-only edit control. Forward to the frame.
      //
      SendMessage(GetParent(_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                  LPARAM(hwndCtrl));

      return false;
   }

   return true;
}

//+----------------------------------------------------------------------------
//
//  Function:  GetOrgText
//
//  Synopsis:  Select the appropriate text to describe the results of whether
//             the TRUST_ATTRIBUTE_CROSS_ORGANIZATION bit is set on either side
//             of the trust. There are 16 permutations at last count...
//
//-----------------------------------------------------------------------------
void
GetOrgText(bool fCreateBothSides,
           bool fIsXForest,
           bool fOtherOrgLocal,
           bool fOtherOrgRemote,
           DWORD dwDirection,
           CStrW & strMsg)
{
   CStrW strItem;
   UINT nStrId = IDS_TW_STATUS_ONE_SIDE_THIS_D;

   if (TRUST_DIRECTION_OUTBOUND == dwDirection)
   {
      // If the trust is outbound-only, then the org bit does not apply on the
      // remote side so treat it the same as one-side only.
      //
      fCreateBothSides = false;
   }

   if (fCreateBothSides)
   {
      if (fIsXForest)
      {
         if (TRUST_DIRECTION_INBOUND == dwDirection)
         {
            // Inbound only trust, look only at the my-org setting on the
            // remote side.
            //
            nStrId = (fOtherOrgRemote) ? IDS_TW_STATUS_REMOTE_SIDE_OTHER :
                                         IDS_TW_STATUS_REMOTE_SIDE_THIS;
         }
         else // Trust is bi-directional (outbound-only handled by first if test).
         {
            if (fOtherOrgLocal)
            {
               nStrId = (fOtherOrgRemote) ? IDS_TW_STATUS_BOTH_OTHER :
                                            IDS_TW_STATUS_LOCAL_OTHER_REMOTE_THIS;
            }
            else
            {
               nStrId = (fOtherOrgRemote) ? IDS_TW_STATUS_LOCAL_THIS_REMOTE_OTHER : 
                                            IDS_TW_STATUS_BOTH_THIS;
            }
         }
      }
      else
      {
         if (TRUST_DIRECTION_INBOUND == dwDirection)
         {
            // Inbound only trust, look only at the my-org setting on the
            // remote side.
            //
            nStrId = (fOtherOrgRemote) ? IDS_TW_STATUS_REMOTE_SIDE_OTHER_D :
                                         IDS_TW_STATUS_REMOTE_SIDE_THIS_D;
         }
         else // Trust is bi-directional (outbound-only handled by first if test).
         {
            if (fOtherOrgLocal)
            {
               nStrId = (fOtherOrgRemote) ? IDS_TW_STATUS_BOTH_OTHER_D :
                                            IDS_TW_STATUS_LOCAL_OTHER_REMOTE_THIS_D;
            }
            else
            {
               nStrId = (fOtherOrgRemote) ? IDS_TW_STATUS_LOCAL_THIS_REMOTE_OTHER_D :
                                            IDS_TW_STATUS_BOTH_THIS_D;
            }
         }
      }
   }
   else
   {
      if (fIsXForest)
      {
         nStrId = (fOtherOrgLocal) ? IDS_TW_STATUS_ONE_SIDE_OTHER :
                                     IDS_TW_STATUS_ONE_SIDE_THIS;
      }
      else
      {
         nStrId = (fOtherOrgLocal) ? IDS_TW_STATUS_ONE_SIDE_OTHER_D :
                                     IDS_TW_STATUS_ONE_SIDE_THIS_D;
      }
   }
   // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
   strItem.LoadString(g_hInstance, nStrId);
   strMsg += g_wzCRLF;
   strMsg += strItem;
   strMsg += g_wzCRLF;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\trustwiz2.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Domains and Trust
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       trustwiz2.cxx
//
//  Contents:   More Domain trust creation wizard.
//
//  History:    28-Sept-00 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "trust.h"
#include "trustwiz.h"
#include <lmerr.h>
#include <crypt.h>

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Method:    CallMember::Invoke subclasses
//
//-----------------------------------------------------------------------------
HRESULT
CallPolicyRead::Invoke(void)
{
   TRACER(CallPolicyRead,Invoke);
   HRESULT hr;

   hr = _pWiz->RetryCollectInfo();

   _pWiz->CredMgr.Revert();

   return hr;
}

HRESULT
CallTrustExistCheck::Invoke(void)
{
   TRACER(CallTrustExistCheck,Invoke);
   HRESULT hr;

   hr = _pWiz->RetryContinueCollectInfo();

   _pWiz->CredMgr.Revert();

   return hr;
}

HRESULT
CallCheckOtherDomainTrust::Invoke(void)
{
   TRACER(CallCheckOtherDomainTrust,Invoke);
   HRESULT hr;

   hr = _pWiz->CheckOtherDomainTrust();

   _pWiz->CredMgr.Revert();

   return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCreds::Impersonate
//
//-----------------------------------------------------------------------------
DWORD
CCreds::Impersonate(void)
{
   TRACER(CCreds,Impersonate);
   if (!_fSet)
   {
      return NO_ERROR;
   }
   if (_strUser.IsEmpty())
   {
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }

   DWORD dwErr = NO_ERROR;

   if (!_hToken)
   {
      // The PW is encrypted, decrypt it before using it.
      WCHAR wzPw[CREDUI_MAX_PASSWORD_LENGTH+1+4] = {0}; // add 4 because the PW size was rounded up to an 8 byte boundary.
      if (_cbPW > CREDUI_MAX_PASSWORD_LENGTH+1+4)
      {
         dspAssert(false);
         return ERROR_INTERNAL_ERROR;
      }
      // NOTICE-2002/02/18-ericb - SecurityPush: the above check verifies that
      // the destination buffer is large enough.
      RtlCopyMemory(wzPw, _strPW, _cbPW);
      RtlDecryptMemory(wzPw, _cbPW, 0);

      if (!LogonUser(_strUser, 
                     _strDomain,
                     wzPw,
                     LOGON32_LOGON_NEW_CREDENTIALS,
                     LOGON32_PROVIDER_WINNT50,
                     &_hToken))
      {
         dwErr = GetLastError();
         dspDebugOut((DEB_ITRACE, "LogonUser failed with error %d on user name %ws\n",
                      dwErr, _strUser.GetBuffer(0)));
         return dwErr;
      }
      // Zero out the buffer so that the PW won't be left on the stack.
      // NOTICE-2002/02/18-ericb - SecurityPush: see above RtlCopyMemory notice.
      SecureZeroMemory(wzPw, _cbPW);

      // Because the login uses the LOGON32_LOGON_NEW_CREDENTIALS flag, no
      // attempt is made to use the credentials until a remote resource is
      // accessed. Thus, we don't yet know if the user entered credentials are
      // valid at this point.
   }

   if (!ImpersonateLoggedOnUser(_hToken))
   {
      dwErr = GetLastError();
      dspDebugOut((DEB_ITRACE, "ImpersonateLoggedOnUser failed with error %d on user name %ws\n",
                   dwErr, _strUser.GetBuffer(0)));
      return dwErr;
   }

   _fImpersonating = true;

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCreds::Revert
//
//-----------------------------------------------------------------------------
void
CCreds::Revert()
{
   if (_fImpersonating)
   {
      TRACER(CCreds,Revert);
      BOOL f = RevertToSelf();
      dspAssert(f);
      _fImpersonating = false;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CCreds::Clear
//
//-----------------------------------------------------------------------------
void
CCreds::Clear(void)
{
   Revert();
   _strUser.Empty();
   _strPW.Empty();
   if (_hToken)
   {
      CloseHandle(_hToken);
      _hToken = NULL;
   }
   _fSet = false;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCreds::SetUserAndPW
//
//-----------------------------------------------------------------------------
DWORD
CCreds::SetUserAndPW(PCWSTR pwzUser, PCWSTR pwzPW, PCWSTR pwzDomain)
{
   // Check the parameters for null. pwzDomain can be null.
   if (!pwzUser || !pwzPW)
   {
      dspAssert(false);
      return ERROR_INVALID_PARAMETER;
   }

   Clear();

   DWORD dwErr = NO_ERROR;
   WCHAR wzName[CRED_MAX_USERNAME_LENGTH+1] = {0}, 
         wzDomain[CRED_MAX_USERNAME_LENGTH+1] = {0},
         wzPw[CREDUI_MAX_PASSWORD_LENGTH+1+4] = {0}; // add 4 so that the PW size can be rounded up to 8 byte boundary.

   dwErr = CredUIParseUserName(pwzUser, wzName, CRED_MAX_USERNAME_LENGTH,
                               wzDomain, CRED_MAX_USERNAME_LENGTH);

   if (NO_ERROR == dwErr)
   {
      _strUser = wzName;
      _strDomain = wzDomain;
   }
   else
   {
      if (ERROR_INVALID_PARAMETER == dwErr ||
          ERROR_INVALID_ACCOUNT_NAME == dwErr)
      {
         // CredUIParseUserName returns this error if the user entered name
         // does not include a domain. Default to the target domain.
         //
         _strUser = pwzUser;

         if (pwzDomain)
         {
            _strDomain = pwzDomain;
         }
      }
      else
      {
         dspDebugOut((DEB_ITRACE, "CredUIParseUserName failed with error %d\n", dwErr));
         return dwErr;
      }
   }

   // Encrypt the PW, rounding up buffer size to 8 byte boundary. The
   // RtlEncryptMemory function encrypts in place, so copy to a buffer that is
   // large enough for the round-up. The buffer is null-initialized, so it is
   // guaranteed to be null terminated after the copy.
   //
   // NOTICE-2002/02/18-ericb - SecurityPush: wzPw initiallized to all nulls.
   wcsncpy(wzPw, pwzPW, CREDUI_MAX_PASSWORD_LENGTH);

   _cbPW = static_cast<ULONG>(wcslen(wzPw) * sizeof(WCHAR));
   ULONG roundup = RTL_ENCRYPT_MEMORY_SIZE - (_cbPW % RTL_ENCRYPT_MEMORY_SIZE);
   if (roundup < RTL_ENCRYPT_MEMORY_SIZE)
   {
      _cbPW += roundup;
   }
   NTSTATUS status = RtlEncryptMemory(wzPw, _cbPW, 0);
   dspDebugOut((DEB_ITRACE, "CCreds::SetUserAndPW: RtlEncryptMemory returned status 0x%x\n", status));
   _strPW.GetBufferSetLength(_cbPW + 2); // make sure there is room for a null after the encrypted PW.
   _strPW = wzPw;

   _fSet = true;

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:     CCreds::PromptForCreds
//
//  Synopsis:   Post a login dialog.
//
//-----------------------------------------------------------------------------
int
CCreds::PromptForCreds(PCWSTR pwzDomain, HWND hParent)
{
   TRACE3(CCreds, PromptForCreds);

   if (pwzDomain)
   {
      _strDomain = pwzDomain;
   }

   int nRet = (int)DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_CRED_ENTRY),
                                  hParent, CredPromptProc, (LPARAM)this);
   if (-1 == nRet)
   {
      REPORT_ERROR(GetLastError(), hParent);
      return GetLastError();
   }

   return nRet;
}

//+----------------------------------------------------------------------------
//
//  Function:   CredPromptProc
//
//  Synopsis:   Trust credentials dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CredPromptProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
   int code;
   CCreds * pCreds = (CCreds*)GetWindowLongPtr(hDlg, DWLP_USER);

   switch (uMsg)
   {
   case WM_INITDIALOG:
      {
         SetWindowLongPtr(hDlg, DWLP_USER, lParam);
         pCreds = (CCreds *)lParam;
         dspAssert(pCreds);
         EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
         SendDlgItemMessage(hDlg, IDC_CREDMAN, CRM_SETUSERNAMEMAX, CREDUI_MAX_USERNAME_LENGTH, 0);
         SendDlgItemMessage(hDlg, IDC_CREDMAN, CRM_SETPASSWORDMAX, CREDUI_MAX_PASSWORD_LENGTH, 0);
         WCHAR wzMsg[MAX_PATH+1] = {0};
         PWSTR pwzMsgFmt = NULL;
         if (!LoadStringToTchar(IDS_TRUST_LOGON_MSG, &pwzMsgFmt))
         {
            REPORT_ERROR(E_OUTOFMEMORY, hDlg);
            return FALSE;
         }
         if (FAILED(StringCchPrintf(wzMsg, MAX_PATH+1, pwzMsgFmt, pCreds->_strDomain)))
         {
            dspAssert(false);
            // continue with truncated, but null terminated, output buffer.
         }
         SetDlgItemText(hDlg, IDC_MSG, wzMsg);
         delete pwzMsgFmt;
      }
      return TRUE;

   case WM_COMMAND:
      code = GET_WM_COMMAND_CMD(wParam, lParam);
      switch (GET_WM_COMMAND_ID(wParam, lParam))
      {
      case IDOK:
         if (code == BN_CLICKED)
         {
            DWORD dwErr = NO_ERROR;
            dspAssert(pCreds);
            WCHAR wzName[CREDUI_MAX_USERNAME_LENGTH+1] = {0},
                  wzPw[CREDUI_MAX_PASSWORD_LENGTH+1] = {0};

            // NOTICE-2002/02/18-ericb - SecurityPush: wzName/wzPw are initialized
            // to all zeros and are one char longer than the size passed to
            // Credential_GetUserName/Password so that even if these functions truncate
            // without null terminating, the strings will still be null terminated.
            Credential_GetUserName(GetDlgItem(hDlg, IDC_CREDMAN), wzName,
                                   CREDUI_MAX_USERNAME_LENGTH);

            Credential_GetPassword(GetDlgItem(hDlg, IDC_CREDMAN), wzPw,
                                   CREDUI_MAX_PASSWORD_LENGTH);

            dwErr = pCreds->SetUserAndPW(wzName, wzPw);

            // Zero out the pw buffer so that the pw isn't left on the stack.
            SecureZeroMemory(wzPw, CREDUI_MAX_PASSWORD_LENGTH * sizeof(WCHAR));

            CHECK_WIN32_REPORT(dwErr, hDlg, ;);

            EndDialog(hDlg, dwErr);
         }
         break;

      case IDCANCEL:
         if (code == BN_CLICKED)
         {
            EndDialog(hDlg, ERROR_CANCELLED);
         }
         break;

      case IDC_CREDMAN:
         if (CRN_USERNAMECHANGE == code)
         {
            bool fNameEntered = SendDlgItemMessage(hDlg, IDC_CREDMAN,
                                                   CRM_GETUSERNAMELENGTH,
                                                   0, 0) > 0;

            EnableWindow(GetDlgItem(hDlg, IDOK), fNameEntered);
         }
         break;
      }
      break;

   default:
      return(FALSE);
   }

   return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:    CCreds::ImpersonateAnonymous
//
//-----------------------------------------------------------------------------
DWORD
CCreds::ImpersonateAnonymous(void)
{
   TRACER(CCreds,ImpersonateAnonymous);
   DWORD dwErr = NO_ERROR;
   HANDLE hThread = NULL;

   hThread = OpenThread(THREAD_ALL_ACCESS, FALSE, GetCurrentThreadId());

   if (!hThread)
   {
      dwErr = GetLastError();
      dspDebugOut((DEB_ITRACE, "OpenThread failed with error %d\n", dwErr));
      return dwErr;
   }

   if (!ImpersonateAnonymousToken(hThread))
   {
      CloseHandle(hThread);
      dwErr = GetLastError();
      dspDebugOut((DEB_ITRACE, "ImpersonateAnonymousToken failed with error %d\n", dwErr));
      return dwErr;
   }

   CloseHandle(hThread);

   _fImpersonating = true;

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::GetPrompt
//
//-----------------------------------------------------------------------------
PCWSTR
CCredMgr::GetPrompt()
{
   // NOTICE-2002/02/18-ericb - SecurityPush: CStrW::LoadString sets the
   // string to an empty string on failure.
   _strPrompt.LoadString(g_hInstance, _fRemote ? 
                                         _fAdmin ? IDS_CRED_ADMIN_OTHER_PROMPT :
                                                   IDS_CRED_USER_OTHER_PROMPT :
                                      IDS_CRED_ADMIN_LOCAL_PROMPT);
   return _strPrompt;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::GetDomainPrompt
//
//-----------------------------------------------------------------------------
PCWSTR
CCredMgr::GetDomainPrompt(void)
{
   CStrW strFormat;

   // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
   strFormat.LoadString(g_hInstance, _fRemote ? IDS_CRED_OTHER_DOMAIN :
                                                IDS_CRED_LOCAL_DOMAIN);
   _strDomainPrompt.Format(strFormat, _strDomain);

   return _strDomainPrompt;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::GetSubTitle
//
//-----------------------------------------------------------------------------
PCWSTR
CCredMgr::GetSubTitle(void)
{
   // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
   _strSubTitle.LoadString(g_hInstance, _fRemote ?
                                          _fAdmin ? IDS_TW_CREDS_SUBTITLE_OTHER :
                                                    IDS_TW_CREDS_SUBTITLE_OTHER_NONADMIN :
                                          IDS_TW_CREDS_SUBTITLE_LOCAL);
   return _strSubTitle;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::SetNextFcn
//
//-----------------------------------------------------------------------------
bool
CCredMgr::SetNextFcn(CallMember * pNext)
{
   if (!pNext)
   {
      return false;
   }

   if (_pNextFcn)
   {
      delete _pNextFcn;
   }

   _pNextFcn = pNext;

   _fNewCall = true;

   return true;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::InvokeNext
//
//-----------------------------------------------------------------------------
int
CCredMgr::InvokeNext(void)
{
   if (_nNextPage)
   {
      int tmp = _nNextPage;
      _nNextPage = 0;
      return tmp;
   }

   dspAssert(_pNextFcn);
   return _pNextFcn->Invoke();
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::SaveCreds
//
//-----------------------------------------------------------------------------
DWORD
CCredMgr::SaveCreds(HWND hWndCredCtrl)
{
   TRACER(CCredMgr,SaveCreds);
   WCHAR wzName[CREDUI_MAX_USERNAME_LENGTH+1] = {0},
         wzPw[CREDUI_MAX_PASSWORD_LENGTH+1] = {0};

   // NOTICE-2002/02/18-ericb - SecurityPush: wzName/wzPw are initialized to
   // all zeros and are one char longer than the size passed to
   // Credential_GetUserName/Password so that even if these functions truncate
   // without null terminating, the strings will still be null terminated.
   Credential_GetUserName(hWndCredCtrl, wzName, CREDUI_MAX_USERNAME_LENGTH);

   Credential_GetPassword(hWndCredCtrl, wzPw, CREDUI_MAX_PASSWORD_LENGTH);

   DWORD dwRet = 0;

   if (_fRemote)
   {
      dwRet = _RemoteCreds.SetUserAndPW(wzName, wzPw, _strDomain);
   }
   else
   {
      dwRet = _LocalCreds.SetUserAndPW(wzName, wzPw, _strDomain);
   }
   // Zero out the pw buffer so that the pw isn't left on the stack.
   SecureZeroMemory(wzPw, sizeof(wzPw));

   return dwRet;
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::Impersonate
//
//-----------------------------------------------------------------------------
DWORD
CCredMgr::Impersonate(void)
{
   TRACER(CCredMgr,Impersonate);
   if (_fRemote)
   {
      return _RemoteCreds.Impersonate();
   }
   else
   {
      return _LocalCreds.Impersonate();
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CCredMgr::Revert
//
//-----------------------------------------------------------------------------
void
CCredMgr::Revert(void)
{
   _LocalCreds.Revert();
   _RemoteCreds.Revert();
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::RetryCollectInfo
//
//  Synopsis:  Called after LsaOpenPolicy failed with access-denied and then
//             obtaining credentials to the remote domain.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::RetryCollectInfo(void)
{
   CWaitCursor Wait;

   DWORD dwErr = OtherDomain.OpenLsaPolicy(CredMgr._RemoteCreds);

   if (NO_ERROR != dwErr)
   {
      CHECK_WIN32(dwErr, ;);
      WizError.SetErrorString2Hr(dwErr);
      _hr = HRESULT_FROM_WIN32(dwErr);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   int nRet = GetDomainInfo();

   if (nRet)
   {
      // nRet will be non-zero if an error occured.
      //
      return nRet;
   }

   return ContinueCollectInfo();
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::RetryContinueCollectInfo
//
//  Synopsis:  Called after TrustExistCheck got access-denied and then
//             obtaining credentials to the local domain.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::RetryContinueCollectInfo(void)
{
   TRACER(CNewTrustWizard,RetryContinueCollectInfo);

   return ContinueCollectInfo(FALSE);
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::CollectInfo
//
//  Synopsis:  Attempt to contact the domains and collect the domain/trust info.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::CollectInfo(void)
{
   TRACER(CNewTrustWizard,CollectInfo);
   CStrW strFmt, strErr;
   CWaitCursor Wait;
   int nRet = 0;

   HRESULT hr = OtherDomain.DiscoverDC(OtherDomain.GetUserEnteredName());

   if (FAILED(hr))
   {
      CHECK_HRESULT(hr, ;);
      WizError.SetErrorString2Hr(hr);
      _hr = hr;
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   if (OtherDomain.IsFound())
   {
      DWORD dwErr = OtherDomain.OpenLsaPolicy(CredMgr._RemoteCreds);

      if (NO_ERROR != dwErr)
      {
         CredMgr.Revert();
         switch (dwErr)
         {
         case STATUS_ACCESS_DENIED:
         case ERROR_ACCESS_DENIED:
            //
            // Normally an anonymous token is good enough to read the domain
            // policy. However, if restrict anonymous is set, then real domain
            // creds are needed. That must be the case if we are here.
            // Go to the credentials page. If the creds are good, then
            // call RetryCollectInfo() which will call GetDomainInfo
            //
            CredMgr.DoRemote();
            CredMgr.SetAdmin(false);
            CredMgr.SetDomain(OtherDomain.GetUserEnteredName());
            if (!CredMgr.SetNextFcn(new CallPolicyRead(this)))
            {
               WizError.SetErrorString2Hr(E_OUTOFMEMORY);
               _hr = E_OUTOFMEMORY;
               return IDD_TRUSTWIZ_FAILURE_PAGE;
            }
            return IDD_TRUSTWIZ_CREDS_PAGE;

         case RPC_S_SERVER_UNAVAILABLE:
            {
            CStrW strMsg, strFormat;
            // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
            strFormat.LoadString(g_hInstance, IDS_TRUST_LSAOPEN_NO_RPC);
            strMsg.Format(strFormat, OtherDomain.GetDcName());
            WizError.SetErrorString2(strMsg);
            _hr = HRESULT_FROM_WIN32(dwErr);
            }
            return IDD_TRUSTWIZ_FAILURE_PAGE;
            
         default:
            CHECK_WIN32(dwErr, ;);
            PWSTR pwzMsg = NULL;
            PCWSTR rgArgs[1];
            rgArgs[0] = OtherDomain.GetDcName();
            DspFormatMessage(IDS_TRUST_LSAOPEN_ERROR,
                             dwErr,
                             (PVOID*)rgArgs,
                             1,
                             FALSE,
                             &pwzMsg);
            WizError.SetErrorString2(pwzMsg);
            if (pwzMsg) LocalFree(pwzMsg);
            _hr = HRESULT_FROM_WIN32(dwErr);
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
      }

      nRet = GetDomainInfo();

      if (nRet)
      {
         // nRet will be non-zero if an error occured.
         //
         return nRet;
      }
   }

   return ContinueCollectInfo();
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::ContinueCollectInfo
//
//  Synopsis:  Continues CollectInfo. Determines which pages to branch to
//             next based on the collected info.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::ContinueCollectInfo(BOOL fPrompt)
{
   CWaitCursor Wait;

   // Set the trust type value.
   //
   if (OtherDomain.IsFound())
   {
      if (OtherDomain.IsUplevel())
      {
         // First, make sure the user isn't trying to create trust to the same
         // domain.
         //
         // NOTICE-2002/02/18-ericb - SecurityPush: GetDnsDomainName will always return
         // a valid null-terminated string containing zero or more charactes.
         if (_wcsicmp(TrustPage()->GetDnsDomainName(), OtherDomain.GetDnsDomainName()) == 0)
         {
            WizError.SetErrorString1(IDS_TWERR_NOT_TO_SELF1);
            WizError.SetErrorString2(IDS_TWERR_NOT_TO_SELF2);
            _hr = E_FAIL;
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }

         // TRUST_TYPE_UPLEVEL
         //
         Trust.SetTrustTypeUplevel();
      }
      else
      {
         // TRUST_TYPE_DOWNLEVEL
         //
         Trust.SetTrustTypeDownlevel();
      }
   }
   else
   {
      // Only Realm trust is possible
      //
      // TRUST_TYPE_MIT
      //
      Trust.SetTrustTypeRealm();
   }

   // See if the trust is external. It is external if the other domain is
   // downlevel or if they are not in the same forest.
   //
   // NOTICE-2002/02/18-ericb - SecurityPush: GetForestName will always return
   // a valid null-terminated string containing zero or more charactes.
   Trust.SetExternal(!(OtherDomain.IsUplevel() &&
                       (_wcsicmp(OtherDomain.GetForestName(), TrustPage()->GetForestName()) == 0)
                      )
                    );

   // Look for an existing trust and if found save the state.
   //
   int nRet = TrustExistCheck(fPrompt);

   if (nRet)
   {
      // nRet will be non-zero if creds are needed or an error occured.
      //
      return nRet;
   }

   if (Trust.Exists())
   {
      // If an existing two-way trust, then nothing to do, otherwise a
      // one-way trust can be made bi-di.
      //
      if (Trust.GetTrustDirection() == TRUST_DIRECTION_BIDIRECTIONAL)
      {
         // Nothing to do, bail.
         //
         WizError.SetErrorString1((Trust.GetTrustType() == TRUST_TYPE_MIT) ?
                                  IDS_TWERR_REALM_ALREADY_EXISTS : IDS_TWERR_ALREADY_EXISTS);
         WizError.SetErrorString2((Trust.GetTrustType() == TRUST_TYPE_MIT) ?
                                  IDS_TWERR_REALM_CANT_CHANGE : IDS_TWERR_CANT_CHANGE);
         _hr = HRESULT_FROM_WIN32(ERROR_DOMAIN_EXISTS);
         return IDD_TRUSTWIZ_ALREADY_EXISTS_PAGE;
      }
      else
      {
         return IDD_TRUSTWIZ_BIDI_PAGE;
      }
   }

   if (OtherDomain.IsFound())
   {
      // If the local domain qualifies for cross-forest trust and the other
      // domain is external and root, then prompt for trust type.
      //
      if (_pTrustPage->QualifiesForestTrust() && Trust.IsExternal())
      {
         // Check if the other domain is the enterprise root.
         //
         if (OtherDomain.IsForestRoot())
         {
            return IDD_TRUSTWIZ_EXTERN_OR_FOREST_PAGE;
         }
      }

      // New external or shortcut trust.
      //
      return IDD_TRUSTWIZ_DIRECTION_PAGE;
   }

   // Other domain not found, ask if user wants Realm trust.
   //
   return IDD_TRUSTWIZ_WIN_OR_MIT_PAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::GetDomainInfo
//
//  Synopsis:  Read the naming info from the remote domain.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::GetDomainInfo(void)
{
   TRACER(CNewTrustWizard,GetDomainInfo);
   HRESULT hr = S_OK;

   // Read the LSA domain policy naming info for the other domain (flat and DNS
   // names, SID, up/downlevel, forest root).
   //
   hr = OtherDomain.ReadDomainInfo();

   CredMgr.Revert();

   if (FAILED(hr))
   {
      CHECK_HRESULT(hr, ;);
      WizError.SetErrorString2Hr(hr);
      _hr = hr;
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::CheckOtherDomainTrust
//
//  Synopsis:  If the user has selected both-sides, see if the trust on the
//             two sides is consistent.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::CheckOtherDomainTrust(void)
{
   DWORD dwErr = NO_ERROR;
   CWaitCursor Wait;

   if (Trust.IsCreateBothSides())
   {
      dwErr = OtherDomain.TrustExistCheck(Trust.IsOneWayOutBoundForest(),
                                          TrustPage(), CredMgr);

      if (ERROR_SUCCESS != dwErr)
      {
         WizError.SetErrorString2Hr(dwErr);
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      // Test for error conditions.
      //
      if (Trust.Exists())
      {
         if (!OtherDomain.Exists())
         {
            WizError.SetErrorString1(IDS_TW_OTHER_NOT_EXIST);
            WizError.SetErrorString2(IDS_TW_SIDES_ERR_REMEDY);
            _hr = E_FAIL;
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
         if (TRUST_TYPE_MIT == OtherDomain.GetTrustType())
         {
            WizError.SetErrorString1(IDS_TW_SIDES_ERR_MIT);
            WizError.SetErrorString2(IDS_TW_SIDES_REMEDY_DEL_BOTH);
            _hr = E_FAIL;
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
         if (Trust.IsXForest() &&
             !(OtherDomain.GetTrustAttrs() & TRUST_ATTRIBUTE_FOREST_TRANSITIVE))
         {
            WizError.SetErrorString1(IDS_TW_FOREST_VS_EXTERNAL);
            WizError.SetErrorString2(IDS_TW_SIDES_REMEDY_DEL_BOTH);
            _hr = E_FAIL;
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
         if (!Trust.IsXForest() &&
             (OtherDomain.GetTrustAttrs() & TRUST_ATTRIBUTE_FOREST_TRANSITIVE))
         {
            WizError.SetErrorString1(IDS_TW_EXTERNAL_VS_FOREST);
            WizError.SetErrorString2(IDS_TW_SIDES_REMEDY_DEL_BOTH);
            _hr = E_FAIL;
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
      }
      else
      {
         if (OtherDomain.Exists())
         {
            WizError.SetErrorString1(IDS_TW_OTHER_ALREADY_EXISTS);
            WizError.SetErrorString2(IDS_TW_SIDES_REMEDY_DEL_OTHER);
            _hr = E_FAIL;
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
      }
   }

   if (Trust.IsXForest())
   {
      // See if the other domain qualifies.
      //
      BOOL fAllWhistler = FALSE;

      dwErr = CredMgr.ImpersonateRemote();

      if (NO_ERROR != dwErr)
      {
         WizError.SetErrorString1(IDS_ERR_CREATE_BAD_CREDS);
         WizError.SetErrorString2Hr(dwErr);
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      HRESULT hr = GetEnterpriseVer(OtherDomain.GetDcName(), &fAllWhistler);      

      CredMgr.Revert();

      if (FAILED(hr))
      {
         WizError.SetErrorString1(IDS_ERR_READ_ENT_VER);
         WizError.SetErrorString2Hr(hr);
         _hr = hr;
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      if (!fAllWhistler)
      {
         WizError.SetErrorString1(IDS_ERR_NG_ENT_VER);
         WizError.SetErrorString2(IDS_ERR_NG_ENT_VER_REMEDY);
         _hr = E_FAIL;
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   if (Trust.IsExternal())
   {
      UINT ulDomainVer = 0;
      HRESULT hr = S_OK;

      //
      // See if the My Organization page should be displayed. The "other-org"
      // trust attribute bit is only applicable to outbound external or forest
      // trusts. The outbound domain must have its behavior version at
      // .Net mixed or higher.
      //
      if (Trust.Exists())
      {
         if (TRUST_DIRECTION_INBOUND == Trust.GetTrustDirection())
         {
            dwErr = CredMgr.ImpersonateLocal();

            if (NO_ERROR != dwErr)
            {
               WizError.SetErrorString1(IDS_ERR_CREATE_BAD_CREDS);
               WizError.SetErrorString2Hr(dwErr);
               _hr = HRESULT_FROM_WIN32(dwErr);
               return IDD_TRUSTWIZ_FAILURE_PAGE;
            }

            hr = TrustPage()->GetDomainVersion(NULL, &ulDomainVer);

            CredMgr.Revert();

            if (FAILED(hr))
            {
               WizError.SetErrorString2Hr(hr);
               SetCreationResult(hr);
               return IDD_TRUSTWIZ_FAILURE_PAGE;
            }

            if (ulDomainVer >= DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
            {
               // Old direction is inbound, so adding outbound to an external
               // trust, check if the user wants to set the other-org bit.
               //
               return IDD_TRUSTWIZ_ORGANIZATION_ATTR_PAGE;
            }
         }
         else
         {
            if (Trust.IsCreateBothSides())
            {
               dwErr = CredMgr.ImpersonateRemote();

               if (NO_ERROR != dwErr)
               {
                  WizError.SetErrorString1(IDS_ERR_CREATE_BAD_CREDS);
                  WizError.SetErrorString2Hr(dwErr);
                  _hr = HRESULT_FROM_WIN32(dwErr);
                  return IDD_TRUSTWIZ_FAILURE_PAGE;
               }

               hr = OtherDomain.GetDomainVersion(NULL, &ulDomainVer);

               CredMgr.Revert();

               if (FAILED(hr))
               {
                  WizError.SetErrorString2Hr(hr);
                  SetCreationResult(hr);
                  return IDD_TRUSTWIZ_FAILURE_PAGE;
               }

               if (ulDomainVer >= DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
               {
                  // Old direction is outbound, so adding a new outbound direction
                  // to the remote side.
                  //
                  return IDD_TRUSTWIZ_ORG_ATTR_REMOTE_PAGE;
               }
            }
         }
      }
      else
      {
         if (TRUST_DIRECTION_OUTBOUND & Trust.GetNewTrustDirection())
         {
            dwErr = CredMgr.ImpersonateLocal();

            if (NO_ERROR != dwErr)
            {
               WizError.SetErrorString1(IDS_ERR_CREATE_BAD_CREDS);
               WizError.SetErrorString2Hr(dwErr);
               _hr = HRESULT_FROM_WIN32(dwErr);
               return IDD_TRUSTWIZ_FAILURE_PAGE;
            }

            hr = TrustPage()->GetDomainVersion(NULL, &ulDomainVer);

            CredMgr.Revert();

            if (FAILED(hr))
            {
               WizError.SetErrorString2Hr(hr);
               SetCreationResult(hr);
               return IDD_TRUSTWIZ_FAILURE_PAGE;
            }

            if (ulDomainVer >= DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
            {
               // It is a new external/forest trust with an outbound component,
               // check if the user wants to set the other-org bit.
               //
               return IDD_TRUSTWIZ_ORGANIZATION_ATTR_PAGE;
            }
         }
         else
         {
            if (Trust.IsCreateBothSides())
            {
               dwErr = CredMgr.ImpersonateRemote();

               if (NO_ERROR != dwErr)
               {
                  WizError.SetErrorString1(IDS_ERR_CREATE_BAD_CREDS);
                  WizError.SetErrorString2Hr(dwErr);
                  _hr = HRESULT_FROM_WIN32(dwErr);
                  return IDD_TRUSTWIZ_FAILURE_PAGE;
               }

               hr = OtherDomain.GetDomainVersion(NULL, &ulDomainVer);

               CredMgr.Revert();

               if (FAILED(hr))
               {
                  WizError.SetErrorString2Hr(hr);
                  SetCreationResult(hr);
                  return IDD_TRUSTWIZ_FAILURE_PAGE;
               }

               if (ulDomainVer >= DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
               {
                  // New trust is inbound direction, so creating a new outbound
                  // trust on the remote side.
                  //
                  return IDD_TRUSTWIZ_ORG_ATTR_REMOTE_PAGE;
               }
            }
         }
      }
   }
   return IDD_TRUSTWIZ_SELECTIONS;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::CreateOrUpdateTrust
//
//  Synopsis:  When called, enough information has been gathered to create
//             the trust. All of this info is in the Trust member object.
//             Go ahead and create the trust.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::CreateOrUpdateTrust(void)
{
   TRACER(CNewTrustWizard, CreateOrUpdateTrust);
   HRESULT hr = S_OK;
   DWORD dwErr = NO_ERROR;

   dwErr = CredMgr.ImpersonateLocal();

   if (ERROR_SUCCESS != dwErr)
   {
      WizError.SetErrorString2Hr(dwErr);
      _hr = HRESULT_FROM_WIN32(dwErr);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   if (Trust.IsCreateBothSides())
   {
      // Generate a random trust password.
      //
      WCHAR wzPW[MAX_COMPUTERNAME_LENGTH] = {0};

      dwErr = GenerateRandomPassword(wzPW, MAX_COMPUTERNAME_LENGTH);

      if (ERROR_SUCCESS != dwErr)
      {
         WizError.SetErrorString2Hr(dwErr);
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      Trust.SetTrustPW(wzPW);
   }

   CPolicyHandle cPolicy(TrustPage()->GetUncDcName());

   dwErr = cPolicy.OpenReqAdmin();

   if (ERROR_SUCCESS != dwErr)
   {
      dspDebugOut((DEB_ITRACE, "LsaOpenPolicy returned 0x%x\n", dwErr));
      WizError.SetErrorString2Hr(dwErr);
      _hr = HRESULT_FROM_WIN32(dwErr);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }

   if (Trust.Exists())
   {
      // This is a modify rather than create operation.
      //
      dwErr = Trust.DoModify(cPolicy, OtherDomain);

      CredMgr.Revert();

      if (ERROR_ALREADY_EXISTS == dwErr)
      {
         WizError.SetErrorString1(IDS_TWERR_ALREADY_EXISTS);
         WizError.SetErrorString2(IDS_TWERR_CANT_CHANGE);
         _hr = E_FAIL;
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
      if (ERROR_SUCCESS != dwErr)
      {
         // TODO: better error reporting
         WizError.SetErrorString2Hr(dwErr);
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }
   else
   {
      // Create a new trust.
      //
      dwErr = Trust.DoCreate(cPolicy, OtherDomain);

      CredMgr.Revert();

      if (ERROR_SUCCESS != dwErr)
      {
         // TODO: better error reporting
         WizError.SetErrorString2Hr(dwErr);
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   if (Trust.IsCreateBothSides())
   {
      dwErr = CredMgr.ImpersonateRemote();

      if (ERROR_SUCCESS != dwErr)
      {
         WizError.SetErrorString2Hr(dwErr);
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }

      if (Trust.Exists())
      {
         dwErr = OtherDomain.DoModify(Trust, TrustPage());
      }
      else
      {
         dwErr = OtherDomain.DoCreate(Trust, TrustPage());
      }

      CredMgr.Revert();

      if (ERROR_SUCCESS != dwErr)
      {
         if (!Trust.Exists())
         {
            // Delete the local trust that was just created.
            //
            CredMgr.ImpersonateLocal();
            LSA_HANDLE hTrustedDomain = NULL;
            LSA_UNICODE_STRING Name;
            RtlInitUnicodeString(&Name, Trust.GetTrustpartnerName());

            NTSTATUS Status = LsaOpenTrustedDomainByName(cPolicy,
                                                         &Name,
                                                         TRUSTED_ALL_ACCESS,
                                                         &hTrustedDomain);
            if (NT_SUCCESS(Status))
            {
               dspAssert(hTrustedDomain);

               Status = LsaDelete(hTrustedDomain);

               LsaClose(hTrustedDomain);
            }
            CredMgr.Revert();
#if DBG == 1
            if (!NT_SUCCESS(Status))
            {
               dspDebugOut((DEB_ERROR, "Open/Delete failed with error 0x%08x\n",
                            Status));
            }
#endif
            // Handle known errors.
            //
            if (Trust.IsXForest() &&
                ERROR_INVALID_DOMAIN_STATE == dwErr)
            {
               // The other domain doesn't qualify for a forest trust. It has
               // already been checked to be a forest root, so it must be at
               // the wrong behavior version.
               //
               WizError.SetErrorString1(IDS_TW_OTHER_WRONG_VER);
               WizError.SetErrorString2(IDS_TW_OTHER_FIX_WRONG_VER);
               _hr = HRESULT_FROM_WIN32(dwErr);
               return IDD_TRUSTWIZ_FAILURE_PAGE;
            }
         }
         else
         {
            // Restore the prior direction on the TDO.
            //
         }

         WizError.SetErrorString2Hr(dwErr);
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   if (Trust.GetTrustType() == TRUST_TYPE_MIT)
   {
      // If Realm, go to trust OK page.
      //
      return IDD_TRUSTWIZ_COMPLETE_OK_PAGE;
   }

   _fQuarantineSet = Trust.WasQuarantineSet () || OtherDomain.WasQuarantineSet ();
   return IDD_TRUSTWIZ_STATUS_PAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::TrustExistCheck
//
//  Synopsis:  Look for an existing trust and if found save the state.
//
//  Returns:   Zero for success or a page ID if creds are needed or an error
//             occured.
//-----------------------------------------------------------------------------
int
CNewTrustWizard::TrustExistCheck(BOOL fPrompt)
{
   TRACER(CNewTrustWizard,TrustExistCheck);
   NTSTATUS Status = STATUS_SUCCESS;
   DWORD dwErr = NO_ERROR;
   PTRUSTED_DOMAIN_FULL_INFORMATION pFullInfo = NULL;

   CPolicyHandle cPolicy(TrustPage()->GetUncDcName());

   if (CredMgr.IsLocalSet())
   {
      CredMgr.ImpersonateLocal();
   }

   dwErr = cPolicy.OpenReqAdmin();

   if (ERROR_SUCCESS != dwErr)
   {
      CredMgr.Revert();

      if ((STATUS_ACCESS_DENIED == dwErr || ERROR_ACCESS_DENIED == dwErr) &&
          fPrompt)
      {
         // send prompt message to creds page. If the creds are good then
         // call TrustExistCheck().
         //
         CredMgr.DoRemote(false);
         CredMgr.SetAdmin();
         CredMgr.SetDomain(TrustPage()->GetDnsDomainName());
         if (!CredMgr.SetNextFcn(new CallTrustExistCheck(this)))
         {
            WizError.SetErrorString2Hr(E_OUTOFMEMORY);
            _hr = E_OUTOFMEMORY;
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
         return IDD_TRUSTWIZ_CREDS_PAGE;
      }
      else
      {
         dspDebugOut((DEB_ITRACE, "LsaOpenPolicy returned 0x%x\n", dwErr));
         WizError.SetErrorString2Hr(dwErr);
         _hr = HRESULT_FROM_WIN32(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   Status = Trust.Query(cPolicy, OtherDomain, NULL, &pFullInfo);

   CredMgr.Revert();

   if (STATUS_SUCCESS == Status)
   {
      dspAssert(pFullInfo);

      // NTBUG#NTRAID9-658659-2002/07/02-ericb
      if (pFullInfo->Information.TrustType != Trust.GetTrustType() &&
          !(TRUST_TYPE_DOWNLEVEL == pFullInfo->Information.TrustType &&
            TRUST_TYPE_UPLEVEL == Trust.GetTrustType()))
      {
         // The current domain state is not the same as that stored on the TDO.
         //
         UINT nID1 = IDS_WZERR_TYPE_UNEXPECTED, nID2 = IDS_WZERR_TYPE_DELETE;
         CStrW strErr, strFormat;
         switch (pFullInfo->Information.TrustType)
         {
         case TRUST_TYPE_MIT:
            //
            // The domain was contacted and is a Windows domain, yet the TDO
            // thinks it is an MIT trust.
            //
            nID1 = IDS_WZERR_TYPE_MIT;
            break;

         case TRUST_TYPE_DOWNLEVEL:
         case TRUST_TYPE_UPLEVEL:
            if (Trust.GetTrustType() == TRUST_TYPE_MIT)
            {
               //
               // The domain cannot be contacted, yet the TDO says it is a
               // Windows trust.
               //
               nID1 = IDS_WZERR_TYPE_WIN;
               nID2 = IDS_WZERR_TYPE_NOT_FOUND;
            }
            break;
         }

         // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
         strFormat.LoadString(g_hInstance, nID1);
         strErr.Format(strFormat, OtherDomain.GetUserEnteredName());
         WizError.SetErrorString1(strErr);
         WizError.SetErrorString2(IDS_WZERR_TYPE_DELETE);
         _hr = E_FAIL;
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
      Trust.SetExists();
      Trust.SetTrustDirection(pFullInfo->Information.TrustDirection);
      Trust.SetTrustAttr(pFullInfo->Information.TrustAttributes);
      LsaFreeMemory(pFullInfo);
   }
   else
   {
      // If the object isn't found, then a trust doesn't already exist. That
      // isn't an error. The CTrust::_fExists property is initilized to be
      // FALSE. If some other status is returned, then that is an error.
      //
      if (STATUS_OBJECT_NAME_NOT_FOUND != Status)
      {
         dspDebugOut((DEB_ITRACE, "LsaQueryTDIBN returned 0x%x\n", Status));
         WizError.SetErrorString2Hr(LsaNtStatusToWinError(Status));
         _hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status));
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::VerifyOutboundTrust
//
//  Synopsis:  Verify the outbound trust.
//
//-----------------------------------------------------------------------------
void
CNewTrustWizard::VerifyOutboundTrust(void)
{
    TRACER(CNewTrustWizard,VerifyOutboundTrust);
    DWORD dwRet = NO_ERROR;

    dspAssert(Trust.GetTrustDirection() & TRUST_DIRECTION_OUTBOUND);

    if (CredMgr.IsLocalSet())
    {
        dwRet = CredMgr.ImpersonateLocal();

        if (ERROR_SUCCESS != dwRet)
        {
            VerifyTrust.BadOutboundCreds(dwRet);
            return;
        }
        // Because the login uses the LOGON32_LOGON_NEW_CREDENTIALS flag, no
        // attempt is made to use the credentials until a remote resource is
        // accessed. Thus, we don't yet know if the user entered credentials are
        // valid at this point. Use LsaOpenPolicy to do a quick check.
        //
        CPolicyHandle Policy(TrustPage()->GetUncDcName());

        dwRet = Policy.OpenReqAdmin();

        if (ERROR_SUCCESS != dwRet)
        {
            VerifyTrust.BadOutboundCreds(dwRet);
            CredMgr.Revert();
            return;
        }
        Policy.Close();
    }

    // First try the DNS Name
    VerifyTrust.VerifyOutbound( TrustPage()->GetUncDcName(),
                                OtherDomain.GetDnsDomainName());

    if ( 
         VerifyTrust.GetOutboundResult () == ERROR_NO_SUCH_DOMAIN
       )
    {
        // Try the FlatName, this might be an upgraded trust.
        VerifyTrust.ClearOutboundResults ();
        VerifyTrust.VerifyOutbound( TrustPage()->GetUncDcName(), 
                                    OtherDomain.GetDomainFlatName());
    }
    CredMgr.Revert();

    return;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::VerifyInboundTrust
//
//  Synopsis:  Verify the inbound trust.
//
//-----------------------------------------------------------------------------
void
CNewTrustWizard::VerifyInboundTrust(void)
{
    TRACER(CNewTrustWizard,VerifyInboundTrust);
    DWORD dwRet = NO_ERROR;

    dspAssert(Trust.GetTrustDirection() & TRUST_DIRECTION_INBOUND);

    if (CredMgr.IsRemoteSet())
    {
        dwRet = CredMgr.ImpersonateRemote();

        if (ERROR_SUCCESS != dwRet)
        {
            VerifyTrust.BadInboundCreds(dwRet);
            return;
        }

        CPolicyHandle Policy(OtherDomain.GetUncDcName());

        dwRet = Policy.OpenReqAdmin();

        if (ERROR_SUCCESS != dwRet)
        {
            VerifyTrust.BadInboundCreds(dwRet);
            return;
        }
        Policy.Close();
    }

    // First try with DNS name
    VerifyTrust.VerifyInbound(OtherDomain.GetDcName(),
                                OtherDomain.IsUplevel() ?
                                    TrustPage()->GetDnsDomainName() :
                                    TrustPage()->GetDomainFlatName()
                            );
                                
    if ( 
         VerifyTrust.GetInboundResult () == ERROR_NO_SUCH_DOMAIN
       )
    {
        // Try with the Flat name, might be an upgraded trust
        VerifyTrust.ClearInboundResults ();
        VerifyTrust.VerifyInbound(OtherDomain.GetDcName(), TrustPage()->GetDomainFlatName() );
    }

    CredMgr.Revert();
    return;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::CreateDefaultFTInfos
//
//  Synopsis:  Create default FTInfos to be added to the TDOs with just the
//             forest TLN and forest domain entries for the case where the user
//             has skipped the verification or the verification failed.
//
//  Arguments: [strErr] - used to return the error string if fPostVerify is true.
//             [fPostVerify] - set to true when this method is called after a
//                             verification failed. The error string is then
//                             appended to the verification results.
//
//  Returns:   Zero for success or a page ID if an error occured.
//
//-----------------------------------------------------------------------------
int
CNewTrustWizard::CreateDefaultFTInfos(CStrW & strErr, bool fPostVerify)
{
   DWORD dwErr = NO_ERROR;

   if (!Trust.CreateDefaultFTInfo(OtherDomain.GetDnsDomainName(),
                                  OtherDomain.GetDomainFlatName(),
                                  OtherDomain.GetSid()))
   {
      dwErr = ERROR_NOT_ENOUGH_MEMORY;
      goto DoError;
   }

   CredMgr.ImpersonateLocal();

   dwErr = Trust.WriteFTInfo(TrustPage()->GetUncDcName());

   CredMgr.Revert();

   if (ERROR_SUCCESS != dwErr)
   {
      goto DoError;
   }

   if (Trust.IsCreateBothSides())
   {
      if (!OtherDomain.CreateDefaultFTInfo(TrustPage()->GetDnsDomainName(),
                                           TrustPage()->GetDomainFlatName(),
                                           TrustPage()->GetSid()))
      {
         dwErr = ERROR_NOT_ENOUGH_MEMORY;
         goto DoError;
      }

      CredMgr.ImpersonateRemote();

      dwErr = OtherDomain.WriteFTInfo();

      CredMgr.Revert();

      if (ERROR_SUCCESS != dwErr)
      {
         goto DoError;
      }
   }

DoError:

   if (ERROR_SUCCESS != dwErr)
   {
      CStrW strErrMsg, strFormat;
      if (fPostVerify)
      {
         // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
         strErrMsg.LoadString(g_hInstance, IDS_ERR_CANT_CREATE_DEFAULT);
         strErr += g_wzCRLF;
         strErr += strErrMsg;
         PWSTR pwzMsg = NULL;
         // NOTICE-2002/02/18-ericb - SecurityPush: FormatMessage is allocating
         // the return buffer, so check that FormatMessage returns a non-zero
         // char count and that the message buffer pointer is non-null.
         if (FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            NULL,
                            dwErr,
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (PWSTR)&pwzMsg,
                            0,
                            NULL) &&
             pwzMsg != NULL)
         {
            strFormat.LoadString(g_hInstance, IDS_FMT_STRING_ERROR_MSG);
            strErrMsg.Format(strFormat, pwzMsg);
            LocalFree(pwzMsg);
            pwzMsg = NULL;
            strErr += g_wzCRLF;
            strErr += strErrMsg;
         }
         strErr += g_wzCRLF;
         return dwErr;
      }
      else
      {
         WizError.SetErrorString1(IDS_ERR_CANT_CREATE_DEFAULT);
         WizError.SetErrorString2Hr(dwErr);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   return dwErr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CNewTrustWizard::ValidateTrustPassword
//
//  Synopsis:  Check that the new trust password entered by the user conforms
//             to domain password policy.
//
//  Returns:   IDD_TRUSTWIZ_PW_MATCH_PAGE - if the password fails the policy.
//             IDD_TRUSTWIZ_FAILURE_PAGE - if the NetValidate call fails.
//             zero - for success (the password is accepted).
//-----------------------------------------------------------------------------
int
CNewTrustWizard::ValidateTrustPassword(PCWSTR pwzPW)
{
   NET_API_STATUS NetStatus = NO_ERROR;
   //
   // NTRAID#NTBUG9-617030-2002/05/09-ericb
   // Bind to NetValidatePasswordPolicy dynamically since it is not present
   // on XP client.
   //
   HINSTANCE hNetApiInstance = 0;
   {
      CWaitCursor wait;
      // Load the library
      hNetApiInstance =::LoadLibrary(L"netapi32.dll");
   }

   if (hNetApiInstance == NULL)
   {
      DBG_OUT("Unable to load netapi32.dll.\n");
      HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
      SetCreationResult(hr);
      WizError.SetErrorString1(IDS_TRUST_PW_CHECK_FAILED);
      WizError.SetErrorString2Hr(hr);
      return IDD_TRUSTWIZ_FAILURE_PAGE;
   }
   typedef NET_API_STATUS (*PFnCheckPw)(
      IN LPCWSTR ServerName,
      IN LPVOID Qualifier,
      IN NET_VALIDATE_PASSWORD_TYPE ValidationType,
      IN LPVOID InputArg,
      OUT LPVOID *OutputArg
      );
   PFnCheckPw pfn;

   pfn = (PFnCheckPw)::GetProcAddress(hNetApiInstance, "NetValidatePasswordPolicy");

   if (!pfn)
   {
      // Must be running on XP, NetValidatePasswordPolicy not exported by netapi32.dll
      //
      (void)::FreeLibrary(hNetApiInstance);
      return 0; // skip the check.
   }

   NET_VALIDATE_PASSWORD_RESET_INPUT_ARG ResetPwIn = {0};
   PNET_VALIDATE_OUTPUT_ARG pCheckPwOut = NULL;

   ResetPwIn.ClearPassword = const_cast<PWSTR>(pwzPW);

   NetStatus = pfn(TrustPage()->GetUncDcName(),
                   NULL,
                   NetValidatePasswordReset,
                   &ResetPwIn,
                   (LPVOID*)&pCheckPwOut);

   (void)::FreeLibrary(hNetApiInstance);

   if (NERR_Success == NetStatus && pCheckPwOut)
   {
      _nPasswordStatus = pCheckPwOut->ValidationStatus;

      // ISSUE: 4/18/02, ericb: there will be a new memory free function for NetValidatePasswordPolicy,
      // so this will need to be replaced when that is available. Using NetApiBufferFree
      // will leak memory.
      // NetValidatePasswordPolicyFree(pCheckPwOut);
      NetApiBufferFree(pCheckPwOut);

      if (NERR_Success != _nPasswordStatus)
      {
         return IDD_TRUSTWIZ_PW_MATCH_PAGE;
      }
   }
   else
   {
       // If NetStatus has returned a failure, we could not
       // check the password policy, allow trust creation to
       // proceed
       dspDebugOut ( (DEB_WARN, "Password policy could not be validated. Proceeding with trust creation. Error no. 0x%x\n", NetStatus) ); 
   }
   return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyTrust::Verify
//
//  Synopsis:  Verify the trust and record the results.
//
//-----------------------------------------------------------------------------
DWORD
CVerifyTrust::Verify(PCWSTR pwzDC, PCWSTR pwzDomain, BOOL fInbound)
{
   TRACER(CVerifyTrust,Verify);
   dspDebugOut((DEB_ITRACE, "Verifying %ws on %ws to %ws\n",
                fInbound ? L"inbound" : L"outbound", pwzDC, pwzDomain));
   DWORD dwRet = NO_ERROR;
   NET_API_STATUS NetStatus = NO_ERROR;
   BOOL fVerifySupported = TRUE;
   PNETLOGON_INFO_2 NetlogonInfo2 = NULL;
   PDS_DOMAIN_TRUSTS rgDomains = NULL;
   ULONG DomainCount = 0;

   dspAssert(pwzDC && pwzDomain);

   // DsEnumerateDomainTrusts will block if there is a NetLogon trust
   // update in progress. Call it to insure that our trust changes are
   // known by NetLogon before we do the query/reset.
   //
   dwRet = DsEnumerateDomainTrusts(const_cast<PWSTR>(pwzDC),
                                   DS_DOMAIN_IN_FOREST | DS_DOMAIN_DIRECT_OUTBOUND | DS_DOMAIN_DIRECT_INBOUND,
                                   &rgDomains, &DomainCount);
   if (ERROR_SUCCESS == dwRet)
   {
      NetApiBufferFree(rgDomains);
   }
   else
   {
      dspDebugOut((DEB_ERROR,
                   "**** DsEnumerateDomainTrusts ERROR <%s @line %d> -> %d\n",
                   __FILE__, __LINE__, dwRet));
   }

   if (fInbound)
   {
      _fInboundVerified = TRUE;
   }
   else
   {
      _fOutboundVerified = TRUE;
   }

   // First try a non-destructive trust password verification.
   //
   NetStatus = I_NetLogonControl2(pwzDC,
                                  NETLOGON_CONTROL_TC_VERIFY,
                                  2,
                                  (LPBYTE)&pwzDomain,
                                  (LPBYTE *)&NetlogonInfo2);

   if (NERR_Success == NetStatus)
   {
      dspAssert(NetlogonInfo2);

      if (NETLOGON_VERIFY_STATUS_RETURNED & NetlogonInfo2->netlog2_flags)
      {
         // The status of the verification is in the
         // netlog2_pdc_connection_status field.
         //
         NetStatus = NetlogonInfo2->netlog2_pdc_connection_status;

         dspDebugOut((DEB_ITRACE,
                      "NetLogon SC verify for %ws on DC %ws gives verify status %d to DC %ws\n\n",
                      pwzDomain, pwzDC, NetStatus,
                      NetlogonInfo2->netlog2_trusted_dc_name));

         if (ERROR_DOMAIN_TRUST_INCONSISTENT == NetStatus)
         {
            // The trust attribute types don't match; one side is
            // forest but the other isn't.
            //
            NetApiBufferFree(NetlogonInfo2);

            SetResult(NetStatus, fInbound);

            return NetStatus;
         }
      }
      else
      {
         NetStatus = NetlogonInfo2->netlog2_tc_connection_status;

         dspDebugOut((DEB_ITRACE,
                      "NetLogon SC verify for %ws on pre-2474 DC %ws gives conection status %d to DC %ws\n\n",
                      pwzDomain, pwzDC, NetStatus,
                      NetlogonInfo2->netlog2_trusted_dc_name));
      }

      NetApiBufferFree(NetlogonInfo2);
   }
   else
   {
      if (ERROR_INVALID_LEVEL == NetStatus ||
          ERROR_NOT_SUPPORTED == NetStatus ||
          RPC_S_PROCNUM_OUT_OF_RANGE == NetStatus ||
          RPC_NT_PROCNUM_OUT_OF_RANGE == NetStatus)
      {
         dspDebugOut((DEB_ITRACE, "NETLOGON_CONTROL_TC_VERIFY is not supported on %ws\n", pwzDC));
         fVerifySupported = FALSE;
      }
      else
      {
         dspDebugOut((DEB_ITRACE,
                      "NetLogon SC Verify for %ws on DC %ws returns error 0x%x\n\n",
                      pwzDomain, pwzDC, NetStatus));
      }
   }

   CStrW strResult;
   PWSTR pwzErr = NULL;

   if (NERR_Success == NetStatus)
   {
      // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
      strResult.LoadString(g_hInstance,
                           fInbound ? IDS_TRUST_VERIFY_INBOUND : IDS_TRUST_VERIFY_OUTBOUND);
      AppendResultString(strResult, fInbound);
      return NO_ERROR;
   }
   else
   {
      if (fVerifySupported)
      {
         // Ignore ERROR_NO_LOGON_SERVERS because that is often due to the SC
         // just not being set up yet.
         //
         if (ERROR_NO_LOGON_SERVERS == NetStatus)
         {
            strResult.LoadString(g_hInstance, IDS_VERIFY_TCV_LOGSRV);
            AppendResultString(strResult, fInbound);
            AppendResultString(g_wzCRLF, fInbound);
         }
         else
         {
            // LoadErrorMessage calls FormatMessage for a message from the
            // system and places a crlf at the end of the string,
            // so don't place another afterwards.
            LoadErrorMessage(NetStatus, 0, &pwzErr);
            dspAssert(pwzErr);
            bool fDelete = true;
            if (!pwzErr)
            {
               pwzErr = L"";
               fDelete = false;
            }
            // NOTICE-2002/02/18-ericb - SecurityPush: if CStrW::FormatMessage
            // fails it sets the string value to an empty string.
            strResult.FormatMessage(g_hInstance, IDS_VERIFY_TCV_FAILED, NetStatus, pwzErr);
            if (fDelete) delete [] pwzErr;
            pwzErr = NULL;
            AppendResultString(strResult, fInbound);
         }
      }
      else
      {
         PCWSTR pwz = pwzDC;
         if (L'\\' == *pwzDC) pwz = pwzDC + 2; // Raid 488452.
         strResult.FormatMessage(g_hInstance, IDS_VERIFY_TCV_NSUPP, pwz); //Raid #344552
         AppendResultString(strResult, fInbound);
         AppendResultString(g_wzCRLF, fInbound);
      }
      strResult.LoadString(g_hInstance, IDS_VERIFY_DOING_RESET);
      AppendResultString(strResult, fInbound);
   }

   // Now try a secure channel reset.
   //
   NetStatus = I_NetLogonControl2(pwzDC,
                                  NETLOGON_CONTROL_REDISCOVER,
                                  2,
                                  (LPBYTE)&pwzDomain,
                                  (LPBYTE *)&NetlogonInfo2);

   if (NERR_Success == NetStatus)
   {
      dspAssert(NetlogonInfo2);

      NetStatus = NetlogonInfo2->netlog2_tc_connection_status;

      dspDebugOut((DEB_ITRACE,
                   "NetLogon SC reset for %ws on DC %ws gives status %d to DC %ws\n\n",
                   pwzDomain, pwzDC, NetStatus,
                   NetlogonInfo2->netlog2_trusted_dc_name));

      NetApiBufferFree(NetlogonInfo2);
   }
   else
   {
      dspDebugOut((DEB_ITRACE,
                   "NetLogon SC reset for %ws on DC %ws returns error 0x%x\n\n",
                   pwzDomain, pwzDC, NetStatus));
   }

   AppendResultString(g_wzCRLF, fInbound);

   if (NERR_Success == NetStatus)
   {
      strResult.LoadString(g_hInstance,
                           fInbound ? IDS_TRUST_VERIFY_INBOUND : IDS_TRUST_VERIFY_OUTBOUND);
      return NO_ERROR;
   }
   else
   {
      LoadErrorMessage(NetStatus, 0, &pwzErr);
      dspAssert(pwzErr);
      if (!pwzErr)
      {
         pwzErr = L"";
      }
      strResult.FormatMessage(g_hInstance, IDS_VERIFY_RESET_FAILED, NetStatus, pwzErr);
      delete [] pwzErr;
   }
   AppendResultString(strResult, fInbound);

   SetResult(NetStatus, fInbound);

   return NetStatus;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyTrust::ClearResults
//
//-----------------------------------------------------------------------------
void
CVerifyTrust::ClearResults(void)
{
   TRACER(CVerifyTrust,ClearResults);
   _strInboundResult.Empty();
   _strOutboundResult.Empty();
   _dwInboundResult = _dwOutboundResult = 0;
   _fInboundVerified = _fOutboundVerified = FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyTrust::ClearInboundResults
//
//-----------------------------------------------------------------------------
void 
CVerifyTrust::ClearInboundResults (void)
{
    TRACER(CVerifyTrust,ClearInboundResults);
    _strInboundResult.Empty();
    _dwInboundResult = 0;
    _fInboundVerified = FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyTrust::ClearOutboundResults
//
//-----------------------------------------------------------------------------
void 
CVerifyTrust::ClearOutboundResults (void)
{
    TRACER(CVerifyTrust,ClearOutboundResults);
    _strOutboundResult.Empty();
    _dwOutboundResult = 0;
    _fOutboundVerified = FALSE;
}


//+----------------------------------------------------------------------------
//
//  Method:    CVerifyTrust::BadInboundCreds
//
//-----------------------------------------------------------------------------
void
CVerifyTrust::BadInboundCreds(DWORD dwErr)
{
   TRACER(CVerifyTrust,BadInboundCreds);
   // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
   _strInboundResult.LoadString(g_hInstance, IDS_ERR_CANT_VERIFY_CREDS);
   _dwInboundResult = dwErr;
   _fInboundVerified = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CVerifyTrust::BadOutboundCreds
//
//-----------------------------------------------------------------------------
void
CVerifyTrust::BadOutboundCreds(DWORD dwErr)
{
   TRACER(CVerifyTrust,BadOutboundCreds);
   // NOTICE-2002/02/18-ericb - SecurityPush: see above CStrW::Loadstring notice
   _strOutboundResult.LoadString(g_hInstance, IDS_ERR_CANT_VERIFY_CREDS);
   _dwOutboundResult = dwErr;
   _fOutboundVerified = TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::CreateDefaultFTInfo
//
//  Synopsis:  Create a default FTInfo to be added to the TDO with just the
//             forest TLN and forest domain entries for the case where the user
//             has skipped the verification or the verification failed.
//
//-----------------------------------------------------------------------------
bool
CTrust::CreateDefaultFTInfo(PCWSTR pwzForestRoot, PCWSTR pwzNBName, PSID pSid)
{
   return _FTInfo.CreateDefault(pwzForestRoot, pwzNBName, pSid);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::Query
//
//  Synopsis:  Read the TDO.
//
//-----------------------------------------------------------------------------
NTSTATUS
CTrust::Query(LSA_HANDLE hPolicy,
              CRemoteDomain & OtherDomain,
              PLSA_UNICODE_STRING pName, // optional, can be NULL
              PTRUSTED_DOMAIN_FULL_INFORMATION * ppFullInfo)
{
   NTSTATUS Status = STATUS_SUCCESS;
   LSA_UNICODE_STRING Name = {0};

   if (!pName)
   {
      pName = &Name;
   }

   if (_strTrustPartnerName.IsEmpty())
   {
      switch (GetTrustType())
      {
      case TRUST_TYPE_UPLEVEL:
         _strTrustPartnerName = IsUpdated() ? OtherDomain.GetDomainFlatName() :
                                              OtherDomain.GetDnsDomainName();
         break;

      case TRUST_TYPE_DOWNLEVEL:
         _strTrustPartnerName = OtherDomain.GetDomainFlatName();
         break;

      case TRUST_TYPE_MIT:
         _strTrustPartnerName = OtherDomain.GetUserEnteredName();
         break;

      default:
         dspAssert(FALSE);
         return STATUS_INVALID_PARAMETER;
      }
   }

   RtlInitUnicodeString(pName, _strTrustPartnerName);

   Status = LsaQueryTrustedDomainInfoByName(hPolicy,
                                            pName,
                                            TrustedDomainFullInformation,
                                            (PVOID *)ppFullInfo);

   // NTBUG#NTRAID9-658659-2002/07/02-ericb
   if (STATUS_OBJECT_NAME_NOT_FOUND == Status &&
       TRUST_TYPE_UPLEVEL == GetTrustType())
   {
      // If we haven't tried the flat name yet, try it now; can get here if a
      // downlevel domain is upgraded to NT5. The name used the first time
      // that Query is called would be the DNS name but the TDO would be
      // named after the flat name.
      //
      dspDebugOut((DEB_ITRACE, "LsaQueryTDIBN: DNS name failed, trying flat name\n"));

      RtlInitUnicodeString(pName, OtherDomain.GetDomainFlatName());

      Status = LsaQueryTrustedDomainInfoByName(hPolicy,
                                               pName,
                                               TrustedDomainFullInformation,
                                               (PVOID *)ppFullInfo);
      if (STATUS_SUCCESS == Status)
      {
         // Remember the fact that the flat name had to be used.
         //
         SetUpdated();
      }
   }

   return Status;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::DoCreate
//
//  Synopsis:  Create the trust based on the settings in the CTrust object.
//
//-----------------------------------------------------------------------------
DWORD
CTrust::DoCreate(LSA_HANDLE hPolicy, CRemoteDomain & OtherDomain)
{
   TRACER(CTrust, DoCreate);
   NTSTATUS Status = STATUS_SUCCESS;
   TRUSTED_DOMAIN_INFORMATION_EX tdix = {0};
   LSA_AUTH_INFORMATION AuthData = {0};
   TRUSTED_DOMAIN_AUTH_INFORMATION AuthInfoEx = {0};

   GetSystemTimeAsFileTime((PFILETIME)&AuthData.LastUpdateTime);

   AuthData.AuthType = TRUST_AUTH_TYPE_CLEAR;
   AuthData.AuthInfoLength = static_cast<ULONG>(GetTrustPWlen() * sizeof(WCHAR));
   AuthData.AuthInfo = (PUCHAR)GetTrustPW();


   if (GetNewTrustDirection() & TRUST_DIRECTION_INBOUND)
   {
      AuthInfoEx.IncomingAuthInfos = 1;
      AuthInfoEx.IncomingAuthenticationInformation = &AuthData;
      AuthInfoEx.IncomingPreviousAuthenticationInformation = NULL;
   }

   if (GetNewTrustDirection() & TRUST_DIRECTION_OUTBOUND)
   {
      AuthInfoEx.OutgoingAuthInfos = 1;
      AuthInfoEx.OutgoingAuthenticationInformation = &AuthData;
      AuthInfoEx.OutgoingPreviousAuthenticationInformation = NULL;

      //Set the Quarantined bit on all outgoing External trusts
      if ( IsExternal() && !IsXForest () && !IsRealm() )
      {
        SetNewTrustAttr ( GetNewTrustAttr () | TRUST_ATTRIBUTE_QUARANTINED_DOMAIN );
        //Remember that we set this attribute
        _fQuarantineSet = true;
      }
   }

   tdix.TrustAttributes = GetNewTrustAttr();

   switch (GetTrustType())
   {
   case TRUST_TYPE_UPLEVEL:
      RtlInitUnicodeString(&tdix.Name, OtherDomain.GetDnsDomainName());
      RtlInitUnicodeString(&tdix.FlatName, OtherDomain.GetDomainFlatName());
      tdix.Sid = OtherDomain.GetSid();
      tdix.TrustType = TRUST_TYPE_UPLEVEL;
      SetTrustPartnerName(OtherDomain.GetDnsDomainName());
      break;

   case TRUST_TYPE_DOWNLEVEL:
      RtlInitUnicodeString(&tdix.Name, OtherDomain.GetDomainFlatName());
      RtlInitUnicodeString(&tdix.FlatName, OtherDomain.GetDomainFlatName());
      tdix.Sid = OtherDomain.GetSid();
      tdix.TrustType = TRUST_TYPE_DOWNLEVEL;
      SetTrustPartnerName(OtherDomain.GetDomainFlatName());
      break;

   case TRUST_TYPE_MIT:
      RtlInitUnicodeString(&tdix.Name, OtherDomain.GetUserEnteredName());
      RtlInitUnicodeString(&tdix.FlatName, OtherDomain.GetUserEnteredName());
      tdix.Sid = NULL;
      tdix.TrustType = TRUST_TYPE_MIT;
      SetTrustPartnerName(OtherDomain.GetUserEnteredName());
      break;

   default:
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }
   tdix.TrustDirection = GetNewTrustDirection();

   LSA_HANDLE hTrustedDomain;

   Status = LsaCreateTrustedDomainEx(hPolicy,
                                     &tdix,
                                     &AuthInfoEx,
                                     TRUSTED_SET_AUTH | TRUSTED_SET_POSIX,
                                     &hTrustedDomain);
   if (NT_SUCCESS(Status))
   {
      LsaClose(hTrustedDomain);
      SetTrustDirection(GetNewTrustDirection());
      SetTrustAttr(GetNewTrustAttr());
   }
   else
   {
      dspDebugOut((DEB_ITRACE, "LsaCreateTrustedDomainEx failed with error 0x%x\n",
                   Status));
   }

   return LsaNtStatusToWinError(Status);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::DoModify
//
//  Synopsis:  Modify the trust based on the settings in the CTrust object.
//
//-----------------------------------------------------------------------------
DWORD
CTrust::DoModify(LSA_HANDLE hPolicy, CRemoteDomain & OtherDomain)
{
   TRACER(CTrust, DoModify);

   _ulNewDir = GetTrustDirection() ^ GetNewTrustDirection();
   BOOL fSetAttr = GetTrustAttr() != GetNewTrustAttr();

   if (!_ulNewDir & !fSetAttr)
   {
      // Nothing to do.
      //
      return ERROR_ALREADY_EXISTS;
   }

   NTSTATUS Status = STATUS_SUCCESS;
   PTRUSTED_DOMAIN_FULL_INFORMATION pFullInfo = NULL;
   LSA_UNICODE_STRING Name = {0};

   Status = Query(hPolicy, OtherDomain, &Name, &pFullInfo);

   if (STATUS_SUCCESS != Status)
   {
      dspDebugOut((DEB_ITRACE, "Trust.Query returned 0x%x\n", Status));
      return LsaNtStatusToWinError(Status);
   }

   dspAssert(pFullInfo);

   LSA_AUTH_INFORMATION AuthData = {0};
   BOOL fSidSet = FALSE;

   if (_ulNewDir)
   {
      GetSystemTimeAsFileTime((PFILETIME)&AuthData.LastUpdateTime);

      AuthData.AuthType = TRUST_AUTH_TYPE_CLEAR;
      AuthData.AuthInfoLength = static_cast<ULONG>(GetTrustPWlen() * sizeof(WCHAR));
      AuthData.AuthInfo = (PUCHAR)GetTrustPW();

      if (TRUST_DIRECTION_INBOUND == _ulNewDir)
      {
         // Adding Inbound.
         //
         pFullInfo->AuthInformation.IncomingAuthInfos = 1;
         pFullInfo->AuthInformation.IncomingAuthenticationInformation = &AuthData;
         pFullInfo->AuthInformation.IncomingPreviousAuthenticationInformation = NULL;
      }
      else
      {
         // Adding outbound.
         //
         pFullInfo->AuthInformation.OutgoingAuthInfos = 1;
         pFullInfo->AuthInformation.OutgoingAuthenticationInformation = &AuthData;
         pFullInfo->AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;

         // Set quarantine bit by default on outgoing external trusts
         if ( IsExternal() && !IsXForest () && !IsRealm () )
         {
             SetNewTrustAttr ( GetNewTrustAttr () | TRUST_ATTRIBUTE_QUARANTINED_DOMAIN );
             //Remember that we set this attribute
             _fQuarantineSet = true;
         }

         fSetAttr = GetTrustAttr() != GetNewTrustAttr();
      }
      pFullInfo->Information.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
      //
      // Check for a NULL domain SID. The SID can be NULL if the inbound
      // trust was created when the domain was NT4. MIT trusts don't have a SID.
      //
      if (!pFullInfo->Information.Sid && (TRUST_TYPE_MIT != GetTrustType()))
      {
         pFullInfo->Information.Sid = OtherDomain.GetSid();
         fSidSet = TRUE;
      }
   }

   if (fSetAttr)
   {
      pFullInfo->Information.TrustAttributes = GetNewTrustAttr();
   }

   Status = LsaSetTrustedDomainInfoByName(hPolicy,
                                          &Name,
                                          TrustedDomainFullInformation,
                                          pFullInfo);
   if (fSidSet)
   {
      // the SID memory is owned by OtherDomain, so don't free it here.
      //
      pFullInfo->Information.Sid = NULL;
   }
   LsaFreeMemory(pFullInfo);

   if (NT_SUCCESS(Status))
   {
      SetTrustDirection(GetNewTrustDirection());
      SetTrustAttr(GetNewTrustAttr());
   }

   return LsaNtStatusToWinError(Status);
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::SetXForest
//
//-----------------------------------------------------------------------------
void
CTrust::SetXForest(bool fMakeXForest)
{
   if (!_dwNewAttr)
   {
      _dwNewAttr = _dwAttr;
   }
   if (fMakeXForest)
   {
      _dwNewAttr |= TRUST_ATTRIBUTE_FOREST_TRANSITIVE;
   }
   else
   {
      _dwNewAttr &= ~TRUST_ATTRIBUTE_FOREST_TRANSITIVE;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::SetTrustAttr
//
//-----------------------------------------------------------------------------
void
CTrust::SetTrustAttr(DWORD attr)
{
   TRACER(CTrust,SetTrustAttr);

   _dwAttr = _dwNewAttr = attr;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::IsXForest
//
//-----------------------------------------------------------------------------
bool
CTrust::IsXForest(void) const
{
   return _dwAttr & TRUST_ATTRIBUTE_FOREST_TRANSITIVE ||
          _dwNewAttr & TRUST_ATTRIBUTE_FOREST_TRANSITIVE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::Clear
//
//-----------------------------------------------------------------------------
void
CTrust::Clear(void)
{
   _strTrustPartnerName.Empty();
   _strTrustPW.Empty();
   _dwType = 0;
   _dwDirection = 0;
   _dwNewDirection = 0;
   _dwAttr = 0;
   _dwNewAttr = 0;
   _fExists = FALSE;
   _fUpdatedFromNT4 = FALSE;
   _fExternal = FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::ReadFTInfo
//
//  Synopsis:  Read the forest trust name suffixes claimed by the trust
//             partner (the remote domain) and save them on the local TDO.
//
//  Arguments: [pwzLocalDC] - the name of the local DC.
//             [pwzOtherDC] - the DC of the trust partner.
//             [CredMgr]    - credentials obtained earlier.
//             [WizErr]     - reference to the error object.
//             [fCredErr]   - if true, then the return value is a page ID.
//
//  Returns:   Page ID or error code depending on the value of fCredErr.
//
//-----------------------------------------------------------------------------
DWORD
CTrust::ReadFTInfo(PCWSTR pwzLocalDC, PCWSTR pwzOtherDC, CCredMgr & CredMgr,
                   CWizError & WizErr, bool & fCredErr)
{
   TRACER(CTrust,ReadFTInfo);
   DWORD dwRet = NO_ERROR;

   if (!IsXForest() || _strTrustPartnerName.IsEmpty() || !pwzLocalDC ||
       !pwzOtherDC)
   {
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }

   PLSA_FOREST_TRUST_INFORMATION pNewFTInfo = NULL;

   if (GetNewTrustDirection() == TRUST_DIRECTION_INBOUND)
   {
      // Inbound-only trust must have the name fetch remoted to the other
      // domain.
      //
      if (CredMgr.IsRemoteSet())
      {
         dwRet = CredMgr.ImpersonateRemote();

         if (ERROR_SUCCESS != dwRet)
         {
            fCredErr = true;
            WizErr.SetErrorString1(IDS_ERR_CANT_SAVE_CREDS);
            WizErr.SetErrorString2Hr(dwRet);
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
      }

      dwRet = DsGetForestTrustInformationW(pwzOtherDC,
                                           NULL,
                                           0,
                                           &pNewFTInfo);
      CredMgr.Revert();

      if (NO_ERROR != dwRet)
      {
         return dwRet;
      }

      dspAssert(pNewFTInfo);

      // Read the locally known names and then merge them with the names
      // discovered from the other domain.
      //
      NTSTATUS status = STATUS_SUCCESS;
      LSA_UNICODE_STRING TrustPartner = {0};
      PLSA_FOREST_TRUST_INFORMATION pKnownFTInfo = NULL, pMergedFTInfo = NULL;

      RtlInitUnicodeString(&TrustPartner, _strTrustPartnerName);

      if (CredMgr.IsLocalSet())
      {
         dwRet = CredMgr.ImpersonateLocal();

         if (ERROR_SUCCESS != dwRet)
         {
            NetApiBufferFree(pNewFTInfo);
            fCredErr = true;
            WizErr.SetErrorString1(IDS_ERR_CANT_SAVE_CREDS);
            WizErr.SetErrorString2Hr(dwRet);
            return IDD_TRUSTWIZ_FAILURE_PAGE;
         }
      }

      CPolicyHandle cPolicy(pwzLocalDC);

      dwRet = cPolicy.OpenNoAdmin();

      if (NO_ERROR != dwRet)
      {
         return dwRet;
      }

      status = LsaQueryForestTrustInformation(cPolicy,
                                              &TrustPartner,
                                              &pKnownFTInfo);
      if (STATUS_NOT_FOUND == status)
      {
         // no FT info stored yet, which is the expected state for a new trust.
         //
         status = STATUS_SUCCESS;
      }

      if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
      {
         NetApiBufferFree(pNewFTInfo);
         CredMgr.Revert();
         return dwRet;
      }

      if (pKnownFTInfo && pKnownFTInfo->RecordCount)
      {
         // Merge the two.
         //
         dwRet = DsMergeForestTrustInformationW(_strTrustPartnerName,
                                                pNewFTInfo,
                                                pKnownFTInfo,
                                                &pMergedFTInfo);
         NetApiBufferFree(pNewFTInfo);

         CHECK_WIN32(dwRet, return dwRet);

         dspAssert(pMergedFTInfo);

         _FTInfo = pMergedFTInfo;

         LsaFreeMemory(pKnownFTInfo);
         LsaFreeMemory(pMergedFTInfo);
      }
      else
      {
         _FTInfo = pNewFTInfo;

         NetApiBufferFree(pNewFTInfo);
      }

      // Now write the data. On return from the call the pColInfo struct
      // will contain current collision data.
      //
      PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo = NULL;

      status = LsaSetForestTrustInformation(cPolicy,
                                            &TrustPartner,
                                            _FTInfo.GetFTInfo(),
                                            FALSE,
                                            &pColInfo);
      CredMgr.Revert();

      if (NO_ERROR != (dwRet = LsaNtStatusToWinError(status)))
      {
         return dwRet;
      }

      _CollisionInfo = pColInfo;

      return NO_ERROR;
   }

   // Outbound or bi-di trust, call DsGetForestTrustInfo locally with the
   // flag set to update the TDO.
   //
   if (CredMgr.IsLocalSet())
   {
      dwRet = CredMgr.ImpersonateLocal();

      if (ERROR_SUCCESS != dwRet)
      {
         fCredErr = true;
         WizErr.SetErrorString1(IDS_ERR_CANT_SAVE_CREDS);
         WizErr.SetErrorString2Hr(dwRet);
         return IDD_TRUSTWIZ_FAILURE_PAGE;
      }
   }

   dwRet = DsGetForestTrustInformationW(pwzLocalDC,
                                        _strTrustPartnerName,
                                        DS_GFTI_UPDATE_TDO,
                                        &pNewFTInfo);
   if (NO_ERROR != dwRet)
   {
      CredMgr.Revert();
      return dwRet;
   }

   _FTInfo = pNewFTInfo;

   NetApiBufferFree(pNewFTInfo);

   //
   // Check for name conflicts.
   //
   dwRet = WriteFTInfo(pwzLocalDC, false);

   CredMgr.Revert();

   return dwRet;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::WriteFTInfo
//
//-----------------------------------------------------------------------------
DWORD
CTrust::WriteFTInfo(PCWSTR pwzLocalDC, bool fWrite)
{
   TRACER(CTrust,WriteFTInfo);
   DWORD dwRet = NO_ERROR;

   if (!IsXForest() || _strTrustPartnerName.IsEmpty() || !_FTInfo.GetCount() ||
       !pwzLocalDC)
   {
      dspAssert(FALSE);
      return ERROR_INVALID_PARAMETER;
   }

   NTSTATUS status = STATUS_SUCCESS;
   LSA_UNICODE_STRING Name = {0};
   PLSA_FOREST_TRUST_COLLISION_INFORMATION pColInfo = NULL, pColInfo2 = NULL;

   RtlInitUnicodeString(&Name, _strTrustPartnerName);

   CPolicyHandle cPolicy(pwzLocalDC);

   dwRet = cPolicy.OpenReqAdmin();

   if (ERROR_SUCCESS != dwRet)
   {
      return dwRet;
   }

   status = LsaSetForestTrustInformation(cPolicy,
                                         &Name,
                                         _FTInfo.GetFTInfo(),
                                         TRUE,
                                         &pColInfo);
   if (STATUS_SUCCESS != status)
   {
      return LsaNtStatusToWinError(status);
   }

   if (pColInfo && pColInfo->RecordCount)
   {
      PLSA_FOREST_TRUST_COLLISION_RECORD pRec = NULL;
      PLSA_FOREST_TRUST_RECORD pFTRec = NULL;

      for (UINT i = 0; i < pColInfo->RecordCount; i++)
      {
         pRec = pColInfo->Entries[i];
         pFTRec = _FTInfo.GetFTInfo()->Entries[pRec->Index];

         dspDebugOut((DEB_ITRACE, "Collision on record %d, type %d, flags 0x%x, name %ws\n",
                      pRec->Index, pRec->Type, pRec->Flags, pRec->Name.Buffer));

         switch (pFTRec->ForestTrustType)
         {
         case ForestTrustTopLevelName:
         case ForestTrustTopLevelNameEx:
            dspDebugOut((DEB_ITRACE, "Referenced FTInfo: %ws, type: TLN\n",
                         pFTRec->ForestTrustData.TopLevelName.Buffer));
            pFTRec->Flags = pRec->Flags;
            break;

         case ForestTrustDomainInfo:
            dspDebugOut((DEB_ITRACE, "Referenced FTInfo: %ws, type: Domain\n",
                         pFTRec->ForestTrustData.DomainInfo.DnsName.Buffer));
            pFTRec->Flags = pRec->Flags;
            break;

         default:
            break;
         }
      }
   }

   status = LsaSetForestTrustInformation(cPolicy,
                                         &Name,
                                         _FTInfo.GetFTInfo(),
                                         !fWrite,
                                         &pColInfo2);
   if (STATUS_SUCCESS != status)
   {
      return LsaNtStatusToWinError(status);
   }

   if (pColInfo2)
   {
      _CollisionInfo = pColInfo2;

      if (pColInfo)
      {
         LsaFreeMemory(pColInfo);
      }
   }
   else
   {
      _CollisionInfo = pColInfo;
   }

#if DBG == 1
   if (pColInfo && pColInfo->RecordCount)
   {
      PLSA_FOREST_TRUST_COLLISION_RECORD pRec;

      for (UINT i = 0; i < pColInfo->RecordCount; i++)
      {
         pRec = pColInfo->Entries[i];

         dspDebugOut((DEB_ITRACE, "Collision on record %d, type %d, flags 0x%x, name %ws\n",
                      pRec->Index, pRec->Type, pRec->Flags, pRec->Name.Buffer));
      }
   }
#endif

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::AreThereCollisions
//
//-----------------------------------------------------------------------------
bool
CTrust::AreThereCollisions(void) const
{
   if (_CollisionInfo.IsInConflict() || _FTInfo.IsInConflict())
   {
      return TRUE;
   }

   return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::GetTrustDirStrID
//
//-----------------------------------------------------------------------------
int
CTrust::GetTrustDirStrID(DWORD dwDir) const
{
   switch (dwDir)
   {
   case TRUST_DIRECTION_INBOUND:
      return IDS_TRUST_DIR_INBOUND_SHORTCUT;

   case TRUST_DIRECTION_OUTBOUND:
      return IDS_TRUST_DIR_OUTBOUND_SHORTCUT;

   case TRUST_DIRECTION_BIDIRECTIONAL:
      return IDS_TRUST_DIR_BIDI;

   default:
      return IDS_TRUST_DISABLED;
   }
}

//+----------------------------------------------------------------------------
//
//  Method:    CTrust::IsOneWayOutBoundForest
//
//-----------------------------------------------------------------------------
bool
CTrust::IsOneWayOutBoundForest(void) const
{
   if (!IsXForest())
   {
      return false;
   }

   bool fOutbound = TRUST_DIRECTION_OUTBOUND == _dwDirection;

   if (_dwNewDirection)
   {
      // If the new direction is set, see if it is outbound only.
      //
      fOutbound = TRUST_DIRECTION_OUTBOUND == _dwNewDirection;
   }

   return fOutbound;
}

//+----------------------------------------------------------------------------
//
//  Method:    CQuarantineWarnDlg::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT 
CQuarantineWarnDlg::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if ( id == IDOK && codeNotify == BN_CLICKED )
    {
        if ( IsDlgButtonChecked( _hDlg, IDC_QUARANTINE_POPUP_CHK) == BST_CHECKED )
        {
            HKEY hKey = NULL;
            DWORD regValue = 0x1;

            if ( RegCreateKeyEx (  HKEY_CURRENT_USER, 
                                   L"Software\\Policies\\Microsoft\\Windows\\Directory UI",
                                   NULL,
                                   L"",
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_ALL_ACCESS,
                                   NULL,
                                   &hKey,
                                   NULL
                               ) == ERROR_SUCCESS && hKey )
            {

                RegSetValueEx(
                                hKey,
                                L"SIDFilterNoPopup",
                                NULL,
                                REG_DWORD,
                                (BYTE *)&regValue,
                                sizeof ( DWORD )
                            );
            }

            RegCloseKey ( hKey );
        }
        EndDialog( _hDlg, IDOK); 
    }
    return 0; 
};

//+----------------------------------------------------------------------------
//
//  Method:    CQuarantineWarnDlg::OnCommand
//
//-----------------------------------------------------------------------------
LRESULT 
CQuarantineWarnDlg::OnNotify(WPARAM wParam, LPARAM lParam)
{
    if(wParam == IDC_QUARANTINE_POPUP_STATIC)
    {
        switch (((NMHDR FAR*)lParam)->code)
        {
            //
            //Show the help popup for SIDFiltering
            //
            case NM_CLICK:
            case NM_RETURN:
            {
                    ShowHelp ( L"adconcepts.chm::/domadmin_concepts_explicit.htm#SIDFiltering" );
            }
            break;
        }
    }
    return 0;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\trustwiz.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       trustwiz.h
//
//  Contents:   AD domain trust creation wizard classes and definition.
//
//  Classes:    CNewTrustWizard, CTrustWizPageBase, wizard pages classes.
//
//  History:    04-Aug-00 EricB created
//
//-----------------------------------------------------------------------------

#ifndef TRUSTWIZ_H_GUARD
#define TRUSTWIZ_H_GUARD

#include <list>
#include <stack>
#include "subclass.h"
#include "ftinfo.h"

// forward declarations:
class CCredMgr;
class CDsDomainTrustsPage;
class CNewTrustWizard;
class CTrustWizPageBase;
class CTrustWizCredPage;

//+----------------------------------------------------------------------------
//
//  Class:     CallMember and its derivatives
//
//  Purpose:   Allows a page to indicate what the next step of the creation
//             process should be. It is an abstraction of the process of passing
//             a function pointer.
//
//-----------------------------------------------------------------------------
class CallPolicyRead : public CallMember
{
public:
   CallPolicyRead(CNewTrustWizard * pWiz) : CallMember(pWiz) {}
   ~CallPolicyRead() {}

   HRESULT Invoke(void);
};

class CallTrustExistCheck : public CallMember
{
public:
   CallTrustExistCheck(CNewTrustWizard * pWiz) : CallMember(pWiz) {}
   ~CallTrustExistCheck() {}

   HRESULT Invoke(void);
};

class CallCheckOtherDomainTrust : public CallMember
{
public:
   CallCheckOtherDomainTrust(CNewTrustWizard * pWiz) : CallMember(pWiz) {}
   ~CallCheckOtherDomainTrust() {}

   HRESULT Invoke(void);
};

//+----------------------------------------------------------------------------
//
//  Class:     CWizError
//
//  Purpose:   Gathers error information that will be displayed by the wizard
//             error page.
//
//-----------------------------------------------------------------------------
class CWizError
{
public:
   CWizError() {}
   ~CWizError() {}

   void     SetErrorString1(LPCWSTR pwz) {_strError1 = pwz;}
   // NOTICE-2002/02/18-ericb - SecurityPush: CStrW::LoadString sets the
   // string to an empty string on failure.
   void     SetErrorString1(int nID) {_strError1.LoadString(g_hInstance, nID);}
   void     SetErrorString2(LPCWSTR pwz) {_strError2 = pwz;}
   void     SetErrorString2(int nID) {_strError2.LoadString(g_hInstance, nID);}
   void     SetErrorString2Hr(HRESULT hr, int nID = 0);
   CStrW &  GetErrorString1(void) {return _strError1;}
   CStrW &  GetErrorString2(void) {return _strError2;}

private:
   CStrW    _strError1;
   CStrW    _strError2;

   // not implemented to disallow copying.
   CWizError(const CWizError&);
   const CWizError& operator=(const CWizError&);
};

class CTrust; // forward declaration

//+----------------------------------------------------------------------------
//
//  Class:      CRemoteDomain
//
//  Purpose:    Obtains information about a trust partner domain.
//
//-----------------------------------------------------------------------------
class CRemoteDomain : public CDomainInfo
{
public:
   CRemoteDomain();
   CRemoteDomain(PCWSTR pwzDomainName);
   ~CRemoteDomain() {}

   void SetUserEnteredName(PCWSTR pwzDomain) {Clear(); _strUserEnteredName = pwzDomain;}
   PCWSTR GetUserEnteredName(void) const {return _strUserEnteredName;}
   DWORD TrustExistCheck(bool fOneWayOutBoundForest, CDsDomainTrustsPage * pTrustPage,
                         CCredMgr & CredMgr);
   DWORD DoCreate(CTrust & Trust, CDsDomainTrustsPage * pTrustPage);
   DWORD DoModify(CTrust & Trust, CDsDomainTrustsPage * pTrustPage);
   bool  Exists(void) const {return _fExists;}
   ULONG GetTrustType(void) const {return _ulTrustType;}
   ULONG GetTrustDirection(void) const {return _ulTrustDirection;}
   ULONG GetTrustAttrs(void) const {return _ulTrustAttrs;}
   DWORD ReadFTInfo(ULONG ulDir, PCWSTR pwzLocalDC, CCredMgr & CredMgr,
                    CWizError & WizErr, bool & fCredErr);
   DWORD WriteFTInfo(bool fWrite = true);
   CFTInfo & GetFTInfo(void) {return _FTInfo;}
   bool CreateDefaultFTInfo(PCWSTR pwzForestRoot, PCWSTR pwzNBName, PSID pSid);
   CFTCollisionInfo & GetCollisionInfo(void) {return _CollisionInfo;}
   bool AreThereCollisions(void) const;
   void SetOtherOrgBit(bool fSetBit = true) {_fSetOtherOrgBit = fSetBit;};
   bool IsSetOtherOrgBit(void) const {return _fSetOtherOrgBit;};
   bool IsUpdated (void) const { return _fUpdatedFromNT4; };
   bool WasQuarantineSet (void) { return _fQuarantineSet; }

private:

   NTSTATUS Query(CDsDomainTrustsPage * pTrustPage, PLSA_UNICODE_STRING pName,
                  PTRUSTED_DOMAIN_FULL_INFORMATION * ppFullInfo);

   CStrW          _strUserEnteredName;
   CStrW          _strTrustPartnerName;
   bool           _fUpdatedFromNT4;
   bool           _fExists;
   ULONG          _ulTrustType;
   ULONG          _ulTrustDirection;
   ULONG          _ulTrustAttrs;
   CFTInfo           _FTInfo;
   CFTCollisionInfo  _CollisionInfo;
   bool           _fSetOtherOrgBit;
   bool           _fQuarantineSet;

   // not implemented to disallow copying.
   CRemoteDomain(const CRemoteDomain&);
   const CRemoteDomain& operator=(const CRemoteDomain&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CTrust
//
//  Purpose:   A trust is represented in the AD by a Trusted-Domain object.
//             This class encapsulates the operations and properties of a
//             pending or existing trust.
//
//-----------------------------------------------------------------------------
class CTrust
{
public:
   CTrust() : _dwType(0), _dwDirection(0), _dwNewDirection(0), _dwAttr(0),
              _dwNewAttr(0), _fExists(FALSE), _fUpdatedFromNT4(FALSE),
              _fCreateBothSides(false), _fExternal(FALSE), _fQuarantineSet(false),_ulNewDir(0) {}
   ~CTrust() {}

   // methods
   NTSTATUS Query(LSA_HANDLE hPolicy, CRemoteDomain & OtherDomain,
                  PLSA_UNICODE_STRING pName,
                  PTRUSTED_DOMAIN_FULL_INFORMATION * ppFullInfo);
   DWORD    DoCreate(LSA_HANDLE hPolicy, CRemoteDomain & OtherDomain);
   DWORD    DoModify(LSA_HANDLE hPolicy, CRemoteDomain & OtherDomain);
   DWORD    ReadFTInfo(PCWSTR pwzLocalDC, PCWSTR pwzOtherDC,
                       CCredMgr & CredMgr, CWizError & WizErr, bool & fCredErr);
   DWORD    WriteFTInfo(PCWSTR pwzLocalDC, bool fWrite = true);
   CFTInfo & GetFTInfo(void) {return _FTInfo;}
   bool     CreateDefaultFTInfo(PCWSTR pwzForestRoot, PCWSTR pwzNBName, PSID pSid);
   CFTCollisionInfo & GetCollisionInfo(void) {return _CollisionInfo;}
   bool     AreThereCollisions(void) const;
   void     Clear(void);

   // property access routines.
   void     SetTrustPW(LPCWSTR pwzPW) {_strTrustPW = pwzPW;}
   PCWSTR   GetTrustPW(void) const {return _strTrustPW;}
   size_t   GetTrustPWlen(void) const {return _strTrustPW.GetLength();}
   void     SetTrustType(DWORD type) {_dwType = type;}
   void     SetTrustTypeUplevel(void) {_dwType = TRUST_TYPE_UPLEVEL;}
   void     SetTrustTypeDownlevel(void) {_dwType = TRUST_TYPE_DOWNLEVEL;}
   bool     IsTrustTypeDownlevel(void) const {return TRUST_TYPE_DOWNLEVEL == _dwType;}
   void     SetTrustTypeRealm(void) {_dwType = TRUST_TYPE_MIT;}
   DWORD    GetTrustType(void) const {return _dwType;}
   void     SetTrustDirection(DWORD dir) {_dwDirection = dir;}
   DWORD    GetTrustDirection(void) const {return _dwDirection;}
   int      GetTrustDirStrID(DWORD dwDir) const;
   void     SetNewTrustDirection(DWORD dir) {_dwNewDirection = dir;}
   DWORD    GetNewTrustDirection(void) const {return _dwNewDirection;}
   void     SetTrustAttr(DWORD attr);
   DWORD    GetTrustAttr(void) const {return _dwAttr;}
   void     SetNewTrustAttr(DWORD attr) {_dwNewAttr = attr;}
   DWORD    GetNewTrustAttr(void) const {return _dwNewAttr;}
   void     SetTrustPartnerName(PCWSTR pwzName) {_strTrustPartnerName = pwzName;}
   PCWSTR   GetTrustpartnerName(void) const {return _strTrustPartnerName;}
   void     SetExists(void) {_fExists = TRUE;}
   BOOL     Exists(void) const {return _fExists;}
   void     SetUpdated(void) {_fUpdatedFromNT4 = TRUE;}
   BOOL     IsUpdated(void) const {return _fUpdatedFromNT4;}
   void     SetExternal(BOOL x) {_fExternal = x;}
   BOOL     IsExternal(void) const {return _fExternal;}
   void     SetXForest(bool fMakeXForest);
   bool     IsXForest(void) const;
   bool     IsRealm(void) const {return _dwType == TRUST_TYPE_MIT;};
   void     CreateBothSides(bool fCreate) {_fCreateBothSides = fCreate;}
   bool     IsCreateBothSides(void) const {return _fCreateBothSides;}
   bool     IsOneWayOutBoundForest(void) const;
   bool     WasQuarantineSet (void) { return _fQuarantineSet; }
   ULONG     GetNewDirAdded (void) { return _ulNewDir; }

private:
   CStrW          _strTrustPartnerName;
   CStrW          _strTrustPW;
   DWORD          _dwType;
   DWORD          _dwDirection;
   DWORD          _dwNewDirection;
   DWORD          _dwAttr;
   DWORD          _dwNewAttr;
   BOOL           _fExists;
   BOOL           _fUpdatedFromNT4;
   BOOL           _fExternal;
   bool           _fCreateBothSides;
   CFTInfo           _FTInfo;
   CFTCollisionInfo  _CollisionInfo;
   bool           _fQuarantineSet;
   ULONG          _ulNewDir;

   // not implemented to disallow copying.
   CTrust(const CTrust&);
   const CTrust& operator=(const CTrust&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CVerifyTrust
//
//  Purpose:    Verifies a trust and stores the results.
//
//-----------------------------------------------------------------------------
class CVerifyTrust
{
public:
   CVerifyTrust() : _dwInboundResult(0), _dwOutboundResult(0),
                    _fInboundVerified(FALSE), _fOutboundVerified(FALSE) {}
   ~CVerifyTrust() {}

   DWORD    VerifyInbound(PCWSTR pwzRemoteDC, PCWSTR pwzLocalDomain) {return Verify(pwzRemoteDC, pwzLocalDomain, TRUE);}
   DWORD    VerifyOutbound(PCWSTR pwzLocalDC, PCWSTR pwzRemoteDomain) {return Verify(pwzLocalDC, pwzRemoteDomain, FALSE);}
   void     BadOutboundCreds(DWORD dwErr);
   void     BadInboundCreds(DWORD dwErr);
   DWORD    GetInboundResult(void) const {return _dwInboundResult;}
   DWORD    GetOutboundResult(void) const {return _dwOutboundResult;}
   PCWSTR   GetInboundResultString(void) const {return _strInboundResult;}
   PCWSTR   GetOutboundResultString(void) const {return _strOutboundResult;}
   BOOL     IsInboundVerified(void) const {return _fInboundVerified;}
   BOOL     IsOutboundVerified(void) const {return _fOutboundVerified;}
   BOOL     IsVerified(void) const {return _fInboundVerified || _fOutboundVerified;}
   BOOL     IsVerifiedOK(void) const {return (NO_ERROR == _dwInboundResult) && (NO_ERROR == _dwOutboundResult);}
   void     ClearResults(void);
   void     ClearInboundResults (void);
   void     ClearOutboundResults (void);
   void     AddExtra(PCWSTR pwz) {_strExtra += pwz;}
   PCWSTR   GetExtra(void) const {return _strExtra;}

private:
   DWORD    Verify(PCWSTR pwzDC, PCWSTR pwzDomain, BOOL fInbound);
   void     SetResult(DWORD dwRes, BOOL fInbound) {if (fInbound) _dwInboundResult = dwRes; else _dwOutboundResult = dwRes;}
   void     AppendResultString(PCWSTR pwzRes, BOOL fInbound) {if (fInbound) _strInboundResult += pwzRes; else _strOutboundResult += pwzRes;}
   void     SetInboundResult(DWORD dwRes) {_dwInboundResult = dwRes;}
   void     AppendInboundResultString(PCWSTR pwzRes) {_strInboundResult += pwzRes;}
   void     SetOutboundResult(DWORD dwRes) {_dwOutboundResult = dwRes;}
   void     AppendOutboundResultString(PCWSTR pwzRes) {_strOutboundResult += pwzRes;}

   CStrW    _strInboundResult;
   DWORD    _dwInboundResult;
   CStrW    _strOutboundResult;
   DWORD    _dwOutboundResult;
   BOOL     _fInboundVerified;
   BOOL     _fOutboundVerified;
   CStrW    _strExtra;

   // not implemented to disallow copying.
   CVerifyTrust(const CVerifyTrust&);
   const CVerifyTrust& operator=(const CVerifyTrust&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CNewTrustWizard
//
//  Purpose:    New trust creation wizard.
//
//-----------------------------------------------------------------------------
class CNewTrustWizard
{
public:
   CNewTrustWizard(CDsDomainTrustsPage * pTrustPage);
   ~CNewTrustWizard();

   // Wizard page managment data structures and methods
   HRESULT CreatePages(void);
   HRESULT LaunchModalWiz(void);

   typedef std::stack<unsigned> PAGESTACK;
   typedef std::list<CTrustWizPageBase *> PAGELIST;

   PAGELIST          _PageList;
   PAGESTACK         _PageIdStack;

   void              SetNextPageID(CTrustWizPageBase * pPage, int iNextPageID);
   BOOL              IsBacktracking(void) const {return _fBacktracking;}
   BOOL              HaveBacktracked(void) const {return _fHaveBacktracked;}
   void              ClearBacktracked(void) {_fHaveBacktracked = false;}
   void              BackTrack(HWND hPage);
   void              PopTopPage(void) {_PageIdStack.pop();};
   HFONT             GetTitleFont(void) const {return _hTitleFont;}
   CDsDomainTrustsPage * TrustPage(void) {return _pTrustPage;}
   CTrustWizPageBase * GetPage(unsigned uDlgResId);
   void              SetCreationResult(HRESULT hr) {_hr = hr;}
   HRESULT           GetCreationResult(void) const {return _hr;}
   void              ShowStatus(CStrW & strMsg, bool fNewTrust = true);
   int               ValidateTrustPassword(PCWSTR pwzPW);
   int               GetPasswordValidationStatus(void) const {return _nPasswordStatus;};
   void              ClearPasswordValidationStatus(void) {_nPasswordStatus = 0;};
   bool              WasQuarantineSet (void) { return _fQuarantineSet; }

   // Methods that collect data. They return zero for success or the page ID of
   // the creds page or the page ID of the error page.
   int               GetDomainInfo(void);
   int               TrustExistCheck(BOOL fPrompt = TRUE);

   int               CreateDefaultFTInfos(CStrW & strErr,
                                          bool fPostVerify = false);

   // Methods that implement the steps of trust creation/modification.
   // These are executed in the order listed. They all return the page ID of
   // the next wizard page to be shown.
   int               CollectInfo(void);
   int               ContinueCollectInfo(BOOL fPrompt = TRUE); // continues CollectInfo.
   int               CreateOrUpdateTrust(void);
   void               VerifyOutboundTrust(void);
   void               VerifyInboundTrust(void);

   // Additonal methods passed to CCredMgr::_pNextFcn
   int               RetryCollectInfo(void);
   int               RetryContinueCollectInfo(void); // continues ContinueCollectInfo1 if creds were needed.
   int               CheckOtherDomainTrust(void);

   // Objects that hold state info.
   CTrust            Trust;
   CRemoteDomain     OtherDomain;
   CWizError         WizError;
   CCredMgr          CredMgr;
   CVerifyTrust      VerifyTrust;

private:
   BOOL  AddPage(CTrustWizPageBase * pPage);
   void  MakeBigFont(void);

   CDsDomainTrustsPage *   _pTrustPage; // the wizard is modal so it is OK to hold the parent page's pointer
   BOOL                    _fBacktracking;
   BOOL                    _fHaveBacktracked;
   HFONT                   _hTitleFont;
   int                     _nPasswordStatus;
   bool                    _fQuarantineSet;
   HRESULT                 _hr; // Controls whether the trust list is refreshed.
                                // It should only be set if the new trust
                                // creation failed. If a failure occurs after
                                // a trust is created, don't set this because
                                // in that case we still want the trust list to
                                // be refreshed.

   // not implemented to disallow copying.
   CNewTrustWizard(CNewTrustWizard&);
   const CNewTrustWizard& operator=(const CNewTrustWizard&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizPageBase
//
//  Purpose:    Common base class for wizard pages.
//
//-----------------------------------------------------------------------------
class CTrustWizPageBase
{
public:
   CTrustWizPageBase(CNewTrustWizard * pWiz,
                     UINT uDlgID,
                     UINT uTitleID,
                     UINT uSubTitleID,
                     BOOL fExteriorPage = FALSE);
   virtual ~CTrustWizPageBase();

   //
   //  Static WndProc to be passed to CreatePropertySheetPage.
   //
   static INT_PTR CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg,
                                         WPARAM wParam, LPARAM lParam);
   //
   //  Instance specific window procedure
   //
   LRESULT PageProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

   HPROPSHEETPAGE          Create(void);
   HWND                    GetPageHwnd(void) {return _hPage;}
   UINT                    GetDlgResID(void) {return _uDlgID;}
   CNewTrustWizard *       Wiz(void) {return _pWiz;}
   CRemoteDomain &         OtherDomain(void) {return _pWiz->OtherDomain;}
   CTrust &                Trust(void) {return _pWiz->Trust;}
   CWizError &             WizErr(void) {return _pWiz->WizError;}
   CCredMgr &              CredMgr(void) {return _pWiz->CredMgr;}
   CVerifyTrust &          VerifyTrust() {return _pWiz->VerifyTrust;}
   CDsDomainTrustsPage *   TrustPage(void) {return _pWiz->TrustPage();}

protected:
   virtual int     Validate(void) = 0;
   virtual BOOL    OnInitDialog(LPARAM lParam) = 0;
   virtual LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify) {return false;}
   virtual void    OnSetActive(void) = 0;
   void            OnWizBack(void);
   virtual void    OnWizNext(void);
   virtual void    OnWizFinish(void) {}
   virtual void    OnWizReset(void) {}
   virtual void    OnDestroy(void) {}

   HWND _hPage;
   UINT _uDlgID;
   UINT _uTitleID;
   UINT _uSubTitleID;
   BOOL _fExteriorPage;
   BOOL _fInInit;
   DWORD _dwWizButtons;
   CNewTrustWizard * _pWiz;

private:
   // not implemented to disallow copying.
   CTrustWizPageBase(const CTrustWizPageBase &);
   const CTrustWizPageBase & operator=(const CTrustWizPageBase &);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizIntroPage
//
//  Purpose:    Intro page for trust creation wizard.
//
//-----------------------------------------------------------------------------
class CTrustWizIntroPage : public CTrustWizPageBase
{
public:
   CTrustWizIntroPage(CNewTrustWizard * pWiz) :
         CTrustWizPageBase(pWiz, IDD_TRUSTWIZ_INTRO_PAGE, 0, 0, TRUE)
         {TRACER(CTrustWizIntroPage, CTrustWizIntroPage);}

   ~CTrustWizIntroPage() {}

private:
   int     Validate(void) {return IDD_TRUSTWIZ_NAME_PAGE;}
   BOOL    OnInitDialog(LPARAM lParam);
   void    OnSetActive(void) {PropSheet_SetWizButtons(GetParent(_hPage), PSWIZB_NEXT);}
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   // not implemented to disallow copying.
   CTrustWizIntroPage(const CTrustWizIntroPage&);
   const CTrustWizIntroPage& operator=(const CTrustWizIntroPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizNamePage
//
//  Purpose:    Name and pw page for trust creation wizard.
//
//-----------------------------------------------------------------------------
class CTrustWizNamePage : public CTrustWizPageBase
{
public:
   CTrustWizNamePage(CNewTrustWizard * pWiz);
   ~CTrustWizNamePage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizNamePage(const CTrustWizNamePage&);
   const CTrustWizNamePage& operator=(const CTrustWizNamePage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizSidesPage
//
//  Purpose:    Prompt if one or both sides should be created.
//
//-----------------------------------------------------------------------------
class CTrustWizSidesPage : public CTrustWizPageBase
{
public:
   CTrustWizSidesPage(CNewTrustWizard * pWiz);
   ~CTrustWizSidesPage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizSidesPage(const CTrustWizSidesPage&);
   const CTrustWizSidesPage& operator=(const CTrustWizSidesPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizPasswordPage
//
//  Purpose:    Get the trust password for a one-side trust creation.
//
//-----------------------------------------------------------------------------
class CTrustWizPasswordPage : public CTrustWizPageBase
{
public:
   CTrustWizPasswordPage(CNewTrustWizard * pWiz);
   ~CTrustWizPasswordPage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizPasswordPage(const CTrustWizPasswordPage&);
   const CTrustWizPasswordPage& operator=(const CTrustWizPasswordPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizPwMatchPage
//
//  Purpose:    Trust passwords entered don't match page for trust wizard.
//
//-----------------------------------------------------------------------------
class CTrustWizPwMatchPage : public CTrustWizPageBase
{
public:
   CTrustWizPwMatchPage(CNewTrustWizard * pWiz);
   ~CTrustWizPwMatchPage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);
   void    OnWizNext(void); // override the default.

   void    SetText(void);

   // not implemented to disallow copying.
   CTrustWizPwMatchPage(const CTrustWizPwMatchPage&);
   const CTrustWizPwMatchPage& operator=(const CTrustWizPwMatchPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizCredPage
//
//  Purpose:    Credentials specification page for trust creation wizard.
//
//-----------------------------------------------------------------------------
class CTrustWizCredPage : public CTrustWizPageBase
{
public:
   CTrustWizCredPage(CNewTrustWizard * pWiz);
   ~CTrustWizCredPage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   void    SetText(void);

   BOOL    _fNewCall;

   // not implemented to disallow copying.
   CTrustWizCredPage(const CTrustWizCredPage&);
   const CTrustWizCredPage& operator=(const CTrustWizCredPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CTrustWizMitOrWinPage
//
//  Purpose:   Domain not found, query for Non-Windows trust or re-enter name
//             wizard page.
//
//-----------------------------------------------------------------------------
class CTrustWizMitOrWinPage : public CTrustWizPageBase
{
public:
   CTrustWizMitOrWinPage(CNewTrustWizard * pWiz);
   ~CTrustWizMitOrWinPage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizMitOrWinPage(const CTrustWizMitOrWinPage&);
   const CTrustWizMitOrWinPage& operator=(const CTrustWizMitOrWinPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CTrustWizTransitivityPage
//
//  Purpose:   Realm transitivity page.
//
//-----------------------------------------------------------------------------
class CTrustWizTransitivityPage : public CTrustWizPageBase
{
public:
   CTrustWizTransitivityPage(CNewTrustWizard * pWiz);
   ~CTrustWizTransitivityPage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizTransitivityPage(const CTrustWizTransitivityPage&);
   const CTrustWizTransitivityPage& operator=(const CTrustWizTransitivityPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CTrustWizExternOrForestPage
//
//  Purpose:   External or Forest type trust wizard page.
//
//-----------------------------------------------------------------------------
class CTrustWizExternOrForestPage : public CTrustWizPageBase
{
public:
   CTrustWizExternOrForestPage(CNewTrustWizard * pWiz);
   ~CTrustWizExternOrForestPage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizExternOrForestPage(const CTrustWizExternOrForestPage&);
   const CTrustWizExternOrForestPage& operator=(const CTrustWizExternOrForestPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizDirectionPage
//
//  Purpose:    Trust direction trust wizard page.
//
//-----------------------------------------------------------------------------
class CTrustWizDirectionPage : public CTrustWizPageBase
{
public:
   CTrustWizDirectionPage(CNewTrustWizard * pWiz);
   ~CTrustWizDirectionPage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizDirectionPage(const CTrustWizDirectionPage&);
   const CTrustWizDirectionPage& operator=(const CTrustWizDirectionPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizBiDiPage
//
//  Purpose:    Ask to make a one way trust bidi trust wizard page.
//
//-----------------------------------------------------------------------------
class CTrustWizBiDiPage : public CTrustWizPageBase
{
public:
   CTrustWizBiDiPage(CNewTrustWizard * pWiz);
   ~CTrustWizBiDiPage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   void    OnSetActive(void);
   void    SetSubtitle(void);

   // not implemented to disallow copying.
   CTrustWizBiDiPage(const CTrustWizBiDiPage&);
   const CTrustWizBiDiPage& operator=(const CTrustWizBiDiPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CTrustWizOrganizationPage
//
//  Purpose:   Ask if the trust partner is part of the same organization.
//
//-----------------------------------------------------------------------------
class CTrustWizOrganizationPage : public CTrustWizPageBase
{
public:
   CTrustWizOrganizationPage(CNewTrustWizard * pWiz);
   ~CTrustWizOrganizationPage() {}

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void);
   void     OnSetActive(void);
   void     SetText(bool fBackTracked = false);

   bool     _fForest;
   bool     _fBackTracked;

   // not implemented to disallow copying.
   CTrustWizOrganizationPage(const CTrustWizOrganizationPage&);
   const CTrustWizOrganizationPage& operator=(const CTrustWizOrganizationPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CTrustWizOrgRemotePage
//
//  Purpose:   Ask if the trust partner is part of the same organization.
//             This page is posted if creating both sides and the remote side
//             has an outbound component.
//
//-----------------------------------------------------------------------------
class CTrustWizOrgRemotePage : public CTrustWizPageBase
{
public:
   CTrustWizOrgRemotePage(CNewTrustWizard * pWiz);
   ~CTrustWizOrgRemotePage() {}

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void);
   void     OnSetActive(void);
   void     SetText(bool fBackTracked = false);

   bool     _fForest;
   bool     _fBackTracked;

   // not implemented to disallow copying.
   CTrustWizOrgRemotePage(const CTrustWizOrgRemotePage&);
   const CTrustWizOrgRemotePage& operator=(const CTrustWizOrgRemotePage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizSelectionsPage
//
//  Purpose:    Show the settings that will be used for the trust.
//
//-----------------------------------------------------------------------------
class CTrustWizSelectionsPage : public CTrustWizPageBase
{
public:
   CTrustWizSelectionsPage(CNewTrustWizard * pWiz);
   ~CTrustWizSelectionsPage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);
   void    SetSelections(void);

   MultiLineEditBoxThatForwardsEnterKey   _multiLineEdit;
   BOOL                                   _fSelNeedsRemoving;

   // not implemented to disallow copying.
   CTrustWizSelectionsPage(const CTrustWizSelectionsPage&);
   const CTrustWizSelectionsPage& operator=(const CTrustWizSelectionsPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizVerifyOutboundPage
//
//  Purpose:    Ask to confirm the new outbound trust.
//
//-----------------------------------------------------------------------------
class CTrustWizVerifyOutboundPage : public CTrustWizPageBase
{
public:
   CTrustWizVerifyOutboundPage(CNewTrustWizard * pWiz);
   ~CTrustWizVerifyOutboundPage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizVerifyOutboundPage(const CTrustWizVerifyOutboundPage&);
   const CTrustWizVerifyOutboundPage& operator=(const CTrustWizVerifyOutboundPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizVerifyInboundPage
//
//  Purpose:    Ask to confirm the new inbound trust.
//
//-----------------------------------------------------------------------------
class CTrustWizVerifyInboundPage : public CTrustWizPageBase
{
public:
   CTrustWizVerifyInboundPage(CNewTrustWizard * pWiz);
   ~CTrustWizVerifyInboundPage() {}

private:
   int     Validate(void);
   BOOL    OnInitDialog(LPARAM lParam);
   LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
   void    OnSetActive(void);

   BOOL  _fNeedCreds;

   // not implemented to disallow copying.
   CTrustWizVerifyInboundPage(const CTrustWizVerifyInboundPage&);
   const CTrustWizVerifyInboundPage& operator=(const CTrustWizVerifyInboundPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizStatusPage
//
//  Purpose:    Forest trust has been created and verified, show the status.
//
//-----------------------------------------------------------------------------
class CTrustWizStatusPage : public CTrustWizPageBase
{
public:
   CTrustWizStatusPage(CNewTrustWizard * pWiz);
   ~CTrustWizStatusPage() {}

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void);
   void     OnSetActive(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   MultiLineEditBoxThatForwardsEnterKey   _multiLineEdit;
   BOOL                                   _fSelNeedsRemoving;

   // not implemented to disallow copying.
   CTrustWizStatusPage(const CTrustWizStatusPage&);
   const CTrustWizStatusPage& operator=(const CTrustWizStatusPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CTrustWizSaveSuffixesOnLocalTDOPage
//
//  Purpose:   Forest name suffixes page for saving the remote domain's
//             claimed names on the local TDO.
//
//-----------------------------------------------------------------------------
class CTrustWizSaveSuffixesOnLocalTDOPage : public CTrustWizPageBase
{
public:
   CTrustWizSaveSuffixesOnLocalTDOPage(CNewTrustWizard * pWiz);
   ~CTrustWizSaveSuffixesOnLocalTDOPage() {}

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void);
   void     OnSetActive(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   // not implemented to disallow copying.
   CTrustWizSaveSuffixesOnLocalTDOPage(const CTrustWizSaveSuffixesOnLocalTDOPage&);
   const CTrustWizSaveSuffixesOnLocalTDOPage& operator=(const CTrustWizSaveSuffixesOnLocalTDOPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:     CTrustWizSaveSuffixesOnRemoteTDOPage
//
//  Purpose:   Forest name suffixes page for saving the local domain's
//             claimed names on the remote TDO after creating both sides.
//
//-----------------------------------------------------------------------------
class CTrustWizSaveSuffixesOnRemoteTDOPage : public CTrustWizPageBase
{
public:
   CTrustWizSaveSuffixesOnRemoteTDOPage(CNewTrustWizard * pWiz);
   ~CTrustWizSaveSuffixesOnRemoteTDOPage() {}

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void);
   void     OnSetActive(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   // not implemented to disallow copying.
   CTrustWizSaveSuffixesOnRemoteTDOPage(const CTrustWizSaveSuffixesOnRemoteTDOPage&);
   const CTrustWizSaveSuffixesOnRemoteTDOPage& operator=(const CTrustWizSaveSuffixesOnRemoteTDOPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizDoneOKPage
//
//  Purpose:    Completion page when there are no errors.
//
//-----------------------------------------------------------------------------
class CTrustWizDoneOKPage : public CTrustWizPageBase
{
public:
   CTrustWizDoneOKPage(CNewTrustWizard * pWiz);
   ~CTrustWizDoneOKPage() {}

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void) {return -1;}
   void     OnSetActive(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   MultiLineEditBoxThatForwardsEnterKey   _multiLineEdit;
   BOOL                                   _fSelNeedsRemoving;

   // not implemented to disallow copying.
   CTrustWizDoneOKPage(const CTrustWizDoneOKPage&);
   const CTrustWizDoneOKPage& operator=(const CTrustWizDoneOKPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizDoneVerErrPage
//
//  Purpose:    Completion page for when the verification fails.
//
//-----------------------------------------------------------------------------
class CTrustWizDoneVerErrPage : public CTrustWizPageBase
{
public:
   CTrustWizDoneVerErrPage(CNewTrustWizard * pWiz);
   ~CTrustWizDoneVerErrPage() {}

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void) {return -1;}
   void     OnSetActive(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   MultiLineEditBoxThatForwardsEnterKey   _multiLineEdit;
   BOOL                                   _fSelNeedsRemoving;

   // not implemented to disallow copying.
   CTrustWizDoneVerErrPage(const CTrustWizDoneVerErrPage&);
   const CTrustWizDoneVerErrPage& operator=(const CTrustWizDoneVerErrPage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizFailurePage
//
//  Purpose:    Failure page for trust creation wizard.
//
//-----------------------------------------------------------------------------
class CTrustWizFailurePage : public CTrustWizPageBase
{
public:
   CTrustWizFailurePage(CNewTrustWizard * pWiz);
   ~CTrustWizFailurePage() {}

private:
   BOOL    OnInitDialog(LPARAM lParam);
   int     Validate(void) {return -1;}
   void    OnSetActive(void);

   // not implemented to disallow copying.
   CTrustWizFailurePage(const CTrustWizFailurePage&);
   const CTrustWizFailurePage& operator=(const CTrustWizFailurePage&);
};

//+----------------------------------------------------------------------------
//
//  Class:      CTrustWizAlreadyExistsPage
//
//  Purpose:    Trust already exists page for trust creation wizard.
//
//-----------------------------------------------------------------------------
class CTrustWizAlreadyExistsPage : public CTrustWizPageBase
{
public:
   CTrustWizAlreadyExistsPage(CNewTrustWizard * pWiz);
   ~CTrustWizAlreadyExistsPage() {}

private:
   BOOL     OnInitDialog(LPARAM lParam);
   int      Validate(void) {return -1;}
   void     OnSetActive(void);
   LRESULT  OnCommand(int id, HWND hwndCtl, UINT codeNotify);

   MultiLineEditBoxThatForwardsEnterKey   _multiLineEdit;
   BOOL                                   _fSelNeedsRemoving;

   // not implemented to disallow copying.
   CTrustWizAlreadyExistsPage(const CTrustWizAlreadyExistsPage&);
   const CTrustWizAlreadyExistsPage& operator=(const CTrustWizAlreadyExistsPage&);
};

void
GetOrgText(bool fCreateBothSides,
           bool fIsXForest,
           bool fOtherOrgLocal,
           bool fOtherOrgRemote,
           DWORD dwDirection,
           CStrW & strMsg);

#endif // TRUSTWIZ_H_GUARD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\uacct.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       uacct.cxx
//
//  Contents:   CDsUserAcctPage, the class that implements the user object
//              Accounts property page, and
//              CDsUsrProfilePage for the user profile page.
//
//  History:    10-April-97 EricB created
//              11-Nov-97   EricB split profile out of account page.
//
//-----------------------------------------------------------------------------

#include "pch.h"

#include "uacct.h"
#include "proppage.h"
#include "user.h"
#include "chklist.h"
#include "icanon.h" // I_NetPathType
#include <ntsam.h>
#include <aclapi.h>
//#include <aclapip.h>
#include <seopaque.h>   // in private\inc: RtlObjectAceSid().
#include <lmerr.h>
#include <time.h>

#ifdef DSADMIN

extern ATTR_MAP LogonWkstaBtn = {IDC_LOGON_TO_BTN, FALSE, FALSE, 15,
                                  {wzUserWksta, ADS_ATTR_UPDATE,
                                   ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

extern const GUID GUID_CONTROL_UserChangePassword =
   { 0xab721a53, 0x1e2f, 0x11d0,  { 0x98, 0x19, 0x00, 0xaa, 0x00, 0x40, 0x52, 0x9b}};

/////////////////////////////////////////////////////////////////////
//  DllScheduleDialog()
//
//  Wrapper to call the function LogonScheduleDialog() &
//  ConnectionScheduleDialog ().
//  The wrapper will load the library loghours.dll, export
//  the function LogonScheduleDialog() or
//  ConnectionScheduleDialog () and free the library.
//
//  INTERFACE NOTES
//  This routine has EXACTLY the same interface notes
//  as LogonScheduleDialog() & ConnectionScheduleDialog ().
//
//  The function launches either ConnectionScheduleDialog () or LogonScheduleDialog ()
//  depending on the ID of the title passed in.
//
//  HISTORY
//  21-Jul-97   t-danm      Creation.
//  3-4-98		bryanwal	Modification to launch different dialogs.
//
HRESULT
DllScheduleDialog(
    HWND hwndParent,
    BYTE ** pprgbData,
    int idsTitle,
    LPCTSTR pszName,
    LPCTSTR,
    DWORD dwFlags,
    ScheduleDialogType dlgtype )
{
  ASSERT(::IsWindow(hwndParent));
  static const TCHAR szLibrary[] = _T("LogHours.dll");        // Not subject to localization

  HINSTANCE hInstance = 0;
  {
    CWaitCursor wait;
    // Load the library
    hInstance =::LoadLibrary(szLibrary);
  }

  if (hInstance == NULL)
  {
   TRACE0("Unable to load LogHours.dll.\n");
   return E_UNEXPECTED;
  }
  HRESULT hr = E_UNEXPECTED;
  typedef HRESULT (*PFnUiScheduleDialog)(HWND hwndParent, BYTE ** pprgbData, LPCTSTR pszTitle, DWORD dwFlags);
  PFnUiScheduleDialog pfn;
  switch (dlgtype)
  {
  case SchedDlg_Connection:
  pfn = (PFnUiScheduleDialog)::GetProcAddress( hInstance, "ConnectionScheduleDialogEx" );
  break;
  case SchedDlg_Replication:
  pfn = (PFnUiScheduleDialog)::GetProcAddress( hInstance, "ReplicationScheduleDialogEx" );
  break;
  case SchedDlg_Logon:
  pfn = (PFnUiScheduleDialog)::GetProcAddress( hInstance, "LogonScheduleDialogEx" );
  break;
  default:
  ASSERT (0);
  return E_FAIL;
  }
  if (pfn != NULL)
  {
    // load the dialog title
    PTSTR ptz = NULL;
    if (!LoadStringToTchar(idsTitle, &ptz))
    {
      REPORT_ERROR(E_OUTOFMEMORY, hwndParent);
      (void)::FreeLibrary(hInstance);
      return E_OUTOFMEMORY;
    }
    ASSERT( NULL != ptz );
    if (NULL == pszName)
    {
      hr = pfn(hwndParent, IN OUT pprgbData, ptz, dwFlags);
    }
    else
    {
      LPTSTR ptsz2 = NULL;
      if (!FormatMessage(
             FORMAT_MESSAGE_ALLOCATE_BUFFER |
               FORMAT_MESSAGE_ARGUMENT_ARRAY |
               FORMAT_MESSAGE_FROM_STRING,
               ptz,
               0,
               0,
               reinterpret_cast<LPTSTR>(&ptsz2),
               0,
               (va_list*)(&pszName)) )
      {
		  //NTRAID#NTBUG9-567482-2002/03/10-jmessec   Back up valid failure with code
         ASSERT(FALSE);
      }
      hr = pfn(hwndParent, IN OUT pprgbData, ptsz2, dwFlags);
      LocalFree( ptsz2 );
    }

    delete ptz;
  }
  else
  {
    TRACE0("Unable to find proc address for UiScheduleDialog.\n");
  }
  (void)::FreeLibrary(hInstance);
  if (hr == S_OK)
  {
   // User clicked on OK button

  }
  return hr;
} // DllScheduleDialog()


/////////////////////////////////////////////////////////////////////
//  FIsValidUncPath()
//
//  Return TRUE if a UNC path is valid, otherwise return FALSE.
//
//  HISTORY
//  18-Aug-97   t-danm      Creation.
//
BOOL
FIsValidUncPath(
    LPCTSTR pszPath,    // IN: Path to validate
    UINT uFlags)        // IN: Validation flags
{
  ASSERT(pszPath != NULL);

  if (pszPath[0] == _T('\0'))
  {
    // Empty path
    if (uFlags & VUP_mskfAllowEmptyPath)
        return TRUE;
    return FALSE;
  }

  DWORD dwPathType = 0;
  DWORD dwErr = ::I_NetPathType(0, IN const_cast<TCHAR *>(pszPath), OUT &dwPathType, 0);
  if (dwErr != ERROR_SUCCESS) 
  {
    return FALSE;
  }
  if (uFlags & VUP_mskfAllowUNCPath) 
  {
    if (dwPathType & ITYPE_UNC) 
    {
      return TRUE;
    }
  } 
  else 
  {
    if (dwPathType & ITYPE_ABSOLUTE) 
    {
      return TRUE;
    }
  }
  return FALSE;
} // FIsValidUncPath()


/////////////////////////////////////////////////////////////////////
//  DSPROP_IsValidUNCPath()
//
//  Exported (UNICODE ONLY) entry point to call FIsValidUncPath()
//  for use in DS Admin
//
BOOL DSPROP_IsValidUNCPath(LPCWSTR lpszPath)
{
  if (lpszPath == NULL)
    return FALSE;
  return FIsValidUncPath(lpszPath, VUP_mskfAllowUNCPath);
}


//+----------------------------------------------------------------------------
//
//  Member:     CDsUserAcctPage::CDsUserAcctPage
//
//-----------------------------------------------------------------------------
CDsUserAcctPage::CDsUserAcctPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                 HWND hNotifyObj, DWORD dwFlags) :
    m_dwUsrAcctCtrl(0),
    m_dwUsrAcctCtrlComputed(0),
    m_pargbLogonHours(NULL),
    m_pwzUPN(NULL),
    m_pwzSAMname(NULL),
    m_cchSAMnameCtrl(0),
    m_pSelfSid(NULL),
    m_pWorldSid(NULL),
    m_pWkstaDlg(NULL),
    m_fOrigCantChangePW(FALSE),
    m_fOrigSelfAllowChangePW(FALSE),
    m_fOrigWorldAllowChangePW(FALSE),
    m_fUACWritable(FALSE),
    m_fUPNWritable(FALSE),
    m_fSAMNameWritable(FALSE),
    m_fPwdLastSetWritable(FALSE),
    m_fAcctExpiresWritable(FALSE),
    m_fLoginHoursWritable(FALSE),
    m_fUserWkstaWritable(FALSE),
    m_fLockoutTimeWritable(FALSE),
    m_fNTSDWritable(FALSE),
    m_fSAMNameChanged(FALSE),
    m_fAcctCtrlChanged(FALSE),
    m_fAcctExpiresChanged(FALSE),
    m_fLogonHoursChanged(FALSE),
    m_fIsAdmin(FALSE),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsUserAcctPage,CDsUserAcctPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsUserAcctPage");
#endif
    m_PwdLastSet.HighPart = m_PwdLastSet.LowPart = 0;
    m_LockoutTime.HighPart = m_LockoutTime.LowPart = 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsUserAcctPage::~CDsUserAcctPage
//
//-----------------------------------------------------------------------------
CDsUserAcctPage::~CDsUserAcctPage()
{
  TRACE(CDsUserAcctPage,~CDsUserAcctPage);
  if (m_pargbLogonHours != NULL)
  {
    LocalFree(m_pargbLogonHours);
  }
  DO_DEL(m_pwzUPN);
  DO_DEL(m_pwzSAMname);
  if (m_pSelfSid)
  {
    FreeSid(m_pSelfSid);
  }
  if (m_pWorldSid)
  {
    FreeSid(m_pWorldSid);
  }
  DO_DEL(m_pWkstaDlg);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateUserAcctPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateUserAcctPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR pwzADsPath,
                   PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                   const CDSSmartBasePathsInfo& basePathsInfo, 
                   HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateUserAcctPage);

    CDsUserAcctPage * pPageObj = new CDsUserAcctPage(pDsPage, pDataObj,
                                                     hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CDsUserAcctPage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserAcctPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsUserAcctPage::OnInitDialog(LPARAM)
{
    TRACE(CDsUserAcctPage,OnInitDialog);
    HRESULT hr = S_OK;
    Smart_PADS_ATTR_INFO pAttrs;
    DWORD i, cAttrs = 0, iLogonWksta, iUPN, iSAM, iLoghrs, iUAC, iLastSet,
          iExpires, iSid, iLockout, iUACComputed;
    PWSTR pwz = NULL, pwzDomain = NULL;
    CWaitCursor wait;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    //
    // Set edit control length limit.
    //
    SendDlgItemMessage(m_hPage, IDC_NT4_NAME_EDIT, EM_LIMITTEXT,
                       MAX_SAM_NAME_LEN, 0);
    //
    // Add the check boxes to the scrolling checkbox list.
    //
    TCHAR tzList[161];
    HWND hChkList = GetDlgItem(m_hPage, IDC_CHECK_LIST);

    // The fields that are added are dependent on the domain behavior version
    // Do not add IDS_DELEGATION_OK for Whistler or greater domains.  This
    // will be handled by the delegation page

    UINT* pIDS = 0;
    UINT arrayCount = 0;
    if (GetBasePathsInfo()->GetDomainBehaviorVersion() >= DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
    {
       // Whistler domain version

       static UINT rgIDSWhistler[] = {IDS_MUST_CHANGE_PW, IDS_CANT_CHANGE_PW, IDS_NO_PW_EXPIRE,
                                      IDS_CLEAR_TEXT_PW, IDS_ACCT_DISABLED, IDS_SMARTCARD_REQ,
                                      IDS_NOT_DELEGATED, IDS_DES_KEY_ONLY,
                                      IDS_DONT_REQ_PREAUTH};
       pIDS = rgIDSWhistler;
       arrayCount = ARRAYLENGTH(rgIDSWhistler);
    }
    else
    {
       // Windows 2000 domain version

       static UINT rgIDSW2K[] = {IDS_MUST_CHANGE_PW, IDS_CANT_CHANGE_PW, IDS_NO_PW_EXPIRE,
                                 IDS_CLEAR_TEXT_PW, IDS_ACCT_DISABLED, IDS_SMARTCARD_REQ,
                                 IDS_DELEGATION_OK, IDS_NOT_DELEGATED, IDS_DES_KEY_ONLY,
                                 IDS_DONT_REQ_PREAUTH};
       pIDS = rgIDSW2K;
       arrayCount = ARRAYLENGTH(rgIDSW2K);
    }

    for (i = 0; i < arrayCount; i++)
    {
        LOAD_STRING(pIDS[i], tzList, 160, return E_OUTOFMEMORY);
        SendMessage(hChkList, CLM_ADDITEM, (WPARAM)tzList, pIDS[i]);
    }

    //
    // Check which attributes are writable.
    //
    m_fUACWritable = CheckIfWritable(g_wzUserAccountControl);
    m_fUPNWritable = CheckIfWritable(wzUPN);
    m_fSAMNameWritable = CheckIfWritable(wzSAMname);
    m_fPwdLastSetWritable = CheckIfWritable(wzPwdLastSet);
    m_fAcctExpiresWritable = CheckIfWritable(wzAcctExpires);
    m_fLoginHoursWritable = CheckIfWritable(wzLogonHours);
    m_fUserWkstaWritable = CheckIfWritable(wzUserWksta);
    m_fLockoutTimeWritable = CheckIfWritable(wzLockoutTime);
    m_fNTSDWritable = CheckIfWritable(wzSecDescriptor);

    //
    // Get the attribute values.
    //
    PWSTR rgpwzAttrNames[] = {g_wzUserAccountControl, wzUserAccountControlComputed,
                              wzUPN, wzSAMname, wzPwdLastSet,
                              wzAcctExpires, wzLogonHours, wzUserWksta,
                              wzLockoutTime, g_wzObjectSID};

    hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames,
                                       ARRAYLENGTH(rgpwzAttrNames),
                                       &pAttrs, &cAttrs);
    if (!CHECK_ADS_HR(&hr, GetHWnd()))
    {
        return hr;
    }

    CSmartWStr spwzUserDN;

    hr = SkipPrefix(GetObjPathName(), &spwzUserDN);
    CHECK_HRESULT(hr, return hr);

    iLogonWksta = iUPN = iSAM = iLoghrs = iUAC = iLastSet = iExpires = iSid = iLockout = iUACComputed = cAttrs; // set to a flag value.
    //
    // Locate the returned values.
    //
    for (i = 0; i < cAttrs; i++)
    {
        dspAssert(pAttrs[i].dwNumValues);
        dspAssert(pAttrs[i].pADsValues);

        if (_wcsicmp(pAttrs[i].pszAttrName, wzUPN) == 0)
        {
            iUPN = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzSAMname) == 0)
        {
            iSAM = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzPwdLastSet) == 0)
        {
            iLastSet = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, g_wzUserAccountControl) == 0)
        {
            iUAC = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzUserAccountControlComputed) == 0)
        {
            iUACComputed = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzAcctExpires) == 0)
        {
            iExpires = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzLogonHours) == 0)
        {
            iLoghrs = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzUserWksta) == 0)
        {
            iLogonWksta = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, g_wzObjectSID) == 0)
        {
            iSid = i;
            continue;
        }
        if (_wcsicmp(pAttrs[i].pszAttrName, wzLockoutTime) == 0)
        {
            iLockout = i;
            continue;
        }
    }

    HWND hctlDateTime = GetDlgItem(m_hPage, IDC_ACCT_EXPIRES);
    int idRadioButton = IDC_ACCT_NEVER_EXPIRES_RADIO;

    //
    // User Principle Name.
    //
    PWSTR pwzUsrSuffix = NULL;

    if (iUPN < cAttrs)
    {
        dspAssert(pAttrs[iUPN].pADsValues->CaseIgnoreString);
        //
        // Search for the last at-sign in case there is more than one.
        // If found, put the preceeding characters in the first edit
        // control and use the remainder to match on the suffix combo box.
        // Otherwise, put everything in the first.
        //
        if (!AllocWStr(pAttrs[iUPN].pADsValues->CaseIgnoreString, &m_pwzUPN))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            return E_OUTOFMEMORY;
        }

        pwzUsrSuffix = wcsrchr(pAttrs[iUPN].pADsValues->CaseIgnoreString, L'@');

        if (pwzUsrSuffix)
        {
            *pwzUsrSuffix = L'\0';

            SetDlgItemText(m_hPage, IDC_NT5_NAME_EDIT,
                           pAttrs[iUPN].pADsValues->CaseIgnoreString);

            *pwzUsrSuffix = L'@';
        }
        else
        {
            SetDlgItemText(m_hPage, IDC_NT5_NAME_EDIT, m_pwzUPN);
        }
    }

    FillSuffixCombo(pwzUsrSuffix);

    //
    // SAM account name - put the downlevel domain name in the first
    // field and the SAM name in the second.
    //
    if (iSAM < cAttrs)
    {
        dspAssert(pAttrs[iSAM].pADsValues->CaseIgnoreString);

        if (!AllocWStr(pAttrs[iSAM].pADsValues->CaseIgnoreString, &m_pwzSAMname))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            return E_OUTOFMEMORY;
        }

        SetDlgItemText(m_hPage, IDC_NT4_NAME_EDIT, m_pwzSAMname);

        m_cchSAMnameCtrl = wcslen(m_pwzSAMname);
    }

    hr = CrackName(spwzUserDN, &pwzDomain, GET_NT4_DOMAIN_NAME, m_hPage);

    if (FAILED(hr))
    {
        ERR_MSG(IDS_UACCT_NO_DOMAIN, m_hPage);
        SetDlgItemText(m_hPage, IDC_NT4_DOMAIN, L"");
    }
    else
    {
        pwz = new WCHAR[wcslen(pwzDomain) + 2];
        CHECK_NULL_REPORT(pwz, m_hPage, return E_OUTOFMEMORY);

        wcscpy(pwz, pwzDomain);
        wcscat(pwz, L"\\");

        SetDlgItemText(m_hPage, IDC_NT4_DOMAIN, pwz);

        if (pwz)
        {
           delete[] pwz;
           pwz = 0;
        }
        LocalFreeStringW(&pwzDomain);
    }

    //
    // Object SID. Extract the RID and check if this is a well-known security
    // principle that requires special processing.
    //
    if (iSid < cAttrs)
    {
        if (!IsValidSid(pAttrs[iSid].pADsValues->OctetString.lpValue))
        {
            ErrMsg(IDS_INVALID_SID, m_hPage);
        }
        else
        {
            PSID pSid = pAttrs[iSid].pADsValues->OctetString.lpValue;

            // find RID part of SID
            //
            PUCHAR saCount = GetSidSubAuthorityCount(pSid);
            PULONG pRid = GetSidSubAuthority(pSid, (ULONG)*saCount - 1);

            dspAssert(pRid);

            if ((*pRid == DOMAIN_USER_RID_ADMIN) ||
                (*pRid == DOMAIN_USER_RID_KRBTGT))
            {
                m_fIsAdmin = TRUE;
                //
                // Disable those operations not allowed on these accounts.
                //
                EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO), FALSE);
                m_fLoginHoursWritable = FALSE;
                m_fUserWkstaWritable = FALSE;
                if (*pRid == DOMAIN_USER_RID_KRBTGT)
                {
                    m_fUACWritable = FALSE;
                    m_fSAMNameWritable = FALSE;
                }
            }
        }
    }

    //
    // User Account Control flags. This is a required attribute but may not
    // be readable due to the objects ACLs and the user's token privileges.
    //
    if (iUAC < cAttrs)
    {
        BOOL fCheckedState = CLST_CHECKED;

        if (!m_fUACWritable)
        {
            fCheckedState = CLST_CHECKDISABLED;
        }

        m_dwUsrAcctCtrl = pAttrs[iUAC].pADsValues->Integer;

        if (m_dwUsrAcctCtrl & UF_DONT_EXPIRE_PASSWD)
        {
            CheckList_SetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, CLST_DISABLED);
        }
        if (m_dwUsrAcctCtrl & UF_ACCOUNTDISABLE)
        {
            CheckList_SetLParamCheck(hChkList, IDS_ACCT_DISABLED, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_ACCT_DISABLED, CLST_DISABLED);
        }
        if (m_dwUsrAcctCtrl & UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED)
        {
            CheckList_SetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, CLST_DISABLED);
        }
        if (m_dwUsrAcctCtrl & UF_SMARTCARD_REQUIRED)
        {
            CheckList_SetLParamCheck(hChkList, IDS_SMARTCARD_REQ, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_SMARTCARD_REQ, CLST_DISABLED);
        }

        // The delegation checkbox is only available for pre-Whistler domains

        if (GetBasePathsInfo()->GetDomainBehaviorVersion() < DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
        {
           if (m_dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION)
           {
               CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, fCheckedState);
           }
           else if (!m_fUACWritable)
           {
               CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_DISABLED);
           }
        }

        if (m_dwUsrAcctCtrl & UF_NOT_DELEGATED)
        {
            CheckList_SetLParamCheck(hChkList, IDS_NOT_DELEGATED, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_NOT_DELEGATED, CLST_DISABLED);
        }
        if (m_dwUsrAcctCtrl & UF_USE_DES_KEY_ONLY)
        {
            CheckList_SetLParamCheck(hChkList, IDS_DES_KEY_ONLY, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_DES_KEY_ONLY, CLST_DISABLED);
        }
        if (m_dwUsrAcctCtrl & UF_DONT_REQUIRE_PREAUTH)
        {
            CheckList_SetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, fCheckedState);
        }
        else if (!m_fUACWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, CLST_DISABLED);
        }
    }
    else if (!m_fUACWritable)
    {
        CheckList_SetLParamCheck(hChkList, IDS_NO_PW_EXPIRE, CLST_DISABLED);
        CheckList_SetLParamCheck(hChkList, IDS_ACCT_DISABLED, CLST_DISABLED);
        CheckList_SetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW, CLST_DISABLED);
        CheckList_SetLParamCheck(hChkList, IDS_SMARTCARD_REQ, CLST_DISABLED);
        if (GetBasePathsInfo()->GetDomainBehaviorVersion() < DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
        {
           CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_DISABLED);
        }
        CheckList_SetLParamCheck(hChkList, IDS_NOT_DELEGATED, CLST_DISABLED);
        CheckList_SetLParamCheck(hChkList, IDS_DES_KEY_ONLY, CLST_DISABLED);
        CheckList_SetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH, CLST_DISABLED);
    }

    if (iUACComputed != cAttrs)
    {
        m_dwUsrAcctCtrlComputed = pAttrs[iUACComputed].pADsValues->Integer;
        if (m_dwUsrAcctCtrlComputed & UF_LOCKOUT)
        {
            CheckDlgButton(m_hPage, IDC_ACCT_LOCKOUT_CHK, BST_CHECKED);
        }
        else
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_LOCKOUT_CHK), FALSE);
        }
    }
    else
    {
        if (iLockout < cAttrs) 
        {
            m_LockoutTime.HighPart = pAttrs[iLockout].pADsValues->LargeInteger.HighPart;
            m_LockoutTime.LowPart = pAttrs[iLockout].pADsValues->LargeInteger.LowPart;
            if ((m_LockoutTime.HighPart != 0) ||
                (m_LockoutTime.LowPart != 0))
            {
                CheckDlgButton(m_hPage, IDC_ACCT_LOCKOUT_CHK, BST_CHECKED);
            }
            else
            {
                EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_LOCKOUT_CHK), FALSE);
            }
        }
        else
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_LOCKOUT_CHK), FALSE);
        }
    }

    //
    // Account Expires.
    //
    SYSTEMTIME st,stGMT;
    BOOL fSetDefaultExpiration = FALSE;

    if (iExpires < cAttrs)
    {
        dspDebugOut((DEB_ITRACE, "Account-Expires (raw):   0x%x,%08x\n",
                     pAttrs[iExpires].pADsValues->LargeInteger.HighPart,
                     pAttrs[iExpires].pADsValues->LargeInteger.LowPart));
        ADS_LARGE_INTEGER liADsExpiresDate = pAttrs[iExpires].pADsValues->LargeInteger;

        // Zero, -1, and the third constant are all flags meaning account
        // never expires.
        //
        if (!(liADsExpiresDate.QuadPart == 0 ||
              liADsExpiresDate.QuadPart == -1 ||
              liADsExpiresDate.QuadPart == 0x7FFFFFFFFFFFFFFF))
        {
            FILETIME ftGMT;     // GMT filetime
            FILETIME ftLocal;   // Local filetime

            //Get Local Time in SYSTEMTIME format
            ftGMT.dwLowDateTime = liADsExpiresDate.LowPart;
            ftGMT.dwHighDateTime = liADsExpiresDate.HighPart;
            FileTimeToSystemTime(&ftGMT, &stGMT);
            SystemTimeToTzSpecificLocalTime(NULL, &stGMT,&st);

            //For Display Purpose reduce one day
            SystemTimeToFileTime(&st, &ftLocal );
            liADsExpiresDate.LowPart = ftLocal.dwLowDateTime;
            liADsExpiresDate.HighPart = ftLocal.dwHighDateTime;
            liADsExpiresDate.QuadPart -= DSPROP_FILETIMES_PER_DAY;
            ftLocal.dwLowDateTime = liADsExpiresDate.LowPart;
            ftLocal.dwHighDateTime = liADsExpiresDate.HighPart;
            FileTimeToSystemTime(&ftLocal, &st);


            idRadioButton = IDC_ACCT_EXPIRES_ON_RADIO;
        }
        else
        {
            fSetDefaultExpiration = TRUE;
        }
    }
    else
    {
        fSetDefaultExpiration = TRUE;
    }

    if (fSetDefaultExpiration)
    {
        LARGE_INTEGER li;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, (LPFILETIME)&li);
        //
        // The default account expiration time is 30 days from today.
        //
        li.QuadPart += DSPROP_FILETIMES_PER_MONTH;
        FILETIME ft;
        // Convert the GMT time to Local time
        FileTimeToLocalFileTime((LPFILETIME)&li, &ft);
        FileTimeToSystemTime(&ft, &st);
    }

    // Initialize datepicker to expiration date
    BOOL bRet = DateTime_SetSystemtime(hctlDateTime, GDT_VALID, &st);
    CheckDlgButton(m_hPage, idRadioButton, BST_CHECKED);
    EnableWindow(hctlDateTime, idRadioButton == IDC_ACCT_EXPIRES_ON_RADIO);

    //
    // Logon Workstations.
    //
    m_pWkstaDlg = new CLogonWkstaDlg(this);

    CHECK_NULL_REPORT(m_pWkstaDlg, m_hPage, return E_OUTOFMEMORY);

    if (iLogonWksta < cAttrs)
    {
        // User-Workstations is a comma-separated list of workstation names.
        // It is a single-valued attribute. We are using the Multi-valued
        // attribute edit dialog for updating this attribue but by setting the
        // last parameter to TRUE it will accept the the comma list.
        //
        hr = m_pWkstaDlg->Init(&LogonWkstaBtn, &pAttrs[iLogonWksta],
                               CheckIfWritable(wzUserWksta),
                               MAX_LOGON_WKSTAS, TRUE);
    }
    else
    {
        hr = m_pWkstaDlg->Init(&LogonWkstaBtn, NULL,
                               CheckIfWritable(wzUserWksta),
                               MAX_LOGON_WKSTAS, TRUE);
    }
    CHECK_HRESULT(hr, return hr);

    //
    // Logon Hours.
    //
    if (iLoghrs < cAttrs)
    {
        const ADS_OCTET_STRING * pOctetString = &pAttrs[iLoghrs].pADsValues->OctetString;

        if (pOctetString->dwLength == cbLogonHoursArrayLength)
        {
            ASSERT(m_pargbLogonHours == NULL && "Memory Leak");
            m_pargbLogonHours = (BYTE *)LocalAlloc(0, cbLogonHoursArrayLength); // Allocate 21 bytes
            if (m_pargbLogonHours != NULL)
            {
                // Copy the data into the variable
                memcpy(m_pargbLogonHours, pOctetString->lpValue, cbLogonHoursArrayLength);
            }
			//NTRAID#NTBUG9-572011-2002/03/10-jmessec   Else what?  It appears data just drops out here and processing continues on failure
        }
        else
        {
            dspDebugOut((DEB_ERROR, "Illegal length for logonHours attribute. cbExpected=%d, cbReturned=%d.\n",
                        cbLogonHoursArrayLength, pOctetString->dwLength));
        }
    }

    //
    // User Can't change password.
    //
    // Allocate Self and World (Everyone) SIDs.
    //
    {
        SID_IDENTIFIER_AUTHORITY NtAuth    = SECURITY_NT_AUTHORITY,
                                 WorldAuth = SECURITY_WORLD_SID_AUTHORITY;
        if (!AllocateAndInitializeSid(&NtAuth,
                                      1,
                                      SECURITY_PRINCIPAL_SELF_RID,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &m_pSelfSid))
        {
            DBG_OUT("AllocateAndInitializeSid failed!");
            ReportError(GetLastError(), 0, m_hPage);
            return HRESULT_FROM_WIN32(GetLastError());
        }
        if (!AllocateAndInitializeSid(&WorldAuth,
                                      1,
                                      SECURITY_WORLD_RID,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &m_pWorldSid))
        {
            DBG_OUT("AllocateAndInitializeSid failed!");
            ReportError(GetLastError(), 0, m_hPage);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // Look for a change-pw deny ACE.
    //
    DWORD dwErr;
    CSimpleSecurityDescriptorHolder SDHolder;
    PACL pAcl = NULL;

    dwErr = 
       GetDsObjectSD(
          GetObjPathName(),
          &pAcl,
          &(SDHolder.m_pSD));

    switch (dwErr)
    {
    case ERROR_ACCESS_DENIED:
        //
        // If the user lacks read-access, then LDAP returns LDAP_NO_SUCH_ATTRIBUTE
        // to GetNamedSecurityInfo who then calls LdapMapErrorToWin32 which
        // returns ERROR_INVALID_PARAMETER!
        //
    case ERROR_INVALID_PARAMETER:
    case ERROR_DS_NO_ATTRIBUTE_OR_VALUE:
        dspDebugOut((DEB_ITRACE, "GetDsObjectSD returned ERROR_ACCESS_DENIED...\n"));
        m_fNTSDWritable = FALSE;
        m_fOrigCantChangePW = FALSE;
        break;

    default:
        CHECK_WIN32_REPORT(dwErr, m_hPage, return HRESULT_FROM_WIN32(dwErr));
    }

    ULONG ulCount, j;
    PEXPLICIT_ACCESS rgEntries;

    dwErr = GetExplicitEntriesFromAcl(pAcl, &ulCount, &rgEntries);


    CHECK_WIN32_REPORT(dwErr, m_hPage, return HRESULT_FROM_WIN32(dwErr));

    for (j = 0; j < ulCount; j++)
    {
      if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
          (rgEntries[j].grfAccessMode == DENY_ACCESS))
      {
        OBJECTS_AND_SID * pObjectsAndSid;
        pObjectsAndSid = (OBJECTS_AND_SID *)rgEntries[j].Trustee.ptstrName;

        if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                        GUID_CONTROL_UserChangePassword) &&
            (EqualSid(pObjectsAndSid->pSid, m_pSelfSid) ||
             EqualSid(pObjectsAndSid->pSid, m_pWorldSid)))
        {
          m_fOrigCantChangePW = TRUE;
        }
      }
      else if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
               (rgEntries[j].grfAccessMode == GRANT_ACCESS))
      {
        OBJECTS_AND_SID* pObjectsAndSid;
        pObjectsAndSid = (OBJECTS_AND_SID*)rgEntries[j].Trustee.ptstrName;

        if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                        GUID_CONTROL_UserChangePassword))
        {
          if (EqualSid(pObjectsAndSid->pSid, m_pSelfSid))
          {
            m_fOrigSelfAllowChangePW = TRUE;
          }
          else if (EqualSid(pObjectsAndSid->pSid, m_pWorldSid))
          {
            m_fOrigWorldAllowChangePW = TRUE;
          }
        }
      }
    }

    if (ulCount)
    {
        LocalFree(rgEntries);
    }

    if (m_fOrigCantChangePW)
    {
        CheckList_SetLParamCheck(hChkList, IDS_CANT_CHANGE_PW,
                                 (!m_fNTSDWritable) ? CLST_CHECKDISABLED :
                                                      CLST_CHECKED);
    }
    else if (!m_fNTSDWritable)
    {
        CheckList_SetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, CLST_DISABLED);
    }

    //
    // User Must Change Password. This is flagged by a zero Last-Changed-PW
    // attribute value. This value is ignored if the Password-never-expires
    // bit is set in user account control.
    //
    if (iLastSet < cAttrs)
    {
        m_PwdLastSet.HighPart = pAttrs[iLastSet].pADsValues->LargeInteger.HighPart;
        m_PwdLastSet.LowPart = pAttrs[iLastSet].pADsValues->LargeInteger.LowPart;
        if ((pAttrs[iLastSet].pADsValues->LargeInteger.HighPart == 0) &&
            (pAttrs[iLastSet].pADsValues->LargeInteger.LowPart == 0) &&
            !(m_dwUsrAcctCtrl & UF_DONT_EXPIRE_PASSWD))
        {
            CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW,
                                     (!m_fPwdLastSetWritable) ? CLST_CHECKDISABLED :
                                                                CLST_CHECKED);
        }
        else if (!m_fPwdLastSetWritable)
        {
            CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, CLST_DISABLED);
        }
    }
    else if (!m_fPwdLastSetWritable)
    {
        CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, CLST_DISABLED);
    }

    // NTRAID#NTBUG9-503964-2001/12/13-JeffJon
    // If all the checkboxes in the scroll check list are disabled
    // change the label so that it doesn't contain an accelerator
    if (!m_fPwdLastSetWritable &&
        !m_fNTSDWritable &&
        !m_fUACWritable)
    {
       CStr strLabel;
       strLabel.LoadString(g_hInstance, IDS_ACCOUNT_OPTIONS_NO_ACCEL);

       SetDlgItemText(m_hPage, IDC_OPTIONS_STATIC, strLabel);
    }

    //
    // Disable those controls that aren't writable.
    //
    if (!m_fUPNWritable)
    {
        SendDlgItemMessage(m_hPage, IDC_NT5_NAME_EDIT, EM_SETREADONLY, (WPARAM)TRUE, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_UPN_SUFFIX_COMBO), FALSE);
    }
    if (!m_fSAMNameWritable)
    {
        SendDlgItemMessage(m_hPage, IDC_NT4_NAME_EDIT, EM_SETREADONLY, (WPARAM)TRUE, 0);
    }
    if (!m_fAcctExpiresWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_NEVER_EXPIRES_RADIO), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES), FALSE);
    }
    if (!m_fLockoutTimeWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_LOCKOUT_CHK), FALSE);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserAcctPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserAcctPage::OnApply(void)
{
    TRACE(CDsUserAcctPage,OnApply);
    HRESULT hr = S_OK;
    BOOL fWritePwdLastSet = FALSE;
    BOOL fUPNchanged = FALSE;
    int cchName, cchDomain;

    ADSVALUE ADsValueUPN = {ADSTYPE_CASE_IGNORE_STRING, NULL};
    ADS_ATTR_INFO AttrInfoUPN = {wzUPN, ADS_ATTR_UPDATE,
                                 ADSTYPE_CASE_IGNORE_STRING, &ADsValueUPN, 1};
    ADSVALUE ADsValueSAMname = {ADSTYPE_CASE_IGNORE_STRING, NULL};
    ADS_ATTR_INFO AttrInfoSAMname = {wzSAMname, ADS_ATTR_UPDATE,
                                     ADSTYPE_CASE_IGNORE_STRING, &ADsValueSAMname, 1};
    ADSVALUE ADsValueAcctCtrl = {ADSTYPE_INTEGER, 0};
    ADS_ATTR_INFO AttrInfoAcctCtrl = {g_wzUserAccountControl, ADS_ATTR_UPDATE,
                                      ADSTYPE_INTEGER, &ADsValueAcctCtrl, 1};
    ADSVALUE ADsValueAcctExpires = {ADSTYPE_LARGE_INTEGER, 0};
    ADS_ATTR_INFO AttrInfoAcctExpires = {wzAcctExpires, ADS_ATTR_UPDATE,
                                         ADSTYPE_LARGE_INTEGER,
                                         &ADsValueAcctExpires, 1};
    ADSVALUE ADsValuePwdLastSet = {ADSTYPE_LARGE_INTEGER, NULL};
    ADS_ATTR_INFO AttrInfoPwdLastSet = {wzPwdLastSet, ADS_ATTR_UPDATE,
                                       ADSTYPE_LARGE_INTEGER,
                                       &ADsValuePwdLastSet, 1};
    ADSVALUE ADsValueLogonHours = {ADSTYPE_OCTET_STRING, NULL};
    ADS_ATTR_INFO AttrInfoLogonHours = {wzLogonHours, ADS_ATTR_UPDATE,
                                        ADSTYPE_OCTET_STRING,
                                        &ADsValueLogonHours, 1};
    ADS_ATTR_INFO AttrInfoLogonWksta = {wzUserWksta, ADS_ATTR_UPDATE,
                                        ADSTYPE_CASE_IGNORE_STRING,
                                        NULL, 1};
    ADSVALUE ADsValueLockoutTime = {ADSTYPE_LARGE_INTEGER, 0};
    ADS_ATTR_INFO AttrInfoLockoutTime = {wzLockoutTime, ADS_ATTR_UPDATE,
                                         ADSTYPE_LARGE_INTEGER,
                                         &ADsValueLockoutTime, 1};
    // Array of attributes to write
    ADS_ATTR_INFO rgAttrs[9];
    DWORD cAttrs = 0;  // Number of attributes to write

    //
    // User Principle Name - concatonate the values from the name edit and
    // suffix combo controls. If the result differs from the saved value, then
    // update the attribute. If no value in the edit control, skip checking the
    // combobox as it is irrelevant.
    //
    CStr csUPN, csUPNSuffix;
    if (m_fUPNWritable)
    {
        cchName = (int)SendDlgItemMessage(m_hPage, IDC_NT5_NAME_EDIT, WM_GETTEXTLENGTH, 0, 0);
        if (cchName)
        {
            csUPN.GetBufferSetLength(cchName);
            CHECK_NULL_REPORT((LPCWSTR)csUPN, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

            GetDlgItemText(m_hPage, IDC_NT5_NAME_EDIT, (LPWSTR)(LPCWSTR)csUPN, cchName + 1);

            int iLenPreTrim = csUPN.GetLength();

            csUPN.TrimLeft();
            csUPN.TrimRight();

            if (iLenPreTrim != csUPN.GetLength())
            {
                // the length is different, it must have been trimmed. Write
                // trimmed value back to the control.
                //
                SetDlgItemText(m_hPage, IDC_NT5_NAME_EDIT, const_cast<PWSTR>((LPCWSTR)csUPN));
            }

            int iCurSuffix;
            iCurSuffix = (int)SendDlgItemMessage(m_hPage, IDC_UPN_SUFFIX_COMBO, CB_GETCURSEL, 0, 0);
            if (iCurSuffix != CB_ERR)
            {
                cchDomain = (int)SendDlgItemMessage(m_hPage, IDC_UPN_SUFFIX_COMBO,
                                               CB_GETLBTEXTLEN, iCurSuffix, 0);
                csUPNSuffix.GetBufferSetLength(cchDomain);
                CHECK_NULL_REPORT((LPCWSTR)csUPNSuffix, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

                SendDlgItemMessage(m_hPage, IDC_UPN_SUFFIX_COMBO, CB_GETLBTEXT,
                                   iCurSuffix, (LPARAM)(LPCWSTR)csUPNSuffix);
                csUPN += csUPNSuffix;
            }


        }

        if (m_pwzUPN)
        {
            if (csUPN.IsEmpty())
            {
                fUPNchanged = TRUE;
            }
            else
            {
                if (_wcsicmp(csUPN, m_pwzUPN) != 0)
                {
                    fUPNchanged = TRUE;
                }
            }
        }
        else
        {
            if (!csUPN.IsEmpty())
            {
                fUPNchanged = TRUE;
            }
        }
    }

    //
    // SAM account name. This is a required attribute, so it can't be empty.
    //
    if (!m_cchSAMnameCtrl)
    {
        ErrMsg(IDS_EMPTY_SAM_NAME, m_hPage);
        SetFocus(GetDlgItem(m_hPage, IDC_NT4_NAME_EDIT));
        return PSNRET_INVALID_NOCHANGEPAGE;
    }
    CStr csNewSamName;
    csNewSamName.GetBufferSetLength(static_cast<int>(m_cchSAMnameCtrl));
    CHECK_NULL_REPORT((LPCWSTR)csNewSamName, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

    GetDlgItemText(m_hPage, IDC_NT4_NAME_EDIT, (PWSTR)(LPCWSTR)csNewSamName,
                   static_cast<int>(m_cchSAMnameCtrl + 1));

    int iLenBeforeTrim = csNewSamName.GetLength();

    csNewSamName.TrimLeft();
    csNewSamName.TrimRight();

    //
    // Now check for illegal characters
    //
    bool bSAMChanged = false;
    int iFind = csNewSamName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS_WITH_AT);
    if (iFind != -1 && !csNewSamName.IsEmpty())
    {
      PVOID apv[1] = {(LPWSTR)(LPCWSTR)csNewSamName};
      if (IDYES == SuperMsgBox(m_hPage,
                               IDS_SAMNAME_ILLEGAL, 
                               0, 
                               MB_YESNO | MB_ICONWARNING,
                               S_OK, 
                               apv, 
                               1,
                               FALSE, 
                               __FILE__, 
                               __LINE__))
      {
        while (iFind != -1)
        {
          csNewSamName.SetAt(iFind, L'_');
          iFind = csNewSamName.FindOneOf(INVALID_ACCOUNT_NAME_CHARS_WITH_AT);
          bSAMChanged = true;
        }
      }
      else
      {
        //
        // Set the focus to the edit box and select the text
        //
        SetFocus(GetDlgItem(m_hPage, IDC_NT4_NAME_EDIT));
        SendDlgItemMessage(m_hPage, IDC_NT4_NAME_EDIT, EM_SETSEL, 0, -1);
        return PSNRET_INVALID_NOCHANGEPAGE;
      }
    }

    if (bSAMChanged || iLenBeforeTrim != csNewSamName.GetLength())
    {
        //
        // Since we modified the name set it back into the control
        //
        SetDlgItemText(m_hPage, IDC_NT4_NAME_EDIT, const_cast<PWSTR>((LPCWSTR)csNewSamName));
    }

    dspAssert(m_pwzSAMname);

    if (m_pwzSAMname && (wcscmp(m_pwzSAMname, csNewSamName) != 0))
    {
        m_fSAMNameChanged = TRUE;
    }

    if(m_fLockoutTimeWritable)
    {
        if (!IsDlgButtonChecked(m_hPage, IDC_ACCT_LOCKOUT_CHK) &&
            ((m_LockoutTime.HighPart != 0) || 
             (m_LockoutTime.LowPart != 0) ||
             (m_dwUsrAcctCtrlComputed & UF_LOCKOUT)))
        {
            ADsValueLockoutTime.LargeInteger.LowPart = 0;
            ADsValueLockoutTime.LargeInteger.HighPart = 0;
            rgAttrs[cAttrs++] = AttrInfoLockoutTime;
        }
    }

    BOOL fDelegationChanged = FALSE;
    HWND hChkList = GetDlgItem(m_hPage, IDC_CHECK_LIST);
    //
    // User-Account-Control check boxes.
    //
    if (m_fUACWritable && m_fAcctCtrlChanged)
    {
      if (IsDlgButtonChecked(m_hPage, IDC_ACCT_LOCKOUT_CHK) &&
          ((m_LockoutTime.HighPart != 0) || 
           (m_LockoutTime.LowPart != 0)  ||
           (m_dwUsrAcctCtrlComputed & UF_LOCKOUT)))
      {
         m_dwUsrAcctCtrl |= UF_LOCKOUT;
      }
        
        if (CheckList_GetLParamCheck(hChkList, IDS_NO_PW_EXPIRE))
        {
            m_dwUsrAcctCtrl |= UF_DONT_EXPIRE_PASSWD;
        }
        else
        {
            m_dwUsrAcctCtrl &= ~(UF_DONT_EXPIRE_PASSWD);
        }

        if (CheckList_GetLParamCheck(hChkList, IDS_ACCT_DISABLED))
        {
            m_dwUsrAcctCtrl |= UF_ACCOUNTDISABLE;
        }
        else
       {
            m_dwUsrAcctCtrl &= ~(UF_ACCOUNTDISABLE);
        }

        if (CheckList_GetLParamCheck(hChkList, IDS_CLEAR_TEXT_PW))
        {
            m_dwUsrAcctCtrl |= UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
        }
        else
        {
            m_dwUsrAcctCtrl &= ~(UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED);
        }

        if (CheckList_GetLParamCheck(hChkList, IDS_SMARTCARD_REQ))
        {
            m_dwUsrAcctCtrl |= UF_SMARTCARD_REQUIRED;
        }
        else
        {
            m_dwUsrAcctCtrl &= ~(UF_SMARTCARD_REQUIRED);
        }

        // The delegation checkbox is only available for pre-Whistler domains

        if (GetBasePathsInfo()->GetDomainBehaviorVersion() < DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
        {
           if (CheckList_GetLParamCheck(hChkList, IDS_DELEGATION_OK))
           {
               if (!(m_dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION))
               {
                   m_dwUsrAcctCtrl |= UF_TRUSTED_FOR_DELEGATION;
                   fDelegationChanged = TRUE;
               }
           }
           else
           {
               if (m_dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION)
               {
                   m_dwUsrAcctCtrl &= ~(UF_TRUSTED_FOR_DELEGATION);
                   fDelegationChanged = TRUE;
               }
           }
        }

        if (CheckList_GetLParamCheck(hChkList, IDS_NOT_DELEGATED))
        {
            m_dwUsrAcctCtrl |= UF_NOT_DELEGATED;
        }
        else
        {
            m_dwUsrAcctCtrl &= ~(UF_NOT_DELEGATED);
        }

        if (CheckList_GetLParamCheck(hChkList, IDS_DES_KEY_ONLY))
        {
            m_dwUsrAcctCtrl |= UF_USE_DES_KEY_ONLY;
        }
        else
        {
            m_dwUsrAcctCtrl &= ~(UF_USE_DES_KEY_ONLY);
        }

        if (CheckList_GetLParamCheck(hChkList, IDS_DONT_REQ_PREAUTH))
        {
            m_dwUsrAcctCtrl |= UF_DONT_REQUIRE_PREAUTH;
        }
        else
        {
            m_dwUsrAcctCtrl &= ~(UF_DONT_REQUIRE_PREAUTH);
        }

        ADsValueAcctCtrl.Integer = m_dwUsrAcctCtrl;
        rgAttrs[cAttrs++] = AttrInfoAcctCtrl;
    }

    //
    // Account Expires
    //
    if (m_fAcctExpiresWritable && m_fAcctExpiresChanged)
    {
        ADsValueAcctExpires.LargeInteger.LowPart = 0;
        ADsValueAcctExpires.LargeInteger.HighPart = 0;
        if (IsDlgButtonChecked(m_hPage, IDC_ACCT_EXPIRES_ON_RADIO) == BST_CHECKED)
        {
            // Get the expire date from the control
            HWND hctlDateTime = GetDlgItem(m_hPage, IDC_ACCT_EXPIRES);
            SYSTEMTIME st;   // Local time in a human-readable format
            LRESULT lResult = DateTime_GetSystemtime(hctlDateTime, &st);
            dspAssert(lResult == GDT_VALID); // The control should always have a valid time
            // Zero the time part of the struct.
            st.wHour = st.wMinute = st.wSecond = st.wMilliseconds = 0;
            FILETIME ftLocal;   // Local filetime
            FILETIME ftGMT;     // GMT filetime
            // Convert the human-readable time to a cryptic local filetime format
            SystemTimeToFileTime(&st, &ftLocal);
            //
            // Add a day since it expires at the beginning of the next day.
            //
            ADS_LARGE_INTEGER liADsExpiresDate;
            liADsExpiresDate.LowPart = ftLocal.dwLowDateTime;
            liADsExpiresDate.HighPart = ftLocal.dwHighDateTime;
            liADsExpiresDate.QuadPart += DSPROP_FILETIMES_PER_DAY;
            ftLocal.dwLowDateTime = liADsExpiresDate.LowPart;
            ftLocal.dwHighDateTime = liADsExpiresDate.HighPart;

            FileTimeToSystemTime(&ftLocal,&st);
            //Convert time to UTC time
            SYSTEMTIME stGMT;
            TzSpecificLocalTimeToSystemTime(NULL,&st,&stGMT);
            SystemTimeToFileTime(&stGMT,&ftGMT);

            // Store the GMT time into the ADs value
            //
            ADsValueAcctExpires.LargeInteger.LowPart = ftGMT.dwLowDateTime;
            ADsValueAcctExpires.LargeInteger.HighPart = ftGMT.dwHighDateTime;
            dspDebugOut((DEB_ITRACE, "Setting Account-Expires to 0x%x,%08x\n",
                         ADsValueAcctExpires.LargeInteger.HighPart,
                         ADsValueAcctExpires.LargeInteger.LowPart));
        }
        rgAttrs[cAttrs++] = AttrInfoAcctExpires;
    }

    //
    // Validate and save UPN.
    //
    if (fUPNchanged)
    {
        if (csUPN.IsEmpty())
        {
            // clear the attribute.
            //
            AttrInfoUPN.dwControlCode = ADS_ATTR_CLEAR;
            AttrInfoUPN.dwNumValues = 0;
        }
        else
        {
            // Validate the new UPN by checking for uniqueness. That is,
            // search the GC.
            //
            CComPtr <IDirectorySearch> spDsSearch;
            CSmartWStr cswzCleanObj;
            PWSTR pwzDnsDom;

            hr = SkipPrefix(GetObjPathName(), &cswzCleanObj);

            CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);
            //
            // To bind to a GC, you need to supply the domain name rather than the
            // server path because the current DC may not be hosting a GC.
            //
            hr = CrackName(cswzCleanObj, &pwzDnsDom, GET_DNS_DOMAIN_NAME, m_hPage);

            CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

            hr = DSPROP_GetGCSearchOnDomain(pwzDnsDom,
                                            IID_IDirectorySearch,
                                            (PVOID*)&spDsSearch);
            LocalFreeStringW(&pwzDnsDom);
            if (S_OK != hr)
            {
                if (S_FALSE == hr ||
                    HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN) == hr)
                {
                    // GC not found, warn and skip uniqueness test
                    ErrMsg( IDS_WARN_UPN_NO_GC_FOUND, m_hPage );
                }
                else
                {
                    SuperMsgBox(GetHWnd(), 
                                IDS_WARN_UPN_GC_FOUND_ERROR, 
                                0, 
                                MB_OK |MB_ICONERROR, 
                                hr, 
                                NULL, 
                                0,
                                FALSE, 
                                __FILE__, 
                                __LINE__);
                    return PSNRET_INVALID_NOCHANGEPAGE;
                }
            }
            else
            {
                WCHAR wzSearchFormat[] = L"(userPrincipalName=%s)";

                CStr csFilter;
                csFilter.Format(wzSearchFormat, csUPN);

                ADS_SEARCH_HANDLE hSrch = NULL;
                PWSTR pwzAttrName[] = {g_wzADsPath};

                hr = spDsSearch->ExecuteSearch((PWSTR)(LPCWSTR)csFilter,
                                               pwzAttrName, 1, &hSrch);

                CHECK_HRESULT_REPORT(hr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

                hr = spDsSearch->GetNextRow(hSrch);

                if (hSrch)
                {
                    spDsSearch->CloseSearchHandle(hSrch);
                }

                if (hr == S_OK)
                {
                    // If the search succeeded, then the UPN is not unique.
                    //
                    ErrMsg(IDS_ERR_UPN_NONUNIQUE, m_hPage);
                    SetFocus(GetDlgItem(m_hPage, IDC_NT5_NAME_EDIT));
                    return PSNRET_INVALID_NOCHANGEPAGE;
                }
                else
                {
                    // S_ADS_NOMORE_ROWS means no match, thus user's UPN is
                    // unique.
                    //
                    if (hr != S_ADS_NOMORE_ROWS)
                    {
                        SuperMsgBox(m_hPage, IDS_ERR_FINDING_UPN, 0,
                                    MB_ICONEXCLAMATION | MB_OK, hr, NULL, 0,
                                    TRUE, __FILE__, __LINE__);
                    }
                }
            }

            // It passed the uniqueness test, so prepare to save it.
            //
            ADsValueUPN.CaseIgnoreString = (PWSTR)(LPCWSTR)csUPN;
        }
        rgAttrs[cAttrs++] = AttrInfoUPN;
    }

    if (m_fSAMNameChanged)
    {
        ADsValueSAMname.CaseIgnoreString = (PWSTR)(LPCWSTR)csNewSamName;
        rgAttrs[cAttrs++] = AttrInfoSAMname;
    }

    if (m_pargbLogonHours != NULL && m_fLoginHoursWritable && m_fLogonHoursChanged)
    {
        ADsValueLogonHours.OctetString.dwLength = cbLogonHoursArrayLength;
        ADsValueLogonHours.OctetString.lpValue = m_pargbLogonHours;
        ASSERT(cAttrs < ARRAYLENGTH(rgAttrs));
        rgAttrs[cAttrs++] = AttrInfoLogonHours;
    }

    //
    // Get PW check box values.
    //
    BOOL fMustChangePW = CheckList_GetLParamCheck(hChkList, IDS_MUST_CHANGE_PW) == TRUE;

    BOOL fNewCantChangePW = CheckList_GetLParamCheck(hChkList, IDS_CANT_CHANGE_PW) == TRUE;

    //
    // Enforce PW combination rules.
    //
    if (fMustChangePW && fNewCantChangePW)
    {
        ErrMsg(IDS_ERR_BOTH_PW_BTNS, m_hPage);
        CheckList_SetLParamCheck(hChkList, IDS_CANT_CHANGE_PW, FALSE, 1);
        return PSNRET_INVALID_NOCHANGEPAGE;
    }

    if ((m_dwUsrAcctCtrl & UF_DONT_EXPIRE_PASSWD) && fMustChangePW)
    {
        ErrMsg(IDS_PASSWORD_MUTEX, m_hPage);
        CheckList_SetLParamCheck(hChkList, IDS_MUST_CHANGE_PW, FALSE, 1);
        return PSNRET_INVALID_NOCHANGEPAGE;
    }

    //
    // User-must-change-PW.
    //
    if (m_fPwdLastSetWritable)
    {
        if (fMustChangePW)
        {
            if ((m_PwdLastSet.HighPart != 0) || (m_PwdLastSet.LowPart != 0))
            {
                ADsValuePwdLastSet.LargeInteger.LowPart = 0;
                ADsValuePwdLastSet.LargeInteger.HighPart = 0;
                fWritePwdLastSet = TRUE;
            }
        }
        else
        {
            if ((m_PwdLastSet.HighPart == 0) && (m_PwdLastSet.LowPart == 0))
            {
                ADsValuePwdLastSet.LargeInteger.LowPart = 0xffffffff;
                ADsValuePwdLastSet.LargeInteger.HighPart = 0xffffffff;
                fWritePwdLastSet = TRUE;
            }
        }
        if (fWritePwdLastSet)
        {
            AttrInfoPwdLastSet.dwNumValues = 1;
            ASSERT(cAttrs < ARRAYLENGTH(rgAttrs));
            rgAttrs[cAttrs++] = AttrInfoPwdLastSet;
        }
    }

    //
    // Logon Workstations.
    //
    if (m_pWkstaDlg && m_pWkstaDlg->IsDirty())
    {
        dspAssert(m_fUserWkstaWritable);

        hr = m_pWkstaDlg->Write(&AttrInfoLogonWksta);

        CHECK_HRESULT(hr, return PSNRET_INVALID_NOCHANGEPAGE);

        rgAttrs[cAttrs++] = AttrInfoLogonWksta;
    }

    if (!cAttrs)
    {
        return PSNRET_NOERROR;
    }

    DWORD cModified;

    //
    // Write the changes.
    //
    hr = m_pDsObj->SetObjectAttributes(rgAttrs, cAttrs, &cModified);

    if (AttrInfoLogonWksta.pADsValues)
    {
        DO_DEL(AttrInfoLogonWksta.pADsValues->CaseIgnoreString);
        delete AttrInfoLogonWksta.pADsValues;
    }
    if (FAILED(hr))
    {
        DWORD dwErr;
        WCHAR wszErrBuf[MAX_PATH+1];
        WCHAR wszNameBuf[MAX_PATH+1];
        ADsGetLastError(&dwErr, wszErrBuf, MAX_PATH, wszNameBuf, MAX_PATH);

        if (dwErr)
        {
            dspDebugOut((DEB_ERROR,
                         "Extended Error 0x%x: %ws %ws <%s @line %d>.\n", dwErr,
                         wszErrBuf, wszNameBuf, __FILE__, __LINE__));

            if ((ERROR_PRIVILEGE_NOT_HELD == dwErr) && fDelegationChanged)
            {
               // The delegation checkbox is only available for pre-Whistler domains

               if (GetBasePathsInfo()->GetDomainBehaviorVersion() < DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS)
               {
                  // Whoda thunk that a single bit in UAC has an access check on
                  // it. Do special case error checking and reporting for the
                  // delegate bit.
                  //
                  if (m_dwUsrAcctCtrl & UF_TRUSTED_FOR_DELEGATION)
                  {
                     m_dwUsrAcctCtrl &= ~(UF_TRUSTED_FOR_DELEGATION);
                     CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_UNCHECKED);
                  }
                  else
                  {
                     m_dwUsrAcctCtrl |= UF_TRUSTED_FOR_DELEGATION;
                     CheckList_SetLParamCheck(hChkList, IDS_DELEGATION_OK, CLST_CHECKED);
                  }
                  ErrMsg(IDS_ERR_CANT_DELEGATE, m_hPage);
               }
            }
            else
            {
                ReportError(dwErr, IDS_ADS_ERROR_FORMAT, m_hPage);
            }
        }
        else
        {
            dspDebugOut((DEB_ERROR, "Error %08lx <%s @line %d>\n", hr, __FILE__, __LINE__));
            ReportError(hr, IDS_ADS_ERROR_FORMAT, m_hPage);
        }
        return PSNRET_INVALID_NOCHANGEPAGE;
    }

    //
    // We must reset the member variables for user must change password
    // if the value was changed or else the apply on works an odd number
    // of times for one instance of the property page
    //
    if (m_fPwdLastSetWritable)
    {
        if (fMustChangePW)
        {
            m_PwdLastSet.HighPart = 0;
            m_PwdLastSet.LowPart = 0;
        }
        else
        {
            if ((m_PwdLastSet.HighPart == 0) && (m_PwdLastSet.LowPart == 0))
            {
                m_PwdLastSet.HighPart = 0xffffffff;
                m_PwdLastSet.LowPart = 0xffffffff;
            }
        }
    }

    if (fUPNchanged)
    {
        DO_DEL(m_pwzUPN);

        if (csUPN)
        {
            if (!AllocWStr((PWSTR)(LPCWSTR)csUPN, &m_pwzUPN))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            }
        }
    }

    //
    // User-can't change password
    //
    if ((fNewCantChangePW != m_fOrigCantChangePW) && m_fNTSDWritable)
    {
        CSimpleSecurityDescriptorHolder SDHolder;
        PACL pDacl = NULL;
        CSimpleAclHolder NewDacl;

        CHECK_HRESULT(hr, return PSNRET_INVALID_NOCHANGEPAGE);

        DWORD dwErr = 
           GetDsObjectSD(
              GetObjPathName(),
              &pDacl,
              &(SDHolder.m_pSD));

        dspAssert(IsValidAcl(pDacl));
        CHECK_WIN32_REPORT(dwErr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

        if (fNewCantChangePW)
        {
            // Revoke the user's change password right by writing DENY ACEs.
            // Note that this can be an inherited right (which is the default
            // case), so attempting to remove GRANT ACEs is not sufficient.
            //
            OBJECTS_AND_SID rgObjectsAndSid[2] = {0};
            PEXPLICIT_ACCESS rgEntries, rgNewEntries;
            ULONG ulCount, ulNewCount = 0, j;

            dwErr = GetExplicitEntriesFromAcl(pDacl, &ulCount, &rgEntries);
            CHECK_WIN32_REPORT(dwErr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);
            
            //+2 for two deny entries
            rgNewEntries = (PEXPLICIT_ACCESS)LocalAlloc(LPTR, sizeof(EXPLICIT_ACCESS)*(ulCount + 2));
            CHECK_NULL_REPORT(rgNewEntries, m_hPage, LocalFree(rgEntries); return PSNRET_INVALID_NOCHANGEPAGE);

            //Remove allow ace from it if present
            for (j = 0; j < ulCount; j++)
            {
                BOOL fAllowAceFound = FALSE;

                if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
                    (rgEntries[j].grfAccessMode == GRANT_ACCESS))
                {
                  OBJECTS_AND_SID * pObjectsAndSid;
                  pObjectsAndSid = (OBJECTS_AND_SID *)rgEntries[j].Trustee.ptstrName;

                  if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                                  GUID_CONTROL_UserChangePassword) &&
                      (EqualSid(pObjectsAndSid->pSid, m_pSelfSid) ||
                       EqualSid(pObjectsAndSid->pSid, m_pWorldSid)))
                  {
                    fAllowAceFound = TRUE;
                  }
                }

                if (!fAllowAceFound)
                {
                  rgNewEntries[ulNewCount] = rgEntries[j];
                  ulNewCount++;
                }
            }            


            // initialize the new entries (DENY ACE's)
            //
            rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
            rgNewEntries[ulNewCount].grfAccessMode = DENY_ACCESS;
            rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;
            // build the trustee structs for change password
            //
            BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                          &(rgObjectsAndSid[0]),
                                          const_cast<GUID *>(&GUID_CONTROL_UserChangePassword),
                                          NULL, // inherit guid
                                          m_pSelfSid);
            ulNewCount++;

            rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
            rgNewEntries[ulNewCount].grfAccessMode = DENY_ACCESS;
            rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;

            // build the trustee structs for change password
            //
            BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                          &(rgObjectsAndSid[1]),
                                          const_cast<GUID *>(&GUID_CONTROL_UserChangePassword),
                                          NULL, // inherit guid
                                          m_pWorldSid);
            ulNewCount++;



            // add the entries to the ACL
            //
            DBG_OUT("calling SetEntriesInAcl()");

            dwErr = SetEntriesInAcl(ulNewCount, rgNewEntries, NULL, &(NewDacl.m_pAcl));


            if (dwErr == ERROR_SUCCESS)
            {
              // NTRAID#NTBUG9-759644-2003/01/02-JeffJon
              // Must reset these members so that if the user continues to toggle
              // "User cannot change password" we will update the allow ace appropriately

              m_fOrigSelfAllowChangePW = FALSE;
              m_fOrigWorldAllowChangePW = FALSE;
            }

            dspAssert(IsValidAcl(NewDacl.m_pAcl));
            LocalFree(rgNewEntries);
            LocalFree(rgEntries);
        }
        else
        {
            // Restore the user's change password right by removing any DENY ACEs.
            // If the GRANT ACEs are not present then we will add them back.
            // Bug #435315
            //
            ULONG ulCount, ulNewCount = 0, j;
            PEXPLICIT_ACCESS rgEntries, rgNewEntries;

            dwErr = GetExplicitEntriesFromAcl(pDacl, &ulCount, &rgEntries);

            CHECK_WIN32_REPORT(dwErr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

            if (!ulCount)
            {
                CHECK_WIN32_REPORT(ERROR_INVALID_SECURITY_DESCR, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);
            }

            rgNewEntries = (PEXPLICIT_ACCESS)LocalAlloc(LPTR, (ulCount+2) * sizeof(EXPLICIT_ACCESS));

            CHECK_NULL_REPORT(rgNewEntries, m_hPage, LocalFree(rgEntries); return PSNRET_INVALID_NOCHANGEPAGE);
            memset(rgNewEntries, 0, (ulCount+2) * sizeof(EXPLICIT_ACCESS));

            for (j = 0; j < ulCount; j++)
            {
                BOOL fDenyAceFound = FALSE;

                if ((rgEntries[j].Trustee.TrusteeForm == TRUSTEE_IS_OBJECTS_AND_SID) &&
                    (rgEntries[j].grfAccessMode == DENY_ACCESS))
                {
                  OBJECTS_AND_SID * pObjectsAndSid;
                  pObjectsAndSid = (OBJECTS_AND_SID *)rgEntries[j].Trustee.ptstrName;

                  if (IsEqualGUID(pObjectsAndSid->ObjectTypeGuid,
                                  GUID_CONTROL_UserChangePassword) &&
                      (EqualSid(pObjectsAndSid->pSid, m_pSelfSid) ||
                       EqualSid(pObjectsAndSid->pSid, m_pWorldSid)))
                  {
                    fDenyAceFound = TRUE;
                  }
                }

                if (!fDenyAceFound)
                {
                  rgNewEntries[ulNewCount] = rgEntries[j];
                  ulNewCount++;
                }
            }

            if (!m_fOrigSelfAllowChangePW)
            {
              OBJECTS_AND_SID rgObjectsAndSid = {0};
              rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
              rgNewEntries[ulNewCount].grfAccessMode = GRANT_ACCESS;
              rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;

              BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                            &(rgObjectsAndSid),
                                            const_cast<GUID*>(&GUID_CONTROL_UserChangePassword),
                                            NULL, // inherit guid
                                            m_pSelfSid);
              ulNewCount++;
            }

            if (!m_fOrigWorldAllowChangePW)
            {
              OBJECTS_AND_SID rgObjectsAndSid = {0};
              rgNewEntries[ulNewCount].grfAccessPermissions = ACTRL_DS_CONTROL_ACCESS;
              rgNewEntries[ulNewCount].grfAccessMode = GRANT_ACCESS;
              rgNewEntries[ulNewCount].grfInheritance = NO_INHERITANCE;

              BuildTrusteeWithObjectsAndSid(&(rgNewEntries[ulNewCount].Trustee),
                                            &(rgObjectsAndSid),
                                            const_cast<GUID*>(&GUID_CONTROL_UserChangePassword),
                                            NULL, // inherit guid
                                            m_pWorldSid);
              ulNewCount++;
            }

            ACL EmptyAcl;
            InitializeAcl(&EmptyAcl, sizeof(ACL), ACL_REVISION_DS);

            // Create a new ACL without the DENY entries.
            //
            DBG_OUT("calling SetEntriesInAcl()");

            dwErr = SetEntriesInAcl(ulNewCount, rgNewEntries, NULL, &(NewDacl.m_pAcl));

            if (dwErr == ERROR_SUCCESS)
            {
              // NTRAID#NTBUG9-759644-2003/01/02-JeffJon
              // Must reset these members so that if the user continues to toggle
              // "User cannot change password" we will update the allow ace appropriately

              m_fOrigSelfAllowChangePW = TRUE;
              m_fOrigWorldAllowChangePW = TRUE;
            }

            dspAssert(IsValidAcl(NewDacl.m_pAcl));
            LocalFree(rgEntries);
            LocalFree(rgNewEntries);
        }

        CHECK_WIN32_REPORT(dwErr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

        dwErr = 
           SetDsObjectDacl(
              GetObjPathName(),
              NewDacl.m_pAcl);

        CHECK_WIN32_REPORT(dwErr, m_hPage, return PSNRET_INVALID_NOCHANGEPAGE);

        m_fOrigCantChangePW = fNewCantChangePW;
    }

    if (m_fSAMNameChanged)
    {
        DO_DEL(m_pwzSAMname);
        if (!TcharToUnicode((PWSTR)(LPCWSTR)csNewSamName, &m_pwzSAMname))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
        }
    }

    if (SUCCEEDED(hr))
    {
        m_fSAMNameChanged = FALSE;
        m_fAcctCtrlChanged = FALSE;
        m_fAcctExpiresChanged = FALSE;
        m_fLogonHoursChanged = FALSE;

        if (m_pWkstaDlg && m_pWkstaDlg->IsDirty())
        {
            m_pWkstaDlg->ClearDirty();
        }
    }

    return (SUCCEEDED(hr)) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserAcctPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      Standard multi-valued attribute handling assumes that the
//              "modify" button has an ID that is one greater than the
//              corresponding combo box.
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserAcctPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }

    switch (id)
    {
    case IDC_ACCT_LOCKOUT_CHK:
        if (codeNotify == BN_CLICKED && m_cchSAMnameCtrl)
        {
            m_fAcctCtrlChanged = TRUE;
            SetDirty();
        }
        break;

    case IDC_NT5_NAME_EDIT:
        if (codeNotify == EN_CHANGE)
        {
            SetDirty();
        }
        break;

    case IDC_UPN_SUFFIX_COMBO:
        if (codeNotify == CBN_SELCHANGE)
        {
            SetDirty();
        }
        break;

    case IDC_NT4_NAME_EDIT:
        if (codeNotify == EN_CHANGE)
        {
            m_cchSAMnameCtrl = (int)SendDlgItemMessage(m_hPage, IDC_NT4_NAME_EDIT,
                                                  WM_GETTEXTLENGTH, 0, 0);
            if (m_cchSAMnameCtrl == 0)
            {
                // SAM account name is a required property, so disable the
                // apply button if blank.
                //
                dspDebugOut((DEB_ITRACE, "no characters, disabling Apply.\n"));
                PropSheet_UnChanged(GetParent(m_hPage), m_hPage);
                m_fPageDirty = FALSE;
                m_fSAMNameChanged = FALSE;
            }
            else
            {
                m_fSAMNameChanged = TRUE;
                SetDirty();
            }
        }
        break;

    case IDC_LOGON_HOURS_BTN:
        if (codeNotify == BN_CLICKED)
        {
            if (m_fIsAdmin)
            {
                MsgBox2(IDS_ADMIN_NOCHANGE, IDS_LOGON_HOURS, m_hPage);
                break;
            }

            LPCWSTR pszRDN = GetObjRDName();
            if (!m_fLoginHoursWritable)
            {
                MsgBox2(IDS_CANT_WRITE, IDS_LOGON_HOURS, m_hPage);
            }
            HRESULT hr = DllScheduleDialog(m_hPage,
                                           &m_pargbLogonHours,
                                           (NULL != pszRDN)
                                               ? IDS_s_LOGON_HOURS_FOR
                                               : IDS_LOGON_HOURS,
                                           pszRDN );
            if (hr == S_OK && m_cchSAMnameCtrl && m_fLoginHoursWritable)
            {
                m_fLogonHoursChanged = TRUE;
                SetDirty();
            }
        }
        break;

    case IDC_LOGON_TO_BTN:
        if (codeNotify == BN_CLICKED)
        {
            if (m_fIsAdmin)
            {
                MsgBox2(IDS_ADMIN_NOCHANGE, IDS_LOGON_WKSTA, m_hPage);
                break;
            }
            if (m_pWkstaDlg && (m_pWkstaDlg->Edit() == IDOK))
            {
                if (m_pWkstaDlg->IsDirty())
                {
                    SetDirty();
                }
            }
        }
        break;

    case IDC_ACCT_NEVER_EXPIRES_RADIO:
    case IDC_ACCT_EXPIRES_ON_RADIO:
        if (codeNotify == BN_CLICKED && m_cchSAMnameCtrl)
        {
            EnableWindow(GetDlgItem(m_hPage, IDC_ACCT_EXPIRES), id == IDC_ACCT_EXPIRES_ON_RADIO);
            m_fAcctExpiresChanged = TRUE;
            SetDirty();
        }
        return 1;
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserAcctPage::OnNotify
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserAcctPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    NMHDR * pNmHdr = (NMHDR *)lParam;
    int codeNotify = pNmHdr->code;
    switch (wParam)
    {
    case IDC_CHECK_LIST:
        if (codeNotify == CLN_CLICK && m_cchSAMnameCtrl)
        {
            m_fAcctCtrlChanged = TRUE;
            SetDirty();
        }
        break;

    case IDC_ACCT_EXPIRES:
        dspDebugOut((DEB_ITRACE,
                     "OnNotify, id = IDC_ACCT_EXPIRES, code = 0x%x\n",
                     codeNotify));
        if (codeNotify == DTN_DATETIMECHANGE)
        {
            m_fAcctExpiresChanged = TRUE;
            SetDirty();
        }
        break;
    }
    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserAcctPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserAcctPage::OnDestroy(void)
{
    CDsPropPageBase::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     UpdateComboBoxDropWidth
//
//  Synopsis:   Sets the drop width of the combo box to the width of the 
//              widest string
//
//-----------------------------------------------------------------------------
void
UpdateComboBoxDropWidth(HWND hwnd)
{
   if (!hwnd)
   {
      return;
   }

	int nHorzExtent = 0;

   HDC deviceContext = 0;

   do
   {
      deviceContext = GetDC(hwnd);
      
      if (!deviceContext)
      {
         break;
      }

      LRESULT count =
         SendMessage(
            hwnd,
            CB_GETCOUNT,
            0,
            0);

      if (count == CB_ERR)
      {
         break;
      }

      // Loop through each item in the combobox and
      // find the widest string

      for (LRESULT i=0; i < count; i++)
      {
         LRESULT stringLength =
            SendMessage(
               hwnd,
               CB_GETLBTEXTLEN,
               i,
               0);

         if (stringLength <= 0)
         {
            continue;
         }

         PWSTR pszString = new WCHAR[stringLength + 1];
         if (!pszString)
         {
            continue;
         }

         ::ZeroMemory(pszString, sizeof(WCHAR) * (stringLength + 1));

         LRESULT textResult = 
            SendMessage(
               hwnd,
               CB_GETLBTEXT,
               i,
               (LPARAM)pszString);

         if (textResult == CB_ERR)
         {
            delete[] pszString;
            continue;
         }
   
         SIZE size = { 0 };

         if (!GetTextExtentPoint32(
                 deviceContext,
                 pszString,
                 static_cast<int>(textResult),
                 &size))
         {
            DWORD error = ::GetLastError();
            
            delete[] pszString;
            continue;
         }

         if (size.cx > nHorzExtent)
         {
            nHorzExtent = size.cx;
         }

         delete[] pszString;
      }

      // Finally set the minimum width of the combobox

      SendMessage(
         hwnd,
         CB_SETDROPPEDWIDTH,
         nHorzExtent,
         0);

	} while (false);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsUserAcctPage::FillSuffixCombo
//
//  Synopsis:   Put the UPN suffixes into the combo box.
//
//-----------------------------------------------------------------------------
BOOL
CDsUserAcctPage::FillSuffixCombo(LPWSTR pwzUPNdomain)
{
    HRESULT hr;
    int iCurSuffix = -1;
    PWSTR pwzDomain;
    DWORD cAttrs, i;
    CComPtr <IDirectoryObject> spOU;
    CComPtr <IADs> spIADs;
    Smart_PADS_ATTR_INFO spAttrs;

    //
    // See if there is a UPN Suffixes attribute set on the containing OU and
    // use that if found.
    //

    CComBSTR sbParentPath;

    hr = m_pDsObj->QueryInterface(IID_IADs, (PVOID *)&spIADs);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = spIADs->get_Parent(&sbParentPath);
    
    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = DSAdminOpenObject(sbParentPath, 
                           IID_IDirectoryObject, 
                           (void **)&spOU);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    PWSTR rgAttrs[] = {L"uPNSuffixes"};

    hr = spOU->GetObjectAttributes(rgAttrs, 1, &spAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
        return FALSE;
    }

    if (cAttrs)
    {
        dspAssert(spAttrs && spAttrs->pADsValues && spAttrs->pADsValues->CaseIgnoreString);

        for (i = 0; i < spAttrs->dwNumValues; i++)
        {
            CStr csSuffix = L"@";
            csSuffix += spAttrs->pADsValues[i].CaseIgnoreString;

            int pos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                              CB_ADDSTRING, 0,
                                              (LPARAM)(LPCTSTR)csSuffix);

            if (pwzUPNdomain && !wcscmp(csSuffix, pwzUPNdomain))
            {
                iCurSuffix = pos;
            }
        }

        if (iCurSuffix == -1 && pwzUPNdomain)
        {
            // User's UPN suffix does not match any of the defaults, so put
            // the user's into the combobox and select it.
            //
            iCurSuffix = (int)SendDlgItemMessage(GetHWnd(),
                                                 IDC_UPN_SUFFIX_COMBO,
                                                 CB_ADDSTRING, 0,
                                                 (LPARAM)pwzUPNdomain);
        }

        if (pwzUPNdomain)
        {
          SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_SETCURSEL,
                               (iCurSuffix > -1) ? iCurSuffix : 0, 0);
        }
        return TRUE;
    }

    //
    // No UPN suffixes on the OU, get those for the domain.
    //

    // Get the name of the user's domain.
    //
    CSmartWStr spwzUserDN;

    hr = SkipPrefix(GetObjPathName(), &spwzUserDN);

    CHECK_HRESULT(hr, return FALSE);

    CStrW strServer;

    hr = GetLdapServerName(m_pDsObj, strServer);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    // Get the name of the root domain.
    //
    CComPtr <IDsBrowseDomainTree> spDsDomains;

    hr = CoCreateInstance(CLSID_DsDomainTreeBrowser,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsBrowseDomainTree,
                          (LPVOID*)&spDsDomains);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = spDsDomains->SetComputer(strServer, NULL, NULL);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    int pos;
    CStr csRootDomain = L"@";
    PDOMAIN_TREE pDomTree = NULL;

    hr = spDsDomains->GetDomains(&pDomTree, 0);

    CHECK_HRESULT(hr,;);

    hr = CrackName(spwzUserDN, &pwzDomain, GET_DNS_DOMAIN_NAME, GetHWnd());

    CHECK_HRESULT(hr, return FALSE);

    if (pDomTree)
    {
        for (UINT index = 0; index < pDomTree->dwCount; index++)
        {
            if (pDomTree->aDomains[index].pszTrustParent == NULL)
            {
                // Add the root domain only if it is a substring of the current
                // domain.
                //
                size_t cchRoot = wcslen(pDomTree->aDomains[index].pszName);
                PWSTR pRoot = pwzDomain + wcslen(pwzDomain) - cchRoot;

                if (!_wcsicmp(pRoot, pDomTree->aDomains[index].pszName))
                {
                    csRootDomain += pDomTree->aDomains[index].pszName;

                    pos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                                  CB_ADDSTRING, 0,
                                                  (LPARAM)(LPCTSTR)csRootDomain);

                    if (pwzUPNdomain && !_wcsicmp(csRootDomain, pwzUPNdomain))
                    {
                        iCurSuffix = pos;
                    }
                    break;
                }
            }
        }

        spDsDomains->FreeDomains(&pDomTree);
    }

    // If the local domain is not the root, add it as well.
    //
    CStr csLocalDomain = L"@";
    csLocalDomain += pwzDomain;

    LocalFreeStringW(&pwzDomain);

    if (_wcsicmp(csRootDomain, csLocalDomain))
    {
        pos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                      CB_ADDSTRING, 0,
                                      (LPARAM)(LPCTSTR)csLocalDomain);

        if (pwzUPNdomain && !_wcsicmp(csLocalDomain, pwzUPNdomain))
        {
            iCurSuffix = pos;
        }
    }

    // Get UPN suffixes
    //
    CComBSTR bstrPartitions;
    //
    // get config path from main object
    //
    CComPtr<IADsPathname> spPathCracker;
    CDSBasePathsInfo CPaths;
    CStr cstrConfigPath;
    PDSDISPLAYSPECOPTIONS pDsDispSpecOptions;
    STGMEDIUM ObjMedium = {TYMED_NULL};
    FORMATETC fmte = {g_cfDsDispSpecOptions, NULL, DVASPECT_CONTENT, -1,
                      TYMED_HGLOBAL};

    hr = m_pWPTDataObj->GetData(&fmte, &ObjMedium);

    if (RPC_E_SERVER_DIED_DNE == hr)
    {
        hr = CPaths.InitFromName(strServer);

        CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&ObjMedium); return FALSE);

        PWSTR pwzConfigPath = (PWSTR)CPaths.GetConfigNamingContext();

        PWSTR pwzFullConfigPath = 0;
        CPaths.ComposeADsIPath(&pwzFullConfigPath, pwzConfigPath);

        if (pwzFullConfigPath)
        {
           cstrConfigPath = pwzFullConfigPath;
           delete[] pwzFullConfigPath;
           pwzFullConfigPath = 0;
        }
    }
    else
    {
        if (SUCCEEDED(hr))
        {
           pDsDispSpecOptions = (PDSDISPLAYSPECOPTIONS)ObjMedium.hGlobal;

           if (pDsDispSpecOptions->offsetServerConfigPath)
           {
              cstrConfigPath = (PWSTR)ByteOffset(pDsDispSpecOptions,
                                                 pDsDispSpecOptions->offsetServerConfigPath);
           }
        }

        if (cstrConfigPath.IsEmpty())
        {
            hr = CPaths.InitFromName(strServer);

            CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&ObjMedium); return FALSE);

            PWSTR pwzConfigPath = (PWSTR)CPaths.GetConfigNamingContext();

            PWSTR pwzFullConfigPath = 0;
            CPaths.ComposeADsIPath(&pwzFullConfigPath, pwzConfigPath);

            if (pwzFullConfigPath)
            {
               cstrConfigPath = pwzFullConfigPath;
               delete[] pwzFullConfigPath;
               pwzFullConfigPath = 0;
            }
        }
    }
    dspDebugOut((DEB_USER1, "Config path: %ws\n", (PCWSTR)cstrConfigPath));

    hr = GetADsPathname(spPathCracker);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), ReleaseStgMedium(&ObjMedium); return FALSE);

    hr = spPathCracker->Set(CComBSTR((PCWSTR)cstrConfigPath), ADS_SETTYPE_FULL);

    ReleaseStgMedium(&ObjMedium);
    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = spPathCracker->AddLeafElement(CComBSTR(g_wzPartitionsContainer));

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    hr = spPathCracker->Retrieve(ADS_FORMAT_X500, &bstrPartitions);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);
    dspDebugOut((DEB_ITRACE, "Config path: %ws\n", bstrPartitions));

    CComPtr <IDirectoryObject> spPartitions;

    hr = DSAdminOpenObject(bstrPartitions, 
                           IID_IDirectoryObject, 
                           (void **)&spPartitions);

    CHECK_HRESULT_REPORT(hr, GetHWnd(), return FALSE);

    spAttrs.Empty();

    hr = spPartitions->GetObjectAttributes(rgAttrs, 1, &spAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
        return FALSE;
    }

    if (cAttrs)
    {
        dspAssert(spAttrs && spAttrs->pADsValues && spAttrs->pADsValues->CaseIgnoreString);

        for (i = 0; i < spAttrs->dwNumValues; i++)
        {
            CStr csSuffix = L"@";
            csSuffix += spAttrs->pADsValues[i].CaseIgnoreString;

            int suffixPos = (int)SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO,
                                              CB_ADDSTRING, 0,
                                              (LPARAM)(LPCTSTR)csSuffix);

            if (pwzUPNdomain && !wcscmp(csSuffix, pwzUPNdomain))
            {
                iCurSuffix = suffixPos;
            }
        }
    }

    if (iCurSuffix == -1 && pwzUPNdomain)
    {
        // User's UPN suffix does not match any of the defaults, so put
        // the user's into the combobox and select it.
        //
        iCurSuffix = (int)SendDlgItemMessage(GetHWnd(),
                                             IDC_UPN_SUFFIX_COMBO,
                                             CB_ADDSTRING, 0,
                                             (LPARAM)pwzUPNdomain);
    }

    if (pwzUPNdomain)
    {
      SendDlgItemMessage(GetHWnd(), IDC_UPN_SUFFIX_COMBO, CB_SETCURSEL,
                        (iCurSuffix > -1) ? iCurSuffix : 0, 0);
    }

    UpdateComboBoxDropWidth(::GetDlgItem(GetHWnd(), IDC_UPN_SUFFIX_COMBO));
    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Member:     CDsUsrProfilePage::CDsUsrProfilePage
//
//-----------------------------------------------------------------------------
CDsUsrProfilePage::CDsUsrProfilePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                     HWND hNotifyObj, DWORD dwFlags) :
    m_ptszLocalHomeDir(NULL),
    m_ptszRemoteHomeDir(NULL),
    m_pwzSamName(NULL),
    m_nDrive(COMBO_Z_DRIVE),
    m_idHomeDirRadio(IDC_LOCAL_PATH_RADIO),
    m_fProfilePathWritable(FALSE),
    m_fScriptPathWritable(FALSE),
    m_fHomeDirWritable(FALSE),
    m_fHomeDriveWritable(FALSE),
    m_fProfilePathChanged(FALSE),
    m_fLogonScriptChanged(FALSE),
    m_fHomeDirChanged(FALSE),
    m_fHomeDriveChanged(FALSE),
    m_fSharedDirChanged(FALSE),
    m_pObjSID(NULL),
    CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags)
{
    TRACE(CDsUsrProfilePage,CDsUsrProfilePage);
#ifdef _DEBUG
    strcpy(szClass, "CDsUsrProfilePage");
#endif
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsUsrProfilePage::~CDsUsrProfilePage
//
//-----------------------------------------------------------------------------
CDsUsrProfilePage::~CDsUsrProfilePage()
{
    TRACE(CDsUsrProfilePage,~CDsUsrProfilePage);
    if (m_ptszLocalHomeDir)
    {
        delete m_ptszLocalHomeDir;
    }
    if (m_ptszRemoteHomeDir)
    {
        delete m_ptszRemoteHomeDir;
    }
    if (m_pwzSamName)
    {
        delete m_pwzSamName;
    }
    DO_DEL(m_pObjSID);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateUsrProfilePage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT
CreateUsrProfilePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, PWSTR pwzADsPath,
                     PWSTR pwzClass, HWND hNotifyObj, DWORD dwFlags,
                     const CDSSmartBasePathsInfo& basePathsInfo, HPROPSHEETPAGE * phPage)
{
    TRACE_FUNCTION(CreateUsrProfilePage);

    CDsUsrProfilePage * pPageObj = new CDsUsrProfilePage(pDsPage, pDataObj,
                                                         hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CDsUsrProfilePage::DlgProc(HWND, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUsrProfilePage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsUsrProfilePage::OnInitDialog(LPARAM)
{
    TRACE(CDsUsrProfilePage,OnInitDialog);
    HRESULT hr = S_OK;
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD i, iHomeDir, iHomeDrive, cAttrs = 0;
    LPTSTR ptz;
    CWaitCursor wait;

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    m_fProfilePathWritable  = CheckIfWritable(wzProfilePath);
    m_fScriptPathWritable   = CheckIfWritable(wzScriptPath);
    m_fHomeDirWritable      = CheckIfWritable(wzHomeDir);
    m_fHomeDriveWritable    = CheckIfWritable(wzHomeDrive);

    LPWSTR rgpwzAttrNames[] = {wzProfilePath, wzScriptPath, wzHomeDir,
                               wzHomeDrive, wzSAMname, g_wzObjectSID};
    //
    // Set edit control length limits.
    //
    SendDlgItemMessage(m_hPage, IDC_PROFILE_PATH_EDIT, EM_LIMITTEXT,
                       MAX_PATH+MAX_PATH, 0);
    SendDlgItemMessage(m_hPage, IDC_LOGON_SCRIPT_EDIT, EM_LIMITTEXT,
                       MAX_PATH+MAX_PATH, 0);
    SendDlgItemMessage(m_hPage, IDC_LOCAL_PATH_EDIT, EM_LIMITTEXT,
                       MAX_PATH+MAX_PATH, 0);
    SendDlgItemMessage(m_hPage, IDC_CONNECT_TO_PATH_EDIT, EM_LIMITTEXT,
                       MAX_PATH+MAX_PATH, 0);
    //
    // Get the attribute values.
    //
    hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames,
                                       ARRAYLENGTH(rgpwzAttrNames),
                                       &pAttrs, &cAttrs);

    if (!CHECK_ADS_HR_IGNORE_UNFOUND_ATTR(&hr, GetHWnd()))
    {
        return hr;
    }

    //
    // cAttrs + 1 is a flag value to indicate "not found".
    //
    iHomeDir = iHomeDrive = cAttrs + 1;

    //
    // Set the corresponding controls to the values found.
    //
    for (i = 0; i < cAttrs; i++)
    {
		//NTRAID#NTBUG9-567482-2002/03/10-jmessec   dspAssert simply redefines ASSERT; there is no code to back this up,
		//leading to a potential NULL dereference
        dspAssert(pAttrs[i].dwNumValues);
        dspAssert(pAttrs[i].pADsValues);

        if (_wcsicmp(pAttrs[i].pszAttrName, wzProfilePath) == 0)
        {
            if (!UnicodeToTchar(pAttrs[i].pADsValues->CaseIgnoreString, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                goto ExitCleanup;
            }

            SetDlgItemText(m_hPage, IDC_PROFILE_PATH_EDIT, ptz);

            delete ptz;

            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzScriptPath) == 0)
        {
            if (!UnicodeToTchar(pAttrs[i].pADsValues->CaseIgnoreString, &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                goto ExitCleanup;
            }

            SetDlgItemText(m_hPage, IDC_LOGON_SCRIPT_EDIT, ptz);

            delete ptz;

            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzHomeDir) == 0)
        {
            iHomeDir = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzHomeDrive) == 0)
        {
            iHomeDrive = i;
            continue;
        }

        if (_wcsicmp(pAttrs[i].pszAttrName, wzSAMname) == 0)
        {
            if (!AllocWStr(pAttrs[i].pADsValues->CaseIgnoreString, &m_pwzSamName))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                goto ExitCleanup;
            }
            continue;
        }
        if (_wcsicmp(pAttrs[i].pszAttrName, g_wzObjectSID) == 0)
        {
            if (IsValidSid(pAttrs[i].pADsValues->OctetString.lpValue))
            {
                m_pObjSID = new BYTE[pAttrs[i].pADsValues->OctetString.dwLength];

                CHECK_NULL_REPORT(m_pObjSID, m_hPage, return S_OK);

                memcpy(m_pObjSID, pAttrs[i].pADsValues->OctetString.lpValue,
                       pAttrs[i].pADsValues->OctetString.dwLength);
            }
        }
    }


    if (m_fHomeDirWritable && (m_pObjSID == NULL))
    {
        //
        // could write dir, but cannot read SID
        //
        m_fHomeDirWritable = FALSE;

        //
        // put up a warning
        //
        PWSTR pwzUserName = GetObjRDName();
        SuperMsgBox(GetHWnd(), IDS_CANT_READ_HOME_DIR_SID, 0, MB_OK |
            MB_ICONEXCLAMATION, hr, (PVOID *)&pwzUserName, 1,
            FALSE, __FILE__, __LINE__);
    }

    //
    // Fill the home drive combobox.
    //
    TCHAR szDrive[3];
    _tcscpy(szDrive, TEXT("C:"));
    for (i = 0; i <= COMBO_Z_DRIVE; i++)
    {
        szDrive[0]++;
        SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_ADDSTRING, 0,
                           (LPARAM)szDrive);
    }

    //
    // If there is a home directory set, display it.
    //
    if (iHomeDir < (cAttrs + 1))
    {
        if (!UnicodeToTchar(pAttrs[iHomeDir].pADsValues->CaseIgnoreString,
                            &ptz))
        {
            REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
            goto ExitCleanup;
        }

        if (iHomeDrive < (cAttrs + 1))
        {
            // A home drive value implies "connect to"; choose the
            // corresponding combobox item.
            //
            dspDebugOut((DEB_ITRACE, "Home-Drive: %S\n",
                         pAttrs[iHomeDrive].pADsValues->CaseIgnoreString));

            m_idHomeDirRadio = IDC_CONNECT_TO_RADIO;

            m_ptszRemoteHomeDir = ptz;

            if (!UnicodeToTchar(pAttrs[iHomeDrive].pADsValues->CaseIgnoreString,
                                &ptz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, m_hPage);
                goto ExitCleanup;
            }

            m_nDrive = (int)SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO,
                                               CB_FINDSTRING, 0,(LPARAM)ptz);

            delete ptz;

            dspAssert(m_nDrive >= 0);

            SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                               (WPARAM)m_nDrive, 0);
            //
            // Now set the radio button and edit control.
            //
            SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT,
                           m_ptszRemoteHomeDir);
            CheckDlgButton(m_hPage, IDC_CONNECT_TO_RADIO, BST_CHECKED);

            //
            // Enable the associated controls
            //
            EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), TRUE);
            EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), TRUE);
            EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), TRUE);

            //
            // Disable the local path edit box
            //
            EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), FALSE);
        }
        else
        {
            m_idHomeDirRadio = IDC_LOCAL_PATH_RADIO;

            m_ptszLocalHomeDir = ptz;

            SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                               (WPARAM)-1, 0);
            SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, m_ptszLocalHomeDir);
            CheckDlgButton(m_hPage, IDC_LOCAL_PATH_RADIO, BST_CHECKED);

            //
            // Enable the associated controls
            //
            EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), TRUE);

            //
            // Disable to connect to controls
            //
            EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), FALSE);
            EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), FALSE);
            EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), FALSE);
        }
    }
    else
    {
        m_idHomeDirRadio = IDC_LOCAL_PATH_RADIO;

        CheckDlgButton(m_hPage, IDC_LOCAL_PATH_RADIO, BST_CHECKED);

        //
        // Enable the associated controls
        //
        EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), TRUE);

        //
        // Disable to connect to controls
        //
        EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), FALSE);
    }

    if (!m_fProfilePathWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_PROFILE_PATH_EDIT), FALSE);
    }
    if (!m_fScriptPathWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_LOGON_SCRIPT_EDIT), FALSE);
    }
    if (!m_fHomeDirWritable || !m_fHomeDriveWritable)
    {
        EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_RADIO), FALSE);
        SendDlgItemMessage(m_hPage, IDC_CONNECT_TO_PATH_EDIT, EM_SETREADONLY, (WPARAM)TRUE, 0);
        EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_RADIO), FALSE);
        EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), FALSE);
        SendDlgItemMessage(m_hPage, IDC_LOCAL_PATH_EDIT, EM_SETREADONLY, (WPARAM)TRUE, 0);
    }

ExitCleanup:

    if (pAttrs)
    {
        FreeADsMem(pAttrs);
    }
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsUsrProfilePage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsUsrProfilePage::OnApply(void)
{
    TRACE(CDsUsrProfilePage,OnApply);
    HRESULT hr = S_OK;

    ADSVALUE ADsValueProfilePath = {ADSTYPE_CASE_IGNORE_STRING, NULL};
    ADS_ATTR_INFO AttrInfoProfilePath = {wzProfilePath, ADS_ATTR_UPDATE,
                                         ADSTYPE_CASE_IGNORE_STRING,
                                         &ADsValueProfilePath, 1};
    ADSVALUE ADsValueScriptPath = {ADSTYPE_CASE_IGNORE_STRING, NULL};
    ADS_ATTR_INFO AttrInfoScriptPath = {wzScriptPath, ADS_ATTR_UPDATE,
                                        ADSTYPE_CASE_IGNORE_STRING,
                                        &ADsValueScriptPath, 1};
    ADSVALUE ADsValueHomeDir = {ADSTYPE_CASE_IGNORE_STRING, NULL};
    ADS_ATTR_INFO AttrInfoHomeDir = {wzHomeDir, ADS_ATTR_UPDATE,
                                     ADSTYPE_CASE_IGNORE_STRING,
                                     &ADsValueHomeDir};
    ADSVALUE ADsValueHomeDrive = {ADSTYPE_CASE_IGNORE_STRING, NULL};
    ADS_ATTR_INFO AttrInfoHomeDrive = {wzHomeDrive, ADS_ATTR_UPDATE,
                                       ADSTYPE_CASE_IGNORE_STRING,
                                       &ADsValueHomeDrive};
    // Array of attributes to write
    ADS_ATTR_INFO rgAttrs[4];
    DWORD cAttrs = 0;
    TCHAR tsz[MAX_PATH+MAX_PATH+1];
    PTSTR ptsz;
    PWSTR pwzValue;

    //
    // Profile Path
    //

    if (m_fProfilePathWritable && m_fProfilePathChanged)
    {
        if (GetDlgItemText(m_hPage, IDC_PROFILE_PATH_EDIT, tsz,
                           MAX_PATH+MAX_PATH+1) == 0)
        {
            // An empty control means remove the attribute value from the object.
            //
            AttrInfoProfilePath.dwControlCode = ADS_ATTR_CLEAR;
            AttrInfoProfilePath.dwNumValues = 0;
            AttrInfoProfilePath.pADsValues = NULL;
        }
        else
        {
            CStr cstrValue = tsz;
            cstrValue.TrimLeft();
            cstrValue.TrimRight();

            if (cstrValue.CompareNoCase(tsz) != 0)
            {
               SetDlgItemText(m_hPage, IDC_PROFILE_PATH_EDIT, cstrValue);
            }

            if (!TcharToUnicode(const_cast<PTSTR>((LPCTSTR)cstrValue), &pwzValue))
            {
                CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
            }
            BOOL fExpanded;
            if (!ExpandUsername(pwzValue, fExpanded))
            {
                goto Cleanup;
            }
            if (fExpanded)
            {
                if (!UnicodeToTchar(pwzValue, &ptsz))
                {
                    CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
                }
                SetDlgItemText(m_hPage, IDC_PROFILE_PATH_EDIT, ptsz);
                delete [] ptsz;
            }
            ADsValueProfilePath.CaseIgnoreString = pwzValue;
        }
        rgAttrs[cAttrs++] = AttrInfoProfilePath;
    }

    //
    // Logon Script
    //
    if (m_fScriptPathWritable && m_fLogonScriptChanged)
    {
        if (GetDlgItemText(m_hPage, IDC_LOGON_SCRIPT_EDIT, tsz,
                           MAX_PATH+MAX_PATH) == 0)
        {
            // An empty control means remove the attribute value from the object.
            //
            AttrInfoScriptPath.dwControlCode = ADS_ATTR_CLEAR;
            AttrInfoScriptPath.dwNumValues = 0;
            AttrInfoScriptPath.pADsValues = NULL;
        }
        else
        {
            if (!TcharToUnicode(tsz, &pwzValue))
            {
                CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
            }
            ADsValueScriptPath.CaseIgnoreString = pwzValue;
        }
        rgAttrs[cAttrs++] = AttrInfoScriptPath;
    }

    //
    // Home Directory, Drive.
    //
    int nDirCtrl;
    if (m_fHomeDirWritable && m_fHomeDriveWritable &&
        (m_fHomeDirChanged || m_fHomeDriveChanged))
    {
        LONG iSel;
        if (IsDlgButtonChecked(m_hPage, IDC_LOCAL_PATH_RADIO) == BST_CHECKED)
        {
            nDirCtrl = IDC_LOCAL_PATH_EDIT;

            AttrInfoHomeDrive.dwControlCode = ADS_ATTR_CLEAR;
            AttrInfoHomeDrive.dwNumValues = 0;
            AttrInfoHomeDrive.pADsValues = NULL;
            rgAttrs[cAttrs++] = AttrInfoHomeDrive;
        }
        else
        {
            nDirCtrl = IDC_CONNECT_TO_PATH_EDIT;

            iSel = (int)SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_GETCURSEL, 0, 0);

            dspAssert(iSel >= 0);

            if (iSel >= 0)
            {
                GetDlgItemText(m_hPage, IDC_DRIVES_COMBO, tsz, MAX_PATH+MAX_PATH);
            }
            else
            {
                _tcscpy(tsz, TEXT("Z:"));
            }

            if (!TcharToUnicode(tsz, &pwzValue))
            {
                CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
            }

            AttrInfoHomeDrive.dwControlCode = ADS_ATTR_UPDATE;
            AttrInfoHomeDrive.dwNumValues = 1;
            AttrInfoHomeDrive.pADsValues = &ADsValueHomeDrive;
            ADsValueHomeDrive.CaseIgnoreString = pwzValue;
            rgAttrs[cAttrs++] = AttrInfoHomeDrive;
        }

        int cch;
        cch = GetDlgItemText(m_hPage, nDirCtrl, tsz, MAX_PATH+MAX_PATH);

        if (!FIsValidUncPath(tsz, (nDirCtrl == IDC_LOCAL_PATH_EDIT) ? VUP_mskfAllowEmptyPath : VUP_mskfAllowUNCPath))
        {
            ErrMsg((nDirCtrl == IDC_LOCAL_PATH_EDIT) ? IDS_ERRMSG_INVALID_PATH : IDS_ERRMSG_INVALID_UNC_PATH, m_hPage);
            SetFocus(GetDlgItem(m_hPage, nDirCtrl));
            hr = E_INVALIDARG;  // Path is not valid
            goto Cleanup;
        }

        if (cch == 0)
        {
            // An empty control means remove the attribute value from the object.
            //
            AttrInfoHomeDir.dwControlCode = ADS_ATTR_CLEAR;
            AttrInfoHomeDir.dwNumValues = 0;
            AttrInfoHomeDir.pADsValues = NULL;
        }
        else
        {
            if (!TcharToUnicode(tsz, &pwzValue))
            {
                CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), goto Cleanup);
            }
            BOOL fExpanded;
            if (!ExpandUsername(pwzValue, fExpanded))
            {
                goto Cleanup;
            }
            if (fExpanded)
            {
                if (!UnicodeToTchar(pwzValue, &ptsz))
                {
                    CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
                }
                SetDlgItemText(m_hPage, nDirCtrl, ptsz);
                if (nDirCtrl == IDC_LOCAL_PATH_EDIT)
                {
                    if (m_ptszLocalHomeDir)
                    {
                        delete [] m_ptszLocalHomeDir;
                    }
                    m_ptszLocalHomeDir = new TCHAR[_tcslen(ptsz) + 1];
                    CHECK_NULL_REPORT(m_ptszLocalHomeDir, m_hPage, hr = E_OUTOFMEMORY; goto Cleanup);
                    _tcscpy(m_ptszLocalHomeDir, ptsz);
                }
                else
                {
                    if (m_ptszRemoteHomeDir)
                    {
                        delete [] m_ptszRemoteHomeDir;
                    }
                    m_ptszRemoteHomeDir = new TCHAR[_tcslen(ptsz) + 1];
                    CHECK_NULL_REPORT(m_ptszRemoteHomeDir, m_hPage, hr = E_OUTOFMEMORY; goto Cleanup);
                    _tcscpy(m_ptszRemoteHomeDir, ptsz);
                }
                delete [] ptsz;
            }

            AttrInfoHomeDir.dwControlCode = ADS_ATTR_UPDATE;
            AttrInfoHomeDir.dwNumValues = 1;
            AttrInfoHomeDir.pADsValues = &ADsValueHomeDir;
            ADsValueHomeDir.CaseIgnoreString = pwzValue;
        }
        rgAttrs[cAttrs++] = AttrInfoHomeDir;

        if (nDirCtrl == IDC_CONNECT_TO_PATH_EDIT)
        {
            dspAssert(m_pObjSID != NULL);
            // attempt to create the directory.
            //
            DWORD dwErr = 
                DSPROP_CreateHomeDirectory(m_pObjSID, ADsValueHomeDir.CaseIgnoreString);
            if (dwErr != 0)
            {
                switch (dwErr)
                {
                case ERROR_ALREADY_EXISTS:
                    {
                        if (PathIsUNCServerShare(ADsValueHomeDir.CaseIgnoreString))
                        {
                           // Since this is the root of a share, we can't set
                           // the permissions without losing the inheritance so
                           // just give the admin a warning that they will have
                           // to set the permissions manually.

                           PVOID apv[1] = { (PVOID)ADsValueHomeDir.CaseIgnoreString };
                           SuperMsgBox(
                              GetHWnd(),
                              IDS_HOME_DIR_IS_ROOT, 
                              0, 
                              MB_OK | MB_ICONEXCLAMATION,
                              hr, 
                              apv, 
                              1,
                              FALSE, 
                              __FILE__, 
                              __LINE__);
                        }
                        else
                        {
                           //
                           // Report a warning and give the user full control
                           // of the directory
                           //
                           PVOID apv[1] = { (PVOID)ADsValueHomeDir.CaseIgnoreString };
                           if (IDYES == SuperMsgBox(GetHWnd(),
                                          IDS_USER_GIVEN_FULL_CONTROL, 
                                          0, 
                                          MB_YESNO | MB_DEFBUTTON1 | MB_ICONEXCLAMATION,
                                          hr, 
                                          apv, 
                                          1,
                                          FALSE, 
                                          __FILE__, 
                                          __LINE__))
                           {
                              dwErr = ERROR_SUCCESS;
                              dwErr = AddFullControlForUser(m_pObjSID, ADsValueHomeDir.CaseIgnoreString);
                           }
                        }
                     }
                     break;

                case ERROR_PATH_NOT_FOUND:
                case ERROR_BAD_NETPATH:
                    {
                        //
                        // Report a warning but continue
                        //
                        PWSTR* ppwzHomeDirName = &(ADsValueHomeDir.CaseIgnoreString);
                        SuperMsgBox(GetHWnd(),
                            IDS_HOME_DIR_CREATE_FAILED,
                            0, MB_OK | MB_ICONEXCLAMATION,
                            hr, (PVOID *)ppwzHomeDirName, 1,
                            FALSE, __FILE__, __LINE__);
                    }
                    break;

                case ERROR_LOGON_FAILURE:
                case ERROR_NOT_AUTHENTICATED:
                case ERROR_INVALID_PASSWORD:
                case ERROR_PASSWORD_EXPIRED:
                case ERROR_ACCOUNT_DISABLED:
                case ERROR_ACCOUNT_LOCKED_OUT:
                case ERROR_ACCESS_DENIED:
                    {
                        //
                        // Report a warning but continue
                        //
                        PWSTR* ppwzHomeDirName = &(ADsValueHomeDir.CaseIgnoreString);
                        SuperMsgBox(GetHWnd(),
                            IDS_HOME_DIR_CREATE_NO_ACCESS,
                            0, MB_OK | MB_ICONEXCLAMATION,
                            hr, (PVOID *)ppwzHomeDirName, 1,
                            FALSE, __FILE__, __LINE__);
                    }
                    break;

                default:
                    REPORT_ERROR_FORMAT(dwErr, IDS_ERR_CREATE_DIR, m_hPage);
                    SetFocus(GetDlgItem(m_hPage, nDirCtrl));
                    hr = E_INVALIDARG;  // Path is not valid
                    goto Cleanup;
                }
            }
        }
    }

    dspAssert(cAttrs > 0);

    DWORD cModified;

    //
    // Write the changes
    //
    hr = m_pDsObj->SetObjectAttributes(rgAttrs, cAttrs, &cModified);

    if (!CHECK_ADS_HR(&hr, m_hPage))
    {
        goto Cleanup;
    }

    m_fProfilePathChanged = FALSE;
    m_fLogonScriptChanged = FALSE;
    m_fHomeDirChanged = FALSE;
    m_fHomeDriveChanged = FALSE;
    m_fSharedDirChanged = FALSE;

Cleanup:

    if (ADsValueProfilePath.CaseIgnoreString)
    {
        delete ADsValueProfilePath.CaseIgnoreString;
    }
    if (ADsValueScriptPath.CaseIgnoreString)
    {
        delete ADsValueScriptPath.CaseIgnoreString;
    }
    if (ADsValueHomeDir.CaseIgnoreString)
    {
        delete ADsValueHomeDir.CaseIgnoreString;
    }
    if (ADsValueHomeDrive.CaseIgnoreString)
    {
        delete ADsValueHomeDrive.CaseIgnoreString;
    }
    return (SUCCEEDED(hr)) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUsrProfilePage::ExpandUsername
//
//  Synopsis:   If the %username% token is found in the string, substitute
//              the SAM account name.
//
//-----------------------------------------------------------------------------
BOOL
CDsUsrProfilePage::ExpandUsername(PWSTR & pwzValue, BOOL & fExpanded)
{
    dspAssert(pwzValue);

    CStrW strUserToken;

    strUserToken.LoadString(g_hInstance, IDS_PROFILE_USER_TOKEN);

    unsigned int TokenLength = strUserToken.GetLength();

    if (!TokenLength)
    {
        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
    }

    PWSTR pwzTokenStart = wcschr(pwzValue, strUserToken.GetAt(0));

    if (pwzTokenStart)
    {
        if (!m_pwzSamName)
        {
            ErrMsgParam(IDS_NO_SAMNAME_FOR_PROFILE, (LPARAM)(LPCWSTR)strUserToken, GetHWnd());
            return FALSE;
        }
        if ((wcslen(pwzTokenStart) >= TokenLength) &&
            (_wcsnicmp(pwzTokenStart, strUserToken, TokenLength) == 0))
        {
            fExpanded = TRUE;
        }
        else
        {
            fExpanded = FALSE;
            return TRUE;
        }
    }
    else
    {
        fExpanded = FALSE;
        return TRUE;
    }

    CStrW strValue, strAfterToken;

    while (pwzTokenStart)
    {
        *pwzTokenStart = L'\0';

        strValue = pwzValue;

        if ((L'\0' != *pwzValue) && !strValue.GetLength())
        {
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
        }

        PWSTR pwzAfterToken = pwzTokenStart + TokenLength;

        strAfterToken = pwzAfterToken;

        if ((L'\0' != *pwzAfterToken) && !strAfterToken.GetLength())
        {
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
        }

        delete pwzValue;

        strValue += m_pwzSamName;

        if (!strValue.GetLength())
        {
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
        }

        strValue += strAfterToken;

        if (!strValue.GetLength())
        {
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
        }

        if (!AllocWStr((PWSTR)(LPCWSTR)strValue, &pwzValue))
        {
            CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return FALSE);
        }

        pwzTokenStart = wcschr(pwzValue, strUserToken.GetAt(0));

        if (!(pwzTokenStart &&
              (wcslen(pwzTokenStart) >= TokenLength) &&
              (_wcsnicmp(pwzTokenStart, strUserToken, TokenLength) == 0)))
        {
            return TRUE;
        }
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:     DSPROP_CreateHomeDirectory
//
//  Synopsis:   Create the user's home directory.
//
//  Notes:      It calls the CreateDirectory() OS API with the
//              security descriptor with 2 ACEs, 
//              granting GENERIC_ALL access to the Administrators builtin group 
//              and to the user.
//
//-----------------------------------------------------------------------------



class CSidHolder
{
public:
  CSidHolder()
  {
    m_pSID = NULL;
  }
  ~CSidHolder()
  {
    if (m_pSID != NULL)
      ::FreeSid(m_pSID);
  }

  PSID m_pSID;
};


DWORD 
DSPROP_CreateHomeDirectory(IN PSID pUserSid, IN LPCWSTR lpszPathName)
{
    DWORD dwErr = 0;


    // build a SID for domain administrators
    CSidHolder sidAdmins;

    SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
    if (!AllocateAndInitializeSid(&NtAuth,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID, 
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &(sidAdmins.m_pSID)))
    {
        dwErr = GetLastError();
        DBG_OUT("AllocateAndInitializeSid failed!");
        return dwErr;
    }


    // build a DACL
    CSimpleAclHolder Dacl;

    static const int nAceCount = 2;
    PSID pAceSid[nAceCount];

    pAceSid[0] = pUserSid;
    pAceSid[1] = sidAdmins.m_pSID;

    EXPLICIT_ACCESS rgAccessEntry[nAceCount] = {0};

    for (int i = 0 ; i < nAceCount; i++) 
    {
        rgAccessEntry[i].grfAccessPermissions = GENERIC_ALL;
        rgAccessEntry[i].grfAccessMode = GRANT_ACCESS;
        rgAccessEntry[i].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;

        // build the trustee structs 
        //
        BuildTrusteeWithSid(&(rgAccessEntry[i].Trustee), pAceSid[i]);
    }

    // add the entries to the ACL
    //
    DBG_OUT("calling SetEntriesInAcl()");

    dwErr = SetEntriesInAcl(nAceCount, rgAccessEntry, NULL, &(Dacl.m_pAcl));
    if (dwErr != 0)
    {
        DBG_OUT("SetEntriesInAcl() failed");
        return dwErr;
    }

    // NTRAID#NTBUG9-660881-2002/07/18-JeffJon
    // Now that we have a DACL with the entries we want, create
    // the directory and then use SetNamedSecurityInfo to set the DACL
    // and the inheritance flag.

    SECURITY_ATTRIBUTES securityAttributes;
    securityAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    securityAttributes.lpSecurityDescriptor = 0;
    securityAttributes.bInheritHandle = FALSE;

    DBG_OUT("calling CreateDirectory()");
    if (!CreateDirectory(lpszPathName, &securityAttributes))
    {
        dwErr = GetLastError();
        DBG_OUT("CreateDirectory() failed");
        return dwErr;
    }

    // Now set the DACL and allow for inheritance

    dwErr = 
       SetNamedSecurityInfo(
          (LPWSTR)lpszPathName,
          SE_FILE_OBJECT,
          UNPROTECTED_DACL_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
          0,
          0,
          Dacl.m_pAcl,
          0);

    if (dwErr != ERROR_SUCCESS)
    {
        DBG_OUT("SetNamedSecurityInfo() failed");
        return dwErr;
    }

    return 0;
}

DWORD 
AddFullControlForUser(IN PSID pUserSid, IN LPCWSTR lpszPathName)
{
    DWORD dwErr = 0;
    // DACL
    PACL pOldDacl = NULL;
    PACL pNewDacl = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;


    EXPLICIT_ACCESS rgAccessEntry;

    rgAccessEntry.grfAccessPermissions = GENERIC_ALL;
    rgAccessEntry.grfAccessMode = GRANT_ACCESS;
    rgAccessEntry.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        
    // build the trustee structs 
    //
    BuildTrusteeWithSid(&(rgAccessEntry.Trustee), pUserSid);

    //Read Exisiting Security Descriptor

    dwErr = GetNamedSecurityInfo((LPWSTR)lpszPathName,
                                 SE_FILE_OBJECT,
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
          &pOldDacl,
                                 NULL,
          &pSD);

    if( dwErr != ERROR_SUCCESS )
    {
        DBG_OUT("GetNamedSecurityInfo() failed");
        goto CLEAN_RETURN;
    }

    //Build the New Acl to set
    DBG_OUT("calling SetEntriesInAcl()");
    dwErr = SetEntriesInAcl(1, &rgAccessEntry,pOldDacl,&pNewDacl);
    if( dwErr != ERROR_SUCCESS )
    {
        DBG_OUT("SetEntriesInAcl() failed");
        goto CLEAN_RETURN;
    }


    DBG_OUT("calling SetNamedSecurityInfo()");
    dwErr = SetNamedSecurityInfo((LPWSTR)lpszPathName, 
                                 SE_FILE_OBJECT,
                                 DACL_SECURITY_INFORMATION,
                                 NULL,
                                 NULL,
                                 pNewDacl,
                                 NULL);

    if (dwErr != ERROR_SUCCESS)
    {
        DBG_OUT("SetNamedSecurityInfo failed");
        goto CLEAN_RETURN;
    }
CLEAN_RETURN:
    if(pSD)
        LocalFree(pSD);
    if(pNewDacl)
        LocalFree(pNewDacl);

    return dwErr;
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsUsrProfilePage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//  Notes:      Standard multi-valued attribute handling assumes that the
//              "modify" button has an ID that is one greater than the
//              corresponding combo box.
//
//-----------------------------------------------------------------------------
LRESULT
CDsUsrProfilePage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if (m_fInInit)
    {
        return 0;
    }

    TCHAR tsz[MAX_PATH+MAX_PATH+1];
    int idNewHomeDirRadio = -1;

    switch (id)
    {
    case IDC_LOCAL_PATH_EDIT:
        if (codeNotify == EN_KILLFOCUS)
        {
            // Save any edit control changes.
            //
            if (GetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, tsz,
                               MAX_PATH+MAX_PATH) == 0)
            {
                if (m_ptszLocalHomeDir)
                {
                    delete m_ptszLocalHomeDir;
                    m_ptszLocalHomeDir = NULL;
                }
            }
            else
            {
                if (!m_ptszLocalHomeDir || _tcscmp(tsz, m_ptszLocalHomeDir))
                {
                    if (m_ptszLocalHomeDir)
                    {
                        delete m_ptszLocalHomeDir;
                    }

                    m_ptszLocalHomeDir = new TCHAR[_tcslen(tsz) + 1];

                    if (!m_ptszLocalHomeDir)
                    {
                        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
                    }

                    _tcscpy(m_ptszLocalHomeDir, tsz);
                }
            }
            break;
        }
        // fall through
    case IDC_CONNECT_TO_PATH_EDIT:
    case IDC_DRIVES_COMBO:
        if ((codeNotify == EN_KILLFOCUS) || (codeNotify == CBN_KILLFOCUS))
        {
            // Save any edit control changes.
            //
            if (GetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, tsz,
                               MAX_PATH+MAX_PATH) == 0)
            {
                if (m_ptszRemoteHomeDir)
                {
                    delete m_ptszRemoteHomeDir;
                    m_ptszRemoteHomeDir = NULL;
                }
            }
            else
            {
                if (!m_ptszRemoteHomeDir || _tcscmp(tsz, m_ptszRemoteHomeDir))
                {
                    if (m_ptszRemoteHomeDir)
                    {
                        delete m_ptszRemoteHomeDir;
                    }

                    m_ptszRemoteHomeDir = new TCHAR[_tcslen(tsz) + 1];

                    if (!m_ptszRemoteHomeDir)
                    {
                        CHECK_HRESULT_REPORT(E_OUTOFMEMORY, GetHWnd(), return E_OUTOFMEMORY);
                    }

                    _tcscpy(m_ptszRemoteHomeDir, tsz);
                }
            }
            break;
        }

        if ((codeNotify == EN_SETFOCUS) || (codeNotify == CBN_SETFOCUS))
        {
            // Toggle the radio buttons if needed.
            //
            if (id == IDC_LOCAL_PATH_EDIT)
            {
                if (IsDlgButtonChecked(m_hPage, IDC_CONNECT_TO_RADIO) == BST_CHECKED)
                {
                    idNewHomeDirRadio = IDC_LOCAL_PATH_RADIO;

                    CheckDlgButton(m_hPage, IDC_LOCAL_PATH_RADIO, BST_CHECKED);

                    CheckDlgButton(m_hPage, IDC_CONNECT_TO_RADIO, BST_UNCHECKED);
                }
            }
            else
            {
                if (IsDlgButtonChecked(m_hPage, IDC_LOCAL_PATH_RADIO) == BST_CHECKED)
                {
                    idNewHomeDirRadio = IDC_CONNECT_TO_RADIO;

                    CheckDlgButton(m_hPage, IDC_CONNECT_TO_RADIO, BST_CHECKED);

                    CheckDlgButton(m_hPage, IDC_LOCAL_PATH_RADIO, BST_UNCHECKED);
                }
            }
            //
            // Restore the incoming edit control and clear the other if needed.
            // Also set or clear the drives combo as appropiate.
            //
            if (id == IDC_LOCAL_PATH_EDIT)
            {
                if (idNewHomeDirRadio == IDC_LOCAL_PATH_RADIO)
                {
                    if (m_ptszLocalHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT,
                                       m_ptszLocalHomeDir);
                    }
                    SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, TEXT(""));
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)-1, 0);
                }
            }
            else
            {
                if (idNewHomeDirRadio == IDC_CONNECT_TO_RADIO)
                {
                    SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, TEXT(""));
                    if (m_ptszRemoteHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT,
                                       m_ptszRemoteHomeDir);
                    }
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)m_nDrive, 0);
                }
            }
            if (idNewHomeDirRadio != -1)
            {
                m_idHomeDirRadio = idNewHomeDirRadio;
            }
            break;
        }

        if (id == IDC_DRIVES_COMBO && codeNotify == CBN_SELCHANGE)
        {
            m_nDrive = (int)SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO,
                                               CB_GETCURSEL, 0, 0);
            SetDirty();
            m_fHomeDriveChanged = TRUE;
            break;
        }
        if ((id == IDC_LOCAL_PATH_EDIT || IDC_CONNECT_TO_PATH_EDIT == id)
            && codeNotify == EN_CHANGE)
        {
            SetDirty();
            m_fHomeDirChanged = TRUE;
        }
        break;

    case IDC_PROFILE_PATH_EDIT:
        if (codeNotify == EN_CHANGE)
        {
            SetDirty();
            m_fProfilePathChanged = TRUE;
        }
        break;

    case IDC_LOGON_SCRIPT_EDIT:
        if (codeNotify == EN_CHANGE)
        {
            SetDirty();
            m_fLogonScriptChanged = TRUE;
        }
        break;

    case IDC_LOCAL_PATH_RADIO:
    case IDC_CONNECT_TO_RADIO:
        if (codeNotify == BN_CLICKED)
        {
            if (id == IDC_LOCAL_PATH_RADIO)
            {
                if (m_idHomeDirRadio != IDC_LOCAL_PATH_RADIO)
                {
                    if (m_ptszLocalHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT,
                                       m_ptszLocalHomeDir);
                    }
                    SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT, TEXT(""));
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)-1, 0);
                    //
                    // Enable the associated controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), TRUE);

                    //
                    // Disable to connect to controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), FALSE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), FALSE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), FALSE);
                }
            }
            else
            {
                if (m_idHomeDirRadio != IDC_CONNECT_TO_RADIO)
                {
                    SetDlgItemText(m_hPage, IDC_LOCAL_PATH_EDIT, TEXT(""));
                    if (m_ptszRemoteHomeDir)
                    {
                        SetDlgItemText(m_hPage, IDC_CONNECT_TO_PATH_EDIT,
                                       m_ptszRemoteHomeDir);
                    }
                    SendDlgItemMessage(m_hPage, IDC_DRIVES_COMBO, CB_SETCURSEL,
                                       (WPARAM)m_nDrive, 0);

                    //
                    // Enable the associated controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_DRIVES_COMBO), TRUE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_TO_STATIC), TRUE);
                    EnableWindow(GetDlgItem(m_hPage, IDC_CONNECT_TO_PATH_EDIT), TRUE);

                    //
                    // Disable to connect to controls
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDC_LOCAL_PATH_EDIT), FALSE);
                }
            }
            if (m_idHomeDirRadio != id)
            {
                m_idHomeDirRadio = id;
                SetDirty();
                m_fHomeDriveChanged = TRUE;
                m_fHomeDirChanged = TRUE;
            }
        }
        return 1;
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUsrProfilePage::OnNotify
//
//-----------------------------------------------------------------------------
LRESULT
CDsUsrProfilePage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    return CDsPropPageBase::OnNotify(wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUsrProfilePage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsUsrProfilePage::OnDestroy(void)
{
    if (m_ptszLocalHomeDir)
    {
        delete m_ptszLocalHomeDir;
        m_ptszLocalHomeDir = NULL;
    }
    if (m_ptszRemoteHomeDir)
    {
        delete m_ptszRemoteHomeDir;
        m_ptszRemoteHomeDir = NULL;
    }
    CDsPropPageBase::OnDestroy();
    // If an application processes this message, it should return zero.
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Class:      CLogonWkstaDlg
//
//  Purpose:    Update the logon workstations attribute. This is a dialog
//              that hosts the CMultiStringAttr class.
//
//-----------------------------------------------------------------------------
CLogonWkstaDlg::CLogonWkstaDlg(CDsPropPageBase * pPage) :
    m_pPage(pPage),
    m_MSA(pPage),
    m_fAllWkstas(TRUE),
    m_fOrigAllWkstas(TRUE),
    m_fFirstUp(TRUE)
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::Init
//
//  Synopsis:   Do initialization where failures can occur and then be
//              returned. Can be only called once as written.
//
//  Arguments:  [pAttrMap]   - contains the attr name.
//              [pAttrInfo]  - place to store the values.
//              [fWritable]  - is the attribute writable.
//              [nLimit]     - the max number of values (zero means no limit).
//              [fCommaList] - if TRUE, pAttrInfo is a single-valued, comma
//                             delimited list.
//-----------------------------------------------------------------------------
HRESULT
CLogonWkstaDlg::Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                     BOOL fWritable, int nLimit, BOOL fCommaList)
{
    return m_MSA.Init(pAttrMap, pAttrInfo, fWritable, nLimit, fCommaList);
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::Write
//
//  Synopsis:   Return the ADS_ATTR_INFO array of values to be Applied.
//
//-----------------------------------------------------------------------------
HRESULT CLogonWkstaDlg::Write(PADS_ATTR_INFO pAttrInfo)
{
    if (m_fAllWkstas)
    {
        pAttrInfo->pADsValues = NULL;
        pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        return S_OK;
    }
    return m_MSA.Write(pAttrInfo);
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::Edit
//
//  Synopsis:   Post the edit dialog.
//
//-----------------------------------------------------------------------------
int
CLogonWkstaDlg::Edit(void)
{
    return (int)DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_LOGON_WKSTA),
                          m_pPage->GetHWnd(), StaticDlgProc, (LPARAM)this);
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::IsDirty
//
//  Synopsis:   Has anything changed.
//
//-----------------------------------------------------------------------------
BOOL
CLogonWkstaDlg::IsDirty(void)
{
    if (m_fAllWkstas)
    {
        return !m_fOrigAllWkstas;
    }
    else
    {
        return m_MSA.IsDirty();
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::ClearDirty
//
//  Synopsis:   Clear dirty state.
//
//-----------------------------------------------------------------------------
void
CLogonWkstaDlg::ClearDirty(void)
{
    m_fOrigAllWkstas = m_fAllWkstas;
    m_MSA.ClearDirty();
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::StaticDlgProc
//
//  Synopsis:   The static dialog proc for editing a multi-valued attribute.
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CLogonWkstaDlg::StaticDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam)
{
    CLogonWkstaDlg * pMSAD = (CLogonWkstaDlg *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        pMSAD = (CLogonWkstaDlg *)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pMSAD);
    }

    if (pMSAD)
    {
        return pMSAD->MultiValDlgProc(hDlg, uMsg, wParam, lParam);
    }

    return 0;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLogonWkstaDlg::MultiValDlgProc
//
//  Synopsis:   The instancce dialog proc for editing a multi-valued attribute.
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CLogonWkstaDlg::MultiValDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CLogonWkstaDlg * pMSAD = (CLogonWkstaDlg *)GetWindowLongPtr(hDlg, DWLP_USER);
    CMultiStringAttr * pMSA = &pMSAD->m_MSA;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        CHECK_NULL_REPORT(pMSA, hDlg, return 0;);
        if (m_fFirstUp)
        {
            m_fAllWkstas = !pMSA->HasValues();
            m_fFirstUp = FALSE;
        }
        m_fOrigAllWkstas = m_fAllWkstas;
        if (m_fAllWkstas)
        {
            CheckDlgButton(hDlg, IDC_ANY_WKSTA_RADIO, BST_CHECKED);
            if (!pMSA->IsWritable())
            {
                EnableWindow(GetDlgItem(hDlg, IDC_SPECIFIC_WKSTAS_RADIO), FALSE);
            }
            pMSA->EnableControls(hDlg, FALSE);
        }
        else
        {
            CheckDlgButton(hDlg, IDC_SPECIFIC_WKSTAS_RADIO, BST_CHECKED);
            if (!pMSA->IsWritable())
            {
                EnableWindow(GetDlgItem(hDlg, IDC_ANY_WKSTA_RADIO), FALSE);
            }
        }
        return pMSA->DoDlgInit(hDlg);

    case WM_COMMAND:
        CHECK_NULL_REPORT(pMSA, hDlg, return 0;);
        int id, code;
        id = GET_WM_COMMAND_ID(wParam, lParam);
        code = GET_WM_COMMAND_CMD(wParam, lParam);

        if ((id == IDC_SPECIFIC_WKSTAS_RADIO) || (id == IDC_ANY_WKSTA_RADIO))
        {
            if (code == BN_CLICKED)
            {
                m_fAllWkstas = id == IDC_ANY_WKSTA_RADIO;

                // Set the dialog dirty if there was a change
                if (m_fAllWkstas != m_fOrigAllWkstas)
                {
                   pMSA->SetDirty(hDlg);
                   pMSA->ToggleDefaultBtn(hDlg, TRUE);
                }

                pMSA->EnableControls(hDlg, !m_fAllWkstas);
            }
        }
        else
        {
            int ret = pMSA->DoCommand(hDlg, id, code);
            if (ret == IDCANCEL)
            {
                m_fAllWkstas = m_fOrigAllWkstas;
            }
            return ret;
        }
        break;

    case WM_NOTIFY:
        CHECK_NULL_REPORT(pMSA, hDlg, return 0;);
        return pMSA->DoNotify(hDlg, (NMHDR *)lParam);

    case WM_HELP:
        LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
        dspDebugOut((DEB_ITRACE, "WM_HELP: CtrlId = %d, ContextId = 0x%x\n",
                     pHelpInfo->iCtrlId, pHelpInfo->dwContextId));
        if (pHelpInfo->iCtrlId < 1)
        {
            return 0;
        }
        WinHelp(hDlg, DSPROP_HELP_FILE_NAME, HELP_CONTEXTPOPUP, pHelpInfo->dwContextId);
        break;
    }

    return 0;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\user.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       user.cxx
//
//  Contents:   
//
//  History:    05-May-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "objlist.h"
#include "user.h"
#include "group.h"
#include "qrybase.h"
#ifndef UNICODE
#   include <stdio.h>
#endif

//+----------------------------------------------------------------------------
//
//  Function:   CountryCode
//
//  Synopsis:   Handles the Country combo box to get/set the Country-Code
//              (LDAP display name: countryCode) numeric ISO-3166 code.
//
//  Notes:      This attr function MUST be called after CountryName. It
//              relies on CountryName populating the combobox and setting its
//              item data values.
//
//-----------------------------------------------------------------------------
HRESULT
CountryCode(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    switch(DlgOp)
    {
    case fOnCommand:
        if (CBN_SELCHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fApply:
        DBG_OUT("CountryCode: fApply");

        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        int iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                           CB_GETCURSEL, 0, 0);
        if (iSel < 0)
        {
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            INT_PTR pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                              CB_GETITEMDATA, iSel, 0);
            if (pCur == LB_ERR)
            {
                DWORD dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr););
            }

            PDsCountryCode pCountryCode = (PDsCountryCode)pCur;

            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->Integer = pCountryCode->wCode;
        }
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CountryName
//
//  Synopsis:   Handles the Country combo box/static control to get/set the
//              Country-Name (LDAP display name: c) 2 character ISO-3166 code.
//
//  Notes:      If the control is read-only, then assume it is a static text
//              control (or a read-only edit control) rather than a combobox.
//              Also, if read-only, then only the fInit should be called.
//
//-----------------------------------------------------------------------------
HRESULT
CountryName(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    PWSTR pwsz = NULL;
    DWORD dwErr = 0;
    INT_PTR pCur = NULL;
    PDsCountryCode pCountryCode = NULL;
    int iSel = 0, iCur = -1, cxExtent = 0;
#ifdef UNICODE
    CStrW strFirstCode, strLastCode, strCodeLine, strCurName;
#else
    CStr strFirstCode, strLastCode, strCodeLine, strCurName;
#endif
    CStrW str2CharAbrev;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        if (!pAttrMap->fIsReadOnly && !PATTR_DATA_IS_WRITABLE(pAttrData))
        {
            EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID),
                         FALSE);
            //
            // Remove the accelerator from the label since a disabled control
            // is not reachable.
            //
            CStrW strLabel;
            strLabel.LoadString(g_hInstance, IDS_COUNTRY_LABEL_NO_ACCEL);
            SetDlgItemText(pPage->GetHWnd(), IDC_COUNTRY_LABEL, strLabel.GetBuffer(0));
        }
		// fall through...
    case fObjChanged:
      {
        DBG_OUT("CountryName: fInit");
        PTSTR ptzFullName = NULL;
        WORD wCode = 0;
        HDC hDC = NULL;
        unsigned long ulFirstCode, ulLastCode, i;

        strFirstCode.LoadString(g_hInstance, IDS_FIRST_COUNTRY_CODE);
        strLastCode.LoadString(g_hInstance, IDS_LAST_COUNTRY_CODE);

        if (strFirstCode.IsEmpty() || strLastCode.IsEmpty())
        {
            ERR_MSG(IDS_ERR_COUNTRY_DATA_BAD, pPage->GetHWnd());
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }

        ulFirstCode = _tcstoul(strFirstCode, NULL, 10);
        ulLastCode = _tcstoul(strLastCode, NULL, 10);

        if (!pAttrMap->fIsReadOnly)
        {
            hDC = GetDC(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID));
        }

        PWSTR pwzCurCode;

        if (pAttrInfo && pAttrInfo->dwNumValues)
        {
            pwzCurCode = pAttrInfo->pADsValues->CaseIgnoreString;
        }
        else
        {
            pwzCurCode = NULL;
        }

        for (i = ulFirstCode; i <= ulLastCode; i++)
        {
            strCodeLine.LoadString(g_hInstance, i);

            if (strCodeLine.IsEmpty())
            {
                ERR_MSG(IDS_ERR_COUNTRY_DATA_BAD, pPage->GetHWnd());
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            if (!GetALineOfCodes(strCodeLine.GetBuffer(1), &ptzFullName, str2CharAbrev, &wCode))
            {
                ERR_MSG(IDS_ERR_COUNTRY_DATA_BAD, pPage->GetHWnd());
                return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            }

            if (!pAttrMap->fIsReadOnly)
            {
                // If not in read-only mode, then we use a combobox from which
                // the user selects the country.
                // Insert the full name into the combobox list.
                //
                SIZE s;
                if (hDC != NULL)
                {
                  GetTextExtentPoint32(hDC, ptzFullName, static_cast<int>(_tcslen(ptzFullName)), &s);

                  if (s.cx > cxExtent)
                  {
                      cxExtent = s.cx;
                  }

                  iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                                 CB_ADDSTRING, 0, (LPARAM)ptzFullName);

                  if (iSel < 0)
                  {
                      CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
                  }

                  //
                  // Add the name codes as item data.
                  //
                  pCountryCode = new DsCountryCode;

                  CHECK_NULL_REPORT(pCountryCode, pPage->GetHWnd(), return E_OUTOFMEMORY);

                  wcscpy(pCountryCode->pwz2CharAbrev, str2CharAbrev);

                  pCountryCode->wCode = wCode;

                  if (SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                         CB_SETITEMDATA, iSel,
                                         (LPARAM)pCountryCode) == CB_ERR)
                  {
                      CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
                  }
                }
            }
            //
            // See if the current country matches that saved on the DS object
            // (if one has been saved).
            //
            if (pwzCurCode)
            {
                if (_wcsicmp(pwzCurCode, str2CharAbrev) == 0)
                {
                    iCur = iSel;
                    strCurName = ptzFullName;
                }
            }

            if ((iCur == iSel) && pAttrMap->fIsReadOnly)
            {
                // Read-only mode means that we are using a static text
                // control. Insert the full name into the control.
                //
                SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptzFullName);
                break;
            }

            if (pAttrMap->fIsReadOnly)
            {
                iSel++;
            }
        }

        if (!pAttrMap->fIsReadOnly)
        {
          if (hDC != NULL)
          {
            ReleaseDC(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), hDC);
          }
          SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                             CB_SETHORIZONTALEXTENT, (WPARAM)cxExtent, 0);
          if (iCur >= 0)
          {
            iCur = (int) SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      CB_FINDSTRINGEXACT, 0,
                                      (WPARAM)(LPCTSTR)strCurName);
            dspAssert(iCur != CB_ERR);
            SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                               CB_SETCURSEL, iCur, 0);
          }
        }
        else
        {
          if (iCur < 0)
          {
            // If iCur is still -1, then country code hasn't been set.
            //
            SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, TEXT(""));
          }
        }
        break;
      }
    case fApply:
        DBG_OUT("CountryName: fApply");

        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                       CB_GETCURSEL, 0, 0);
        if (iSel < 0)
        {
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {
            pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      CB_GETITEMDATA, iSel, 0);
            if (pCur == LB_ERR)
            {
                dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr););
            }

            pCountryCode = (PDsCountryCode)pCur;

            if (!AllocWStr(pCountryCode->pwz2CharAbrev, &pwsz))
            {
                CHECK_HRESULT_REPORT(E_OUTOFMEMORY, pPage->GetHWnd(), return E_OUTOFMEMORY);
            }

            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL_REPORT(pADsValue, pPage->GetHWnd(), return E_OUTOFMEMORY);

            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->CaseIgnoreString = pwsz;
        }
        break;

    case fOnCommand:
        if (CBN_SELCHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fOnDestroy:
        DBG_OUT("CountryName: fOnDestroy");
        iSel = 0;
        do
        {
            pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                      CB_GETITEMDATA, iSel, 0);
            if (pCur != CB_ERR)
            {
                // Delete the itemdata string.
                //
                delete (PDsCountryCode)pCur;

                iSel++;
            }
        } while (pCur != CB_ERR);
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   TextCountry
//
//  Synopsis:   Handles the Country combo box to get/set the Text-Country
//              (LDAP display name: co) 
//
//  Notes:      This attr function MUST be called after CountryName. It
//              relies on CountryName populating the combobox
//
//-----------------------------------------------------------------------------
HRESULT
TextCountry(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    switch(DlgOp)
    {
    case fOnCommand:
        if (CBN_SELCHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fApply:
        DBG_OUT("TextCountry: fApply");

        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        int iSel = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                           CB_GETCURSEL, 0, 0);
        if (iSel < 0)
        {
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        else
        {   
            LPTSTR ptz = new TCHAR[pAttrMap->nSizeLimit + 1];
            CHECK_NULL_REPORT(ptz, pPage->GetHWnd(), return E_OUTOFMEMORY);

            INT_PTR pCur = SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                              CB_GETLBTEXT, iSel, (LPARAM) (LPCSTR) ptz );
            if (pCur == LB_ERR)
            {
                delete[] ptz;
                DWORD dwErr = GetLastError();
                CHECK_WIN32_REPORT(dwErr, pPage->GetHWnd(), return HRESULT_FROM_WIN32(dwErr););
            }
            
            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            if( pADsValue == NULL )
            {
              ReportError(E_OUTOFMEMORY,0, pPage->GetHWnd()); 
              delete[] ptz;
              return E_OUTOFMEMORY;
            }

            
            if (!TcharToUnicode(ptz, &pADsValue->CaseIgnoreString))
            {
              delete[] ptz;
              delete pADsValue;
              REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
              return E_OUTOFMEMORY;
            }

            delete[] ptz;
    
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            
        }
        break;
    }

    return S_OK;
}

// CountryName helpers:

//+----------------------------------------------------------------------------
//
//  Function:   GetALineOfCodes
//
//  Synopsis:   Parse a line of country codes.
//
//-----------------------------------------------------------------------------
BOOL GetALineOfCodes(PTSTR ptzLine, PTSTR * pptzFullName,
                     CStrW & str2CharAbrev, LPWORD pwCode)
{
    //
    // The line is parsed from end to beginning. That way we don't need to
    // dependend on the column widths being fixed.
    //
    // The last token is the numeric code. Read it.
    //
    RemoveTrailingWhitespace(ptzLine);

    PTSTR ptzCode = _tcsrchr(ptzLine, TEXT(' '));

    if (!ptzCode)
    {
        // try tab char.
        //
        ptzCode = _tcsrchr(ptzLine, TEXT('\t'));
    }

    if (!ptzCode || (ptzCode <= ptzLine) || (_tcslen(ptzCode) < 2))
    {
        return FALSE;
    }

    *ptzCode = TEXT('\0');

    ptzCode++;

    int iScanned = _stscanf(ptzCode, TEXT("%u"), pwCode);
    dspAssert(iScanned == 1);

    //
    // The next to last token is the 3 character code. Skip it.
    //
    RemoveTrailingWhitespace(ptzLine);

    size_t nLen = _tcslen(ptzLine);

    if (3 >= nLen)
    {
        return FALSE;
    }

    ptzLine[nLen - 3] = TEXT('\0');

    //
    // The next token (moving toward the front) is the 2 character code.
    //
    RemoveTrailingWhitespace(ptzLine);

    PTSTR ptz2CharAbrev = _tcsrchr(ptzLine, TEXT(' '));

    if (!ptz2CharAbrev)
    {
        // try tab char.
        //
        ptz2CharAbrev = _tcsrchr(ptzLine, TEXT('\t'));
    }

    if (!ptz2CharAbrev || (ptz2CharAbrev <= ptzLine))
    {
        return FALSE;
    }

    *ptz2CharAbrev = TEXT('\0');

    ptz2CharAbrev++;

    if (_tcslen(ptz2CharAbrev) != 2)
    {
        return FALSE;
    }

    str2CharAbrev = ptz2CharAbrev;

    //
    // The first token is the full country name.
    //
    RemoveTrailingWhitespace(ptzLine);

    if (!_tcslen(ptzLine))
    {
        return FALSE;
    }

    *pptzFullName = ptzLine;

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   RemoveTrailingWhitespace
//
//  Synopsis:   Trailing white space is replaced by NULLs.
//
//-----------------------------------------------------------------------------
void RemoveTrailingWhitespace(PTSTR ptz)
{
    size_t nLen = _tcslen(ptz);

    while (nLen)
    {
        if (!iswspace(ptz[nLen - 1]))
        {
            return;
        }
        ptz[nLen - 1] = L'\0';
        nLen--;
    }
}

//+----------------------------------------------------------------------------
//
//  Function:   ManagerEdit
//
//  Synopsis:   Handles the manager edit control.
//
//  Notes:      The page member m_pData stores the pAttrData value whose pVoid
//              element is set to the DN of the manager. The other manager
//              attr functions can then access the manager value and can also
//              read the fWritable element.
//
//-----------------------------------------------------------------------------
HRESULT
ManagerEdit(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
            PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
            DLG_OP DlgOp)
{
    PWSTR pwz = NULL;
    PWSTR canonical = NULL;
    HRESULT hr = S_OK;

    switch (DlgOp)
    {
    case fInit:
        dspAssert(pAttrData);
        if (pAttrInfo && pAttrInfo->dwNumValues > 0)
        {
            if (!AllocWStr(pAttrInfo->pADsValues[0].DNString, &pwz))
            {
                REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                return E_OUTOFMEMORY;
            }
            hr = CrackName (pwz, &canonical, GET_OBJ_CAN_NAME_EX, pPage->GetHWnd());
            if (FAILED(hr))
            {
                delete [] pwz;
                return S_FALSE;
            }

            CStr folder;
            CStr name;

            GetNameParts(canonical, folder, name);

            SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, (PCWSTR)name);
        }
        pAttrData->pVoid = reinterpret_cast<LPARAM>(pwz);
        ((CDsTableDrivenPage *)pPage)->m_pData = reinterpret_cast<LPARAM>(pAttrData);
        break;

    case fOnCommand:
        if (EN_CHANGE == lParam)
        {
            pPage->SetDirty();
            PATTR_DATA_SET_DIRTY(pAttrData);
        }
        break;

    case fApply:
        if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
        {
            return ADM_S_SKIP;
        }

        pwz = (PWSTR)reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData)->pVoid;

        if (pwz)
        {
            // make a copy cause CDsTableDrivenPage::OnApply deletes it.
            PWSTR pwzTmp;
            if (!AllocWStr(pwz, &pwzTmp))
            {
                REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
                return E_OUTOFMEMORY;
            }

            PADSVALUE pADsValue;
            pADsValue = new ADSVALUE;
            CHECK_NULL(pADsValue, return E_OUTOFMEMORY);
      
            pAttrInfo->pADsValues = pADsValue;
            pAttrInfo->dwNumValues = 1;
            pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
            pADsValue->dwType = pAttrInfo->dwADsType;
            pADsValue->CaseIgnoreString = pwzTmp;
        }
        else
        {
            pAttrInfo->pADsValues = NULL;
            pAttrInfo->dwNumValues = 0;
            pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
        }
        break;

    case fOnDestroy:
        if (reinterpret_cast<CDsTableDrivenPage *>(pPage)->m_pData)
        {
            PATTR_DATA pData = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData);
            PVOID pVoid = reinterpret_cast<PVOID>(pData->pVoid);
            DO_DEL(pVoid);
        }
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   DirectReportsList
//
//  Synopsis:   Handles the User Organisation Direct Reports list.
//
//-----------------------------------------------------------------------------
HRESULT
DirectReportsList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                  PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA,
                  DLG_OP DlgOp)
{
  //
  // Multi-select will result in a return at this point
  //
  if (pPage->GetObjPathName() == NULL)
  {
    return S_OK;
  }

  switch (DlgOp)
  {
    case fInit:
      {
        HRESULT hr;
        Smart_PADS_ATTR_INFO spAttrs;
        DWORD cAttrs = 0;
        PWSTR rgpwzAttrNames[] = {pAttrMap->AttrInfo.pszAttrName};
        CComPtr <IDirectoryObject> spGcObj;

        hr = BindToGCcopyOfObj(pPage, pPage->GetObjPathName(), &spGcObj);

        if (SUCCEEDED(hr))
        {
          hr = spGcObj->GetObjectAttributes(rgpwzAttrNames, 1, &spAttrs, &cAttrs);

          if (SUCCEEDED(hr))
          {
            //
            // If the bind to the GC was successful, use those results.
            // Otherwise, use the results of the local object read.
            //
            if (!cAttrs)
            {
              return S_OK;
            }
            pAttrInfo = spAttrs;
          }
        }

        if (!pAttrInfo)
        {
          return S_OK;
        }

        for (DWORD i = 0; i < pAttrInfo->dwNumValues; i++)
        {
          PWSTR pwzDns;
          hr = CrackName(pAttrInfo->pADsValues[i].DNString, &pwzDns,
                         GET_OBJ_CAN_NAME_EX, pPage->GetHWnd());

          CHECK_HRESULT(hr, return hr);

          CStr name;
          CStr folder;

          GetNameParts(pwzDns, folder, name);

          LRESULT lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST, LB_ADDSTRING,
                                               0, (LPARAM)(LPCTSTR)name);
          if (lresult != LB_ERR)
          {
            PWSTR pwzDN = new WCHAR[wcslen(pAttrInfo->pADsValues[i].DNString) + 1];
            if (pwzDN != NULL)
            {
              wcscpy(pwzDN, pAttrInfo->pADsValues[i].DNString);
              SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                 LB_SETITEMDATA, lresult, (LPARAM)pwzDN);
            }
          }
        }
      }
      break;
    
    case fOnCommand:
      {
        if (lParam == LBN_DBLCLK)
        {
          //
          // Retrieve the current selection
          //
          PWSTR pwzDN = NULL;
          LRESULT lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                               LB_GETCURSEL, 0, 0);

          if (lresult != LB_ERR)
          {
            //
            // Get the DN associated with the item
            //
            lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                         LB_GETITEMDATA, lresult, 0);
            if (lresult != LB_ERR)
            {
              pwzDN = (PWSTR)lresult;
              if (pwzDN != NULL)
              {
                //
                // Launch the secondary proppages
                //
                PostPropSheet(pwzDN, pPage);
              }
            }
          }
        }
      }
      break;
    
    case fOnDestroy:
      {
        //
        // Must free the memory associated with the list box
        //
        LRESULT lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                             LB_GETCOUNT, 0, 0);
        if (lresult != LB_ERR)
        {
          for (LRESULT idx = lresult - 1 ; idx >= 0; idx--)
          {
            lresult = SendDlgItemMessage(pPage->GetHWnd(), IDC_REPORTS_LIST,
                                         LB_GETITEMDATA, idx, 0);
            if (lresult != LB_ERR)
            {
              PWSTR pwzDN = (PWSTR)lresult;
              if (pwzDN != NULL)
              {
                delete[] pwzDN;
              }
            }
          }
        }
      }
      break;

    default:
      break;
  }

  return S_OK;
}

#ifdef DSADMIN

//+----------------------------------------------------------------------------
//
//  Function:   ExpandUsername
//
//  Synopsis:   Substitutes the SAM account name for the %username%
//
//  Notes:      
//
//-----------------------------------------------------------------------------

BOOL
ExpandUsername(
   PWSTR&         pwzValue,  
   PWSTR          pwzSamName,
   BOOL&          fExpanded, 
   const CStrW&   strUserToken)     
{
  dspAssert(pwzValue);

  unsigned int TokenLength = strUserToken.GetLength();

  if (!TokenLength)
  {
    return FALSE;
  }

  if (!pwzSamName)
  {
    return FALSE;
  }

  PWSTR pwzTokenStart = wcschr(pwzValue, strUserToken.GetAt(0));

  if (pwzTokenStart)
  {
    if ((wcslen(pwzTokenStart) >= TokenLength) &&
        (_wcsnicmp(pwzTokenStart, strUserToken, TokenLength) == 0))
    {
      fExpanded = TRUE;
    }
    else
    {
      fExpanded = FALSE;
      return TRUE;
    }
  }
  else
  {
    fExpanded = FALSE;
    return TRUE;
  }

  CStrW strValue, strAfterToken;

  while (pwzTokenStart)
  {
    *pwzTokenStart = L'\0';

    strValue = pwzValue;

    if ((L'\0' != *pwzValue) && !strValue.GetLength())
    {
      return FALSE;
    }

    PWSTR pwzAfterToken = pwzTokenStart + TokenLength;

    strAfterToken = pwzAfterToken;

    if ((L'\0' != *pwzAfterToken) && !strAfterToken.GetLength())
    {
      return FALSE;
    }

    delete [] pwzValue;

    strValue += pwzSamName;

    if (!strValue.GetLength())
    {
      return FALSE;
    }

    strValue += strAfterToken;

    if (!strValue.GetLength())
    {
      return FALSE;
    }

    if (!AllocWStr((PWSTR)(LPCWSTR)strValue, &pwzValue))
    {
      return FALSE;
    }

    pwzTokenStart = wcschr(pwzValue, strUserToken.GetAt(0));

    if (!(pwzTokenStart &&
          (wcslen(pwzTokenStart) >= TokenLength) &&
          (_wcsnicmp(pwzTokenStart, strUserToken, TokenLength) == 0)))
    {
      return TRUE;
    }
  }

  return TRUE;
}



// Helper for MailAttr function.  Reads the samAccountName attribute of the
// given object.  Returns the value of the attribute on success, or an empty
// string on failure.
// 
// iDirObj - in, instance of IDirectoryObject that already "pointing to" the
// user object for which the attribute should be read.

CStrW
GetSamAccountName(IDirectoryObject* iDirObj)
{
   dspAssert(iDirObj);

   // no need to refcount the IDirectoryObject pointer because our copy of
   // it is within the lifetime of the MailAttr function.

   CStrW result;
   PADS_ATTR_INFO pAttrs = 0;

   do
   {
      if (!iDirObj)
      {
         dspDebugOut((DEB_ERROR, "GetSamAccountName given null iDirObj\n"));
         break;
      }
      
      // this stolen from uacct.cxx: CDsUsrProfilePage::OnInitDialog, mostly
   
      static const PWSTR wzSAMname = L"sAMAccountName";

      PWSTR rgpwzAttrNames[] = {wzSAMname};

      DWORD cAttrs = 0;
      
      HRESULT hr =
         iDirObj->GetObjectAttributes(
            rgpwzAttrNames,
            ARRAYLENGTH(rgpwzAttrNames),
            &pAttrs,
            &cAttrs);
      if (FAILED(hr))
      {
         dspDebugOut((
            DEB_ERROR,
            "GetSamAccountName: can't read attr %08x\n",
            hr));         
         break;
      }

      for (DWORD i = 0; i < cAttrs; ++i)
      {
         if (_wcsicmp(pAttrs[i].pszAttrName, wzSAMname) == 0)
         {
            result = pAttrs[i].pADsValues->CaseIgnoreString;
            break;
         }
      }
   }
   while (0);

   if (pAttrs)
   {
      FreeADsMem(pAttrs);
   }
   
   return result;
}



void
MassageEmailAddress(CDsPropPageBase* pPage, PATTR_MAP pAttrMap)
{
   dspAssert(pPage);
   dspAssert(pAttrMap);   
   
   // No reason to attempt to massage and email address for a contact.
   // They don't have a samAccountName to replace the %username%

   if (_wcsicmp(pPage->GetObjClass(), g_wzContact) == 0)
   {
      return;
   }

   int cch = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                 WM_GETTEXTLENGTH, 0, 0);

   cch++;
   PWSTR pwz = new WCHAR[cch];
   CHECK_NULL_REPORT(pwz, pPage->GetHWnd(), return);

   GetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pwz, cch);

   if (pwz)
   {
      // look for a %username% token in the value. If present, replace
      // it with the sam account name.
      // NTRAID#NTBUG9-346862-2001/05/14-sburns

      CStrW strUserToken;
      strUserToken.LoadString(g_hInstance, IDS_PROFILE_USER_TOKEN);

      PWSTR pwzTokenStart = wcschr(pwz, strUserToken.GetAt(0));
    
      if (pwzTokenStart)
      {
        // check to make sure the full token is there. A single % can cause problems

        if (_wcsnicmp(pwzTokenStart, strUserToken, strUserToken.GetLength()) == 0)
        {
          CStrW samName = GetSamAccountName(pPage->m_pDsObj);

          if (!samName.IsEmpty())
          {
            BOOL fExpanded = FALSE;
            ExpandUsername(pwz, samName, fExpanded, strUserToken);

            // update the UI with the new value.
          
            SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pwz);
          }
        }
      }

      delete[] pwz;
   }
}

   
   
//+----------------------------------------------------------------------------
//
//  Function:   MailAttr
//
//  Synopsis:   Handles the mail edit control.
//
//  Notes:      Manages inter-page communications/attribute syncronization of
//              the mail attribute.
//
//-----------------------------------------------------------------------------
HRESULT
MailAttr(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
         LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp)
{
  PWSTR pwz = NULL;
  dspAssert(pAttrData);
  int cch;

  switch (DlgOp)
  {
    case fInit:
      if (pAttrInfo && pAttrInfo->pADsValues && pAttrInfo->pADsValues->CaseIgnoreString)
      {
        SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID,
                       pAttrInfo->pADsValues->CaseIgnoreString);
      }
      if (!PATTR_DATA_IS_WRITABLE(pAttrData))
      {
        EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
      }

      SendDlgItemMessage(
         pPage->GetHWnd(), 
         pAttrMap->nCtrlID,
         EM_LIMITTEXT,
         pAttrMap->nSizeLimit,
         0);

      break;

    case fOnCommand:
      if (EN_CHANGE == lParam)
      {
        pPage->SetDirty();
        PATTR_DATA_SET_DIRTY(pAttrData);
      }
      break;

    case fApply:
      if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
      {
        return ADM_S_SKIP;
      }

      MassageEmailAddress(pPage, pAttrMap);
      
      SendMessage(GetParent(pPage->GetHWnd()), PSM_QUERYSIBLINGS,
                  (WPARAM)pAttrMap->AttrInfo.pszAttrName,
                  (LPARAM)pPage->GetHWnd());

      cch = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                    WM_GETTEXTLENGTH, 0, 0);
      if (cch)
      {
        cch++;
        pwz = new WCHAR[cch];
        CHECK_NULL_REPORT(pwz, pPage->GetHWnd(), return E_OUTOFMEMORY);

        GetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pwz, cch);
      }
      if (pwz)
      {
        if (!FValidSMTPAddress(pwz))
        {
          ErrMsg(IDS_INVALID_MAIL_ADDR, pPage->GetHWnd());
          delete [] pwz;
          return E_FAIL;
        }
        PADSVALUE pADsValue;
        pADsValue = new ADSVALUE;
        CHECK_NULL(pADsValue, return E_OUTOFMEMORY);

        pAttrInfo->pADsValues = pADsValue;
        pAttrInfo->dwNumValues = 1;
        pAttrInfo->dwControlCode = ADS_ATTR_UPDATE;
        pADsValue->dwType = pAttrInfo->dwADsType;
        pADsValue->CaseIgnoreString = pwz;
      }
      else
      {
        pAttrInfo->pADsValues = NULL;
        pAttrInfo->dwNumValues = 0;
        pAttrInfo->dwControlCode = ADS_ATTR_CLEAR;
      }
      break;

    case fOnSetActive:
      dspDebugOut((DEB_ITRACE,
                  "(HWND: %08x) got PSN_SETACTIVE, sending PSM_QUERYSIBLINGS.\n",
                  pPage->GetHWnd()));
      SendMessage(GetParent(pPage->GetHWnd()), PSM_QUERYSIBLINGS,
                  (WPARAM)pAttrMap->AttrInfo.pszAttrName,
                  (LPARAM)pPage->GetHWnd());
      break;

    case fOnKillActive:
      //
      // Validate the entry if the focus is lost.
      //
      if (!PATTR_DATA_IS_WRITABLE(pAttrData) || !PATTR_DATA_IS_DIRTY(pAttrData))
      {
        return ADM_S_SKIP;
      }

      MassageEmailAddress(pPage, pAttrMap);
            
      cch = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                    WM_GETTEXTLENGTH, 0, 0);
      if (cch)
      {
        cch++;
        pwz = new WCHAR[cch];
        CHECK_NULL_REPORT(pwz, pPage->GetHWnd(), return E_OUTOFMEMORY);

        GetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, pwz, cch);
      }
      if (pwz)
      {
        if (!FValidSMTPAddress(pwz))
        {
          ErrMsg(IDS_INVALID_MAIL_ADDR, pPage->GetHWnd());
          delete [] pwz;
          SetFocus(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID));
          return PSNRET_INVALID_NOCHANGEPAGE;
        }
        else
        {
          delete [] pwz;
        }
      }
      break;

    case fQuerySibling:
      //
      // lParam == the HWND of the sending window.
      // pAttrInfo == the name of the attribute whose status is sought.
      //
  #if DBG == 1
      char szBuf[100];
      strcpy(szBuf, "(HWND: %08x) got PSM_QUERYSIBLINGS for '%ws'");
  #endif
      if ((HWND)lParam != pPage->GetHWnd())
      {
        if (PATTR_DATA_IS_DIRTY(pAttrData) && pAttrInfo &&
            _wcsicmp((PWSTR)pAttrInfo, pAttrMap->AttrInfo.pszAttrName) == 0)
        {
  #if DBG == 1
          strcat(szBuf, " sending DSPROP_ATTRCHANGED_MSG");
  #endif
          ADS_ATTR_INFO Attr;
          ADSVALUE ADsValue;

          cch = (int)SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID,
                                        WM_GETTEXTLENGTH, 0, 0);
          pwz = new WCHAR[++cch];
          CHECK_NULL_REPORT(pwz, pPage->GetHWnd(), return E_OUTOFMEMORY);

          Attr.dwNumValues = 1;
          Attr.pszAttrName = pAttrMap->AttrInfo.pszAttrName;
          Attr.pADsValues = &ADsValue;
          Attr.pADsValues->dwType = pAttrMap->AttrInfo.dwADsType;
          Attr.pADsValues->CaseIgnoreString = pwz;

          GetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID,
                         Attr.pADsValues->CaseIgnoreString, cch);

          SendMessage((HWND)lParam, g_uChangeMsg, (WPARAM)&Attr, 0);

          delete[] pwz;
        }
      }
  #if DBG == 1
      else
      {
        strcat(szBuf, " (it was sent by this page!)");
      }
      strcat(szBuf, "\n");
      dspDebugOut((DEB_ITRACE, szBuf, pPage->GetHWnd(), pAttrInfo));
  #endif
        break;

    case fAttrChange:
      //
      // pAttrInfo == the PADS_ATTR_INFO struct for the changed attribute.
      //
      dspAssert(pAttrInfo && pAttrInfo->pszAttrName && pAttrInfo->pADsValues &&
                pAttrInfo->pADsValues->CaseIgnoreString);
      dspDebugOut((DEB_ITRACE,
                   "(HWND: %08x) got DSPROP_ATTRCHANGED_MSG for '%ws'.\n",
                   pPage->GetHWnd(), pAttrInfo->pszAttrName));
      if (_wcsicmp(pAttrInfo->pszAttrName, pAttrMap->AttrInfo.pszAttrName) == 0)
      {
        SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID,
                       pAttrInfo->pADsValues->CaseIgnoreString);
      }
      break;

    case fOnDestroy:
      break;
  }

  return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   ManagerChangeBtn
//
//  Synopsis:   Handles the User Organization page change manager button.
//
//-----------------------------------------------------------------------------
HRESULT
ManagerChangeBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
                 PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
                 DLG_OP DlgOp)
{
    if (DlgOp == fInit)
    {
        PATTR_DATA pad = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData);
        dspAssert(pad);
        if (!PATTR_DATA_IS_WRITABLE(pad))
        {
          EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID), FALSE);
        }
        return S_OK;
    }
    if (!(DlgOp == fOnCommand && lParam == BN_CLICKED))
    {
        return S_OK;
    }
    HRESULT hr = S_OK;
    PWSTR cleanstr, canonical;
    CWaitCursor WaitCursor;
    IDsObjectPicker * pObjSel;
    BOOL fIsObjSelInited;

    hr = pPage->GetObjSel(&pObjSel, &fIsObjSelInited);

    CHECK_HRESULT(hr, return hr);

    if (!fIsObjSelInited)
    {
        CStrW cstrDC;
        CComPtr<IDirectoryObject> spDsObj;
        if (pPage->m_pDsObj == NULL)
        {
          //
          // For the retrieval of the DS Object names
          //
          FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
          STGMEDIUM objMedium;
          hr = pPage->m_pWPTDataObj->GetData(&fmte, &objMedium);
          CHECK_HRESULT(hr, return hr);

          LPDSOBJECTNAMES pDsObjectNames = (LPDSOBJECTNAMES)objMedium.hGlobal;

          //
          // Get the objects path 
          //
          LPWSTR pwzObjADsPath = (PWSTR)ByteOffset(pDsObjectNames,
                                                   pDsObjectNames->aObjects[0].offsetName);

          //
          // Bind to the object
          //
          hr = DSAdminOpenObject(pwzObjADsPath,  
                                 IID_IDirectoryObject, 
                                 (PVOID*)&spDsObj);
          ReleaseStgMedium(&objMedium);
          CHECK_HRESULT(hr, return hr);
        }
        else
        {
          spDsObj = pPage->m_pDsObj;
        }
        hr = GetLdapServerName(spDsObj, cstrDC);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        DSOP_SCOPE_INIT_INFO rgScopes[3];
        DSOP_INIT_INFO InitInfo;

        ZeroMemory(rgScopes, sizeof(rgScopes));
        ZeroMemory(&InitInfo, sizeof(InitInfo));

        rgScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
        rgScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
        rgScopes[0].pwzDcName = cstrDC;
        rgScopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS |
                                                      DSOP_FILTER_CONTACTS;

        rgScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[1].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
        rgScopes[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS |
                                                      DSOP_FILTER_CONTACTS;

        rgScopes[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        rgScopes[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
        rgScopes[2].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS |
                                                      DSOP_FILTER_CONTACTS;

        InitInfo.cbSize = sizeof(DSOP_INIT_INFO);
        InitInfo.cDsScopeInfos = 3;
        InitInfo.aDsScopeInfos = rgScopes;
        InitInfo.pwzTargetComputer = cstrDC;

        hr = pObjSel->Initialize(&InitInfo);

        CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

        pPage->ObjSelInited();
    }

    IDataObject * pdoSelections = NULL;

    hr = pObjSel->InvokeDialog(pPage->GetHWnd(), &pdoSelections);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    if (hr == S_FALSE || !pdoSelections)
    {
        return S_OK;
    }

    FORMATETC fmte = {g_cfDsSelList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
	STGMEDIUM medium = {TYMED_NULL, NULL, NULL};

    hr = pdoSelections->GetData(&fmte, &medium);

    CHECK_HRESULT_REPORT(hr, pPage->GetHWnd(), return hr);

    PDS_SELECTION_LIST pSelList = (PDS_SELECTION_LIST)GlobalLock(medium.hGlobal);

    if (!pSelList || !pSelList->cItems || !pSelList->aDsSelection->pwzADsPath)
    {
        ReleaseStgMedium(&medium);
        return S_OK;
    }

    WaitCursor.SetWait();

    hr = pPage->SkipPrefix(pSelList->aDsSelection->pwzADsPath, &cleanstr);

    GlobalUnlock(medium.hGlobal);
    ReleaseStgMedium(&medium);
    pdoSelections->Release();

    if (FAILED(hr))
    {
        return hr;
    }

    PATTR_DATA pData = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData);
    if (pData != NULL)
    {
      PVOID pVoid = reinterpret_cast<PVOID>(pData->pVoid);
      if (pVoid != NULL)
      {
        DO_DEL(pVoid);
      }
      pData->pVoid = reinterpret_cast<LPARAM>(cleanstr);
    }

    hr = CrackName(cleanstr, &canonical, GET_OBJ_CAN_NAME_EX, pPage->GetHWnd());

    if (FAILED(hr))
    {
        return hr;
    }

    CStr name;
    CStr folder;

    GetNameParts(canonical, folder, name);

    SetDlgItemText(pPage->GetHWnd(), IDC_MANAGER_EDIT, (LPCWSTR)name);

    EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_PROPPAGE_BTN), TRUE);
    EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_MGR_CLEAR_BTN), TRUE);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   MgrPropBtn
//
//  Synopsis:   Handles the User Organisation page Manager Properties button.
//
//-----------------------------------------------------------------------------
HRESULT
MgrPropBtn(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
           PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
           DLG_OP DlgOp)
{
    PATTR_DATA pad = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData);
    PWSTR pwzManager = NULL;
    if (pad)
    {
        pwzManager = (PWSTR)pad->pVoid;
    }

    if (DlgOp == fInit)
    {
        dspAssert(pad);
        EnableWindow(GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID),
                     pwzManager != NULL);
        return S_OK;
    }
    if (!(DlgOp == fOnCommand && lParam == BN_CLICKED))
    {
        return S_OK;
    }

    dspAssert(pwzManager);

    return PostPropSheet(pwzManager, pPage);
}

//+----------------------------------------------------------------------------
//
//  Function:   ClearMgrBtn
//
//  Synopsis:   Handles the User Organisation page Clear Manager button.
//
//-----------------------------------------------------------------------------
HRESULT
ClearMgrBtn(CDsPropPageBase * pPage, PATTR_MAP,
            PADS_ATTR_INFO, LPARAM lParam, PATTR_DATA,
            DLG_OP DlgOp)
{
    PATTR_DATA pad = reinterpret_cast<PATTR_DATA>(((CDsTableDrivenPage *)pPage)->m_pData);
    PWSTR pwzManager = NULL;
    if (pad)
    {
        pwzManager = (PWSTR)pad->pVoid;
    }

    if (DlgOp == fInit)
    {
        dspAssert(pad);
        if ( pad )
        {
            EnableWindow(
                            GetDlgItem(pPage->GetHWnd(), IDC_MGR_CLEAR_BTN),
                            (pwzManager != NULL) && PATTR_DATA_IS_WRITABLE(pad)
                         );
        }
        return S_OK;
    }
    if (!(DlgOp == fOnCommand && lParam == BN_CLICKED))
    {
        return S_OK;
    }

    dspAssert(pwzManager);

    SetDlgItemText(pPage->GetHWnd(), IDC_MANAGER_EDIT, TEXT(""));

    if (pad)
    {
        PVOID pVoid = reinterpret_cast<PVOID>(pad->pVoid);
        if (pVoid != NULL)
        {
            DO_DEL(pVoid);
        }
        pad->pVoid = NULL;
    }

    // NTRAID#NTBUG9-498174-2001/11/28-JeffJon
    // Set the focus to the Add button because when we disable the 
    // clear button we break keyboard navigation
    HWND hwndSheet = GetParent(pPage->GetHWnd());
    HWND hwndAddBtn = GetDlgItem(pPage->GetHWnd(), IDC_MGR_CHANGE_BTN);

    ::SetFocus(GetDlgItem(pPage->GetHWnd(), IDC_MGR_CHANGE_BTN));
    
    // Make the add button the default
    ::PostMessage(hwndSheet, DM_SETDEFID, (WPARAM)IDC_MGR_CHANGE_BTN, 0);
    ::PostMessage(hwndAddBtn,
                  BM_SETSTYLE,
                  BS_DEFPUSHBUTTON,
                  MAKELPARAM(TRUE, 0));

    // Change the clear button back to normal
    ::PostMessage(GetDlgItem(pPage->GetHWnd(), IDC_MGR_CLEAR_BTN),
                  BM_SETSTYLE,
                  BS_PUSHBUTTON,
                  MAKELPARAM(TRUE, 0));


    EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_PROPPAGE_BTN), FALSE);
    EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_MGR_CLEAR_BTN), FALSE);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   AddReportsBtn
//
//  Synopsis:   Handles the User Organisation page Add Direct Reports button.
//
//-----------------------------------------------------------------------------
HRESULT
AddReportsBtn(CDsPropPageBase * pPage, PATTR_MAP,
              PADS_ATTR_INFO, LPARAM, PATTR_DATA,
              DLG_OP DlgOp)
{
    if (DlgOp == fInit)
    {
        EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_ADD_BTN), FALSE);
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   RmReportsBtn
//
//  Synopsis:   Handles the User Organisation page Remove Direct Reports button.
//
//-----------------------------------------------------------------------------
HRESULT
RmReportsBtn(CDsPropPageBase * pPage, PATTR_MAP,
             PADS_ATTR_INFO, LPARAM, PATTR_DATA,
             DLG_OP DlgOp)
{
    if (DlgOp == fInit)
    {
        EnableWindow(GetDlgItem(pPage->GetHWnd(), IDC_REMOVE_BTN), FALSE);
    }
    return S_OK;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\usercert.h ===
//+----------------------------------------------------------------------------
//
//  Class:      CDsUserCertPage
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       UserCert.h
//
//  Contents:   DS user object property pages header
//
//  Classes:    CDsUserCertPage
//
//  History:    12-November-97 BryanWal created
//
//-----------------------------------------------------------------------------

#ifndef _USERCERT_H_
#define _USERCERT_H_
#include "proppage.h"
#include <wincrypt.h>
#include <cryptui.h>
#include "certifct.h"

enum {
    CERTCOL_ISSUED_TO = 0,
    CERTCOL_ISSUED_BY,
    CERTCOL_PURPOSES,
    CERTCOL_EXP_DATE
};

HRESULT CreateUserCertPage(PDSPAGE, LPDATAOBJECT, PWSTR,
                           PWSTR, HWND, DWORD, 
                           const CDSSmartBasePathsInfo& basePathsInfo,
                           HPROPSHEETPAGE *);
//
//  Purpose:    property page object class for the User Certificates page.
//
//-----------------------------------------------------------------------------
class CDsUserCertPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsUserCertPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                    DWORD dwFlags);
    virtual ~CDsUserCertPage(void);

    //
    //  Instance specific wind proc
    //
    INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    CRYPTUI_SELECTCERTIFICATE_STRUCT m_selCertStruct;
    HBITMAP     m_hbmCert;
    HIMAGELIST  m_hImageList;
    int         m_nCertImageIndex;
    int         m_nUserCerts;
    bool        m_fUserStoreInitiallyEmpty;
    HRESULT AddListViewColumns ();
    HCERTSTORE m_hCertStore;
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnDestroy(void);

protected:
    int MessageBox (int caption, int text, UINT flags);
    HRESULT AddCertToStore (PCCERT_CONTEXT pCertContext);
    void OnNotifyItemChanged (LPNMLISTVIEW pnmv);
    void OnNotifyStateChanged (LPNMLVODSTATECHANGE pStateChange);
    void EnableControls ();
    void DisplaySystemError (DWORD dwErr, int iCaptionText);
    HRESULT InsertCertInList (CCertificate* pCert, int nItem);
    void RefreshItemInList (CCertificate * pCert, int nItem);
    CCertificate* GetSelectedCertificate (int& nSelItem);
    HRESULT PopulateListView ();
    virtual LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    HRESULT OnDeleteItemCertList (LPNMLISTVIEW pNMListView);
    HRESULT OnColumnClickCertList (LPNMLISTVIEW pNMListView);
    HRESULT OnDblClkCertList (LPNMHDR pNMHdr);
    HRESULT OnClickedCopyToFile ();
    HRESULT OnClickedRemove();
    HRESULT OnClickedAddFromFile();
    HRESULT OnClickedAddFromStore ();
    HRESULT OnClickedViewCert ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\usercert.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       UserCert.cxx
//
//  Contents:   
//
//  History:    12-November-97 BryanWal created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "commdlg.h"
#include "UserCert.h"
#include "pages.h"
#include "proppage.h"
#include "crtdbg.h"
#include "certifct.h"

#ifdef DSADMIN

CStrW GetSystemMessage (DWORD dwErr)
{
    CStrW message;

    LPVOID lpMsgBuf = NULL;
        
    // security review 2/26/2002 BryanWal ok - message is from system
    ::FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,    
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
             (LPWSTR) &lpMsgBuf,    0,    NULL );
    message = (LPWSTR) lpMsgBuf;

    // Free the buffer.
    LocalFree (lpMsgBuf);

    return message;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsUserCertPage::CDsUserCertPage
//
//-----------------------------------------------------------------------------
CDsUserCertPage::CDsUserCertPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                                 HWND hNotifyObj, DWORD dwFlags) 
    : CDsPropPageBase(pDsPage, pDataObj, hNotifyObj, dwFlags),
    m_hCertStore (0),
    m_hImageList (0),
    m_hbmCert (0),
    m_nCertImageIndex (0),
    m_nUserCerts (0),
    m_fUserStoreInitiallyEmpty (false)
{
    TRACE(CDsUserCertPage,CDsUserCertPage);
#ifdef _DEBUG
    strcpy(szClass, "CDsUserCertPage");
#endif

    ::ZeroMemory (&m_selCertStruct, sizeof (m_selCertStruct));
}


//+----------------------------------------------------------------------------
//
//  Member:     CDsUserCertPage::~CDsUserCertPage
//
//-----------------------------------------------------------------------------
CDsUserCertPage::~CDsUserCertPage()
{
    TRACE(CDsUserCertPage,~CDsUserCertPage);

    // Clean up enumerated store list
    for (DWORD dwIndex = 0; dwIndex < m_selCertStruct.cDisplayStores; dwIndex++)
    {
        dspAssert (m_selCertStruct.rghDisplayStores);
        ::CertCloseStore (m_selCertStruct.rghDisplayStores[dwIndex], CERT_CLOSE_STORE_FORCE_FLAG);
    }
    if ( m_selCertStruct.rghDisplayStores )
        delete [] m_selCertStruct.rghDisplayStores;


    if ( m_hbmCert )
        DeleteObject (m_hbmCert);
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateUserCertPage
//
//  Synopsis:   Creates an instance of a page window.
//
//-----------------------------------------------------------------------------
HRESULT CreateUserCertPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj,
                             PWSTR pwzADsPath, PWSTR pwzClass,
                             HWND hNotifyObj, DWORD dwFlags,
                             const CDSSmartBasePathsInfo& basePathsInfo,
                             HPROPSHEETPAGE *phPage)
{
    TRACE_FUNCTION(CreateUserCertPage);

    CDsUserCertPage * pPageObj = new CDsUserCertPage(pDsPage, pDataObj,
                                                     hNotifyObj, dwFlags);
    CHECK_NULL(pPageObj, return E_OUTOFMEMORY);

    pPageObj->Init(pwzADsPath, pwzClass, basePathsInfo);

    return pPageObj->CreatePage(phPage);
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPageBase::DlgProc
//
//  Synopsis:   per-instance dialog proc
//
//-----------------------------------------------------------------------------
INT_PTR CALLBACK
CDsUserCertPage::DlgProc(HWND /*hDlg*/, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return InitDlg(lParam);

    case WM_NOTIFY:
        return OnNotify(wParam, lParam);

    case WM_SHOWWINDOW:
        return OnShowWindow();

    case WM_SETFOCUS:
        return OnSetFocus((HWND)wParam);

    case WM_HELP:
        return OnHelp((LPHELPINFO)lParam);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                         GET_WM_COMMAND_HWND(wParam, lParam),
                         GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}


typedef struct _ENUM_ARG {
    DWORD               dwFlags;
    DWORD*              pcDisplayStores;          
    HCERTSTORE **       prghDisplayStores;        
} ENUM_ARG, *PENUM_ARG;

static BOOL WINAPI EnumStoresSysCallback(
    IN const void* pwszSystemStore,
    IN DWORD /*dwFlags*/,
    IN PCERT_SYSTEM_STORE_INFO /*pStoreInfo*/,
    IN OPTIONAL void * /*pvReserved*/,
    IN OPTIONAL void *pvArg
    )
{
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
    void*       pvPara = (void*)pwszSystemStore;



    HCERTSTORE  hNewStore  = ::CertOpenStore (CERT_STORE_PROV_SYSTEM, 
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
                CERT_SYSTEM_STORE_CURRENT_USER, pvPara);
    if ( !hNewStore )
    {
        hNewStore = ::CertOpenStore (CERT_STORE_PROV_SYSTEM, 
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
                CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG, pvPara);
    }
    if ( hNewStore )
    {
        DWORD       dwCnt = *(pEnumArg->pcDisplayStores);
        HCERTSTORE* phStores = 0;

        phStores = new HCERTSTORE[dwCnt+1];
        if ( phStores )
        {
            DWORD   dwIndex = 0;
            if ( *(pEnumArg->prghDisplayStores) )
            {
                for (; dwIndex < dwCnt; dwIndex++)
                {
                    phStores[dwIndex] = (*(pEnumArg->prghDisplayStores))[dwIndex];
                }
                delete [] (*(pEnumArg->prghDisplayStores));
            }
            (*(pEnumArg->pcDisplayStores))++;
            (*(pEnumArg->prghDisplayStores)) = phStores;
            (*(pEnumArg->prghDisplayStores))[dwIndex] = hNewStore;
        }
        else
        {
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    }

    return TRUE;
}



//+----------------------------------------------------------------------------
//
//  Method:     CDsUserCertPage::OnInitDialog
//
//  Synopsis:   Set the initial control values from the corresponding DS
//              attributes.
//
//-----------------------------------------------------------------------------
HRESULT CDsUserCertPage::OnInitDialog(LPARAM /*lParam*/)
{
    TRACE(CDsUserCertPage,OnInitDialog);
    HRESULT hr = S_OK;
    CWaitCursor WaitCursor;
    const   LPWSTR  CERT_PROPERTY_NAME = L"UserCertificate";

    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    // Get the object name and open its Published Certificate store
    LPCWSTR pszObjName = GetObjPathName ();
    dspAssert (pszObjName);
    if ( pszObjName )
    {
        // NTRAID#NTBUG9-706271-2002/09/24-ericb Forward slash in user name causes CertOpenStore failure.
        // This is because the object path returned by GetObjPathName is escaped using
        // ADSI escaping rules. CertOpenStore only requires LDAP escaping and fails on
        // ADSI escaping. Use the IADsPathname interface to remove any ADSI escaping.
        CComPtr<IADsPathname> pADsPath;
        hr = GetADsPathname(pADsPath);
        CHECK_HRESULT_REPORT(hr, GetHWnd(), return hr);
        hr = pADsPath->Set(CComBSTR(pszObjName), ADS_SETTYPE_FULL);
        CHECK_HRESULT_REPORT(hr, GetHWnd(), return hr);
        hr = pADsPath->put_EscapedMode(ADS_ESCAPEDMODE_OFF); // only do LDAP escaping, not ADSI escaping
        CHECK_HRESULT_REPORT(hr, GetHWnd(), return hr);
        CComBSTR bstr;
        hr = pADsPath->Retrieve(ADS_FORMAT_X500, &bstr);
        CStrW strObjName = bstr.m_str;
        strObjName += L"?";
        strObjName += CERT_PROPERTY_NAME;
        dspDebugOut((DEB_ITRACE, "Opening cert store for %ws\n", strObjName.GetBuffer(0)));

        m_hCertStore = ::CertOpenStore (CERT_STORE_PROV_LDAP,
            0, NULL,
            0,
            (void*) strObjName.GetBuffer(0));
        if ( !m_hCertStore )
        {
            DWORD dwErr = GetLastError ();
            hr = HRESULT_FROM_WIN32 (dwErr);
            if ( ERROR_ACCESS_DENIED == dwErr )
            {
                MessageBox (IDS_USER_TITLE_PUBLISHED_CERTS, IDS_CANT_OPEN_STORE_OPEN_READ_ONLY,
                        MB_ICONINFORMATION | MB_OK);
                
                m_hCertStore = ::CertOpenStore (CERT_STORE_PROV_LDAP,
                    0, NULL,
                    CERT_STORE_READONLY_FLAG,
                    (void*) strObjName.GetBuffer(0));
                if ( m_hCertStore )
                {
                    dwErr = 0;
                    hr = S_OK;
                    ::EnableWindow (GetDlgItem (GetHWnd (), IDC_ADD_FROM_STORE), FALSE);
                    ::EnableWindow (GetDlgItem (GetHWnd (), IDC_ADD_FROM_FILE), FALSE);
                }
                else
                {
                    dwErr = GetLastError ();
                    hr = HRESULT_FROM_WIN32 (dwErr);
                }
            }

            if ( FAILED (hr) )
            {
                DisplaySystemError (dwErr, IDS_CANT_OPEN_STORE);
                ::EnableWindow (GetDlgItem (GetHWnd (), IDC_ADD_FROM_STORE), FALSE);
                ::EnableWindow (GetDlgItem (GetHWnd (), IDC_ADD_FROM_FILE), FALSE);
            }
        }
    }

    // Set up result list view
    COLORREF    crMask = RGB (255, 0, 255);
    m_hImageList = ImageList_Create (16, 16, ILC_MASK, 10, 10);
    dspAssert (m_hImageList);
    if ( m_hImageList )
    {
        m_hbmCert = ::LoadBitmap (g_hInstance, MAKEINTRESOURCE (IDB_CERTIFICATE));
        dspAssert (m_hbmCert);
        if ( m_hbmCert )
        {
            m_nCertImageIndex = ImageList_AddMasked (m_hImageList, m_hbmCert,
                    crMask);
            dspAssert (m_nCertImageIndex != -1);
            if ( m_nCertImageIndex != -1 )
            {
                ListView_SetImageList (::GetDlgItem (GetHWnd (), IDC_CERT_LIST),
                        m_hImageList, LVSIL_SMALL);     
            }
        }
    }


    hr = AddListViewColumns ();
    if ( SUCCEEDED  (hr) && m_hCertStore )
        hr = PopulateListView ();

    EnableControls ();

    // Enumerate User's certificate stores for use in selecting certificates
    // from stores.
    ENUM_ARG    EnumArg;

    m_selCertStruct.dwSize = sizeof (CRYPTUI_SELECTCERTIFICATE_STRUCT);
    m_selCertStruct.hwndParent = GetHWnd ();
    EnumArg.pcDisplayStores = &m_selCertStruct.cDisplayStores;
    EnumArg.prghDisplayStores = &m_selCertStruct.rghDisplayStores;

    ::CertEnumSystemStore (CERT_SYSTEM_STORE_CURRENT_USER, 0, &EnumArg, 
            EnumStoresSysCallback);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserCertPage::OnApply
//
//  Synopsis:   Handles the Apply notification.
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserCertPage::OnApply(void)
{
    TRACE(CDsUserCertPage,OnApply);
    HRESULT hr = S_OK;
    CWaitCursor WaitCursor;

    // NTRAID#NTBUG9-541102-2002/08/01-ericb Adding, removing, then applying causes error.
    dspAssert(m_nUserCerts > -1);
    if (m_nUserCerts < 1 && m_fUserStoreInitiallyEmpty)
    {
        return PSNRET_NOERROR;
    }

    if ( m_hCertStore )
    {
        BOOL bResult = ::CertControlStore (m_hCertStore, CERT_STORE_CTRL_COMMIT_FORCE_FLAG, 
                CERT_STORE_CTRL_COMMIT, NULL);
        if ( !bResult )
        {
            DWORD   dwErr = GetLastError ();
            dspAssert (dwErr == ERROR_NOT_SUPPORTED);
            if ( dwErr != ERROR_NOT_SUPPORTED )
            {
                hr = E_FAIL;
                LPWSTR  pszCaption = 0;
                CStrW   strMsg;

                strMsg.FormatMessage(g_hInstance, IDS_CANT_SAVE_STORE, GetSystemMessage (dwErr));

                if ( LoadStringToTchar (IDS_USER_TITLE_PUBLISHED_CERTS, &pszCaption) )
                {
                    ::MessageBox (GetHWnd (), strMsg, pszCaption, MB_ICONINFORMATION | MB_OK);
                }
                else
                    hr = E_OUTOFMEMORY;

                if ( pszCaption )
                    delete [] pszCaption;
            }
        }
    }

    m_fUserStoreInitiallyEmpty = (0 == m_nUserCerts);

    return (SUCCEEDED(hr)) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsUserCertPage::OnCommand
//
//  Synopsis:   Handle control notifications.
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserCertPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    switch (codeNotify)
    {
    case BN_CLICKED:
        switch (id)
        {
        case IDC_VIEW_CERT:
            return OnClickedViewCert ();
            break;

        case IDC_ADD_FROM_STORE:
            return OnClickedAddFromStore ();
            break;

        case IDC_ADD_FROM_FILE:
            return OnClickedAddFromFile ();
            break;

        case IDC_REMOVE:
            return OnClickedRemove ();
            break;

        case IDC_COPY_TO_FILE:
            return OnClickedCopyToFile ();
            break;

        default:
            _ASSERT (0);
            return E_UNEXPECTED;
            break;
        }
        break;

    default:
        break;
    }
    return CDsPropPageBase::OnCommand(id, hwndCtl, codeNotify);
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsUserCertPage::OnNotify
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserCertPage::OnNotify(WPARAM wParam, LPARAM lParam)
{
    LPNMHDR pNMHdr = (LPNMHDR) lParam;
    _ASSERT (pNMHdr);
    if ( !pNMHdr )
        return E_POINTER;

    switch (pNMHdr->code)
    {
    case NM_DBLCLK:
        if (m_fInInit)
            return TRUE;
        else if ( wParam == IDC_CERT_LIST )
            return OnDblClkCertList (pNMHdr);
        break;

    case LVN_COLUMNCLICK:
        if (m_fInInit)
            return TRUE;
        else if ( wParam == IDC_CERT_LIST )
            return OnColumnClickCertList ((LPNMLISTVIEW) lParam);
        break;

    case LVN_DELETEALLITEMS:
        if (m_fInInit)
            return TRUE;
        else if ( wParam == IDC_CERT_LIST )
            return FALSE;   // Do not suppress LVN_DELETEITEM messages
        break;

    case LVN_DELETEITEM:
        if (m_fInInit)
            return TRUE;
        else if ( wParam == IDC_CERT_LIST )
            return OnDeleteItemCertList ((LPNMLISTVIEW) lParam);
        break;

    case LVN_ODSTATECHANGED:
        OnNotifyStateChanged ((LPNMLVODSTATECHANGE) lParam);
        return 0;

    case LVN_ITEMCHANGED:
        OnNotifyItemChanged ((LPNMLISTVIEW) lParam); 
        return 0;
 
    default:
        break;
    }

    return CDsPropPageBase::OnNotify(wParam, lParam);
}


//+----------------------------------------------------------------------------
//
//  Method:     CDsUserCertPage::OnDestroy
//
//  Synopsis:   Exit cleanup
//
//-----------------------------------------------------------------------------
LRESULT
CDsUserCertPage::OnDestroy(void)
{
    ListView_DeleteAllItems (::GetDlgItem (GetHWnd (), IDC_CERT_LIST));
    CDsPropPageBase::OnDestroy();

    if ( m_hCertStore )
    {
        // Back out of uncommitted changes before closing the store.
        BOOL    bResult = ::CertControlStore (m_hCertStore, 
            CERT_STORE_CTRL_COMMIT_CLEAR_FLAG, 
            CERT_STORE_CTRL_COMMIT, NULL);
        if ( !bResult )
        {
            DWORD   dwErr = GetLastError ();
            dspAssert (dwErr != ERROR_NOT_SUPPORTED && dwErr != ERROR_CALL_NOT_IMPLEMENTED);
        }
        ::CertCloseStore (m_hCertStore, 0);
        m_hCertStore = 0;
    }

    // If an application processes this message, it should return zero.
    return 0;
}




HRESULT CDsUserCertPage::AddListViewColumns()
{
    // Add list view columns
    LVCOLUMN    lvCol;
    ::ZeroMemory (&lvCol, sizeof (lvCol));
    PTSTR       ptsz = 0;

    if ( !LoadStringToTchar (IDS_CERTCOL_ISSUED_TO, &ptsz) )
    {
        ReportError(GetLastError(), 0, GetHWnd());
        return E_OUTOFMEMORY;
    }
    
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; 
    lvCol.fmt = LVCFMT_LEFT;
    lvCol.cx = 90;
    lvCol.pszText = ptsz;     
    lvCol.iSubItem = CERTCOL_ISSUED_TO; 
    HWND    hWndList = ::GetDlgItem (GetHWnd (), IDC_CERT_LIST);
    int nIndex = ListView_InsertColumn (hWndList, CERTCOL_ISSUED_TO, &lvCol);
    _ASSERT (nIndex != -1);
    delete [] ptsz;
    if ( nIndex == -1 )
        return E_UNEXPECTED;

    if ( !LoadStringToTchar (IDS_CERTCOL_ISSUED_BY, &ptsz) )
    {
        ReportError (GetLastError (), 0, GetHWnd ());
        return E_OUTOFMEMORY;
    }
    lvCol.cx = 90;
    lvCol.pszText = ptsz;     
    lvCol.iSubItem = CERTCOL_ISSUED_BY; 
    nIndex = ListView_InsertColumn (hWndList, IDS_CERTCOL_ISSUED_BY, &lvCol);
    _ASSERT (nIndex != -1);
    delete [] ptsz;
    if ( nIndex == -1 )
        return E_UNEXPECTED;


    if ( !LoadStringToTchar (IDS_CERTCOL_PURPOSES, &ptsz) )
    {
        ReportError (GetLastError (), 0, GetHWnd ());
        return E_OUTOFMEMORY;
    }
    lvCol.cx = 125;
    lvCol.pszText = ptsz;     
    lvCol.iSubItem = CERTCOL_PURPOSES; 
    nIndex = ListView_InsertColumn (hWndList, IDS_CERTCOL_PURPOSES, &lvCol);
    _ASSERT (nIndex != -1);
    delete [] ptsz;
    if ( nIndex == -1 )
        return E_UNEXPECTED;

    if ( !LoadStringToTchar (IDS_CERTCOL_EXP_DATE, &ptsz) )
    {
        ReportError (GetLastError (), 0, GetHWnd ());
        return E_OUTOFMEMORY;
    }
    lvCol.cx = 125;
    lvCol.pszText = ptsz;     
    lvCol.iSubItem = CERTCOL_EXP_DATE; 
    nIndex = ListView_InsertColumn (hWndList, IDS_CERTCOL_EXP_DATE, &lvCol);
    _ASSERT (nIndex != -1);
    delete [] ptsz;
    if ( nIndex == -1 )
        return E_UNEXPECTED;

    return S_OK;
}

HRESULT CDsUserCertPage::OnClickedViewCert()
{
    HRESULT hr = S_OK;
    int             nSelItem = -1;
    CCertificate*   pCert = GetSelectedCertificate (nSelItem);
    if ( pCert )
    {
        CRYPTUI_VIEWCERTIFICATE_STRUCT  vcs;
        HCERTSTORE                      hCertStore = ::CertDuplicateStore (pCert->GetCertStore ());


        ::ZeroMemory (&vcs, sizeof (vcs));
        vcs.dwSize = sizeof (vcs);
        vcs.hwndParent = GetHWnd ();
        vcs.dwFlags = 0;
        vcs.cStores = 1;
        vcs.rghStores = &hCertStore;
        vcs.pCertContext = pCert->GetCertContext ();

        BOOL fPropertiesChanged = FALSE;
        BOOL bResult = ::CryptUIDlgViewCertificate (&vcs, &fPropertiesChanged);
        if ( bResult )
        {
            if ( fPropertiesChanged )
            {
                pCert->Refresh ();
                RefreshItemInList (pCert, nSelItem);
            }
        }
        ::CertCloseStore (hCertStore, 0);
    }
    
    ::SetFocus (::GetDlgItem (GetHWnd (), IDC_CERT_LIST));
    return hr;
}

HRESULT CDsUserCertPage::OnClickedAddFromStore()
{
    HRESULT                             hr = S_OK;

    PCCERT_CONTEXT  pCertContext = ::CryptUIDlgSelectCertificate (&m_selCertStruct);
    if ( pCertContext )
    {
        hr = AddCertToStore (pCertContext);
        SetDirty();
    }
    

    ::SetFocus (::GetDlgItem (GetHWnd (), IDC_CERT_LIST));
    return hr;
}

HRESULT CDsUserCertPage::OnClickedAddFromFile()
{
    HRESULT         hr = S_OK;
    HWND            hwndList = ::GetDlgItem (GetHWnd (), IDC_CERT_LIST);


    PWSTR   pszFilter = 0;
    PWSTR   pszDlgTitle = 0;
    if ( LoadStringToTchar (IDS_CERT_SAVE_FILTER, &pszFilter) &&
            LoadStringToTchar (IDS_OPEN_FILE_DLG_TITLE, &pszDlgTitle) )
    {
        LPWSTR          pszDefExt = _T("cer");
        OPENFILENAME    ofn;
        WCHAR           szFile[MAX_PATH];
        WCHAR           chReplace = pszFilter[wcslen (pszFilter)-1]; // retrieve wild character
        for (int i = 0; pszFilter[i]; i++)
        {
            if ( pszFilter[i] == chReplace )
                pszFilter[i] = 0;
        }


        ::ZeroMemory (szFile, MAX_PATH * sizeof (WCHAR));
        ::ZeroMemory (&ofn, sizeof (ofn));
        ofn.lStructSize = sizeof (OPENFILENAME);     
        ofn.hwndOwner = GetHWnd ();
        ofn.lpstrFilter = pszFilter;
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = MAX_PATH;     
        ofn.lpstrTitle = pszDlgTitle;
        ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST; 
        ofn.lpstrDefExt = pszDefExt;     


        BOOL bResult = GetOpenFileName (&ofn);
        if ( bResult )
        {
            DWORD           dwMsgAndCertEncodingType = 0;
            DWORD           dwContentType = 0;
            DWORD           dwFormatType = 0;
            PCERT_CONTEXT   pCertContext = 0;

            bResult = ::CryptQueryObject (
                    CERT_QUERY_OBJECT_FILE,
                    (void *) ofn.lpstrFile,
                    CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT |
                        CERT_QUERY_CONTENT_FLAG_CERT |
                        CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED | 
                        CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED |  
                        CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
                    CERT_QUERY_FORMAT_FLAG_ALL,
                    0,
                    &dwMsgAndCertEncodingType,
                    &dwContentType,
                    &dwFormatType,
                    NULL,
                    NULL,
                    (const void **) &pCertContext);
            if ( bResult && pCertContext )
            {       
                hr = AddCertToStore (pCertContext);
//              ::CertFreeCertificateContext (pCertContext);
                SetDirty();
            }
            else
            {
                LPWSTR  pszCaption = 0;
                LPWSTR  pszMsg = 0;

                if ( LoadStringToTchar (IDS_OPEN_FILE_DLG_TITLE, &pszCaption) &&
                        LoadStringToTchar (IDS_UNKNOWN_CERT_FILE_TYPE, &pszMsg) )
                {
                    ::MessageBox (GetHWnd (), pszMsg, pszCaption, MB_ICONWARNING | MB_OK);
                }
                else
                    hr = E_OUTOFMEMORY;

                if ( pszCaption )
                    delete [] pszCaption;

                if ( pszMsg )
                    delete [] pszMsg;
            }
        }
    }

    if ( pszFilter )
        delete [] pszFilter;
    if ( pszDlgTitle )
        delete [] pszDlgTitle;

    ::SetFocus (hwndList);
    return hr;
}

HRESULT CDsUserCertPage::OnClickedRemove()
{
    HRESULT         hr = S_OK;
    int             nSelItem = -1;
    HWND            hwndList = ::GetDlgItem (GetHWnd (), IDC_CERT_LIST);
    bool            bConfirmationRequested = false;
    int             iResult = 0;
    int             nSelCnt = ListView_GetSelectedCount (hwndList);

    if ( nSelCnt < 1 )
        return E_FAIL;

    while (1)
    {
        CCertificate*   pCert = GetSelectedCertificate (nSelItem);
        if ( pCert )
        {
            if ( !bConfirmationRequested )
            {
                LPWSTR  pszCaption = 0;
                LPWSTR  pszText = 0;
                int     textId = 0;

                if ( 1 == nSelCnt )
                    textId = IDS_CONFIRM_DELETE_CERT;
                else
                    textId = IDS_CONFIRM_DELETE_CERTS;

                if ( LoadStringToTchar (textId, &pszText) &&
                        LoadStringToTchar (IDS_REMOVE_CERT, &pszCaption) )
                {
                    iResult = ::MessageBox (GetHWnd (), pszText, pszCaption,
                            MB_YESNO);
                }
                if ( pszCaption )
                    delete [] pszCaption;
                if ( pszText )
                    delete [] pszText;
                bConfirmationRequested = true;
                if ( IDYES != iResult )
                    break;
            }

            BOOL bResult = pCert->DeleteFromStore ();
            dspAssert (bResult);
            if ( bResult )
            {
                // NTRAID#NTBUG9-541102-2002/08/01-ericb Adding, removing, then applying causes error.
                m_nUserCerts--;

                bResult = ListView_DeleteItem (
                        hwndList, 
                        nSelItem);
                dspAssert (bResult);
                if ( bResult )
                    SetDirty ();
                else
                    hr = E_FAIL;
            }
            else
            {
                DWORD dwErr = GetLastError ();
                DisplaySystemError (dwErr, IDS_REMOVE_CERT);
                hr = HRESULT_FROM_WIN32 (dwErr);
                break;
            }
        }
        else
            break;
    }

    ::SetFocus (hwndList);
    EnableControls ();

    return hr;
}

HRESULT CDsUserCertPage::OnClickedCopyToFile()
{
    HRESULT         hr = S_OK;

    PWSTR   pszFilter = 0;
    PWSTR   pszDlgTitle = 0;
    if ( LoadStringToTchar (IDS_CERT_SAVE_FILTER, &pszFilter) &&
            LoadStringToTchar (IDS_SAVE_FILE_DLG_TITLE, &pszDlgTitle) )
    {
        LPWSTR          pszDefExt = _T("cer");
        OPENFILENAME    ofn;
        WCHAR           szFile[MAX_PATH];
        WCHAR           chReplace = pszFilter[wcslen (pszFilter)-1]; // retrieve wild character
        for (int i = 0; pszFilter[i]; i++)
        {
            if ( pszFilter[i] == chReplace )
                pszFilter[i] = 0;
        }


        ::ZeroMemory (szFile, MAX_PATH * sizeof (WCHAR));
        ::ZeroMemory (&ofn, sizeof (ofn));
        ofn.lStructSize = sizeof (OPENFILENAME);     
        ofn.hwndOwner = GetHWnd ();
        ofn.lpstrFilter = pszFilter;
        ofn.lpstrFile = szFile;
        ofn.nMaxFile = MAX_PATH;     
        ofn.lpstrTitle = pszDlgTitle;
        ofn.Flags = OFN_PATHMUSTEXIST | OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY; 
        ofn.lpstrDefExt = pszDefExt;     

        BOOL bResult = ::GetSaveFileName (&ofn);
        //NTRAID#NTBUG9-572003-2002/03/10-jmessec    GetSaveFileName may fail due to an internal error (versus user cancellation); error is
        //silently ignored and processing stopped, possibly causing fear and confusion on the part of the user
        if ( bResult )
        {
            if ( wcsstr (_wcsupr (ofn.lpstrFile), _T(".CER")) )
            {
                HANDLE hFile = ::CreateFile (ofn.lpstrFile, // pointer to name of the file
                      GENERIC_READ | GENERIC_WRITE,         // access (read-write) mode
                      0,                                    // share mode
                      NULL,                                 // pointer to security attributes
                      CREATE_ALWAYS,                        // how to create
                      FILE_ATTRIBUTE_NORMAL,                // file attributes
                      NULL);                                // handle to file with attributes to copy
                dspAssert (hFile != INVALID_HANDLE_VALUE);
                if ( hFile != INVALID_HANDLE_VALUE )
                {
                    int iSelItem = -1;

                    CCertificate* pCert = GetSelectedCertificate (iSelItem);
                    dspAssert (pCert);
                    if ( pCert )
                    {
                        // To cer file -> put out encoded blob
                        // pbEncodedCert
                        hr = pCert->WriteToFile (hFile);
                        if ( !SUCCEEDED (hr) )
                            DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
                    }

                    if ( !CloseHandle (hFile) )
                    {
                        dspAssert (0);
                        DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
                    }
                }
                else
                    DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
            }
            else
            {
                void* pvSaveToPara = (void*) ofn.lpstrFile;

                HCERTSTORE hCertStore = ::CertOpenStore (CERT_STORE_PROV_MEMORY, 
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
                        CERT_FILE_STORE_COMMIT_ENABLE_FLAG, 0);
                if ( hCertStore )
                {
                    int iSelItem = -1;

                    CCertificate* pCert = GetSelectedCertificate (iSelItem);
                    dspAssert (pCert);
                    if ( pCert )
                    {
                        bResult = ::CertAddCertificateContextToStore (
                                hCertStore,
                                ::CertDuplicateCertificateContext (pCert->GetCertContext ()),
                                CERT_STORE_ADD_ALWAYS,
                                NULL);
                        dspAssert (bResult);
                        if ( bResult )
                        {
                            bResult = ::CertSaveStore (
                                    hCertStore,
                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                    CERT_STORE_SAVE_AS_PKCS7,
                                    CERT_STORE_SAVE_TO_FILENAME,
                                    pvSaveToPara,
                                    0);
                            dspAssert (bResult);
                            if ( !bResult )
                                DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
                        }
                        else
                            DisplaySystemError (GetLastError (), IDS_COPY_TO_FILE);
                    }
                    ::CertCloseStore (hCertStore, 0);
                }
            }
        }
    }
    else
        hr = E_OUTOFMEMORY;

    if ( pszFilter )
        delete [] pszFilter;
    if ( pszDlgTitle )
        delete [] pszDlgTitle;
    
    ::SetFocus (::GetDlgItem (GetHWnd (), IDC_CERT_LIST));
    return hr;
}

HRESULT CDsUserCertPage::OnDblClkCertList(LPNMHDR /*pNMHdr*/)
{
    HRESULT hr = S_OK;
    
    hr = OnClickedViewCert ();
    return hr;
}

HRESULT CDsUserCertPage::OnColumnClickCertList(LPNMLISTVIEW /*pNMListView*/)
{
    HRESULT hr = S_OK;
    
    return hr;
}

HRESULT CDsUserCertPage::OnDeleteItemCertList (LPNMLISTVIEW pNMListView)
{
    HRESULT hr = S_OK;

    dspAssert (pNMListView);
    if ( pNMListView )
    {
        LVITEM  lvItem;

        ::ZeroMemory (&lvItem, sizeof (lvItem));

        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = pNMListView->iItem;

        if ( ListView_GetItem (::GetDlgItem (GetHWnd (), IDC_CERT_LIST), &lvItem) )
        {
            CCertificate* pCert = (CCertificate*) lvItem.lParam;
            dspAssert (pCert);
            if ( pCert )
            {
                delete pCert;
            }
            else
                hr = E_UNEXPECTED;
        }
        else
            hr = E_UNEXPECTED;
    }
    else
        hr = E_POINTER;

    return hr;
}

HRESULT CDsUserCertPage::PopulateListView()
{
    CWaitCursor         cursor;
    PCCERT_CONTEXT      pCertContext = 0;
    HRESULT             hr = S_OK;
    CCertificate*       pCert = 0;

    //  Iterate through the list of certificates in the system store,
    //  allocate new certificates with the CERT_CONTEXT returned,
    //  and store them in the certificate list.
    int nItem = -1;
    while ( SUCCEEDED (hr) )
    {
        pCertContext = ::CertEnumCertificatesInStore (m_hCertStore, pCertContext);
        if ( !pCertContext )
            break;

        pCert = new CCertificate (pCertContext, m_hCertStore);
        if ( pCert )
        {
            nItem++;
            // NTRAID#NTBUG9-541102-2002/08/01-ericb Adding, removing, then applying causes error.
            m_nUserCerts++;

            hr = InsertCertInList (pCert, nItem);
            if ( !SUCCEEDED (hr) )
                delete pCert;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // NTRAID#NTBUG9-541102-2002/08/01-ericb Adding, removing, then applying causes error.
    if (0 == m_nUserCerts)
    {
        m_fUserStoreInitiallyEmpty = true;
    }

    return hr;
}

// Get the first selected certificate, starting at the end of the list
// and previous to the passed in nSelItem.  Pass in a -1 to search
// the entire list
CCertificate* CDsUserCertPage::GetSelectedCertificate (int& nSelItem)
{
    HWND            hWndList = ::GetDlgItem (GetHWnd (), IDC_CERT_LIST);
    int             nCnt = ListView_GetItemCount (hWndList);
    CCertificate*   pCert = 0;
    int             nSelCnt = ListView_GetSelectedCount (hWndList);
    LVITEM          lvItem;

    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_PARAM;


    if ( nSelCnt >= 1 )
    {
        if ( -1 != nSelItem )
            nCnt = nSelItem;

        while (--nCnt >= 0)
        {
            UINT    flag = ListView_GetItemState (hWndList, 
                nCnt, LVIS_SELECTED);
            if ( flag & LVNI_SELECTED )
            {
                lvItem.iItem = nCnt;

                if ( ListView_GetItem (::GetDlgItem (GetHWnd (), 
                        IDC_CERT_LIST),
                        &lvItem) )
                {
                    pCert = (CCertificate*) lvItem.lParam;
                    dspAssert (pCert);
                    if ( pCert )
                    {
                        nSelItem = nCnt;
                    }
                }
                else
                {
                    dspAssert (0);
                }
                break; 
            }
        }
    }

    return pCert;
}

void CDsUserCertPage::RefreshItemInList (CCertificate * /*pCert*/, int nItem)
{
    HWND            hWndList = ::GetDlgItem (GetHWnd (), IDC_CERT_LIST);
    BOOL bResult = ListView_Update (hWndList, nItem);
    dspAssert (bResult);
}


HRESULT CDsUserCertPage::InsertCertInList(CCertificate * pCert, int nItem)
{
    HRESULT         hr = S_OK;
    HWND            hWndList = ::GetDlgItem (GetHWnd (), IDC_CERT_LIST);
    LVITEM          lvItem;
    PWSTR           pszText = 0;
    int             nIndex = 0;


    // Insert icon and subject name
    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lvItem.iItem = nItem;
    lvItem.iSubItem = CERTCOL_ISSUED_TO;
    lvItem.iImage = m_nCertImageIndex;
    lvItem.lParam = (LPARAM) pCert;
    hr = pCert->GetSubjectName (&pszText);
    if ( SUCCEEDED (hr) )
        lvItem.pszText = pszText;
    else
    {
        hr = pCert->GetAlternateSubjectName (&pszText);
        if ( SUCCEEDED (hr) )
            lvItem.pszText = pszText;
    }
    if ( SUCCEEDED (hr) )
    {
        nIndex = ListView_InsertItem (hWndList, &lvItem);       
        _ASSERT (nIndex != -1);
        if ( nIndex == -1 )
        {
            delete pCert;
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        delete pCert;
        hr = E_UNEXPECTED;
    }


    if ( SUCCEEDED (hr) )
    {
        // Insert issuer name
        ::ZeroMemory (&lvItem, sizeof (lvItem));
        HRESULT hResultToo = pCert->GetIssuerName (&pszText);
        if ( !SUCCEEDED (hResultToo) )
        {
            hr = pCert->GetAlternateIssuerName (&pszText);
        }
        if ( SUCCEEDED (hResultToo) )
        {
            ListView_SetItemText (hWndList, nIndex, CERTCOL_ISSUED_BY, pszText);
        }
    }

    // Insert intended purpose
    if ( SUCCEEDED (hr) )
    {
        HRESULT hResultToo = pCert->GetEnhancedKeyUsage (&pszText);
        if ( SUCCEEDED (hResultToo) && pszText )
        {
            ListView_SetItemText (hWndList, nIndex, CERTCOL_PURPOSES, pszText);
        }
    }

    // Insert expiration date
    if ( SUCCEEDED (hr) )
    {
        HRESULT hResultToo = pCert->GetValidNotAfter (&pszText);
        if ( SUCCEEDED (hResultToo) )
        {
            ListView_SetItemText (hWndList, nIndex, CERTCOL_EXP_DATE, pszText);
        }
    }

    if ( pszText )
        delete [] pszText;

    return hr;
}

void CDsUserCertPage::DisplaySystemError(DWORD dwErr, int iCaptionText)
{
    LPVOID lpMsgBuf = 0;


    //NTRAID#NTBUG9-571997-2002/03/10-jmessec   FormatMessage can throw an exception if allocating buffer; not handled here,
    //is this by design?
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,    
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &lpMsgBuf, 0, NULL);
        
    // Display the string.
    PWSTR   pszCaption = 0;
    if ( LoadStringToTchar (IDS_MSG_TITLE, & pszCaption) )
    {
        PWSTR pszText = 0;
        if ( LoadStringToTchar (iCaptionText, &pszText) )
        {
            //NTRAID#NTBUG9-569720-2002/03/10-jmessec   buffer length calculation uses magic number which is highly dependent
            //upon hard-coded strings later in code; and is wrong anyway (looks like it should be 3, not 4)

            PWSTR pszFinalText = new WCHAR[wcslen ((PWSTR) lpMsgBuf) +
                    wcslen (pszText) + 4];
            if ( pszFinalText )
            {
                wcscpy (pszFinalText, pszText);

                if ( HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER) != dwErr )
                {
                    //NTRAID#NTBUG9-571073-2002/03/10-jmessec   Non-localized UI Text hard-coded in code.
                    wcscat (pszFinalText, L"  ");
                    wcscat (pszFinalText, (PWSTR) lpMsgBuf);
                }
                ::MessageBox (GetHWnd (), pszFinalText, pszCaption, 
                        MB_ICONWARNING | MB_OK);
                delete [] pszFinalText;
            }
            delete [] pszText;
        }
        delete [] pszCaption;
    }

    // Free the buffer.
    LocalFree (lpMsgBuf);
}

void CDsUserCertPage::EnableControls()
{
    HWND    hWndDlg = GetHWnd ();
    HWND    hWndList = ::GetDlgItem (hWndDlg, IDC_CERT_LIST);
    int     nSelCnt = ListView_GetSelectedCount (hWndList);
    int     nSelItem = -1;
    bool    bCanDelete = true;

    while (bCanDelete)
    {
        CCertificate*   pCert = GetSelectedCertificate (nSelItem);
        if ( pCert )
            bCanDelete = pCert->CanDelete ();
        else
            break;
    }

    ::EnableWindow (::GetDlgItem (hWndDlg, IDC_REMOVE), bCanDelete && nSelCnt > 0);
    ::EnableWindow (::GetDlgItem (hWndDlg, IDC_COPY_TO_FILE), nSelCnt == 1);
    ::EnableWindow (::GetDlgItem (hWndDlg, IDC_VIEW_CERT), nSelCnt == 1);
}

void CDsUserCertPage::OnNotifyStateChanged(LPNMLVODSTATECHANGE /*pStateChange*/)
{
    EnableControls ();
}

void CDsUserCertPage::OnNotifyItemChanged (LPNMLISTVIEW /*pnmv*/)
{
    EnableControls ();
}

HRESULT CDsUserCertPage::AddCertToStore(PCCERT_CONTEXT pCertContext)
{
    HRESULT hr = S_OK;

    if ( pCertContext )
    {
        BOOL bResult = ::CertAddCertificateContextToStore (
                    m_hCertStore,
                    pCertContext,
                    CERT_STORE_ADD_NEW,
                    0);
        if ( bResult )
        {
            DWORD   cbData = 20;
            BYTE    certHash[20];
            BOOL bReturn = ::CertGetCertificateContextProperty (
                    pCertContext,
                    CERT_SHA1_HASH_PROP_ID,
                    certHash,
                    &cbData);
            ASSERT (bReturn);
            if ( bReturn )
            {
                CRYPT_DATA_BLOB blob = {sizeof (certHash), certHash};
                PCCERT_CONTEXT pNewCertContext = CertFindCertificateInStore(
                    m_hCertStore,
                    0,
                    0,
                    CERT_FIND_SHA1_HASH,
                    &blob,
                    0);
                if ( pNewCertContext )
                {
                    CCertificate* pCert = new CCertificate (pNewCertContext, m_hCertStore); 
                    if ( pCert )
                    {
                        // NTRAID#NTBUG9-541102-2002/08/01-ericb Adding, removing, then applying causes error.
                        m_nUserCerts++;

                        hr = InsertCertInList (pCert, 
                                ListView_GetItemCount (
                                ::GetDlgItem (GetHWnd (), IDC_CERT_LIST)));
                        if ( !SUCCEEDED (hr) )
                            delete pCert;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                    ::CertFreeCertificateContext (pNewCertContext);
                }
            }
        }
        else
        {
            DWORD   dwErr = GetLastError ();
            if ( dwErr == CRYPT_E_EXISTS )
            {
                LPWSTR  pszMsg = 0;
                LPWSTR  pszCaption = 0;

                if ( LoadStringToTchar (IDS_DUPLICATE_CERT, &pszMsg) &&
                        LoadStringToTchar (IDS_ADD_FROM_STORE, &pszCaption) )
                {
                    ::MessageBox (GetHWnd (), pszMsg, pszCaption, 
                            MB_ICONINFORMATION | MB_OK);
                    hr = E_FAIL;
                }
                else
                    hr = E_OUTOFMEMORY;

                if ( pszMsg )
                    delete [] pszMsg;
                if ( pszCaption )
                    delete [] pszCaption;
            }
            else
            {
                DisplaySystemError (dwErr, IDS_ADD_FROM_STORE);
                hr = HRESULT_FROM_WIN32 (dwErr);
            }
        }

        ::CertFreeCertificateContext (pCertContext);
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

int CDsUserCertPage::MessageBox(int caption, int text, UINT flags)
{
    int iReturn = -1;

    LPWSTR  pszMsg = 0;
    LPWSTR  pszCaption = 0;

    if ( LoadStringToTchar (text, &pszMsg) && 
            LoadStringToTchar (caption, &pszCaption) )
    {
        iReturn = ::MessageBox (GetHWnd (), pszMsg, pszCaption, flags);
    }

    if ( pszMsg )
        delete [] pszMsg;
    if ( pszCaption )
        delete [] pszCaption;

    return iReturn;
}

#endif // DSADMIN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\uacct.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       uacct.h
//
//  Contents:   User account page declarations
//
//  Classes:    
//
//  History:    29-Nov-99 JeffJon created
//
//-----------------------------------------------------------------------------

#ifndef __UACCT_H_
#define __UACCT_H_

#include "proppage.h"
#include "user.h"

#ifdef DSADMIN

static const PWSTR wzUPN          = L"userPrincipalName";

static const PWSTR wzSAMname      = L"sAMAccountName";   // DS max length 64,
#define MAX_SAM_NAME_LEN LM20_UNLEN                      // but SAM max is 20.

static const PWSTR wzPwdLastSet   = L"pwdLastSet";       // LARGE INTEGER

static const PWSTR wzAcctExpires  = L"accountExpires";   // [Interval] ADSTYPE_INTEGER

static const PWSTR wzLogonHours   = L"logonHours";       // ADSTYPE_OCTET_STRING

static const PWSTR wzSecDescriptor= L"nTSecurityDescriptor";

static const PWSTR wzUserWksta    = L"userWorkstations"; // ADSTYPE_CASE_IGNORE_STRING

static const PWSTR wzLockoutTime  = L"lockoutTime";      // LARGE INTEGER

static const PWSTR wzUserAccountControlComputed = L"msDS-User-Account-Control-Computed";

// User-Workstations is a comma-separated list of NETBIOS machine names.
// The attribute has a range upper of 1024 characters. A NETBIOS machine name
// has a maximum length of 15 characters; add one for the comma and you have
// sixteen characters. Thus, the maximum logon workstations that can be
// stored is 1024/16.

#define MAX_LOGON_WKSTAS (1024/16)

#define cbLogonHoursArrayLength     21      // Number of bytes in the logon array

#define DSPROP_NO_ACE_FOUND 0xffffffff

#define TRACE0(szMsg)   dspDebugOut((DEB_ERROR, szMsg));

/////////////////////////////////////////////////////////////////////
//  DllScheduleDialog()
//
//  Wrapper to call the function LogonScheduleDialog() &
//  ConnectionScheduleDialog ().
//  The wrapper will load the library loghours.dll, export
//  the function LogonScheduleDialog() or
//  ConnectionScheduleDialog () and free the library.
//
//  INTERFACE NOTES
//  This routine has EXACTLY the same interface notes
//  as LogonScheduleDialog() & ConnectionScheduleDialog ().
//
//  The function launches either ConnectionScheduleDialog () or LogonScheduleDialog ()
//  depending on the ID of the title passed in.
//
//  HISTORY
//  21-Jul-97   t-danm      Creation.
//  3-4-98		bryanwal	Modification to launch different dialogs.
//
HRESULT
DllScheduleDialog(
    HWND hwndParent,
    BYTE ** pprgbData,
    int idsTitle,
    LPCTSTR pszName,
    LPCTSTR pszObjClass,
    DWORD dwFlags,
    ScheduleDialogType dlgtype );

/////////////////////////////////////////////////////////////////////
//  FIsValidUncPath()
//
//  Return TRUE if a UNC path is valid, otherwise return FALSE.
//
//  HISTORY
//  18-Aug-97   t-danm      Creation.
//
BOOL
FIsValidUncPath(
    LPCTSTR pszPath,    // IN: Path to validate
    UINT uFlags);        // IN: Validation flags


/////////////////////////////////////////////////////////////////////
//  DSPROP_IsValidUNCPath()
//
//  Exported (UNICODE ONLY) entry point to call FIsValidUncPath()
//  for use in DS Admin
//
BOOL DSPROP_IsValidUNCPath(LPCWSTR lpszPath);


//+----------------------------------------------------------------------------
//
//  User Profile Page
//
//-----------------------------------------------------------------------------

#define COMBO_Z_DRIVE   22

static const PWSTR wzProfilePath  = L"profilePath";      // ADSTYPE_CASE_IGNORE_STRING

static const PWSTR wzScriptPath   = L"scriptPath";       // ADSTYPE_CASE_IGNORE_STRING

static const PWSTR wzHomeDir      = L"homeDirectory";    // ADSTYPE_CASE_IGNORE_STRING

static const PWSTR wzHomeDrive    = L"homeDrive";        // ADSTYPE_CASE_IGNORE_STRING


DWORD 
AddFullControlForUser(IN PSID pUserSid, IN LPCWSTR lpszPathName);

void
UpdateComboBoxDropWidth(HWND hwnd);

#endif // DSADMIN


#endif // __UACCT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\admin\user.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       user.h
//
//  Contents:   DS user object property pages header
//
//  Classes:    CDsUserAcctPage, CDsUsrProfilePage, CDsMembershipPage
//
//  History:    05-May-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _USER_H_
#define _USER_H_

#include "objlist.h"
#include "loghrapi.h"

BOOL ExpandUsername(PWSTR& pwzValue, PWSTR pwzSamName, BOOL& fExpanded, const CStrW& strToken);

HRESULT CountryName(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT CountryCode(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT TextCountry(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ManagerEdit(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT ManagerChangeBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                         LPARAM, PATTR_DATA, DLG_OP);

HRESULT MgrPropBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                   LPARAM, PATTR_DATA, DLG_OP);

HRESULT ClearMgrBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                    LPARAM, PATTR_DATA, DLG_OP);

HRESULT DirectReportsList(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                          LPARAM, PATTR_DATA, DLG_OP);

HRESULT AddReportsBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                      LPARAM, PATTR_DATA, DLG_OP);

HRESULT RmReportsBtn(CDsPropPageBase *, struct _ATTR_MAP *, PADS_ATTR_INFO,
                     LPARAM, PATTR_DATA, DLG_OP);

HRESULT MailAttr(CDsPropPageBase *, PATTR_MAP, PADS_ATTR_INFO,
                 LPARAM, PATTR_DATA, DLG_OP);

HRESULT ShBusAddrBtn(CDsPropPageBase *, PATTR_MAP, PADS_ATTR_INFO,
                     LPARAM, PATTR_DATA, DLG_OP);

#ifdef DSADMIN

typedef enum _ScheduleDialogType {
  SchedDlg_Connection,
  SchedDlg_Replication,
  SchedDlg_Logon
} ScheduleDialogType;

HRESULT
DllScheduleDialog(HWND hwndParent, BYTE ** pprgbData, int idsTitle,
                  LPCTSTR pszName = NULL,
                  LPCTSTR pszObjClass = NULL,
                  DWORD dwFlags = 0,
                  ScheduleDialogType dlgtype = SchedDlg_Logon );

//+----------------------------------------------------------------------------
//
//  Class:      CLogonWkstaDlg
//
//  Purpose:    Update the logon workstations attribute. This is a dialog
//              that hosts the CMultiStringAttr class.
//
//-----------------------------------------------------------------------------
class CLogonWkstaDlg
{
public:
    CLogonWkstaDlg(CDsPropPageBase * pPage);
    ~CLogonWkstaDlg() {};
    //
    //  Static WndProc for multi-valued edit dialog.
    //
    static INT_PTR CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg,
                                          WPARAM wParam, LPARAM lParam);
    HRESULT Init(PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
                 BOOL fWritable = TRUE, int nLimit = 0,
                 BOOL fCommaList = FALSE);
    int     Edit(void);
    HRESULT Write(PADS_ATTR_INFO pAttr);
    BOOL    IsDirty(void);
    void    ClearDirty(void);

private:
    //
    // Dialog proc.
    //
    INT_PTR CALLBACK MultiValDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                     LPARAM lParam);

    void                ClearAttrInfo(void);

    CMultiStringAttr    m_MSA;
    CDsPropPageBase   * m_pPage;
    BOOL                m_fAllWkstas;
    BOOL                m_fOrigAllWkstas;
    BOOL                m_fFirstUp;
};

HRESULT CreateUserAcctPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND,
                           DWORD, const CDSSmartBasePathsInfo&, HPROPSHEETPAGE *);

//+----------------------------------------------------------------------------
//
//  Class:      CDsUserAcctPage
//
//  Purpose:    property page object class for the user object account page.
//
//-----------------------------------------------------------------------------
class CDsUserAcctPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsUserAcctPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                    DWORD dwFlags);
    ~CDsUserAcctPage(void);

    //
    //  Instance specific wind proc
    //
    INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(void);

    BOOL FillSuffixCombo(LPWSTR pwzUPNdomain);

    //
    //  Data members
    //
    DWORD           m_dwUsrAcctCtrl;
    DWORD           m_dwUsrAcctCtrlComputed;
    BOOL            m_fOrigCantChangePW;
    BOOL            m_fOrigSelfAllowChangePW;
    BOOL            m_fOrigWorldAllowChangePW;
    LARGE_INTEGER   m_PwdLastSet;
    BYTE *          m_pargbLogonHours;  // Pointer to allocated array of bytes for the logon hours (array length=21 bytes)
    PWSTR           m_pwzUPN;
    PWSTR           m_pwzSAMname;
    PSID            m_pSelfSid;
    PSID            m_pWorldSid;
    size_t          m_cchSAMnameCtrl;
    LARGE_INTEGER   m_LockoutTime;
    BOOL            m_fUACWritable;
    BOOL            m_fUPNWritable;
    BOOL            m_fSAMNameWritable;
    BOOL            m_fPwdLastSetWritable;
    BOOL            m_fAcctExpiresWritable;
    BOOL            m_fLoginHoursWritable;
    BOOL            m_fUserWkstaWritable;
    BOOL            m_fLockoutTimeWritable;
    BOOL            m_fNTSDWritable;
    BOOL            m_fSAMNameChanged;
    BOOL            m_fAcctCtrlChanged;
    BOOL            m_fAcctExpiresChanged;
    BOOL            m_fLogonHoursChanged;
    BOOL            m_fIsAdmin;
    CLogonWkstaDlg        * m_pWkstaDlg;
};

HRESULT CreateUsrProfilePage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR, HWND, DWORD,
                             const CDSSmartBasePathsInfo&, HPROPSHEETPAGE *);

//+----------------------------------------------------------------------------
//
//  Class:      CDsUsrProfilePage
//
//  Purpose:    property page object class for the user object profile page.
//
//-----------------------------------------------------------------------------
class CDsUsrProfilePage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsUsrProfilePage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                      DWORD dwFlags);
    ~CDsUsrProfilePage(void);

    //
    //  Instance specific wind proc
    //
    INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
	LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(void);
    BOOL    ExpandUsername(PWSTR & pwzValue, BOOL & fExpanded);

    //
    //  Data members
    //
    PTSTR       m_ptszLocalHomeDir;
    PTSTR       m_ptszRemoteHomeDir;
    PWSTR       m_pwzSamName;
    int         m_nDrive;
    int         m_idHomeDirRadio;
    BOOL        m_fProfilePathWritable;
    BOOL        m_fScriptPathWritable;
    BOOL        m_fHomeDirWritable;
    BOOL        m_fHomeDriveWritable;
    BOOL        m_fProfilePathChanged;
    BOOL        m_fLogonScriptChanged;
    BOOL        m_fHomeDirChanged;
    BOOL        m_fHomeDriveChanged;
    BOOL        m_fSharedDirChanged;
    PSID        m_pObjSID;
};

HRESULT CreateMembershipPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR,
                             HWND, DWORD, 
                             const CDSSmartBasePathsInfo& basePathsInfo, HPROPSHEETPAGE *);

HRESULT CreateNonSecMembershipPage(PDSPAGE, LPDATAOBJECT, PWSTR, PWSTR,
                                   HWND, DWORD, 
                                   const CDSSmartBasePathsInfo& basePathsInfo, HPROPSHEETPAGE *);

//+----------------------------------------------------------------------------
//
//  Class:      CDsMembershipPage
//
//  Purpose:    property page object class for the membership page.
//
//-----------------------------------------------------------------------------
class CDsMembershipPage : public CDsPropPageBase
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CDsMembershipPage(PDSPAGE pDsPage, LPDATAOBJECT pDataObj, HWND hNotifyObj,
                      DWORD dwFlags, BOOL fSecPrinciple = TRUE);
    ~CDsMembershipPage(void);

    //
    //  Instance specific wind proc
    //
    INT_PTR CALLBACK DlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(WPARAM wParam, LPARAM lParam);
    LRESULT OnDestroy(void);
    bool    IsSPInSameDomain(PCWSTR pszGroupDN, PCWSTR pszDomainName);
    HRESULT FillMembershipList(void);
    void    InvokeGroupQuery(void);
    void    RemoveMember(void);
    BOOL    SelectionCanBePrimaryGroup(void);
    HRESULT SetPrimaryGroup(void);
    HRESULT ConvertRIDtoName(DWORD RID, PTSTR * pptzName, PWSTR * ppwzDN);
    HRESULT BindToGroup(CMemberListItem * pItem, BOOL fAdd,
                        IUnknown ** ppUnk,
                        PBOOL pfBindFailed);

    //
    //  Data members
    //
    CDsMembershipList * m_pList;
    CMemberLinkList     m_DelList;
    CMemberListItem   * m_pPriGrpLI;
    PWSTR               m_pwzObjDomain;
    BSTR                m_bstrDomPath;
    PSID                m_pObjSID;
    DWORD               m_dwOriginalPriGroup;
    BOOL                m_fSecPrinciple;
    BOOL                m_fMixed; // Domain is in mixed mode
    DWORD               m_dwGrpType;
    BOOL                m_fPriGrpWritable;
};

#endif // DSADMIN

// CountryCode helpers:

typedef struct _DsCountryCode {
    WORD  wCode;
    WCHAR pwz2CharAbrev[3];
} DsCountryCode, *PDsCountryCode;

BOOL GetALineOfCodes(PTSTR pwzLine, PTSTR * pptzFullName,
                     CStrW & str2CharAbrev, LPWORD pwCode);

void RemoveTrailingWhitespace(PTSTR pwz);

#endif // _USER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\sample\dll.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Property Page Sample
//
//  The code contained in this source file is for demonstration purposes only.
//  No warrantee is expressed or implied and Microsoft disclaims all liability
//  for the consequenses of the use of this source code.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       dll.h
//
//  Contents:   DLL refcounting classes.
//
//  Classes:    CDll, CDllRef
//
//  History:    6/09/1997 Eric Brown
//
//-----------------------------------------------------------------------------

#ifndef _DLL_H_
#define _DLL_H_

class CDll
{
public:

    static ULONG AddRef() { return InterlockedIncrement((LONG*)&s_cObjs); }
    static ULONG Release() { return InterlockedDecrement((LONG*)&s_cObjs); }

    static void LockServer(BOOL fLock)
    {
        (fLock == TRUE) ? InterlockedIncrement((LONG*)&s_cLocks)
                        : InterlockedDecrement((LONG*)&s_cLocks);
    }

    static HRESULT CanUnloadNow(void)
    {
        return (0L == s_cObjs && 0L == s_cLocks) ? S_OK : S_FALSE;
    }

    static ULONG s_cObjs;
    static ULONG s_cLocks;

};

class CDllRef
{
public:
    CDllRef(void) { CDll::AddRef(); }
    ~CDllRef(void) { CDll::Release(); }
};

#endif // _DLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\sample\dllmisc.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Property Page Sample
//
//  The code contained in this source file is for demonstration purposes only.
//  No warrantee is expressed or implied and Microsoft disclaims all liability
//  for the consequenses of the use of this source code.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       dllmisc.cxx
//
//  Contents:   AD property page sample class object handler DLL fcns.
//
//  History:    21-Mar-97 Eric Brown created
//
//-----------------------------------------------------------------------------

#include "page.h"

HINSTANCE g_hInstance = NULL;
ULONG CDll::s_cObjs  = 0;
ULONG CDll::s_cLocks = 0;

//+----------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Provide a DllMain for Win32
//
//  Arguments:  hInstance - HANDLE to this dll
//              dwReason  - Reason this function was called. Can be
//                          Process/Thread Attach/Detach.
//
//  Returns:    BOOL - TRUE if no error, FALSE otherwise
//
//  History:    24-May-95 EricB created.
//
//-----------------------------------------------------------------------------
extern "C" INT APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, PVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            //
            // Get instance handle
            //
            g_hInstance = hInstance;
            break;

        case DLL_PROCESS_DETACH:
            break;
    }
    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Creates a class factory for the requested object.
//
//  Arguments:  [cid]    - the requested class object
//              [iid]    - the requested interface
//              [ppvObj] - returned pointer to class object
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDAPI
DllGetClassObject(REFCLSID cid, REFIID iid, void **ppvObj)
{
    IUnknown *pUnk = NULL;
    HRESULT hr = S_OK;

    if (cid != CLSID_SamplePage)
    {
        return E_NOINTERFACE;
    }

    pUnk = CDsPropPageHostCF::Create();
    if (pUnk != NULL)
    {
        hr = pUnk->QueryInterface(iid, ppvObj);
        pUnk->Release();
    }
    else
    {
        return E_OUTOFMEMORY;
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Indicates whether the DLL can be removed if there are no
//              objects in existence.
//
//  Returns:    S_OK or S_FALSE
//
//-----------------------------------------------------------------------------
STDAPI
DllCanUnloadNow(void)
{
    return CDll::CanUnloadNow();
}

TCHAR const c_szDsProppagesProgID[] = TEXT("ADsSamplePropertyPage");
TCHAR const c_szServerType[] = TEXT("InProcServer32");
TCHAR const c_szDsProppagesDllName[] = TEXT("proppage.dll");
TCHAR const c_szThreadModel[] = TEXT("ThreadingModel");
TCHAR const c_szThreadModelValue[] = TEXT("Apartment");

//+----------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Adds entries to the system registry.
//
//  Returns:    S_OK or S_FALSE
//
//  Notes:      The keys look like this:
//
//      HKC\CLSID\clsid <No Name> REG_SZ name.progid
//                     \InPropServer32 <No Name> : REG_SZ : proppage.dll
//                                     ThreadingModel : REG_SZ : Apartment
//-----------------------------------------------------------------------------
STDAPI
DllRegisterServer(void)
{
    HRESULT hr = S_OK;
    HKEY hKeyCLSID, hKeyDsPPClass, hKeySvr;
    
    long lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0,
                             KEY_WRITE, &hKeyCLSID);
    if (lRet != ERROR_SUCCESS)
    {
        return (HRESULT_FROM_WIN32(lRet));
    }

    LPOLESTR pszCLSID;
    DWORD dwDisposition;

    hr = StringFromCLSID(CLSID_SamplePage, &pszCLSID);
    
    lRet = RegCreateKeyEx(hKeyCLSID, pszCLSID, 0, NULL,
                          REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                          &hKeyDsPPClass, &dwDisposition);

    if (lRet != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRet);
        return hr;
    }

    lRet = RegSetValueEx(hKeyDsPPClass, NULL, 0, REG_SZ,
                         (CONST BYTE *)c_szDsProppagesProgID,
                         sizeof(TCHAR) * (wcslen(c_szDsProppagesProgID) + 1));
    if (lRet != ERROR_SUCCESS)
    {
        RegCloseKey(hKeyDsPPClass);
        hr = HRESULT_FROM_WIN32(lRet);
        return hr;
    }

    lRet = RegCreateKeyEx(hKeyDsPPClass, c_szServerType, 0, NULL,
                          REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                          &hKeySvr, &dwDisposition);

    RegCloseKey(hKeyDsPPClass);
    
    if (lRet != ERROR_SUCCESS)
    {
         hr = HRESULT_FROM_WIN32(lRet);
        return hr;
    }
    
    lRet = RegSetValueEx(hKeySvr, NULL, 0, REG_SZ,
        (CONST BYTE *)c_szDsProppagesDllName,
        sizeof(TCHAR) * (wcslen(c_szDsProppagesDllName) + 1));
    if (lRet != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRet);
    }
    
    lRet = RegSetValueEx(hKeySvr, c_szThreadModel, 0, REG_SZ,
        (CONST BYTE *)c_szThreadModelValue,
        sizeof(TCHAR) * (wcslen(c_szThreadModelValue) + 1));
    if (lRet != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRet);
    }
    
    RegCloseKey(hKeySvr);

    RegCloseKey(hKeyCLSID);

    lRet = RegCreateKeyEx(HKEY_CLASSES_ROOT, c_szDsProppagesProgID, 0, NULL,
                          REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                          &hKeyDsPPClass, &dwDisposition);

    if (lRet != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRet);
        return hr;
    }
    lRet = RegCreateKeyEx(hKeyDsPPClass, L"CLSID", 0, NULL,
                          REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                          &hKeyCLSID, &dwDisposition);

    if (lRet != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRet);
        return hr;
    }
    lRet = RegSetValueEx(hKeyCLSID, NULL, 0, REG_SZ,
                         (CONST BYTE *)pszCLSID,
                         sizeof(TCHAR) * (wcslen(pszCLSID) + 1));
    if (lRet != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(lRet);
        return hr;
    }
    CoTaskMemFree(pszCLSID);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\sample\host.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Property Page Sample
//
//  The code contained in this source file is for demonstration purposes only.
//  No warrantee is expressed or implied and Microsoft disclaims all liability
//  for the consequenses of the use of this source code.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       host.cxx
//
//  Contents:   CDsPropPageHost, the class that exposes IShellExtInit and
//              IShellPropSheetExt
//              Also, the ClassFactory and IUnknown code.
//
//  History:    8-Sep-97 Eric Brown created
//
//-----------------------------------------------------------------------------

#include "page.h"

CLIPFORMAT g_cfDsObjectNames = 0;
const CLSID CLSID_SamplePage = { /* cca62184-294f-11d1-bcfe-00c04fd8d5b6 */
    0xcca62184,
    0x294f,
    0x11d1,
    {0xbc, 0xfe, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xb6}
};

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::CDsPropPageHost
//
//-----------------------------------------------------------------------------
CDsPropPageHost::CDsPropPageHost() :
    m_pDataObj(NULL),
    m_uRefs(1)
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::~CDsPropPageHost
//
//-----------------------------------------------------------------------------
CDsPropPageHost::~CDsPropPageHost()
{
    if (m_pDataObj)
    {
        m_pDataObj->Release();
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::IShellExtInit::Initialize
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHost::Initialize(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj,
                            HKEY hKeyID)
{
    if (IsBadReadPtr(pDataObj, sizeof(LPDATAOBJECT)))
    {
        return E_INVALIDARG;
    }

    if (m_pDataObj)
    {
        m_pDataObj->Release();
        m_pDataObj = NULL;
    }

    // Hang onto the IDataObject we are being passed.

    m_pDataObj = pDataObj;
    if (m_pDataObj)
    {
        m_pDataObj->AddRef();
    }
    else
    {
        return E_INVALIDARG;
    }

    // Check to see if we have our clipboard format registered, if not then
    // lets do it.

    if (!g_cfDsObjectNames)
    {
        g_cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
    }
    if (!g_cfDsObjectNames)
    {
        return E_FAIL;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::IShellExtInit::AddPages
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHost::AddPages(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam)
{
    HRESULT hr = S_OK;
    HPROPSHEETPAGE hPage;
    STGMEDIUM ObjMedium = {TYMED_NULL};
    FORMATETC fmte = {g_cfDsObjectNames, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    LPDSOBJECTNAMES pDsObjectNames;
    PWSTR pwzObjName;
    PWSTR pwzClass;
    CDsPropPage * PropPage;

    //
    // Get the path to the DS object from the data object.
    // Note: This call runs on the caller's main thread. The pages' window
    // procs run on a different thread, so don't reference the data object
    // from a winproc unless it is first marshalled on this thread.
    //
    hr = m_pDataObj->GetData(&fmte, &ObjMedium);
    if (!SUCCEEDED(hr))
    {
        return hr;
    }

    pDsObjectNames = (LPDSOBJECTNAMES)ObjMedium.hGlobal;

    if (pDsObjectNames->cItems < 1)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    pwzObjName = (PWSTR)ByteOffset(pDsObjectNames,
                                   pDsObjectNames->aObjects[0].offsetName);
    pwzClass = (PWSTR)ByteOffset(pDsObjectNames,
                                 pDsObjectNames->aObjects[0].offsetClass);

    //
    // NOTIFY_OBJ
    // Create/contact the notification object.
    //
    HWND hNotifyObj;

    hr = ADsPropCreateNotifyObj(m_pDataObj, pwzObjName, &hNotifyObj);

    if (FAILED(hr))
    {
        goto Cleanup;
    }

    //
    // Create the page.
    //
    PropPage = new CDsPropPage(hNotifyObj);

    hr = PropPage->Init(pwzObjName, pwzClass);

    if (!SUCCEEDED(hr))
    {
        goto Cleanup;
    }

    hr = PropPage->CreatePage(&hPage);

    if (!SUCCEEDED(hr))
    {
        goto Cleanup;
    }

    //
    // Invoke the callback function, which will add the page to the list of
    // pages that will be used to create the property sheet.
    //
    (*pAddPageProc)(hPage, lParam);

Cleanup:
    ReleaseStgMedium(&ObjMedium);

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member: CDsPropPageHost::IShellExtInit::ReplacePage
//
//  Notes:  Not used.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHost::ReplacePage(UINT uPageID,
                             LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                             LPARAM lParam)
{
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHost::QueryInterface(REFIID riid, void ** ppvObject)
{
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)(LPSHELLEXTINIT)this;
    }
    else if (IID_IShellExtInit == riid)
    {
        *ppvObject = (LPSHELLEXTINIT)this;
    }
    else if (IID_IShellPropSheetExt == riid)
    {
        *ppvObject = (LPSHELLPROPSHEETEXT)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPageHost::AddRef(void)
{
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHost::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    zero if the reference count is zero or non-zero otherwise
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPageHost::Release(void)
{
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//      CDsPropPageHostCF - class factory for the CDsPropPageHost object
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::Create
//
//  Synopsis:   creates a new class factory object
//
//-----------------------------------------------------------------------------
IClassFactory *
CDsPropPageHostCF::Create(void)
{
    return new CDsPropPageHostCF();
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::CDsPropPageHostCF
//
//  Synopsis:   ctor
//
//-----------------------------------------------------------------------------
CDsPropPageHostCF::CDsPropPageHostCF() :
    m_uRefs(1)
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::~CDsPropPageHostCF
//
//  Synopsis:   dtor
//
//-----------------------------------------------------------------------------
CDsPropPageHostCF::~CDsPropPageHostCF(void)
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHostCF::QueryInterface(REFIID riid, void ** ppvObject)
{
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        *ppvObject = (IClassFactory *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the new reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPageHostCF::AddRef(void)
{
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::IUnknown::Release
//
//  Synopsis:   decrement the refcount
//
//  Returns:    the new reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CDsPropPageHostCF::Release(void)
{
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::IClassFactory::CreateInstance
//
//  Synopsis:   create an incore instance of the proppage host class object
//
//  Arguments:  [pUnkOuter] - aggregator
//              [riid]      - requested interface
//              [ppvObject] - receptor for itf ptr
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHostCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid,
                                   void **ppvObject)
{
    HRESULT hr = S_OK;
    *ppvObject = NULL;

    CDsPropPageHost * pPropPage = new CDsPropPageHost();
    if (pPropPage == NULL)
    {
        return E_OUTOFMEMORY;
    }

    hr = pPropPage->QueryInterface(riid, ppvObject);
    if (FAILED(hr))
    {
        pPropPage->Release();
        return hr;
    }

    //
    // We got a refcount of one when launched, and the above QI increments it
    // to 2, so call release to take it back to 1.
    //
    pPropPage->Release();
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPageHostCF::IClassFactory::LockServer
//
//  Synopsis:   Called with fLock set to TRUE to indicate that the server
//              should continue to run even if none of its objects are active
//
//  Arguments:  [fLock] - increment/decrement the instance count
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CDsPropPageHostCF::LockServer(BOOL fLock)
{
    CDll::LockServer(fLock);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\sample\page.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Property Page Sample
//
//  The code contained in this source file is for demonstration purposes only.
//  No warrantee is expressed or implied and Microsoft disclaims all liability
//  for the consequenses of the use of this source code.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       page.cxx
//
//  Contents:   CDsPropPage, the class that implements the sample property
//              page.
//
//  History:    8-Sep-97 Eric Brown created
//              24-Sep-98  "    "   revised to include notification object.
//
//-----------------------------------------------------------------------------

#include "page.h"

WCHAR wzSpendingLimit[] = L"spendingLimit";

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPage::CDsPropPage
//
//-----------------------------------------------------------------------------
CDsPropPage::CDsPropPage(HWND hNotifyObj) :
    m_hPage(NULL),
    m_pDsObj(NULL),
    m_fInInit(FALSE),
    m_fPageDirty(FALSE),
    m_pwzObjPathName(NULL),
    m_pwzObjClass(NULL),
    m_pwzRDName(NULL),
    m_hNotifyObj(hNotifyObj),
    m_pWritableAttrs(NULL),
    m_hrInit(S_OK)
{
}

//+----------------------------------------------------------------------------
//
//  Member:     CDsPropPage::~CDsPropPage
//
//  Notes:      m_pWritableAttrs does not need to be freed. It refers to
//              memory held by the notify object and freed when the notify
//              object is destroyed.
//
//-----------------------------------------------------------------------------
CDsPropPage::~CDsPropPage()
{
    if (m_pDsObj)
    {
        m_pDsObj->Release();
    }
    if (m_pwzObjPathName)
    {
        delete m_pwzObjPathName;
    }
    if (m_pwzObjClass)
    {
        delete m_pwzObjClass;
    }
    if (m_pwzRDName)
    {
        delete m_pwzRDName;
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::CreatePage
//
//  Sysnopsis:  Create the prop page
//
//  Notes:      if m_hrInit contains a failure code at this point, then an
//              error page template could be substituted for the regular one.
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPage::CreatePage(HPROPSHEETPAGE * phPage)
{
    TCHAR szTitle[MAX_PATH];
    
    if (!LoadString(g_hInstance, IDS_PAGE_TITLE, szTitle, MAX_PATH - 1))
    { 
        DWORD dwErr = GetLastError();
        return HRESULT_FROM_WIN32(GetLastError());
    }
    
    PROPSHEETPAGE   psp;

    psp.dwSize      = sizeof(PROPSHEETPAGE);
    psp.dwFlags     = PSP_USECALLBACK | PSP_USETITLE;
    psp.pszTemplate = (LPCTSTR)IDD_SAMPLE_PAGE;
    psp.pfnDlgProc  = StaticDlgProc;
    psp.pfnCallback = PageCallback;
    psp.pcRefParent = NULL; // do not set PSP_USEREFPARENT
    psp.lParam      = (LPARAM) this;
    psp.hInstance   = g_hInstance;
    psp.pszTitle    = L"Spending Limit";

    *phPage = CreatePropertySheetPage(&psp);

    if (*phPage == NULL)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::Init
//
//  Sysnopsis:  Initialize the page object. This is the second part of a two
//              phase creation where operations that could fail are located.
//
//-----------------------------------------------------------------------------
HRESULT
CDsPropPage::Init(PWSTR pwzObjName, PWSTR pwzClass)
{
	//NTRAID#NTBUG9-572007-2002/03/10-jmessec   If Init called multiple times, memory is leaked
	//NTRAID#NTBUG9-572007-2002/03/10-jmessec   If second allocation fails, m_pwszObjPathName points to an uninitialized buffer
	
    m_pwzObjPathName = new WCHAR[wcslen(pwzObjName) + 1];
    if (m_pwzObjPathName == NULL )
    {
        return E_OUTOFMEMORY;
    }

    m_pwzObjClass = new WCHAR[wcslen(pwzClass) + 1];
    if (m_pwzObjClass == NULL)
    {
        return E_OUTOFMEMORY;
    }
    wcscpy(m_pwzObjPathName, pwzObjName);
    wcscpy(m_pwzObjClass, pwzClass);

    //
    // NOTIFY_OBJ
    // Contact the notification object for the initialization info.
    //
    ADSPROPINITPARAMS InitParams = {0};

    InitParams.dwSize = sizeof (ADSPROPINITPARAMS);
    
    if (!ADsPropGetInitInfo(m_hNotifyObj, &InitParams))
    {
        m_hrInit = E_FAIL;
        return E_FAIL;
    }

    if (FAILED(InitParams.hr))
    {
        m_hrInit = InitParams.hr;
        return m_hrInit;
    }

    m_pwzRDName = new WCHAR[wcslen(InitParams.pwzCN) + 1];

    if (m_pwzRDName == NULL)
    {
        m_hrInit = E_OUTOFMEMORY;
        return E_OUTOFMEMORY;
    }

    m_pDsObj = InitParams.pDsObj;
    m_pDsObj->AddRef();

    m_pWritableAttrs = InitParams.pWritableAttrs;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     StaticDlgProc
//
//  Sysnopsis:  static dialog proc
//
//-----------------------------------------------------------------------------
BOOL CALLBACK
StaticDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDsPropPage * pPage = (CDsPropPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)lParam;

        pPage = (CDsPropPage *) ppsp->lParam;
        pPage->m_hPage = hDlg;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pPage);
    }

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pPage->m_fInInit = TRUE;
        pPage->OnInitDialog(lParam);
        pPage->m_fInInit = FALSE;
        return TRUE;

    case WM_COMMAND:
        return pPage->OnCommand(LOWORD(wParam),(HWND)lParam, HIWORD(wParam));

    case WM_NOTIFY:
        return pPage->OnNotify(uMsg, wParam, lParam);
    }

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::OnInitDialog
//
//  Sysnopsis:  Handles dialog initialization messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPage::OnInitDialog(LPARAM lParam)
{
    PADS_ATTR_INFO pAttrs = NULL;
    DWORD cAttrs = 0;
    HRESULT hr = S_OK;

    //
    // NOTIFY_OBJ
    // Send the notification object the page's window handle.
    //
    if (!ADsPropSetHwnd(m_hNotifyObj, m_hPage))
    {
        m_pWritableAttrs = NULL;
    }

    //
    // Disable the edit control if the user does not have write permission on
    // the attribute.
    //
    if (!ADsPropCheckIfWritable(wzSpendingLimit, m_pWritableAttrs))
    {
        EnableWindow(GetDlgItem (m_hPage, IDC_SPENDING_EDIT), FALSE);
    }

    //
    // Get the attribute value.
    //
    PWSTR rgpwzAttrNames[] = {wzSpendingLimit};

    hr = m_pDsObj->GetObjectAttributes(rgpwzAttrNames, 1, &pAttrs, &cAttrs);

    if (FAILED(hr))
    {
        // Display an error.
        return TRUE;
    }

    if (cAttrs == 1 && pAttrs->dwNumValues > 0)
    {
        // Display the value.
        //
        SetWindowText(GetDlgItem (m_hPage, IDC_SPENDING_EDIT), 
                      pAttrs->pADsValues->CaseIgnoreString);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::OnNotify
//
//  Sysnopsis:  Handles notification messages
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPage::OnNotify(UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (((LPNMHDR)lParam)->code)
    {
    case PSN_APPLY:

        if (!m_fPageDirty)
        {
            return PSNRET_NOERROR;
        }
		{
	    	LRESULT lResult = OnApply();
		    // Store the result into the dialog
    		SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, lResult);
		}
		return TRUE;

    case PSN_RESET:
        return FALSE; // allow the property sheet to be destroyed.

    case PSN_SETACTIVE:
        return OnPSNSetActive(lParam);

    case PSN_KILLACTIVE:
        return OnPSNKillActive(lParam);
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::OnCommand
//
//  Sysnopsis:  Handles the WM_COMMAND message
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPage::OnCommand(int id, HWND hwndCtl, UINT codeNotify)
{
    if ((codeNotify == EN_CHANGE) && !m_fInInit)
    {
        SetDirty();
    }
    if ((codeNotify == BN_CLICKED) && (id == IDCANCEL))
    {
        //
        // Pressing ESC in a multi-line edit control results in this
        // WM_COMMAND being sent. Pass it on to the parent (the sheet proc) to
        // close the sheet.
        //
        PostMessage(GetParent(m_hPage), WM_COMMAND, MAKEWPARAM(id, codeNotify),
                    (LPARAM)hwndCtl);
    }
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::OnApply
//
//  Sysnopsis:  Handles the  PSN_APPLY notification message
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPage::OnApply()
{
    HRESULT hr = S_OK;
    DWORD cModified;
    ADS_ATTR_INFO aAttrs[1];
    PADS_ATTR_INFO pAttrs = aAttrs;
    WCHAR wzEdit[MAX_PATH];
    UINT cch;
    ADSVALUE Value;
    PWSTR rgpwzAttrNames[] = {wzSpendingLimit};

    cch = GetDlgItemText(m_hPage, IDC_SPENDING_EDIT, wzEdit, MAX_PATH);

    pAttrs[0].dwADsType = ADSTYPE_CASE_IGNORE_STRING;
    pAttrs[0].pszAttrName = rgpwzAttrNames[0];

    if (cch > 0)
    {
        Value.dwType = ADSTYPE_CASE_IGNORE_STRING;
        Value.CaseIgnoreString = wzEdit;
        pAttrs[0].pADsValues = &Value;
        pAttrs[0].dwNumValues = 1;
        pAttrs[0].dwControlCode = ADS_ATTR_UPDATE;
    }
    else
    {
        pAttrs[0].pADsValues = NULL;
        pAttrs[0].dwNumValues = 0;
        pAttrs[0].dwControlCode = ADS_ATTR_CLEAR;
    }

    //
    // Write the changes.
    //
    hr = m_pDsObj->SetObjectAttributes(pAttrs, 1, &cModified);

    //
    // NOTIFY_OBJ
    // Signal the change notification. Note that the notify-apply
    // message must be sent even if the page is not dirty so that the
    // notify ref-counting will properly decrement.
    //
    SendMessage(m_hNotifyObj, WM_ADSPROP_NOTIFY_APPLY, TRUE, 0);

    m_fPageDirty = FALSE;

    return FALSE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::OnPSNSetActive
//
//  Sysnopsis:  Page activation event.
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPage::OnPSNSetActive(LPARAM lParam)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::OnPSNKillActive
//
//  Sysnopsis:  Page deactivation event (when other pages cover this one).
//
//-----------------------------------------------------------------------------
LRESULT
CDsPropPage::OnPSNKillActive(LPARAM lParam)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CDsPropPage::PageCallback
//
//  Sysnopsis:  Callback used to free the CDsPropPage object when the
//              property sheet has been destroyed.
//
//-----------------------------------------------------------------------------
UINT CALLBACK
CDsPropPage::PageCallback(HWND hDlg, UINT uMsg, LPPROPSHEETPAGE ppsp)
{

    if (uMsg == PSPCB_RELEASE)
    {
        //
        // Determine instance that invoked this static function
        //
        CDsPropPage * pPage = (CDsPropPage *) ppsp->lParam;

        if (IsWindow(pPage->m_hNotifyObj))
        {
            //
            // NOTIFY_OBJ
            // Tell the notification object to shut down.
            //
            SendMessage(pPage->m_hNotifyObj, WM_ADSPROP_NOTIFY_EXIT, 0, 0);
        }

        delete pPage;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\sample\page.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Active Directory Property Page Sample
//
//  The code contained in this source file is for demonstration purposes only.
//  No warrantee is expressed or implied and Microsoft disclaims all liability
//  for the consequenses of the use of this source code.
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       page.h
//
//  Contents:   Active Directory object property page sample class header
//
//  Classes:    CDsPropPageHost, CDsPropPageHostCF, CDsPropPage
//
//  History:    8-Sep-97 Eric Brown created
//
//  This code produces a dynlink library called proppage.dll. It adds a new
//  property page to an Active Directory object class for a new attribute
//  called Spending-Limit (LDAP display name: spendingLimit). To use this DLL,
//  you need to modify the Display Specifier for the class of interest by
//  adding the following value:
//  10,{cca62184-294f-11d1-bcfe-00c04fd8d5b6}
//  to the adminPropertyPages attribute. Then run regsvr32 proppage.dll. You
//  also need to modify the schema by creating the string attribute
//  Spending-Limit and adding it to the May-Contain list for the class. Now
//  start Active Directory Manager and open properties on an object of the
//  applicable class and you should see the new property page.
//
//-----------------------------------------------------------------------------

#ifndef _PAGE_H_
#define _PAGE_H_

#include <windows.h>
#include <ole2.h>
#include <activeds.h>
#include <shlobj.h> // needed for dsclient.h
#include <dsclient.h>
#include <adsprop.h>
#include "resource.h"


extern HINSTANCE g_hInstance;
extern CLIPFORMAT g_cfDsObjectNames;
extern const CLSID CLSID_SamplePage;

#define ByteOffset(base, offset) (((LPBYTE)base)+offset)

//
// a couple of helper classes for dll ref. counting.
//
class CDll
{
public:

    static ULONG AddRef() { return InterlockedIncrement((LONG*)&s_cObjs); }
    static ULONG Release() { return InterlockedDecrement((LONG*)&s_cObjs); }

    static void LockServer(BOOL fLock) {
        (fLock == TRUE) ? InterlockedIncrement((LONG*)&s_cLocks)
                        : InterlockedDecrement((LONG*)&s_cLocks);
    }

    static HRESULT CanUnloadNow(void) {
        return (0L == s_cObjs && 0L == s_cLocks) ? S_OK : S_FALSE;
    }

    static ULONG s_cObjs;
    static ULONG s_cLocks;

};  // class CDll


class CDllRef
{
public:

    CDllRef(void) { CDll::AddRef(); }
    ~CDllRef(void) { CDll::Release(); }

}; // class CDllRef


//+----------------------------------------------------------------------------
//
//  Class:      CDsPropPageHost
//
//  Purpose:    Property pages host object class. This is the COM object that
//              creates the property page(s).
//
//-----------------------------------------------------------------------------
class CDsPropPageHost : public IShellExtInit, IShellPropSheetExt
{
public:
   CDsPropPageHost();
    ~CDsPropPageHost();

    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    // IShellExtInit methods
    //
    STDMETHOD(Initialize)(LPCITEMIDLIST pIDFolder, LPDATAOBJECT pDataObj,
                          HKEY hKeyID );

    //
    // IShellPropSheetExt methods
    //
    STDMETHOD(AddPages)(LPFNADDPROPSHEETPAGE pAddPageProc, LPARAM lParam);
    STDMETHOD(ReplacePage)(UINT uPageID, LPFNADDPROPSHEETPAGE pReplacePageFunc,
                           LPARAM lParam);

private:

    LPDATAOBJECT        m_pDataObj;
    unsigned long       m_uRefs;
    CDllRef             m_DllRef;
};

//+----------------------------------------------------------------------------
//
//  Class:      CDsPropPageHostCF
//
//  Purpose:    object class factory
//
//-----------------------------------------------------------------------------
class CDsPropPageHostCF : public IClassFactory
{
public:
    CDsPropPageHostCF();
    ~CDsPropPageHostCF();

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IClassFactory methods
    STDMETHOD(CreateInstance)(IUnknown * pUnkOuter, REFIID riid,
                              void ** ppvObject);
    STDMETHOD(LockServer)(BOOL fLock);

    static IClassFactory * Create(void);

private:

    unsigned long   m_uRefs;
    CDllRef         m_DllRef;
};

//
//  static wind proc
//
static LRESULT CALLBACK StaticDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam,
                            LPARAM lParam);

//+----------------------------------------------------------------------------
//
//  Class:      CDsPropPage
//
//  Purpose:    property page object class
//
//-----------------------------------------------------------------------------
class CDsPropPage
{
public:

    CDsPropPage(HWND hNotifyObj);
    ~CDsPropPage(void);

    HRESULT Init(PWSTR pwzObjName, PWSTR pwzClass);
    HRESULT CreatePage(HPROPSHEETPAGE * phPage);
    void    SetDirty(void) {
                PropSheet_Changed(GetParent(m_hPage), m_hPage);
                m_fPageDirty = TRUE;
            };

    static  UINT CALLBACK PageCallback(HWND hwnd, UINT uMsg,
                                       LPPROPSHEETPAGE ppsp);

    //
    //  Member functions, called by WndProc
    //
    LRESULT OnInitDialog(LPARAM lParam);
    LRESULT OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    LRESULT OnNotify(UINT uMessage, WPARAM wParam, LPARAM lParam);
    LRESULT OnApply(void);
    LRESULT OnPSMQuerySibling(WPARAM wParam, LPARAM lParam);
    LRESULT OnPSNSetActive(LPARAM lParam);
    LRESULT OnPSNKillActive(LPARAM lParam);

    //
    //  Data members
    //
    HWND                m_hPage;
    IDirectoryObject *  m_pDsObj;
    BOOL                m_fInInit;
    BOOL                m_fPageDirty;
    PWSTR               m_pwzObjPathName;
    PWSTR               m_pwzObjClass;
    PWSTR               m_pwzRDName;
    HWND                m_hNotifyObj;
    PADS_ATTR_INFO      m_pWritableAttrs;
    CDllRef             m_DllRef;
    HRESULT             m_hrInit;
};

#endif // _PAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\sample\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by page.rc
//
#define IDS_PAGE_TITLE                  1
#define IDD_SAMPLE_PAGE                 101
#define IDC_SPENDING_EDIT               1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\shell\computer.h ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       computer.h
//
//  Contents:   DS computer object property pages header
//
//  History:    07-July-97 EricB created
//
//-----------------------------------------------------------------------------

#ifndef _COMPUTER_H_
#define _COMPUTER_H_

HRESULT
ShComputerRole(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp);

#endif // _COMPUTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\shell\computer.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       computer.cxx
//
//  Contents:   Computer object functionality.
//
//  History:    07-July-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "computer.h"

//+----------------------------------------------------------------------------
//
//  Function:   ShComputerRole
//
//  Synopsis:   Handles the computer Role value for the shell computer general
//              page.
//
//-----------------------------------------------------------------------------
HRESULT
ShComputerRole(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
             PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA,
             DLG_OP DlgOp)
{
    TRACE_FUNCTION(ComputerRole);

    if (DlgOp != fInit)
    {
        return S_OK;
    }
    //
    // Set the computer role value.
    //
    PTSTR ptz;

    int id = IDS_ROLE_WKS;  // UF_WORKSTATION_TRUST_ACCOUNT

    if (pAttrInfo && pAttrInfo->dwNumValues && pAttrInfo->pADsValues &&
        (pAttrInfo->pADsValues->Integer & UF_SERVER_TRUST_ACCOUNT))
    {
        id = IDS_ROLE_SVR;
    }

    if (!LoadStringToTchar(id, &ptz))
    {
        REPORT_ERROR(E_OUTOFMEMORY, pPage->GetHWnd());
        return E_OUTOFMEMORY;
    }

    SetDlgItemText(pPage->GetHWnd(), pAttrMap->nCtrlID, ptz);

    delete ptz;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\shell\dllmisc.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       dllmisc.cxx
//
//  Contents:   DS property pages class objects handler DLL fcn strings.
//
//  History:    21-Mar-97 EricB created
//              25-Mar-01 EricB split out shell version for dsprop.dll.
//
//-----------------------------------------------------------------------------

#include "pch.h"

TCHAR const c_szDsProppagesProgID[] = TEXT("DsPropertyPages.");
TCHAR const c_szDsProppagesDllName[] = TEXT("dsprop.dll");

#include "misc.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\shell\guids.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       guids.cxx
//
//  Contents:   guid allocations - guids are defined in propuuid.h
//
//  History:    21-March-97 EricB created
//
//-----------------------------------------------------------------------------

#include "pch.h"

// initguid.h requires this.
//
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>

#include <shluuid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\shell\shlprop.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:       shlprop.cxx
//
//  Contents:   Tables for table-driven Shell DS property pages
//
//  History:    14-July-97 Jimharr created from dsprop.cxx by ericb
//
//  Note:       Attribute LDAP display names, types, upper ranges, and so
//              forth, have been manually copied from schema.ini. Thus,
//              consistency is going to be difficult to maintain. If you know
//              of schema.ini changes that affect any of the attributes in
//              this file, then please make any necessary corrections here.
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "user.h"
#include "group.h"
#include "computer.h"
#include "pages.hm" // HIDC_*
#include <ntdsadef.h>

#include "dsprop.cxx"

HRESULT
ROList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
       LPARAM lParam, PATTR_DATA pAttrData, DLG_OP DlgOp);

#define NT_GROUP_PAGE

#ifdef NT_GROUP_PAGE
HRESULT
BmpPictureCtrl(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM lParam, PATTR_DATA pAttrData,
               DLG_OP DlgOp);

INT_PTR CALLBACK
PictureDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

//+----------------------------------------------------------------------------
//
//  Class:      CBmpPicCtrl
//
//  Purpose:    Picture control sub-class window proc for displaying bitmaps.
//
//-----------------------------------------------------------------------------
class CBmpPicCtrl
{
public:
#ifdef _DEBUG
    char szClass[32];
#endif

    CBmpPicCtrl(HWND hCtrl, PBYTE pb);
    ~CBmpPicCtrl(void);

    //
    //  Static WndProc to be passed as subclass address.
    //
    static LRESULT CALLBACK StaticCtrlProc(HWND hWnd, UINT uMsg,
                                       WPARAM wParam, LPARAM lParam);
    //
    //  Member functions, called by WndProc
    //
    LRESULT OnPaint(void);

    HRESULT CreateBmpPalette(void);
    //
    //  Data members
    //

protected:
    HWND                m_hCtrl;
    HWND                m_hDlg;
    WNDPROC             m_pOldProc;
    PBYTE               m_pbBmp;
    HPALETTE            m_hPal;
};

#endif // NT_GROUP_PAGE

//+----------------------------------------------------------------------------
// User Object.
//-----------------------------------------------------------------------------

//
// General page, first name
//
ATTR_MAP USGFirstName = {IDC_SH_FIRST_NAME_EDIT, FALSE, FALSE, 64,
                         {L"givenName", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, last name
//
ATTR_MAP USGLastName = {IDC_SH_LAST_NAME_EDIT, FALSE, FALSE, 64,
                       {L"sn", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                        NULL, 0}, NULL, NULL};
//
// General page, friendly name
//
ATTR_MAP USGFriendlyName = {IDC_SH_DISPLAY_NAME_EDIT, FALSE, FALSE,
                            ATTR_LEN_UNLIMITED, {L"displayName",
                            ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                            NULL, 0}, NULL, NULL};
//
// General page, phone number
//
ATTR_MAP USGPhone = {IDC_PHONE_EDIT, FALSE, FALSE, 32,
                    {L"telephoneNumber", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// General page, email
//
ATTR_MAP USGEMail = {IDC_EMAIL_EDIT, FALSE, FALSE, 256,
                    {L"mail", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                     NULL, 0}, NULL, NULL};
//
// General page, URL
//
ATTR_MAP USGURL = {IDC_URL_EDIT, FALSE, FALSE, 2048,
                  {L"wWWHomePage", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING, NULL,
                   0}, NULL, NULL};
//
// The list of attributes on the User General page.
//
PATTR_MAP rgpUSGAttrMap[] = {{&GenIcon}, {&AttrName}, {&USGFirstName},
                             {&USGLastName}, {&USGFriendlyName},
                             {&USGPhone}, {&USGEMail}, {&USGURL}};
//--------------------------------------------------------
// Business page, title
//
ATTR_MAP USBTitle = {IDC_TITLE, FALSE, FALSE, ATTR_LEN_UNLIMITED,
                     {L"title", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                      NULL, 0}, NULL, NULL};
//
// Business page, Company
//
ATTR_MAP USBCo = {IDC_COMPANY, FALSE, FALSE, 64,
                  {L"company", ADS_ATTR_UPDATE,
                   ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Business page, Department
//
ATTR_MAP USBDept = {IDC_DEPARTMENT, FALSE, FALSE, 64,
                    {L"department", ADS_ATTR_UPDATE,
                     ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Business page, office
//
ATTR_MAP USBOffice = {IDC_OFFICE, FALSE, FALSE, 128,
                     {L"physicalDeliveryOfficeName", ADS_ATTR_UPDATE,
                      ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Business page, Manager
//
ATTR_MAP USBMgr = {IDC_MANAGER, TRUE, FALSE, ATTR_LEN_UNLIMITED,
                   {L"manager", ADS_ATTR_UPDATE,
                    ADSTYPE_DN_STRING, NULL, 0}, ManagerEdit, NULL};
//
// Business page, direct reports
//
ATTR_MAP USBReports = {IDC_REPORTS_LIST, TRUE, TRUE, 0,
                       {L"directReports", ADS_ATTR_UPDATE,
                        ADSTYPE_DN_STRING, NULL, 0}, DirectReportsList, NULL};
//
// The list of attributes on the User Business page.
//
PATTR_MAP rgpUSBAttrMap[] = {{&USBTitle}, {&USBCo}, {&USBDept}, {&USBOffice},
                             {&USBMgr}, {&USBReports}};

//
// The User General page description.
//
DSPAGE ShellUserGeneral = {IDS_TITLE_GENERAL, IDD_SHELL_USER_GEN, 0, 0, NULL,
                           CreateTableDrivenPage,
                           sizeof(rgpUSGAttrMap)/sizeof(PATTR_MAP), rgpUSGAttrMap};

//
// The User Business page description.
//
DSPAGE ShellUserBusiness = {IDS_TITLE_BUSINESS, IDD_SHELL_BUSINESS, 0, 0, NULL,
                            CreateTableDrivenPage,
                            sizeof(rgpUSBAttrMap)/sizeof(PATTR_MAP), rgpUSBAttrMap};

#ifdef NT_GROUP_PAGE
//----------------------------------------------
// Special User page, Home phone primary/other
//
ATTR_MAP USpecHomePhone = {IDC_HOMEPHONE_EDIT, FALSE, FALSE, 64,
                           {L"homePhone", ADS_ATTR_UPDATE,
                            ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};

ATTR_MAP USpecHomeOther = {IDC_OTHER_HOME_BTN, FALSE, TRUE, 64,
                         {L"otherHomePhone", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Special page, Pager
//
ATTR_MAP USpecPager = {IDC_PAGER_EDIT, FALSE, FALSE, 64,
                     {L"pager", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                      NULL, 0}, NULL, NULL};

ATTR_MAP USpecOtherPager = {IDC_OTHER_PAGER_BTN, FALSE, TRUE, 64,
                          {L"otherPager", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Special page, Mobile
//
ATTR_MAP USpecMobile = {IDC_MOBILE_EDIT, FALSE, FALSE, 64,
                      {L"mobile", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                       NULL, 0}, NULL, NULL};

ATTR_MAP USpecOtherMobile = {IDC_OTHER_MOBLE_BTN, FALSE, TRUE, 64,
                          {L"otherMobile", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Special page, user's home page
//
ATTR_MAP USpecURL = {IDC_HOME_PAGE_EDIT, FALSE, FALSE, 2048,
                  {L"wWWHomePage", ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                   NULL, 0}, NULL, NULL};
//
// Special page, other home pages
//
ATTR_MAP USpecOtherURL = {IDC_OTHER_URL_BTN, FALSE, TRUE, 2048,
                       {L"url", ADS_ATTR_UPDATE,
                       ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, OtherValuesBtn, NULL};
//
// Special page, Address
//
ATTR_MAP USpecAddress = {IDC_ADDRESS_EDIT, FALSE, FALSE, 1024,
                         {L"homePostalAddress", ADS_ATTR_UPDATE,
                          ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL, NULL};
//
// Special page, Picture
//
ATTR_MAP USpecPicture = {IDC_PICTURE_BMP, TRUE, FALSE, 0,
                         {L"thumbnailPhoto", ADS_ATTR_UPDATE,
                          ADSTYPE_OCTET_STRING, NULL, 0}, BmpPictureCtrl, NULL};

//
// The list of attributes on the User Special page.
//
PATTR_MAP rgpUSpecAttrMap[] = {{&USpecHomePhone}, {&USpecHomeOther}, {&USpecPager},
                               {&USpecOtherPager}, {&USpecMobile}, {&USpecOtherMobile},
                               {&USpecURL}, {&USpecOtherURL}, {&USpecAddress},
                               {&USpecPicture}};
//
// The Special page description.
//
DSPAGE NTGroup = {IDS_NT_GRP_TITLE, IDD_NT_GROUP, 0, 0, NULL,
                  CreateTableDrivenPage,
                  sizeof(rgpUSpecAttrMap)/sizeof(PATTR_MAP),
                  rgpUSpecAttrMap};

//----------------------------------------------
// The list of Special pages.
//
PDSPAGE rgShellUSpecPages[] = {{&NTGroup}};

//
// The User Special class description.
//
DSCLASSPAGES ShellUSpecCls = {&CLSID_SpecialUserInfo, TEXT("User Special Info"),
                              sizeof(rgShellUSpecPages)/sizeof(PDSPAGE),
                              rgShellUSpecPages};
#endif // NT_GROUP_PAGE

//----------------------------------------------
// The list of User pages.
//
PDSPAGE rgShellUserPages[] = {{&ShellUserGeneral}, {&UserAddress}, {&ShellUserBusiness}};

//
// The User class description.
//
DSCLASSPAGES ShellUserCls = {&CLSID_DsShellUserPropPages, TEXT("User"),
                             sizeof(rgShellUserPages)/sizeof(PDSPAGE),
                             rgShellUserPages};


//-------------------------------------------------------
// Contact object
//-------------------------------------------------------
//
// The list of Contact pages.
//
PDSPAGE rgShellContactPages[] = {{&ShellUserGeneral}, {&ShellUserBusiness}};
//
// The Contact class description.
//
DSCLASSPAGES ShellContactCls = {&CLSID_DsShellContactPropPages, TEXT("Contact"),
                                sizeof(rgShellContactPages)/sizeof(PDSPAGE),
                                rgShellContactPages};

//-------------------------------------------------------
// Volume object
//-------------------------------------------------------

//
// Volume page, path
//
ATTR_MAP VSPath = {IDC_PATH, FALSE, FALSE,
                   ATTR_LEN_UNLIMITED, {L"uNCName",
                   ADS_ATTR_UPDATE, ADSTYPE_CASE_IGNORE_STRING,
                   NULL, 0}, NULL, NULL};
ATTR_MAP VolKey = {IDC_KEYWORDS_LIST, TRUE, TRUE, 0,
                   {L"keywords", ADS_ATTR_UPDATE,
                    ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, ROList, NULL};

//
// The list of attributes on the Volume General page.
//
PATTR_MAP rgpVSAttrMap[] = {{&GenIcon}, {&AttrName}, {&Description}, {&VSPath}, {&VolKey}};

//
// The Volume  General page description.
//
DSPAGE ShellVolumeGeneral = {IDS_TITLE_GENERAL, IDD_SHELL_VOLUME_GEN, 0, 0, NULL,
                             CreateTableDrivenPage,
                             sizeof(rgpVSAttrMap)/sizeof(PATTR_MAP),
                             rgpVSAttrMap};

//----------------------------------------------
// The list of Volume pages.
//
PDSPAGE rgShellVolumePages[] = {{&ShellVolumeGeneral}};

//
// The Volume class description.
//
DSCLASSPAGES ShellVolumeCls = {&CLSID_DsShellVolumePropPages, TEXT("Volume"),
                               sizeof(rgShellVolumePages)/sizeof(PDSPAGE),
                               rgShellVolumePages};

//
//-----------------------------------------------
// computer object
//----------------------------------------------
//
// Computer General page, Network Address.
//
//ATTR_MAP CSComputerNetAddr = {IDC_NET_ADDR_EDIT, FALSE, FALSE, 256,
//                              {L"networkAddress", ADS_ATTR_UPDATE,
//                              ADSTYPE_CASE_IGNORE_STRING, NULL, 0}, NULL};
//
// Computer General page, Role.
//
ATTR_MAP CSComputerRoleAttr = {IDC_ROLE, TRUE, FALSE, 260,
                               {g_wzUserAccountControl, ADS_ATTR_UPDATE,
                               ADSTYPE_INTEGER, NULL, 0}, ShComputerRole, NULL};

//
// The list of attributes on the Computer General page.
//
PATTR_MAP rgpCSAttrMap[] = {{&GenIcon}, {&AttrName},
                            {&Description}, // {&CSComputerNetAddr},
                            {&CSComputerRoleAttr}};
//
// The Computer General page description.
//
DSPAGE ShellComputerGeneral = {IDS_TITLE_GENERAL, IDD_SHELL_COMPUTER_GEN, 0, 0, NULL,
                               CreateTableDrivenPage,
                               sizeof(rgpCSAttrMap)/sizeof(PATTR_MAP),
                               rgpCSAttrMap};
//----------------------------------------------
// The list of Computer pages.
//
PDSPAGE rgShellComputerPages[] = {{&ShellComputerGeneral}};

//
// The Computer class description.
//
DSCLASSPAGES ShellComputerCls = {&CLSID_DsShellComputerPropPages, TEXT("Computer"),
                                 sizeof(rgShellComputerPages)/sizeof(PDSPAGE),
                                 rgShellComputerPages};

//----------------------------------------------
// Domain object
//----------------------------------------------

//
// The list of attributes on the General page.
//
PATTR_MAP rgpDSAttrMap[] = {{&GenIcon}, {&AttrName},
                            {&Description}};
//
// The Computer General page description.
//
DSPAGE ShellDomainGeneral = {IDS_TITLE_GENERAL, IDD_SHELL_DOMAIN_GEN, 0, 0, NULL,
                             CreateTableDrivenPage,
                             sizeof(rgpDSAttrMap)/sizeof(PATTR_MAP),
                             rgpDSAttrMap};
//----------------------------------------------
// The list of Domain pages.
//
PDSPAGE rgShellDomainPages[] = {{&ShellDomainGeneral}};

//
// The Domain class description.
//
DSCLASSPAGES ShellDomainCls = {&CLSID_DsShellDomainPropPages, TEXT("Domain"),
                             sizeof(rgShellDomainPages)/sizeof(PDSPAGE),
                             rgShellDomainPages};

//----------------------------------------------
// OU object
//----------------------------------------------

//
// The list of attributes on the OU General page.
//
PATTR_MAP rgpOSAttrMap[] = {{&GenIcon}, {&AttrName},
                            {&Description}};
//
// The OU General page description.
//
DSPAGE ShellOUGeneral = {IDS_TITLE_GENERAL, IDD_SHELL_DOMAIN_GEN, 0, 0, NULL,
                             CreateTableDrivenPage,
                             sizeof(rgpOSAttrMap)/sizeof(PATTR_MAP),
                             rgpOSAttrMap};
//----------------------------------------------
// The list of OU pages.
//
PDSPAGE rgShellOUPages[] = {{&ShellOUGeneral}};

//
// The OU class description.
//
DSCLASSPAGES ShellOUCls = {&CLSID_DsShellOUPropPages, TEXT("OU"),
                             sizeof(rgShellOUPages)/sizeof(PDSPAGE),
                             rgShellOUPages};

//----------------------------------------------
// Group object
//----------------------------------------------

//
// The Group General page description.
//
DSPAGE ShellGroupGeneral = {IDS_TITLE_GENERAL, IDD_SHELL_GROUP_GEN, 0, 0, NULL,
                            CreateGrpShlGenPage, 0, NULL};

//----------------------------------------------
// The list of Group pages.
//
PDSPAGE rgShellGroupPages[] = {{&ShellGroupGeneral}};

//
// The Group class description.
//
DSCLASSPAGES ShellGroupCls = {&CLSID_DsShellGroupPropPages, TEXT("Group"),
                              sizeof(rgShellGroupPages)/sizeof(PDSPAGE),
                              rgShellGroupPages};

#ifdef NT_GROUP_PAGE

//+----------------------------------------------------------------------------
//
//  Function:   BmpPictureCtrl
//
//  Synopsis:   Fetches the bitmap from the user object Picture attribute
//              and draws it on the page.
//
//-----------------------------------------------------------------------------
HRESULT
BmpPictureCtrl(CDsPropPageBase * pPage, PATTR_MAP pAttrMap,
               PADS_ATTR_INFO pAttrInfo, LPARAM, PATTR_DATA pAttrData,
               DLG_OP DlgOp)
{
    HWND hPicCtrl;
    PBYTE pb;
    CBmpPicCtrl * pPicCtrlObj;

    switch (DlgOp)
    {
    case fInit:
        pAttrData->pVoid = NULL;

        if (pAttrInfo == NULL)
        {
            return S_OK;
        }
        hPicCtrl = GetDlgItem(pPage->GetHWnd(), pAttrMap->nCtrlID);

        dspAssert(pAttrInfo->pADsValues != NULL);
        dspAssert(pAttrInfo->dwADsType == ADSTYPE_OCTET_STRING);
        dspAssert(pAttrInfo->dwNumValues == 1);
        dspAssert(pAttrInfo->pADsValues->dwType == ADSTYPE_OCTET_STRING);

        dspAssert(pAttrInfo->pADsValues->OctetString.dwLength > 0);
        dspAssert(pAttrInfo->pADsValues->OctetString.lpValue != NULL);

        //
        // Enforce the maximum size.
        //
        pb = pAttrInfo->pADsValues->OctetString.lpValue;

        PBITMAPINFO pBmpInfo;

        pBmpInfo = (PBITMAPINFO)((PBYTE)pb + sizeof(BITMAPFILEHEADER));

        dspDebugOut((DEB_ITRACE, "Bitmap size: (%d, %d)\n",
                     pBmpInfo->bmiHeader.biWidth, pBmpInfo->bmiHeader.biHeight));
#define MAX_PIC_SIZE 100
        if ((pBmpInfo->bmiHeader.biWidth > MAX_PIC_SIZE) ||
            (pBmpInfo->bmiHeader.biHeight > MAX_PIC_SIZE))
        {
            LONG_PTR lStyle = GetWindowLongPtr(hPicCtrl, GWL_STYLE);
            lStyle &= ~(SS_BITMAP);
            lStyle |= SS_LEFT;
            SetWindowLongPtr(hPicCtrl, GWL_STYLE, lStyle);
            TCHAR szMsg[200];
            wsprintf(szMsg, TEXT("Bitmap is too large (%d, %d)!"),
                     pBmpInfo->bmiHeader.biWidth, pBmpInfo->bmiHeader.biHeight);
            SetWindowText(hPicCtrl, szMsg);
            dspDebugOut((DEB_ITRACE, "Bitmap too large! (%d, %d) max allowed.\n",
                         MAX_PIC_SIZE, MAX_PIC_SIZE));
            return S_OK;
        }

        //
        // Save the bitmap.
        //
        pb = (PBYTE)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                pAttrInfo->pADsValues->OctetString.dwLength);

        CHECK_NULL_REPORT(pb, pPage->GetHWnd(), return E_OUTOFMEMORY);

        memcpy(pb, pAttrInfo->pADsValues->OctetString.lpValue,
               pAttrInfo->pADsValues->OctetString.dwLength);
        //
        // Subclass the picture "static" control.
        //
        pPicCtrlObj = new CBmpPicCtrl(hPicCtrl, pb);

        CHECK_NULL_REPORT(pPicCtrlObj, pPage->GetHWnd(), return E_OUTOFMEMORY);

        pAttrData->pVoid = reinterpret_cast<LPARAM>(pPicCtrlObj);

        break;

    case fOnDestroy:
        pPicCtrlObj = reinterpret_cast<CBmpPicCtrl*>(pAttrData->pVoid);
        DO_DEL(pPicCtrlObj);
        break;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Class:      CBmpPicCtrl
//
//  Synopsis:   Icon control window subclass object, so we can paint a class-
//              specific icon.
//
//-----------------------------------------------------------------------------
CBmpPicCtrl::CBmpPicCtrl(HWND hCtrl, PBYTE pb) :
    m_hCtrl(hCtrl),
    m_pbBmp(pb),
    m_pOldProc(NULL),
    m_hPal(NULL)
{
#ifdef _DEBUG
    strcpy(szClass, "CBmpPicCtrl");
#endif
    SetWindowLongPtr(hCtrl, GWLP_USERDATA, (LONG_PTR)this);
    m_pOldProc = (WNDPROC)SetWindowLongPtr(hCtrl, GWLP_WNDPROC, (LONG_PTR)StaticCtrlProc);
    m_hDlg = GetParent(hCtrl);
}

CBmpPicCtrl::~CBmpPicCtrl(void)
{
    SetWindowLongPtr(m_hCtrl, GWLP_WNDPROC, (LONG_PTR)m_pOldProc);
    if (m_pbBmp)
    {
        GlobalFree(m_pbBmp);
    }
    if (m_hPal)
    {
        DeleteObject(m_hPal);
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CBmpPicCtrl::StaticCtrlProc
//
//  Synopsis:   control sub-proc
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CBmpPicCtrl::StaticCtrlProc(HWND hCtrl, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;
    HDC hDC;
    HPALETTE hOldPal;
    UINT iChanged = 0;
    CBmpPicCtrl * pCCtrl = (CBmpPicCtrl*)GetWindowLongPtr(hCtrl, GWLP_USERDATA);

    dspAssert(pCCtrl != NULL);

    switch (uMsg)
    {
    case WM_PALETTECHANGED:
        if ((HWND)wParam == hCtrl)
        {
            break;
        }
        // Fall through:
    case WM_QUERYNEWPALETTE:
        dspDebugOut((DEB_ITRACE, "Got palette message.\n"));
        if (pCCtrl->m_hPal == NULL)
        {
            hr = pCCtrl->CreateBmpPalette();

            CHECK_HRESULT(hr, return FALSE);
        }
        hDC = GetDC(hCtrl);
        if (hDC != NULL)
        {
          hOldPal = SelectPalette(hDC, pCCtrl->m_hPal, FALSE);
          iChanged = RealizePalette(hDC);
          SelectPalette(hDC, hOldPal, TRUE);
          RealizePalette(hDC);
          ReleaseDC(hCtrl, hDC);
          if (iChanged > 0 && iChanged != GDI_ERROR)
          {
              InvalidateRect(hCtrl, NULL, TRUE);
          }
        }
        return(iChanged);        

    case WM_PAINT:
        if (!pCCtrl->OnPaint())
        {
            return FALSE;
        }
        break;

    default:
        break;
    }

    return CallWindowProc(pCCtrl->m_pOldProc, hCtrl, uMsg, wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CBmpPicCtrl::OnPaint
//
//  Synopsis:   Paint the DS specified icon.
//
//-----------------------------------------------------------------------------
LRESULT
CBmpPicCtrl::OnPaint(void)
{
    TRACE(CBmpPicCtrl,OnPaint);
    HRESULT hr = S_OK;
    HDC hDC = NULL;
    PAINTSTRUCT ps;
    HPALETTE hOldPal = NULL;

    if (m_hPal == NULL)
    {
        hr = CreateBmpPalette();
        CHECK_HRESULT(hr, return FALSE);
    }

    hDC = BeginPaint(m_hCtrl, &ps);

    CHECK_NULL_REPORT(hDC, m_hDlg, return FALSE);

    if (m_hPal)
    {
        hOldPal = SelectPalette(hDC, m_hPal, FALSE);
        RealizePalette(hDC);
    }

    dspAssert(m_pbBmp != NULL);

    PBITMAPFILEHEADER pBmpFileHdr = (PBITMAPFILEHEADER)m_pbBmp;

    // Advance past the BITMAPFILEHEADER struct.
    //
    PBITMAPINFO pBmpInfo = (PBITMAPINFO)(m_pbBmp + sizeof(BITMAPFILEHEADER));

    if (SetDIBitsToDevice(hDC,
                          0, 0,
                          pBmpInfo->bmiHeader.biWidth,
                          pBmpInfo->bmiHeader.biHeight,
                          0, 0, 0,
                          pBmpInfo->bmiHeader.biHeight,
                          m_pbBmp + pBmpFileHdr->bfOffBits,
                          pBmpInfo,
                          DIB_RGB_COLORS) == 0)
    {
        REPORT_ERROR(GetLastError(), m_hDlg);
    }

    if (m_hPal)
    {
        SelectPalette(hDC, hOldPal, TRUE);
    }
    EndPaint(m_hCtrl, &ps);

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   CreateBmpPalette
//
//  Synopsis:   Creates the palette for the bitmap.
//
//-----------------------------------------------------------------------------
HRESULT
CBmpPicCtrl::CreateBmpPalette(void)
{
    TRACE(CBmpPicCtrl,CreateBmpPalette);
    PBITMAPINFO pBmpInfo;

    pBmpInfo = (PBITMAPINFO)(m_pbBmp + sizeof(BITMAPFILEHEADER));

    WORD nColors, cClrBits = pBmpInfo->bmiHeader.biBitCount;

    if (cClrBits == 1)
        cClrBits = 1;
    else if (cClrBits <= 4) 
        cClrBits = 4;
    else if (cClrBits <= 8)
        cClrBits = 8; 
    else if (cClrBits <= 16)
        cClrBits = 16; 
    else if (cClrBits <= 24)
        cClrBits = 24;
    else 
        cClrBits = 32; 

    if (cClrBits >= 24)
    {
        // True color BMPs don't need explicit palettes.
        //
        return S_OK;
    }

    nColors = static_cast<WORD>(1 << cClrBits);

    dspDebugOut((DEB_ITRACE, "Bitmap has %d colors.\n", nColors));

    PLOGPALETTE plp = (PLOGPALETTE)LocalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                              sizeof(LOGPALETTE) +
                                              sizeof (PALETTEENTRY) * nColors);
    
    CHECK_NULL_REPORT(plp, m_hDlg, return E_OUTOFMEMORY);

    plp->palVersion = 0x300;
    plp->palNumEntries = nColors;

    for (WORD i = 0; i < nColors; i++)
    {
        plp->palPalEntry[i].peBlue = pBmpInfo->bmiColors[i].rgbBlue;
        plp->palPalEntry[i].peGreen = pBmpInfo->bmiColors[i].rgbGreen;
        plp->palPalEntry[i].peRed = pBmpInfo->bmiColors[i].rgbRed;
        plp->palPalEntry[i].peFlags = 0; //PC_NOCOLLAPSE;
    }

    m_hPal = CreatePalette(plp);

    if (m_hPal == NULL)
    {
        REPORT_ERROR(GetLastError(), m_hDlg);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    LocalFree(plp);

    return S_OK;
}

#endif // NT_GROUP_PAGE

HRESULT
ROList(CDsPropPageBase * pPage, PATTR_MAP pAttrMap, PADS_ATTR_INFO pAttrInfo,
       LPARAM, PATTR_DATA, DLG_OP DlgOp)
{

    if (DlgOp != fInit)
    {
        return S_OK;
    }
    if (pAttrInfo == NULL)
    {
        return S_OK;
    }
    dspAssert(pAttrInfo->pADsValues != NULL);

    for (DWORD i = 0; i < pAttrInfo->dwNumValues; i++)
    {
        SendDlgItemMessage(pPage->GetHWnd(), pAttrMap->nCtrlID, LB_ADDSTRING, 0,
                           (LPARAM)pAttrInfo->pADsValues[i].CaseIgnoreString);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
// The list of classes.
//-----------------------------------------------------------------------------

PDSCLASSPAGES rgClsPages[] = {
    &ShellComputerCls,
    &ShellVolumeCls,
    &ShellUserCls,
    &ShellContactCls,
    &ShellDomainCls,
    &ShellGroupCls,
    &ShellOUCls,
    &ShellUSpecCls
};


//+----------------------------------------------------------------------------
// The global struct containing the list of classes.
//-----------------------------------------------------------------------------
RGDSPPCLASSES g_DsPPClasses = {sizeof(rgClsPages)/sizeof(PDSCLASSPAGES),
                               rgClsPages};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\display\proppage\shell\notify.cxx ===
//+----------------------------------------------------------------------------
//
//  Windows NT Directory Service Property Pages
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       notify.cxx
//
//  Contents:   Change notification ref-counting object.
//
//  Classes:    CNotifyObj
//
//  History:    20-Jan-98 EricB
//
//-----------------------------------------------------------------------------

#include "pch.h"
#include "proppage.h"
#include "objlist.h"  // g_ClassIconCache

#define NOTIFYOUT(x) dspDebugOut((DEB_ITRACE, "Notify Obj (this: 0x%p) " #x "\n", this));
#define DSPROP_WAITTIME 600000 // wait 600 seconds, 10 minutes.

//+----------------------------------------------------------------------------
//
//  Function:   ADsPropCreateNotifyObj
//
//  Synopsis:   Checks to see if the notification window/object exists for this
//              sheet instance and if not creates it.
//
//  Arguments:  [pAppThdDataObj] - the unmarshalled data object pointer.
//              [pwzADsObjName]  - object path name.
//              [phNotifyObj]    - to return the notificion window handle.
//
//  Returns:    HRESULTs.
//
//-----------------------------------------------------------------------------
STDAPI
ADsPropCreateNotifyObj(LPDATAOBJECT pAppThdDataObj, PWSTR pwzADsObjName,
                       HWND * phNotifyObj)
{
    return CNotifyObj::Create(pAppThdDataObj, pwzADsObjName, phNotifyObj);
}

//+----------------------------------------------------------------------------
//
//  Function:   ADsPropGetInitInfo
//
//  Synopsis:   Pages call this at their init time to retreive DS object info.
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [pInitParams] - struct filled in with DS object info.
//
//  Returns:    FALSE if the notify window has gone away for some reason.
//
//  Note that pInitParams->pWritableAttrs can be NULL if there are no writable
//  attributes.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL)
ADsPropGetInitInfo(HWND hNotifyObj, PADSPROPINITPARAMS pInitParams)
{
    return CNotifyObj::GetInitInfo(hNotifyObj, pInitParams);
}

//+----------------------------------------------------------------------------
//
//  Function:   ADsPropSetHwndWithTitle
//
//  Synopsis:   Pages call this at their dialog init time to send their hwnd
//              to the Notify object. Use this function instead of 
//              ADsPropSetHwnd for multi-select property pages.
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [hPage]       - the page's window handle.
//              [ptzTitle]    - the page's title
//
//  Returns:    FALSE if the notify window has gone away for some reason.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL)
ADsPropSetHwndWithTitle(HWND hNotifyObj, HWND hPage, PTSTR ptzTitle)
{
    return CNotifyObj::SetHwnd(hNotifyObj, hPage, ptzTitle);
}

//+----------------------------------------------------------------------------
//
//  Function:   ADsPropSetHwnd
//
//  Synopsis:   Pages call this at their dialog init time to send their hwnd
//              to the Notify object.
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [hPage]       - the page's window handle.
//
//  Returns:    FALSE if the notify window has gone away for some reason.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL)
ADsPropSetHwnd(HWND hNotifyObj, HWND hPage)
{
   return ADsPropSetHwndWithTitle(hNotifyObj, hPage, 0);
}

//+----------------------------------------------------------------------------
//
//  function:   ADsPropCheckIfWritable
//
//  Synopsis:   See if the attribute is writable by checking if it is in
//              the allowedAttributesEffective array.
//
//  Arguments:  [pwzAttr]        - the attribute name.
//              [pWritableAttrs] - the array of writable attributes.
//
//  Returns:    FALSE if the attribute name is not found in the writable-attrs
//              array or if the array pointer is NULL.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL)
ADsPropCheckIfWritable(const PWSTR pwzAttr, const PADS_ATTR_INFO pWritableAttrs)
{
    BOOL fWritable = FALSE;

    if (!pWritableAttrs || IsBadReadPtr(pWritableAttrs, sizeof(ADS_ATTR_INFO)))
    {
        return FALSE;
    }

    for (DWORD i = 0; i < pWritableAttrs->dwNumValues; i++)
    {
        if (_wcsicmp(pWritableAttrs->pADsValues[i].CaseIgnoreString,
                     pwzAttr) == 0)
        {
            fWritable = TRUE;
            break;
        }
    }
    return fWritable;
}

//+----------------------------------------------------------------------------
//
//  function:   ADsPropSendErrorMessage
//
//  Synopsis:   Adds an error message to a list which is presented when
//              ADsPropShowErrorDialog is called
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [pError]      - the error structure
//
//  Returns:    FALSE if the notify window has gone away for some reason.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL)
ADsPropSendErrorMessage(HWND hNotifyObj, PADSPROPERROR pError)
{
   return SendMessage(hNotifyObj, WM_ADSPROP_NOTIFY_ERROR, 0, (LPARAM)pError) != 0;
}

//+----------------------------------------------------------------------------
//
//  function:   ADsPropShowErrorDialog
//
//  Synopsis:   Presents an error dialog with the error messages accumulated
//              through calls to ADsPropSendErrorMessage
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [hPage]       - the property page window handle.
//
//  Returns:    FALSE if the notify window has gone away for some reason.
//
//-----------------------------------------------------------------------------
STDAPI_(BOOL)
ADsPropShowErrorDialog(HWND hNotifyObj, HWND hPage)
{
#ifdef DSADMIN
  CNotifyObj* pNotifyObj = NULL;

  dspAssert(hNotifyObj);
  if (!IsWindow(hNotifyObj))
  {
    return FALSE;
  }
  LRESULT lResult = SendMessage(hNotifyObj, WM_ADSPROP_NOTIFY_GET_NOTIFY_OBJ, 0,
                                (LPARAM)&pNotifyObj);

  if (lResult && pNotifyObj)
  {
    CMultiSelectErrorDialog dlg(hNotifyObj, hPage);
    
    CPageInfo* pPageInfoArray = pNotifyObj->m_pPageInfoArray;
    UINT cPages = pNotifyObj->m_cPages;
    IDataObject* pDataObject = pNotifyObj->m_pAppThdDataObj;

    dspAssert(pPageInfoArray);
    dspAssert(cPages > 0);
    dspAssert(pDataObject);

    HRESULT hr = dlg.Init(pPageInfoArray, 
                          cPages, 
                          pDataObject);
    if (SUCCEEDED(hr))
    {
      dlg.DoModal();
      SetForegroundWindow(dlg.m_hWnd);

      for (UINT pageIdx = 0; pageIdx < cPages; pageIdx++)
      {
        pPageInfoArray[pageIdx].m_ApplyErrors.Clear();
        pPageInfoArray[pageIdx].m_ApplyStatus = CPageInfo::notAttempted;
      }
    }
  }
#endif
  return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::Create
//
//  Synopsis:   Creation procedure: creates instances of the object.
//
//  Arguments:  [pAppThdDataObj] - the unmarshalled data object pointer.
//              [pwzADsObjName]  - object path name.
//              [phNotifyObj]    - to return the notificion window handle.
//
//  Returns:    HRESULTs.
//
//-----------------------------------------------------------------------------
HRESULT
CNotifyObj::Create(LPDATAOBJECT pAppThdDataObj, PWSTR pwzADsObjName,
                   HWND * phNotifyObj)
{
    HWND hNotify;
    HRESULT hr = S_OK;

    // Only one caller at a time.
    //
    CNotifyCreateCriticalSection NotifyCS;

    //
    // See if the object/window already exist for this property sheet and
    // get the object DN.
    //
    hNotify = FindSheetNoSetFocus(pwzADsObjName);

    if (hNotify != NULL)
    {
        // The window already exists, return the window handle.
        //
        *phNotifyObj = hNotify;
        dspDebugOut((DEB_ITRACE, "CNotifyObj::Create returning existing notify obj HWND.\n"));
        return S_OK;
    }
    dspDebugOut((DEB_ITRACE, "CNotifyObj::Create, creating notify obj.\n"));

    PPROPSHEETCFG pSheetCfg;
    PROPSHEETCFG sheetCfg;
    ZeroMemory(&sheetCfg, sizeof(PROPSHEETCFG));
    STGMEDIUM sm = {TYMED_NULL, NULL, NULL};
    FORMATETC fmte = {g_cfDsPropCfg, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    hr = pAppThdDataObj->GetData(&fmte, &sm);

    if (FAILED(hr))
    {
        if (hr != DV_E_FORMATETC)
        {
            REPORT_ERROR_FORMAT(hr, IDS_NOTIFYFAILURE, GetDesktopWindow());
            return hr;
        }
    }
    else
    {
        pSheetCfg = (PPROPSHEETCFG)sm.hGlobal;

		//NTRAID#NTBUG9-567482-2002/03/10-jmessec    dspAssert simply maps to ASSERT; if sm.hGlobal can be NULL, back it up with code
        dspAssert(pSheetCfg);
        memcpy(&sheetCfg, pSheetCfg, sizeof(PROPSHEETCFG));

        ReleaseStgMedium(&sm);
    }

    //
    // Create the notification object.
    //
    CNotifyObj * pNotifyObj = new CNotifyObj(pAppThdDataObj, &sheetCfg);

    CHECK_NULL_REPORT(pNotifyObj, GetDesktopWindow(), return ERROR_OUTOFMEMORY);

    if (pNotifyObj->m_hr != S_OK)
    {
        REPORT_ERROR_FORMAT(pNotifyObj->m_hr, IDS_NOTIFYFAILURE, GetDesktopWindow());
        return pNotifyObj->m_hr;
    }

    dspDebugOut((DEB_ITRACE, "Notify Obj (this: 0x%p) object allocated, pAppThdDataObj = 0x%08p\n",
                 pNotifyObj, pAppThdDataObj));

    if (!AllocWStr(pwzADsObjName, &pNotifyObj->m_pwzObjDN))
    {
        return E_OUTOFMEMORY;
    }

    uintptr_t hThread;

    hThread = _beginthread(NotifyThreadFcn, 0, (PVOID)pNotifyObj);

    if (hThread == -1)
    {
        dspDebugOut((DEB_ERROR, "_beginthread failed with error %s\n",
                     strerror(errno)));
        REPORT_ERROR_FORMAT(ERROR_NOT_ENOUGH_MEMORY, IDS_NOTIFYFAILURE, GetDesktopWindow());
        return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Wait for initialization to complete and return the results.
    //
    if (WaitForSingleObject(pNotifyObj->m_hInitEvent, DSPROP_WAITTIME) == WAIT_TIMEOUT)
    {
        CloseHandle(pNotifyObj->m_hInitEvent);
        REPORT_ERROR_FORMAT(0, IDS_NOTIFYTIMEOUT, GetDesktopWindow());
        return HRESULT_FROM_WIN32(WAIT_TIMEOUT);
    }

    CloseHandle(pNotifyObj->m_hInitEvent);

    if (pNotifyObj->m_hWnd != NULL)
    {
        *phNotifyObj = pNotifyObj->m_hWnd;
    }
    else
    {
        REPORT_ERROR_FORMAT(pNotifyObj->m_hr, IDS_NOTIFYFAILURE, GetDesktopWindow());
        hr = pNotifyObj->m_hr;
        delete pNotifyObj;
        return hr;
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::GetInitInfo
//
//  Synopsis:   Pages call this at their init time to retreive DS object info.
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [pInitParams] - struct filled in with DS object info.
//
//  Note that pInitParams->pWritableAttrs can be NULL if there are no writable
//  attributes.
//
//-----------------------------------------------------------------------------
BOOL
CNotifyObj::GetInitInfo(HWND hNotifyObj, PADSPROPINITPARAMS pInitParams)
{
    dspDebugOut((DEB_ITRACE, "CNotifyObj::GetInitInfo\n"));
    if (IsBadWritePtr(pInitParams, sizeof(ADSPROPINITPARAMS)))
    {
        return FALSE;
    }
    dspAssert(hNotifyObj && pInitParams);
    if (!IsWindow(hNotifyObj))
    {
        pInitParams->hr = E_FAIL;
        return FALSE;
    }
    if (pInitParams->dwSize != sizeof (ADSPROPINITPARAMS))
    {
        return FALSE;
    }
    SendMessage(hNotifyObj, WM_ADSPROP_NOTIFY_PAGEINIT, 0,
                (LPARAM)pInitParams);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::SetHwnd
//
//  Synopsis:   Pages call this at their dialog init time to send their hwnd.
//
//  Arguments:  [hNotifyObj]  - the notificion window handle.
//              [hPage]       - the page's window handle.
//
//  Returns:    FALSE if the notify window has gone away for some reason.
//
//-----------------------------------------------------------------------------
BOOL
CNotifyObj::SetHwnd(HWND hNotifyObj, HWND hPage, PTSTR ptzTitle)
{
    dspDebugOut((DEB_ITRACE, "CNotifyObj::SetHwnd\n"));
    dspAssert(hNotifyObj && hPage);
    if (!IsWindow(hNotifyObj))
    {
        return FALSE;
    }
    SendMessage(hNotifyObj, WM_ADSPROP_NOTIFY_PAGEHWND, (WPARAM)hPage, (LPARAM)ptzTitle);
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Method:     NotifyThreadFcn
//
//  Synopsis:   Object window creation and message loop thread.
//
//-----------------------------------------------------------------------------
VOID __cdecl
NotifyThreadFcn(PVOID pParam)
{
  // All of the function except the _endthread() call is enclosed in braces
  // so that the dtors of the auto classes would run. Otherwise the thread is
  // ended before the function scope is left and the auto class object dtors
  // never run.
  {
    CNotifyObj * pNotifyObj = (CNotifyObj *)pParam;
    dspAssert(pNotifyObj);

    MSG msg;

    CSmartPtr <TCHAR> ptzTitle;
    if (!UnicodeToTchar(pNotifyObj->m_pwzObjDN, &ptzTitle))
    {
        pNotifyObj->m_hr = E_OUTOFMEMORY;
        SetEvent(pNotifyObj->m_hInitEvent);
        return;
    }

    CStr cstrTitle(ptzTitle);

    WCHAR szIH[10];
    _itow(g_iInstance, szIH, 16);

    cstrTitle += szIH;

    //
    // The window title is set to the DN of the object plus the instance
    // identifier converted to a string. This enables FindWindow to locate a
    // pre-existing instance of the notify window for a specific object for
    // a specific instance of DS Admin.
    //
    pNotifyObj->m_hWnd = CreateWindow(tzNotifyWndClass, cstrTitle, WS_POPUP,
                                      0, 0, 1, 1, NULL, NULL, g_hInstance,
                                      pNotifyObj);
    if (pNotifyObj->m_hWnd == NULL)
    {
        DWORD dwErr = GetLastError();
        dspDebugOut((DEB_ERROR,
                     "Notify Obj window creation failed with error %d!\n",
                     dwErr));
        pNotifyObj->m_hr = HRESULT_FROM_WIN32(dwErr);
        SetEvent(pNotifyObj->m_hInitEvent);
        return;
    }
    dspDebugOut((DEB_ITRACE, "Notify Obj (this: 0x%p) window creation complete.\n",
                 pNotifyObj));

    SetEvent(pNotifyObj->m_hInitEvent);

    while (GetMessage(&msg, NULL, 0, 0))
    {
        DispatchMessage(&msg);
    }

    delete pNotifyObj;
  }
  _endthread();
}

//+----------------------------------------------------------------------------
//
//  Method:     _FindDSAHiddenWindowFromDSFind
//
//  Synopsis:   Looks for hidden DSA window of the snapin instance calling DS Find
//
//  Returns:    HWND of DSA hidden window if called from DS Find.
//
//-----------------------------------------------------------------------------

BOOL CALLBACK EnumDSAHiddenWindowProc(HWND hwnd,	LPARAM lParam)
{
    HWND* phWnd = (HWND*)lParam;
    *phWnd = NULL;

    // get the window class
    TCHAR szClass[64];
    if (0 == GetClassName(hwnd, szClass, 64))
    {
        return TRUE;
    }
    
    if (_tcscmp(szClass, TEXT("DSAHiddenWindow")) != 0)
    {
        return TRUE; // no match, continue
    }


    // got a DSA hidden window
    // get the window title, to make sure it is 
    // the one originating DS Find

	  TCHAR szTitle[256];
	  ::GetWindowText(hwnd, szTitle, 256);
	  if (_tcscmp(szTitle, TEXT("DS Find")) != 0)
	  {
        return TRUE; // no match continue
    }

    // we go the right class and title, but
    // we still have to verify it is from the 
    // same process (assuming DS Find modal)

    DWORD dwProcessId = 0x0;
    GetWindowThreadProcessId(hwnd, &dwProcessId);

    if (GetCurrentProcessId() != dwProcessId)
    {
        return TRUE; // from wrong process, continue
    }

    // finally, we got it!!

		*phWnd = hwnd;
		return FALSE;
}


HWND _FindDSAHiddenWindowFromDSFind()
{
    HWND hwndHidden = NULL;
    EnumWindows(EnumDSAHiddenWindowProc, (LPARAM)&hwndHidden);  
    return hwndHidden;
}


//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::CNotifyObj
//
//-----------------------------------------------------------------------------
CNotifyObj::CNotifyObj(LPDATAOBJECT pDataObj, PPROPSHEETCFG pSheetCfg) :
    m_hWnd(NULL),
    m_hPropSheet(NULL),
    m_cPages(0),
    m_cApplies(0),
    m_pAppThdDataObj(pDataObj),
    m_pStrmMarshalledDO(NULL),
    m_hInitEvent(NULL),
    m_fBeingDestroyed(FALSE),
    m_fSheetDirty(FALSE),
    m_hr(S_OK),
    m_pwzObjDN(NULL),
    m_pDsObj(NULL),
    m_pwzCN(NULL),
    m_pWritableAttrs(NULL),
    m_pAttrs(NULL),
    m_pPageInfoArray(NULL)
{
#ifdef _DEBUG
  strcpy(szClass, "CNotifyObj");
#endif

  memcpy(&m_sheetCfg, pSheetCfg, sizeof(PROPSHEETCFG));


  if (m_sheetCfg.hwndHidden == NULL)
  {
    // we might be called from DS Find, so we want to find
    // the DSA hidden window, needed for creating
    // secondary property sheets
    m_sheetCfg.hwndHidden = _FindDSAHiddenWindowFromDSFind();
  }


  //
  // We need to addref the data object but can't release it on this thread,
  // so we marshall it (which implicitly addrefs it) and then then unmarshall
  // and release on the notify object thread.
  //
  CoMarshalInterThreadInterfaceInStream(IID_IDataObject,
                                        pDataObj,
                                        &m_pStrmMarshalledDO);

  m_hInitEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

  if (m_hInitEvent == NULL)
  {
    m_hr = HRESULT_FROM_WIN32(GetLastError());
  }

  //
  // Arbitrary default size.  This will expand as more pages are added
  //
  m_nPageInfoArraySize = 5;
  m_pPageInfoArray = new CPageInfo[m_nPageInfoArraySize];
}

//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::~CNotifyObj
//
//-----------------------------------------------------------------------------
CNotifyObj::~CNotifyObj(void)
{
  NOTIFYOUT(destructor);

  LPDATAOBJECT pNotifyThdDataObj = NULL;

  if (m_pStrmMarshalledDO)
  {
    CoGetInterfaceAndReleaseStream(m_pStrmMarshalledDO,
                                   IID_IDataObject,
                                   reinterpret_cast<void**>(&pNotifyThdDataObj));
    m_pStrmMarshalledDO = NULL;
  }
  DO_RELEASE(pNotifyThdDataObj);
  //DBG_OUT("-----------------------releasing object in notify obj dtor");
  DO_RELEASE(m_pDsObj);

  if (m_sheetCfg.lNotifyHandle &&
      !IsBadReadPtr(
         reinterpret_cast<void*>(m_sheetCfg.lNotifyHandle), 
         sizeof(LONG_PTR)))
  {
    MMCFreeNotifyHandle(m_sheetCfg.lNotifyHandle);
    m_sheetCfg.lNotifyHandle = 0;
  }
  if (m_sheetCfg.hwndHidden && m_sheetCfg.wParamSheetClose)
  {
   ::PostMessage(m_sheetCfg.hwndHidden, 
                 WM_DSA_SHEET_CLOSE_NOTIFY, 
                 (WPARAM)m_sheetCfg.wParamSheetClose, 
                 (LPARAM)0);
  }
  DO_DEL(m_pwzObjDN);
  if (m_pAttrs)
  {
    FreeADsMem(m_pAttrs);
  }

  if (m_pPageInfoArray != NULL)
  {
    delete[] m_pPageInfoArray;
    m_pPageInfoArray = NULL;
  }

}

//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::StaticNotifyProc
//
//  Synopsis:   window procedure
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CNotifyObj::StaticNotifyProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CNotifyObj * pNotifyObj = (CNotifyObj*)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    if (uMsg == WM_CREATE)
    {
        pNotifyObj = (CNotifyObj *)((CREATESTRUCT *)lParam)->lpCreateParams;
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)pNotifyObj);
    }

    if (pNotifyObj)
    {
        return pNotifyObj->NotifyProc(hWnd, uMsg, wParam, lParam);
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::NotifyProc
//
//  Synopsis:   Instance window procedure
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
CNotifyObj::NotifyProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
  switch (uMsg)
  {
  case WM_CREATE:
    return OnCreate();

  case WM_ADSPROP_NOTIFY_PAGEINIT:
    dspDebugOut((DEB_ITRACE,
                 "Notify Obj 0x%p: WM_ADSPROP_NOTIFY_PAGEINIT\n",
                 this));
    PADSPROPINITPARAMS pInitParams;
    pInitParams = (PADSPROPINITPARAMS)lParam;
    pInitParams->hr = m_hr;
    pInitParams->pDsObj = m_pDsObj;
    pInitParams->pwzCN = m_pwzCN;
    pInitParams->pWritableAttrs = m_pWritableAttrs;
    return 0;

  case WM_ADSPROP_NOTIFY_PAGEHWND:
    {
      m_cApplies = ++m_cPages;
      dspDebugOut((DEB_ITRACE,
                   "Notify Obj 0x%p: WM_ADSPROP_NOTIFY_PAGEHWND count now %d\n",
                   this, m_cPages));
      HWND hWndPage = (HWND)wParam;
      if (!m_hPropSheet)
      {
        m_hPropSheet = GetParent(hWndPage);
      }

      if (m_cPages > m_nPageInfoArraySize)
      {
        //
        // REVIEW_JEFFJON : after going beyond the initial size, should the size increase
        //                  incrementally or in chunks?
        //
        CPageInfo* pNewPageInfoArray = new CPageInfo[m_cPages];
        if (pNewPageInfoArray != NULL)
        {
          memset(pNewPageInfoArray, 0, sizeof(CPageInfo) * m_cPages);
          memcpy(pNewPageInfoArray, m_pPageInfoArray, sizeof(CPageInfo) * m_nPageInfoArraySize);
          delete[] m_pPageInfoArray;
          m_pPageInfoArray = pNewPageInfoArray;
          m_nPageInfoArraySize = m_cPages;
        }
      }

	  //NTRAID#NTBUG9-572006-2002/03/10-jmessec   buffer overrun:  If memory allocation fails above, the array is too small
      m_pPageInfoArray[m_cPages - 1].m_hWnd = hWndPage;

      //
      // Copy the title if one was sent
      //
      PTSTR ptzPageTitle = reinterpret_cast<PTSTR>(lParam);
      if (ptzPageTitle != NULL)
      {
        size_t iTitleSize = _tcslen(ptzPageTitle);
        m_pPageInfoArray[m_cPages - 1].m_ptzTitle = new TCHAR[iTitleSize + 1];
        if (m_pPageInfoArray[m_cPages - 1].m_ptzTitle != NULL)
        {
          _tcscpy(m_pPageInfoArray[m_cPages - 1].m_ptzTitle, ptzPageTitle);
        }
      }
    }
    return 0;

  case WM_ADSPROP_NOTIFY_APPLY:
    {
      NOTIFYOUT(WM_ADSPROP_NOTIFY_APPLY);
      if ((BOOL)wParam)
      {
        // The security page and extension pages don't inherit from our
        // page framework and thus don't participate in the notify object
        // refcounting or the page-dirty flagging. So, don't fire a change
        // notification unless one of our pages was dirty.
        //
        m_fSheetDirty = TRUE;
      }

      // NTRAID#NTBUG9-462165-2001/10/17-JeffJon
      // Need to set the apply status to success.

      HWND hPage = reinterpret_cast<HWND>(lParam);
      if (hPage)
      {
        for (UINT idx = 0; idx < m_cPages; idx++)
        {
          if (m_pPageInfoArray[idx].m_hWnd == hPage)
          {
             m_pPageInfoArray[idx].m_ApplyStatus = CPageInfo::success;
             break;
          }
        }
      }

      if (--m_cApplies == 0 && m_fSheetDirty)
      {
        NOTIFYOUT(Sending change notification);
        if (m_sheetCfg.lNotifyHandle)
        {
          // The change notify call results in a PostMessage back to the
          // MMC main thread. Therefore, we need to pass the data object
          // pointer that came from the main thread.
          //
          MMCPropertyChangeNotify(m_sheetCfg.lNotifyHandle, (LPARAM)m_pAppThdDataObj);
        }
        if (m_sheetCfg.hwndParentSheet)
        {
          PostMessage(m_sheetCfg.hwndParentSheet, WM_ADSPROP_NOTIFY_CHANGE, 0, 0);
        }
        m_cApplies = m_cPages;
        m_fSheetDirty = FALSE;

        //
        // Change the status of all the pages back to notAttempted
        //
        for (UINT idx = 0; idx < m_cPages; idx++)
        {
          m_pPageInfoArray[idx].m_ApplyStatus = CPageInfo::notAttempted;
        }

      }
      return 0;
    }

  case WM_ADSPROP_NOTIFY_ERROR:
    {
      NOTIFYOUT(WM_ADSPROP_NOTIFY_ERROR);
      PADSPROPERROR pApplyErrors = reinterpret_cast<PADSPROPERROR>(lParam);
      if (pApplyErrors != NULL)
      {
        for (UINT idx = 0; idx < m_cPages; idx++)
        {
          if (m_pPageInfoArray[idx].m_hWnd == pApplyErrors->hwndPage)
          {
            m_pPageInfoArray[idx].m_ApplyErrors.SetError(pApplyErrors);
            if (m_pPageInfoArray[idx].m_ApplyErrors.GetErrorCount() > 0)
            {
              m_pPageInfoArray[idx].m_ApplyStatus = CPageInfo::failed;
            }
            else
            {
              m_pPageInfoArray[idx].m_ApplyStatus = CPageInfo::success;
            }
            break;
          }
        }
      }
      return 0;
    }

  case WM_ADSPROP_NOTIFY_GET_NOTIFY_OBJ:
    {
      NOTIFYOUT(WM_ADSPROP_NOTIFY_GET_NOTIFY_OBJ);
      BOOL retVal = FALSE;
      if (lParam != NULL)
      {
        CNotifyObj** ppNotifyObj = reinterpret_cast<CNotifyObj**>(lParam);
        if (ppNotifyObj)
        {
          *ppNotifyObj = this;
          retVal = TRUE;
        }
      }
      return retVal;
    }

  case WM_ADSPROP_NOTIFY_SETFOCUS:
    NOTIFYOUT(WM_ADSPROP_NOTIFY_SETFOCUS);
    SetForegroundWindow(m_hPropSheet);
    return 0;

  case WM_ADSPROP_NOTIFY_FOREGROUND:
    NOTIFYOUT(WM_ADSPROP_NOTIFY_FOREGROUND);
    if (wParam) //  bActivate flag
    {
      SetForegroundWindow(m_hPropSheet);
    }
    else
    {
      SetWindowPos(m_hPropSheet, HWND_TOP, 
                   0,0,0,0,
                    SWP_NOMOVE | SWP_NOSIZE);
    }
    return 0;

  case WM_ADSPROP_SHEET_CREATE:
    NOTIFYOUT(WM_ADSPROP_SHEET_CREATE);

    if (m_sheetCfg.hwndHidden)
    {
      ::PostMessage(m_sheetCfg.hwndHidden, 
                   WM_DSA_SHEET_CREATE_NOTIFY, 
                   wParam, 
                   lParam);
    }
    return 0;

  case WM_ADSPROP_NOTIFY_EXIT:
    {
      NOTIFYOUT(WM_ADSPROP_NOTIFY_EXIT);
      if (m_fBeingDestroyed)
      {
        return 0;
      }
      m_fBeingDestroyed = TRUE;

      DestroyWindow(hWnd);
      return 0;
    }

  case WM_DESTROY:
    NOTIFYOUT(WM_DESTROY);
    CoUninitialize();
    PostQuitMessage(0);
    return 0;

  default:
    break;
  }

  return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

//+----------------------------------------------------------------------------
//
//  Method:     CNotifyObj::OnCreate
//
//  Synopsis:   Window creation/initialization processing. Bind to the DS
//              object and read its CN and Allowed-Attributes-Effective
//              properties.
//
//-----------------------------------------------------------------------------
LRESULT
CNotifyObj::OnCreate(void)
{
    NOTIFYOUT(WM_CREATE);
    HRESULT hr;
    DWORD cAttrs;

    CoInitialize(NULL);

    //
    // we need to check to see if we can
    // convert the string to a CLSID.  If
    // we can then this is a multi-select
    // property page and we shouldn't try
    // to bind.
    //
    CLSID clsid;
    if (SUCCEEDED(::CLSIDFromString(m_pwzObjDN, &clsid)))
    {
      m_hr = S_OK;
      return S_OK;
    }

    //DBG_OUT("+++++++++++++++++++++++++++addrefing (opening) object");
    hr = DSAdminOpenObject(m_pwzObjDN, 
                           IID_IDirectoryObject, 
                           (PVOID *)&m_pDsObj);

    if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
    {
        // ErrMsg(IDS_ERRMSG_NO_LONGER_EXISTS);
        m_hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }
    if (hr == 0x80070051)
    {
        // On subsequent network failures, ADSI returns this error code which
        // is not documented anywhere. I'll turn it into a documented error
        // code which happens to be the code returned on the first failure.
        //
        hr = HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP);
    }
    if (hr == HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP))
    {
        // ErrMsg(IDS_ERRMSG_NO_DC_RESPONSE);
        m_hr = HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP);
        return 0;
    }
    CHECK_HRESULT(hr, m_hr = hr; return hr);

    PWSTR rgszNames[2] = {g_wzName, g_wzAllowed};

    hr = m_pDsObj->GetObjectAttributes(rgszNames, 2, &m_pAttrs, &cAttrs);

    CHECK_HRESULT(hr, m_hr = hr; return hr);

    dspAssert(cAttrs >= 1); // expect to always get name.

    for (DWORD i = 0; i < cAttrs; i++)
    {
        if (_wcsicmp(m_pAttrs[i].pszAttrName, g_wzName) == 0)
        {
            m_pwzCN = m_pAttrs[i].pADsValues->CaseIgnoreString;
            continue;
        }

        if (_wcsicmp(m_pAttrs[i].pszAttrName, g_wzAllowed) == 0)
        {
            m_pWritableAttrs = &m_pAttrs[i];

#if DBG == 1
            for (DWORD j = 0; j < m_pAttrs[i].dwNumValues; j++)
            {
                dspDebugOut((DEB_USER4, "Allowed attribute (effective): %ws\n",
                             m_pAttrs[i].pADsValues[j].CaseIgnoreString));
            }
#endif
        }
    }
    
    NOTIFYOUT(WM_CREATE done);
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   RegisterNotifyClass
//
//  Synopsis:   Register the window class for the notification window.
//
//-----------------------------------------------------------------------------
VOID
RegisterNotifyClass(void)
{
    WNDCLASS wcls;
    wcls.style = 0;
    wcls.lpfnWndProc = CNotifyObj::StaticNotifyProc;
    wcls.cbClsExtra = 0;
    wcls.cbWndExtra = 0;
    wcls.hInstance = g_hInstance;
    wcls.hIcon = NULL;
    wcls.hCursor = NULL;
    wcls.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wcls.lpszMenuName = NULL;
    wcls.lpszClassName = tzNotifyWndClass;

    RegisterClass(&wcls);
}

//+----------------------------------------------------------------------------
//
//  Function:   FindSheetNoSetFocus
//
//  Synopsis:   Locate the property sheet for the DS object.
//
//-----------------------------------------------------------------------------
HWND
FindSheetNoSetFocus(PWSTR pwzObjADsPath)
{
    HWND hNotify = NULL;
    //
    // See if the object/window already exists for this property sheet.
    // Note that the window title is the DN of the object plus the instance id.
    //
#ifdef UNICODE
    CStr cstrTitle(pwzObjADsPath);

    WCHAR szIH[10];
    _itow(g_iInstance, szIH, 16);

    cstrTitle += szIH;

    hNotify = FindWindow(tzNotifyWndClass, cstrTitle);
#else
    LPSTR pszTitle;
    if (UnicodeToTchar(pwzObjADsPath, &pszTitle))
    {
        CStr cstrTitle(pszTitle);

        char szIH[10];
        _itoa(g_iInstance, szIH, 16);

        cstrTitle += szIH;

        hNotify = FindWindow(tzNotifyWndClass, cstrTitle);
        delete [] pszTitle;
    }
#endif

    dspDebugOut((DEB_ITRACE, "FindSheet: returned hNotify = 0x%08x\n", hNotify));

    return hNotify;
}

//+----------------------------------------------------------------------------
//
//  Function:   BringSheetToForeground
//
//  Synopsis:   Locate the property sheet for the DS object identified by the
//              data object and bring it to the top of the Z order
//
//-----------------------------------------------------------------------------
extern "C" BOOL 
BringSheetToForeground(PWSTR pwzObjADsPath, BOOL bActivate)
{
    HWND hNotify = FindSheetNoSetFocus(pwzObjADsPath);

    if (!hNotify)
    {
        return FALSE;
    }

    PostMessage(hNotify, WM_ADSPROP_NOTIFY_F