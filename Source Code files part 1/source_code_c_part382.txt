const DSNAME *pName,
    unsigned *pCount
    );

ATTRTYP
KeyToAttrTypeLame(
    WCHAR * pKey,
    unsigned cc
    );

unsigned
StepToNextDNSep(
    const WCHAR * pString,
    const WCHAR * pLastChar,
    const WCHAR **ppNextSep,
    const WCHAR **ppStartOfToken,
    const WCHAR **ppEqualSign
    );

unsigned
GetTopNameComponent(
    const WCHAR * pName,
    unsigned ccName,
    const WCHAR **ppKey,
    unsigned *pccKey,
    const WCHAR **ppVal,
    unsigned *pccVal
    );

unsigned
UnquoteRDNValue(
    const WCHAR * pQuote,
    unsigned ccQuote,
    WCHAR * pVal
    );

BOOL
IsRoot(
    const DSNAME *pName
    );


#ifdef __cplusplus
}
#endif

    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\remove.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"

#include "resource.h"

#include <lmcons.h>
#include <lmapibuf.h>
#include <dsgetdc.h>
#include <ntldap.h>

CParser removeParser;
BOOL    fRemoveQuit;
BOOL    fRemoveParserInitialized = FALSE;

extern DS_NAME_RESULTW *gServerInfo;

// Forward references.

extern HRESULT RemoveHelp(CArgs *pArgs);
extern HRESULT RemoveQuit(CArgs *pArgs);
extern HRESULT RemoveServer(CArgs *pArgs);
extern HRESULT RemoveDomain(CArgs *pArgs);
extern HRESULT RemoveNamingContext(CArgs *pArgs);

extern "C" {

const WCHAR *
GetWinErrorMessage(
    DWORD winError
    );

}


//
// Forwards local to this file
//
BOOL    FRSRequirementsHandled(IN LPWSTR pwszDomain,
                               IN LPWSTR pwszServer,
                               OUT BOOL *fDeleteFRS);
HRESULT FRSRemoveServer(IN LPWSTR pwszServer,IN LPWSTR pwszDomain);
HRESULT GetDNSDomainFormat(IN LPWSTR pwszDomainDn,OUT LPWSTR *pwszDnsName);

//
// A helpful macro to know if two strings are the same.
// x and y must be NULL terminated.
//
#define EQUAL_STRING(x, y)                                           \
    (CSTR_EQUAL == CompareStringW(DS_DEFAULT_LOCALE,                 \
                                  DS_DEFAULT_LOCALE_COMPARE_FLAGS,   \
                                  (x), wcslen(x), (y), wcslen(y)))


// Build a table which defines our language.

LegalExprRes removeLanguage[] = 
{
    CONNECT_SENTENCE_RES

    SELECT_SENTENCE_RES

    {   L"?",
        RemoveHelp,
        IDS_HELP_MSG, 0  },

    {   L"Help",
        RemoveHelp,
        IDS_HELP_MSG, 0  },

    {   L"Quit",
        RemoveQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Remove selected server",
        RemoveServer,
        IDS_REMOVE_SERVER_MSG, 0 },

    {   L"Remove selected domain",
        RemoveDomain,
        IDS_REMOVE_DOMAIN_MSG, 0 },

    {   L"Remove selected Naming Context",
        RemoveNamingContext,
        IDS_REMOVE_NC_MSG, 0 }
};

HRESULT
RemoveMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !fRemoveParserInitialized )
    {
        cExpr = sizeof(removeLanguage) / sizeof(LegalExprRes);
    
        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (removeLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }

        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = removeParser.AddExpr(removeLanguage[i].expr,
                                                  removeLanguage[i].func,
                                                  removeLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fRemoveParserInitialized = TRUE;
    fRemoveQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_METADATA_CLEANUP);

    hr = removeParser.Parse(gpargc,
                            gpargv,
                            stdin,
                            stdout,
                            prompt,
                            &fRemoveQuit,
                            FALSE,               // timing info
                            FALSE);              // quit on error

    if ( FAILED(hr) )
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    
    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}

HRESULT RemoveHelp(CArgs *pArgs)
{
    return(removeParser.Dump(stdout,L""));
}

HRESULT RemoveQuit(CArgs *pArgs)
{
    fRemoveQuit = TRUE;
    return(S_OK);
}

HRESULT RemoveServer(CArgs *pArgs)
{
    WCHAR   *pwszServer;
    WCHAR   *pwszDomain;
    DWORD   cBytes;
    DWORD   dwErr;
    BOOL    fLastDcInDomain;
    int     ret;
    BOOL    fDeleteFRS = FALSE;

    RETURN_IF_NOT_CONNECTED;

    if ( NULL == (pwszServer = SelectGetCurrentServer()) )
    {
        return(S_OK);
    }

    if ( NULL == (pwszDomain = SelectGetCurrentDomain()) )
    {
        return(S_OK);
    }


    //
    // See if the FRS objects can and should be removed by the
    // server we are connected to.
    //
    if (!FRSRequirementsHandled(pwszDomain, pwszServer, &fDeleteFRS))
    {
        //
        // Reason has already been printed out why the operation
        // shouldn't continue.
        //
        return (S_OK);            
    }

    if ( dwErr = DsRemoveDsServerW( ghDS,
                                    pwszServer,
                                    pwszDomain,
                                    &fLastDcInDomain,
                                    FALSE) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsRemoveDsServerW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    if ( fPopups )
    {
        const WCHAR * message_title = READ_STRING (IDS_REMOVE_SERVER_CONFIRM_TITLE);
        const WCHAR * message_body;
        WCHAR * msg;

        if (fLastDcInDomain) 
           message_body  = READ_STRING (IDS_REMOVE_SERVER_CONFIRM_MSG1);
        else
           message_body  = READ_STRING (IDS_REMOVE_SERVER_CONFIRM_MSG2);

        
        cBytes =   wcslen(message_body)
                 + wcslen(pwszServer)
                 + wcslen(pwszDomain)
                 + 25; // just in case

        msg = (WCHAR *) malloc(cBytes * sizeof (WCHAR));

        if ( !msg  )
        {
            RESOURCE_PRINT (IDS_MEMORY_ERROR);
            return(S_OK);
        }

        wsprintfW(msg, 
                message_body, 
                pwszServer, 
                pwszDomain);
        
        ret = MessageBoxW(   GetFocus(),
                            msg,
                            message_title,
                            (   MB_APPLMODAL
                              | MB_DEFAULT_DESKTOP_ONLY
                              | MB_YESNO
                              | MB_DEFBUTTON2
                              | MB_ICONQUESTION
                              | MB_SETFOREGROUND ) );
        free(msg);
        RESOURCE_STRING_FREE (message_body);
        RESOURCE_STRING_FREE (message_title);

        switch ( ret )
        {
        case 0:
           {
              RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);
           
              return(S_OK);    
           }

        case IDYES:

            break;

        default:
           {
              RESOURCE_PRINT (IDS_OPERATION_CANCELED);
           
              return(S_OK);
           }
        }
    }

    if (fDeleteFRS) {

        //
        // Call into FRS module
        //
        dwErr = FRSRemoveServer(pwszServer,
                                pwszDomain);
        if (dwErr) {
            //
            // FRSRemoveServer prints out any error.  See
            // FRSRemoveServer for error conditions.
            //
            return(S_OK);
        }
    }

    if ( dwErr = DsRemoveDsServerW( ghDS,
                                    pwszServer,
                                    NULL,
                                    NULL,
                                    TRUE) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsRemoveDsServerW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }
    
    //"\"%ws\" removed from server \"%ws\"\n"
    RESOURCE_PRINT2 (IDS_REMOVE_SERVER_SUCCESS,
                     pwszServer,
                     gpwszServer);
    return(S_OK);
}

HRESULT 
RemoveDomainOrNamingContext(
    IN PWCHAR   Name,
    IN DWORD    Title,
    IN DWORD    Body
    )
{
    DWORD   cBytes;
    WCHAR   *msg;
    DWORD   dwErr;
    int     ret;
    DS_NAME_RESULTW *roles = NULL;

    if ( fPopups )
    {
        const WCHAR * message_title = READ_STRING (Title);
        const WCHAR * message_body  = READ_STRING (Body);
        
        
        cBytes =   wcslen(message_body)
                 + wcslen(Name)
                 + 10;
        msg = (WCHAR *) malloc(cBytes * sizeof (WCHAR));

        if ( !msg )
        {
            RESOURCE_PRINT (IDS_MEMORY_ERROR);
            return(S_OK);
        }

        wsprintfW(msg, message_body, Name);
        
        ret = MessageBoxW(   GetFocus(),
                            msg,
                            message_title,
                            (   MB_APPLMODAL
                              | MB_DEFAULT_DESKTOP_ONLY
                              | MB_YESNO
                              | MB_DEFBUTTON2
                              | MB_ICONQUESTION
                              | MB_SETFOREGROUND ) );
        free(msg);
        RESOURCE_STRING_FREE (message_body);
        RESOURCE_STRING_FREE (message_title);

        switch ( ret )
        {
        case 0:
           {
             RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);

              return(S_OK);
           }

        case IDYES:

            break;

        default:
           {
              RESOURCE_PRINT (IDS_OPERATION_CANCELED);
           
              return(S_OK);
           }
        }
    }

    if ( dwErr = DsRemoveDsDomainW( ghDS, Name) )
    {   
        switch ( dwErr ) {
            
            //
            // Remind the user that this operation must be performed at 
            // the domain naming FSMO
            //
            case ERROR_DS_NO_CROSSREF_FOR_NC:
                
                if ( dwErr = DsListRolesW(ghDS, &roles) )
                {
                    RESOURCE_PRINT (IDS_GET_DOMAIN_NAMING_FSMO_ERROR);
                    break;
                }   

                //
                // DsListRoles should return no errors
                //
                if ( DS_NAME_NO_ERROR != roles->rItems[DS_ROLE_DOMAIN_OWNER].status )
                { 
                    RESOURCE_PRINT (IDS_GET_DOMAIN_NAMING_FSMO_ERROR);
                    break;
                }
                else
                {
                    RESOURCE_PRINT1 (IDS_ERR_REQUIRES_DOMAIN_NAMING_FSMO, roles->rItems[DS_ROLE_DOMAIN_OWNER].pName);    
                }
                
                break;
                
            default:
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsRemoveDsDomainW", dwErr, GetW32Err (dwErr));        
                break;
        }
        
        if (roles) 
            DsFreeNameResultW(roles);
        
        return(S_OK);
    }
    
    //"\"%ws\" removed from server \"%ws\"\n"
    RESOURCE_PRINT2 (IDS_REMOVE_SERVER_SUCCESS, Name, gpwszServer);

    return(S_OK);
}

HRESULT RemoveDomain(CArgs *pArgs)
{
    WCHAR   *pwszDomain;
    WCHAR   *msg;
    DWORD   cBytes;
    DWORD   dwErr;
    int     ret;

    RETURN_IF_NOT_CONNECTED;

    if ( NULL == (pwszDomain = SelectGetCurrentDomain()) )
    {
        return(S_OK);
    }
    return(RemoveDomainOrNamingContext(pwszDomain,
                                       IDS_REMOVE_DOMAIN_CONFIRM_TITLE,
                                       IDS_REMOVE_DOMAIN_CONFIRM_MSG));
}

HRESULT RemoveNamingContext(CArgs *pArgs)
{
    WCHAR   *pwszNamingContext;
    WCHAR   *msg;
    DWORD   cBytes;
    DWORD   dwErr;
    int     ret;

    RETURN_IF_NOT_CONNECTED;

    if ( NULL == (pwszNamingContext = SelectGetCurrentNamingContext()) )
    {
        return(S_OK);
    }
    return(RemoveDomainOrNamingContext(pwszNamingContext,
                                       IDS_REMOVE_NC_CONFIRM_TITLE,
                                       IDS_REMOVE_NC_CONFIRM_MSG));
}

//
// This is the prototype of the API ntdsutil.exe calls from the
// ntfrsapi.dll.  Note that the code does a LoadLibrary as opposed to 
// statically linking so that ntdsutil can still be used even when the 
// ntfrsapi.dll is not available.
//
typedef DWORD (*NtdsUtil_NtFrsApi_DeleteSysvolMember) (
    IN SEC_WINNT_AUTH_IDENTITY_W *,  // credentials to bind with
    IN PWCHAR,                       // target dc
    IN PWCHAR,                       // ntds settings object dn
    IN OPTIONAL PWCHAR               // computer dn
    );

HRESULT FRSRemoveServer(
    IN LPWSTR pwszServer,
    IN LPWSTR pwszDomain
    )
//
// This routine will call NTFRSAPI::NtFrsApi_DeleteSysvolMember to remove
// the FRS related objects for pwszServer.
//
// This routine will only error if the NTFRSAPI API can't be snapped.
//
{
    DWORD dwErr = S_OK;
    HMODULE hMod = NULL;
    NtdsUtil_NtFrsApi_DeleteSysvolMember pfnFrsDelete = NULL;
    DWORD Size;

    LPWSTR ComputerDN = NULL, NtdsServerDN = NULL;
    LPWSTR NtdsaPrefix = L"CN=Ntds Settings,";

    //
    // Load the FRS API dll and snap the API
    //
    hMod = LoadLibraryA("ntfrsapi");
    if (hMod)
    {
        pfnFrsDelete = (NtdsUtil_NtFrsApi_DeleteSysvolMember) 
                        GetProcAddress(hMod,
                                      "NtFrsApi_DeleteSysvolMember");
    }

    if (NULL == pfnFrsDelete)
    {
        RESOURCE_PRINT(IDS_REMOVE_SERVER_NO_FRS_API);
        dwErr = E_FAIL;
        goto Exit;
    }


    //
    // Setup the computer DN if possible
    //
    if ( gServerInfo
    &&  (gServerInfo->cItems > DS_LIST_ACCOUNT_OBJECT_FOR_SERVER)
    &&  (DS_NAME_NO_ERROR == gServerInfo->rItems[DS_LIST_ACCOUNT_OBJECT_FOR_SERVER].status))
    {
        ComputerDN = gServerInfo->rItems[DS_LIST_ACCOUNT_OBJECT_FOR_SERVER].pName;
    }

    //
    // Add the Ntds Setting prefix
    //
    Size = ( wcslen( NtdsaPrefix )
           + wcslen( pwszServer )
           + 1 ) * sizeof( WCHAR );

    NtdsServerDN = (LPWSTR) malloc(Size);
    if (!NtdsServerDN)
    {
        RESOURCE_PRINT (IDS_MEMORY_ERROR);
        dwErr = E_FAIL;
        goto Exit;
    }
    wcscpy( NtdsServerDN, NtdsaPrefix );
    wcscat( NtdsServerDN, pwszServer );

    //
    // Call out to delete the object
    //
    dwErr =(*pfnFrsDelete)(gpCreds,      // creds to use
                           gpwszServer,  // target server
                           NtdsServerDN, // server to remove
                           ComputerDN    // computer object, if present
                           );


    if (dwErr != ERROR_SUCCESS) 
    {
        RESOURCE_PRINT2(IDS_REMOVE_SERVER_FRS_ERR, 
                        pwszServer, 
                        GetWinErrorMessage(dwErr));

        //
        // This won't fail the call
        //
        dwErr = S_OK;
        goto Exit;
    }

Exit:

    if (hMod)
    {
        FreeLibrary(hMod);
    }

    if (NtdsServerDN)
    {
        free(NtdsServerDN);
    }

    return dwErr;        
}



BOOL FRSRequirementsHandled(
    IN  LPWSTR pwszDomainDN,                                
    IN  LPWSTR pwszServerDN,                                
    OUT BOOL *fDeleteFRS
    )
//
// This routine determines if the connected server is a sufficient
// server to remove the requested Ntds Settings object from.  Ideally
// we want the destination server to in the same domain as the server
// that is being removed.  If this is not the case and a such a DC can be
// found then the operation is aborted.  Otherwise, if no such DC can be
// found then the user confirms that they want to continue (and remove
// just the Ntds Settings object).
//
// pwszDomainDN -- the DN of the domain that the to-be-deleted server
//                 belonged to
//
// pwszServerDN -- the DN of the to-be-deleted server
//
// fDeleteFRS -- set to TRUE if and only the connected server will handle
//               the request to delete the FRS objects.  FALSE otherwise.
//
//
{
    DWORD dwErr = S_OK;
    LPWSTR pwszTargetDomainDN = NULL;
    LPWSTR pwszTargetServerDN = NULL;
    LPWSTR pwszDomainDnsName = NULL;
    DOMAIN_CONTROLLER_INFOW *DCInfo = NULL;

    //
    // Validate in parameters
    //
    ASSERT(pwszDomainDN);

    //
    // Init the OUT parameter
    //
    *fDeleteFRS = FALSE;

    //
    // Extract LDAP_OPATT_SERVER_NAME_W from target server and
    // compare with pwszTargetServerDN
    //
    if (dwErr = ReadAttribute( gldapDS,
                               L"\0",
                               LDAP_OPATT_SERVER_NAME_W,
                               &pwszTargetServerDN ) ) 
    {

        //
        // Error already printed
        //
        goto Exit;
    }

    if (EQUAL_STRING(pwszTargetServerDN, pwszServerDN)) 
    {
        //
        // Error -- can't delete one's own objects
        //
        RESOURCE_PRINT(IDS_REMOVE_SERVER_FRS_SAME);
        dwErr = E_FAIL;
        goto Exit;
    }


    //
    // Extract LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W from target server and
    // compare with pwszDomainDN
    //
    if (dwErr = ReadAttribute( gldapDS,
                               L"\0",
                               LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W,
                               &pwszTargetDomainDN ) ) 
    {

        //
        // Error already printed
        //
        goto Exit;
    }

    if (EQUAL_STRING(pwszTargetDomainDN, pwszDomainDN)) 
    {
        //
        // We are fine
        //
        *fDeleteFRS = TRUE;
        goto Exit;
    }

    //
    // The connected server is no good -- see if there is another server
    // available to service the request.
    //

    //
    // Translate DN form of domain name to DNS form
    //
    if (dwErr = GetDNSDomainFormat( pwszDomainDN,
                                   &pwszDomainDnsName)) 
    {
        //
        // Error already printed
        //
        goto Exit;
    }

    //
    // Make locator call to find if a DC that hosts this domain
    //
    dwErr = DsGetDcNameW(NULL,
                         pwszDomainDnsName,
                         NULL,
                         NULL,
                         0,
                         &DCInfo);
    if (ERROR_SUCCESS == dwErr)
    {
        //
        // A DC exists -- bail and suggest the user use another DC
        //
        RESOURCE_PRINT2(IDS_REMOVE_SERVER_FRS_SRV,
                        pwszDomainDnsName,
                        DCInfo->DomainControllerName);

        dwErr = E_FAIL;
        goto Exit;

    }
    else if (ERROR_NO_SUCH_DOMAIN == dwErr) 
    {
        //
        // We can't find a DC to remove the FRS objects from. Ensure that
        // the user really wants to continue.
        //
        if (fPopups) 
        {
            //
            // Ask the user if they really want to continue
            //
            const WCHAR * message_title = READ_STRING (IDS_REMOVE_SERVER_CONFIRM_TITLE);
            const WCHAR * message_body;
            DWORD cBytes, ret;
            WCHAR * msg;
    
            message_body  = READ_STRING (IDS_REMOVE_SERVER_NO_FRS_SRV);
            
            cBytes =   wcslen(message_body)
                     + wcslen(pwszDomainDnsName)
                     + 1;
    
            msg = (WCHAR *) malloc(cBytes * sizeof (WCHAR));
    
            if ( !msg  )
            {
                RESOURCE_PRINT (IDS_MEMORY_ERROR);
                dwErr = E_FAIL;
                goto Exit;
            }
    
            wsprintfW(msg, 
                      message_body, 
                      pwszDomainDnsName); 
            
            ret = MessageBoxW(  GetFocus(),
                                msg,
                                message_title,
                                (   MB_APPLMODAL
                                  | MB_DEFAULT_DESKTOP_ONLY
                                  | MB_YESNO
                                  | MB_DEFBUTTON2
                                  | MB_ICONQUESTION
                                  | MB_SETFOREGROUND ) );
            free(msg);
            RESOURCE_STRING_FREE (message_body);
            RESOURCE_STRING_FREE (message_title);
    
            dwErr = E_FAIL;
            switch ( ret )
            {
            case 0:

                RESOURCE_PRINT (IDS_MESSAGE_BOX_ERROR);
                dwErr = E_FAIL;
                break;
    
            case IDYES:
    
                dwErr = S_OK;
                break;
    
            default:

                RESOURCE_PRINT (IDS_OPERATION_CANCELED);
                dwErr = E_FAIL;
                break;
            }
        } 
        else
        {
            //
            // No popups?  Let the operation continue
            //
            dwErr = S_OK;
        }

        goto Exit;

    }
    else
    {
        //
        // This is an unhandled error, continue and let the operation fail.
        //
        RESOURCE_PRINT2(IDS_REMOVE_SERVER_FRS_LOC_ERR,
                        pwszDomainDnsName,
                        GetWinErrorMessage(dwErr));
        
    }

Exit:

    if (pwszTargetDomainDN) 
    {
        free(pwszTargetDomainDN);
    }

    if (pwszTargetServerDN) 
    {
        free(pwszTargetServerDN);
    }

    if (pwszDomainDnsName) 
    {
        free(pwszDomainDnsName);
    }

    if (DCInfo) 
    {
        NetApiBufferFree(DCInfo);
    }

    return ( (dwErr == S_OK) ? TRUE : FALSE);
}

HRESULT
GetDNSDomainFormat(
    IN  LPWSTR pwszDomainDn,
    OUT LPWSTR *pwszDnsName
    )
//
// This routine determines the DNS domain name of the domain
// indicated by pwszDomainDn by searching the partitions container.
//
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD LdapError = 0;

    LDAPMessage  *SearchResult = NULL;

    LDAPMessage *Entry;
    WCHAR       *Attr;
    WCHAR       **Values;
    BerElement  *pBerElement;

    WCHAR  *DnsRootAttr       = L"dnsRoot";
    WCHAR  *ncName            = L"(ncName=";
    WCHAR  *Partitions        = L"CN=Partitions,";
    WCHAR  *ConfigDN          = NULL;
    WCHAR  *ncNameFilter      = NULL;
    WCHAR  *AttrArray[2];
    ULONG  Length;
    WCHAR  *BaseDn;

    //
    // Parameter check
    //
    ASSERT(pwszDomainDn);
    ASSERT(pwszDnsName);
    *pwszDnsName = NULL;


    //
    // Get the config DN
    //
    if (dwErr = ReadAttribute( gldapDS,
                               L"\0",
                               LDAP_OPATT_CONFIG_NAMING_CONTEXT_W,
                               &ConfigDN ) ) 
    {
        //
        // Error already printed
        //
        return E_FAIL;
    }

    //
    // Prepare the ldap search
    //
    AttrArray[0] = DnsRootAttr;
    AttrArray[1] = NULL;

    //
    // Prepare the filter
    //
    Length = wcslen( ncName ) + wcslen( pwszDomainDn ) + 3;
    Length *= sizeof( WCHAR );
    ncNameFilter = (WCHAR*) alloca( Length );
    wcscpy( ncNameFilter, ncName );
    wcscat( ncNameFilter, pwszDomainDn );
    wcscat( ncNameFilter, L")" );

    //
    // Prepare the base dn
    //
    Length = wcslen( ConfigDN ) + wcslen( Partitions ) + 1;
    Length *= sizeof( WCHAR );
    BaseDn = (WCHAR*) alloca( Length );
    wcscpy( BaseDn, Partitions );
    wcscat( BaseDn, ConfigDN );

    //
    // Get all the children of the current node
    //
    LdapError = ldap_search_sW(gldapDS,
                               BaseDn,
                               LDAP_SCOPE_ONELEVEL,
                               ncNameFilter,
                               AttrArray,
                               FALSE,  // return values, too
                               &SearchResult
                               );

    dwErr = LdapMapErrorToWin32(LdapError);

    if ( ERROR_SUCCESS == dwErr )
    {
        if ( 0 != ldap_count_entries( gldapDS, SearchResult ) )
        {
            for ( Entry = ldap_first_entry(gldapDS, SearchResult);
                      Entry != NULL;
                          Entry = ldap_next_entry(gldapDS, Entry))
            {
                for( Attr = ldap_first_attributeW(gldapDS, Entry, &pBerElement);
                      Attr != NULL;
                          Attr = ldap_next_attributeW(gldapDS, Entry, pBerElement))
                {
                    if ( !_wcsicmp( Attr, DnsRootAttr ) )
                    {
                        Values = ldap_get_valuesW( gldapDS, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                             //
                             // Found it - these are NULL-terminated strings
                             //
                             ULONG len = wcslen(Values[0]);
                             *pwszDnsName = (WCHAR*)malloc((len+1) * sizeof(WCHAR));
                             if (*pwszDnsName) 
                             {
                                 wcscpy(*pwszDnsName, Values[0]);
                             }
                             break;
                        }
                    }
                }
            }
        }
    }

    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }

    if (ConfigDN)
    {
        free(ConfigDN);
    }

    if (NULL == *pwszDnsName)
    {
        RESOURCE_PRINT1(IDS_REMOVE_SERVER_NO_DNS,
                        pwszDomainDn);

        return E_FAIL;
    }
    else
    {
        return S_OK;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\refc.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <process.h>
#include <dsjet.h>
#include <ntdsa.h>
#include <scache.h>
#include <mdglobal.h>
#include <dbglobal.h>
#include <mdlocal.h>
#include <attids.h>
#include <dbintrnl.h>
#include <dsconfig.h>
#include <ctype.h>
#include <direct.h>
#include <ntdsa.h>
#include <dsutil.h>
#include <objids.h>
#include "ditlayer.h"
#include "scheck.h"
#include "crc32.h"

#include "reshdl.h"
#include "resource.h"

DWORD       bDeleted;
DWORD       insttype;
BYTE        bObject;
ULONG       ulDnt;
ULONG       ulPdnt;
ULONG       ulDName;
ULONG       ulNcDnt;
DSTIME      DelTime;
GUID        Guid;
SYSTEMTIME  NowTime;
ATTRTYP     ClassId;
SDID        sdId;

PDNAME_TABLE_ENTRY pDNameTable = NULL;
DWORD   DnameTableSize = 0;

JET_RETRIEVECOLUMN *jrc = NULL;
DWORD jrcSize = 0;
PDWORD AncestorBuffer = NULL;
PWCHAR szRdn = NULL;

#define COLS    14
JET_RETRIEVECOLUMN jrcf[COLS] =  {
    {0, &ulDnt, sizeof(ulDnt), 0, 0, 0, 1, 0, 0},
    {0, &ulPdnt, sizeof(ulPdnt), 0, 0, 0, 1, 0, 0},
    {0, &ClassId, sizeof(ClassId), 0, 0, 0, 1, 0, 0},
    {0, &bObject, sizeof(bObject), 0, 0, 0, 1, 0, 0},
    {0, &lCount, sizeof(lCount), 0, 0, 0, 1, 0, 0},
    {0, &bDeleted, sizeof(bDeleted), 0, 0, 0, 1, 0, 0},
    {0, &insttype, sizeof(insttype), 0, 0, 0, 1, 0, 0},
    {0, &ulNcDnt, sizeof(ulNcDnt), 0, 0, 0, 1, 0, 0},
    {0, NULL, sizeof(WCHAR)*512, 0, 0, 0, 1, 0, 0},
    {0, NULL, 2048, 0, 0, 0, 1, 0, 0},
    {0, NULL, sizeof(DWORD)*1024, 0, 0, 0, 1, 0, 0},
    {0, &DelTime, sizeof(DelTime), 0, 0, 0, 1, 0, 0},
    {0, &Guid, sizeof(Guid), 0, 0, 0, 1, 0, 0},
    {0, &ulDName, sizeof(ulDName), 0, 0, 0, 1, 0, 0}
};

#define PDNT_ENTRY          1
#define REFC_ENTRY          4
#define NCDNT_ENTRY         7
#define IT_ENTRY            COLS-8
#define RDN_ENTRY           COLS-6
#define SD_ENTRY            COLS-5
#define ANCESTOR_ENTRY      COLS-4
#define DELTIME_ENTRY       COLS-3
#define GUID_ENTRY          COLS-2
#define OBJ_DNAME_ENTRY     COLS-1


#define DEF_SUBREF_ENTRIES  16

char *szColNames[] = {
    SZDNT,
    SZPDNT,
    SZOBJCLASS,
    SZOBJ,
    SZCNT,
    SZISDELETED,
    SZINSTTYPE,
    SZNCDNT,
    SZRDNATT,
    SZNTSECDESC,
    SZANCESTORS,
    SZDELTIME,
    SZGUID,
    "ATTb49"        // obj dist name
};

DWORD   NcDntIndex = 0;
DWORD   GuidIndex = 0;
DWORD   DeltimeIndex = 0;
DWORD   AncestorIndex = 0;
DWORD   SdIndex = 0;
DWORD   rdnIndex = 0;
DWORD   itIndex = 0;
DWORD   subRefcolid = 0;

PREFCOUNT_ENTRY RefTable = NULL;
DWORD   RefTableSize = 0;

PSD_REFCOUNT_ENTRY SDRefTable = NULL;
DWORD SDRefTableSize = 0;

DWORD deletedFound = 0;
DWORD phantomFound = 0;
DWORD realFound = 0;
DWORD recFound = 0;
DWORD sdsFound = 0;

BOOL fDisableSubrefChecking = FALSE;    // should we check the subrefs

JET_ERR
GotoDnt(
    IN DWORD Dnt
    );

JET_ERR
GotoSdId(
    IN SDID sdId
    );

JET_ERR LoadRecord();

JET_ERR BuildSDRefTable(IN DWORD nSDs);

VOID
AddToSubRefList(
    PREFCOUNT_ENTRY pParent,
    DWORD Subref,
    BOOL fListed
    );

BOOL
FixSubref(
    IN DWORD Dnt,
    IN DWORD SubRef,
    IN BOOL  fAdd
    );

BOOL
FixRefCount(
    IN DWORD Dnt,
    IN DWORD OldCount,
    IN DWORD NewCount
    );

BOOL
FixSDRefCount(
    IN SDID sdID,
    IN DWORD OldCount,
    IN DWORD NewCount
    );

VOID
CheckSubrefs(
    IN BOOL fFixup
    );

VOID
CheckForBogusReference(
    IN DWORD Dnt,
    IN JET_COLUMNID ColId,
    IN PDWORD pSequence
    );

VOID
FixReferences(
    VOID
    );

VOID
CheckForBogusReferenceOnLinkTable(
    IN DWORD Dnt
    );

VOID XXX();

VOID
DoRefCountCheck(
    IN DWORD nRecs,
    IN DWORD nSDs,
    IN BOOL fFixup
    )
{
    JET_ERR err;
    DWORD i;
    DWORD checkPoint;
    PREFCOUNT_ENTRY pEntry;
    PREFCOUNT_ENTRY pCurrentEntry;
    PSD_REFCOUNT_ENTRY pSDEntry;
    DWORD seq;

    GetLocalTime(&NowTime);
    
    if ( !BuildRetrieveColumnForRefCount() ) {
        return;
    }

    if (sdtblid != -1) {
        // we got an SD table
        if (BuildSDRefTable(nSDs) != 0) {
            goto exit;
        }
    }

    //
    // Allocate our in memory structure
    //

    if ( nRecs < 50 ) {
        checkPoint = 5;
    } else if (nRecs < 1000) {
        checkPoint = 50;
    } else {
        checkPoint = 100;
    }

    RefTableSize = ROUND_ALLOC(nRecs);

    RefTable = LocalAlloc(LPTR, sizeof(REFCOUNT_ENTRY) * RefTableSize );
    if ( RefTable == NULL ) {
        //"Cannot allocate memory for %hs Table[entries = %d]\n"
        RESOURCE_PRINT2 (IDS_REFC_TABLE_ALLOC_ERR, "Ref", RefTableSize);
        goto exit;
    }

    RefTable[0].Dnt = 0xFFFFFFFF;
    RefTable[0].Actual = 1;

    deletedFound = 0;
    phantomFound = 0;
    realFound = 0;
    recFound = 0;

    //"Records scanned: %10u"
    RESOURCE_PRINT1 (IDS_REFC_REC_SCANNED, recFound);

    err = JetMove(sesid, tblid, JET_MoveFirst, 0);

    while ( !err ) {

        szRdn[0] = L'\0';
        ulDName = 0;
        bDeleted = 0;
        bObject = 0;
        insttype = 0;
        ulNcDnt = 0;
        ClassId = 0;
        sdId = 0;

        err = LoadRecord();
        if (err) {
            // We should not continue scanning!
            // Since we were not able to load a record, all our refcount computations
            // are now wrong. Bail.
            goto exit;
        }

        //printf("got dnt %d pdnt %d count %d\n", ulDnt, ulPdnt, lCount);

        pCurrentEntry = pEntry = FindDntEntry(ulDnt,TRUE);
        pEntry->Actual += lCount;
        pEntry->InstType = (WORD)insttype;
        pEntry->NcDnt = ulNcDnt;
        pEntry->fDeleted = bDeleted;
        pEntry->fObject = bObject;

        // update the SD ref count
        if (sdId != 0 && sdId != -1 && sdtblid != -1) {
            // SD was non-null and in the single-instancing format
            pSDEntry = FindSdEntry(sdId, FALSE);
            if (pSDEntry == NULL) {
                // strange. We should have failed in LoadRecord because SD would not be found.
                err = 1;
                goto exit;
            }
            pSDEntry->RefCount++;
            // update the SD length
            pSDEntry->cbSD = jrc[SdIndex].cbActual;
        }

        //
        // null terminate the rdn
        //

        szRdn[jrc[rdnIndex].cbActual/sizeof(WCHAR)] = L'\0';

        if ( ulDnt != 1 ) {

            //
            // Check the ancestor Blob
            //

            CheckAncestorBlob(pEntry);

            //
            // Check the security descriptor
            //

            ValidateSD( );
        }

        if ( (jrc[itIndex].err == JET_wrnColumnNull) && bObject ) {

            //
            // DNT == 1 is the NOT_AN_OBJECT object
            //

            if ( ulDnt != 1 ) {
                Log(TRUE,"No Instancetype for Dnt %d[%ws]\n",ulDnt, szRdn);
            }
        }

        //
        // ref the PDNT
        //

        if ( !jrc[PDNT_ENTRY].err ) {

            pEntry->Pdnt = ulPdnt;
            pEntry = FindDntEntry(ulPdnt,TRUE);
            pEntry->RefCount++;

        } else if ( ulDnt != 1 ) {

            Log(TRUE, "Dnt %d [%ws] does not have a PDNT\n", ulDnt, szRdn);
        }

        //
        // see if we need to process subrefs
        //

        if ( !jrc[NcDntIndex].err &&
             (insttype & IT_NC_HEAD) &&
             (ulDnt != ulNcDnt) &&
             (!bDeleted) ) {

            pEntry = FindDntEntry(ulNcDnt,TRUE);

            //
            // if this is an NC head, then it must be a subref of another NC head.
            // Add to the list.
            //

            AddToSubRefList(pEntry, ulDnt, FALSE);
        }

        //
        // everyone has an RDN
        //

        if ( jrc[rdnIndex].err ) {
            Log(TRUE, "Dnt %d does not have an RDN\n",ulDnt);
        }

        //
        // go through the entire list and ref the DNTs and the SDs
        //

        for (i=0;i < jrcSize; i++) {

            //
            // Syntax is zero if this is not a distname
            //

            if ( pDNameTable[i].Syntax == 0 ) {
                // we have already processed the predefined columns and the NTSD
                continue;
            }

            seq = 1;
            // the first value was just read in LoadRecord
            while ( jrc[i].err == JET_errSuccess  ) {
                DWORD alen;
                JET_RETINFO retInfo;

                if (pDNameTable[i].Syntax == SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE) {
                    SDID theSdId;
                    
                    // This is an SD-syntax attribute, but not NTSD (because NTSD has pDNameTable[i].Syntax == 0)
                    // If it appears to be an SDID then refCount it.
                    if (jrc[i].cbActual == sizeof(SDID)) {
                        theSdId = *((SDID*)jrc[i].pvData);

                        pSDEntry = FindSdEntry(theSdId, FALSE);
                        if (pSDEntry == NULL) {
                            // invalid SD reference? or invalid SD value?
                            // "SDID %016I64x refers to a missing SD [ColId %d, DNT %d (%ws)]\n", 
                            RESOURCE_PRINT4(IDS_REFC_SD_IS_MISSING, theSdId, jrc[i].columnid, ulDnt, szRdn);
                        }
                        else {
                            pSDEntry->RefCount++;
                        }
                    }
                }
                else {
                    // DN-valued attr
                    DWORD dnt;

                    dnt = (*((PDWORD)jrc[i].pvData));

                    //
                    // Find the entry and reference it.
                    //

                    pEntry = FindDntEntry(dnt,TRUE);
                    pEntry->RefCount++;

                    //
                    // See if we have more values
                    //

                    if ( jrc[i].columnid == subRefcolid ) {

                        AddToSubRefList( pCurrentEntry, dnt, TRUE );
                    }
                }

                // read next value
                retInfo.itagSequence = ++seq;
                retInfo.cbStruct = sizeof(retInfo);
                retInfo.ibLongValue = 0;
                jrc[i].err = JetRetrieveColumn(sesid,
                                               tblid,
                                               jrc[i].columnid,
                                               jrc[i].pvData,
                                               jrc[i].cbData,
                                               &alen,
                                               0,
                                               &retInfo);
            }

            if ( jrc[i].err != JET_wrnColumnNull) {
                Log(TRUE,"JetRetrieveColumn error[%S] [Colid %d Size %d]\n",
                        GetJetErrString(jrc[i].err),
                        jrc[i].columnid, jrc[i].cbActual);
            }
        }

        //
        // Check object and phantom properties
        //

        if ( bObject ) {

            //
            // A real object has both an object name and a GUID
            //

            if ( (ulDName == 0) && (ulDnt != 1) ) {
                Log(TRUE,
                    "Real object[DNT %d(%ws)] has no distinguished name!\n", ulDnt, szRdn);
            }

            if ( jrc[GuidIndex].err ) {
                Log(TRUE, "Cannot get GUID for object DNT %d(%ws). Jet Error [%S]\n",
                       ulDnt, szRdn, GetJetErrString(jrc[GUID_ENTRY].err));
            }

            if ( lCount == 0 ) {
                Log(TRUE, "DNT %d(%ws) has zero refcount\n",ulDnt, szRdn);
            }

            //
            // if this is deleted, the check the deletion date
            //

            if ( bDeleted ) {

                CheckDeletedRecord("Deleted");
                deletedFound++;
            } else {
                realFound++;
            }

        } else {

            phantomFound++;

            //
            // Should have no GUID or object dist name
            //

            if ( ulDName != 0 ) {
                Log(TRUE, "The phantom %d(%ws) has a distinguished name!\n",
                    ulDnt, szRdn);
            }

            if ( bDeleted ) {
                Log(TRUE, "Phantom %d(%ws) has deleted bit turned on!\n", ulDnt,szRdn);
            }

            ValidateDeletionTime("Phantom");
        }

        //
        // Check the object's replication blob
        //

        if ( bObject ) {
            CheckReplicationBlobs( );
        }

        recFound++;

        if ( (recFound % checkPoint) == 0 || recFound == nRecs ) {
            printf("\b\b\b\b\b\b\b\b\b\b%10u", recFound);
        }

        err = JetMove(sesid, tblid, JET_MoveNext, 0);
    }
    printf("\n");

    if (err != JET_errNoCurrentRecord) {
        Log(TRUE, "Error while walking data table. Last Dnt = %d. JetMove failed [%S]\n",
             ulDnt, GetJetErrString(err));
    }

    RESOURCE_PRINT (IDS_REFC_PROC_RECORDS);

    //
    // Get references from the link table
    //

    ProcessLinkTable( );

    fprintf(stderr,".");

    //
    // Print results
    //

    ProcessResults(fFixup);
    RESOURCE_PRINT (IDS_DONE);

exit:
    if ( jrc != NULL ) {

        if ( jrc[SdIndex].pvData != NULL ) {
            LocalFree(jrc[SdIndex].pvData);
        }

        if ( jrc[rdnIndex].pvData != NULL ) {
            LocalFree(jrc[rdnIndex].pvData);
        }

        if ( jrc[AncestorIndex].pvData != NULL ) {
            LocalFree(jrc[AncestorIndex].pvData);
        }

        LocalFree(jrc);
    }

    if ( RefTable != NULL ) {
        LocalFree(RefTable);
    }

    if (SDRefTable != NULL) {
        LocalFree(SDRefTable);
    }

    if ( pDNameTable != NULL ) {
        LocalFree(pDNameTable);
    }

} // DoRefCountCheck


PREFCOUNT_ENTRY
FindDntEntry(
    IN DWORD Dnt,
    IN BOOL fInsert
    )
{
    DWORD slot;
    DWORD inc;
    PREFCOUNT_ENTRY table = RefTable;
    PREFCOUNT_ENTRY entry;

    slot = Dnt & REFCOUNT_HASH_MASK;
    if ( Dnt == 0 ) {
        goto exit;
    }

    while ( slot < RefTableSize ) {

        entry = &table[slot];

        if ( entry->Dnt == Dnt ) {

            goto exit;

        } else if ( entry->Dnt == 0 ) {

            if ( fInsert ) {
                entry->Dnt = Dnt;
                goto exit;
            } else {
                return NULL;
            }
        }

        slot += REFCOUNT_HASH_INCR;
    }

    //
    // ok, we failed to get a slot on the first level hashing.
    // now do a secondary hash
    //

    inc = GET_SECOND_HASH_INCR(Dnt);

    while (TRUE ) {

        slot += inc;

        if ( slot >= RefTableSize ) {
            slot -= RefTableSize;
        }
        entry = &table[slot];

        if ( entry->Dnt == Dnt ) {
            goto exit;

        } else if ( entry->Dnt == 0 ) {

            if ( fInsert ) {
                entry->Dnt = Dnt;
                goto exit;
            } else {
                return NULL;
            }
        }
    }

exit:
    return &RefTable[slot];

} // FindDntEntry


BOOL
BuildRetrieveColumnForRefCount(
    VOID
    )
{
    DWORD i;

    JET_ERR err;
    JET_COLUMNLIST jcl;
    JET_RETRIEVECOLUMN ajrc[2];
    JET_TABLEID newtid;
    CHAR achColName[50];
    DWORD colCount;
    JET_COLUMNID jci;
    DWORD syntax;

    //
    // First do the required fields
    //

    colCount = COLS;
    DnameTableSize = colCount + 32;

    pDNameTable = LocalAlloc(LPTR,
                     DnameTableSize * sizeof(DNAME_TABLE_ENTRY));

    if ( pDNameTable == NULL ) {
        //"Cannot allocate memory for %hs Table[entries = %d]\n"
        RESOURCE_PRINT2 (IDS_REFC_TABLE_ALLOC_ERR, "DName", DnameTableSize);
        return FALSE;
    }

    for (i=0; i < COLS; i++) {

        JET_COLUMNDEF coldef;
        if (err = JetGetTableColumnInfo(sesid, tblid, szColNames[i], &coldef,
                sizeof(coldef), 0)) {

            //"%hs [%hs] failed with [%ws].\n",
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetTableColumnInfo", szColNames[i], GetJetErrString(jrc[i].err));
            return FALSE;
        }

        //printf("Name %s ColumnId %d type %d\n", szColNames[i], coldef.columnid, coldef.coltyp);

        jrcf[i].columnid = coldef.columnid;
        pDNameTable[i].ColId = coldef.columnid;
        pDNameTable[i].Syntax = 0;
        pDNameTable[i].pValue = &jrcf[i];
    }

    err = JetGetColumnInfo(sesid, dbid, SZDATATABLE, 0, &jcl,
                           sizeof(jcl), JET_ColInfoList);

    if ( err ) {
            //"%hs [%hs] failed with [%ws].\n",
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetGetColumnInfo",
                SZDATATABLE, GetJetErrString(jrc[i].err));
        return FALSE;
    }

    // Ok, now walk the table and extract info for each column.  Whenever
    // we find a column that looks like an attribute (name starts with ATT)
    // allocate an attcache structure and fill in the jet col and the att
    // id (computed from the column name).
    ZeroMemory(ajrc, sizeof(ajrc));

    ajrc[0].columnid = jcl.columnidcolumnid;
    ajrc[0].pvData = &jci;
    ajrc[0].cbData = sizeof(jci);
    ajrc[0].itagSequence = 1;
    ajrc[1].columnid = jcl.columnidcolumnname;
    ajrc[1].pvData = achColName;
    ajrc[1].cbData = sizeof(achColName);
    ajrc[1].itagSequence = 1;

    //
    // Go through the column list table
    //

    newtid = jcl.tableid;
    err = JetMove(sesid, newtid, JET_MoveFirst, 0);

    while (!err) {

        ZeroMemory(achColName, sizeof(achColName));
        err = JetRetrieveColumns(sesid, newtid, ajrc, 2);
        if ( err ) {
            //"%hs failed with [%ws].\n"
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetRetrieveColumn", GetJetErrString(err));
            continue;
        }
#if 0
        if ( jci == 790) {
            printf("name is %s\n",achColName);
        }
#endif
        if (strncmp(achColName,"ATT",3)) {
            // not an att column

            err = JetMove(sesid, newtid, JET_MoveNext, 0);
            continue;
        }

        syntax = achColName[3] - 'a';
        if ( (syntax == SYNTAX_DISTNAME_TYPE) ||
             (syntax == SYNTAX_DISTNAME_BINARY_TYPE) ||
             (syntax == SYNTAX_DISTNAME_STRING_TYPE) ||
             (syntax == SYNTAX_NT_SECURITY_DESCRIPTOR_TYPE && sdtblid != -1) ) {

            // printf("found an ATTname %s col %d\n", achColName, jci);

            if ( colCount >= DnameTableSize ) {

                PVOID tmp;
                DnameTableSize = colCount + 63;
                tmp = LocalReAlloc(pDNameTable,
                                       DnameTableSize * sizeof(DNAME_TABLE_ENTRY),
                                       LMEM_MOVEABLE | LMEM_ZEROINIT);

                if ( tmp == NULL ) {
                    //"Cannot allocate memory for %hs Table[entries = %d]\n"
                    RESOURCE_PRINT2 (IDS_REFC_TABLE_ALLOC_ERR, "DName", DnameTableSize);
                    return FALSE;
                }
                pDNameTable = (PDNAME_TABLE_ENTRY)tmp;
            }

            if ( strcmp(achColName, "ATTb131079") == 0) {
                subRefcolid = jci;
            }

            if ( jci != jrcf[OBJ_DNAME_ENTRY].columnid && jci != jrcf[SD_ENTRY].columnid ) {
                pDNameTable[colCount].ColId = jci;
                pDNameTable[colCount].Syntax = syntax;
                colCount++;
            }
        }

        err = JetMove(sesid, newtid, JET_MoveNext, 0);
    }

    err = JetCloseTable(sesid, newtid);

    //
    // ok, now we need to sort the entries based on column id
    //

    qsort(pDNameTable, colCount, sizeof(DNAME_TABLE_ENTRY), fnColIdSort);

    //
    // OK, now we build the retrieve column list
    //

    jrcSize = colCount;
    jrc = LocalAlloc(LPTR, sizeof(JET_RETRIEVECOLUMN) * jrcSize );

    if ( jrc == NULL ) {
        //"Cannot allocate memory for Jet retrieve column table\n"
        RESOURCE_PRINT (IDS_REFC_MEM_ERR1);
        return FALSE;
    }

    for (i=0;i<colCount;i++) {

        jrc[i].columnid = pDNameTable[i].ColId;
        jrc[i].itagSequence = 1;

        if ( pDNameTable[i].Syntax == SYNTAX_DISTNAME_TYPE ) {

            jrc[i].cbData = sizeof(DWORD);
            jrc[i].pvData = &pDNameTable[i].Value;

        } else if (pDNameTable[i].Syntax == 0) {

            //
            // Syntax is zero if this is not a distname
            //

            JET_RETRIEVECOLUMN *pJrc = (JET_RETRIEVECOLUMN*)pDNameTable[i].pValue;
            jrc[i].cbData = pJrc->cbData;
            jrc[i].pvData = pJrc->pvData;

            if ( jrc[i].columnid == jrcf[GUID_ENTRY].columnid ) {
                GuidIndex = i;
            } else if ( jrc[i].columnid == jrcf[ANCESTOR_ENTRY].columnid ) {
                jrc[i].pvData = LocalAlloc(LPTR, jrc[i].cbData);
                if ( jrc[i].pvData == NULL ) {
                    //"Cannot allocate ancestor buffer.\n"
                    RESOURCE_PRINT (IDS_REFC_MEM_ERR2);
                    return FALSE;
                }
                AncestorIndex = i;
                AncestorBuffer = (PDWORD)jrc[i].pvData;
            } else if ( jrc[i].columnid == jrcf[SD_ENTRY].columnid ) {

                jrc[i].pvData = LocalAlloc(LPTR, jrc[i].cbData);
                if ( jrc[i].pvData == NULL ) {
                    //"Cannot allocate security descriptor buffer.\n"
                    RESOURCE_PRINT (IDS_REFC_MEM_ERR3);
                    return FALSE;
                }
                SdIndex = i;

            } else if ( jrc[i].columnid == jrcf[RDN_ENTRY].columnid ) {
                jrc[i].pvData = LocalAlloc(LPTR, jrc[i].cbData + sizeof(WCHAR));
                if ( jrc[i].pvData == NULL ) {
                    //"Cannot allocate rdn buffer.\n"
                    RESOURCE_PRINT(IDS_REFC_MEM_ERR4);
                    return FALSE;
                }

                rdnIndex = i;
                szRdn = (PWCHAR)jrc[i].pvData;

            } else if ( jrc[i].columnid == jrcf[DELTIME_ENTRY].columnid ) {
                DeltimeIndex = i;
            } else if ( jrc[i].columnid == jrcf[NCDNT_ENTRY].columnid ) {
                NcDntIndex = i;
            } else if ( jrc[i].columnid == jrcf[IT_ENTRY].columnid ) {
                itIndex = i;
            } else if ( jrc[i].columnid == jrcf[OBJ_DNAME_ENTRY].columnid ) {
                pDNameTable[i].Syntax = SYNTAX_DISTNAME_TYPE;
            }
        } else {
            jrc[i].pvData = LocalAlloc(LPTR,64);
            if ( jrc[i].pvData == NULL ) {
                //"Cannot allocate data buffer for column %d\n"
                RESOURCE_PRINT1 (IDS_REFC_COL_ALLOC_ERR, i);
                jrc[i].cbData = 0;
            } else {
                jrc[i].cbData = 64;
            }
        }
    }

    return TRUE;
}


int __cdecl
fnColIdSort(
    const void * keyval,
    const void * datum
    )
{
    PDNAME_TABLE_ENTRY entry1 = (PDNAME_TABLE_ENTRY)keyval;
    PDNAME_TABLE_ENTRY entry2 = (PDNAME_TABLE_ENTRY)datum;
    return (entry1->ColId - entry2->ColId);

} // AuxACCmp


VOID
ValidateDeletionTime(
    IN LPSTR ObjectStr
    )
{

    CHAR szDelTime[32];

    //
    // should have delete time
    //

    if ( jrc[DeltimeIndex].err ) {
        Log(TRUE,"%s object %u does not have a deletion time. Error %d\n",
               ObjectStr, ulDnt, jrc[DELTIME_ENTRY].err);
    } else {

        SYSTEMTIME st;
        DWORD   now;
        DWORD   del;

        //
        // Check time
        //

        DSTimeToLocalSystemTime(DelTime, &st);

        now = NowTime.wYear * 12 + NowTime.wMonth;
        del = st.wYear * 12 + st.wMonth;

        if ( del > now ) {

            // this is for the deleted object containers
            if ( !(st.wYear == 9999 && st.wMonth==12 && st.wDay==31) ) {
                Log(VerboseMode,"WARNING: %s object %u has timestamp[%02d/%02d/%4d] later than now\n",
                    ObjectStr, ulDnt, st.wMonth, st.wDay, st.wYear);
            }

        } else if ( (now - del) > 6 ) {

            Log(VerboseMode,"WARNING: %s object %u has old timestamp[%02d/%02d/%4u]\n",
                   ObjectStr, ulDnt, st.wMonth, st.wDay, st.wYear);

        }
    }
} // ValidateDeletionTime


// Named IsRdnMangled to avoid warnings due to def of IsMangledRdn in mdlocal.h.
BOOL
IsRdnMangled(
    IN  WCHAR * pszRDN,
    IN  DWORD   cchRDN,
    OUT GUID *  pGuid
    )
/*++

Routine Description:

    Detect whether an RDN has been mangled by a prior call to MangleRDN().
    If so, decode the embedded GUID and return it to the caller.

Arguments:

    pszRDN (IN) - The RDN.

    cchRDN (IN) - Size in characters of the RDN.

    pGuid (OUT) - On return, holds the decoded GUID if found.

Return Values:

    TRUE - RDN was mangled; *pGuid holds the GUID passed to MangleRDN().

    FALSE - The RDN was not mangled.

--*/
{
    BOOL        fDecoded = FALSE;
    LPWSTR      pszGuid;
    RPC_STATUS  rpcStatus;

// Size in characters of tags (e.g., "DEL", "CNF") embedded in mangled RDNs.
#define MANGLE_TAG_LEN  (3)

// Size in characters of string (e.g.,
// "#DEL:a746b716-0ac0-11d2-b376-0000f87a46c8", where # is BAD_NAME_CHAR)
// appended to an RDN by MangleRDN().
#define MANGLE_APPEND_LEN   (1 + MANGLE_TAG_LEN + 1 + 36)
#define SZGUIDLEN (36)

    if ((cchRDN > MANGLE_APPEND_LEN)
        && (BAD_NAME_CHAR == pszRDN[cchRDN - MANGLE_APPEND_LEN])) {
        WCHAR szGuid[SZGUIDLEN + 1];

        // The RDN has indeed been mangled; decode it.
        pszGuid = pszRDN + cchRDN - MANGLE_APPEND_LEN + 1 + MANGLE_TAG_LEN + 1;

        // Unfortunately the RDN is not null-terminated, so we need to copy and
        // null-terminate it before we can hand it to RPC.
        memcpy(szGuid, pszGuid, SZGUIDLEN * sizeof(szGuid[0]));
        szGuid[SZGUIDLEN] = L'\0';

        rpcStatus = UuidFromStringW(szGuid, pGuid);

        if (RPC_S_OK == rpcStatus) {
            fDecoded = TRUE;
        }
        else {
            Log(TRUE,"UuidFromStringW(%ws, %p) returned %d!\n",
                    szGuid, pGuid, rpcStatus);
        }
    }

    return fDecoded;
}

VOID
CheckDeletedRecord(
    IN LPSTR ObjectStr
    )
{
    GUID guid;

    //
    // Make sure the times are cool
    //

    ValidateDeletionTime(ObjectStr);

    //
    // Check the GUID. Should start with DEL:
    //

    if ( !IsRdnMangled(szRdn,jrc[rdnIndex].cbActual/sizeof(WCHAR),&guid) ) {

        if ( _wcsicmp(szRdn,L"Deleted Objects") != 0 ) {
            Log(TRUE, "Deleted object %d(%ws) does not have a mangled rdn\n",ulDnt, szRdn);
        }
        return;
    }

    //
    // Compare the guid we got with this object's guid
    //

    if ( memcmp(&guid,&Guid,sizeof(GUID)) != 0 ) {
        Log(TRUE, "Object guid for deleted object %d(%ws) does not match the mangled version\n",
            ulDnt, szRdn);
    }

    return;

} // CheckDeletedRecord


VOID
CheckAncestorBlob(
    PREFCOUNT_ENTRY pEntry
    )
{
    PDWORD pId;
    DWORD nIds = 0;
    DWORD newCrc;

    if ( !jrc[AncestorIndex].err ) {
        nIds = jrc[AncestorIndex].cbActual/sizeof(DWORD);
    } else {

        Log(TRUE, "Cannot get ancestor for %d(%ws)\n", ulDnt, szRdn);
    }

    if ( nIds == 0 ) {
        Log(TRUE,"Object %d(%ws) does not have an ancestor\n", ulDnt,szRdn);
        return;
    }

    pId = AncestorBuffer;
    Crc32(0, jrc[AncestorIndex].cbActual, pId, &newCrc);

    //
    // Make sure last DNT is equal to current DNT. Make sure second to the last is
    // equal to the PDNT
    //

    if ( pId[nIds-1] != ulDnt ) {
        Log(TRUE,"Last entry[%d] of ancestor list does not match current DNT %d(%ws)\n",
               pId[nIds-1], ulDnt, szRdn);
    }

    if ( nIds >= 2 ) {
        if ( pId[nIds-2] != ulPdnt ) {
            Log(TRUE,"Second to last entry[%d] of ancestor list does not match PDNT[%d] of current DNT %d(%ws)\n",
                   pId[nIds-2], ulPdnt, ulDnt, szRdn);
        }
    }

    pEntry->nAncestors = (WORD)(nIds - 1);
    pEntry->AncestorCrc = newCrc;
    return;

} // CheckAncestorBlob


VOID
ValidateSD(
    VOID
    )
{
    SECURITY_DESCRIPTOR         *pSD = (SECURITY_DESCRIPTOR *)jrc[SdIndex].pvData;
    ACL                         *pDACL = NULL;
    BOOLEAN                     fDaclPresent = FALSE;
    BOOLEAN                     fDaclDefaulted = FALSE;
    NTSTATUS                    status;
    ULONG                       revision;
    SECURITY_DESCRIPTOR_CONTROL control;
    DWORD                       cb;

    if ( jrc[SdIndex].err != JET_errSuccess ) {
        if ( jrc[SdIndex].err == JET_wrnColumnNull ) {

            //
            // if not real object, don't expect a SD
            //

            if ( !bObject ) {
                return;
            }

            //
            // not instantiated, no SD.
            //

            if ( insttype & IT_UNINSTANT ) {
                return;
            }

            Log(TRUE, "Object %d(%ws) does not have a Security descriptor.\n",
                ulDnt, szRdn);
            return;

        } else {

            Log(TRUE, "Jet Error [%S] retrieving security descriptor for object %d(%ws).\n",
                GetJetErrString(jrc[SdIndex].err), ulDnt, szRdn);
            return;
        }
    }

    if ( !bObject ) {

        Log(TRUE, "Non object %d(%ws) has a security descriptor\n", ulDnt, szRdn);
        return;
    }

    cb = jrc[SdIndex].cbActual;

    // Parent SD can be legally NULL - caller tells us via fNullOK.

    if ( !cb ) {
        Log(TRUE,"Object %d(%ws) has a null SD\n",ulDnt, szRdn);
        return;
    }

    if (ulDnt == ROOTTAG) {
        // don't check the SD on the root object. It's invalid (there's a prepended DWORD),
        // but it's unused
        return;
    }

    // Does base NT like this SD?

    status = RtlValidRelativeSecurityDescriptor(pSD, cb, 0);
    if ( !NT_SUCCESS(status) ) {
        Log(TRUE,"Object %d(%ws) has an invalid Security Descriptor [error %x]\n",
               ulDnt,szRdn,status);
        return;
    }

    // Every SD should have a control field.

    status = RtlGetControlSecurityDescriptor(pSD, &control, &revision);

    if ( !NT_SUCCESS(status) ) {

        Log(TRUE,"Error(0x%x) getting SD control for %d(%ws). Rev %d\n",
                status, ulDnt, szRdn, revision);
        return;
    }

    // Emit warning if protected bit is set as this stops propagation
    // down the tree.

    if ( control & SE_DACL_PROTECTED ) {
        if ( !bDeleted ) {
            Log(VerboseMode,"Warning SE_DACL_PROTECTED for %d(%ws)\n",ulDnt,szRdn);
        }
    }

    // Every SD in the DS should have a DACL.

    status = RtlGetDaclSecurityDescriptor(
                            pSD, &fDaclPresent, &pDACL, &fDaclDefaulted);

    if ( !NT_SUCCESS(status) ) {
        Log(TRUE,"Error(0x%x) getting DACL for %d(%ws)\n",status,ulDnt,szRdn);
        return;
    }

    if ( !fDaclPresent )
    {
        Log(TRUE,"No DACL found for %d(%ws)\n",ulDnt,szRdn);
        return;
    }

    // A NULL Dacl is equally bad.

    if ( NULL == pDACL ) {
        Log(TRUE,"NULL DACL for %d(%ws)\n",ulDnt,szRdn);
        return;
    }
    // A DACL without any ACEs is just as bad as no DACL at all.

    if ( 0 == pDACL->AceCount ) {
        Log(TRUE,"No ACEs in DACL for %d(%ws)\n",ulDnt,szRdn);
        return;
    }
    return;

} // ValidateSD


VOID
ProcessLinkTable(
    VOID
    )
{

    DWORD err;
    PREFCOUNT_ENTRY pEntry;

    //
    // Walk the link table and retrieve the backlink field to get additional
    // references.
    //

    err = JetMove(sesid, linktblid, JET_MoveFirst, 0);

    while ( !err ) {

        DWORD blinkdnt;
        DWORD alen;

        err = JetRetrieveColumn(sesid,
                                linktblid,
                                blinkid,
                                &blinkdnt,
                                sizeof(blinkdnt),
                                &alen,
                                0,
                                NULL);

        if (err && (err != JET_wrnColumnNull) && (err != JET_wrnBufferTruncated)) {

            Log(TRUE,"Cannot retrieve back link column. Error [%S].\n",
                GetJetErrString(err));
            return;
        }

        if (!err) {
            pEntry = FindDntEntry(blinkdnt,TRUE);
            if ( pEntry != NULL ) {
                pEntry->RefCount++;
            } else {
                Log(TRUE,"Data Table has missing backlink entry DNT %d.\n",
                    blinkdnt);
            }
        }
        err = JetMove(sesid, linktblid, JET_MoveNext, 0);
    }
} // ProcessLinkTable



VOID
ProcessResults(
    IN BOOL fFixup
    )
{

    Log(VerboseMode, "%d total records walked.\n",recFound);

    //
    // Check Subrefs. We need to do subref fixing before refcount checking since
    // this might change the refcount of an object.
    //

    CheckSubrefs( fFixup );

    //
    // CheckRefCount
    //

    CheckRefCount( fFixup );

    //
    // Check Ancestors
    //

    CheckAncestors( fFixup );

    //
    // Check InstanceTypes
    //

    CheckInstanceTypes( );

    if (sdtblid != -1) {
        CheckSDRefCount( fFixup );
    }

    return;
} // ProcessResults


DWORD
FixAncestors (VOID)
{
    JET_TABLEID sdproptblid = JET_tableidNil;
    JET_ERR err;
    JET_COLUMNDEF coldef;
    JET_COLUMNID begindntid;
    JET_COLUMNID trimmableid;
    JET_COLUMNID orderid;
    BYTE Trim=1;
    DWORD index, cbActual;
    DWORD rootTAG = ROOTTAG;


    __try
    {
        if (err = JetOpenTable(sesid,
                               dbid,
                               SZPROPTABLE,
                               NULL,
                               0,
                               JET_bitTableUpdatable | JET_bitTableDenyRead,
                               &sdproptblid)) {

            sdproptblid = JET_tableidNil;
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetOpenTable",
                    SZPROPTABLE, GetJetErrString(err));
            _leave;
        }

        // get several needed column ids

        if ((err = JetGetTableColumnInfo(sesid, sdproptblid, SZBEGINDNT, &coldef,
                                         sizeof(coldef), 0)) != JET_errSuccess) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetGetTableColumnInfo", GetJetErrString(err));
            _leave;
        }
        begindntid = coldef.columnid;

        if ((err = JetGetTableColumnInfo(sesid, sdproptblid, SZTRIMMABLE, &coldef,
                                         sizeof(coldef), 0)) != JET_errSuccess) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetGetTableColumnInfo", GetJetErrString(err));
            _leave;
        }
        trimmableid = coldef.columnid;

        if ((err = JetGetTableColumnInfo(sesid, sdproptblid, SZORDER,
                                         &coldef,
                                         sizeof(coldef), 0)) != JET_errSuccess) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetGetTableColumnInfo", GetJetErrString(err));
            _leave;
        }
        orderid = coldef.columnid;


        // check to see if propagation already there
        // we insert in the end

        err = JetMove (sesid,
                       sdproptblid,
                       JET_MoveLast, 0);


        if (err == JET_errSuccess) {
            err = JetRetrieveColumn(sesid,
                                    sdproptblid,
                                    begindntid,
                                    &index,
                                    sizeof(index),
                                    &cbActual,
                                    JET_bitRetrieveCopy,
                                    NULL);

            if (err == JET_errSuccess) {
                if (index == ROOTTAG) {

                    err = JetRetrieveColumn(sesid,
                                            sdproptblid,
                                            orderid,
                                            &index,
                                            sizeof(index),
                                            &cbActual,
                                            JET_bitRetrieveCopy,
                                            NULL);


                    Log(TRUE,"Propagation to fix Ancestry already enqueued (id=%d). Skipped.\n", index);
                    _leave;
                }
            }
        }

        Log(TRUE,"Enqueing a propagation to fix Ancestry\n");

        err = JetPrepareUpdate(sesid,
                               sdproptblid,
                               JET_prepInsert);
        if ( err ) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetPrepareUpdate", GetJetErrString(err));
            _leave;
        }


        // Set the DNT column
        err = JetSetColumn(sesid,
                           sdproptblid,
                           begindntid,
                           &rootTAG,
                           sizeof(rootTAG),
                           0,
                           NULL);

        if(err != DB_success)   {
            JetPrepareUpdate(sesid,
                             sdproptblid,
                             JET_prepCancel);
            _leave;
        }

        err = JetSetColumn(sesid,
                           sdproptblid,
                           trimmableid,
                           &Trim,
                           sizeof(Trim),
                           0,
                           NULL);
        if(err != DB_success) {
            JetPrepareUpdate(sesid,
                             sdproptblid,
                             JET_prepCancel);
            _leave;
        }

        err = JetRetrieveColumn(sesid,
                                sdproptblid,
                                orderid,
                                &index,
                                sizeof(index),
                                &cbActual,
                                JET_bitRetrieveCopy,
                                NULL);

        Log(TRUE,"Propagation to fix Ancestry Enqueued (id=%d). Propagation will be done the next time the DS is restarted.\n", index);

        err = JetUpdate(sesid,
                        sdproptblid,
                        NULL,
                        0,
                        NULL);

        if(err != DB_success)  {
            JetPrepareUpdate(sesid,
                             sdproptblid,
                             JET_prepCancel);
            _leave;
        }
    }
    __finally
    {
        if ( sdproptblid != JET_tableidNil ) {
            JetCloseTable(sesid,sdproptblid);
        }
    }

    return err;
}



VOID
CheckAncestors(
    IN BOOL fFixup
    )
{
    PREFCOUNT_ENTRY pEntry;
    DWORD i;
    BOOL  fNeedFix = FALSE;

    for ( i=0; i < RefTableSize; i++ ) {

        DWORD dnt = RefTable[i].Dnt;

        if ( dnt != 0 ) {

            DWORD newCrc;
            DWORD pdnt;
            DWORD ncdnt;
            BOOL  foundNcDnt;
            BOOL  nextNCExists;

            //
            // Check ancestors. Make sure that the ancestor of current DNT is
            // equal to ancestor of parent + current DNT
            //

            if ( RefTable[i].Pdnt != 0 ) {
                pEntry = FindDntEntry(RefTable[i].Pdnt,FALSE);
                if ( pEntry != NULL ) {

                    Crc32(pEntry->AncestorCrc, sizeof(DWORD), &RefTable[i].Dnt, &newCrc);

                    if ( newCrc != RefTable[i].AncestorCrc ) {
                        Log(TRUE,"Ancestor crc inconsistency for DNT %d PDNT %d.\n",
                            dnt, RefTable[i].Pdnt );

                        fNeedFix = TRUE;
                    }

                    if ( RefTable[i].nAncestors != (pEntry->nAncestors+1)) {
                        Log(TRUE,"Ancestor count mismatch for DNT %d.\n",dnt);

                        fNeedFix = TRUE;
                    }
                } else {
                    Log(TRUE, "parent [PDNT %d] of entry [dnt %d] is missing.\n",
                        RefTable[i].Pdnt, dnt);
                }
            }

            //
            // Walk up the PDNT link until we hit the parent
            //

            if ( RefTable[i].InstType == 0 ) {
                continue;
            }

            ncdnt = RefTable[i].NcDnt;
            pdnt = RefTable[i].Pdnt;
            nextNCExists = FALSE;
            foundNcDnt = FALSE;

            while ( pdnt != 0 ) {

                pEntry = FindDntEntry(pdnt,FALSE);
                if ( pEntry == NULL ) {
                    Log(TRUE, "Ancestor [dnt %d] of entry [dnt %d] is missing.\n",
                        pdnt, dnt);
                    break;
                }

                //
                // If we've aready gone through this object, then we're done.
                //

                if ( (ncdnt == pdnt) || nextNCExists ) {

                    if ( ((pEntry->InstType & IT_NC_HEAD) == 0) ||
                          (pEntry->InstType & IT_UNINSTANT) ) {

                        if ( nextNCExists ) {
                            Log(TRUE,"Expecting %d to be instantiated NC head. Referring entry %d\n",
                               pdnt, RefTable[i].Dnt);
                        }
                    }

                    nextNCExists = FALSE;

                    if ( ncdnt == pdnt ) {
                        foundNcDnt = TRUE;
                    }
                }

                if ( pEntry->InstType & IT_NC_ABOVE ) {
                    nextNCExists = TRUE;
                }

                if ( pEntry->Pdnt == 0 ) {
                    if ( (pEntry->InstType & IT_NC_HEAD) == 0 ) {
                        Log(TRUE,"Unexpected termination of search on non NC Head %d\n",
                               pEntry->Pdnt);
                    }
                }
                pdnt = pEntry->Pdnt;
            }

            if (RefTable[i].Pdnt != 0) {

                if ( !foundNcDnt ) {
                    Log(TRUE,"Did not find the NCDNT for object %d\n",RefTable[i].Dnt);
                }
            }
        }
    }

    if (fNeedFix && fFixup) {
        FixAncestors ();
    }

    return;

} //CheckAncestors


VOID
CheckInstanceTypes(
    VOID
    )
{
    DWORD i;
    PREFCOUNT_ENTRY pEntry;

    for ( i=0; i < RefTableSize; i++ ) {

        if ( RefTable[i].Dnt != 0 ) {

            SYNTAX_INTEGER instType = RefTable[i].InstType;
            DWORD dnt = RefTable[i].Dnt;

            //
            // Make sure the instance type is valid. Root object (dnt 2)
            // is an exception.
            //

            if ( !ISVALIDINSTANCETYPE(instType) ) {
                if ( (dnt != 2) || (instType != (IT_UNINSTANT | IT_NC_HEAD)) ) {
                    Log(TRUE,"Invalid instance type %x for Dnt %d\n",
                           instType, dnt);
                }
                continue;
            }

            //
            // if not object, then no instance type
            //

            if ( !RefTable[i].fObject ) {
                continue;
            }

            //
            // For non-NCHead objects, if instance type has IT_WRITE,
            // the parent should also have it
            //

            if ( (instType & IT_NC_HEAD) == 0 ) {

                BOOL writeable, parentWriteable;

                pEntry = FindDntEntry(RefTable[i].Pdnt,FALSE);
                if ( pEntry == NULL ) {
                    Log(TRUE,"Parent [PDNT %d] of DNT %d missing\n",
                        RefTable[i].Pdnt, dnt);
                    continue;
                }

                writeable = (BOOL)((instType & IT_WRITE) != 0);
                parentWriteable = (BOOL)((pEntry->InstType & IT_WRITE) != 0);

                if ( writeable != parentWriteable ) {
                    Log(TRUE,"Inconsistent Instance type for %d and parent %d [%x != %x]\n",
                            dnt,RefTable[i].Pdnt,instType,pEntry->InstType);
                }

                //
                // fSubRef should not be set on non NC heads
                //

                if ( RefTable[i].fSubRef ) {
                    Log(TRUE,"Non Nc Head %d marked as SubRef\n",dnt);
                }
            }
        }
    }
    return;

} // CheckInstanceTypes


VOID
CheckSubrefs(
    IN BOOL fFixup
    )
{

    DWORD i;
    DWORD fBad = FALSE;

    //
    // If stated and found refcounts are different, print a message
    //

    for ( i=1; i < RefTableSize; i++ ) {

        // ok, we have something...
        if ( RefTable[i].Subrefs != NULL ) {

            // ignore if fatal error or object is a phantom

            if ( !fDisableSubrefChecking && RefTable[i].fObject ) {

                DWORD j;
                PSUBREF_ENTRY pSubref = RefTable[i].Subrefs;

                for (j=0; j < RefTable[i].nSubrefs; j++ ) {

                    // if found and also listed, then everything is fine.
                    if ( pSubref[j].fListed && pSubref[j].fFound ) {
                        continue;
                    }

                    // if found only, then

                    fBad = TRUE;
                    if ( pSubref[j].fFound ) {
                        Log(TRUE, "Missing subref entry for %d on %d.\n",
                               pSubref[j].Dnt, RefTable[i].Dnt);
                    } else {
                        Log(TRUE, "Found extra subref entry for %d on %d.\n",
                               pSubref[j].Dnt, RefTable[i].Dnt);
                    }

                    if ( fFixup ) {

                        // if fixup succeeded, add a ref to the subref
                        if ( FixSubref(RefTable[i].Dnt, pSubref[j].Dnt, pSubref[j].fFound) ){

                            PREFCOUNT_ENTRY pEntry;

                            //
                            // if add, increment else decrement
                            //

                            pEntry = FindDntEntry(pSubref[j].Dnt,FALSE);
                            //
                            // PREFIX: Since it's technically possible for
                            // FindDntEntry() to return NULL, the following
                            // check on pEntry was added to shut PREFIX up.
                            // FindDntEntry() should never return NULL here though.
                            //
                            if (pEntry) {
                                if ( pSubref[j].fFound ) {
                                    pEntry->RefCount++;
                                } else {
                                    pEntry->RefCount--;
                                }
                            }
                        }
                    }
                }
            }

            // free blob

            LocalFree(RefTable[i].Subrefs);
            RefTable[i].Subrefs = NULL;
            RefTable[i].nSubrefs = 0;
        }
    }

    if ( fBad ) {
        fprintf(stderr, "\nError: Missing subrefs detected.\n");
    }

    return;

} // CheckSubrefs

VOID
CheckRefCount(
    IN BOOL fFixup
    )
{

    BOOL fBad = FALSE;
    DWORD i;
    BOOL  fRemoveInvalidReference = FALSE;

    // call Log multiple times because it is unable to output \n's properly
    Log(TRUE,"Summary:\n");
    Log(TRUE,"Active Objects \t%8u\n", realFound);
    Log(TRUE,"Phantoms \t%8u\n", phantomFound);
    Log(TRUE,"Deleted \t%8u\n", deletedFound);

    //
    // If stated and found refcounts are different, print a message
    //

    for ( i=1; i < RefTableSize; i++ ) {

        // ignore weird DNTs (0,1,2,3)
        if ( RefTable[i].Dnt > 3 ) {

            //
            // if not equal
            //

            if ( RefTable[i].RefCount != RefTable[i].Actual ) {

                BOOL fFixed;

                fBad = TRUE;
                if ( fFixup ) {
                    fFixed = FixRefCount(RefTable[i].Dnt,
                                    RefTable[i].Actual,
                                    RefTable[i].RefCount);
                } else {
                    fFixed = FALSE;
                }

                Log(TRUE,"RefCount mismatch for DNT %u [RefCount %4u References %4u] [%s]\n",
                       RefTable[i].Dnt,
                       RefTable[i].Actual,
                       RefTable[i].RefCount,
                       fFixed ? "Fixed" : "Not Fixed");

                //
                // if this had been fixed, indicate this on the count
                //

                if ( fFixed ) {
                    RefTable[i].Actual = RefTable[i].RefCount;

                } else if ( fFixup &&
                            (RefTable[i].Actual == 0) &&
                            (RefTable[i].RefCount != 0) ) {

                    //
                    // This indicates that we have a reference to a
                    // non-existent object
                    //

                    fRemoveInvalidReference = TRUE;
                }
            }
        }
    }

    //
    // See if we need to run the reference fixer
    //

    if ( fRemoveInvalidReference ) {
        FixReferences();
    }

    if ( fBad ) {
        fprintf(stderr, "\nError: Inconsistent refcounts detected.\n");
    }

    return;

} // CheckRefCount


BOOL
ExpandBuffer(
    JET_RETRIEVECOLUMN *jetcol
    )
{

    PCHAR p;
    DWORD len = jetcol->cbActual + 512;

    p = LocalAlloc(0,len);
    if ( p != NULL ) {

        if ( jetcol->pvData != NULL ) {
            LocalFree(jetcol->pvData);
        }
        jetcol->pvData = p;
        jetcol->cbData = len;

        return TRUE;
    }
    RESOURCE_PRINT1(IDS_ERR_MEMORY_ALLOCATION, len);
    return FALSE;
}




VOID
DisplayRecord(
    IN DWORD Dnt
    )
{
    JET_ERR err;
    DWORD i;

    if ( !BuildRetrieveColumnForRefCount() ) {
        return;
    }

    // seek using DNT
    err = GotoDnt(Dnt);
    if ( err ) {
        return;
    }

    szRdn[0] = L'\0';
    ulDName = 0;
    bDeleted = 0;
    bObject = 0;
    insttype = 0;
    ulNcDnt = 0;
    ClassId = 0;

    err = LoadRecord();
    if (err) {
        return;
    }

    //
    // display the results
    //

    szRdn[jrc[rdnIndex].cbActual/sizeof(WCHAR)] = L'\0';

    //"\n\nData for DNT %d\n\n", Dnt
    //"RDN = %ws\n", szRdn
    //"PDNT = %d\n", ulPdnt
    //"RefCount = %d\n", lCount
    RESOURCE_PRINT4 (IDS_REFC_RESULTS1, Dnt, szRdn, ulPdnt, lCount);


    if (VerboseMode) {
        //"DNT of NC = %d\n", ulNcDnt);
        //"ClassID = 0x%x\n", ClassId);
        //"Deleted? %s\n", bDeleted ? "YES" : "NO");
        //"Object? %s\n", bObject ? "YES" : "NO");

        RESOURCE_PRINT4 (IDS_REFC_RESULTS2, ulNcDnt, ClassId, bDeleted ? L"YES" : L"NO", bObject ? L"YES" : L"NO");

        if (!jrc[itIndex].err ) {
            //"Instance Type = 0x%x\n"
            RESOURCE_PRINT1 (IDS_REFC_INSTANCE_TYPE, insttype);
        } else if (jrc[itIndex].err == JET_wrnColumnNull) {
            //"No Instance Type\n"
            RESOURCE_PRINT (IDS_REFC_NOINSTANCE_TYPE);
        }

        if ( jrc[SdIndex].err == JET_errSuccess ) {
            //"Security Descriptor Present [Length %d].\n"
            RESOURCE_PRINT1 (IDS_REFC_SEC_DESC_PRESENT, jrc[SdIndex].cbActual);
        } else if (jrc[SdIndex].err == JET_wrnColumnNull ) {
            //"No Security Descriptor Found.\n"
            RESOURCE_PRINT (IDS_REFC_SEC_DESC_NOTPRESENT);
        } else {
            //"Error fetching security descriptor [%ws]\n";
            RESOURCE_PRINT1 (IDS_REFC_ERR_FETCH_SEC_DESC, GetJetErrString(jrc[SdIndex].err));
        }

        //
        // Ancestor index
        //

        if ( !jrc[AncestorIndex].err ) {
            DWORD nAncestors;
            // "Ancestors = "
            RESOURCE_PRINT (IDS_REFC_ANCESTORS);
            nAncestors = jrc[AncestorIndex].cbActual/sizeof(DWORD);
            for (i=0;i<nAncestors;i++) {
                fprintf(stderr,"%u ",AncestorBuffer[i]);
            }
            fprintf(stderr,"\n");
        }
    }
    return;
}

BOOL
FixSubref(
    IN DWORD Dnt,
    IN DWORD SubRef,
    IN BOOL  fAdd
    )
{
    JET_ERR err;
    INT seq = -1;
    JET_SETINFO setInfo;
    DWORD setFlags = 0;

    // seek using DNT
    err = GotoDnt(Dnt);
    if ( err ) {
        return FALSE;
    }

    //
    // Replace the value
    //

    err = JetPrepareUpdate(sesid,
                           tblid,
                           JET_prepReplace);
    if ( err ) {

        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetPrepareUpdate", GetJetErrString(err));
        return FALSE;
    }

    // if not add, then this is a delete. Look for this particular entry

    if ( !fAdd ) {

        JET_RETINFO retInfo;
        retInfo.itagSequence = 0;
        retInfo.cbStruct = sizeof(retInfo);
        do {

            DWORD alen;
            DWORD dnt;

            retInfo.itagSequence++;
            retInfo.ibLongValue = 0;

            err = JetRetrieveColumn(sesid,
                                    tblid,
                                    subRefcolid,
                                    &dnt,
                                    sizeof(dnt),
                                    &alen,
                                    0,
                                    &retInfo);

            if ( !err ) {
                if ( dnt == SubRef ) {
                    // found it!
                    seq = retInfo.itagSequence;
                    break;
                }
            }

        } while (!err);

    } else {
        seq = 0;
        setFlags = JET_bitSetUniqueMultiValues;
    }

    // !!! Should not happen. If entry not found, then bail out.
    if ( seq == -1) {
        fprintf(stderr, "Cannot find subref %d on object %d\n",
                SubRef, Dnt);
        return FALSE;
    }

    setInfo.cbStruct = sizeof(setInfo);
    setInfo.ibLongValue = 0;
    setInfo.itagSequence = seq;

    err = JetSetColumn(sesid,
                       tblid,
                       subRefcolid,
                       fAdd ? &SubRef : NULL,
                       fAdd ? sizeof(SubRef) : 0,
                       setFlags,
                       &setInfo);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetSetColumn", GetJetErrString(err));
        return FALSE;
    }

    err = JetUpdate(sesid,
                    tblid,
                    NULL,
                    0,
                    NULL);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetUpdate", GetJetErrString(err));
        return FALSE;
    }

    if ( fAdd ) {
        Log(TRUE, "Added subref %d to object %d.\n",SubRef,Dnt);
    } else {
        Log(TRUE, "Deleted subref %d from object %d.\n",SubRef,Dnt);
    }
    return TRUE;
}


BOOL
FixRefCount(
    IN DWORD Dnt,
    IN DWORD OldCount,
    IN DWORD NewCount
    )
{
    JET_ERR err;
    DWORD nActual;
    DWORD refCount;

    // seek using DNT
    err = GotoDnt(Dnt);
    if ( err ) {
        return FALSE;
    }

    err = JetRetrieveColumn(sesid,
                            tblid,
                            jrcf[REFC_ENTRY].columnid,
                            &refCount,
                            sizeof(refCount),
                            &nActual,
                            0,
                            NULL
                            );

    if (err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetRetrieveColumn", GetJetErrString(err));
        return FALSE;
    }

    //
    // Replace the value
    //

    err = JetPrepareUpdate(sesid,
                           tblid,
                           JET_prepReplace);
    if ( err ) {

        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetPrepareUpdate", GetJetErrString(err));
        return FALSE;
    }

    err = JetSetColumn(sesid,
                       tblid,
                       jrcf[REFC_ENTRY].columnid,
                       &NewCount,
                       sizeof(NewCount),
                       0,
                       NULL);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetSetColumn", GetJetErrString(err));
        return FALSE;
    }

    err = JetUpdate(sesid,
                    tblid,
                    NULL,
                    0,
                    NULL);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetUpdate", GetJetErrString(err));
        return FALSE;
    }

    return TRUE;
}


VOID
FixReferences(
    VOID
    )
{
    JET_ERR err;
    DWORD i;

    Log(TRUE,"\n\nRemoving Non-existent references:\n\n");
    err = JetMove(sesid, tblid, JET_MoveFirst, 0);

    while ( !err ) {

        err = JetRetrieveColumns(sesid, tblid, jrc, jrcSize);

        if (err && (err != JET_wrnColumnNull) && (err != JET_wrnBufferTruncated)) {

            Log(TRUE,"JetRetrieveColumns error: %S.\n", GetJetErrString(err));
            goto next_rec;
        }

        //
        // make sure pdnt is referring to something valid
        //

        if ( !jrc[PDNT_ENTRY].err ) {
            CheckForBogusReference(ulPdnt, jrc[PDNT_ENTRY].columnid, NULL);
        }

        //
        // go through the entire list and ref the DNTs
        //

        for (i=0;i < jrcSize; i++) {

            //
            // Syntax is zero if this is not a distname
            //

            if ( pDNameTable[i].Syntax == 0 ) {
                continue;
            }

            if ( !jrc[i].err ) {

                DWORD dnt;
                DWORD seq;

                seq = 1;
                dnt = (*((PDWORD)jrc[i].pvData));
                CheckForBogusReference(dnt, jrc[i].columnid, &seq);

                //
                // See if we have more values
                //

                do {

                    DWORD alen;
                    JET_RETINFO retInfo;

                    retInfo.itagSequence = ++seq;
                    retInfo.cbStruct = sizeof(retInfo);
                    retInfo.ibLongValue = 0;
                    err = JetRetrieveColumn(sesid,
                                            tblid,
                                            jrc[i].columnid,
                                            jrc[i].pvData,
                                            jrc[i].cbData,
                                            &alen,
                                            0,
                                            &retInfo);

                    if ( !err ) {

                        dnt = (*((PDWORD)jrc[i].pvData));
                        CheckForBogusReference(dnt, jrc[i].columnid, &seq);
                    }

                } while (!err);
            }
        }

next_rec:

        err = JetMove(sesid, tblid, JET_MoveNext, 0);
    }

    if (err != JET_errNoCurrentRecord) {
        Log(TRUE, "Error while walking data table. Last Dnt = %d. JetMove failed [%S]\n",
             ulDnt, GetJetErrString(err));
    }

    //
    // Go through link table
    //

    //
    // Walk the link table and retrieve the backlink field to get additional
    // references.
    //

    err = JetMove(sesid, linktblid, JET_MoveFirst, 0);

    while ( !err ) {

        DWORD blinkdnt;
        DWORD alen;

        err = JetRetrieveColumn(sesid,
                                linktblid,
                                blinkid,
                                &blinkdnt,
                                sizeof(blinkdnt),
                                &alen,
                                0,
                                NULL);

        if (err && (err != JET_wrnColumnNull) && (err != JET_wrnBufferTruncated)) {

            Log(TRUE,"Cannot retrieve back link column. Error [%S].\n",
                GetJetErrString(err));
            return;
        }

        if (!err) {
            CheckForBogusReferenceOnLinkTable(blinkdnt);
        }
        err = JetMove(sesid, linktblid, JET_MoveNext, 0);
    }
}

VOID
CheckForBogusReference(
    IN DWORD Dnt,
    IN JET_COLUMNID ColId,
    IN PDWORD Sequence
    )
{
    JET_ERR err;
    DWORD refCount;
    PREFCOUNT_ENTRY pEntry;
    JET_SETINFO SetInfo;
    JET_SETINFO * pSetInfo = NULL;
    BOOL fTransactionInProgress = FALSE;

    if ( Dnt <= 3 ) {
        return;
    }

    pEntry = FindDntEntry(Dnt,FALSE);
    if ( pEntry == NULL ) {             // should never happen
        return;
    }

    if ( (pEntry->Actual != 0) || (pEntry->RefCount == 0) ) {   // refCount == 0 should never happen
        return;
    }

    //
    // Start a transaction
    //

    err = JetBeginTransaction(sesid);
    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetBeginTransaction", GetJetErrString(err));
        goto error_exit;
    }

    //
    // Remove the reference
    //

    fTransactionInProgress = TRUE;
    err = JetPrepareUpdate(sesid,
                           tblid,
                           JET_prepReplace);
    if ( err ) {

        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetPrepareUpdate", GetJetErrString(err));
        goto error_exit;
    }

    if ( Sequence != NULL ) {
        SetInfo.itagSequence = *Sequence;
        SetInfo.cbStruct = sizeof(SetInfo);
        SetInfo.ibLongValue = 0;
        pSetInfo = &SetInfo;
    }

    err = JetSetColumn(sesid,
                       tblid,
                       ColId,
                       NULL,
                       0,
                       0,
                       pSetInfo);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetSetColumn", GetJetErrString(err));
        goto error_exit;
    }

    err = JetUpdate(sesid,
                    tblid,
                    NULL,
                    0,
                    NULL);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetUpdate", GetJetErrString(err));
        goto error_exit;
    }

    err = JetCommitTransaction(sesid,0);
    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetCommitTransaction", GetJetErrString(err));
        goto error_exit;
    }

    fTransactionInProgress = FALSE;
    pEntry->RefCount--;

    Log(TRUE,"Object %d has reference (colid %d) to bogus DNT %d. Removed\n",
        ulDnt, ColId, Dnt);

    return;

error_exit:

    //
    // Rollback on failure
    //

    if ( fTransactionInProgress ) {
        err = JetRollback(sesid, 0);
        if (err) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2,
                             "JetRollback",
                             GetJetErrString(err));
        }
    }

    Log(TRUE,"Unable to remove reference to bogus DNT %d from object %d(colid %d)\n",
        Dnt, ulDnt, ColId);
    return;

} // CheckForBogusReference


VOID
CheckForBogusReferenceOnLinkTable(
    IN DWORD Dnt
    )
{
    JET_ERR err;
    PREFCOUNT_ENTRY pEntry;

    if ( Dnt <= 3 ) {
        return;
    }

    pEntry = FindDntEntry(Dnt,FALSE);
    if ( pEntry == NULL ) {     // should never happen
        return;
    }

    //
    // Object ok?
    //

    if ( (pEntry->Actual != 0) || (pEntry->RefCount == 0) ) {  // RefCount == 0 should never happen

        // yes, nothing else to do
        return;
    }

    //
    // Delete the record
    //

    err = JetDelete(sesid,linktblid);
    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetDelete", GetJetErrString(err));
        goto error_exit;
    }

    pEntry->RefCount--;
    Log(TRUE,"A LinkTable record has a backlink reference to bogus DNT %d. Record removed\n",
        Dnt);

    return;

error_exit:

    Log(TRUE,"Unable to remove backlink reference to bogus DNT %d\n", Dnt);
    return;

} // CheckForBogusReferenceOnLinkTable

VOID
AddToSubRefList(
    PREFCOUNT_ENTRY pParent,
    DWORD Subref,
    BOOL fListed
    )
{
    //
    // subref checking may be disabled by memory problems. Also ignore 0,1,2,3, these
    // are weird dnts.
    //

    if ( (fDisableSubrefChecking) || ((LONG)pParent->Dnt < 4) ) {
        return;
    }

    //
    // allocate enough for 16. Mark last with -1. If allocation failed,
    // disable all subref checking.
    //

    if ( pParent->Subrefs == NULL ) {
        pParent->Subrefs =
            LocalAlloc(LPTR, DEF_SUBREF_ENTRIES * sizeof(SUBREF_ENTRY) );

        if ( pParent->Subrefs != NULL ) {
            pParent->Subrefs[DEF_SUBREF_ENTRIES-1].Dnt = 0xFFFFFFFF;
        }

    } else if ( pParent->Subrefs[pParent->nSubrefs].Dnt == 0xFFFFFFFF ) {

        //
        // Need more space
        //

        PSUBREF_ENTRY pTmp;
        DWORD  newSize = pParent->nSubrefs * 2;

        pTmp = (PSUBREF_ENTRY)LocalReAlloc( pParent->Subrefs,
                                newSize * sizeof(SUBREF_ENTRY),
                                LMEM_MOVEABLE | LMEM_ZEROINIT);

        if ( pTmp == NULL ) {
            LocalFree(pParent->Subrefs);
            pParent->Subrefs = NULL;
            pParent->nSubrefs = 0;

        } else {

            pParent->Subrefs = pTmp;
            // set new end marker
            pTmp[newSize-1].Dnt = 0xFFFFFFFF;
        }
    }

    //
    // ok, add this entry to the subref list if it's not there yet
    //

    if ( pParent->Subrefs != NULL ) {

        PSUBREF_ENTRY pSubref = NULL;
        DWORD i;

        for (i=0; i< pParent->nSubrefs; i++ ) {

            pSubref = &pParent->Subrefs[i];

            // find an existing one?
            if ( pSubref->Dnt == Subref ) {
                break;
            }
        }

        // did we find anything? if not, initialize a new entry
        if ( i == pParent->nSubrefs ) {
            pSubref = &pParent->Subrefs[pParent->nSubrefs++];
            pSubref->Dnt = Subref;
        }

        if ( fListed ) {
            // found on a subref list of this object
            pSubref->fListed = TRUE;
        } else {
            // should be no subref list of this object
            pSubref->fFound = TRUE;
        }

        //printf("Adding subref entry %x for %d. entry %d. fListed %d\n",
        //       pSubref, pParent->Dnt, Subref, fListed);
    } else {

        printf("alloc failed\n");
        fDisableSubrefChecking = TRUE;
    }

    return;
}

#if 0
VOID
XXX()
{
    JET_ERR err;
    DWORD blink=0x99999999;
    err = JetPrepareUpdate(sesid,
                           linktblid,
                           JET_prepInsert);
    if ( err ) {

        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetPrepareUpdate", GetJetErrString(err));
        goto error_exit;
    }

    err = JetSetColumn(sesid,
                       linktblid,
                       blinkid,
                       &blink,
                       sizeof(blink),
                       0,
                       NULL);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetSetColumn", GetJetErrString(err));
        goto error_exit;
    }

    err = JetUpdate(sesid,
                    linktblid,
                    NULL,
                    0,
                    NULL);

    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetUpdate", GetJetErrString(err));
        goto error_exit;
    }
    return;
error_exit:
    return;
}
#endif


JET_ERR
GotoDnt(
    IN DWORD Dnt
    )
{
    JET_ERR err;

    err = JetMakeKey(sesid, tblid, &Dnt, sizeof(Dnt), JET_bitNewKey);
    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetMakeKey", GetJetErrString(err));
        return err;
    }

    err = JetSeek(sesid, tblid, JET_bitSeekEQ);
    if ( err ) {
        //"Cannot find requested record with dnt = %d. JetSeek failed [%ws]\n"
        if ( VerboseMode ) {
            RESOURCE_PRINT2 (IDS_REFC_DNT_SEEK_ERR,
                    Dnt,
                    GetJetErrString(err));
        }
        return err;
    }

    return err;
}

JET_ERR
GotoSdId(
    IN SDID sdId
    )
{
    JET_ERR err;

    if (sdtblid == -1) {
        // we should not be here
        return JET_errObjectNotFound;
    }

    err = JetMakeKey(sesid, sdtblid, &sdId, sizeof(sdId), JET_bitNewKey);
    if ( err ) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetMakeKey", GetJetErrString(err));
        return err;
    }

    err = JetSeek(sesid, sdtblid, JET_bitSeekEQ);
    if ( err ) {
        //"Cannot find requested SD with SDID = %lu. JetSeek failed [%ws]\n"
        if ( VerboseMode ) {
            RESOURCE_PRINT2 (IDS_REFC_SDID_SEEK_ERR, sdId, GetJetErrString(err));
        }
        return err;
    }

    return err;
}

JET_ERR LoadRecord() {
    JET_ERR err;
    DWORD i;

    err = JetRetrieveColumns(sesid, tblid, jrc, jrcSize);

    if (err == JET_wrnBufferTruncated) {
        // One or more columns got truncated. Alloc more space and reload them.
        for (i=0; i < jrcSize ;i++) {
            if ( jrc[i].err == JET_wrnBufferTruncated ) {
                if (!ExpandBuffer(&jrc[i])) {
                    // unable to allocate memory
                    return JET_errOutOfMemory;
                }
                // update global ptrs if needed
                if (i == rdnIndex) {
                    szRdn = (PWCHAR)jrc[rdnIndex].pvData;
                }
                else if (i == AncestorIndex) {
                    AncestorBuffer = (PDWORD)jrc[AncestorIndex].pvData;
                }
                // reload the data
                err = JetRetrieveColumns(sesid, tblid, &jrc[i], 1);
                // should not get an error
                if (err) {
                    break;
                }
            }
        }
    }
    
    if (err && (err != JET_wrnColumnNull)) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetRetrieveColumns", GetJetErrString(err));
        return err;
    }

    // compute the sdid
    sdId = 0;
    if (sdtblid != -1 && jrc[SdIndex].err == JET_errSuccess) {
        if (jrc[SdIndex].cbActual == sizeof(SDID)) {
            // Un-single-instance the NTSD
            sdId = *((SDID*)jrc[SdIndex].pvData);

            err = jrc[SdIndex].err = GotoSdId(sdId);
            if (err) {
                RESOURCE_PRINT2(IDS_REFC_SDID_SEEK_ERR, sdId, GetJetErrString(err));
                return err;
            }

            // read the SD value
            err = jrc[SdIndex].err = JetRetrieveColumn(sesid, sdtblid, sdvalueid, 
                                                       jrc[SdIndex].pvData, jrc[SdIndex].cbData, 
                                                       &jrc[SdIndex].cbActual, 0, NULL);
            
            if (err == JET_wrnBufferTruncated) {
                // need more space
                if (!ExpandBuffer(&jrc[SdIndex])) {
                    err = jrc[SdIndex].err = JET_errOutOfMemory;
                    return err;
                }
                // reread the SD value
                err = jrc[SdIndex].err = JetRetrieveColumn(sesid, sdtblid, sdvalueid, 
                                                           jrc[SdIndex].pvData, jrc[SdIndex].cbData, 
                                                           &jrc[SdIndex].cbActual, 0, NULL);

            }
            if (err != JET_errSuccess) {
                RESOURCE_PRINT1(IDS_REFC_ERR_FETCH_SEC_DESC, GetJetErrString(err));
            }
        }
        else {
            if (ulDnt != ROOTTAG){
                // "SD is not in single-instanced format for DNT %d[%ws]\n"
                RESOURCE_PRINT2(IDS_REFC_SDNOTSINGLEINSTANCED, ulDnt, szRdn);
            }
            sdId = -1;
        }
    }

    return err;
}

JET_ERR BuildSDRefTable(IN DWORD nSDs) {
    JET_RETRIEVECOLUMN jrc[2];
    SDID sdId;
    DWORD sdRefCount;
    JET_ERR err;
    PSD_REFCOUNT_ENTRY pSDEntry;
    DWORD checkPoint;

    if (sdtblid == -1) {
        // we should not be here
        return JET_errObjectNotFound;
    }

    SDRefTableSize = nSDs*4;
    SDRefTable = LocalAlloc(LPTR, sizeof(SD_REFCOUNT_ENTRY) * SDRefTableSize);
    if ( SDRefTable == NULL ) {
        //"Cannot allocate memory for %hs Table[entries = %d]\n"
        RESOURCE_PRINT2 (IDS_REFC_TABLE_ALLOC_ERR, "SDRef", SDRefTableSize);
        return ERROR_OUTOFMEMORY;
    }

    if ( nSDs < 50 ) {
        checkPoint = 5;
    } else if (nSDs < 1000) {
        checkPoint = 50;
    } else {
        checkPoint = 100;
    }

    memset(&jrc, 0, sizeof(jrc));
    jrc[0].pvData = &sdId;
    jrc[0].cbData = sizeof(sdId);
    jrc[0].columnid = sdidid;
    jrc[0].itagSequence = 1;

    jrc[1].pvData = &sdRefCount;
    jrc[1].cbData = sizeof(sdRefCount);
    jrc[1].columnid = sdrefcountid;
    jrc[1].itagSequence = 1;

    sdsFound = 0;

    //"Records scanned: %10u"
    RESOURCE_PRINT1 (IDS_REFC_SDREC_SCANNED, sdsFound);

    err = JetMove(sesid, sdtblid, JET_MoveFirst, 0);
    while ( !err ) {
        err = JetRetrieveColumns(sesid, sdtblid, jrc, 2);
        
        if (err) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetRetrieveColumns", GetJetErrString(err));
            break;
        }

        pSDEntry = FindSdEntry(sdId, TRUE);
        if (pSDEntry == NULL) {
            // could not insert entry
            err = 1;
            break;
        }
        pSDEntry->Actual = sdRefCount;
        pSDEntry->RefCount = 0;
        pSDEntry->cbSD = 0; // to be filled in when we will be reading SDs in LoadRecord

        sdsFound++;

        if ( (sdsFound % checkPoint) == 0 || sdsFound == nSDs ) {
            printf("\b\b\b\b\b\b\b\b\b\b%10u", sdsFound);
        }

        err = JetMove(sesid, sdtblid, JET_MoveNext, 0);
    }
    printf("\n");

    if (err != JET_errSuccess && err != JET_errNoCurrentRecord) {
        Log(TRUE, "Error while walking SD table. Last sdId = %016I64x. JetMove failed [%S]\n",
             sdId, GetJetErrString(err));
        return err;
    }
    return JET_errSuccess;
}

PSD_REFCOUNT_ENTRY
FindSdEntry(
    IN SDID sdId,
    IN BOOL fInsert
    )
{
    DWORD slot, originalSlot;
    DWORD inc;
    PSD_REFCOUNT_ENTRY entry;

    originalSlot = slot = (DWORD)(sdId % SDRefTableSize);

    while (1) {

        entry = &SDRefTable[slot];

        if ( entry->sdId == sdId ) {
            
            goto exit;

        } else if ( entry->sdId == 0 ) {

            if ( fInsert ) {
                entry->sdId = sdId;
                goto exit;
            } else {
                return NULL;
            }
        }

        slot++;
        if (slot == SDRefTableSize) {
            slot = 0;
        }
        if (slot == originalSlot) {
            fprintf(stderr, "SD table is full!?\n");
            return NULL;
        }
    }

exit:
    return entry;
}

VOID
CheckSDRefCount(
    IN BOOL fFixup
    )
{

    BOOL fBad = FALSE;
    DWORD i;
    ULONGLONG cbSDSingleInstanced = 0, cbSDTotal = 0;

    if (sdtblid == -1) {
        // we should not be here
        return;
    }

    //
    // If stated and found refcounts are different, print a message
    //

    for ( i=0; i < SDRefTableSize; i++ ) {
        if (SDRefTable[i].sdId == 0) {
            continue;
        }
        //
        // if not equal
        //

        if ( SDRefTable[i].RefCount != SDRefTable[i].Actual || SDRefTable[i].RefCount == 0 ) {

            BOOL fFixed;

            fBad = TRUE;
            if ( fFixup ) {
                fFixed = FixSDRefCount(SDRefTable[i].sdId,
                                       SDRefTable[i].Actual,
                                       SDRefTable[i].RefCount);
            } else {
                fFixed = FALSE;
            }

            if (SDRefTable[i].RefCount == 0) {
                Log(TRUE,"Zero RefCount for SD %016I64x [%s]\n",
                    SDRefTable[i].sdId,
                    fFixed ? "Fixed (SD deleted)" : "Not Fixed");
            }
            else {
                Log(TRUE,"RefCount mismatch for SD %016I64x [RefCount %4u References %4u] [%s]\n",
                    SDRefTable[i].sdId,
                    SDRefTable[i].Actual,
                    SDRefTable[i].RefCount,
                    fFixed ? "Fixed" : "Not Fixed");
            }

            //
            // if this had been fixed, indicate this on the count
            //

            if ( fFixed ) {
                SDRefTable[i].Actual = SDRefTable[i].RefCount;
            }
        }

        // update stats
        cbSDSingleInstanced += (ULONGLONG)SDRefTable[i].cbSD;
        cbSDTotal += (ULONGLONG)SDRefTable[i].cbSD * SDRefTable[i].RefCount;
    }

    Log(TRUE,"Security descriptor summary:\n");
    Log(TRUE,"SD count: \t%8u\n", sdsFound);
    Log(TRUE,"Total SD size before single-instancing: \t%12u Kb\n", cbSDTotal/1024);
    Log(TRUE,"Total SD size after single-instancing:  \t%12u Kb\n", cbSDSingleInstanced/1024);

    if ( fBad ) {
        fprintf(stderr, "\nError: Inconsistent SD refcounts detected.\n");
    }

} // CheckSDRefCount

BOOL
FixSDRefCount(
    IN SDID sdId,
    IN DWORD OldCount,
    IN DWORD NewCount
    )
{
    JET_ERR err;

    if (sdtblid == -1) {
        // we should not be here
        return FALSE;
    }

    // seek using sdId
    err = GotoSdId(sdId);
    if ( err ) {
        return FALSE;
    }

    if (NewCount == 0) {
        err = JetDelete(sesid, sdtblid);
        if ( err ) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetDelete", GetJetErrString(err));
            return FALSE;
        }

    }
    else {
        //
        // Replace the value
        //

        err = JetPrepareUpdate(sesid,
                               sdtblid,
                               JET_prepReplace);
        if ( err ) {

            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetPrepareUpdate", GetJetErrString(err));
            return FALSE;
        }

        err = JetSetColumn(sesid,
                        sdtblid,
                        sdrefcountid,
                        &NewCount,
                        sizeof(NewCount),
                        0,
                        NULL);

        if ( err ) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetSetColumn", GetJetErrString(err));
            return FALSE;
        }

        err = JetUpdate(sesid,
                        sdtblid,
                        NULL,
                        0,
                        NULL);

        if ( err ) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetUpdate", GetJetErrString(err));
            return FALSE;
        }
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\resource.h ===
#ifndef __RESOURCE_H
#define __RESOURCE_H

#define IDS_AR_AUTH_RESTORE_COMPLETE       1000
#define IDS_AR_AUTH_RESTORE_FAIL           1001
#define IDS_AR_ERR_CONVERT_FILE_TIME       1002
#define IDS_AR_ERR_CONVERT_LOCAL_TIME      1003 
#define IDS_AR_ERR_CONVERT_SYSTEM_TIME     1004
#define IDS_AR_ERR_FAIL_COMMIT_TRANS       1005
#define IDS_AR_ERR_FAIL_ROLLBACK_TRANS     1006
#define IDS_AR_ERR_FAILED_UPDATE_REC       1007
#define IDS_AR_ERR_FIND_SUBREF             1008
#define IDS_AR_ERR_GEN_INVOK_ID_DSA        1009
#define IDS_AR_ERR_MOVE_CURSOR_DIT         1010
#define IDS_AR_ERR_MOVE_IN_TABLE           1011
#define IDS_AR_ERR_PREPARE_UPDATE          1012
#define IDS_AR_ERR_SET_METADATA            1013
#define IDS_AR_ERR_SET_USN_CHANGED         1014
#define IDS_AR_ERR_SET_WHEN_CHANGED        1015
#define IDS_AR_ERR_START_TRANS             1016
#define IDS_AR_ERR_UPDATE_COLUMN           1017
#define IDS_AR_INCREASE_VERSION            1018
#define IDS_AR_OPEN_DB_DIT                 1019
#define IDS_AR_RECORDS_NON_UPDATED         1020
#define IDS_AR_RECORDS_REMAIN              1021
#define IDS_AR_RECORDS_UPDATE1             1022
#define IDS_AR_RECORDS_UPDATE2             1023
#define IDS_AR_RECORDS_UPDATE3             1024
#define IDS_AR_RECORDS_UPDATED             1025
#define IDS_AR_UPDATE_TIME                 1026
#define IDS_ASSERT_FAILED                  1027
#define IDS_AUTH_RESTORE_CONFIRM_MSG       1028
#define IDS_AUTH_RESTORE_CONFIRM_TITLE     1029
#define IDS_AUTH_RESTORE_DB_MSG            1030
#define IDS_AUTH_RESTORE_DB_VERINC_MSG     1031
#define IDS_AUTH_RESTORE_MSG               1032
#define IDS_AUTH_RESTORE_SUBTREE_MSG       1033
#define IDS_AUTH_RESTORE_SUBTREE_VINC_MSG  1034
#define IDS_BACKUP_PATH                    1035
#define IDS_BUFFER_OVERFLOW                1036
#define IDS_CANNOT_FIND_EXECUTABLE         1037
#define IDS_COMPACT_DEST_ERROR             1038
#define IDS_COMPACT_DISK_WARN              1039
#define IDS_COMPACT_FILE_EXISTS            1040
#define IDS_COMPACT_MISSING_DB             1041
#define IDS_COMPACT_PATH_ERROR             1042
#define IDS_COMPACT_SUCC_MSG               1043
#define IDS_CONNECT_BINDING1               1044
#define IDS_CONNECT_BINDING2               1045
#define IDS_CONNECT_CLEANUP1               1046
#define IDS_CONNECT_CLEANUP2               1047
#define IDS_CONNECT_CLEAR_CRED_MSG         1048
#define IDS_CONNECT_DOMAIN_MSG             1049
#define IDS_CONNECT_ERROR                  1050
#define IDS_CONNECT_INFO_MSG               1051 
#define IDS_CONNECT_INFO1                  1052
#define IDS_CONNECT_INFO2                  1053
#define IDS_CONNECT_LDAP_BIND_ERROR        1054
#define IDS_CONNECT_LDAP_OPEN_ERROR        1055
#define IDS_CONNECT_MSG                    1056
#define IDS_CONNECT_SET_CRED_MSG           1057
#define IDS_CONNECT_SRV_MSG                1058
#define IDS_CONTINUING                     1059
#define IDS_CREATING_DIR                   1060
#define IDS_CREATING_WINDOW                1061
#define IDS_DATABASE_PATH                  1062
#define IDS_DIT_ATTACH_ERR                 1063
#define IDS_DIT_CLOSE_ERR                  1064
#define IDS_DIT_CLOSEHIDENTBL_ERR          1065
#define IDS_DIT_DETACH_ERR                 1066
#define IDS_DIT_DISP_ATTR_TYPE_ERR         1067
#define IDS_DIT_DN_TOO_LONG_ERR            1068
#define IDS_DIT_FIND_OBJ_ERR               1069
#define IDS_DIT_GETDSACOL_ERR              1070
#define IDS_DIT_GETDSAINFO_ERR             1071
#define IDS_DIT_GETUSNCOL_ERR              1072
#define IDS_DIT_INVALIDKEY_DN_ERR          1073
#define IDS_DIT_MAKE_KEY_ERR               1074
#define IDS_DIT_MOVEHIDENTBL_ERR           1075
#define IDS_DIT_OPEN_ERR                   1076
#define IDS_DIT_OPENHIDENTBL_ERR           1077
#define IDS_DIT_PARSEDN_ERR                1078
#define IDS_DIT_PREPARE_HIDDENTBL_ERR      1079
#define IDS_DIT_RECOVER_ERR                1080
#define IDS_DIT_RETRUSNCOL_ERR             1081
#define IDS_DIT_SETUSNCOL_ERR              1082
#define IDS_DIT_UNEXPECTER_COLTYP_ERR      1083
#define IDS_DIT_UPDATEHIDDENTBL_ERR        1084
#define IDS_DM_MGMT_ADDING_OBJ             1085
#define IDS_DM_MGMT_ADDRESS_ERR            1086
#define IDS_DM_MGMT_BAD_RDN                1087
#define IDS_DM_MGMT_FOUND_NC               1088
#define IDS_DM_MGMT_LIST_MSG               1089
#define IDS_DM_MGMT_PRECREATE_MSG          1090
#define IDS_DM_MGMT_UNPARSABLE_DN          1091
#define IDS_DOMAIN_LIST_MSG                1092
#define IDS_DOMAIN_MGNT_MSG                1093
#define IDS_DOMAIN_PRECREATE_MSG           1094
#define IDS_DONE                           1095
#define IDS_DRIVE_FIXED                    1096
#define IDS_DRIVE_FREE_TOTAL               1097
#define IDS_DRIVE_INFO                     1098
#define IDS_DRIVE_NETWORK                  1099
#define IDS_DS_PATH_INFO                   1100
#define IDS_DSA_CLOSE_REGISTRY_KEY_ERR     1101
#define IDS_DSA_KEY_NOT_DWORD_ERR          1102
#define IDS_DSA_KEY_NOT_STRING_ERR         1103
#define IDS_DSA_OPEN_REGISTRY_KEY_ERR      1104
#define IDS_DSA_QUERY_REGISTRY_KEY_ERR     1105
#define IDS_ERR_BUFFER_OVERFLOW            1106
#define IDS_ERR_CANNOT_READ_RESOURCE       1107
#define IDS_ERR_CNV_UNICODE_ANSI           1108
#define IDS_ERR_DIR_NOT_EXIST              1109
#define IDS_ERR_FILE_EXISTS                1110
#define IDS_ERR_FINDING_1st_MATCH          1111
#define IDS_ERR_FINDING_Nth_MATCH          1112
#define IDS_ERR_GET_LOGICAL_DRIVE_STRS     1113
#define IDS_ERR_GETTING_SIZE               1114
#define IDS_ERR_INTERNAL                   1115
#define IDS_ERR_INTERNAL_FILE_LINE         1116
#define IDS_ERR_INVALID_PATH               1117
#define IDS_ERR_LOG_FILE_EXISTS            1118
#define IDS_ERR_MEMORY_ALLOCATION          1119
#define IDS_ERR_NO_DB_FILE_SPECIFIED       1120
#define IDS_ERR_NO_LOCAL_DRIVE             1121
#define IDS_ERR_NO_LOGS_IN_SOURCE          1122
#define IDS_ERR_NO_LOGS_SPECIFIED          1123
#define IDS_ERR_OLD_NEW_PATHS_SAME         1124
#define IDS_ERR_OPENING_REGISTRY           1125
#define IDS_ERR_READING_REGISTRY           1126
#define IDS_ERR_SOFT_RECOVERY              1127
#define IDS_ERR_SOURCE_FILE_EMPTY          1128
#define IDS_ERR_SOURCE_FILE_IS_DIR         1129
#define IDS_ERR_SOURCE_FILE_NOT_EXIST      1130
#define IDS_ERR_SOURCE_NOT_DIR             1131
#define IDS_ERR_WRITING_REG_KEY            1132 
#define IDS_EXECUTING_COMMAND              1133
#define IDS_FAIL_READ_ATTRIBUTE            1134
#define IDS_FAILED                         1135
#define IDS_FILES_COMPACT_MSG              1136
#define IDS_FILES_HEADER_MSG               1137
#define IDS_FILES_INFO_MSG                 1138
#define IDS_FILES_JET_INTEGRITY_MSG        1139
#define IDS_FILES_MOVE_DB_MSG              1140
#define IDS_FILES_MOVE_LOGS_MSG            1141
#define IDS_FILES_MSG                      1142
#define IDS_FILES_RECOVER_MSG              1143
#define IDS_FILES_REPAIR_MSG               1144
#define IDS_FILES_SET_BACKUP_PATH_MSG      1145
#define IDS_FILES_SET_DB_PATH_MSG          1146
#define IDS_FILES_SET_LOGS_PATH_MSG        1147
#define IDS_FILES_SET_WRK_PATH_MSG         1148
#define IDS_FSMO_ABANDON_ALL_MSG           1149
#define IDS_FSMO_SEIZE_DN_MSG              1150
#define IDS_FSMO_SEIZE_INFRASTR_MSG        1151
#define IDS_FSMO_SEIZE_PDC_MSG             1152
#define IDS_FSMO_SEIZE_RID_MSG             1153
#define IDS_FSMO_SEIZE_SCHEMA_MSG          1154
#define IDS_FSMO_TRANFER_DN_MSG            1155
#define IDS_FSMO_TRANFER_INFRASTR_MSG      1156
#define IDS_FSMO_TRANFER_PDC_MSG           1157
#define IDS_FSMO_TRANFER_RID_MSG           1158
#define IDS_FSMO_TRANFER_SCHEMA_MSG        1159
#define IDS_FSMOXFER_ABANDON_ROLES         1160
#define IDS_FSMOXFER_ATTEMPT_TRFR          1161
#define IDS_FSMOXFER_ATTEMPT_TRFR_FAIL     1162
#define IDS_FSMOXFER_ATTEMPT_TRFR_SUC      1163
#define IDS_FSMOXFER_BECOME_DM_MSTR        1164
#define IDS_FSMOXFER_BECOME_INF_MSTR       1165
#define IDS_FSMOXFER_BECOME_PDC            1166
#define IDS_FSMOXFER_BECOME_RIDMASTER      1167
#define IDS_FSMOXFER_BECOME_SCH_MSTR       1168
#define IDS_FSMOXFER_CNV_TXT_SD_ERR        1169

#define IDS_FSMOXFER_MSG1_TITLE            1171
#define IDS_FSMOXFER_MSG2                  1172
#define IDS_FSMOXFER_MSG2_TITLE            1173
#define IDS_FSMOXFER_MSG3                  1174
#define IDS_FSMOXFER_MSG3_TITLE            1175
#define IDS_FSMOXFER_NEIGHBOURHOOD_WARN    1176
#define IDS_FSMOXFER_OVERFLOW_INC_RID      1177
#define IDS_FSMOXFER_PARSE_REPL_LINKS      1178
#define IDS_FSMOXFER_PARSE_RID_POOL        1179
#define IDS_FSMOXFER_PREV_RID_ERR          1180
#define IDS_FSMOXFER_PROC_AVAIL_RID_POOL   1181
#define IDS_FSMOXFER_QUERY_CUR_SVR         1182
#define IDS_FSMOXFER_QUERY_RID_MGR         1183
#define IDS_FSMOXFER_QUERY_RID_POOL        1184
#define IDS_FSMOXFER_SVR_ALREADY_RID       1185
#define IDS_FSMOXFER_SYNCHRONIZE_WARN      1186
#define IDS_FSMOXFER_SYNCHRONIZING_MSG     1187
#define IDS_FSMOXFER_USE_ACL_REPAIR        1188
#define IDS_GENERAL_ERROR1                 1189
#define IDS_HELP_MSG                       1190
#define IDS_HELP_MSG_BANNER1               1191
#define IDS_HELP_MSG_BANNER2               1192
#define IDS_INTEGRITY_SUCC_MSG             1193
#define IDS_INVALID_ON_OFF                 1194
// Former home of IP Deny List messages
#define IDS_LDAP_CON_ERR            1208

#define IDS_JET_CRITICAL_DB_ERR            1219
#define IDS_JET_ERRBACKUPINPROGRESS        1220
#define IDS_JET_ERRBUFFERTOOSMALL          1221
#define IDS_JET_ERRCOLUMNDOESNOTFIT        1222
#define IDS_JET_ERRCOLUMNILLEGALNULL       1223
#define IDS_JET_ERRCOLUMNNOTFOUND          1224
#define IDS_JET_ERRCOLUMNNOTUPDATABLE      1225
#define IDS_JET_ERRCOLUMNTOOBIG            1226
#define IDS_JET_ERRDATABASEINCONSISTENT    1227
#define IDS_JET_ERRDATABASEINUSE           1228
#define IDS_JET_ERRDATABASENOTFOUND        1229
#define IDS_JET_ERRFILEACCESSDENIED        1230
#define IDS_JET_ERRFILENOTFOUND            1231
#define IDS_JET_ERRINVALIDBUFFERSIZE       1232
#define IDS_JET_ERRINVALIDDATABASEID       1233
#define IDS_JET_ERRINVALIDNAME             1234
#define IDS_JET_ERRINVALIDPARAMETER        1235
#define IDS_JET_ERRINVALIDSESID            1236
#define IDS_JET_ERRINVALIDTABLEID          1237
#define IDS_JET_ERRKEYDUPLICATE            1238
#define IDS_JET_ERRKEYISMADE               1239
#define IDS_JET_ERRKEYNOTMADE              1240
#define IDS_JET_ERRNOCURRENTINDEX          1241
#define IDS_JET_ERRNOCURRENTRECORD         1242
#define IDS_JET_ERRNOTINITIALIZED          1243
#define IDS_JET_ERRNOTINTRANSACTION        1244
#define IDS_JET_ERRNULLKEYDISALLOWED       1245
#define IDS_JET_ERROBJECTNOTFOUND          1246
#define IDS_JET_ERROR                      1247
#define IDS_JET_ERRPERMISSIONDENIED        1248
#define IDS_JET_ERRSUCCESS                 1249
#define IDS_JET_ERRTABLEINUSE              1250
#define IDS_JET_ERRTABLELOCKED             1251
#define IDS_JET_ERRTOOMANYACTIVEUSERS      1252
#define IDS_JET_ERRTOOMANYOPENDATABASES    1253
#define IDS_JET_ERRTOOMANYOPENTABLES       1254
#define IDS_JET_ERRTRANSTOODEEP            1255
#define IDS_JET_ERRUPDATENOTPREPARED       1256
#define IDS_JET_ERRWRITECONFLICT           1257
#define IDS_JET_GENERIC_ERR1               1258
#define IDS_JET_GENERIC_ERR2               1259
#define IDS_JET_GENERIC_WRN                1260
#define IDS_JET_OPEN_DATABASE              1261
#define IDS_JET_SET_PARAMETER_ERR          1262
#define IDS_JET_WARNING                    1263
#define IDS_JET_WRNBUFFERTRUNCATED         1264
#define IDS_JET_WRNCOLUMNNULL              1265
#define IDS_JETBEGINSESSION_ERR            1266
#define IDS_JETBEGINTRANS_ERR              1267
#define IDS_JETCLOSETABLE_ERR              1268
#define IDS_JETCOMMITTRANSACTION_ERR       1269
#define IDS_JETCOUNTREC_ERR                1270
#define IDS_JETENDSESSION_ERR              1271
#define IDS_JETGETCOLUMNINFO_ERR           1272
#define IDS_JETINIT_ERR                    1273
#define IDS_JETMAKEKEY_ERR                 1274
#define IDS_JETMOVE_ERR                    1275
#define IDS_JETOPENTABLE_ERR               1276
#define IDS_JETPREPARE_ERR                 1277
#define IDS_JETRETRIEVECOLUMN_ERR          1278
#define IDS_JETROLLBACK_ERR                1279
#define IDS_JETSEEK_ERR                    1280
#define IDS_JETSETCOLUMN_ERR               1281
#define IDS_JETSETINDEX_ERR                1282
#define IDS_JETTERM_ERR                    1283
#define IDS_JETUPDATE_ERR                  1284
#define IDS_LDAP_ADDW_FAIL                 1285
#define IDS_LDAP_EXT_ERROR                 1286
#define IDS_LDAP_MODIFY_ERR                1287
#define IDS_LDAP_MODIFY_FSMOROLE_ERR       1288
#define IDS_LDAP_MODIFY_RID_ERR            1289
#define IDS_LDAP_MODIFY_SD_ERR             1290
#define IDS_LDAP_NO_RIGHTS                 1291
#define IDS_LDAP_POLICIES_CANCEL_MSG       1292
#define IDS_LDAP_POLICIES_COMMIT_MSG       1293
#define IDS_LDAP_POLICIES_INFO             1294
#define IDS_LDAP_POLICIES_LIMIT_ERR        1295
#define IDS_LDAP_POLICIES_LIST_ERR         1296
#define IDS_LDAP_POLICIES_LIST_MSG         1297
#define IDS_LDAP_POLICIES_MEMORY1_ERR      1298
#define IDS_LDAP_POLICIES_MEMORY2_ERR      1299
#define IDS_LDAP_POLICIES_MODIFY_ERR       1300
#define IDS_LDAP_POLICIES_MSG              1301
#define IDS_LDAP_POLICIES_NAME_ERR         1302
#define IDS_LDAP_POLICIES_NO_COMMIT        1303
#define IDS_LDAP_POLICIES_NO_ENTRIES1      1304
#define IDS_LDAP_POLICIES_NO_ENTRIES2      1305
#define IDS_LDAP_POLICIES_NO_RIGHTS1       1306
#define IDS_LDAP_POLICIES_NO_RIGHTS2       1307
#define IDS_LDAP_POLICIES_NOTFOUND         1308
#define IDS_LDAP_POLICIES_RETRIVE_ERR      1309
#define IDS_LDAP_POLICIES_SEARCH_ENTRY_ERR 1310
#define IDS_LDAP_POLICIES_SEARCH1_ERR      1311
#define IDS_LDAP_POLICIES_SEARCH2_ERR      1312
#define IDS_LDAP_POLICIES_SEARCH3_ERR      1313
#define IDS_LDAP_POLICIES_SET_VAL_MSG      1314
#define IDS_LDAP_POLICIES_SHOW_VAL_MSG     1315
#define IDS_LDAP_POLICIES_SUPPORTED        1316
#define IDS_LDAP_POLICIES_VALUE_ERR        1317
#define IDS_LDAP_READ_SD_ERR               1318
#define IDS_LDAP_READ_SD_ERR1              1319
#define IDS_LDAP_SEARCH_ATTR_ERR           1320
#define IDS_LDAP_SEARCH_ERR                1321
#define IDS_LOG_PATH                       1322
#define IDS_MEMORY_ERROR                   1323
#define IDS_MESSAGE_BOX_ERROR              1324
#define IDS_METADATA_CLEANUP_MSG           1325
#define IDS_MOVE_DB_SUCC_MSG               1326
#define IDS_MOVE_LOGS_SUCC_MSG             1327
#define IDS_NO                             1328
#define IDS_NO_DN_ENTRY                    1329
#define IDS_NO_ENTRY                       1330
#define IDS_NO_ERROR_MAPPING               1331
#define IDS_NOT_CONNECTED                  1332
#define IDS_OFF                            1333
#define IDS_ON                             1334
#define IDS_OPEN_SCRIPT_ERROR              1335
#define IDS_OPERATION_CANCELED             1336
#define IDS_POPUPS_DISABLED                1337
#define IDS_POPUPS_ENABLED                 1338
#define IDS_POPUPS_MSG                     1339
#define IDS_PROMPT_AUTH_RESTORE            1340
#define IDS_PROMPT_DOMAIN_MGMT             1341
#define IDS_PROMPT_FILE_MAINTAINANCE       1342
#define IDS_PROMPT_FSMO_MAINTAINANCE       1343
// old deny list prompt
#define IDS_PROMPT_LDAP_POLICY             1345
#define IDS_PROMPT_METADATA_CLEANUP        1346
#define IDS_PROMPT_SCHECK                  1347
#define IDS_PROMPT_SELECT                  1348
#define IDS_PROMPT_SRV_CONNECTIONS         1349
#define IDS_QUIT_MSG                       1350
#define IDS_RECOVER_SUCC_MSG               1351
#define IDS_REFC_COL_ALLOC_ERR             1352
#define IDS_REFC_DNT_SEEK_ERR              1353
#define IDS_REFC_ERR_FETCH_SEC_DESC        1354
#define IDS_REFC_INSTANCE_TYPE             1355
#define IDS_REFC_MEM_ERR1                  1356
#define IDS_REFC_MEM_ERR2                  1357
#define IDS_REFC_MEM_ERR3                  1358
#define IDS_REFC_MEM_ERR4                  1359
#define IDS_REFC_NOINSTANCE_TYPE           1360
#define IDS_REFC_PROC_RECORDS              1361
#define IDS_REFC_REC_SCANNED               1362
#define IDS_REFC_RESULTS1                  1363
#define IDS_REFC_RESULTS2                  1364
#define IDS_REFC_SEC_DESC_NOTPRESENT       1365
#define IDS_REFC_SEC_DESC_PRESENT          1366
#define IDS_REFC_TABLE_ALLOC_ERR           1367
#define IDS_REMOVE_DOMAIN_CONFIRM_MSG      1368
#define IDS_REMOVE_DOMAIN_CONFIRM_TITLE    1369
#define IDS_REMOVE_DOMAIN_MSG              1370
#define IDS_REMOVE_SERVER_CONFIRM_MSG1     1371
#define IDS_REMOVE_SERVER_CONFIRM_MSG2     1372
#define IDS_REMOVE_SERVER_CONFIRM_TITLE    1373
#define IDS_REMOVE_SERVER_MSG              1374
#define IDS_REMOVE_SERVER_SUCCESS          1375

#define IDS_RESTORE_CHK1                   1377
#define IDS_RETURN_MENU_MSG                1378
#define IDS_ROLES_MSG                      1379
#define IDS_SAFE_MODE_ERROR                1380
#define IDS_SCHECK_GET_MSG                 1381
#define IDS_SCHECK_GET_REC_COUNT1          1382
#define IDS_SCHECK_GET_REC_COUNT2          1383
#define IDS_SCHECK_GO_MSG                  1384
#define IDS_SCHECK_OPEN_LOG_ERR            1385
#define IDS_SCHECK_VERBOSE_DISABLED        1386
#define IDS_SCHECK_VERBOSE_ENABLED         1387
#define IDS_SCHECK_VERBOSE_MSG             1388
#define IDS_SCHECK_WRITING_LOG             1389
#define IDS_SELECT_DOMAIN_MSG              1390
#define IDS_SELECT_LIST_DOMAIN_SRV_MSG     1391
#define IDS_SELECT_LIST_DOMAINS_CR_MSG     1392
#define IDS_SELECT_LIST_DOMAINS_MSG        1393
#define IDS_SELECT_LIST_MSG                1394
#define IDS_SELECT_LIST_ROLES_MSG          1395
#define IDS_SELECT_LIST_SERVERS_MSG        1396
#define IDS_SELECT_LIST_SITES_MSG          1397
#define IDS_SELECT_MSG                     1398
#define IDS_SELECT_NO_ACTIVE_DOMAIN_LIST   1399
#define IDS_SELECT_NO_ACTIVE_SERVER_LIST   1400
#define IDS_SELECT_NO_ACTIVE_SITE_LIST     1401
#define IDS_SELECT_NO_DOMAIN1              1402
#define IDS_SELECT_NO_DOMAIN2              1403
#define IDS_SELECT_NO_SERVER1              1404
#define IDS_SELECT_NO_SERVER2              1405
#define IDS_SELECT_NO_SITE1                1406
#define IDS_SELECT_NO_SITE2                1407
#define IDS_SELECT_PRINT_COMPUTER          1408
#define IDS_SELECT_PRINT_DNS               1409
#define IDS_SELECT_PRINT_DOMAIN            1410
#define IDS_SELECT_PRINT_DSA               1411
#define IDS_SELECT_PRINT_FOUND_DOMAINS     1412
#define IDS_SELECT_PRINT_FOUND_SERVERS     1413
#define IDS_SELECT_PRINT_FOUND_SITES       1414
#define IDS_SELECT_PRINT_INFRASTR          1415
#define IDS_SELECT_PRINT_PDC               1416
#define IDS_SELECT_PRINT_RID               1417
#define IDS_SELECT_PRINT_SCHEMA            1418
#define IDS_SELECT_PRINT_SERVER            1419
#define IDS_SELECT_PRINT_SITE              1420
#define IDS_SELECT_PRINT_UNKNOWN           1421
#define IDS_SELECT_ROLE_ITEM_ERR           1422
#define IDS_SELECT_SEL_OUT_OF_RANGE        1423
#define IDS_SELECT_SERVER_MSG              1424
#define IDS_SELECT_SERVER_ROLES            1425
#define IDS_SELECT_SITE_MSG                1426
#define IDS_SEMANTIC_DB_ANALYSIS_MSG       1427
#define IDS_SPAWN_EXTERNAL_COMMAND         1428
#define IDS_SPAWN_PROC_EXIT_CODE           1429
#define IDS_SUCCESS                        1430
#define IDS_TIME                           1431
#define IDS_UNKNOWN                        1432
#define IDS_USING_TEMP_PATH                1433
#define IDS_W32_ERROR                      1434
#define IDS_WORK_PATH                      1435
#define IDS_WRN_GET_FREE_SPACE             1436
#define IDS_WRN_GET_VOLUME_INFO            1437
#define IDS_WRN_READING                    1438
#define IDS_YES                            1439
#define IDS_SAM_MSG                        1440
#define IDS_PROMPT_SAM_MAINTENANCE         1441 
#define IDS_SAM_CONNECT_SERVER_MSG         1442
#define IDS_SAM_CONNECT_ERROR              1443
#define IDS_SAM_NOT_CONNECTED              1444
#define IDS_SAM_CANT_OPEN_ACCOUNT_DOMAIN   1445
#define IDS_SAM_EXCEPTION                  1446
#define IDS_SAM_DUP_SID_CLEANUP_MSG        1447
#define IDS_SAM_CANT_CREATE_LOG_FILE       1448
#define IDS_SAM_DUP_SID_CLEANUP_AND        1449
#define IDS_SAM_DUP_SID_CLEANUP_STATUS     1450
#define IDS_SAM_DUP_SID_CLEANUP_END        1451
#define IDS_SAM_DUPLICATE_SID_CHECK_ONLY   1452 
#define IDS_SAM_DUPLICATE_SID_CLEANUP      1453
#define IDS_SAM_SPECIFY_LOG_FILE           1454
#define IDS_SAM_INVALID_LOG_FILE_NAME      1455
#define IDS_SAM_DUP_SID_CHECK_FAILED       1456
#define IDS_SAM_DUP_SID_CHECK_SUCCEED      1457
#define IDS_SAM_DUP_SID_CLEANUP_FAILED     1458
#define IDS_SAM_DUP_SID_CLEANUP_SUCCEED    1459
#define IDS_SCHECK_SCHEMA_REPAIR_MSG       1460
#define IDS_SEIZURE_FORBIDDEN              1461
#define IDS_FIXUP_MSG                      1462
#define IDS_SCHECK_GO_FIXUP_MSG            1463
#define IDS_MOVE_DB_DISK_SPACE_ERR         1464
#define IDS_MOVE_LOGS_DISK_SPACE_ERR       1465
#define IDS_SCH_REPAIR_WRONG_VER           1466
#define IDS_SCH_REPAIR_LOG_ERROR           1467
#define IDS_SCH_REPAIR_CONFIRM_MSG         1468
#define IDS_SCH_REPAIR_CONFIRM_TITLE       1469
#define IDS_SCH_REPAIR_CONFLICT_FOUND      1470
#define IDS_SCH_REPAIR_GUID_NOTFOUND       1471
#define IDS_SCH_REPAIR_ATT_NOTFOUND        1472
#define IDS_SCH_REPAIR_FIND_FAILURE        1473
#define IDS_SCH_REPAIR_FIND_TITLE          1474
#define IDS_SCH_REPAIR_FIND_DETAIL         1475
#define IDS_SCH_REPAIR_DEL_SUCCESS         1476
#define IDS_SCH_REPAIR_DEL_FAILURE         1477
#define IDS_SCH_REPAIR_REF_FIXUP           1478
#define IDS_SCH_REPAIR_NONE_DETECTED       1479
//
// Support the removal of a naming context (aka cross reference)
//
#define IDS_SELECT_LIST_NCS_MSG            1480
#define IDS_SELECT_PRINT_FOUND_NCS         1481
#define IDS_SELECT_NC_MSG                  1482
#define IDS_SELECT_NO_ACTIVE_NC_LIST       1483
#define IDS_SELECT_PRINT_NC                1484
#define IDS_SELECT_NO_NC1                  1485
#define IDS_SELECT_NO_NC2                  1486
#define IDS_REMOVE_NC_MSG                  1487
#define IDS_REMOVE_NC_CONFIRM_MSG          1488
#define IDS_REMOVE_NC_CONFIRM_TITLE        1489
//
// Better error messages for List Roles
//
#define IDS_SELECT_ROLE_INFRASTRUCTURE_NOT_FOUND 1490
#define IDS_SELECT_ROLE_SCHEMA_NOT_FOUND         1491
#define IDS_SELECT_ROLE_DOMAIN_NOT_FOUND         1492
#define IDS_SELECT_ROLE_PDC_NOT_FOUND            1493
#define IDS_SELECT_ROLE_RID_NOT_FOUND            1494
//
//  added for "authoritatively restore object"
//
#define IDS_AUTH_RESTORE_OBJECT_MSG        1495
#define IDS_AUTH_RESTORE_OBJECT_VINC_MSG   1496
//
// Added for RID seizure
//
#define IDS_FSMOXFER_CREDENTIALS            1497
#define IDS_FSMOXFER_DN                     1498
#define IDS_FSMOXFER_OP_ATTR                1499
#define IDS_FSMOXFER_NO_DCS                 1500
#define IDS_FSMOXFER_SLEEP_BIND             1501
#define IDS_FSMOXFER_SLEEP_SEARCH           1502

//
// Added for Configurable Settings
//
#define IDS_CONFSET_CANCEL_MSG              1503
#define IDS_CONFSET_COMMIT_MSG              1504
#define IDS_CONFSET_INFO                    1505
#define IDS_CONFSET_SETTINGS_ERR            1506
#define IDS_CONFSET_LIST_ERR                1507
#define IDS_CONFSET_LIST_MSG                1508
#define IDS_CONFSET_MEMORY1_ERR             1509
#define IDS_CONFSET_MEMORY2_ERR             1510
#define IDS_CONFSET_MODIFY_ERR              1511
#define IDS_CONFSET_MSG                     1512
#define IDS_CONFSET_NAME_ERR                1513
#define IDS_CONFSET_NO_COMMIT               1514
#define IDS_CONFSET_NO_ENTRIES1             1515
#define IDS_CONFSET_NO_ENTRIES2             1516
#define IDS_CONFSET_NO_RIGHTS1              1517
#define IDS_CONFSET_NO_RIGHTS2              1518
#define IDS_CONFSET_NOTFOUND                1519
#define IDS_CONFSET_RETRIVE_ERR             1520
#define IDS_CONFSET_SEARCH_ENTRY_ERR        1521
#define IDS_CONFSET_SEARCH1_ERR             1522
#define IDS_CONFSET_SEARCH2_ERR             1523
#define IDS_CONFSET_SEARCH3_ERR             1524
#define IDS_CONFSET_SET_VAL_MSG             1525
#define IDS_CONFSET_SHOW_VAL_MSG            1526
#define IDS_CONFSET_SUPPORTED               1527
#define IDS_CONFSET_VALUE_ERR               1528
#define IDS_PROMPT_CONFSET                  1529
#define IDS_CONFSET_RANGE                   1530

//
// Added for Non-Domain Naming Contexts
//
#define IDS_DM_MGMT_CREATE_NDNC            1531
#define IDS_DM_MGMT_DELETE_NDNC            1532
#define IDS_DM_MGMT_ADD_NDNC_REPLICA       1533
#define IDS_DM_MGMT_REMOVE_NDNC_REPLICA    1534
#define IDS_DM_MGMT_SET_NDNC_REF_DOM       1535
#define IDS_DM_MGMT_SET_NDNC_REPL_DELAYS   1536
#define IDS_DM_MGMT_LIST_NDNC_REPLICAS     1537
#define IDS_DM_MGMT_LIST_NDNC_INFO         1538
#define IDS_DM_MGMT_NAMING_FSMO_CONN       1539

//
// Authoritative restore of linked values
//
#define IDS_AR_ERR_SET_DEL_TIME             1540
#define IDS_AR_ERR_UNKNOWN_VALUE_METADATA_FORMAT   1541

// More for Non-Domain Naming Contexts.
#define IDS_DM_MGMT_BAD_DNS                 1542
#define IDS_DM_MGMT_NDNC_LIST_HEADER        1543
#define IDS_DM_MGMT_NDNC_LIST_FOOTER        1544
#define IDS_DM_MGMT_NC_REPL_DELAY_1         1545
#define IDS_DM_MGMT_NC_REPL_DELAY_2         1546
#define IDS_DM_MGMT_NDNC_SD_REF_DOM         1547
#define IDS_DM_MGMT_NC_NO_INFO              1548
#define IDS_DM_MGMT_NDNC_LIST_NO_REPLICAS   1549
#define IDS_DM_MGMT_NDNC_SERVER_DUPLICATES  1550
#define IDS_DM_MGMT_NDNC_SERVER_COULDNT_FIND   1551




// Added for reporting errors in the connection menu
#define IDS_CONNECT_LDAP_GET_OPTION_ERROR  1565
#define IDS_CONNECT_LDAP_SET_OPTION_ERROR  1566

// Set path security errors
#define IDS_ERR_GET_SECURITY_INFO             1567
#define IDS_ERR_SET_SECURITY_INFO             1568
#define IDS_ERR_SET_ENTRIES_ACL                1569

// Description attribute value on a NDNC head object.
#define IDS_DM_MGMT_NDNC_DESC                1570

#define IDS_GET_DOMAIN_NAMING_FSMO_ERROR    1571
#define IDS_BIND_DOMAIN_NAMING_FSMO_ERROR   1572
#define IDS_DM_MGMT_NDNC_LIST_FOOTER_2      1573


//
// Support for deleting FRS objects
//
#define IDS_REMOVE_SERVER_FRS_SRV      1574
#define IDS_REMOVE_SERVER_NO_DNS       1575
#define IDS_REMOVE_SERVER_NO_FRS_SRV   1576
#define IDS_REMOVE_SERVER_NO_FRS_API   1577
#define IDS_REMOVE_SERVER_FRS_ERR      1578
#define IDS_REMOVE_SERVER_FRS_LOC_ERR  1579
#define IDS_REMOVE_SERVER_FRS_SAME     1580

//
// Authoritative restore of USN range
//
#define IDS_AUTH_RESTORE_DB_USN_MSG    1581
#define IDS_AR_USN_RANGE               1582
#define IDS_AR_RECORDS_UPDATED_BY_NAME 1583

//
// Domain management
//
#define IDS_DM_MGMT_DELETE_NDNC_DELAY  1584

//
// Set DS Restore Mode Admin Account Password
//
#define IDS_SET_DSRM_PWD_MSG            1585
#define IDS_SET_DSRM_PWD_ON_SERVER      1586
#define IDS_PROMPT_SET_DSRM_PWD         1587
#define IDS_INVALID_PASSWORD            1588
#define IDS_PROMPT_INPUT_PASSWORD       1589
#define IDS_SET_DSRM_PWD_SUCCESS        1590
#define IDS_SET_DSRM_PWD_FAILURE        1591
#define IDS_SET_DSRM_PWD_FAILURE_CODE   1592
#define IDS_SET_DSRM_PWD_FAILURE_MSG    1593

#define IDS_DM_MGMT_LIST_UNICODE_WARNING    1596
#define IDS_DM_MGMT_LIST_REPLICAS_NO_AUTH_SRC  1597
#define IDS_DM_MGMT_FOUND_NC_ITEM        1598

// SD single instancing
#define IDS_REFC_SDID_SEEK_ERR          1599
#define IDS_SCHECK_GET_SDREC_COUNT1     1600
#define IDS_SCHECK_GET_SDREC_COUNT2     1601
#define IDS_REFC_SDREC_SCANNED          1602
#define IDS_SDTABLE_NOTFOUND            1603
#define IDS_REFC_ANCESTORS              1604
#define IDS_REFC_SDNOTSINGLEINSTANCED   1605
#define IDS_REFC_SD_IS_MISSING          1606

#define IDS_AUTH_RESTORE_LIST_NC_CRS    1607
#define IDS_AUTH_RESTORE_LIST_ONE_NC    1608
#define IDS_AUTH_RESTORE_LIST_NCS_CR    1609
#define IDS_AUTH_RESTORE_LIST_NO_NC_NAME 1610
#define IDS_AUTH_RESTORE_LIST_NO_CR_DN  1611
#define IDS_AUTH_RESTORE_LIST_SKIP      1612
#define IDS_AUTH_RESTORE_LIST_LIST      1613
#define IDS_AUTH_RESTORE_LIST_FAILED_TO_OPEN_DB  1614

#define IDS_ERR_GENERIC_FAILURE             1615
#define IDS_ERR_GETFILEINFO                 1616
#define IDS_FILES_UPDATING_SECURITY         1617
#define IDS_WRN_FILE_NOT_FOUND              1618
#define IDS_WRN_FOLDER_NOT_FOUND            1619
#define IDS_FILES_UPDATE_SECURITY_MSG       1620
#define IDS_FILES_SET_DEFAULT_FOLDER_SECURITY_MSG 1621
#define IDS_ERR_TEMPLATE_NOT_FOUND          1622
#define IDS_WRN_OLD_LOCATION_UNAVAILABLE    1623
#define IDS_ERR_REQUIRES_DOMAIN_NAMING_FSMO 1624
#define IDS_PROMPT_PASSWORD                 1625

#define IDS_DM_MGMT_NDNC_LIST_NO_NC_FOUND   1626

#define IDS_FSMO_PDC_NOTIFY_FAILED          1627

#define IDS_FILES_JET_CHECKSUM_MSG          1628

#define IDS_PROMPT_CONFIRM_PASSWORD         1629
#define IDS_SET_DSRM_PWD_DO_NOT_MATCH       1630
#define IDS_SET_DSRM_PWD_BLANK_PWD          1631
#define IDS_SET_DSRM_PWD_CANT_VALIDATE_LOCALLY  1632
#define IDS_SET_DSRM_PWD_CANT_VALIDATE_ON_DC    1633

#define IDS_SNAPSHOT_BACKUP_EXPIRED         1634

#define IDS_SCHECK_QUOTA_INTEGRITY_MSG      1635
#define IDS_SCHECK_QUOTA_REBUILD_MSG        1636
#define IDS_SCHECK_QUOTA_RUN_INTEGRITY      1637
#define IDS_SCHECK_QUOTA_NO_CORRUPTION      1638
#define IDS_SCHECK_QUOTA_CORRUPTION         1639
#define IDS_SCHECK_QUOTA_ERROR              1640
#define IDS_SCHECK_QUOTA_REBUILD_SUCCESS    1641
#define IDS_SCHECK_QUOTA_REBUILD_ERROR      1642

#define IDS_DM_MGMT_MANY_REPLICAS_QUERY     1643
#define IDS_DM_MGMT_MANY_REPLICAS_TITLE     1644

#define IDS_DIT_GETDITSTATE_COL_ERR         1645
#define IDS_DIT_GETDITSTATE_DATA_ERR        1646

// WARNING
// TRY TO UPDATE IDS_END WHEN ADDING RESOURCES

#define IDS_START 1000
#define IDS_END   1647
#define IDS_SIZE  (IDS_END - IDS_START + 1)


#endif // __RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\recover.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "file.hxx"
#include "dsconfig.h"
#include "resource.h"
#include <dbopen.h>


HRESULT 
Recover(
    CArgs   *pArgs
    )
/*++

  Routine Description:

    Called by parser to perform soft database recovery.

  Parameters:

    pArgs - Pointer to argument block - ignored.

  Return Values:

    Always returns S_OK.

--*/
{
    SystemInfo      *pInfo;
    ExePathString   pszScript;
    ExePathString   pszEsentutlPath;
    FILE            *fp;
    BOOL            fIsDir;

    pInfo = GetSystemInfo();

    if ( !pInfo ) 
    {
        return(S_OK);
    }

    _try
    {
        // Check whether log files exist.  We can recover with no database
        // or checkpoint file, but we at least need log files.

        if ( !pInfo->pszLogDir[0] )
        {
            //"No log files specified in %s\\%s\n"
            RESOURCE_PRINT2( IDS_ERR_NO_LOGS_SPECIFIED,
                             DSA_CONFIG_SECTION,
                             LOGPATH_KEY );
            _leave;
        }
        else if ( !ExistsFile( pInfo->pszLogDir, &fIsDir ) )
        {
            //"Source directory \"%s\" does not exist\n"
            RESOURCE_PRINT1( IDS_ERR_DIR_NOT_EXIST,
                             pInfo->pszLogDir );
            _leave;
        }
        else if ( !fIsDir )
        {
            //"Source \"%s\" is not a directory\n"
            RESOURCE_PRINT1( IDS_ERR_SOURCE_NOT_DIR,
                             pInfo->pszLogDir );
            _leave;
        }
        else if ( !pInfo->pLogInfo ) 
        {
            //"No logs in source directory \"%s\"\n",
            RESOURCE_PRINT1( IDS_ERR_NO_LOGS_IN_SOURCE,
                             pInfo->pszLogDir );
            _leave;
        }

        // Make sure we have esentutl.exe on this machine.

        if ( !FindExecutable(ESE_UTILITY_PROGRAM, pszEsentutlPath) )
        {
            _leave;
        }

        // invoke esentutl with the following command-line params:
        //      /redb - specifies recovery mode (MUST be first param), with logfile basename of "edb"
        //      /l - specifies logfile path
        //      /s - specifies system path
        //      /8 - specifies 8k database pages
        //      /o - suppresses "Microsoft Windows Database Utilities" logo

        const char * const  szCmdFmt        = "%s /redb /l\"%s\" /s\"%s%s\" /8 /o";
        const SIZE_T        cbCmdFmt        = strlen( szCmdFmt );           // buffer will be slighly over-allocated, big deal!
        const SIZE_T        cbEsentutlPath  = strlen( pszEsentutlPath );
        const SIZE_T        cbLogDir        = strlen( pInfo->pszLogDir );
        const SIZE_T        cbSystemDir     = strlen( pInfo->pszSystem );
        char * const        szCmd           = (char *)alloca( cbCmdFmt      // over-allocated, so no need for +1 for null-terminator
                                                              + cbEsentutlPath
                                                              + cbLogDir
                                                              + cbSystemDir );

        // WARNING: assert no trailing backslash
        // on the logfile path because it would
        // cause problems with the surrounding
        // quotes that we stick in (a trailing
        // (backslash followed by the end quote
        // ends up getting interpreted as an
        // escape sequence)
        // Note that we know that the logfile
        // path cannot have a trailing backslash
        // because the path is validated using
        // ExistsFile() above. That function
        // uses FindFirstFile() to perform the
        // validation, and FirdFirstFile() will
        // always err out if a trailing backslash
        // is present.
        ASSERT( '\\' != pInfo->pszLogDir[ cbLogDir-1 ] );

        // if no system path specified, use current dir
        // (which will be pszDbDir due to the manner in
        // which we spawn esentutl)

        if ( cbSystemDir > 0 )
        {
            // WARNING: must account for trailing
            // backslash on the system path because
            // it would cause problems with the
            // surrounding quotes that we stick in
            // (a trailing backslash followed by the
            // end quote ends up getting interpreted
            // as an escape sequence)
            // Note that there's no need to do the
            // same for the logfile path (see above
            // for explanation why there can't be a
            // trailing backslash on the logfile path)

            sprintf( szCmd,
                     szCmdFmt,
                     pszEsentutlPath,
                     pInfo->pszLogDir,
                     pInfo->pszSystem,
                     ( '\\' == pInfo->pszSystem[ cbSystemDir-1 ] ? "." : "" ) );
        }
        else
        {
            sprintf( szCmd,
                     "%s /redb /l\"%s\" /8 /o",
                     pszEsentutlPath,
                     pInfo->pszLogDir );
        }

        RESOURCE_PRINT1 (IDS_EXECUTING_COMMAND, szCmd);

        SpawnCommand (szCmd, pInfo->pszLogDir, NULL);

        RESOURCE_PRINT (IDS_RECOVER_SUCC_MSG);
    }
    _finally
    {
        FreeSystemInfo(pInfo);
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\samclean.cxx ===
/*++
Copyright (c) 1999 Microsoft Corporation

Module Name:

    samclean.cxx

Abstract:

    This file contains SAM duplicate SID cleanup routines that connect
    to the server, open the account domain (we believe there won't be 
    duplicate sid in the builtin domain), then enumerata all SAM accounts 
    in the account domain. Once get the accounts Relative ID, insert this
    account into our Sorted by RID generic table. Because the account domain
    could be very large, we use the following algorithm to find the 
    duplicate SID.

    
    Important: This algorithm is only applied for Windows 2000 DC.
               Can't be used on NT4 BDC. Because Windows 2000 will 
               use SID as index to execute the enumeration, while NT 4 
               does NOT. Thus ONLY Windows 2000 DC can guarantee the 
               order of returned accounts. The whole algorithm is based 
               on that assumption.
        
    
    while ( Enumeration is not finished )
    {
        Enumerate Normal User in Account Domain
        Enumerate Workstation Account
        Enumerate Server Accounts
        Enumerate InterDomain Trust accounts
        Enumerate Group objects
        Enumerate Alias objects
        (totally Six catagories)
        
        Put the returned entries (from above enumeration) into EnumInfo->CmpAccounts
        (Each catagory has its own EnumInfo, for example: UserEnumInfo, WksEnumInfo,
         ... AliasEnumInfo.  EnumInfo->CmpAccounts is used to hold all entries which
         need to be examined. 
         
        Find the maximum RID of each catagory's CmpAccounts. 
        It should be the last one in the CmpAccounts array. 
        
        Get the minimum value from the six maximum RID. We will call
        it MinimumRid.
   
        Scan each catagory's CmpAccounts, for each entry whose 
        RID <= MinimumRid, insert that account into the Sorted By Rid 
        Generic Table. 
            if can't insert, then it must be a Duplicate RID. ==> Duplicate SID.
        
        Scan CmpAccounts of the six catagories (Normal User, Worksation...alias)
        discard the checked entries.

        Free the Generic Table. 
    }        
       
    Note: all above depends on that SAM enumeration will guarantee the order
          of returned accounts. Thus we can check these returned accounts
          by small set instead of scan them in a whole. 
          
          Because different catagory will not follow the same order, so 
          we introduce the MinimumRid to force that every account gets a 
          chance to compare with the rest five catagory in a proper manner.


Author:

    ShaoYin

Revision History

    02-11-99 Created

--*/





#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"
#include "sam.hxx"

extern "C" {
// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>
#include <prefix.h>
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mappings.h>

#include "ntsam.h"
#include "ntldap.h"
#include "winldap.h"
#include "ntlsa.h"
#include "lmcons.h"         // MAPI constants req'd for lmapibuf.h
#include "lmapibuf.h"       // NetApiBufferFree()
}                   


#include "resource.h"




#define DBPRINT 0

#if     DBPRINT == 1
#define dbprintf(x)     printf x
#else
#define dbprintf(x) 
#endif



////////////////////////////////////////////////////////////////
//                                                            //
//          Defines                                           //
//                                                            //
////////////////////////////////////////////////////////////////

#define AVERAGE_MEMORY_PER_ENTRY    32
#define SAMP_MAXIMUM_DOMAIN_RID     0x3FFFFFFF

#define INIT_COUNT_COMPARE_ACCOUNTS 256


//
// Control the behavior of SamDuplicateSidCleanup()
// 
#define SAM_DUPLICATE_SID_CHECK_ONLY    0x0001
#define SAM_DUPLICATE_SID_CLEANUP       0x0002


#define SAM_DEFAULT_LOG_FILE        L"dupsid.log"



#define CalculateBufferSize( c )                                    \
        (sizeof(GENERIC_TABLE_ELEMENT) + c.Length - sizeof(WCHAR) + \
         sizeof(L'\0')) 




//////////////////////////////////////////////////
//                                              //
// Global Varialbes                             //
//                                              //
//////////////////////////////////////////////////


SAM_HANDLE      gSamServerHandle = NULL;

UNICODE_STRING  gServerName;
WCHAR           gpwszServerName[MAX_PATH] = { L'\0' };

BOOLEAN         gUseDefaultLogFile = TRUE;
WCHAR           gpwszLogFileName[MAX_PATH+1] = { L'\0' };

PWCHAR          gpszMessage = NULL;
PWCHAR          gpszAnd = NULL;

RTL_GENERIC_TABLE   gSortedByRidTable;



//////////////////////////////////////////////////
//                                              //
// TypeDefine                                   //
//                                              //
//////////////////////////////////////////////////


typedef struct _SAM_ENUMERATION_INFO
{
    BOOLEAN NotFinished;                // indicate whether enumeration ends or not
    ULONG   CheckedCount;               // number of entried had been checked.
    ULONG   PreferedCount;              // number of entries need to enumerate
    SAM_ENUMERATE_HANDLE EnumContext;   // restart the enumeration
    ULONG   ReturnedCount;              // number of entries returned 
    PSAM_RID_ENUMERATION ReturnedAccounts; // contains the returned accounts (entries) 
    ULONG   CmpCapacity;                // record how many entries CmpAccounts can contain
    ULONG   CmpCount;                   // number of entries wait to be examined.
    PSAM_RID_ENUMERATION CmpAccounts;   // contains the entries wait to be examined

} SAM_ENUMERATION_INFO, *PSAM_ENUMERATION_INFO;




typedef struct _GENERIC_TABLE_ELEMENT
{
    ULONG   Rid;            // Relative ID 
    USHORT  Length;         // Length is byte size of the name, 
                            // not include the NULL terminator.
    WCHAR   Name[1];        // Wide Char String.

} GENERIC_TABLE_ELEMENT, *PGENERIC_TABLE_ELEMENT;



//////////////////////////////////////////////////
//                                              //
// forward declaration                          //
//                                              //
//////////////////////////////////////////////////


PVOID
RidTableAllocate(
    RTL_GENERIC_TABLE   *Table, 
    CLONG               ByteSize
    );

VOID
RidTableFree(
    RTL_GENERIC_TABLE   *Table, 
    PVOID               Buffer
    );

RTL_GENERIC_COMPARE_RESULTS
RidTableCompare(
    RTL_GENERIC_TABLE   *Table, 
    PVOID               FirstStruct, 
    PVOID               SecondStruct
    );

VOID
SamFreeGenericTable(
    VOID
    );

NTSTATUS
SamDuplicateSidCleanup(
    IN ULONG Flags
    );

NTSTATUS
SamOpenAccountDomain(
    PUNICODE_STRING ServerName,
    SAM_HANDLE      SamHandle, 
    PSAM_HANDLE     pDomainHandle 
    );


ULONG
SamGetMinimumRid(
    IN PSAM_ENUMERATION_INFO UserEnumInfo, 
    IN PSAM_ENUMERATION_INFO WksEnumInfo, 
    IN PSAM_ENUMERATION_INFO SrvEnumInfo, 
    IN PSAM_ENUMERATION_INFO InterDomEnumInfo, 
    IN PSAM_ENUMERATION_INFO GroupEnumInfo, 
    IN PSAM_ENUMERATION_INFO AliasEnumInfo
    );

NTSTATUS
SamEnumerateAccounts(
    IN SAM_HANDLE DomainHandle, 
    IN SAMP_OBJECT_TYPE ObjectType, 
    IN ULONG UserAccountControl,
    IN OUT PSAM_ENUMERATION_INFO  EnumInfo
    );

NTSTATUS
SamUpdateCmpAccountsWithReturnedAccounts(
    IN OUT PSAM_ENUMERATION_INFO EnumInfo
    );

VOID
SamUpdateCmpAccountsAfterCheck(
    IN OUT PSAM_ENUMERATION_INFO EnumInfo, 
    IN ULONG MinimumRid
    );

NTSTATUS
SamDetectAndCleanupDuplicateSid(
    IN SAM_HANDLE DomainHandle,
    IN FILE * LogFile,
    IN ULONG MinimumRid,
    IN PSAM_ENUMERATION_INFO EnumInfo, 
    IN ULONG Flags
    );

VOID
SamInitEnumInfo(
    PSAM_ENUMERATION_INFO EnumInfo
    );

VOID
SamFreeEnumInfo(
    PSAM_ENUMERATION_INFO EnumInfo
    );

////////////////////////////////////////////////////////////////////
//                                                                //
//  exported API throught SAM.HXX                                 //
//                                                                //
////////////////////////////////////////////////////////////////////

HRESULT SamDuplicateSidCheckOnly(
    CArgs *pArgs
    )
/*++
Routine Descrption:
    
    This routine calls SamDuplicateSidCleanup(), with check only flag.

Parameters:

    None.
    
Return Value:

    S_OK
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = SamDuplicateSidCleanup(SAM_DUPLICATE_SID_CHECK_ONLY);

    if (!NT_SUCCESS(NtStatus))
    {
        RESOURCE_PRINT(IDS_SAM_DUP_SID_CHECK_FAILED);
    }
    else
    {
        RESOURCE_PRINT1(IDS_SAM_DUP_SID_CHECK_SUCCEED, gpwszLogFileName);
    }

    return (S_OK);
    
}

HRESULT SamDuplicateSidCheckAndCleanup(
    CArgs *pArgs
    )
/*++
Routine Descrption:
    
    This routine calls SamDuplicateSidCleanup(), with check and cleanup flags.
    
Parameters:

    None.
    
Return Value:

    S_OK
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    NtStatus = SamDuplicateSidCleanup(SAM_DUPLICATE_SID_CHECK_ONLY |
                                      SAM_DUPLICATE_SID_CLEANUP);

    if (!NT_SUCCESS(NtStatus))
    {
        RESOURCE_PRINT(IDS_SAM_DUP_SID_CLEANUP_FAILED);
    }
    else
    {
        RESOURCE_PRINT1(IDS_SAM_DUP_SID_CLEANUP_SUCCEED, gpwszLogFileName);
    }


    return (S_OK);
}




HRESULT
SamSpecifyLogFile(
    CArgs *pArgs
    )
/*++
Routine Description:

    This routine simply gets the specified log file from client

Parameter:
    
    New Log File Name    

Return Values:
    
    HRESULT
--*/
{
    HRESULT HResult = S_OK;
    PWCHAR  pLogFileName = NULL;

    if ( FAILED(HResult = pArgs->GetString(0, (const WCHAR **) &pLogFileName)) )
    {
        return (HResult);
    }
    if ( wcslen(pLogFileName) > MAX_PATH ) 
    {
        return (E_INVALIDARG);
    }

    RtlZeroMemory(gpwszLogFileName, MAX_PATH * sizeof(WCHAR) );
    gUseDefaultLogFile = FALSE;

   wcscpy(gpwszLogFileName, pLogFileName);

    return (S_OK);
}


HRESULT SamConnectToServer(
    CArgs *pArgs
    )
/*++
Routine Description:

    This routine makes the SAM connection to the server
    
Parameter:

    Server Name
    
Return Values:

    HRESULT - S_OK
--*/
{
    HRESULT     HResult = S_OK;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PWCHAR      pServerName = NULL;
    OBJECT_ATTRIBUTES Attributes;


    //
    //  Close any open connection
    //
     
    if (NULL != gSamServerHandle)
    {
        SamCloseHandle(gSamServerHandle);
        gSamServerHandle = NULL;
    }

    //
    // Init Global Variables. Hold the server name.
    // 

    RtlZeroMemory(&gServerName, sizeof(UNICODE_STRING));
    RtlZeroMemory(gpwszServerName, MAX_PATH * sizeof(WCHAR));

    if ( FAILED(HResult = pArgs->GetString(0, (const WCHAR **) &pServerName)) )
    {
        return (HResult);
    }
    if ( wcslen(pServerName) > MAX_PATH ) 
    {
        return (E_INVALIDARG);
    }

    wcscpy(gpwszServerName, pServerName);

    RtlInitUnicodeString(&gServerName, gpwszServerName);

    InitializeObjectAttributes(&Attributes, NULL, 0, NULL, NULL);

    //
    // Connect
    // 

    NtStatus = SamConnect(
                    &gServerName, 
                    &gSamServerHandle, 
                    MAXIMUM_ALLOWED, 
                    &Attributes
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        RESOURCE_PRINT2(IDS_SAM_CONNECT_ERROR, pServerName, NtStatus); 
        return(S_OK);
    }

    
    return (S_OK);
}



//
// Implementation of the main algorithm
// 

NTSTATUS
SamDuplicateSidCleanup(
    IN ULONG Flags
    )
/*++
Routine Description:

    This routine enumerates all accounts in the account domain.
    Detect the duplicate SID. If any, log it and clean it up if 
    required to do so. 
 

Parameters:

    Flags - Control this function's behavior. 

Return Values:

    NtStatus
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    SAM_HANDLE  DomainHandle = NULL;
    SAM_ENUMERATION_INFO    UserEnumInfo;
    SAM_ENUMERATION_INFO    GroupEnumInfo;
    SAM_ENUMERATION_INFO    AliasEnumInfo;
    SAM_ENUMERATION_INFO    WksEnumInfo;
    SAM_ENUMERATION_INFO    SrvEnumInfo;
    SAM_ENUMERATION_INFO    InterDomEnumInfo;
    ULONG       MinimumRid = 0;
    FILE        * LogFile = NULL;


    //
    // the server connection should be ready
    //
    if (NULL == gSamServerHandle)
    {
        //
        // not connect to any server yet
        // 
        RESOURCE_PRINT(IDS_SAM_NOT_CONNECTED);
        return (STATUS_UNSUCCESSFUL);
    }

    //
    //  Create the log file
    // 

    if (gUseDefaultLogFile)
    {
        RtlZeroMemory(gpwszLogFileName, MAX_PATH * sizeof(WCHAR) );
        wcscpy(gpwszLogFileName, SAM_DEFAULT_LOG_FILE);
    }

    if (L'\0' == gpwszLogFileName[0])
    {
        RESOURCE_PRINT1(IDS_SAM_INVALID_LOG_FILE_NAME, gpwszLogFileName); 
        return (STATUS_UNSUCCESSFUL);
    }

    LogFile = _wfopen(gpwszLogFileName, L"w");

    if (NULL == LogFile)
    {
        RESOURCE_PRINT1(IDS_SAM_CANT_CREATE_LOG_FILE, gpwszLogFileName);
        return (STATUS_UNSUCCESSFUL);
    }

    //
    // open the account domain
    // 
    NtStatus = SamOpenAccountDomain(&gServerName, 
                                    gSamServerHandle, 
                                    &DomainHandle
                                    );
     
    if (!NT_SUCCESS(NtStatus))
    {
        RESOURCE_PRINT(IDS_SAM_CANT_OPEN_ACCOUNT_DOMAIN);
        fclose(LogFile);
        return (NtStatus);
    }

    //
    // Initialize global variable 
    // 
    RtlInitializeGenericTable(
                &gSortedByRidTable, 
                RidTableCompare, 
                RidTableAllocate, 
                RidTableFree, 
                NULL
                );

    gpszMessage = (PWCHAR) READ_STRING(IDS_SAM_DUP_SID_CLEANUP_MSG);
    gpszAnd = (PWCHAR) READ_STRING(IDS_SAM_DUP_SID_CLEANUP_AND);


    //
    // Initialize all these enumeration info structure
    // 
    SamInitEnumInfo(&UserEnumInfo);
    SamInitEnumInfo(&WksEnumInfo);
    SamInitEnumInfo(&SrvEnumInfo);
    SamInitEnumInfo(&InterDomEnumInfo);
    SamInitEnumInfo(&GroupEnumInfo);
    SamInitEnumInfo(&AliasEnumInfo);


    if (NULL == UserEnumInfo.CmpAccounts ||
        NULL == WksEnumInfo.CmpAccounts || 
        NULL == SrvEnumInfo.CmpAccounts ||
        NULL == InterDomEnumInfo.CmpAccounts ||
        NULL == GroupEnumInfo.CmpAccounts ||
        NULL == AliasEnumInfo.CmpAccounts ) 
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }

    __try
    {
        while (UserEnumInfo.NotFinished || WksEnumInfo.NotFinished || 
               SrvEnumInfo.NotFinished || InterDomEnumInfo.NotFinished || 
               GroupEnumInfo.NotFinished || AliasEnumInfo.NotFinished )
        {
            RESOURCE_PRINT(IDS_SAM_DUP_SID_CLEANUP_STATUS);

            NtStatus = SamEnumerateAccounts(DomainHandle, 
                                            SampUserObjectType, 
                                            USER_NORMAL_ACCOUNT,
                                            &UserEnumInfo
                                            );

            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamEnumerateAccounts(DomainHandle, 
                                            SampUserObjectType, 
                                            USER_WORKSTATION_TRUST_ACCOUNT,
                                            &WksEnumInfo
                                            );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamEnumerateAccounts(DomainHandle, 
                                            SampUserObjectType, 
                                            USER_SERVER_TRUST_ACCOUNT,
                                            &SrvEnumInfo
                                            );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }       

            NtStatus = SamEnumerateAccounts(DomainHandle, 
                                            SampUserObjectType, 
                                            USER_INTERDOMAIN_TRUST_ACCOUNT,
                                            &InterDomEnumInfo
                                            );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamEnumerateAccounts(DomainHandle, 
                                            SampGroupObjectType, 
                                            0,
                                            &GroupEnumInfo
                                            );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamEnumerateAccounts(DomainHandle, 
                                            SampAliasObjectType, 
                                            0,
                                            &AliasEnumInfo
                                            );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }       

        
            NtStatus = SamUpdateCmpAccountsWithReturnedAccounts(&UserEnumInfo);
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamUpdateCmpAccountsWithReturnedAccounts(&WksEnumInfo);
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamUpdateCmpAccountsWithReturnedAccounts(&SrvEnumInfo);
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamUpdateCmpAccountsWithReturnedAccounts(&InterDomEnumInfo);
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamUpdateCmpAccountsWithReturnedAccounts(&GroupEnumInfo);
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            NtStatus = SamUpdateCmpAccountsWithReturnedAccounts(&AliasEnumInfo);
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            MinimumRid = SamGetMinimumRid(&UserEnumInfo, 
                                          &WksEnumInfo, 
                                          &SrvEnumInfo, 
                                          &InterDomEnumInfo,
                                          &GroupEnumInfo, 
                                          &AliasEnumInfo 
                                          );

            dbprintf(("MinimumRid MinimumRid MinimumRid ========> %x\n", MinimumRid));


            dbprintf(("Check User\n"));
            NtStatus = SamDetectAndCleanupDuplicateSid(DomainHandle, 
                                                       LogFile,
                                                       MinimumRid, 
                                                       &UserEnumInfo, 
                                                       Flags
                                                       );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            dbprintf(("Check Workstation\n"));
            NtStatus = SamDetectAndCleanupDuplicateSid(DomainHandle, 
                                                       LogFile,
                                                       MinimumRid, 
                                                       &WksEnumInfo, 
                                                       Flags
                                                       );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            dbprintf(("Check Server Machine\n"));
            NtStatus = SamDetectAndCleanupDuplicateSid(DomainHandle, 
                                                       LogFile,
                                                       MinimumRid, 
                                                       &SrvEnumInfo, 
                                                       Flags
                                                       );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            dbprintf(("Check Inter Domain Machine\n"));
            NtStatus = SamDetectAndCleanupDuplicateSid(DomainHandle, 
                                                       LogFile,
                                                       MinimumRid, 
                                                       &InterDomEnumInfo, 
                                                       Flags
                                                       );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }


            dbprintf(("Check Group\n"));
            NtStatus = SamDetectAndCleanupDuplicateSid(DomainHandle, 
                                                       LogFile,
                                                       MinimumRid, 
                                                       &GroupEnumInfo,
                                                       Flags
                                                       );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            dbprintf(("Check Alias\n"));
            NtStatus = SamDetectAndCleanupDuplicateSid(DomainHandle, 
                                                       LogFile,
                                                       MinimumRid, 
                                                       &AliasEnumInfo, 
                                                       Flags
                                                       );
            if (!NT_SUCCESS(NtStatus))
            {
                __leave;
            }

            SamFreeGenericTable();

            SamUpdateCmpAccountsAfterCheck(&UserEnumInfo, 
                                           MinimumRid);
            SamUpdateCmpAccountsAfterCheck(&WksEnumInfo,
                                           MinimumRid);
            SamUpdateCmpAccountsAfterCheck(&SrvEnumInfo,
                                           MinimumRid);
            SamUpdateCmpAccountsAfterCheck(&InterDomEnumInfo,
                                           MinimumRid);
            SamUpdateCmpAccountsAfterCheck(&GroupEnumInfo,
                                           MinimumRid);
            SamUpdateCmpAccountsAfterCheck(&AliasEnumInfo,
                                           MinimumRid);

        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        RESOURCE_PRINT(IDS_SAM_EXCEPTION);
        NtStatus = STATUS_UNHANDLED_EXCEPTION;
    }


Error:

    RESOURCE_PRINT(IDS_SAM_DUP_SID_CLEANUP_END);

    //
    // Cleanup EnumInfo.CmpAccounts, EnumInfo.ReturnedAccounts
    // And the RtlGenericTable
    //
 
    RESOURCE_STRING_FREE( gpszAnd );
    RESOURCE_STRING_FREE( gpszMessage );

    SamFreeGenericTable();

    if (DomainHandle)
    {
        SamCloseHandle(DomainHandle);
        DomainHandle = NULL;
    }

    if (LogFile)
    {
        fclose(LogFile);
        LogFile = NULL;
    }

    //
    // Free EnumInfo
    // 
    SamFreeEnumInfo(&UserEnumInfo);
    SamFreeEnumInfo(&WksEnumInfo);
    SamFreeEnumInfo(&SrvEnumInfo);
    SamFreeEnumInfo(&InterDomEnumInfo);
    SamFreeEnumInfo(&GroupEnumInfo);
    SamFreeEnumInfo(&AliasEnumInfo);


    return (NtStatus);
}



NTSTATUS
SamOpenAccountDomain(
    PUNICODE_STRING ServerName,
    SAM_HANDLE      SamHandle, 
    PSAM_HANDLE     pDomainHandle 
    )
/*++
Routine Description:

    This routine opens the Account Domain
    
Parameters:

    ServerName - pointer to unicode structure. hold server name
    
    SamHandle - SAM Server Handle

    pDomainHandle - return the SAM Account Domain Handle

Return Values:

    NtStatus Code
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    LSA_HANDLE  LsaHandle = NULL;
    PSID        pDomainSid;
    OBJECT_ATTRIBUTES   Attributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = NULL;
    ULONG       SidSize = 0;


    //
    // Get the Account Domain SID
    // 

    RtlZeroMemory(&Attributes, sizeof(OBJECT_ATTRIBUTES));

    NtStatus = LsaOpenPolicy(ServerName, 
                             &Attributes, 
                             POLICY_VIEW_LOCAL_INFORMATION, 
                             &LsaHandle
                             );

    if (!NT_SUCCESS(NtStatus))
    {
        return (NtStatus);
    }

    NtStatus = LsaQueryInformationPolicy(
                            LsaHandle, 
                            PolicyAccountDomainInformation, 
                            (PVOID *) &DomainInfo
                            );

    if (!NT_SUCCESS(NtStatus))
    {
        LsaClose(LsaHandle);
        return (NtStatus);
    }


    SidSize = RtlLengthSid(DomainInfo->DomainSid);

    pDomainSid = RtlAllocateHeap(RtlProcessHeap(), 0, SidSize ); 

    if (NULL == pDomainSid)
    {
        LsaFreeMemory(DomainInfo);
        LsaClose(LsaHandle);
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(pDomainSid, SidSize);

    RtlCopyMemory(pDomainSid, 
                  DomainInfo->DomainSid, 
                  SidSize
                  );

    //
    // Open Account Domain
    // 

    NtStatus = SamOpenDomain(SamHandle,
                             MAXIMUM_ALLOWED, 
                             (PSID) pDomainSid, 
                             pDomainHandle
                             );

    //
    // Clean up
    // 

    LsaFreeMemory(DomainInfo);

    LsaClose(LsaHandle);

    RtlFreeHeap(RtlProcessHeap(), 0, pDomainSid);

    if (!NT_SUCCESS(NtStatus))
    {
        *pDomainHandle = NULL;
    }

    return (NtStatus);
}



NTSTATUS
SamEnumerateAccounts(
    IN SAM_HANDLE DomainHandle, 
    IN SAMP_OBJECT_TYPE ObjectType, 
    IN ULONG UserAccountControl,
    IN OUT PSAM_ENUMERATION_INFO  EnumInfo
    )
/*++
Routine Description:
    
    this routine does the SAM enumeration

Parameters:

    DomainHandle - Handle of an opened domain.

    ObjectType - Indicate the object Type, (user, group or alias)

    UserAccountControl - Used to enumerate Normal User or Machine
    
    EnumInfo - tell how many entries returned and the Rid, Account name info..
    
Return Values:

    NTSTATUS
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       PreferedMaxLength = 0;


    dbprintf(("Ask For   %d Entries\n", EnumInfo->PreferedCount));
    //
    // if Finished already, or ask for 0 entry. Return immediately.
    // 
    if (!(EnumInfo->NotFinished) || (0 == EnumInfo->PreferedCount) )
    {
        EnumInfo->ReturnedAccounts = NULL;
        EnumInfo->ReturnedCount = 0;
        return (STATUS_SUCCESS);
    }

    //
    // Calculate the length of memory.
    // Because in enum.c, they add one entry for everybody. 
    // so ( - 1 ) in below, to ensure that we always get the 
    // most clost entries to our request. 
    // 

    PreferedMaxLength = (EnumInfo->PreferedCount - 1 ) * AVERAGE_MEMORY_PER_ENTRY; 

    //
    // make the enumeration according to the object type
    // 
    switch (ObjectType) {
    case SampUserObjectType:
        NtStatus = SamEnumerateUsersInDomain(DomainHandle, 
                                             &(EnumInfo->EnumContext), 
                                             UserAccountControl,
                                             (PVOID *) &(EnumInfo->ReturnedAccounts), 
                                             PreferedMaxLength, 
                                             &(EnumInfo->ReturnedCount)
                                             );
        break;
    case SampGroupObjectType:
        NtStatus = SamEnumerateGroupsInDomain(DomainHandle, 
                                              &(EnumInfo->EnumContext), 
                                              (PVOID *) &(EnumInfo->ReturnedAccounts), 
                                              PreferedMaxLength, 
                                              &(EnumInfo->ReturnedCount)
                                              );
        break;
    case SampAliasObjectType:
        NtStatus = SamEnumerateAliasesInDomain(DomainHandle, 
                                               &(EnumInfo->EnumContext), 
                                               (PVOID *) &(EnumInfo->ReturnedAccounts), 
                                               PreferedMaxLength, 
                                               &(EnumInfo->ReturnedCount)
                                               );
        break;
    default:
        return (STATUS_INVALID_PARAMETER);
    }

    dbprintf(("Return %d entries.\n", EnumInfo->ReturnedCount));

    //
    // Set correct value, when enumeration ends.
    // 
    if (STATUS_MORE_ENTRIES == NtStatus)
    {
        EnumInfo->NotFinished = TRUE;
    }
    else
    {
        EnumInfo->NotFinished = FALSE;

        dbprintf(("Finished !!!!! \n")); 
    }

    {
        ULONG i;

        for (i = 0; i < EnumInfo->ReturnedCount; i++)
        {
            dbprintf((" %x ", EnumInfo->ReturnedAccounts[i].RelativeId));
        }
    }

    return (NtStatus);

}



ULONG
SamGetMinimumRid(
    IN PSAM_ENUMERATION_INFO UserEnumInfo, 
    IN PSAM_ENUMERATION_INFO WksEnumInfo, 
    IN PSAM_ENUMERATION_INFO SrvEnumInfo, 
    IN PSAM_ENUMERATION_INFO InterDomEnumInfo, 
    IN PSAM_ENUMERATION_INFO GroupEnumInfo, 
    IN PSAM_ENUMERATION_INFO AliasEnumInfo
    )
/*++
Routine Description:

    Compare the Upper Limits, return the smallest one.
    
Parameters:
    
    All Enumeration Info
    
Return Value:

    smallest Upper Limit

--*/
{
    ULONG   UserLastRid = SAMP_MAXIMUM_DOMAIN_RID;
    ULONG   WksLastRid = SAMP_MAXIMUM_DOMAIN_RID;
    ULONG   SrvLastRid = SAMP_MAXIMUM_DOMAIN_RID;
    ULONG   InterDomLastRid = SAMP_MAXIMUM_DOMAIN_RID;
    ULONG   GroupLastRid = SAMP_MAXIMUM_DOMAIN_RID;
    ULONG   AliasLastRid = SAMP_MAXIMUM_DOMAIN_RID;
    ULONG   Temp1 = 0;
    ULONG   Temp2 = 0;
    ULONG   Temp3 = 0;


    if ((NULL != UserEnumInfo->CmpAccounts) && 
        (0 != UserEnumInfo->CmpCount) && 
        (UserEnumInfo->NotFinished) )
    {
        UserLastRid = UserEnumInfo->CmpAccounts
                                [UserEnumInfo->CmpCount - 1].RelativeId;
    }

    if ((NULL != WksEnumInfo->CmpAccounts) && 
        (0 != WksEnumInfo->CmpCount) &&
        (WksEnumInfo->NotFinished) )
    {
        WksLastRid = WksEnumInfo->CmpAccounts
                                [WksEnumInfo->CmpCount - 1].RelativeId;
    }

    if ((NULL != SrvEnumInfo->CmpAccounts) && 
        (0 != SrvEnumInfo->CmpCount) && 
        (SrvEnumInfo->NotFinished) )
    {
        SrvLastRid = SrvEnumInfo->CmpAccounts
                                [SrvEnumInfo->CmpCount - 1].RelativeId;
    }

    if ((NULL != InterDomEnumInfo->CmpAccounts) && 
        (0 != InterDomEnumInfo->CmpCount) &&
        (InterDomEnumInfo->NotFinished) )
    {
        InterDomLastRid = InterDomEnumInfo->CmpAccounts
                                [InterDomEnumInfo->CmpCount - 1].RelativeId;
    }

    if ((NULL != GroupEnumInfo->CmpAccounts) && 
        (0 != GroupEnumInfo->CmpCount) &&
        (GroupEnumInfo->NotFinished) )
    {
        GroupLastRid = GroupEnumInfo->CmpAccounts
                                [GroupEnumInfo->CmpCount - 1].RelativeId;
    }

    if ((NULL != AliasEnumInfo->CmpAccounts) && 
        (0 != AliasEnumInfo->CmpCount) &&
        (AliasEnumInfo->NotFinished) )
    {
        AliasLastRid = AliasEnumInfo->CmpAccounts
                                [AliasEnumInfo->CmpCount - 1].RelativeId;
    }

    Temp1 = (UserLastRid < WksLastRid) ? UserLastRid : WksLastRid;

    Temp2 = (SrvLastRid < InterDomLastRid) ? SrvLastRid : InterDomLastRid;
    
    Temp3 = (GroupLastRid < AliasLastRid) ? GroupLastRid : AliasLastRid;

    
    return( (min(Temp1, Temp2) < Temp3) ? min(Temp1, Temp2) : Temp3 );
}


NTSTATUS
SamUpdateCmpAccountsWithReturnedAccounts(
    IN OUT PSAM_ENUMERATION_INFO EnumInfo
    )
/*++
Routine Description:

    This routine merges the EnumInfo->ReturnedAccounts with 
    EnumInfo->CmpAccounts. The merged results will be placed in 
    CmpAccounts. ReturnedAccounts should be released by calling
    SamFreeMemory(). 
    
    Note: Allocate memory for account name in the SAM_RID_ENUMERATION
          structure.
          
Parameters:

    EnumInfo - pointer to SAM_ENUMERATION_INFO

Return Values:

    NTSTATUS Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       Index = 0;
    ULONG       ReturnedIndex = 0;


    //
    // Nothing to merge if ReturnedAccounts does not
    // container any info
    //

    if ((NULL == EnumInfo->ReturnedAccounts) ||
        (0 == EnumInfo->ReturnedCount) )
    {
        return (STATUS_SUCCESS);
    }

    dbprintf(("ReturnedCount %d  CmpCount %d Capacity %d ", 
              EnumInfo->ReturnedCount, 
              EnumInfo->CmpCount, 
              EnumInfo->CmpCapacity
              )); 


    //
    // if the returned accounts plus the entries waiting to be examined exceed
    // our capacity. Extend the memory
    // 
    if ((EnumInfo->CmpCount + EnumInfo->ReturnedCount) > EnumInfo->CmpCapacity)
    {
        PVOID   Temp = NULL;
        ULONG   Count = 0;

        dbprintf(("Extend the memory\n"));        

        Count = EnumInfo->CmpCount + EnumInfo->ReturnedCount;

        Temp = RtlAllocateHeap(RtlProcessHeap(), 
                               0, 
                               Count * sizeof(SAM_RID_ENUMERATION)
                               );

        if (NULL == Temp)
        {
            //
            // ReturnedAccounts will be freed when we terminate 
            //
            return (STATUS_NO_MEMORY);
        }

        RtlZeroMemory(Temp, Count * sizeof(SAM_RID_ENUMERATION));

        RtlCopyMemory(Temp, 
                      EnumInfo->CmpAccounts, 
                      EnumInfo->CmpCount * sizeof(SAM_RID_ENUMERATION)
                      );

        RtlFreeHeap(RtlProcessHeap(), 0, EnumInfo->CmpAccounts);

        EnumInfo->CmpAccounts = (PSAM_RID_ENUMERATION) Temp;
        EnumInfo->CmpCapacity = EnumInfo->CmpCount + EnumInfo->ReturnedCount;
    }

    
    //
    // copy the info in ReturnedAccounts to the 
    // end of CmpAccounts
    // 

    Index = EnumInfo->CmpCount;

    for (ReturnedIndex = 0; 
         ReturnedIndex < EnumInfo->ReturnedCount;
         ReturnedIndex++ )
    {
        USHORT   Length = 0;

        //
        // need one more WCHAR for NULL terminator
        // 
        Length = EnumInfo->ReturnedAccounts[ReturnedIndex].Name.Length + sizeof(WCHAR);

        EnumInfo->CmpAccounts[Index].RelativeId = 
                    EnumInfo->ReturnedAccounts[ReturnedIndex].RelativeId;

        EnumInfo->CmpAccounts[Index].Name.Length = Length;

        //
        // Allocate the space for account name
        // 
        EnumInfo->CmpAccounts[Index].Name.Buffer =  (PWCHAR)
                    RtlAllocateHeap(RtlProcessHeap(), 0, Length); 

        if (NULL == EnumInfo->CmpAccounts[Index].Name.Buffer)
        {
            //
            // ReturnedAccounts will be freed when we terminate
            // 
            return (STATUS_NO_MEMORY);
        }

        RtlZeroMemory(EnumInfo->CmpAccounts[Index].Name.Buffer, 
                      Length
                      );

        RtlCopyMemory(EnumInfo->CmpAccounts[Index].Name.Buffer, 
                      EnumInfo->ReturnedAccounts[ReturnedIndex].Name.Buffer, 
                      Length - sizeof(WCHAR)
                      );

        Index ++;
        EnumInfo->CmpCount ++;
    }

    dbprintf(("CmpCount after merge is %d\n", EnumInfo->CmpCount));

    //
    // SamFreeMemory will also free the memory occupied by
    // account name
    // 
    SamFreeMemory(EnumInfo->ReturnedAccounts);

    EnumInfo->ReturnedAccounts = NULL;
    EnumInfo->ReturnedCount = 0;

    return (NtStatus);
}



VOID
SamUpdateCmpAccountsAfterCheck(
    IN OUT PSAM_ENUMERATION_INFO EnumInfo, 
    IN ULONG MinimumRid
    )
/*++
Routine Description:
    
    This routine will update the CmpAccounts array. Remove 
    those entries which have been examined already.

    Note: we will keep the entries whose RID is equal to the 
          MinimumRid
    
Parameters:

    EnumInfo - pointer to SAM_ENUMERATION_INFO
    
Return Values:

    None
--*/
{
    ULONG       RemovedCount;  
    ULONG       Index = 0;

    dbprintf(("CheckedCount ==> %d in CmpCount ==> %d  ", 
           EnumInfo->CheckedCount, 
           EnumInfo->CmpCount));

    //
    // if less then 1 entry has been checked, nothing 
    // to discard
    // 
    if (EnumInfo->CheckedCount >= 1)
    {
        //
        // Calculate the number of entries which should be discarded.
        //

        RemovedCount = EnumInfo->CheckedCount;

        if (EnumInfo->CmpAccounts[EnumInfo->CheckedCount - 1].RelativeId == MinimumRid )
        {
            RemovedCount --;
        }

        //
        // Release the space occupied by the account names
        // 
        for (Index = 0; Index < RemovedCount; Index ++)
        {
            RtlFreeHeap(RtlProcessHeap(), 0, EnumInfo->CmpAccounts[Index].Name.Buffer);
        }

        //
        // move all the entries (left) to the front of this array.
        // 
        for (Index = RemovedCount; Index < EnumInfo->CmpCount; Index ++)
        {
            EnumInfo->CmpAccounts[Index - RemovedCount] = EnumInfo->CmpAccounts[Index];
        }

        //
        // zero the rest of entries
        // 
        for (Index = EnumInfo->CmpCount - RemovedCount; 
             Index < EnumInfo->CmpCount;
             Index ++)
        {
            RtlZeroMemory(&(EnumInfo->CmpAccounts[Index]), sizeof(SAM_RID_ENUMERATION) );
        }

        dbprintf(("RemovedCount is %d ", RemovedCount));
        //
        // Update counters
        //
        EnumInfo->CmpCount -= RemovedCount;

    }

    //
    // Calculate how many new entries we can ask for
    // 
    EnumInfo->PreferedCount = EnumInfo->CmpCapacity - EnumInfo->CmpCount;
    EnumInfo->CheckedCount = 0;

    dbprintf(("New CmpCount after remove %d \n", EnumInfo->CmpCount ));


    return;
}


NTSTATUS
SamDetectAndCleanupDuplicateSid(
    IN SAM_HANDLE DomainHandle,
    IN FILE * LogFile,
    IN ULONG MinimumRid,
    IN PSAM_ENUMERATION_INFO EnumInfo, 
    IN ULONG Flags
    )
/*++
Routine Description:

    This routine checks all entries in EnumInfo->CmpAccounts whose Rid
    is less than MinimumRid by insert them into the gSortedByRidTable. 

Parameters:

    DomainHandle - SAM handle to an opened domain (which holds the RID)
    
    MinimumRid - Define the upper limit of Entries which we should check.
    
    EnumInfo - pointer to the SAM_ENUMERATION_INFO structure

    Flags - Control the behaivor of this function. (Whether cleanup the 
            duplicate SID or just check.

Return Values:

    NTSTATUS code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    SAM_RID_ENUMERATION Account;
    ULONG       Index = 0;
    USHORT      BufferSize = 0;
    BOOLEAN     fNewElement = TRUE;
    PGENERIC_TABLE_ELEMENT TableElement = NULL;
    PGENERIC_TABLE_ELEMENT OldElement = NULL;
    PWCHAR      Msg = NULL;



    EnumInfo->CheckedCount = 0;

    for (Index = 0; Index < EnumInfo->CmpCount; Index++)
    {
        TableElement = NULL;
        OldElement = NULL;
        fNewElement = TRUE;


        Account = EnumInfo->CmpAccounts[Index];


        if (Account.RelativeId <= MinimumRid)
        {
            // dbprintf(("Check %x %ls\n", Account.RelativeId, Account.Name.Buffer));

            //
            //  construct a new table element for insertion
            // 
            BufferSize = CalculateBufferSize(Account.Name);

            TableElement = (PGENERIC_TABLE_ELEMENT)
                            RtlAllocateHeap(RtlProcessHeap(), 0, BufferSize);

            if (NULL == TableElement)
            {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            RtlZeroMemory(TableElement, BufferSize);

            TableElement->Rid = Account.RelativeId;
            TableElement->Length = Account.Name.Length;

            wcsncpy(TableElement->Name, 
                    Account.Name.Buffer, 
                    Account.Name.Length / sizeof(WCHAR)
                    );

            //
            // Insert it into the Generic Table
            // 
            OldElement = (PGENERIC_TABLE_ELEMENT)
                         RtlInsertElementGenericTable(
                                    &gSortedByRidTable, 
                                    TableElement, 
                                    BufferSize, 
                                    &fNewElement
                                    );


            if (!fNewElement)
            {
                ULONG  BufferSize = 0;

                //
                // Duplicate Rid ==> SID happened
                // 

                //
                // create the message
                // 
                if (!gpszMessage || ! gpszAnd) {
                    NtStatus = STATUS_UNSUCCESSFUL;
                    goto Cleanup;
                }
                BufferSize = TableElement->Length + 
                             OldElement->Length +
                             (wcslen(gpszMessage) + wcslen(gpszAnd) + 1 ) * sizeof(WCHAR);

                Msg = (PWCHAR) RtlAllocateHeap(RtlProcessHeap(), 0, BufferSize);

                if (NULL == Msg)
                {
                    NtStatus = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                RtlZeroMemory(Msg, BufferSize);

                swprintf(Msg, L"%s%s%s%s", 
                         gpszMessage, 
                         TableElement->Name, 
                         gpszAnd, 
                         OldElement->Name
                         );

                dbprintf(("DUPLICATE DUPLICATE DUPLICATE %ls %d\n", 
                          Msg, 
                          TableElement->Rid
                          ));

                fwprintf(LogFile, L"%s", Msg);
                fwprintf(LogFile, L"\n\n");
                fflush(LogFile);

                RtlFreeHeap(RtlProcessHeap(), 0, Msg);
                Msg = NULL;

                //
                // clean up the duplicate sid if the client asked to do so.
                // 
                if (Flags & SAM_DUPLICATE_SID_CLEANUP)
                {
                    SAM_HANDLE UserHandle = NULL;
                    NTSTATUS   IgnoreStatus = STATUS_SUCCESS;

                    //
                    // clean up the duplicate SID by
                    // explicitly Lookup this Account
                    //

                    IgnoreStatus = SamOpenUser(DomainHandle,
                                               MAXIMUM_ALLOWED,
                                               TableElement->Rid,
                                               &UserHandle
                                               );

                    //
                    // close the SAM handle if we should do so.
                    //
                    if (UserHandle || NT_SUCCESS(IgnoreStatus))
                    {
                        SamCloseHandle(UserHandle);
                    }
                }
            }

            EnumInfo->CheckedCount ++;
            RtlFreeHeap(RtlProcessHeap(), 0, TableElement);
            TableElement = NULL;

        }
        else
            break;
    }

Cleanup:

    if (Msg) {
        RtlFreeHeap(RtlProcessHeap(), 0, Msg);
    }

    if (TableElement) {
        RtlFreeHeap(RtlProcessHeap(), 0, TableElement);
    }

    return (NtStatus);
}


VOID
SamInitEnumInfo(
    PSAM_ENUMERATION_INFO EnumInfo
    )
/*++
Routine Description

    Initialize an EnumInfo Structure

Parameter:

    EnumInfo - pointer to the structure needs to be intialized.

Return Values:
    
    None.
--*/
{
    ASSERT(EnumInfo);

    RtlZeroMemory(EnumInfo, sizeof(SAM_ENUMERATION_INFO));

    EnumInfo->NotFinished = TRUE;    
    EnumInfo->PreferedCount = INIT_COUNT_COMPARE_ACCOUNTS;

    EnumInfo->CmpAccounts = (PSAM_RID_ENUMERATION) 
                            RtlAllocateHeap(
                                RtlProcessHeap(), 
                                0, 
                                sizeof(SAM_RID_ENUMERATION) * INIT_COUNT_COMPARE_ACCOUNTS
                                );

    if (NULL == EnumInfo->CmpAccounts)
    {
        return;
    }

    EnumInfo->CmpCapacity = INIT_COUNT_COMPARE_ACCOUNTS;

    RtlZeroMemory(EnumInfo->CmpAccounts, 
                  sizeof(SAM_RID_ENUMERATION) * INIT_COUNT_COMPARE_ACCOUNTS
                  );
                  
    return;
}





VOID
SamFreeEnumInfo(
    PSAM_ENUMERATION_INFO EnumInfo
    )
/*++
Routine Description

    Free an EnumInfo Structure and memory accociated with it.

Parameter:

    EnumInfo - pointer to the structure needs to be intialized.

Return Values:
    
    None.
--*/
{
    ULONG   Index = 0;

    if (EnumInfo->CmpAccounts)
    {
        for (Index = 0; Index < EnumInfo->CmpCount; Index ++)
        {
            RtlFreeHeap( RtlProcessHeap(), 
                         0, 
                         EnumInfo->CmpAccounts[Index].Name.Buffer
                       );
        }

        RtlFreeHeap( RtlProcessHeap(), 
                     0, 
                     EnumInfo->CmpAccounts
                    );
    }

    if (EnumInfo->ReturnedAccounts)
    {
        SamFreeMemory(EnumInfo->ReturnedAccounts);
    }

    RtlZeroMemory(EnumInfo, sizeof(SAM_ENUMERATION_INFO));

    return;
}
    



VOID
SamCleanupGlobals(
    VOID
    )
/*++
Routine Description:

    Cleanup all Global Variables when quit from security account management
    
Parameters:
    None.
    
Return Values:
    None.

--*/
{

    //
    // sam server handle
    //
    if (gSamServerHandle)
    {
        SamCloseHandle(gSamServerHandle);
        gSamServerHandle = NULL;
    }

    //
    // Server Name
    // 
    RtlZeroMemory(&gServerName, sizeof(UNICODE_STRING));
    RtlZeroMemory(gpwszServerName, MAX_PATH * sizeof(WCHAR));

    //
    // Log file Name
    // 
    gUseDefaultLogFile = TRUE;
    RtlZeroMemory(gpwszLogFileName, MAX_PATH * sizeof(WCHAR));

    return;
}




VOID
SamFreeGenericTable(
    VOID
    )
/*++
Routine Description:

    Free the memory occupied by the Generic Table element

Parameter:
    
    None.
    
Return Values:

    None.
--*/
{
    PGENERIC_TABLE_ELEMENT  TableElement = NULL;
    BOOLEAN     Restart = TRUE;

    dbprintf(("Generic Table is Empty? : %d Number of Element: %d ", 
           RtlIsGenericTableEmpty(&gSortedByRidTable), 
           RtlNumberGenericTableElements(&gSortedByRidTable)
           ));

    for( TableElement = (PGENERIC_TABLE_ELEMENT) RtlEnumerateGenericTable(&gSortedByRidTable, TRUE);
         TableElement != NULL; // !RtlIsGenericTableEmpty(&gSortedByRidTable); 
         TableElement = (PGENERIC_TABLE_ELEMENT) RtlEnumerateGenericTable(&gSortedByRidTable, TRUE)
        )
    {
        RtlDeleteElementGenericTable(&gSortedByRidTable, TableElement);
    }

    dbprintf(("Generic Table is Emptied %d\n", 
           RtlIsGenericTableEmpty(&gSortedByRidTable)
           ));
}




/////////////////////////////////////////////////////////////////////
//                                                                 //
//  Implementation for RTL Generic Table Functions                 //
//  About the parameters and return values, please refer to        //
//  ntrtl.h                                                        //
//                                                                 //
/////////////////////////////////////////////////////////////////////


PVOID
RidTableAllocate(
    RTL_GENERIC_TABLE   *Table,
    CLONG               ByteSize)
{
    return (RtlAllocateHeap(RtlProcessHeap(), 0, ByteSize));
}

//////////////////////////////////////////////////////////////////////


VOID
RidTableFree(
    RTL_GENERIC_TABLE   *Table,
    PVOID               Buffer)
{
    RtlFreeHeap(RtlProcessHeap(), 0, Buffer);
}


///////////////////////////////////////////////////////////////////////


RTL_GENERIC_COMPARE_RESULTS
RidTableCompare(
    RTL_GENERIC_TABLE   *Table,
    PVOID               FirstStruct,
    PVOID               SecondStruct)
{

    ULONG       Rid1, Rid2;

    Rid1 = ((PGENERIC_TABLE_ELEMENT) FirstStruct)->Rid;
    Rid2 = ((PGENERIC_TABLE_ELEMENT) SecondStruct)->Rid;


    //
    // use the Rid as the base of comparation.
    // 

    if (Rid1 > Rid2)
    {
        return GenericGreaterThan;
    }
    else if (Rid1 < Rid2)
    {
        return GenericLessThan;
    }
    else
    {
        return GenericEqual;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\scheckc.c ===
#include <NTDSpch.h>
#pragma hdrstop

#include <process.h>
#include <dsjet.h>
#include <ntdsa.h>
#include <scache.h>
#include <mdglobal.h>
#include <dbglobal.h>
#include <attids.h>
#include <dbintrnl.h>
#include <dbopen.h>
#include <dsconfig.h>
#include <ctype.h>
#include <direct.h>
#include <ntdsa.h>
#include <dsutil.h>
#include <ctype.h>
#include <dsatools.h>
#include <mdlocal.h>        // for BAD_NAME_CHAR
#include <anchor.h>
#include <quota.h>

#include "parsedn.h"
#include "ditlayer.h"
#include "reshdl.h"
#include "resource.h"
#include <winldap.h>
#include "utilc.h"

#include "scheck.h"

//
// Global Variables
//

JET_INSTANCE    jetInstance = -1;
JET_SESID       sesid = JET_sesidNil;
JET_DBID        dbid = JET_dbidNil;
JET_TABLEID     tblid = JET_tableidNil;
JET_TABLEID     sdtblid = JET_tableidNil;
JET_TABLEID     linktblid = JET_tableidNil;
JET_COLUMNID    dntid;
JET_COLUMNID    ncdntid;
JET_COLUMNID    objid;
JET_COLUMNID    insttypeid;
JET_COLUMNID    isdeletedid;
JET_COLUMNID    ntsecdescid;
JET_COLUMNID    blinkid;
JET_COLUMNID    sdidid;
JET_COLUMNID    sdrefcountid;
JET_COLUMNID    sdvalueid;

char        *szIndex = SZDNTINDEX;
BOOL        LogToFile = TRUE;
BOOL        fTerminateJet = FALSE;
DWORD       IndexCount = 0;

CHAR        gszFileName[MAX_PATH+1] = {0};

WCHAR       pszDeletedNameTag[]  = {BAD_NAME_CHAR, L'D', L'E', L'L', L':', L'\0'};
WCHAR       pszConflictNameTag[] = {BAD_NAME_CHAR, L'C', L'N', L'F', L':', L'\0'};

//
// constant definitions
//
#define MAX_PRINTF_LEN 1024        // Arbitrary.
#define SZCONFIG_W      L"CN=Configuration"
#define SZPARTITIONS_W  L"CN=Partitions"

// Error handling
// Not internationalized because being delivered in a service pack

#define XERROR(str)                fprintf(stderr, str);
#define XERROR1(str, a1)           fprintf(stderr, str, a1);
#define XERROR2(str, a1, a2)       fprintf(stderr, str, a1, a2);
#define XERROR3(str, a1, a2, a3)   fprintf(stderr, str, a1, a2, a3);

// Verbose dev debug/test
#define CNF_NC_DBG DBG

#if CNF_NC_DBG
#define XDBG(str)                fprintf(stderr, str);
#define XDBG1(str, a1)           fprintf(stderr, str, a1);
#define XDBG2(str, a1, a2)       fprintf(stderr, str, a1, a2);
#define XDBG3(str, a1, a2, a3)   fprintf(stderr, str, a1, a2, a3);
#define XDBG4(str, a1, a2, a3, a4)   fprintf(stderr, str, a1, a2, a3, a4);
#else
#define XDBG(str)
#define XDBG1(str, a1)
#define XDBG2(str, a1, a2)
#define XDBG3(str, a1, a2, a3)
#define XDBG4(str, a1, a2, a3, a4)
#endif

//
// command line switches
//

BOOL        VerboseMode = FALSE;
long        lCount;
HANDLE      hsLogFile = INVALID_HANDLE_VALUE;

//
// local prototypes
//

HRESULT
FixMangledNC(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD CrossRefDnt,
    IN DWORD MangledDnt,
    IN LPWSTR pRdn
    );

HRESULT
FixConfNCByRenameWithStructColl(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD CrossRefDnt,
    IN DWORD MangledDnt,
    IN LPWSTR pRdn
    );

HRESULT
FixDELMangledNC(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD CrossRefDnt,
    IN DWORD MangledDnt,
    IN LPWSTR pRdn
    );

HRESULT
FixConfNCUndelete(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD CrossRefDnt,
    IN DWORD MangledDnt,
    IN LPWSTR pRdn,
    IN DWORD cLen
    );

HRESULT
FixConfNCByResetNcName(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD CrossRefDnt,
    IN DWORD MangledDnt,
    IN DWORD UnmangledDnt,
    IN LPWSTR pRdn,
    IN DWORD cLen
    );

HRESULT
ReParentChildren(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD dntNew,
    IN DWORD dntOld
    );

HRESULT
ReParent(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD dntKid,
    IN DWORD dntNew,
    IN DWORD dntOld
    );

HRESULT
UnmangleDn(
    IN  OUT LPWSTR pDn
    );

LPWSTR
MangleRdn(
    IN  LPWSTR  pDn,
    IN  LPWSTR  szTag,
    IN  GUID    guid
    );


//
// Implementation
//

VOID
StartSemanticCheck(
    IN BOOL fFixup,
    IN BOOL fVerbose
    )
{

    DWORD nRecs, nSDs;
    JET_ERR err;

    VerboseMode = fVerbose;

    if ( OpenJet(NULL) == S_OK ) {
        err = OpenTable(fFixup, TRUE, &nRecs, &nSDs); // read only, count records

        if (err == 0) {

            if ( LogToFile ) {
                OpenLogFile( );
            }

            DoRefCountCheck( nRecs, nSDs, fFixup );

            CloseLogFile( );
        }
    }

    CloseJet();

    return;

} // StartSemanticCheck


//  HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK
//  must duplicate definition because ntdsutil can't see the real one
//
DSA_ANCHOR gAnchor;

//  HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK
//  must duplicate definition because ntdsutil can't see the real one
//
volatile SHUTDOWN	eServiceShutdown	= eRunning;


#ifdef AUDIT_QUOTA_OPERATIONS

//  HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK
//  must duplicate definition because ntdsutil can't see the real one
//
VOID QuotaAudit_(
	JET_SESID		sesid,
	JET_DBID		dbid,
	DWORD			dnt,
	DWORD			ncdnt,
	PSID			psidOwner,
	const ULONG		cbOwnerSid,
	const DWORD		fUpdatedTotal,
	const DWORD		fUpdatedTombstoned,
	const DWORD		fIncrementing,
	const DWORD		fAdding,
	const CHAR		fRebuild )
    {
    return;
    }

#endif


//  HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK! HACK
//  must duplicate definition because ntdsutil can't see the real one
//
JET_ERR JetCloseTableWithErr_(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_ERR			err,
	const BOOL		fHandleException,
	const USHORT	usFile,
	const INT		lLine )
	{
	const JET_ERR	errT	= JetCloseTable( sesid, tableid );

	//	should not normally fail
	//
	ASSERT( JET_errSuccess == errT );

	//	tableid should have already been pre-validated by caller
	//
	ASSERT( JET_tableidNil != tableid );

	//	this hack version is only called without exception-handling
	//
	ASSERT( !fHandleException );

	return ( JET_errSuccess != errT && JET_errSuccess == err ? errT : err );
	}


JET_ERR ErrCacheColumnidsForQuotaIntegrityCheck()
    {
	JET_ERR			err;
	JET_TABLEID		tableid		= JET_tableidNil;
	JET_COLUMNDEF	columndef;

	//	cache columns of Quota table
	//
	err = JetOpenTable(
				sesid,
				dbid,
				g_szQuotaTable,
				NULL,		//	pvParameters
				0,			//	cbParameters
				JET_bitTableDenyRead,
				&tableid );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}

	err = JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szQuotaColumnNcdnt,
				&columndef,
				sizeof(columndef),
				JET_ColInfo );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	g_columnidQuotaNcdnt = columndef.columnid;

	err = JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szQuotaColumnSid,
				&columndef,
				sizeof(columndef),
				JET_ColInfo );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	g_columnidQuotaSid = columndef.columnid;

	err = JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szQuotaColumnTombstoned,
				&columndef,
				sizeof(columndef),
				JET_ColInfo );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	g_columnidQuotaTombstoned = columndef.columnid;

	err = JetGetTableColumnInfo(
				sesid,
				tableid,
				g_szQuotaColumnTotal,
				&columndef,
				sizeof(columndef),
				JET_ColInfo );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	g_columnidQuotaTotal = columndef.columnid;

	err = JetCloseTable( sesid, tableid );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	tableid = JET_tableidNil;


	//	cache columns of Datatable
	//
	err = JetOpenTable(
				sesid,
				dbid,
				SZDATATABLE,
				NULL,		//	pvParameters
				0,			//	cbParameters
				JET_bitTableDenyRead,
				&tableid );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}

	err = JetGetTableColumnInfo(
				sesid,
				tableid,
				SZDNT,
				&columndef,
				sizeof(columndef),
				JET_ColInfo );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	dntid = columndef.columnid;

	err = JetGetTableColumnInfo(
				sesid,
				tableid,
				SZNCDNT,
				&columndef,
				sizeof(columndef),
				JET_ColInfo );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	ncdntid = columndef.columnid;

	err = JetGetTableColumnInfo(
				sesid,
				tableid,
				SZOBJ,
				&columndef,
				sizeof(columndef),
				JET_ColInfo );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	objid = columndef.columnid;

	err = JetGetTableColumnInfo(
				sesid,
				tableid,
				SZINSTTYPE,
				&columndef,
				sizeof(columndef),
				JET_ColInfo );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	insttypeid = columndef.columnid;

	err = JetGetTableColumnInfo(
				sesid,
				tableid,
				SZISDELETED,
				&columndef,
				sizeof(columndef),
				JET_ColInfo );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	isdeletedid = columndef.columnid;

	err = JetGetTableColumnInfo(
				sesid,
				tableid,
				SZNTSECDESC,
				&columndef,
				sizeof(columndef),
				JET_ColInfo );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	ntsecdescid = columndef.columnid;

	err = JetCloseTable( sesid, tableid );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	tableid = JET_tableidNil;


	//	cache columns of SD table
	//
	err = JetOpenTable(
				sesid,
				dbid,
				SZSDTABLE,
				NULL,		//	pvParameters
				0,			//	cbParameters
				JET_bitTableDenyRead,
				&tableid );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}

	err = JetGetTableColumnInfo(
				sesid,
				tableid,
				SZSDVALUE,
				&columndef,
				sizeof(columndef),
				JET_ColInfo );
	if ( JET_errSuccess != err )
		{
		goto HandleError;
		}
	sdvalueid = columndef.columnid;

HandleError:
	if ( JET_tableidNil != tableid )
		{
		//	only trap CloseTable error if no other error was encountered
		//
		const JET_ERR	errT	= JetCloseTable( sesid, tableid );
		err = ( JET_errSuccess != errT && JET_errSuccess == err ? errT : err );
		}

	return err;
    }

VOID StartQuotaIntegrity()
	{
	if ( S_OK == OpenJet( NULL ) )
		{
		DWORD	err;
		ULONG	cCorruptions	= 0;

		RESOURCE_PRINT( IDS_SCHECK_QUOTA_RUN_INTEGRITY );

		err = ErrCacheColumnidsForQuotaIntegrityCheck();
		if ( JET_errSuccess == err )
			{
			err = ErrQuotaIntegrityCheck( sesid, dbid, &cCorruptions );
			}
		if ( err )
			{
			RESOURCE_PRINT2( IDS_SCHECK_QUOTA_ERROR, err, GetJetErrString( err ) );
			}
		else if ( 0 != cCorruptions )
			{
			RESOURCE_PRINT1( IDS_SCHECK_QUOTA_CORRUPTION, cCorruptions );
			}
		else
			{
			RESOURCE_PRINT( IDS_SCHECK_QUOTA_NO_CORRUPTION );
			}
		}

	CloseJet();
	}

VOID StartQuotaRebuild()
	{
	if ( S_OK == OpenJet( NULL ) )
		{
		//	async rebuild is forced on subsequent init by deleting
		//	the quota table
		//
		const JET_ERR	err		= JetDeleteTable( sesid, dbid, g_szQuotaTable );

		switch ( err )
			{
			case JET_errSuccess:
			case JET_errObjectNotFound:
				//	quota-table will be scheduled for async rebuild on
				//	next reboot
				//
				RESOURCE_PRINT( IDS_SCHECK_QUOTA_REBUILD_SUCCESS );
				break;

			default:
				RESOURCE_PRINT2( IDS_SCHECK_QUOTA_REBUILD_ERROR, err, GetJetErrString( err ) );
				break;
			}
		}

	CloseJet();
	}

VOID
SCheckGetRecord(
    IN BOOL fVerbose,
    IN DWORD Dnt
    )
{
    JET_ERR err;

    VerboseMode = fVerbose;

    if (OpenJet (NULL) == S_OK ) {
        err = OpenTable(FALSE, FALSE, NULL, NULL); // read only, don't count records

        if (err == 0) {

            //
            // Search for record
            //

            DisplayRecord(Dnt);
        }
    }
    CloseJet();

} // ScheckGetRecord



LPWSTR
GetDN(
    IN DB_STATE *dbState,
    IN TABLE_STATE *tableState,
    IN DWORD dnt,
    IN BOOL  fPrint )
/*++

Routine Description:

    Shells on DitGetDnFromDnt for convinience.
    Also conditionally print the DN
    Warning: currency is lost after this function

Arguments:

    dbState -- opened database
    tableState -- opened table
    dnt -- dnt of dn to retrieve & print
    fPrint -- basically a verbose flag (print to console)



Return Value:

    allocated dn buffer or NULL on error

remark:

    fPrint --
    In the future it'd be nice if we can change this
    to a real print as a resource string. Currently
    it'll get used only in debug mode cause we can't
    change resource strings in SP (the time this feature
    was added).

--*/
{
    // initial dn length guess, will be re-allocated if needed
#define MAX_DN_LEN_GUESS     1024

    DWORD cbBuffer;
    LPWSTR pBuffer;
    HRESULT result;

    //
    // Seek to DSA & print DN (for user)
    //

    cbBuffer = sizeof(WCHAR) * MAX_DN_LEN_GUESS;
    result = DitAlloc(&pBuffer, cbBuffer);
    if ( FAILED(result) ) {
        return NULL;
    }
    ZeroMemory(pBuffer, cbBuffer);

    result = DitGetDnFromDnt(dbState,
                             tableState,
                             dnt,
                             &pBuffer,
                             &cbBuffer);
    if ( FAILED(result) ) {
        XERROR1("Error: failed to get dn of dnt %d\n", dnt);
        DitFree(pBuffer);
        pBuffer = NULL;
    }
    else if ( fPrint ) {
         XDBG1("DN: %S\n",
               (pBuffer ? pBuffer : L"<null>") );
    }
    return pBuffer;
}

HRESULT
FixMangledNC(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD CrossRefDnt,
    IN DWORD MangledDnt,
    IN LPWSTR pRdn )
/*++

Routine Description:

Dispatch depending on the type of mangling

I think that you reproduced one of the other ncname conflicted name scenarios.
There are atleast three. Someone ought to write this up.  
1. ncName has CNF
name.  
2. ncName has DEL name and guid in the name matches the current guid of
the current partition root in the forest. There only was once instance of the
partition in the forest ever.
3. ncName has DEL name, and guid in the name is
the guid of an old partition root. The guid does not match the guid of the
current partition root held elsewhere in the forest.

Arguments:

    DbState -- opened database
    TableState -- opened table
    MangledDnt -- bad NC we wish to recover
    pRdn -- the rdn of this bad NC.

Return Value:

    HRESULT error space

--*/
{
    HRESULT result = S_OK;
    BOOL fDeleteMangled = FALSE, fConflictMangled = FALSE;

    fDeleteMangled = (NULL != wcsstr(pRdn, pszDeletedNameTag));
    fConflictMangled = (NULL != wcsstr(pRdn, pszConflictNameTag));

    ASSERT( fDeleteMangled || fConflictMangled );
    if (fConflictMangled) {
/*
This is scenario #1: a cross ref with a ncname attribute referring to a CNF mangled
phantom.
This is likely series of steps which lead to this condition:
Promote a domain.  Domain is instantiated on GC. Demote domain. Cross ref
deletion replicates to GC. KCC starts domain tear down, but it takes a
while. Meanwhile, new instance of domain with same name is promoted. Cross ref
for new instance of domain replicates in to GC. Ncname on crossref conflicts
with name of partition root of old domain which is still in the process of
being removed.
*/
        result = FixConfNCByRenameWithStructColl( DbState, TableState, CrossRefDnt, MangledDnt, pRdn );
    } else if (fDeleteMangled) {
        result = FixDELMangledNC( DbState, TableState, CrossRefDnt, MangledDnt, pRdn );
    }

    return result;
}

HRESULT
FixConfNCByRenameWithStructColl(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD CrossRefDnt,
    IN DWORD MangledDnt,
    IN LPWSTR pRdn )
/*++

Routine Description:

    Rename and unmangle a conflicted phantom, dealing with the possibility of a structural
    collision.

    Attempt to fix conflicted NC name:
    a) remove conflict. If the name exist, see if it is a phantom. If so
    b) move phantom's kids to conflicted name
    c) mangle phantom name
    d) recover name (unmangle).

    (actually doesn't have to be NC, but this is how it is used today,
    if you re-use, you must re-evaluate this function)


Arguments:

    DbState -- opened database
    TableState -- opened table
    MangledDnt -- bad NC we wish to recover
    pRdn -- the rdn of this bad NC.

Return Value:

    HRESULT error space

--*/
{
    HRESULT result = S_OK;
    JET_ERR jErr;
    LPWSTR pch;
    DWORD cLen;     // watch usaged below
    LPWSTR pBuffer = NULL;
    DWORD  cbBuffer = 0;
    DWORD  pdnt, dnt, dntUnMangled;
    DWORD iKids = 0;
    GUID MangledGuid, UnMangledGuid;
    LPWSTR pDn, pMangledDn;
    BYTE bVal = 0;
    BOOL fDeleted = 0;
    BOOL fInTransaction = FALSE;
    BOOL fRenameSuccessful = FALSE;
    DSTIME DelTime;

    XERROR1("Fixing conflict mangled name: %ws\n", pRdn );
    XERROR("Fixing by rename with structural collision.\n" );

    //
    // - fix string name (get rid of mangle)
    //

    pch = wcsrchr(pRdn, BAD_NAME_CHAR);
    if ( !pch ) {
        return E_UNEXPECTED;
    }

    *pch = '\0';
    cLen = wcslen(pRdn);        // don't overwrite. re-used below.

    XDBG2(" DBG: new RDN = %S; cLen = %d\n",
                            pRdn, cLen);

    __try {

        //
        // Start Jet transaction
        //
        jErr = JetBeginTransaction(DbState->sessionId);
        if ( jErr != JET_errSuccess ) {
            //"Could not start a new transaction: %ws.\n"
            RESOURCE_PRINT1 (IDS_JETBEGINTRANS_ERR, GetJetErrString(jErr));
            result = E_UNEXPECTED;
            goto CleanUp;
        }
        fInTransaction = TRUE;

        // Position on record
        result = DitSeekToDnt(
                        DbState,
                        TableState,
                        MangledDnt);
        if ( FAILED(result) ) {
            XERROR1("Error: failed to seek to MangledDnt %d\n",
                                    MangledDnt );
            goto CleanUp;
        }

        //
        // Set column rdn (excluding terminating \0)
        //
        result = DitSetColumnByName(
                        DbState,
                        TableState,
                        SZRDNATT,
                        pRdn,
                        cLen*sizeof(WCHAR),
                        FALSE );
        if ( SUCCEEDED(result) ) {
            //
            // Tell user we fixed his domain
            //
            XERROR1("Successfully converted mangled Naming Context %S\n", pRdn);
            fRenameSuccessful = TRUE;
            goto CleanUp;
        }

        //
        // UnMangle failed.
        // Most common reason would be due to existing object
        // (we'd lost the jet error code here)
        // -->
        //  a) seek to object w/ good name
        //  b) See if it's a phantom, thus we can take over
        //  c) move it's children to currently mangled object
        //  d) mangle other object's name
        //  e) unmangle this object
        //
        XERROR2("Error<%x>: failed to fix mangled dn %S. Retrying.\n",
              result, pRdn);

        pDn = GetDN(DbState, TableState, MangledDnt, TRUE);
        // Warning: currency now lost
        if (!pDn) {
            XERROR("Error: failed to get mangled DN\n");
            result = E_UNEXPECTED;
            goto CleanUp;
        }
        cbBuffer = wcslen(pDn);
        result = DitAlloc(&pMangledDn, (cbBuffer+1) * sizeof(WCHAR));
        if ( FAILED(result) ) {
            XERROR("Error: failed to allocate memory for mangled DN\n");
            goto CleanUp;
        }
        wcscpy(pMangledDn, pDn);

        // verify that our mangled object is a good one
        // (has a guid)
        // Get the guid now, and act on it later

        // Position on record, since currency lost above
        result = DitSeekToDnt(
                        DbState,
                        TableState,
                        MangledDnt);
        if ( FAILED(result) ) {
            XERROR1("Error: failed to seek to MangledDnt %d\n",
                                    MangledDnt );
            goto CleanUp;
        }

        ZeroMemory( &MangledGuid, sizeof( GUID ) );
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZGUID,
                    &MangledGuid,
                    sizeof(MangledGuid),
                    NULL);


        //
        // Now unmangle & seek to what we hope is a phantom
        //
        result = UnmangleDn(pDn);
        if ( FAILED(result) ) {
            // unexpected. syntactic unmangling should work.
            XERROR1(" [DBG] Can't unmangle name %S\n", pDn);
            goto CleanUp;
        }

        result = DitSeekToDn(
                    DbState,
                    TableState,
                    pDn);
        if ( FAILED(result) ) {
            XERROR2("Error <%x>: can't seek to %S\n", result, pDn);
            goto CleanUp;
        }

        // get its dnt
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZDNT,
                    &dntUnMangled,
                    sizeof(dntUnMangled),
                    NULL);
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to get good named dnt\n", result);
            goto CleanUp;
        }

        // Choose our action on whether the mangled phantom has a guid.
        // a. If it has a guid, we are going to rename it.
        // b. If it does not have a guid, and there exists an other object with
        //    the unmangled name that does have a guid, change our source to
        //    point to that object instead.


        if ( fNullUuid(&MangledGuid)) {
            // This is scenario #5.
            // We have found a ncname with a conflicted phantom without a guid.
            // There exists another object with the unconflicted name and a guid.
            // Reset the ncname to point to the other object.
            XERROR1("The phantom %S lacks a guid.\n", pMangledDn );

            result = ReParentChildren(
                DbState,
                TableState,
                MangledDnt,
                dntUnMangled);
            if ( FAILED(result)) {
                XERROR1("Error <%x>: Failed to reparent object\n", result);
                goto CleanUp;
            }

            // Our initial position doesn't matter for this routine
            result = FixConfNCByResetNcName(
                DbState, TableState,
                CrossRefDnt, MangledDnt, dntUnMangled,
                pRdn, cLen );

            // Error, if any, has already been logged
            goto CleanUp;
        }

        // is it a phantom?
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZOBJ,
                    &bVal,
                    sizeof(bVal),
                    NULL);
        if ( FAILED(result)  || bVal) {
            // phantom's have the object byte set to 0.
            XERROR("\n***Manual intervention required***\n");
            XERROR2("Error <%x>: non mangled name isn't a phantom (%d)\n",
                    result, bVal);
            XERROR1(
"There is an object holding the non managled name %S.\n"
"The object must be removed or renamed before the mangled name may be corrected.\n",
pDn );
            result = E_FAIL;
            goto CleanUp;
        }

        // Is it a reference (ie guid-ed) phantom? We can't touch those
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZGUID,
                    &UnMangledGuid,
                    sizeof(UnMangledGuid),
                    NULL);
        if ( SUCCEEDED(result)  && !fNullUuid(&UnMangledGuid)) {

            XERROR("\n***Manual intervention required***\n");
            XERROR1("Error <%x>: non mangled name has guid\n", result);
            XERROR1("The phantom currently using name %S has a guid.\n", pDn );
            XERROR(
"Remove all references to this phantom.\n"
"If you believe that the phantom has the wrong guid, try authoritative\n"
"restore of a good copy of the object that contains the phantom.\n"
"Allow garbage collection to run so that this phantom is removed.\n");
            if (SUCCEEDED(result)){
                RPC_STATUS rpcErr;
                LPWSTR pszGuid = NULL;

                // convert guid to string form
                rpcErr = UuidToStringW(&UnMangledGuid, &pszGuid);
                if (RPC_S_OK == rpcErr ) {
                    XERROR1( "The guid of the phantom holding the non-mangled name is %ws.\n",
                             pszGuid );
                }

                if (pszGuid) {
                    RpcStringFreeW(&pszGuid);
                }
                result = E_FAIL;
            }
            goto CleanUp;
        }


        // Cool, it is a phantom, we can fix it up.

        XDBG4("Ready to reparent\n\tfrom %S (%d)\n\tto %S (%d).\n",
                pDn, dntUnMangled, pMangledDn, MangledDnt);

        //
        // move non-mangled children to mangled parent
        //

        result = ReParentChildren(
                    DbState,
                    TableState,
                    MangledDnt,
                    dntUnMangled);
        if ( FAILED(result)) {
            XERROR1("Error <%x>: Failed to reparent object\n", result);
            goto CleanUp;
        }

        //
        // Mangle phantom (non-mangled, non-guided) object
        //

        result = DitSeekToDnt(
                        DbState,
                        TableState,
                        dntUnMangled);
        if ( FAILED(result) ) {
            XERROR1("Error: failed to seek to MangledDnt %d\n",
                                    MangledDnt );
            goto CleanUp;
        }

        // we must create the guid here since we assume above
        // that the non-mangled object doesn't have a guid.
        result = UuidCreate(&UnMangledGuid);
        if ( RPC_S_OK != result ) {
            XERROR1("Error <%x>: Failed to create Uuid\n", result);
            result = E_UNEXPECTED;
            goto CleanUp;
        }

        pBuffer = MangleRdn(
                    pRdn,
                    L"CNF",
                    UnMangledGuid);

		if ( NULL == pBuffer ) {
        	XERROR("Error: failed to mangle RDN.\n" );
	        goto CleanUp;
			}
	
        cbBuffer = wcslen(pBuffer);

    #if CNF_NC_DBG
        if ( !IsRdnMangled(pBuffer,cbBuffer,&UnMangledGuid) ) {
            // sanity
            XERROR2("Error: Failed to mangle dn %S. Mangle = %S\n",
                        pDn, pBuffer);
            result = E_UNEXPECTED;
            goto CleanUp;
        }
        else {
            XDBG1(" DBG: verified mangled rdn <<%S>>\n", pBuffer);
        }
    #endif

        result = DitSeekToDnt(
                        DbState,
                        TableState,
                        dntUnMangled);
        if ( FAILED(result) ) {
            XERROR2("Error <0x%X>: failed to seek to dntUnMangled %d\n",
                                    result, dntUnMangled );
            goto CleanUp;
        }

        //
        // Set column rdn (excluding terminating \0)
        //
        result = DitSetColumnByName(
                        DbState,
                        TableState,
                        SZRDNATT,
                        pBuffer,
                        cbBuffer*sizeof(WCHAR),
                        FALSE );
        if ( FAILED(result) ) {
            XERROR2("Error <0x%x>: Failed to mangle phantom %S\n",
                                result, pBuffer);
            goto CleanUp;
        }



        XERROR1("Successfully converted Mangled phantom <<%S>>\n", pBuffer);


        //
        // Retry unmangling the cnf object again for the last
        // time.
        //
        // first seek back again to our object
        result = DitSeekToDnt(
                        DbState,
                        TableState,
                        MangledDnt);
        if ( FAILED(result) ) {
            XERROR1("Error: failed to seek to MangledDnt %d\n",
                                    MangledDnt );
            goto CleanUp;
        }

        //
        // Set column rdn (excluding terminating \0)
        //
        result = DitSetColumnByName(
                        DbState,
                        TableState,
                        SZRDNATT,
                        pRdn,
                        cLen*sizeof(WCHAR),
                        FALSE );
        if ( SUCCEEDED(result) ) {
            //
            // Tell user we fixed his domain
            //
            XERROR1("Successfully recovered mangled Naming Context %S\n", pRdn);
            fRenameSuccessful = TRUE;
        }
        else {
            XERROR2("Error <0x%x>: Failed to Unmangle conflicted name %S\n",
                                result, pRdn);
        }

CleanUp:;
    }
    __finally {

        if ( pBuffer ) {
            DitFree(pBuffer);
        }

        if ( fInTransaction ) {
            //
            // Jet transaction mgmt
            //
            if ( SUCCEEDED(result) ) {
                XDBG(" DBG: Commiting transaction\n");
                jErr = JetCommitTransaction(DbState->sessionId, 0);
                if ( jErr != JET_errSuccess ) {
                    //"Failed to commit transaction: %ws.\n"
                    RESOURCE_PRINT1(IDS_JETCOMMITTRANSACTION_ERR, GetJetErrString(jErr));
                    if ( SUCCEEDED(result) ) {
                        result = E_UNEXPECTED;
                    }
                }
            }
            else {
                // failed fixup-- rollback
                XERROR1(" DBG: Rolling back transaction due to error %x.\n", result);
                jErr = JetRollback(DbState->sessionId, JET_bitRollbackAll);
                if ( jErr != JET_errSuccess ) {
                    //"Failed to rollback transaction: %ws.\n"
                    RESOURCE_PRINT1(IDS_JETROLLBACK_ERR, GetJetErrString(jErr));
                    if ( SUCCEEDED(result) ) {
                        result = E_UNEXPECTED;
                    }
                }
            }
        }

    }   // finally

    return result;
}

HRESULT
FixDELMangledNC(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD CrossRefDnt,
    IN DWORD MangledDnt,
    IN LPWSTR pRdn )
/*++

Routine Description:

Dispatch on type of DEL mangled name

2. ncName has DEL name and guid in the name matches the current guid of
the current partition root in the forest. There only was once instance of the
partition in the forest ever.

3. ncName has DEL name, and guid in the name is
the guid of an old partition root. The guid does not match the guid of the
current partition root held elsewhere in the forest.

Arguments:

    DbState -- opened database
    TableState -- opened table
    MangledDnt -- bad NC we wish to recover
    pRdn -- the rdn of this bad NC.

Return Value:

    HRESULT error space

--*/
{
    HRESULT result = S_OK;
    JET_ERR jErr;
    LPWSTR pch;
    DWORD cLen;     // watch usaged below
    LPWSTR pBuffer = NULL;
    LPWSTR pDn;
    BOOL fInTransaction = FALSE;
    DWORD UnmangledDnt;

    XERROR1("Fixing DEL mangled name: %ws\n", pRdn );
    //
    // - fix string name (get rid of mangle)
    //

    pch = wcsrchr(pRdn, BAD_NAME_CHAR);
    if ( !pch ) {
        return E_UNEXPECTED;
    }

    *pch = '\0';
    cLen = wcslen(pRdn);        // don't overwrite. re-used below.

    XDBG2(" DBG: new RDN = %S; cLen = %d\n",
                            pRdn, cLen);


    __try {

        //
        // Start Jet transaction
        //
        jErr = JetBeginTransaction(DbState->sessionId);
        if ( jErr != JET_errSuccess ) {
            //"Could not start a new transaction: %ws.\n"
            RESOURCE_PRINT1 (IDS_JETBEGINTRANS_ERR, GetJetErrString(jErr));
            result = E_UNEXPECTED;
            goto CleanUp;
        }
        fInTransaction = TRUE;

        // Determine what kind of DEL mangling we have
        // We can tell what to do, depending on whether there exists a record using
        // the unmangled name.  We try to rename the mangled record. If it fails, we
        // know there exists another record holding the name.  We use this method to
        // determine the existence of the unmangled name because seeking to a dn
        // which doesn't exist displays an ugly message.

        //
        // Set column rdn (excluding terminating \0)
        //

        result = DitSetColumnByName(
                        DbState,
                        TableState,
                        SZRDNATT,
                        pRdn,
                        cLen*sizeof(WCHAR),
                        FALSE );

        if ( SUCCEEDED(result) ) {

            // No unmangled name exists, and we have succeeded in renaming

            XERROR1( " Successfully renamed mangled Rdn to %ws\n", pRdn );

            // Now finish the job
            // We remain positioned on the mangled, now corrected object

/*
This is scenario #2: Fix type 2 DEL mangling

These are the conditions that lead to this situation:
Domain is promoted into forest. GC holds domain. All
holders of writeably copy of domain are powered off. Domain is removed from
forest using ntdsutil metadata cleanup. Writeable domain holder is turned
on. Domain cross ref is reanimated. Also detected by cross ref metadata of
isDeleted attribute showing even version number.  Reanimated cross ref
replicates into GC, and ncname points to partition root of domain that has
already been torn down.
*/
            result = FixConfNCUndelete( DbState, TableState, CrossRefDnt, MangledDnt,
                                       pRdn, cLen );

            goto CleanUp;
        }

        // Type 3 - a record with the unmangled name exists

        pDn = GetDN(DbState, TableState, MangledDnt, TRUE);
        // Warning: currency is lost after this function
        if (!pDn) {
            XERROR("Error: failed to get mangled DN\n");
            result = E_UNEXPECTED;
            goto CleanUp;
        }

        //
        // Now unmangle & seek
        //
        result = UnmangleDn(pDn);
        if ( FAILED(result) ) {
            // unexpected. syntactic unmangling should work.
            XERROR1(" [DBG] Can't unmangle name %S\n", pDn);
            goto CleanUp;
        }

        result = DitSeekToDn(
                    DbState,
                    TableState,
                    pDn);
        if ( FAILED(result) ) {
            XERROR1("Error: failed to seek to unmangled Dn %ws\n", pDn );
            goto CleanUp;
        }

        result = DitGetColumnByName(
            DbState,
            TableState,
            SZDNT,
            &UnmangledDnt,
            sizeof(UnmangledDnt),
            NULL);
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to get unmangled DNT \n", result);
            goto CleanUp;
        }

        // Reset index
        result = DitSetIndex(DbState, TableState, SZDNTINDEX, FALSE);
        if ( FAILED(result) ) {
            goto CleanUp;
        }
/*
This is scenario #3. Fix type 3 DEL mangling.

Only occurs with domains which are their own tree
root. Domain is promoted into forest. GC holds domain.  Domain is demoted from
forest. Deletion of cross ref replicates into GC. KCC begins tear down of
domain. New domain is promoted with same name. Remember must be named in own
tree. New cross ref replicates in. ncname in this cross ref DOES NOT HAVE A
GUID YET. This is timing related as well so you may not hit it every
time. Ncname unifies (attaches) to wrong object, namely the partition root of
the old domain in the process of removal. KCC finishes removal of domain. New
cross ref now has ncname that has a reference to the deleted partition
root. By the guid you can tell that it is referring to the wrong partition.
Note that another scenario is likely. If the new cross ref attaches to the old
partition root, the next time the KCC runs, it could falsely conclude that the
domain is supposed to be present again (because the cross ref is there naming
the nc) and stop the removal. You could be left with a live cross ref to half
deleted nc.
*/

        // Our initial position doesn't matter for this routine

        result = FixConfNCByResetNcName(
            DbState, TableState,
            CrossRefDnt, MangledDnt, UnmangledDnt,
            pRdn, cLen );

CleanUp:;
    }
    __finally {

        if ( fInTransaction ) {
            //
            // Jet transaction mgmt
            //
            if ( SUCCEEDED(result) ) {
                XDBG(" DBG: Commiting transaction\n");
                jErr = JetCommitTransaction(DbState->sessionId, 0);
                if ( jErr != JET_errSuccess ) {
                    //"Failed to commit transaction: %ws.\n"
                    RESOURCE_PRINT1(IDS_JETCOMMITTRANSACTION_ERR, GetJetErrString(jErr));
                    if ( SUCCEEDED(result) ) {
                        result = E_UNEXPECTED;
                    }
                }
            }
            else {
                // failed fixup-- rollback
                XERROR1(" DBG: Rolling back transaction due to error %x.\n", result);
                jErr = JetRollback(DbState->sessionId, JET_bitRollbackAll);
                if ( jErr != JET_errSuccess ) {
                    //"Failed to rollback transaction: %ws.\n"
                    RESOURCE_PRINT1(IDS_JETROLLBACK_ERR, GetJetErrString(jErr));
                    if ( SUCCEEDED(result) ) {
                        result = E_UNEXPECTED;
                    }
                }
            }
        }

    }   // finally

    return result;
}

HRESULT
FixConfNCUndelete(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD CrossRefDnt,
    IN DWORD MangledDnt,
    IN LPWSTR pRdn,
    IN DWORD cLen
    )
/*++

Routine Description:

Undelete the object. Clear its deleted status.

Already in a transaction.
Positioned on mangled dnt
Good rdn is passed into us.

Arguments:

    DbState -- opened database
    TableState -- opened table
    MangledDnt -- bad NC we wish to recover
    pRdn -- good rdn
    cLen -- length of good rdn in characters

Return Value:

    HRESULT error space

--*/
{
    HRESULT result = S_OK;
    JET_ERR jErr;
    BYTE bVal = 0;
    BOOL fDeleted = 0;
    DSTIME DelTime;

    XERROR( "Found object that needs to be undeleted.\n" );

    __try {
        // Check if record is a phantom
        result = DitGetColumnByName(
            DbState,
            TableState,
            SZOBJ,
            &bVal,
            sizeof(bVal),
            NULL);
        if ( FAILED(result) || (!bVal)) {
            XDBG(" DBG: Delete mangled phantom requires no further processing.\n");
            // Note that phantoms normally have a DelTime and we shouldn't remove it
            // Phantom's don't require any further processing
            result = S_OK;
            goto CleanUp;
        }

        // The object is a SUBREF tombstone (see DelAutoSubRef)
        // Make it a non-tombstone SUBREF

        // Check if record is marked deleted
        result = DitGetColumnByName(
            DbState,
            TableState,
            SZISDELETED,
            &fDeleted,
            sizeof(fDeleted),
            NULL);
        if ( SUCCEEDED(result) && fDeleted) {
            // Deleted flag present and true
            fDeleted = FALSE;
            result = DitSetColumnByName(
                DbState,
                TableState,
                SZISDELETED,
                &fDeleted, // must be non-null
                0, // means delete column sizeof(fDeleted)
                FALSE );
            if ( FAILED(result) ) {
                XERROR1("Error <%x>: failed to clear is deleted\n", result);
                goto CleanUp;
            }
            // Check if record has deltime
            result = DitGetColumnByName(
                DbState,
                TableState,
                SZDELTIME,
                &DelTime,
                sizeof(DelTime),
                NULL);
            if ( SUCCEEDED(result) && DelTime) {
                // Deletion time is present and non-zero
                DelTime = 0;
                result = DitSetColumnByName(
                    DbState,
                    TableState,
                    SZDELTIME,
                    &DelTime, // must be non-null
                    0,    // means delete column sizeof(DelTime)
                    FALSE );
                if ( FAILED(result) ) {
                    XERROR1("Error <%x>: failed to clear deletion time\n", result);
                    goto CleanUp;
                }
            }
            XERROR1("Successfully cleared deletion status for Naming Context %S\n", pRdn);
        }
CleanUp:;
    }
    __finally {

        NOTHING;

    }   // finally

    return result;
}

HRESULT
FixConfNCByResetNcName(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD CrossRefDnt,
    IN DWORD MangledDnt,
    IN DWORD UnmangledDnt,
    IN LPWSTR pRdn,
    IN DWORD cLen
    )
/*++

Routine Description:

Given a cross ref with an ncname attribute pointing to a mangled phantom,
reset the ncname attribute to point to the unmangled phantom. Adjust
ref counts appropriately.

Already in a transaction.
Initial position not assumed.
Good rdn is passed into us.

Arguments:

    DbState -- opened database
    TableState -- opened table
    MangledDnt -- bad NC we wish to recover
    pRdn -- good rdn
    cLen -- length of good rdn in characters

Return Value:

    HRESULT error space

--*/
{
    HRESULT result = S_OK;
    DWORD ncNameDnt;
    DWORD dwRefCount;
    GUID UnmangledGuid;
    RPC_STATUS rpcErr;
    LPWSTR pszGuid = NULL;

    XERROR( "Fix cross ref by resetting ncname attribute.\n" );
    XDBG3( " DBG: CR DNT = %d, Mangled DNT = %d, Unmangled DNT = %d\n",
           CrossRefDnt, MangledDnt, UnmangledDnt );

    // ******************************************************************************
    // CrossRefDnt has a reference on mangledDnt
    result = DitSeekToDnt(
        DbState,
        TableState,
        CrossRefDnt);
    if ( FAILED(result) ) {
        XERROR1("Error: failed to seek to CrossRefDnt %d\n",
                MangledDnt );
        goto CleanUp;
    }

    result = DitGetColumnByName(
        DbState,
        TableState,
        SZNCNAME,
        &ncNameDnt,
        sizeof(ncNameDnt),
        NULL);
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to get NCNAME\n", result);
        goto CleanUp;
    }

    if (ncNameDnt != MangledDnt) {
        XERROR( "Cross reference NCNAME did not have expected contents.\n" );
        result = E_UNEXPECTED;
        goto CleanUp;
    }

    // ******************************************************************************
    // Decrement that reference
    XDBG(" DBG: Seeking to old mangled dnt\n");
    result = DitSeekToDnt(
                DbState,
                TableState,
                MangledDnt);
    if ( FAILED(result) ) {
        XERROR2("Error <%x>: can't seek to old mangled dnt %d\n", result, MangledDnt);
        goto CleanUp;
    }

    XDBG(" DBG: Getting old mangled dnt refCount\n");
    dwRefCount = 0;
    // get old ref count
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZCNT,
                &dwRefCount,
                sizeof(dwRefCount),
                NULL);
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to get old mangled dnt refcount\n", result);
        goto CleanUp;
    }

    XDBG2(" DBG: Old mangled dnt (%d) refCount = %d\n",
                    MangledDnt, dwRefCount);

    if (dwRefCount < 1) {
        XERROR( "Old mangled dnt has unexpected refcount.\n" );
        result = E_UNEXPECTED;
        goto CleanUp;
    }

    // decrement due to move
    dwRefCount--;

    XDBG1(" DBG: Setting old mangled dnt refCount to %d\n", dwRefCount);
    //
    // Set refcount
    //
    result = DitSetColumnByName(
                DbState,
                TableState,
                SZCNT,
                &dwRefCount,
                sizeof(dwRefCount),
                FALSE );
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to set old mangled refCount\n", result);
        goto CleanUp;
    }

    // ******************************************************************************
    // Make CrossRefDnt reference UnmangledDnt
    result = DitSeekToDnt(
        DbState,
        TableState,
        CrossRefDnt);
    if ( FAILED(result) ) {
        XERROR1("Error: failed to seek to CrossRefDnt %d\n",
                MangledDnt );
        goto CleanUp;
    }

    result = DitSetColumnByName(
        DbState,
        TableState,
        SZNCNAME,
        &UnmangledDnt,
        sizeof(UnmangledDnt),
        FALSE);
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to set NCNAME\n", result);
        goto CleanUp;
    }

    // ******************************************************************************
    // Increment that reference

    XDBG(" DBG: Seeking to new unmangled dnt\n");
    result = DitSeekToDnt(
                DbState,
                TableState,
                UnmangledDnt);
    if ( FAILED(result) ) {
        XERROR2("Error <%x>: can't seek to new unmangled %d\n", result, UnmangledDnt);
        goto CleanUp;
    }

    XDBG(" DBG: Getting new unmangled dnt refCount\n");
    dwRefCount = 0;
    // get old ref count
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZCNT,
                &dwRefCount,
                sizeof(dwRefCount),
                NULL);
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to get new unmangled dnt refcount\n", result);
        goto CleanUp;
    }

    XDBG2(" DBG: New unmangled dnt (%d) refCount = %d\n",
                    UnmangledDnt, dwRefCount);

    // Increment due to move
    dwRefCount++;

    XDBG1(" DBG: Setting new unmangled dnt refCount to %d\n", dwRefCount);
    //
    // Set refcount
    //
    result = DitSetColumnByName(
                DbState,
                TableState,
                SZCNT,
                &dwRefCount,
                sizeof(dwRefCount),
                FALSE );
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to set new unmangled refCount \n", result);
        goto CleanUp;
    }

    // ******************************************************************************
    // Check the guid of the new reference
    result = DitGetColumnByName(
        DbState,
        TableState,
        SZGUID,
        &UnmangledGuid,
        sizeof(UnmangledGuid),
        NULL);
    if ( FAILED(result)  || fNullUuid(&UnmangledGuid)) {
        XERROR1("Error <%x>: Invalid Guid for unmangled name\n", result);
        if (SUCCEEDED(result)) result = E_FAIL;
        goto CleanUp;
    }

    // convert guid to string form
    rpcErr = UuidToStringW(&UnmangledGuid, &pszGuid);
    if (RPC_S_OK != rpcErr ) {
        XERROR("Error: Failed to convert UuidToString\n");
        goto CleanUp;
    }
    XERROR1( "The cross ref NCNAME will now refer to NC with guid %ws.\n",
             pszGuid );

    XERROR3( "Successfully adjusted NCNAME on cross ref (DNT %d) from DNT %d to DNT %d.\n",
             CrossRefDnt, MangledDnt, UnmangledDnt );

 CleanUp:

    if (pszGuid) {
        RpcStringFreeW(&pszGuid);
    }

    return result;
}


HRESULT
ReParentConflict(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD dntKid,
    IN DWORD dntNew,
    IN DWORD dntOld
    )

/*++

Routine Description:

    Handle a conflict during reparenting. dntKid is being reparented to dntNew. The problem
    is that there exists an object X under dntNew that has the same rdn as dntKid.  The
    algorithm is as follows:
    - determine the dnt of object x
    - see if dntKid has a guid
    - see if object x has a guid
    - if both have a guid, error
    - conflict mangle the object that doesn't have a guid
    - reparent all children of the object that doesn't have a guid to the one that does

    Return with the expectation that dntKid will be reparented again, this time successfully.

    Assumptions before and after:
        Currency is set to dntKid
        Index is SZDNTINDEX
    

Arguments:

    DbState - 
    TableState - 
    dntKid - child object being reparented
    dntNew - new parent dnt

Return Value:

    HRESULT - 

--*/

{
    HRESULT result = S_OK;
    DWORD  cbRdn = 0;
    WCHAR szRDN[MAX_RDN_SIZE + 1];
    ATTRTYP currentRdnType;
    INT cch, cchMangled;
    GUID guidKid, guidConflictKid;
    BOOL fKidHasGuid = FALSE, fConflictKidHasGuid = FALSE;
    DWORD dntConflictKid = INVALIDDNT;
    DWORD dntLoser, dntWinner;
    GUID *pGuidLoser;
    LPWSTR pBuffer = NULL;

    XDBG2( "DBG: Handle reparent conflict of dnt %d to new parent %d\n", dntKid, dntNew );

    // determine the dnt of object x
    // Get the RDN of the child
    result = DitGetColumnByName(
        DbState,
        TableState,
        SZRDNATT,
        szRDN,
        sizeof(szRDN),
        &cbRdn);
    if ( FAILED(result) ) {
        XERROR1( "Error <%x>: failed to get RDN\n", result);
        goto CleanUp;
    }

    // Null terminate the rdn
    cch = cbRdn/2;
    ASSERT(cch < MAX_RDN_SIZE);
    szRDN[cch] = '\0';

    XDBG1( "DBG: child rdn is '%ws'\n", szRDN );

    // Get the rdntype of the child
    result = DitGetColumnByName(DbState,
                                TableState,
                                SZRDNTYP,
                                &currentRdnType,
                                sizeof(currentRdnType),
                                NULL);
    if ( FAILED(result) || (result == S_FALSE) ) {
        XERROR1( "Error <%x>: failed to get RDNTYPE\n", result);
        goto CleanUp;
    }

    XDBG1( "DBG: child rdntype is %d\n", currentRdnType );

    // Get the guid of the child, or make one if necessary
    result = DitGetColumnByName(
        DbState,
        TableState,
        SZGUID,
        &guidKid,
        sizeof(guidKid),
        NULL);
    if ( FAILED(result)  || fNullUuid(&guidKid)) {
        // we must create the guid here since we assume above
        // that the non-mangled object doesn't have a guid.
        result = UuidCreate(&guidKid);
        if ( RPC_S_OK != result ) {
            XERROR1("Error <%x>: Failed to create Uuid\n", result);
            result = E_UNEXPECTED;
            goto CleanUp;
        }
    } else {
        fKidHasGuid = TRUE;
    }

    // seek to object we are conflicting with

    result = DitSetIndex(DbState, TableState, SZPDNTINDEX, FALSE);
    if ( FAILED(result) ) {
        XERROR1( "Error <%x>: failed to set index to SZPDNTINDEX\n", result);
        goto CleanUp;
    }

    result = DitSeekToChild(DbState,
                            TableState,
                            dntNew,
                            currentRdnType,
                            szRDN);
    if ( FAILED(result) || ( result == S_FALSE ) ) {
        // There must have been some other reason, other than conflict, that the
        // attempted reparenting failed.
        XERROR3( "Error <%x>: failed to seek to conflicting child with parent %d and rdn '%ws'\n",
                 result, dntNew, szRDN);
        goto CleanUp;
    }

    // get its dnt
    result = DitGetColumnByName(
        DbState,
        TableState,
        SZDNT,
        &dntConflictKid,
        sizeof(dntConflictKid),
        NULL);
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to confict child dnt\n", result);
        goto CleanUp;
    }

    XDBG1( "DBG: conflict child dnt is %d\n", dntConflictKid );

    // Get the guid of the conflict child, or make one if necessary
    result = DitGetColumnByName(
        DbState,
        TableState,
        SZGUID,
        &guidConflictKid,
        sizeof(guidConflictKid),
        NULL);
    if ( FAILED(result)  || fNullUuid(&guidConflictKid)) {
        // we must create the guid here since we assume above
        // that the non-mangled object doesn't have a guid.
        result = UuidCreate(&guidConflictKid);
        if ( RPC_S_OK != result ) {
            XERROR1("Error <%x>: Failed to create Uuid\n", result);
            result = E_UNEXPECTED;
            goto CleanUp;
        }
    } else {
        fConflictKidHasGuid = TRUE;
    }

    // if both have a guid, error
    if (fKidHasGuid && fConflictKidHasGuid) {
        XERROR("Both child and conflict-child have guids. Cannot rename.\n" );
        XERROR("Manual intervention required.\n" );
        XERROR3( "Rename one of the instances of '%ws' under either parent dnts %d or %d.\n",
                 szRDN, dntNew, dntOld );
        result = E_UNEXPECTED;
        goto CleanUp;
    }

    // Decide who wins and who loses
    if (fKidHasGuid) {
        // Kid is the winner of the name
        dntLoser = dntConflictKid;
        dntWinner = dntKid;
        pGuidLoser = &guidConflictKid;
    } else {
        // Conflict Kid is the winner of the name
        dntLoser = dntKid;
        dntWinner = dntConflictKid;
        pGuidLoser = &guidKid;
    }

    // conflict mangle the object that doesn't have a guid
    pBuffer = MangleRdn(
        szRDN,
        L"CNF",
        *pGuidLoser);

	if ( NULL == pBuffer ) {
        XERROR("Error: failed to mangle RDN.\n" );
        goto CleanUp;
		}

    cchMangled = wcslen(pBuffer);

    XERROR3( "Winning parent dnt %d, Losing parent dnt %d, new name of losing rdn '%ws'\n",
             dntWinner, dntLoser, pBuffer );

    // Seek to the loser
    result = DitSetIndex(DbState, TableState, SZDNTINDEX, FALSE);
    if ( FAILED(result) ) {
        XERROR1( "Error <%x>: failed to set index to SZDNTINDEX\n", result);
        goto CleanUp;
    }

    result = DitSeekToDnt(
                DbState,
                TableState,
                dntLoser);
    if ( FAILED(result) ) {
        XERROR2("Error <%x>: can't seek to loser dnt %d\n", result, dntLoser);
        goto CleanUp;
    }

    //
    // Set column rdn (excluding terminating \0)
    //
    result = DitSetColumnByName(
        DbState,
        TableState,
        SZRDNATT,
        pBuffer,
        cchMangled*sizeof(WCHAR),
        FALSE );
    if ( FAILED(result) ) {
        XERROR2("Error <0x%x>: Failed to mangle child %S\n",
                result, pBuffer);
        goto CleanUp;
    }

    XERROR2("Note: record %d was renamed to avoid a conflict. New name: %ws\n",
            dntLoser, pBuffer );

    // reparent all children of the object that doesn't have a guid to the one that does
    // Note that this call is recursive.  However we expect there only to be 2 or 3 levels of
    // recursion worst case.  The most that we have ever seen in the field is 2 levels of
    // structural collision that need repair.

    result = ReParentChildren(
        DbState,
        TableState,
        dntLoser,
        dntWinner);
    if ( FAILED(result)) {
        XERROR3("Error <%x>: Failed to reparent children from %d to %d\n",
                dntLoser, dntWinner, result);
        goto CleanUp;
    }

    XERROR("This record should have no more references and will be garbage collected.\n" );

    // Leave currency on dntKid
    result = DitSeekToDnt(
                DbState,
                TableState,
                dntKid);
    if ( FAILED(result) ) {
        XERROR2("Error <%x>: can't seek to loser dnt %d\n", result, dntLoser);
        goto CleanUp;
    }

    // Success!!
    goto CleanUp;

CleanUp:

    if ( pBuffer ) {
        DitFree(pBuffer);
    }

    return result;

} /* ReParentConflict */

HRESULT
ReParent(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD dntKid,
    IN DWORD dntNew,
    IN DWORD dntOld
    )
/*++

Routine Description:

    Reparent a single kid from old parent to
    new parent. Reparenting consiste of:
      - Change kid's pdnt
      - Change kid's ancestors list
      - Decrement old parent's refcount
      - Increment new parent's refcount

    If a name conflict occurs during reparenting, mangle the child's name

Arguments:
    IN *DbState, -- opened database
    IN *TableState -- opened table
    IN dntKid --  current child to reparent
    IN dntNew -- new parent dnt
    IN dntOld -- old parent dnt

Return Value:

    Success: S_OK
    Error: HRESULT space

Remarks:
    This is called w/in inside a jet transaction.


--*/
{
    HRESULT result = S_OK;
    BOOL fStatus;
    DWORD pdnt;
    DWORD dwRefCount;
    DWORD dwActual, dwActual2;
    DWORD *pAnc = NULL;
    DWORD cAnc = 0;
    DWORD i;

    XDBG3(" > Reparenting kid %d from %d to %d\n",
                dntKid, dntOld, dntNew);

    result = DitSeekToDnt(
                DbState,
                TableState,
                dntKid);
    if ( FAILED(result) ) {
        XERROR2("Error <%x>: can't seek to %d\n", result, dntKid);
        goto CleanUp;
    }

    XDBG1(" DBG: Getting pdnt of %d\n", dntKid);

    // extra precaution. get pdnt & compare w/ expected
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZPDNT,
                &pdnt,
                sizeof(pdnt),
                NULL);
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to get partitions SZPDNT\n", result);
        goto CleanUp;
    }
    else if ( pdnt != dntOld ) {
        XERROR2("Error: expected old parent %d but found %d\n",
                        dntOld, pdnt);
        result = E_UNEXPECTED;
        goto CleanUp;
    }

    XDBG2(" DBG: Setting pdnt of %d to %d\n", dntKid, dntNew);
    XDBG1(" DBG: current pdnt is %d\n", pdnt);
    //
    // Set pdnt
    //
    result = DitSetColumnByName(
                DbState,
                TableState,
                SZPDNT,
                &dntNew,
                sizeof(dntNew),
                FALSE );
    if ( FAILED(result) ) {
        //
        // Assume there was a conflict. Try to correct the problem
        // Assumptions before and after:
        //    Currency is set to dntKid
        //    Index is SZDNTINDEX
        //
        XERROR3("Warning <%x>: child dnt %d, failed to set new parent dnt %d col SZPDNT - retrying\n", dntKid, dntNew, result);
        result = ReParentConflict( DbState, TableState, dntKid, dntNew, dntOld);
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to handle reparenting conflict\n", result);
            goto CleanUp;
        }

        //
        // Set pdnt again
        //
        result = DitSetColumnByName(
            DbState,
            TableState,
            SZPDNT,
            &dntNew,
            sizeof(dntNew),
            FALSE );
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to set new parent col SZPDNT\n", result);
            goto CleanUp;
        }
    }


    XDBG1(" DBG: Getting Ancestors of %d (size)\n", dntKid);
    // Replace ancestors:
    //  1. get ancestors of new parent
    //  2. allocate room for ancestor list + the to-be-child
    //     (we're reparenting now).
    //  3. read in new parent ancestor list
    //  4. concat current child dnt
    //  5. write to child
    //

    result = DitSeekToDnt(
                DbState,
                TableState,
                dntNew);
    if ( FAILED(result) ) {
        XERROR2("Error <%x>: can't seek to %d\n", result, dntNew);
        goto CleanUp;
    }

    // get size of ancestors blob
    dwActual = 0;
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZANCESTORS,
                &pAnc,
                0,
                &dwActual);
    if ( S_FALSE != result ) {
        XERROR1("Error <%x>: failed to get ancestors size\n", result);
        goto CleanUp;
    }

    XDBG1(" DBG: Allocating %d bytes for ancestor list\n", dwActual+sizeof(DWORD));

    // allocate for one more dnt
    result = DitAlloc(&pAnc, dwActual+sizeof(DWORD));
    if (FAILED(result)) {
        XERROR("Error: not enough memory in ReParent\n");
        goto CleanUp;
    }
    ZeroMemory(pAnc, dwActual+sizeof(DWORD));

    XDBG1(" DBG: Getting Ancestors\n", dwActual);
    // get ancestors
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZANCESTORS,
                &pAnc[0],
                dwActual,
                NULL);
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to get ancestors \n", result);
        goto CleanUp;
    }

    cAnc = dwActual/sizeof(DWORD);
    // concat dntKid to ancestor list & then write
    pAnc[cAnc] = dntKid;
    // now we can increment the dwActual for the write
    dwActual += sizeof(DWORD);
    XDBG(" DBG: Setting Ancestor list\n");

    //
    // seek to new kid & set Ancestors
    //
    result = DitSeekToDnt(
                DbState,
                TableState,
                dntKid);
    if ( FAILED(result) ) {
        XERROR2("Error <%x>: can't seek to %d\n", result, dntKid);
        goto CleanUp;
    }

    result = DitSetColumnByName(
                DbState,
                TableState,
                SZANCESTORS,
                pAnc,
                dwActual,
                FALSE );
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to set new ancestor list\n", result);
        goto CleanUp;
    }


#if CNF_NC_DBG
    XDBG(" DBG: Verifying Proper set of Ancestors\n");
    // get ancestors
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZANCESTORS,
                &pAnc[0],
                dwActual,
                NULL);
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to get ancestors \n", result);
        goto CleanUp;
    }

    cAnc = dwActual/sizeof(DWORD);
    //
    // Replace old parent w/ new parent
    //
    XDBG1("Ancestors list (%d):\n", cAnc);
    fStatus = FALSE;
    for (i=0; i<cAnc; i++) {
        XDBG2(" %d> %d\n", i, pAnc[i]);
    }
    XDBG("---\n");
#endif

    //
    // Fix ref of old parent (--)
    //

    XDBG(" DBG: Seeking to old parent\n");
    result = DitSeekToDnt(
                DbState,
                TableState,
                dntOld);
    if ( FAILED(result) ) {
        XERROR2("Error <%x>: can't seek to old folk %d\n", result, dntOld);
        goto CleanUp;
    }

    XDBG(" DBG: Getting old parent refCount\n");
    dwRefCount = 0;
    // get old ref count
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZCNT,
                &dwRefCount,
                sizeof(dwRefCount),
                NULL);
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to get old folk refcount\n", result);
        goto CleanUp;
    }

    XDBG2(" DBG: Old parent (%d) refCount = %d\n",
                    dntOld, dwRefCount);

    // decrement due to move
    dwRefCount--;

    XDBG1(" DBG: Setting old parent refCount to %d\n", dwRefCount);
    //
    // Set refcount
    //
    result = DitSetColumnByName(
                DbState,
                TableState,
                SZCNT,
                &dwRefCount,
                sizeof(dwRefCount),
                FALSE );
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to set old parent refCount \n", result);
        goto CleanUp;
    }


    //
    // Fix ref of new parent (++)
    //

    XDBG(" DBG: Seeking to new parent\n");
    result = DitSeekToDnt(
                DbState,
                TableState,
                dntNew);
    if ( FAILED(result) ) {
        XERROR2("Error <%x>: can't seek to new folk %d\n", result, dntNew);
        goto CleanUp;
    }

    XDBG(" DBG: Getting new parent refCount\n");
    dwRefCount = 0;
    // get old ref count
    result = DitGetColumnByName(
                DbState,
                TableState,
                SZCNT,
                &dwRefCount,
                sizeof(dwRefCount),
                NULL);
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to get new folk refcount\n", result);
        goto CleanUp;
    }

    XDBG2(" DBG: New parent (%d) refCount = %d\n",
                    dntNew, dwRefCount);

    // Increment due to move
    dwRefCount++;

    XDBG1(" DBG: Setting new parent refCount to %d\n", dwRefCount);
    //
    // Set refcount
    //
    result = DitSetColumnByName(
                DbState,
                TableState,
                SZCNT,
                &dwRefCount,
                sizeof(dwRefCount),
                FALSE );
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to set new parent refCount \n", result);
        goto CleanUp;
    }


    goto CleanUp;

CleanUp:

    if ( pAnc ) {
        DitFree(pAnc);
    }
    return result;
}


HRESULT
ReParentChildren(
    IN DB_STATE *DbState,
    IN TABLE_STATE *TableState,
    IN DWORD dntNew,
    IN DWORD dntOld
    )
/*++

Routine Description:

    Traverse all children of object given by dntOld & move them
    over to be children of dntNew

Arguments:

    DbState -- opened database
    TableState -- opened tabel
    dntNew -- new parent dnt
    dntOld -- current parent dnt

Return Value:

    HRESULT error space

Remark:
    This isn't very efficient implementation (see code). If you end up
    re-using this heavily, you should do some optimization work below such
    as single index walk rather then twice.

--*/
{

    HRESULT result = S_OK;
    DWORD *pKidDnts = NULL;
    DWORD dnt, pdnt;
    DWORD cDnts, cbDnts;
    DWORD i, j;
    JET_ERR jErr;

    //
    // traverse pdnt index to cycle through all partition kids.
    //

    result = DitSetIndex(DbState, TableState, SZPDNTINDEX, FALSE);
    if ( FAILED(result) ) {
        goto CleanUp;
    }

    result = DitSeekToFirstChild(DbState, TableState, dntOld);
    if ( FAILED(result) ) {
        goto CleanUp;
    }


    //
    // Count kids
    //


    pdnt = dnt = dntOld;
    cDnts = 0;
    while ( pdnt == dntOld ) {

        // get kid dnt
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZDNT,
                    &dnt,
                    sizeof(dnt),
                    NULL);
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to get obj dnt\n", result);
            goto CleanUp;
        }


        // get parent dnt
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZPDNT,
                    &pdnt,
                    sizeof(pdnt),
                    NULL);
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to get parent SZPDNT\n", result);
            goto CleanUp;
        }

        if ( pdnt == dntOld ) {
            // proceed until we got a diff parent
            cDnts++;
        }
        else{
            XDBG1(" DBG: Found %d kids\n", cDnts);
            break;
        }

        // find next one
        jErr = JetMove(
                    DbState->sessionId,
                    TableState->tableId,
                    JET_MoveNext,
                    0);
    }

    //
    // Populate dnt array
    //
    cbDnts = sizeof(DWORD)*cDnts;
    result = DitAlloc(&pKidDnts, cbDnts);
    if ( FAILED(result) ) {
        goto CleanUp;
    }

    result = DitSeekToFirstChild(DbState, TableState, dntOld);
    if ( FAILED(result) ) {
        goto CleanUp;
    }

    pdnt = dnt = 0;
    i = 0;
    for ( i=0; i<cDnts; i++ ) {

        // get dnt for consistency & loop termination
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZDNT,
                    &dnt,
                    sizeof(dnt),
                    NULL);
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to get partitions DNT \n", result);
            goto CleanUp;
        }


        // get parent dnt
        result = DitGetColumnByName(
                    DbState,
                    TableState,
                    SZPDNT,
                    &pdnt,
                    sizeof(pdnt),
                    NULL);
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to get partitions SZPDNT\n", result);
            goto CleanUp;
        }

        pKidDnts[i] = dnt;

        // find next one
        jErr = JetMove(
                    DbState->sessionId,
                    TableState->tableId,
                    JET_MoveNext,
                    0);
    }

    //
    // We got the array of kids.
    // Resent index to main & reparent each.
    //

    result = DitSetIndex(DbState, TableState, SZDNTINDEX, FALSE);
    if ( FAILED(result) ) {
        goto CleanUp;
    }

    for ( i=0; i<cDnts; i++) {
        result = ReParent(
                    DbState,
                    TableState,
                    pKidDnts[i],
                    dntNew,
                    dntOld);
        if ( FAILED(result) ) {
            XERROR2("Error<0x%x>: Failed ot reparent dnt %d\n",
                            result, pKidDnts[i]);
            goto CleanUp;
        }
    }

    goto CleanUp;

CleanUp:

    if ( pKidDnts ) {
        DitFree(pKidDnts);
    }
    return result;
}

HRESULT
UnmangleDn(
    IN  OUT LPWSTR pDn
    )
/*++

Routine Description:

    Takes a mangled name & unmangle it inplace

Arguments:

    pDn -- name to unmangle

Return Value:

    error in HRESULT error space

--*/
{
    LPWSTR pNxtRdn, pBadChar;
    DWORD len;

    // seek to bad char
    pBadChar = wcsrchr(pDn, BAD_NAME_CHAR);
    if ( !pBadChar ) {
        XERROR1(" Logic Error: Failed to find bad char in %S\n",
                                pDn );
        return E_UNEXPECTED;
    }
    // seek to next rdn
    // Or this DN may have only one AVA
    pNxtRdn = wcschr(pBadChar, L',');
    if ( pNxtRdn ) {
        // move to skip mangle
        len = wcslen(pNxtRdn);
        MoveMemory(pBadChar, pNxtRdn, len*sizeof(WCHAR) );
    } else {
        len = 0;
    }

    // add term char. note that we should be safe here
    // w/ a valid cnf name since original name was
    // larget by at least the mangle string (guid etc)
    pBadChar[len] = '\0';
    XDBG1(" DBG: Unmangled DN = %S\n", pDn);

    return S_OK;
}

LPWSTR
MangleRdn(
    IN  LPWSTR  pRdn,
    IN  LPWSTR  szTag,
    IN  GUID    guid
    )
/*++

Routine Description:

    Allocates & Creates a mangled RDN of the form

Arguments:

    pRdn -- rdn to mangle
    szTag -- tag to mangle with (typically "DEL" or "CNF")
    guid -- guid to add to mangle

Return Value:

    success: newly allocated mangled name
    failure: NULL

Remarks:
    Allocates memory. Need to free().

--*/
{

    DWORD cbBuffer;
    LPWSTR pBuffer = NULL;
    LPWSTR pszGuid = NULL;
    RPC_STATUS rpcErr;
    HRESULT result = S_OK;

    // convert guid to string form
    rpcErr = UuidToStringW(&guid, &pszGuid);
    if (RPC_S_OK != rpcErr ) {
        XERROR("Error: Failed to convert UuidToString\n");
        return NULL;
    }

    // buffer len = strings + bad char + ':' + '\0'
    cbBuffer = sizeof(WCHAR) * (wcslen(pRdn) + wcslen(szTag) + wcslen(pszGuid) + 3);

    // alloc string
    result = DitAlloc(&pBuffer, cbBuffer);
    if (FAILED(result)) {
        XERROR("Error: failed to allocate memory in MangleRdn\n");
        pBuffer = NULL;
        goto CleanUp;
    }

    // format mangled string
    wsprintfW(pBuffer, L"%s%c%s:%s",
                        pRdn, BAD_NAME_CHAR, szTag, pszGuid);

CleanUp:

    if (pszGuid) {
        RpcStringFreeW(&pszGuid);
    }

    return pBuffer;
}


HRESULT
enumerateConflictedHasMasterNcLinks(
    DB_STATE *dbState,
    TABLE_STATE *tableState,
    TABLE_STATE *linkTableState
    )

/*++

Routine Description:

    This routine looks for references to conflicted phantoms in the link table under
the has-master-nc's attribute. If it find's any, it invokes the logic to rename the
phantom.

Arguments:

    dbState - 
    tableState - 
    linkTableState - 

Return Value:

    HRESULT - 

--*/

{
    HRESULT result = S_OK;
    JET_ERR jErr;
    BOOL  fStatus;

    DWORD dnt, dntBackLink, dwLinkBase;
    DWORD  cbBuffer = 0;
    GUID  guid;
    WCHAR szRDN[MAX_RDN_SIZE];
    INT cch;
    BYTE bVal = 0;

// from mkdit.ini has-master-ncs Link-ID=76
    const DWORD hasMasterLinkId = 76;
    const DWORD hasMasterLinkBase = MakeLinkBase(hasMasterLinkId);

    result = DitSetIndex(
                dbState,
                linkTableState,
                SZLINKALLINDEX,
                TRUE);
    if ( FAILED(result) ) {
        XDBG1("Error <0x%x>: failed to set index \n", result);
        goto CleanUp;
    }


    result = DitSeekToLink(
                dbState,
                linkTableState,
                0,  // first dnt
                0); // first linkbase

    if (FAILED(result)) {
        XERROR1("Error <0x%x>: failed to seek link\n", result);
        goto CleanUp;
    }

    // Walk the whole link table looking for bad links

    jErr = JET_errSuccess;
    while ( jErr == JET_errSuccess ) {
        // get link base
        result = DitGetColumnByName(
                    dbState,
                    linkTableState,
                    SZLINKBASE,
                    &dwLinkBase,
                    sizeof(dwLinkBase),
                    NULL);
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to get link base\n", result);
            goto CleanUp;
        }

        // See if this is the kind of link we want
        if (dwLinkBase != hasMasterLinkBase) {
            goto LoopEnd;
        }

        // get dnt
        result = DitGetColumnByName(
                    dbState,
                    linkTableState,
                    SZLINKDNT,
                    &dnt,
                    sizeof(dnt),
                    NULL);
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to get configuration (link)\n", result);
            goto CleanUp;
        }

        // get back link dnt -- this is what we want.
        result = DitGetColumnByName(
                    dbState,
                    linkTableState,
                    SZBACKLINKDNT,
                    &dntBackLink,
                    sizeof(dntBackLink),
                    NULL);
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to get configuration (back link)\n", result);
            goto CleanUp;
        }

        // See if the record meets our criteria
        // rdn is mangled
        // record is a phantom

        result = DitSeekToDnt(
                        dbState,
                        tableState,
                        dntBackLink);
        if ( FAILED(result) ) {
            XERROR1("Error: failed to seek to back link dnt %d\n",
                                    dntBackLink );
            goto CleanUp;
        }

        result = DitGetColumnByName(
            dbState,
            tableState,
            SZRDNATT,
            szRDN,
            sizeof(szRDN),
            &cbBuffer);
        if ( FAILED(result) ) {
            fprintf(stderr, "Error <%x>: failed to get RDN\n", result);
            goto CleanUp;
        }

        cch = cbBuffer/2;
        ASSERT(cch < MAX_RDN_SIZE);
        szRDN[cch] = '\0';
        fStatus = IsRdnMangled(szRDN,cbBuffer/sizeof(WCHAR),&guid);

        result = DitGetColumnByName(
                    dbState,
                    tableState,
                    SZOBJ,
                    &bVal,
                    sizeof(bVal),
                    NULL);
        if ( FAILED(result) ) {
            // phantom's have the object byte set to 0.
            XERROR1("Error <%x>: failed to read object flag\n", result);
            goto CleanUp;
        }

        XDBG3( "rdn = '%S', fStatus = %d, bVal = %d\n", szRDN, fStatus, bVal );

        // Not mangled or not a phantom
        if ( (!fStatus) || bVal ) {
            goto LoopEnd;
        }

        // Correct the phantom
        // We assume that the link table position is not changed by this call
/*
This is scenario #4.
In the link table we find a has-master-nc link referring to a conflicted name.
We attempt to rename this object to have a non-conflicted name. The correction
is similar to what is done in scenario #1.
*/

        result = FixConfNCByRenameWithStructColl(
            dbState,
            tableState,
            0,  // Not contained on a cross ref
            dntBackLink,
            szRDN
            );

    LoopEnd:

        // find next one
        jErr = JetMove(
                    dbState->sessionId,
                    linkTableState->tableId,
                    JET_MoveNext,
                    0);
    }

CleanUp:

    return result;
} /* enumerateConflictedHasMasterNcLinks */

HRESULT
enumerateConflictedNcname(
    DB_STATE *dbState,
    TABLE_STATE *tableState,
    TABLE_STATE *linkTableState
    )

/*++

Routine Description:

    Examine each cross ref object in the partition container, and check whether the
    ncname attribute is conflicted

Arguments:

    dbState - 
    tableState - 
    linkTableState - 

Return Value:

    HRESULT - 

--*/

{

    // return
    HRESULT returnValue = S_OK;
    HRESULT result;
    JET_ERR jErr;
    BOOL  fStatus;

    // database & jet
    // various local helpers
    DWORD dnt, pdnt = 0, dntPartitions = 0;
    LPWSTR pBuffer = NULL;
    DWORD  cbBuffer = 0;
    GUID  guid;
    struct _PARTITION_DATA {
        DWORD   dntCR;
        DWORD   dntNC;
    } *pPartitions = NULL;
    INT iPartitions, i, j;
    WCHAR szRDN[MAX_RDN_SIZE];
    INT cch;


    __try{

        result = FindPartitions(
                    dbState,
                    tableState,
                    linkTableState,
                    &dntPartitions);
        if ( FAILED(result) ) {
            RESOURCE_PRINT1(IDS_AUTH_RESTORE_LIST_FAILED_TO_OPEN_DB, result);
            returnValue = result;
            goto CleanUp;
        }


        //
        // traverse pdnt index to cycle through all partition kids.
        //

        result = DitSetIndex(dbState, tableState, SZPDNTINDEX, FALSE);
        if ( FAILED(result) ) {
            RESOURCE_PRINT1(IDS_AUTH_RESTORE_LIST_FAILED_TO_OPEN_DB, result);
            returnValue = result;
            goto CleanUp;
        }

        result = DitSeekToFirstChild(dbState, tableState, dntPartitions);
        if ( FAILED(result) ) {
            RESOURCE_PRINT1(IDS_AUTH_RESTORE_LIST_FAILED_TO_OPEN_DB, result);
            returnValue = result;
            goto CleanUp;
        }


        //
        // Count kids
        //


        pdnt = dntPartitions;
        dnt = dntPartitions;
        iPartitions = 0;
        while ( pdnt == dntPartitions ) {

            // get kid dnt
            result = DitGetColumnByName(
                        dbState,
                        tableState,
                        SZDNT,
                        &dnt,
                        sizeof(dnt),
                        NULL);
            if ( FAILED(result) ) {
                XERROR1("Error <%x>: failed to get partitions DNT \n", result);
                returnValue = result;
                goto CleanUp;
            }


            // get parent dnt
            result = DitGetColumnByName(
                        dbState,
                        tableState,
                        SZPDNT,
                        &pdnt,
                        sizeof(pdnt),
                        NULL);
            if ( FAILED(result) ) {
                XERROR1("Error <%x>: failed to get partitions SZPDNT\n", result);
                returnValue = result;
                goto CleanUp;
            }

            if ( pdnt == dntPartitions ) {

                // proceed until we got a diff parent
                iPartitions++;
            }
            else{
                XDBG1(" DBG: Found %d partitions\n", iPartitions);
                break;
            }

            // find next one
            jErr = JetMove(
                        dbState->sessionId,
                        tableState->tableId,
                        JET_MoveNext,
                        0);
        }

        //
        // Populate dnt index
        //
        cbBuffer = sizeof(struct _PARTITION_DATA)*iPartitions;
        result = DitAlloc(&pPartitions, cbBuffer);
        if ( FAILED(result) ) {
            RESOURCE_PRINT1(IDS_AUTH_RESTORE_LIST_FAILED_TO_OPEN_DB, result);
            returnValue = result;
            goto CleanUp;
        }

        result = DitSeekToFirstChild(dbState, tableState, dntPartitions);
        if ( FAILED(result) ) {
            RESOURCE_PRINT1(IDS_AUTH_RESTORE_LIST_FAILED_TO_OPEN_DB, result);
            returnValue = result;
            goto CleanUp;
        }

        pdnt = dnt = 0;
        i = 0;
        for ( i=0; i<iPartitions; i++ ) {

            // get dnt for consistency & loop termination
            result = DitGetColumnByName(
                        dbState,
                        tableState,
                        SZDNT,
                        &dnt,
                        sizeof(dnt),
                        NULL);
            if ( FAILED(result) ) {
                XERROR1("Error <%x>: failed to get partitions DNT \n", result);
                returnValue = result;
                goto CleanUp;
            }


            // get link base for sanity (not realy used).
            result = DitGetColumnByName(
                        dbState,
                        tableState,
                        SZPDNT,
                        &pdnt,
                        sizeof(pdnt),
                        NULL);
            if ( FAILED(result) ) {
                XERROR1("Error <%x>: failed to get partitions SZPDNT\n", result);
                returnValue = result;
                goto CleanUp;
            }

            if ( pdnt == dntPartitions ) {
                XDBG2(" DBG: dnt = %d; pdnt = %d\n", dnt, pdnt);
                pPartitions[i].dntCR = dnt;
            }
            else{
                XDBG3(" DBG: end of partition kids (dnt%d;pdnt=%d)\n",
                                result, dnt, pdnt);
                break;
            }

            // find next one
            jErr = JetMove(
                        dbState->sessionId,
                        tableState->tableId,
                        JET_MoveNext,
                        0);
        }


        result = DitSetIndex(dbState, tableState, SZDNTINDEX, FALSE);
        if ( FAILED(result) ) {
            RESOURCE_PRINT1(IDS_AUTH_RESTORE_LIST_FAILED_TO_OPEN_DB, result);
            returnValue = result;
            goto CleanUp;
        }

    #if CNF_NC_DBG
        // read in dn
        XDBG(" DBG: Partition DNT list:\n");
        for (i = 0; i < iPartitions; i ++) {
            pBuffer = GetDN(dbState, tableState, pPartitions[i].dntCR, TRUE);
            // Warning: currency is lost after this function
            if ( pBuffer ) {
                DitFree(pBuffer); pBuffer = NULL;
            }
        }
    #endif


        //
        // We've got the partition dnt list.
        //  - for each partition, get to the NC dnt
        //

        XDBG("Scanning NCs:\n");

        for ( i = 0; i < iPartitions; i++ ) {

            result = DitSeekToDnt(
                            dbState,
                            tableState,
                            pPartitions[i].dntCR);
            if ( FAILED(result) ) {
                returnValue = result;
                goto CleanUp;
            }


            result = DitGetColumnByName(
                        dbState,
                        tableState,
                        SZNCNAME,
                        &dnt,
                        sizeof(dnt),
                        NULL);
            if ( FAILED(result) ) {
                XERROR1("Error <%x>: failed to get NCNAME\n", result);
                returnValue = result;
                goto CleanUp;
            }


            // verify it's there & accessible (sanity)
            result = DitSeekToDnt(
                            dbState,
                            tableState,
                            dnt);
            if ( FAILED(result) ) {
                XDBG1("Skipping %d\n", dnt);
                continue;
            }

    #if CNF_NC_DBG
            pBuffer = GetDN(dbState, tableState, dnt, TRUE);
            // Warning: currency is lost after this function
            if ( pBuffer ) {
                DitFree(pBuffer); pBuffer = NULL;
            }
    #endif

            pPartitions[i].dntNC = dnt;

        }



        //
        // Finally do the work:
        //  - for each NC:
        //      - read name
        //      - see if name is mangled
        //      - modify/fix it if needed
        //      - rm old name
        //
        //

        XDBG("Scanning for conflicts:\n");
        for (i=0; i<iPartitions; i++) {
            if (pPartitions[i].dntNC != 0) {
                // we have this NC
                //  - read & eval fix

                result = DitSeekToDnt(
                                dbState,
                                tableState,
                                pPartitions[i].dntNC);
                if ( FAILED(result) ) {
                    XERROR1("Error: failed to seek to nc dnt %d\n",
                                            pPartitions[i].dntNC );
                    returnValue = result;
                    goto CleanUp;
                }


                result = DitGetColumnByName(
                            dbState,
                            tableState,
                            SZRDNATT,
                            szRDN,
                            sizeof(szRDN),
                            &cbBuffer);
                if ( FAILED(result) ) {
                    fprintf(stderr, "Error <%x>: failed to get RDN\n", result);
                    returnValue = result;
                    goto CleanUp;
                }

                cch = cbBuffer/2;
                ASSERT(cch < MAX_RDN_SIZE);
                szRDN[cch] = '\0';
                fStatus = IsRdnMangled(szRDN,cbBuffer/sizeof(WCHAR),&guid);

                if ( fStatus ) {
                    XDBG1(" DBG: Got Mangled rdn \t<<%S>>\n", szRDN);

                    //
                    // Fix mangled rdn
                    //
                    result = FixMangledNC(
                                    dbState,
                                    tableState,
                                    pPartitions[i].dntCR,
                                    pPartitions[i].dntNC,
                                    szRDN );
                    if ( FAILED(result) ) {
                        XERROR(" Can't fix Mangled NC\n");
                        // remember failure but proceed
                        returnValue = result;
                        // continue trying other names.
                        continue;
                    }   // Fix failed
                }       // name is mangled
            }           // non-zero partition dnt
        }               // cycle partitions


CleanUp:;

    } __finally {

        if ( pBuffer ) {
            DitFree(pBuffer);
        }

        if ( pPartitions ) {
            DitFree(pPartitions);
        }
    }

    return returnValue;
} /* enumerateConflictedNcname */

VOID
SFixupCnfNc(
    VOID
    )
/*++

Routine Description:


    This routine walks the partitions container seeking conflicted
    NC names pointed by crossrefs via the nCName property.
    For each conflict, it will attempt to fix it by calling
    FixMangledNC.
    Phases:
    a) get to the configuration container, then the partitions one
    b) get all cross-ref's nCName (NC's w/ potentional conflict)
    c) Call FixMangledNC for each NC.

Remark:
    This isn't very efficient implementation (see code). If you end up
    re-using this heavily, you should do some optimization work below such
    as single index walk rather then twice.


--*/
{

    // return
    HRESULT returnValue = S_OK;
    HRESULT result;

    // database & jet
    DB_STATE *dbState = NULL;
    TABLE_STATE *tableState = NULL;
    TABLE_STATE *linkTableState = NULL;


    //
    // Open database/tables
    //

    RESOURCE_PRINT (IDS_AR_OPEN_DB_DIT);

    __try{

        result = DitOpenDatabase(&dbState);
        if ( FAILED(result) ) {
            returnValue = result;
            goto CleanUp;
        }

        //"done.\n"
        RESOURCE_PRINT (IDS_DONE);


        result = DitOpenTable(dbState, SZDATATABLE, SZDNTINDEX, &tableState);
        if ( FAILED(result) ) {
            RESOURCE_PRINT1(IDS_AUTH_RESTORE_LIST_FAILED_TO_OPEN_DB, result);
            returnValue = result;
            goto CleanUp;
        }

        // SZLINKALLINDEX includes both present and absent link values
        result = DitOpenTable(dbState, SZLINKTABLE, SZLINKALLINDEX, &linkTableState);
        if ( FAILED(result) ) {
            RESOURCE_PRINT1(IDS_AUTH_RESTORE_LIST_FAILED_TO_OPEN_DB, result);
            returnValue = result;
            goto CleanUp;
        }



        // Fix Has-Master-Nc links
        returnValue = enumerateConflictedHasMasterNcLinks(
            dbState, tableState, linkTableState );

        // Fix Cross Ref Nc Names
        returnValue = enumerateConflictedNcname(
            dbState, tableState, linkTableState );

CleanUp:;

    } __finally {


        if ( SUCCEEDED(returnValue) ) {
            RESOURCE_PRINT(IDS_DONE);
        } else {
            RESOURCE_PRINT(IDS_FAILED);
        }

        if ( tableState != NULL ) {
            result = DitCloseTable(dbState, &tableState);
            if ( FAILED(result) ) {
                if ( SUCCEEDED(returnValue) ) {
                    returnValue = result;
                }
            }
        }

        if ( tableState != NULL ) {
            result = DitCloseTable(dbState, &linkTableState);
            if ( FAILED(result) ) {
                if ( SUCCEEDED(returnValue) ) {
                    returnValue = result;
                }
            }
        }


        if ( dbState != NULL ) {
            result = DitCloseDatabase(&dbState);
            if ( FAILED(result) ) {
                if ( SUCCEEDED(returnValue) ) {
                    returnValue = result;
                }
            }
        }

    }

//    return returnValue;
} // SFixupCnfNc


HRESULT
FindPartitions(
    IN  DB_STATE *dbState,
    IN  TABLE_STATE *tableState,
    IN  TABLE_STATE *linkTableState,
    OUT PDWORD  pDnt
    )
/*++

Routine Description:

    Retrieves the dnt of the partitions container

Arguments:

    dbState -- opened table
    tableState -- opened table
    pDnt -- a pointer to accept found partitions container



Return Value:

    error in HRESULT space

--*/
{
    HRESULT result = S_OK;
    JET_ERR jErr;

    DWORD dnt, dntDsa, dntBackLink, dntConfig = 0;
    LPWSTR pBuffer = NULL;
    DWORD  cbBuffer = 0;
    LPWSTR pDn = NULL;
    JET_COLUMNDEF coldef;

// from mkdit.ini has-master-ncs Link-ID=76
    const DWORD hasMasterLinkId = 76;
    const DWORD hasMasterLinkBase = MakeLinkBase(hasMasterLinkId);

    XDBG(" >Getting DsaDnt. .");
    result = DitGetDsaDnt(dbState, &dntDsa);
    if ( FAILED(result) ) {
        goto CleanUp;
    }

    XDBG1(" . %lu\n", dntDsa);



#if CNF_NC_DBG

    // debug:
    // Seek to DSA & print DN
    pBuffer = GetDN(dbState, tableState, dntDsa, TRUE);
    // Warning: currency is lost after this function
    if(pBuffer){
        DitFree(pBuffer); pBuffer = NULL;
    }
#endif

    XDBG2("Seeking to link %d base %d\n",
                dntDsa, hasMasterLinkBase);

    result = DitSetIndex(
                dbState,
                linkTableState,
                SZLINKALLINDEX,
                TRUE);
    if ( FAILED(result) ) {
        XDBG1("Error <0x%x>: failed to set index \n", result);
        goto CleanUp;
    }


    result = DitSeekToLink(
                dbState,
                linkTableState,
                dntDsa,
                hasMasterLinkBase);

    if (FAILED(result)) {
        XERROR1("Error <0x%x>: failed to seek link\n", result);
        goto CleanUp;
    }


    //
    // Look for configuration container
    //



    jErr = JET_errSuccess;

    dnt = dntDsa;

    while ( jErr == JET_errSuccess &&
            dnt == dntDsa ) {

        // get dnt for consistency & loop termination
        result = DitGetColumnByName(
                    dbState,
                    linkTableState,
                    SZLINKDNT,
                    &dnt,
                    sizeof(dnt),
                    NULL);
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to get configuration (link)\n", result);
            goto CleanUp;
        }

        // get back link dnt -- this is what we want.
        result = DitGetColumnByName(
                    dbState,
                    linkTableState,
                    SZBACKLINKDNT,
                    &dntBackLink,
                    sizeof(dntBackLink),
                    NULL);
        if ( FAILED(result) ) {
            XERROR1("Error <%x>: failed to get configuration (back link)\n", result);
            goto CleanUp;
        }

        // read in dn
        pBuffer = GetDN(dbState, tableState, dntBackLink, FALSE);
        // Warning: currency is lost after this function

        if ( pBuffer ) {
            // is it our config?
            if ( 0 == _wcsnicmp(SZCONFIG_W, pBuffer, wcslen(SZCONFIG_W)) ) {
                // got it.
               XDBG1("Got Config: %S\n", pBuffer);
               dntConfig = dntBackLink;
               break;
            }
            else {
                DitFree(pBuffer); pBuffer = NULL;
            }
        }
        else {
            XERROR1("Error: found an empty DN with DNT %d\n", dntBackLink);
        }

        // find next one
        jErr = JetMove(
                    dbState->sessionId,
                    linkTableState->tableId,
                    JET_MoveNext,
                    0);
    }



    if ( !pBuffer ) {
        XERROR("Inconsistency Error: failed to find Configuration NC.\n");
        result = E_UNEXPECTED;
        goto CleanUp;
    }

    cbBuffer = wcslen(pBuffer) +
               wcslen(SZPARTITIONS_W) +
               + 2;     // room for ',' & '\0'
    cbBuffer *= 2;

    result = DitAlloc(&pDn, cbBuffer);
    if ( FAILED(result) ) {
        XERROR("Error: memory allocation failed for partitions\n");
        goto CleanUp;
    }

    wsprintfW(pDn, L"%s,%s", SZPARTITIONS_W, pBuffer);
    DitFree(pBuffer); pBuffer = NULL;

    XDBG1("Partitions = %S\n", pDn);


    //
    // Get Partitions
    //

    result = DitSeekToDn(
                dbState,
                tableState,
                pDn);
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to get partitions\n", result);
        goto CleanUp;
    }
    DitFree(pDn); pDn = NULL;


    result = DitGetColumnByName(
                dbState,
                tableState,
                SZDNT,
                pDnt,
                sizeof(DWORD),
                NULL);
    if ( FAILED(result) ) {
        XERROR1("Error <%x>: failed to get partitions dnt\n", result);
        goto CleanUp;
    }

    XDBG1("Got partitions dnt %d\n", *pDnt);

CleanUp:

    if ( pBuffer ) {
        DitFree(pBuffer);
    }

    if ( pDn ) {
        DitFree(pDn);
    }

    return result;
}






VOID SetJetParameters (JET_INSTANCE *JetInst)
{
    // DaveStr - 5/21/99 - This routine used to cache knowledge of whether
    // Jet parameters had ever been set and be a no-op if they had under the
    // assumption that setting Jet parameters is expensive.  However, this
    // causes confusion after a DB move, so caching is permanently disabled.

    DBSetRequiredDatabaseSystemParameters (JetInst);
}


DWORD OpenJet(
    IN const char * pszFileName
    )
/*
    Opens Jet Database.
    If supplied filename is Null, then uses default filename.

    returns S_OK on success, S_FALSE on error.
*/

{
    JET_ERR err;

    RESOURCE_PRINT1 (IDS_JET_OPEN_DATABASE, "[Current]");

    SetJetParameters (&jetInstance);

    //
    // Do JetInit, BeginSession, Attach/OpenDatabase
    //

    err = DBInitializeJetDatabase(&jetInstance, &sesid, &dbid, pszFileName, FALSE);
    if (err != JET_errSuccess) {
        RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "DBInitializeJetDatabase", GetJetErrString(err));
        return S_FALSE;
    }

    return S_OK;
}

JET_ERR
OpenTable (
    IN BOOL fWritable,
    IN BOOL fCountRecords,
    OUT DWORD* pNRecs,
    OUT DWORD* pNSDs
    )
{
    JET_ERR err;

    fprintf(stderr,".");
    if (err = JetOpenTable(sesid,
                           dbid,
                           SZDATATABLE,
                           NULL,
                           0,
                           (fWritable?
                            (JET_bitTableUpdatable | JET_bitTableDenyRead):
                            JET_bitTableReadOnly),
                           &tblid)) {
        tblid = -1;
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetOpenTable",
                SZDATATABLE, GetJetErrString(err));
        return err;
    }

    fprintf(stderr,".");
    if (err =  JetSetCurrentIndex(sesid, tblid, szIndex)) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetCurrentIndex",
                szIndex, GetJetErrString(err));
        return err;
    }

    //
    // link table
    //

    fprintf(stderr,".");
    if (err = JetOpenTable(sesid,
                           dbid,
                           SZLINKTABLE,
                           NULL,
                           0,
                           (fWritable?
                            (JET_bitTableUpdatable | JET_bitTableDenyRead):
                            JET_bitTableReadOnly),
                           &linktblid)) {
        linktblid = -1;
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetOpenTable",
                SZLINKTABLE, GetJetErrString(err));
        return err;
    }

    fprintf(stderr,".");
    if (err =  JetSetCurrentIndex(sesid, linktblid, SZLINKINDEX)) {
        RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetCurrentIndex",
                SZLINKINDEX, GetJetErrString(err));
        return err;
    }

    {
        JET_COLUMNDEF coldef;

        err = JetGetTableColumnInfo(sesid,
                                    linktblid,
                                    SZBACKLINKDNT,
                                    &coldef,
                                    sizeof(coldef),
                                    0);

        if ( err ) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetGetTableColumnInfo",
                    GetJetErrString(err));
            return err;
        }

        blinkid = coldef.columnid;
    }

    //
    // SD table
    //

    fprintf(stderr,".");
    if (err = JetOpenTable(sesid,
                           dbid,
                           SZSDTABLE,
                           NULL,
                           0,
                           (fWritable?
                            (JET_bitTableUpdatable | JET_bitTableDenyRead):
                            JET_bitTableReadOnly),
                           &sdtblid)) {
        sdtblid = -1;
        if (err == JET_errObjectNotFound) {
            // "SD table is not found in the database. The database is in the old format.\n"
            RESOURCE_PRINT(IDS_SDTABLE_NOTFOUND);
            err = 0;
        }
        else {
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetOpenTable", SZSDTABLE, GetJetErrString(err));
            return err;
        }
    }

    if (sdtblid != -1) {
        fprintf(stderr,".");
        if (err =  JetSetCurrentIndex(sesid, sdtblid, SZSDIDINDEX)) {
            RESOURCE_PRINT3 (IDS_JET_GENERIC_ERR1, "JetSetCurrentIndex",
                    SZSDIDINDEX, GetJetErrString(err));
            return err;
        }


        {
            JET_COLUMNDEF coldef;

            err = JetGetTableColumnInfo(sesid,
                                        sdtblid,
                                        SZSDID,
                                        &coldef,
                                        sizeof(coldef),
                                        0);

            if ( err ) {
                RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetGetTableColumnInfo",
                        GetJetErrString(err));
                return err;
            }

            sdidid = coldef.columnid;

            err = JetGetTableColumnInfo(sesid,
                                        sdtblid,
                                        SZSDREFCOUNT,
                                        &coldef,
                                        sizeof(coldef),
                                        0);

            if ( err ) {
                RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetGetTableColumnInfo",
                        GetJetErrString(err));
                return err;
            }

            sdrefcountid = coldef.columnid;

            err = JetGetTableColumnInfo(sesid,
                                        sdtblid,
                                        SZSDVALUE,
                                        &coldef,
                                        sizeof(coldef),
                                        0);

            if ( err ) {
                RESOURCE_PRINT2 (IDS_JET_GENERIC_ERR2, "JetGetTableColumnInfo",
                        GetJetErrString(err));
                return err;
            }

            sdvalueid = coldef.columnid;
        }
    }

    RESOURCE_PRINT (IDS_DONE);
    if ( fCountRecords ) {
        if(pNRecs == NULL || pNSDs == NULL) {
            // invalid call, ptrs must be specified
            return 1;
        }

        RESOURCE_PRINT (IDS_SCHECK_GET_REC_COUNT1);
        JetMove(sesid, tblid, JET_MoveFirst, 0);
        JetIndexRecordCount( sesid, tblid, pNRecs, 0xFFFFFFFF );
        //"%u records"
        RESOURCE_PRINT1 (IDS_SCHECK_GET_REC_COUNT2,*pNRecs);

        if (sdtblid != -1) {
            RESOURCE_PRINT (IDS_SCHECK_GET_SDREC_COUNT1);
            JetMove(sesid, sdtblid, JET_MoveFirst, 0);
            JetIndexRecordCount( sesid, sdtblid, pNSDs, 0xFFFFFFFF );
            //"%u security descriptors"
            RESOURCE_PRINT1 (IDS_SCHECK_GET_SDREC_COUNT2,*pNSDs);
        }
    }

    return 0;
} // OpenTables


VOID
CloseJet(
    VOID
    )
{
    JET_ERR err;

    //
    // Close all tables
    //

    if ( linktblid != JET_tableidNil ) {
        JetCloseTable(sesid,linktblid);
        linktblid = JET_tableidNil;
    }

    if ( tblid != JET_tableidNil ) {
        JetCloseTable(sesid,tblid);
        tblid = JET_tableidNil;
    }

    if (sesid != JET_sesidNil ) {
        if(dbid != JET_dbidNil) {
            // JET_bitDbForceClose not supported in Jet600.
            if ((err = JetCloseDatabase(sesid, dbid, 0)) != JET_errSuccess) {
                RESOURCE_PRINT2 (IDS_JET_GENERIC_WRN, "JetCloseDatabase", GetJetErrString(err));
            }
            dbid = JET_dbidNil;
        }

        if ((err = JetEndSession(sesid, JET_bitForceSessionClosed)) != JET_errSuccess) {
            RESOURCE_PRINT2 (IDS_JET_GENERIC_WRN, "JetEndSession", GetJetErrString(err));
        }
        sesid = JET_sesidNil;

        JetTerm(jetInstance);
        jetInstance = 0;
    }
} // CloseJet



BOOL
GetLogFileName2(
    IN PCHAR Name
    )
{
    DWORD i;
    WIN32_FIND_DATA w32Data;
    HANDLE hFile;
    DWORD err;

    //
    // ok, add a suffix
    //

    for (i=0;i<500000;i++) {

        sprintf(Name,"dsdit.dmp.%u",i);

        hFile = FindFirstFile(Name, &w32Data);
        if ( hFile == INVALID_HANDLE_VALUE ) {
            if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
                break;
            }
            //"*** Error: %d(%ws) Cannot open log file %hs\n"
            err = GetLastError();
            RESOURCE_PRINT3 (IDS_SCHECK_OPEN_LOG_ERR, err, GetW32Err(err), Name );
            return FALSE;
        } else {
            FindClose(hFile);
        }
    }

    return TRUE;

} // GetLogFileName2


VOID
CloseLogFile(
    VOID
    )
{
    if ( hsLogFile != INVALID_HANDLE_VALUE ) {
        CloseHandle(hsLogFile);
        hsLogFile = INVALID_HANDLE_VALUE;
    }
    return;
}


BOOL
OpenLogFile(
    VOID
    )
{
    BOOL ret = TRUE;
    CHAR LogFileName[1024];
    DWORD err;

    //
    // Get Name to open
    //

    if (!GetLogFileName2(LogFileName)) {
        ret = FALSE;
        goto exit;
    }

    hsLogFile = CreateFileA( LogFileName,
                            GENERIC_WRITE|GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

    if ( hsLogFile == INVALID_HANDLE_VALUE ) {
        //"*** Error: %d(%ws) Cannot open log file %hs\n"
        err = GetLastError();
        RESOURCE_PRINT3 (IDS_SCHECK_OPEN_LOG_ERR, err, GetW32Err(err), LogFileName );
        ret=FALSE;
        goto exit;
    }

    //"\nWriting summary into log file %s\n"
    RESOURCE_PRINT1 (IDS_SCHECK_WRITING_LOG, LogFileName);
exit:

    return ret;

} // OpenLogFile



BOOL
Log(
    IN BOOL     fLog,
    IN LPSTR    Format,
    ...
    )

{
    va_list arglist;

    if ( !fLog ) {
        return TRUE;
    }

    //
    // Simply change arguments to va_list form and call DsPrintRoutineV
    //

    va_start(arglist, Format);

    PrintRoutineV( Format, arglist );

    va_end(arglist);

    return TRUE;
} // ScLog


VOID
PrintRoutineV(
    IN LPSTR Format,
    va_list arglist
    )
// Must be called with DsGlobalLogFileCritSect locked

{
    static LPSTR logFileOutputBuffer = NULL;
    ULONG length;
    DWORD BytesWritten;
    static BeginningOfLine = TRUE;
    static LineCount = 0;
    static TruncateLogFileInProgress = FALSE;
    static LogProblemWarned = FALSE;

    //
    // Allocate a buffer to build the line in.
    //  If there isn't already one.
    //

    length = 0;

    if ( logFileOutputBuffer == NULL ) {
        logFileOutputBuffer = LocalAlloc( 0, MAX_PRINTF_LEN );

        if ( logFileOutputBuffer == NULL ) {
            return;
        }
    }

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // Never print empty lines.
        //

        if ( Format[0] == '\n' && Format[1] == '\0' ) {
            return;
        }
    }

    //
    // Put a the information requested by the caller onto the line
    //

    length += (ULONG) vsprintf(&logFileOutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && logFileOutputBuffer[length-1] == '\n' );
    if ( BeginningOfLine ) {
        logFileOutputBuffer[length-1] = '\r';
        logFileOutputBuffer[length] = '\n';
        logFileOutputBuffer[length+1] = '\0';
        length++;
    }

    if ( hsLogFile == INVALID_HANDLE_VALUE ) {

        fprintf(stderr, "%s", logFileOutputBuffer);
        return;
    }

    //
    // Write the debug info to the log file.
    //

    if ( !WriteFile( hsLogFile,
                     logFileOutputBuffer,
                     length,
                     &BytesWritten,
                     NULL ) ) {

        if ( !LogProblemWarned ) {
            fprintf(stderr, "[DSLOGS] Cannot write to log file error %ld\n",
                             GetLastError() );
            LogProblemWarned = TRUE;
        }
    }

} // PrintRoutineV

static WCHAR jetdesc[MAX_JET_ERROR_LENGTH+1];

PWCHAR
GetJetErrString(
    IN JET_ERR JetError
    )
/*++

Routine Description:

    This function takes a JET_ERR and writes the description of it
    into a global variable which is returned.

Arguments:

    JetError - Supplies the Jet error code.

Return Value:

    None

--*/
{

    CONST WCHAR *description = NULL;


    switch ( JetError ) {

    case JET_errBackupInProgress:
        description = READ_STRING(IDS_JET_ERRBACKUPINPROGRESS);
        break;

    case JET_errBufferTooSmall:
        description = READ_STRING(IDS_JET_ERRBUFFERTOOSMALL);
        break;

    case JET_errColumnDoesNotFit:
        description = READ_STRING(IDS_JET_ERRCOLUMNDOESNOTFIT);
        break;

    case JET_errColumnIllegalNull:
        description = READ_STRING(IDS_JET_ERRCOLUMNILLEGALNULL);
        break;

    case JET_errColumnNotFound:
        description = READ_STRING(IDS_JET_ERRCOLUMNNOTFOUND);
        break;

    case JET_errColumnNotUpdatable:
        description = READ_STRING(IDS_JET_ERRCOLUMNNOTUPDATABLE);
        break;

    case JET_errColumnTooBig:
        description = READ_STRING(IDS_JET_ERRCOLUMNTOOBIG);
        break;

    case JET_errDatabaseInconsistent:
        description = READ_STRING(IDS_JET_ERRDATABASEINCONSISTENT);
        break;

    case JET_errDatabaseInUse:
        description = READ_STRING(IDS_JET_ERRDATABASEINUSE);
        break;

    case JET_errDatabaseNotFound:
        description = READ_STRING(IDS_JET_ERRDATABASENOTFOUND);
        break;

    case JET_errFileAccessDenied:
        description = READ_STRING(IDS_JET_ERRFILEACCESSDENIED);
        break;

    case JET_errFileNotFound:
        description = READ_STRING(IDS_JET_ERRFILENOTFOUND);
        break;

    case JET_errInvalidBufferSize:
        description = READ_STRING(IDS_JET_ERRINVALIDBUFFERSIZE);
        break;

    case JET_errInvalidDatabaseId:
        description = READ_STRING(IDS_JET_ERRINVALIDDATABASEID);
        break;

    case JET_errInvalidName:
        description = READ_STRING(IDS_JET_ERRINVALIDNAME);
        break;

    case JET_errInvalidParameter:
        description = READ_STRING(IDS_JET_ERRINVALIDPARAMETER);
        break;

    case JET_errInvalidSesid:
        description = READ_STRING(IDS_JET_ERRINVALIDSESID);
        break;

    case JET_errInvalidTableId:
        description = READ_STRING(IDS_JET_ERRINVALIDTABLEID);
        break;

    case JET_errKeyDuplicate:
        description = READ_STRING(IDS_JET_ERRKEYDUPLICATE);
        break;

    case JET_errKeyIsMade:
        description = READ_STRING(IDS_JET_ERRKEYISMADE);
        break;

    case JET_errKeyNotMade:
        description = READ_STRING(IDS_JET_ERRKEYNOTMADE);
        break;

    case JET_errNotInitialized:
        description = READ_STRING(IDS_JET_ERRNOTINITIALIZED);
        break;

    case JET_errNoCurrentIndex:
        description = READ_STRING(IDS_JET_ERRNOCURRENTINDEX);
        break;

    case JET_errNoCurrentRecord:
        description = READ_STRING(IDS_JET_ERRNOCURRENTRECORD);
        break;

    case JET_errNotInTransaction:
        description = READ_STRING(IDS_JET_ERRNOTINTRANSACTION);
        break;

    case JET_errNullKeyDisallowed:
        description = READ_STRING(IDS_JET_ERRNULLKEYDISALLOWED);
        break;

    case JET_errObjectNotFound:
        description = READ_STRING(IDS_JET_ERROBJECTNOTFOUND);
        break;

    case JET_errPermissionDenied:
        description = READ_STRING(IDS_JET_ERRPERMISSIONDENIED);
        break;

    case JET_errSuccess:
        description = READ_STRING(IDS_JET_ERRSUCCESS);
        break;

    case JET_errTableInUse:
        description = READ_STRING(IDS_JET_ERRTABLEINUSE);
        break;

    case JET_errTableLocked:
        description = READ_STRING(IDS_JET_ERRTABLELOCKED);
        break;

    case JET_errTooManyActiveUsers:
        description = READ_STRING(IDS_JET_ERRTOOMANYACTIVEUSERS);
        break;

    case JET_errTooManyOpenDatabases:
        description = READ_STRING(IDS_JET_ERRTOOMANYOPENDATABASES);
        break;

    case JET_errTooManyOpenTables:
        description = READ_STRING(IDS_JET_ERRTOOMANYOPENTABLES);
        break;

    case JET_errTransTooDeep:
        description = READ_STRING(IDS_JET_ERRTRANSTOODEEP);
        break;

    case JET_errUpdateNotPrepared:
        description = READ_STRING(IDS_JET_ERRUPDATENOTPREPARED);
        break;

    case JET_errWriteConflict:
        description = READ_STRING(IDS_JET_ERRWRITECONFLICT);
        break;

    case JET_wrnBufferTruncated:
        description = READ_STRING(IDS_JET_WRNBUFFERTRUNCATED);
        break;

    case JET_wrnColumnNull:
        description = READ_STRING(IDS_JET_WRNCOLUMNNULL);
        break;

    default:
        {
            const WCHAR * msg;
            if ( JetError > 0 ) {
                msg = READ_STRING (IDS_JET_WARNING);
                swprintf(jetdesc, msg, JetError);
            } else {
                msg = READ_STRING (IDS_JET_ERROR);
                swprintf(jetdesc, msg, JetError);
            }
        }
    }

    if ( description != NULL ) {
        wcscpy(jetdesc, description);
    }

    return jetdesc;

} // GetJetErrorDescription
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\scheck.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"

#include "resource.h"

CParser scheckParser;
BOOL    fScheckQuit;
BOOL    fScheckParserInitialized = FALSE;
BOOL    fVerbose = FALSE;
WCHAR   ditPath[1] = {0};

extern "C" {
VOID
StartSemanticCheck(
    IN BOOL fFixup,
    IN BOOL fVerbose
    );

VOID StartQuotaIntegrity();
VOID StartQuotaRebuild();

VOID
SCheckGetRecord(
    IN BOOL fVerbose,
    IN DWORD Dnt
    );

VOID
SFixupCnfNc(
    VOID
    );

VOID
StartFixup(
    IN BOOL fVerbose
    );

void
DoRepairSchemaConflict(void);

}

// Forward references.

extern HRESULT SCheckHelp(CArgs *pArgs);
extern HRESULT SCheckQuit(CArgs *pArgs);
extern HRESULT SetVerbose(CArgs *pArgs);
extern HRESULT DoSCheckFixup(CArgs *pArgs);
extern HRESULT DoSCheck(CArgs *pArgs);
extern HRESULT DoSCheckGetRecord(CArgs *pArgs);
extern HRESULT DoSCheckQuotaIntegrity(CArgs *pArgs);
extern HRESULT DoSCheckQuotaRebuild(CArgs *pArgs);
/*
// unused
extern HRESULT RepairSchemaConflict(CArgs *pArgs);
*/
extern HRESULT FixupCnfNc(CArgs *pArgs);


// Build a table which defines our language.

LegalExprRes scheckLanguage[] =
{
    {   L"?",
        SCheckHelp,
        IDS_HELP_MSG, 0  },

    {   L"Help",
        SCheckHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit",
        SCheckQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Verbose %s",
        SetVerbose,
        IDS_SCHECK_VERBOSE_MSG, 0 },

    {   L"Go",
        DoSCheck,
        IDS_SCHECK_GO_MSG, 0 },

    {   L"Go Fixup",
        DoSCheckFixup,
        IDS_SCHECK_GO_FIXUP_MSG, 0 },

    {   L"Get %d",
        DoSCheckGetRecord,
        IDS_SCHECK_GET_MSG, 0  },

    {   L"Check Quota",
        DoSCheckQuotaIntegrity,
        IDS_SCHECK_QUOTA_INTEGRITY_MSG, 0  },

    {   L"Rebuild Quota",
        DoSCheckQuotaRebuild,
        IDS_SCHECK_QUOTA_REBUILD_MSG, 0  }

// Future:
//    Add this is a separate entry.
//    Currently it is embedded in DoSCheckFix
//    {   L"Fix NC Conflict",
//        FixupCnfNc,
//        IDS_SCHECK_FIXUP_CNFNC, 0  }

};

HRESULT
SCheckMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    //
    // if not in safe mode and not restored, bail
    //

    if ( !IsSafeMode() || CheckIfRestored() )
    {
        return(S_OK);
    }

    if ( !fScheckParserInitialized )
    {
        cExpr = sizeof(scheckLanguage) / sizeof(LegalExprRes);


        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (scheckLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }


        // Read in our language.

        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = scheckParser.AddExpr(scheckLanguage[i].expr,
                                                  scheckLanguage[i].func,
                                                  scheckLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fScheckParserInitialized = TRUE;
    fScheckQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_SCHECK);

    hr = scheckParser.Parse(gpargc,
                            gpargv,
                            stdin,
                            stdout,
                            prompt,
                            &fScheckQuit,
                            FALSE,               // timing info
                            FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }

    // Cleanup things
    RESOURCE_STRING_FREE (prompt);


    return(hr);
}

HRESULT SCheckHelp(CArgs *pArgs)
{
    return(scheckParser.Dump(stdout,L""));
}

HRESULT SCheckQuit(CArgs *pArgs)
{
    fScheckQuit = TRUE;
    return(S_OK);
}

HRESULT SetVerbose(CArgs *pArgs)
{
    const WCHAR *pwszVal;
    HRESULT     hr;

    if ( FAILED(hr = pArgs->GetString(0, &pwszVal)) )
    {
        return(hr);
    }

    const WCHAR * message_on = READ_STRING (IDS_ON);
    const WCHAR * message_off = READ_STRING (IDS_OFF);


    if ( !_wcsicmp(message_on, pwszVal) )
    {
        fVerbose = TRUE;
        RESOURCE_PRINT (IDS_SCHECK_VERBOSE_ENABLED);
    }
    else if ( !_wcsicmp(message_off, pwszVal) )
    {
        fVerbose = FALSE;
        RESOURCE_PRINT (IDS_SCHECK_VERBOSE_DISABLED);
    }
    else
    {
        //"Invalid argument - expected \"on\" or \"off\"\n"
        RESOURCE_PRINT (IDS_INVALID_ON_OFF);
    }

    RESOURCE_STRING_FREE (message_on);
    RESOURCE_STRING_FREE (message_off);

    return(S_OK);
}

HRESULT DoSCheck(CArgs *pArgs)
{
    RESOURCE_PRINT1 (IDS_FIXUP_MSG, L"off");
    StartSemanticCheck(FALSE,fVerbose);
    return S_OK;
}

HRESULT DoSCheckFixup(CArgs *pArgs)
{
    RESOURCE_PRINT1 (IDS_FIXUP_MSG, L"on");

    //
    // Fix mangled NCs
    //
    FixupCnfNc(pArgs);

    //
    // Do Semantic check & fixup.
    //
    StartSemanticCheck(TRUE,fVerbose);

    return S_OK;
}

HRESULT DoSCheckQuotaIntegrity(CArgs *pArgs)
{
    StartQuotaIntegrity();
    return S_OK;
}

HRESULT DoSCheckQuotaRebuild(CArgs *pArgs)
{
    StartQuotaRebuild();
    return S_OK;
}

/*
// unused code from loser.c
HRESULT RepairSchemaConflict(CArgs *pArgs)
{
    DoRepairSchemaConflict();
    return S_OK;
}
*/


HRESULT DoSCheckGetRecord(CArgs *pArgs)
{
    HRESULT hr;
    DWORD dnt;

    if ( FAILED(hr = pArgs->GetInt(0, (PINT)&dnt)) )
    {
        return hr;
    }

    SCheckGetRecord(fVerbose, dnt);
    return S_OK;
}

HRESULT FixupCnfNc(CArgs *pArgs)
{
    HRESULT hr;
    DWORD dnt;

    SFixupCnfNc();

    UNREFERENCED_PARAMETER(pArgs);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\scheck.h ===
/*++
                                            
Copyright (c) 1998  Microsoft Corporation

Module Name:

    Scheck.h

Abstract:

    Semantic Checker Main Header File

Author:

    Johnson Apacible    (JohnsonA)  1-July-1998

--*/

#ifndef _SCHECK_H_
#define _SCHECK_H_

typedef struct _SUBREF_ENTRY {

   DWORD    Dnt;            // owner of subref list
   BOOL     fListed:1;      // listed on objects subref list
   BOOL     fFound:1;       // referenced by an NC

} SUBREF_ENTRY, *PSUBREF_ENTRY;
    
//
// per entry structure used for ref count checker
//

typedef struct _REFCOUNT_ENTRY {

    DWORD   Dnt;
    INT     RefCount;       // number of references
    INT     Actual;         // refcount value stored in the database
    DWORD   Pdnt;
    DWORD   NcDnt;
    WORD    InstType;
    WORD    nAncestors;
    DWORD   AncestorCrc;

    PSUBREF_ENTRY  Subrefs;
    DWORD   nSubrefs;

    BOOL    fSubRef:1;
    BOOL    fObject:1;
    BOOL    fDeleted:1;

} REFCOUNT_ENTRY, *PREFCOUNT_ENTRY;

#define REFCOUNT_HASH_MASK          0x0000FFFF
#define REFCOUNT_HASH_INCR          0x00010000

//
// The secondary hash is always odd
//

#define GET_SECOND_HASH_INCR(_dnt)  (((_dnt) >> 16) | 1)

// per entry structure for SD ref count checker
typedef struct _SD_REFCOUNT_ENTRY {
    SDID    sdId;           // SD ID
    INT     RefCount;       // count of references
    INT     Actual;         // refCount from the DB
    DWORD   cbSD;           // actual SD length
} SD_REFCOUNT_ENTRY, *PSD_REFCOUNT_ENTRY;

//
// Round allocation to a multiple of 64K
//

#define ROUND_ALLOC(_rec)   (((((_rec) + 16000 ) >> 16) + 1) << 16)

typedef struct _DNAME_TABLE_ENTRY {

    DWORD   ColId;
    ULONGLONG Value;
    DWORD   Syntax;
    PVOID   pValue;

} DNAME_TABLE_ENTRY, *PDNAME_TABLE_ENTRY;

//
// Routines
//

VOID
DoRefCountCheck(
    IN DWORD nRecs,
    IN DWORD nSDs,
    IN BOOL fFixup
    );

VOID
PrintRoutineV(
    IN LPSTR Format,
    va_list arglist
    );

BOOL
BuildRetrieveColumnForRefCount(
    VOID
    );

int __cdecl 
fnColIdSort(
    const void * keyval, 
    const void * datum
    ) ;

VOID
ProcessResults(
    IN BOOL fFixup
    );

VOID
CheckAncestors(
    IN BOOL fFixup
    );

VOID
CheckRefCount(
    IN BOOL fFixup
    );
VOID
CheckInstanceTypes(
    VOID
    );

VOID
CheckSDRefCount(
    IN BOOL fFixup
    );

VOID
CheckReplicationBlobs(
    VOID
    );

PREFCOUNT_ENTRY
FindDntEntry(
    DWORD Dnt,
    BOOL  fInsert
    );

PSD_REFCOUNT_ENTRY
FindSdEntry(
    IN SDID sdId,
    IN BOOL fInsert
    );

VOID
ValidateDeletionTime(
    IN LPSTR ObjectStr
    );

VOID
CheckAncestorBlob(
    PREFCOUNT_ENTRY pEntry
    );

VOID
CheckDeletedRecord(
    IN LPSTR ObjectStr
    );

VOID
ValidateSD(
    VOID
    );

VOID
ProcessLinkTable(
    VOID
    );

NTSTATUS
DsWaitUntilDelayedStartupIsDone(void);

DWORD
OpenJet(
    IN const char * pszFileName 
    );

JET_ERR
OpenTable (
    IN BOOL fWritable,
    IN BOOL fCountRecords,
    OUT DWORD* pNRecs,
    OUT DWORD* pNSDs
    );

VOID CloseJet(void);

VOID 
SetJetParameters (
    JET_INSTANCE *JetInst
    );

VOID
DisplayRecord(
    IN DWORD Dnt
    );

BOOL
GetLogFileName2(
    IN PCHAR Name
    );

BOOL
OpenLogFile(
    VOID
    );

VOID
CloseLogFile(
    VOID
    );

BOOL
Log(
    IN BOOL     fLog,
    IN LPSTR    Format,
    ...
    );


PWCHAR
GetJetErrString(
    IN JET_ERR JetError
    );

BOOL
ExpandBuffer(
    JET_RETRIEVECOLUMN *jetcol
    );

VOID
StartSemanticCheck(
    IN BOOL fFixup,
    IN BOOL fVerbose
    );

VOID StartQuotaIntegrity();
VOID StartQuotaRebuild();

//
// Externs
//

extern JET_INSTANCE jetInstance;
extern JET_COLUMNID    blinkid;
extern JET_COLUMNID    sdidid;
extern JET_COLUMNID    sdrefcountid;
extern JET_COLUMNID    sdvalueid;
extern JET_SESID    sesid;
extern JET_DBID	dbid;
extern JET_TABLEID  tblid;
extern JET_TABLEID  sdtblid;
extern JET_TABLEID  linktblid;
extern BOOL        VerboseMode;
extern BOOL        CheckSchema;
extern long lCount;

extern PWCHAR       szRdn;
extern DWORD        insttype;
extern BYTE         bObject;
extern ULONG        ulDnt;



// maximum number of characters that will be written to the buffer given
// by GetJetErrorDescription
#define MAX_JET_ERROR_LENGTH 128


// Attribute name for the ldap nCName attribute.
#define SZNCNAME        "ATTb131088"

// Functions used by ar.c as well.
LPWSTR
GetDN(
    IN DB_STATE *dbState,
    IN TABLE_STATE *tableState,
    IN DWORD dnt,
    IN BOOL fPrint
    );

HRESULT
FindPartitions(
    IN  DB_STATE *dbState,
    IN  TABLE_STATE *tableState,
    IN  TABLE_STATE *linkTableState,
    OUT PDWORD  pDnt
    );


#endif // _SCHECK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\sammain.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"
#include "sam.hxx"

#include "resource.h"

CParser         samParser;
BOOL            fSamQuit;
BOOL            fSamParserInitialized = FALSE;

// Build a table which defines our language.

LegalExprRes samLanguage[] = 
{
    {   L"?", 
        SamHelp,
        IDS_HELP_MSG, 0 },

    {   L"Help", 
        SamHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit", 
        SamQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Log File %s", 
        SamSpecifyLogFile, 
        IDS_SAM_SPECIFY_LOG_FILE, 0},

    {   L"Connect to server %s", 
        SamConnectToServer,
        IDS_SAM_CONNECT_SERVER_MSG, 0 },

    {   L"Check Duplicate SID",
        SamDuplicateSidCheckOnly,
        IDS_SAM_DUPLICATE_SID_CHECK_ONLY, 0 }, 

    {   L"Cleanup Duplicate SID", 
        SamDuplicateSidCheckAndCleanup, 
        IDS_SAM_DUPLICATE_SID_CLEANUP, 0 },

};

HRESULT
SamMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !fSamParserInitialized )
    {
        cExpr = sizeof(samLanguage) / sizeof(LegalExprRes);
    
        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (samLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }


        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = samParser.AddExpr(samLanguage[i].expr,
                                               samLanguage[i].func,
                                               samLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fSamParserInitialized = TRUE;
    fSamQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_SAM_MAINTENANCE);

    hr = samParser.Parse(gpargc,
                         gpargv,
                         stdin,
                         stdout,
                         prompt,
                         &fSamQuit,
                         FALSE,               // timing info
                         FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }

    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}

HRESULT SamHelp(CArgs *pArgs)
{
    return(samParser.Dump(stdout,L""));
}

HRESULT SamQuit(CArgs *pArgs)
{
    fSamQuit = TRUE;

    SamCleanupGlobals();

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\select.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"
#include "ntdsapip.h"
extern "C" {
#include "utilc.h"
}

#include "resource.h"

CParser selectParser;
BOOL    fSelectQuit;
BOOL    fSelectParserInitialized = FALSE;

// Build a table which defines our language.

LegalExprRes selectLanguage[] = 
{
    CONNECT_SENTENCE_RES

    {   L"?",
        SelectHelp,
        IDS_HELP_MSG, 0  },

    {   L"Help",
        SelectHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit",
        SelectQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"List current selections",
        SelectListCurrentSelections,
        IDS_SELECT_LIST_MSG, 0 },

    {   L"List sites",
        SelectListSites,
        IDS_SELECT_LIST_SITES_MSG, 0 },

    {   L"List roles for connected server",
        SelectListRoles,
        IDS_SELECT_LIST_ROLES_MSG, 0 },

    {   L"List servers in site",
        SelectListServersInSite,
        IDS_SELECT_LIST_SERVERS_MSG, 0 },

    {   L"List Naming Contexts",
        SelectListNamingContexts,
        IDS_SELECT_LIST_NCS_MSG, 0 },

    {   L"List domains",
        SelectListDomains,
        IDS_SELECT_LIST_DOMAINS_CR_MSG, 0 },

    {   L"List domains in site",
        SelectListDomainsInSite,
        IDS_SELECT_LIST_DOMAINS_MSG, 0 },

    {   L"List servers for domain in site",
        SelectListServersForDomainInSite,
        IDS_SELECT_LIST_DOMAIN_SRV_MSG, 0 },

    {   L"Select site %d",
        SelectSelectSite,
        IDS_SELECT_SITE_MSG, 0 },
        
    {   L"Select Naming Context %d",
        SelectSelectNamingContext,
        IDS_SELECT_NC_MSG, 0 },

    {   L"Select domain %d",
        SelectSelectDomain,
        IDS_SELECT_DOMAIN_MSG, 0 },

    {   L"Select server %d",
        SelectSelectServer,
        IDS_SELECT_SERVER_MSG, 0 }
};

HRESULT
SelectMain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    const WCHAR   *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !fSelectParserInitialized )
    {
        cExpr = sizeof(selectLanguage) / sizeof(LegalExprRes);
    

        // Load String from resource file
        //
        if ( FAILED (hr = LoadResStrings (selectLanguage, cExpr)) )
        {
             RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr));
             return (hr);
        }

        // Read in our language.
    
        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = selectParser.AddExpr(selectLanguage[i].expr,
                                                  selectLanguage[i].func,
                                                  selectLanguage[i].help)) )
            {
                RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return(hr);
            }
        }
    }

    fSelectParserInitialized = TRUE;
    fSelectQuit = FALSE;

    prompt = READ_STRING (IDS_PROMPT_SELECT);

    hr = selectParser.Parse(gpargc,
                            gpargv,
                            stdin,
                            stdout,
                            prompt,
                            &fSelectQuit,
                            FALSE,               // timing info
                            FALSE);              // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }

    // Cleanup things
    RESOURCE_STRING_FREE (prompt);

    return(hr);
}

HRESULT SelectHelp(CArgs *pArgs)
{
    return(selectParser.Dump(stdout,L""));
}

HRESULT SelectQuit(CArgs *pArgs)
{
    fSelectQuit = TRUE;
    return(S_OK);
}

#define INVALID_INDEX (-1)

DS_NAME_RESULTW *gServers = NULL;
DS_NAME_RESULTW *gServerInfo = NULL;
DS_NAME_RESULTW *gSites = NULL;
DS_NAME_RESULTW *gDomains = NULL;
DS_NAME_RESULTW *gNamingContexts = NULL;
int             giCurrentServer = INVALID_INDEX;
int             giCurrentSite = INVALID_INDEX;
int             giCurrentDomain = INVALID_INDEX;
int             giCurrentNamingContext = INVALID_INDEX;

WCHAR * SelectGetCurrentSite()
{
    if ( CHECK_IF_NOT_CONNECTED )
    {
        return(NULL);
    }

    if ( INVALID_INDEX == giCurrentSite )
    {
        //"No current site - use \"Select operation target\"\n"
        RESOURCE_PRINT (IDS_SELECT_NO_SITE1);
        
        return(NULL);
    }

    return(gSites->rItems[giCurrentSite].pName);
}

WCHAR * SelectGetCurrentNamingContext()
{
    if ( CHECK_IF_NOT_CONNECTED )
    {
        return(NULL);
    }

    if ( INVALID_INDEX == giCurrentNamingContext )
    {
        //"No current Naming Context - use \"Select operation target\"\n"
        RESOURCE_PRINT (IDS_SELECT_NO_NC1);
        return(NULL);
    }

    return(gNamingContexts->rItems[giCurrentNamingContext].pName);
}

WCHAR * SelectGetCurrentDomain()
{
    if ( CHECK_IF_NOT_CONNECTED )
    {
        return(NULL);
    }

    if ( INVALID_INDEX == giCurrentDomain )
    {
        //"No current domain - use \"Select operation target\"\n"
        RESOURCE_PRINT (IDS_SELECT_NO_DOMAIN1);
        return(NULL);
    }

    return(gDomains->rItems[giCurrentDomain].pName);
}

WCHAR * SelectGetCurrentServer()
{
    if ( CHECK_IF_NOT_CONNECTED )
    {
        return(NULL);
    }

    if ( INVALID_INDEX == giCurrentServer )
    {
        //"No current server - use \"Select operation target\"\n"
        RESOURCE_PRINT (IDS_SELECT_NO_SERVER1);

        return(NULL);
    }

    return(gServers->rItems[giCurrentServer].pName);
}

VOID
SelectCleanupGlobals()
{
    if ( ghDS )
    {
        DsUnBindW(&ghDS);
        ghDS = NULL;
    }

    if ( gServers ) 
    {
        DsFreeNameResultW(gServers);
        gServers = NULL;
    }

    if ( gServerInfo )
    {
        DsFreeNameResultW(gServerInfo);
        gServerInfo = NULL;
    }

    if ( gSites )
    {
        DsFreeNameResultW(gSites);
        gSites = NULL;
    }

    if ( gDomains )
    {
        DsFreeNameResultW(gDomains);
        gDomains = NULL;
    }
    
    if ( gNamingContexts )
    {
        DsFreeNameResultW(gNamingContexts);
        gNamingContexts = NULL;
    }

    giCurrentServer = INVALID_INDEX;
    giCurrentSite = INVALID_INDEX;
    giCurrentDomain = INVALID_INDEX;
    giCurrentNamingContext = INVALID_INDEX;
}

HRESULT
SelectListCurrentSelections(
    CArgs   *pArgs
    )
{
    DWORD   i;

    RETURN_IF_NOT_CONNECTED;

    if ( INVALID_INDEX == giCurrentSite )
    {
        //"No current site\n"
        RESOURCE_PRINT (IDS_SELECT_NO_SITE2);
    }
    else
    {
       //"Site - %ws\n"
       RESOURCE_PRINT1 (IDS_SELECT_PRINT_SITE,
               gSites->rItems[giCurrentSite].pName);
    }

    if ( INVALID_INDEX == giCurrentDomain )
    {
        //"No current domain\n"
        RESOURCE_PRINT (IDS_SELECT_NO_DOMAIN2);
    }
    else
    {
        //"Domain - %ws\n"
        RESOURCE_PRINT1 (IDS_SELECT_PRINT_DOMAIN,
               gDomains->rItems[giCurrentDomain].pName);
    }

    if ( INVALID_INDEX == giCurrentServer )
    {
        //"No current server\n"
        RESOURCE_PRINT (IDS_SELECT_NO_SERVER2);
    }
    else
    {
        //"Server - %ws\n"
        RESOURCE_PRINT1 (IDS_SELECT_PRINT_SERVER,
                  gServers->rItems[giCurrentServer].pName);

        if ( gServerInfo )
        {
            if (    (gServerInfo->cItems > DS_LIST_DSA_OBJECT_FOR_SERVER)
                 && (i = DS_LIST_DSA_OBJECT_FOR_SERVER,
                     DS_NAME_NO_ERROR == gServerInfo->rItems[i].status) )
            {
               //"\tDSA object - %ws\n"
               RESOURCE_PRINT1 (IDS_SELECT_PRINT_DSA,
                          gServerInfo->rItems[i].pName);
            }

            if (    (gServerInfo->cItems > DS_LIST_DNS_HOST_NAME_FOR_SERVER)
                 && (i = DS_LIST_DNS_HOST_NAME_FOR_SERVER,
                     DS_NAME_NO_ERROR == gServerInfo->rItems[i].status) )
            {
                //\tDNS host name - %ws\n"
                RESOURCE_PRINT1 (IDS_SELECT_PRINT_DNS,
                            gServerInfo->rItems[i].pName);
            }

            if (    (gServerInfo->cItems > DS_LIST_ACCOUNT_OBJECT_FOR_SERVER)
                 && (i = DS_LIST_ACCOUNT_OBJECT_FOR_SERVER,
                     DS_NAME_NO_ERROR == gServerInfo->rItems[i].status) )
            {
                //"\tComputer object - %ws\n"
                RESOURCE_PRINT1 (IDS_SELECT_PRINT_COMPUTER,
                           gServerInfo->rItems[i].pName);
            }
        }
    }

    if ( INVALID_INDEX == giCurrentNamingContext )
    {
        //"No current Naming Context\n"
        RESOURCE_PRINT (IDS_SELECT_NO_NC2);
    }
    else
    {
        //"Naming Context - %ws\n"
        RESOURCE_PRINT1 (IDS_SELECT_PRINT_NC,
               gNamingContexts->rItems[giCurrentNamingContext].pName);
    }

    return(S_OK);
}

HRESULT
SelectListRoles(
    CArgs   *pArgs
    )
{
    DWORD           dwErr;
    DWORD           i;
    DS_NAME_RESULTW *roles;

    RETURN_IF_NOT_CONNECTED;

    if ( dwErr = DsListRolesW(ghDS, &roles) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListRolesW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Server \"%ws\" knows about %d roles\n"
    RESOURCE_PRINT2 (IDS_SELECT_SERVER_ROLES, gpwszServer, roles->cItems);

    for ( i = 0; i < roles->cItems; i++ )
    {

        // DsListRoles should return no error or error_not_found (handled below)
        if (   DS_NAME_NO_ERROR != roles->rItems[i].status 
            && DS_NAME_ERROR_NOT_FOUND != roles->rItems[i].status )
        {
            //"Role item[%d] error 0x%x\n",
            RESOURCE_PRINT2 (IDS_SELECT_ROLE_ITEM_ERR, i, roles->rItems[i].status);
            continue;
        }

        switch ( i )
        {
        case DS_ROLE_INFRASTRUCTURE_OWNER:

            if (   DS_NAME_ERROR_NOT_FOUND == roles->rItems[i].status )
            {
                //"Infrastructure role owner cannot be found\n"
                RESOURCE_PRINT(IDS_SELECT_ROLE_INFRASTRUCTURE_NOT_FOUND);
            } else
            {
                //"Infrastructure - %ws\n"
                RESOURCE_PRINT1 (IDS_SELECT_PRINT_INFRASTR, roles->rItems[i].pName);
            }
            break;

        case DS_ROLE_SCHEMA_OWNER:

            if (   DS_NAME_ERROR_NOT_FOUND == roles->rItems[i].status )
            {
                //"Schema role owner cannot be found\n"
                RESOURCE_PRINT(IDS_SELECT_ROLE_SCHEMA_NOT_FOUND);
            } else
            {
                //"Schema - %ws\n"
                RESOURCE_PRINT1(IDS_SELECT_PRINT_SCHEMA, roles->rItems[i].pName);
            }
            break;
            
        case DS_ROLE_DOMAIN_OWNER:

            if (   DS_NAME_ERROR_NOT_FOUND == roles->rItems[i].status )
            {
                //"Domain role owner cannot be found\n"
                RESOURCE_PRINT(IDS_SELECT_ROLE_DOMAIN_NOT_FOUND);
            } else
            {
                //"Domain - %ws\n"
                RESOURCE_PRINT1 (IDS_SELECT_PRINT_DOMAIN, roles->rItems[i].pName);
            }
            break;

        case DS_ROLE_PDC_OWNER:

            if (   DS_NAME_ERROR_NOT_FOUND == roles->rItems[i].status )
            {
                //"PDC role owner cannot be found\n"
                RESOURCE_PRINT(IDS_SELECT_ROLE_PDC_NOT_FOUND);
            } else
            {
                //"PDC - %ws\n"
                RESOURCE_PRINT1 (IDS_SELECT_PRINT_PDC, roles->rItems[i].pName);
            }
            break;

        case DS_ROLE_RID_OWNER:

            if (   DS_NAME_ERROR_NOT_FOUND == roles->rItems[i].status )
            {
                //"RID role owner cannot be found\n"
                RESOURCE_PRINT(IDS_SELECT_ROLE_RID_NOT_FOUND);
            } else
            {
                //"RID - %ws\n"
                RESOURCE_PRINT1 (IDS_SELECT_PRINT_RID, roles->rItems[i].pName);
            }
            break;

        default:
            //"Unknown item %d\n"
            RESOURCE_PRINT1 (IDS_SELECT_PRINT_UNKNOWN,  i);
            break;
        }
    }

    DsFreeNameResultW(roles);
    return(S_OK);
}

HRESULT
SelectListSites(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;

    RETURN_IF_NOT_CONNECTED;

    if ( gSites )
    {
        DsFreeNameResultW(gSites);
        gSites = NULL;
        giCurrentSite = INVALID_INDEX;
    }

    if ( dwErr = DsListSitesW(ghDS, &gSites) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListSitesW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d site%s\n"
    RESOURCE_PRINT1 (IDS_SELECT_PRINT_FOUND_SITES, gSites->cItems );
           

    for ( i = 0; i < gSites->cItems; i++ )
    {
        printf("%d - %ws\n", i, gSites->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
SelectListServersInSite(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;

    RETURN_IF_NOT_CONNECTED;

    if ( !gSites )
    {
        //"No active site list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_SITE_LIST);
        return(S_OK);
    }

    if ( INVALID_INDEX == giCurrentSite )
    {
        //"No current site\n");
        RESOURCE_PRINT (IDS_SELECT_NO_SITE2);
        SelectListCurrentSelections(NULL);
        return(S_OK);
    }

    if ( gServers )
    {
        DsFreeNameResultW(gServers);
        gServers = NULL;
        giCurrentServer = INVALID_INDEX;
    }

    // Providing empty string for domain parameter returns all Servers with 
    // NTDS-DSA objects in the site.

    if ( dwErr = DsListServersForDomainInSiteW(
                                ghDS, 
                                NULL,
                                gSites->rItems[giCurrentSite].pName,
                                &gServers) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListServersForDomainInSiteW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d server%s\n"
    RESOURCE_PRINT1 (IDS_SELECT_PRINT_FOUND_SERVERS, gServers->cItems);

    for ( i = 0; i < gServers->cItems; i++ )
    {
        printf("%d - %ws\n", i, gServers->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
SelectListDomainsInSite(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;

    RETURN_IF_NOT_CONNECTED;

    if ( !gSites )
    {
        //"No active site list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_SITE_LIST);
        return(S_OK);
    }

    if ( INVALID_INDEX == giCurrentSite )
    {
        //"No current site\n");
        RESOURCE_PRINT (IDS_SELECT_NO_SITE2);
        SelectListCurrentSelections(NULL);
        return(S_OK);
    }

    if ( gDomains )
    {
        DsFreeNameResultW(gDomains);
        gDomains = NULL;
        giCurrentDomain = INVALID_INDEX;
    }

    if ( dwErr = DsListDomainsInSiteW(
                                ghDS, 
                                gSites->rItems[giCurrentSite].pName,
                                &gDomains) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListDomainsInSiteW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d domain%s\n"
    RESOURCE_PRINT1 (IDS_SELECT_PRINT_FOUND_DOMAINS, gDomains->cItems);

    for ( i = 0; i < gDomains->cItems; i++ )
    {
        printf("%d - %ws\n", i, gDomains->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
SelectListNamingContexts(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;
    LPCWSTR dummy = L"dummy";

    RETURN_IF_NOT_CONNECTED;

    if ( gNamingContexts )
    {
        DsFreeNameResultW(gNamingContexts);
        gNamingContexts = NULL;
        giCurrentNamingContext = INVALID_INDEX;
    }

    if ( dwErr = DsCrackNamesW(ghDS,
                               DS_NAME_NO_FLAGS,
                               (DS_NAME_FORMAT)DS_LIST_NCS,
                               DS_FQDN_1779_NAME,
                               1,
                               &dummy,
                               &gNamingContexts) ) {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsCrackNamesW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d Naming Context(s)\n"
    RESOURCE_PRINT1 (IDS_SELECT_PRINT_FOUND_NCS, gNamingContexts->cItems);

    for ( i = 0; i < gNamingContexts->cItems; i++ )
    {
        printf("%d - %S\n", i, gNamingContexts->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
SelectListDomains(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;

    RETURN_IF_NOT_CONNECTED;

    if ( gDomains )
    {
        DsFreeNameResultW(gDomains);
        gDomains = NULL;
        giCurrentDomain = INVALID_INDEX;
    }

    if ( dwErr = DsListDomainsInSiteW(
                                ghDS, 
                                NULL, 
                                &gDomains) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListDomainsInSiteW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d domain%s\n"
    RESOURCE_PRINT1 (IDS_SELECT_PRINT_FOUND_DOMAINS, gDomains->cItems);

    for ( i = 0; i < gDomains->cItems; i++ )
    {
        printf("%d - %ws\n", i, gDomains->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
SelectListServersForDomainInSite(
    CArgs   *pArgs
    )
{
    DWORD   dwErr;
    DWORD   i;

    RETURN_IF_NOT_CONNECTED;

    if ( !gSites )
    {
        //"No active site list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_SITE_LIST);
        return(S_OK);
    }

    if ( INVALID_INDEX == giCurrentSite )
    {
        //"No current site\n");
        RESOURCE_PRINT (IDS_SELECT_NO_SITE2);
        SelectListCurrentSelections(NULL);
        return(S_OK);
    }

    if ( !gDomains )
    {
        //"No active domain list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_DOMAIN_LIST);
        return(S_OK);
    }

    if ( INVALID_INDEX == giCurrentDomain )
    {
        // "No current domain\n"
        RESOURCE_PRINT (IDS_SELECT_NO_DOMAIN2);
        SelectListCurrentSelections(NULL);
        return(S_OK);
    }

    if ( gServers )
    {
        DsFreeNameResultW(gServers);
        gServers = NULL;
        giCurrentServer = INVALID_INDEX;
    }

    if ( dwErr = DsListServersForDomainInSiteW(
                                ghDS, 
                                gDomains->rItems[giCurrentDomain].pName,
                                gSites->rItems[giCurrentSite].pName,
                                &gServers) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListServersForDomainInSiteW", dwErr, GetW32Err(dwErr));
        return(S_OK);
    }

    //"Found %d server%s\n"
    RESOURCE_PRINT1 (IDS_SELECT_PRINT_FOUND_SERVERS, gServers->cItems);


    for ( i = 0; i < gServers->cItems; i++ )
    {
        printf("%d - %ws\n", i, gServers->rItems[i].pName);
    }

    return(S_OK);
}

HRESULT
SelectSelectSite(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    DWORD   num;

    if ( !gSites )
    {
        //"No active site list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_SITE_LIST);
        return(S_OK);
    }

    if ( FAILED(hr = pArgs->GetInt(0, (int *) &num)) )
    {
        return(hr);
    }

    if ( num >= gSites->cItems )
    {
        //"Selection out of range\n"
        RESOURCE_PRINT (IDS_SELECT_SEL_OUT_OF_RANGE);
        return(S_OK);
    }

    giCurrentSite = num;
    SelectListCurrentSelections(NULL);
    return(S_OK);
}

HRESULT
SelectSelectServer(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    DWORD   num;
    DWORD   dwErr;

    if ( !gServers )
    {
        //"No active server list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_SERVER_LIST);
        return(S_OK);
    }

    if ( FAILED(hr = pArgs->GetInt(0, (int *) &num)) )
    {
        return(hr);
    }

    if ( num >= gServers->cItems )
    {
        //"Selection out of range\n"
        RESOURCE_PRINT (IDS_SELECT_SEL_OUT_OF_RANGE);
        return(S_OK);
    }

    giCurrentServer = num;

    if ( dwErr = DsListInfoForServerW(
                                ghDS, 
                                gServers->rItems[giCurrentServer].pName,
                                &gServerInfo) )
    {
        RESOURCE_PRINT3 (IDS_GENERAL_ERROR1, "DsListInfoForServerW", dwErr, GetW32Err(dwErr));
        
        //"Continuing ...\n"
        RESOURCE_PRINT (IDS_CONTINUING);
    }

    SelectListCurrentSelections(NULL);
    return(S_OK);
}

HRESULT
SelectSelectNamingContext(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    DWORD   num;

    if ( !gNamingContexts )
    {
        //"No active domain list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_NC_LIST);
        return(S_OK);
    }

    if ( FAILED(hr = pArgs->GetInt(0, (int *) &num)) )
    {
        return(hr);
    }

    if ( num >= gNamingContexts->cItems )
    {
        //"Selection out of range\n"
        RESOURCE_PRINT (IDS_SELECT_SEL_OUT_OF_RANGE);
        return(S_OK);
    }

    giCurrentNamingContext = num;
    SelectListCurrentSelections(NULL);
    return(S_OK);
}

HRESULT
SelectSelectDomain(
    CArgs   *pArgs
    )
{
    HRESULT hr;
    DWORD   num;

    if ( !gDomains )
    {
        //"No active domain list\n"
        RESOURCE_PRINT (IDS_SELECT_NO_ACTIVE_DOMAIN_LIST);
        return(S_OK);
    }

    if ( FAILED(hr = pArgs->GetInt(0, (int *) &num)) )
    {
        return(hr);
    }

    if ( num >= gDomains->cItems )
    {
        //"Selection out of range\n"
        RESOURCE_PRINT (IDS_SELECT_SEL_OUT_OF_RANGE);
        return(S_OK);
    }

    giCurrentDomain = num;
    SelectListCurrentSelections(NULL);
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\setpath.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include <accctrl.h>
#include <aclapi.h>

#include "ntdsutil.hxx"
#include "dsconfig.h"
#include "connect.hxx"

#include "resource.h"

BOOL fSecurityPrivilegeEnabled = FALSE;

DWORD EnableSecurityPrivilege() {
    TOKEN_PRIVILEGES EnableSeSecurity;
    TOKEN_PRIVILEGES Previous;
    DWORD PreviousSize;
    HANDLE ProcessTokenHandle;
    DWORD dwErr = 0;

    if (fSecurityPrivilegeEnabled) {
        return 0;
    }

    if(!OpenProcessToken(
            GetCurrentProcess(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            &ProcessTokenHandle)) {
        dwErr = GetLastError();
        RESOURCE_PRINT3 (IDS_ERR_GENERIC_FAILURE, L"OpenProcessToken", dwErr, GetW32Err(dwErr));
    }
    else {
        EnableSeSecurity.PrivilegeCount = 1;
        EnableSeSecurity.Privileges[0].Luid.LowPart =
            SE_SECURITY_PRIVILEGE;
        EnableSeSecurity.Privileges[0].Luid.HighPart = 0;
        EnableSeSecurity.Privileges[0].Attributes =
            SE_PRIVILEGE_ENABLED;
        PreviousSize = sizeof(Previous);

        if ( !AdjustTokenPrivileges(ProcessTokenHandle,
                                    FALSE, // Don't disable all
                                    &EnableSeSecurity,
                                    sizeof(EnableSeSecurity),
                                    &Previous,
                                    &PreviousSize ) ) {
            dwErr = GetLastError();
            RESOURCE_PRINT3 (IDS_ERR_GENERIC_FAILURE, L"AdjustTokenPrivileges", dwErr, GetW32Err(dwErr));
        }

        CloseHandle(ProcessTokenHandle);
    }
    fSecurityPrivilegeEnabled = dwErr == 0;
    return dwErr;
}

// DC default security template
#define SECURITY_TEMPLATE "\\inf\\defltdc.inf"
#define SECURITY_TEMPLATE_LEN (sizeof(SECURITY_TEMPLATE)/sizeof(CHAR))

HRESULT SetDefaultFolderSecurity(CArgs* args) {
    CHAR  szTemplatePath[MAX_PATH+20];
    BOOL  fIsDir;
    DWORD dwErr;
    DWORD dwValue = 1;
    HKEY  hKey = NULL;

    // construct the template name
    // read the security template
    if (GetWindowsDirectoryA(szTemplatePath, sizeof(szTemplatePath)) == 0) {
        dwErr = GetLastError();
        RESOURCE_PRINT3 (IDS_ERR_GENERIC_FAILURE, L"GetWindowsDirectory", dwErr, GetW32Err(dwErr));
        goto exit;
    }
    // make sure we have enough space in the path
    if (strlen(szTemplatePath) + SECURITY_TEMPLATE_LEN >= sizeof(szTemplatePath)) {
        RESOURCE_PRINT3 (IDS_ERR_GENERIC_FAILURE, L"Security template path is too long", 0, L"");
        goto exit;
    }
    strcat(szTemplatePath, SECURITY_TEMPLATE);

    // check if the template is there
    if (!ExistsFile(szTemplatePath, &fIsDir) || fIsDir) {
        // template file is not found
        RESOURCE_PRINT1 (IDS_ERR_TEMPLATE_NOT_FOUND, szTemplatePath);
        goto exit;
    }

    // OK, the template is in place. Set the reg key for NTDSA to update the security.

    // Open the DS parameters key.

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, 
                        DSA_CONFIG_SECTION, 
                        &hKey);

    if ( ERROR_SUCCESS != dwErr )
    {
        //"%d(%s) opening registry key \"%s\"\n"
        RESOURCE_PRINT3 (IDS_ERR_OPENING_REGISTRY,
                dwErr, GetW32Err(dwErr),
                DSA_CONFIG_SECTION);
        return(S_OK);
    }
    
    dwErr = RegSetValueEx(  hKey, 
                            DSA_UPDATE_FOLDER_SECURITY, 
                            0, 
                            REG_DWORD, 
                            (BYTE *) &dwValue, 
                            sizeof(dwValue));

    if ( ERROR_SUCCESS != dwErr )
    {
        //"%d(%s) writing \"%s\" to \"%s\"\n"

        RESOURCE_PRINT4 (IDS_ERR_WRITING_REG_KEY,
                dwErr, GetW32Err(dwErr),
                L"1",
                DSA_UPDATE_FOLDER_SECURITY);
        goto exit;
    }

    RESOURCE_PRINT(IDS_FILES_UPDATE_SECURITY_MSG);

exit:
    if (hKey) {
        RegCloseKey(hKey);
    }
    return S_OK;
}

DWORD UpdateFolderSecurity(PCHAR szNewValue, PCHAR szOldValue, PCHAR label) {
    BOOL fIsDir;
    DWORD dwErr = 0;
    PACL dacl, sacl;
    PSECURITY_DESCRIPTOR pSD = NULL;
    SECURITY_INFORMATION si;
    SECURITY_DESCRIPTOR_CONTROL sdControl;
    DWORD dwRevision;
    PCHAR pLastSlash = NULL;

    if (strcmp(label, FILEPATH_KEY) == 0) {
        // we need to trim the filename
        // convert DB file path to a folder path
        pLastSlash = strrchr(szOldValue, '\\');
        if (pLastSlash != NULL) {
            *pLastSlash = '\0';
        }
        // remember pLastSlash -- we will need to restore the value
        pLastSlash = strrchr(szNewValue, '\\');
        if (pLastSlash != NULL) {
            *pLastSlash = '\0';
        }
    }

    if (_stricmp(szNewValue, szOldValue) == 0) {
        // same folder, nothing to do
        goto exit;
    }

    // check if the old folder exists
    if (!ExistsFile(szOldValue, &fIsDir) || !fIsDir) {
        // the old folder is not present. Set default security
        RESOURCE_PRINT1(IDS_WRN_OLD_LOCATION_UNAVAILABLE, szOldValue);
        SetDefaultFolderSecurity(NULL);
        goto exit;
    }

    dwErr = EnableSecurityPrivilege();
    if (dwErr) {
        // error already logged
        goto exit;
    }

    // ok, the old folder is there. Attempt to copy the SD from the old one to the new one.
    RESOURCE_PRINT2(IDS_FILES_UPDATING_SECURITY, szOldValue, szNewValue);

    si = DACL_SECURITY_INFORMATION | SACL_SECURITY_INFORMATION;

    dwErr = GetNamedSecurityInfo(
        szOldValue, 
        SE_FILE_OBJECT, 
        si,
        NULL,
        NULL,
        &dacl,
        &sacl,
        &pSD);
    if (dwErr) {
        RESOURCE_PRINT3 (IDS_ERR_GENERIC_FAILURE, L"GetNamedSecurityInfo", dwErr, GetW32Err(dwErr));
        goto exit;
    }

    // grab SD control
    if (!GetSecurityDescriptorControl(pSD, &sdControl, &dwRevision)) {
        dwErr = GetLastError();
        RESOURCE_PRINT3 (IDS_ERR_GENERIC_FAILURE, L"GetSecurityDescriptorControl", dwErr, GetW32Err(dwErr));
        goto exit;
    }
    // set the dacl protection flags
    if (sdControl & SE_DACL_PROTECTED) {
        // need to protect DACL
        si |= PROTECTED_DACL_SECURITY_INFORMATION;
    }
    if ((sdControl & SE_DACL_AUTO_INHERIT_REQ) || (sdControl & SE_DACL_AUTO_INHERITED)) {
        // need to unprotect DACL
        si |= UNPROTECTED_DACL_SECURITY_INFORMATION;
    }
    // set the sacl protection flags
    if (sdControl & SE_SACL_PROTECTED) {
        // need to protect SACL
        si |= PROTECTED_SACL_SECURITY_INFORMATION;
    }
    if ((sdControl & SE_SACL_AUTO_INHERIT_REQ) || (sdControl & SE_SACL_AUTO_INHERITED)) {
        // need to unprotect SACL
        si |= UNPROTECTED_SACL_SECURITY_INFORMATION;
    }

    dwErr = SetNamedSecurityInfo(
        szNewValue,
        SE_FILE_OBJECT,
        si,
        NULL,
        NULL,
        dacl,
        sacl);
    if (dwErr) {
        RESOURCE_PRINT3 (IDS_ERR_GENERIC_FAILURE, L"SetNamedSecurityInfo", dwErr, GetW32Err(dwErr));
        goto exit;
    }

exit:
    if (pSD) {
        LocalFree(pSD);
    }

    if (pLastSlash) {
        // restore szNewValue
        *pLastSlash = '\\';
    }

    return dwErr;
}


// A generic warning popup defined in fsmoxfer.cxx
DWORD EmitWarningAndPrompt(UINT WarningMsgId);

BOOL
CheckPathExists(PCHAR szPath, BOOL isDir) {
    BOOL fIsDir;
    BOOL fExists = FALSE;
    if (ExistsFile(szPath, &fIsDir)) {
        // check it's the correct type
        // ExistsFile does not really return a BOOL so we can not simply compare them, thus !
        fExists = (!isDir) == (!fIsDir);
    }
    if (!fExists) {
        if (EmitWarningAndPrompt(isDir ? IDS_WRN_FOLDER_NOT_FOUND : IDS_WRN_FILE_NOT_FOUND) != 0) {
            return FALSE;
        }
    }
    return TRUE;
}

HRESULT
SetPathAny(
    CArgs   *pArgs,
    char    *label
    )
/*++

  Routine Description: 

    Sets any value under the ...\Services\NTDS\Parameters registry key.
    All values are assumed to be REG_SZ.

  Parameters: 

    pArgs - Pointer to argument from original "set path ..." call.

    label - Name of value to update.

  Return Values:

    Always S_OK unless reading original arguments fails.

--*/
{
    const WCHAR     *pwszVal;
    char            *pszVal;
    HRESULT         hr;
    DWORD           cb, dwType;
    DWORD           dwErr;
    HKEY            hKey = NULL;
    CHAR            szPrevValue[MAX_PATH];

    if ( FAILED(hr = pArgs->GetString(0, &pwszVal)) )
    {
        return(hr);
    }

    // Convert arguments from WCHAR to CHAR.

    cb = wcslen(pwszVal) + 1;
    pszVal = (char *) alloca(cb);
    memset(pszVal, 0, cb);
    wcstombs(pszVal, pwszVal, wcslen(pwszVal));
    DsNormalizePathName(pszVal);

    // check if the specified file/folder exists
    if (strcmp(label, FILEPATH_KEY) == 0) {
        // check if file exists
        if (!CheckPathExists(pszVal, FALSE)) {
            return S_OK;
        }
    }
    else if (strcmp(label, LOGPATH_KEY) == 0 || strcmp(label, JETSYSTEMPATH_KEY) == 0) {
        // check if folder exists
        if (!CheckPathExists(pszVal, TRUE)) {
            return S_OK;
        }
    }

    // Open the DS parameters key.

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE, 
                        DSA_CONFIG_SECTION, 
                        &hKey);

    if ( ERROR_SUCCESS != dwErr )
    {
        //"%d(%s) opening registry key \"%s\"\n"
        RESOURCE_PRINT3 (IDS_ERR_OPENING_REGISTRY,
                dwErr, GetW32Err(dwErr),
                DSA_CONFIG_SECTION);
        goto exit;
    }
    
    cb = sizeof(szPrevValue);
    dwErr = RegQueryValueEx( hKey,
                             label,
                             0,
                             &dwType,
                             (BYTE*) szPrevValue,
                             &cb);

    if ( ERROR_SUCCESS != dwErr )
    {
        //"%s %d(%s) reading %s\\%s\n"
        RESOURCE_PRINT4(IDS_WRN_READING, 
                dwErr, GetW32Err(dwErr),
                DSA_CONFIG_SECTION,
                label);
        // assume there is no prev location
        szPrevValue[0] = '\0';
    } 
    else if ( cb > sizeof(szPrevValue) )
    {
        // "%s buffer overflow reading %s\\%s\n"
        RESOURCE_PRINT2(IDS_ERR_BUFFER_OVERFLOW,
                DSA_CONFIG_SECTION,
                label);
        goto exit;
    }
    
    // attempt to update folder security by copying the SD from the old folder.
    // If this fails (for example, the old folder does not exist), then
    // set a registry key so that NTDSA updates the security from the
    // default security template on normal boot.
    dwErr = UpdateFolderSecurity(pszVal, szPrevValue, label);
    if (dwErr) {
        // error already logged
        goto exit;
    }

    dwErr = RegSetValueEx(  hKey, 
                            label, 
                            0, 
                            REG_SZ, 
                            (BYTE *) pszVal, 
                            strlen(pszVal) + 1);

    if ( ERROR_SUCCESS != dwErr )
    {
        //"%d(%s) writing \"%s\" to \"%s\"\n"

        RESOURCE_PRINT4 (IDS_ERR_WRITING_REG_KEY,
                dwErr, GetW32Err(dwErr),
                pszVal,
                label);
        goto exit;
    }

exit:
    if (hKey) {
        RegCloseKey(hKey);
    }

    return S_OK;
}

HRESULT
SetPathDb(
    CArgs   *pArgs)
{
    return(SetPathAny(pArgs, FILEPATH_KEY));
}

HRESULT
SetPathBackup(
    CArgs   *pArgs)
{
    return(SetPathAny(pArgs, BACKUPPATH_KEY));
}

HRESULT
SetPathLogs(
    CArgs   *pArgs)
{
    return(SetPathAny(pArgs, LOGPATH_KEY));
}

HRESULT
SetPathSystem(
    CArgs   *pArgs)
{
    return(SetPathAny(pArgs, JETSYSTEMPATH_KEY));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\oid\oid.c ===
/********************************************************************/
/**               Copyright(c) Microsoft Corp., 1996               **/
/**                     All Rights Reserverd                       **/
/**                                                                **/
/** Author: DonH                                                   **/
/** Description: Tool to BER encode and decode OIDs                **/
/**                                                                **/
/********************************************************************/

#include <ntdspch.h>
#pragma hdrstop
#include <assert.h>

#define MAX_OID_VALS 15		// who knows?

typedef struct _OID {
    int cVal;
    unsigned Val[MAX_OID_VALS];
} OID;

/*++ EncodeOID
 *
 * Takes an OID in structure format and constructs a BER encoded octet
 * string representing that OID.
 *
 * INPUT:
 *    pOID     - Pointer to an OID structure to be encoded
 *    pEncoded - Pointer to a *preallocated* buffer that will hold the
 *               encoded octet string.  Sould be at least 4*MAX_OID_VALS long
 *
 * OUTPUT:
 *    pEncoded - Buffer holds the encoded OID
 *
 * RETURN VALUE:
 *    0        - Value could not be encoded (bad OID)
 *    non-0    - Length of resulting octet string, in bytes
 */
unsigned EncodeOID(OID *pOID, unsigned char * pEncoded){
    int i;
    unsigned len;
    unsigned val;

    // check for obviously invalid OIDs

    if (pOID->cVal <= 2 ||
	pOID->Val[0] > 2 ||
	pOID->Val[1] > 40) {
	return 0;		// error
    }

    // The first two values in the OID are encoded into a single octet
    // by a really appalling rule, as shown here.

    *pEncoded = (pOID->Val[0] * 40) + pOID->Val[1];
    len = 1;

    // For all subsequent values, each is encoded across multiple bytes
    // in big endian order (MSB first), seven bits per byte, with the
    // high bit being clear on the last byte, and set on all others.

    for (i=2; i<pOID->cVal; i++) {
	val = pOID->Val[i];

	if (val > ((0x7f << 14) | (0x7f << 7)| 0x7f)) {
	    // Do we need 4 octets to represent the value?
	    // Make sure it's not 5
	    assert(0 == (val & ~((0x7f << 21) | (0x7f << 14) | (0x7f << 7) | 0x7f)));
	    if (val & ~((0x7f << 21) | (0x7f << 14) | (0x7f << 7) | 0x7f)) {
		return 0;	// we can't encode things this big
	    }
	    pEncoded[len++] = 0x80 | ((val >> 21) & 0x7f);
	}
	if (val > ((0x7f << 7)| 0x7f)) {
	    // Do we need 3 octets to represent the value?
	    pEncoded[len++] = 0x80 | ((val >> 14) & 0x7f);
	}
	if (val > 0x7f) {
	    // Do we need 2 octets to represent the value?
	    pEncoded[len++] = 0x80 | ((val >> 7) & 0x7f);
	}
	// Encode the low 7 bits into the last octet for this value
	pEncoded[len++] = val & 0x7f;
    }

    return len;		
}

/*++ DecodeOID
 *
 * Takes a BER encoded OID as an octet string and returns the OID in 
 * structure format.
 *
 * INPUT:
 *    pEncoded - Pointer to a buffer holding the encoded octet string.
 *    len      - Length of the encoded OID
 *    pOID     - Pointer to a *preallocated* OID structure that will
 *               be filled in with the decoded OID.
 *
 * OUTPUT:
 *    pOID     - Structure is filled in with the decoded OID
 *
 * RETURN VALUE:
 *    0        - value could not be decoded (bad OID)
 *    non-0    - OID decoded successfully
 */
BOOL DecodeOID(unsigned char *pEncoded, int len, OID *pOID) {
    unsigned cval;
    unsigned val;
    int i, j;

    if (len <=2) {
	return FALSE;
    }

    // The first two values are encoded in the first octet.

    pOID->Val[0] = pEncoded[0] / 40;
    pOID->Val[1] = pEncoded[0] % 40;
    cval = 2;
    i = 1;

    while (i < len) {
	j = 0;
	val = pEncoded[i] & 0x7f;
	while (pEncoded[i] & 0x80) {
	    val <<= 7;
	    ++i;
	    if (++j > 4 || i >= len) {
		// Either this value is bigger than we can handle (we
		// don't handle values that span more than four octets)
		// -or- the last octet in the encoded string has its
		// high bit set, indicating that it's not supposed to 
		// be the last octet.  In either case, we're sunk.
		return FALSE;
	    }
	    val |= pEncoded[i] & 0x7f;
	}
	assert(i < len);
	pOID->Val[cval] = val;
	++cval;
	++i;
    }
    pOID->cVal = cval;

    return TRUE;
}



#define iswdigit(x) ((x) >= '0' && (x) <= '9')

OidStringToStruct( char * pString, unsigned len, OID * pOID)
{
    int i;
    unsigned val;
    char * pCur = pString;
    char * pEnd = pString + len;

    if ((*pCur != 'O' && *pCur != 'o') ||
	(*++pCur != 'I' && *pCur != 'i') ||
	(*++pCur != 'D' && *pCur != 'd') ||
	(*++pCur != '.')) {
	return 1;
    }

    pOID->cVal = 0;

    while (++pCur < pEnd) {
	if (!iswdigit(*pCur)) {
	    return 2;
	}
	val = *pCur - '0';
	++pCur;
	while (pCur < pEnd && *pCur != '.') {
	    if (!iswdigit(*pCur)) {
		return 3;
	    }
	    val = 10*val + *pCur - '0';
	    ++pCur;
	}
	pOID->Val[pOID->cVal] = val;
	pOID->cVal++;
    }

    return 0;
}

unsigned OidStructToString(OID *pOID, char *pOut)
{
    int i;
    char *pCur = pOut;

    *pCur++ = 'O';
    *pCur++ = 'I';
    *pCur++ = 'D';

    for (i=0; i<pOID->cVal; i++) {
	*pCur++ = '.';
	_ultoa(pOID->Val[i], pCur, 10);
	while (*pCur) {
	    ++pCur;
	}
    }
    return pCur - pOut;
}

#define HexToC(x) (((x) >= '0' && (x) <= '9') ? (x) - '0' : tolower((x)) - 'a' + 10)

void __cdecl main(int argc, char ** argv)
{
    OID oid;
    unsigned char buf[128];
    int i, len;
    char * p;

    if (argc != 2) {
	printf("usage: %s <oid>\nwhere <oid> is either "
	       "encoded ('550403') or not ('OID.2.5.4.3')\n", 
	       argv[0]);
	exit(__LINE__);
    }

    if (argv[1][0] == 'O' || argv[1][0] == 'o') {
	OidStringToStruct(argv[1], strlen(argv[1]), &oid);
	len = EncodeOID(&oid, buf);
	printf("encoded oid is: 0x");
	for (i=0; i<len; i++) {
	    printf("%02X", buf[i]);
	}
	printf("\n");
    }
    else {
	len = strlen(argv[1]);
	if (len % 2) {
	    printf("odd length string?\n");
	    exit(__LINE__);
	}

	p = argv[1];
	if ((p[0] == '\\' || p[0] == '0') &&
	    (p[1] == 'x')) {
	    len -= 2;
	    p += 2;
	}

	for (i=0; i<len; i+=2) {
	    buf[i/2] = HexToC(p[i]) * 16 + HexToC(p[i+1]);
	}

	DecodeOID(buf, len/2, &oid);
	i = OidStructToString(&oid, buf);
	buf[i] = '\0';
	printf("decoded oid is: %s\n", buf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\setpwd.cxx ===
/*++
Copyright (c) 1999 Microsoft Corporation

Module Name:

    setpwd.cxx

Abstract:

    
Author:

    ShaoYin

Revision History

    14-May-01 Created

--*/





#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "connect.hxx"
#include "select.hxx"
#include "sam.hxx"

extern "C" {
// Core DSA headers.
#include <ntdsa.h>
#include <scache.h>
#include <prefix.h>
#include <dbglobal.h>                   // The header for the directory database
#include <mdglobal.h>                   // MD global definition header
#include <mappings.h>

#include "ntsam.h"
#include "ntldap.h"
#include "winldap.h"
#include "ntlsa.h"
#include "lmcons.h"         // MAPI constants req'd for lmapibuf.h
#include "lmapibuf.h"       // NetApiBufferFree()
#include "lmerr.h"          // NetValidatePasswordPolicy()
#include "lmaccess.h"       // NetValidatePasswordPolicy()
}                   


#include "resource.h"



////////////////////////////////////////////////////////////////
//                                                            //
//          Defines                                           //
//                                                            //
////////////////////////////////////////////////////////////////


typedef ULONG (WINAPI *SamSetDSRMPwdFuncPtr)(
    PUNICODE_STRING ServerName, 
    ULONG UserId, 
    PUNICODE_STRING ClearPassword
    );

typedef NET_API_STATUS (*NetValidatePwdFuncPtr)(
    IN LPCWSTR ServerName, 
    IN LPVOID Qualifier, 
    IN NET_VALIDATE_PASSWORD_TYPE ValidationType, 
    IN LPVOID InputArg, 
    OUT LPVOID *OutputArg 
    );

typedef NET_API_STATUS (*NetValidatePwdFreeFuncPtr)(
    IN LPVOID *OutputArg
    );


#define CR                  0xD
#define BACKSPACE           0x8





//////////////////////////////////////////////////
//                                              //
// Global Varialbes                             //
//                                              //
//////////////////////////////////////////////////



CParser         setPwdParser;
BOOL            fSetPwdQuit;
BOOL            fSetPwdParserInitialized = FALSE;


 


// Build a table which defines our language.

LegalExprRes setPwdLanguage[] = 
{
    {   L"?", 
        SetPwdHelp,
        IDS_HELP_MSG, 0 },

    {   L"Help", 
        SetPwdHelp,
        IDS_HELP_MSG, 0 },

    {   L"Quit", 
        SetPwdQuit,
        IDS_RETURN_MENU_MSG, 0 },

    {   L"Reset Password on server %s", 
        SetDSRMPwdWorker,
        IDS_SET_DSRM_PWD_ON_SERVER, 0 },

};

HRESULT SetDSRMPwdMain(
    CArgs *pArgs
    )
{
    HRESULT hr;
    const WCHAR *prompt;
    int     cExpr;
    char    *pTmp;

    if ( !fSetPwdParserInitialized )
    {
        cExpr = sizeof(setPwdLanguage) / sizeof(LegalExprRes);

        //
        // load string from resource file
        //
        if ( FAILED (hr = LoadResStrings(setPwdLanguage, cExpr)) )
        {
            RESOURCE_PRINT3( IDS_GENERAL_ERROR1, "LoadResStrings", hr, GetW32Err(hr) );
            return( hr );
        }

        // Read in our language.

        for ( int i = 0; i < cExpr; i++ )
        {
            if ( FAILED(hr = setPwdParser.AddExpr(setPwdLanguage[i].expr, 
                                                  setPwdLanguage[i].func,
                                                  setPwdLanguage[i].help)) )
            {
                RESOURCE_PRINT3(IDS_GENERAL_ERROR1, "AddExpr", hr, GetW32Err(hr));
                return( hr );
            }
        }
    }

    fSetPwdParserInitialized = TRUE;
    fSetPwdQuit = FALSE;

    prompt = READ_STRING( IDS_PROMPT_SET_DSRM_PWD );

    hr = setPwdParser.Parse(gpargc,
                            gpargv,
                            stdin,
                            stdout,
                            prompt,
                            &fSetPwdQuit,
                            FALSE,          // timing info
                            FALSE);         // quit on error

    if ( FAILED(hr) ) {
        RESOURCE_PRINT3( IDS_GENERAL_ERROR1, gNtdsutilPath, hr, GetW32Err(hr));
    }

    // cleanup local resource
    RESOURCE_STRING_FREE( prompt );

    return( hr );
}


HRESULT SetPwdHelp(CArgs *pArgs)
{
    return(setPwdParser.Dump(stdout,L""));
}

HRESULT SetPwdQuit(CArgs *pArgs)
{
    fSetPwdQuit = TRUE;

    return(S_OK);
}


ULONG
CheckBlankPassword(
    BOOL *fContinue
    )
/*++
Routine Description:

    this routine warns the user that the password typed is blank password, and
    ask the user to confirm whether he/she wants to continue or not to use the 
    blank password

Parameter:
    
    fContinue - used to return whether the caller routines should continue or 
                stop. 

Return Value:
    
    Win32 code              

--*/
{
    ULONG       WinError = ERROR_SUCCESS;
    HANDLE      InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    DWORD       OriginalMode = 0;
    WCHAR       InputChar = L'\0';
    DWORD       NumRead = 0;
    BOOL        Success = TRUE; 


    // init return value
    *fContinue = FALSE;


    // set STD input mode
    GetConsoleMode(InputHandle, &OriginalMode);
    SetConsoleMode(InputHandle, (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & OriginalMode);

    // read from std input
    RESOURCE_PRINT( IDS_SET_DSRM_PWD_BLANK_PWD );
    Success = ReadConsoleW(InputHandle, &InputChar, 1, &NumRead, NULL);


    // can't read from console
    if ( !Success || (1 != NumRead) )
    {
        WinError = GetLastError();
    }
    else if ( (L'Y' == InputChar) || (L'y' == InputChar) )
    {
        // user wants to continue
        *fContinue = TRUE;
    }

    // cleanup
    SetConsoleMode(InputHandle, OriginalMode);
    FlushConsoleInputBuffer( InputHandle );
    putchar(InputChar);
    putchar(L'\n');
    putchar(L'\n');

    
    return( WinError );

}




HRESULT SetDSRMPwdWorker(
    CArgs *pArgs
    )
/*++

--*/
{
    HRESULT         hr;
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    ULONG           WinError = ERROR_SUCCESS;
    WCHAR           Password[MAX_NT_PASSWORD];
    WCHAR           ConfirmPassword[MAX_NT_PASSWORD];
    PWCHAR          pTmp = NULL;
    UNICODE_STRING  ClearPassword;
    UNICODE_STRING  ServerName;
    UNICODE_STRING  *pServerName = NULL;
    BOOL            fContinue = FALSE;
    HMODULE                 SamLibModule = NULL;
    SamSetDSRMPwdFuncPtr    SetPasswordProc = NULL;



    //
    // parse input parameters, get target DC name
    // 

    if ( FAILED(hr = pArgs->GetString(0, (const WCHAR **)&pTmp)) )
    {
        return( hr );
    }

    if (!_wcsnicmp(pTmp, L"NULL", 4) ||
        !_wcsnicmp(pTmp, L"\"NULL\"", 6) )
    {
        RtlInitUnicodeString(&ServerName, NULL);
        pServerName = NULL;
    }
    else
    {
        RtlInitUnicodeString(&ServerName, pTmp);
        pServerName = &ServerName;
    }


    //
    // get password from standard input
    // 

    RESOURCE_PRINT( IDS_PROMPT_INPUT_PASSWORD );

    SecureZeroMemory(Password, MAX_NT_PASSWORD * sizeof(WCHAR));

    WinError = GetPasswordFromConsole(Password, 
                                      MAX_NT_PASSWORD
                                      ); 

    if (ERROR_SUCCESS != WinError)
    {
        goto Error;
    }




    //
    // ask user to re-type new password
    // 

    RESOURCE_PRINT( IDS_PROMPT_CONFIRM_PASSWORD );

    SecureZeroMemory(ConfirmPassword, MAX_NT_PASSWORD * sizeof(WCHAR));

    WinError = GetPasswordFromConsole(ConfirmPassword, 
                                      MAX_NT_PASSWORD
                                      ); 

    if (ERROR_SUCCESS != WinError)
    {
        goto Error;
    }



    //
    // compare the first password and re-confirmed password 
    // 

    if ( wcscmp(Password, ConfirmPassword) )
    {
        RESOURCE_PRINT( IDS_SET_DSRM_PWD_DO_NOT_MATCH );
        goto Cleanup;
    }


    //
    // warn user if it is a blank password
    // 

    if ( 0 == wcslen(Password) )
    {
        WinError = CheckBlankPassword( &fContinue );

        if (ERROR_SUCCESS != WinError)
        {
            goto Error;
        }
        
        if ( !fContinue )
        {
            goto Cleanup;
        }
    }



    //
    // verify the complexity of the new password
    // 

    WinError = ValidatePasswordPolicy(NULL==pServerName ? NULL:pServerName->Buffer,
                                      Password
                                      );



    if (ERROR_SUCCESS == WinError)
    {
        RtlInitUnicodeString(&ClearPassword, Password);

        //
        // invoke SAM RPC
        // 
        SamLibModule = (HMODULE) LoadLibraryW( L"SAMLIB.DLL" );

        if (SamLibModule)
        {
            SetPasswordProc = (SamSetDSRMPwdFuncPtr) GetProcAddress(SamLibModule, "SamiSetDSRMPassword");

            if (SetPasswordProc)
            {
                NtStatus = SetPasswordProc(pServerName,
                                           DOMAIN_USER_RID_ADMIN,
                                           &ClearPassword
                                           );

                WinError = RtlNtStatusToDosError(NtStatus);
            }
            else
            {
                WinError = GetLastError();
            }
        }
        else
        {
            WinError = GetLastError();
        }
    }

Error:

    if (ERROR_SUCCESS == WinError)
    {
        RESOURCE_PRINT( IDS_SET_DSRM_PWD_SUCCESS );
    }
    else
    {
        PWCHAR      ErrorMessage = NULL;

        FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |     // find message from system resource table
                       FORMAT_MESSAGE_IGNORE_INSERTS |  // do not insert
                       FORMAT_MESSAGE_ALLOCATE_BUFFER,  // please allocate buffer for me
                       NULL,                            // source dll (NULL for system)
                       WinError,                        // message ID
                       0,                               // Language ID
                       (LPWSTR)&ErrorMessage,           // address of output
                       0,                               // maxium buffer size if not 0
                       NULL                             // can not insert message
                       );

        RESOURCE_PRINT( IDS_SET_DSRM_PWD_FAILURE );
        RESOURCE_PRINT1( IDS_SET_DSRM_PWD_FAILURE_CODE, WinError );
        RESOURCE_PRINT1( IDS_SET_DSRM_PWD_FAILURE_MSG, ErrorMessage );


        if (NULL != ErrorMessage) {
            LocalFree(ErrorMessage); 
        }
    }



Cleanup:

    //
    // zero out clear text password
    // 
    SecureZeroMemory(Password, MAX_NT_PASSWORD * sizeof(WCHAR));
    SecureZeroMemory(ConfirmPassword, MAX_NT_PASSWORD * sizeof(WCHAR));

    if (SamLibModule)
    {
        FreeLibrary( SamLibModule );
    }


    return(S_OK);
}


ULONG
GetPasswordFromConsole(
    IN OUT PWCHAR Buffer, 
    IN USHORT BufferLength
    )
{
    ULONG       WinError = ERROR_SUCCESS;
    BOOL        Success;
    WCHAR       CurrentChar;
    WCHAR       *CurrentBufPtr = Buffer; 
    HANDLE      InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    HANDLE      OutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );
    DWORD       OriginalMode = 0;
    DWORD       Length = 0;
    DWORD       NumRead = 0;
    DWORD       NumWritten = 0;



    //
    // Always leave one WCHAR for NULL terminator
    //
    BufferLength --;  

    //
    // Change the console setting. Disable echo input
    // 
    GetConsoleMode(InputHandle, &OriginalMode);
    SetConsoleMode(InputHandle, 
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & OriginalMode);

    while (TRUE)
    {
        CurrentChar = 0;
        //
        // ReadConsole return NULL if failed
        // 
        Success = ReadConsoleW(InputHandle, 
                               &CurrentChar, 
                               1, 
                               &NumRead, 
                               NULL
                               );
        if (!Success)
        {
            WinError = GetLastError();
            break;
        }

        if ((CR == CurrentChar) || (1 != NumRead))   // end of the line 0xd
            break;

        if (BACKSPACE == CurrentChar)             // back up one or two 0x8
        {
            if (Buffer != CurrentBufPtr)
            {
                CurrentBufPtr--;
                Length--;

                // erase the last '*' sign
                {
                    CONSOLE_SCREEN_BUFFER_INFO csbi;

                    GetConsoleScreenBufferInfo(OutputHandle, &csbi);
                    --csbi.dwCursorPosition.X;
                    SetConsoleCursorPosition(OutputHandle, csbi.dwCursorPosition);
                    WriteConsoleW(OutputHandle, L" ", 1, &NumWritten, NULL);
                    SetConsoleCursorPosition(OutputHandle, csbi.dwCursorPosition);
                }
            }
        }
        else
        {
            if (Length == BufferLength)
            {
                RESOURCE_PRINT( IDS_INVALID_PASSWORD );
                WinError = ERROR_PASSWORD_RESTRICTION;
                break;
            }
            *CurrentBufPtr = CurrentChar;
            CurrentBufPtr++;
            Length++;

            // display a '*' sign 
            WriteConsoleW(OutputHandle, L"*", 1, &NumWritten, NULL);
        }
    }

    SetConsoleMode(InputHandle, OriginalMode);
    *CurrentBufPtr = L'\0';
    putchar(L'\n');


    return( WinError );
}


ULONG
ValidatePasswordPolicy(
    IN LPWSTR ServerName,
    IN LPWSTR ClearPassword
    )
/*++
Routine description:

    this routine checks whether the clear password meets domain 
    password policy or not. 

       call Netapi to validate the password using target DC domain 
       password policy. 
       if doesn't meet password policy, error out. 
       if NetValidatePasswordPolicy() is not supported by either client
       side netapi32.dll or server side samsrv.dll, warn user but continue 
       
Parameter:

    ServerName - target DC name or NULL
    
    ClearPassword 

Return Code:

    Win32 Error code

--*/
{
    ULONG           WinError = ERROR_SUCCESS;    
    NET_API_STATUS  NetStatus = NERR_Success;
    HMODULE         NetApiModule = NULL;
    NetValidatePwdFuncPtr                   NetValidatePwdProc = NULL;
    NetValidatePwdFreeFuncPtr               NetValidatePwdFreeProc = NULL;
    NET_VALIDATE_PASSWORD_RESET_INPUT_ARG   ResetPwdIn;
    PNET_VALIDATE_OUTPUT_ARG                pCheckPwdOut = NULL;




    // 
    // load library - netapi32.dll
    // 

    NetApiModule = (HMODULE) LoadLibraryW( L"NETAPI32.DLL" );

    if (NetApiModule)
    {
        // 
        // get address of exported function
        // 

        NetValidatePwdProc = (NetValidatePwdFuncPtr) 
                            GetProcAddress(NetApiModule,
                                           "NetValidatePasswordPolicy" 
                                           );

        NetValidatePwdFreeProc = (NetValidatePwdFreeFuncPtr)
                            GetProcAddress(NetApiModule,
                                           "NetValidatePasswordPolicyFree"
                                           );

        if (NetValidatePwdProc && NetValidatePwdFreeProc)
        {
            // 
            // validate new password
            // 

            memset(&ResetPwdIn, 0, sizeof(ResetPwdIn));
            ResetPwdIn.ClearPassword = ClearPassword;
            NetStatus = NetValidatePwdProc(ServerName,               // server name
                                           NULL,                     // qualifier
                                           NetValidatePasswordReset, // verfiry type
                                           &ResetPwdIn,              // input
                                           (LPVOID *) &pCheckPwdOut
                                           );


            if (NERR_Success == NetStatus)
            {
                if ( pCheckPwdOut )
                {
                    // get the validation result
                    WinError = pCheckPwdOut->ValidationStatus;
                }
                else
                {
                    // no out parameter - this is wrong
                    WinError = ERROR_NO_SYSTEM_RESOURCES;
                }
            }
            else if (ERROR_NOT_SUPPORTED == NetStatus ||
                     RPC_S_PROCNUM_OUT_OF_RANGE == NetStatus)
            {
                // this functionality is not supported by the target DC
                // might because the DC is running downlevel OS
                // we'll just continue, but will display warning 
                WinError = ERROR_SUCCESS;
                RESOURCE_PRINT( IDS_SET_DSRM_PWD_CANT_VALIDATE_ON_DC );
            }
            else
            {
                // other error from validation API
                WinError = NetStatus;
            }
        }
        else
        {
            // 
            // can't get address of exported function - NetValidatePasswordPolicy
            // user maybe copy and run a higher version ntdsutil.exe on lower OS 
            // 
            WinError = ERROR_SUCCESS;
            RESOURCE_PRINT( IDS_SET_DSRM_PWD_CANT_VALIDATE_LOCALLY );
        }
    }
    else
    {
        // can't load library - netapi32.dll
        WinError = GetLastError();
    }



    //
    // clean up
    // 
    if (pCheckPwdOut)
    {
        ASSERT(NULL != NetValidatePwdFreeProc);
        if (NetValidatePwdFreeProc)
        {
            NetValidatePwdFreeProc( (LPVOID *) &pCheckPwdOut );
        }
    }

    if (NetApiModule)
    {
        FreeLibrary( NetApiModule );
    }



    return( WinError );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\utilc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    utilc.c

Abstract:

    This module contains error management routines.  Takes an LDAP or
    Win32 error, and produces a string error message.

Author:

    Dave Straube (DaveStr) Long Ago

Environment:

    User Mode.

Revision History:

    16-Aug-2000     BrettSh
                Added this comment block, and allowed the DisplayErr()]
                and GetLdapErrorMessage to handle a variable LDAP handle.
        

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <assert.h>

#include "windows.h"
#include "winldap.h"
#include "reshdl.h"
#include "resource.h"

// GetWinErrorMessage assumes ntdsutil.exe is single threaded.
// Thus we can use a globally variable.

const WCHAR *pDefaultMsg = NULL;
const WCHAR *pExtComment = NULL;
const WCHAR *pW32Comment = NULL;
const WCHAR *pSuccessMsg = NULL;
PWCHAR pWinErrorMsg = NULL;

PWCHAR pLdapErrorMsg = NULL;
DWORD LdapErrLen = 0;
BOOL            fPopups = TRUE;

LDAP* gldapDS = NULL;


void InitErrorMessages ()
{
    pDefaultMsg = READ_STRING (IDS_NO_ERROR_MAPPING);
    pExtComment = READ_STRING (IDS_LDAP_EXT_ERROR);
    pW32Comment = READ_STRING (IDS_W32_ERROR);
    pSuccessMsg = READ_STRING (IDS_SUCCESS);
}

void FreeErrorMessages ()
{
    RESOURCE_STRING_FREE (pDefaultMsg);
    RESOURCE_STRING_FREE (pExtComment);
    RESOURCE_STRING_FREE (pW32Comment);
    RESOURCE_STRING_FREE (pSuccessMsg);

    if ( pWinErrorMsg )
    {
        LocalFree(pWinErrorMsg);
        pWinErrorMsg = NULL;
    }
    
    if ( pLdapErrorMsg != NULL ) {
        LocalFree(pLdapErrorMsg);
        pLdapErrorMsg = NULL;
        LdapErrLen = 0;
    }
}


const WCHAR * 
GetWinErrorMessage(
    DWORD winError
    )
{
    ULONG   len;
    DWORD   flags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;

    // Lazy dealloc of the message buffer.

    if ( pWinErrorMsg )
    {
        LocalFree(pWinErrorMsg);
        pWinErrorMsg = NULL;
    }

    len = FormatMessageW(   flags,
                            NULL,           // resource DLL
                            winError,
                            0,              // use caller's language
                            (LPWSTR) &pWinErrorMsg,
                            0,
                            NULL);

    if ( !pWinErrorMsg )
    {
        return(pDefaultMsg);
    }

    // Truncate cr/lf.

    pWinErrorMsg[len-2] = L'\0';
    return(pWinErrorMsg);
}

const WCHAR *
GetLdapErrorMessage(
    LDAP *     pLdap,
    DWORD      LdapError
    )
{
    DWORD err = 0;
    WCHAR *pmsg = NULL;
    ULONG   len = 0;
    HINSTANCE hwldap;
    static WCHAR strBuff[MAX_PATH];

    hwldap = LoadLibrary("wldap32.dll");
    if ( hwldap == NULL ) {
        goto output_default;
    }

    len = LoadStringW(hwldap, LdapError+1000, strBuff, MAX_PATH);
    if ( len == 0 ) {
        strBuff[0] = '\0';
    }

    // ldap_get_option can return success but without allocating memory for the 
    // error, so we have to check for this too.
    if ( ldap_get_optionW(pLdap, LDAP_OPT_SERVER_ERROR, &pmsg) == LDAP_SUCCESS ) {
        len += wcslen(pExtComment) + 16;
        if (pmsg) {
            len += wcslen(pmsg);
        }
    }

    if ( ldap_get_optionW(pLdap, LDAP_OPT_SERVER_EXT_ERROR, &err) == LDAP_SUCCESS ) {
        len += wcslen(pW32Comment) + 32 + wcslen(GetWinErrorMessage(err));
    }

    if ( len > 0 ) {

        INT i;
        len += 64;  // fudge

        if ( LdapErrLen < len ) {

            if ( pLdapErrorMsg != NULL ) {
                LocalFree(pLdapErrorMsg);
                pLdapErrorMsg = NULL;
                LdapErrLen = 0;
            }

            pLdapErrorMsg = LocalAlloc(LPTR, len * sizeof (WCHAR));
            if ( pLdapErrorMsg == NULL ) {
                goto output_default;
            }

            LdapErrLen = len;
        }


        if ( strBuff[0] != L'\0' ) {
            i = swprintf(pLdapErrorMsg, L"%d (%ws).\n", LdapError, strBuff);
        } else {
            i = swprintf(pLdapErrorMsg, L"%d.\n", LdapError);
        }

        if ( i <= 0 ) {
            goto output_default;
        }
        len = i;

        if ( pmsg != NULL ) {
            i = swprintf(pLdapErrorMsg + len, L"%ws %ws\n", pExtComment, pmsg);
            if ( i <= 0 ) {
                goto output_default;
            }
            len += i;
        }

        if ( err != ERROR_SUCCESS ) {
            i = swprintf(pLdapErrorMsg + len, L"%ws 0x%x(%ws)\n", 
                        pW32Comment, err, GetWinErrorMessage(err));

            if ( i <= 0 ) {
                goto output_default;
            }
        }

    } else {

output_default:
        if ( pmsg != NULL ) {
            ldap_memfreeW(pmsg);
        }
        (VOID) swprintf(strBuff,L"%d\n", LdapError);
        return strBuff;
    }

    if ( pmsg != NULL ) {
        ldap_memfreeW(pmsg);
    }

    return pLdapErrorMsg;
}


const WCHAR *
DisplayErr(
    IN LDAP *   pLdap,
    IN DWORD    Win32Err,
    IN DWORD    LdapErr
    )
{
    if ( Win32Err != ERROR_SUCCESS ) {
        return GetWinErrorMessage(Win32Err);
    } else if ( LdapErr != LDAP_SUCCESS ) {
        assert(pLdap);
        return GetLdapErrorMessage(pLdap, LdapErr);
    } else {
        return pSuccessMsg;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\outward-facing\dcaffres\dcaffres.c ===
/*++

    BY INSTALLING, COPYING, OR OTHERWISE USING THE SOFTWARE PRODUCT (source
    code and binaries) YOU AGREE TO BE BOUND BY THE TERMS OF THE ATTACHED EULA
    (end user license agreement) .  IF YOU DO NOT AGREE TO THE TERMS OF THE
    ATTACHED EULA, DO NOT INSTALL OR USE THE SOFTWARE PRODUCT.

Module Name:

    dcaffres.c

Abstract:

    DCAFFRES.DLL is a resource DLL for the Microsoft Cluster Service.  This
    resource is used to negotiate which DC in a given cluster advertises itself
    to clients through the DC locator.  It accomplishes this by "pausing" and
    "continuing" the Net Logon service.

--*/

#pragma comment(lib, "dnsapi.lib")
#pragma comment(lib, "netapi32.lib")
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "clusapi.lib")
#pragma comment(lib, "resutils.lib")

#define UNICODE 1

#pragma warning( disable : 4115 )  // named type definition in parentheses
#pragma warning( disable : 4201 )  // nonstandard extension used: nameless struct/union
#pragma warning( disable : 4214 )  // nonstandard extension used: bit field types other than int

#include <windows.h>

#pragma warning( default : 4214 )  // nonstandard extension used: bit field types other than int
#pragma warning( default : 4201 )  // nonstandard extension used: nameless struct/union
#pragma warning( default : 4115 )  // named type definition in parentheses

#include <clusapi.h>
#include <resapi.h>
#include <stdio.h>
#include <lm.h>
#include <lmapibuf.h>
#include <dsgetdc.h>
#include <windns.h>

//
// Type and constant definitions
//

#define DCAFFINITY_RESNAME  L"DC Advertisement"
#define DCAFFINITY_SVCNAME  TEXT("NlPause")

typedef struct _DCAFFINITY_RESOURCE {
    RESID                   ResId; // for validation
    HKEY                    ParametersKey;
    RESOURCE_HANDLE         ResourceHandle;
    LPWSTR                  ResourceName;
    CLUS_WORKER             OnlineThread;
    CLUSTER_RESOURCE_STATE  State;
} DCAFFINITY_RESOURCE, *PDCAFFINITY_RESOURCE;


//
// Global data
//

// Event logging routine

PLOG_EVENT_ROUTINE g_LogEvent = NULL;

// Resource Status routine for pending Online and Offline calls

PSET_RESOURCE_STATUS_ROUTINE g_SetResourceStatus = NULL;

// Forward reference to the RESAPI function table

extern CLRES_FUNCTION_TABLE g_DCAffinityFunctionTable;

//
//  Private, read/write properties for the DC Advertisement resource
//
RESUTIL_PROPERTY_ITEM
DCAffinityResourcePrivateProperties[] = {
    { 0 }
};


//
// Function prototypes
//

DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    );

RESID
WINAPI
DCAffinityOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    );

VOID
WINAPI
DCAffinityClose(
    IN RESID ResourceId
    );

DWORD
WINAPI
DCAffinityOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    );

DWORD
WINAPI
DCAffinityOnlineThread(
    PCLUS_WORKER WorkerPtr,
    IN PDCAFFINITY_RESOURCE ResourceEntry
    );

DWORD
WINAPI
DCAffinityOffline(
    IN RESID ResourceId
    );

VOID
WINAPI
DCAffinityTerminate(
    IN RESID ResourceId
    );

DWORD
DCAffinityDoTerminate(
    IN PDCAFFINITY_RESOURCE ResourceEntry
    );

BOOL
WINAPI
DCAffinityLooksAlive(
    IN RESID ResourceId
    );

BOOL
WINAPI
DCAffinityIsAlive(
    IN RESID ResourceId
    );

BOOL
DCAffinityCheckIsAlive(
    IN PDCAFFINITY_RESOURCE ResourceEntry
    );

DWORD
WINAPI
DCAffinityResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    );

DWORD
MyControlService(
    IN LPWSTR ServiceName,
    IN DWORD Control,
    IN RESOURCE_HANDLE ResourceHandle
    );



BOOLEAN
WINAPI
DllMain(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )

/*++

Routine Description:

    Main DLL entry point.

Arguments:

    DllHandle - DLL instance handle.

    Reason - Reason for being called.

    Reserved - Reserved argument.

Return Value:

    TRUE - Success.

    FALSE - Failure.

--*/

{
    switch( Reason ) {

    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls( DllHandle );
        break;

    default:
        break;
    }

    return(TRUE);

} // DllMain




DWORD
WINAPI
Startup(
    IN LPCWSTR ResourceType,
    IN DWORD MinVersionSupported,
    IN DWORD MaxVersionSupported,
    IN PSET_RESOURCE_STATUS_ROUTINE SetResourceStatus,
    IN PLOG_EVENT_ROUTINE LogEvent,
    OUT PCLRES_FUNCTION_TABLE *FunctionTable
    )

/*++

Routine Description:

    Start the resource DLL. This routine verifies that at least one
    currently supported version of the resource DLL is between
    MinVersionSupported and MaxVersionSupported. If not, then the resource
    DLL should return ERROR_REVISION_MISMATCH.

    If more than one version of the resource DLL interface is supported by
    the resource DLL, then the highest version (up to MaxVersionSupported)
    should be returned as the resource DLL's interface. If the returned
    version is not within range, then startup fails.

    The ResourceType is passed in so that if the resource DLL supports more
    than one ResourceType, it can pass back the correct function table
    associated with the ResourceType.

Arguments:

    ResourceType - Type of resource requesting a function table.

    MinVersionSupported - Minimum resource DLL interface version 
        supported by the cluster software.

    MaxVersionSupported - Maximum resource DLL interface version
        supported by the cluster software.

    SetResourceStatus - Pointer to a routine that the resource DLL should 
        call to update the state of a resource after the Online or Offline 
        routine returns a status of ERROR_IO_PENDING.

    LogEvent - Pointer to a routine that handles the reporting of events 
        from the resource DLL. 

    FunctionTable - Pointer to the function table defined for the
        version of the resource DLL interface returned by the resource DLL.

Return Value:

    ERROR_SUCCESS - The operation succeeded.

    ERROR_MOD_NOT_FOUND - The resource type is not recognized by this DLL.

    ERROR_REVISION_MISMATCH - The version of the cluster service does not
        match the version of the DLL.

    Win32 error code - The operation failed.

--*/

{
    if ( (MinVersionSupported > CLRES_VERSION_V1_00) ||
         (MaxVersionSupported < CLRES_VERSION_V1_00) ) {
        return(ERROR_REVISION_MISMATCH);
    }

    if ( lstrcmpiW( ResourceType, DCAFFINITY_RESNAME ) != 0 ) {
        return(ERROR_MOD_NOT_FOUND);
    }

    if ( !g_LogEvent ) {
        g_LogEvent = LogEvent;
        g_SetResourceStatus = SetResourceStatus;
    }

    *FunctionTable = &g_DCAffinityFunctionTable;

    return(ERROR_SUCCESS);

} // Startup



RESID
WINAPI
DCAffinityOpen(
    IN LPCWSTR ResourceName,
    IN HKEY ResourceKey,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Open routine for DC Advertisement resources.

    Open the specified resource (create an instance of the resource). 
    Allocate all structures necessary to bring the specified resource 
    online.

Arguments:

    ResourceName - Name of the resource to open.

    ResourceKey - Handle to the database key of the 
        resource's cluster configuration.

    ResourceHandle - Handle passed back to the resource monitor 
        when the SetResourceStatus or LogEvent method is called (see the 
        description of the SetResourceStatus and LogEvent methods on the
        DCAffinityStatup routine). This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogEvent callback.

Return Value:

    RESID of created resource.

    NULL on failure.

--*/

{
    DWORD               status;
    DWORD               disposition;
    RESID               resid = 0;
    HKEY                parametersKey = NULL;
    PDCAFFINITY_RESOURCE resourceEntry = NULL;

    //
    // Open the Parameters registry key for this resource.
    //

    status = ClusterRegCreateKey( ResourceKey,
                                  L"Parameters",
                                  0,
                                  KEY_ALL_ACCESS,
                                  NULL,
                                  &parametersKey,
                                  &disposition );

    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to open Parameters key. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Allocate a resource entry.
    //

    resourceEntry = (PDCAFFINITY_RESOURCE) LocalAlloc( LMEM_FIXED, sizeof(DCAFFINITY_RESOURCE) );

    if ( resourceEntry == NULL ) {
        status = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Unable to allocate resource entry structure. Error: %1!u!.\n",
            status );
        goto exit;
    }

    //
    // Initialize the resource entry.
    //

    ZeroMemory( resourceEntry, sizeof(DCAFFINITY_RESOURCE) );

    resourceEntry->ResId = (RESID)resourceEntry; // for validation
    resourceEntry->ResourceHandle = ResourceHandle;
    resourceEntry->ParametersKey = parametersKey;
    resourceEntry->State = ClusterResourceOffline;

    //
    // Save the name of the resource.
    //
    resourceEntry->ResourceName = LocalAlloc( LMEM_FIXED, (lstrlenW( ResourceName ) + 1) * sizeof(WCHAR) );
    if ( resourceEntry->ResourceName == NULL ) {
        goto exit;
    }
    lstrcpyW( resourceEntry->ResourceName, ResourceName );


    resid = (RESID)resourceEntry;

exit:

    if ( resid == 0 ) {
        if ( parametersKey != NULL ) {
            ClusterRegCloseKey( parametersKey );
        }
        if ( resourceEntry != NULL ) {
            LocalFree( resourceEntry->ResourceName );
            LocalFree( resourceEntry );
        }
    }

    if ( status != ERROR_SUCCESS ) {
        SetLastError( status );
    }

    return(resid);

} // DCAffinityOpen




VOID
WINAPI
DCAffinityClose(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Close routine for DC Advertisement resources.

    Close the specified resource and deallocate all structures and other
    resources allocated in the Open call. If the resource is not in the
    offline state, then the resource should be taken offline (by calling
    Terminate) before the close operation is performed.

Arguments:

    ResourceId - RESID of the resource to close.

Return Value:

    None.

--*/

{
    PDCAFFINITY_RESOURCE resourceEntry;

    resourceEntry = (PDCAFFINITY_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Close resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Close request.\n" );
#endif


    //
    // Close the Parameters key.
    //

    if ( resourceEntry->ParametersKey ) {
        ClusterRegCloseKey( resourceEntry->ParametersKey );
    }

    //
    // Deallocate the resource entry.
    //

    // ADDPARAM: Add new parameters here.

    LocalFree( resourceEntry->ResourceName );
    LocalFree( resourceEntry );

} // DCAffinityClose




DWORD
WINAPI
DCAffinityOnline(
    IN RESID ResourceId,
    IN OUT PHANDLE EventHandle
    )

/*++

Routine Description:

    Online routine for DC Advertisement resources.

    Bring the specified resource online (available for use). The resource
    DLL should attempt to arbitrate for the resource if it is present on a
    shared medium, like a shared SCSI bus.

Arguments:

    ResourceId - Resource ID for the resource to be brought 
        online (available for use).

    EventHandle - Returns a handle that is signaled when the 
        resource DLL detects a failure on the resource. This argument is 
        NULL on input, and the resource DLL returns NULL if asynchronous 
        notification of failures is not supported; otherwise, this must be 
        the address of a handle that is signaled on resource failures.

Return Value:

    ERROR_SUCCESS - The operation succeeded, and the resource is now 
        online.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_RESOURCE_NOT_AVAILABLE - The resource was arbitrated with some 
        other systems, and one of the other systems won the arbitration.

    ERROR_IO_PENDING - The request is pending. A thread has been activated 
        to process the online request. The thread that is processing the 
        online request will periodically report status by calling the 
        SetResourceStatus callback method until the resource is placed into 
        the ClusterResourceOnline state or the resource monitor decides to 
        timeout the online request and terminate the resource. This pending 
        timeout value can be set and has a default value of 3 minutes.

    Win32 error code - The operation failed.

--*/

{
    PDCAFFINITY_RESOURCE resourceEntry = NULL;
    DWORD               status;

    resourceEntry = (PDCAFFINITY_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online service sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Online request.\n" );
#endif

    resourceEntry->State = ClusterResourceOffline;
    ClusWorkerTerminate( &resourceEntry->OnlineThread );
    status = ClusWorkerCreate( &resourceEntry->OnlineThread,
                               (PWORKER_START_ROUTINE)DCAffinityOnlineThread,
                               resourceEntry );
    if ( status != ERROR_SUCCESS ) {
        resourceEntry->State = ClusterResourceFailed;
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Online: Unable to start thread, status %1!u!.\n",
            status
            );
    } else {
        status = ERROR_IO_PENDING;
    }

    return(status);

} // DCAffinityOnline




DWORD
WINAPI
DCAffinityOnlineThread(
    PCLUS_WORKER WorkerPtr,
    IN PDCAFFINITY_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Worker function that brings a resource from the resource table online.
    This function is executed in a separate thread.

Arguments:

    WorkerPtr - Supplies the worker structure.

    ResourceEntry - Pointer to the DCAFFINITY_RESOURCE block for this resource.

Returns:

    ERROR_SUCCESS - The operation succeeded.
    
    Win32 error code - The operation failed.

--*/

{
    RESOURCE_STATUS     resourceStatus;
    DWORD               status = ERROR_SUCCESS;

    ResUtilInitializeResourceStatus( &resourceStatus );

    resourceStatus.ResourceState = ClusterResourceFailed;
    resourceStatus.WaitHint = 0;
    resourceStatus.CheckPoint = 1;

    //
    // Start the NlPause service
    //
    status = ResUtilStartResourceService( DCAFFINITY_SVCNAME, NULL );
    if ( status == ERROR_SERVICE_ALREADY_RUNNING ) {
        status = ERROR_SUCCESS;
    } else if ( status != ERROR_SUCCESS ) {
        goto exit;
    }

    //
    // Bring the resource online.
    //

    status = MyControlService(L"NetLogon",
                              SERVICE_CONTROL_CONTINUE,
                              ResourceEntry->ResourceHandle);

exit:
    if ( status != ERROR_SUCCESS ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Error %1!u! bringing resource online.\n",
            status );
    } else {
        resourceStatus.ResourceState = ClusterResourceOnline;
    }

    g_SetResourceStatus( ResourceEntry->ResourceHandle, &resourceStatus );
    ResourceEntry->State = resourceStatus.ResourceState;

    return(status);

} // DCAffinityOnlineThread




DWORD
WINAPI
DCAffinityOffline(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Offline routine for DC Advertisement resources.

    Take the specified resource offline gracefully (unavailable for use).  
    Wait for any cleanup operations to complete before returning.

Arguments:

    ResourceId - Resource ID for the resource to be shutdown 
        gracefully.

Return Value:

    ERROR_SUCCESS - The request succeeded, and the resource is 
        offline.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_IO_PENDING - The request is pending. A thread has been 
        activated to process the offline request. The thread that is 
        processing the offline will periodically report status by calling 
        the SetResourceStatus callback method until the resource is placed 
        into the ClusterResourceOffline state or the resource monitor decides 
        to timeout the offline request and terminate the resource. This pending 
        timeout value can be set and has a default value of 3 minutes.
    
    Win32 error code - The resource monitor will log an event and 
        call the Terminate routine.

--*/

{
    PDCAFFINITY_RESOURCE resourceEntry;

    resourceEntry = (PDCAFFINITY_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Offline resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Offline request.\n" );
#endif

    // NOTE: Offline should try to shut the resource down gracefully, whereas
    // Terminate must shut the resource down immediately. If there are no
    // differences between a graceful shut down and an immediate shut down,
    // Terminate can be called for Offline, as shown below. However, if there
    // are differences, replace the call to Terminate below with your graceful
    // shutdown code.

    //
    // Terminate the resource.
    //
    return DCAffinityDoTerminate( resourceEntry );

} // DCAffinityOffline




VOID
WINAPI
DCAffinityTerminate(
    IN RESID ResourceId
    )

/*++

Routine Description:

    Terminate routine for DC Advertisement resources.

    Take the specified resource offline immediately (the resource is
    unavailable for use).

Arguments:

    ResourceId - Resource ID for the resource to be brought 
        offline.

Return Value:

    None.

--*/

{
    PDCAFFINITY_RESOURCE resourceEntry;

    resourceEntry = (PDCAFFINITY_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return;
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"Terminate resource sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return;
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"Terminate request.\n" );
#endif

    //
    // Terminate the resource.
    //
    DCAffinityDoTerminate( resourceEntry );
    resourceEntry->State = ClusterResourceOffline;

} // DCAffinityTerminate




DWORD
DCAffinityDoTerminate(
    IN PDCAFFINITY_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Do the actual Terminate work for DC Advertisement resources.

Arguments:

    ResourceEntry - Resource entry for resource to be terminated.

Return Value:

    ERROR_SUCCESS - The request succeeded, and the resource is 
        offline.

    Win32 error code - The resource monitor will log an event and 
        call the Terminate routine.

--*/

{
    DWORD       status = ERROR_SUCCESS;

    //
    // Terminate any pending threads.
    //
    ClusWorkerTerminate( &ResourceEntry->OnlineThread );

    //
    // Terminate the resource.
    //
    status = MyControlService(L"NetLogon",
                              SERVICE_CONTROL_PAUSE,
                              ResourceEntry->ResourceHandle);

    if ( status == ERROR_SUCCESS ) {
        ResourceEntry->State = ClusterResourceOffline;
    }

    return(status);

} // DCAffinityDoTerminate




BOOL
WINAPI
DCAffinityLooksAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    LooksAlive routine for DC Advertisement resources.

    Perform a quick check to determine whether the specified resource is 
    probably online (available for use).  This call should not block for 
    more than 300 ms, preferably less than 50 ms.

Arguments:

    ResourceId - Resource ID for the resource to be polled.

Return Value:

    TRUE - The specified resource is probably online and available for use.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PDCAFFINITY_RESOURCE  resourceEntry;

    resourceEntry = (PDCAFFINITY_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"LooksAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"LooksAlive request.\n" );
#endif

    // NOTE: LooksAlive should be a quick check to determine whether the 
    // resource is available, whereas IsAlive should be a thorough check. If
    // there are no differences between a quick check and a thorough check,
    // IsAlive can be called for LooksAlive, as shown below. However, if there
    // are differences, replace the call to IsAlive below with your quick-
    // check code.

    //
    // Determine whether the resource is alive.
    //
    return(DCAffinityCheckIsAlive( resourceEntry ));

} // DCAffinityLooksAlive




BOOL
WINAPI
DCAffinityIsAlive(
    IN RESID ResourceId
    )

/*++

Routine Description:

    IsAlive routine for DC Advertisement resources.

    Perform a thorough check to determine whether the specified resource is 
    online(available for use). This call should not block for more than 400 ms,
    preferably less than 100 ms.

Arguments:

    ResourceId - Resource ID for the resource to be polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    PDCAFFINITY_RESOURCE  resourceEntry;

    resourceEntry = (PDCAFFINITY_RESOURCE)ResourceId;

    if ( resourceEntry == NULL ) {
        return(FALSE);
    }

    if ( resourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            resourceEntry->ResourceHandle,
            LOG_ERROR,
            L"IsAlive sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(FALSE);
    }

#ifdef LOG_VERBOSE
    (g_LogEvent)(
        resourceEntry->ResourceHandle,
        LOG_INFORMATION,
        L"IsAlive request.\n" );
#endif

    //
    // Determine whether the resource is alive.
    //
    return(DCAffinityCheckIsAlive( resourceEntry ));

} // DCAffinityIsAlive




BOOL
DCAffinityCheckIsAlive(
    IN PDCAFFINITY_RESOURCE ResourceEntry
    )

/*++

Routine Description:

    Check to determine whether the resource is alive for DC Advertisement
    resources.

Arguments:

    ResourceEntry - Resource entry for the resource to be polled.

Return Value:

    TRUE - The specified resource is online and functioning normally.

    FALSE - The specified resource is not functioning normally.

--*/

{
    //
    // Check to determine whether the resource is alive.
    //

    DWORD err;
    BOOL ok;
    DWORD dwDcFlags = DS_DS_FLAG | DS_KDC_FLAG | DS_WRITABLE_FLAG;
    DOMAIN_CONTROLLER_INFOW * pDcInfo = NULL;
    WCHAR szMyComputerName[256];
    DWORD cchMyComputerName = sizeof(szMyComputerName)/sizeof(szMyComputerName[0]);
    WCHAR * pszMyComputerName = szMyComputerName;
    WCHAR * pszTempMyComputerName;
    WCHAR * pszTempDcName;
    BOOL fIsAdvertising = FALSE;

    // Are we advertising? Ask Netlogon for a DC -- we are advertising if and
    // only if Netlogon returns itself.

    __try {    
        err = DsGetDcNameW(NULL, NULL, NULL, NULL, dwDcFlags, &pDcInfo);
        if (err) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"DsGetDcName() failed, error %1!u!.\n",
                err);
            __leave;
        }
        
        ok = GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified,
                               pszMyComputerName,
                               &cchMyComputerName);
        if (!ok) {
            err = GetLastError();

            if (ERROR_MORE_DATA == err) {
                pszMyComputerName = LocalAlloc(LPTR, cchMyComputerName);

                if (NULL == pszMyComputerName) {
                    err = GetLastError();
                    (g_LogEvent)(
                        ResourceEntry->ResourceHandle,
                        LOG_ERROR,
                        L"LocalAlloc() failed, error %1!u!.\n",
                        err);
                    __leave;
                } else {
                    ok = GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified,
                                           pszMyComputerName,
                                           &cchMyComputerName);
                    if (!ok) {
                        err = GetLastError();
                    }
                }
            }
        }
             
        if (!ok) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"GetComputerNameEx() failed, error %1!u!.\n",
                err);
            __leave;
        }

        pszTempMyComputerName = pszMyComputerName;
        pszTempDcName = pDcInfo->DomainControllerName;

        if ((L'\\' == pszTempMyComputerName[0])
            && (L'\\' == pszTempMyComputerName[1])) {
            pszTempMyComputerName += 2;
        }

        if ((L'\\' == pszTempDcName[0])
            && (L'\\' == pszTempDcName[1])) {
            pszTempDcName += 2;
        }
        
        fIsAdvertising = DnsNameCompare_W(pszTempDcName, pszTempMyComputerName);
        if (!fIsAdvertising) {
            (g_LogEvent)(
                ResourceEntry->ResourceHandle,
                LOG_ERROR,
                L"DC should be advertising but isn't!\n");
        }
    } __finally {
        if (NULL != pDcInfo) {
            NetApiBufferFree(pDcInfo);
        }

        if ((NULL != pszMyComputerName)
            && (szMyComputerName != pszMyComputerName)) {
            LocalFree(pszMyComputerName);
        }
    }

    return fIsAdvertising;

} // DCAffinityCheckIsAlive




DWORD
WINAPI
DCAffinityResourceControl(
    IN RESID ResourceId,
    IN DWORD ControlCode,
    IN PVOID InBuffer,
    IN DWORD InBufferSize,
    OUT PVOID OutBuffer,
    IN DWORD OutBufferSize,
    OUT LPDWORD BytesReturned
    )

/*++

Routine Description:

    ResourceControl routine for DC Advertisement resources.

    Perform the control request specified by ControlCode on the specified
    resource.

Arguments:

    ResourceId - Resource ID for the specified resource.

    ControlCode - Control code that defines the action
        to be performed.

    InBuffer - Pointer to a buffer containing input data.

    InBufferSize - Size, in bytes, of the data pointed
        to by InBuffer.

    OutBuffer - Pointer to the output buffer to be filled.

    OutBufferSize - Size, in bytes, of the available space
        pointed to by OutBuffer.

    BytesReturned - Returns the number of bytes of OutBuffer actually
        filled by the resource. If OutBuffer is too small, BytesReturned
        contains the total number of bytes required for the operation to succeed.

Return Value:

    ERROR_SUCCESS - The function succeeded.

    ERROR_RESOURCE_NOT_FOUND - RESID is not valid.

    ERROR_INVALID_FUNCTION - The requested control code is not supported.
        In some cases, this allows the cluster software to perform the work.

    Win32 error code - The function failed.

--*/

{
    DWORD               status;
    PDCAFFINITY_RESOURCE  ResourceEntry;

    ResourceEntry = (PDCAFFINITY_RESOURCE)ResourceId;

    if ( ResourceEntry == NULL ) {
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    if ( ResourceEntry->ResId != ResourceId ) {
        (g_LogEvent)(
            ResourceEntry->ResourceHandle,
            LOG_ERROR,
            L"ResourceControl sanity check failed! ResourceId = %1!u!.\n",
            ResourceId );
        return(ERROR_RESOURCE_NOT_FOUND);
    }

    switch ( ControlCode ) {

        case CLUSCTL_RESOURCE_UNKNOWN:
            *BytesReturned = 0;
            status = ERROR_SUCCESS;
            break;

        default:
            status = ERROR_INVALID_FUNCTION;
            break;
    }

    return(status);

} // DCAffinityResourceControl




DWORD
MyControlService(
    IN LPWSTR ServiceName,
    IN DWORD Control,
    IN RESOURCE_HANDLE ResourceHandle
    )

/*++

Routine Description:

    Send the given service control code to the named service.

Arguments:

    ServiceName - Name of the service to control.

    Control - Control code to send to the service.

    ResourceHandle - Handle passed back to the resource monitor 
        when the SetResourceStatus or LogEvent method is called (see the 
        description of the SetResourceStatus and LogEvent methods on the
        DCAffinityStatup routine). This handle should never be closed or used
        for any purpose other than passing it as an argument back to the
        Resource Monitor in the SetResourceStatus or LogEvent callback.

Return Value:

    ERROR_SUCCESS - The operation succeeded.

    Win32 error code - The operation failed.

--*/

{
    DWORD err = 0;
    BOOL ok;
    SC_HANDLE hSCMgr = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS SvcStatus;
    DWORD dwAccessMask;
    
    hSCMgr = OpenSCManagerW(NULL, NULL, SC_MANAGER_CONNECT);
    if (NULL == hSCMgr) {
        err = GetLastError();
        (g_LogEvent)(
            ResourceHandle,
            LOG_ERROR,
            L"Failed to OpenSCManagerW(), error %1!u!.\n",
            err);
    }

    if (!err) {
        // Determine access mask we need to request for this control.
        switch (Control) {
        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
            dwAccessMask = SERVICE_PAUSE_CONTINUE;
            break;
        
        case SERVICE_CONTROL_STOP:
            dwAccessMask = SERVICE_STOP;
            break;
        
        default:
            if ((Control >= 128) && (Control <= 255)) {
                // Magic numbers defined by ControlService(), not defined in any
                // header file.
                dwAccessMask = SERVICE_USER_DEFINED_CONTROL;
            } else {
                // Don't know what access mask is required for this control;
                // default to requesting all access.
                dwAccessMask = SERVICE_ALL_ACCESS;
            }
            break;
        }

        hService = OpenServiceW(hSCMgr, ServiceName, dwAccessMask);
        if (NULL == hService) {
            err = GetLastError();
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Failed to OpenServiceW(), error %1!u!.\n",
                err);
        }
    }

    if (!err) {
        ok = ControlService(hService, Control, &SvcStatus);
        if (!ok) {
            err = GetLastError();
            (g_LogEvent)(
                ResourceHandle,
                LOG_ERROR,
                L"Failed to ControlService(), error %1!u!.\n",
                err);
        }
    }

    if (NULL != hService) {
        CloseServiceHandle(hService);
    }

    if (NULL != hSCMgr) {
        CloseServiceHandle(hSCMgr);
    }

    return err;

} // MyControlService


//***********************************************************
//
// Define Function Table
//
//***********************************************************

CLRES_V1_FUNCTION_TABLE( g_DCAffinityFunctionTable,     // Name
                         CLRES_VERSION_V1_00,           // Version
                         DCAffinity,                    // Prefix
                         NULL,                          // Arbitrate
                         NULL,                          // Release
                         DCAffinityResourceControl,     // ResControl
                         NULL);                         // ResTypeControl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\outward-facing\nlpause\nlpause.c ===
/*++

    BY INSTALLING, COPYING, OR OTHERWISE USING THE SOFTWARE PRODUCT (source
    code and binaries) YOU AGREE TO BE BOUND BY THE TERMS OF THE ATTACHED EULA
    (end user license agreement) .  IF YOU DO NOT AGREE TO THE TERMS OF THE
    ATTACHED EULA, DO NOT INSTALL OR USE THE SOFTWARE PRODUCT. 

Module Name:

    nlpause.c

Abstract:

    NLPAUSE.EXE is a Windows service. Its sole purpose is, on boot, to put the
    Net Logon service into the "paused" state, in which it does not service
    DC locator requests -- that is, it does not "advertise" itself as a DC
    to client computers.

    The Net Logon service may later be "continued" (such as by DCAFFRES.DLL),
    causing DC locator requests to again be serviced.
    
--*/

#pragma comment(lib, "advapi32.lib")

#include <windows.h>
#include <stdio.h>

#define SERVICE_NAME            "nlpause"
#define SERVICE_DISPLAY_NAME    "nlpause"
#define SERVICE_DEPENDENCIES    "netlogon\0"

BOOL g_fIsRunningAsService = TRUE;
HANDLE g_hShutdown = NULL;
BOOL g_fIsStopPending = FALSE;
SERVICE_STATUS g_Status = {0};
SERVICE_STATUS_HANDLE g_hStatus = NULL;

DWORD
WINAPI
ServiceMain(
    IN  DWORD   argc,
    IN  LPTSTR  argv[]
    );

SERVICE_TABLE_ENTRY DispatchTable[] = {
    { SERVICE_NAME, ServiceMain },
    { NULL, NULL }
};




DWORD
MyControlService(
    IN  LPWSTR  pszServiceName,
    IN  DWORD   dwControl
    )

/*++

Routine Description:

    Send the given service control code to the named service.

Arguments:

    pszServiceName - The name of the service to control.

    dwControl - The control code to send to the service.

Return Value:

    ERROR_SUCCESS - The operation succeeded.

    Win32 error code - The operation failed.

--*/

{
    DWORD err = 0;
    BOOL ok;
    SC_HANDLE hSCMgr = NULL;
    SC_HANDLE hService = NULL;
    SERVICE_STATUS SvcStatus;
    DWORD dwAccessMask;
    
    hSCMgr = OpenSCManagerW(NULL, NULL, SC_MANAGER_CONNECT);
    if (NULL == hSCMgr) {
        err = GetLastError();
        printf("Failed to OpenSCManagerW(), error %d.\n", err);
    }

    if (!err) {
        // Determine the access mask to request for this control.
        switch (dwControl) {
        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
            dwAccessMask = SERVICE_PAUSE_CONTINUE;
            break;
        
        case SERVICE_CONTROL_STOP:
            dwAccessMask = SERVICE_STOP;
            break;
        
        default:
            if ((dwControl >= 128) && (dwControl <= 255)) {
                // Magic numbers are defined by ControlService() and are not
                // defined in any header file.
                dwAccessMask = SERVICE_USER_DEFINED_CONTROL;
            } else {
                // Do not know what access mask is required for this control;
                // default to all access.
                dwAccessMask = SERVICE_ALL_ACCESS;
            }
            break;
        }

        hService = OpenServiceW(hSCMgr, pszServiceName, dwAccessMask);
        if (NULL == hService) {
            err = GetLastError();
            printf("Failed to OpenServiceW(), error %d.\n", err);
        }
    }

    if (!err) {
        ok = ControlService(hService, dwControl, &SvcStatus);
        if (!ok) {
            err = GetLastError();
            printf("Failed to ControlService(), error %d.\n", err);
        }
    }

    if (NULL != hService) {
        CloseServiceHandle(hService);
    }

    if (NULL != hSCMgr) {
        CloseServiceHandle(hSCMgr);
    }

    return err;
}




VOID
SetStatus()
/*++

Routine Description:

    Report current service status to the SCM.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (g_fIsRunningAsService) {
        g_Status.dwCheckPoint++;
        SetServiceStatus(g_hStatus, &g_Status);
    }
}




DWORD
Install()
/*++

Routine Description:

    Add service to the SCM database.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation succeeded.

    Win32 error code - The operation failed.

--*/
{
    DWORD       err = ERROR_SUCCESS;
    SC_HANDLE   hService = NULL;
    SC_HANDLE   hSCM = NULL;
    TCHAR       szPath[512];
    DWORD       cchPath;

    cchPath = GetModuleFileName(NULL, szPath, sizeof(szPath)/sizeof(szPath[0]));
    if (0 == cchPath) {
        err = GetLastError();
        printf("Unable to GetModuleFileName(), error %d.\n", err);
    }

    if (ERROR_SUCCESS == err) {
        hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
        if (NULL == hSCM) {
            err = GetLastError();
            printf("Unable to OpenSCManager(), error %d.\n", err);
        }
    }

    if (ERROR_SUCCESS == err) {
        hService = CreateService(hSCM,
                                 SERVICE_NAME,
                                 SERVICE_DISPLAY_NAME,
                                 SERVICE_ALL_ACCESS,
                                 SERVICE_WIN32_OWN_PROCESS,
                                 SERVICE_AUTO_START,
                                 SERVICE_ERROR_NORMAL,
                                 szPath,
                                 NULL,
                                 NULL,
                                 SERVICE_DEPENDENCIES,
                                 NULL,
                                 NULL);
        if (NULL == hService) {
            err = GetLastError();
            printf("Unable to CreateService(), error %d.\n", err);
        }
    }

    if (NULL != hService) {
        CloseServiceHandle(hService);
    }

    if (NULL != hSCM) {
        CloseServiceHandle(hSCM);
    }

    return err;
}




DWORD
Remove()
/*++

Routine Description:

    Remove service from the SCM database.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation succeeded.

    Win32 error code - The operation failed.

--*/
{
    DWORD           err = ERROR_SUCCESS;
    SC_HANDLE       hService = NULL;
    SC_HANDLE       hSCM = NULL;
    SERVICE_STATUS  SvcStatus;

    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (NULL == hSCM) {
        err = GetLastError();
        printf("Unable to OpenSCManager(), error %d.\n", err);
    }

    if (ERROR_SUCCESS == err) {
        hService = OpenService(hSCM, SERVICE_NAME, SERVICE_ALL_ACCESS);
        if (NULL == hService) {
            err = GetLastError();
            printf("Unable to OpenService(), error %d.\n", err);
        }
    }

    if (ERROR_SUCCESS == err) {
        if (!DeleteService(hService)) {
            err = GetLastError();
            printf("Unable to DeleteService(), error %d.\n", err);
        }
    }

    if (NULL != hService) {
        CloseServiceHandle(hService);
    }

    if (NULL != hSCM) {
        CloseServiceHandle(hSCM);
    }

    return err;
}




VOID
Stop()
/*++

Routine Description:

    Signal the service to stop. Does not wait for service termination before
    returning.

Arguments:

    None.

Return Value:

    None.

--*/
{
    g_fIsStopPending = TRUE;

    g_Status.dwCurrentState = SERVICE_STOP_PENDING;
    SetStatus();

    SetEvent(g_hShutdown);
}




VOID
WINAPI
ServiceCtrlHandler(
    IN  DWORD   dwControl
    )
/*++

Routine Description:

    Entry point used by Service Control Manager (SCM) to control (that is, stop,
    query, and so on) the service after it has been started.

Arguments:

    dwControl (IN) - Requested action (see docs for "Handler" function in
        Win32 SDK).

Return Value:

    None.

--*/
{
    DWORD err;

    switch (dwControl) {
    case SERVICE_CONTROL_SHUTDOWN:
    case SERVICE_CONTROL_STOP:
        Stop();
        break;

    case SERVICE_CONTROL_INTERROGATE:
        SetStatus();
        break;
    }
}




DWORD
WINAPI
ServiceMain(
    IN  DWORD   argc,
    IN  LPTSTR  argv[]
    )
/*++

Routine Description:

    Execute the service, which is called either directly or by way of
    the SCM. The service returns on error or when service shutdown is
    requested.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - The operation succeeded.

    Win32 error code - The operation failed.

--*/
{
    DWORD err = 0;

    g_fIsStopPending = FALSE;

    if (g_fIsRunningAsService) {
        g_hStatus = RegisterServiceCtrlHandler(SERVICE_NAME, ServiceCtrlHandler);
        if (NULL == g_hStatus) {
            err = GetLastError();
            printf("RegisterServiceCtrlHandler() failed, error %d.\n", err);
            return err;
        }
    }

    // Start the service immediately so the service controller and other
    // automatically started services are not delayed by long initialization.
    memset(&g_Status, 0, sizeof(g_Status)); 
    g_Status.dwServiceType      = SERVICE_WIN32;
    g_Status.dwCurrentState     = SERVICE_RUNNING; 
    g_Status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
    g_Status.dwWaitHint         = 15*1000;
    SetStatus();

    // Control Netlogon
    err = MyControlService(L"Netlogon", SERVICE_CONTROL_PAUSE);

    if (0 != err) {
        Stop();
    }
    
    WaitForSingleObject(g_hShutdown, INFINITE);

    g_Status.dwCurrentState = SERVICE_STOPPED;
    g_Status.dwWin32ExitCode = 0;
    SetStatus();

    g_fIsStopPending = FALSE;

    return g_Status.dwWin32ExitCode;
}




BOOL
WINAPI
ConsoleCtrlHandler(
    IN  DWORD   dwCtrlType
    )
/*++

Routine Description:

    Console control handler. Intercepts Ctrl+C and Ctrl+Break to simulate
    "stop" service control when running in debug mode (that is, when not
    running under the Service Control Manager).

Arguments:

    dwCtrlType (IN) - Console control type (see docs for "HandlerRoutine" in
        Win32 SDK).

Return Value:

    TRUE - The function handled the control signal.
    
    FALSE - The function did not handle the control signal.
        Use the next handler function in the list of
        handlers for this process. 

--*/
{
    switch (dwCtrlType) {
      case CTRL_BREAK_EVENT:
      case CTRL_C_EVENT:
        printf("Stopping %s...\n", SERVICE_DISPLAY_NAME);
        Stop();
        return TRUE;

      default:
        return FALSE;
    }
}




int
__cdecl
main(
    IN  int     argc,
    IN  char *  argv[]
    )
/*++

Routine Description:

    Entry point for the process. Called when started both directly from
    the command line and indirectly through the Service Control Manager.

Arguments:

    argc, argv (IN) - Command-line arguments.  Accepted arguments are:
       /install - Add the service to the Service Control Manager (SCM) database.
       /remove  - Remove the service from the SCM database.
       /debug   - Run the service as a normal process, not under the SCM.

Return Value:

    ERROR_SUCCESS - The operation succeeded.

    Win32 error code - The operation failed.

--*/
{
    int  ret = ERROR_SUCCESS;
    BOOL fInstall = FALSE;
    BOOL fRemove = FALSE;
    BOOL fDisplayUsage = FALSE;
    DWORD err = ERROR_SUCCESS;
    int iArg;

    g_fIsRunningAsService = TRUE;

    g_hShutdown = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (NULL == g_hShutdown) {
        err = GetLastError();
        printf("Unable to CreateEvent(), error %d.\n", err);
        return err;
    }

    // Parse command-line arguments.
    for (iArg = 1; iArg < argc; iArg++) {
        switch (argv[iArg][0]) {
          case '/':
          case '-':
            // An option
            if (!lstrcmpi(&argv[iArg][1], "install")) {
                fInstall = TRUE;
                break;
            }
            else if (!lstrcmpi(&argv[iArg][1], "remove")) {
                fRemove = TRUE;
                break;
            }
            else if (!lstrcmpi(&argv[iArg][1], "debug")) {
                g_fIsRunningAsService = FALSE;
                break;
            }
            else if (!lstrcmpi(&argv[iArg][1], "?")
                     || !lstrcmpi(&argv[iArg][1], "h")
                     || !lstrcmpi(&argv[iArg][1], "help")) {
                fDisplayUsage = TRUE;
                break;
            }
            else {
                // Fall through
            }

          default:
            printf("Unrecognized parameter \"%s\".\n", argv[iArg]);
            ret = -1;
            fDisplayUsage = TRUE;
            break;
        }
    }

    if (fDisplayUsage) {
        // Display usage information.
        printf("Usage:"
               "/install - Add the service to the Service Control Manager (SCM) database.\n"
               "/remove  - Remove the service from the SCM database.\n"
               "/debug   - Run the service as a normal process, not under the SCM.\n"
               "\n");
    }
    else if (fInstall) {
        // Add the service to the Service Control Manager database.
        ret = Install();

        if (ERROR_SUCCESS == ret) {
            printf("Service installed successfully.\n");
        }
        else {
            printf("Failed to install service, error %d.\n", ret);
        }
    }
    else if (fRemove) {
        // Remove the service from the Service Control Manager database.
        ret = Remove();

        if (ERROR_SUCCESS == ret) {
            printf("Service removeed successfully.\n");
        }
        else {
            printf("Failed to remove service, error %d.\n", ret);
        }
    }
    else {
        if (g_fIsRunningAsService) {
            if (!StartServiceCtrlDispatcher(DispatchTable)) {
                ret = GetLastError();
                printf("Unable to StartServiceCtrlDispatcher(), error %d.\n", ret);
            }
        }
        else {
            // Start the service without Service Control Manager supervision.
            SetConsoleCtrlHandler(ConsoleCtrlHandler, TRUE);

            ret = ServiceMain(0, NULL);
        }
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\utilc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    utilc.h

Abstract:

    This module contains error management routines.  Takes an LDAP or
    Win32 error, and produces a string error message.

Author:

    Dave Straube (DaveStr) Long Ago

Environment:

    User Mode.

Revision History:

    16-Aug-2000     BrettSh
                Added this comment block, also added the GetLdapErrEx()
                function to handle a variable LDAP handle.

--*/

#ifndef _UTILC_H_
#define _UTILC_H_

extern LDAP* gldapDS;
extern BOOL  fPopups;

const WCHAR *
DisplayErr(
    IN LDAP *   pLdap,
    IN DWORD Win32Err,
    IN DWORD LdapErr
    );

// from refc.c
BOOL
IsRdnMangled(
    IN  WCHAR * pszRDN,
    IN  DWORD   cchRDN,
    OUT GUID *  pGuid
    );


#define GetW32Err(_e)   DisplayErr(NULL, _e,0)
#define GetLdapErr(_e)  DisplayErr(gldapDS, 0,_e)
#define GetLdapErrEx(_ld, _e)  DisplayErr(_ld, 0, _e)

extern void InitErrorMessages ();
extern void FreeErrorMessages ();


#endif // _UTILC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\ntdsutil\util.cxx ===
#include <NTDSpch.h>
#pragma hdrstop

#include "ntdsutil.hxx"
#include "file.hxx"

extern "C" {
#include "windows.h"
#include "dsconfig.h"
#include "mxsutil.h"
#include "ntdsbcli.h"
#include "jetbp.h"
#include "safeboot.h"
#include "winldap.h"
#include "utilc.h"
#include "winnlsp.h"
}


#include "resource.h"


void
FormatDiskSpaceString(
    LARGE_INTEGER   *pli,
    DiskSpaceString buf
    )
/*++

  Routine Description: 

    Formats a LARGE_INTEGER as a string representing either Kb/Mb/Gb/Tb.

  Parameters: 

    pli - Pointer to LARGE_INTEGER to format.

    buf - Buffer of type DiskSpaceString which holds the formatted result.

  Return Values:

    None.

--*/
{
    // Estimate to the nearest Kb/Mb/Gb/Tb with 1 decimal point precision.

    LARGE_INTEGER   liTmp;
    LARGE_INTEGER   liWholePart;
    LARGE_INTEGER   liFraction;
    LARGE_INTEGER   li100;
    char            *pszUnits;
    char            pszFraction[40];

    li100.QuadPart = 100;

    if ( liTmp.QuadPart = (pli->QuadPart / gliOneKb.QuadPart),
         liTmp.QuadPart < gliOneKb.QuadPart )
    {
        liWholePart.QuadPart = (pli->QuadPart / gliOneKb.QuadPart);
        liFraction.QuadPart = (pli->QuadPart % gliOneKb.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart * li100.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart / gliOneKb.QuadPart);
        pszUnits = "Kb";
    }
    else if ( liTmp.QuadPart = (pli->QuadPart / gliOneMb.QuadPart),
              liTmp.QuadPart < gliOneKb.QuadPart )
    {
        liWholePart.QuadPart = (pli->QuadPart / gliOneMb.QuadPart);
        liFraction.QuadPart = (pli->QuadPart % gliOneMb.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart * li100.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart / gliOneMb.QuadPart);
        pszUnits = "Mb";
    }
    else if ( liTmp.QuadPart = (pli->QuadPart / gliOneGb.QuadPart),
              liTmp.QuadPart < gliOneKb.QuadPart )
    {
        liWholePart.QuadPart = (pli->QuadPart / gliOneGb.QuadPart);
        liFraction.QuadPart = (pli->QuadPart % gliOneGb.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart * li100.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart / gliOneGb.QuadPart);
        pszUnits = "Gb";
    }
    else 
    {
        liWholePart.QuadPart = (pli->QuadPart / gliOneTb.QuadPart);
        liFraction.QuadPart = (pli->QuadPart % gliOneTb.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart * li100.QuadPart);
        liFraction.QuadPart = (liFraction.QuadPart / gliOneTb.QuadPart);
        pszUnits = "Tb";
    }
    
    pszFraction[0] = '\0';
    sprintf(pszFraction, "%d", liFraction.LowPart);
    pszFraction[1] = '\0';
    sprintf(buf, "%d.%s %s", liWholePart.LowPart, pszFraction, pszUnits);
}

BOOL
FindExecutable(
    char            *pszExeName,
    ExePathString   pszExeFullPathName
    )
/*++

  Routine Description: 

    Searches for an executable and returns its full path.

  Parameters: 

    pszExeName - Name of executable to find.

    pszExeFullPathName - Buffer of type ExePathString which receives result.

  Return Values:

    TRUE/FALSE indicating whether the executable was found.

--*/
{
    DWORD   dwErr;
    char    *pDontCare;

    dwErr = SearchPath( NULL, 
                        pszExeName, 
                        NULL, 
                        sizeof(ExePathString), 
                        pszExeFullPathName, 
                        &pDontCare);

    if ( (0 == dwErr) || (dwErr > sizeof(ExePathString)) )
    {
        if ( dwErr > sizeof(ExePathString) )
        {
            RESOURCE_PRINT1 (IDS_BUFFER_OVERFLOW, pszExeName );
        }

        RESOURCE_PRINT1 (IDS_CANNOT_FIND_EXECUTABLE, pszExeName );
        
        return(FALSE);
    }

    return(TRUE);
}

BOOL
SpawnCommandWindow(
    char    *title,
    char    *whatToRun
    )
/*++

  Routine Description: 

    Start a command window to run the specified exe/cmd file.  
    The command window uses the same window as the parent process,
    and exits as soon as the execution terminates.
    Current process waits until child process terminates.

  Parameters: 

    title - String for the window's title bar.

    whaToRun - Name of exe/cmd file to run

  Return Values:

    TRUE on success, FALSE on error.

--*/
{
    char                *commandLine;
//  char                *shellArgs = "cmd.exe /K";
    char                *shellArgs = "cmd.exe /C";
    DWORD               dwErr;
    PROCESS_INFORMATION processInfo;
    STARTUPINFO         startupInfo;

    commandLine = (char *) alloca(strlen(shellArgs) + strlen(whatToRun) + 10);
    sprintf(commandLine, "%s \"%s\"", shellArgs, whatToRun);

    memset(&startupInfo, 0, sizeof(startupInfo));
    startupInfo.cb = sizeof(startupInfo);
    startupInfo.lpTitle = title;
    startupInfo.dwXCountChars = 80;
    startupInfo.dwYCountChars = 9999;
    startupInfo.dwFlags = STARTF_USECOUNTCHARS;

    // use this only when cmd /K
    //RESOURCE_PRINT (IDS_SPAWN_EXTERNAL_COMMAND);

    if ( !CreateProcess(
                    NULL,               // image name
                    commandLine,        // command line
                    NULL,               // process security attributes
                    NULL,               // primary thread security attributes
                    TRUE,               // inherit handles
//                    HIGH_PRIORITY_CLASS | CREATE_NEW_CONSOLE,
                    HIGH_PRIORITY_CLASS,
                    NULL,               // environment block pointer
                    NULL,               // initial current drive:\directory
                    &startupInfo,
                    &processInfo) )
    {
        dwErr = GetLastError();
        
        RESOURCE_PRINT3 (IDS_CREATING_WINDOW,
                dwErr, 
                GetW32Err(dwErr),
                commandLine);
        
        return(FALSE);
    }

    // Wait until child process exits.
    WaitForSingleObject( processInfo.hProcess, INFINITE );


    return(TRUE);
}


BOOL SpawnCommand( 
    char *commandLine, 
    LPCSTR lpCurrentDirectory, 
    WCHAR *successMsg )
/*++

  Routine Description: 

    Executes a new process in the same window. Current process waits until child process terminates.

  Parameters: 

    commandLine - Name of exe/cmd file to run
    
    lpCurrentDirectory - directory where the process should start executing
    
    successMsg - a message that should be printed after the process execution (possibly NULL)

  Return Values:

    TRUE on success, FALSE on error.

--*/

{
    DWORD               dwErr;
    DWORD               exitCode;
    PROCESS_INFORMATION processInfo;
    STARTUPINFO         startupInfo;

    memset(&startupInfo, 0, sizeof(startupInfo));
    startupInfo.cb = sizeof(startupInfo);
    

    if ( !CreateProcess(
                    NULL,               // image name
                    commandLine,        // command line
                    NULL,               // process security attributes
                    NULL,               // primary thread security attributes
                    TRUE,               // inherit handles
                    HIGH_PRIORITY_CLASS,
                    NULL,               // environment block pointer
                    lpCurrentDirectory, // initial current drive:\directory
                    &startupInfo,       // startuo info
                    &processInfo) )
    {
        dwErr = GetLastError();
        
        RESOURCE_PRINT3 (IDS_CREATING_WINDOW,
                dwErr, 
                GetW32Err(dwErr),
                commandLine);
        
        return(FALSE);
    }

    // Wait until child process exits.
    WaitForSingleObject( processInfo.hProcess, INFINITE );


    if (GetExitCodeProcess ( processInfo.hProcess, &exitCode )) {
        RESOURCE_PRINT2 (IDS_SPAWN_PROC_EXIT_CODE, exitCode, exitCode);

        if (successMsg) {
            wprintf (successMsg);
        }
    }

    return(TRUE);
}



BOOL
ExistsFile(
    char    *pszFile,
    BOOL    *pfIsDir
    )
/*++

  Routine Description: 

    Checks whether a given file exists.

  Parameters: 

    pszFile - Name of file to find.

    pfIsDir - Pointer to BOOL which identifies if found file is a directory.

  Return Values:

    TRUE if file exists, FALSE otherwise.

--*/
{
    DWORD           dwAttributes;

    dwAttributes = GetFileAttributes(pszFile); 
    if(dwAttributes == INVALID_FILE_ATTRIBUTES){
        return(FALSE);
    }

    *pfIsDir = (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;

    return(TRUE);
}

FILE *
OpenScriptFile(
    SystemInfo      *pInfo, 
    ExePathString   pszScript
    )
/*++

  Routine Description: 

    Opens a script file and returns an open FILE* to it.

  Parameters: 

    pInfo - Pointer to a SystemInfo from which is taken the initial
        location for the script file if possible.

    pszScript - Buffer of type ExePathString which receives the resulting
        script full path.

  Return Values:

    FILE pointer on success, NULL otherwise.

--*/
{
    FILE    *fp = NULL;
    DWORD   cbScript;
    int     i;
    char    *key;

    // Try to open ntds-scr.cmd in %tmp% and %temp%.

    for ( i = 0; i <= 1; i++ )
    {
        key =  ((0 == i)
                    ? "%tmp%\\ntds-scr.cmd"
                    : "%temp%\\ntds-scr.cmd");

        cbScript = ExpandEnvironmentStrings(
                                key,
                                pszScript, 
                                sizeof(ExePathString));

        if (    cbScript 
             && (cbScript <= sizeof(ExePathString))
             && _stricmp(key, pszScript) )
        {
            fp = fopen(pszScript, "w+");

            if ( fp )
            {
                return(fp);
            }
        }
    }

    // If we got here we were unable to open any script file.

    RESOURCE_PRINT (IDS_OPEN_SCRIPT_ERROR);        

    return(NULL);
}

BOOL
IsSafeMode(
    )
/*++

  Routine Description: 

    Determines if the server is booted in safe mode or not where
    safe mode == directory service repair.

  Parameters: 

    None.

  Return Values:

    TRUE if in safe mode, FALSE otherwise.

--*/
{
    DWORD   cbData;
    char    data[100];
    char    *key = "%SAFEBOOT_OPTION%";

    cbData = ExpandEnvironmentStrings(key, data, sizeof(data));

    if (    cbData 
         && (cbData <= sizeof(data))
         && !_stricmp(data, SAFEBOOT_DSREPAIR_STR_A) )
    {
        return(TRUE);
    }

    
    RESOURCE_PRINT1 (IDS_SAFE_MODE_ERROR, SAFEBOOT_DSREPAIR_STR_A );
    
    return(FALSE);
}

BOOL 
CheckIfRestored(
    )
/*++

  Routine Description: 

    Determines if the server is in the restored but not yet recovered state.

  Parameters: 

    None.

  Return Values:

    TRUE  - if we're sitting on restored files which have not been recovered 
            yet OR we get an error while determining this.
    FALSE - otherwise

--*/
{
    HKEY    hKey;
    DWORD   dwErr;
    DWORD   type;
    DWORD   cBuffer = 0;
    BOOL    fRestored = TRUE;

    // Open the DS parameters key.

    dwErr = RegOpenKey( HKEY_LOCAL_MACHINE,
                        DSA_CONFIG_SECTION,
                        &hKey);

    if ( ERROR_SUCCESS == dwErr )
    {
        dwErr = RegQueryValueExW(   hKey,
                                    RESTORE_IN_PROGRESS,
                                    NULL,
                                    &type,
                                    NULL,
                                    &cBuffer);

        if ( ERROR_FILE_NOT_FOUND == dwErr )
        {
            fRestored = FALSE;
        }
        else if ( ERROR_SUCCESS == dwErr )
        {
            // leave (fRestored == TRUE) but alert user.
        
            RESOURCE_PRINT (IDS_RESTORE_CHK1);        
        }
        else
        {
            // leave (fRestored == TRUE) but alert user.
           RESOURCE_PRINT3 (IDS_ERR_READING_REGISTRY,
                     dwErr, 
                     GetW32Err(dwErr),
                     RESTORE_IN_PROGRESS);
        }
            
        RegCloseKey(hKey);
    }
    else
    {
        // leave (fRestored == TRUE) but alert user.
       RESOURCE_PRINT3 (IDS_ERR_OPENING_REGISTRY,
                  dwErr, 
                  GetW32Err(dwErr),
                  DSA_CONFIG_SECTION);
    }

    return(fRestored);
}


void SetConsoleAttrs (void)
{
    HANDLE hdlCons = GetStdHandle (STD_ERROR_HANDLE);
    CONSOLE_SCREEN_BUFFER_INFO scrInfo;
    HWINSTA hWindowStation;
    char WinStationName[1024];
    DWORD dwNameSize;
    BOOL fSkip;

    
    SetThreadUILanguage(0);

    // SetConsoleScreenBufferSize() will mess up the telnet screen,
    // here we try to detect if the ntdsutil is in a telnet session,
    // if yes, we will skip SetConsoleScreenBufferSize()

    hWindowStation = GetProcessWindowStation();
    
    fSkip = GetUserObjectInformation(hWindowStation, 
                                     UOI_NAME, 
                                     WinStationName,
                                     1024, 
                                     &dwNameSize)
            && 
            !strcmp("TelnetSrvWinSta",WinStationName);
    
    if (   hdlCons != INVALID_HANDLE_VALUE && !fSkip ) {
            
        if (GetConsoleScreenBufferInfo (hdlCons, &scrInfo)) {
            scrInfo.dwMaximumWindowSize.Y = 9999;
            scrInfo.dwMaximumWindowSize.X = 80;
            
            SetConsoleScreenBufferSize (hdlCons, scrInfo.dwMaximumWindowSize);

        }
    } 
    // set buffers to NULL so as to be able to work under remote
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\outward-facing\ofstress\main.c ===
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ofstress/main.c

ABSTRACT:

    Just a little stress application for JeffParh's Outward Facing 
    Directory scenario.

DETAILS:

CREATED:

    07/20/2000    Brett Shirley (brettsh)

REVISION HISTORY:


--*/

#include <NTDSpch.h>
#pragma hdrstop
     
#include <winldap.h>
#include <assert.h>
#include <locale.h>
// Debugging library, andstub out FILENO and DSID, so the Assert()s will work
#include "debug.h"
#define FILENO 0
#define DSID(x, y)  (0xFFFF0000 | y)

//#include <ndnc.h>

// ---------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------
#define QUIT_WAIT_TIME_MS    30000
#define TICK_TIME_MS           250

// These are the iKinds of stress threads we might start.
#define STRESS_SIMPLE_BINDS      0
#define STRESS_KERBEROS_BINDS    1
#define STRESS_NTLM_BINDS        2 
#define STRESS_NEGOTIATE_BINDS   3
#define STRESS_ROOT_SEARCHES     4
#define STRESS_ROOT_MODIFIES     5

// Cluster and users constants.
const ULONG                  gcNodes = 2;
const ULONG                  gcUsersPerNode = 10000;

// ---------------------------------------------------------------------
// Forward declarations 
// ---------------------------------------------------------------------
//
// Stress functions
ULONG __stdcall XxxxBinds(VOID * piThread);
ULONG __stdcall RootXxxx(VOID * piThread);
// Logging functions
ULONG OfStressBeginLog(LPSTR szLogFile);
ULONG OfStressLog(ULONG iThread, LPSTR szType, LPSTR szWhat, LPSTR szMore);
ULONG OfStressLogD(ULONG iThread, LPSTR szType, LPSTR szWhat, ULONG ulNum);
ULONG OfStressEndLog(void);
// Other functions
DWORD GetDnFromDns(char * wszDns, char ** pwszDn);
void  PrintHelp(void);
void  PrintInteractiveHelp(void);

// ---------------------------------------------------------------------
// Types and Structs
// ---------------------------------------------------------------------
typedef struct {
    ULONG                    iKind;   
    char *                   szName;  
    ULONG                    cInstances;
    LPTHREAD_START_ROUTINE   pfStress;
} STRESS_THREAD;  

typedef struct {
    ULONG                    iThread;
    STRESS_THREAD *          pStressKind;
} STRESS_THREAD_SIGNAL_BLOCK;


// ---------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------
HANDLE                        ghLogFile = NULL;
ULONG                         gbQuiting = FALSE;
STRESS_THREAD_SIGNAL_BLOCK *  gaSignals = NULL;
LPSTR                         gszDnsDomainName = NULL;
LPSTR                         gszDomainDn = NULL;
ULONG                         giAcctDomain = 0;
SEC_WINNT_AUTH_IDENTITY       gAdminCreds;
//
BOOL                          gbDebug = FALSE;
ULONG                         gulSlow = 0;
ULONG                         gulOfStressFlags = 0;

// ---------------------------------------------------------------------
// Main Function
// ---------------------------------------------------------------------
INT __cdecl 
main (
    INT                argc,
    LPSTR *            argv,
    LPSTR *            envp
    )
/*++

Routine Description:

    Basic structure is this thread creates the signal blocks and 
    thread data structures, spawns a whole bunch of threads and then 
    waits for someone to hit 'q' to quit.  Once, the quit command is
    issued main signals all the threads it's time to wrap up gives
    them 30 seconds to do so and quits.

Arguments:

    argc (IN) - Number of arguments in argv.
    argv (IN) - The arguments from the command line.
    envp (IN) - The environmental variables from the shell.

Return value:

    INT - 0, success, otherwise error code.  This allows the program
    to be used in scripting.

--*/
{
    ULONG              i, dwRet;
    LONG               iArg;
    
    ULONG              cTick;
    WCHAR              wcInput = 0;
    // The optional command line parameters

    ULONG              iKind, iInstance;
    ULONG              cThreads, iThread;

    LPSTR              szLogFile = NULL;
    ULONG              cbUsedBuffer;

    // Other stuff ...
    UINT               Codepage;
                       // ".", "uint in decimal", null
    char               achCodepage[12] = ".OCP";
    
    STRESS_THREAD      aThreads[] =
    {     // Kind of thread       kind of thread name  #of   function
        { STRESS_SIMPLE_BINDS,    "SimpleBinds",       1,   XxxxBinds },
        { STRESS_NTLM_BINDS,      "NTLMBinds",         1,   XxxxBinds },
        { STRESS_NEGOTIATE_BINDS, "NegotiateBinds",    1,   XxxxBinds },
        { STRESS_ROOT_SEARCHES,   "RootSearches",      1,   RootXxxx  },
        { STRESS_ROOT_MODIFIES,   "RootModifies",      1,   RootXxxx  },
        { 0,                      NULL,                0,   NULL      },
    };
    HANDLE *           aThreadHandles = NULL;
    SYSTEMTIME         stTime;
    LDAP *             hTestLdap;
    ULONG              ulTemp;
    CHAR               szTemp[81];
    CHAR *             pcTemp;
    BOOL               bDontGetLineReturn = FALSE;


    // -------------------------------------------------------------
    //   Setup the program.
    // -------------------------------------------------------------

    //
    // Set locale to the default
    //
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%u", Codepage);
        setlocale(LC_ALL, achCodepage);
    } else {
        // We do this because LC_ALL sets the LC_CTYPE as well, and we're
        // not supposed to do that, say the experts if we're setting the
        // locale to ".OCP".
        setlocale (LC_COLLATE, achCodepage );    // sets the sort order 
        setlocale (LC_MONETARY, achCodepage ); // sets the currency formatting rules
        setlocale (LC_NUMERIC, achCodepage );  // sets the formatting of numerals
        setlocale (LC_TIME, achCodepage );     // defines the date/time formatting
    }

    //
    // Initialize the debugging libaray
    //
    DEBUGINIT(0, NULL, "ofstress");
    
    //
    // Parse the options
    //
#define InvalidSyntaxExit()    printf("Invalid syntax.  Please run \"ofstress -?\" for help.\n");  return(ERROR_INVALID_PARAMETER);
    if (argc < 2) {
        InvalidSyntaxExit();
    }

    for (iArg = 1; iArg < argc ; iArg++)
    {
        if (*argv[iArg] == '-')
        {
            *argv[iArg] = '/';
        }
        if (*argv[iArg] != '/') {

            InvalidSyntaxExit();

        } else if (argv[iArg][1] == 'd' ||
                   argv[iArg][1] == 'D'){
            
            iArg++;
            gszDnsDomainName = argv[iArg];

        } else if (argv[iArg][1] == 'a' ||
                   argv[iArg][1] == 'A') {

            iArg++;
            giAcctDomain = atoi(argv[iArg]);

        } else if (argv[iArg][1] == 'f' ||
                   argv[iArg][1] == 'F') {

            iArg++;
            szLogFile = argv[iArg];

        } else if (argv[iArg][1] == 'g' ||
                   argv[iArg][1] == 'G'){

            gbDebug = TRUE;
        
        } else if (argv[iArg][1] == 's' ||
                   argv[iArg][1] == 'S'){

            iArg++;
            gulSlow = atoi(argv[iArg]);

        } else if (argv[iArg][1] == 'o' ||
                   argv[iArg][1] == 'O'){

            iArg++;
            gulOfStressFlags = atoi(argv[iArg]);

        } else if (argv[iArg][1] == 'h' ||
                   argv[iArg][1] == 'H' ||
                   argv[iArg][1] == '?') {
            
            PrintHelp();
            return(0);

        } else {

            InvalidSyntaxExit();

        }
    }
    if (giAcctDomain == 0 || gszDnsDomainName == NULL) {
        wprintf(L"FATAL: either acct-domain or dnsDomainName wasn't provied");
        InvalidSyntaxExit();
    }
    dwRet = GetDnFromDns(gszDnsDomainName, &gszDomainDn);
    if (dwRet) {
        printf("FATAL: error %d converting %s to a DN\n", dwRet, gszDnsDomainName);
        InvalidSyntaxExit();
    }
    

    //
    // Initialize the random number generator
    //
    GetSystemTime(&stTime); // should be random enough.
    srand(((((stTime.wMinute * 60) + stTime.wSecond) * 1000) + stTime.wMilliseconds) % 0xFFFFFFFF );
    
    //
    // Start the logging mechanism
    //
    if(dwRet = OfStressBeginLog(szLogFile)){
        wprintf(L"FATAL: Couldn't open log file %S\n", szLogFile);
        return(dwRet);
    }
    // Example Use: OfStressLog("SimpleBind", "server1.dnsname");

    //
    // Setup the administrator credentials
    //
#if 1
    gAdminCreds.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
    gAdminCreds.Domain = gszDnsDomainName;
    gAdminCreds.DomainLength = strlen(gAdminCreds.Domain);
    gAdminCreds.User = "Administrator";
    gAdminCreds.UserLength = strlen(gAdminCreds.User);
    gAdminCreds.Password = "";
    gAdminCreds.PasswordLength = strlen(gAdminCreds.Password);
#else
    gAdminCreds.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
    gAdminCreds.Domain = "brettsh-spice.nttest.microsoft.com";
    gAdminCreds.DomainLength = strlen(gAdminCreds.Domain);
    gAdminCreds.User = "Administrator";
    gAdminCreds.UserLength = strlen(gAdminCreds.User);
    gAdminCreds.Password = "oj";
    gAdminCreds.PasswordLength = strlen(gAdminCreds.Password);
#endif


    // 
    // Log and Print the initial info
    // 
    printf("Beggining with:\n\t%s\n\t%s\n\t%d\n",
           gszDnsDomainName, gszDomainDn, giAcctDomain);
    OfStressLog (0, "main", "DnsDomainName: ", gszDnsDomainName);
    OfStressLog (0, "main", "DomainDn: ", gszDomainDn);
    OfStressLogD(0, "main", "AcctDomain: ", giAcctDomain);

    //
    // Set up the threads signal blocks
    //
    cThreads = 0;
    for (iKind = 0; aThreads[iKind].szName; iKind++) {
        cThreads += aThreads[iKind].cInstances;
    }
    cThreads++; // Plus one for this, the original thread
    gaSignals = LocalAlloc(LMEM_FIXED, cThreads * sizeof(STRESS_THREAD_SIGNAL_BLOCK));
    if (gaSignals == NULL) {
        wprintf(L"FATAL: No memory\n");
        exit(ERROR_NOT_ENOUGH_MEMORY);
    }
    aThreadHandles = LocalAlloc(LMEM_FIXED, cThreads * sizeof(HANDLE));
    if (aThreadHandles == NULL) {
        wprintf(L"FATAL: No memory\n");
        exit(ERROR_NOT_ENOUGH_MEMORY);
    }
    
    // -------------------------------------------------------------
    //   Run the program.
    // -------------------------------------------------------------

    //
    // First, we need to spawn all the stress threads
    //
    iThread = 1;
    for (iKind = 0; aThreads[iKind].szName; iKind++) {
        for (iInstance = 0; iInstance < aThreads[iKind].cInstances; iInstance++) {
            
            //
            // First, initialize our little thread signal block
            //
            gaSignals[iThread].iThread = iThread;
            gaSignals[iThread].pStressKind = &aThreads[iKind];
            
            OfStressLogD(0, "main", "Start Thread: ", iThread);

            //
            // Second, spawn the worker stress thread
            //
            aThreadHandles[iThread] = (HANDLE) _beginthreadex(NULL,
                           0,
                           aThreads[iKind].pfStress,
                           &(gaSignals[iThread].iThread),
                           0,
                           NULL);

            printf("    Started thread: %u - %s\n", iThread,
                   aThreads[iKind].szName);

            iThread++;
        }
    }
    Assert(iThread == cThreads);
    
    //
    // Second we wait in our user interface loop
    //
    while (gbQuiting == FALSE) {

        wprintf(L"Waiting for user command: ");

        wcInput = getwchar();
        switch (wcInput) {
        
        case L'q':
            OfStressLog(0, "main", "Initiating quit ...", NULL);
            gbQuiting = TRUE;
            break;

        // Code.Improvement, pause, restart threads, fail nodes, log stuff????
        case L'p':
            // Pause threads
            dwRet = scanf("%u", &iThread);
            if (dwRet) {
                if (iThread == 0) {
                    for (iThread = 1; iThread < cThreads; iThread++) {
                        SuspendThread(aThreadHandles[iThread]);
                    }
                } else if (iThread < cThreads &&
                           iThread > 0) {
                    SuspendThread(aThreadHandles[iThread]);
                } else {
                    wprintf(L"Invalid thread index %u was provided.\n", iThread);
                }
            }
            break;

        case L'r':
            // Pause threads
            dwRet = scanf("%u", &iThread);
            if (dwRet) {
                if (iThread == 0) {
                    for (iThread = 1; iThread < cThreads; iThread++) {
                        ResumeThread(aThreadHandles[iThread]);
                    }
                } else if (iThread < cThreads &&
                           iThread > 0) {
                    ResumeThread(aThreadHandles[iThread]);
                } else {
                    wprintf(L"Invalid thread index %u was provided.\n", iThread);
                }
            }

        case L'd':
            OfStressLog(0, "debug", "Starting debug mode ...", NULL);
            gbDebug = TRUE;
            break;

        case L'g':
            OfStressLog(0, "debug", "Ending debug mode ...", NULL);
            gbDebug = FALSE;
            gulSlow = 0;
            break;

        case L'a':
        case L'A':
            dwRet = scanf("%u", &ulTemp);
            if (dwRet) {
                if (wcInput == L'A') {
                    gulOfStressFlags = ulTemp;
                } else {
                    gulOfStressFlags = gulOfStressFlags | ulTemp;
                }
            }
            printf("New options are: 0x%x\n", gulOfStressFlags);
            break;      

        case L's':
            dwRet = scanf("%u", &ulTemp);
            if (dwRet) {
                gulOfStressFlags = gulOfStressFlags & ~ulTemp;
            }
            printf("New options are: 0x%x\n", gulOfStressFlags);
            break; 

        case L'l':
            pcTemp = fgets(szTemp, 80, stdin);
            if (pcTemp == NULL) {
                break;
            }
            pcTemp = strchr(szTemp, '/n');
            if (pcTemp != NULL) {
                *pcTemp = '/0';
            }
            OfStressLog(0, "userlogging", szTemp, NULL);
            bDontGetLineReturn = TRUE;
            break;
        
        case L'S':
            dwRet = scanf("%u", &ulTemp);
            if (dwRet) {
                gulSlow = ulTemp;
            }
            printf("New slow down rate is: %d\n", gulSlow);
            break;

        case L'?':
        case L'h':
        case L'H':
            PrintInteractiveHelp();
            break;

        case L'\n':
            // ignore ...
            break;

        default:
            wprintf(L"Unrecognized command '%c', type ?<return> for help.\n", wcInput);
        }
           
        if(!bDontGetLineReturn){
            wcInput = getwchar();
            // BUGBUG This assert goes off sometimes, and it kind of confuses the parser
            // Not sure exactly how to deal with this, and not sure what triggers it.
            Assert(wcInput == L'\n');
        }
    }

    // -------------------------------------------------------------
    //   Quit the program.
    // -------------------------------------------------------------

    //
    // Try to quit cleanly, wait a little while for the stress
    // threads to finish.
    //
    wprintf(L"We're quiting now (this might take some time) ...\n");
    dwRet = WaitForMultipleObjects(cThreads-1, // first handle is blank
                                   &(aThreadHandles[1]), 
                                   TRUE,
                                   10 * 1000);

    if (dwRet == WAIT_OBJECT_0 ||
        dwRet == WAIT_ABANDONED_0) {
        wprintf(L"Clean shutdown, all worker threads quit.\n");
    } else {
        wprintf(L"Timeout, bad shutdown, killing threads\n");
        
        Assert(dwRet == WAIT_TIMEOUT);

        for (iThread = 1; iThread < cThreads; iThread++) {

            dwRet = WaitForSingleObject(aThreadHandles[iThread], 0);
            if( WAIT_OBJECT_0 != dwRet &&
                WAIT_ABANDONED_0 != dwRet){
                printf("    killing thread %u - %s\n", iThread,
                       gaSignals[iThread].pStressKind->szName);
                dwRet = TerminateThread(aThreadHandles[iThread], 1);
            }
        }
    }

    // Close handles of all threads.
    for (iThread = 1; iThread < cThreads; iThread++) {
        dwRet = CloseHandle(aThreadHandles[iThread]);
        Assert(dwRet != 0);
    }

    // Close log file.
    OfStressEndLog();

    // Close debugging package.
    DEBUGTERM();

    return(0);
} /* wmain  */

// ---------------------------------------------------------------------
// Other/Helper Functions
// ---------------------------------------------------------------------

void
SlowDown()
/*++

Routine Description:

    This basically slows down the stress app.  The slow down function is
    constructed so it doesn't block for more than 1/2 a second before checking
    if someone has sped up the program or if we're quiting yet.

--*/
{
    ULONG  cTimesToSleep, i;

    // Rules are user set slow down speed overrules all, if no slow down
    // speed is set, we'll just quit right away, except if we're in debug
    // mode in which case we'll slow to 3 second intervals, which I found
    // moderately debuggable.
    cTimesToSleep = ((gulSlow) ? gulSlow : ((gbDebug) ? 3000 : 0)) / 500;
    
    // Was having to kill sleeping threads.
    if (gbQuiting) {
        return;
    }
    for (i = 0; i < cTimesToSleep; i++) {
        Sleep(500);
        // Requery our sleep time, incase someone set it while we were 
        // sleeping, this makes it much more responsive.
        cTimesToSleep = ((gulSlow) ? gulSlow : ((gbDebug) ? 3000 : 0)) / 500;
        if (gbQuiting) {
            return;
        }
    }
}

void
PrintInteractiveHelp(void)
/*++

Routine Description:

    Prints the interactive help.

--*/
{
    //      ---------------------------------- 80 char line --------------------------------
    printf("The following commands are available:\n");
    printf("   q       - Quit program.\n");
    printf("   d       - Start debug mode.\n");
    printf("   g       - End debug mode.\n");
    printf("   a <num> - Add <num> to options.\n");
    printf("   A <num> - Replace options with <num>.\n");
    printf("   s <num> - Remove <num> from options.\n");
    printf("   S <num> - Set slow down rate to <num> (milliseconds).\n");
    printf("   p <num> - Pause thread <num> (Use 0 for all threads).\n");
    printf("   r <num> - Restart thread <num> (Use 0 for all threads).\n");
    printf("   l <str> - Logs the string <str> to the log file, for check points.\n");
    printf("   ?       - Print this interactive help screen.\n");
}

void
PrintHelp(void)
/*++

Routine Description:

    Prints the command line help.

--*/
{
    //      ---------------------------------- 80 char line --------------------------------
    printf("Command syntax: ofstress <-option argument> <-option>\n");
    printf("                \n");
    printf("   Required Arguments:\n");
    printf("    -d <dom>    The DNS domain name of the account domain to target.\n");
    printf("    -a <num>    The number of the account domain to target.\n");
    printf("                \n");
    printf("   Optional Arguments:\n");
    printf("    -f <file>   The relative or full path of the log file to create.\n");
    printf("    -?          displays this help screen and quits.\n");
    printf("                \n");
    printf("Example: ofstress -d ofd-acct2.nttest.microsoft.com -a 2\n");
}

DWORD
GetDnFromDns(
    IN      char *       szDns,
    OUT     char **      pszDn
    )       
/*++

Routine Description:

    Takes DNS form domain returns DN form domain in LocalAlloc()'d 
    memory

Arguments:

    szDns (IN) - This is the DNS name to convert to a DN.
    pszDn (OUT) - This is the pointer to allocate the buffer in,
        to return with the DN.  It will be LocalAlloc()'d.

Return value:

    Win32 Error.

--*/
{
    DWORD         dwRet = ERROR_SUCCESS;
    char *        szFinalDns = NULL;
    DS_NAME_RESULT *  pdsNameRes = NULL;

    Assert(szDns);
    Assert(pszDn);

    *pszDn = NULL;

    __try{ 
        szFinalDns = LocalAlloc(LMEM_FIXED, 
                                  (strlen(szDns) + 3) * sizeof(char));
        if(szFinalDns == NULL){
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }
        strcpy(szFinalDns, szDns);
        strcat(szFinalDns, "/");

        // DsCrackNames to the rescue.
        dwRet = DsCrackNames(NULL, DS_NAME_FLAG_SYNTACTICAL_ONLY,
                             DS_CANONICAL_NAME,
                             DS_FQDN_1779_NAME, 
                             1, &szFinalDns, &pdsNameRes);
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }
        if((pdsNameRes == NULL) ||
           (pdsNameRes->cItems < 1) ||
           (pdsNameRes->rItems == NULL)){
            dwRet = ERROR_INVALID_PARAMETER;
            __leave;
        }
        if(pdsNameRes->rItems[0].status != DS_NAME_NO_ERROR){
            dwRet = pdsNameRes->rItems[0].status;
            __leave;
        }
        if(pdsNameRes->rItems[0].pName == NULL){
            dwRet = ERROR_INVALID_PARAMETER;
            Assert(!"Wait how can this happen?\n");
            __leave;
        }
        // The parameter that we want is
        //    pdsNameRes->rItems[0].pName

        *pszDn = LocalAlloc(LMEM_FIXED, 
                            (strlen(pdsNameRes->rItems[0].pName) + 1) * 
                            sizeof(char));
        if(*pszDn == NULL){
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }

        strcpy(*pszDn, pdsNameRes->rItems[0].pName);

    } __finally {
        if(szFinalDns) { LocalFree(szFinalDns); }
        if(pdsNameRes) { DsFreeNameResult(pdsNameRes); }
    }

    return(dwRet);
}

ULONG
OfStressBeginLog(
    LPSTR     szLogFile
)
/*++

Routine Description:

    Sets up the ofstress logging mechanism.

Arguments:

    szLogFile (IN) - Name of the log file to use.  If not specified
        we default to OfdStressLog.txt.  We always overwrite the log
        file.

Return value:

    Win32 Error.

--*/
{
    ULONG      ulRet;
    
    if (szLogFile == NULL) {
        szLogFile = "OfdStressLog.txt";
    }

    ghLogFile = CreateFile(szLogFile, 
                           GENERIC_WRITE, 
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
    if (ghLogFile == INVALID_HANDLE_VALUE) {
        ulRet = GetLastError();
        printf("FATAL: Couldn't open log file %s with %u\n", szLogFile, ulRet);
        return(ulRet);
    }
    
    ulRet = OfStressLog(0, "Logging", "Starting log ...", NULL);
    return(ulRet);
}

ULONG
OfStressLog(
    ULONG          iThread,
    LPSTR          szType,
    LPSTR          szMessage,
    LPSTR          szMore
)
/*++

Routine Description:

    Main logging function, all psuedo log functions should still destill down
    to this logging function so a consistent format is easily maintained and
    changed.
    
    Log format:
    yyyy/mm/dd hh:mm:ss.mls<tab>nn<tab>ThreadType<tab>Message
        Where "yyyy/mm/dd hh:mm:ss.mls" is formatted date down to milliseconds.
        Where "nn" is the thread number.
        Where "ThreadType" is the type of stress thread (SimpleBinds, RootSearches, etc).
        Where "Message" is the thing we want to communicate.
        
    Long Example of begining Log File (cut a little):
        2001/10/12 22:53:37.014	0	Logging	Starting log ...
        2001/10/12 22:53:37.014	0	main	DnsDomainName: bas-ofd-a1.bas-ofd.nttest.microsoft.com
        2001/10/12 22:53:37.014	0	main	DomainDn: DC=bas-ofd-a1,DC=bas-ofd,DC=nttest,DC=microsoft,DC=com
        2001/10/12 22:53:37.014	0	main	AcctDomain: 1
        2001/10/12 22:53:37.014	0	main	Start Thread: 1
        2001/10/12 22:53:37.014	0	main	Start Thread: 2
        2001/10/12 22:53:37.014	0	main	Start Thread: 3
        2001/10/12 22:53:37.014	0	main	Start Thread: 4
        2001/10/12 22:53:37.014	0	main	Start Thread: 5
        2001/10/12 22:53:37.014	1	SimpleBinds	Beginning stress thread
        2001/10/12 22:53:37.034	1	SimpleBinds	ldap_open successful.
        2001/10/12 22:53:37.034	2	NTLMBinds	Beginning stress thread
        2001/10/12 22:53:37.034	2	NTLMBinds	ldap_open successful.
        2001/10/12 22:53:37.044	3	NegotiateBinds	Beginning stress thread
        2001/10/12 22:53:37.044	3	NegotiateBinds	ldap_open successful.
        2001/10/12 22:53:37.044	4	RootSearches	Beginning stress thread ...
        2001/10/12 22:53:37.044	4	RootSearches	ldap_open successful.
        2001/10/12 22:53:37.044	5	RootModifies	Beginning stress thread ...
        2001/10/12 22:53:37.054	5	RootModifies	ldap_open successful.
        2001/10/12 22:53:37.194	1	SimpleBinds	failure DC: 2, userID: 20041, ulRet: 49
        2001/10/12 22:53:37.194	1	SimpleBinds	switching dcs to: 1
        2001/10/12 22:53:37.324	1	SimpleBind	success DC: 1, user: of-acct1-41
        2001/10/12 22:53:37.905	5	RootModifies	ContainerDn: CN=Ofd-Stress-c5638850-4084-470a-af17-70af690152f2,DC=bas-ofd-a1,DC=bas-ofd,DC=nttest,DC=microsoft,DC=com
        2001/10/12 22:53:38.045	5	RootModifies	Creating Object: CN=Ofd-Stress-c5638850-4084-470a-af17-70af690152f2,DC=bas-ofd-a1,DC=bas-ofd,DC=nttest,DC=microsoft,DC=com
        2001/10/12 22:53:38.065	4	RootSearches	success: ds13x13.bas-ofd-a1.bas-ofd.nttest.microsoft.com
        2001/10/12 22:53:38.135	1	SimpleBind	success DC: 1, user: of-acct1-5724
        2001/10/12 22:53:38.165	2	NTLMBind	success DC: 1, user: of-acct1-6334
        2001/10/12 22:53:38.275	5	RootModifies	success: ds13x13.bas-ofd-a1.bas-ofd.nttest.microsoft.com
        2001/10/12 22:53:38.396	5	RootModifies	modified successfully: LimaReansABEYucky

Arguments:

    iThread (IN) - The local thread number we are, 0 is generally used for the main
        part of the program, and all the stress threads have a number 1+.
    szType (IN) - The "ThreadType" from the log format, such as SimpleBinds, 
        RootModifies, etc.
    szMessage (IN) - The message to print out.
    szMore (IN) - This is actually just more message to concatonate without a space
        to szMessage.  Just found it was very convienent to have two possible strings
        and deal with the buffer here.

Return value:

    Win32 Error.

--*/
{
    ULONG          ulRet;
    ULONG          cbBuffer = 400;
    LPSTR          szBuffer = alloca(cbBuffer);
    ULONG          cbUsedBuffer;
    SYSTEMTIME     stTime;       

    // 100 is the size of the two commas, two tabs, and time string
    if (cbBuffer < ((strlen(szType) 
                    + strlen(szMessage) 
                    + ((szMore != NULL) ? strlen(szMore) : 0)
                    + 100 /* for time string plus thread number plus some. */)) ) {
        Assert(!"Logging too much info, please reduce.");
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    
    GetSystemTime(&stTime);
    // Target Time Format: "2001/10/08 13:40:37.000" size: 23 chars 
    if (szMore) {
        sprintf(szBuffer, "%04u/%02u/%02u %02u:%02u:%02u.%03u" 
                          "\t%u\t%s\t%s%s\r\n",
                stTime.wYear, stTime.wMonth, stTime.wDay, stTime.wHour,
                stTime.wMinute, stTime.wSecond, stTime.wMilliseconds,
                iThread, szType, szMessage, szMore);
    } else {
        sprintf(szBuffer, "%04u/%02u/%02u %02u:%02u:%02u.%03u" 
                          "\t%u\t%s\t%s\r\n",
                stTime.wYear, stTime.wMonth, stTime.wDay, stTime.wHour,
                stTime.wMinute, stTime.wSecond, stTime.wMilliseconds,
                iThread, szType, szMessage);
    }
    cbUsedBuffer = strlen(szBuffer);

    if (gbDebug) {
        printf("      debug[%02u:%02u.%03u]: %s", stTime.wMinute, stTime.wSecond,
               stTime.wMilliseconds, &szBuffer[24] ); // Start on char after first tab.
    }

    if (0 == WriteFile(ghLogFile,
                       szBuffer,
                       cbUsedBuffer,
                       &cbUsedBuffer,
                       NULL)){
        // WriteFile had an error
        ulRet = GetLastError();
        wprintf(L"FATAL: Couldn't write to log file with %u\n", ulRet);
        return(ulRet);
    }

    return(ERROR_SUCCESS);
}

ULONG
OfStressLogD(
    ULONG          iThread,
    LPSTR          szType,
    LPSTR          szMessage,
    ULONG          ulNum          
)
/*++

Routine Description:

    Logs a message and a number at the end of that message.

Arguments:

    iThread (IN) - The local thread number we are, 0 is generally used for the main
        part of the program, and all the stress threads have a number 1+.
    szType (IN) - The "ThreadType" from the log format, such as SimpleBinds, 
        RootModifies, etc.
    szMessage (IN) - The message to print out.
    ulNum (IN) - The number to print after the message.

Return value:

    Win32 Error.

--*/
{
    char           szBuffer[20];
    
    _itoa(ulNum, szBuffer, 10);

    return(OfStressLog(iThread, szType, szMessage, szBuffer));
}

ULONG
OfStressLogBind(
    ULONG          iThread,
    LPSTR          szType,
    LPSTR          szUser,
    ULONG          iDc
)
/*++

Routine Description:

    Logs a bind success.

Arguments:

    iThread (IN) - The local thread number we are, 0 is generally used for the main
        part of the program, and all the stress threads have a number 1+.
    szType (IN) - The "ThreadType" from the log format, such as SimpleBinds, 
        RootModifies, etc.  Except, this will obviously always be a bind type
        thread.
    szUser (IN) - The user that succeeded at the bind.
    iDc (IN) - The DC we ended up binding against.

Return value:

    Win32 Error.

--*/
{
    char           szBuffer[100];

    sprintf(szBuffer, "success DC: %d, user: %s", iDc, szUser);

    return(OfStressLog(iThread, szType, szBuffer, NULL));
}

ULONG
OfStressLogBindFailure(
    ULONG          iThread,
    LPSTR          szType,
    ULONG          iUser,
    ULONG          ulRet,
    ULONG          iDc
)
/*++

Routine Description:

    Logs a bind failure.

Arguments:

    iThread (IN) - The local thread number we are, 0 is generally used for the main
        part of the program, and all the stress threads have a number 1+.
    szType (IN) - The "ThreadType" from the log format, such as SimpleBinds, 
        RootModifies, etc.  Except, this will obviously always be a bind type
        thread.
    iUser (IN) - The user number that failed the bind.
    ulRet (IN) - The error of the bind failure.
    iDc (IN) - The DC we just failed against.
    

Return value:

    Win32 Error.

--*/
{
    char           szBuffer[120];

    sprintf(szBuffer, "failure DC: %d, userID: %d, ulRet: %d", iDc, iUser, ulRet);

    return(OfStressLog(iThread, szType, szBuffer, NULL));
}

ULONG
OfStressEndLog(
    void
)
/*++

Routine Description:

    This closes up the log file properly.

Return value:

    Win32 Error.

--*/
{
    ULONG          ulRet;

    if(0 == CloseHandle(ghLogFile)){
        ulRet = GetLastError();
        wprintf(L"FATAL: Couldn't close log file with %u\n", ulRet);
        return(ulRet);
    }

    ghLogFile = NULL;
    return(ERROR_SUCCESS);
}

ULONG
DoBind(
    LDAP *     hLdap,
    ULONG      iThread,
    ULONG      iBindKind,
    ULONG      iUser,
    ULONG      iDc,
    ULONG      iAcctDomain // Crap why did we have to have this
)
/*++

Routine Description:

    This routine takes a user, DC, domain and bind type and then uses this 
    information to create the right user string, password, etc and try to bind
    using the bind type provided.

Arguments:

    hLdap (IN) - This is the LDAP handle to use.
    iThread (IN) - For logging purposes, the number of the thread we are.
    iBindKind (IN) - One of STRESS_SIMPLE_BINDS, STRESS_NTLM_BINDS, or
        STRESS_NEGOTIATE_BINDS.
    iUser (IN) - The number of the user to try.
    iDc (IN) - The DC we're supposedly to be targeting.
    iAcctDomain (IN) - This is just a piece of information to correctly
        create the user string from the ldifde files provided.

Return value:

    Win32 Error.

--*/
{
    ULONG                    ulRet = 0;
    SEC_WINNT_AUTH_IDENTITY  Creds;
    LPSTR                    szUserDn;

    // Example:
    // wszUserDn = CN=of-acct1-0,CN=Outward-facing-DC1,DC=bas-ofd-a1,DC=bas-ofd,DC=nttest,DC=microsoft,DC=com
    // wszUserName = of-acct1-0
    // wszUserDomain = bas-ofd-a1
    // wszUserPassword = of-acct1-0
            
    // 
    // Fill in the creds block
    //
    Creds.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
    Creds.Domain = gszDnsDomainName;
    Creds.DomainLength = strlen(Creds.Domain);
    Creds.User = alloca(60); // Should be plenty for 10 (num) + 10 (num) + 8 char str
    sprintf(Creds.User, "of-acct%d-%d", iAcctDomain, iUser);
    Creds.UserLength = strlen(Creds.User);
    // Is this valid?  pointing password to same as user?
    Creds.Password = Creds.User;
    Creds.PasswordLength = Creds.UserLength;

    switch (iBindKind) {
    case STRESS_SIMPLE_BINDS:
        
        // Construct DN for the simple bind case.
        szUserDn = alloca(strlen("CN=%s,CN=Outward-facing-DC%d,%s") 
                          + strlen(Creds.User) 
                          + strlen(gszDomainDn)
                          + 44 /* size of 2 nums plus NULL plus some */ );
        sprintf(szUserDn, "CN=%s,CN=Outward-facing-DC%d,%s",
                 Creds.User, iDc, gszDomainDn);
        ulRet = ldap_simple_bind_s(hLdap, szUserDn, Creds.Password);
        if (gbDebug) {
            szUserDn[30] = '\0'; // We can mutilate this, because we won't need it again.
            printf("   SimpleBind: %d, UserCreds %s %s\n", ulRet, szUserDn, Creds.Password);
        }
        if (ulRet == 0) {
            OfStressLogBind(iThread, "SimpleBind", Creds.User, iDc);
        }
        break;

    case STRESS_NTLM_BINDS:
        
        ulRet = ldap_bind_sW(hLdap, NULL, (LPWSTR) &Creds, LDAP_AUTH_NTLM);
        if (gbDebug) {
            printf("   NtlmBind: %d, UserCreds %s\\%s %s\n", ulRet, Creds.Domain, Creds.User, Creds.Password);
        }
        if (ulRet == 0) {
            OfStressLogBind(iThread, "NTLMBind", Creds.User, iDc);
        }
        break;

    case STRESS_NEGOTIATE_BINDS:

        ulRet = ldap_bind_sW(hLdap, NULL, (LPWSTR) &Creds, LDAP_AUTH_NEGOTIATE);
        if (gbDebug) {
            printf("   NegBind: %d, UserCreds %s\\%s %s\n", ulRet, Creds.Domain, Creds.User, Creds.Password);
        }
        if (ulRet == 0) {
            OfStressLogBind(iThread, "NegotiateBind", Creds.User, iDc);
        }
        break;

    default:
        wprintf(L"Hmmm, unrecognized bind type!\n");
        Assert(!"This should never happend, programmer error.");
    }


    return(ulRet);
}

// ---------------------------------------------------------------------
// Stress Functions
// ---------------------------------------------------------------------

ULONG __stdcall 
XxxxBinds(
    VOID * piThread
)
/*++

Routine Description:

    Main bind stress function.  This basically repeatedly binds, and binds
    failing over to try the next DC if binds start failing.  We quite when
    gbQuiting is set to TRUE.

Arguments:

    piThread (IN) - This is a pointer to the local thread number this 
        program has assigned this thread.  This is needed because this
        number is also the index into the global gaSignals array of
        our paticular signal block.
    gaSignal[*piThread] - Not technically and argument, but really this
        is a global array, that was the entire purpose for the only true
        argument to this function (piThread).  So We list is as an
        argument.  Really, however we're more interested in the following
        fields:
            iKind (IN) - The kind of stress thread.  For use to 
                differentiate a mostly similar function, like this
                one, to do something different only at a few key points.
            szName (IN) - The ThreadType, to be provided to logging
                functions.  This is really a user friendly iKind.
    gbQuiting (IN) - Not technically an argument to this function, but
        a global we use.  This boolean is set by the main thread, when
        the user has instructed the application to quit.

Return value:

    Win32 Error.

--*/
{
    ULONG    iMyThread = *((ULONG *)piThread);
    LPSTR    szName = gaSignals[iMyThread].pStressKind->szName;
    ULONG    iBindKind = gaSignals[iMyThread].pStressKind->iKind;
    ULONG    iUser, iCurrentDc, iInitialDc;
    ULONG    ulRet;
    HANDLE   hLdap = NULL;
    LPSTR    pszAttrFilter [] = { "dnsHostName", "currentTime", NULL };
    PLDAPMessage pmResult = NULL, pmEntry;

    Assert(iBindKind == STRESS_SIMPLE_BINDS || 
           iBindKind == STRESS_KERBEROS_BINDS ||
           iBindKind == STRESS_NTLM_BINDS || 
           iBindKind == STRESS_NEGOTIATE_BINDS);
    Assert(gcNodes == 2 && "Haven't tested more than 2 nodes, but should work.");

    OfStressLog(iMyThread, szName, "Beginning stress thread", NULL);

    hLdap = ldap_open(gszDnsDomainName, LDAP_PORT);
    if (hLdap == NULL) {
        printf("FATAL: ldap_open failed\n");
        if ( ! (gulOfStressFlags & 0x02)) {
            // For debugging sometimes we like to not quit even when 
            return(0);
        }
    } else {
        OfStressLog(iMyThread, szName, "ldap_open successful.", NULL);
        printf("Thread: %d - ldap_open() success\n", iMyThread);
    }
    iCurrentDc = 1;
    
    while (!gbQuiting) {

        // Generate a random user in the right range
        // NOTE: This may not generate an exactly equal distribution of
        // user IDs, but it should be good enough.
        iUser = rand() % gcUsersPerNode; 

        iInitialDc = iCurrentDc;
        do {

            //
            // Try the actual bind
            //
            ulRet = DoBind(hLdap, 
                           iMyThread,
                           iBindKind, 
                           // Note this 2 doesn't belong here, but the
                           // ldife files were wrong.
                           iUser + (2 * gcUsersPerNode * iCurrentDc),
                           iCurrentDc + 1,
                           giAcctDomain );

            if (ulRet == LDAP_SUCCESS) {
                // Logged in, DoBind is successful
                break;
            } else {
                if (gbDebug) {
                    printf("   %s bind failure on dc %d for user %d\n", 
                            szName, iCurrentDc + 1, (iUser + (2 * gcUsersPerNode * iCurrentDc)));
                }
                OfStressLogBindFailure(iMyThread, szName, 
                                       (iUser + (2 * gcUsersPerNode * iCurrentDc)), 
                                       ulRet, iCurrentDc + 1);
            }

            iCurrentDc = ++iCurrentDc % gcNodes;
            OfStressLogD(iMyThread, szName, "switching dcs to: ", iCurrentDc + 1);
            // We'll quit when we've tried all DCs.
            
            SlowDown();
        } while ( iCurrentDc != iInitialDc );

        if (ulRet) {
            OfStressLogBindFailure(iMyThread, szName, 
                                   (iUser + (2 * gcUsersPerNode * iCurrentDc)), 
                                   ulRet, iCurrentDc + 1);
        }

        SlowDown();
    }
    
    //
    // Signal the end master thread that we quit cleanly
    //
    ldap_unbind(hLdap);
    return(0);
}
            
ULONG __stdcall 
RootXxxx(
    VOID * piThread
)
/*++

Routine Description:

    Modify and RootDSE search stress function.  Function continously
    searches the root DSE, and in the case of the modify stress, modifies
    an object the thread created.  At any time we need to be prepared to
    re-create the modify object, because a node could've failed, and the
    object could've not replicated there yet.  We quite when gbQuiting is
    set to TRUE.
      
Arguments:

    piThread (IN) - This is a pointer to the local thread number this 
        program has assigned this thread.  This is needed because this
        number is also the index into the global gaSignals array of
        our paticular signal block.
    gaSignal[*piThread] - Not technically and argument, but really this
        is a global array, that was the entire purpose for the only true
        argument to this function (piThread).  So We list is as an
        argument.  Really, however we're more interested in the following
        fields:
            iKind (IN) - The kind of stress thread.  For use to 
                differentiate a mostly similar function, like this
                one, to do something different only at a few key points.
            szName (IN) - The ThreadType, to be provided to logging
                functions.  This is really a user friendly iKind.
    gbQuiting (IN) - Not technically an argument to this function, but
        a global we use.  This boolean is set by the main thread, when
        the user has instructed the application to quit.

Return value:

    Win32 Error.

--*/
{
    ULONG    ulRet;
    ULONG    iMyThread = *((ULONG *)piThread);
    LPSTR    szName = gaSignals[iMyThread].pStressKind->szName;
    ULONG    iStressKind = gaSignals[iMyThread].pStressKind->iKind;
    LDAP *   hLdap;
    LPSTR    pszAttrFilter [] = { "dnsHostName", "currentTime", NULL };
    PLDAPMessage pmResult = NULL, pmEntry;
    char **  pszDnsHostName = NULL;
    GUID     ContainerGuid = { 0, 0, 0, 0 };
    LPSTR    szContainerGuid;
    LPSTR    szContainerDn;
    LDAPMod * pMods[2];
    LDAPMod * pAdd[3];
    LDAPMod  DescModify;
    LDAPMod  ObjectClass;
    CHAR *   pszDescValues[2];
    CHAR *   pszObjectClassValues[2];
    ULONG    cbTemp;
    ULONG    iTemp;
    char     chTemp;
    // In this description, no char past the 4th should repeat (cap sensitive),
    // so are modulation is always guaranteed to produce a different string.
    char     szDesc [] = "LimaBeansAREYucky"; 
    ULONG    cbDesc;
    
    // 
    // Start logging
    //
    OfStressLog(iMyThread, szName, "Beginning stress thread ...", NULL);

    //
    // Setup the ldap connection.
    //
    hLdap = ldap_open(gszDnsDomainName, LDAP_PORT);
    if (hLdap == NULL) {
        wprintf(L"FATAL: couldn't ldap_open\n");
        return(0);
    } else {
        OfStressLog(iMyThread, szName, "ldap_open successful.", NULL);
    }
    
    ulRet = ldap_bind_s(hLdap, NULL, (char *) &gAdminCreds, LDAP_AUTH_NEGOTIATE);
    if (ulRet) {                    
        wprintf(L"FATAL: couldn't ldap_bind() = %u\n", ulRet);
        // Convert error, why bother
        return(ulRet);
    }

    if (iStressKind == STRESS_ROOT_MODIFIES) {

        //
        // Create the DN under which this thread will modify things.
        //
        ulRet = UuidCreate(&ContainerGuid);
        if(ulRet != RPC_S_OK){
            wprintf(L"FATAL: couldn't UuidCreate() = %u\n", ulRet);
            return(ulRet);
        }
        ulRet = UuidToString(&ContainerGuid, &szContainerGuid);
        if(ulRet != RPC_S_OK){
            wprintf(L"FATAL: couldn't UuidToString() = %u\n", ulRet);
            return(ulRet);
        }
        cbTemp = strlen(gszDomainDn) + strlen(szContainerGuid) + 50;
        szContainerDn = LocalAlloc(LMEM_FIXED, cbTemp);
        sprintf(szContainerDn, "CN=Ofd-Stress-%s,%s", szContainerGuid, gszDomainDn);
        RpcStringFree(&szContainerGuid);

        OfStressLog(iMyThread, szName, "ContainerDn: ", szContainerDn);

        //
        // Setup our Mod array.
        //
        DescModify.mod_op = LDAP_MOD_REPLACE;
        DescModify.mod_type = "description";
        pszDescValues[0] = szDesc;
        cbDesc = strlen(szDesc); // Used later
        pszDescValues[1] = NULL;
        DescModify.mod_vals.modv_strvals = pszDescValues;
        pMods[0] = &DescModify;
        pMods[1] = NULL;

    }

    while(!gbQuiting){

        //
        // Do the container modifies if we're in a MODIFY thread.
        //

        if (iStressKind == STRESS_ROOT_MODIFIES) {
            
            ulRet = ldap_modify_s(hLdap, szContainerDn, pMods);

            if (ulRet == LDAP_NO_SUCH_OBJECT) {

                OfStressLog(iMyThread, szName, "Creating Object: ", szContainerDn); 
                // This means that we've either just started up, or just
                // failed over to a new server.
                ObjectClass.mod_op = LDAP_MOD_ADD;
                ObjectClass.mod_type = "objectClass";
                pszObjectClassValues[0] = "container";
                pszObjectClassValues[1] = NULL;
                ObjectClass.mod_vals.modv_strvals = pszObjectClassValues;
                pAdd[0] = &ObjectClass;
                pAdd[1] = &DescModify;
                pAdd[2] = NULL;
                
                DescModify.mod_op = LDAP_MOD_ADD;

                ulRet = ldap_add_s(hLdap, szContainerDn, pAdd);
                if (ulRet) {

                    printf("Error: couldn't add object we needed to.\n");
                    OfStressLog(iMyThread, szName, "failure: couldn't create object: ", szContainerDn);

                }

                DescModify.mod_op = LDAP_MOD_REPLACE;

            } else {
                OfStressLog(iMyThread, szName, "modified successfully: ", szDesc);
            }

            // Modulate our description by selecting a random character from
            // the last part (everything past the first 5 chars) of the
            // description and swap it with the 5th char to guarantee a 
            // different description for the next modify.  In other words
            // the description will always end up as: "Lima????".
            iTemp = (rand() % (cbDesc - 5)) + 5;
            chTemp = szDesc[iTemp];
            szDesc[iTemp] = szDesc[4];
            szDesc[4] = chTemp;

        }         
        //
        // Do a search of the RootDSE for dnsHostName and currentTime
        //

        ulRet = ldap_search_s(hLdap,
                              NULL,
                              LDAP_SCOPE_BASE,
                              "(objectCategory=*)",
                              pszAttrFilter,
                              0,
                              &pmResult);

        if (ulRet != LDAP_SUCCESS) {
            OfStressLogD(iMyThread, szName, "FAILED ldap_search_s() = ", ulRet);
            continue;
        }

        pmEntry = ldap_first_entry(hLdap, pmResult);
        if(!pmEntry) {
            OfStressLog(iMyThread, szName, "FAILED ldap_first_entry()", NULL);
            if (pmResult) { 
                ldap_msgfree(pmResult);
                pmResult = NULL;
            }
            continue;
        }
              
        pszDnsHostName = ldap_get_values(hLdap, pmEntry, "dnsHostName");
        if(pszDnsHostName == NULL || pszDnsHostName[0] == NULL){
            OfStressLog(iMyThread, szName, "FAILED ldap_get_values()", NULL);
            if (pmResult) { 
                ldap_msgfree(pmResult);
                pmResult = NULL;
            }
            if (pszDnsHostName) {
                ldap_value_free(pszDnsHostName);
                pszDnsHostName = NULL;
            }
            continue;
        }
        
        //
        // Log Success
        //
        OfStressLog(iMyThread, szName, "success: ", pszDnsHostName[0]);
        
        //
        // Free stuff ...
        //
        if (pmResult) { 
            ldap_msgfree(pmResult);
            pmResult = NULL;
        }
        if (pszDnsHostName) {
            ldap_value_free(pszDnsHostName);
            pszDnsHostName = NULL;
        }
        
        SlowDown();
    }

    //
    // Signal the end master thread that we quit cleanly
    //
    ldap_unbind(hLdap);
    LocalFree(szContainerDn);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\parser\ctimer.cxx ===
#include <NTDSpchX.h>
#pragma hdrstop

#include "parser.hxx"
#include "ctimer.hxx"

CTimer::CTimer()
{
   _hProcess = GetCurrentProcess();

   FILETIME ftCreate, ftExit;

   _fGoodProcInfo = GetProcessTimes(_hProcess,
					&ftCreate,
					&ftExit,
					&_ftKernel0,
					&_ftUser0);
}

void CTimer::ReportElapsedTime(TimingInfo *pInfo)
{
   if ( NULL == pInfo )
      return;

   pInfo->msUser.LowPart = 0xBAD;
   pInfo->msUser.HighPart = 0xBAD;
   pInfo->msKernel.LowPart = 0xBAD;
   pInfo->msKernel.HighPart = 0xBAD;
   pInfo->msTotal.LowPart = 0xBAD;
   pInfo->msTotal.HighPart = 0xBAD;

   FILETIME ftCreate, ftExit, ftKernel1, ftUser1;

   if ( _fGoodProcInfo )
   {
      _fGoodProcInfo = GetProcessTimes(_hProcess,
					&ftCreate,
					&ftExit,
					&ftKernel1,
					&ftUser1);

      if ( _fGoodProcInfo )
      {
         LARGE_INTEGER *pliKernel0 = (LARGE_INTEGER *) &_ftKernel0;
         LARGE_INTEGER *pliKernel1 = (LARGE_INTEGER *) &ftKernel1;
         LARGE_INTEGER *pliUser0 = (LARGE_INTEGER *) &_ftUser0;
         LARGE_INTEGER *pliUser1 = (LARGE_INTEGER *) &ftUser1;

         LARGE_INTEGER liKernel;
         liKernel.QuadPart = pliKernel1->QuadPart - pliKernel0->QuadPart;
         LARGE_INTEGER liUser;
         liUser.QuadPart = pliUser1->QuadPart - pliUser0->QuadPart;
         LARGE_INTEGER liTotal;
         liTotal.QuadPart = liKernel.QuadPart - liUser.QuadPart;

         LARGE_INTEGER liPercentUser = { 0, 0 };
         LARGE_INTEGER liPercentKernel = { 0, 0 };

         if ( liTotal.QuadPart != 0 )
         {
            liPercentKernel = RtlExtendedIntegerMultiply(liKernel,100);

            liPercentKernel.QuadPart = liPercentKernel.QuadPart / liTotal.QuadPart;

            liPercentUser = RtlExtendedIntegerMultiply(liUser,100);

            liPercentUser.QuadPart = liPercentUser.QuadPart / liTotal.QuadPart;
         }

         // convert all times to ms

         ULONG ulRemainder;
         liKernel = RtlExtendedLargeIntegerDivide(liKernel,10000,&ulRemainder);
         liUser = RtlExtendedLargeIntegerDivide(liUser,10000,&ulRemainder);

         // package it up

         pInfo->msUser = liUser;
         pInfo->msKernel = liKernel;
         pInfo->msTotal.QuadPart = liKernel.QuadPart + liUser.QuadPart;

      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\perfdsa\datadsa.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       datadsa.h
//
//--------------------------------------------------------------------------

/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

      datadsa.h

Abstract:

    Header file for the DSA Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:

   Don Hacherl 25 June 1993

Revision History:


--*/

#ifndef _DATADSA_H_
#define _DATADSA_H_

/****************************************************************************\
                                                                April 21, 1998
                                                                wlees

           Adding a Counter to the Extensible Objects Code

Note that the order or position of counters is significant.
There are two orders which are important, the order of counters indexes for
names and help, and the order of data in the shared data block for passing
your values.
You want to maintain consistent counter order, and consistent data layout,
across all five files to be modified.

You want to make sure that your binary matches the .h/.ini file on the target,
which gets loaded in to the registry.

1. nt\private\ds\src\dsamain\include\ntdsctr.h
This file is copied to the system32 directory of the target along with the
ntdsctrs.ini file.
a. Add your counter offset at the end of the counter name list. Order
significant.  If your counter is the last one, change DSA_LAST_COUNTER_INDEX
accordingly.
b. Add an extern reference for the pointer which the actual code will use
to set the measured value. Order doesn't matter.
c. Change the ntds peformance counter version number so the counters will
be reloaded on the next reboot.

2. nt\private\ds\src\perfdsa\ntdsctrs.ini
This file is also copied to the system32 directory of the target and is read
by the lodctr/unlodctr program to copy the counters in the registry
a. Supply your counter visible name and help.  These are used by the perfmon
program. Order doesn't matter.

3. nt\private\ds\src\perfdsa\datadsa.h (this file)
a. Add your data offset definition. Order significant.
b. Add a field to the DSA_DATA_DEFINITION for your counter. Order significant.

4. \nt\private\ds\src\perfdsa\perfdsa.c
This is the dll which perfmon uses to learn about your counters, and to read
them out of the shared data area.
a. Update the huge initializer for the DsaDataDefinition array of counters to
   include your new counter (defined in 3b). Order important.

5. \nt\private\ds\src\dsamain\src\dsamain.c
This file initializes the ds.  It loads the shared memory block and initializes
pointers to the counter fields.  It also loads/reloads the registry counters
as necessary according the version field.
a. Declare the pointer to the data in your counter. Order does not matter.
b. Initialize the pointer to the right location in the shared data block.
   Order of assignments doesn't matter.
c. Initialize your pointer to the dummy value on error

6. yourfile.c
This is the file in the ntdsa where the measured counter is changed.
Use ISET/IADJUST operations in ntdsctr.h on the pointer to your data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to Get<object>PerfomanceData
on return from that routine.

\****************************************************************************/

//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define DSA_NUM_PERF_OBJECT_TYPES 1

//----------------------------------------------------------------------------

//
//  DSA Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//
//  The first counter (ACCVIOL) follows immediately after the
//  PERF_COUNTER_BLOCK, and subsequent counters follow immediately
//  after.  Thus the offest of any counter in the block is <offset of
//  previous counter> + <size of previous counter>

typedef struct _DSA_COUNTER_DATA {
    PERF_COUNTER_BLOCK  cb;    
    DWORD               dwPad;
} DSA_COUNTER_DATA;

#define NUM_DRA_IN_PROPS_OFFSET        sizeof(DSA_COUNTER_DATA)
#define NUM_BROWSE_OFFSET       NUM_DRA_IN_PROPS_OFFSET + sizeof(DWORD)
#define NUM_REPL_OFFSET         NUM_BROWSE_OFFSET + sizeof(DWORD)
#define NUM_THREAD_OFFSET       NUM_REPL_OFFSET + sizeof(DWORD)
#define NUM_ABCLIENT_OFFSET     NUM_THREAD_OFFSET + sizeof(DWORD)
#define NUM_PENDSYNC_OFFSET     NUM_ABCLIENT_OFFSET + sizeof(DWORD)
#define NUM_REMREPUPD_OFFSET    NUM_PENDSYNC_OFFSET + sizeof(DWORD)
#define NUM_SDPROPS_OFFSET      NUM_REMREPUPD_OFFSET + sizeof(DWORD)
#define NUM_SDEVENTS_OFFSET     NUM_SDPROPS_OFFSET + sizeof(DWORD)
#define NUM_LDAPCLIENTS_OFFSET  NUM_SDEVENTS_OFFSET + sizeof(DWORD)
#define NUM_LDAPACTIVE_OFFSET   NUM_LDAPCLIENTS_OFFSET + sizeof(DWORD)
#define NUM_LDAPWRITE_OFFSET    NUM_LDAPACTIVE_OFFSET + sizeof(DWORD)
#define NUM_LDAPSEARCH_OFFSET   NUM_LDAPWRITE_OFFSET + sizeof(DWORD)
#define NUM_DRAOBJSHIPPED_OFFSET                        NUM_LDAPSEARCH_OFFSET + sizeof(DWORD)
#define NUM_DRAPROPSHIPPED_OFFSET                       NUM_DRAOBJSHIPPED_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_VALUES_OFFSET                        NUM_DRAPROPSHIPPED_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCREQUESTMADE_OFFSET                   NUM_DRA_IN_VALUES_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCREQUESTSUCCESSFUL_OFFSET             NUM_DRASYNCREQUESTMADE_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCREQUESTFAILEDSCHEMAMISMATCH_OFFSET   NUM_DRASYNCREQUESTSUCCESSFUL_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCOBJRECEIVED_OFFSET                   NUM_DRASYNCREQUESTFAILEDSCHEMAMISMATCH_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCPROPUPDATED_OFFSET                   NUM_DRASYNCOBJRECEIVED_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCPROPSAME_OFFSET                      NUM_DRASYNCPROPUPDATED_OFFSET + sizeof(DWORD)
#define NUM_MONLIST_OFFSET         NUM_DRASYNCPROPSAME_OFFSET + sizeof(DWORD)
#define NUM_NOTIFYQ_OFFSET         NUM_MONLIST_OFFSET + sizeof(DWORD)
#define NUM_LDAPUDPCLIENTS_OFFSET  NUM_NOTIFYQ_OFFSET + sizeof(DWORD)
#define NUM_SUBSEARCHOPS_OFFSET    NUM_LDAPUDPCLIENTS_OFFSET + sizeof(DWORD)
#define NUM_NAMECACHEHIT_OFFSET    NUM_SUBSEARCHOPS_OFFSET +  sizeof(DWORD)
#define NUM_NAMECACHETRY_OFFSET    NUM_NAMECACHEHIT_OFFSET +  sizeof(DWORD)
#define NUM_HIGHESTUSNISSUEDLO_OFFSET       NUM_NAMECACHETRY_OFFSET + sizeof(DWORD)
#define NUM_HIGHESTUSNISSUEDHI_OFFSET       NUM_HIGHESTUSNISSUEDLO_OFFSET + sizeof(DWORD)
#define NUM_HIGHESTUSNCOMMITTEDLO_OFFSET    NUM_HIGHESTUSNISSUEDHI_OFFSET + sizeof(DWORD)
#define NUM_HIGHESTUSNCOMMITTEDHI_OFFSET    NUM_HIGHESTUSNCOMMITTEDLO_OFFSET + sizeof(DWORD)
#define NUM_SAMWRITES_OFFSET                NUM_HIGHESTUSNCOMMITTEDHI_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES1_OFFSET             NUM_SAMWRITES_OFFSET + sizeof(DWORD)
#define NUM_DRAWRITES_OFFSET                NUM_TOTALWRITES1_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES2_OFFSET             NUM_DRAWRITES_OFFSET + sizeof(DWORD)
#define NUM_LDAPWRITES_OFFSET               NUM_TOTALWRITES2_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES3_OFFSET             NUM_LDAPWRITES_OFFSET + sizeof(DWORD)
#define NUM_LSAWRITES_OFFSET                NUM_TOTALWRITES3_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES4_OFFSET             NUM_LSAWRITES_OFFSET + sizeof(DWORD)
#define NUM_KCCWRITES_OFFSET                NUM_TOTALWRITES4_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES6_OFFSET             NUM_KCCWRITES_OFFSET + sizeof(DWORD)
#define NUM_NSPIWRITES_OFFSET               NUM_TOTALWRITES6_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES7_OFFSET             NUM_NSPIWRITES_OFFSET + sizeof(DWORD)
#define NUM_OTHERWRITES_OFFSET              NUM_TOTALWRITES7_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES8_OFFSET             NUM_OTHERWRITES_OFFSET + sizeof(DWORD)
#define NUM_TOTALWRITES_OFFSET              NUM_TOTALWRITES8_OFFSET + sizeof(DWORD)

#define NUM_SAMSEARCHES_OFFSET              NUM_TOTALWRITES_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES1_OFFSET           NUM_SAMSEARCHES_OFFSET + sizeof(DWORD)
#define NUM_DRASEARCHES_OFFSET              NUM_TOTALSEARCHES1_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES2_OFFSET           NUM_DRASEARCHES_OFFSET + sizeof(DWORD)
#define NUM_LDAPSEARCHES_OFFSET             NUM_TOTALSEARCHES2_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES3_OFFSET           NUM_LDAPSEARCHES_OFFSET + sizeof(DWORD)
#define NUM_LSASEARCHES_OFFSET              NUM_TOTALSEARCHES3_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES4_OFFSET           NUM_LSASEARCHES_OFFSET + sizeof(DWORD)
#define NUM_KCCSEARCHES_OFFSET              NUM_TOTALSEARCHES4_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES6_OFFSET           NUM_KCCSEARCHES_OFFSET + sizeof(DWORD)
#define NUM_NSPISEARCHES_OFFSET             NUM_TOTALSEARCHES6_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES7_OFFSET           NUM_NSPISEARCHES_OFFSET + sizeof(DWORD)
#define NUM_OTHERSEARCHES_OFFSET            NUM_TOTALSEARCHES7_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES8_OFFSET           NUM_OTHERSEARCHES_OFFSET + sizeof(DWORD)
#define NUM_TOTALSEARCHES_OFFSET            NUM_TOTALSEARCHES8_OFFSET + sizeof(DWORD)

#define NUM_SAMREADS_OFFSET                 NUM_TOTALSEARCHES_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS1_OFFSET              NUM_SAMREADS_OFFSET + sizeof(DWORD)
#define NUM_DRAREADS_OFFSET                 NUM_TOTALREADS1_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS2_OFFSET              NUM_DRAREADS_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_DN_VALUES_OFFSET         NUM_TOTALREADS2_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_OBJS_FILTERED_OFFSET     NUM_DRA_IN_DN_VALUES_OFFSET + sizeof(DWORD)
#define NUM_LSAREADS_OFFSET                 NUM_DRA_IN_OBJS_FILTERED_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS4_OFFSET              NUM_LSAREADS_OFFSET + sizeof(DWORD)
#define NUM_KCCREADS_OFFSET                 NUM_TOTALREADS4_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS6_OFFSET              NUM_KCCREADS_OFFSET + sizeof(DWORD)
#define NUM_NSPIREADS_OFFSET                NUM_TOTALREADS6_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS7_OFFSET              NUM_NSPIREADS_OFFSET + sizeof(DWORD)
#define NUM_OTHERREADS_OFFSET               NUM_TOTALREADS7_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS8_OFFSET              NUM_OTHERREADS_OFFSET + sizeof(DWORD)
#define NUM_TOTALREADS_OFFSET               NUM_TOTALREADS8_OFFSET + sizeof(DWORD)

#define NUM_LDAPBINDSUCCESSFUL_OFFSET       NUM_TOTALREADS_OFFSET + sizeof(DWORD)
#define NUM_LDAPBINDTIME_OFFSET             NUM_LDAPBINDSUCCESSFUL_OFFSET + sizeof(DWORD)
#define NUM_CREATEMACHINESUCCESSFUL_OFFSET  NUM_LDAPBINDTIME_OFFSET + sizeof(DWORD)
#define NUM_CREATEMACHINETRIES_OFFSET       NUM_CREATEMACHINESUCCESSFUL_OFFSET + sizeof(DWORD)
#define NUM_CREATEUSERSUCCESSFUL_OFFSET     NUM_CREATEMACHINETRIES_OFFSET + sizeof(DWORD)
#define NUM_CREATEUSERTRIES_OFFSET          NUM_CREATEUSERSUCCESSFUL_OFFSET + sizeof(DWORD)
#define NUM_PASSWORDCHANGES_OFFSET          NUM_CREATEUSERTRIES_OFFSET + sizeof(DWORD)
#define NUM_MEMBERSHIPCHANGES_OFFSET        NUM_PASSWORDCHANGES_OFFSET + sizeof(DWORD)
#define NUM_QUERYDISPLAYS_OFFSET            NUM_MEMBERSHIPCHANGES_OFFSET + sizeof(DWORD)
#define NUM_ENUMERATIONS_OFFSET             NUM_QUERYDISPLAYS_OFFSET + sizeof(DWORD)

#define NUM_MEMBEREVALTRANSITIVE_OFFSET     NUM_ENUMERATIONS_OFFSET + sizeof(DWORD)
#define NUM_MEMBEREVALNONTRANSITIVE_OFFSET  NUM_MEMBEREVALTRANSITIVE_OFFSET + sizeof(DWORD)
#define NUM_MEMBEREVALRESOURCE_OFFSET       NUM_MEMBEREVALNONTRANSITIVE_OFFSET + sizeof(DWORD)
#define NUM_MEMBEREVALUNIVERSAL_OFFSET      NUM_MEMBEREVALRESOURCE_OFFSET + sizeof(DWORD)
#define NUM_MEMBEREVALACCOUNT_OFFSET        NUM_MEMBEREVALUNIVERSAL_OFFSET + sizeof(DWORD)
#define NUM_MEMBEREVALASGC_OFFSET           NUM_MEMBEREVALACCOUNT_OFFSET + sizeof(DWORD)
#define NUM_AS_REQUESTS_OFFSET              NUM_MEMBEREVALASGC_OFFSET + sizeof(DWORD)
#define NUM_TGS_REQUESTS_OFFSET             NUM_AS_REQUESTS_OFFSET + sizeof(DWORD)
#define NUM_KERBEROS_AUTHENTICATIONS_OFFSET NUM_TGS_REQUESTS_OFFSET + sizeof(DWORD)
#define NUM_MSVAUTHENTICATIONS_OFFSET       NUM_KERBEROS_AUTHENTICATIONS_OFFSET + sizeof(DWORD)
#define NUM_DRASYNCFULLREM_OFFSET           NUM_MSVAUTHENTICATIONS_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_TOTAL_RATE_OFFSET       NUM_DRASYNCFULLREM_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_NOT_COMP_RATE_OFFSET    NUM_DRA_IN_BYTES_TOTAL_RATE_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_COMP_PRE_RATE_OFFSET    NUM_DRA_IN_BYTES_NOT_COMP_RATE_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_COMP_POST_RATE_OFFSET   NUM_DRA_IN_BYTES_COMP_PRE_RATE_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_TOTAL_RATE_OFFSET      NUM_DRA_IN_BYTES_COMP_POST_RATE_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_NOT_COMP_RATE_OFFSET   NUM_DRA_OUT_BYTES_TOTAL_RATE_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_COMP_PRE_RATE_OFFSET   NUM_DRA_OUT_BYTES_NOT_COMP_RATE_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_COMP_POST_RATE_OFFSET  NUM_DRA_OUT_BYTES_COMP_PRE_RATE_OFFSET + sizeof(DWORD)
#define NUM_DS_CLIENT_BIND_OFFSET           NUM_DRA_OUT_BYTES_COMP_POST_RATE_OFFSET + sizeof(DWORD)
#define NUM_DS_SERVER_BIND_OFFSET           NUM_DS_CLIENT_BIND_OFFSET + sizeof(DWORD)
#define NUM_DS_CLIENT_NAME_TRANSLATE_OFFSET NUM_DS_SERVER_BIND_OFFSET + sizeof(DWORD)
#define NUM_DS_SERVER_NAME_TRANSLATE_OFFSET NUM_DS_CLIENT_NAME_TRANSLATE_OFFSET + sizeof(DWORD)
#define NUM_SDPROP_RUNTIME_QUEUE_OFFSET     NUM_DS_SERVER_NAME_TRANSLATE_OFFSET + sizeof(DWORD)
#define NUM_SDPROP_WAIT_TIME_OFFSET         NUM_SDPROP_RUNTIME_QUEUE_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_OBJS_FILTERED_OFFSET    NUM_SDPROP_WAIT_TIME_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_VALUES_OFFSET           NUM_DRA_OUT_OBJS_FILTERED_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_DN_VALUES_OFFSET        NUM_DRA_OUT_VALUES_OFFSET + sizeof(DWORD)
#define NUM_NSPI_ANR_OFFSET                 NUM_DRA_OUT_DN_VALUES_OFFSET + sizeof(DWORD)
#define NUM_NSPI_PROPERTY_READS_OFFSET      NUM_NSPI_ANR_OFFSET + sizeof(DWORD)
#define NUM_NSPI_OBJECT_SEARCH_OFFSET       NUM_NSPI_PROPERTY_READS_OFFSET + sizeof(DWORD)
#define NUM_NSPI_OBJECT_MATCHES_OFFSET      NUM_NSPI_OBJECT_SEARCH_OFFSET + sizeof(DWORD)
#define NUM_NSPI_PROXY_LOOKUP_OFFSET        NUM_NSPI_OBJECT_MATCHES_OFFSET + sizeof(DWORD)
#define NUM_ATQ_THREADS_TOTAL_OFFSET        NUM_NSPI_PROXY_LOOKUP_OFFSET + sizeof(DWORD)
#define NUM_ATQ_THREADS_LDAP_OFFSET         NUM_ATQ_THREADS_TOTAL_OFFSET + sizeof(DWORD)
#define NUM_ATQ_THREADS_OTHER_OFFSET        NUM_ATQ_THREADS_LDAP_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_TOTAL_OFFSET       NUM_ATQ_THREADS_OTHER_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_NOT_COMP_OFFSET    NUM_DRA_IN_BYTES_TOTAL_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_COMP_PRE_OFFSET    NUM_DRA_IN_BYTES_NOT_COMP_OFFSET + sizeof(DWORD)
#define NUM_DRA_IN_BYTES_COMP_POST_OFFSET   NUM_DRA_IN_BYTES_COMP_PRE_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_TOTAL_OFFSET      NUM_DRA_IN_BYTES_COMP_POST_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_NOT_COMP_OFFSET   NUM_DRA_OUT_BYTES_TOTAL_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_COMP_PRE_OFFSET   NUM_DRA_OUT_BYTES_NOT_COMP_OFFSET + sizeof(DWORD)
#define NUM_DRA_OUT_BYTES_COMP_POST_OFFSET  NUM_DRA_OUT_BYTES_COMP_PRE_OFFSET + sizeof(DWORD)
#define NUM_LDAP_NEW_CONNS_PER_SEC_OFFSET   NUM_DRA_OUT_BYTES_COMP_POST_OFFSET + sizeof(DWORD)
#define NUM_LDAP_CLS_CONNS_PER_SEC_OFFSET   NUM_LDAP_NEW_CONNS_PER_SEC_OFFSET + sizeof(DWORD)
#define NUM_LDAP_SSL_CONNS_PER_SEC_OFFSET   NUM_LDAP_CLS_CONNS_PER_SEC_OFFSET + sizeof(DWORD)
#define NUM_DRA_REPL_QUEUE_OPS_OFFSET       NUM_LDAP_SSL_CONNS_PER_SEC_OFFSET + sizeof(DWORD)
#define NUM_DRA_TDS_IN_GETCHNGS_OFFSET      NUM_DRA_REPL_QUEUE_OPS_OFFSET + sizeof(DWORD)
#define NUM_DRA_TDS_IN_GETCHNGS_W_SEM_OFFSET     NUM_DRA_TDS_IN_GETCHNGS_OFFSET + sizeof(DWORD)
#define NUM_DRA_REM_REPL_UPD_LNK_OFFSET     NUM_DRA_TDS_IN_GETCHNGS_W_SEM_OFFSET + sizeof(DWORD)
#define NUM_DRA_REM_REPL_UPD_TOT_OFFSET     NUM_DRA_REM_REPL_UPD_LNK_OFFSET + sizeof(DWORD)
#define NUM_NTDSAPIWRITES_OFFSET            NUM_DRA_REM_REPL_UPD_TOT_OFFSET + sizeof(DWORD)
#define NUM_NTDSAPISEARCHES_OFFSET          NUM_NTDSAPIWRITES_OFFSET + sizeof(DWORD)
#define NUM_NTDSAPIREADS_OFFSET             NUM_NTDSAPISEARCHES_OFFSET + sizeof(DWORD)
#define NUM_SAM_ACCT_GROUP_LATENCY_OFFSET   NUM_NTDSAPIREADS_OFFSET + sizeof(DWORD)
#define NUM_SAM_RES_GROUP_LATENCY_OFFSET    NUM_SAM_ACCT_GROUP_LATENCY_OFFSET + sizeof(DWORD)

// <-- insert new NUM_*_OFFSET's here, and update SIZE_OF_... #define below.
#define SIZE_OF_DSA_PERFORMANCE_DATA_IN_USE NUM_SAM_RES_GROUP_LATENCY_OFFSET + sizeof(DWORD)

// The total size of the structure must be a multiple of 8 (see perflib Event 1016).
// This will adjust the total size if the total number of counters (DWORD each) is odd.
// We don't really care about 4 extra bytes at the end of the buffer since all data
// is defined by the DSA_DATA_DEFINITION struct. No one will look at this extra DWORD
// at the end of the buffer.
#define SIZE_OF_DSA_PERFORMANCE_DATA ((SIZE_OF_DSA_PERFORMANCE_DATA_IN_USE + 0x07) & ~0x07)                                                                    

//
//  This is the counter structure presently returned by Dsa for
//  each Resource.  Each Resource is an Instance, named by its number.
//

typedef struct _DSA_DATA_DEFINITION {
    PERF_OBJECT_TYPE            DsaObjectType;
    PERF_COUNTER_DEFINITION     NumDRAInProps;
    PERF_COUNTER_DEFINITION     NumBrowse;
    PERF_COUNTER_DEFINITION     NumRepl;
    PERF_COUNTER_DEFINITION     NumThread;
    PERF_COUNTER_DEFINITION     NumABClient;
    PERF_COUNTER_DEFINITION     NumPendSync;
    PERF_COUNTER_DEFINITION     NumRemRepUpd;
    PERF_COUNTER_DEFINITION     NumSDProp;
    PERF_COUNTER_DEFINITION     NumSDEvents;
    PERF_COUNTER_DEFINITION     NumLDAPClients;
    PERF_COUNTER_DEFINITION     NumLDAPActive;
    PERF_COUNTER_DEFINITION     NumLDAPWrite;
    PERF_COUNTER_DEFINITION     NumLDAPSearch;
    PERF_COUNTER_DEFINITION     NumDRAObjShipped;
    PERF_COUNTER_DEFINITION     NumDRAPropShipped;
    PERF_COUNTER_DEFINITION     NumDRAInValues;
    PERF_COUNTER_DEFINITION     NumDRASyncRequestMade;
    PERF_COUNTER_DEFINITION     NumDRASyncRequestSuccessful;
    PERF_COUNTER_DEFINITION     NumDRASyncRequestFailedSchemaMismatch;
    PERF_COUNTER_DEFINITION     NumDRASyncObjReceived;
    PERF_COUNTER_DEFINITION     NumDRASyncPropUpdated;
    PERF_COUNTER_DEFINITION     NumDRASyncPropSame;
    PERF_COUNTER_DEFINITION     NumMonList;
    PERF_COUNTER_DEFINITION     NumNotifyQ;
    PERF_COUNTER_DEFINITION     NumLDAPUDPClients;
    PERF_COUNTER_DEFINITION     NumSubSearchOps;
    PERF_COUNTER_DEFINITION     NameCacheHit;
    PERF_COUNTER_DEFINITION     NameCacheTry;
    PERF_COUNTER_DEFINITION     HighestUsnIssuedLo;
    PERF_COUNTER_DEFINITION     HighestUsnIssuedHi;
    PERF_COUNTER_DEFINITION     HighestUsnCommittedLo;
    PERF_COUNTER_DEFINITION     HighestUsnCommittedHi;
    PERF_COUNTER_DEFINITION     SAMWrites;
    PERF_COUNTER_DEFINITION     TotalWrites1;
    PERF_COUNTER_DEFINITION     DRAWrites;
    PERF_COUNTER_DEFINITION     TotalWrites2;
    PERF_COUNTER_DEFINITION     LDAPWrites;
    PERF_COUNTER_DEFINITION     TotalWrites3;
    PERF_COUNTER_DEFINITION     LSAWrites;
    PERF_COUNTER_DEFINITION     TotalWrites4;
    PERF_COUNTER_DEFINITION     KCCWrites;
    PERF_COUNTER_DEFINITION     TotalWrites6;
    PERF_COUNTER_DEFINITION     NSPIWrites;
    PERF_COUNTER_DEFINITION     TotalWrites7;
    PERF_COUNTER_DEFINITION     OtherWrites;
    PERF_COUNTER_DEFINITION     TotalWrites8;
    PERF_COUNTER_DEFINITION     TotalWrites;
    PERF_COUNTER_DEFINITION     SAMSearches;
    PERF_COUNTER_DEFINITION     TotalSearches1;
    PERF_COUNTER_DEFINITION     DRASearches;
    PERF_COUNTER_DEFINITION     TotalSearches2;
    PERF_COUNTER_DEFINITION     LDAPSearches;
    PERF_COUNTER_DEFINITION     TotalSearches3;
    PERF_COUNTER_DEFINITION     LSASearches;
    PERF_COUNTER_DEFINITION     TotalSearches4;
    PERF_COUNTER_DEFINITION     KCCSearches;
    PERF_COUNTER_DEFINITION     TotalSearches6;
    PERF_COUNTER_DEFINITION     NSPISearches;
    PERF_COUNTER_DEFINITION     TotalSearches7;
    PERF_COUNTER_DEFINITION     OtherSearches;
    PERF_COUNTER_DEFINITION     TotalSearches8;
    PERF_COUNTER_DEFINITION     TotalSearches;
    PERF_COUNTER_DEFINITION     SAMReads;
    PERF_COUNTER_DEFINITION     TotalReads1;
    PERF_COUNTER_DEFINITION     DRAReads;
    PERF_COUNTER_DEFINITION     TotalReads2;
    PERF_COUNTER_DEFINITION     DRAInDNValues;
    PERF_COUNTER_DEFINITION     DRAInObjsFiltered;
    PERF_COUNTER_DEFINITION     LSAReads;
    PERF_COUNTER_DEFINITION     TotalReads4;
    PERF_COUNTER_DEFINITION     KCCReads;
    PERF_COUNTER_DEFINITION     TotalReads6;
    PERF_COUNTER_DEFINITION     NSPIReads;
    PERF_COUNTER_DEFINITION     TotalReads7;
    PERF_COUNTER_DEFINITION     OtherReads;
    PERF_COUNTER_DEFINITION     TotalReads8;
    PERF_COUNTER_DEFINITION     TotalReads;
    PERF_COUNTER_DEFINITION     LDAPBindSuccessful;
    PERF_COUNTER_DEFINITION     LDAPBindTime;
    PERF_COUNTER_DEFINITION     CreateMachineSuccessful;
    PERF_COUNTER_DEFINITION     CreateMachineTries;
    PERF_COUNTER_DEFINITION     CreateUserSuccessful;
    PERF_COUNTER_DEFINITION     CreateUserTries;
    PERF_COUNTER_DEFINITION     PasswordChanges;
    PERF_COUNTER_DEFINITION     MembershipChanges;
    PERF_COUNTER_DEFINITION     QueryDisplays;
    PERF_COUNTER_DEFINITION     Enumerations;
    PERF_COUNTER_DEFINITION     MemberEvalTransitive;
    PERF_COUNTER_DEFINITION     MemberEvalNonTransitive;
    PERF_COUNTER_DEFINITION     MemberEvalResource;
    PERF_COUNTER_DEFINITION     MemberEvalUniversal;
    PERF_COUNTER_DEFINITION     MemberEvalAccount;
    PERF_COUNTER_DEFINITION     MemberEvalAsGC;
    PERF_COUNTER_DEFINITION     AsRequests;
    PERF_COUNTER_DEFINITION     TgsRequests;
    PERF_COUNTER_DEFINITION     KerberosAuthentications;
    PERF_COUNTER_DEFINITION     MsvAuthentications;
    PERF_COUNTER_DEFINITION     NumDRASyncFullRemaining;
    PERF_COUNTER_DEFINITION     NumDRAInBytesTotalRate;
    PERF_COUNTER_DEFINITION     NumDRAInBytesNotCompRate;
    PERF_COUNTER_DEFINITION     NumDRAInBytesCompPreRate;
    PERF_COUNTER_DEFINITION     NumDRAInBytesCompPostRate;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesTotalRate;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesNotCompRate;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesCompPreRate;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesCompPostRate;
    PERF_COUNTER_DEFINITION     NumDsClientBind;
    PERF_COUNTER_DEFINITION     NumDsServerBind;
    PERF_COUNTER_DEFINITION     NumDsClientNameTranslate;
    PERF_COUNTER_DEFINITION     NumDsServerNameTranslate;
    PERF_COUNTER_DEFINITION     SDPropRuntimeQueue;
    PERF_COUNTER_DEFINITION     SDPropWaitTime;
    PERF_COUNTER_DEFINITION     NumDRAOutObjsFiltered;
    PERF_COUNTER_DEFINITION     NumDRAOutValues;
    PERF_COUNTER_DEFINITION     NumDRAOutDNValues;
    PERF_COUNTER_DEFINITION     NumNspiANR;
    PERF_COUNTER_DEFINITION     NumNspiPropertyReads;
    PERF_COUNTER_DEFINITION     NumNspiObjectSearch;
    PERF_COUNTER_DEFINITION     NumNspiObjectMatches;
    PERF_COUNTER_DEFINITION     NumNspiProxyLookup;
    PERF_COUNTER_DEFINITION     AtqThreadsTotal;
    PERF_COUNTER_DEFINITION     AtqThreadsLDAP;
    PERF_COUNTER_DEFINITION     AtqThreadsOther;
    PERF_COUNTER_DEFINITION     NumDRAInBytesTotal;
    PERF_COUNTER_DEFINITION     NumDRAInBytesNotComp;
    PERF_COUNTER_DEFINITION     NumDRAInBytesCompPre;
    PERF_COUNTER_DEFINITION     NumDRAInBytesCompPost;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesTotal;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesNotComp;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesCompPre;
    PERF_COUNTER_DEFINITION     NumDRAOutBytesCompPost;
    PERF_COUNTER_DEFINITION     LdapNewConnsPerSec;
    PERF_COUNTER_DEFINITION     LdapClosedConnsPerSec;
    PERF_COUNTER_DEFINITION     LdapSSLConnsPerSec;
    PERF_COUNTER_DEFINITION     DRAReplQueueOps;
    PERF_COUNTER_DEFINITION     DRATdsInGetChngs;
    PERF_COUNTER_DEFINITION     DRATdsInGetChngsWSem;
    PERF_COUNTER_DEFINITION     DRARemReplUpdLnk;
    PERF_COUNTER_DEFINITION     DRARemReplUpdTot;
    PERF_COUNTER_DEFINITION     NTDSAPIWrites;
    PERF_COUNTER_DEFINITION     NTDSAPISearches;
    PERF_COUNTER_DEFINITION     NTDSAPIReads;
    PERF_COUNTER_DEFINITION     SAMAcctGroupLatency;
    PERF_COUNTER_DEFINITION     SAMResGroupLatency;
} DSA_DATA_DEFINITION;

#pragma pack ()

#endif //_DATADSA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\parser\cargs.cxx ===
#include <NTDSpchX.h>
#pragma hdrstop
#include "parser.hxx"

CArgs::CArgs()
{
   _cArgs = 0;
   _cMax = 0;
   _rArgs = NULL;
}

CArgs::~CArgs()
{
   if ( _rArgs != NULL )
   {
      ASSERT(_cArgs > 0);

      for ( int i = 0; i < _cArgs; i++ )
      {
         if ( ARG_STRING == _rArgs[i].argType )
         {
            delete [] (void *) _rArgs[i].pwsz;
         }
      }

      delete [] _rArgs;
   }
}

#if DBG == 1
#define ARG_INCREMENT 1
#else
#define ARG_INCREMENT 10
#endif

HRESULT CArgs::MakeSpace()
{
   ASSERT(_cArgs <= _cMax);

   if ( _cArgs == _cMax )
   {
      _cMax += ARG_INCREMENT;

      Argument *tmp = new Argument [_cMax];

      if ( tmp == NULL )
      {
         return(E_OUTOFMEMORY);
      }

      if ( _cArgs > 0 )
      {
         memcpy(tmp,_rArgs,(_cArgs * sizeof(Argument)));
         delete [] _rArgs;
      }

      memset(&(tmp[_cArgs]),0,(ARG_INCREMENT * sizeof(Argument)));

      _rArgs = tmp;
   }

   return(S_OK);
}

HRESULT CArgs::Add(int i)
{
   HRESULT hr = MakeSpace();

   if ( FAILED(hr) )
      return(hr);

   _rArgs[_cArgs].argType = ARG_INTEGER;
   _rArgs[_cArgs].i = i;
   _cArgs++;

   return(S_OK);
}

HRESULT CArgs::Add(LONGLONG i64)
{
   HRESULT hr = MakeSpace();

   if ( FAILED(hr) )
      return(hr);

   _rArgs[_cArgs].argType = ARG_LONGLONG;
   _rArgs[_cArgs].i64 = i64;
   _cArgs++;

   return(S_OK);
}

HRESULT CArgs::Add(const WCHAR *pwsz)
{
   if ( (NULL == pwsz) || (0 == wcslen(pwsz)) )
      return(E_INVALIDARG);

   HRESULT hr = MakeSpace();

   if ( FAILED(hr) )
      return(hr);

   DWORD cBytes = sizeof(WCHAR) * (wcslen(pwsz) + 1);
   const WCHAR *p = (const WCHAR *) new BYTE [ cBytes ];

   if ( NULL == p )
      return(E_OUTOFMEMORY);

   wcscpy((WCHAR *) p,pwsz);
   _rArgs[_cArgs].argType = ARG_STRING;
   _rArgs[_cArgs].pwsz = p;
   _cArgs++;

   return(S_OK);
}

int CArgs::Count()
{
   return(_cArgs);
}

HRESULT CArgs::GetString(int i, const WCHAR **ppValue)
{
   if ( (i >= _cArgs) || (ARG_STRING != _rArgs[i].argType) )
   {
      return(E_INVALIDARG);
   }

   *ppValue = _rArgs[i].pwsz;

   return(S_OK);
}

HRESULT CArgs::GetInt(int i, int *pValue)
{
   if ( (i >= _cArgs) || (ARG_INTEGER != _rArgs[i].argType) )
   {
      return(E_INVALIDARG);
   }

   *pValue = _rArgs[i].i;

   return(S_OK);
}

HRESULT CArgs::GetLongLong(int i, LONGLONG *pValue)
{
   if ( (i >= _cArgs) || (ARG_LONGLONG != _rArgs[i].argType) )
   {
      return(E_INVALIDARG);
   }

   *pValue = _rArgs[i].i64;

   return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\perfdsa\perfdsa.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1993 - 1999
//
//  File:       perfdsa.c
//
//--------------------------------------------------------------------------

/*

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    perfdsa.c

Abstract:

    This file implements the Extensible Objects for the DSA object type

Created:

    Don Hacherl 25 June 1993

Revision History
*/

//
//  Include Files
//
#include <NTDSpch.h>
#pragma hdrstop

#include <wchar.h>
#include <winperf.h>

#ifndef MessageId               /* used in mdcodes */
#define MessageId   ULONG
#endif

#include <mdcodes.h>            /* error message definitions */
#include "perfmsg.h"
#include "perfutil.h"
#include "datadsa.h"
#include "ntdsctr.h"
#include <dsconfig.h>
#include <align.h>

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK

//
// DSA counter data structures

HANDLE hDsaSharedMemory;                 // Handle of Dsa Shared Memory
PDWORD pCounterBlock;
size_t cbPerfCounterData;
int cProcessor;
extern DSA_DATA_DEFINITION DsaDataDefinition;

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC            OpenDsaPerformanceData;
PM_COLLECT_PROC         CollectDsaPerformanceData;
PM_CLOSE_PROC           CloseDsaPerformanceData;




DWORD
OpenDsaPerformanceData(
    LPWSTR lpDeviceNames
    )

/*++

Routine Description:

    This routine will open and map the memory used by the DSA to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (DSA), which
    seems to be totally unused, just as it was in the sample code
    from which this is stolen.


Return Value:

    None.

--*/
{
    DWORD status;
    DWORD_PTR maskProcess;
    DWORD_PTR maskSystem;
    HKEY hKeyDriverPerf;
    DWORD size, type, dwFirstCounter, dwFirstHelp;
    PERF_COUNTER_DEFINITION * pCtrDef;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //
    /* DebugBreak() */
    if (!dwOpenCount) {
        // open shared memory used by device driver to pass performance values
        hDsaSharedMemory = OpenFileMapping(FILE_MAP_READ,
                                        FALSE,
                                        DSA_PERF_COUNTER_BLOCK);
        pCounterBlock = NULL;   // initialize pointer to memory

        // log error if unsuccessful

        if (hDsaSharedMemory == NULL) {
            // this is fatal, if we can't get data then there's no
            // point in continuing.
            status = GetLastError(); // return error
            LogPerfEvent( DIRLOG_PERF_FAIL_OPEN_MEMORY, status, NULL);
            goto OpenExitPoint;
        } else {

            // if opened ok, then map pointer to memory
            pCounterBlock = (PDWORD) MapViewOfFile(hDsaSharedMemory,
                                            FILE_MAP_READ,
                                            0,
                                            0,
                                            0);
            if (pCounterBlock == NULL) {
                // this is fatal, if we can't get data then there's no
                // point in continuing.
                status = GetLastError(); // return error
                LogPerfEvent( DIRLOG_PERF_FAIL_MAP_MEMORY, status, NULL);
                CloseHandle(hDsaSharedMemory);
                hDsaSharedMemory = NULL;
                goto OpenExitPoint;
            }
        }

        // compute parameters of counter block (size, # procs)
        
        cbPerfCounterData = ((DSA_LAST_COUNTER_INDEX/2 + 1) * sizeof(unsigned long));
        cbPerfCounterData = ((cbPerfCounterData + cbPerfCounterDataAlign - 1) / cbPerfCounterDataAlign) * cbPerfCounterDataAlign;

        GetProcessAffinityMask(GetCurrentProcess(), &maskProcess, &maskSystem);
        for ( cProcessor = 0; maskSystem != 0; maskSystem >>= 1 ) {
            if ( maskSystem & 1 ) {
                cProcessor++;
            }
        }

        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data strucutures by adding base to
        //          offset value in structure.

        status = RegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Services\\" SERVICE_NAME "\\Performance",
            0L,
            KEY_READ,
            &hKeyDriverPerf);

        if (status != ERROR_SUCCESS) {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            LogPerfEvent( 
                DIRLOG_PERF_FAIL_OPEN_REG, 
                status, 
                L"SYSTEM\\CurrentControlSet\\Services\\" MAKE_WIDE(SERVICE_NAME) L"\\Performance"
                );
            UnmapViewOfFile (pCounterBlock);
            pCounterBlock = NULL;
            CloseHandle(hDsaSharedMemory);
            hDsaSharedMemory = NULL;
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf,
                    "First Counter",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstCounter,
                    &size);

        if (status != ERROR_SUCCESS) {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            LogPerfEvent( 
                DIRLOG_PERF_FAIL_QUERY_REG, 
                status, 
                L"SYSTEM\\CurrentControlSet\\Services\\" MAKE_WIDE(SERVICE_NAME) L"\\Performance\\First Counter"
                );
            RegCloseKey (hKeyDriverPerf);
            UnmapViewOfFile (pCounterBlock);
            pCounterBlock = NULL;
            CloseHandle(hDsaSharedMemory);
            hDsaSharedMemory = NULL;
            goto OpenExitPoint;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf,
                    "First Help",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstHelp,
                    &size);

        if (status != ERROR_SUCCESS) {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            LogPerfEvent( 
                DIRLOG_PERF_FAIL_QUERY_REG, 
                status, 
                L"SYSTEM\\CurrentControlSet\\Services\\" MAKE_WIDE(SERVICE_NAME) L"\\Performance\\First Help");
            RegCloseKey (hKeyDriverPerf);
            UnmapViewOfFile (pCounterBlock);
            pCounterBlock = NULL;
            CloseHandle(hDsaSharedMemory);
            hDsaSharedMemory = NULL;
            goto OpenExitPoint;
        }

        //
        //  NOTE: the initialization program could also retrieve
        //      LastCounter and LastHelp if they wanted to do
        //      bounds checking on the new number. e.g.
        //
        //      counter->CounterNameTitleIndex += dwFirstCounter;
        //      if (counter->CounterNameTitleIndex > dwLastCounter) {
        //          LogErrorToEventLog (INDEX_OUT_OF_BOUNDS);
        //      }

        DsaDataDefinition.DsaObjectType.ObjectNameTitleIndex += dwFirstCounter;
        DsaDataDefinition.DsaObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        for (pCtrDef = &DsaDataDefinition.NumDRAInProps;
             (BYTE *) pCtrDef < (BYTE *) &DsaDataDefinition + sizeof(DsaDataDefinition);
             pCtrDef++) {
            pCtrDef->CounterNameTitleIndex += dwFirstCounter;
            pCtrDef->CounterHelpTitleIndex += dwFirstCounter;
        }

        RegCloseKey (hKeyDriverPerf); // close key to registry

        bInitOK = TRUE; // ok to use this function
    }
    dwOpenCount++;  // increment OPEN counter
//    LogPerfEvent( DIRLOG_PERF_OPEN, 1, &dwOpenCount);
    status = ERROR_SUCCESS; // for successful exit

OpenExitPoint:

    return (DWORD)status;
}



DWORD
CollectDsaPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes
)
/*++

Routine Description:

    This routine will return the data for the DSA counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

    ULONG SpaceNeeded;
    PDWORD pdwCounter;
    DSA_COUNTER_DATA *pPerfCounterBlock;
    DSA_DATA_DEFINITION *pDsaDataDefinition;

    // variables used for error logging

    DWORD                               dwQueryType;

    int i, j;          //loop variable

//    DebugBreak();
    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK) {
        // unable to continue because open failed.
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN || QUERY_COSTLY == dwQueryType) {
        // this routine does not service requests for data from
        // Non-NT computers, nor do we have any costly counters.
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS){
        if ( !(IsNumberInUnicodeList (DsaDataDefinition.DsaObjectType.ObjectNameTitleIndex, lpValueName))) {

            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pDsaDataDefinition = (DSA_DATA_DEFINITION *) *lppData;

    SpaceNeeded = sizeof(DSA_DATA_DEFINITION) +
                  SIZE_OF_DSA_PERFORMANCE_DATA;

    if ( *lpcbTotalBytes < SpaceNeeded ) {
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove(pDsaDataDefinition,
           &DsaDataDefinition,
           sizeof(DSA_DATA_DEFINITION));

    //  Format and collect DSA data from shared memory

    // The counter block is to immediately follow the data definition,
    // so obtain a pointer to that space
    pPerfCounterBlock = (DSA_COUNTER_DATA *) &pDsaDataDefinition[1];

    // The byte length is of the counter block header and all following data
    pPerfCounterBlock->cb.ByteLength = SIZE_OF_DSA_PERFORMANCE_DATA;

    // Compute a pointer to the buffer immediately following the counter
    // block header
    pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

    // copy the counter data from shared memory block into the counter block
    for( i = 0; i < DSA_LAST_COUNTER_INDEX/2; i++ )
    {
        pdwCounter[i] = 0;
        for( j = 0; j < cProcessor; j++ )
        {
            pdwCounter[i] += *((LPLONG)(((LPBYTE)&pCounterBlock[i + 1]) + cbPerfCounterData * j));
        }
    }

    // Tell caller where the next available byte is
    *lppData = (PVOID) ((PBYTE)pdwCounter + SIZE_OF_DSA_PERFORMANCE_DATA - sizeof(DSA_COUNTER_DATA));

    // update arguments before return

    *lpNumObjectTypes = 1;

    *lpcbTotalBytes = (DWORD)((PBYTE) *lppData - (PBYTE) pDsaDataDefinition);

    ASSERT ((sizeof(DSA_COUNTER_DATA) & 0x7) == 0);

    return ERROR_SUCCESS;
}


DWORD
CloseDsaPerformanceData(
)
/*++
Routine Description:
    This routine closes the open handles to DSA device performance counters

Arguments:
    None.

Return Value:
    ERROR_SUCCESS
--*/
{
// DebugBreak();
    if (!(--dwOpenCount)) {                 // when this is the last thread...
        
        UnmapViewOfFile (pCounterBlock);
        CloseHandle(hDsaSharedMemory);
        pCounterBlock = NULL;
        hDsaSharedMemory = NULL;
    }
//    LogPerfEvent( DIRLOG_PERF_CLOSE, 1, &dwOpenCount);
    return ERROR_SUCCESS;
}


//
// Data for this whole thing to work on
//

DSA_DATA_DEFINITION DsaDataDefinition = {

    {   sizeof(DSA_DATA_DEFINITION) + SIZE_OF_DSA_PERFORMANCE_DATA, // TotLen
        sizeof(DSA_DATA_DEFINITION),            // DefinitionLength
        sizeof(PERF_OBJECT_TYPE),               // HeaderLength
        DSAOBJ,                                 // ObjectNameTitleIndex
        0,                                      // ObjectNameTitle
        DSAOBJ + 1,                                 // ObjectHelpTitleIndex
        0,                                      // ObjectHelpTitle
        PERF_DETAIL_NOVICE,                     // DetailLevel
        (sizeof(DSA_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
          sizeof(PERF_COUNTER_DEFINITION),      // NumCounters
        0,                                      // DefaultCounter
        -1,                                     // NumInstances
        0                                       // CodePage (0=Unicode)
      },

    /* DRA Inbound Properties Total/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DRA_IN_PROPS,                           // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DRA_IN_PROPS + 1,                           // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        NUM_DRA_IN_PROPS_OFFSET                 // CounterOffset
    },

    /* AB browse ops */
    {   sizeof(PERF_COUNTER_DEFINITION),
        BROWSE,
        0,
        BROWSE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_BROWSE_OFFSET
      },

    /* DRA Inbound Object Updates Total/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        REPL,
        0,
        REPL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_REPL_OFFSET
      },

    /* live client threads in server */
    {   sizeof(PERF_COUNTER_DEFINITION),
        THREAD,
        0,
        THREAD + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_THREAD_OFFSET
      },

    /* count of bound AB clients */
    {   sizeof(PERF_COUNTER_DEFINITION),
        ABCLIENT,
        0,
        ABCLIENT + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_ABCLIENT_OFFSET
      },

    /* DRA Pending Replication Synchronizations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        PENDSYNC,
        0,
        PENDSYNC + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_PENDSYNC_OFFSET
      },

    /* DRA Inbound Object Updates Remaining in Packet */
    {   sizeof(PERF_COUNTER_DEFINITION),
        REMREPUPD,
        0,
        REMREPUPD + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_REMREPUPD_OFFSET
      },

    /* Number of Security descriptor propagations per second. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SDPROPS,
        0,
        SDPROPS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_SDPROPS_OFFSET
    },
    /* Number of Security descriptor propagations Events in the queue. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SDEVENTS,
        0,
        SDEVENTS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_SDEVENTS_OFFSET
    },
    /* Number of bound LDAP clients. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPCLIENTS,
        0,
        LDAPCLIENTS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_LDAPCLIENTS_OFFSET
    },
    /* Number of active LDAP threads. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPACTIVE,
        0,
        LDAPACTIVE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_LDAPACTIVE_OFFSET
    },
    /* Number of LDAP writes per second. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPWRITE,
        0,
        LDAPWRITE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAPWRITE_OFFSET
    },
    /* Number of LDAP searches per second. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPSEARCH,
        0,
        LDAPSEARCH + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAPSEARCH_OFFSET
    },
    /* DRA Outbound Objects/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRAOBJSHIPPED,
        0,
        DRAOBJSHIPPED + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRAOBJSHIPPED_OFFSET
    },
    /* DRA Outbound Properties/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRAPROPSHIPPED,
        0,
        DRAPROPSHIPPED + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRAPROPSHIPPED_OFFSET
    },
    /* DRA Inbound Values Total/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_VALUES,
        0,
        DRA_IN_VALUES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_VALUES_OFFSET
    },
    /* Number of replication sync requests made - # of GetNCChanges() calls made */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCREQUESTMADE,
        0,
        DRASYNCREQUESTMADE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRASYNCREQUESTMADE_OFFSET
    },
    /* Number of successful replication syncs - # of GetNCChanges() that returned successfully. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCREQUESTSUCCESSFUL,
        0,
        DRASYNCREQUESTSUCCESSFUL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRASYNCREQUESTSUCCESSFUL_OFFSET
    },
    /* Number of GetNCChanges() that failed due to a schema mismatch between the source and destination servers */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCREQUESTFAILEDSCHEMAMISMATCH,
        0,
        DRASYNCREQUESTFAILEDSCHEMAMISMATCH + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRASYNCREQUESTFAILEDSCHEMAMISMATCH_OFFSET
    },
    /* DRA Inbound Objects/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCOBJRECEIVED,
        0,
        DRASYNCOBJRECEIVED + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRASYNCOBJRECEIVED_OFFSET
    },
    /* DRA Inbound Properties Applied/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCPROPUPDATED,
        0,
        DRASYNCPROPUPDATED + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRASYNCPROPUPDATED_OFFSET
    },
    /* DRA Inbound Properties Filtered/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCPROPSAME,
        0,
        DRASYNCPROPSAME + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRASYNCPROPSAME_OFFSET
    },

    /* The size of the monitor list (see DirNotifyRegister) */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MONLIST,
        0,
        MONLIST + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_MONLIST_OFFSET
    },

    /* The size of the dir notify queue (see DirNotifyRegister) */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NOTIFYQ,
        0,
        NOTIFYQ + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_NOTIFYQ_OFFSET
    },
        /* The number of UDP connections per second for LDAP */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPUDPCLIENTS,
        0,
        LDAPUDPCLIENTS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAPUDPCLIENTS_OFFSET
    },
        /* The number of search sub operations per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SUBSEARCHOPS,
        0,
        SUBSEARCHOPS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_SUBSEARCHOPS_OFFSET
    },

    /* The hit rate of the DN read cache (with the next counter) */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NAMECACHEHIT,
        0,
        NAMECACHEHIT + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_SAMPLE_FRACTION,
        sizeof(DWORD),
        NUM_NAMECACHEHIT_OFFSET
    },

    /* The lookup rate of the DN read cache (should be invisible) */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NAMECACHETRY,
        0,
        NAMECACHETRY + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_SAMPLE_BASE,
        sizeof(DWORD),
        NUM_NAMECACHETRY_OFFSET
    },

    /* LowOrder 32 bit of the Highest USN Issued */
    {   sizeof(PERF_COUNTER_DEFINITION),
        HIGHESTUSNISSUEDLO,
        0,
        HIGHESTUSNISSUEDLO + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_HIGHESTUSNISSUEDLO_OFFSET
    },

    /* HighOrder 32 bit of the Highest USN Issued */
    {   sizeof(PERF_COUNTER_DEFINITION),
        HIGHESTUSNISSUEDHI,
        0,
        HIGHESTUSNISSUEDHI + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_HIGHESTUSNISSUEDHI_OFFSET
    },

    /* LowOrder 32 bit of the Highest USN Committed */
    {   sizeof(PERF_COUNTER_DEFINITION),
        HIGHESTUSNCOMMITTEDLO,
        0,
        HIGHESTUSNCOMMITTEDLO + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_HIGHESTUSNCOMMITTEDLO_OFFSET
    },

    /* HighOrder 32 bit of the Highest USN Committed */
    {   sizeof(PERF_COUNTER_DEFINITION),
        HIGHESTUSNCOMMITTEDHI,
        0,
        HIGHESTUSNCOMMITTEDHI + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_HIGHESTUSNCOMMITTEDHI_OFFSET
    },

    /* SAM Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SAMWRITES,
        0,
        SAMWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_SAMWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES1,
        0,
        TOTALWRITES1 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* DRA Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRAWRITES,
        0,
        DRAWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_DRAWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES2,
        0,
        TOTALWRITES2 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* LDAP Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPWRITES,
        0,
        LDAPWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_LDAPWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES3,
        0,
        TOTALWRITES3 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* LSA Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LSAWRITES,
        0,
        LSAWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_LSAWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES4,
        0,
        TOTALWRITES4 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* KCC Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        KCCWRITES,
        0,
        KCCWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_KCCWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES6,
        0,
        TOTALWRITES6 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* NSPI Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPIWRITES,
        0,
        NSPIWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NSPIWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES7,
        0,
        TOTALWRITES7 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* Other Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        OTHERWRITES,
        0,
        OTHERWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_OTHERWRITES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES8,
        0,
        TOTALWRITES8 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* Total Writes /sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALWRITES,
        0,
        TOTALWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_TOTALWRITES_OFFSET
    },

    /* SAM Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SAMSEARCHES,
        0,
        SAMSEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_SAMSEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES1,
        0,
        TOTALSEARCHES1 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* DRA Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASEARCHES,
        0,
        DRASEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_DRASEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES2,
        0,
        TOTALSEARCHES2 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* LDAP Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPSEARCHES,
        0,
        LDAPSEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_LDAPSEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES3,
        0,
        TOTALSEARCHES3 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* LSA Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LSASEARCHES,
        0,
        LSASEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_LSASEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES4,
        0,
        TOTALSEARCHES4 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* KCC Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        KCCSEARCHES,
        0,
        KCCSEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_KCCSEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES6,
        0,
        TOTALSEARCHES6 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* NSPI Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPISEARCHES,
        0,
        NSPISEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NSPISEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES7,
        0,
        TOTALSEARCHES7 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* Other Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        OTHERSEARCHES,
        0,
        OTHERSEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_OTHERSEARCHES_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES8,
        0,
        TOTALSEARCHES8 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* Total Searches /sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALSEARCHES,
        0,
        TOTALSEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_TOTALSEARCHES_OFFSET
    },

    /* SAM Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SAMREADS,
        0,
        SAMREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_SAMREADS_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS1,
        0,
        TOTALREADS1 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },

    /* DRA Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRAREADS,
        0,
        DRAREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_DRAREADS_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS2,
        0,
        TOTALREADS2 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },

    /* DRA Inbound Values (DNs only)/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_DN_VALUES,
        0,
        DRA_IN_DN_VALUES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_DN_VALUES_OFFSET
    },

    /* DRA Inbound Objects Filtered/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_OBJS_FILTERED,
        0,
        DRA_IN_OBJS_FILTERED + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_OBJS_FILTERED_OFFSET
    },

    /* LSA Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LSAREADS,
        0,
        LSAREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_LSAREADS_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS4,
        0,
        TOTALREADS4 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },


    /* KCC Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        KCCREADS,
        0,
        KCCREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_KCCREADS_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS6,
        0,
        TOTALREADS6 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },

    /* NSPI Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPIREADS,
        0,
        NSPIREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NSPIREADS_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS7,
        0,
        TOTALREADS7 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },

    /* Other Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        OTHERREADS,
        0,
        OTHERREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_OTHERREADS_OFFSET
    },

    /* Should be invisible */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS8,
        0,
        TOTALREADS8 + 1,
        0,
        0,
        PERF_DETAIL_WIZARD,
        PERF_RAW_BASE,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },

    /* Total Reads /sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TOTALREADS,
        0,
        TOTALREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_TOTALREADS_OFFSET
    },

    /* LDAP Binds */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPBINDSUCCESSFUL,
        0,
        LDAPBINDSUCCESSFUL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAPBINDSUCCESSFUL_OFFSET
    },

    /* LDAP Bind Times */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAPBINDTIME,
        0,
        LDAPBINDTIME + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_LDAPBINDTIME_OFFSET
    },

    /* Create Machine Successful */
    {   sizeof(PERF_COUNTER_DEFINITION),
        CREATEMACHINESUCCESSFUL,
        0,
        CREATEMACHINESUCCESSFUL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_CREATEMACHINESUCCESSFUL_OFFSET
    },

    /* Create Machine Attempts */
    {   sizeof(PERF_COUNTER_DEFINITION),
        CREATEMACHINETRIES,
        0,
        CREATEMACHINETRIES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_CREATEMACHINETRIES_OFFSET
    },

    /* Create User Successful */
    {   sizeof(PERF_COUNTER_DEFINITION),
        CREATEUSERSUCCESSFUL,
        0,
        CREATEUSERSUCCESSFUL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_CREATEUSERSUCCESSFUL_OFFSET
    },

    /* Create User Attempts */
    {   sizeof(PERF_COUNTER_DEFINITION),
        CREATEUSERTRIES,
        0,
        CREATEUSERTRIES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_CREATEUSERTRIES_OFFSET
    },

    /* Password Changes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        PASSWORDCHANGES,
        0,
        PASSWORDCHANGES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_PASSWORDCHANGES_OFFSET
    },

    /* Group Membership Changes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBERSHIPCHANGES,
        0,
        MEMBERSHIPCHANGES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBERSHIPCHANGES_OFFSET
    },

    /* Query Displays */
    {   sizeof(PERF_COUNTER_DEFINITION),
        QUERYDISPLAYS,
        0,
        QUERYDISPLAYS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_QUERYDISPLAYS_OFFSET
    },

    /* Enumerations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        ENUMERATIONS,
        0,
        ENUMERATIONS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_ENUMERATIONS_OFFSET
    },

    /* Transitive Evaluations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBEREVALTRANSITIVE,
        0,
        MEMBEREVALTRANSITIVE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBEREVALTRANSITIVE_OFFSET
    },

    /* Non Transitive Evaluations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBEREVALNONTRANSITIVE,
        0,
        MEMBEREVALNONTRANSITIVE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBEREVALNONTRANSITIVE_OFFSET
    },

    /* Resource Group Evaluations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBEREVALRESOURCE,
        0,
        MEMBEREVALRESOURCE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBEREVALRESOURCE_OFFSET
    },

    /* Universal Group Evaluations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBEREVALUNIVERSAL,
        0,
        MEMBEREVALUNIVERSAL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBEREVALUNIVERSAL_OFFSET
    },

    /* Account Group Evaluations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBEREVALACCOUNT,
        0,
        MEMBEREVALACCOUNT + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBEREVALACCOUNT_OFFSET
    },

    /* GC Evaluations */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MEMBEREVALASGC,
        0,
        MEMBEREVALASGC + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MEMBEREVALASGC_OFFSET
    },

    /* Kerberos Logons */
    {   sizeof(PERF_COUNTER_DEFINITION),
        ASREQUESTS,
        0,
        ASREQUESTS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_AS_REQUESTS_OFFSET
    },

    /* KDC TGS Requests/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        TGSREQUESTS,
        0,
        TGSREQUESTS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_TGS_REQUESTS_OFFSET
    },

    /* Kerberos Authentications/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        KERBEROSAUTHENTICATIONS,
        0,
        KERBEROSAUTHENTICATIONS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_KERBEROS_AUTHENTICATIONS_OFFSET
     },

    /* NTLM Authentications/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        MSVAUTHENTICATIONS,
        0,
        MSVAUTHENTICATIONS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_MSVAUTHENTICATIONS_OFFSET
     },

    /* DRA Inbound Full Sync Remaining Objects */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRASYNCFULLREM,
        0,
        DRASYNCFULLREM + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRASYNCFULLREM_OFFSET
    },

    /* DRA Inbound Bytes Total/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_TOTAL_RATE,
        0,
        DRA_IN_BYTES_TOTAL_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_TOTAL_RATE_OFFSET
    },

    /* DRA Inbound Bytes Not Compressed/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_NOT_COMP_RATE,
        0,
        DRA_IN_BYTES_NOT_COMP_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_NOT_COMP_RATE_OFFSET
    },

    /* DRA Inbound Compressed Bytes Before Compression/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_COMP_PRE_RATE,
        0,
        DRA_IN_BYTES_COMP_PRE_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_COMP_PRE_RATE_OFFSET
    },

    /* DRA Inbound Compressed Bytes After Compression/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_COMP_POST_RATE,
        0,
        DRA_IN_BYTES_COMP_POST_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_COMP_POST_RATE_OFFSET
    },

    /* DRA Outbound Bytes Total/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_TOTAL_RATE,
        0,
        DRA_OUT_BYTES_TOTAL_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_TOTAL_RATE_OFFSET
    },

    /* DRA Outbound Bytes Not Compressed/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_NOT_COMP_RATE,
        0,
        DRA_OUT_BYTES_NOT_COMP_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_NOT_COMP_RATE_OFFSET
    },

    /* DRA Outbound Compressed Bytes Before Compression/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_COMP_PRE_RATE,
        0,
        DRA_OUT_BYTES_COMP_PRE_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_COMP_PRE_RATE_OFFSET
    },

    /* DRA Outbound Compressed Bytes After Compression/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_COMP_POST_RATE,
        0,
        DRA_OUT_BYTES_COMP_POST_RATE + 1,
        0,
        (DWORD) -3, // default 1/1,000th scale
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_COMP_POST_RATE_OFFSET
    },

        /* The number of ntdsapi.dll originated IDL_DRSBind per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DS_CLIENT_BIND,
        0,
        DS_CLIENT_BIND + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DS_CLIENT_BIND_OFFSET
    },

        /* The number of DC-to-DC originated IDL_DRSBind per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DS_SERVER_BIND,
        0,
        DS_SERVER_BIND + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DS_SERVER_BIND_OFFSET
    },

        /* The number of ntdsapi.dll originated name translations per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DS_CLIENT_NAME_XLATE,
        0,
        DS_CLIENT_NAME_XLATE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DS_CLIENT_NAME_TRANSLATE_OFFSET
    },

        /* The number of DC-to-DC originated name translations per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DS_SERVER_NAME_XLATE,
        0,
        DS_SERVER_NAME_XLATE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DS_SERVER_NAME_TRANSLATE_OFFSET
    },
    /* Size of the runtime queue for the SD propagator. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SDPROP_RUNTIME_QUEUE,
        0,
        SDPROP_RUNTIME_QUEUE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_SDPROP_RUNTIME_QUEUE_OFFSET
    },
    /* Size of the runtime queue for the SD propagator. */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SDPROP_WAIT_TIME,
        0,
        SDPROP_WAIT_TIME + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_SDPROP_WAIT_TIME_OFFSET
    },

    /* DRA Outbound Objects Filtered/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_OBJS_FILTERED,
        0,
        DRA_OUT_OBJS_FILTERED + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_OBJS_FILTERED_OFFSET
    },

    /* DRA Outbound Values Total/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_VALUES,
        0,
        DRA_OUT_VALUES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_VALUES_OFFSET
    },

    /* DRA Outbound Values (DNs only)/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_DN_VALUES,
        0,
        DRA_OUT_DN_VALUES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_DRA_OUT_DN_VALUES_OFFSET
    },

    /* AB ANR/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPI_ANR,
        0,
        NSPI_ANR + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_NSPI_ANR_OFFSET
    },

    /* AB Property Reads/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPI_PROPERTY_READS,
        0,
        NSPI_PROPERTY_READS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_NSPI_PROPERTY_READS_OFFSET
    },

    /* AB Searches/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPI_OBJECT_SEARCH,
        0,
        NSPI_OBJECT_SEARCH + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_NSPI_OBJECT_SEARCH_OFFSET
    },

    /* AB Matches/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPI_OBJECT_MATCHES,
        0,
        NSPI_OBJECT_MATCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_NSPI_OBJECT_MATCHES_OFFSET
    },

    /* Proxy Lookups/sec */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NSPI_PROXY_LOOKUP,
        0,
        NSPI_PROXY_LOOKUP + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_NSPI_PROXY_LOOKUP_OFFSET
    },
    /* ATQ Threads in use */
    {   sizeof(PERF_COUNTER_DEFINITION),
        ATQ_THREADS_TOTAL,
        0,
        ATQ_THREADS_TOTAL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_ATQ_THREADS_TOTAL_OFFSET
    },
    /* ATQ Threads used by LDAP */
    {   sizeof(PERF_COUNTER_DEFINITION),
        ATQ_THREADS_LDAP,
        0,
        ATQ_THREADS_LDAP + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_ATQ_THREADS_LDAP_OFFSET
    },
    /* ATQ Threads used by other services i.e. Kerberos */
    {   sizeof(PERF_COUNTER_DEFINITION),
        ATQ_THREADS_OTHER,
        0,
        ATQ_THREADS_OTHER + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_ATQ_THREADS_OTHER_OFFSET
    },

    /* DRA Inbound Bytes Total */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_TOTAL,
        0,
        DRA_IN_BYTES_TOTAL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_TOTAL_OFFSET
    },

    /* DRA Inbound Bytes Not Compressed */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_NOT_COMP,
        0,
        DRA_IN_BYTES_NOT_COMP + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_NOT_COMP_OFFSET
    },

    /* DRA Inbound Compressed Bytes Before Compression */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_COMP_PRE,
        0,
        DRA_IN_BYTES_COMP_PRE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_COMP_PRE_OFFSET
    },

    /* DRA Inbound Compressed Bytes After Compression */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_IN_BYTES_COMP_POST,
        0,
        DRA_IN_BYTES_COMP_POST + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_IN_BYTES_COMP_POST_OFFSET
    },

    /* DRA Outbound Bytes Total */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_TOTAL,
        0,
        DRA_OUT_BYTES_TOTAL + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_TOTAL_OFFSET
    },

    /* DRA Outbound Bytes Not Compressed */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_NOT_COMP,
        0,
        DRA_OUT_BYTES_NOT_COMP + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_NOT_COMP_OFFSET
    },

    /* DRA Outbound Compressed Bytes Before Compression */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_COMP_PRE,
        0,
        DRA_OUT_BYTES_COMP_PRE + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_COMP_PRE_OFFSET
    },

    /* DRA Outbound Compressed Bytes After Compression */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_OUT_BYTES_COMP_POST,
        0,
        DRA_OUT_BYTES_COMP_POST + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_OUT_BYTES_COMP_POST_OFFSET
    },

    /* Incoming LDAP connections per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAP_NEW_CONNS_PER_SEC,
        0,
        LDAP_NEW_CONNS_PER_SEC + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAP_NEW_CONNS_PER_SEC_OFFSET
    },

    /* Closed LDAP connections per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAP_CLS_CONNS_PER_SEC,
        0,
        LDAP_CLS_CONNS_PER_SEC + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAP_CLS_CONNS_PER_SEC_OFFSET
    },

    /* New SSL/TLS LDAP connections per second */
    {   sizeof(PERF_COUNTER_DEFINITION),
        LDAP_SSL_CONNS_PER_SEC,
        0,
        LDAP_SSL_CONNS_PER_SEC + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        NUM_LDAP_SSL_CONNS_PER_SEC_OFFSET
    },

    /* Replication Operations in the queue */
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_REPL_QUEUE_OPS,
        0,
        DRA_REPL_QUEUE_OPS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_REPL_QUEUE_OPS_OFFSET
    },

    /* Number of Threads in IDL_DRSGetNCChanges*/
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_TDS_IN_GETCHNGS,
        0,
        DRA_TDS_IN_GETCHNGS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_TDS_IN_GETCHNGS_OFFSET
    },

    /* Number of Threads in IDL_DRSGetNCChanges which aquired the Semaphore*/
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_TDS_IN_GETCHNGS_W_SEM,
        0,
        DRA_TDS_IN_GETCHNGS_W_SEM + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_TDS_IN_GETCHNGS_W_SEM_OFFSET
    },

    /* Number of Remaining Replication Updates for Link Values*/
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_REM_REPL_UPD_LNK,
        0,
        DRA_REM_REPL_UPD_LNK + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_REM_REPL_UPD_LNK_OFFSET
    },
    
    /* Number of Remaining Replication Updates for Total (objects + link values)*/
    {   sizeof(PERF_COUNTER_DEFINITION),
        DRA_REM_REPL_UPD_TOT,
        0,
        DRA_REM_REPL_UPD_TOT + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_DRA_REM_REPL_UPD_TOT_OFFSET
    },

    /* NTDSAPI Writes */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NTDSAPIWRITES,
        0,
        NTDSAPIWRITES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NTDSAPIWRITES_OFFSET
    },

    /* NTDSAPI Searches */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NTDSAPISEARCHES,
        0,
        NTDSAPISEARCHES + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NTDSAPISEARCHES_OFFSET
    },

    /* NTDSAPI Reads */
    {   sizeof(PERF_COUNTER_DEFINITION),
        NTDSAPIREADS,
        0,
        NTDSAPIREADS + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_RAW_FRACTION,
        sizeof(DWORD),
        NUM_NTDSAPIREADS_OFFSET
    },

    /* SAM Account and Universal Group evaluation latency */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SAM_ACCT_GROUP_LATENCY,
        0,
        SAM_ACCT_GROUP_LATENCY + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_SAM_ACCT_GROUP_LATENCY_OFFSET
    },

    /* SAM Resource Group evaluation latency */
    {   sizeof(PERF_COUNTER_DEFINITION),
        SAM_RES_GROUP_LATENCY,
        0,
        SAM_RES_GROUP_LATENCY + 1,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        NUM_SAM_RES_GROUP_LATENCY_OFFSET
    },
};

int APIENTRY _CRT_INIT(
        HANDLE hInstance,
        DWORD ulReasonBeingCalled,
        LPVOID lpReserved);


int __stdcall LibMain(
        HANDLE hInstance,
        DWORD ulReasonBeingCalled,
        LPVOID lpReserved)
{
    return (_CRT_INIT(hInstance, ulReasonBeingCalled,lpReserved));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\parser\utest\main.cxx ===
#include <NTDSpch.h>
#pragma hdrstop
#include "parser.hxx"

CParser parser;
BOOL fQuit;

// Expression 1: "What time is it"

HRESULT Expr1Implementation(CArgs *pArgs)
{
    SYSTEMTIME sysTime;

    GetLocalTime(&sysTime);

    printf("The time is: %02d/%02d/%04d @ %02d:%02d:%02d:%04d\n",
           sysTime.wDay,
           sysTime.wMonth,
           sysTime.wYear,
           sysTime.wHour,
           sysTime.wMinute,
           sysTime.wMinute,
           sysTime.wMilliseconds);

    return(S_OK);
}

// Expression 2: "What is %d x %d"

HRESULT Expr2Implementation(CArgs *pArgs)
{
    int i0,i1;
    HRESULT hr;

    if ( FAILED(hr = pArgs->GetInt(0,&i0)) )
        return(hr);

    if ( FAILED(hr = pArgs->GetInt(1,&i1)) )
        return(hr);

    printf("%d x %d --> %d\n", 
           i0, 
           i1, 
           i0 * i1);
    
    return(S_OK);
}

// Expression 3: "Reverse the string %s"

HRESULT Expr3Implementation(CArgs *pArgs)
{
    const WCHAR *p;
    HRESULT hr;

    if ( FAILED(hr = pArgs->GetString(0,&p)) )
        return(hr);

    int l = wcslen(p);

    WCHAR *pReverse = new WCHAR [ l + 1 ];

    if ( NULL == pReverse )
        return(E_OUTOFMEMORY);

    for ( int i = 0; i < l; i++ )
    {
        WCHAR c = p[i];
        pReverse[i]  = p[l-i-1];
        pReverse[l-i-1] = c;
    }

    pReverse[l] = L'\0';

    printf("%ws <--> %ws\n",
           p,
           pReverse);

    delete [] pReverse;

    return(S_OK);
}

// Expression 4: "Help"

HRESULT Expr4Implementation(CArgs *pArgs)
{
    return(parser.Dump(stdout,L""));
}

// Expression 5: "Quit"

HRESULT Expr5Implementation(CArgs *pArgs)
{
    fQuit = TRUE;
    return(S_OK);
}

// Expression 6: print large integer
HRESULT Expr6Implementation(CArgs *pArgs)
{
    LONGLONG i64a = 0,i64b = 0;
    HRESULT hr;

    hr = pArgs->GetLongLong(0,&i64a);
    hr = pArgs->GetLongLong(1,&i64b);

    printf("Large integer = %I64d, %I64d\n", i64a, i64b );
    
    return(S_OK);
}


// Build a table which defines our language.

typedef struct _LegalExpr {
   WCHAR       *expr;
   HRESULT    (*func)(CArgs *pArgs);
   WCHAR       *help;
} LegalExpr;

LegalExpr language[] = 
{
    {   L"What time is it",
        Expr1Implementation,
        L"Prints the current date and time" },

    {   L"What is %d x %d",
        Expr2Implementation,
        L"Multiplies two integers" },

    {   L"Reverse the string %s",
        Expr3Implementation,
        L"Reverses the specified string" },

    {   L"Help",
        Expr4Implementation,
        L"Prints this help information" },

    {   L"?",
        Expr4Implementation,
        L"Prints this help information" },

    {   L"Quit",
        Expr5Implementation,
        L"Ends parsing" },

    {   L"print large integer",
        Expr6Implementation,
        L"Prints a large integer with no arguments" },

    {   L"print large integer first %I64d",
        Expr6Implementation,
        L"Prints a large integer with one argument" },

    {   L"print large integer first %I64d second %I64d",
        Expr6Implementation,
        L"Prints a large integer with two arguments" },
};

int _cdecl main(int argc, char *argv[])
{
    HRESULT hr;

    int cExpr = sizeof(language) / sizeof(LegalExpr);

    for ( int i = 0; i < cExpr; i++ )
    {
        if ( FAILED(hr = parser.AddExpr(language[i].expr,
                                        language[i].func,
                                        language[i].help)) )
        {
            printf("AddExpr error %08lx\n", hr);
            return(hr);
        }
    }

    fQuit = FALSE;

    // advance past program name
    argc -= 1;
    argv += 1;

    hr = parser.Parse(&argc,
                      &argv,
                      stdin,
                      stdout,
                      L"Parser unit test:",
                      &fQuit,
                      TRUE,                 // timing info
                      FALSE);               // quit on error

    if ( FAILED(hr) )
        printf("Unit test error %08lx\n", hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\parsedn\parsedn.c ===
/*++

Copyright (c) 1987-1997 Microsoft Corporation

Module Name:

    parsedn.c

Abstract:

    This file is a superset of ds\src\ntdsa\src\parsedn.c by virtue
    of #include of the aforementioned source file.  The idea is that
    the various clients need to do some client side DN parsing and
    we do not want to duplicate the code.  And build.exe won't find
    files any other place than in the directory being built or the
    immediate parent directory.

Author:

    Dave Straube    (davestr)   26-Oct-97

Revision History:

    Dave Straube    (davestr)   26-Oct-97
        Genesis  - #include of src\dsamain\src\parsedn.c and no-op DoAssert().

    Brett Shirley   (brettsh)   18-Jun-2001
        Modification to seperate library.  Moved this file and turned it into
        the parsedn.lib library.  See primary comment below.

--*/

//
// On 28-Jun-2001 the main part of this file was moved from ntdsapi\parsedn.c
// to here to provide a seperate statically linkeable library for the various 
// string only DN parsing functions (like CountNameParts, NameMatched, 
// TrimDSNameBy, etc).
//

// Define the symbol which turns off varios capabilities in the original
// parsedn.c which we don't need or would take in too many helpers which we
// don't want on the client side.  For example, we disable recognition of
// "OID=1.2.3.4" type tags and any code which uses THAlloc/THFree.

#define CLIENT_SIDE_DN_PARSING 1

// Include the original source in all its glory.

#include "..\..\ntdsa\src\parsedn.c"

// Provide stubs for what would otherwise be unresolved externals.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\parser\cparser.cxx ===
#include <NTDSpchX.h>
#pragma hdrstop
#include <conio.h>
#include "parser.hxx"
#include "ctimer.hxx"

static WCHAR *pwszDelimiters = L" ";  // input delimiters - used by wcstok

#define MIN(x,y) ((x < y) ? x : y )
#define COMMENT_ESCAPE_STRING       "//"

//+-------------------------------------------------------------------
//
//  Member:    mywcstok
//
//  Synopsis:  A wrapper around the C library wcstok() to provide quoted token
//             support in a primitive fashion.
//
//  Effects:   None
//
//  Arguments: [pString] - pointer to string to be parsed, or NULL
//             [pDelim]  - pointer to string of delimiters
//
//  Algorithm: Replaces embedded spaces with FUNKY_WCHAR on first call, and
//             converts them back after wcstok has parsed the space-delimited
//             string.
//
//  History:   14-Dec-93	DaveStr		Genesis
//
//--------------------------------------------------------------------

#define FUNKY_WCHAR ((WCHAR) 0xffff)    // non-printable character used as
                                    // embedded space marker

static WCHAR *mywcstok(
	WCHAR *pString,
	WCHAR *pDelim)
{
   if ( pString != NULL )
   {
      BOOL fQuotes = FALSE;

      for ( WCHAR *p = pString; *p != L'\0'; p++ )
      {
         if ( *p == L'\"' )
         {
            fQuotes = !fQuotes;
            *p = ' ';
            continue;
         }

         if ( fQuotes == TRUE && *p == L' ' )
         {
            *p = FUNKY_WCHAR;
         }
      }
   }

   WCHAR *pRetVal = wcstok(pString,pDelim);

   if ( pRetVal != NULL )
   {
      for ( WCHAR *p = pRetVal; *p != L'\0'; p++ )
      {
         if ( *p == FUNKY_WCHAR )
         {
            *p = L' ';
         }
      }
   }

   return(pRetVal);
}

//+-------------------------------------------------------------------
//
//  Member:    CompareParseNode
//
//  Synopsis:  Compares two ParseNodes based on their pwszToken field.
//             Comparison is case-insensitive.
//             Passed as argument to qsort() and bsearch().
//
//  Effects:   None
//
//  Arguments: [pVoid1] pointer to first ParseNode
//             [pVoid2] pointer to second ParseNode
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:     None
//
//--------------------------------------------------------------------

int _cdecl CompareParseNode(const void *pVoid1,
                            const void *pVoid2)
{
   ParseNode *p1 = (ParseNode *) pVoid1;
   ParseNode *p2 = (ParseNode *) pVoid2;

   return(_wcsicmp(p1->pwszToken,p2->pwszToken));
}

//+-------------------------------------------------------------------
//
//  Member:    CompareParseNodePrefix
//
//  Synopsis:  Compares two ParseNodes based on their common pwszToken prefixes.
//             Comparison is case-insensitive.
//             Passed as argument to bsearch().
//
//  Effects:   None
//
//  Arguments: [pVoid1] pointer to first ParseNode
//             [pVoid2] pointer to second ParseNode
//
//  Algorithm: Calls wcsnicmp().
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:     None
//
//--------------------------------------------------------------------

int _cdecl CompareParseNodePrefix(const void *pVoid1,
                                   const void *pVoid2)
{
   ParseNode *p1 = (ParseNode *) pVoid1;
   ParseNode *p2 = (ParseNode *) pVoid2;

   int l1 = wcslen(p1->pwszToken);
   int l2 = wcslen(p2->pwszToken);

   return(_wcsnicmp(p1->pwszToken,p2->pwszToken,MIN(l1,l2)));
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::CParser
//
//  Synopsis:  Constructor
//
//  Effects:   None
//
//  Arguments: None
//
//  Algorithm: Zeros all member variables.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:     None
//
//--------------------------------------------------------------------

CParser::CParser()
{
   _cNodes = 0;
   _cMax = 0;
   _rNodes = NULL;
   _pExprChain = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::~CParser
//
//  Synopsis:  Destructor
//
//  Effects:   None
//
//  Arguments: None
//
//  Algorithm: "delete"s all pointers alocated by "new".
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:     None
//
//--------------------------------------------------------------------

CParser::~CParser()
{
   for ( int i = 0; i < _cNodes; i++ )
   {
      if ( _rNodes[i].pChild != NULL )
      {
         delete _rNodes[i].pChild;
      }
   }

   if ( _cNodes > 0 )
   {
      delete [] _rNodes;
   }

   while ( NULL != _pExprChain )
   {
      ParserExpr *px = _pExprChain;

      _pExprChain = _pExprChain->pNext;
      delete [] px;
   }
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::_FindToken
//
//  Synopsis:  Finds a token and adds it it to the CArgs argument.
//             CArgs pointer may be NULL.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::_FindToken(WCHAR *pwszToken,
                            int *pIndex,
                            CArgs *pArgs,
                            int matchType,
                            int *pStatus)
{
   HRESULT hr;

   ASSERT((matchType == FULL_MATCH) || (matchType == PREFIX_MATCH));
   ASSERT(pwszToken);

   ParseNode testNode;
   ParseNode *pFoundNode;

   BOOL prefixMatched = FALSE;

   
   if ( wcslen(pwszToken) >= TOKEN_LENGTH )
   {
      // definitely won't match any real tokens but might still match %d or %s

      goto PatternMatch;
   }

   // first search for literal token

   wcscpy(testNode.pwszToken,pwszToken);

   if ( matchType == FULL_MATCH )
   {
      pFoundNode = (ParseNode *) bsearch((void *) &testNode,
                                         (void *) _rNodes,
                                         (size_t) _cNodes,
                                         (size_t) sizeof(ParseNode),
                                         CompareParseNode);

      if ( pFoundNode != NULL )
      {
         *pIndex = (INT)(pFoundNode - _rNodes);
         *pStatus = TOKEN_FOUND;
         return(S_OK);
      }
   }
   else
   {
      pFoundNode = (ParseNode *) bsearch((void *) &testNode,
                                         (void *) _rNodes,
                                         (size_t) _cNodes,
                                         (size_t) sizeof(ParseNode),
                                         CompareParseNodePrefix);
      // PREFIX: 'testNode' may be used without being initialized if 
      // pwszToken==0.  However, the callers of this function will never call
      // with pwszToken==0.

      if ( pFoundNode != NULL )
      {
         // A match was found.  But we don't know if pwszToken is shorter
         // than the node value or the other way around.  pwszToken needs
         // to be a prefix of the node for a valid match.

         int i = (INT)(pFoundNode - _rNodes);

         int len = wcslen(pwszToken);

         if ( len <= (int) wcslen(_rNodes[i].pwszToken) )
         {
            // make sure no neighbors have the same prefix

            if ( ( (i == 0) ||
                   _wcsnicmp(pwszToken,_rNodes[i-1].pwszToken,len) )
                 &&
                 ( (i == (_cNodes-1)) ||
                   _wcsnicmp(pwszToken,_rNodes[i+1].pwszToken,len) ) )
            {
               *pIndex = i;
               *pStatus = TOKEN_FOUND;
               return(S_OK);
            }
            else
            {
               // we had an ambiguous prefix match - save for later
               // error reporting

               prefixMatched = TRUE;
            }
         }
      }
   }

PatternMatch:

   // next try for %d
   // do this before matching against %s since any string will match it

   wcscpy(testNode.pwszToken,L"%d");

   pFoundNode = (ParseNode *) bsearch((void *) &testNode,
                                      (void *) _rNodes,
                                      (size_t) _cNodes,
                                      (size_t) sizeof(ParseNode),
                                      CompareParseNode);

   if ( pFoundNode != NULL )
   {
      WCHAR tmp[MAX_PATH];
      int i;

      // following swscanf insures we don't accept numbers with trailing garbage

      if ( swscanf(pwszToken,L"%d%s",&i,tmp) == 1 )
      {
         if ( pArgs != NULL )
         {
            hr = pArgs->Add(i);

            if ( FAILED(hr) )
               return(hr);
         }

         *pIndex = (INT)(pFoundNode - _rNodes);
         *pStatus = TOKEN_INTEGER;
         return(S_OK);
      }
   }

   // next try for %I64d

   wcscpy(testNode.pwszToken,L"%I64d");

   pFoundNode = (ParseNode *) bsearch((void *) &testNode,
                                      (void *) _rNodes,
                                      (size_t) _cNodes,
                                      (size_t) sizeof(ParseNode),
                                      CompareParseNode);

   if ( pFoundNode != NULL )
   {
      WCHAR tmp[MAX_PATH];
      LONGLONG i64;

      // following swscanf insures we don't accept numbers with trailing garbage

      if ( swscanf(pwszToken,L"%I64d%s",&i64,tmp) == 1 )
      {
         if ( pArgs != NULL )
         {
            hr = pArgs->Add(i64);

            if ( FAILED(hr) )
               return(hr);
         }

         *pIndex = (INT)(pFoundNode - _rNodes);
         *pStatus = TOKEN_LONGLONG;
         return(S_OK);
      }
   }

   // next try for %s

   wcscpy(testNode.pwszToken,L"%s");

   pFoundNode = (ParseNode *) bsearch((void *) &testNode,
                                      (void *) _rNodes,
                                      (size_t) _cNodes,
                                      (size_t) sizeof(ParseNode),
                                      CompareParseNode);

   if ( pFoundNode != NULL )
   {
      if ( pArgs != NULL )
      {
         hr = pArgs->Add(pwszToken);

         if ( FAILED(hr) )
            return(hr);
      }

      *pIndex = (INT)(pFoundNode - _rNodes);
      *pStatus = TOKEN_STRING;
      return(S_OK);
   }

   if ( prefixMatched == TRUE )
   {
      *pStatus = PREFIX_NOT_UNIQUE;
   }
   else
   {
      *pStatus = TOKEN_NOT_FOUND;
   }

   return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::_InsertToken
//
//  Synopsis:  Insert a new token and return its index.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::_InsertToken(WCHAR *pwszToken,
                              int *pIndex)
{
   HRESULT hr;

   if ( (NULL == pwszToken) || (0 == wcslen(pwszToken)) )
     return(E_INVALIDARG);

   if ( wcslen(pwszToken) >= TOKEN_LENGTH )
      return(E_INVALIDARG);

   int result;

   if ( FAILED(hr = _FindToken(pwszToken,pIndex,NULL,FULL_MATCH,&result)) )
      return(hr);

   if ( TOKEN_FOUND == result )
      return(E_INVALIDARG);

   if ( FAILED(hr = MakeSpace()) )
      return(hr);

   wcscpy(_rNodes[_cNodes++].pwszToken,pwszToken);

   qsort((void *) _rNodes,
         (size_t) _cNodes,
         (size_t) sizeof(ParseNode),
         CompareParseNode);

   // qsort may have moved the index - find it again

   if ( FAILED(hr = _FindToken(pwszToken,pIndex,NULL,FULL_MATCH,&result)) )
      return(hr);

   ASSERT(result == TOKEN_FOUND);

   return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::AddExpr
//
//  Synopsis:  Add an entire expression (sentence) to the parser.
//
//  History:   01-Sep-93	DaveStr		Genesis
//             04-Aug-95    DaveStr     read-only data segment workaround
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::AddExpr(WCHAR *pwszExpr,
                         HRESULT (*pFunc)(CArgs *pArgs),
                         const WCHAR *pwszHelp)
{
   if ( (NULL == pwszExpr) ||
        (0 == wcslen(pwszExpr)) ||
        (NULL == pFunc) )
   {
      return(E_INVALIDARG);
   }

   ULONG cBytes = sizeof(ParserExpr) +
                  (sizeof(WCHAR) * (1 + wcslen(pwszExpr)));

   ParserExpr *px = (ParserExpr *) new BYTE [ cBytes ];

   if ( NULL == px )
      return(E_OUTOFMEMORY);

   wcscpy(px->expr, pwszExpr);
   px->pNext = _pExprChain;
   _pExprChain = px;

   WCHAR *pwszToken = mywcstok(px->expr,pwszDelimiters);

   if ( pwszToken == NULL )
   {
      // Attempt to add expression with no tokens.

      return(E_INVALIDARG);
   }

   return(this->_AddToken(pwszToken,pFunc,pwszHelp));
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::_AddToken
//
//  Synopsis:  Add a single token to the parser.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::_AddToken(WCHAR *pwszToken,
                           HRESULT (*pFunc)(CArgs *pArgs),
                           const WCHAR *pwszHelp)
{
   HRESULT hr;

   // Args should have been checked in AddExpr().

   WCHAR *pwszNextToken = mywcstok(NULL,pwszDelimiters);

   int i, result;

   if ( FAILED(hr = _FindToken(pwszToken,&i,NULL,FULL_MATCH,&result)) )
      return(hr);

   if ( result != TOKEN_FOUND )
   {
      hr = _InsertToken(pwszToken,&i);

      if ( FAILED(hr) )
         return(hr);
   }

   if ( pwszNextToken == NULL )
   {
      if ( _rNodes[i].pFunc == NULL )
      // PREFIX: 'i' may be used uninitialized.
      // The complaint is: when above _FindToken() fails, the _InsertToken() call may
      // succeed with 'i' uninitialized.  This is impossible. In function _InsertToken(), 
      // the second _FindToken() call is after the new token is inserted and qsort(), 
      // it must succeed with a valid 'pIndex'. Therefore, 'i' must be given a value 
      // in above _InsertToken() call.
      {
         _rNodes[i].pFunc = pFunc;
         _rNodes[i].pwszHelp = pwszHelp;
         return(S_OK);
      }
      else
      {
         // Duplicate expression/function definition.

         return(E_INVALIDARG);
      }
   }
   else
   {
      if ( _rNodes[i].pChild == NULL )
      {
         _rNodes[i].pChild = new CParser;

         if ( NULL == _rNodes[i].pChild )
            return(E_OUTOFMEMORY);
      }

      return(_rNodes[i].pChild->_AddToken(pwszNextToken,pFunc,pwszHelp));
   }

   return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::Dump
//
//  Synopsis:  Dumps all tokens with the given prefix.  Prefix of "" OK.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::Dump(FILE *pFile,
                      WCHAR *pwszPrefix)
{
   if ( (NULL == pFile) || (NULL == pwszPrefix) )
      return(E_INVALIDARG);

   if ( _cNodes == 0 )
   {
      fwprintf(pFile,L"No language defined\n");
      return(S_OK);;
   }

   fprintf(pFile,"\n");
   HRESULT hr = this->_Dump(pFile,pwszPrefix);
   fprintf(pFile,"\n");

   return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::_Dump
//
//  Synopsis:
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::_Dump(FILE *pFile,
                       WCHAR *pwszPrefix)
{
   WCHAR *pwszExpr = new WCHAR [ wcslen(pwszPrefix) + TOKEN_LENGTH + 2 ];

   if ( NULL == pwszExpr )
      return(E_OUTOFMEMORY);

   for ( int i = 0; i < _cNodes; i++ )
   {
      swprintf(pwszExpr,L"%s %s",pwszPrefix,_rNodes[i].pwszToken);

      // Nodes without help are hidden
      if ( ( _rNodes[i].pFunc != NULL ) && ( _rNodes[i].pwszHelp != NULL ) )
      {
         const WCHAR *pwszHelp;

         if ( _rNodes[i].pwszHelp != NULL )
         {
            pwszHelp = _rNodes[i].pwszHelp;
         }
         else
         {
            pwszHelp = L"(no description)";
         }
         fwprintf(pFile,L"%-30s - %s\n",pwszExpr,pwszHelp);
      }

      if ( _rNodes[i].pChild != NULL )
      {
         _rNodes[i].pChild->_Dump(pFile,pwszExpr);
      }
   }

   delete pwszExpr;

   return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::_ParseToken
//
//  Synopsis:
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::_ParseToken(WCHAR *pwszToken,
                             CArgs *pArgs)
{
   HRESULT hr;

   if ( _IsPattern(pwszToken,NULL) == TRUE )
   {
      return(E_INVALIDARG);
   }

   int i, result;

   hr = _FindToken(pwszToken,&i,pArgs,PREFIX_MATCH,&result);

   if ( FAILED(hr) )
      return(hr);

   if ( result == PREFIX_NOT_UNIQUE )
   {
      return(E_INVALIDARG);
   }

   if ( result == TOKEN_NOT_FOUND )
   {
      return(E_INVALIDARG);
   }

   WCHAR *pwszNextToken = mywcstok(NULL,pwszDelimiters);

   if ( pwszNextToken == NULL )
   {
      if ( _rNodes[i].pFunc == NULL )
      {
         return(E_INVALIDARG);
      }
      else
      {
         __try
         {
            hr = (*_rNodes[i].pFunc)(pArgs);
         }
         __except(EXCEPTION_EXECUTE_HANDLER)
         {
            hr = HRESULT_FROM_NT(GetExceptionCode());
         }

         return(hr);
      }
   }
   else
   {
      if ( _rNodes[i].pChild == NULL )
      {
         return(E_INVALIDARG);
      }
      else
      {
         return(_rNodes[i].pChild->_ParseToken(pwszNextToken,pArgs));
      }
   }

   // should never get here ...

   return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::Parse
//
//  Synopsis:  Parse and execute an expression.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::Parse(WCHAR *pwszExpr,
                       TimingInfo *pInfo)
{
   HRESULT hr;

   CTimer timer;

   if ( pwszExpr == NULL )
   {
      hr = E_INVALIDARG;
   }
   else
   {
      WCHAR *pwszToken = mywcstok(pwszExpr,pwszDelimiters);

      if ( pwszToken == NULL )
      {
         // empty expression is OK - return warning

         hr = (S_OK | ERROR_SEVERITY_WARNING);
      }
      else
      {
         CArgs args;

         hr = this->_ParseToken(pwszToken,&args);
      }
   }

   if ( NULL != pInfo )
      timer.ReportElapsedTime(pInfo);

   return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::_IsPattern
//
//  Synopsis:  Determine if a string is a pattern or not.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

BOOL CParser::_IsPattern(WCHAR *pwsz,
                         int *pPatternType)
{
   if ( 0 == _wcsicmp(L"%s",pwsz) )
   {
      if ( pPatternType != NULL )
      {
         *pPatternType = PATTERN_STRING;
      }
      return(TRUE);
   }

   if ( 0 == _wcsicmp(L"%d",pwsz) )
   {
      if ( pPatternType != NULL )
      {
         *pPatternType = PATTERN_INTEGER;
      }
      return(TRUE);
   }

   if ( 0 == _wcsicmp(L"%I64d",pwsz) )
   {
      if ( pPatternType != NULL )
      {
         *pPatternType = PATTERN_LONGLONG;
      }
      return(TRUE);
   }

   return(FALSE);
}

#ifdef DEBUG
#define TOKEN_INCREMENT 1
#else
#define TOKEN_INCREMENT 10
#endif

//+-------------------------------------------------------------------
//
//  Member:    CParser::MakeSpace
//
//  Synopsis:  Grow a parse node to hold more tokens.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::MakeSpace()
{
   ASSERT(_cNodes <= _cMax);

   if ( _cNodes == _cMax )
   {
      _cMax += TOKEN_INCREMENT;

      ParseNode *tmp = new ParseNode [_cMax];

      if ( tmp == NULL )
      {
         return(E_OUTOFMEMORY);
      }

      if ( _cNodes > 0 )
      {
         memcpy(tmp,_rNodes,(_cNodes * sizeof(ParseNode)));
         delete [] _rNodes;
      }

      memset(&(tmp[_cNodes]),0,(TOKEN_INCREMENT * sizeof(ParseNode)));

      _rNodes = tmp;
   }

   return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:    CParser::Parse
//
//  Synopsis:  Parse console input and any command line arguments.
//
//  History:   01-Sep-93	DaveStr		Genesis
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CParser::Parse(int  *pargc,
                       CHAR **pargv[],
                       FILE *pFileIn,
                       FILE *pFileOut,
                       const WCHAR *pPrompt,
                       BOOL *pfQuit,
                       BOOL fTiming,
                       BOOL fQuitOnError)
{
   HRESULT hr;

   if ( (NULL == pFileIn) || (NULL == pFileOut) )
      return(E_INVALIDARG);

   // main() may be invoked with multiple arguments, each of which is considered
   // a command to be executed.  If the last agument in the sequence is "quit",
   // the program exits.  If not, the program executes all the command line
   // supplied commands and then hangs out in interactive mode.

   // Note that commands with spaces in them should be quoted.  For example:
   //
   //	foo.exe "bind x:\gc.sc" "dump gt" quit

   while ( !*pfQuit )
   {
      CHAR Expr[1000];
      WCHAR wExpr[1000];
      CHAR *p;

      if ( NULL != pPrompt )
         fprintf(pFileOut,"%ws ", pPrompt);

      if ( pargc && *pargc && pargv && *pargv && **pargv)
      {
         // next expression is in *argv

         strncpy(Expr,**pargv,1000);
         Expr[999] = '\0';
         (*pargc)--;
         (*pargv)++;

         if ( NULL != pPrompt )
            fprintf(pFileOut,"%s\n",Expr);
      }
      else
      {
         // argv[] expressions exhausted.  Start reading from pFileIn.

         if ( NULL == (p = fgets(Expr,1000,pFileIn)) )
         {
            hr = S_OK;
            int error = ferror(pFileIn);

            if ( 0 != error )
            {
               hr = HRESULT_FROM_WIN32(error);

               if ( NULL != pPrompt )
                  fprintf(pFileOut, "Error %08lx reading input\n", hr);
            }

            return(hr);
         }

         int len = strlen(Expr);

         if ( len > 0 )
         {
            //
            // find first occurance of comment escape & repl by '\0'
            //
            LPTSTR pComment = strstr(Expr, COMMENT_ESCAPE_STRING);
            if(pComment){
               // terminate to ignore comment
               *pComment = '\0';
               // recalc new len
               len = (Expr[0] == '\0') ? 0 : strlen(Expr);
            }
            else if ( Expr[len-1] == '\n' ){
            // Strip off trailing new line.
               Expr[len-1] = '\0';
            }

         }
         //
         // re-present cmd prompt on empty input
         //
         if(len == 0 || Expr[0] == '\0'){
            continue;
         }
      }

      // Expr now holds next expression to parse.

      mbstowcs(wExpr,Expr,1000);
      wExpr[999] = L'\0';

      TimingInfo info;

      hr = Parse(wExpr,&info);

      if ( FAILED(hr) && (NULL != pPrompt) )
      {
         fprintf(pFileOut,"Error %08lx parsing input - illegal syntax?\n", hr);

         if ( fQuitOnError )
            return(hr);
      }

      if ( fTiming  && (NULL != pPrompt) )
      {
         fprintf(pFileOut,"\n");

         if ( info.msUser.HighPart == 0 )
            fprintf(pFileOut,"\tuser:          %lu ms\n",info.msUser.LowPart);
         else
            fprintf(pFileOut,"\tuser:          *** out of range ***\n");

         if ( info.msKernel.HighPart == 0 )
            fprintf(pFileOut,"\tkernel:        %lu ms\n", info.msKernel.LowPart);
         else
            fprintf(pFileOut,"\tkernel:        *** out of range ***\n");

         if ( info.msTotal.HighPart == 0 )
            fprintf(pFileOut,"\tuser + kernel: %lu ms\n\n",info.msTotal.LowPart);
         else
            fprintf(pFileOut,"\tuser + kernel: *** out of range ***\n\n");
      }
   }

   return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\perfdsa\perftest.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       perftest.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <conio.h>
#include "ntdsctr.h"

TCHAR szMappedObject[] = TEXT("MICROSOFT_DSA_COUNTER_BLOCK");
//PPERF_COUNTER_BLOCK     pCounterBlock;  // data structure for counter values
unsigned long *     pCounterBlock;  // data structure for counter values


void _cdecl main()
{
    HANDLE hMappedObject;
    int c, fRun = 1;
    
    /*
     *  create named section for the performance data
     */
    hMappedObject = CreateFileMapping(
        (HANDLE) (-1),
	NULL,
	PAGE_READWRITE,
	0,
	4096,
	szMappedObject);
    if (hMappedObject == NULL) {
	/* Should put out an EventLog error message here */
	printf("DSA: Could not Create Mapped Object for Counters %x",
	    GetLastError());
	pCounterBlock = NULL;
    }
    else {
	/* Mapped object created okay
	 *
         * map the section and assign the counter block pointer
         * to this section of memory
         */
	pCounterBlock = (unsigned long *) MapViewOfFile(hMappedObject,
	    FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if (pCounterBlock == NULL) {
	    /* Failed to Map View of file */
	    printf("DSA: Failed to Map View of File %x",
		GetLastError());
	}
    }

    /*
     * Ok, now sit around in a loop reading keystrokes
     */
    do {
	c = _getch();
	printf("Incrementing ");
	switch (c) {
	case 'v':
	case 'V':
	    pCounterBlock[(ACCVIOL >> 1) - 1]++;
	    printf("access violation");
	    break;
	case 'b':
	case 'B':
	    pCounterBlock[(BROWSE >> 1) - 1]++;
	    printf("browse");
	    break;
	case 'd':
	case 'D':
	    pCounterBlock[(ABREAD >> 1) - 1]++;
	    printf("AB details");
	    break;
	case 'r':
	case 'R':
	    pCounterBlock[(DSREAD >> 1) - 1]++;
	    printf("ds_read");
	    break;
	case 'e':
	case 'E':
	    pCounterBlock[(REPL >> 1) - 1]++;
	    printf("replication");
	    break;
	case 't':
	case 'T':
	    pCounterBlock[(THREAD >> 1) - 1]++;
	    printf("thread count");
	    break;
	case 'w':
	case 'W':
	    pCounterBlock[(ABWRITE >> 1) - 1]++;
	    printf("AB write");
	    break;
	case 'm':
	case 'M':
	    pCounterBlock[(DSWRITE >> 1) - 1]++;
	    printf("ds_modify, add, or remove");
	    break;
	case 'q':
	case 'Q':
	    printf("nothing, quiting now\n");
	    fRun = 0;
	    break;
	default:
	    printf("\rWhat the heck does '%c' mean?\n", c);
	    continue;
	};
	printf("\n");
    } while (fRun);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\perfdsa\perfutil.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       perfutil.c
//
//--------------------------------------------------------------------------

/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (C) Microsoft Corporation, 1992 - 1998

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
	common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.

Created:

    Russ Blake  07/30/92

Revision History:

--*/
//
//  include files
//
#include <NTDSpch.h>
#pragma hdrstop

#include <winperf.h>
#include "mdcodes.h"	 // error message definition
#include <dsconfig.h>
#include "perfmsg.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//

ULONG                   ulInfoBufferSize = 0;

HANDLE hEventLog = NULL;      // event log handle for reporting events
                              // initialized in Open... routines
DWORD  dwLogUsers = 0;        // count of functions using event log

DWORD MESSAGE_LEVEL = 0;

WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}


BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList


#define DS_EVENT_CAT_PERFORMANCE	10   /* also in dsevent.h */
/*********************************************\
Log a Performance-category event.

Input
    midEvent	Event message identifier, as defined in mdcodes.mc
    status      error code
    szRegKey    (optional) registry key string

Returns nothing.
\*********************************************/
void LogPerfEvent( ULONG midEvent, DWORD status, PWCHAR szRegKey)
{
    WCHAR	szBuf[12];
    WORD	eventType;
    HANDLE	hEventSource;
    PWCHAR  aArgs[3];
    WORD    cArgs;
    DWORD   cch;

    aArgs[0] = _ultow( status, szBuf, 10);
    // try to format the message
    cch = FormatMessageW(
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS | 
        FORMAT_MESSAGE_ALLOCATE_BUFFER, // flags
        NULL,               // source == NULL (use system messages)
        status,             // message number
        0,                  // language id
        (PWCHAR)&aArgs[1],  // (out) message buffer
        0,                  // buffer size
        NULL                // arguments
        );
    if (cch == 0) {
        // no luck formatting message, put a dummy string in
        aArgs[1] = L"[]";
    }
    cArgs = 2;

    if (szRegKey) {
        // append regkey string if supplied
        aArgs[2] = szRegKey;
        cArgs++;
    }

    switch((midEvent >> 30) & 0xFF) {	    /* map DS event type to sys type */
    case DIR_ETYPE_SECURITY:
    	eventType = EVENTLOG_AUDIT_FAILURE;
    	break;

    case DIR_ETYPE_WARNING:
    	eventType = EVENTLOG_WARNING_TYPE;
    	break;

    case DIR_ETYPE_INFORMATIONAL:
    	eventType = EVENTLOG_INFORMATION_TYPE;
    	break;

    case DIR_ETYPE_ERROR:
    default:
    	eventType = EVENTLOG_ERROR_TYPE;
    	break;
    }
    /* open log, write, and close */
    if ((hEventSource = RegisterEventSource( NULL, "NTDS General"))) {
    	ReportEventW( hEventSource, eventType, DS_EVENT_CAT_PERFORMANCE,
                      midEvent, NULL, cArgs, 0, aArgs, NULL);
	    DeregisterEventSource( hEventSource);
    }
    if (cch != 0) {
        // message was alloced, free it now
        LocalFree(aArgs[1]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\perfdsa\perfmsg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       perfmsg.h
//
//--------------------------------------------------------------------------

/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (C) Microsoft Corporation, 1992 - 1996

Module Name:

    perfmsg.h  

Abstract:

    This file provides the macros and definitions used by the extensible
    counters for reporting events to the event logging facility

Author:

      Bob Watson (a-robw) 5 Oct 92

Revision History:


--*/
#ifndef  _PERFMSG_H_
#define  _PERFMSG_H_
//
// Report error message ID's for Counters
//

#define APP_NAME  "vgactrs"

//
// The constant below defines how many (if any) messages will be reported
// to the event logger. As the number goes up in value more and more events
// will be reported. The purpose of this is to allow lots of messages during
// development and debugging (e.g. a message level of 3) to a minimum of
// messages (e.g. operational messages with a level of 1) or no messages if
// message logging inflicts too much of a performance penalty. Right now
// this is a compile time constant, but could later become a registry entry.
//
//    Levels:  LOG_NONE = No event log messages ever
//             LOG_USER = User event log messages (e.g. errors)
//             LOG_DEBUG = Minimum Debugging 
//             LOG_VERBOSE = Maximum Debugging 
//

#define  LOG_NONE     0
#define  LOG_USER     1
#define  LOG_DEBUG    2
#define  LOG_VERBOSE  3

#define  MESSAGE_LEVEL_DEFAULT  LOG_USER

// define macros
//
// Format for event log calls without corresponding insertion strings is:
//    REPORT_xxx (message_value, message_level)
//       where:   
//          xxx is the severity to be displayed in the event log
//          message_value is the numeric ID from above
//          message_level is the "filtering" level of error reporting
//             using the error levels above.
//
// if the message has a corresponding insertion string whose symbol conforms
// to the format CONSTANT = numeric value and CONSTANT_S = string constant for
// that message, then the 
// 
//    REPORT_xxx_STRING (message_value, message_level)
//
// macro may be used.
//

//
// REPORT_SUCCESS was intended to show Success in the error log, rather it
// shows "N/A" so for now it's the same as information, though it could 
// (should) be changed  in the future
//


#define REPORT_SUCCESS(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_WARNING(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_ERROR(i,l) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, 0, NULL, (PVOID)NULL) : FALSE)

#define REPORT_INFORMATION_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_INFORMATION_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_WARNING_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_WARNING_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

#define REPORT_ERROR_DATA(i,l,d,s) (MESSAGE_LEVEL >= l ? ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE, \
   0, i, (PSID)NULL, 0, s, NULL, (PVOID)(d)) : FALSE)

// External Variables

extern HANDLE hEventLog;   // handle to event log
extern DWORD  dwLogUsers;  // counter of event log using routines
extern DWORD  MESSAGE_LEVEL; // event logging detail level

#endif //_PERFMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\inc\dclistparser.h ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    Dclistparser.h

ABSTRACT:

    This is the header for the globally useful data structures for the dclist parser.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/


// Dclistparser.h: interface for the MyContent class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _DCLISTPARSER_H
#define _DCLISTPARSER_H

/************************************************************************
*
*  State machine description for state file.
*
*
* sample:
* <DcList>
*	<Hash>ufxMMH2dRAWYRIHWXxJ8ZvNul1g=</Hash>
*	<Signature>B9frVM24g4Edlqt2fhN2hywFkZ8=</Signature>
*	<DC>
*		<Name>mydc.nttest.microsoft.com</Name>
*		<State>Initial</State>
*		<Password></Password>
*		<LastError>0</LastError>
*		<LastErrorMsg></LastErrorMsg>
*		<FatalErrorMsg></FatalErrorMsg>
*		<Retry></Retry>
*	</DC>
* </Dclist>
*
* Two states in this machine
* CurrentDcAttribute
* CurrentDcParsingStatus
*
* At the start:
* CurrentDcAttribute = DC_ATT_TYPE_NONE
* CurrentDcParsingStatus = SCRIPT_STATUS_WAITING_FOR_DCLIST
*
* At DcList start:
* CurrentDcParsingStatus = SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT
*
* At Hash start:
* CurrentDcParsingStatus = SCRIPT_STATUS_PARSING_HASH
* Action: Record hash
* At Hash end:
* CurrentDcParsingStatus = SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT
*
* At Signature start:
* CurrentDcParsingStatus = SCRIPT_STATUS_PARSING_SIGNATURE
* Action: Record Signature
* At Signature end:
* CurrentDcParsingStatus = SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT
*  
* At DC start:
* CurrentDcParsingStatus = SCRIPT_STATUS_PARSING_DCLIST_ATT
* At DC end:
* CurrentDcParsingStatus = SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT
* Action: Record DC into memory structure
*
* At [Name|State|Password|LastError|LastErrorMsg|FatalErrorMsg|Retry] start:
* CurrentDcAttribute = DC_ATT_TYPE_[Name|State|Password|LastError|LastErrorMsg|FatalErrorMsg|Retry]
* Action: Record [Name|State|Password|LastError|LastErrorMsg|FatalErrorMsg|Retry]
* At [Name|State|Password|LastError|LastErrorMsg|FatalErrorMsg|Retry] end:
* CurrentDcAttribute = DC_ATT_TYPE_NONE
*
*************************************************************************/

//#include "rendom.h"
#include "SAXContentHandlerImpl.h"

#define DCSCRIPT_DCLIST           L"DcList"
#define DCSCRIPT_HASH             L"Hash"
#define DCSCRIPT_SIGNATURE        L"Signature"
#define DCSCRIPT_DC               L"DC"
#define DCSCRIPT_DC_NAME          L"Name"
#define DCSCRIPT_DC_STATE         L"State"
#define DCSCRIPT_DC_PASSWORD      L"Password"
#define DCSCRIPT_DC_LASTERROR     L"LastError"
#define DCSCRIPT_DC_LASTERRORMSG  L"LastErrorMsg"
#define DCSCRIPT_DC_FATALERRORMSG L"FatalErrorMsg"
#define DCSCRIPT_DC_RETRY         L"Retry"

//
// NTDSContent
//
// Implements the SAX Handler interface
// 
class CXMLDcListContentHander : public SAXContentHandlerImpl  
{
public:
    enum DcAttType {

        DC_ATT_TYPE_NONE = 0,
        DC_ATT_TYPE_NAME,
        DC_ATT_TYPE_STATE,
        DC_ATT_TYPE_PASSWORD,
        DC_ATT_TYPE_LASTERROR,
        DC_ATT_TYPE_LASTERRORMSG,
        DC_ATT_TYPE_FATALERRORMSG,
        DC_ATT_TYPE_RETRY
                                 
    };
    
    // the order of the enumeration is important
    enum DcParsingStatus {

        SCRIPT_STATUS_WAITING_FOR_DCLIST = 0,
        SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT,
        SCRIPT_STATUS_PARSING_DCLIST_ATT,
        SCRIPT_STATUS_PARSING_HASH,
        SCRIPT_STATUS_PARSING_SIGNATURE
    };

    CXMLDcListContentHander(CEnterprise *p_Enterprise);
    virtual ~CXMLDcListContentHander();
    
    virtual HRESULT STDMETHODCALLTYPE startElement( 
        /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
        /* [in] */ int cchNamespaceUri,
        /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
        /* [in] */ int cchLocalName,
        /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
        /* [in] */ int cchRawName,
        /* [in] */ ISAXAttributes __RPC_FAR *pAttributes);
    
    virtual HRESULT STDMETHODCALLTYPE endElement( 
        /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
        /* [in] */ int cchNamespaceUri,
        /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
        /* [in] */ int cchLocalName,
        /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
        /* [in] */ int cchRawName);

    virtual HRESULT STDMETHODCALLTYPE startDocument();

    virtual HRESULT STDMETHODCALLTYPE characters( 
        /* [in] */ const wchar_t __RPC_FAR *pwchChars,
        /* [in] */ int cchChars);

private:

    inline
    DcParsingStatus 
    CurrentDcParsingStatus() {return m_eDcParsingStatus;}

    inline
    DcAttType
    CurrentDcAttType()       {return m_eDcAttType;}

    inline
    VOID
    SetDcParsingStatus(DcParsingStatus p_status) {m_eDcParsingStatus = p_status;}

    inline
    VOID
    SetCurrentDcAttType(DcAttType p_AttType) {m_eDcAttType = p_AttType;}

    CRenDomErr                   m_Error;

    DcParsingStatus              m_eDcParsingStatus; 
    DcAttType                    m_eDcAttType;

    CDcList                      *m_DcList;

    CDc                          *m_dc;
    WCHAR                        *m_Name;
    DWORD                         m_State;
    WCHAR                        *m_Password;
    DWORD                         m_LastError;
    WCHAR                        *m_LastErrorMsg;
    WCHAR                        *m_FatalErrorMsg;
    BOOL                         m_Retry;
    
};

#endif // _DCLISTPARSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\redirect\redirect.h ===
////////////////////////////////////////////////////////////////
//
// redirect.h
//
// User / Computer Object Redirection exe
//
//
////////////////////////////////////////////////////////////////

#if !defined(__REDIRECT_H__)
#define __REDIRECT_H__                                                   

#define    IDS_USAGE_FIRST                      101

#define    IDS_USAGE1                           101
#define    IDS_USAGE2                           102
#define    IDS_USAGE3                           103
#define    IDS_USAGE4                           104
#define    IDS_USAGE5                           105
#define    IDS_USAGE6                           106

#define    IDS_USAGE_LAST                       106

#define    IDS_SUCCESS_REDIRECT                 201
#define    IDS_FAIL_REDIRECT                    202

#define    IDS_FAIL_GENERIC_ERROR               203


#define    IDS_FAIL_PDC                         204
#define    IDS_FAIL_MEMORY                      205
#define    IDS_FAIL_LDAP_CONNECT                206
#define    IDS_FAIL_DATA_INTEGRITY              207
#define    IDS_FAIL_LDAP_BIND                   208
#define    IDS_FAIL_NAME_CONTEXT                209
#define    IDS_FAIL_ATTRIBUTE_READ              210
#define    IDS_FAIL_ATTRIBUTE_MODIFY            211
#define    IDS_FAIL_ATTRIBUTE_PARSE             212
                                                   
#endif // !defined(__REDIRECT_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\perfdsa\perfutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       perfutil.h
//
//--------------------------------------------------------------------------

/*
Copyright (C) Microsoft Corporation, 1992 - 1998

Module Name:
    perfutil.h

Abstract:
    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:
    Russ Blake  7/30/92

Revision History:
    11/1/95	Dave Van Horn	Trim out unused.

--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

/*
 * The definition of the routines in perfutil.c,
 */

DWORD GetQueryType (IN LPWSTR);
BOOL IsNumberInUnicodeList (DWORD, LPWSTR);
void LogPerfEvent( ULONG midEvent, DWORD status, PWCHAR szRegKey);

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\redirect\main.cxx ===
//////////////////////////////////////////////////////////////////////////////
//
// main.cxx
//
// User / Computer object creation container redirection
//
// Created:  01-10-2002 MattRim -- Initial Creation for Reskit
// Modified: 01-21-2003 AdamEd  -- Update for moving from Reskit to core OS
//
// Synopsis:
//      Contains implementation of the tool to set the
//      path for the container in which new user or computer
//      objects will be created
//
// Note:
//      There are two separate tools, one for computers, one for
//      users.  They are both built using this source code, but
//      at compile time the following preprocessor definition is
//      used to control whether this source code generates the user
//      or computer tool:
//
//      BUILD_USER_TOOL
//
// Please see comments later in this source for implementation details
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <dsgetdc.h>
#include <lm.h>
#include <winldap.h>
#include <stdlib.h>
#include <stdio.h>

// Needed for FormatMessage support

#include <locale.h>
#include <winnlsp.h>

// Needed for GetADsOpenObjectFlags support
#include <ole2.h>
#include <iads.h>
#include <adshlp.h>
#include <adsopenflags.h>
#include "redirect.h"
#define SECURITY_WIN32
#include <strsafe.h>

#define BAIL()     goto exit;

#define MIN_CONTAINER_VALUE_LEN 37
#define CONTAINER_VALUE_PREFIX_LEN  5
#define CONTAINER_GUID_LEN 32
#define GETMESSAGEFROMRESOURCE_MAX_BUFFER 1024
#define PRINTERROR_MAX_HEX_ERRORCODE_CHARS 10

enum ErrorType
{
    PrintError_Ldap = 1,
    PrintError_Win32
};


// Whether this source code generates the user or computer tool
// is controlled by this preprocessor definition

#ifdef BUILD_USER_TOOL
const WCHAR g_GuidString[] = L"a9d1ca15768811d1aded00c04fd8d5cd";
#else
const WCHAR g_GuidString[] = L"aa312825768811d1aded00c04fd8d5cd";
#endif

// Prototypes
void PrintUsage();

WCHAR* GetMessageFromResource( DWORD dwMessageId );
void FreeMessage( WCHAR* wszMessage );
void PrintMessage( DWORD dwMessageId );
void PrintError( DWORD dwMessageId, ErrorType dwErrorType, DWORD dwError );

DWORD LocateDomainObject(LDAP *ld, PWCHAR *ppszDomainObjDN);
DWORD AdjustContainer(LDAP *ld,
                      PWCHAR pszDomainObjDN,
                      PWCHAR pszNewDN);
DWORD GetAttrValues(LDAP *ld,
                    PWCHAR pszDN,
                    PWCHAR pszAttr,
                    PWCHAR **pppszValues);


///////////////////////////////////////////////////////
//
// wmain()
//
// Synopsis:
//
//      Unicode entry point for the tool
//
// Implementation notes:
//
//      This tool is very simple -- in general, all it does is modify a single attribute in the domain
//      that specifies where new user or computer objects should be created.  It operates as follows:
//
//      1. The tool binds to the domain root -- i.e. for the domain with dns name d2.d1.company.com, the tool
//         binds to DC=d2,DC=d1,DC=company,DC=com
//      2. The tool retrieves the value "wellKnownObjects" from the domain object above.  This is a
//         multi-valued attribute.
//      3. The tool searches this attribute for a string value that contains the dn of the guid of the user
//         or computer container depending on whether or not this is the user or computer version
//         of the tool -- the guid of the container is specified in g_GuidString and the value is identified
//         by parsing this string searching for the guid (see AdjustContainer comments for an idea of what the
//         value looks like).
//      4. Once identified, we build a new version of this value that reflects the new path chosen by the user
//         on the command line of this tool
//      5. The wellKnownObjects attribute is modified with the new value above
//
//  General Assumptions and Limitations:
//    
//      1. This code is not localized (localization is not a requirement for all command line tools).  All text in the tool
//         is currently in US English.  Error code text will be displayed according to the user's language.
//      2. LDAP traffic is signed / encypted according to the admin tool preferences (as exposed through GetADsOpenObjectFlags)
//         of the machine on which the tool is executing.
//      3. We always ask for a DNS name for the DC (using DsGetDCName) we talk to avoid spoofing attacks.
//      4. The tool displays error text for ldap errors and Win32 errors.
//

int __cdecl wmain(int argc, WCHAR *argv[])
{
    DWORD err;
    BOOL fSuccess = FALSE;
    PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;
    PWCHAR pszDCName = NULL;

    LDAP *ld = NULL;
    struct l_timeval timeout;

    PWCHAR pszDomainObjDN = NULL;

    WCHAR achCodePage[13] = L".OCP";

    UINT  CodePage = GetConsoleOutputCP();

    // Set locale to the default
    if ( 0 != CodePage )
    {
       _ultow( CodePage, achCodePage + 1, 10 );
    }

    _wsetlocale(LC_ALL, achCodePage);
    SetThreadUILanguage(0);

    // Print usage info, if requested
    if ((argc != 2) ||
        (argc == 2) && (_wcsicmp(argv[1], L"/?") == 0)){

        PrintUsage();
        return EXIT_SUCCESS;
    }


    // Locate the PDC on which to make the modification
    err = DsGetDcName(NULL,         // current computer
                      NULL,         // current domain
                      NULL,
                      NULL,
                      (DS_DIRECTORY_SERVICE_REQUIRED |
                       DS_RETURN_DNS_NAME |
                       DS_PDC_REQUIRED),
                      &pDCInfo);

    if (err != NO_ERROR) {
        PrintError( IDS_FAIL_PDC, PrintError_Win32, err);
        BAIL();
    }

    // Extract the DC name, stripping off the terminating '.' if present
    DWORD cchDCName = wcslen(pDCInfo->DomainControllerName)+1;
    pszDCName = new WCHAR[cchDCName];
    if (!pszDCName) {
        PrintError,(L"Error, memory allocation error", PrintError_Win32, ERROR_OUTOFMEMORY);
        BAIL();
    }

    HRESULT hr = StringCchCopy(pszDCName, cchDCName, pDCInfo->DomainControllerName+2);  // +2 to skip the "\\" prefix
    
    ASSERT(SUCCEEDED(hr));

    if (pszDCName[wcslen(pszDCName)-1] == L'.') {
        pszDCName[wcslen(pszDCName)-1] = L'\0';
    }

    // Open a connection to the PDC and authenticate using default credentials
    timeout.tv_sec = 30;
    timeout.tv_usec = 0;


    ld = ldap_init(pszDCName, 389);
    if (!ld) {
        PrintError( IDS_FAIL_LDAP_CONNECT, PrintError_Win32, ERROR_OUTOFMEMORY);
        BAIL();
    }

    // Check to see if signing and sealing are enabled    
    DWORD dwDsFlags = GetADsOpenObjectFlags();

    BOOL bUseSigning = dwDsFlags & ADS_USE_SIGNING;
    BOOL bUseSealing = dwDsFlags & ADS_USE_SEALING;    
    
    // Enable signing and sealing if specified
    VOID* pData = (VOID *) LDAP_OPT_ON;    

    // First enable signing
    if ( bUseSigning )
    {
        err = ldap_set_option(ld, LDAP_OPT_SIGN, &pData);
        
        if (err != LDAP_SUCCESS) {
            PrintError(IDS_FAIL_DATA_INTEGRITY, PrintError_Ldap, err);
            BAIL();
        }
    }

    // Now enable sealing

    if ( bUseSealing )
    {
        err = ldap_set_option(ld, LDAP_OPT_ENCRYPT, &pData);
        
        if (err != LDAP_SUCCESS) {
            PrintError(IDS_FAIL_DATA_INTEGRITY, PrintError_Ldap, err);
            BAIL();
        }
    }

    err = ldap_connect(ld, &timeout);
    if (err != LDAP_SUCCESS) {
        PrintError(IDS_FAIL_LDAP_CONNECT, PrintError_Ldap, err);
        BAIL();
    }

    err = ldap_bind_s(ld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    if (err != LDAP_SUCCESS) {
        PrintError(IDS_FAIL_LDAP_BIND, PrintError_Ldap, err);      
        BAIL();
    }

    err = LocateDomainObject(ld, &pszDomainObjDN);
    if (err != NO_ERROR) {
        // any error would have been displayed by LocateDomainObject itself
        BAIL();
    }       

    err = AdjustContainer(ld, pszDomainObjDN, argv[1]);
    if (err != NO_ERROR) {
        // any error would have been displayed by AdjustContainer itself
        BAIL();
    }

    fSuccess = TRUE;

exit:

    if (ld) {
        ldap_unbind_s(ld);
    }

    if (pDCInfo) {
        NetApiBufferFree(pDCInfo);
    }

    delete [] pszDomainObjDN;
    delete [] pszDCName;

    if (fSuccess) {
        PrintMessage(IDS_SUCCESS_REDIRECT);
    }
    else {
        PrintMessage(IDS_FAIL_REDIRECT);
    }

    return EXIT_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////////
//
// PrintUsage
//
// Synopsis:
//
//     Displays command line usage for this tool
//
void PrintUsage()
{
    for ( int iMessage = IDS_USAGE_FIRST; iMessage < IDS_USAGE_LAST; iMessage++ )
    {
        PrintMessage( iMessage );
    }
}

//////////////////////////////////////////////////////
//
// LocateDomainObject()
//
// Synopsis:
//
//      Binds to the root object of this domain
//

DWORD LocateDomainObject(LDAP *ld,
                         PWCHAR *ppszDomainObjDN)
{
    DWORD err = LDAP_SUCCESS;
    PWCHAR *ppszValues = NULL;

    err = GetAttrValues(ld,
                        L"",    // rootDSE
                        L"defaultNamingContext",
                        &ppszValues);

    if (err != NO_ERROR) {
        PrintError(IDS_FAIL_NAME_CONTEXT, PrintError_Ldap, err);
        err = LdapMapErrorToWin32(err);
    }

    // Save off the default naming context
    DWORD cchDomainObjDN = wcslen(ppszValues[0])+1;
    *ppszDomainObjDN = new WCHAR[cchDomainObjDN];
    if (!*ppszDomainObjDN) {
        PrintError(IDS_FAIL_ATTRIBUTE_READ, PrintError_Win32, ERROR_OUTOFMEMORY);
        err = ERROR_NOT_ENOUGH_MEMORY;
        BAIL();
    }

    HRESULT hr = StringCchCopy(*ppszDomainObjDN, cchDomainObjDN, ppszValues[0]);

    ASSERT(SUCCEEDED(hr));

exit:

    if (ppszValues) {
        ldap_value_free(ppszValues);
    }

    return err;
}

//////////////////////////////////////////////////////////////////////////////////////////////
//
// AdjustContainer()
//
// Synopsis:
// 
//      Modifies the multi-valued wellKnownObjects attribute of the specified domain DN
//      according to reflect the specified destination for newly created user and computer objects.
//

DWORD AdjustContainer(LDAP *ld,
                      PWCHAR pszDomainObjDN,
                      PWCHAR pszNewDN)
{

    //
    // Get the old value
    //
    DWORD err = LDAP_SUCCESS;
    PWCHAR *ppszValues = NULL;
    PWCHAR pszValue = NULL;
    PWCHAR pszNewValue = NULL;
    int i = 0;

    LDAPModW delMod;
    PWCHAR delModVals[2];
    LDAPModW addMod;
    PWCHAR addModVals[2];
    LDAPModW *modList[3] = {&delMod, &addMod, NULL};

    err = GetAttrValues(ld,
                        pszDomainObjDN,
                        L"wellKnownObjects",
                        &ppszValues);

    if (err != NO_ERROR) {
        PrintError(IDS_FAIL_ATTRIBUTE_READ, PrintError_Ldap, err);
        err = LdapMapErrorToWin32(err);
        BAIL();
    }

    //
    // Find the value corresponding to the GUID of interest
    //
    while (ppszValues[i] != NULL) {

        pszValue = ppszValues[i];

        if (wcslen(pszValue) >= MIN_CONTAINER_VALUE_LEN) {
        
            if (_wcsnicmp(pszValue+CONTAINER_VALUE_PREFIX_LEN, // Skip over the prefix, to the GUID portion
                          g_GuidString,
                          CONTAINER_GUID_LEN) == 0) {

                // found it
                break;
            }

        }

        pszValue = NULL;
        i++;
    }

    if (pszValue == NULL) {
        PrintError(IDS_FAIL_ATTRIBUTE_PARSE, PrintError_Ldap, LDAP_NO_SUCH_OBJECT);
        err = LdapMapErrorToWin32(LDAP_NO_SUCH_OBJECT);
        BAIL();
    }

    //
    // Build the new value
    //
    DWORD cchNewValue =     CONTAINER_VALUE_PREFIX_LEN+     // "B:32:"
                            CONTAINER_GUID_LEN+             // "....."
                            1 +                             // ":"
                            wcslen(pszNewDN) +
                            1;                             // NULL terminator
    
    pszNewValue = new WCHAR[cchNewValue];

    if (!pszNewValue) {
        PrintError(IDS_FAIL_ATTRIBUTE_MODIFY, PrintError_Win32, ERROR_OUTOFMEMORY);
        err = ERROR_OUTOFMEMORY;
        BAIL();
    }

    wcsncpy(pszNewValue, pszValue, CONTAINER_VALUE_PREFIX_LEN+CONTAINER_GUID_LEN+1);
    pszNewValue[CONTAINER_VALUE_PREFIX_LEN+CONTAINER_GUID_LEN+1] = L'\0';   // not done by wcsncpu
    
    HRESULT hr = StringCchCat(pszNewValue, cchNewValue, pszNewDN);
    
    ASSERT(SUCCEEDED(hr));

    //
    // Build a modification structure
    //
    delMod.mod_op = LDAP_MOD_DELETE;
    delMod.mod_type = L"wellKnownObjects";
    delModVals[0] = pszValue;
    delModVals[1] = NULL;
    delMod.mod_vals.modv_strvals = delModVals;

    addMod.mod_op = LDAP_MOD_ADD;
    addMod.mod_type = L"wellKnownObjects";
    addModVals[0] = pszNewValue;
    addModVals[1] = NULL;
    addMod.mod_vals.modv_strvals = addModVals;
    
    //
    // Do the modify
    //
    err = ldap_modify_ext_s(ld,
                            pszDomainObjDN,
                            modList,
                            NULL,
                            NULL);
    if (err != LDAP_SUCCESS) {
        PrintError(IDS_FAIL_ATTRIBUTE_MODIFY, PrintError_Ldap, err);
        err = LdapMapErrorToWin32(err);        
        BAIL();
    }

exit:

    if (ppszValues) {
        ldap_value_free(ppszValues);
    }

    delete [] pszNewValue;

    return err;
}

///////////////////////////////////////////////////////////////////////
//
// GetAttrValues()
//
// Synopsis:
//
//      Retrieves the specified attributes from the specified object.
//

DWORD GetAttrValues(LDAP *ld,
                    PWCHAR pszDN,
                    PWCHAR pszAttr,
                    PWCHAR **pppszValues)
{
    DWORD err = LDAP_SUCCESS;
    PLDAPMessage results = NULL;
    PLDAPMessage entry = NULL;
    struct l_timeval timeout;
    PWCHAR attrs[] = {pszAttr, NULL};
    PWCHAR *ppszValues = NULL;

    timeout.tv_sec = 30;
    timeout.tv_usec = 0;

    // Find the defaultNamingContext
    err = ldap_search_ext_s(ld,
                            pszDN,
                            LDAP_SCOPE_BASE,
                            L"(objectclass=*)",
                            attrs,
                            FALSE,
                            NULL,
                            NULL,
                            &timeout,
                            0,
                            &results);

    if (err != LDAP_SUCCESS) {
        BAIL();
    }

    entry = ldap_first_entry(ld, results);
    if (entry == NULL) {
        err = LDAP_NO_SUCH_OBJECT;
        BAIL();
    }

    ppszValues = ldap_get_values(ld, entry, pszAttr);
    if ((!ppszValues) || (ppszValues[0] == NULL)) {
        err = LDAP_NO_SUCH_ATTRIBUTE;
        BAIL();
    }

    *pppszValues = ppszValues;

exit:

    if (results) {
        ldap_msgfree(results);
    }
    
    return err;
}

///////////////////////////////////////////////////////////////////////////////
//
// GetMessageFromResource()
//
// Synopsis:
//  
//      Allocates a string that contains the message corresponding to the 
//      specified resource id from the current module
//
// Note: The caller must call FreeMessage to free the message allocated by this
//      function
//
WCHAR* GetMessageFromResource( DWORD dwMessageId )
{
    WCHAR*    wszMessage = NULL;
    BOOL      bStringLoaded = FALSE;
    HINSTANCE hInst;

    hInst = GetModuleHandle( NULL );

    if ( NULL != hInst )
    {    
        wszMessage = new WCHAR [ GETMESSAGEFROMRESOURCE_MAX_BUFFER ];

        if ( NULL != wszMessage )
        {
            int cchLoadedString;

            cchLoadedString = LoadString(
                hInst,
                dwMessageId,
                wszMessage,
                GETMESSAGEFROMRESOURCE_MAX_BUFFER);

            bStringLoaded = 0 != cchLoadedString;
        }
    }

    // NTRAID#NTBUG9-770750-2003/01/30-ronmart-Help is broken on Redirusr and Redircmp
    // Comparison was being made against the wrong variable
    if ( !bStringLoaded && (NULL != wszMessage))
    {
        delete [] wszMessage;

        wszMessage = NULL;
    }

    return wszMessage;
}

///////////////////////////////////////////////////////////////////////////////
//
// FreeMessage()
//
// Synopsis:
//  
//      Frees a message allocated by GetMessageFromResource
//
void FreeMessage( WCHAR* wszMessage )
{
    delete [] wszMessage;
}

///////////////////////////////////////////////////////////////////////////////
//
// PrintMessage()
//
// Synopsis:
//  
//      Prints the message corresponding to the specified message id to the console
//
void PrintMessage( DWORD dwMessageId )
{
    WCHAR* wszMessageBuffer ;

    wszMessageBuffer = GetMessageFromResource( dwMessageId );

    if ( wszMessageBuffer )
    {
        wprintf( wszMessageBuffer );

        FreeMessage( wszMessageBuffer );
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// PrintError()
//
// Synopsis:
//  
//      Displays the error text specified by the caller, as well as the system's
//      error text for the error code specified by the caller.  The supported
//      error codes are ldap and Win32 error codes.  If the error type is
//      unknown or no system error text for the error code can be found, a
//      generic error listing the error code in hexadecimal notation is displayed.
//
//      Note that system text for the error codes is always localized.
//
void PrintError( DWORD dwMessageId, ErrorType dwErrorType, DWORD dwError )
{    
    BOOL bMapErrorToText = FALSE;

    // Display the context specified error text for the user
    PrintMessage( dwMessageId );
    wprintf( L"\n" );

    // Display error text if possible for the user rather than a status code

    if ( dwErrorType == PrintError_Win32 )
    {
        BOOL bResult;
        ULONG dwSize = 0;
        WCHAR *lpBuffer;

        bResult = FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER, 
            NULL, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), (PWSTR ) &lpBuffer, dwSize, NULL);
        
        if ( 0 != bResult )
        {        
            if ( lpBuffer != NULL )
            {
                wprintf(L"%s\n", lpBuffer);
                LocalFree(lpBuffer);
                
                bMapErrorToText = TRUE;
            }                
        }
    }
    else if ( dwErrorType == PrintError_Ldap )
    {
        WCHAR* wszErrorString = ldap_err2string( dwError );

        if ( wszErrorString )
        {
            wprintf(L"%s\n", wszErrorString);

            bMapErrorToText = TRUE;
        }        
    }    

    if ( ! bMapErrorToText )
    {
        // For unknown error types, just display the error code in a generic message

        WCHAR* wszMessageFormat = GetMessageFromResource( IDS_FAIL_GENERIC_ERROR );

        if ( wszMessageFormat )
        {
            // This message contains a %x so that it can display the error code -- we need to allocate space for it        
            
            DWORD cchMessageWithErrorCode = wcslen( wszMessageFormat ) +   // The message itself
                    PRINTERROR_MAX_HEX_ERRORCODE_CHARS +                   // The maximum size of a hex dword error code
                    1;                                                     // The null terminator

            WCHAR* wszMessageWithErrorCode = new WCHAR [ cchMessageWithErrorCode ];
        
            if ( wszMessageWithErrorCode)
            {
                HRESULT hr = StringCchPrintf( 
                    wszMessageWithErrorCode,
                    cchMessageWithErrorCode,
                    wszMessageFormat,
                    dwError );
                    
                ASSERT(SUCCEEDED(hr));

                wprintf( wszMessageWithErrorCode );

                delete [] wszMessageWithErrorCode;
            }

            FreeMessage( wszMessageFormat );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\inc\filter.h ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    filter.h

ABSTRACT:

    This is the header for the globally useful ldap filters.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/


// filter.h: Filter that are passed to ldap searchs.
//
//////////////////////////////////////////////////////////////////////

#ifndef _FILTER_H
#define _FILTER_H

#define LDAP_FILTER_DEFAULT         L"objectClass=*"
#define LDAP_FILTER_TRUSTEDDOMAIN   L"objectCategory=trustedDomain"
#define LDAP_FILTER_NTDSA           L"objectCategory=nTDSDSA"
#define LDAP_FILTER_EXCHANGE        L"objectCategory=ms-Exch-Exchange-Server"
#define LDAP_FILTER_SAMTRUSTACCOUNT GetLdapSamFilter(SAM_TRUST_ACCOUNT)

#endif  //_FILTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\inc\dnslib.h ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    dnslib.h

Abstract:

    Domain Name System (DNS) Library

    DNS Library Routines -- Main Header File

Author:

    Jim Gilroy (jamesg)     December 7, 1996

Revision History:

--*/


#ifndef _DNSLIB_INCLUDED_
#define _DNSLIB_INCLUDED_

#include <windns.h>
#include <dnsapi.h>
#include <rpc.h>

#define BACKCOMPAT  1


#ifdef __cplusplus
extern "C"
{
#endif  // __cplusplus


//
//  Alignment and rounding macros
//

#define WORD_ALIGN(ptr)     ((PVOID) ((UINT_PTR)((PBYTE)ptr + 1) & ~(UINT_PTR)1))

#define DWORD_ALIGN(ptr)    ((PVOID) ((UINT_PTR)((PBYTE)ptr + 3) & ~(UINT_PTR)3))

#define QWORD_ALIGN(ptr)    ((PVOID) ((UINT_PTR)((PBYTE)ptr + 7) & ~(UINT_PTR)7))

#ifdef WIN64
#define POINTER_ALIGN(ptr)  QWORD_ALIGN(ptr)
#else
#define POINTER_ALIGN(ptr)  DWORD_ALIGN(ptr)
#endif

#define WORD_ALIGN_DWORD(dw)        (((WORD)dw + 1) & ~(DWORD)1)
#define DWORD_ALIGN_DWORD(dw)       (((DWORD)dw + 3) & ~(DWORD)3)
#define QWORD_ALIGN_DWORD(dw)       (((QWORD)dw + 7) & ~(DWORD)7)

#ifdef WIN64
#define POINTER_ALIGN_DWORD(dw)     QWORD_ALIGN_DWORD(dw)
#else
#define POINTER_ALIGN_DWORD(dw)     DWORD_ALIGN_DWORD(dw)
#endif


//
//  Inline byte flipping
//

__inline
WORD
inline_word_flip(
    IN      WORD            Word
    )
{
    return ( (Word << 8) | (Word >> 8) );
}

#define inline_htons(w)     inline_word_flip(w)
#define inline_ntohs(w)     inline_word_flip(w)

__inline
DWORD
inline_dword_flip(
    IN      DWORD           Dword
    )
{
    return ( ((Dword << 8) & 0x00ff0000) |
             (Dword << 24)               |
             ((Dword >> 8) & 0x0000ff00) |
             (Dword >> 24) );
}

#define inline_htonl(d)     inline_dword_flip(d)
#define inline_ntohl(d)     inline_dword_flip(d)



//
//  Useful type defs
//

#define PGUID       LPGUID
#define PADDRINFO   LPADDRINFO


//
//  QWORD 
//

#ifndef QWORD
typedef DWORD64     QWORD, *PQWORD;
#endif


//
//  Until converted must define PDNS_NAME
//
//  Note:  PDNS_NAME is NOT really a LPTSTR.
//      Rather it's the definition of a field that can be
//      either an PWSTR or PSTR depending on some other field.
//

#ifdef UNICODE
typedef PWSTR   PDNS_NAME;
#else
typedef PSTR    PDNS_NAME;
#endif




//
//  Flat buffer definition
//
//  Note:  using INT for sizes so that we can push BytesLeft negative
//  and use routines to determine REQUIRED space, even when no
//  buffer or buf too small.
//

typedef struct _FLATBUF
{
    PBYTE   pBuffer;
    PBYTE   pEnd;
    PBYTE   pCurrent;
    INT     Size;
    INT     BytesLeft;
}
FLATBUF, *PFLATBUF;


//
//  Flat buffer routines -- argument versions
//
//  These versions have the actual code so that we can
//  easily use this stuff with existing code that has
//  independent pCurrent and BytesLeft variables.
//
//  FLATBUF structure versions just call these inline.
//

PBYTE
FlatBuf_Arg_Reserve(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size,
    IN      DWORD           Alignment
    );

PBYTE
FlatBuf_Arg_WriteString(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PSTR            pString,
    IN      BOOL            fUnicode
    );

PBYTE
FlatBuf_Arg_CopyMemory(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PVOID           pMemory,
    IN      DWORD           Length,
    IN      DWORD           Alignment
    );

__inline
PBYTE
FlatBuf_Arg_ReserveAlignPointer(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(PVOID) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignQword(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(QWORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignDword(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(DWORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignWord(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                sizeof(WORD) );
}

__inline
PBYTE
FlatBuf_Arg_ReserveAlignByte(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                ppCurrent,
                pBytesLeft,
                Size,
                0 );
}

PBYTE
__inline
FlatBuf_Arg_WriteString_A(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PSTR            pString
    )
{
    return  FlatBuf_Arg_WriteString(
                ppCurrent,
                pBytesLeft,
                pString,
                FALSE       // not unicode
                );
}

PBYTE
__inline
FlatBuf_Arg_WriteString_W(
    IN OUT  PBYTE *         ppCurrent,
    IN OUT  PINT            pBytesLeft,
    IN      PWSTR           pString
    )
{
    return  FlatBuf_Arg_WriteString(
                ppCurrent,
                pBytesLeft,
                (PSTR) pString,
                TRUE        // unicode
                );
}

//
//  Flat buffer routines -- structure versions
//

VOID
FlatBuf_Init(
    IN OUT  PFLATBUF        pFlatBuf,
    IN      PBYTE           pBuffer,
    IN      INT             Size
    );


__inline
PBYTE
FlatBuf_Reserve(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size,
    IN      DWORD           Alignment
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                Alignment );
}

__inline
PBYTE
FlatBuf_ReserveAlignPointer(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(PVOID) );
}

__inline
PBYTE
FlatBuf_ReserveAlignQword(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(QWORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignDword(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(DWORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignWord(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                sizeof(WORD) );
}

__inline
PBYTE
FlatBuf_ReserveAlignByte(
    IN OUT  PFLATBUF        pBuf,
    IN      DWORD           Size
    )
{
    return FlatBuf_Arg_Reserve(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                Size,
                0 );
}

PBYTE
__inline
FlatBuf_WriteString(
    IN OUT  PFLATBUF        pBuf,
    IN      PSTR            pString,
    IN      BOOL            fUnicode
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pString,
                fUnicode
                );
}

PBYTE
__inline
FlatBuf_WriteString_A(
    IN OUT  PFLATBUF        pBuf,
    IN      PSTR            pString
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pString,
                FALSE       // not unicode
                );
}

PBYTE
__inline
FlatBuf_WriteString_W(
    IN OUT  PFLATBUF        pBuf,
    IN      PWSTR           pString
    )
{
    return  FlatBuf_Arg_WriteString(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                (PSTR) pString,
                TRUE        // unicode
                );
}

PBYTE
__inline
FlatBuf_CopyMemory(
    IN OUT  PFLATBUF        pBuf,
    IN      PVOID           pMemory,
    IN      DWORD           Length,
    IN      DWORD           Alignment
    )
{
    return FlatBuf_Arg_CopyMemory(
                & pBuf->pCurrent,
                & pBuf->BytesLeft,
                pMemory,
                Length,
                Alignment );
}

//
//  Multicast off until new features ready
//

#define MULTICAST_ENABLED 0


//
//  Multicast DNS definitions
//

#define MULTICAST_DNS_ADDR   0xEFFFFFFD // 239.255.255.253
#define MULTICAST_DNS_RADDR  0xFDFFFFEF // Same as above, in host ordering

#define MULTICAST_DNS_LOCAL_DOMAIN      ("local.")
#define MULTICAST_DNS_LOCAL_DOMAIN_W    (L"local.")
#define MULTICAST_DNS_SRV_RECORD_NAME   ("_dns._udp.local.")
#define MULTICAST_DNS_SRV_RECORD_NAME_W (L"_dns._udp.local.")
#define MULTICAST_DNS_A_RECORD_NAME     ("_dns.local.")
#define MULTICAST_DNS_A_RECORD_NAME_W   (L"_dns.local.")


//
//  Read unaligned value from given position in packet
//

#define READ_PACKET_HOST_DWORD(pch)  \
            FlipUnalignedDword( pch )

#define READ_PACKET_NET_DWORD(pch)  \
            ( *(UNALIGNED DWORD *)(pch) )

#define READ_PACKET_HOST_WORD(pch)  \
            FlipUnalignedWord( pch )

#define READ_PACKET_NET_WORD(pch)  \
            ( *(UNALIGNED WORD *)(pch) )


//
//  Private DNS_RECORD Flag field structure definition and macros
//
//  Note:  don't add to this list -- private stuff in dnslibp.h
//

typedef struct _DnsRecordLibFlags
{
    DWORD   Section     : 2;
    DWORD   Delete      : 1;
    DWORD   CharSet     : 2;

    DWORD   Unused      : 6;
    DWORD   Matched     : 1;
    DWORD   FreeData    : 1;
    DWORD   FreeOwner   : 1;

    DWORD   Reserved    : 18;
}
DNSRECLIB_FLAGS, *PDNSRECLIB_FLAGS;


#define PFLAGS( pRecord )           ((PDNSRECLIB_FLAGS)&pRecord->Flags.DW)
#define FLAG_Section( pRecord )     (PFLAGS( pRecord )->Section)
#define FLAG_Delete( pRecord )      (PFLAGS( pRecord )->Delete)
#define FLAG_CharSet( pRecord )     (PFLAGS( pRecord )->CharSet)
#define FLAG_FreeData( pRecord )    (PFLAGS( pRecord )->FreeData)
#define FLAG_FreeOwner( pRecord )   (PFLAGS( pRecord )->FreeOwner)
#define FLAG_Matched( pRecord )     (PFLAGS( pRecord )->Matched)

#define SET_FREE_OWNER(pRR)         (FLAG_FreeOwner(pRR) = TRUE)
#define SET_FREE_DATA(pRR)          (FLAG_FreeData(pRR) = TRUE)
#define SET_RR_MATCHED(pRR)         (FLAG_Matched(pRR) = TRUE)

#define CLEAR_FREE_OWNER(pRR)       (FLAG_FreeOwner(pRR) = FALSE)
#define CLEAR_FREE_DATA(pRR)        (FLAG_FreeData(pRR) = FALSE)
#define CLEAR_RR_MATCHED(pRR)       (FLAG_Matched(pRR) = FALSE)

#define IS_FREE_OWNER(pRR)          (FLAG_FreeOwner(pRR))
#define IS_FREE_DATA(pRR)           (FLAG_FreeData(pRR))
#define IS_RR_MATCHED(pRR)          (FLAG_Matched(pRR))

#define IS_ANSWER_RR(pRR)           (FLAG_Section(pRR) == DNSREC_ANSWER)
#define IS_AUTHORITY_RR(pRR)        (FLAG_Section(pRR) == DNSREC_AUTHORITY)
#define IS_ADDITIONAL_RR(pRR)       (FLAG_Section(pRR) == DNSREC_ADDITIONAL)


//
//  Converting RCODEs to\from DNS errors.
//

#define DNS_ERROR_FROM_RCODE(rcode)     ((rcode)+DNS_ERROR_RESPONSE_CODES_BASE)

#define DNS_RCODE_FROM_ERROR(err)       ((err)-DNS_ERROR_RESPONSE_CODES_BASE)




//
//  Record character sets
//
//  Currently supports records in three character sets
//      - unicode
//      - ANSI
//      - UTF8
//
//  Unicode and ANSI are supported through external DNSAPI interfaces.
//  UTF8 is not (at least offcially).
//
//  However, internally unicode and UTF8 are used for caching, reading
//  to and writing from packet.
//
//  All DNS_RECORD structs created by our code, are tagged with a
//  character set type in the flags CharSet field.
//

//
//  A couple of handy macros:
//

#define RECORD_CHARSET(pRR) \
        ( (DNS_CHARSET) (pRR)->Flags.S.CharSet )

#define IS_UNICODE_RECORD(pRR) \
        ( (DNS_CHARSET) (pRR)->Flags.S.CharSet == DnsCharSetUnicode )

//
//  Quick buffer size determination
//
//  Strings are read from the wire into dotted UTF8 format.
//  Strings are in UTF8 in RPC buffers.
//
//  Goal here is to quickly determine adequate buffer size,
//  slight overallocation is not critical.
//
//  Currently supporting only UTF8 or Unicode, however, if later
//  support direct ANSI conversion that's ok too, as ANSI will
//  no (to my knowledge) use more space than UTF8.
//

#define STR_BUF_SIZE_GIVEN_UTF8_LEN( Utf8Length, CharSet ) \
        ( ((CharSet)==DnsCharSetUnicode) ? ((Utf8Length)+1)*2 : (Utf8Length)+1 )


//
//  Default locale for string comparison and case mappings
//
//  Sublang: US English (0x04)  Lang:  English (0x09)
//

#define DNS_DEFAULT_LOCALE      (0x0409)




//
//  Addressing  IP4/6 sockaddr union
//

#define MAX_SOCKADDR_BLOB_SOCKADDR_LENGTH (32)

typedef struct _SockaddrBlob
{
    union
    {
        SOCKADDR        Sockaddr;
        SOCKADDR_IN     SockaddrIn;
#ifdef _WS2TCPIP_H_
        SOCKADDR_IN6    SockaddrIn6;
#endif
        CHAR            MaxSa[ MAX_SOCKADDR_BLOB_SOCKADDR_LENGTH ];
    };

    DWORD   Length;
    DWORD   SubnetLength;
}
SOCKADDR_BLOB, *PSOCKADDR_BLOB;

#define SOCKADDR_IS_IP4( pSa )          ( (pSa)->sa_family == AF_INET )
#define SOCKADDR_IS_IP6( pSa )          ( (pSa)->sa_family == AF_INET6 )

#define SOCKADDR_BLOB_IS_IP4( pSa )     SOCKADDR_IS_IP4( &(pSa)->Sockaddr )
#define SOCKADDR_BLOB_IS_IP6( pSa )     SOCKADDR_IS_IP6( &(pSa)->Sockaddr )



//
//  IP4 array utilities (iparray.c)
//
//  Note some of these require memory allocation, see note
//  on memory allocation below.
//


#define DNS_NET_ORDER_LOOPBACK      (0x0100007f)

//  NT5-autonet is 169.254.x.y

#define AUTONET_MASK                (0x0000ffff)
#define AUTONET_NET                 (0x0000fea9)

#define DNS_IS_AUTONET_IP(ip)       ( ((ip) & AUTONET_MASK) == AUTONET_NET )

#define DNS_IPARRAY_CLEAN_ZERO      (0x00000001)
#define DNS_IPARRAY_CLEAN_LOOPBACK  (0x00000002)
#define DNS_IPARRAY_CLEAN_AUTONET   (0x00000010)

//
//  Simple IP address array routines
//

PIP4_ADDRESS
Dns_CreateIpAddressArrayCopy(
    IN      PIP4_ADDRESS    aipAddress,
    IN      DWORD           cipAddress
    );

BOOL
Dns_ValidateIpAddressArray(
    IN      PIP4_ADDRESS    aipAddress,
    IN      DWORD           cipAddress,
    IN      DWORD           dwFlag
    );


//
//  IP4_ARRAY datatype routines
//

PIP4_ARRAY
Dns_CreateIpArray(
    IN      DWORD           cAddrCount
    );

DWORD
Dns_SizeofIpArray(
    IN      PIP4_ARRAY      pIpArray
    );

PIP4_ARRAY
Dns_BuildIpArray(
    IN      DWORD           cAddrCount,
    IN      PIP4_ADDRESS    pipAddrs
    );

PIP4_ARRAY
Dns_CopyAndExpandIpArray(
    IN      PIP4_ARRAY      pIpArray,
    IN      DWORD           ExpandCount,
    IN      BOOL            fDeleteExisting
    );

PIP4_ARRAY
Dns_CreateIpArrayCopy(
    IN      PIP4_ARRAY      pIpArray
    );

BOOL
Dns_IsAddressInIpArray(
    IN      PIP4_ARRAY      pIpArray,
    IN      IP4_ADDRESS     IpAddress
    );

BOOL
Dns_AddIpToIpArray(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      IP4_ADDRESS     IpNew
    );

VOID
Dns_ClearIpArray(
    IN OUT  PIP4_ARRAY      pIpArray
    );

VOID
Dns_ReverseOrderOfIpArray(
    IN OUT  PIP4_ARRAY      pIpArray
    );

BOOL
Dns_CheckAndMakeIpArraySubset(
    IN OUT  PIP4_ARRAY      pIpArraySub,
    IN      PIP4_ARRAY      pIpArraySuper
    );

INT
WINAPI
Dns_ClearIpFromIpArray(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      IP4_ADDRESS     IpDelete
    );

INT
WINAPI
Dns_DeleteIpFromIpArray(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      IP4_ADDRESS     IpDelete
    );

#define Dns_RemoveZerosFromIpArray(pArray)   \
        Dns_DeleteIpFromIpArray( (pArray), 0 )

INT
WINAPI
Dns_CleanIpArray(
    IN OUT  PIP4_ARRAY      pIpArray,
    IN      DWORD           Flag
    );

BOOL
Dns_AreIpArraysEqual(
    IN       PIP4_ARRAY     pIpArray1,
    IN       PIP4_ARRAY     pIpArray2
    );

BOOL
Dns_AreIpArraysSimilar(
    IN       PIP4_ARRAY     pIpArray1,
    IN       PIP4_ARRAY     pIpArray2
    );

DNS_STATUS
WINAPI
Dns_DiffOfIpArrays(
    IN      PIP4_ARRAY      pIpArray1,
    IN      PIP4_ARRAY      pIpArray2,
    OUT     PIP4_ARRAY*     ppOnlyIn1,
    OUT     PIP4_ARRAY*     ppOnlyIn2,
    OUT     PIP4_ARRAY*     ppIntersect
    );

BOOL
WINAPI
Dns_IsIntersectionOfIpArrays(
    IN       PIP4_ARRAY     pIpArray1,
    IN       PIP4_ARRAY     pIpArray2
    );

DNS_STATUS
WINAPI
Dns_UnionOfIpArrays(
    IN      PIP4_ARRAY      pIpArray1,
    IN      PIP4_ARRAY      pIpArray2,
    OUT     PIP4_ARRAY*     ppUnion
    );

#define Dns_IntersectionOfIpArrays(p1, p2, ppInt)    \
        Dns_DiffOfIpArrays( (p1), (p2), NULL, NULL, (ppInt) )


DNS_STATUS
Dns_CreateIpArrayFromMultiIpString(
    IN      PSTR            pchMultiIpString,
    OUT     PIP4_ARRAY*     ppIpArray
    );

PSTR 
Dns_CreateMultiIpStringFromIpArray(
    IN      PIP4_ARRAY      pIpArray,
    IN      CHAR            chSeparator     OPTIONAL
    );


//
//  Type list array routines
//

DNS_STATUS
Dns_CreateTypeArrayFromMultiTypeString(
    IN      PSTR            pchMultiTypeString,
    OUT     INT *           piTypeCount,
    OUT     PWORD *         ppwTypeArray
    );

PSTR 
Dns_CreateMultiTypeStringFromTypeArray(
    IN      INT             iTypeCount,
    IN      PWORD           ppwTypeArray,
    IN      CHAR            chSeparator     OPTIONAL
    );


//
//  IP6 stuff
//

#ifndef DEFINED_IP6_ARRAY
typedef struct _Ip6Array
{
    DWORD           MaxCount;
    DWORD           AddrCount;
#ifdef MIDL_PASS
    [size_is(MaxCount)] IP6_ADDRESS AddrArray[];
#else
    IP6_ADDRESS     AddrArray[1];
#endif
}
IP6_ARRAY, *PIP6_ARRAY;
#define DEFINED_IP6_ARRAY   1
#endif



//
//  General utilities
//


//
//  Wrap free, multi-thread safe seconds timer (timer.c)
//

VOID
Dns_InitializeSecondsTimer(
    VOID
    );

DWORD
Dns_GetCurrentTimeInSeconds(
    VOID
    );

//
//  Tokenizer
//

DWORD
Dns_TokenizeString(
    IN OUT  PSTR            pBuffer,
    OUT     PCHAR *         Argv,
    IN      DWORD           MaxArgs
    );



//
//  IP interfaces on local machine (iplist.c)
//

#define DNS_MAX_NAME_SERVERS        (50)
#define DNS_MAX_IP_INTERFACE_COUNT  (10000)

DWORD
Dns_GetIpAddresses(
    IN OUT  PDNS_ADDRESS_INFO IpAddressInfoList,
    IN      DWORD             ListCount
    );

PIP4_ARRAY
Dns_GetLocalIpAddressArray(
    VOID
    );

//
//  IP interfaces on local machine (iplist4.c)
//

DWORD
Dns_GetIpAddressesNT4(
    IN OUT  PDNS_ADDRESS_INFO IpAddressInfoList,
    IN      DWORD             ListCount
    );

//
//  IP interfaces on local machine (iplist9x.c)
//

DWORD
Dns_GetIpAddressesWin9X(
    IN OUT  PDNS_ADDRESS_INFO IpAddressInfoList,
    IN      DWORD             ListCount
    );



//
//  DNS server list routines (servlist.c)
//
//  Also includes default domain and search list information.
//

#define DNS_FLAG_IGNORE_ADAPTER             (0x00000001)
#define DNS_FLAG_IS_WAN_ADAPTER             (0x00000002)
#define DNS_FLAG_IS_AUTONET_ADAPTER         (0x00000004)
#define DNS_FLAG_IS_DHCP_CFG_ADAPTER        (0x00000008)

#define DNS_FLAG_REGISTER_DOMAIN_NAME       (0x00000010)
#define DNS_FLAG_REGISTER_IP_ADDRESSES      (0x00000020)

#define DNS_FLAG_ALLOW_MULTICAST            (0x00000100)
#define DNS_FLAG_MULTICAST_ON_NAME_ERROR    (0x00000200)

#define DNS_FLAG_AUTO_SERVER_DETECTED       (0x00000400)
#define DNS_FLAG_DUMMY_SEARCH_LIST          (0x00000800)

#define DNS_FLAG_SERVERS_UNREACHABLE        (0x00010000)




//
//  NetInfo structures
//
//  WARNING:  Do NOT use these!
//
//  These are internal dnsapi.dll structures.  They are only
//  included here for backward compatibility with previous
//  code (netdiag) which incorrectly used these.
//
//  If you code with them you will inevitably wake up broken
//  down the road.
//

//#ifdef  _DNSLIB_NETINFO_  

typedef struct
{
    DNS_STATUS      Status;
    DWORD           Priority;
    DWORD           Reserved0;
    DWORD           Reserved1;
    DWORD           Reserved2;
    IP4_ADDRESS     IpAddress;
}
DNSLIB_SERVER_INFO, *PDNSLIB_SERVER_INFO;

typedef struct
{
    PSTR                pszAdapterGuidName;
    PSTR                pszAdapterDomain;
    PIP4_ARRAY          pAdapterIPAddresses;
    PIP4_ARRAY          pAdapterIPSubnetMasks;
    PVOID               pIp6Addrs;
    PVOID               pIp6ClusterAddrs;
    DWORD               InterfaceIndex;
    DWORD               InfoFlags;
    DWORD               Reserved;
    DWORD               Status;
    DWORD               ReturnFlags;
    DWORD               IpLastSend;
    DWORD               cServerCount;
    DWORD               cTotalListSize;
    DNSLIB_SERVER_INFO  ServerArray[1];
}
DNSLIB_ADAPTER, *PDNSLIB_ADAPTER;

#define DNS_MAX_SEARCH_LIST_ENTRIES     (50)

typedef struct
{
    PSTR            pszName;
    DWORD           Flags;
}
DNSLIB_SEARCH_NAME, *PDNSLIB_SEARCH_NAME;

typedef struct
{
    PSTR            pszDomainOrZoneName;
    DWORD           cNameCount;         // Zero for FindAuthoritativeZone
    DWORD           cTotalListSize;     // Zero for FindAuthoritativeZone
    DWORD           CurrentName;        // 0 for pszDomainOrZoneName
                                        // 1 for first name in array below
                                        // 2 for second name in array below
                                        // ...
    DNSLIB_SEARCH_NAME  SearchNameArray[1];
}
DNSLIB_SEARCH_LIST, *PDNSLIB_SEARCH_LIST;

typedef struct
{
    PSTR                pszDomainName;
    PSTR                pszHostName;
    PDNSLIB_SEARCH_LIST pSearchList;
    DWORD               TimeStamp;
    DWORD               InfoFlags;
    DWORD               Tag;
    DWORD               ReturnFlags;
    DWORD               cAdapterCount;
    DWORD               cTotalListSize;
    PDNSLIB_ADAPTER     AdapterArray[1];
}
DNSLIB_NETINFO, *PDNSLIB_NETINFO;


//
//  Create correct internal\external definitions    
//

#ifdef DNSAPI_INTERNAL

typedef RPC_DNS_SERVER_INFO     DNS_SERVER_INFO,    *PDNS_SERVER_INFO;
typedef RPC_DNS_ADAPTER         DNS_ADAPTER,        *PDNS_ADAPTER;
typedef RPC_SEARCH_NAME         SEARCH_NAME,        *PSEARCH_NAME;
typedef RPC_SEARCH_LIST         SEARCH_LIST,        *PSEARCH_LIST;
typedef RPC_DNS_NETINFO         DNS_NETINFO,        *PDNS_NETINFO;

#else   // external

typedef DNSLIB_SERVER_INFO      DNS_SERVER_INFO,    *PDNS_SERVER_INFO;
typedef DNSLIB_ADAPTER          DNS_ADAPTER,        *PDNS_ADAPTER;
typedef DNSLIB_SEARCH_NAME      SEARCH_NAME,        *PSEARCH_NAME;
typedef DNSLIB_SEARCH_LIST      SEARCH_LIST,        *PSEARCH_LIST;
typedef DNSLIB_NETINFO          DNS_NETINFO,        *PDNS_NETINFO;

#endif


//
//  NetInfo routines (should be private)
//
//  But currently used in netdiag and nslookup
//  (nslookup problem is simply getting isolation
//  in header file)
//

BOOL
Dns_IsUpdateNetworkInfo(
    IN      PDNS_NETINFO    pNetInfo
    );



//
//  General DNS utilities (dnsutil.c)
//

IP4_ADDRESS
Dns_GetNetworkMask(
    IN      IP4_ADDRESS     ipAddress
    );

PSTR 
_fastcall
Dns_StatusString(
    IN      DNS_STATUS      Status
    );

#define Dns_StatusToErrorString_A(status)    Dns_StatusString(status)

DNS_STATUS
_fastcall
Dns_MapRcodeToStatus(
    IN      BYTE            ResponseCode
    );

BYTE
_fastcall
Dns_IsStatusRcode(
    IN      DNS_STATUS      Status
    );

//
//  Name utilities (name.c)
//

PSTR 
_fastcall
Dns_GetDomainName(
    IN      PCSTR           pszName
    );

PWSTR
_fastcall
Dns_GetDomainName_W(
    IN      PCWSTR          pwsName
    );

PCHAR
_fastcall
Dns_GetTldForName(
    IN      PCSTR           pszName
    );

BOOL
_fastcall
Dns_IsNameShort(
    IN      PCSTR           pszName
    );

BOOL
_fastcall
Dns_IsNameFQDN(
    IN      PCSTR           pszName
    );

DNS_STATUS
Dns_ValidateAndCategorizeDnsNameEx(
    IN      PCHAR           pchName,
    IN      DWORD           cchNameLength,
    OUT     PDWORD          pLabelCount
    );

#define Dns_ValidateAndCategorizeDnsName(p,c)   \
        Dns_ValidateAndCategorizeDnsNameEx((p),(c),NULL)

DWORD
Dns_NameLabelCount(
    IN      PCSTR           pszName
    );

#define DNS_NAME_UNKNOWN        0x00000000
#define DNS_NAME_IS_FQDN        0x00000001
#define DNS_NAME_SINGLE_LABEL   0x00000010
#define DNS_NAME_MULTI_LABEL    0x00000100

DWORD
_fastcall
Dns_GetNameAttributes(
    IN      PCSTR           pszName
    );



//
//  Packet create\read\write (packet.c)
//

//
//  UDP packet buffer
//
//  1472 is the maximum ethernet IP\UDP payload size
//  without causing fragmentation, use as default buffer
//

#define DNS_MAX_UDP_PACKET_BUFFER_LENGTH    (1472)


//  parsing RR
//  convenient to get WIRE records into aligned\host order format

typedef struct _DNS_PARSED_RR
{
    PCHAR   pchName;
    PCHAR   pchRR;
    PCHAR   pchData;
    PCHAR   pchNextRR;

    //  note from here on down mimics wire record

    WORD    Type;
    WORD    Class;
    DWORD   Ttl;
    WORD    DataLength;
}
DNS_PARSED_RR, *PDNS_PARSED_RR;


//
//  DNS Server Message Info structure
//
//  This is structure in which requests are held while being
//  processed by the DNS server.
//


typedef struct _DnsMessageBuf
{
    LIST_ENTRY      ListEntry;          //  for queuing

    //
    //  Addressing
    //

    SOCKET          Socket4;
    SOCKET          Socket6;

    //16/32
    SOCKADDR_BLOB   RemoteAddress;

    //32/48
    SOCKET          Socket;

    //
    //  Basic packet info
    //

    DWORD           BufferLength;       //  total length of buffer
    PCHAR           pBufferEnd;         //  ptr to byte after buffer

    PBYTE           pCurrent;           //  current location in buffer
    PWORD           pCurrentCountField; //  current count field being written

    //
    //  Current lookup info
    //

    DWORD           Timeout;            //  recv timeout
    DWORD           QueryTime;          //  time of original query
    WORD            wTypeCurrent;       //  type of query being done
    WORD            wOffsetCurrent;

    //
    //  Queuing
    //

    WORD            wQueuingXid;        //  match XID to response
    DWORD           QueuingTime;        //  time queued
    DWORD           ExpireTime;         //  queue timeout

    //
    //  Basic packet flags
    //

    BOOLEAN         fTcp;
    BOOLEAN         fSwapped;           //  header in net order
    BOOLEAN         fMessageComplete;   //  complete message received
    BOOLEAN         fConvertUnicode;    //  convert to unicode
    BOOLEAN         fSocketKeepalive;   //  keep socket alive
    BOOLEAN         fLastSendOpt;       //  last send contained OPT

    //
    //  TCP message reception
    //

    PCHAR           pchRecv;            //  ptr to next pos in message

    //
    //  End of message before OPT addition
    //

    PCHAR           pPreOptEnd;

    //
    //  WARNING !
    //
    //  Message length MUST
    //      - be a WORD type
    //      - immediately preceed message itself
    //  for proper send/recv of TCP messages.
    //
    //  Use pointers above to DWORD (or QWORD) align, then recv bytes to push
    //  message length against MessageHead.  Note, that DNS_HEADER contains
    //  only WORDs as it's largest element and so should chummy up even on
    //  WORD boundary.  DWORD boundary should be very safe.
    //
                                                          
    WORD            BytesToReceive;
    WORD            MessageLength;

    //
    //  DNS Message itself
    //

    DNS_HEADER      MessageHead;

    //
    //  Question and RR section
    //
    //  This simply provides some coding simplicity in accessing
    //  this section given MESSAGE_INFO structure.
    //

    CHAR            MessageBody[1];

}
DNS_MSG_BUF, *PDNS_MSG_BUF;

#define SIZEOF_MSG_BUF_OVERHEAD (sizeof(DNS_MSG_BUF) - sizeof(DNS_HEADER) - 1)

#define DNS_MESSAGE_END(pMsg) \
                ((PCHAR)&(pMsg)->MessageHead + (pMsg)->MessageLength)

#define DNS_MESSAGE_OFFSET( pMsg, p ) \
                ((PCHAR)(p) - (PCHAR)(&(pMsg)->MessageHead))

#define DNS_MESSAGE_CURRENT_OFFSET( pMsg ) \
                DNS_MESSAGE_OFFSET( (pMsg), (pMsg)->pCurrent )


//  Sockaddr combined length

#define DNS_MESSAGE_REMOTE_ADDRESS_AND_LENGTH_


//
//  Handy for packet setup
//

#define CLEAR_DNS_HEADER_FLAGS_AND_XID( pHead )     ( *(PDWORD)(pHead) = 0 )


PDNS_MSG_BUF
Dns_AllocateMsgBuf(
    IN      WORD            wBufferLength   OPTIONAL
    );

VOID
Dns_InitializeMsgBuf(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

PDNS_MSG_BUF
Dns_BuildPacket(
    IN      PDNS_HEADER     pHeader,
    IN      BOOL            fNoHeaderCounts,
    IN      PDNS_NAME       pszQuestionName,
    IN      WORD            wQuestionType,
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      BOOL            fUpdatePacket
    );

PCHAR
_fastcall
Dns_WriteDottedNameToPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PSTR            pszName,
    IN      PSTR            pszDomain,      OPTIONAL
    IN      WORD            wDomainOffset,  OPTIONAL
    IN      BOOL            fUnicodeName
    );

PCHAR
_fastcall
Dns_WriteStringToPacket(
    IN OUT  PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      PSTR            pszString,
    IN      BOOL            fUnicodeString
    );

PCHAR
Dns_WriteQuestionToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_NAME       pszName,
    IN      WORD            wType,
    IN      BOOL            fUnicodeName
    );

DNS_STATUS
Dns_WriteRecordStructureToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      WORD            wType,
    IN      WORD            wClass,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    );

PCHAR
Dns_WriteRecordStructureToPacketEx(
    IN OUT  PCHAR           pchBuf,
    IN      WORD            wType,
    IN      WORD            wClass,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    );

DNS_STATUS
Dns_WriteRecordStructureToPacket(
    IN OUT  PCHAR           pchBuf,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUpdatePacket
    );

VOID
Dns_SetRecordDatalength(
    IN OUT  PDNS_WIRE_RECORD    pRecord,
    IN      WORD                wDataLength
    );

DNS_STATUS
Dns_AddRecordsToMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PDNS_RECORD     pRecord,
    IN      BOOL            fUpdateMessage
    );

PCHAR
_fastcall
Dns_SkipPacketName(
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    );

BOOL
Dns_IsSamePacketQuestion(
    IN      PDNS_MSG_BUF    pMsg1,
    IN      PDNS_MSG_BUF    pMsg2
    );

PCHAR
_fastcall
Dns_SkipPacketRecord(
    IN      PCHAR           pchRecord,
    IN      PCHAR           pchMsgEnd
    );

PCHAR
Dns_SkipToRecord(
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd,
    IN      INT             iCount
    );

PCHAR
Dns_ReadRecordStructureFromPacket(
    IN      PCHAR           pchPacket,
    IN      PCHAR           pchMsgEnd,
    IN OUT  PDNS_PARSED_RR  pParsedRR
    );

DNS_STATUS
Dns_ExtractRecordsFromMessage(
    IN      PDNS_MSG_BUF    pMsg,
    IN      BOOL            fUnicode,
    OUT     PDNS_RECORD *   ppRecord
    );

DNS_STATUS
Dns_ExtractRecordsFromBuffer(
    IN      PDNS_MESSAGE_BUFFER pDnsBuffer,
    IN      WORD                wMessageLength,
    IN      BOOL                fUnicode,
    OUT     PDNS_RECORD *       ppRecord
    );

void
Dns_NormalizeAllRecordTtls(
    IN      PDNS_RECORD         pRecord
    );

PCHAR
_fastcall
Dns_ReadPacketName(
    IN OUT  PCHAR           pchNameBuffer,
    OUT     PWORD           pwNameLength,
    IN OUT  PWORD           pwNameOffset,           OPTIONAL
    OUT     PBOOL           pfNameSameAsPrevious,   OPTIONAL
    IN      PCHAR           pchName,
    IN      PCHAR           pchStart,
    IN      PCHAR           pchEnd
    );

PCHAR
_fastcall
Dns_ReadPacketNameAllocate(
    IN OUT  PCHAR *         ppchName,
    OUT     PWORD           pwNameLength,
    IN OUT  PWORD           pwPrevNameOffset,       OPTIONAL
    OUT     PBOOL           pfNameSameAsPrevious,   OPTIONAL
    IN      PCHAR           pchPacketName,
    IN      PCHAR           pchStart,
    IN      PCHAR           pchEnd
    );

WORD
Dns_GetRandomXid(
    IN      PVOID           pSeed
    );


//
//  Socket setup (socket.c)
//

//
//  these two routines really don't belong here -- system stuff should be elsewhere
//

DNS_STATUS
Dns_InitializeWinsock(
    VOID
    );
VOID
Dns_CleanupWinsock(
    VOID
    );

SOCKET
Dns_CreateSocket(
    IN      INT             SockType,
    IN      IP4_ADDRESS     ipAddress,
    IN      USHORT          Port
    );

SOCKET
Dns_CreateMulticastSocket(
    IN      INT             SockType,
    IN      IP4_ADDRESS     ipAddress,
    IN      USHORT          Port,
    IN      BOOL            fSend,
    IN      BOOL            fReceive
    );

VOID
Dns_CloseSocket(
    IN      SOCKET          Socket
    );

VOID
Dns_CloseConnection(
    IN      SOCKET          Socket
    );

DNS_STATUS
Dns_SetupGlobalAsyncSocket(
    VOID
    );



//
//  Raw packet send and recv (send.c)
//

DNS_STATUS
Dns_SendEx(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP4_ADDRESS     SendIp,     OPTIONAL
    IN      BOOL            fNoOpt
    );

#define Dns_Send( pMsg )    Dns_SendEx( (pMsg), 0, 0 )

DNS_STATUS
Dns_Recv(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

DNS_STATUS
Dns_RecvUdp(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

VOID
Dns_SendMultipleUdp(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PIP4_ARRAY      aipSendAddrs
    );

DNS_STATUS
Dns_SendAndRecvUdp(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF    pMsgRecv,
    IN      DWORD           dwFlags,
    IN      PIP4_ARRAY      aipServers,
    IN OUT  PDNS_NETINFO    pAdapterInfo
    );

DNS_STATUS
Dns_SendAndRecvMulticast(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF    pMsgRecv,
    IN OUT  PDNS_NETINFO    pAdapterInfo OPTIONAL
    );

DNS_STATUS
Dns_OpenTcpConnectionAndSend(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP4_ADDRESS     ipServer,
    IN      BOOL            fBlocking
    );

DNS_STATUS
Dns_RecvTcp(
    IN OUT  PDNS_MSG_BUF    pMsg
    );

DNS_STATUS
Dns_SendAndRecvTcp(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF    pMsgRecv,
    IN      PIP4_ARRAY      aipServers,
    IN OUT  PDNS_NETINFO    pAdapterInfo
    );

VOID
Dns_InitializeMsgRemoteSockaddr(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      IP4_ADDRESS     IpAddress
    );

DNS_STATUS
Dns_SendAndRecv(
    IN OUT  PDNS_MSG_BUF    pMsgSend,
    OUT     PDNS_MSG_BUF *  ppMsgRecv,
    OUT     PDNS_RECORD *   ppResponseRecords,
    IN      DWORD           dwFlags,
    IN      PIP4_ARRAY      aipServers,
    IN OUT  PDNS_NETINFO    pAdapterInfo
    );

VOID
Dns_InitQueryTimeouts(
    VOID
    );



//
//  Query (query.c)
//


//
//  Flags to DnsQuery
//
//  These are in addition to public flags in dnsapi.h
//  They must all be in the reserved section defined by
//  DNS_QUERY_RESERVED
//

//  Unicode i\o

#define     DNSQUERY_UNICODE_NAME       (0x01000000)
#define     DNSQUERY_UNICODE_OUT        (0x02000000)

//  DNS server query

#define DNS_SERVER_QUERY_NAME           (L"..DnsServers")


DNS_STATUS
Dns_QueryLib(
    IN OUT  PDNS_MSG_BUF *  ppMsgResponse,
    OUT     PDNS_RECORD *   ppRecord,
    IN      PDNS_NAME       pszName,
    IN      WORD            wType,
    IN      DWORD           dwFlags,
    IN      PIP4_ARRAY      aipDnsServers,
    IN      PDNS_NETINFO    pNetworkInfo,
    IN      SOCKET          Socket OPTIONAL
    );

DNS_STATUS
Dns_QueryLibEx(
    IN OUT  PDNS_MSG_BUF *  ppMsgResponse,
    OUT     PDNS_RECORD *   ppResponseRecord,
    IN      PDNS_HEADER     pHeader,
    IN      BOOL            fNoHeaderCounts,
    IN      PDNS_NAME       pszName,
    IN      WORD            wType,
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      PIP4_ARRAY      aipDnsServers,
    IN      PDNS_NETINFO    pNetworkInfo
    );

DNS_STATUS
Dns_FindAuthoritativeZoneLib(
    IN      PDNS_NAME       pszName,
    IN      DWORD           dwFlags,
    IN      PIP4_ARRAY      aipQueryServers,
    OUT     PDNS_NETINFO *  ppNetworkInfo
    );

PDNS_NETINFO     
Dns_BuildUpdateNetworkInfoFromFAZ(
    IN      PSTR            pszZone,
    IN      PSTR            pszPrimaryDns,
    IN      PDNS_RECORD     pRecord
    );



//
//  Dynamic update (update.c)
//

PCHAR
Dns_WriteNoDataUpdateRecordToMessage(
    IN      PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      WORD            wClass,
    IN      WORD            wType
    );

PCHAR
Dns_WriteDataUpdateRecordToMessage(
    IN      PCHAR           pch,
    IN      PCHAR           pchStop,
    IN      WORD            wClass,
    IN      WORD            wType,
    IN      DWORD           dwTtl,
    IN      WORD            wDataLength
    );

PDNS_MSG_BUF
Dns_BuildHostUpdateMessage(
    IN OUT  PDNS_MSG_BUF    pMsg,
    IN      PSTR            pszZone,
    IN      PSTR            pszName,
    IN      PIP4_ARRAY      aipAddresses,
    IN      DWORD           dwTtl
    );

PDNS_RECORD
Dns_HostUpdateRRSet(
    IN      PSTR            pszHostName,
    IN      PIP4_ARRAY      aipAddrs,
    IN      DWORD           dwTtl
    );

DNS_STATUS
Dns_UpdateHostAddrs(
    IN      PSTR            pszName,
    IN      PIP4_ARRAY      aipAddresses,
    IN      PIP4_ARRAY      aipServers,
    IN      DWORD           dwTtl
    );

DNS_STATUS
Dns_UpdateHostAddrsOld(
    IN      PSTR            pszName,
    IN      PIP4_ARRAY      aipAddresses,
    IN      PIP4_ARRAY      aipServers,
    IN      DWORD           dwTtl
    );

DNS_STATUS
Dns_UpdateLib(
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      PDNS_NETINFO    pNetworkInfo,
    IN      HANDLE          hCreds,         OPTIONAL
    OUT     PDNS_MSG_BUF *  ppMsgRecv       OPTIONAL
    );

DNS_STATUS
Dns_UpdateLibEx(
    IN      PDNS_RECORD     pRecord,
    IN      DWORD           dwFlags,
    IN      PDNS_NAME       pszZone,
    IN      PDNS_NAME       pszServerName,
    IN      PIP4_ARRAY      aipServers,
    IN      HANDLE          hCreds,         OPTIONAL
    OUT     PDNS_MSG_BUF *  ppMsgRecv       OPTIONAL
    );


//
//  Record verification table
//

typedef struct _DnsVerifyTable
{
    DWORD           RecordCount;
    PDNS_RECORD     pRecordList;
    PIP6_ARRAY      pServerArray;
    PBOOL           pVerifyArray;
}
DNS_VERIFY_TABLE, *PDNS_VERIFY_TABLE;

DNS_STATUS
Dns_VerifyRecords(
    IN OUT  PDNS_VERIFY_TABLE   pTable
    );


//
//  Record verification table for rendom
//
//  Implementation note:
//  Using pointers here for server\bool arrays here instead
//  of open array of server count.  The reason is to allow dynamic
//  allocation of the lists by the API if it FAZes to find to
//  zone\servers to target.
//  The server IPs and bools could be combined in another
//  structure, but that doesn't seem to add much and makes
//  use of the existing IP array stuff more difficult.
//

typedef struct _DnsRendomEntry
{
    PSTR                    pDcName;
    //  could have this in unicode
    //PWSTR                   pDcName;
    PDNS_RECORD             pRecord;
    PIP6_ARRAY              pServerArray;
    PBOOL                   pVerifyArray;
}
DNS_RENDOM_ENTRY, *PDNS_RENDOM_ENTRY;


#define DNS_RENDOM_VERIFY_WITH_FAZ          (0x00000001)
#define DNS_RENDOM_VERIFY_WITH_LIST         (0x00000002)


typedef struct _DnsZoneServerList
{
    PWSTR            pZoneName;
    //  could have this in unicode
    //PWSTR           pZoneName;
    PIP6_ARRAY      pServerArray;
}
DNS_ZONE_SERVER_LIST, *PDNS_ZONE_SERVER_LIST;


DNS_STATUS
Dns_VerifyRendomDcRecords(
    IN OUT  PDNS_RENDOM_ENTRY       pTable,
    IN      PDNS_ZONE_SERVER_LIST   pZoneServList,  OPTIONAL
    IN      DWORD                   Flag
    );



//
//  List build
//
//  pFirst points to first element in list.
//  pLast points to last element in list.
//
//  This builds a list for element types which have a pNext field
//  as their first structure member.
//

typedef struct _Dns_List
{
    PVOID   pFirst;
    PVOID   pLast;
}
DNS_LIST, *PDNS_LIST;

//
//  To init pFirst is NULL.
//  But pLast points at the location of the pFirst pointer -- essentially
//  treating the DNS_LIST as an element and pFirst as its next ptr.
//
//  During an add, the address given in pLast, is set with the new element,
//  equivalent to setting pLast's pNext field.  Then pLast is reset to point
//  at a new element.
//
//  When the first element is added to the list, pLast is pointing at the
//  DNS_LIST structure itself, so pFirst (as a dummy pNext) is set with
//  the ptr to the first element.
//
//  This works ONLY for elements which have a pNext field as the first
//  structure member.
//

#define DNS_LIST_INIT( pList )              \
        {                                   \
            PDNS_LIST _plist = (pList);     \
            _plist->pFirst = NULL;          \
            _plist->pLast = (_plist);       \
        }

#define DNS_LIST_ADD( pList, pnew )         \
        {                                   \
            PDNS_LIST   _plist = (pList);   \
            PVOID       _pnew = (pnew);         \
            *(PVOID*)(_plist->pLast) = _pnew;   \
            _plist->pLast = _pnew;              \
        }

#define IS_DNS_LIST_EMPTY( pList )          \
            ( (pList)->pFirst == NULL )


//
//  DNS_LIST as structure macros
//
//  Faster when function contains DNS_LIST structure itself and
//  NO SIDE EFFECTS will be present in call.
//

#define DNS_LIST_STRUCT_INIT( List )    \
        {                               \
            List.pFirst = NULL;         \
            List.pLast = &List;         \
        }

#define DNS_LIST_STRUCT_ADD( List, pnew ) \
        {                                           \
            *(PVOID*)(List.pLast) = (PVOID)pnew;    \
            List.pLast = (PVOID)pnew;               \
        }

#define IS_DNS_LIST_STRUCT_EMPTY( List ) \
            ( List.pFirst == NULL )



//
//  Record building (rralloc.c)
//

PDNS_RECORD
WINAPI
Dns_AllocateRecord(
    IN      WORD            wBufferLength
    );

VOID
WINAPI
Dns_RecordFree(
    IN OUT  PDNS_RECORD     pRecord
    );

#if 1
//  Old BS with flag -- kill when all fixed up

VOID
WINAPI
Dns_RecordListFreeEx(
    IN OUT  PDNS_RECORD     pRRList,
    IN      BOOL            fFreeOwner
    );

#define Dns_RecordListFree(p, f)    Dns_RecordListFreeEx(p, f)

#else   // new version
VOID
WINAPI
Dns_RecordListFree(
    IN OUT  PDNS_RECORD     pRRList
    );

#endif



PDNS_RECORD
Dns_RecordSetDetach(
    IN OUT  PDNS_RECORD     pRRList
    );

PDNS_RECORD
WINAPI
Dns_RecordListAppend(
    IN OUT  PDNS_RECORD     pHeadList,
    IN      PDNS_RECORD     pTailList
    );

DWORD
Dns_RecordListCount(
    IN      PDNS_RECORD     pRRList,
    IN      WORD            wType
    );


//
//  Record build from data strings (rrbuild.c)
//

PDNS_RECORD
Dns_RecordBuild_A(
    IN OUT  PDNS_RRSET      pRRSet,
    IN      PSTR            pszOwner,
    IN      WORD            wType,
    IN      BOOL            fAdd,
    IN      UCHAR           Section,
    IN      INT             Argc,
    IN      PCHAR *         Argv
    );

PDNS_RECORD
Dns_RecordBuild_W(
    IN OUT  PDNS_RRSET      pRRSet,
    IN      PWSTR           pszOwner,
    IN      WORD            wType,
    IN      BOOL            fAdd,
    IN      UCHAR           Section,
    IN      INT             Argc,
    IN      PWCHAR *        Argv
    );

//
//  Record to\from string functions.
//

DNS_STATUS
Dns_WriteRecordToString(
    OUT     PCHAR           pBuffer,
    IN      DWORD           BufferLength,
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSet,
    IN      DWORD           Flags
    );

PDNS_RECORD
Dns_CreateRecordFromString(
    IN      PSTR            pString,
    IN      DNS_CHARSET     CharSet,
    IN      DWORD           Flags
    );



//
//  Record set manipulation
//

//
//  Record Compare
//
//  Note:  these routines will NOT do proper unicode compare, unless
//          records have the fUnicode flag set.
//

BOOL
WINAPI
Dns_RecordCompare(
    IN      PDNS_RECORD     pRecord1,
    IN      PDNS_RECORD     pRecord2
    );

BOOL
WINAPI
Dns_RecordSetCompare(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,    OPTIONAL
    OUT     PDNS_RECORD *   ppDiff2     OPTIONAL
    );

typedef enum _DnsSetCompareResult
{
    DnsSetCompareError = (-1),
    DnsSetCompareIdentical,
    DnsSetCompareNoOverlap,
    DnsSetCompareOneSubsetOfTwo,
    DnsSetCompareTwoSubsetOfOne,
    DnsSetCompareIntersection
}
DNS_SET_COMPARE_RESULT;

DNS_SET_COMPARE_RESULT
WINAPI
Dns_RecordSetCompareEx(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,    OPTIONAL
    OUT     PDNS_RECORD *   ppDiff2     OPTIONAL
    );

BOOL
WINAPI
Dns_RecordSetCompareForIntersection(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2
    );

//
//  Record set prioritization (rrsort.c)
//

BOOL
Dns_CompareIpAddresses(
    IN      IP4_ADDRESS     addr1,
    IN      IP4_ADDRESS     addr2,
    IN      IP4_ADDRESS     subnetMask
    );


//
//  DNS Name compare
//

BOOL
Dns_NameCompare_A(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2
    );

BOOL
Dns_NameCompare_W(
    IN      PCWSTR          pName1,
    IN      PCWSTR          pName2
    );

BOOL
Dns_NameCompare_UTF8(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2
    );

//#define Dns_NameCompare(pName1, pName2)     Dns_NameCompare_UTF8((pName1),(pName2))
//#define Dns_NameCompare_U(pName1, pName2)   Dns_NameCompare_UTF8((pName1),(pName2))


BOOL
Dns_NameComparePrivate(
    IN      PCSTR           pName1,
    IN      PCSTR           pName2,
    IN      DNS_CHARSET     CharSet
    );

//
//  Advanced name comparison
//  Includes hierarchial name relationship.
//

DNS_NAME_COMPARE_STATUS
Dns_NameCompareEx(
    IN      LPCSTR          pszNameLeft,
    IN      LPCSTR          pszNameRight,
    IN      DWORD           dwReserved,
    IN      DNS_CHARSET     CharSet
    );

//
//  Record Copy
//

PDNS_RECORD
WINAPI
Dns_RecordCopyEx(
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

//
//  RR Set copy
//

PDNS_RECORD
WINAPI
Dns_RecordSetCopyEx(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );



//
//  Record \ type routines
//
//
//  Resource record type\name mapping table
//

typedef struct
{
    PCHAR   pszTypeName;    //  type string (used in database files)
    WORD    wType;          //  type in host byte order
}
TYPE_NAME_TABLE;

extern TYPE_NAME_TABLE TypeTable[];


//
//  Max record name length, allows upcasing of incoming labels
//  to optimize comparisons
//

#define MAX_RECORD_NAME_LENGTH  (8)

//
//  Record type specific sizes
//

#define WKS_MAX_PORT                (1024)  // max well known service port
#define WKS_MAX_BITMASK_LENGTH      (128)   // 1024bits / 8bits/byte

#define SIZEOF_A6_ADDRESS_SUFFIX_LENGTH 16

#define SIZEOF_SOA_FIXED_DATA       (5 * sizeof(DWORD))
#define SIZEOF_MX_FIXED_DATA        (sizeof(WORD))
#define SIZEOF_WKS_FIXED_DATA       (SIZEOF_IP4_ADDRESS+ sizeof(BYTE))
#define SIZEOF_KEY_FIXED_DATA       (sizeof(DWORD))
#define SIZEOF_SIG_FIXED_DATA       (4 * sizeof(DWORD) + sizeof(WORD))
#define SIZEOF_NXT_FIXED_DATA       (0)
#define SIZEOF_LOC_FIXED_DATA       (4 * sizeof(DWORD))
#define SIZEOF_SRV_FIXED_DATA       (3 * sizeof(WORD))
#define SIZEOF_A6_FIXED_DATA        (1 + SIZEOF_A6_ADDRESS_SUFFIX_LENGTH)

#define SIZEOF_TKEY_FIXED_DATA      (2 * sizeof(DWORD) + 4 * sizeof(WORD))

#define SIZEOF_TSIG_PRE_SIG_FIXED_DATA  (2 * sizeof(DWORD) + sizeof(WORD))
#define SIZEOF_TSIG_POST_SIG_FIXED_DATA (3 * sizeof(WORD))
#define SIZEOF_TSIG_FIXED_DATA          (2 * sizeof(DWORD) + 4 * sizeof(WORD))

#define SIZEOF_WINS_FIXED_DATA      (4 * sizeof(DWORD))
#define SIZEOF_NBSTAT_FIXED_DATA    (3 * sizeof(DWORD))

//
//  Record type routines
//  These ones are of possible public interest and exposed in dnsapi.dll
//

BOOL
_fastcall
Dns_IsAMailboxType(
    IN      WORD            wType
    );

WORD
Dns_RecordTypeForName(
    IN      PCHAR           pszName,
    IN      INT             cchNameLength
    );

BOOL
Dns_WriteStringForType_A(
    OUT     PCHAR           pBuffer,
    IN      WORD            wType
    );

BOOL
Dns_WriteStringForType_W(
    OUT     PWCHAR          pBuffer,
    IN      WORD            wType
    );

PCHAR
Dns_RecordStringForType(
    IN      WORD            wType
    );

PCHAR
Dns_RecordStringForWritableType(
    IN      WORD            wType
    );

//
//  Record type specific stuff
//

BOOL
Dns_IsStringCountValidForTextType(
    IN      WORD            wType,
    IN      WORD            StringCount
    );


//
//  ATMA conversions
//

DWORD
Dns_AtmaAddressLengthForAddressString(
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    );

DNS_STATUS
Dns_AtmaStringToAddress(
    OUT     PBYTE           pAddress,
    IN OUT  PDWORD          pdwAddrLength,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    );

PCHAR
Dns_AtmaAddressToString(
    OUT     PCHAR           pchString,
    IN      UCHAR           AddrType,
    IN      PBYTE           pAddress,
    IN      DWORD           dwAddrLength
    );

//
//  DNSSEC SIG and KEY routines
//

//  Max key is 4096 bit giving 512 byte length.
//
//  Max string representation is actually 33% larger as each three byte (24bit)
//  block contains four base64 characters.

#define DNS_MAX_KEY_LENGTH              (512)

#define DNS_MAX_KEY_STRING_LENGTH       (685)


WORD
Dns_KeyRecordFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_KeyRecordFlagString(
    IN      DWORD           dwFlag,
    IN OUT  PCHAR           pchFlag
    );

UCHAR
Dns_KeyRecordProtocolForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_GetKeyProtocolString(
    IN      UCHAR           uchProtocol
    );

UCHAR
Dns_SecurityAlgorithmForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_GetDnssecAlgorithmString(
    IN      UCHAR           uchAlgorithm
    );

UCHAR
Dns_SecurityBase64CharToBits(
    IN      CHAR            ch64
    );

DNS_STATUS
Dns_SecurityBase64StringToKey(
    OUT     PBYTE           pKey,
    OUT     PDWORD          pKeyLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchLength
    );

PCHAR
Dns_SecurityKeyToBase64String(
    IN      PBYTE           pKey,
    IN      DWORD           KeyLength,
    OUT     PCHAR           pchBuffer
    );

LONG
Dns_ParseSigTime(
    IN      PCHAR           pchString,
    IN      INT             cchLength
    );

PCHAR
Dns_SigTimeString(
    IN      LONG            SigTime,
    OUT     PCHAR           pchBuffer
    );


//
//  WINS \ WINS-R types detection
//

#define IS_WINS_TYPE(type)      (((type) & 0xfffc) == 0xff00)

//
//  MS WINS mapping flags
//

//  return on invalid WINS flag

#define DNS_WINS_FLAG_ERROR     (-1)

//  max length of WINS flags
//  pass buffer at least this big

#define WINS_FLAG_MAX_LENGTH    (80)


DWORD
Dns_WinsRecordFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_WinsRecordFlagString(
    IN      DWORD           dwFlag,
    IN OUT  PCHAR           pchFlag
    );

//
//  must sit here until PDNS_RECORD defined in public dns.h header
//

DNS_STATUS
Dns_RecordWriteFileString(
    IN      PDNS_RECORD     pRecord,
    IN      PSTR            pszZoneName,
    IN      DWORD           dwDefaultTtl    OPTIONAL
    );




//
//  IP Address to\from string utilities (straddr.c)
//

//
//  String to Address
//

BOOL
Dns_Ip4StringToAddress_W(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCWSTR          pwString
    );

BOOL
Dns_Ip4StringToAddress_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pString
    );

BOOL
Dns_Ip6StringToAddress_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pString
    );

BOOL
Dns_Ip6StringToAddress_W(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCWSTR          pwString
    );

//
//  Combined IP4\IP6 string to address
//

BOOL
Dns_StringToAddress_W(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCWSTR          pString,
    IN OUT  PDWORD          pAddrFamily
    );

BOOL
Dns_StringToAddress_A(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily
    );


//
//  Address to string 
//

PWCHAR
Dns_Ip6AddressToString_W(
    OUT     PWCHAR          pwString,
    IN      PIP6_ADDRESS    pIp6Addr
    );

PCHAR
Dns_Ip6AddressToString_A(
    OUT     PCHAR           pchString,
    IN      PIP6_ADDRESS    pIp6Addr
    );

PWCHAR
Dns_Ip4AddressToString_W(
    OUT     PWCHAR          pwString,
    IN      PIP4_ADDRESS    pIp4Addr
    );

PCHAR
Dns_Ip4AddressToString_A(
    OUT     PCHAR           pString,
    IN      PIP4_ADDRESS    pIp4Addr
    );

//
//  Address to string -- combined
//

PCHAR
Dns_AddressToString_A(
    OUT     PCHAR           pchString,
    IN OUT  PDWORD          pStringLength,
    IN      PBYTE           pAddr,
    IN      DWORD           AddrLength,
    IN      DWORD           AddrFamily
    );


//
//  Reverse lookup address-to-name IP4
//

PCHAR
Dns_Ip4AddressToReverseName_A(
    OUT     PCHAR           pBuffer,
    IN      IP4_ADDRESS     IpAddr
    );

PWCHAR
Dns_Ip4AddressToReverseName_W(
    OUT     PWCHAR          pBuffer,
    IN      IP4_ADDRESS     IpAddr
    );

PCHAR
Dns_Ip4AddressToReverseNameAlloc_A(
    IN      IP4_ADDRESS     IpAddr
    );

PWCHAR
Dns_Ip4AddressToReverseNameAlloc_W(
    IN      IP4_ADDRESS     IpAddr
    );

//
//  Reverse lookup address-to-name IP6
//

PCHAR
Dns_Ip6AddressToReverseName_A(
    OUT     PCHAR           pBuffer,
    IN      IP6_ADDRESS     Ip6Addr
    );

PWCHAR
Dns_Ip6AddressToReverseName_W(
    OUT     PWCHAR          pBuffer,
    IN      IP6_ADDRESS     Ip6Addr
    );

PCHAR
Dns_Ip6AddressToReverseNameAlloc_A(
    IN      IP6_ADDRESS     Ip6Addr
    );

PWCHAR
Dns_Ip6AddressToReverseNameAlloc_W(
    IN      IP6_ADDRESS     Ip6Addr
    );

//
//  Reverse lookup name-to-address
//

BOOL
Dns_Ip4ReverseNameToAddress_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pszName
    );

BOOL
Dns_Ip4ReverseNameToAddress_W(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCWSTR          pwsName
    );

BOOL
Dns_Ip6ReverseNameToAddress_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pszName
    );

BOOL
Dns_Ip6ReverseNameToAddress_W(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCWSTR          pwsName
    );

//
//  Combined IP4\IP6 reverse lookup name-to-address
//

BOOL
Dns_ReverseNameToAddress_W(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCWSTR          pString,
    IN OUT  PDWORD          pAddrFamily
    );

BOOL
Dns_ReverseNameToAddress_A(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily
    );



//
//  String utilities (string.c)
//
//  Note some of these require memory allocation, see note
//  on memory allocation below.
//
//  Flags are defined in dnsapi.h
//

//#define DNS_ALLOW_RFC_NAMES_ONLY    (0)
//#define DNS_ALLOW_NONRFC_NAMES      (0x00000001)
//#define DNS_ALLOW_MULTIBYTE_NAMES   (0x00000002)
//#define DNS_ALLOW_ALL_NAMES         (0x00000003)

//
//  Unicode name buffer length.
//  Non-type specific routines below take buffer counts in bytes.
//  Unicode buffers of max name length have twice the bytes.
//

#define DNS_MAX_NAME_BUFFER_LENGTH_UNICODE  (2 * DNS_MAX_NAME_BUFFER_LENGTH)


//
//  Macros to simplify UTF8 conversions
//
//  UTF8 is simply a representation of unicode that maps one-to-one
//  for the ASCII space.
//  Unicode                     UTF8
//  -------                     ----
//      < 0x80 (128)    ->      use low byte (one-to-one mapping)
//      < 0x07ff        ->      two chars
//      > 0x07ff        ->      three chars
//

#define UTF8_1ST_OF_2     0xc0      //  110x xxxx
#define UTF8_1ST_OF_3     0xe0      //  1110 xxxx
#define UTF8_TRAIL        0x80      //  10xx xxxx

#define UTF8_2_MAX        0x07ff    //  max unicode character representable in
                                    //  in two byte UTF8


//
//  Explicitly UTF8 string
//

typedef PSTR    PU8STR;


PSTR 
Dns_CreateStringCopy(
    IN      PCHAR           pchString,
    IN      DWORD           cchString
    );

DWORD
Dns_GetBufferLengthForStringCopy(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

DWORD
Dns_StringCopy(
    OUT     PBYTE           pBuffer,
    IN OUT  PDWORD          pdwBufLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

PVOID
Dns_StringCopyAllocate(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    );

#define Dns_StringCopyAllocate_W( p, c )  \
        ( (PWCHAR) Dns_StringCopyAllocate(  \
                    (PCHAR) (p),            \
                    (c),                    \
                    DnsCharSetUnicode,      \
                    DnsCharSetUnicode ) )

#define Dns_StringCopyAllocate_A( p, c )  \
        ( (PCHAR) Dns_StringCopyAllocate(   \
                    (p),                    \
                    (c),                    \
                    DnsCharSetUtf8,         \
                    DnsCharSetUtf8 ) )


PSTR
Dns_CreateStringCopy_A(
    IN      PCSTR           pwsString
    );

PWSTR
Dns_CreateStringCopy_W(
    IN      PCWSTR          pwsString
    );

PWSTR
Dns_CreateConcatenatedString_W(
    IN      PCWSTR *        pStringArray
    );

PWSTR 
Dns_GetResourceString(
    IN      DWORD           dwStringId,
    IN      PWSTR           pwszBuffer,
    IN      DWORD           cbBuffer
    );

INT
wcsicmp_ThatWorks(
    IN      PWSTR           pString1,
    IN      PWSTR           pString2
    );


//
//  Special DNS name string functions
//

#define Dns_GetBufferLengthForNameCopy(a,b,c,d)\
        Dns_GetBufferLengthForStringCopy((a),(b),(c),(d))

#define Dns_NameCopy(a,b,c,d,e,f) \
        Dns_StringCopy(a,b,c,d,e,f)

#define Dns_NameCopyAllocate(a,b,c,d) \
        Dns_StringCopyAllocate(a,b,c,d)



//
//  Name validation (string.c)
//

DNS_STATUS
Dns_ValidateName_UTF8(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    );

DNS_STATUS
Dns_ValidateName_W(
    IN      LPCWSTR         pwszName,
    IN      DNS_NAME_FORMAT Format
    );

DNS_STATUS
Dns_ValidateName_A(
    IN      LPCSTR          pszName,
    IN      DNS_NAME_FORMAT Format
    );


DNS_STATUS
Dns_ValidateDnsString_UTF8(
    IN      LPCSTR          pszName
    );

DNS_STATUS
Dns_ValidateDnsString_W(
    IN      LPCWSTR         pszName
    );

PSTR 
Dns_CreateStandardDnsNameCopy(
    IN      PCHAR           pchName,
    IN      DWORD           cchName,
    IN      DWORD           dwFlag
    );


//
//  UTF8 conversions (utf8.c)
//

DNS_STATUS
_fastcall
Dns_ValidateUtf8Byte(
    IN      BYTE            chUtf8,
    IN OUT  PDWORD          pdwTrailCount
    );

DWORD
_fastcall
Dns_UnicodeToUtf8(
    IN      PWCHAR          pwUnicode,
    IN      DWORD           cchUnicode,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    );

DWORD
_fastcall
Dns_Utf8ToUnicode(
    IN      PCHAR           pchUtf8,
    IN      DWORD           cchUtf8,
    OUT     PWCHAR          pwResult,
    IN      DWORD           cwResult
    );

DWORD
Dns_Utf8ToOrFromAnsi(
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult,
    IN      PCHAR           pchIn,
    IN      DWORD           cchIn,
    IN      DNS_CHARSET     InCharSet,
    IN      DNS_CHARSET     OutCharSet
    );

DWORD
Dns_AnsiToUtf8(
    IN      PCHAR           pchAnsi,
    IN      DWORD           cchAnsi,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    );

DWORD
Dns_Utf8ToAnsi(
    IN      PCHAR           pchUtf8,
    IN      DWORD           cchUtf8,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    );

BOOL
_fastcall
Dns_IsStringAscii(
    IN      PSTR            pszString
    );

BOOL
_fastcall
Dns_IsStringAsciiEx(
    IN      PCHAR           pchString,
    IN      DWORD           cchString
    );

BOOL
_fastcall
Dns_IsWideStringAscii(
    IN      PWSTR           pwsString
    );




//
//  Resource record dispatch tables
//
//  Resource record tables are indexed by type for standard types
//  These define limits on tables.
//
//  Currently indexing out to RR 40, so that we'll handle any new RR types
//  out this far without interfering with WINS stuff.
//

#define MAX_SELF_INDEXED_TYPE   (48)

//
//  Mappings for non-self indexed types
//
//  Note:  these are presented here for information purposes only!
//
//  Always call Dns_RecordTableIndexForType(wType) to get correct index.
//

#define TKEY_TYPE_INDEX         (MAX_SELF_INDEXED_TYPE + 1)
#define TSIG_TYPE_INDEX         (MAX_SELF_INDEXED_TYPE + 2)

#define WINS_TYPE_INDEX         (MAX_SELF_INDEXED_TYPE + 3)
#define WINSR_TYPE_INDEX        (MAX_SELF_INDEXED_TYPE + 4)

//  End of actual record types.
//  Query type indexes may extend beyond this index.

#define MAX_RECORD_TYPE_INDEX   (MAX_SELF_INDEXED_TYPE + 4)

//
//  Generic indexer for both regular and extended (non-self-indexing) types
//

#define INDEX_FOR_TYPE(type)    Dns_RecordTableIndexForType(type)


//
//  Type to index mapping
//

WORD
Dns_RecordTableIndexForType(
    IN      WORD            wType
    );


//
//  Generic print routine
//
//  All our print routines will take the real print routine
//  as a parameter.  This routine must have "sprintf-like"
//  or "fprintf-like" semantics.  In other words a context,
//  format and variable number of arguments.
//
//  Note the context argument is effectively a PVOID --
//  different routines will have different contexts.  The
//  explicit definition is to enforce strong type checking
//  so a call without a context is caught on compile.
//  

typedef struct _DnsPrintContext
{
    PVOID   pvDummy;
    DWORD   Dummy;
}
PRINT_CONTEXT, *PPRINT_CONTEXT;

typedef VOID (* PRINT_ROUTINE)(
                    PPRINT_CONTEXT,
                    CHAR*,
                    ... );



//
//  RnR utilities
//

DWORD
Dns_RnrLupFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_GetRnrLupFlagString(
    IN      DWORD           dwFlag
    );

DWORD
Dns_RnrNameSpaceIdForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    );

PCHAR
Dns_GetRnrNameSpaceIdString(
    IN      DWORD           dwFlag
    );


//
//  Hostent utilities
//

BOOL
Hostent_IsSupportedAddrType(
    IN      WORD            wType
    );

DWORD
Hostent_Size(
    IN      PHOSTENT        pHostent,
    IN      DNS_CHARSET     CharSetExisting,
    IN      DNS_CHARSET     CharSetTarget,
    IN      PDWORD          pAliasCount,
    IN      PDWORD          pAddrCount
    );

PHOSTENT
Hostent_Copy(
    IN OUT  PBYTE *         ppBuffer,
    IN OUT  PINT            pBufferSize,
    OUT     PINT            pHostentSize,
    IN      PHOSTENT        pHostent,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetTarget,
    IN      BOOL            fOffsets,
    IN      BOOL            fAlloc
    );

DWORD
Hostent_WriteIp4Addrs(
    IN OUT  PHOSTENT        pHostent,
    OUT     PCHAR           pAddrBuf,
    IN      DWORD           MaxBufCount,
    IN      PIP4_ADDRESS    Ip4Array,
    IN      DWORD           ArrayCount,
    IN      BOOL            fScreenZero
    );

DWORD
Hostent_WriteLocalIp4Array(
    IN OUT  PHOSTENT        pHostent,
    OUT     PCHAR           pAddrBuf,
    IN      DWORD           MaxBufCount,
    IN      PIP4_ARRAY      pIpArray
    );

BOOL
Hostent_IsAddressInHostent(
    IN OUT  PHOSTENT        pHostent,
    IN      PCHAR           pAddr,
    IN      DWORD           AddrLength,
    IN      INT             Family          OPTIONAL
    );

BOOL
Hostent_IsIp4AddressInHostent(
    IN OUT  PHOSTENT        pHostent,
    IN      IP4_ADDRESS     Ip4Addr
    );


//
//  Hostent Object
//

typedef struct _HostentBlob
{
    PHOSTENT    pHostent;

    //  flags
    BOOL        fAllocatedBlob;
    BOOL        fAllocatedBuf;

    //  buffer allocated
    PCHAR       pBuffer;
    DWORD       BufferLength;

    DWORD       AvailLength;
    PCHAR       pAvailBuffer;

    //  buffer in build
    PCHAR       pCurrent;
    DWORD       BytesLeft;

    //  sizing info
    DWORD       MaxAliasCount;
    DWORD       MaxAddrCount;

    //  hostent building
    DWORD       AliasCount;
    DWORD       AddrCount;
    BOOL        fWroteName;
    DNS_CHARSET CharSet;
    BOOL        fUnicode;
}
HOSTENT_BLOB, *PHOSTENT_BLOB;


typedef struct _HostentInitRequest
{
    INT         AddrFamily;
    WORD        wType;
    DWORD       AddrCount;
    BOOL        fUnicode;
    DNS_CHARSET CharSet;
    DWORD       NameLength;
    PBYTE       pName;
    DWORD       AliasCount;
    DWORD       AliasNameLength;
}
HOSTENT_INIT, *PHOSTENT_INIT;


DNS_STATUS
HostentBlob_Create(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      PHOSTENT_INIT   pReq
    );

PHOSTENT_BLOB
HostentBlob_CreateAttachExisting(
    IN      PHOSTENT        pHostent,
    IN      BOOL            fUnicode
    );

VOID
HostentBlob_Free(
    IN OUT  PHOSTENT_BLOB   pBlob
    );

DNS_STATUS
HostentBlob_WriteAddress(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PVOID           pAddress,
    IN      DWORD           AddrSize,
    IN      DWORD           AddrType
    );

DNS_STATUS
HostentBlob_WriteAddressArray(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PVOID           pAddrArray,
    IN      DWORD           AddrCount,
    IN      DWORD           AddrSize,
    IN      DWORD           AddrType
    );

DNS_STATUS
HostentBlob_WriteNameOrAlias(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PSTR            pszName,
    IN      BOOL            fAlias,
    IN      BOOL            fUnicode
    );

DNS_STATUS
HostentBlob_WriteRecords(
    IN OUT  PHOSTENT_BLOB   pBlob,
    IN      PDNS_RECORD     pRecords,
    IN      BOOL            fWriteName
    );

//  Special hostents

PHOSTENT_BLOB
Hostent_Localhost(
    IN      INT             AddrFamily
    );

DNS_STATUS
HostentBlob_CreateFromIpArray(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      INT             AddrFamily,
    IN      INT             AddrSize,
    IN      INT             AddrCount,
    IN      PCHAR           pArray,
    IN      PSTR            pName,
    IN      BOOL            fUnicode
    );

DNS_STATUS
HostentBlob_CreateLocal(
    IN OUT  PHOSTENT_BLOB * ppBlob,
    IN      INT             AddrFamily,
    IN      BOOL            fLoopback,
    IN      BOOL            fZero,
    IN      BOOL            fHostnameOnly
    );

//  Query for hostent

PHOSTENT_BLOB
HostentBlob_Query(
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags,
    IN OUT  PVOID *         ppMsg,      OPTIONAL
    IN      INT             AddrFamily  OPTIONAL
    );



//
//  Memory allocation
//
//  Some DNS library functions -- including the IP array and string utils
//  -- allocate memory.  This memory allocation defaults to routines that
//  use LocalAlloc, LocalReAlloc, LocalFree.  If you desire alternative
//  memory allocation mechanisms, use this function to override the DNS
//  library defaults.  All memory allocated by the DNS library, should
//  then be freed by the corresponding function.
//

typedef PVOID   (* DNSLIB_ALLOC_FUNCTION)();
typedef PVOID   (* DNSLIB_REALLOC_FUNCTION)();
typedef VOID    (* DNSLIB_FREE_FUNCTION)();

VOID
Dns_LibHeapReset(
    IN      DNSLIB_ALLOC_FUNCTION   pAlloc,
    IN      DNSLIB_REALLOC_FUNCTION pRealloc,
    IN      DNSLIB_FREE_FUNCTION    pFree
    );

//
//  These routines call the currently registered allocation functions
//  whether default or reset through Dns_ApiHeapReset()
//

PVOID
Dns_Alloc(
    IN      INT             iSize
    );

PVOID
Dns_AllocZero(
    IN      INT             iSize
    );

PVOID
Dns_Realloc(
    IN OUT  PVOID           pMem,
    IN      INT             iSize
    );

VOID
Dns_Free(
    IN OUT  PVOID           pMem
    );

PVOID
Dns_AllocMemCopy(
    IN      PVOID           pMem,
    IN      INT             iSize
    );



//
//  Print routines (print.c)
//
//  Print routines below use any printf() like function to print.
//  this is typedef that function must match.
//

//
//  Print Locking
//

VOID
DnsPrint_InitLocking(
    IN      PCRITICAL_SECTION   pLock
    );

VOID
DnsPrint_Lock(
    VOID
    );

VOID
DnsPrint_Unlock(
    VOID
    );

#define Dns_PrintInitLocking(a)     DnsPrint_InitLocking(a)
#define Dns_PrintLock()             DnsPrint_Lock()
#define Dns_PrintUnlock()           DnsPrint_Unlock()

//
//  Print routines for general types and structures
//

VOID
DnsPrint_String(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,      OPTIONAL
    IN      PSTR            pszString,
    IN      BOOL            fUnicode,
    IN      PSTR            pszTrailer      OPTIONAL
    );

VOID
DnsPrint_StringCharSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,      OPTIONAL
    IN      PSTR            pszString,
    IN      DNS_CHARSET     CharSet,
    IN      PSTR            pszTrailer      OPTIONAL
    );

VOID
DnsPrint_Utf8StringBytes(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PCHAR           pUtf8,
    IN      DWORD           Length
    );

VOID
DnsPrint_UnicodeStringBytes(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PWCHAR          pUnicode,
    IN      DWORD           Length
    );

VOID
DnsPrint_StringArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR *          StringArray,
    IN      DWORD           Count,          OPTIONAL
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_Argv(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      CHAR **         Argv,
    IN      DWORD           Argc,            OPTIONAL
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_DwordArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      DWORD           dwCount,
    IN      PDWORD          adwArray
    );

VOID
DnsPrint_Ip4AddressArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      DWORD           dwIpAddrCount,
    IN      PIP4_ADDRESS    pIpAddrs
    );

VOID
DnsPrint_Ip4Array(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      PIP4_ARRAY      pIpArray
    );

VOID
DnsPrint_Ip6Address(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PIP6_ADDRESS    pIp6Address,
    IN      PSTR            pszTrailer
    );

VOID
DnsPrint_Ip6Array(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      PIP6_ARRAY      pIpArray
    );

VOID
DnsPrint_Guid(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PGUID           pGuid
    );

//
//  Winsock \ RnR types and structures
//

VOID
DnsPrint_FdSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      struct fd_set * pFdSet
    );

VOID
DnsPrint_Hostent(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PHOSTENT        pHostent,
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_Sockaddr(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PSOCKADDR       pSockaddr,
    IN      INT             iSockaddrLength
    );

VOID
DnsPrint_SockaddrBlob(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PSOCKADDR_BLOB  pSockaddrBlob
    );

#ifdef  _WINSOCK2API_
VOID
DnsPrint_SocketAddress(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PSOCKET_ADDRESS pSocketAddress
    );

VOID
DnsPrint_CsAddr(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PCSADDR_INFO    pCsAddrInfo
    );

VOID
DnsPrint_AfProtocolsArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PAFPROTOCOLS    pProtocolArray,
    IN      DWORD           ProtocolCount
    );

VOID
DnsPrint_WsaQuerySet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      LPWSAQUERYSET   pQuerySet,
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_WsaNsClassInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PWSANSCLASSINFO pInfo,
    IN      BOOL            fUnicode
    );

VOID
DnsPrint_WsaServiceClassInfo(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pContext,
    IN      PSTR                    pszHeader,
    IN      LPWSASERVICECLASSINFO   pInfo,
    IN      BOOL                    fUnicode
    );
#endif

#ifdef  _WS2TCPIP_H_
VOID
DnsPrint_AddrInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PADDRINFO       pAddrInfo
    );

VOID
DnsPrint_AddrInfoList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PADDRINFO       pAddrInfo
    );
#endif


#ifdef  IP_TYPES_INCLUDED
VOID
DnsPrint_IpAdapterAddress(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pContext,
    IN      PSTR                    pszHeader,
    IN      PVOID                   pAddr,
    IN      BOOL                    fUnicast,
    IN      BOOL                    fPrintList
    );

VOID
DnsPrint_IpAdapterList(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pContext,
    IN      PSTR                    pszHeader,
    IN      PIP_ADAPTER_ADDRESSES   pAdapt,
    IN      BOOL                    fPrintAddressLists,
    IN      BOOL                    fPrintList
    );
#endif


//
//  Print routines for DNS types and structures
//

VOID
DnsPrint_Message(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_MSG_BUF    pMsg
    );

VOID
DnsPrint_MessageNoContext(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_HEADER     pMsgHead,
    IN      WORD            wLength
    );

INT
DnsPrint_PacketName(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,      OPTIONAL
    IN      PBYTE           pMsgName,
    IN      PDNS_HEADER     pMsgHead,       OPTIONAL
    IN      PBYTE           pMsgEnd,        OPTIONAL
    IN      PSTR            pszTrailer      OPTIONAL
    );

INT
DnsPrint_PacketRecord(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_WIRE_RECORD    pMsgRR,
    IN      PDNS_HEADER         pMsgHead,       OPTIONAL
    IN      PBYTE               pMsgEnd         OPTIONAL
    );

VOID
DnsPrint_ParsedRecord(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_PARSED_RR  pParsedRR
    );

VOID
DnsPrint_RawOctets(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszLineHeader,
    IN      PCHAR           pchData,
    IN      DWORD           dwLength
    );

VOID
DnsPrint_ParsedMessage(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_PARSED_MESSAGE pParsed
    );

VOID
DnsPrint_HostentBlob(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PHOSTENT_BLOB   pBlob
    );



//
//  Print to string
//

#define GUID_STRING_BUFFER_LENGTH   (80)

DWORD
DnsStringPrint_Guid(
    OUT     PCHAR           pBuffer,
    IN      PGUID           pGuid
    );

DWORD
DnsStringPrint_RawOctets(
    OUT     PCHAR           pBuffer,
    IN      PCHAR           pchData,
    IN      DWORD           dwLength,
    IN      PSTR            pszLineHeader,
    IN      DWORD           dwLineLength
    );

//
//  Print related utilities
//

INT
Dns_WriteFormattedSystemTimeToBuffer(
    OUT     PCHAR           pBuffer,
    IN      PSYSTEMTIME     pSystemTime
    );

INT
Dns_WritePacketNameToBuffer(
    OUT     PCHAR           pBuffer,
    OUT     PCHAR *         ppBufferOut,
    IN      PBYTE           pMsgName,
    IN      PDNS_HEADER     pMsgHead,       OPTIONAL
    IN      PBYTE           pMsgEnd         OPTIONAL
    );

PCHAR
Dns_ResponseCodeString(
    IN      INT     ResponseCode
    );

PCHAR
Dns_ResponseCodeExplanationString(
    IN      INT     ResponseCode
    );

PCHAR
Dns_KeyFlagString(
    IN OUT      PCHAR   pszBuff,
    IN          WORD    flags
    );

PCHAR
Dns_OpcodeString(
    IN      INT     Opcode
    );

CHAR
Dns_OpcodeCharacter(
    IN      INT     Opcode
    );

PCHAR
Dns_SectionNameString(
    IN      INT     iSection,
    IN      INT     iOpcode
    );

//
//  Record printing (rrprint.c)
//

VOID
DnsPrint_Record(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_RECORD     pRecord,
    IN      PDNS_RECORD     pPreviousRecord     OPTIONAL
    );

VOID
DnsPrint_RecordSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_RECORD     pRecord
    );

//
//  Macros to get correct string type (utf8\unicode) for printing.
//

//  Empty string for simple switching of UTF-8/Unicode print

extern DWORD   DnsEmptyString;

#define pDnsEmptyString         ( (PSTR) &DnsEmptyString )
#define pDnsEmptyWideString     ( (PWSTR) &DnsEmptyString )


#define DNSSTRING_UTF8( fUnicode, String ) \
        ( (fUnicode) ? pDnsEmptyString : (PSTR)(String) )

#define DNSSTRING_ANSI( fUnicode, String ) \
        ( (fUnicode) ? pDnsEmptyString : (PSTR)(String) )

#define DNSSTRING_WIDE( fUnicode, String ) \
        ( (fUnicode) ? (PWSTR)(String) : pDnsEmptyWideString )

#define RECSTRING_UTF8( pRR, String ) \
        DNSSTRING_UTF8( IS_UNICODE_RECORD(pRR), (String) )

#define RECSTRING_WIDE( pRR, String ) \
        DNSSTRING_WIDE( IS_UNICODE_RECORD(pRR), (String) )


#define PRINT_STRING_WIDE_CHARSET( String, CharSet ) \
        ( ((CharSet)==DnsCharSetUnicode) ? (PWSTR)(String) : pDnsEmptyWideString )

#define PRINT_STRING_ANSI_CHARSET( String, CharSet ) \
        ( ((CharSet)==DnsCharSetUnicode) ? pDnsEmptyString : (PSTR)(String) )



//
//  Debugging
//
//  Debug routines.
//

VOID
Dns_StartDebugEx(
    IN      DWORD           DebugFlag,
    IN      PSTR            pszFlagFile,
    IN OUT  PDWORD          pdwExternalFlag,
    IN      PSTR            pszLogFile,
    IN      DWORD           WrapSize,
    IN      BOOL            fUseGlobalFile,
    IN      BOOL            fUseGlobalFlag,
    IN      BOOL            fSetGlobals
    );

VOID
Dns_StartDebug(
    IN      DWORD           DebugFlag,
    IN      PSTR            pszFlagFile,
    IN OUT  PDWORD          pdwExternalFlag,
    IN      PSTR            pszLogFile,
    IN      DWORD           WrapSize
    );

VOID
Dns_EndDebug(
    VOID
    );

VOID
Dns_Assert(
    IN      PSTR            pszFile,
    IN      INT             LineNo,
    IN      PSTR            pszExpr
    );

VOID
DnsDbg_PrintfToDebugger(
    IN      PSTR            Format,
    ...
    );

VOID
DnsDbg_Printf(
    IN      PSTR            Format,
    ...
    );

VOID
DnsDbg_PrintRoutine(
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            Format,
    ...
    );

VOID
DnsDbg_Flush(
    VOID
    );

VOID
DnsDbg_WrapLogFile(
    VOID
    );

VOID
DnsDbg_CSEnter(
    IN      PCRITICAL_SECTION   pLock,
    IN      PSTR                pszLockName,
    IN      PSTR                pszFile,
    IN      INT                 LineNo
    );

VOID
DnsDbg_CSLeave(
    IN      PCRITICAL_SECTION   pLock,
    IN      PSTR                pszLockName,
    IN      PSTR                pszFile,
    IN      INT                 LineNo
    );



//
//  Debug flag test
//
//  We make the test against a pointer here which allows library
//  client application to point at a flag that may be dynamically
//  reset.
//

extern  PDWORD  pDnsDebugFlag;
#define IS_DNSDBG_ON(flag)      (*pDnsDebugFlag & DNS_DBG_ ## flag)


//
//  Debugging Bit Flags
//
//  These flags control gross output and are the same for all users
//

#define DNS_DBG_BREAKPOINTS     0x00000001
#define DNS_DBG_DEBUGGER        0x00000002
#define DNS_DBG_FILE            0x00000004
#define DNS_DBG_EVENTLOG        0x00000008
#define DNS_DBG_EXCEPT          0x00000008

#define DNS_DBG_TIMESTAMP       0x10000000
#define DNS_DBG_CONSOLE         0x20000000
#define DNS_DBG_START_BREAK     0x40000000
#define DNS_DBG_FLUSH           0x80000000

#define DNS_DBG_ANY             0xffffffff
#define DNS_DBG_ALL             0xffffffff
#define DNS_DBG_OFF             (0x0)

//
//  Flags specific to library
//

#define DNS_DBG_IPARRAY         0x00000020
#define DNS_DBG_INIT            0x00000040
#define DNS_DBG_REGISTRY        0x00000040
#define DNS_DBG_SOCKET          0x00000040
#define DNS_DBG_WRITE           0x00000080
#define DNS_DBG_READ            0x00000080

#define DNS_DBG_RPC             0x00000100
#define DNS_DBG_STUB            0x00000100
#define DNS_DBG_RECV            0x00000200
#define DNS_DBG_SEND            0x00000400
#define DNS_DBG_TCP             0x00000800

#define DNS_DBG_TRACE           0x00001000
#define DNS_DBG_HOSTENT         0x00001000
#define DNS_DBG_UPDATE          0x00002000
#define DNS_DBG_SECURITY        0x00004000
#define DNS_DBG_QUERY           0x00008000

#define DNS_DBG_HEAP            0x00010000
#define DNS_DBG_HEAPDBG         0x00020000
#define DNS_DBG_NETINFO         0x00040000
#define DNS_DBG_RNR             0x00080000

//
//  High output detail debugging
//

#define DNS_DBG_RECURSE2        0x00100000
#define DNS_DBG_UPDATE2         0x00200000
#define DNS_DBG_SECURITY2       0x00400000

#define DNS_DBG_RPC2            0x01000000
#define DNS_DBG_STUB2           0x01000000
#define DNS_DBG_INIT2           0x01000000
#define DNS_DBG_NETINFO2        0x01000000
#define DNS_DBG_PARSE2          0x01000000
#define DNS_DBG_LOOKUP2         0x02000000
#define DNS_DBG_WRITE2          0x04000000
#define DNS_DBG_READ2           0x04000000
#define DNS_DBG_LOCK            0x08000000
#define DNS_DBG_LOCKS           0x08000000
#define DNS_DBG_STRING          0x10000000

#define DNS_DBG_HEAP2           0x10000000
#define DNS_DBG_HEAP_CHECK      0x10000000




//
//  Debug macros
//
//  Macros that include debug code in debug versions only,
//  these macro are NULL for retail versions.
//

#if DBG

#define STATIC

#define DNS_PRINT(_a_)          ( DnsDbg_Printf _a_ )

#define DnsPrintfPtrToFunc      DnsDbg_PrintRoutine

#define IF_DNSDBG(flag)         if ( IS_DNSDBG_ON(flag) )
#define ELSE_IF_DNSDBG(flag)    else if ( IS_DNSDBG_ON(flag) )
#define ELSE                    else

#define DNSDBG(flag, _printlist_)   \
        IF_DNSDBG( flag )           \
        {                           \
            ( DnsDbg_Printf _printlist_ ); \
        }

//  protect debug prints with print lock

#define DnsDbg_Lock()           DnsPrint_Lock()
#define DnsDbg_Unlock()         DnsPrint_Unlock()


//
//  Probe
//

#define PROBE(p)    (*p)

//
//  Assert Macros
//

#define DNS_ASSERT( expr )  \
{                       \
    if ( !(expr) )      \
    {                   \
        Dns_Assert( __FILE__, __LINE__, # expr );    \
    }                   \
}

#define TEST_ASSERT( expr )     DNS_ASSERT( expr )

#define FAIL( msg )                         \
{                                           \
    DNS_PRINT(( "FAILURE:  %s\n", msg ));   \
    DNS_ASSERT( FALSE );                    \
}


//
//  Asserts on trailing else
//

#define ELSE_ASSERT( expr ) \
            else                \
            {                   \
                DNS_ASSERT( expr ); \
            }

#define ELSE_ASSERT_FALSE \
            else                \
            {                   \
                DNS_ASSERT( FALSE );\
            }

#define ELSE_FAIL( msg ) \
            else                \
            {                   \
                FAIL( msg );    \
            }

//
//  Assert and print message
//

#define DNS_MSG_ASSERT( pMsg, expr )  \
{                       \
    if ( !(expr) )      \
    {                   \
        debug_MessageBuffer( "FAILED MESSAGE:", (pMsg) ); \
        Dns_Assert( __FILE__, __LINE__, # expr );    \
    }                   \
}


//
//  Debug types and structures
//

#define DnsPR   DnsDbg_PrintRoutine

#define DnsDbg_String(a,b,c,d)              DnsPrint_String(DnsPR,NULL,a,b,c,d)
#define DnsDbg_UnicodeStringBytes(a,b,c)    DnsPrint_UnicodeStringBytes(DnsPR,NULL,a,b,c)
#define DnsDbg_Utf8StringBytes(a,b,c)       DnsPrint_Utf8StringBytes(DnsPR,NULL,a,b,c)
#define DnsDbg_StringArray(a,b,c,d)         DnsPrint_StringArray(DnsPR,NULL,a,b,c,d)
#define DnsDbg_Argv(a,b,c,d)                DnsPrint_Argv(DnsPR,NULL,a,b,c,d)
#define DnsDbg_DwordArray(a,b,c,d)          DnsPrint_DwordArray(DnsPR,NULL,a,b,c,d)
#define DnsDbg_Ip4AddressArray(a,b,c,d)     DnsPrint_Ip4AddressArray(DnsPR,NULL,a,b,c,d)
#define DnsDbg_Ip4Array(a,b,c)              DnsPrint_Ip4Array(DnsPR,NULL,a,b,c)
#define DnsDbg_Ip6Address(a,b,c)            DnsPrint_Ip6Address(DnsPR,NULL,a,b,c)
#define DnsDbg_Ip6Array(a,b,c)              DnsPrint_Ip6Array(DnsPR,NULL,a,b,c)
#define DnsDbg_Guid(a,b)                    DnsPrint_Guid(DnsPR,NULL,a,b)

#define DnsDbg_FdSet(a,b)                   DnsPrint_FdSet(DnsPR,NULL,a,b)
#define DnsDbg_Sockaddr(a,b,c)              DnsPrint_Sockaddr(DnsPR,NULL,a,0,b,c)
#define DnsDbg_SockaddrBlob(a,b)            DnsPrint_SockaddrBlob(DnsPR,NULL,a,0,b)
#define DnsDbg_SocketAddress(a,b)           DnsPrint_SocketAddress(DnsPR,NULL,a,0,b)
#define DnsDbg_CsAddr(a,b)                  DnsPrint_CsAddr(DnsPR,NULL,a,0,b)
#define DnsDbg_AfProtocolsArray(a,b,c)      DnsPrint_AfProtocolsArray(DnsPR,NULL,a,b,c)
#define DnsDbg_WsaQuerySet(a,b,c)           DnsPrint_WsaQuerySet(DnsPR,NULL,a,b,c)
#define DnsDbg_WsaNsClassInfo(a,b,c)        DnsPrint_WsaNsClassInfo(DnsPR,NULL,a,b,c)
#define DnsDbg_WsaServiceClassInfo(a,b,c)   DnsPrint_WsaServiceClassInfo(DnsPR,NULL,a,b,c)
#define DnsDbg_Hostent(a,b,c)               DnsPrint_Hostent(DnsPR,NULL,a,b,c)
#define DnsDbg_AddrInfo(a,b)                DnsPrint_AddrInfo(DnsPR,NULL,a,0,b)
#define DnsDbg_HostentBlob(a,b)             DnsPrint_HostentBlob(DnsPR,NULL,a,b)
#define DnsDbg_IpAdapterAddress(a,b,c,d)    DnsPrint_IpAdapterAddress(DnsPR,NULL,a,b,c,d)
#define DnsDbg_IpAdapterList(a,b,c,d)       DnsPrint_IpAdapterList(DnsPR,NULL,a,b,c,d)

#define DnsDbg_DnsMessage(a,b)              DnsPrint_DnsMessage(DnsPR,NULL,a,b)
#define DnsDbg_Message(a,b)                 DnsPrint_Message(DnsPR,NULL,a,b)
#define DnsDbg_MessageNoContext(a,b,c)      DnsPrint_MessageNoContext(DnsPR,NULL,a,b,c)
#define DnsDbg_Compression(a,b)             DnsPrint_Compression(DnsPR,NULL,a,b)
#define DnsDbg_PacketRecord(a,b,c,d)        DnsPrint_PacketRecord(DnsPR,NULL,a,b,c,d)
#define DnsDbg_PacketName(a,b,c,d,e)        DnsPrint_PacketName(DnsPR,NULL,a,b,c,d,e)
#define DnsDbg_ParsedMessage(a,b)           DnsPrint_ParsedMessage(DnsPR,NULL,(a),(b))

#define DnsDbg_RawOctets(a,b,c,d)           DnsPrint_RawOctets(DnsPR,NULL,a,b,c,d)
#define DnsDbg_Record(a,b)                  DnsPrint_Record(DnsPR,NULL,a,b,NULL)
#define DnsDbg_RecordSet(a,b)               DnsPrint_RecordSet(DnsPR,NULL,a,b)

//  backcompat special on sockaddr

#define DnsDbg_SockaddrIn(a,b,c)            DnsPrint_Sockaddr(DnsPR,NULL,a,0,(PSOCKADDR)b,c)



//
//  Non-Debug
//

#else

#define STATIC static

//
//  Define away debugging operations
//

#define IF_DNSDBG(a)                if (0)
#define ELSE_IF_DNSDBG(a)           if (0)
#define ELSE                        if (0)
#define DNSDBG(flag, _printlist_)
#define DNS_PRINT(_printlist_)

#define DnsDbg_Lock()
#define DnsDbg_Unlock()

#define DnsDbg_CSEnter(a,b,c,d)
#define DnsDbg_CSLeave(a,b,c,d)

#define DnsDbg_String(a,b,c,d)          
#define DnsDbg_UnicodeStringBytes(a,b,c)
#define DnsDbg_Utf8StringBytes(a,b,c)   
#define DnsDbg_DwordArray(a,b,c,d)      
#define DnsDbg_StringArray(a,b,c,d)
#define DnsDbg_Argv(a,b,c,d)            
#define DnsDbg_Ip4AddressArray(a,b,c,d)
#define DnsDbg_Ip4Array(a,b,c)
#define DnsDbg_Ip6Address(a,b,c)
#define DnsDbg_Ip6Array(a,b,c)
#define DnsDbg_Guid(a,b)

#define DnsDbg_FdSet(a,b)               
#define DnsDbg_Sockaddr(a,b,c)          
#define DnsDbg_SockaddrBlob(a,b)
#define DnsDbg_SocketAddress(a,b)       
#define DnsDbg_CsAddr(a,b)              
#define DnsDbg_AfProtocolsArray(a,b,c)
#define DnsDbg_WsaQuerySet(a,b,c)       
#define DnsDbg_WsaNsClassInfo(a,b,c)
#define DnsDbg_WsaServiceClassInfo(a,b,c)
#define DnsDbg_Hostent(a,b,c)       
#define DnsDbg_AddrInfo(a,b)
#define DnsDbg_HostentBlob(a,b)
#define DnsDbg_IpAdapterAddress(a,b,c,d)
#define DnsDbg_IpAdapterList(a,b,c,d)

#define DnsDbg_DnsMessage(a,b)          
#define DnsDbg_Message(a,b)             
#define DnsDbg_MessageNoContext(a,b,c)  
#define DnsDbg_Compression(a,b)         
#define DnsDbg_PacketRecord(a,b,c,d)    
#define DnsDbg_PacketName(a,b,c,d,e)    
#define DnsDbg_ParsedMessage(a,b)

#define DnsDbg_RawOctets(a,b,c,d)       
#define DnsDbg_Record(a,b)              
#define DnsDbg_RecordSet(a,b)           


//  backcompat special on sockaddr

#define DnsDbg_SockaddrIn(a,b,c)        

//
//  Handle complilation of DnsPrintf used as passed parameter to
//  print routines
//

#define DnsPrintfPtrToFunc  printf

//
//  Eliminate ASSERTs in retail product
//

#define DNS_ASSERT( expr )
#define TEST_ASSERT( expr )
#define ELSE_ASSERT( expr )
#define ELSE_ASSERT_FALSE
#define DNS_MSG_ASSERT( expr, pMsg )

#define FAIL( msg )
#define ELSE_FAIL( msg )

#define PROBE(p)

#endif // non-DBG



#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSLIB_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\inc\domainlistparser.h ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    domainlistparser.h

ABSTRACT:

    This is the header for the globally useful data structures for the domainlist parser.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/



// Domainlistparser.h: interface for the MyContent class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _DOMAINLISTPARSER_H
#define _DOMAINLISTPARSER_H


/************************************************************************
*
*  State machine description for state file.
*
*
* sample:
* <Forest>
*	<Domain>
*		<Guid>8b5943dd-1dd6-48b9-874d-9ec640a59740</Guid>
*		<DNSname>mydomain.nttest.microsoft.com</DNSname>
*		<NetBiosName>mydomain</NetBiosName>
*		<DcName>mydc.mydomain.nttest.microsoft.com</DcName>
*	</Domain>
* </Forest>
*  
*
* Two states in this machine
* CurrentDcAttribute
* CurrentDcParsingStatus
*
* At the start:
* CurrentDcAttribute = DOMAIN_ATT_TYPE_NONE
* CurrentDcParsingStatus = SCRIPT_STATUS_WAITING_FOR_FOREST
*
* At Forest start:
* CurrentDcParsingStatus = SCRIPT_STATUS_WAITING_FOR_DOMAIN
*
* At Domain start:
* CurrentDcParsingStatus = SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT
* At Domain end:
* CurrentDcParsingStatus = SCRIPT_STATUS_WAITING_FOR_DOMAIN
* Action: Record Domain
*
* At [Guid|DNSname|NetBiosName|NetBiosName] start:
* CurrentDcParsingStatus = SCRIPT_STATUS_PARSING_DOMAIN_ATT
* CurrentDcAttribute = DOMAIN_ATT_TYPE_[Guid|DNSname|NetBiosName|NetBiosName]
* Action: Record [Guid|DNSname|NetBiosName|NetBiosName]
* At [Guid|DNSname|NetBiosName|NetBiosName] end:
* CurrentDcParsingStatus = SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT
* CurrentDcAttribute = DOMAIN_ATT_TYPE_NONE
*
*************************************************************************/

//#include "rendom.h"
#include "SAXContentHandlerImpl.h"

#define DOMAINSCRIPT_FOREST           L"Forest"
#define DOMAINSCRIPT_DOMAIN           L"Domain"
#define DOMAINSCRIPT_GUID             L"Guid"
#define DOMAINSCRIPT_DNSROOT          L"DNSname"
#define DOMAINSCRIPT_NETBIOSNAME      L"NetBiosName"
#define DOMAINSCRIPT_DCNAME           L"DcName"

// These are only need for testing the rendom.exe util
#define DOMAINSCRIPT_ENTERPRISE_INFO  L"EnterpriseInfo"
#define DOMAINSCRIPT_CONFIGNC         L"ConfigurationNC"
#define DOMAINSCRIPT_SCHEMANC         L"SchemaNC"
#define DOMAINSCRIPT_DN               L"DN"
#define DOMAINSCRIPT_SID              L"SID"
#define DOMAINSCRIPT_FORESTROOT       L"ForestRootGuid"


//
// NTDSContent
//
// Implements the SAX Handler interface
// 
class CXMLDomainListContentHander : public SAXContentHandlerImpl  
{
public:
    enum DomainAttType {

        DOMAIN_ATT_TYPE_NONE = 0,
        DOMAIN_ATT_TYPE_GUID,
        DOMAIN_ATT_TYPE_DNSROOT,
        DOMAIN_ATT_TYPE_NETBIOSNAME,
        DOMAIN_ATT_TYPE_DCNAME,
        DOMAIN_ATT_TYPE_SID,
        DOMAIN_ATT_TYPE_DN,
        DOMAIN_ATT_TYPE_FORESTROOTGUID,
        
    };
    
    // the order of the enumeration is important
    enum DomainParsingStatus {

        SCRIPT_STATUS_WAITING_FOR_FOREST = 0,
        SCRIPT_STATUS_WAITING_FOR_DOMAIN,
        SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT,
        SCRIPT_STATUS_PARSING_DOMAIN_ATT,
        SCRIPT_STATUS_WAITING_FOR_ENTERPRISE_INFO,
        SCRIPT_STATUS_PARSING_CONFIGURATION_NC,
        SCRIPT_STATUS_PARSING_SCHEMA_NC,
        SCRIPT_STATUS_PARSING_FOREST_ROOT_GUID

    };

    CXMLDomainListContentHander(CEnterprise *p_Enterprise);
    virtual ~CXMLDomainListContentHander();
    
    virtual HRESULT STDMETHODCALLTYPE startElement( 
        /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
        /* [in] */ int cchNamespaceUri,
        /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
        /* [in] */ int cchLocalName,
        /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
        /* [in] */ int cchRawName,
        /* [in] */ ISAXAttributes __RPC_FAR *pAttributes);
    
    virtual HRESULT STDMETHODCALLTYPE endElement( 
        /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
        /* [in] */ int cchNamespaceUri,
        /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
        /* [in] */ int cchLocalName,
        /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
        /* [in] */ int cchRawName);

    virtual HRESULT STDMETHODCALLTYPE startDocument();

    virtual HRESULT STDMETHODCALLTYPE characters( 
        /* [in] */ const wchar_t __RPC_FAR *pwchChars,
        /* [in] */ int cchChars);

private:

    inline
    DomainParsingStatus 
    CurrentDomainParsingStatus() {return m_eDomainParsingStatus;}

    inline
    DomainAttType
    CurrentDomainAttType()       {return m_eDomainAttType;}

    inline
    VOID
    SetDomainParsingStatus(DomainParsingStatus p_status) {m_eDomainParsingStatus = p_status;}

    inline
    VOID
    SetCurrentDomainAttType(DomainAttType p_AttType) {m_eDomainAttType = p_AttType;}

    DomainParsingStatus           m_eDomainParsingStatus; 
    DomainAttType                 m_eDomainAttType;
                                
    CEnterprise                  *m_enterprise;
    CDomain                      *m_Domain;
    CRenDomErr                   m_Error;
    CDsName                      *m_DsName;
    CDsName                      *m_CrossRef;
    CDsName                      *m_ConfigNC;
    CDsName                      *m_SchemaNC;
                                
    WCHAR                        *m_DcToUse;
    WCHAR                        *m_NetBiosName;
    WCHAR                        *m_Dnsname;
    WCHAR                        *m_Guid;
    WCHAR                        *m_Sid;
    WCHAR                        *m_DN;
    WCHAR                        *m_DomainRootGuid;
    
};

#endif // _DOMAINLISTPARSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\inc\renutil.h ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    renutil.h

ABSTRACT:

    This is the header for the globally useful data structures for the entire
    rendom.exe utility.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/

 
#ifndef RENUTIL_H
#define RENUTIL_H

#define NELEMENTS(x) (sizeof(x)/sizeof((x)[0]))

VOID
AddModOrAdd(
    IN PWCHAR  AttrType,
    IN LPCWSTR  AttrValue,
    IN ULONG  mod_op,
    IN OUT LDAPModW ***pppMod
    );

VOID
AddModMod(
    IN PWCHAR  AttrType,
    IN LPCWSTR  AttrValue,
    IN OUT LDAPMod ***pppMod
    );

VOID
FreeMod(
    IN OUT LDAPMod ***pppMod
    );

ULONG 
RemoveRootofDn(
    IN WCHAR *DN
    );

ULONG
ReplaceRDN(
    IN OUT WCHAR *DNprefix,
    IN WCHAR *Witardn
    );

DWORD
GetRDNWithoutType(
       WCHAR *pDNSrc,
       WCHAR **pDNDst
       );

DWORD
TrimDNBy(
       WCHAR *pDNSrc,
       ULONG cava,
       WCHAR **pDNDst
       );

INT
GetPassword(
    WCHAR *     pwszBuf,
    DWORD       cchBufMax,
    DWORD *     pcchBufUsed
    );

int
PreProcessGlobalParams(
    IN OUT    INT *    pargc,
    IN OUT    LPWSTR** pargv,
    SEC_WINNT_AUTH_IDENTITY_W *& gpCreds      
    );

WCHAR *
Convert2WChars(
    char * pszStr
    );

CHAR * 
Convert2Chars(
    LPCWSTR lpWideCharStr
    );

BOOLEAN
ValidateNetbiosName(
    IN  PWSTR Name
    );

WCHAR* 
Tail(
    IN WCHAR *DnsName ,
    IN BOOL  Allocate = TRUE
    );

BOOL 
WINAPI 
RendomHandlerRoutine(
  DWORD dwCtrlType   //  control signal type
  );

BOOL
ProcessHandlingInit(CEnterprise *enterprise);

WCHAR*
GetLdapSamFilter(
    DWORD SamAccountType
    );

DWORD
WrappedMakeSpnW(
    WCHAR   *ServiceClass,
    WCHAR   *ServiceName,
    WCHAR   *InstanceName,
    USHORT  InstancePort,
    WCHAR   *Referrer,
    DWORD   *pcbSpnLength, // Note this is somewhat different that DsMakeSPN
    WCHAR  **ppszSpn
    );

LPWSTR
Win32ErrToString (
    IN    DWORD            dwWin32Err
    );

#endif // RENUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\inc\rendom.h ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    rendom.h

ABSTRACT:

    This is the header for the globally useful data structures for the entire
    rendom.exe utility.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/

#ifndef _RENDOM_H_
#define _RENDOM_H_

#include <Winldap.h>
#include <rpc.h>
#include <ntlsa.h>
#include <string>
#include <ntverp.h>
#include "dnslib.h"

#define RENDOM_VERSION L"Active Directory domain rename utility Version 1.1 (Microsoft)\r\n"
#define RENDOM_SCRIPT_PREFIX L"<?xml version =\"1.0\"?>\r\n<NTDSAscript opType=\"renamedomain\">"

#define RENDOM_DNSRECORDS_FILENAME        L"DNSRecords.txt"
#define RENDOM_DNSRECORDS_FAILED_FILENAME L"DNSRecords.Failed"
#define RENDOM_BUFFERSIZE          2048
#define RENDOM_MAX_ASYNC_RPC_CALLS 64

class CDomain;
class CEnterprise;
class CReadOnlyEntOptions;
class CDcList;
class CDc;
class CDcSpn;

/*******************************************************

Function containing the string Prev in there names 
signifies that they will act on the current forest 
domain names, and not on the ones that are read in
from the xml domain description file.  

********************************************************/

//This is an error class used in this module.  It will be used
//for all the error reporting in all of the class define below
class CRenDomErr {
public:
    static VOID SetErr(DWORD  p_Win32Err,
                       WCHAR* p_ErrStr,
                       ...);
    static VOID SetLdapErr(LDAP *hldap,
                           DWORD  p_LdapErr,
                           WCHAR* p_ErrStr,
                           ...);
    static VOID ClearErr();
    VOID PrintError();
    static BOOL isError();
    VOID SetMemErr();
    static VOID AppendErr(WCHAR*,
                          ...);
    DWORD GetErr();
private:
    static VOID vSetErr(DWORD p_Win32Err,
                        WCHAR* p_ErrStr,
                        va_list arglist);

    static DWORD m_Win32Err;
    static WCHAR *m_ErrStr;
    static BOOL  m_AlreadyPrinted;
};

class CXMLAttributeBlock {
public:
    CXMLAttributeBlock(const WCHAR *p_Name,
                       WCHAR *p_Value);
    ~CXMLAttributeBlock();
    WCHAR* GetName(BOOL ShouldAllocate = TRUE);
    WCHAR* GetValue(BOOL ShouldAllocate = TRUE);
private:
    CXMLAttributeBlock(const CXMLAttributeBlock&);
    WCHAR* m_Name;
    WCHAR* m_Value;
    CRenDomErr m_Error;
};

//This is a Class for generating instructions in XML
class CXMLGen {
public:
    CXMLGen();
    ~CXMLGen();
    BOOL StartDcList();
    BOOL EndDcList();
    BOOL DctoXML(CDc *dc);
    BOOL StartDomainList();
    BOOL WriteHash(WCHAR*);
    BOOL WriteSignature(WCHAR*);
    BOOL EndDomainList();
    BOOL AddDomain(CDomain *d,CDomain *ForestRoot);
    BOOL StartScript();
    BOOL EndScript();
    BOOL StartAction(WCHAR *Actionname,BOOL Preprocess);
    BOOL EndAction();
    BOOL Move(WCHAR *FromPath,
              WCHAR *ToPath,
              DWORD Metadata = 0);
    BOOL Update(WCHAR *Object,
                CXMLAttributeBlock **attblock,
                DWORD Metadata = 0);
    BOOL ifInstantiated(WCHAR *guid,
                        WCHAR *InstanceType = L"write");  
    BOOL EndifInstantiated();
    BOOL Not(WCHAR *errMessage);
    BOOL EndNot();
    BOOL Instantiated(WCHAR *path,
                      WCHAR *returnCode,
                      WCHAR *InstanceType = L"write");
    BOOL Compare(WCHAR *path,
                 WCHAR *Attribute,
                 WCHAR *value,
                 WCHAR *returnCode);
    BOOL Cardinality(WCHAR *path,
                     WCHAR *filter,
                     DWORD cardinality,
                     WCHAR *ErrorMsg);
    BOOL WriteScriptToFile(WCHAR* filename);
    BOOL AddSignatureToScript(WCHAR *signature);
    BOOL UploadScript(LDAP *hLdapConn,
                      PWCHAR ObjectDN,
                      CDcList *dclist);
    VOID DumpScript();

private:
    CRenDomErr   m_Error;
    std::wstring m_xmldoc;
    DWORD        m_ErrorNum;
};

//This
class CDsName {
public:
    CDsName(WCHAR *p_Guid, //= 0
            WCHAR *p_DN, //= 0
            WCHAR *p_ObjectSid); //= 0
    ~CDsName();
    //CDsName(CDsName*);
    //BOOL   SetDNNamefromDNSName(const WCHAR*);
    //BOOL   ReplaceDNRoot(const WCHAR*);
    BOOL   ReplaceDN(const WCHAR*);
    BOOL   CompareByObjectGuid(const WCHAR*);
    VOID   DumpCDsName();
    WCHAR* GetDNSName();
    WCHAR* GetDN(BOOL ShouldAllocate = TRUE);
    WCHAR* GetGuid(BOOL ShouldAllocate = TRUE);
    WCHAR* GetSid();
    BOOL  ErrorOccurred();   
    DWORD GetError();
private:
    WCHAR *m_ObjectGuid;
    WCHAR *m_DistName;
    WCHAR *m_ObjectSid;
    CRenDomErr m_Error;
};

class CTrust {
public:
    CTrust(CDsName *p_Object,
           CDomain *p_TrustPartner,
           DWORD   p_TrustDirection = 0);
    ~CTrust();
    CTrust(const CTrust&);
    inline CTrust* GetNext();
    inline BOOL SetNext(CTrust *);
    VOID DumpTrust();
    inline CDsName* GetTrustDsName();
    inline CDomain* GetTrustPartner();
    BOOL CTrust::operator<(CTrust&);
    CTrust& CTrust::operator=(const CTrust&);
    BOOL CTrust::operator==(CTrust &);
    inline BOOL isInbound() {return (m_TrustDirection&TRUST_DIRECTION_INBOUND)==TRUST_DIRECTION_INBOUND;}
protected:
    CDsName *m_Object;
    CDomain *m_TrustPartner;
    CTrust *m_next;
    CRenDomErr m_Error;
    LONG  *m_refcount;
    DWORD m_TrustDirection;
    
};

class CTrustedDomain : public CTrust {
public:
    CTrustedDomain(CDsName *p_Object,
                   CDomain *p_TrustPartner,
                   DWORD    p_TrustType,
                   DWORD    p_TrustDirection = 0):CTrust(p_Object,
                                                         p_TrustPartner,
                                                         p_TrustDirection),m_TrustType(p_TrustType) {}
    inline VOID            SetTrustType(DWORD type) {m_TrustType = type;}
    inline DWORD           GetTrustType()           {return m_TrustType;}
    VOID DumpTrust();
private:
    DWORD m_TrustType; 
};
        
class CInterDomainTrust : public CTrust {
public:     
    CInterDomainTrust(CDsName *p_Object,
                      CDomain *p_TrustPartner):CTrust(p_Object,
                                                      p_TrustPartner) {}
    
};

class CDomain {
public:
    CDomain(CDsName *Crossref = NULL,
            CDsName *DNSObject = NULL,
            WCHAR *DNSroot = NULL,
            WCHAR *netbiosName = NULL,
            BOOL  p_isDomain = FALSE,
            BOOL  p_isExtern = FALSE,
            BOOL  p_isDisabled = FALSE,
            WCHAR *DcName = NULL);
    ~CDomain();
    CDomain(const CDomain&);
    VOID    DumpCDomain();
    BOOL    isDomain();
    BOOL    isDisabled();
    BOOL    isExtern();
    BOOL    isDnsNameRenamed();
    BOOL    isNetBiosNameRenamed();
    WCHAR*  GetParentDnsRoot(BOOL Allocate = TRUE);
    WCHAR*  GetPrevParentDnsRoot(BOOL Allocate = TRUE);
    WCHAR*  GetDnsRoot(BOOL ShouldAllocate = TRUE);
    WCHAR*  GetNetBiosName(BOOL ShouldAllocate = TRUE);
    WCHAR*  GetGuid(BOOL ShouldAllocate = TRUE);
    WCHAR*  GetSid();
    WCHAR*  GetPrevNetBiosName(BOOL ShouldAllocate = TRUE);
    WCHAR*  GetPrevDnsRoot(BOOL ShouldAllocate = TRUE);
    WCHAR*  GetDcToUse(BOOL Allocate = TRUE);
    CDsName* GetDomainCrossRef();
    CDsName* GetDomainDnsObject();
    CDomain* LookupByDnsRoot(const WCHAR*);
    CDomain* LookupByNetbiosName(const WCHAR*);
    CDomain* LookupByPrevDnsRoot(const WCHAR*);
    CDomain* LookupByPrevNetbiosName(const WCHAR*);
    CDomain* LookupByGuid(const WCHAR*);
    CDomain* LookupbySid(const WCHAR*);
    BOOL     Merge(CDomain *domain);
    BOOL     SetParent(CDomain*);
    BOOL     SetLeftMostChild(CDomain*);
    BOOL     SetRightSibling(CDomain*);
    BOOL     SetNextDomain(CDomain*);
    BOOL     AddDomainTrust(CTrustedDomain *);
    BOOL     AddInterDomainTrust(CInterDomainTrust *);
    BOOL     AddDcSpn(CDcSpn *);
    CDomain* GetParent();
    CDomain* GetLeftMostChild();
    CDomain* GetRightSibling();
    CDomain* GetNextDomain();
    CTrustedDomain* GetTrustedDomainList();
    CInterDomainTrust* GetInterDomainTrustList();
    CDcSpn* GetDcSpn();
    int CDomain::operator<(CDomain&);
    CDomain& CDomain::operator=(const CDomain &domain);
    BOOL CDomain::operator==(CDomain &d);
    inline VOID  SetTrustCount(DWORD count) {m_TDOcount = count;}
    inline DWORD GetTrustCount()            {return m_TDOcount;}
    
private:
    CDcSpn  *m_SpnList;
    CDsName *m_CrossRefObject;
    CDsName *m_DomainDNSObject;
    BOOL   m_isDomain;
    BOOL   m_isExtern;
    BOOL   m_isDisabled;
    WCHAR  *m_dnsRoot;
    WCHAR  *m_NetBiosName;
    WCHAR  *m_PrevDnsRoot;
    WCHAR  *m_PrevNetBiosName;
    WCHAR  *m_DcName;
    DWORD   m_TDOcount;
    CTrustedDomain *m_tdoList;
    CInterDomainTrust *m_itaList;
    CDomain *m_next;
    CDomain *m_parent;
    CDomain *m_lChild;
    CDomain *m_rSibling;
    LONG *m_refcount;
    CRenDomErr m_Error;
};



class CReadOnlyEntOptions {
public:
    CReadOnlyEntOptions():m_GenerateDomainList(FALSE),
                          m_StateFile(L"DcList.xml"),
                          pCreds(NULL),
                          m_DomainlistFile(L"Domainlist.xml"),
                          m_InitalConnection(NULL),
                          m_UpLoadScript(FALSE),
                          m_Cleanup(FALSE),
                          m_End(FALSE),
                          m_ExecuteScript(FALSE),
                          m_PrepareScript(FALSE),
                          m_Showforest(FALSE),
                          m_Dump(FALSE),
                          m_SkipExch(FALSE),
                          m_DNSOptions(DNS_RENDOM_VERIFY_WITH_FAZ),
                          m_DNSZoneListFile(NULL),
                          m_testdns(FALSE),
                          m_MaxAsyncCalls(RENDOM_MAX_ASYNC_RPC_CALLS) {}
    inline BOOL ShouldGenerateDomainList() {return m_GenerateDomainList;}
    inline BOOL ShouldUpLoadScript() {return m_UpLoadScript;}
    inline BOOL ShouldExecuteScript() {return m_ExecuteScript;}
    inline BOOL ShouldPrepareScript() {return m_PrepareScript;}
    inline BOOL ShouldCleanup() {return m_Cleanup;}
    inline BOOL ShouldShowForest() {return m_Showforest;}
    inline BOOL ShouldDump() {return m_Dump;}
    inline BOOL ShouldEnd() {return m_End;}
    inline BOOL ShouldSkipExch() {return m_SkipExch;}
    inline BOOL Shouldtestdns() {return m_testdns;}
    inline DWORD ShouldUseZoneList() {return m_DNSOptions&DNS_RENDOM_VERIFY_WITH_LIST;}
    inline DWORD ShouldUseFAZ() {return m_DNSOptions&DNS_RENDOM_VERIFY_WITH_FAZ;}
    inline DWORD GetMaxAsyncCallsAllowed() {return m_MaxAsyncCalls;}
    inline WCHAR* GetStateFileName() {return m_StateFile;}
    inline WCHAR* GetDomainlistFileName() {return m_DomainlistFile;}
    inline WCHAR* GetInitalConnectionName() {return m_InitalConnection;}
    inline WCHAR* GetDNSZoneListFile() {return m_DNSZoneListFile;}

    SEC_WINNT_AUTH_IDENTITY_W * pCreds;

protected:
    BOOL m_GenerateDomainList;
    WCHAR *m_StateFile;
    WCHAR *m_DomainlistFile;
    WCHAR *m_InitalConnection;
    WCHAR *m_DNSZoneListFile;
    BOOL m_UpLoadScript;
    BOOL m_ExecuteScript;
    BOOL m_PrepareScript;
    BOOL m_Cleanup;
    BOOL m_Showforest;
    BOOL m_Dump;
    BOOL m_End;
    BOOL m_SkipExch;
    DWORD m_DNSOptions;
    BOOL m_testdns;
    DWORD m_MaxAsyncCalls;
};

//Options that can be pass to the construstor
class CEntOptions : public CReadOnlyEntOptions {
public:
    CEntOptions():CReadOnlyEntOptions() {}
    inline VOID SetGenerateDomainList() {m_GenerateDomainList = TRUE;}
    inline VOID SetShouldUpLoadScript() {m_UpLoadScript = TRUE;}
    inline VOID SetShouldExecuteScript() {m_ExecuteScript = TRUE;}
    inline VOID SetShouldPrepareScript() {m_PrepareScript = TRUE;}
    inline VOID SetShouldDump() {m_Dump = TRUE;}
    inline VOID SetShouldEnd() {m_End = TRUE;}
    inline VOID SetStateFileName(WCHAR *p_FileName) {m_StateFile = p_FileName;}
    inline VOID SetDomainlistFile(WCHAR *p_FileName) {m_DomainlistFile = p_FileName;}
    inline VOID SetCleanup() {m_Cleanup = TRUE;}
    inline VOID SetShowForest() {m_Showforest = TRUE;}
    inline VOID SetInitalConnectionName(WCHAR *p_InitalConnection) {m_InitalConnection = p_InitalConnection;}
    inline VOID SetShouldSkipExch() {m_SkipExch = TRUE;}
    inline VOID SetUseZoneList(WCHAR *p_FileName) {m_DNSOptions |= DNS_RENDOM_VERIFY_WITH_LIST;
                                                                                m_DNSZoneListFile = p_FileName;}
    inline VOID SetUseFAZ() {m_DNSOptions |= DNS_RENDOM_VERIFY_WITH_FAZ;}
    inline VOID ClearUseFAZ() {m_DNSOptions &= ~DNS_RENDOM_VERIFY_WITH_FAZ;}
    inline VOID SetShouldtestdns() {m_testdns = TRUE;}
    inline VOID SetMaxAsyncCallsAllowed(DWORD p_MaxAsyncCalls) {m_MaxAsyncCalls = p_MaxAsyncCalls;}
};

#define DC_STATE_INITIAL  0
#define DC_STATE_PREPARED 1
#define DC_STATE_DONE     2
#define DC_STATE_ERROR    3

#define DC_STATE_STRING_INITIAL  L"Initial"
#define DC_STATE_STRING_PREPARED L"Prepared"
#define DC_STATE_STRING_DONE     L"Done"
#define DC_STATE_STRING_ERROR    L"Error"

class CDcList {
public:
    enum ExecuteType {
        ePrepare,
        eExecute
    };
    CDcList(CReadOnlyEntOptions *opts);
    ~CDcList();
    CDc* GetFirstDc() {return m_dclist;}
    BOOL AddDcToList(CDc *dc);
    //This will create a list of dc that will be stored to a File
    BOOL GenerateDCListFromEnterprise(LDAP *hldap,
                                      WCHAR *DcUsed,
                                      WCHAR *ConfigurationDN);
    //will call xml parser to look through file to fill the dcList with DCs from file.
    BOOL PopulateDCListFromFile();
    //will begin async Rpc calls to ExecuteScript all the DCs.  The Flags Will indicate if the Test or Action part of the script should run.
    BOOL ExecuteScript(CDcList::ExecuteType,
                       DWORD RendomMaxAsyncRPCCalls = RENDOM_MAX_ASYNC_RPC_CALLS);
    BOOL HashstoXML(CXMLGen *xmlgen);
    BOOL SetbodyHash(BYTE *Hash,
                     DWORD cbHash);
    BOOL SetbodyHash(WCHAR *Hash);
    BOOL SetSignature(BYTE *Signature,
                      DWORD cbSignature);
    BOOL SetSignature(WCHAR *Signature);
    BOOL GetHashAndSignature(DWORD *cbhash, 
                             BYTE  **hash,
                             DWORD *cbSignature,
                             BYTE  **Signature);

private:
    //Pointer to the first DC on the list
    CDc                 *m_dclist;
    BYTE                *m_hash;
    DWORD                m_cbhash;
    BYTE                *m_Signature;
    DWORD                m_cbSignature;
    CRenDomErr          m_Error;
    CReadOnlyEntOptions *m_Opts;


}; 

class CDc {
public:
    CDc(WCHAR *NetBiosName,
        DWORD State,
        BYTE  *Password,
        DWORD cbPassword,
        DWORD LastError,
        WCHAR *FatalErrorMsg,
        WCHAR *LastErrorMsg,
        BOOL  retry,
        PVOID data
        );
    CDc(WCHAR *NetBiosName,
        DWORD State,
        WCHAR *Password,
        DWORD LastError,
        WCHAR *FatalErrorMsg,
        WCHAR *LastErrorMsg,
        BOOL  retry,
        PVOID data
        );
    ~CDc();
    //This will create an entry into the DCList.xml file expressing information about this DC.
    BOOL   CreateXmlDest();
    BOOL   SetNextDC(CDc *dc);
    static VOID   SetOptions(CReadOnlyEntOptions *Opts) {m_Opts = Opts;}
    BOOL   MakeRPCCall(DWORD CallMade,
                       CDcList::ExecuteType executetype,
                       BOOL CallNext = FALSE);
    CDc*   GetNextDC() {return m_nextDC;}
    BOOL   SetPassword(BYTE *password,
                     DWORD cbpassword);
    BOOL   SetPassword(WCHAR *password);
    BOOL   SetLastErrorMsg(WCHAR *Error);
    BOOL   SetFatalErrorMsg(WCHAR *Error);
    VOID   SetLastError(DWORD Error) {m_LastError = Error;}
    VOID   SetState(DWORD State) {m_State = State;}
    WCHAR* GetName() {return m_Name;}
    BYTE*  GetPassword() {return m_Password;}
    DWORD  GetPasswordSize() {return m_cbPassword;}
    WCHAR* GetLastErrorMsg() {return m_LastErrorMsg;}
    DWORD  GetLastError() {return m_LastError;}
    WCHAR* GetLastFatalErrorMsg() {return m_FatalErrorMsg;}
    DWORD  GetState() {return m_State;}
    DWORD  ShouldRetry() {return m_Retry;}

    VOID   CallSucceeded();
    VOID   CallFailed();

    VOID   PrintRPCResults();
    
    PVOID        m_Data;
    DWORD        m_RPCReturn;
    DWORD        m_RPCVersion;
    DWORD        m_CallIndex;
private:
    HANDLE CDc::GetLocalThreadHandle();

    DWORD        m_State;
    DWORD        m_LastError;
    WCHAR        *m_Name;
    WCHAR        *m_FatalErrorMsg;
    WCHAR        *m_LastErrorMsg;
    BYTE         *m_Password;
    DWORD        m_cbPassword;
    BOOL         m_Retry;
    static CReadOnlyEntOptions *m_Opts;
    //Pointer to the next DC on the list
    CDc          *m_nextDC;
    CRenDomErr   m_Error;

    static LONG        m_CallsSuccess;
    static LONG        m_CallsFailure;
    
};

class CDcSpn {
public:
    CDcSpn(WCHAR *DcHostDns              = NULL,
           WCHAR *NtdsGuid               = NULL,
           WCHAR *ServerMachineAccountDN = NULL
           );
    ~CDcSpn();
    BOOL    SetNtdsGuid(WCHAR *guid);
    WCHAR*  GetNtdsGuid(BOOL Allocate = TRUE);
    BOOL    SetDcHostDns(WCHAR *DcHostDns);
    WCHAR*  GetDcHostDns(BOOL Allocate = TRUE);
    BOOL    SetServerMachineAccountDN(WCHAR *ServerMachineAccountDN);
    WCHAR*  GetServerMachineAccountDN(BOOL Allocate = TRUE);
    BOOL    SetNextDcSpn(CDcSpn *Spn);
    CDcSpn* GetNextDcSpn();
    BOOL    WriteSpnTest(CXMLGen *xmlgen,
                         WCHAR *ServiceClass,
                         WCHAR *ServiceName,
                         WCHAR *InstanceName);
    
private:
    WCHAR  *m_DcHostDns;
    WCHAR  *m_NtdsGuid; 
    CDcSpn *m_NextDcSpn;
    WCHAR  *m_ServerMachineAccountDN;
    CRenDomErr   m_Error;
};


class CEnterprise {
public:
    CEnterprise(CReadOnlyEntOptions *opts);
    ~CEnterprise();
    BOOL Init();
    BOOL InitGlobals();
    BOOL WriteScriptToFile(WCHAR *filename);
    VOID DumpEnterprise();
    VOID DumpScript();
    BOOL ReadDomainInformation();
    BOOL ReadForestChanges();
    BOOL ReadStateFile();
    BOOL GetTrustsAndSpnInfo();
    BOOL GetTrustsInfoTDO(CDomain *d);
    BOOL GetTrustsInfoITA(CDomain *d);
    BOOL GetSpnInfo(CDomain *d);
    BOOL BuildForest(BOOL newForest);
    BOOL MergeForest();
    BOOL RemoveDNSAlias();
    BOOL RemoveScript();
    BOOL PrintForest();
    BOOL PrintForestHelper(CDomain *n, DWORD CurrTabIndex);
    BOOL UploadScript();
    BOOL CreateDnsRecordsFile();
    BOOL VerifyDNSRecords();
    BOOL RecordDnsRec    (std::wstring Record,
                          HANDLE hFile);
    BOOL SaveGCRecord    (WCHAR  *DNSForestRootName,
                          HANDLE hFile);
    BOOL SavePDCRecord   (WCHAR  *DNSDomainName,
                          HANDLE hFile);
    BOOL SaveDCRecord    (WCHAR  *DNSDomainName,
                          HANDLE hFile);
    BOOL SaveCNameRecord (WCHAR  *NtdsGuid,
                          WCHAR  *DNSForestRootName,
                          HANDLE hFile);
    BOOL ExecuteScript();
    BOOL CheckConsistency();
    BOOL CheckConsistencyGuids(CDomain *d);
    BOOL CheckConsistencyNetBiosNames(CDomain *d);
    BOOL CheckConsistencyDNSnames(CDomain *d);
    BOOL GenerateDomainList();
    BOOL GenerateDcList();
    BOOL GenerateDcListForSave();
    BOOL GenerateReNameScript();
    BOOL EnumeratePartitions();
    BOOL CheckForExchangeNotInstalled();
    BOOL GetInfoFromRootDSE();
    BOOL GetReplicationEpoch();
    BOOL LdapConnectandBindToServer(WCHAR *Server);
    BOOL LdapConnectandBind(CDomain *domain = NULL);  
    BOOL LdapConnectandBindToDomainNamingFSMO();
    BOOL LdapCheckGCAvailability();
    BOOL CheckForExistingScript(BOOL *found);
    BOOL TearDownForest();
    BOOL FixMasterCrossrefs();
    BOOL EnsureValidTrustConfiguration();
    BOOL DisplayDomainToConsole(CDomain *d);
    BOOL HandleNDNCCrossRef(CDomain *d);
    BOOL AddDomainToDomainList(CDomain *d);
    BOOL AddDomainToDescList(CDomain *d);
    BOOL ClearLinks(CDomain *d);
    BOOL ScriptTreeFlatting(CDomain *d);
    BOOL ScriptDomainRenaming(CDomain *d);
    BOOL ScriptFixCrossRefs(CDomain *d);
    BOOL ScriptFixTrustedDomains(CDomain *d);
    BOOL ScriptAdvanceReplicationEpoch();
    BOOL DomainToXML(CDomain *d);
    BOOL Error();
    BOOL WriteTest();
    BOOL TestTrusts(CDomain *domain);
    BOOL TestSpns(CDomain *domain);
    BOOL GetDnsZoneListFromFile(WCHAR *Filename,
                                PDNS_ZONE_SERVER_LIST *ZoneServList);

    BOOL    SetDcUsed(const WCHAR *DcUsed);
    WCHAR*  GetDcUsed(BOOL Allocate = TRUE);
    

    CDcList* GetDcList() {return &m_DcList;}
    
       
private:
    WCHAR* DNSRootToDN(WCHAR *DNSRoot);
    BOOL LdapGetGuid(WCHAR *LdapValue,
                     WCHAR **Guid);
    BOOL LdapGetSid(WCHAR *LdapValue,
                    WCHAR **Sid);
    BOOL LdapGetDN(WCHAR *LdapValue,
                   WCHAR **DN);
    // This is a helper to the constructor
    BOOL CreateChildBeforeParentOrder();
    // SetAction must be called before calling one of the 
    // Traverse functions.
    BOOL SetAction(BOOL (CEnterprise::*m_Action)(CDomain *));
    BOOL ClearAction();
    // should only be called when m_Action is set
    BOOL TraverseDomainsParentBeforeChild();
    // should only be called when m_Action is set
    BOOL TraverseDomainsChildBeforeParent();
    //BOOL ReadConfig();
    //BOOL ReadSchema();
    //BOOL ReadForestRootNC();
    BOOL (CEnterprise::*m_Action)(CDomain *);
    BOOL fReadConfig();
    BOOL fReadSchema();
    BOOL fReadForestRootNC();
    inline CReadOnlyEntOptions* GetOpts();
    CDsName *m_ConfigNC;
    CDsName *m_SchemaNC;
    CDsName *m_ForestRootNC;
    CDomain *m_DomainList;
    CDomain *m_ForestRoot;
    CDomain *m_descList;
    DWORD  m_maxReplicationEpoch;
    CXMLGen *m_xmlgen;
    CRenDomErr m_Error;
    LDAP *m_hldap;
    CReadOnlyEntOptions *m_Opts;
    CDcList m_DcList;
    BOOL m_NeedSave;
    WCHAR  *m_DcNameUsed;
};

#endif  // _RENDOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\src\main.cxx ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    main.cxx

ABSTRACT:

    This is the main entry point of rendom.exe.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "rendom.h"
#include <locale.h>
#include <stdio.h>

#include "renutil.h"

//gobal for the eventhandle function
HANDLE gSaveandExit = NULL;

INT __cdecl
wmain (
    INT                argc,
    LPWSTR *           argv,
    LPWSTR *           envp
    )
{
    CEntOptions Opts;

    INT iArg = 0;
    BOOL bFound = FALSE;
    BOOL bOutFileSet = FALSE;
    UINT Codepage;
    WCHAR *pszTemp = NULL;
    BOOL MajorOptSet = FALSE;
    BOOL ExtraMajorSet = FALSE;
    
    char achCodepage[12] = ".OCP";

    //
    // Set locale to the default
    //
    if (Codepage = GetConsoleOutputCP()) {
        sprintf(achCodepage, ".%u", Codepage);
    }
    setlocale(LC_ALL, achCodepage);

    //parse the command line
    PreProcessGlobalParams(&argc, &argv, Opts.pCreds);

    for (iArg = 1; iArg < argc ; iArg++)
    {
        bFound = FALSE;
        if (*argv[iArg] == L'-')
        {
            *argv[iArg] = L'/';
        }
        if (*argv[iArg] != L'/')
        {
            wprintf (L"Invalid Syntax: Use rendom.exe /h for help.\r\n");
            return -1;
        }
        else if (_wcsicmp(argv[iArg],L"/list") == 0)
        {
            Opts.SetGenerateDomainList();
            bFound = TRUE;
            if (MajorOptSet) {
                ExtraMajorSet = TRUE;
            }
            MajorOptSet = TRUE;
        }
        else if (_wcsicmp(argv[iArg],L"/UpLoad") == 0)
        {
            Opts.SetShouldUpLoadScript();
            bFound = TRUE;
            if (MajorOptSet) {
                ExtraMajorSet = TRUE;
            }
            MajorOptSet = TRUE;
        }
        else if (_wcsicmp(argv[iArg],L"/Execute") == 0)
        {
            Opts.SetShouldExecuteScript();
            bFound = TRUE;
            if (MajorOptSet) {
                ExtraMajorSet = TRUE;
            }
            MajorOptSet = TRUE;
        }
        else if (_wcsicmp(argv[iArg],L"/Prepare") == 0)
        {
            Opts.SetShouldPrepareScript();
            bFound = TRUE;
            if (MajorOptSet) {
                ExtraMajorSet = TRUE;
            }
            MajorOptSet = TRUE;
        }
        else if (_wcsicmp(argv[iArg],L"/End") == 0)
        {
            Opts.SetShouldEnd();
            bFound = TRUE;
            if (MajorOptSet) {
                ExtraMajorSet = TRUE;
            }
            MajorOptSet = TRUE;
        }
#if DBG
        else if (_wcsicmp(argv[iArg],L"/dump") == 0)
        {
            Opts.SetShouldDump();
            bFound = TRUE;
        }
        else if (_wcsicmp(argv[iArg],L"/skipexch") == 0)
        {
            Opts.SetShouldSkipExch();
            bFound = TRUE;
        }
        else if (_wcsnicmp(argv[iArg],L"/MaxAsync:",wcslen(L"/MaxAsync:")) == 0)
        {
            pszTemp = &argv[iArg][wcslen(L"/MaxAsync:")];

            if (*pszTemp == L'\0')
            {
                wprintf(L"Syntax Error: must use /MaxAsync:<Max number of async rpc calls>\r\n");
                return -1;
            }
            Opts.SetMaxAsyncCallsAllowed(_wtoi(pszTemp));
            bFound = TRUE;
        }
#endif
        else if (_wcsnicmp(argv[iArg],L"/DC:",wcslen(L"/DC:")) == 0)
        {
            pszTemp = &argv[iArg][wcslen(L"/DC:")];

            if (*pszTemp == L'\0')
            {
                wprintf(L"Syntax Error: must use /DC:<file Name>\r\n");
                return -1;
            }
            Opts.SetInitalConnectionName(pszTemp);
            bFound = TRUE;
        }
        else if (_wcsnicmp(argv[iArg],L"/disablefaz",wcslen(L"/disablefaz")) == 0){
            Opts.ClearUseFAZ();
            bFound = TRUE;
        }
        else if (_wcsnicmp(argv[iArg],L"/testdns",wcslen(L"/testdns")) == 0){
            Opts.SetShouldtestdns();
            bFound = TRUE;
        }
        else if (_wcsnicmp(argv[iArg],L"/Clean",wcslen(L"/Clean")) == 0){
            Opts.SetCleanup();
            bFound = TRUE;
            if (MajorOptSet) {
                ExtraMajorSet = TRUE;
            }
            MajorOptSet = TRUE;
        }
        else if (_wcsnicmp(argv[iArg],L"/showforest",wcslen(L"/showforest")) == 0){
            Opts.SetShowForest();
            bFound = TRUE;
            if (MajorOptSet) {
                ExtraMajorSet = TRUE;
            }
            MajorOptSet = TRUE;
        }
        else if (_wcsnicmp(argv[iArg],L"/dnszonefile:",wcslen(L"/dnszonefile:")) == 0)
        {
            pszTemp = &argv[iArg][wcslen(L"/dnszonefile:")];

            if (*pszTemp == L'\0')
            {
                wprintf(L"Syntax Error: must use /dnszonefile::<file Name>\r\n");
                return -1;
            }
            Opts.SetUseZoneList(pszTemp);
            bFound = TRUE;
        }
        else if (_wcsnicmp(argv[iArg],L"/listfile:",wcslen(L"/listfile:")) == 0)
        {
            pszTemp = &argv[iArg][wcslen(L"/listfile:")];

            if (*pszTemp == L'\0')
            {
                wprintf(L"Syntax Error: must use /listfile:<file Name>\r\n");
                return -1;
            }
            Opts.SetDomainlistFile(pszTemp);
            bFound = TRUE;
        }
        else if (_wcsnicmp(argv[iArg],L"/statefile:",wcslen(L"/statefile:")) == 0)
        {
            pszTemp = &argv[iArg][wcslen(L"/statefile:")];

            if (*pszTemp == L'\0')
            {
                wprintf(L"Syntax Error: must use /statefile:<file Name>\r\n");
                return -1;
            }

            Opts.SetStateFileName(pszTemp);
            bOutFileSet = TRUE;
            bFound = TRUE;
        }
        else if ((_wcsnicmp(argv[iArg],L"/h",wcslen(L"/h")) == 0) ||
                 (_wcsnicmp(argv[iArg],L"/?",wcslen(L"/?")) == 0) ) {

                //   "============================80 char ruler======================================="
            wprintf(RENDOM_VERSION);
            wprintf(L"rendom:  perform various actions necessary for a domain rename operation\r\n\r\n");
            wprintf(L"Usage:  rendom </list | /showforest | /upload | /prepare | /execute | /end | /clean>\r\n");
            wprintf(L"      [/user:USERNAME] [/pwd:{PASSWORD|*}]\r\n");
            wprintf(L"      [/dc:{DCNAME | DOMAIN}]\r\n");
            wprintf(L"      [/listfile:LISTFILE] [/statefile:STATEFILE] [/?]\r\n\r\n");
            wprintf(L"/dc:{DCNAME | DOMAIN}\r\n");
            wprintf(L"      Connect to the DC with name DCNAME. If DOMAIN is specified instead, then\r\n");
            wprintf(L"      connect to a DC in that domain. [Default: connect to a DC in the domain\r\n");
            wprintf(L"      to which the current computer belongs]\r\n\r\n");
            wprintf(L"/user:USERNAME	Connect as USERNAME [Default: the logged in user]\r\n\r\n");
            wprintf(L"/pwd:{PASSWORD | *}\r\n");
            wprintf(L"      Password for the user USERNAME [if * is specified instead of a password,\r\n");
            wprintf(L"      then prompt for password]\r\n\r\n");
            wprintf(L"/list\r\n");
            wprintf(L"      List the naming contexts in the forest (forest desc) into a file as text\r\n");
            wprintf(L"      description using a XML format\r\n\r\n");
            wprintf(L"/upload\r\n");
            wprintf(L"      Upload the auto-generated script into the directory that will perform the\r\n");
            wprintf(L"      domain rename related directory changes on all domain controllers\r\n\r\n");
            wprintf(L"/prepare\r\n");
            wprintf(L"      Prepare for domain rename by verifying authorization, successful\r\n");
            wprintf(L"      replication of the uploaded script and network connectivity\r\n\r\n");
            wprintf(L"/execute\r\n");
            wprintf(L"      Execute the uploaded script on all domain controllers to actually perform\r\n"); 
            wprintf(L"      the domain rename operation\r\n\r\n");
            wprintf(L"/clean\r\n");
            wprintf(L"      Clean up all state left behind in the directory by the domain rename\r\n");
            wprintf(L"      operation\r\n\r\n");
            wprintf(L"/listfile:LISTFILE\r\n");
            wprintf(L"      Use LISTFILE as the name of the file used to hold the list of naming\r\n"); 
            wprintf(L"      contexts in the forest (forest desc). This file is created by the\r\n");
            wprintf(L"      /list command and is used as input for the /upload command. [Default:\r\n");
            wprintf(L"      file DOMAINLIST.XML in the current dir]\r\n\r\n");
            wprintf(L"/statefile:STATEFILE\r\n");
            wprintf(L"      Use STATEFILE as the name of the file used to keep track of the state of\r\n");
            wprintf(L"      the domain rename operation on each DC in the forest. This file is\r\n");
            wprintf(L"      created by the /upload command. [Default: file DCLIST.XML in the current\r\n");
            wprintf(L"      dir]\r\n");
            wprintf(L"/showforest\r\n");
            wprintf(L"      Display the forest structure as represented by its naming contexts contained\r\n");
            wprintf(L"      in the LISTFILE using a friendly indented format.\r\n");
            wprintf(L"/end\r\n");
            wprintf(L"      Ends the rename operation.  Removes restrictions placed on the\r\nDirectory Service during\r\n");
            wprintf(L"      the rename operation.\r\n");
            wprintf(L"/disablefaz");
            wprintf(L"      Will not use FAZ to verify proper DNS record support for domain rename.\r\n");
            wprintf(L"/dnszonefile:DNSZONEFILE\r\n");
            wprintf(L"      The name of the file to use for dns zone verifications.\r\n");
            return 0;
        }
        if(!bFound)
        {
            wprintf (L"Syntax Error: %s.  Use rendom.exe /h for help.\r\n", argv[iArg]);
            return 1;
        }
    }

    if (ExtraMajorSet || !MajorOptSet ) 
    {
        wprintf (L"Usage: must have one and only one of the Following [/list | /upload | /prepare | /execute | /end | /clean]");    
        return 1;
    }

    if ((!Opts.ShouldUseFAZ() || Opts.ShouldUseZoneList()) && !Opts.ShouldPrepareScript()) 
    {
        wprintf(L"Usage: /disablefaz and /dnszonefile:DNSZONEFILE are only used during /prepare");
        return 1;
    }

    CEnterprise *enterprise = new CEnterprise(&Opts);
    if (!enterprise) {
        wprintf (L"Failed to execute out of memory.\r\n");
        return 1;
    }

    if (!ProcessHandlingInit(enterprise))
    {
        goto Exit;
    }

    enterprise->Init();
    if (enterprise->Error()) {
        goto Exit;
    }

    if (Opts.ShouldShowForest()) {
        enterprise->PrintForest();
        if (enterprise->Error()) {
            goto Exit;
        }
    }

    if (Opts.ShouldEnd() || Opts.ShouldCleanup()) {
        enterprise->RemoveScript();
        if (enterprise->Error()) {
            goto Exit;
        }
    }

    if (Opts.ShouldCleanup()) {
        enterprise->RemoveDNSAlias();
        if (enterprise->Error()) {
            goto Exit;
        }
    }

    if (Opts.ShouldUpLoadScript()) {
        enterprise->LdapCheckGCAvailability();
    }

    if (Opts.ShouldExecuteScript() || Opts.ShouldPrepareScript()) {

        if (Opts.Shouldtestdns()) {
            enterprise->VerifyDNSRecords();
            if (enterprise->Error()) {
                goto Exit;
            }
        }

        enterprise->ReadStateFile();
        if (enterprise->Error()) {
            goto Exit;
        }

        enterprise->ExecuteScript();
        if (enterprise->Error()) {
            goto Exit;
        }

    }
    
    if (Opts.ShouldGenerateDomainList()) {

        enterprise->GenerateDomainList();
        if (enterprise->Error()) {
            goto Exit;
        }

        enterprise->WriteScriptToFile(Opts.GetDomainlistFileName());
        if (enterprise->Error()) {
            goto Exit;
        }


    }

    //enterprise->DumpScript();
    //if (enterprise->Error()) {
    //    goto Exit;
    //}

#if DBG
    if (Opts.ShouldDump()) {
        enterprise->DumpEnterprise();
        if (enterprise->Error()) {
            goto Exit;
        }
    }
#endif

    if (Opts.ShouldUpLoadScript()) {

        if (!Opts.ShouldSkipExch()) {
            enterprise->CheckForExchangeNotInstalled();
            if (enterprise->Error()) {
                goto Exit;
            }
        }

        enterprise->MergeForest();
        if (enterprise->Error()) {
            goto Exit;
        }
    
        enterprise->GenerateReNameScript();
        if (enterprise->Error()) {
            goto Exit;
        }

#if DBG
        enterprise->WriteScriptToFile(L"rename.xml");
        if (enterprise->Error()) {
            goto Exit;
        }
#endif

        enterprise->UploadScript();
        if (enterprise->Error()) {
            goto Exit;
        }

        enterprise->CreateDnsRecordsFile();
        if (enterprise->Error()) {
            goto Exit;
        }
        
    }

    if (Opts.ShouldExecuteScript() ||
        Opts.ShouldPrepareScript() ||
        Opts.ShouldUpLoadScript() ) 
    {
        enterprise->GenerateDcList();
        if (enterprise->Error()) {
            goto Exit;
        }

        enterprise->WriteScriptToFile(Opts.GetStateFileName());
        if (enterprise->Error()) {
            goto Exit;
        }
    }
    
    Exit:

    if ( !SetEvent(gSaveandExit) ) 
    {
        CRenDomErr::SetErr(GetLastError(),
                           L"Failed to shutdown event thread");
    }

    if (enterprise->Error()) {
        delete enterprise;
        return 1;
    }

    delete enterprise;

    wprintf(L"\r\nThe operation completed successfully.\r\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\inc\saxcontenthandlerimpl.h ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    saxcontenthandlerimpl.h

ABSTRACT:

    This is the header for the globally useful data structures for the entire
    rendom.exe utility.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/


// SAXContentHandlerImpl.h: interface for the SAXContentHandlerImpl class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _SAXCONTENTHANDLERIMPL_H
#define _SAXCONTENTHANDLERIMPL_H

#include "ole2.h"
#include "msxml2.h"

HRESULT GetClassFactory( REFCLSID clsid, IClassFactory ** ppFactory);


class SAXContentHandlerImpl : public ISAXContentHandler  
{
public:
    SAXContentHandlerImpl();
    virtual ~SAXContentHandlerImpl();

public: // IUnknown
        long __stdcall QueryInterface(const struct _GUID &,void ** );
        unsigned long __stdcall AddRef(void);
        unsigned long __stdcall Release(void);

public: // ISAXContentHandler
            virtual HRESULT STDMETHODCALLTYPE putDocumentLocator( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator);
        
        virtual HRESULT STDMETHODCALLTYPE startDocument( void);
        
        virtual HRESULT STDMETHODCALLTYPE endDocument( void);
        
        virtual HRESULT STDMETHODCALLTYPE startPrefixMapping(
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri);
        
        virtual HRESULT STDMETHODCALLTYPE endPrefixMapping(
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix);
        
        virtual HRESULT STDMETHODCALLTYPE startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes);
        
        virtual HRESULT STDMETHODCALLTYPE endElement(
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchQName,
            /* [in] */ int cchQName);
        
        virtual HRESULT STDMETHODCALLTYPE characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars);
        
        virtual HRESULT STDMETHODCALLTYPE ignorableWhitespace( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars);
        
        virtual HRESULT STDMETHODCALLTYPE processingInstruction( 
            /* [in] */ const wchar_t __RPC_FAR *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ const wchar_t __RPC_FAR *pwchData,
            /* [in] */ int cchData);
        
        virtual HRESULT STDMETHODCALLTYPE skippedEntity( 
            /* [in] */ const wchar_t __RPC_FAR *pwchName,
            /* [in] */ int cchName);

private:
    long    _cRef;
};

#endif //  _SAXCONTENTHANDLERIMPL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\src\rendom.cxx ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    rendom.cxx

ABSTRACT:

    This is the implementation of the core functionality of rendom.cxx.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/
  
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "rendom.h"

#include <mdcommsg.h>
#include <wchar.h>
#include <ntlsa.h>
#include <Ntdsapi.h> // for DsCrackNames()

extern "C"
{
#include <ntdsapip.h>
}                                       

#include <windns.h>
#include <drs_w.h>
#include <base64.h>
#include <list>

#define STRSAFE_NO_DEPRECATE 
#include <strsafe.h>

#include "Domainlistparser.h"
#include "Dclistparser.h"
#include "renutil.h"
#include "dnslib.h"

//gobals
RPC_ASYNC_STATE              *gAsyncState = NULL;
DSA_MSG_PREPARE_SCRIPT_REPLY *gpreparereply = NULL;
DSA_MSG_EXECUTE_SCRIPT_REPLY *gexecutereply = NULL;
RPC_BINDING_HANDLE           *ghDS = NULL;
CDc                          *gdc = NULL;

//Callback functions prototypes for ASyncRPC
VOID ExecuteScriptCallback(struct _RPC_ASYNC_STATE *pAsync,
                           void *Context,
                           RPC_ASYNC_EVENT Event);

VOID PrepareScriptCallback(struct _RPC_ASYNC_STATE *pAsync,
                           void *Context,
                           RPC_ASYNC_EVENT Event);

//Class static variables
WCHAR* CRenDomErr::m_ErrStr = NULL;
DWORD  CRenDomErr::m_Win32Err = 0;             
BOOL   CRenDomErr::m_AlreadyPrinted = 0;
CReadOnlyEntOptions* CDc::m_Opts = NULL;
LONG  CDc::m_CallsSuccess = 0;
LONG  CDc::m_CallsFailure = 0;

// This is a contructor for the class CEnterprise.     
CEnterprise::CEnterprise(CReadOnlyEntOptions *opts):m_DcList(opts)
{                                
    m_DomainList = NULL;
    m_descList = NULL;
    m_maxReplicationEpoch = 0;
    m_hldap = NULL;
    m_ConfigNC = NULL;
    m_SchemaNC = NULL;
    m_ForestRootNC = NULL;
    m_ForestRoot = NULL;
    m_Action = NULL;
    m_Opts = opts;
    m_NeedSave = FALSE;
    m_DcNameUsed = NULL;

}

//This Function will init the Gobals variables that are used in domain rename
BOOL CEnterprise::InitGlobals()
{
    gAsyncState = new RPC_ASYNC_STATE[m_Opts->GetMaxAsyncCallsAllowed()];
    if (!gAsyncState) {
        m_Error.SetMemErr();
        return FALSE;
    }
    memset(gAsyncState,0,sizeof(RPC_ASYNC_STATE)*m_Opts->GetMaxAsyncCallsAllowed());

    ghDS = new RPC_BINDING_HANDLE[m_Opts->GetMaxAsyncCallsAllowed()];
    if (!ghDS) {
        m_Error.SetMemErr();
        return FALSE;
    }
    memset(ghDS,0,sizeof(RPC_BINDING_HANDLE)*m_Opts->GetMaxAsyncCallsAllowed());
    
    if (m_Opts->ShouldPrepareScript()) {
        gpreparereply = new DSA_MSG_PREPARE_SCRIPT_REPLY[m_Opts->GetMaxAsyncCallsAllowed()];
        if (!gpreparereply) {
            m_Error.SetMemErr();
            return FALSE;
        }
        memset(gpreparereply,0,sizeof(DSA_MSG_PREPARE_SCRIPT_REPLY)*m_Opts->GetMaxAsyncCallsAllowed());
    } else if (m_Opts->ShouldExecuteScript()){
        gexecutereply = new DSA_MSG_EXECUTE_SCRIPT_REPLY[m_Opts->GetMaxAsyncCallsAllowed()];
        if (!gexecutereply) {
            m_Error.SetMemErr();
            return FALSE;
        }
        memset(gexecutereply,0,sizeof(DSA_MSG_EXECUTE_SCRIPT_REPLY)*m_Opts->GetMaxAsyncCallsAllowed());
    }

    return TRUE;
    
}

// This init function will read its information for the DS and build the forest from that using
// the domain that the machine that it is run on is joined to and the
// creds of the logged on user.
BOOL CEnterprise::Init()
{
    if (!m_Opts) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                       L"Failed to create Enterprise Discription opts must be passed to CEnterprise");
        return FALSE;
    }
    
    m_xmlgen = new CXMLGen;
    if (!m_xmlgen) {
        m_Error.SetMemErr();
        return FALSE;
    }

    if (!InitGlobals()) {
        return FALSE;
    }

    if (!m_Opts->ShouldExecuteScript() && !m_Opts->ShouldPrepareScript() )  {

        if(!ReadDomainInformation()) 
        {
            return FALSE;
        }

        if (!MergeForest())
        {
            return FALSE;
        }
    
    }

    return TRUE;

}

// This is the distructor for CEnterprise.
CEnterprise::~CEnterprise()
{
    if (m_hldap) {
        ldap_unbind(m_hldap);
    }
    if (m_ConfigNC) {
        delete m_ConfigNC;
    }
    if (m_SchemaNC) {
        delete m_SchemaNC;
    }
    if (m_ForestRootNC) {
        delete m_ForestRootNC;
    }
    while (NULL != m_DomainList) {
        CDomain *p = m_DomainList->GetNextDomain();
        delete m_DomainList;
        m_DomainList = p;
    }
    while (NULL != m_descList) {
        CDomain *p = m_descList->GetNextDomain();
        delete m_descList;
        m_descList = p;
    }
    if (m_xmlgen) {
        delete m_xmlgen;
    }
    if (m_DcNameUsed) {
        delete m_DcNameUsed;
    } 
    if (gAsyncState) {
        delete gAsyncState;
    }
    if (ghDS) {
        delete ghDS;
    }
    if (gpreparereply) {
        delete gpreparereply;
    }
    if (gexecutereply) {
        delete gexecutereply;
    }

}


BOOL CEnterprise::WriteScriptToFile(WCHAR *outfile)
/*++

Routine Description:

    This routine will write the xml script to a file.

Parameters:

    outfile - the name of the to write the script to.

Return Values:

    TRUE for success; FALSE for failures

--*/

{
    if (!outfile) {
        if (m_NeedSave) {
            return m_xmlgen->WriteScriptToFile(m_Opts->GetStateFileName());
        } else {
            return FALSE;
        }
    }
    return m_xmlgen->WriteScriptToFile(outfile);
}
    
BOOL CEnterprise::ExecuteScript()
/*++

Routine Description:

    This routine will prepare or execute the Script on all of the DCs.

Parameters:

    none.

Return Values:

    TRUE for success; FALSE for failures

--*/
{
    if (!m_hldap)
    {
        if (!LdapConnectandBindToDomainNamingFSMO())
        {
            return FALSE;
        }
    }

    m_NeedSave = TRUE;

    if (m_Opts->ShouldExecuteScript()) {
        if (!m_DcList.ExecuteScript(CDcList::eExecute,
                                    m_Opts->GetMaxAsyncCallsAllowed()))
        {
            goto Cleanup;
        }
    } else if (m_Opts->ShouldPrepareScript()) {
        if (!m_DcList.ExecuteScript(CDcList::ePrepare,
                                    m_Opts->GetMaxAsyncCallsAllowed()))
        {
            goto Cleanup;
        }    
    }

    Cleanup:

    m_NeedSave = FALSE;

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;

}  

int CDomain::operator<(CDomain &d)
/*++

Routine Description:

    This routine will compare two domain alphabetically.

Parameters:

    d - the domain to compare with the implicit one.

Return Values:

    TRUE for success; FALSE for failures

--*/

{
    if (_wcsicmp(GetDnsRoot(FALSE),d.GetDnsRoot(FALSE)) > 0) {
        return 0;
    }

    return 1;
    
}

BOOL CDomain::operator==(CDomain &d)
/*++

Routine Description:

    This routine will compare two domains to see if they refer to the same domain.

Parameters:

    d - the domain to compare with the implicit one.

Return Values:

    TRUE for success; FALSE for failures

--*/
{
    if (m_refcount==d.m_refcount) {
        return TRUE;
    }

    return FALSE;
    
}

//strings for printing domains.
#define FP_FlatName             L"FlatName:%ws"
#define FP_Partiton             L"PartitionType:Application"
#define FP_Partiton_Disabled    L"PartitionType:Disabled"
#define FP_Partiton_External    L"PartitionType:External"
#define FP_EndBracket           L"]\r\n"
#define FP_Tab                  L"\t"
#define FP_DomainandBracket     L"%ws ["
#define FP_ForestRootandBracket L"%ws [ForestRoot Domain, "

BOOL CEnterprise::PrintForestHelper(CDomain *n, DWORD CurrTabIndex)
/*++

Routine Description:

    This routine is a helper function for PrintForest.

Parameters:

    n - domain to print.
    
    CurrTabIndex - how much to indent the printing.

Return Values:

    TRUE for success; FALSE for failures

--*/
{
    std::list<CDomain> dl;

    while (n) {
        dl.push_front(*n);
        n = n->GetRightSibling();
    }

    dl.sort();

    for (std::list<CDomain>::iterator it = dl.begin(); it != dl.end(); it++) {
        //print the domain
        for (DWORD i = 0; i < CurrTabIndex; i++) {
            wprintf(FP_Tab);
        }
        //if this is a disabled or external crossref
        //we will not display it.
        if ((!(*it).isDisabled()) && (!(*it).isExtern())) {
            //print the domain
            wprintf(FP_DomainandBracket,
                    (*it).GetDnsRoot(FALSE));
            //If the domain is an NDNC include that information
            if (!((*it).isDomain())) {
                wprintf(FP_Partiton);
            } else if ((*it).isDisabled()) {
                wprintf(FP_Partiton_Disabled);
            } else if ((*it).isExtern()) {
                wprintf(FP_Partiton_External);
            } else {
                wprintf(FP_FlatName,
                        (*it).GetNetBiosName(FALSE));
            }
            wprintf(FP_EndBracket);
        }
        if ((*it).GetLeftMostChild()) {
            if (!PrintForestHelper((*it).GetLeftMostChild(), CurrTabIndex+1))
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL CEnterprise::PrintForest()
/*++

Routine Description:

    This routine will print the forest out to the screen.

Parameters:

    none.

Return Values:

    TRUE for success; FALSE for failures

--*/
{
    CDomain *n = m_ForestRoot;

    try{
        std::list<CDomain> dl;
        
        while (n) {
            dl.push_front(*n);
            n = n->GetRightSibling();
        }
    
        dl.sort();
    
        for (std::list<CDomain>::iterator it = dl.begin(); it != dl.end(); it++) {
            if ((*it) == *m_ForestRoot) {
                //print the ForestRoot Domain.
                wprintf(FP_ForestRootandBracket,
                        (*it).GetDnsRoot(FALSE));
                wprintf(FP_FlatName,
                        (*it).GetNetBiosName(FALSE));
                wprintf(FP_EndBracket);
                if ((*it).GetLeftMostChild()) {
                    if (!PrintForestHelper((*it).GetLeftMostChild(), 1))
                    {
                        return FALSE;
                    }
                }
            } else {
                //if this is a disabled or external crossref
                //we will not display it.
                if ((!(*it).isDisabled()) && (!(*it).isExtern())) {
                    //print the domain
                    wprintf(FP_DomainandBracket,
                            (*it).GetDnsRoot(FALSE));
                    //If the domain is an NDNC include that information
                    if (!((*it).isDomain())) {
                        wprintf(FP_Partiton);
                    } else if ((*it).isDisabled()) {
                        wprintf(FP_Partiton_Disabled);
                    } else if ((*it).isExtern()) {
                        wprintf(FP_Partiton_External);
                    } else {
                        wprintf(FP_FlatName,
                                (*it).GetNetBiosName(FALSE));
                    }
                    wprintf(FP_EndBracket);
                }
                if ((*it).GetLeftMostChild()) {
                    if (!PrintForestHelper((*it).GetLeftMostChild(), 1))
                    {
                        return FALSE;
                    }
                }
            }
        }
    }
    catch (...){
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;

}

BOOL CEnterprise::RemoveScript()
/*++

Routine Description:

    This routine will remove the script from the domain nameing FSMO.

Parameters:

    none.

Return Values:

    TRUE for success; FALSE for failures

--*/
{
    DWORD         Length = 0;
    ULONG         dwErr = LDAP_SUCCESS;
    WCHAR         *ObjectDN = NULL;

    if (!m_hldap) 
    {
        if(!LdapConnectandBindToDomainNamingFSMO())
        {
            goto Cleanup;
        }
    }

    LDAPModW         *pLdapMod[2] = {0,0};

    pLdapMod[0] = new LDAPModW;
    if (!pLdapMod[0]) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    //delete the script

    WCHAR *PartitionsRDN = L"CN=Partitions,";
    WCHAR *PartitionsDN = NULL;

    pLdapMod[0]->mod_type = L"msDS-UpdateScript";
    pLdapMod[0]->mod_op   = LDAP_MOD_DELETE;
    pLdapMod[0]->mod_vals.modv_strvals = NULL;

    ObjectDN = m_ConfigNC->GetDN();
    if (m_Error.isError()) {
        goto Cleanup;
    }

    //
    // Build the partitions DN
    //
    PartitionsDN = new WCHAR[wcslen(ObjectDN)+
                             wcslen(PartitionsRDN)+1];
    if (!PartitionsDN) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    wcscpy(PartitionsDN,PartitionsRDN);
    wcscat(PartitionsDN,ObjectDN);


    dwErr = ldap_modify_sW (m_hldap, PartitionsDN, pLdapMod);

    //It is possiable for the error LDAP_NO_SUCH_ATTRIBUTE.
    //This is not an Error in our case.
    if(dwErr != LDAP_SUCCESS && LDAP_NO_SUCH_ATTRIBUTE != dwErr) {
        m_Error.SetLdapErr(m_hldap,
                           dwErr,
                           L"Failed to delete rename script on the DN: %ws on host %ws",
                           PartitionsDN,
                           GetDcUsed(FALSE));
    }

    if (ObjectDN) {
        delete ObjectDN;
        ObjectDN = NULL;
    }

    Cleanup:

    if (pLdapMod[0]) {
        delete pLdapMod[0];
    }
    if (PartitionsDN) {
        delete [] PartitionsDN;
    }
    if (ObjectDN) {
        delete ObjectDN;
        ObjectDN = NULL;
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;

}

BOOL CEnterprise::RemoveDNSAlias()
/*++

Routine Description:

    This routine will remove the DNSAlias attribute from crossrefs.

Parameters:

    none.

Return Values:

    TRUE for success; FALSE for failures

--*/
{
    DWORD         Length = 0;
    ULONG         dwErr = LDAP_SUCCESS;
    WCHAR         *ObjectDN = NULL;

    if (!m_hldap) 
    {
        if(!LdapConnectandBindToDomainNamingFSMO())
        {
            goto Cleanup;
        }
    }

    //delete the msDS-DNSRootAlias atributes on the crossref objects
    LDAPModW         *pLdapMod[2] = {0,0};

    pLdapMod[0] = new LDAPModW;
    if (!pLdapMod[0]) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    pLdapMod[0]->mod_type = L"msDS-DNSRootAlias";
    pLdapMod[0]->mod_op   = LDAP_MOD_DELETE;
    pLdapMod[0]->mod_vals.modv_strvals = NULL;
    
    //
    // Delete the msDS-DNSRootAlias for every domain in the
    // forest.
    //
    for (CDomain *d = m_DomainList; d;d = d->GetNextDomain()) {

        ObjectDN = d->GetDomainCrossRef()->GetDN();
        if (m_Error.isError()) {
            goto Cleanup;
        }
    
        dwErr = ldap_modify_sW (m_hldap, ObjectDN, pLdapMod);
    
        //It is possiable for the error LDAP_NO_SUCH_ATTRIBUTE.
        //This is not an Error in our case.
        if(dwErr != LDAP_SUCCESS && LDAP_NO_SUCH_ATTRIBUTE != dwErr) {
            m_Error.SetLdapErr(m_hldap,
                               dwErr,
                               L"Failed to delete Dns Root alias on the DN: %ws on the Server %ws",
                               ObjectDN,
                               GetDcUsed(FALSE));
            goto Cleanup;
        }

        if (ObjectDN) {
            delete ObjectDN;
            ObjectDN = NULL;
        }
    
     
    }

    Cleanup:

    if (pLdapMod[0]) {
        delete pLdapMod[0];
    }
    if (ObjectDN) {
        delete ObjectDN;
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;

}

BOOL CEnterprise::GetDnsZoneListFromFile(WCHAR *Filename,
                                         PDNS_ZONE_SERVER_LIST *ZoneServList)
/*++

Routine Description:

    Get the DNS zones from the file.

Parameters:

    none.

Return Values:

    TRUE for success; FALSE for failures

--*/
{

    HANDLE                hFile           = NULL;
    DWORD                 dwFileLen       = 0;
    WCHAR                 *pwszText       = NULL;
    WCHAR                 *pwszTextoffset = NULL;
    DWORD                 i               = 0;
    DWORD                 RecCount        = 0;
    DNS_STATUS            Status          = 0;

    hFile =  CreateFile(Filename,               // file name
                        GENERIC_WRITE,          // access mode
                        0,                      // share mode
                        NULL,                   // SD
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL                    // handle to template file
                        );
    if (INVALID_HANDLE_VALUE == hFile) {
        m_Error.SetErr(GetLastError(),
                       L"Could not create File %s",
                       Filename);
        goto Cleanup;
    }

    dwFileLen = GetFileSize(hFile,           // handle to file
                            NULL  // high-order word of file size
                            );

    if (dwFileLen == -1) {
        m_Error.SetErr(GetLastError(),
                       L"Could not get the file size of %s.",
                       Filename);
        goto Cleanup;
    }

    pwszText = new WCHAR[(dwFileLen+2)/sizeof(WCHAR)];
    if (!pwszText) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    if (!ReadFile(hFile,                   // handle to file
                  (LPVOID)pwszText,        // data buffer
                  dwFileLen,               // number of bytes to read
                  &dwFileLen,              // number of bytes read
                  NULL                     // overlapped buffer
                  ))
    {
        m_Error.SetErr(GetLastError(),
                        L"Failed to read file %s",
                        Filename);
        goto Cleanup;

    }

    if (!CloseHandle(hFile))
    {
        m_Error.SetErr(GetLastError(),
                        L"Failed to Close the file %ws.",
                        Filename);
    }
    hFile = NULL;

    //
    // Expect format of the record file is in the form 
    //
    // zone_name ip_of_dns_server
    //
    // BOF
    // dns.zone.1 xxx.xxx.xxx.xxx\r\n
    // dns.zone.2 xxx.xxx.xxx.xxx\r\n
    // ...
    // dns.zone.last xxx.xxx.xxx.xxx\r\n
    // EOF
    //


    //
    // Count the number of Dns records that we have.
    //
    _try{
    
        i = 0;
        while (pwszText[i]) {
    
            if (pwszText[i] == L'\r') {
    
                RecCount++;
    
            }
    
            i++;    
        }
    
        *ZoneServList = new DNS_ZONE_SERVER_LIST[RecCount+1];
        if (!*ZoneServList) {
    
            m_Error.SetMemErr();
            goto Cleanup;
    
        }
    
        i = 0;
        RecCount = 0;
        pwszTextoffset = pwszText+1;  //skip over the byte order mark
        while (pwszText[i]) {
    
            if (L' ' == pwszText[i]) {
    
                //
                // Copy the Zone name over to the structure field.
                //
                pwszText[i] = L'\0';
                (*ZoneServList)[RecCount].pZoneName = new WCHAR[wcslen(pwszTextoffset)+1];
                if (!(*ZoneServList)[RecCount].pZoneName) {
                    m_Error.SetMemErr();
                    goto Cleanup;
                }
    
                wcscpy((*ZoneServList)[RecCount].pZoneName,pwszText+i);
                pwszTextoffset = (pwszText+i);
    
                i++;
    
            } else if (L'\r' == pwszText[i] && L'\n' == pwszText[i+1]) {
    
                pwszText[i] = L'\0';
    
                (*ZoneServList)[RecCount].pServerArray->AddrCount = 1;
                (*ZoneServList)[RecCount].pServerArray->MaxCount  = 1;
    
                Status = Dns_Ip6StringToAddress_W((*ZoneServList)[RecCount].pServerArray->AddrArray,
                                                  pwszTextoffset);
                if (0 != Status) {
                    m_Error.SetErr(Status,
                                   L"Convert Dns IP string to address");
                    goto Cleanup;
                }
    
                RecCount++;
                i += 2;
                pwszTextoffset = (pwszText+i);
    
            } else {
    
                i++;
    
            }
    
        }
    } __except (EXCEPTION_EXECUTE_HANDLER)
    {
        m_Error.SetErr(ERROR_FILE_CORRUPT,
                       L"The file %ws is not in the expect format.\r\n   \
Expect format of the record file is in the form\r\n                  \
                                                                     \
zone_name ip_of_dns_server\r\n                                       \
                                                                     \
BOF\r\n                                                              \
dns.zone.1 xxx.xxx.xxx.xxx\r\n                                       \
dns.zone.2 xxx.xxx.xxx.xxx\r\n                                       \
...\r\n                                                              \
dns.zone.last xxx.xxx.xxx.xxx\r\n                                    \
EOF\r\n");
        goto Cleanup;

    }

    Cleanup:

    if (hFile) {
        CloseHandle(hFile);
    }

    if (pwszText) {
        delete [] pwszText;
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;



}

BOOL CEnterprise::VerifyDNSRecords()
{
    HANDLE                hFile           = NULL;
    DWORD                 dwFileLen       = 0;
    WCHAR                 *pwszText       = NULL;
    WCHAR                 *pwszTextoffset = NULL;
    PDNS_RENDOM_ENTRY     DnsEntryList    = NULL;
    PDNS_ZONE_SERVER_LIST ZoneServList    = NULL;
    DWORD                 i               = 0;
    DWORD                 RecCount        = 0;
    DNS_STATUS            Status          = 0;
    BOOL                  bsuccess        = TRUE;
    WCHAR                 ByteOrderMark   = (WCHAR)0xFEFF;
    DWORD                 bytesWritten    = 0;
    BOOL                  NotFound        = FALSE;

    hFile =  CreateFile(RENDOM_DNSRECORDS_FAILED_FILENAME,      // file name
                        GENERIC_READ,          // access mode
                        0,                      // share mode
                        NULL,                   // SD
                        OPEN_EXISTING,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL                    // handle to template file
                        );
    if (INVALID_HANDLE_VALUE == hFile) {
        if ( ERROR_FILE_NOT_FOUND == GetLastError() ) {
            NotFound = TRUE;
            hFile =  CreateFile(RENDOM_DNSRECORDS_FILENAME,      // file name
                                GENERIC_READ,          // access mode
                                0,                      // share mode
                                NULL,                   // SD
                                OPEN_EXISTING,          // how to create
                                FILE_ATTRIBUTE_NORMAL,  // file attributes
                                NULL                    // handle to template file
                                );
        }

        if (INVALID_HANDLE_VALUE == hFile) {
            m_Error.SetErr(GetLastError(),
                       L"Could not open File %ws",
                       NotFound?RENDOM_DNSRECORDS_FILENAME:RENDOM_DNSRECORDS_FAILED_FILENAME);
            goto Cleanup;
        }
    }

    dwFileLen = GetFileSize(hFile,           // handle to file
                            NULL  // high-order word of file size
                            );

    if (dwFileLen == -1) {
        m_Error.SetErr(GetLastError(),
                       L"Could not get the file size of %s.",
                       RENDOM_DNSRECORDS_FILENAME);
        goto Cleanup;
    }

    pwszText = new WCHAR[(dwFileLen+2)/sizeof(WCHAR)];
    if (!pwszText) {
        m_Error.SetMemErr();
        goto Cleanup;
    }
    //
    // end the string with a NULL
    //
    pwszText[dwFileLen] = L'\0';

    if (!ReadFile(hFile,                   // handle to file
                  (LPVOID)pwszText,        // data buffer
                  dwFileLen,               // number of bytes to read
                  &dwFileLen,              // number of bytes read
                  NULL                     // overlapped buffer
                  ))
    {
        m_Error.SetErr(GetLastError(),
                        L"Failed to read file %s",
                        RENDOM_DNSRECORDS_FILENAME);
        goto Cleanup;

    }

    if (!CloseHandle(hFile))
    {
        m_Error.SetErr(GetLastError(),
                        L"Failed to Close the file %ws.",
                        RENDOM_DNSRECORDS_FILENAME);
    }
    hFile = NULL;

    //
    // Erase the old file and start a new one that will contain
    // only the failed records.
    //
    hFile =  CreateFile(RENDOM_DNSRECORDS_FAILED_FILENAME,      // file name
                        GENERIC_WRITE,          // access mode
                        0,                      // share mode
                        NULL,                   // SD
                        CREATE_ALWAYS,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL                    // handle to template file
                        );
    if (INVALID_HANDLE_VALUE == hFile) {
        m_Error.SetErr(GetLastError(),
                        L"Could not create File %ws",
                        RENDOM_DNSRECORDS_FILENAME);
        goto Cleanup;
    }

    bsuccess = WriteFile(hFile,                    // handle to file
                         &ByteOrderMark,            // data buffer
                         sizeof(WCHAR),            // number of bytes to write
                         &bytesWritten,            // number of bytes written
                         NULL                      // overlapped buffer
                         );
    if (!bsuccess) {
        m_Error.SetErr(GetLastError(),
                       L"Could not write to File %ws",
                       RENDOM_DNSRECORDS_FILENAME);
        goto Cleanup;
    }

    //
    // Expect format of the record file is in the form
    //
    // dns.record.1\r\n
    // dns.record.2\r\n
    // ...
    // dns.record.last\r\n
    //


    _try{

        //
        // Count the number of Dns records that we have.
        //
        i = 0;
        while (pwszText[i]) {
    
            if (pwszText[i] == L'\r') {
    
                RecCount++;
    
            }
    
            i++;    
        }
    
        DnsEntryList = new DNS_RENDOM_ENTRY[RecCount+1];
        if (!DnsEntryList) {
    
            m_Error.SetMemErr();
            goto Cleanup;
    
        }
    
        //
        // Set the last element in the 
        //
        DnsEntryList[RecCount].pRecord = NULL;
    
        i = 0;
        RecCount = 0;
        pwszTextoffset = pwszText+1; // skip over the Byte order mark
        while (pwszTextoffset[i]) {
    
            if (L'\r' == pwszTextoffset[i] && L'\n' == pwszTextoffset[i+1]) {
    
                pwszTextoffset[i] = L'\0';
    
                DnsEntryList[RecCount].pRecord = Dns_CreateRecordFromString((PSTR)pwszTextoffset,
                                                                            DnsCharSetUnicode,
                                                                            0);
    
                RecCount++;
                i += 2;
                pwszTextoffset = (pwszTextoffset+i);
    
            } else {
    
                i++;
    
            }
    
        }
    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        m_Error.SetErr(ERROR_FILE_CORRUPT,
                       L"The file %ws is not in the expect format.  Recreate the file by reruning the upload stage of rendom.",
                       RENDOM_DNSRECORDS_FILENAME);
        goto Cleanup;
    }

    if (m_Opts->ShouldUseZoneList()) 
    {
        if (GetDnsZoneListFromFile(m_Opts->GetDNSZoneListFile(),
                                   &ZoneServList))
        {
            goto Cleanup;
        }
    }

    Status = Dns_VerifyRendomDcRecords(DnsEntryList,
                                       ZoneServList,
                                       m_Opts->ShouldUseZoneList()|m_Opts->ShouldUseFAZ());
    if (NO_ERROR != Status) 
    {
        if (DNS_ERROR_RCODE_SERVER_FAILURE == Status) {
            m_Error.SetErr(Status,
                           L"Could not determine the list of the authoritative DNS servers for the record(s).  Usual causes of such a failure are incorrect root hints or missing delegations in one of the zones.  Try correcting these on the dns server.");
        }

        if (ERROR_TIMEOUT == Status) {
            m_Error.SetErr(Status,
                           L"Could not determine the list of the authoritative DNS servers for the record(s).  Preferred and alternate DNS servers of the computer on which rendom is running are not responding, or their IP addresses are not correctly specified on the client.  Try to correct this by modifying the preferred and alternate DNS servers.");
        }

        m_Error.SetErr(Status,
                       L"Failed to verify DNS records");
        goto Cleanup;
    } 
    else 
    {
        if (!DnsEntryList->pServerArray) {
            m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                           L"The dns servers specified in %ws are non-authoritative for the zones.",
                           m_Opts->GetDNSZoneListFile());
            goto Cleanup;
        }
        
    }

    RecCount = 0;
    while (DnsEntryList[RecCount].pRecord) {

        i = 0;
        while (DnsEntryList[RecCount].pVerifyArray+i) {

            if (!DnsEntryList[RecCount].pVerifyArray[i]) {

                WCHAR Address[IP6_ADDRESS_STRING_BUFFER_LENGTH];
                WCHAR pBuffer[RENDOM_BUFFERSIZE];
                
                Status = Dns_WriteRecordToString((PCHAR)pBuffer,
                                                 RENDOM_BUFFERSIZE*sizeof(WCHAR),
                                                 DnsEntryList[RecCount].pRecord,
                                                 DnsCharSetUnicode,
                                                 0);
                if (0 != Status) {
                    m_Error.SetErr(Status,
                                   L"Convert Dns record to string");
                    goto Cleanup;
                }

                wprintf(L"Failed to find Dns record %ws on %ws",
                        DnsEntryList[RecCount].pRecord,
                        Dns_Ip6AddressToString_W(Address,
                                                 DnsEntryList[RecCount].pServerArray->AddrArray));
                m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                               L"One or more required dns record are unavailable.");

                bsuccess = WriteFile(hFile,                          // handle to file
                                     (PVOID)pBuffer,                 // data buffer
                                     wcslen(pBuffer)*sizeof(WCHAR),  // number of bytes to write
                                     &bytesWritten,                  // number of bytes written
                                     NULL                            // overlapped buffer
                                     );
                if (!bsuccess) {
                    m_Error.SetErr(GetLastError(),
                                   L"Could not write to File %ws",
                                   RENDOM_DNSRECORDS_FILENAME);
                    goto Cleanup;
                }


            }

        }

        RecCount++;

    }

    Cleanup:

    if (hFile) {
        CloseHandle(hFile);
    }

    if (pwszText) {
        delete [] pwszText;
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CEnterprise::SaveCNameRecord (WCHAR  *NtdsGuid,
                                   WCHAR  *DNSForestRootName,
                                   HANDLE hFile)
{
    std::wstring cnameRecord;

    try {

        cnameRecord  = std::wstring(NtdsGuid);
        cnameRecord += std::wstring(L"._msdcs.");
        cnameRecord += std::wstring(DNSForestRootName);
        cnameRecord += std::wstring(L"\r\n");

    }
    catch(...)
    {
        m_Error.SetMemErr();
    }

    RecordDnsRec(cnameRecord,
                 hFile);

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CEnterprise::SaveDCRecord(WCHAR  *DNSDomainName,
                               HANDLE hFile)
{
    std::wstring dcRecord;

    try {

        dcRecord = std::wstring(L"_ldap._tcp.dc._msdcs.");
        dcRecord += std::wstring(DNSDomainName);
        dcRecord += std::wstring(L"\r\n");

    }
    catch(...)
    {
        m_Error.SetMemErr();
    }

    RecordDnsRec(dcRecord,
                 hFile);

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CEnterprise::SavePDCRecord(WCHAR  *DNSDomainName,
                                HANDLE hFile)
{
    std::wstring pdcRecord;

    try {

        pdcRecord = std::wstring(L"_ldap._tcp.pdc._msdcs.");
        pdcRecord += std::wstring(DNSDomainName);
        pdcRecord += std::wstring(L"\r\n");

    }
    catch(...)
    {
        m_Error.SetMemErr();
    }

    RecordDnsRec(pdcRecord,
                 hFile);

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CEnterprise::SaveGCRecord(WCHAR  *DNSForestRootName,
                               HANDLE hFile)
{
    std::wstring gcRecord;

    try {

        gcRecord = std::wstring(L"_ldap._tcp.gc._msdcs.");
        gcRecord += std::wstring(DNSForestRootName);
        gcRecord += std::wstring(L"\r\n");

    }
    catch(...)
    {
        m_Error.SetMemErr();
    }

    RecordDnsRec(gcRecord,
                 hFile);

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CEnterprise::RecordDnsRec(std::wstring Record,
                               HANDLE hFile)
{
    BOOL    bsuccess     = TRUE;
    DWORD   bytesWritten = 0;

    bsuccess = WriteFile(hFile,                               // handle to file
                         Record.c_str(),                      // data buffer
                         Record.size()*sizeof(WCHAR),         // number of bytes to write
                         &bytesWritten,                       // number of bytes written
                         NULL                                 // overlapped buffer
                         );
    if (!bsuccess)
    {
        m_Error.SetErr(GetLastError(),
                        L"Could not Write to File %s",
                        RENDOM_DNSRECORDS_FILENAME);
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CEnterprise::CreateDnsRecordsFile()
{
    HANDLE  hFile                             = NULL;
    WCHAR   ByteOrderMark                     = (WCHAR)0xFEFF;
    CDomain *Domain                           = m_DomainList;
    CDcSpn  *Dc                               = NULL;
    BOOL    bsuccess                          = TRUE;
    DWORD   bytesWritten                      = 0;
    
    hFile =  CreateFile(RENDOM_DNSRECORDS_FILENAME,      // file name
                        GENERIC_WRITE,          // access mode
                        0,                      // share mode
                        NULL,                   // SD
                        CREATE_ALWAYS,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL                    // handle to template file
                        );
    if (INVALID_HANDLE_VALUE == hFile) {
        m_Error.SetErr(GetLastError(),
                        L"Could not create File %s",
                        RENDOM_DNSRECORDS_FILENAME);
        goto Cleanup;
    }

    bsuccess = WriteFile(hFile,                    // handle to file
                         &ByteOrderMark,            // data buffer
                         sizeof(WCHAR),            // number of bytes to write
                         &bytesWritten,            // number of bytes written
                         NULL                      // overlapped buffer
                         );
    if (!bsuccess)
    {
        m_Error.SetErr(GetLastError(),
                        L"Could not Write to File %s",
                        RENDOM_DNSRECORDS_FILENAME);
        goto Cleanup;
    }

    if (!SaveGCRecord(m_ForestRoot->GetDnsRoot(),
                      hFile))
    {
        goto Cleanup;
    }

    while (Domain) {

        if (!SavePDCRecord(Domain->GetDnsRoot(),
                           hFile))
        {
            goto Cleanup;
        }

        if (!SaveDCRecord(Domain->GetDnsRoot(),
                          hFile))
        {
            goto Cleanup;
        }

        Dc = Domain->GetDcSpn();

        while (Dc) {

            if (!SaveCNameRecord(Dc->GetNtdsGuid(FALSE),
                                 m_ForestRoot->GetDnsRoot(FALSE),
                                 hFile))
            {
                goto Cleanup;
            }

            Dc = Dc->GetNextDcSpn();

        }

        Domain = Domain->GetNextDomain();

    }

    Cleanup:

    if (hFile) {
        CloseHandle(hFile);
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;

}
       
BOOL CEnterprise::UploadScript()
{
    DWORD         Length = 0;
    ULONG         LdapError = LDAP_SUCCESS;
    WCHAR         *DefaultFilter = L"objectClass=*";
    WCHAR         *PartitionsRdn = L"CN=Partitions,";
    WCHAR         *ConfigurationDN = NULL;
    WCHAR         *PartitionsDn = NULL;
    WCHAR         *AliasName = NULL;
    WCHAR         *ObjectDN = NULL;
    BOOL          Found = FALSE;
    
    if (!m_hldap) 
    {
        if(!LdapConnectandBindToDomainNamingFSMO())
        {
            goto Cleanup;
        }
    }

    if (!CheckForExistingScript(&Found)) 
    {
        goto Cleanup;
    }


    if( Found )
    {
        m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                       L"A domain rename operation is already in progress. The current operation must end before a new one can begin.");
        goto Cleanup;
    }

    //update the msDS-DNSRootAlias atributes on the crossref objects
    LDAPModW         **pLdapMod = NULL;

    for (CDomain *d = m_DomainList; d;d = d->GetNextDomain()) {

        DWORD dwErr = ERROR_SUCCESS;

        if (!d->isDnsNameRenamed()) {
            continue;
        }

        AliasName = d->GetDnsRoot();
        ObjectDN = d->GetDomainCrossRef()->GetDN();
        if (m_Error.isError()) {
            goto Cleanup;
        }
    
        AddModMod (L"msDS-DNSRootAlias", AliasName, &pLdapMod);
        
        dwErr = ldap_modify_sW (m_hldap, ObjectDN, pLdapMod);
    
        if(dwErr != LDAP_SUCCESS) {
            m_Error.SetLdapErr(m_hldap,
                               dwErr,
                               L"Failed to upload Dns Root alias on the DN: %s, on host %ws",
                               ObjectDN,
                               GetDcUsed(FALSE));
        }
    
        FreeMod (&pLdapMod);
        delete (AliasName);
        AliasName = NULL;
        delete (ObjectDN);
        ObjectDN = NULL;

    }

    //
    // Build string for the partitions DN
    //
    ConfigurationDN = m_ConfigNC->GetDN();
    if (m_Error.isError()) {
        goto Cleanup;
    }
    ASSERT(ConfigurationDN);
    if (!ConfigurationDN) {
        goto Cleanup;
    }
    
    Length =  (wcslen( ConfigurationDN )
            + wcslen( PartitionsRdn )   
            + 1);
                                                          
    PartitionsDn = new WCHAR[Length+1];
    if (!PartitionsDn) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    wcscpy( PartitionsDn, PartitionsRdn );
    wcscat( PartitionsDn, ConfigurationDN );

    //
    // Place the intentions script on the partitions object.
    //
    if(!m_xmlgen->UploadScript(m_hldap,
                               PartitionsDn,
                               &m_DcList))
    {
        goto Cleanup;
    }



    Cleanup:

    if (PartitionsDn) {
        delete [] PartitionsDn;
    }
    if (ConfigurationDN) {
        delete ConfigurationDN;
    }
    if (AliasName) {
        delete AliasName;
    }
    if (ObjectDN) {
        delete ObjectDN;
    }

    if (m_Error.isError()) {
        return FALSE;
    }
    return TRUE;
}       

// This function is for debugging only.  Will dump out the 
// Compelete description of you enterprise onto the screen
VOID CEnterprise::DumpEnterprise()
{
    wprintf(L"Dump Enterprise****************************************\n");
    if (m_ConfigNC) {
        wprintf(L"ConfigNC:\n");
        m_ConfigNC->DumpCDsName();
    } else {
        wprintf(L"ConfigNC: (NULL)\n");
    }

    if (m_SchemaNC) {
        wprintf(L"m_SchemaNC:\n");
        m_SchemaNC->DumpCDsName();
    } else {
        wprintf(L"m_SchemaNC: (NULL)\n");
    }

    if (m_ForestRootNC) {
        wprintf(L"m_ForestRootNC:\n");
        m_ForestRootNC->DumpCDsName();
    } else {
        wprintf(L"m_ForestRootNC: (NULL)\n");
    }

    wprintf(L"maxReplicationEpoch: %d\n",m_maxReplicationEpoch);

    wprintf(L"ERROR: %d\n",m_Error.GetErr());

    wprintf(L"DomainList::\n");
    
    CDomain *p = m_DomainList;
    while (NULL != p) {
        p->DumpCDomain();
        p = p->GetNextDomain();
    }

    wprintf(L"descList::\n");
    
    p = m_descList;
    while (NULL != p) {
        p->DumpCDomain();
        p = p->GetNextDomain();
    }

    wprintf(L"Dump Enterprise****************************************\n");

}

BOOL CEnterprise::ReadStateFile()
{
    HRESULT                             hr;
    ISAXXMLReader *                     pReader    = NULL;
    CXMLDcListContentHander*            pHandler   = NULL; 
    IClassFactory *                     pFactory   = NULL;

    VARIANT                             varText;
    CHAR                               *pszText;
    WCHAR                              *pwszText;

    HANDLE                             fpScript;
    DWORD                              dwFileLen;

    BSTR                               bstrText    = NULL;

    
    VariantInit(&varText);
    varText.vt = VT_BYREF|VT_BSTR;


    fpScript = CreateFile(m_Opts->GetStateFileName(),   // file name
                          GENERIC_READ,                // access mode
                          FILE_SHARE_READ,             // share mode
                          NULL,                        // SD
                          OPEN_EXISTING,               // how to create
                          0,                           // file attributes
                          NULL                        // handle to template file
                          );
    if (INVALID_HANDLE_VALUE == fpScript) {
        m_Error.SetErr(GetLastError(),
                       L"Failed Could not open file %s.",
                       m_Opts->GetStateFileName());
        goto CleanUp;
    }

    dwFileLen = GetFileSize(fpScript,           // handle to file
                            NULL  // high-order word of file size
                            );

    if (dwFileLen == -1) {
        m_Error.SetErr(GetLastError(),
                       L"Could not get the file size of %s.",
                       m_Opts->GetStateFileName());
        CloseHandle(fpScript);
        goto CleanUp;
    }

    pwszText = new WCHAR[(dwFileLen+2)/sizeof(WCHAR)];
    if (!pwszText) {
        m_Error.SetMemErr();
        CloseHandle(fpScript);
        goto CleanUp;
    }

    if (!ReadFile(fpScript,                // handle to file
                  (LPVOID)pwszText,        // data buffer
                  dwFileLen,               // number of bytes to read
                  &dwFileLen,              // number of bytes read
                  NULL                     // overlapped buffer
                  ))
    {
        m_Error.SetErr(GetLastError(),
                       L"Failed to read file %s",
                       m_Opts->GetStateFileName());
        goto CleanUp;

    }

    if (!CloseHandle(fpScript))
    {
        m_Error.SetErr(GetLastError(),
                       L"Failed to Close the file %s.",
                       m_Opts->GetStateFileName());
    }
    
    //skip Byte-Order-Mark
    
    pwszText[dwFileLen/sizeof(WCHAR)] = 0;
    bstrText = SysAllocString(  ++pwszText );
    
    varText.pbstrVal = &bstrText; 

    delete (--pwszText); pwszText = NULL;

    
    // 
    //

    GetClassFactory( CLSID_SAXXMLReader, &pFactory);
	
	hr = pFactory->CreateInstance( NULL, __uuidof(ISAXXMLReader), (void**)&pReader);

	if(!FAILED(hr)) 
	{
        pHandler = new CXMLDcListContentHander(this);
        if (!pHandler) {
            m_Error.SetMemErr();
            goto CleanUp;
        }
        hr = pReader->putContentHandler(pHandler);
        if(FAILED(hr)) 
	    {
            m_Error.SetErr(HRESULTTOWIN32(hr),
                           L"Failed to set a Content handler for the parser");

            goto CleanUp;
        }
        
        hr = pReader->parse(varText);
        if(FAILED(hr)) 
	    {
            if (m_Error.isError()) {
                goto CleanUp;
            }
            m_Error.SetErr(HRESULTTOWIN32(hr),
                           L"Failed to parser the File %s",
                           m_Opts->GetStateFileName());
            goto CleanUp;
        }
		

    }
	else 
	{
		m_Error.SetErr(HRESULTTOWIN32(hr),
                       L"Failed to parse document");
    }

CleanUp:

    if (pReader) {
        pReader->Release();
    }

    if (pHandler) {
        delete pHandler;
    }

    if (pFactory) {
        pFactory->Release();
    }

    if (bstrText) {
        SysFreeString(bstrText);   
    }

    if (m_Error.isError()) {
        return FALSE;
    }


    return TRUE;
}

BOOL CEnterprise::ReadForestChanges()
{
    HRESULT                             hr;
    ISAXXMLReader *                     pReader    = NULL;
    CXMLDomainListContentHander*        pHandler   = NULL; 
    IClassFactory *                     pFactory   = NULL;

    VARIANT                             varText;
    CHAR                               *pszText;
    WCHAR                              *pwszText;

    HANDLE                             fpScript;
    DWORD                              dwFileLen;

    BSTR                               bstrText    = NULL;

    
    VariantInit(&varText);
    varText.vt = VT_BYREF|VT_BSTR;


    fpScript = CreateFile(m_Opts->GetDomainlistFileName(),   // file name
                          GENERIC_READ,                // access mode
                          FILE_SHARE_READ,             // share mode
                          NULL,                        // SD
                          OPEN_EXISTING,               // how to create
                          0,                           // file attributes
                          NULL                        // handle to template file
                          );
    if (INVALID_HANDLE_VALUE == fpScript) {
        m_Error.SetErr(GetLastError(),
                       L"Failed Could not open file %s.",
                       m_Opts->GetDomainlistFileName());
        goto CleanUp;
    }

    dwFileLen = GetFileSize(fpScript,           // handle to file
                            NULL  // high-order word of file size
                            );

    if (dwFileLen == -1) {
        m_Error.SetErr(GetLastError(),
                       L"Could not get the file size of %s.",
                       m_Opts->GetDomainlistFileName());
        CloseHandle(fpScript);
        goto CleanUp;
    }

    pwszText = new WCHAR[(dwFileLen+2)/sizeof(WCHAR)];
    if (!pwszText) {
        m_Error.SetMemErr();
        CloseHandle(fpScript);
        goto CleanUp;
    }

    if (!ReadFile(fpScript,                // handle to file
                  (LPVOID)pwszText,        // data buffer
                  dwFileLen,               // number of bytes to read
                  &dwFileLen,              // number of bytes read
                  NULL                     // overlapped buffer
                  ))
    {
        m_Error.SetErr(GetLastError(),
                        L"Failed to read file %s",
                        m_Opts->GetDomainlistFileName());
        goto CleanUp;

    }

    if (!CloseHandle(fpScript))
    {
        m_Error.SetErr(GetLastError(),
                        L"Failed to Close the file %s.",
                        m_Opts->GetDomainlistFileName());
    }
    
    //skip Byte-Order-Mark
    
    pwszText[dwFileLen/sizeof(WCHAR)] = 0;
    bstrText = SysAllocString(  ++pwszText );
    
    varText.pbstrVal = &bstrText; 

    delete (--pwszText); pwszText = NULL;

    
    // 
    //

    GetClassFactory( CLSID_SAXXMLReader, &pFactory);
	
	hr = pFactory->CreateInstance( NULL, __uuidof(ISAXXMLReader), (void**)&pReader);

	if(!FAILED(hr)) 
	{
		pHandler = new CXMLDomainListContentHander(this);
        if (!pHandler) {
            m_Error.SetMemErr();
            goto CleanUp;
        }
		hr = pReader->putContentHandler(pHandler);
        if(FAILED(hr)) 
	    {
            m_Error.SetErr(HRESULTTOWIN32(hr),
                            L"Failed to set a Content handler for the parser");

            goto CleanUp;
        }
        
        hr = pReader->parse(varText);
        if(FAILED(hr)) 
	    {
            if (m_Error.isError()) {
                goto CleanUp;
            }
            m_Error.SetErr(HRESULTTOWIN32(hr),
                            L"Failed to parser the File %s",
                            m_Opts->GetDomainlistFileName());
            goto CleanUp;
        }
		

    }
	else 
	{
		m_Error.SetErr(HRESULTTOWIN32(hr),
                        L"Failed to parse document");
    }

CleanUp:

    if (pReader) {
        pReader->Release();
    }

    if (pHandler) {
        delete pHandler;
    }

    if (pFactory) {
        pFactory->Release();
    }

    if (bstrText) {
        SysFreeString(bstrText);   
    }

    if (m_Error.isError()) {
        return FALSE;
    }


    return TRUE;
    
       
}


// This will add a domain to the list of domains in the enterprise.
// All domains should be add to the enterprise before the forest structure is
// built using BuildForest().  If you try to pass a blank domain to the 
// list the function will fail.
BOOL CEnterprise::AddDomainToDomainList(CDomain *d)
{
    if (!d) 
    {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"An Empty Domain was passed to AddDomainToDomainList");
        return false;
    }
    
    d->SetNextDomain(m_DomainList);
    m_DomainList = d;
    return true;
    

}

BOOL CEnterprise::AddDomainToDescList(CDomain *d)
{
    if (!d) 
    {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"An Empty Domain was passed to AddDomainToDescList");
        return false;
    }
    
    d->SetNextDomain(m_descList);
    m_descList = d;
    return true;
}

BOOL CEnterprise::ClearLinks(CDomain *d)
{
    if (!d->SetParent(NULL))
    {
        return FALSE;
    }
    if (!d->SetLeftMostChild(NULL))
    {
        return FALSE;
    }
    if (!d->SetRightSibling(NULL))
    {
        return FALSE;
    }

    return TRUE;
}


// This function will gather all information nessary for domain restucturing
// expect for the new name of the domains.
BOOL CEnterprise::ReadDomainInformation() 
{
    if (!LdapConnectandBindToDomainNamingFSMO())
    {
        return FALSE;
    }
    if (!GetInfoFromRootDSE()) 
    {
        return FALSE;
    }
    if (!EnumeratePartitions()) 
    {
        return FALSE;
    }
    if (GetOpts()->ShouldUpLoadScript()) 
    {
        if (!GetReplicationEpoch())
        {
            return FALSE;
        }
        if (!GetTrustsAndSpnInfo()) 
        {
            return FALSE;
        }
        if (!ReadForestChanges()) 
        {
            return FALSE;
        }
        if (!CheckConsistency()) 
        {
            return FALSE;
        }
    }
    if (GetOpts()->ShouldShowForest()) 
    {
        if (!ReadForestChanges()) 
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL CEnterprise::MergeForest()
{
    for (CDomain *desc = m_descList; desc; desc = desc->GetNextDomain() ) 
    {
        WCHAR *Guid = desc->GetGuid();
        if (!Guid) {
            return FALSE;
        }
        CDomain *domain = m_DomainList->LookupByGuid(Guid);
        if (!domain) {
            m_Error.SetErr(ERROR_OBJECT_NOT_FOUND,
                            L"Could not find the Guid %s\n",
                            Guid);
                           
            return FALSE;
        }
        delete Guid;
        if (!domain->Merge(desc))
        {
            return FALSE;
        }
                
    }

    if (!BuildForest(TRUE))
    {
        return FALSE;
    }

    while (NULL != m_descList) {
        CDomain *p = m_descList->GetNextDomain();
        delete m_descList;
        m_descList = p;
    }

    if (m_Opts->ShouldUpLoadScript()) {
        if (!EnsureValidTrustConfiguration()) 
        {
            return FALSE;
        }
    }

    return TRUE;
}

// This functions will Build the forest stucture.
// newForest - if true forest is built based on the new names given.
//             if False then the forest is built based on it's current structure               
BOOL CEnterprise::BuildForest(BOOL newForest)
{

    if (!TearDownForest()) 
    {
        return FALSE;
    }

    //link each domain to its parent and siblings, if any
    for (CDomain *domain = m_DomainList; domain; domain=domain->GetNextDomain() ) {
        CDomain *domainparent = newForest?m_DomainList->LookupByDnsRoot(domain->GetParentDnsRoot(FALSE)):
                                          m_DomainList->LookupByPrevDnsRoot(domain->GetPrevParentDnsRoot(FALSE));
        if(domainparent)
        {
            domain->SetParent(domainparent);
            domain->SetRightSibling(domainparent->GetLeftMostChild());
            domainparent->SetLeftMostChild(domain);
        }       
    }

    //link the roots together
    for (CDomain *domain = m_DomainList; domain; domain=domain->GetNextDomain() ) {
        if ( (NULL == domain->GetParent()) && (domain != m_ForestRoot) ) {
            domain->SetRightSibling(m_ForestRoot->GetRightSibling());
            m_ForestRoot->SetRightSibling(domain);
        }
    }

    if (!CreateChildBeforeParentOrder()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CEnterprise::TraverseDomainsParentBeforeChild()
{
    if (NULL == m_Action) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"TraverseDomainsParentBeforeChild called with a action defined");
        return FALSE;
    }

    CDomain *n = m_ForestRoot;
    
    while (NULL != n) {
        if (!(this->*m_Action)(n)) {
            return FALSE;
        }
        if (NULL != n->GetLeftMostChild()) {

            n = n->GetLeftMostChild();

        } else if (NULL != n->GetRightSibling()) {

            n = n->GetRightSibling();

        } else {

            for (n = n->GetParent(); n; n = n->GetParent()) {

                if (n->GetRightSibling()) {

                    n = n->GetRightSibling();
                    break;

                }
            }
        }
    }

    return TRUE;
}

BOOL CEnterprise::TraverseDomainsChildBeforeParent()
{
    if (NULL == m_Action) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"TraverseDomainsChildBeforeParent called with a action defined");
        return FALSE;
    }

    for (CDomain *n = m_DomainList; n; n = n->GetNextDomain()) {
        if (!(this->*m_Action)(n)) {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL CEnterprise::SetAction(BOOL (CEnterprise::*p_Action)(CDomain *))
{                                                                         
    if (!p_Action) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"SetAction was called without a Action specified");
        return FALSE;
    }
    m_Action = p_Action;

    return TRUE;

}

CReadOnlyEntOptions* CEnterprise::GetOpts()
{
    return m_Opts;
}
    

BOOL CEnterprise::ClearAction()
{
    m_Action = NULL;
    return TRUE;
}

BOOL CEnterprise::CreateChildBeforeParentOrder()
{
    m_DomainList = NULL;

    if (!SetAction(&CEnterprise::AddDomainToDomainList)) {
        return FALSE;
    }
    if (!TraverseDomainsParentBeforeChild()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    }
    return TRUE;
}

BOOL CEnterprise::EnsureValidTrustConfiguration()
{
    CDomain         *d            = NULL;
    CDomain         *ds           = NULL;
    CDomain         *dc           = NULL;
    CTrustedDomain  *tdo          = NULL;
    BOOL            Trustfound    = FALSE;

    for (d = m_DomainList; d != NULL ; d = d->GetNextDomain()) {
        //make sure this is a real domain
        if (!d->isDomain() || d->isDisabled() || d->isExtern()) {
            continue;
        }
        if ( NULL != d->GetParent() ) {
            //This is a child Domain
            tdo = d->GetTrustedDomainList();
            while (tdo) {
                if ( tdo->GetTrustPartner() == d->GetParent() ) 
                {
                    Trustfound = TRUE;
                    break;
                }
                tdo = (CTrustedDomain*)tdo->GetNext();
            }
            if (!Trustfound) {
                if (!m_Error.isError()) {
                    m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                                    L"Missing trust from %ws to %ws. Create the trust and try the operation again",
                                    d->GetPrevDnsRoot(FALSE),
                                    d->GetParent()->GetPrevDnsRoot(FALSE));
                } else {
                    m_Error.AppendErr(L"Missing trust from %ws to %ws. Create the trust and try the operation again",
                                       d->GetPrevDnsRoot(FALSE),
                                       d->GetParent()->GetPrevDnsRoot(FALSE));
                }
            }

            Trustfound = FALSE;
            
        } else {
            //This is a root of a domain tree
            if (d == m_ForestRoot) {
                for ( ds = d->GetLeftMostChild(); ds != NULL; ds = ds->GetRightSibling() ) {
                    if (!ds->isDomain() || ds->isDisabled() || ds->isExtern()) {
                        continue;
                    }
                    // d is the forest root and ds is another root
                    tdo = d->GetTrustedDomainList();
                    while (tdo) {
                        if ( tdo->GetTrustPartner() == ds ) 
                        {
                            Trustfound = TRUE;
                            break;
                        }
                        tdo = (CTrustedDomain*)tdo->GetNext();
                    }
                    if (!Trustfound) {
                        if (!m_Error.isError()) {
                            m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                                            L"Missing trust from %ws to %ws. Create the trust and try the operation again",
                                            d->GetPrevDnsRoot(FALSE),
                                            ds->GetPrevDnsRoot(FALSE));
                        } else {
                            m_Error.AppendErr(L"Missing trust from %ws to %ws. Create the trust and try the operation again",
                                               d->GetPrevDnsRoot(FALSE),
                                               ds->GetPrevDnsRoot(FALSE));
                        }
                    }
        
                    Trustfound = FALSE;
                
                }
                for ( ds = d->GetRightSibling(); ds != NULL; ds = ds->GetRightSibling() ) {
                    if (!ds->isDomain() || ds->isDisabled() || ds->isExtern()) {
                        continue;
                    }
                    // d is the forest root and ds is another root
                    tdo = d->GetTrustedDomainList();
                    while (tdo) {
                        if ( tdo->GetTrustPartner() == ds ) 
                        {
                            Trustfound = TRUE;
                            break;
                        }
                        tdo = (CTrustedDomain*)tdo->GetNext();
                    }
                    if (!Trustfound) {
                        if (!m_Error.isError()) {
                            m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                                            L"Missing trust from %ws to %ws. Create the trust and try the operation again",
                                            d->GetPrevDnsRoot(FALSE),
                                            ds->GetPrevDnsRoot(FALSE));
                        } else {
                            m_Error.AppendErr(L"Missing trust from %ws to %ws. Create the trust and try the operation again",
                                               d->GetPrevDnsRoot(FALSE),
                                               ds->GetPrevDnsRoot(FALSE));
                        }
                    }
        
                    Trustfound = FALSE;
                
                }
            } else {
                //d is a root but not the forest root
                tdo = d->GetTrustedDomainList();
                while (tdo) {
                    if ( tdo->GetTrustPartner() == m_ForestRoot ) 
                    {
                        Trustfound = TRUE;
                        break;
                    }
                    tdo = (CTrustedDomain*)tdo->GetNext();
                }
                if (!Trustfound) {
                    if (!m_Error.isError()) {
                        m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                                        L"Missing trust from %ws to %ws. Create the trust and try the operation again",
                                        d->GetPrevDnsRoot(FALSE),
                                        m_ForestRoot->GetPrevDnsRoot(FALSE));
                    } else {
                        m_Error.AppendErr(L"Missing trust from %ws to %ws. Create the trust and try the operation again",
                                           d->GetPrevDnsRoot(FALSE),
                                           m_ForestRoot->GetPrevDnsRoot(FALSE));
                    }
                }
    
                Trustfound = FALSE;

            }
        }
        for (dc = d->GetLeftMostChild(); dc != NULL; dc = dc->GetRightSibling()) {
            if (!dc->isDomain() || dc->isDisabled() || dc->isExtern()) {
                continue;
            }
            // d is parent, dc is one of its children
            tdo = d->GetTrustedDomainList();
            while (tdo) {
                if ( tdo->GetTrustPartner() == dc ) 
                {
                    Trustfound = TRUE;
                    break;
                }
                tdo = (CTrustedDomain*)tdo->GetNext();
            }
            if (!Trustfound) {
                if (!m_Error.isError()) {
                    m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                                    L"Missing trust from %ws to %ws. Create the trust and try the operation again",
                                    d->GetPrevDnsRoot(FALSE),
                                    dc->GetPrevDnsRoot(FALSE));
                } else {
                    m_Error.AppendErr(L"Missing trust from %ws to %ws. Create the trust and try the operation again",
                                       d->GetPrevDnsRoot(FALSE),
                                       dc->GetPrevDnsRoot(FALSE));
                }
            }

            Trustfound = FALSE;

        }
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;

}

BOOL CEnterprise::TearDownForest()
{
    if (!SetAction(&CEnterprise::ClearLinks)) {
        return FALSE;
    }
    if (!TraverseDomainsChildBeforeParent()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    }
    return TRUE;
}

BOOL CEnterprise::ScriptDomainRenaming(CDomain *d)
{
    BOOL ret = TRUE;
    WCHAR *Path = NULL;
    WCHAR *Guid = NULL;
    WCHAR *DNSRoot = NULL;
    WCHAR *ToPath = NULL;
    WCHAR *PathTemplate = L"DC=%s,DC=INVALID";
    WCHAR *ToPathTemplate = L"DC=%s,"; 

    if (!d) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"ScriptTreeFlatting did not recieve a valid domain");
        goto Cleanup;
    }
    Guid = d->GetDomainDnsObject()->GetGuid();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    ASSERT(Guid);
    if (!Guid) {
        ret = FALSE;
        goto Cleanup;
    }
    Path = new WCHAR[wcslen(PathTemplate)+
                     wcslen(Guid)+1];
    if (!Path) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(Path,
             PathTemplate,
             Guid);

    DNSRoot = d->GetDnsRoot();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    ToPath = DNSRootToDN(DNSRoot);
    if (!ToPath) {
        ret = FALSE;
        goto Cleanup;
    }


    m_xmlgen->Move(Path,
                   ToPath);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    Cleanup:

    if (DNSRoot) {
        delete DNSRoot;
    }

    if (ToPath) {
        delete ToPath;
    }
    if (Path) {
        delete [] Path;
    }
    if (Guid) {
        delete Guid;
    }

    return ret;

}

WCHAR* CEnterprise::DNSRootToDN(WCHAR *DNSRoot)
{
    if (!DNSRoot) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"A NULL was passed to DNSRoot\n");
        return NULL;
    }

    ASSERT(!m_Error.isError());

    WCHAR *buf = NULL;
    WCHAR *pbuf = NULL;
    WCHAR *p = DNSRoot;
    WCHAR *q = DNSRoot;
    DWORD size = 0;

    while ((*p != L'.') && (*p != L'\0')) {
        size++;
        p++;
    }
    buf = new WCHAR[size+5];
    if (!buf) {
        m_Error.SetMemErr();
        goto Cleanup;
    }
    wcscpy(buf,L"DC=");
    wcsncat(buf,q,size);
    
    if (*p) {
        p++;
        q=p;
    }

    while (*p) {
        size = 0;
        while ((*p != L'.') && (*p != L'\0')) {
            p++;
            size++;
        }
        pbuf = buf;
        buf = new WCHAR[wcslen(pbuf)+size+5];
        if (!buf) {
            m_Error.SetMemErr();
            goto Cleanup;
        }
        wcscpy(buf,pbuf);
        delete pbuf;
        pbuf = NULL;

        wcscat(buf,L",DC=");
        wcsncat(buf,q,size);
        
        if (*p){
            p++;
            q=p;
        }
        
    }

Cleanup:

    if (m_Error.isError()) {
        if (pbuf) {
            delete [] pbuf;
            pbuf = NULL;
        }
        if (buf) {
            delete [] buf;
            buf = NULL;
        }
    }

    return buf;
    
}

BOOL CEnterprise::CheckConsistencyGuids(CDomain *d)
{
    WCHAR *Guid = NULL;
    WCHAR *NetBiosName = NULL;
    CDomain *p = NULL;
    UUID Uuid;
    DWORD Result = ERROR_SUCCESS;
    BOOL res = TRUE;

    //for every Guid in the forest description Make sure it is 
    //1. syntactically correct
    //2. Has an entry in the current forest list
    //3. Only occurs once in the list
    //4. If a NDNC the make sure there is no NetbiosName in the description.
    //5. If is a Domain NC make sure that there is a NetbiosName in the description

    Guid = d->GetGuid(FALSE);
    

    Result = UuidFromStringW(Guid,
                             &Uuid
                             );
    if (RPC_S_INVALID_STRING_UUID == Result) {
        m_Error.SetErr(ERROR_GEN_FAILURE,
                        L"Domain Guid %s from the forest description is not in a valid format",
                        Guid);

    }

    p = m_DomainList->LookupByGuid(Guid);
    if (!p)
    {
        m_Error.SetErr(ERROR_GEN_FAILURE,
                        L"Domain Guid %s from the forest description does not exist in current forest.",
                        Guid);
        res = FALSE;
        goto Cleanup;
    }

    if (!p->isDomain()) {
        NetBiosName = d->GetNetBiosName(FALSE);
        if (NetBiosName) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"NetBIOS name not allowed in application on Guid %s in the forest Description",
                            Guid);
            res = FALSE;
            goto Cleanup;  
        }
    }

    d = d->GetNextDomain();
    
    if (d && d->LookupByGuid(Guid)) {
        m_Error.SetErr(ERROR_GEN_FAILURE,
                        L"Domain Guid %s occurs twice in the forest description",
                        Guid);
        res = FALSE;
        goto Cleanup;
    }

    Cleanup:

    return res;
    
}

BOOL CEnterprise::CheckConsistencyNetBiosNames(CDomain *d)
{
    CDomain *p = NULL;
    BOOL res = TRUE;
    WCHAR *NetBiosName = NULL;
    WCHAR *Guid = d->GetGuid(FALSE);

    p = m_DomainList->LookupByGuid(Guid);
    if (!p)
    {
        m_Error.SetErr(ERROR_GEN_FAILURE,
                        L"Domain Guid %s from the forest description does not exist in current forest.",
                        Guid);
        res = FALSE;
        goto Cleanup;
    }

    if (!p->isDomain() || p->isExtern() || p->isDisabled()) 
    {
        return TRUE;
    }

    NetBiosName = d->GetNetBiosName(FALSE);
    //now that we have our netbios name lets do
    //our checking of it.
    
    //1. Check to see if the netbios name is syntactically correct
    //2. make sure the netbios is not being traded with another domain
    //3. Make sure that the netbiosname is in the forest description.
    if (!NetBiosName) {
        m_Error.SetErr(ERROR_GEN_FAILURE,
                       L"NetBIOS name required on Guid %s in the forest Description",
                       Guid);
        res = FALSE;
        goto Cleanup;  
    }

    if ( !ValidateNetbiosName(NetBiosName) )
    {
        m_Error.SetErr(ERROR_GEN_FAILURE,
                       L"%s is not a valid NetBIOS name.  The name must be 15 or less characters and not contain any of the following characters \"/\\[]:|<>+=;?,*",
                       NetBiosName);
        res = FALSE;
        goto Cleanup;
    
    }
    
    if (CDomain *Tempdomain = m_DomainList->LookupByPrevNetbiosName(NetBiosName))
    {
        WCHAR *TempGuid = Tempdomain->GetGuid(FALSE);
        if (TempGuid && Guid && wcscmp(TempGuid,Guid) != 0) {
    
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"NetBIOS domain name %s in the forest description "
                            L"names a different domain in the current forest. "
                            L"You can't reassign a NetBIOS domain name in a single"
                            L"forest restructuring.",
                            NetBiosName);
            res = FALSE;
            goto Cleanup;
    
        }
        
    }
    
    CDomain *Tempdomain = m_descList->LookupByNetbiosName(NetBiosName);
    Tempdomain = Tempdomain->GetNextDomain();
    if (Tempdomain && Tempdomain->LookupByNetbiosName(NetBiosName)) {
        m_Error.SetErr(ERROR_GEN_FAILURE,
                        L"NetBIOS domain name %s occurs twice in the forest description. "
                        L"NetBIOS domain names must be unique.",
                        NetBiosName);
        res = FALSE;
        goto Cleanup;
    }


    Cleanup:

    return res;

}

BOOL CEnterprise::CheckConsistencyDNSnames(CDomain *d)
{
    CDomain *p = NULL;
    BOOL res = TRUE;
    WCHAR *DNSname = NULL;
    DNS_STATUS Win32Err = ERROR_SUCCESS;
    WCHAR *Guid = NULL;
    WCHAR *DomainGuid = NULL;

    // Now lets check the DNS name
    //1. Make sure the name's syntax is correct
    //2. If Dns name is in the forest then it must match the one in the
    // forest description.
    //3. The Dns name must only occure once in the forest description.
    //4. Make sure that there are no gaps in the dns names.
    //5. Make sure that NDNC's are not parents
    //6. Make sure that the root domain is not a child of another domain.
    DNSname = d->GetPrevDnsRoot(FALSE);
    
    Win32Err =  DnsValidateName_W(DNSname,
                                  DnsNameDomain);
    
    if (ERROR_SUCCESS          != Win32Err &&
        DNS_ERROR_NON_RFC_NAME != Win32Err)
    {
        m_Error.SetErr(Win32Err,
                        L"Syntax error in DNS domain name %s.",
                        DNSname);
        res = FALSE;
        goto Cleanup;
    }

    Guid = d->GetGuid(FALSE);
    if (!Guid) {
        m_Error.SetMemErr();
        goto Cleanup;
    }
    if (p = m_DomainList->LookupByPrevDnsRoot(DNSname)) {
        DomainGuid = p->GetGuid(FALSE);
        if (!DomainGuid) {
            m_Error.SetMemErr();
            goto Cleanup;
        }
    }
    
    if (DomainGuid && wcscmp(Guid,DomainGuid)!=0) {
        m_Error.SetErr(ERROR_GEN_FAILURE,
                        L"DNS domain name %ws in the forest description "
                        L"names a different domain in the current forest. "
                        L"You can't reassign a DNS domain name in a single"
                        L"forest restructuring.",
                        DNSname);
        res = FALSE;
        goto Cleanup;
    }

    p = m_descList->LookupByDnsRoot(DNSname);
    if (p && p->GetNextDomain()?p->GetNextDomain()->LookupByDnsRoot(DNSname):NULL) {
        m_Error.SetErr(ERROR_GEN_FAILURE,
                        L"DNS domain name %ws occurs twice in the forest description. DNS domain names must be unique.",
                        DNSname);
        res = FALSE;
        goto Cleanup;
    }
           
    WCHAR   *name = NULL;
    CDomain *parent = NULL;
    if ((name = Tail(DNSname,FALSE)) != NULL) {
        if ((parent = m_descList->LookupByDnsRoot(name)) == NULL) {
            while( (name = Tail(name,FALSE)) != NULL )
            {
                if (m_descList->LookupByDnsRoot(name) != NULL) {
                    m_Error.SetErr(ERROR_GEN_FAILURE,
                                    L"DNS domain name %ws occurs in forest description, as does its ancestor %ws, but not its parent %ws. No gaps are allowed between a domain and its ancestors within a forest's domain name space.",
                                    DNSname,
                                    name,
                                    Tail(DNSname,FALSE));
                    res = FALSE;
                    goto Cleanup;    
                }
            }
        } else {

            parent = m_DomainList->LookupByGuid(Guid = parent->GetGuid(FALSE));

            if (m_Error.isError()) {
                res = FALSE;
                goto Cleanup;
            }

            ASSERT(parent);

            if (!parent->isDomain()) {
                m_Error.SetErr(ERROR_GEN_FAILURE,
                                L"Domain NC %ws is the child of non-domain NC %ws. A non-domain NC cannot be the parent of a domain NC.",
                                DNSname,
                                Tail(DNSname,FALSE));
                res = FALSE;
                goto Cleanup;    
            }

            DomainGuid = p->GetGuid(FALSE);

            CDomain *Child = NULL;
            Child = m_DomainList->LookupByGuid(DomainGuid);

            if (Child == m_ForestRoot) {
                m_Error.SetErr(ERROR_GEN_FAILURE,
                                L"Forest root domain NC %ws is the child of domain NC %ws. The forest root domain NC cannot be a child.",
                                DNSname,
                                Tail(DNSname,FALSE));
                res = FALSE;
                goto Cleanup;    
            }

        }

    }

    Cleanup:

    return res;
    
}

BOOL CEnterprise::CheckConsistency() 
{                                                     
    WCHAR *DNSname = NULL;
    BOOL res = TRUE;
    WCHAR *DomainGuid = NULL;

    CDomain *d = m_DomainList;          
    CDomain *p = NULL;
    WCHAR   *NetBiosName = NULL;
    DWORD   Win32Err = ERROR_SUCCESS;

    //For every Guid in the current forest make sure there is a entry in
    //the descList
    d = m_DomainList;
    while (d) {
        //external and disabled crossrefs are not expected in the domainlist file.
        if (d->isDisabled() || d->isExtern()) {
            d = d->GetNextDomain();
            continue;
        }
        if (!m_descList->LookupByGuid(d->GetGuid(FALSE)))
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Domain Guid %s from current forest missing from forest description.",
                            d->GetGuid(FALSE));
            res = FALSE;
            goto Cleanup;
        }
        d = d->GetNextDomain();
    }

    
    d = m_descList;

    while (d) {

        if (!CheckConsistencyGuids(d))
        {
            res = FALSE;
            goto Cleanup;
        }

        if (!CheckConsistencyNetBiosNames(d)) 
        {
            res = FALSE;
            goto Cleanup;
        }

        if (!CheckConsistencyDNSnames(d)) 
        {
            res = FALSE;
            goto Cleanup;
        }

        d = d->GetNextDomain();

    }

    Cleanup:
    
    return res;

}

BOOL CEnterprise::DomainToXML(CDomain *d)
{
    return m_xmlgen->AddDomain(d,m_ForestRoot);
}


BOOL CEnterprise::ScriptTreeFlatting(CDomain *d)
{
    BOOL ret = TRUE;
    WCHAR *Path = NULL;
    WCHAR *Guid = NULL;
    WCHAR *ToPath = NULL;
    WCHAR *ToPathTemplate = L"DC=%s,DC=INVALID";

    if (!d) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"ScriptTreeFlatting did not receive a valid domain");
        goto Cleanup;
    }

    Path = d->GetDomainDnsObject()->GetDN();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }


    Guid = d->GetDomainDnsObject()->GetGuid();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    ASSERT(Guid);
    if (!Guid) {
        ret = FALSE;
        goto Cleanup;
    }
    
    ToPath = new WCHAR[wcslen(ToPathTemplate)+
                              wcslen(Guid)+1];
    if (!ToPath) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(ToPath,
             ToPathTemplate,
             Guid);
    
    m_xmlgen->Move(Path,
                   ToPath);
    if (m_Error.isError()) {
        ret = FALSE;
    }

    Cleanup:

    if (ToPath) {
        delete [] ToPath;
    }
    if (Path) {
        delete Path;
    }

    if (Guid) {
        delete Guid;
    }
    
    return ret;
}

BOOL CEnterprise::GenerateDcListForSave()
{
    if (m_NeedSave) {
        GenerateDcList();
        if (m_Error.isError()) {
            goto Cleanup;
        }    
    
        WriteScriptToFile(NULL);
        if (m_Error.isError()) {
            goto Cleanup;
        }
    }

    Cleanup:

    if (m_Error.isError()) {
        return FALSE;
    }
    return TRUE;
}

BOOL CEnterprise::GenerateDcList()
{
    if (m_Opts->ShouldUpLoadScript()) 
    {
        if (!m_DcList.GenerateDCListFromEnterprise(m_hldap,
                                                   GetDcUsed(FALSE),
                                                   m_ConfigNC->GetDN())) 
        {
            return FALSE;
        }
    }

    if (!m_xmlgen->StartDcList()) {
        return FALSE;
    }

    if (!m_DcList.HashstoXML(m_xmlgen)) {
        return FALSE;
    }

    CDc *dc = m_DcList.GetFirstDc();

    while (dc) 
    {
        if (!m_xmlgen->DctoXML(dc)) {
            return FALSE;
        }

        dc = dc->GetNextDC();
    }

    if (!m_xmlgen->EndDcList()) {
        return FALSE;
    }

    return TRUE;

}

BOOL CEnterprise::GenerateDomainList()
{
    if (!m_xmlgen->StartDomainList()) {
        return FALSE;
    }

    if (!SetAction(&CEnterprise::DomainToXML)) {
        return FALSE;
    }
    if (!TraverseDomainsChildBeforeParent()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    }

    if (!m_xmlgen->EndDomainList()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CEnterprise::TestSpns(CDomain *domain)
{
    WCHAR*  sLDAP = L"LDAP";
    WCHAR*  sHOST = L"HOST";
    WCHAR*  sGC   = L"GC";
    WCHAR*  sREP  = L"E3514235-4B06-11D1-AB04-00C04FC2DCD2";

    CDcSpn* DcSpn      = domain->GetDcSpn();

    WCHAR   *DomainGuid = domain->GetGuid();

    //run test only if DC has at least a 
    //readable copy of the domain being tested.
    m_xmlgen->ifInstantiated(DomainGuid,
                             L"read");
    if (m_Error.isError()) {
        goto Cleanup;
    }

    while (DcSpn) {

        //Look for the SPN
        //LDAP/host.dns.name/domain.dns.name
        if (!DcSpn->WriteSpnTest(m_xmlgen,
                                 sLDAP,
                                 domain->GetDnsRoot(FALSE),
                                 DcSpn->GetDcHostDns(FALSE)))
        {
            goto Cleanup;
        }
        
        if (!DcSpn->WriteSpnTest(m_xmlgen,
                                 sLDAP,
                                 domain->GetPrevDnsRoot(FALSE),
                                 DcSpn->GetDcHostDns(FALSE)))
        {
            goto Cleanup;
        }

        //Look for the SPN
        //E3514235-4B06-11D1-AB04-00C04FC2DCD2/ntdsa-guid/domain.dns.name
        if (!DcSpn->WriteSpnTest(m_xmlgen,
                                 sREP,
                                 domain->GetDnsRoot(FALSE),
                                 DcSpn->GetNtdsGuid(FALSE)))
        {
            goto Cleanup;
        }

        if (!DcSpn->WriteSpnTest(m_xmlgen,
                                 sREP,
                                 domain->GetPrevDnsRoot(FALSE),
                                 DcSpn->GetNtdsGuid(FALSE)))
        {
            goto Cleanup;
        }

        //Look for the SPN
        //HOST/host.dns.name/domain.dns.name
        if (!DcSpn->WriteSpnTest(m_xmlgen,
                                 sHOST,
                                 domain->GetDnsRoot(FALSE),
                                 DcSpn->GetDcHostDns(FALSE)))
        {
            goto Cleanup;
        }

        if (!DcSpn->WriteSpnTest(m_xmlgen,
                                 sHOST,
                                 domain->GetPrevDnsRoot(FALSE),
                                 DcSpn->GetDcHostDns(FALSE)))
        {
            goto Cleanup;
        }

        //Look for the SPN
        //GC/host.dns.name/root.domain.dns.name
        if (!DcSpn->WriteSpnTest(m_xmlgen,
                                 sGC,
                                 m_ForestRoot->GetDnsRoot(FALSE),
                                 DcSpn->GetDcHostDns(FALSE)))
        {
            goto Cleanup;
        }

        if (!DcSpn->WriteSpnTest(m_xmlgen,
                                 sGC,
                                 m_ForestRoot->GetPrevDnsRoot(FALSE),
                                 DcSpn->GetDcHostDns(FALSE)))
        {
            goto Cleanup;
        }

        DcSpn = DcSpn->GetNextDcSpn();
    }

    if (!m_xmlgen->EndifInstantiated()) 
    {
        goto Cleanup;
    }

    Cleanup:

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;

}

BOOL CEnterprise::TestTrusts(CDomain *domain)
{
    CTrustedDomain    *TDO = domain->GetTrustedDomainList();
    CInterDomainTrust *ITA = domain->GetInterDomainTrustList();

    WCHAR *itardnTemplate = L"CN=%ws$";
    WCHAR *itardn = NULL;

    BOOL  ret = TRUE;
    WCHAR *Guidprefix = L"guid:";
    WCHAR *Guid = NULL;
    WCHAR *GuidPath = NULL;
    WCHAR *Sid = NULL;
    WCHAR *DNprefix = NULL;
    WCHAR *DomainDNS = NULL;
    WCHAR *DNRoot = NULL;
    WCHAR *DomainDN = NULL;
    WCHAR *DNSRoot = NULL;
    WCHAR *TrustPath = NULL;
    WCHAR *NetBiosName = NULL;
    WCHAR *samAccountName = NULL;
    WCHAR *TDOTempate = L"CN=%ws,CN=System,%ws";
    WCHAR *SystemTempate = L"CN=System,%ws";
    WCHAR *SystemDN = NULL;
    WCHAR *TDODN      = NULL;
    WCHAR errMessage[1024] = {0};

    WCHAR *DomainGuid = domain->GetGuid();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    //run test only if DC host the domain
    //we are testing.
    m_xmlgen->ifInstantiated(DomainGuid);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    DNSRoot = domain->GetDnsRoot();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    DNRoot = DNSRootToDN(DNSRoot);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    DomainDN = domain->GetDomainDnsObject()->GetDN();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    ASSERT(DomainDN);
    if (!DomainDN) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    //Do all nessary tests for Trusted domains
    while (TDO) {
        
        Guid = TDO->GetTrustDsName()->GetGuid();
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        ASSERT(Guid);
        if (!Guid) {
            ret = FALSE;
            goto Cleanup;
        }
    
        GuidPath = new WCHAR[wcslen(Guidprefix)+
                             wcslen(Guid)+1];
        if (!GuidPath) {
            m_Error.SetMemErr();
            ret = FALSE;
            goto Cleanup;
        }
    
        wcscpy(GuidPath,Guidprefix);
        wcscat(GuidPath,Guid);

        wsprintf(errMessage,
                 L"The object %ws was not found",
                 Guid);
    
        if (!m_xmlgen->Instantiated(GuidPath,
                                    errMessage))
        {
            ret = FALSE;
            goto Cleanup;
        }
    
        Sid = TDO->GetTrustPartner()->GetDomainDnsObject()->GetSid();
        if (m_Error.isError()) 
        {
            ret = FALSE;
            goto Cleanup;
        }

        wsprintf(errMessage,
                 L"The securityIdentifier attribute on object %ws does not have the expect value of %ws",
                 Guid,
                 Sid);
                                              
        if (!m_xmlgen->Compare(GuidPath,
                               L"securityIdentifier",
                               Sid,
                               errMessage))
        {
            ret = FALSE;
            goto Cleanup;
        }

        // Ensure that there will be no name conflicts
        // when the trust are renamed.
        if (TDO->GetTrustPartner()->isDnsNameRenamed()) {

            DomainDNS = TDO->GetTrustPartner()->GetDnsRoot();
            if (m_Error.isError()) {
                ret = FALSE;
                goto Cleanup;
            }

            TDODN = new WCHAR[wcslen(TDOTempate)+
                              wcslen(DomainDNS)+
                              wcslen(DomainDN)+1];
            if (!TDODN) {
                m_Error.SetMemErr();
                ret = FALSE;
                goto Cleanup;
            }
    
            wsprintf(TDODN,
                     TDOTempate,
                     DomainDNS,
                     DomainDN);

            wsprintf(errMessage,
                     L"The object %ws already exists",
                     Guid);

            if (!m_xmlgen->Not(errMessage)) {
                ret = FALSE;
                goto Cleanup;
            }

            if (!m_xmlgen->Instantiated(TDODN,
                                        errMessage))
            {
                ret = FALSE;
                goto Cleanup;
            }

            if (!m_xmlgen->EndNot()) {
                ret = FALSE;
                goto Cleanup;
            }
    
    
        }

        if (DomainDNS) {
            delete DomainDNS;
            DomainDNS = NULL;
        }
        if (GuidPath) {
            delete [] GuidPath;
            GuidPath = NULL;
        }
        if (Guid) {
            delete Guid;
            Guid = NULL;
        }
        if (Sid) {
            delete Sid;
            Sid = NULL;
        }
        if (DomainGuid) {
            delete DomainGuid;
            DomainGuid = NULL;
        }
        if (TDODN) {
            delete [] TDODN;
            TDODN = NULL;
        }

        TDO = (CTrustedDomain*)TDO->GetNext();
    }

    SystemDN = new WCHAR[wcslen(SystemTempate)+
                         wcslen(DomainDN)+1];
    if (!SystemDN) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(SystemDN,
             SystemTempate,
             DomainDN);

    if (DomainDN) {
        delete [] DomainDN;
        DomainDN = NULL;
    }

    //
    // This test will make sure that the number of trust objects found when querying the
    // ds of this domain is the same as when the script will be prepare and executed.
    //

    wsprintf(errMessage,
             L"A trust has been added or removed under %ws",
             SystemDN);

    if (!m_xmlgen->Cardinality(SystemDN,
                               L"COUNT_TRUSTS_FILTER",
                               domain->GetTrustCount(),
                               errMessage))
    {
        ret = FALSE;
        goto Cleanup;
    }
    

    if (SystemDN) {
        delete [] SystemDN;
        SystemDN = NULL;
    }

    //do all test for interdomain trusted 
    while (ITA) {

        Guid = ITA->GetTrustDsName()->GetGuid();
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }
    
        GuidPath = new WCHAR[wcslen(Guidprefix)+
                             wcslen(Guid)+1];
        if (!GuidPath) {
            m_Error.SetMemErr();
            ret = FALSE;
            goto Cleanup;
        }
    
        wcscpy(GuidPath,Guidprefix);
        wcscat(GuidPath,Guid);

        wsprintf(errMessage,
                 L"The object %ws was not found",
                 Guid);

        if (!m_xmlgen->Instantiated(GuidPath,
                                    errMessage))
        {
            ret = FALSE;
            goto Cleanup;
        }

        NetBiosName = ITA->GetTrustPartner()->GetPrevNetBiosName();
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        // +2 for the L'$' and the L'\0'
        samAccountName = new WCHAR[wcslen(NetBiosName)+2];
        if (!samAccountName) {
            m_Error.SetMemErr();
            ret = FALSE;
            goto Cleanup;
        }

        wcscpy(samAccountName,NetBiosName);
        wcscat(samAccountName,L"$");

        wsprintf(errMessage,
                 L"The samAccountName attribute on object %ws does not have the expect value of %ws",
                 Guid,
                 samAccountName);

        if (!m_xmlgen->Compare(GuidPath,
                               L"samAccountName",
                               samAccountName,
                               errMessage)) 
        {
            ret = FALSE;
            goto Cleanup;
        }

        if (ITA->GetTrustPartner()->isNetBiosNameRenamed()) {
            
            DNprefix =  new WCHAR[wcslen(ITA->GetTrustDsName()->GetDN(FALSE))+
                                  wcslen(ITA->GetTrustPartner()->GetNetBiosName(FALSE))+1];
            if (!DNprefix) {
                m_Error.SetMemErr();
                ret = FALSE;
                goto Cleanup;
            }

            wcscpy(DNprefix,ITA->GetTrustDsName()->GetDN(FALSE));

            itardn = new WCHAR[wcslen(itardnTemplate)+
                               wcslen(ITA->GetTrustPartner()->GetNetBiosName(FALSE))+1];
            if (!itardn) {
                m_Error.SetMemErr();
                ret = FALSE;
                goto Cleanup;
            }

            wsprintf(itardn,
                     itardnTemplate,
                     ITA->GetTrustPartner()->GetNetBiosName(FALSE));

            if (ULONG err = ReplaceRDN(DNprefix,itardn)) {
                m_Error.SetErr(LdapMapErrorToWin32(err),
                                ldap_err2stringW(err));
                ret = FALSE;
                goto Cleanup;
            }

            if (itardn) {
                delete [] itardn;
                itardn = NULL;
            }
            
            if (ULONG err = RemoveRootofDn(DNprefix)) {
                m_Error.SetErr(LdapMapErrorToWin32(err),
                                ldap_err2stringW(err));
                ret = FALSE;
                goto Cleanup;
            }

            TrustPath = new WCHAR[wcslen(DNprefix)+
                                  wcslen(DNRoot)+1];
            if (!TrustPath) {
                m_Error.SetMemErr();
                ret = FALSE;
                goto Cleanup;
            }
    
            wcscpy(TrustPath,DNprefix);
            wcscat(TrustPath,DNRoot);

            wsprintf(errMessage,
                     L"The object %ws already exists",
                     TrustPath);

            if (!m_xmlgen->Not(errMessage)) 
            {
                ret = FALSE;
                goto Cleanup;
            }

            if (!m_xmlgen->Instantiated(TrustPath,
                                        errMessage))
            {
                ret = FALSE;
                goto Cleanup;    
            }

            if (!m_xmlgen->EndNot()) 
            {
                ret = FALSE;
                goto Cleanup;
            }

        }

        if (NetBiosName) {
            delete NetBiosName;
            NetBiosName = NULL;
        }

        if (TrustPath) {
            delete [] TrustPath;
            TrustPath = NULL;
        }

        if (samAccountName) {
            delete [] samAccountName;
            samAccountName = NULL;
        }

        if (DNprefix) {
            delete [] DNprefix;
            DNprefix = NULL;
        }

        if (GuidPath) {
            delete [] GuidPath;
            GuidPath = NULL;
        }
        if (Guid) {
            delete Guid;
            Guid = NULL;
        }

        ITA = (CInterDomainTrust*)ITA->GetNext();
    
    }

    if (!m_xmlgen->EndifInstantiated()) 
    {
        ret = FALSE;
        goto Cleanup;
    }
    
    Cleanup:

    if (NetBiosName) {
        delete NetBiosName;
        NetBiosName = NULL;
    }

    if (GuidPath) {
        delete [] GuidPath;
        GuidPath = NULL;
    }
    if (DNRoot) {
        delete DNRoot;
        DNRoot = NULL;
    }
    if (Guid) {
        delete Guid;
        Guid = NULL;
    }
    if (Sid) {
        delete Sid;
        Sid = NULL;
    }
    if (SystemDN) {
        delete [] SystemDN;
    }
    if (TrustPath) {
        delete [] TrustPath;
        TrustPath = NULL;
    }
    if (DomainDNS) {
        delete DomainDNS;
        DomainDNS = NULL;
    }
    if (DomainGuid) {
        delete DomainGuid;
        DomainGuid = NULL;
    }
    if (TDODN) {
        delete [] TDODN;
        TDODN = NULL;
    }
    if (itardn) {
        delete [] itardn;
    }
    if (DNprefix) {
        delete [] DNprefix;
        DNprefix = NULL;
    }
    if (DNSRoot) {
        delete DNSRoot;
        DNSRoot = NULL;
    }
    if (DomainDNS) {
        delete DomainDNS;
    }
    if (DomainDN) {
        delete DomainDN;
    }

    if (m_Error.isError()) {
        ret = FALSE;
    }

    return ret;
    
}

BOOL CEnterprise::WriteTest()
{

    DWORD ret = ERROR_SUCCESS;
    WCHAR *ConfigDN = NULL;
    WCHAR *PartitionsRDN = L"CN=Partitions,";
    WCHAR *Guidprefix = L"guid:";
    WCHAR *Guid = NULL;
    WCHAR *GuidPath = NULL;
    WCHAR *Path = NULL;
    WCHAR *NetBiosName = NULL;
    WCHAR *CrossrefTemplate = L"CN=%ws,%ws";
    WCHAR *newCrossref = NULL;
    WCHAR *DN =NULL;
    DWORD NumCrossrefs = 0;
    CDomain *d = NULL;
    WCHAR errMessage[1024] = {0};

    Guid = m_ConfigNC->GetGuid();
    if (m_Error.isError()) 
    {
        ret = FALSE;
        goto Cleanup;
    }
    ASSERT(Guid);
    if (!Guid)
    {
        ret = FALSE;
        goto Cleanup;    
    }

    GuidPath = new WCHAR[wcslen(Guidprefix)+
                         wcslen(Guid)+1];
    if (!GuidPath) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    wcscpy(GuidPath,Guidprefix);
    wcscat(GuidPath,Guid);

    if (!m_xmlgen->Instantiated(GuidPath,
                                L"The Configuration container does not exist")) 
    {
        ret = FALSE;
        goto Cleanup;
    }

    if (Guid) {
        delete Guid;
    }
    if (GuidPath) {
        delete [] GuidPath;
    }
    
    WCHAR *ReplicationEpoch = new WCHAR[9];
    if (!ReplicationEpoch) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    wsprintf(ReplicationEpoch,
             L"%d",
             m_maxReplicationEpoch+1);

    if (!m_xmlgen->Not(L"Action already performed")) 
    {
        ret = FALSE;
        goto Cleanup;
    }

    if (!m_xmlgen->Compare(L"$LocalNTDSSettingsObjectDN$",
                  L"msDS-ReplicationEpoch",
                  ReplicationEpoch,
                  L"Action already performed"))
    {
        ret = FALSE;
        goto Cleanup;
    }

    if (!m_xmlgen->EndNot()) 
    {
        ret = FALSE;
        goto Cleanup;
    }
    
    ConfigDN = m_ConfigNC->GetDN();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    Path = new WCHAR[wcslen(PartitionsRDN)+
                     wcslen(ConfigDN)+1];
    if (!Path) {
        m_Error.SetMemErr();
        ret = FALSE;
    }
    
    wcscpy(Path,PartitionsRDN);
    wcscat(Path,ConfigDN);

    d = m_DomainList;

    //for every crossref assert that it still exists.
    while (d) {

        //do not count external or disabled crossrefs.
        if (d->isDomain() && !d->isExtern() && !d->isDisabled()) {
            NumCrossrefs++;
        }

        Guid = d->GetDomainCrossRef()->GetGuid();
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }
    
        GuidPath = new WCHAR[wcslen(Guidprefix)+
                             wcslen(Guid)+1];
        if (!GuidPath) {
            m_Error.SetMemErr();
            ret = FALSE;
            goto Cleanup;
        }

        wcscpy(GuidPath,Guidprefix);
        wcscat(GuidPath,Guid);

        DN = d->GetDomainDnsObject()->GetDN();
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        wsprintf(errMessage,
                 L"The object %ws was not found",
                 Guid);

        if (!m_xmlgen->Instantiated(GuidPath,
                                    errMessage)) 
        {
            ret = FALSE;
            goto Cleanup;
        }

        wsprintf(errMessage,
                 L"The ncName Attribute on object %ws does not have the expected value of %ws",
                 Guid,
                 DN);
    
        if (!m_xmlgen->Compare(GuidPath,
                              L"NcName",
                              DN,
                              errMessage))
        {
            ret = FALSE;
            goto Cleanup;
        }

        //If the netbiosname is being renamed then make sure that 
        //there will not be a naming confict.
        if (d->isDomain() && d->isNetBiosNameRenamed()) {

            NetBiosName = d->GetNetBiosName();
            if (m_Error.isError()) 
            {
                ret = FALSE;
                goto Cleanup;
            }

            newCrossref = new WCHAR[wcslen(CrossrefTemplate)+
                                    wcslen(NetBiosName)+
                                    wcslen(Path)+1];
            if (!newCrossref) {
                m_Error.SetMemErr();
                goto Cleanup;
            }

            wsprintf(newCrossref,
                     CrossrefTemplate,
                     NetBiosName,
                     Path);

            wsprintf(errMessage,
                     L"The object %ws already exists",
                     newCrossref);

            if (!m_xmlgen->Not(errMessage)) 
            {
                ret = FALSE;
                goto Cleanup;
            }

            if (!m_xmlgen->Instantiated(newCrossref,
                                        errMessage))
            {
                ret = FALSE;
                goto Cleanup;
            }

            if (!m_xmlgen->EndNot()) 
            {
                ret = FALSE;
                goto Cleanup;
            }
        
        } 

        if (d->isDomain()) {

            if (!TestTrusts(d))
            {
                ret = FALSE;
                goto Cleanup;
            }

            if (!TestSpns(d)) 
            {
                ret = FALSE;
                goto Cleanup;
            }

        }

        if (newCrossref) {
            delete [] newCrossref;
            newCrossref = NULL;
        }
        if (NetBiosName) {
            delete NetBiosName;
            NetBiosName = NULL;
        }

        if (GuidPath) {
            delete [] GuidPath;
            GuidPath = NULL;
        }
        if (Guid) {
            delete Guid;
            Guid = NULL;
        }
        if (DN) {
            delete DN;
            DN = NULL;
        }

        d = d->GetNextDomain();

    }
    
    if (!m_xmlgen->Cardinality(Path,
                               L"COUNT_DOMAINS_FILTER",
                               NumCrossrefs,
                               L"A domain has been added or removed")) 
    {
        ret = FALSE;
        goto Cleanup;
    }

    Cleanup:

    if (Path) {
        delete [] Path;
    }
    if (newCrossref) {
        delete [] newCrossref;
    }
    if (NetBiosName) {
        delete NetBiosName;
    }

    if (ConfigDN) {
        delete ConfigDN;
    }

    if (GuidPath) {
        delete [] GuidPath;
    }
    if (Guid) {
        delete Guid;
    }

    if (ReplicationEpoch) {
        delete [] ReplicationEpoch;
    }

    if (m_Error.isError()) {
        ret=FALSE;
    }

    return ret;
}  

BOOL CEnterprise::GenerateReNameScript()
{

    m_xmlgen->StartScript();

    //write the initial test.
    m_xmlgen->StartAction(L"Test Enterprise State",TRUE);

    WriteTest();

    m_xmlgen->EndAction();

    //
    //Create forest decription based on old domain structure
    //
    if (!BuildForest(FALSE))
    {
        return FALSE;
    }

    //generate the instructions to flatten the trees
    m_xmlgen->StartAction(L"Flatten Trees",FALSE);

    if (!SetAction(&CEnterprise::ScriptTreeFlatting)) {
        return FALSE;
    }
    if (!TraverseDomainsChildBeforeParent()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    }

    m_xmlgen->EndAction();

    //
    //Create forest decription based on new domain structure
    //
    if (!BuildForest(TRUE))
    {
        return FALSE;
    }

    //generate the instruction to build the new trees.
    m_xmlgen->StartAction(L"Rename Domains",FALSE);

    if (!SetAction(&CEnterprise::ScriptDomainRenaming)) {
        return FALSE;
    }
    if (!TraverseDomainsParentBeforeChild()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    }

    m_xmlgen->EndAction();

    m_xmlgen->StartAction(L"Fix Crossrefs",FALSE);

    if (!FixMasterCrossrefs()) {
        return FALSE;
    }

    if (!SetAction(&CEnterprise::ScriptFixCrossRefs)) {
        return FALSE;
    }
    if (!TraverseDomainsParentBeforeChild()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    } 

    m_xmlgen->EndAction();

    m_xmlgen->StartAction(L"Fix Trusted Domains",FALSE);

    if (!SetAction(&CEnterprise::ScriptFixTrustedDomains)) {
        return FALSE;
    }
    if (!TraverseDomainsParentBeforeChild()) {
        return FALSE;
    }
    if (!ClearAction()) {
        return FALSE;
    } 

    m_xmlgen->EndAction();

    m_xmlgen->StartAction(L"Advance ReplicationEpoch",FALSE);

    if (!ScriptAdvanceReplicationEpoch()) {
        return FALSE;
    }
    
    m_xmlgen->EndAction();

    m_xmlgen->EndScript();

    return TRUE;

}

BOOL CEnterprise::HandleNDNCCrossRef(CDomain *d)
{
    BOOL ret = TRUE;
    DWORD err = ERROR_SUCCESS;
    WCHAR *DNSRoot = NULL;
    WCHAR *Path = NULL;
    WCHAR *Guid = NULL;
    WCHAR *CrossrefDN = NULL;
    WCHAR *newForestRootDN = NULL;
    WCHAR *PathTemplate = L"CN=%s,CN=Partitions,CN=Configuration,%s";

    DNSRoot = m_ForestRoot->GetDnsRoot();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    CrossrefDN = d->GetDomainCrossRef()->GetDN();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    err = GetRDNWithoutType(CrossrefDN,
                            &Guid);
    if (err)
    {
        ret = FALSE;
        m_Error.SetErr(err,
                        L"Could not get the RDN for the NDNC Crossref\n");
        goto Cleanup;
    }

    //get the Guid out of the DN name 
    
    CXMLAttributeBlock *atts[2];
    atts[0] = NULL;
    atts[1] = NULL;

    atts[0] = new CXMLAttributeBlock(L"DnsRoot",
                                     d->GetDnsRoot());
    if (!atts[0] || m_Error.isError()) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    atts[1] = NULL;

    newForestRootDN = DNSRootToDN(DNSRoot);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    //change the DNSRoot attribute of the configuration crossref.
    Path = new WCHAR[wcslen(PathTemplate)+
                     wcslen(Guid)+
                     wcslen(newForestRootDN)+1];
    if (!Path) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(Path,
             PathTemplate,
             Guid,
             newForestRootDN);

    m_xmlgen->Update(Path,
                     atts);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    Cleanup:

    if (DNSRoot) {
        delete DNSRoot;
    }
    if (Path) {
        delete [] Path;
    }
    if (CrossrefDN) {
        delete CrossrefDN;
    }
    if (newForestRootDN) {
        delete newForestRootDN;
    }
    if (atts[0]) {
        delete atts[0];
    }
    if (Guid) {
        delete Guid;
    }

    return ret;
}

BOOL CEnterprise::ScriptAdvanceReplicationEpoch()
{
    BOOL ret = TRUE;
    WCHAR *ReplicationEpoch = NULL;
    CXMLAttributeBlock *atts[2];
    atts[0] = NULL;
    atts[1] = NULL;

    //I am assume no more than (1*(10^9))-1 changes of this type will be made.
    ReplicationEpoch = new WCHAR[9];
    if (!ReplicationEpoch) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    wsprintf(ReplicationEpoch,
             L"%d",
             m_maxReplicationEpoch+1);
    
    atts[0] = new CXMLAttributeBlock(L"msDS-ReplicationEpoch",
                                     ReplicationEpoch);
    if (!atts[0] || m_Error.isError()) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    atts[1] = NULL;

    m_xmlgen->Update(L"$LocalNTDSSettingsObjectDN$",
                     atts);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    Cleanup:

    if (atts[0]) {
        delete atts[0];
    }

    return ret;

}

BOOL CEnterprise::ScriptFixTrustedDomains(CDomain *d)
{
    if (!d->isDomain()) {
        //This is an NDNC no action needs to 
        //be taken
        return TRUE;
    }

    BOOL ret = TRUE;
    WCHAR *Guid = NULL;
    CTrustedDomain *td = NULL;
    CInterDomainTrust *idt = NULL;
    WCHAR *PathTemplate = L"CN=%s,CN=System,%s";
    WCHAR *ToPathTemplate = L"CN=%s,%s";

    WCHAR *RootPath = NULL;
    WCHAR *ToPath = NULL;
    WCHAR *DNSRoot = NULL;
    WCHAR *OldTrustRDN = NULL;
    WCHAR *newTrustRDN = NULL;
    WCHAR *newRootDN = NULL; 
    WCHAR *NewPathSuffex = NULL;
    CXMLAttributeBlock *atts[3];
    atts[0] = NULL;
    atts[1] = NULL;
    atts[2] = NULL;

    WCHAR *DNprefix = NULL;
    WCHAR *DNRoot = NULL;
    WCHAR *TrustPath = NULL;
    WCHAR *samAccountName = NULL;
    WCHAR *NetBiosName = NULL;

    Guid = d->GetDomainDnsObject()->GetGuid();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    m_xmlgen->ifInstantiated(Guid);

    td = d->GetTrustedDomainList();
    while (td) {
        
        atts[0] = new CXMLAttributeBlock(L"flatName",
                                         td->GetTrustPartner()->GetNetBiosName());
        if (!atts[0] || m_Error.isError()) {
            m_Error.SetMemErr();
            ret = FALSE;
            goto Cleanup;
        }
        atts[1] = new CXMLAttributeBlock(L"trustPartner",
                                         td->GetTrustPartner()->GetDnsRoot());
        if (!atts[1] || m_Error.isError()) {
            m_Error.SetMemErr();
            ret = FALSE;
            goto Cleanup;
        }
        atts[2] = NULL;

        if ( TRUST_TYPE_DOWNLEVEL == td->GetTrustType()) {
            OldTrustRDN = td->GetTrustPartner()->GetPrevNetBiosName();
        } else {
            OldTrustRDN = td->GetTrustPartner()->GetPrevDnsRoot();    
        } 
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        DNSRoot = d->GetDnsRoot();
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }
    
        newRootDN = DNSRootToDN(DNSRoot);
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        RootPath = new WCHAR[wcslen(OldTrustRDN)+
                             wcslen(PathTemplate)+
                             wcslen(newRootDN)+1];
        if (!RootPath) {
            m_Error.SetMemErr();
            ret = FALSE;
            goto Cleanup;
        }

        wsprintf(RootPath,
                 PathTemplate,
                 OldTrustRDN,
                 newRootDN);

        
        m_xmlgen->Update(RootPath,
                         atts,
                         1);
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        if ( TRUST_TYPE_DOWNLEVEL == td->GetTrustType()) {
            newTrustRDN = td->GetTrustPartner()->GetNetBiosName();
        } else {
            newTrustRDN = td->GetTrustPartner()->GetDnsRoot();
        }
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        ToPath = new WCHAR[wcslen(newTrustRDN)+
                           wcslen(PathTemplate)+
                           wcslen(newRootDN)+1];
        if (!ToPath) {
            m_Error.SetMemErr();
            ret = FALSE;
            goto Cleanup;
        }
    
        
        wsprintf(ToPath,
                 PathTemplate,
                 newTrustRDN,
                 newRootDN);

        m_xmlgen->Move(RootPath,
                       ToPath,
                       1);
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        if (RootPath) {
            delete [] RootPath;
            RootPath = NULL;
        }
        if (ToPath) {
            delete [] ToPath;
            ToPath = NULL;
        }
        if (DNSRoot) {
            delete DNSRoot;
            DNSRoot = NULL;
        }
        if (newTrustRDN) {
            delete newTrustRDN;
            newTrustRDN = NULL;
        }
        if (OldTrustRDN) {
            delete OldTrustRDN;
            OldTrustRDN = NULL;
        }
        if (newRootDN) {
            delete newRootDN;
            newRootDN = NULL;
        }
        if (atts[0]) {
            delete atts[0];
            atts[0] = NULL;
        }
        if (atts[1]) {
            delete atts[1];
            atts[1] = NULL;
        }
        
        td = (CTrustedDomain*)td->GetNext();
    }

    idt = d->GetInterDomainTrustList();
    while (idt) {

        NetBiosName = idt->GetTrustPartner()->GetNetBiosName();
        if (m_Error.isError()) {
            goto Cleanup;
        }

        // +2 for the L'$' and the L'\0'
        samAccountName = new WCHAR[wcslen(NetBiosName)+2];
        if (!samAccountName) {
            m_Error.SetMemErr();
            goto Cleanup;
        }

        wcscpy(samAccountName,NetBiosName);
        wcscat(samAccountName,L"$");

        //samAccountName should not be freed this will be handled
        //by CXMLAttributeBlock.  It is important not to use samAccountName
        //after it has be Freed by CXMLAttributeBlock
        atts[0] = new CXMLAttributeBlock(L"samAccountName",
                                         samAccountName);
        if (!atts[0] || m_Error.isError()) {
            m_Error.SetMemErr();
            ret = FALSE;
            goto Cleanup;
        }
        atts[1] = NULL;


        DNprefix = idt->GetTrustDsName()->GetDN();
        if (m_Error.isError()) {
            goto Cleanup;
        }

        if (ULONG err = RemoveRootofDn(DNprefix)) {
            m_Error.SetErr(LdapMapErrorToWin32(err),
                                ldap_err2stringW(err));
            goto Cleanup;
        }

        DNSRoot = d->GetDnsRoot();
        if (m_Error.isError()) {
            goto Cleanup;
        }

        DNRoot = DNSRootToDN(DNSRoot);

        TrustPath = new WCHAR[wcslen(DNprefix)+
                              wcslen(DNRoot)+1];
        if (!TrustPath) {
            m_Error.SetMemErr();
            goto Cleanup;
        }

        wcscpy(TrustPath,DNprefix);
        wcscat(TrustPath,DNRoot);

        m_xmlgen->Update(TrustPath,
                         atts,
                         1);
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        DWORD err = TrimDNBy(TrustPath,
                             1,
                             &NewPathSuffex);
        if (ERROR_SUCCESS != err) {
            m_Error.SetErr(err,
                            L"Failed to Trim DN %s",
                            TrustPath);
            goto Cleanup;
        }

        ToPath = new WCHAR[wcslen(samAccountName)+
                           wcslen(ToPathTemplate)+
                           wcslen(NewPathSuffex)+1];
        if (!ToPath) {
            m_Error.SetMemErr();
            goto Cleanup;
        }

        wsprintf(ToPath,
                 ToPathTemplate,
                 samAccountName,
                 NewPathSuffex);

        
        m_xmlgen->Move(TrustPath,
                       ToPath,
                       1);
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }

        if (DNprefix) {
            delete DNprefix;
            DNprefix = NULL;
        }
        if (DNRoot) {
            delete DNRoot;
            DNRoot = NULL;
        }
        if (TrustPath) {
            delete [] TrustPath;
            TrustPath = NULL;
        }
        if (NetBiosName) {
            delete NetBiosName;
            NetBiosName = NULL;
        }
        if (DNSRoot) {
            delete DNSRoot;
            DNSRoot = NULL;
        }
        if (ToPath) {
            delete [] ToPath;
            ToPath = NULL;
        }
        if (NewPathSuffex) {
            delete NewPathSuffex;
            NewPathSuffex = NULL;
        }
        if (atts[0]) {
            delete atts[0];
            atts[0] = NULL;
        }
        if (samAccountName) {
            samAccountName = NULL;
        }
        
        idt = (CInterDomainTrust*)idt->GetNext();
    }
    
    m_xmlgen->EndifInstantiated();

    Cleanup:

    if (Guid) {
        delete Guid;
    }
    if (RootPath) {
        delete [] RootPath;
        RootPath = NULL;
    }
    if (ToPath) {
        delete [] ToPath;
        ToPath = NULL;
    }
    if (DNSRoot) {
        delete DNSRoot;
        DNSRoot = NULL;
    }
    if (newTrustRDN) {
        delete newTrustRDN;
        newTrustRDN = NULL;
    }
    if (OldTrustRDN) {
        delete OldTrustRDN;
        OldTrustRDN = NULL;
    }
    if (newRootDN) {
        delete newRootDN;
        newRootDN = NULL;
    }
    if (DNprefix) {
        delete DNprefix;
        DNprefix = NULL;
    }
    if (DNRoot) {
        delete DNRoot;
        DNRoot = NULL;
    }
    if (TrustPath) {
        delete [] TrustPath;
        TrustPath = NULL;
    }
    if (NetBiosName) {
        delete NetBiosName;
        NetBiosName = NULL;
    }
    if (NewPathSuffex) {
        delete NewPathSuffex;
        NewPathSuffex = NULL;
    }
    if (atts[0]) {
        delete atts[0];
        atts[0] = NULL;
    }
    
    return ret;
    
}

BOOL CEnterprise::ScriptFixCrossRefs(CDomain *d)
{
    //if the domain passed in is the Forest Root
    //We will skip it since it is handled elsewhere
    if (m_ForestRoot == d) {
        return TRUE;
    }
    if (!d->isDomain()) {
        //This is a NDNC We need to handle this
        //differently from the other crossrefs
        return HandleNDNCCrossRef(d);
    }

    if (d->isExtern() || d->isDisabled()) {
        //Nothing needs to be done for disabled or external crossrefs
        return TRUE;
    }

    BOOL ret = TRUE;
    WCHAR *DNSRoot = NULL;
    WCHAR *PrevNetBiosName = NULL;
    WCHAR *RootPath = NULL;
    WCHAR *newRootDN = NULL;
    WCHAR *ParentNetBiosName = NULL;
    WCHAR *ParentCrossRef = NULL;
    WCHAR *forestRootNetBiosName = NULL;
    WCHAR *forestRootCrossRef = NULL;
    WCHAR *forestRootDNS = NULL;
    WCHAR *forestRootDN = NULL;
    WCHAR *ToPath = NULL;
    WCHAR *NetBiosName = NULL;
    WCHAR *PathTemplate = L"CN=%s,CN=Partitions,CN=Configuration,%s";

    CXMLAttributeBlock *atts[6];
    atts[0] = NULL;
    atts[1] = NULL;
    atts[2] = NULL;
    atts[3] = NULL;
    atts[4] = NULL;
    atts[5] = NULL;
    

    DNSRoot = m_ForestRoot->GetDnsRoot();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    newRootDN = DNSRootToDN(DNSRoot);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    PrevNetBiosName = d->GetPrevNetBiosName();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    ASSERT(PrevNetBiosName);
    if (!PrevNetBiosName) {
        ret = FALSE;
        goto Cleanup;
    }


    RootPath = new WCHAR[wcslen(PrevNetBiosName)+
                         wcslen(PathTemplate)+
                         wcslen(newRootDN)+1];
    if (!RootPath) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(RootPath,
             PathTemplate,
             PrevNetBiosName,
             newRootDN);

    if (d->GetParent()) {
        //This is a child Domain therefore we need to setup
        //the TrustParent for this crossref
        ParentNetBiosName = d->GetParent()->GetNetBiosName();
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        ParentCrossRef = new WCHAR[wcslen(ParentNetBiosName)+
                                   wcslen(newRootDN)+
                                   wcslen(PathTemplate)+1];
        if ((!ParentCrossRef) || m_Error.isError()) {
            m_Error.SetMemErr();
            ret = FALSE;
            goto Cleanup;
        }
        wsprintf(ParentCrossRef,
                 PathTemplate,
                 ParentNetBiosName,
                 newRootDN);
        
    } else {
        //this is a Root of a tree but not the forest root
        //setup the RootTrust
        forestRootNetBiosName = m_ForestRoot->GetNetBiosName();
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        forestRootDNS = m_ForestRoot->GetDnsRoot();
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        forestRootDN = DNSRootToDN(forestRootDNS);
        if (m_Error.isError()) {
            ret = FALSE;
            goto Cleanup;
        }
        forestRootCrossRef = new WCHAR[wcslen(forestRootNetBiosName)+
                                   wcslen(forestRootDN)+
                                   wcslen(PathTemplate)+1];
        if ((!forestRootCrossRef) || m_Error.isError()) {
            m_Error.SetMemErr();
            ret = FALSE;
            goto Cleanup;
        }
        wsprintf(forestRootCrossRef,
                 PathTemplate,
                 forestRootNetBiosName,
                 forestRootDN);

    }


    atts[0] = new CXMLAttributeBlock(L"DnsRoot",
                                     d->GetDnsRoot());
    if (!atts[0] || m_Error.isError()) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    atts[1] = new CXMLAttributeBlock(L"NetBiosName",
                                     d->GetNetBiosName());
    if (!atts[1] || m_Error.isError()) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    atts[2] = new CXMLAttributeBlock(L"TrustParent",
                                     ParentCrossRef);
    if (!atts[2] || m_Error.isError()) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    atts[3] = new CXMLAttributeBlock(L"RootTrust",
                                     forestRootCrossRef);
    if (!atts[3] || m_Error.isError()) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    if (d->isDnsNameRenamed()) {
        atts[4] = new CXMLAttributeBlock(L"msDS-DnsRootAlias",
                                         d->GetPrevDnsRoot());
        if (!atts[4] || m_Error.isError()) {
            m_Error.SetMemErr();
            ret = FALSE;
            goto Cleanup;
        }
    } else {
        atts[4] = NULL;
    }
    atts[5] = NULL;

    m_xmlgen->Update(RootPath,
                     atts);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    NetBiosName = d->GetNetBiosName();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    ToPath = new WCHAR[wcslen(NetBiosName)+
                       wcslen(PathTemplate)+
                       wcslen(newRootDN)+1];
    if (!ToPath) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(ToPath,
             PathTemplate,
             NetBiosName,
             newRootDN);

    m_xmlgen->Move(RootPath,
                   ToPath);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    Cleanup:

    if (DNSRoot) {
        delete DNSRoot;
    }
    if (NetBiosName) {
        delete NetBiosName;
    }
    if (ToPath) {
        delete [] ToPath;
    }
    if (PrevNetBiosName) {
        delete PrevNetBiosName;
    }
    if (RootPath) {
        delete [] RootPath;
    }
    if (newRootDN) {
        delete newRootDN;
    }
    if (ParentNetBiosName) {
        delete ParentNetBiosName;
    }
    if (forestRootNetBiosName) {
        delete ParentNetBiosName;
    }
    if (forestRootDNS) {
        delete forestRootDNS;
    }
    if (forestRootDN) {
        delete forestRootDN;
    }
    if (atts[0]) {
        delete atts[0];
    }
    if (atts[1]) {
        delete atts[1];
    }
    if (atts[2]) {
        delete atts[2];
    }
    if (atts[3]) {
        delete atts[3];
    }
    if (atts[4]) {
        delete atts[4];
    }
    
    return ret;

}

BOOL CEnterprise::FixMasterCrossrefs()
{
    BOOL ret = TRUE;
    WCHAR *ConfigPath = NULL;
    WCHAR *SchemaPath = NULL;
    WCHAR *ForestRootPath = NULL;
    WCHAR *DNSRoot = NULL;
    WCHAR *PrevNetBiosName = NULL;
    WCHAR *NetBiosName = NULL;
    WCHAR *newForestRootDN = NULL;
    WCHAR *ToPath = NULL;
    WCHAR *ConfigPathTemplate = L"CN=Enterprise Configuration,CN=Partitions,CN=Configuration,%s";
    WCHAR *SchemaPathTemplate = L"CN=Enterprise Schema,CN=Partitions,CN=Configuration,%s";
    WCHAR *ForestRootPathTemplate = L"CN=%s,CN=Partitions,CN=Configuration,%s";

    DNSRoot = m_ForestRoot->GetDnsRoot();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    CXMLAttributeBlock *atts[4];
    atts[0] = NULL;
    atts[1] = NULL;
    atts[2] = NULL;
    atts[3] = NULL;
    
    atts[0] = new CXMLAttributeBlock(L"DnsRoot",
                                     m_ForestRoot->GetDnsRoot());
    if (!atts[0] || m_Error.isError()) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    atts[1] = NULL;

    newForestRootDN = DNSRootToDN(DNSRoot);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }
    ASSERT(newForestRootDN);
    if (!newForestRootDN) {
        ret = FALSE;
        goto Cleanup;
    }

    //change the DNSRoot attribute of the configuration crossref.
    ConfigPath = new WCHAR[wcslen(ConfigPathTemplate)+
                           wcslen(newForestRootDN)+1];
    if (!ConfigPath) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(ConfigPath,
             ConfigPathTemplate,
             newForestRootDN);

    m_xmlgen->Update(ConfigPath,
                     atts);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }


    //change the DNSRoot attribute of the schema crossref.
    SchemaPath = new WCHAR[wcslen(SchemaPathTemplate)+
                           wcslen(newForestRootDN)+1];
    if (!ConfigPath) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(SchemaPath,
             SchemaPathTemplate,
             newForestRootDN);

    
    m_xmlgen->Update(SchemaPath,
                     atts);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    //Fixup the Forest Root Crossref

    PrevNetBiosName = m_ForestRoot->GetPrevNetBiosName();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    atts[1] = new CXMLAttributeBlock(L"msDS-DnsRootAlias",
                                     m_ForestRoot->GetPrevDnsRoot());
    if (!atts[1] || m_Error.isError()) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    atts[2] = new CXMLAttributeBlock(L"NetBiosName",
                                     m_ForestRoot->GetNetBiosName());
    if (!atts[2] || m_Error.isError()) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }
    atts[3] = NULL;

    ForestRootPath = new WCHAR[wcslen(ForestRootPathTemplate)+
                               wcslen(PrevNetBiosName)+
                               wcslen(newForestRootDN)+1];
    if (!ConfigPath) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(ForestRootPath,
             ForestRootPathTemplate,
             PrevNetBiosName,
             newForestRootDN);


    m_xmlgen->Update(ForestRootPath,
                     atts);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    NetBiosName = m_ForestRoot->GetNetBiosName();
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    ToPath = new WCHAR[wcslen(ForestRootPathTemplate)+
                       wcslen(NetBiosName)+
                       wcslen(newForestRootDN)+1];
    if (!ToPath) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    wsprintf(ToPath,
             ForestRootPathTemplate,
             NetBiosName,
             newForestRootDN);

    m_xmlgen->Move(ForestRootPath,
                   ToPath);
    if (m_Error.isError()) {
        ret = FALSE;
        goto Cleanup;
    }

    Cleanup:

    if (newForestRootDN) {
        delete newForestRootDN;
    }
    if (PrevNetBiosName) {
        delete PrevNetBiosName;
    }
    if (NetBiosName) {
        delete NetBiosName;
    }
    if (DNSRoot) {
        delete DNSRoot;
    }
    if (ForestRootPath) {
        delete [] ForestRootPath;
    }
    if (ConfigPath) {
        delete [] ConfigPath;
    }
    if (SchemaPath) {
        delete [] SchemaPath;
    }
    if (ToPath) {
        delete [] ToPath;
    }
    if (atts[0]) {
        delete atts[0];
    }
    if (atts[1]) {
        delete atts[1];
    }
    if (atts[2]) {
        delete atts[2];
    }
    
    return ret;

}

VOID CEnterprise::DumpScript()
{
    m_xmlgen->DumpScript();
}

WCHAR* CEnterprise::GetDcUsed(BOOL Allocate /*= TRUE*/)
{
    if (!m_DcNameUsed) {
        return NULL;
    }
    if (Allocate) {

        HRESULT hr = S_OK;
        DWORD size = wcslen(m_DcNameUsed)+1;
        WCHAR *ret = new WCHAR[size];
        if (!ret) {

            m_Error.SetMemErr();
            return 0;

        }

        hr = StringCchCopyW(ret,
                            size,
                            m_DcNameUsed);

        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr)) {
    
            m_Error.SetErr(HRESULT_CODE(hr),
                           L"Failed to discover which dc we have an ldap connection to");
            return FALSE;
    
        }
    
        return ret;    
    }

    return m_DcNameUsed;
}

BOOL CEnterprise::SetDcUsed(const WCHAR *DcUsed)
{
    ASSERT(DcUsed);

    HRESULT hr = S_OK;
    DWORD size = wcslen(DcUsed)+1;

    m_DcNameUsed = new WCHAR[size];
    if (!m_DcNameUsed) {
        m_Error.SetMemErr();
        return FALSE;
    }

    hr = StringCchCopyW(m_DcNameUsed,
                        size,
                        DcUsed);

    ASSERT(SUCCEEDED(hr));
    if (FAILED(hr)) {

        m_Error.SetErr(HRESULT_CODE(hr),
                       L"Failed to set which dc ldap connected to");
        return FALSE;

    }

    return TRUE;

}

BOOL CEnterprise::Error()
{
    if (m_Error.isError()) {
        m_Error.PrintError();
        return TRUE;
    }

    return FALSE;
}

VOID CRenDomErr::SetLdapErr(LDAP *hldap,
                            DWORD  LdapError,
                            WCHAR* p_ErrStr,
                            ...) 
{
    va_list arglist;

    va_start(arglist, p_ErrStr);

    vSetErr(LdapMapErrorToWin32(LdapError),
            p_ErrStr,
            arglist);
    //print the extented error as well;
    WCHAR *pErrorString = NULL;
    ULONG ExtError = LDAP_SUCCESS;
    ExtError = ldap_get_option(hldap, LDAP_OPT_SERVER_ERROR, (void*) &pErrorString);

    if (ExtError == LDAP_SUCCESS && pErrorString != NULL) {
        AppendErr(pErrorString);

        if (pErrorString) {
            ldap_memfree(pErrorString);
        }
    }

    va_end(arglist);

}

VOID CRenDomErr::vSetErr(DWORD p_Win32Err,
                         WCHAR* p_ErrStr,
                         va_list arglist) 
{
    WCHAR Errmsg[RENDOM_BUFFERSIZE];

    Errmsg[RENDOM_BUFFERSIZE-1] = L'\0';
    
    _vsnwprintf(Errmsg,RENDOM_BUFFERSIZE-1,p_ErrStr,arglist);

    m_Win32Err = p_Win32Err;
    if (m_ErrStr) {
        delete [] m_ErrStr;
    }
    m_ErrStr = new WCHAR[wcslen(Errmsg)+1];
    if (m_ErrStr) {
        wcscpy(m_ErrStr,Errmsg);
    }

}

VOID CRenDomErr::ClearErr()
{
    SetErr(ERROR_SUCCESS,
           L"");
}

VOID CRenDomErr::SetErr(DWORD p_Win32Err,
                        WCHAR* p_ErrStr,
                        ...) 
{

    WCHAR Errmsg[RENDOM_BUFFERSIZE];
    
    va_list arglist;

    va_start(arglist, p_ErrStr);

    vSetErr(p_Win32Err,
            p_ErrStr,
            arglist);

    va_end(arglist);

}

VOID CRenDomErr::AppendErr(WCHAR* p_ErrStr,
                           ...)
{
    if (!m_ErrStr) {
        wprintf(L"Failed to append error due to no error being set.\n");
        return;
    }
    WCHAR Errmsg[RENDOM_BUFFERSIZE];
    WCHAR Newmsg[RENDOM_BUFFERSIZE];
    DWORD count = 0;

    va_list arglist;

    va_start(arglist, p_ErrStr);

    Errmsg[RENDOM_BUFFERSIZE-1] = L'\0';

    _vsnwprintf(Errmsg,RENDOM_BUFFERSIZE-1,p_ErrStr,arglist);

    wcscpy(Newmsg,m_ErrStr);
    wcscat(Newmsg,L".  \n");
    wcscat(Newmsg,Errmsg);

    if (m_ErrStr) {
        delete [] m_ErrStr;
    }
    m_ErrStr = new WCHAR[wcslen(Newmsg)+1];
    if (m_ErrStr) {
        wcscpy(m_ErrStr,Newmsg);
    }

    

    va_end(arglist);       
}

VOID CRenDomErr::PrintError() {

    if (m_AlreadyPrinted) {
        return;
    }
    if ((ERROR_SUCCESS != m_Win32Err) && (NULL == m_ErrStr)) {
        wprintf(L"Failed to set error message: %d\r\n",
                m_Win32Err);
    }
    if (ERROR_SUCCESS == m_Win32Err) {
        wprintf(L"Successful\r\n");
    } else {
        wprintf(L"%s: %s :%d\r\n",
                m_ErrStr,
                Win32ErrToString(m_Win32Err),
                m_Win32Err);
    }

    m_AlreadyPrinted = TRUE;
}

BOOL CRenDomErr::isError() {
    return ERROR_SUCCESS!=m_Win32Err;
}

VOID CRenDomErr::SetMemErr() {
    if (!isError()) {
        SetErr(ERROR_NOT_ENOUGH_MEMORY,
               L"An operation has failed due to lack of memory.\n");
    }
}

DWORD CRenDomErr::GetErr() {
    return m_Win32Err;
}


CDsName::CDsName(WCHAR* p_Guid = 0,
                 WCHAR* p_DN = 0, 
                 WCHAR* p_ObjectSid = 0)
{
    m_ObjectGuid = p_Guid;
    m_DistName = p_DN;
    m_ObjectSid = p_ObjectSid;
} 

CDsName::~CDsName() 
{
    if (m_ObjectGuid) {
        delete m_ObjectGuid;
    }
    if (m_DistName) {
        delete m_DistName;
    }
    if (m_ObjectSid) {
        delete m_ObjectSid;
    }    
}

VOID CDsName::DumpCDsName()
{
    wprintf(L"**************************************\n");
    if (m_ObjectGuid) {
        wprintf(L"Guid: %ws\n",m_ObjectGuid);
    } else {
        wprintf(L"Guid: (NULL)\n");
    }
    
    if (m_DistName) {
        wprintf(L"DN: %ws\n",m_DistName);
    } else {
        wprintf(L"DN: (NULL)\n");
    }

    if (m_ObjectSid) {
        wprintf(L"Sid: %ws\n",m_ObjectSid);
    } else {
        wprintf(L"Sid: (NULL)\n");
    }
    
    wprintf(L"ERROR: %d\n",m_Error.GetErr());
    wprintf(L"**************************************\n");

}

BOOL CDsName::ReplaceDN(const WCHAR *NewDN) {
    if (!NewDN) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"A Null use passed to ReplaceDN");
        return false;
    }

    if (m_DistName) {
        delete m_DistName;
    }

    m_DistName = new WCHAR[wcslen(NewDN)+1];
    if (!m_DistName) {
        m_Error.SetMemErr();
        return false;
    }
    wcscpy(m_DistName,NewDN);

    return true;
   
}

BOOL CDsName::CompareByObjectGuid(const WCHAR *Guid){
    if (!Guid) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"A Null use passed to CompareByObjectGuid");
        return false;
    }
    if (!m_ObjectGuid) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"CompareByObjectGuid called on function that has no Guid specified");
        return false;
    }
    return 0==wcscmp(m_ObjectGuid,Guid)?true:false;
}

WCHAR* CDsName::GetDNSName() {

    ASSERT(m_DistName);
    
    DS_NAME_RESULTW *res=0;

    DWORD err = DsCrackNamesW(NULL,
                              DS_NAME_FLAG_SYNTACTICAL_ONLY,
                              DS_FQDN_1779_NAME,
                              DS_CANONICAL_NAME,
                              1,
                              &m_DistName,
                              &res
                              );
    if (ERROR_SUCCESS != err) {
        m_Error.SetErr(err,
                        L"Failed to get the DNS name for object.");
        return 0;
    }

    if (DS_NAME_NO_ERROR != res->rItems[0].status) {
        m_Error.SetErr(ERROR_GEN_FAILURE,
                        L"Failed to get the DNS name for object.");
        return 0;
    }

    WCHAR* ret = new WCHAR[wcslen(res->rItems[0].pDomain+1)];
    if (!ret) {
        m_Error.SetMemErr();
        return 0;
    }
    wcscpy(ret,res->rItems[0].pDomain);

    if (res) {
        DsFreeNameResultW(res);
    }

    return ret;
               
}

WCHAR* CDsName::GetDN(BOOL ShouldAllocate /*= TRUE*/) 
{
    ASSERT(m_DistName);

    if (ShouldAllocate) {
        WCHAR *ret = new WCHAR[wcslen(m_DistName)+1];
        if (!ret) {
            m_Error.SetMemErr();
            return 0;
        }
        wcscpy(ret,m_DistName);
        return ret;
    }
    return m_DistName;
}

WCHAR* CDsName::GetGuid(BOOL ShouldAllocate /*= TRUE*/) 
{
    ASSERT(m_ObjectGuid);

    if (ShouldAllocate) {
        WCHAR *ret = new WCHAR[wcslen(m_ObjectGuid)+1];
        if (!ret) {
            m_Error.SetMemErr();
            return 0;
        }
        wcscpy(ret,m_ObjectGuid);
        return ret;    
    }

    return m_ObjectGuid;
}

WCHAR* CDsName::GetSid() 
{
    if (!m_ObjectSid) {
        return 0;
    }

    WCHAR *ret = new WCHAR[wcslen(m_ObjectSid)+1];
    if (!ret) {
        m_Error.SetMemErr();
        return 0;
    }
    wcscpy(ret,m_ObjectSid);
    return ret;    
}

DWORD CDsName::GetError() 
{
    if ( !m_Error.isError() ) {
        return ERROR_SUCCESS;
    }
    return m_Error.GetErr();
        
}

CDomain::CDomain(CDsName *Crossref,
                 CDsName *DNSObject,
                 WCHAR *DNSroot,
                 WCHAR *netbiosName,
                 BOOL  p_isDomain,
                 BOOL  p_isExtern,
                 BOOL  p_isDisabled,
                 WCHAR *DcName) 
{
    m_CrossRefObject = Crossref;
    m_DomainDNSObject = DNSObject;
    m_dnsRoot = DNSroot;
    m_NetBiosName = netbiosName;
    m_isDomain = p_isDomain;
    m_isDisabled = p_isDisabled;
    m_PrevDnsRoot = 0;
    m_PrevNetBiosName = 0;
    m_DcName = DcName;
    m_tdoList = 0;
    m_itaList = 0;
    m_TDOcount = 0;
    m_SpnList = NULL;
    m_isExtern = p_isExtern;
    m_next = m_parent = m_lChild = m_rSibling = 0;
    m_refcount = new LONG;
    if (!m_refcount) {
        m_Error.SetMemErr();
    } else {
        *m_refcount = 1;
    }
    
}

CDomain::CDomain(const CDomain &domain)
{
    memcpy((PVOID)this,(PVOID)&domain,sizeof(domain));
    InterlockedIncrement(m_refcount);
} 

CDomain& CDomain::operator=(const CDomain &domain)
{
    memcpy((PVOID)this,(PVOID)&domain,sizeof(domain));
    InterlockedIncrement(m_refcount);
    return *this;
}

CDomain::~CDomain() {
    if (InterlockedDecrement(m_refcount) == 0) {
        if (m_CrossRefObject) {
            delete m_CrossRefObject;
        }
        if (m_DomainDNSObject) {
            delete m_DomainDNSObject;
        }
        if (m_dnsRoot) {
            delete m_dnsRoot;
        }
        if (m_NetBiosName) {
            delete m_NetBiosName;
        }
        if (m_PrevDnsRoot) {
            delete m_PrevDnsRoot;
        }
        if (m_PrevNetBiosName) {
            delete m_PrevNetBiosName;
        }
        if (m_DcName) {
            delete m_DcName;
        }
        if (m_tdoList) {
            delete m_tdoList;
        }
        if (m_itaList) {
            delete m_itaList;
        }
        if (m_SpnList) {
            delete m_SpnList;
        }
        if (m_refcount) {
            delete m_refcount;
        }
    }
}

VOID CDomain::DumpCDomain()
{
    wprintf(L"Domain Dump****************************\n");

    if (m_CrossRefObject) {
        wprintf(L"CrossRef:\n");
        m_CrossRefObject->DumpCDsName();
    } else {
        wprintf(L"CrossRef: (NULL)\n");
    }

    if (m_DomainDNSObject) {
        wprintf(L"DomainDNS:\n");
        m_DomainDNSObject->DumpCDsName();
    } else {
        wprintf(L"DomainDNS: (NULL)\n");
    }
    
    wprintf(L"Is Domain: %ws\n",m_isDomain?L"TRUE":L"FALSE");

    if (m_dnsRoot) {
        wprintf(L"dnsRoot: %ws\n",m_dnsRoot);
    } else {
        wprintf(L"dnsRoot: (NULL)\n");
    }

    if (m_NetBiosName) {
        wprintf(L"NetBiosName: %ws\n",m_NetBiosName);
    } else {
        wprintf(L"NetBiosName: (NULL)\n");
    }
    
    if (m_PrevDnsRoot) {
        wprintf(L"PrevDnsRoot: %ws\n",m_PrevDnsRoot);
    } else {
        wprintf(L"PrevDnsRoot: (NULL)\n");
    }

    if (m_PrevNetBiosName) {
        wprintf(L"PrevNetBiosName: %ws\n",m_PrevNetBiosName);
    } else {
        wprintf(L"PrevNetBiosName: (NULL)\n");
    }

    if (m_DcName) {
        wprintf(L"DcName: %ws\n",m_DcName);
    } else {
        wprintf(L"DcName: (NULL)\n");
    }

    if (m_parent) {
        wprintf(L"Parent Domain: %ws\n",m_parent->m_dnsRoot);
    } else {
        wprintf(L"Parent Domain: none\n");
    }
    
    if (m_lChild) {
        wprintf(L"Left Child: %ws\n",m_lChild->m_dnsRoot);
    } else {
        wprintf(L"Left Child: none\n");
    }
    
    if (m_rSibling) {
        wprintf(L"Right Sibling: %ws\n",m_rSibling->m_dnsRoot);
    } else {
        wprintf(L"Right Sibling: none\n");
    }

    wprintf(L"Trusted Domain Objects\n");
    if (m_tdoList) {
        CTrustedDomain* t = m_tdoList;
        while (t) {
            t->DumpTrust();
            t = (CTrustedDomain*)t->GetNext();
        }
    } else {
        wprintf(L"!!!!!!!!No Trusts\n");
    }

    wprintf(L"Interdomain Trust Objects\n");
    if (m_itaList) {
        CInterDomainTrust* t = m_itaList;
        while (t) {
            t->DumpTrust();
            t = (CInterDomainTrust*)t->GetNext();
        }
    } else {
        wprintf(L"!!!!!!!!No Trusts\n");
    }

    wprintf(L"ERROR: %d\n",m_Error.GetErr());
    wprintf(L"End Domain Dump ************************\n");

}

BOOL CDomain::isDomain()
{
    return m_isDomain;
}

BOOL CDomain::isDisabled()
{
    return m_isDisabled;
}

BOOL CDomain::isExtern()
{
    return m_isExtern;
}

WCHAR* CDomain::GetParentDnsRoot(BOOL Allocate /*= TRUE*/) 
{
    //Tail will return a point to newly allocated memory
    //with the information that we need.
    return Tail(m_dnsRoot,
                Allocate);
}

WCHAR* CDomain::GetPrevParentDnsRoot(BOOL Allocate /*= TRUE*/) 
{
    //Tail will return a point to newly allocated memory
    //with the information that we need.
    return Tail(m_PrevDnsRoot,
                Allocate);
}

WCHAR* CDomain::GetDnsRoot(BOOL ShouldAllocate /*= TRUE*/)
{
    ASSERT(m_dnsRoot);

    if (ShouldAllocate) {
        WCHAR *ret = new WCHAR[wcslen(m_dnsRoot)+1];
        if (!ret) {
            m_Error.SetMemErr();
            return 0;
        }
    
        wcscpy(ret,m_dnsRoot);
    
        return ret;
    }

    return m_dnsRoot;
}

WCHAR* CDomain::GetDcToUse(BOOL Allocate /*= TRUE*/)
{
    if (!m_DcName) {
        return NULL;
    }
    if (Allocate) {
        WCHAR *ret = new WCHAR[wcslen(m_DcName)+1];
        if (!ret) {
            m_Error.SetMemErr();
            return 0;
        }
    
        wcscpy(ret,m_DcName);
    
        return ret;    
    }

    return m_DcName;
}

BOOL CDomain::Merge(CDomain *domain)
{
    m_PrevDnsRoot = m_dnsRoot;
    m_dnsRoot = domain->GetDnsRoot();
    if (m_Error.isError()) 
    {
        return FALSE;
    }
    m_PrevNetBiosName = m_NetBiosName;
    m_NetBiosName = domain->GetNetBiosName();
    if (m_Error.isError()) {
        return FALSE;
    }
    m_DcName = domain->GetDcToUse();
    if (m_Error.isError()) 
    {
        return FALSE;
    }

    return TRUE;
}

WCHAR* CDomain::GetPrevDnsRoot(BOOL ShouldAllocate /*= TRUE*/)
{
    if (!m_PrevDnsRoot) {
        return GetDnsRoot(ShouldAllocate);
    }

    if (ShouldAllocate) {
        WCHAR *ret = new WCHAR[wcslen(m_PrevDnsRoot)+1];
        if (!ret) {
            m_Error.SetMemErr();
            return 0;
        }
    
        wcscpy(ret,m_PrevDnsRoot);
        
        return ret;
    }

    return m_PrevDnsRoot;

}

WCHAR* CDomain::GetNetBiosName(BOOL ShouldAllocate /*= TRUE*/) 
{
    if (!m_NetBiosName) {
        return NULL;
    }
    if (ShouldAllocate) {
        WCHAR *ret = new WCHAR[wcslen(m_NetBiosName)+1];
        if (!ret) {
            m_Error.SetMemErr();
            return NULL;
        }
    
        wcscpy(ret,m_NetBiosName);
    
        return ret;
    }

    return m_NetBiosName;
}

WCHAR* CDomain::GetPrevNetBiosName(BOOL ShouldAllocate /*= TRUE*/) 
{
    if (!m_PrevNetBiosName) {
        return GetNetBiosName(ShouldAllocate);
    }

    if (ShouldAllocate) {
        WCHAR *ret = new WCHAR[wcslen(m_PrevNetBiosName)+1];
        if (!ret) {
            m_Error.SetMemErr();
            return 0;
        }
    
        wcscpy(ret,m_PrevNetBiosName);
    
        return ret;
    }

    return m_PrevNetBiosName;
}

/*
CDsName* CDomain::GetDomainCrossRef()
{
    CDsName *ret = new CDsName(m_CrossRefObject);
    if (!ret)
    {
        m_Error.SetMemErr();
    }

    return ret;
} */

CDsName* CDomain::GetDomainCrossRef()
{
    return m_CrossRefObject;
}

/*
CDsName* CDomain::GetDomainDnsObject()
{
    CDsName *ret = new CDsName(m_DomainDNSObject);
    if (!ret)
    {
        m_Error.SetMemErr();
    }

    return ret;
} */

CDsName* CDomain::GetDomainDnsObject()
{
    return m_DomainDNSObject;
}

CDomain* CDomain::LookupByNetbiosName(const WCHAR* NetBiosName)
{
    if (!NetBiosName) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Parameter passed into LookupByNetBiosName is NULL");
    }
    if( m_NetBiosName && (0 == _wcsicmp(m_NetBiosName,NetBiosName)) )
    {
        return this;
    }

    CDomain *domain = GetNextDomain();
    while ( domain ) {
        WCHAR *TempNetbiosName = domain->GetNetBiosName();
        if (TempNetbiosName) 
        {
            if( 0 == _wcsicmp(NetBiosName,TempNetbiosName) )
            {
                delete TempNetbiosName;
                return domain;
            }
            delete TempNetbiosName;
        }

        domain = domain ->GetNextDomain();
    }

    return 0;
}

CDomain* CDomain::LookupByPrevNetbiosName(const WCHAR* NetBiosName)
{
    if (!NetBiosName) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Parameter passed into LookupByPrevNetBiosName is NULL");
    }
    
    if( m_PrevNetBiosName && (0 == _wcsicmp(m_PrevNetBiosName,NetBiosName)) )
    {
        return this;
    }

    CDomain *domain = GetNextDomain();
    while ( domain ) {
        WCHAR *TempNetbiosName = domain->GetPrevNetBiosName();
        if (TempNetbiosName) 
        {
            if( 0 == _wcsicmp(NetBiosName,TempNetbiosName) )
            {
                delete TempNetbiosName;
                return domain;
            }
            delete TempNetbiosName;
        }

        domain = domain->GetNextDomain();
    }

    return 0;
}

CDomain* CDomain::LookupByGuid(const WCHAR* Guid)
{
    WCHAR *TempGuid = 0;
    if (!Guid) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Parameter passed into LookupByGuid is NULL");
        return 0;
    }
    TempGuid = m_DomainDNSObject->GetGuid();
    if (!TempGuid) {
        m_Error.SetMemErr();
        return 0;
    }
    if( 0 == _wcsicmp(TempGuid,Guid) )
    {
        delete TempGuid;
        return this;             
    }
    delete TempGuid;

    CDomain *domain = GetNextDomain();
    while ( domain ) {
        TempGuid = domain->GetGuid();
        if (!TempGuid) {
            m_Error.SetMemErr();
            return 0;   
        }
        if( 0 == _wcsicmp(Guid,TempGuid) )
        {
            delete TempGuid;
            return domain;
        }
        delete TempGuid;
        domain = domain->GetNextDomain();
    }

    return 0;
}

CDomain* CDomain::LookupbySid(const WCHAR* Sid)
{
    WCHAR *TempSid = 0;
    if (!Sid) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Parameter passed into LookupBySid is NULL");
        return NULL;
    }
    TempSid = m_DomainDNSObject->GetSid();
    if (m_Error.isError()) {
        return NULL;
    }
    if (TempSid) 
    {
        if( 0 == _wcsicmp(TempSid,Sid) )
        {
            delete TempSid;
            return this;             
        }
        delete TempSid;
    }

    CDomain *domain = GetNextDomain();
    while ( domain ) {
        TempSid = domain->GetSid();
        if (m_Error.isError()) {
            return NULL;   
        }
        if (TempSid) 
        {
            if( 0 == _wcsicmp(Sid,TempSid) )
            {
                delete TempSid;
                return domain;
            }
            delete TempSid;
        }
        domain = domain->GetNextDomain();
    }

    return 0;

}

BOOL CDomain::isNetBiosNameRenamed()
{
    if (!m_PrevNetBiosName) {
        return FALSE;
    }
    if (_wcsicmp(m_PrevNetBiosName,m_NetBiosName) == 0) {
        return FALSE;
    }
    return TRUE;
}

BOOL CDomain::isDnsNameRenamed()
{  
    if (!m_PrevDnsRoot) {
        return FALSE;
    }
    if (_wcsicmp(m_PrevDnsRoot,m_dnsRoot) == 0) {
        return FALSE;
    }
    return TRUE;
}

CDomain* CDomain::LookupByDnsRoot(const WCHAR* DNSRoot)
{
    if (!DNSRoot) {
        return NULL;
    }
    ASSERT(GetDnsRoot(FALSE));
    
    if( 0 == _wcsicmp(DNSRoot,GetDnsRoot(FALSE)) )
    {
        return this;
    }
    
    CDomain *domain = GetNextDomain();
    while( domain ) {

        ASSERT(domain->GetDnsRoot(FALSE));
        
        if( 0 == _wcsicmp(DNSRoot,domain->GetDnsRoot(FALSE)) )
        {
            return domain;
        }
        
        domain = domain->GetNextDomain();
    }


    return 0;
}

CDomain* CDomain::LookupByPrevDnsRoot(const WCHAR* DNSRoot)
{
    if (!DNSRoot) {
        return NULL;
    }
    ASSERT(GetPrevDnsRoot(FALSE));
    
    if( 0 == _wcsicmp(DNSRoot,GetPrevDnsRoot(FALSE)) )
    {
        return this;
    }
    
    CDomain *domain = GetNextDomain();
    while( domain ) {

        ASSERT(domain->GetPrevDnsRoot(FALSE));
        
        if( 0 == _wcsicmp(DNSRoot,domain->GetPrevDnsRoot(FALSE)) )
        {
            return domain;
        }
        
        domain = domain->GetNextDomain();
    }


    return 0;
}

WCHAR* CDomain::GetGuid(BOOL ShouldAllocate /*= TRUE*/)
{
    WCHAR *Guid = m_DomainDNSObject->GetGuid(ShouldAllocate) ;
    if ( !Guid )
    {
        m_Error.SetErr(m_DomainDNSObject->GetError(),
                        L"Failed to get the Guid for the domain");
        return NULL;
    }
    return Guid;
    
}

WCHAR* CDomain::GetSid()
{
    return m_DomainDNSObject->GetSid();
}

BOOL CDomain::SetParent(CDomain *Parent)
{
    m_parent = Parent;
    return true;
}

BOOL CDomain::SetLeftMostChild(CDomain *LeftChild)
{
    m_lChild = LeftChild;
    return true;
}

BOOL CDomain::SetRightSibling(CDomain *RightSibling)
{
    m_rSibling = RightSibling;
    return true;
}

BOOL CDomain::SetNextDomain(CDomain *Next)
{
    m_next = Next;
    return true;
}

CDomain* CDomain::GetParent()
{
    return m_parent;
}

CDomain* CDomain::GetLeftMostChild()
{
    return m_lChild;
}

CDomain* CDomain::GetRightSibling()
{
    return m_rSibling;
}

CDomain* CDomain::GetNextDomain()
{
    return m_next;
}

CTrustedDomain* CDomain::GetTrustedDomainList()
{
    return m_tdoList;
}

CInterDomainTrust* CDomain::GetInterDomainTrustList()
{
    return m_itaList;
}

CDcSpn* CDomain::GetDcSpn()
{
    return m_SpnList;
}

BOOL CDomain::AddDomainTrust(CTrustedDomain *tdo)
{
    if (!tdo->SetNext(m_tdoList))
    {
        return FALSE;
    }
    m_tdoList = tdo;

    return TRUE;
}

BOOL CDomain::AddInterDomainTrust(CInterDomainTrust *ita)
{
    if (!ita->SetNext(m_itaList)) 
    {
        return FALSE;
    }
    m_itaList = ita;

    return TRUE;
}

BOOL CDomain::AddDcSpn(CDcSpn *DcSpn)
{
    if (!DcSpn) {
        m_Error.SetMemErr();
        return FALSE;
    }

    if (!DcSpn->SetNextDcSpn(m_SpnList)) 
    {
        return FALSE;
    }
    m_SpnList = DcSpn;

    return TRUE;
}

inline CDomain* CTrust::GetTrustPartner()
{
    return m_TrustPartner;
}

inline CDsName* CTrust::GetTrustDsName()
{
    return m_Object;
}

BOOL CTrust::SetNext(CTrust *Trust)
{
    m_next = Trust;
    return TRUE;
}

CTrust* CTrust::GetNext()
{
    return m_next;
}

CTrust::CTrust(CDsName *p_Object,
               CDomain *p_TrustPartner,
               DWORD   p_TrustDirection /*= 0*/)
{
    m_Object = p_Object;
    m_TrustPartner = p_TrustPartner;
    m_TrustDirection = p_TrustDirection;
    m_refcount = new LONG;
    if (!m_refcount) {
        m_Error.SetMemErr();
    } else {
        *m_refcount = 1;
    }
}

CTrust::CTrust(const CTrust &trust)
{
    memcpy((PVOID)this,(PVOID)&trust,sizeof(trust));
    InterlockedIncrement(m_refcount);
}

CTrust::~CTrust()
{
    if (InterlockedDecrement(m_refcount) == 0) {
        if (m_Object) {
            delete m_Object;
        }
    }
}

BOOL CTrust::operator<(CTrust& trust)
{
    return this->m_TrustPartner < trust.m_TrustPartner;
}

CTrust& CTrust::operator=(const CTrust &trust)
{
    memcpy((PVOID)this,(PVOID)&trust,sizeof(trust));
    InterlockedIncrement(m_refcount);
    return *this;
}

BOOL CTrust::operator==(CTrust &trust)
{
    return this->m_refcount == trust.m_refcount;
}

VOID CTrust::DumpTrust()
{
    if (m_Object) 
    {
        m_Object->DumpCDsName();
    }
    if (m_TrustPartner)
    {
        m_TrustPartner->GetDomainDnsObject()->DumpCDsName();
    }
}

VOID CTrustedDomain::DumpTrust()
{
    if (m_Object) 
    {
        m_Object->DumpCDsName();
    }
    if (m_TrustPartner)
    {
        m_TrustPartner->GetDomainDnsObject()->DumpCDsName();
    }
    wprintf(L"TrustType: %d\n",
            m_TrustType);
}

CDc::CDc(WCHAR *NetBiosName,
         DWORD State,
         BYTE  *Password,
         DWORD cbPassword,
         DWORD LastError,
         WCHAR *FatalErrorMsg,
         WCHAR *LastErrorMsg,
         BOOL  retry,
         PVOID Data)
{
    m_Name =  NetBiosName;
    m_State = State;
    m_LastError = LastError;
    m_FatalErrorMsg = FatalErrorMsg;
    m_LastErrorMsg = LastErrorMsg;
    m_nextDC = NULL;
    m_Data  = Data;
    m_RPCReturn = 0;
    m_RPCVersion = 0;
    m_Password = NULL;
    m_cbPassword = 0;
    m_Retry = retry;
    
    if (Password) {
        SetPassword(Password,
                    cbPassword);
    }
}

CDc::CDc(WCHAR *NetBiosName,
         DWORD State,
         WCHAR *Password,
         DWORD LastError,
         WCHAR *FatalErrorMsg,
         WCHAR *LastErrorMsg,
         BOOL  retry,
         PVOID Data)
{
    m_Name =  NetBiosName;
    m_State = State;
    m_LastError = LastError;
    m_FatalErrorMsg = FatalErrorMsg;
    m_LastErrorMsg = LastErrorMsg;
    m_nextDC = NULL;
    m_Data  = Data;
    m_RPCReturn = 0;
    m_RPCVersion = 0;
    m_Password = NULL;
    m_cbPassword = 0;
    m_Retry = retry;

    if (Password) {
        SetPassword(Password);
    }
}

CDc::~CDc()
{
    if (m_Name) {
        delete m_Name;
    }
    if (m_FatalErrorMsg) {
        delete m_FatalErrorMsg;
    }
    if (m_LastErrorMsg) {
        delete m_LastErrorMsg;
    }
    if (m_Password) {
        delete m_Password;
    }
    if (m_nextDC) {
        delete m_nextDC;
    }
    
}

BOOL CDc::SetPassword(BYTE *password,
                      DWORD cbpassword)
{
    if (!password) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Null was passed to SetPassword"); 
        return FALSE;
    } 

    m_Password = new BYTE[cbpassword];
    if (!m_Password) {
        m_Error.SetMemErr();
        return FALSE;
    }

    memcpy(m_Password,password,cbpassword);
    m_cbPassword = cbpassword;

    return TRUE;
}

BOOL CDc::SetPassword(WCHAR *password)
{
    if (!password) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Null was passed to SetPassword"); 
        return FALSE;
    } 

    BYTE     decodedbytes[100];
    DWORD    dwDecoded = 0;
    NTSTATUS dwErr = STATUS_SUCCESS;
    CHAR     *szPassword = NULL;

    szPassword = Convert2Chars(password);
    if (!szPassword) {
        m_Error.SetErr(GetLastError(),
                        L"Failed to Convert charaters");
        return FALSE;
    }

    dwErr = base64decode((LPSTR)szPassword, 
                         (PVOID)decodedbytes,
                         sizeof (decodedbytes),
                         &dwDecoded);

    if (szPassword) {
        LocalFree(szPassword);
    }

    ASSERT( dwDecoded <= 100 );

    if (STATUS_SUCCESS != dwErr) {
        m_Error.SetErr(RtlNtStatusToDosError(dwErr),
                        L"Failed to decode Password");
        return FALSE;
    }

    if (!SetPassword(decodedbytes,
                     dwDecoded)) 
    {
        return FALSE;
    }
    
    return TRUE;
}

VOID CDc::CallSucceeded()
{
    InterlockedIncrement(&m_CallsSuccess);
}

VOID CDc::CallFailed()    
{
    InterlockedIncrement(&m_CallsFailure);
}

BOOL CDc::SetFatalErrorMsg(WCHAR *Error)
{
    DWORD size=0;

    if (!Error) {
        return TRUE;
    }

    size = wcslen(Error);
    m_FatalErrorMsg = new WCHAR[size+1];
    if (!m_FatalErrorMsg) {
        m_Error.SetMemErr();
        return FALSE;
    }

    wcscpy(m_FatalErrorMsg,Error);

    return TRUE;
}

VOID CDc::PrintRPCResults()
{
    if (((m_CallsSuccess+m_CallsFailure) == 1)) {
        wprintf(L"%d server contacted, %d ",
                m_CallsSuccess+m_CallsFailure,
                m_CallsFailure);
    } else {
        wprintf(L"%d servers contacted, %d ",
                m_CallsSuccess+m_CallsFailure,
                m_CallsFailure);
    }

    if (m_CallsFailure == 1) {
        _putws(L"server returned Errors\r\n");
    } else {
        _putws(L"servers returned Errors\r\n");
    }
}

BOOL CDc::SetLastErrorMsg(WCHAR *Error)
{
    DWORD size=0;

    if (!Error) {
        return TRUE;
    }

    size = wcslen(Error);
    m_LastErrorMsg = new WCHAR[size+1];
    if (!m_LastErrorMsg) {
        m_Error.SetMemErr();
        return FALSE;
    }

    wcscpy(m_LastErrorMsg,Error);

    return TRUE;
}

CDcList::CDcList(CReadOnlyEntOptions *opts)
{
    m_dclist    = NULL;
    m_hash      = NULL;
    m_Signature = NULL;
    m_cbhash    = 0;
    m_cbSignature = 0;

    m_Opts = opts;

    CDc::SetOptions(m_Opts);
}

CDcList::~CDcList()
{
    if (m_dclist) {
        delete m_dclist;
    }
    if (m_hash) {
        delete m_hash;
    }
    if (m_Signature) {
        delete m_Signature;
    }
}

BOOL CDcList::SetbodyHash(WCHAR *Hash)
{
    if (!Hash) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Null was passed to SetbodyHash"); 
        return FALSE;
    } 

    BYTE  decodedbytes[100];
    DWORD dwDecoded = 0;
    NTSTATUS dwErr = STATUS_SUCCESS;
    CHAR  *szHash = NULL;

    szHash = Convert2Chars(Hash);
    if (!szHash) {
        m_Error.SetErr(GetLastError(),
                        L"Failed to Convert charaters");
        return FALSE;
    }

    dwErr = base64decode((LPSTR)szHash, 
                         (PVOID)decodedbytes,
                         sizeof (decodedbytes),
                         &dwDecoded);

    if (szHash) {
        LocalFree(szHash);
    }

    ASSERT( dwDecoded <= 100 );

    if (STATUS_SUCCESS != dwErr) {
        m_Error.SetErr(RtlNtStatusToDosError(dwErr),
                        L"Failed to decode Hash");
        return FALSE;
    }

    if (!SetbodyHash(decodedbytes,
                     dwDecoded)) 
    {
        return FALSE;
    }
    
    return TRUE;

}

BOOL CDcList::SetbodyHash(BYTE *Hash,
                          DWORD cbHash)
{
    if (!Hash) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Null was passed to SetbodyHash"); 
        return FALSE;
    } 

    m_hash = new BYTE[cbHash];
    if (!m_hash) {
        m_Error.SetMemErr();
        return FALSE;
    }

    memcpy(m_hash,Hash,cbHash);
    m_cbhash = cbHash;

    return TRUE;
    
}

BOOL CDcList::SetSignature(WCHAR *Signature)
{
    if (!Signature) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Null was passed to SetSignature"); 
        return FALSE;
    } 

    BYTE  decodedbytes[100];
    DWORD dwDecoded = 0;
    NTSTATUS dwErr = STATUS_SUCCESS;
    CHAR  *szSignature = NULL;

    szSignature = Convert2Chars(Signature);
    if (!szSignature) {
        m_Error.SetErr(GetLastError(),
                        L"Failed to Convert charaters");
        return FALSE;
    }

    dwErr = base64decode((LPSTR)szSignature, 
                         (PVOID)decodedbytes,
                         sizeof (decodedbytes),
                         &dwDecoded);

    if (szSignature) {
        LocalFree(szSignature);
    }

    ASSERT( dwDecoded <= 100 );

    if (STATUS_SUCCESS != dwErr) {
        m_Error.SetErr(RtlNtStatusToDosError(dwErr),
                        L"Failed to decode Signature");
        return FALSE;
    }

    if (!SetSignature(decodedbytes,
                      dwDecoded)) 
    {
        return FALSE;
    }
    
    return TRUE;
}

BOOL CDcList::SetSignature(BYTE *Signature,
                           DWORD cbSignature)
{
    if (!Signature) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Null was passed to SetSignature"); 
        return FALSE;
    } 

    m_Signature = new BYTE[cbSignature];
    if (!m_Signature) {
        m_Error.SetMemErr();
        return FALSE;
    }

    memcpy(m_Signature,Signature,cbSignature);
    m_cbSignature = cbSignature;

    return TRUE;

}

BOOL CDcList::GetHashAndSignature(DWORD *cbhash, 
                                  BYTE  **hash,
                                  DWORD *cbSignature,
                                  BYTE  **Signature)
{
    *cbhash      = m_cbhash;
    *cbSignature = m_cbSignature;
    *hash         = m_hash;
    *Signature    = m_Signature;

    return TRUE;
}


BOOL CDcList::HashstoXML(CXMLGen *xmlgen)
{
    BYTE encodedbytes[100];
    WCHAR *wszHash      = NULL;
    WCHAR *wszSignature = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    
    
    if (dwErr = base64encode(m_hash, 
                             m_cbhash, 
                             (LPSTR)encodedbytes,
                             100,
                             NULL)) {

        m_Error.SetErr(RtlNtStatusToDosError(dwErr),
                        L"Error encoding Hash");
        
        goto Cleanup;
    }

    wszHash = Convert2WChars((LPSTR)encodedbytes);
    if (!wszHash) {
        m_Error.SetMemErr();
    }

    if (!xmlgen->WriteHash(wszHash))
    {
        goto Cleanup;
    }

    if (wszHash) {
        LocalFree(wszHash);
        wszHash = NULL;
    }

    if (dwErr = base64encode(m_Signature, 
                             m_cbSignature, 
                             (LPSTR)encodedbytes,
                             100,
                             NULL)) {

        m_Error.SetErr(RtlNtStatusToDosError(dwErr),
                        L"Error encoding signature");
        
        goto Cleanup;
    }

    wszSignature = Convert2WChars((LPSTR)encodedbytes);
    if (!wszSignature) {
        m_Error.SetMemErr();
    }

    if (!xmlgen->WriteSignature(wszSignature))
    {
        goto Cleanup;
    }


    Cleanup:

    if (wszHash) {
        LocalFree(wszHash);
    }

    if (wszSignature) {
        LocalFree(wszSignature);
    }

    if (m_Error.isError()) {
        return FALSE;
    }
    
    return TRUE;

}

BOOL CDc::SetNextDC(CDc *dc)
{
    m_nextDC = dc;

    return TRUE;
}

BOOL CDcList::AddDcToList(CDc *dc)
{
    if (!dc->SetNextDC(m_dclist))
    {
        return FALSE;
    }

    m_dclist = dc;

    return TRUE;
}

//parameter block
typedef struct _RPC_PARAMS {
    DWORD                CallIndex;
    CDcList::ExecuteType executetype;
    BOOL                 CallNext;
    HANDLE               hThread;
    CReadOnlyEntOptions  Opts;
    CDc *                pDc;
} RPC_PARAMS,*PRPC_PARAMS;

//Global to see if need to wait for more Calls
LONG gCallsReturned = 0;
//Global For the hash and Signature
BYTE  *gHash = NULL;
DWORD gcbHash = 0;
BYTE *gSignature = NULL;
DWORD gcbSignature = 0;

DWORD 
WINAPI 
ThreadRPCDispatcher(
    LPVOID lpThreadParameter
    )
{
    RPC_STATUS                   rpcStatus  = RPC_S_OK;
    DWORD                        dwErr = ERROR_SUCCESS;
    BOOL                         CallMade = FALSE;
    
    DWORD                CallIndex    = ((PRPC_PARAMS)lpThreadParameter)->CallIndex;
    BOOL                 CallNext     = ((PRPC_PARAMS)lpThreadParameter)->CallNext;
    CDcList::ExecuteType executetype  = ((PRPC_PARAMS)lpThreadParameter)->executetype;
    HANDLE               ThreadHandle = ((PRPC_PARAMS)lpThreadParameter)->hThread;
    CReadOnlyEntOptions  Opts         = ((PRPC_PARAMS)lpThreadParameter)->Opts;
    CDc                  *dc          = ((PRPC_PARAMS)lpThreadParameter)->pDc;

    if ( !dc ) {
        goto Cleanup;
    }

    if (ghDS[CallIndex]) {
        DsaopUnBind(&ghDS[CallIndex]);
        ghDS[CallIndex] = NULL;
    }
    
    if (dc->ShouldRetry() && (executetype==CDcList::eExecute) && (DC_STATE_DONE <= dc->GetState())) {
        dc->SetState(DC_STATE_PREPARED);
    }

    if (dc->ShouldRetry() && (executetype==CDcList::ePrepare) && (DC_STATE_PREPARED <= dc->GetState())) {
        dc->SetState(DC_STATE_INITIAL);
    }

    if (executetype==CDcList::ePrepare) {
        if (DC_STATE_PREPARED == dc->GetState()) {
    
            wprintf(L"%ws has already been prepared.\n",
                    dc->GetName());
            goto Cleanup;
        }
    }

    if (DC_STATE_DONE == dc->GetState()) {

        wprintf(L"%ws has already been renamed.\n",
                dc->GetName());
        goto Cleanup;
    }
    if (DC_STATE_ERROR == dc->GetState()) {
        wprintf(L"%ws has a fatal error cannot recover.\n",
                dc->GetName());
        dc->CallFailed();
        goto Cleanup;
    }

    dc->m_Data = executetype==CDcList::eExecute?(PVOID)&gexecutereply[CallIndex]:(PVOID)&gpreparereply[CallIndex];   //NOTE need different data for execute
    dc->m_CallIndex = CallIndex;
    
    rpcStatus =  RpcAsyncInitializeHandle(&gAsyncState[CallIndex],
                                          sizeof( RPC_ASYNC_STATE ) );
    if (RPC_S_OK != rpcStatus) {
        CRenDomErr::SetErr(rpcStatus,
                           L"Failed to initialize Async State.");
        goto Cleanup;
    }

    gAsyncState[CallIndex].NotificationType      =     RpcNotificationTypeApc;
    gAsyncState[CallIndex].u.APC.NotificationRoutine = executetype==CDcList::eExecute?ExecuteScriptCallback:PrepareScriptCallback;
    gAsyncState[CallIndex].u.APC.hThread             = ThreadHandle;
    gAsyncState[CallIndex].UserInfo                  = (PVOID)dc;

    if ( Opts.pCreds ) {
        
        dwErr = DsaopBindWithCred(dc->GetName(), 
                                  NULL, 
                                  Opts.pCreds,
                                  executetype==CDcList::ePrepare?RPC_C_AUTHN_GSS_KERBEROS:RPC_C_AUTHN_NONE, 
                                  executetype==CDcList::ePrepare?RPC_C_PROTECT_LEVEL_PKT_PRIVACY:RPC_C_PROTECT_LEVEL_NONE,
                                  &ghDS[CallIndex]);
    }
    else {
                                                          
        dwErr = DsaopBind(dc->GetName(), 
                          NULL,
                          executetype!=CDcList::eExecute?RPC_C_AUTHN_GSS_KERBEROS:RPC_C_AUTHN_NONE, 
                          executetype!=CDcList::eExecute?RPC_C_PROTECT_LEVEL_PKT_PRIVACY:RPC_C_PROTECT_LEVEL_NONE,
                          &ghDS[CallIndex]);
    }

    
    if (dwErr) {
        if (dc->GetName()) {
            wprintf(L"Failed to Bind to server %s : %d.\r\n",
                    dc->GetName(),
                    dwErr);
        } else {
            wprintf(L"Failed to Bind to the Active Directory : %d.\r\n",
                    dwErr);   
        }
        dc->SetLastError(dwErr);
        dc->SetLastErrorMsg(L"Failed to Bind to server.");
        dc->CallFailed();
        goto Cleanup;
    }

    
    if (executetype==CDcList::eExecute) {

        dwErr = DsaopExecuteScript ((PVOID)&gAsyncState[CallIndex],
                                    ghDS[CallIndex], 
                                    dc->GetPasswordSize(),
                                    dc->GetPassword(),
                                    &dc->m_RPCVersion,
                                    dc->m_Data);

    } else {
    
        dwErr = DsaopPrepareScript ((PVOID)&gAsyncState[CallIndex],
                                    ghDS[CallIndex],
                                    &dc->m_RPCVersion,
                                    dc->m_Data
                                    );

    }
    
    if (ERROR_SUCCESS != dwErr) {
        if (executetype==CDcList::eExecute) {
            CRenDomErr::SetErr(dwErr,
                               L"Failed to execute script.");
        } else {
            CRenDomErr::SetErr(dwErr,
                               L"Failed to prepare script.");
        }
        goto Cleanup;
    }

    CallMade = TRUE;

    Cleanup:

    if (!CallMade) {
        
        InterlockedIncrement(&gCallsReturned);
        if (dc) {
        
            //
            // Since no call was made we will attempt use this 
            // callindex for the next DC
            // Make a RPC call to the next server (if any) 
            //
            dc->MakeRPCCall(CallIndex,
                            executetype,
                            TRUE);

        }

    }
    
    if (lpThreadParameter) {
        delete lpThreadParameter;
    }

    if (CRenDomErr::isError()) {
        return FALSE;
    }

    return TRUE;

}

BOOL CDc::MakeRPCCall(DWORD CallIndex,
                      CDcList::ExecuteType executetype,
                      BOOL  CallNext /* = FALSE*/)
{
    static HANDLE LocalThreadHandle = NULL;
    PRPC_PARAMS rpcParams = NULL;
    HANDLE CalledThread = NULL;
    DWORD threadID = 0;

    if (CallNext && !gdc) {
        goto Cleanup;
    }

    if (!LocalThreadHandle) {
        LocalThreadHandle = GetLocalThreadHandle();
        if (m_Error.isError()) {
            goto Cleanup;
        }
    }

    rpcParams = new RPC_PARAMS;
    if (!rpcParams) {
        m_Error.SetMemErr();
        goto Cleanup;
    }
    
    rpcParams->CallIndex   = CallIndex;
    rpcParams->CallNext    = CallNext;
    rpcParams->executetype = executetype;
    rpcParams->hThread     = LocalThreadHandle;
    rpcParams->Opts        = *m_Opts;

    if (CallNext) {
        rpcParams->pDc = gdc;
        gdc = gdc->GetNextDC();        
    } else {
        rpcParams->pDc = this;
    }

    if (CallNext) 
    {
        
        InterlockedDecrement(&gCallsReturned);

    }

    CalledThread = CreateThread(NULL,                     // SD
                                0,                        // initial stack size
                                &ThreadRPCDispatcher,     // thread function
                                (LPVOID)rpcParams,        // thread argument
                                0,                        // creation option
                                &threadID                 // thread identifier
                                );
    if (!CalledThread) {
        m_Error.SetErr(GetLastError(),
                       L"Fail to start Rpc Dispatcher thread.");
        goto Cleanup;
    }
    
    CloseHandle(CalledThread);

    Cleanup:

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;
}

HANDLE CDc::GetLocalThreadHandle()
{
    HANDLE LocalThreadHandle = NULL;
    
    if (!DuplicateHandle(GetCurrentProcess(),      // handle to source process
                         GetCurrentThread(),       // handle to duplicate
                         GetCurrentProcess(),      // handle to target process
                         &LocalThreadHandle,       // duplicate handle
                         0,                        // requested access
                         FALSE,                    // handle inheritance option
                         DUPLICATE_SAME_ACCESS     // optional actions
                         )) 
    {
        m_Error.SetErr(GetLastError(),
                       L"Failed to create a duplicate thread handle.");
        goto Cleanup;
    }

    Cleanup:

    if (m_Error.isError()) {
        return NULL;
    }

    return LocalThreadHandle;
}

BOOL CDcList::ExecuteScript(
    CDcList::ExecuteType executetype, 
    DWORD                RendomMaxAsyncRPCCalls /* = RENDOM_MAX_ASYNC_RPC_CALLS */
    )
{
    
    DWORD                        dwErr = ERROR_SUCCESS;
    DWORD                        CallsMade = 0;
    BOOL                         NeedPrepare = FALSE;

    //zero out all of the handles
    memset(ghDS,0,sizeof(ghDS)*RendomMaxAsyncRPCCalls);

    if (!GetHashAndSignature(&gcbHash, 
                             &gHash,
                             &gcbSignature,
                             &gSignature))
    {
        return FALSE;
    }

    gdc = m_dclist;

    if (executetype==eExecute) {
        while (gdc) {
            if ( DC_STATE_PREPARED > gdc->GetState()) {
                m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                                L"Not all servers have been prepared");
                goto Cleanup;
            }
            gdc = gdc->GetNextDC();
        }
    }

    if (executetype==ePrepare) {
        while (gdc) {
            if ( 0 == gdc->GetState() || gdc->ShouldRetry() ) {
                NeedPrepare = TRUE;
            }
            gdc = gdc->GetNextDC();
        }
        if (!NeedPrepare) {
            m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                            L"All servers have been prepared");
            goto Cleanup;
        }
    }

    gdc = m_dclist;

    while (gdc) {



        if (gdc) {
            gdc->MakeRPCCall(CallsMade,
                            executetype);
            if (m_Error.isError()) {
                goto Cleanup;
            }
        }

        //next server
        if (gdc) {
            CallsMade++;
            gdc = gdc->GetNextDC();
        }

        if (!gdc || (CallsMade == RendomMaxAsyncRPCCalls)) {
            if (CallsMade > 0) {
                while (CallsMade > gCallsReturned) {
                    if( 0 == SleepEx(5000,  // time-out interval
                                    TRUE        // early completion option
                                    ))
                    {
                        wprintf(L"Waiting for DCs to reply.\r\n");
                    }

                }
            }

            for (DWORD i = 0 ;i<RendomMaxAsyncRPCCalls; i++) {
                if (ghDS[i]) {
                    dwErr = DsaopUnBind(&ghDS[i]);
                    if (ERROR_SUCCESS != dwErr) {
                        m_Error.SetErr(dwErr,
                                        L"Failed to unbind handle");
                    }
                }
            }
            
            CallsMade = 0;
            gCallsReturned = 0;

        }

    }

    Cleanup:

    for (DWORD i = 0 ;i<RendomMaxAsyncRPCCalls; i++) {
        if (ghDS[i]) {
            dwErr = DsaopUnBind(&ghDS[i]);
            if (ERROR_SUCCESS != dwErr) {
                m_Error.SetErr(dwErr,
                                L"Failed to unbind handle");
            }
        }
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    m_dclist->PrintRPCResults();
    
    return TRUE;



}

CDcSpn::CDcSpn(WCHAR *DcHostDns /*= NULL*/,
               WCHAR *NtdsGuid  /*= NULL*/,
               WCHAR *ServerMachineAccountDN /*= NULL*/
               )
{
    m_DcHostDns = DcHostDns;
    m_NextDcSpn = NULL;
    m_NtdsGuid  = NtdsGuid;
    m_ServerMachineAccountDN = ServerMachineAccountDN;
} 

CDcSpn::~CDcSpn()
{
    if (m_NextDcSpn) {
        delete m_NextDcSpn;
    }
    if (m_DcHostDns) {
        delete m_DcHostDns;
    }
    if (m_NtdsGuid) {
        delete m_NtdsGuid;
    }
    if (m_ServerMachineAccountDN) {
        delete m_ServerMachineAccountDN;
    }
}

WCHAR* CDcSpn::GetServerMachineAccountDN(BOOL Allocate /*= TRUE*/)
{
    ASSERT(m_ServerMachineAccountDN);
    
    if (Allocate) {
        WCHAR *ret = new WCHAR[wcslen(m_ServerMachineAccountDN)+1];
        if (!ret) {
            m_Error.SetMemErr();
            return 0;
        }
        wcscpy(ret,m_ServerMachineAccountDN);
        return ret;    
    }

    return m_ServerMachineAccountDN;
}

WCHAR* CDcSpn::GetDcHostDns(BOOL Allocate /* = TRUE*/)
{
    if (!m_DcHostDns) {
        return 0;
    }

    if (Allocate) {
        WCHAR *ret = new WCHAR[wcslen(m_DcHostDns)+1];
        if (!ret) {
            m_Error.SetMemErr();
            return 0;
        }
        wcscpy(ret,m_DcHostDns);
        return ret;    
    }

    return m_DcHostDns;
}

BOOL CDcSpn::SetServerMachineAccountDN(WCHAR *ServerMachineAccountDN)
{
    if (!ServerMachineAccountDN) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                       L"Null Passed to SetServerMachineAccountDN");
        return FALSE;
    }

    m_ServerMachineAccountDN = new WCHAR[wcslen(ServerMachineAccountDN)+1];
    if (!m_ServerMachineAccountDN) {
        m_Error.SetMemErr();
        return FALSE;
    }

    wcscpy(m_ServerMachineAccountDN,ServerMachineAccountDN);

    return TRUE;
}

BOOL CDcSpn::SetDcHostDns(WCHAR *DcHostDns)
{
    if (!DcHostDns) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                       L"Null Passed to SetDcHostDns");
        return FALSE;
    }

    m_DcHostDns = new WCHAR[wcslen(DcHostDns)+1];
    if (!m_DcHostDns) {
        m_Error.SetMemErr();
        return FALSE;
    }

    wcscpy(m_DcHostDns,DcHostDns);

    return TRUE;
}

BOOL CDcSpn::WriteSpnTest(CXMLGen *xmlgen,
                          WCHAR   *ServiceClass,
                          WCHAR   *ServiceName,
                          WCHAR   *InstanceName
                          )
{
    DWORD   c = 0;
    DWORD   Win32Err = ERROR_SUCCESS;
    WCHAR   errMessage[1024] = {0};
    WCHAR   *SPN = NULL;

    Win32Err = WrappedMakeSpnW(ServiceClass,
                               ServiceName,
                               InstanceName,
                               0,
                               NULL,
                               &c,
                               &SPN
                               );
    if (Win32Err != ERROR_SUCCESS) {
        m_Error.SetErr(Win32Err,
                       L"Failed to create SPN string");
        goto Cleanup;
    }

    swprintf(errMessage,
             L"Failed to find SPN %ws on %ws",
             SPN,
             GetServerMachineAccountDN(FALSE));

    if (!xmlgen->Compare(GetServerMachineAccountDN(FALSE),
                         L"servicePrincipalName",
                         SPN,
                         errMessage))
    {
        goto Cleanup;
    }

    Cleanup:

    if (SPN) {
        delete SPN;
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;

}

CDcSpn* CDcSpn::GetNextDcSpn()
{
    return m_NextDcSpn;
}

BOOL CDcSpn::SetNextDcSpn(CDcSpn *Spn)
{
    m_NextDcSpn = Spn;

    return TRUE;
}

WCHAR* CDcSpn::GetNtdsGuid(BOOL Allocate /* = TRUE*/)
{
    if (!m_NtdsGuid) {
        return 0;
    }

    if (Allocate) {
        WCHAR *ret = new WCHAR[wcslen(m_NtdsGuid)+1];
        if (!ret) {
            m_Error.SetMemErr();
            return 0;
        }
        wcscpy(ret,m_NtdsGuid);
        return ret;    
    }

    return m_NtdsGuid;
}

BOOL CDcSpn::SetNtdsGuid(WCHAR *NtdsGuid)
{
    if (!NtdsGuid) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                       L"Null Passed to SetDcHostDns");
        return FALSE;
    }

    m_NtdsGuid = new WCHAR[wcslen(NtdsGuid)+1];
    if (!m_NtdsGuid) {
        m_Error.SetMemErr();
        return FALSE;
    }

    wcscpy(m_NtdsGuid,NtdsGuid);

    return TRUE;
}


VOID PrepareScriptCallback(struct _RPC_ASYNC_STATE *pAsync,
                           void *Context,
                           RPC_ASYNC_EVENT Event)
{
    RPC_STATUS      rpcStatus  = RPC_S_OK;
    BOOL            rpcFailed  = FALSE;

    //
    // Increment the number of calls that have returned.
    //
    InterlockedIncrement(&gCallsReturned);

    RpcTryExcept 
    {
        //
        // Get the results as of the Async RPC call
        //
        rpcStatus =  RpcAsyncCompleteCall(pAsync,
                                          &(((CDc*)(pAsync->UserInfo))->m_RPCReturn)
                                          );

    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        ((CDc*)(pAsync->UserInfo))->m_RPCReturn = RpcExceptionCode();
    }
    RpcEndExcept;

    // 
    // If the RpcAsyncCompleteCall() fails return that error as the error
    // of the Aync RPC call.
    //
    if (0 != rpcStatus) {
        ((CDc*)(pAsync->UserInfo))->m_RPCReturn = rpcStatus;
    }

    if ( 0 != (((CDc*)(pAsync->UserInfo)))->m_RPCReturn ) {
        rpcFailed = TRUE;
    }

    //
    // If we are able to return the Aync RPC result and 
    // the Call itself was successful the continue to record the 
    // results of the RPC call.
    //
    if ( 0 == (((CDc*)(pAsync->UserInfo)))->m_RPCReturn && 
         0 == ((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.dwOperationStatus ) {
        //
        // Verify that were are using the correct RPC verison.
        //
        if ( 1 != (((CDc*)(pAsync->UserInfo)))->m_RPCVersion ) {
            (((CDc*)(pAsync->UserInfo)))->m_RPCReturn = RPC_S_INTERNAL_ERROR;
            (((CDc*)(pAsync->UserInfo)))->SetFatalErrorMsg(L"Incorrect RPC version expected 1");
        } else {
            //
            // Verify that the script that is on the server is a valid script.
            // We must verify that the Hash of the script is correct and that
            // the Signature of the script is correct.
            //
            BOOL WrongScript = FALSE;
            if (((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.cbHashSignature != gcbSignature)
            {
                WrongScript = TRUE;
            } 
            else if(memcmp((PVOID)gSignature,(PVOID)(((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pbHashSignature) ,gcbSignature) != 0)
            {
                WrongScript = TRUE;
            } 
            else if (((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.cbHashBody != gcbHash)
            {
                WrongScript = TRUE;
            }
            else if(memcmp((PVOID)gHash,(PVOID)(((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pbHashBody) ,gcbHash) != 0)
            {
                WrongScript = TRUE;
            }
            if (WrongScript) 
            {
                //
                // Inform the user that the script on this server is not vaild.
                //
                ((CDc*)(pAsync->UserInfo))->CallFailed();
                (((CDc*)(pAsync->UserInfo)))->m_RPCVersion = ERROR_DS_INVALID_SCRIPT;
                ((CDc*)(pAsync->UserInfo))->SetLastErrorMsg(L"DC has an incorrect Script");
                ((CDc*)(pAsync->UserInfo))->SetLastError(ERROR_DS_UNWILLING_TO_PERFORM);
                wprintf(L"%ws has incorrect Script : %d\r\n",
                    ((CDc*)(pAsync->UserInfo))->GetName(),
                    ((CDc*)(pAsync->UserInfo))->GetLastError());
                return;
            }

            //
            // Record the password given to us in the dclist file so that 
            // the execute RPC can be called later.
            //
            ((CDc*)(pAsync->UserInfo))->SetPassword(((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pbPassword,
                                                    ((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.cbPassword);
        }
    }

    //
    // If the Async RPC Call failed record the Error code and the error string (if any) so that it
    // will be written out to the dclist file later.
    //
    if (0 != ((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.dwOperationStatus) {
        (((CDc*)(pAsync->UserInfo))->m_RPCReturn) = ((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.dwOperationStatus;
        ((CDc*)(pAsync->UserInfo))->SetLastErrorMsg(((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
    }


    if ( 0 == ((CDc*)(pAsync->UserInfo))->m_RPCReturn ) 
    {
        //
        // The RPC call succeeded. Update the state for the machine to Prepared.
        //
        ((CDc*)(pAsync->UserInfo))->CallSucceeded();
        ((CDc*)(pAsync->UserInfo))->SetState(DC_STATE_PREPARED);
        ((CDc*)(pAsync->UserInfo))->SetLastError(ERROR_SUCCESS);
        wprintf(L"%ws was prepared successfully\r\n",
                ((CDc*)(pAsync->UserInfo))->GetName());
    } else {
        ((CDc*)(pAsync->UserInfo))->SetLastError(((CDc*)(pAsync->UserInfo))->m_RPCReturn);
        if (30001 == ((CDc*)(pAsync->UserInfo))->m_RPCReturn) 
        {
            //
            // 30001 is returned if the action has already been preformed.  
            // update the state to Done.
            //
            ((CDc*)(pAsync->UserInfo))->SetState(DC_STATE_DONE);
        } else  
        {
            //
            // Update the State to initial
            //
            ((CDc*)(pAsync->UserInfo))->CallFailed();
            ((CDc*)(pAsync->UserInfo))->SetState(DC_STATE_INITIAL);
        }

        if ( !rpcFailed && 
             ((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage) {
            //
            // Failed to prepare a server.  Print out that information on to the command line
            //
            wprintf(L"Failed to prepare %ws : %d\r\n%ws\r\n",
                    ((CDc*)(pAsync->UserInfo))->GetName(),
                    ((CDc*)(pAsync->UserInfo))->m_RPCReturn,
                    ((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
        } else {
            wprintf(L"Failed to prepare %ws : %d\r\n",
                    ((CDc*)(pAsync->UserInfo))->GetName(),
                    ((CDc*)(pAsync->UserInfo))->m_RPCReturn);
        }
    }

    if (!rpcFailed) {
        if (((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage ) {
            free (((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
            ((DSA_MSG_PREPARE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage = NULL;
        }
    }

    memset(&gpreparereply[((CDc*)(pAsync->UserInfo))->m_CallIndex],0,sizeof(gpreparereply[((CDc*)(pAsync->UserInfo))->m_CallIndex]));

    //
    // Make a RPC call to the next server (if any) 
    //
    ((CDc*)(pAsync->UserInfo))->MakeRPCCall(((CDc*)(pAsync->UserInfo))->m_CallIndex,
                                            CDcList::ePrepare,
                                            TRUE);
    
}

VOID ExecuteScriptCallback(struct _RPC_ASYNC_STATE *pAsync,
                           void *Context,
                           RPC_ASYNC_EVENT Event)
{
    RPC_STATUS      rpcStatus  = RPC_S_OK;
    
    //
    // Increment the number of calls that have returned.
    //
    InterlockedIncrement(&gCallsReturned);

    RpcTryExcept 
    {
        //
        // Get the results as of the Async RPC call
        //
        rpcStatus =  RpcAsyncCompleteCall(pAsync,
                                          &(((CDc*)(pAsync->UserInfo))->m_RPCReturn)
                                          );

    }
    RpcExcept( I_RpcExceptionFilter( RpcExceptionCode() ) )
    {
        ((CDc*)(pAsync->UserInfo))->m_RPCReturn = RpcExceptionCode();
    }
    RpcEndExcept;

    if (0 != rpcStatus) {
        ((CDc*)(pAsync->UserInfo))->m_RPCReturn = rpcStatus;
    } 

    

    if ( 0 == (((CDc*)(pAsync->UserInfo)))->m_RPCReturn ) {
        if ( 1 != (((CDc*)(pAsync->UserInfo)))->m_RPCVersion ) {
            //
            // The RPC version is not the expected one.
            //
            (((CDc*)(pAsync->UserInfo)))->m_RPCReturn = RPC_S_INTERNAL_ERROR;
            (((CDc*)(pAsync->UserInfo)))->SetFatalErrorMsg(L"Incorrect RPC version %d, expected 1");
        } else {
            ((CDc*)(pAsync->UserInfo))->m_RPCReturn = ((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.dwOperationStatus;
            ((CDc*)(pAsync->UserInfo))->SetLastErrorMsg(((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
        }
    }


    if ( 0 == ((CDc*)(pAsync->UserInfo))->m_RPCReturn ) 
    {
        //
        // The Async RPC call succeeded.  Update the state to Done.
        //
        ((CDc*)(pAsync->UserInfo))->CallSucceeded();
        ((CDc*)(pAsync->UserInfo))->SetState(DC_STATE_DONE);
        ((CDc*)(pAsync->UserInfo))->SetLastError(ERROR_SUCCESS);
        wprintf(L"The script was executed successfully on %ws\r\n",
                ((CDc*)(pAsync->UserInfo))->GetName());
    } else {
        ((CDc*)(pAsync->UserInfo))->SetLastError(((CDc*)(pAsync->UserInfo))->m_RPCReturn);
        if (30001 == ((CDc*)(pAsync->UserInfo))->m_RPCReturn) 
        {
            //
            // 30001 is returned if the action has already been preformed.  
            // update the state to Done.
            //
            ((CDc*)(pAsync->UserInfo))->SetState(DC_STATE_DONE);
        } else if (30000 <= ((CDc*)(pAsync->UserInfo))->m_RPCReturn) 
        {
            //
            // Error code return greater or equal to 30000 are error in script execution.
            // Update the State to initial
            //
            ((CDc*)(pAsync->UserInfo))->CallFailed();
            ((CDc*)(pAsync->UserInfo))->SetState(DC_STATE_INITIAL);
        } else {
            //
            // A non script error has ocurred.  Update the state to Error
            //
            ((CDc*)(pAsync->UserInfo))->CallFailed();
            ((CDc*)(pAsync->UserInfo))->SetState(DC_STATE_ERROR);
        }
        if (((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage) {
            ((CDc*)(pAsync->UserInfo))->SetLastErrorMsg(((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
            //
            // Failed to execute a server.  Print out that information on to the command line
            //
            wprintf(L"Failed to execute script on %ws : %d\r\n%ws\r\n",
                    ((CDc*)(pAsync->UserInfo))->GetName(),
                    ((CDc*)(pAsync->UserInfo))->m_RPCReturn,
                    ((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
        } else {
            wprintf(L"Failed to execute script on %ws : %d\r\n",
                    ((CDc*)(pAsync->UserInfo))->GetName(),
                    ((CDc*)(pAsync->UserInfo))->m_RPCReturn);
        }
    }

    if (((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage ) {
        free (((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage);
        ((DSA_MSG_EXECUTE_SCRIPT_REPLY*)(((CDc*)(pAsync->UserInfo))->m_Data))->V1.pwErrMessage = NULL;
    }

    memset(&gexecutereply[((CDc*)(pAsync->UserInfo))->m_CallIndex],0,sizeof(gexecutereply[((CDc*)(pAsync->UserInfo))->m_CallIndex]));

    //
    // Make a RPC call to the next server (if any) 
    //
    ((CDc*)(pAsync->UserInfo))->MakeRPCCall(((CDc*)(pAsync->UserInfo))->m_CallIndex,
                                            CDcList::eExecute,
                                            TRUE);
}

#undef DSAOP_API
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\util\dns.cxx ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dns.cxx

ABSTRACT:

    This is the implementation of the dns testing functionality of rendom.cxx.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "rendom.h"

#include "dnslib.h"


BOOL
Dns_Ip6StringToAddress_W(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCWSTR          pwString
    )
{
    return TRUE;
}

PWCHAR
Dns_Ip6AddressToString_W(
    OUT     PWCHAR          pwString,
    IN      PIP6_ADDRESS    pIp6Addr
    )
{
    return pwString;
}

WCHAR *a =  L"Yes";

DNS_STATUS
Dns_WriteRecordToString(
    OUT     PCHAR           pBuffer,
    IN      DWORD           BufferLength,
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSet,
    IN      DWORD           Flags
    )
{
    pBuffer = (PCHAR)a;
    return 0;
}

DNS_STATUS
Dns_VerifyRendomDcRecords(
    IN OUT  PDNS_RENDOM_ENTRY       pTable,
    IN      PDNS_ZONE_SERVER_LIST   pZoneServList,  OPTIONAL
    IN      DWORD                   Flag
    )
{
    while (pTable->pRecord) {
        pTable->pVerifyArray = new BOOL[2];
        pTable->pVerifyArray[0] = TRUE;
    }
    return 0;
}

PDNS_RECORD
Dns_CreateRecordFromString(
    IN      PSTR            pString,
    IN      DNS_CHARSET     CharSet,
    IN      DWORD           Flags
    )
{
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\util\ldap.cxx ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldap.cxx

ABSTRACT:

    This is the implementation of ldap functionality for rendom.exe.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include "rendom.h"                                     
#include <wchar.h>
#include <sddl.h>
#include <lmcons.h>
#include <lmerr.h>
#include <Dsgetdc.h>
#include <Lmapibuf.h>
#include <ntldap.h>
extern "C"
{
#include <mappings.h>
}
#include <ntlsa.h>
#include <ntdsadef.h>
#include <list>

#include "renutil.h"
#include "filter.h"

BOOL CEnterprise::LdapGetGuid(WCHAR *LdapValue,
                              WCHAR **Guid)
{
    ASSERT(LdapValue);
    ASSERT(Guid);

    BOOL  ret = TRUE;
    WCHAR *p = NULL;
    WCHAR *Uuid = NULL;
    DWORD size = 0;
    DWORD i = 0;
    PBYTE buf = NULL;
    RPC_STATUS err = RPC_S_OK;

    *Guid = NULL;

    p = wcsstr(LdapValue, L"<GUID=");
    if (!p) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                       L"The String passed into LdapGetGuid is in an invalid format");
        ret = FALSE;
        goto Cleanup;
    }
    p+=wcslen(L"<GUID=");
    while ( ((L'>' != *(p+size)) && (L'\0' != *(p+size))) && (size < RENDOM_BUFFERSIZE) ) 
    {
        size++;
    }
    
    ASSERT(size%2 == 0);
    
    buf = new BYTE[size+1];
    if (!buf) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    // convert the string into byte form so that we
    // can pass a binary to UuidToStringW() so that we
    // can have a properly formated GUID string.
    for (i = 0; i<size/2; i++) {
        WCHAR *a = NULL;
        WCHAR bytestr[] = { *p, *(p+1), L'\0' };
        
        buf[i] = (BYTE)wcstol( bytestr, &a, 16 );

        p+=2;
    }

    err = UuidToStringW(((UUID*)buf),&Uuid);
    if (RPC_S_OK != err) {
        m_Error.SetErr(err,
                        L"Failed to convert Guid to string");
        ret = FALSE;
        goto Cleanup;
    }

    // the +5 is for 4 L'-' and one L'\0'
    *Guid = new WCHAR[size+5];
    if (!Guid) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    // We don't want to return a Buffer that was allocated
    // by anything other than new.  It becomes too difficult
    // to track what the proper free for it is.
    CopyMemory(*Guid,Uuid,(size+5)*sizeof(WCHAR));

    Cleanup:

    if (buf) {
        delete [] buf;
    }

    err = RpcStringFreeW(&Uuid);
    if (RPC_S_OK != err) {
        m_Error.SetErr(err,
                        L"Failed to Free Guid String");
        ret = FALSE;
    }
    if (FALSE == ret) {
        if (*Guid) {
            delete [] *Guid;
        }
    }
    
    return ret;
}

BOOL CEnterprise::LdapGetSid(WCHAR *LdapValue,
                             WCHAR **rSid)
{
    ASSERT(LdapValue);
    ASSERT(rSid);
    WCHAR *p = NULL;
    BOOL  ret = TRUE;
    DWORD size = 0;
    WCHAR *Sid = NULL;
    DWORD i = 0;
    PBYTE buf = NULL;
    DWORD err = ERROR_SUCCESS;

    p = wcsstr(LdapValue, L"<SID=");
    if (!p) {
        return TRUE;
    }

    *rSid = NULL;

    p+=wcslen(L"<SID=");
    while ( ((L'>' != *(p+size)) && (L'\0' != *(p+size))) && (size < RENDOM_BUFFERSIZE) ) 
    {
        size++;
    }
    
    buf = new BYTE[size+1];
    if (!buf) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }

    for (i = 0; i<size/2; i++) {
        WCHAR *a = NULL;
        WCHAR bytestr[] = { *p, *(p+1), L'\0'};
        
        buf[i] = (BYTE)wcstol( bytestr, &a, 16 );

        p+=2;
    }
        
    
    if (! ConvertSidToStringSidW((PSID)buf,
                                 &Sid))
    {
        m_Error.SetErr(GetLastError(),
                        L"Failed to convert Sid to Sid String");
        ret = FALSE;
        goto Cleanup;
    }

    *rSid = new WCHAR[wcslen(Sid)+1];
    if (!*rSid) {
        m_Error.SetMemErr();
        ret = FALSE;
        goto Cleanup;
    }


    wcscpy(*rSid,Sid);

    Cleanup:

    if (buf) 
    {
        delete [] buf;
    }
    
    if (LocalFree(Sid))
    {
        m_Error.SetErr(GetLastError(),
                        L"Failed to Free resource");
        ret = FALSE;
        return NULL;
    }

    if (FALSE == ret) {
        if (*rSid) {
            delete [] rSid;
        }
    }

    return ret;
}

BOOL CEnterprise::LdapGetDN(WCHAR *LdapValue,
                            WCHAR **DN)
{
    ASSERT(LdapValue);
    ASSERT(DN);
    WCHAR *p = NULL;
    DWORD size = 0;

    p = wcschr(LdapValue, L';');
    if (!p) {
        return NULL;
    } else if ( L'<' == *(p+1) ) {
        p = wcschr(p+1, L';');
        if (!p) {                                             
            return NULL;
        } 
    }

    // move to the char passed the L';'
    p++;
    while ( ((L';' != *(p+size)) && (L'\0' != *(p+size))) && (size < RENDOM_BUFFERSIZE) ) 
    {
        size++;
    }
    *DN = new WCHAR[size+1];
    if (!*DN) {
        m_Error.SetMemErr();
        return FALSE;
    }
    wcsncpy(*DN,p,size+1);

    return TRUE;
}

BOOL CEnterprise::LdapCheckGCAvailability()
{
    DWORD Win32Err = ERROR_SUCCESS;

    BOOL result = TRUE;

    WCHAR *ConnectTo = NULL;
    PDOMAIN_CONTROLLER_INFOW DomainControllerInfo = NULL;
    DWORD getDCflags = DS_DIRECTORY_SERVICE_REQUIRED | 
                       DS_RETURN_DNS_NAME            |
                       DS_GC_SERVER_REQUIRED;

    Win32Err =  DsGetDcNameW(NULL,
                             m_ForestRoot->GetPrevDnsRoot(FALSE),
                             NULL,
                             NULL,
                             getDCflags,
                             &DomainControllerInfo
                             );
    if (ERROR_SUCCESS != Win32Err) {
        m_Error.SetErr(Win32Err,
                       L"Couldn't find a GC for the enterprise.  Please ensure that there is a contactable GC in the forest and try again.");
        
        goto Cleanup;
    }

    ConnectTo = *DomainControllerInfo->DomainControllerName==L'\\'
                      ?(DomainControllerInfo->DomainControllerName)+2:DomainControllerInfo->DomainControllerName;

    result = LdapConnectandBindToServer(ConnectTo);
    
    if (!result) {

        //Clear the error that was set by LdapConnectandBindToServer
        //since we are going to try again with a different server
        m_Error.ClearErr();

        if (DomainControllerInfo) {
            NetApiBufferFree(DomainControllerInfo);
            DomainControllerInfo = NULL;
        }

        getDCflags |= DS_FORCE_REDISCOVERY;

        Win32Err =  DsGetDcNameW(NULL,
                                 m_ForestRoot->GetDnsRoot(FALSE),
                                 NULL,
                                 NULL,
                                 getDCflags,
                                 &DomainControllerInfo
                                 );
        if (ERROR_SUCCESS != Win32Err) {
            m_Error.SetErr(Win32Err,
                           L"Couldn't find a GC for the enterprise.  Please ensure that there is a contactable GC in the forest and try again.");
            
            goto Cleanup;
        }

        ConnectTo = *DomainControllerInfo->DomainControllerName==L'\\'
                      ?(DomainControllerInfo->DomainControllerName)+2:DomainControllerInfo->DomainControllerName;

        result = LdapConnectandBindToServer(ConnectTo);
        if (!result) {

            m_Error.AppendErr(L"Failed to Bind to a GC.  Please ensure that there is a contactable GC in the forest and try again.");  
            goto Cleanup;

        }

    }

    Cleanup:

    if (DomainControllerInfo) {
        NetApiBufferFree(DomainControllerInfo);
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;

}

BOOL CEnterprise::LdapConnectandBind(CDomain *domain) // = NULL
{
    DWORD Win32Err = ERROR_SUCCESS;
    NET_API_STATUS NetapiStatus = NERR_Success;
    ULONG ldapErr = LDAP_SUCCESS;
    PDOMAIN_CONTROLLER_INFOW DomainControllerInfo = NULL;
    WCHAR *ConnectTo = NULL;
    DWORD getDCflags = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME;
    BOOL result = TRUE;
    
    if (m_hldap) {
        ldapErr = ldap_unbind(m_hldap);
        m_hldap = NULL;

        // NOTE:Log Errors to a log file

        /*if ( LDAP_SUCCESS != ldapErr) {
            m_Error.SetErr(LdapMapErrorToWin32(ldapErr),
                            L"Failed to close the old Ldap session");
            //print the extented error as wel;
            PWCHAR pErrorString;
            ldap_get_option(m_hldap, LDAP_OPT_SERVER_ERROR, (void*) &pErrorString);
            
            m_Error.AppendErr(pErrorString);

            ldap_memfree(pErrorString);

            return FALSE;
        } */
    }

    if (!domain) 
    {
        ConnectTo = m_Opts->GetInitalConnectionName();
    }

    if (domain) 
    {
        ConnectTo = domain->GetDcToUse(FALSE);
    }

    if (!ConnectTo) {
        Win32Err =  DsGetDcNameW(NULL,
                                 domain?domain->GetDnsRoot(FALSE):NULL,
                                 NULL,
                                 NULL,
                                 getDCflags,
                                 &DomainControllerInfo
                                 );
        if (ERROR_SUCCESS != Win32Err) {
            if (!domain) {
                m_Error.SetErr(Win32Err,
                               L"Couldn't Find a DC for the current Domain");
            } else {
                m_Error.SetErr(Win32Err,
                               L"Couldn't Find a DC for the Domain %s",
                               domain->GetDnsRoot(FALSE));
            }
    
            goto Cleanup;
        }

        ConnectTo = *DomainControllerInfo->DomainControllerName==L'\\'
                      ?(DomainControllerInfo->DomainControllerName)+2:DomainControllerInfo->DomainControllerName;
    }

    ASSERT(ConnectTo != NULL);
    result = LdapConnectandBindToServer(ConnectTo);
    //If we failed to Connect then retry with another DC unless
    //There was a specific DC specified.
    if ( !result && !(domain && domain->GetDcToUse(FALSE)) &&
         !(!domain && m_Opts->GetInitalConnectionName()) ) 
    {
        if (DomainControllerInfo) {
            NetApiBufferFree(DomainControllerInfo);
            DomainControllerInfo = NULL;
        }
        getDCflags |= DS_FORCE_REDISCOVERY;
        Win32Err =  DsGetDcNameW(NULL,
                                 domain?domain->GetDnsRoot(FALSE):NULL,
                                 NULL,
                                 NULL,
                                 getDCflags,
                                 &DomainControllerInfo
                                 );
        if (ERROR_SUCCESS != Win32Err) {
            if (!domain) {
                m_Error.SetErr(Win32Err,
                               L"Couldn't Find a DC for the current Domain");
            } else {
                m_Error.SetErr(Win32Err,
                               L"Couldn't Find a DC for the Domain %s",
                               domain->GetDnsRoot(FALSE));
            }
    
            goto Cleanup;
        }

        ConnectTo = *DomainControllerInfo->DomainControllerName==L'\\'
                      ?(DomainControllerInfo->DomainControllerName)+2:DomainControllerInfo->DomainControllerName;

        result = LdapConnectandBindToServer(ConnectTo);
        if (!result) 
        {
            goto Cleanup;
        }
        
    }

    Cleanup:

    if (DomainControllerInfo) {
        NetApiBufferFree(DomainControllerInfo);
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CEnterprise::GetReplicationEpoch()
{
    if (!m_hldap) 
    {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                       L"Call to GetReplicationEpoch without having a valid handle to an ldap server");
        return false;
    }

    DWORD WinError = ERROR_SUCCESS;

    ULONG         LdapError = LDAP_SUCCESS;

    LDAPMessage   *SearchResult = NULL;
    ULONG         NumberOfEntries;

    WCHAR         *Attr = NULL;
    BerElement    *pBerElement = NULL;

    WCHAR         *AttrsToSearch[4];

    WCHAR         *BaseTemplate = L"CN=NTDS Settings,%s";

    WCHAR         *Base = NULL;
    
    ULONG         Length;
    WCHAR         **Values = NULL;

    AttrsToSearch[0] = L"serverName";
    AttrsToSearch[1] = NULL;

    // Get the ReplicationEpoch from the NC head.
    LdapError = ldap_search_sW( m_hldap,
                                NULL,
                                LDAP_SCOPE_BASE,
                                LDAP_FILTER_DEFAULT,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {
        m_Error.SetLdapErr(m_hldap,
                           LdapError,
                           L"Search to find Trusted Domain Objects Failed on %ws",
                           GetDcUsed(FALSE));
        
        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries(m_hldap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(m_hldap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement) )
            {                                 
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {
    
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Base = new WCHAR[wcslen(Values[0])+
                                         wcslen(BaseTemplate)+1];
                        if (!Base) {
                            m_Error.SetMemErr();
                            goto Cleanup;
                        }

                        wsprintf(Base,
                                 BaseTemplate,
                                 Values[0]);
                        
                        LdapError = ldap_value_freeW(Values);
                        Values = NULL;
                        if (LDAP_SUCCESS != LdapError) 
                        {
                            m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                            L"Failed to Free values from a ldap search");
                            goto Cleanup;
                        }
                    }

                }
                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
            }
            
            
        }
        
    }
    if (Values) {
        ldap_value_freeW(Values);
        Values = NULL;    
    }

    ldap_msgfree(SearchResult);
    SearchResult = NULL;

    AttrsToSearch[0] = L"msDS-ReplicationEpoch";
    AttrsToSearch[1] = NULL;

    // Get the ReplicationEpoch from the NC head.
    LdapError = ldap_search_sW( m_hldap,
                                Base,
                                LDAP_SCOPE_BASE,
                                LDAP_FILTER_DEFAULT,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {
        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,                                         
                           L"Search to find Trusted Domain Objects Failed on %ws",
                           GetDcUsed(FALSE));  
        
        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries(m_hldap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(m_hldap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement) )
            {                                 
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {
    
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        DWORD temp = 0;
                        temp = _wtoi(Values[0]);
                        if (temp > m_maxReplicationEpoch) {
                            m_maxReplicationEpoch = temp;
                        }
                        
                        LdapError = ldap_value_freeW(Values);
                        Values = NULL;
                        if (LDAP_SUCCESS != LdapError) 
                        {
                            m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                            L"Failed to Free values from a ldap search");
                            goto Cleanup;
                        }
                    }

                }
                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
            }
            
            
        }
        
    }

    Cleanup:

    if (Values) 
    {
        ldap_value_freeW(Values);
        Values = NULL;
    }
    if (SearchResult) 
    {
        ldap_msgfree(SearchResult);    
        SearchResult = NULL;
    }
    if (Base) {
        delete [] Base;
    }

    if (m_Error.isError()) {
        return FALSE;
    }
    return TRUE;

}

BOOL CEnterprise::GetInfoFromRootDSE()
{
    if (!m_hldap) 
    {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Call to GetInfoFromRootDSE without having a valid handle to an ldap server");
        return false;
    }

    DWORD WinError = ERROR_SUCCESS;

    ULONG         LdapError = LDAP_SUCCESS;

    LDAPMessage   *SearchResult = NULL;
    PLDAPControlW ServerControls[2];
    LDAPControlW  ExtDNcontrol;
    ULONG         NumberOfEntries;

    WCHAR         *Attr = NULL;
    BerElement    *pBerElement = NULL;

    WCHAR         *AttrsToSearch[4];

    BOOL          AttsFound[3] = { FALSE, FALSE, FALSE };

    ULONG         Length;
    WCHAR         **Values = NULL;

    WCHAR         *Guid = NULL;
    WCHAR         *DN = NULL;
    WCHAR         *Sid = NULL;

    
    AttrsToSearch[0] = L"configurationNamingContext";
    AttrsToSearch[1] = L"rootDomainNamingContext";
    AttrsToSearch[2] = L"schemaNamingContext";
    AttrsToSearch[3] = NULL;

    // Set up the extended DN control.
    ExtDNcontrol.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    ExtDNcontrol.ldctl_iscritical = TRUE;
    ExtDNcontrol.ldctl_value.bv_len = 0;
    ExtDNcontrol.ldctl_value.bv_val = NULL;
    ServerControls[0] = &ExtDNcontrol;
    ServerControls[1] = NULL;


    LdapError = ldap_search_ext_sW( m_hldap,
                                    NULL,
                                    LDAP_SCOPE_BASE,
                                    LDAP_FILTER_DEFAULT,
                                    AttrsToSearch,
                                    FALSE,
                                    (PLDAPControlW *)&ServerControls,
                                    NULL,
                                    NULL,
                                    0,
                                    &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {
        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,                                         
                           L"Search to find Configuration container failed on %ws",
                           GetDcUsed(FALSE));  
        
        goto Cleanup;
    }
    
    NumberOfEntries = ldap_count_entries(m_hldap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(m_hldap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    AttsFound[0] = TRUE;
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        if (!LdapGetGuid(Values[0],
                                         &Guid)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetDN(Values[0],
                                       &DN)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetSid(Values[0],
                                        &Sid)) 
                        {
                            goto Cleanup;
                        }
                        
                        m_ConfigNC = new CDsName(Guid,
                                                 DN,
                                                 Sid);
                        if (!m_ConfigNC) {
                            m_Error.SetMemErr();
                            goto Cleanup;
                        }

                        Guid = DN = Sid = NULL;
                    }
                }

                if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                {
                    AttsFound[1] = TRUE;
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        if (!LdapGetGuid(Values[0],
                                         &Guid)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetDN(Values[0],
                                       &DN)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetSid(Values[0],
                                        &Sid)) 
                        {
                            goto Cleanup;
                        }
                        
                        m_ForestRootNC = new CDsName(Guid,
                                                     DN,
                                                     Sid);
                        if (!m_ForestRootNC) {
                            m_Error.SetMemErr();
                            goto Cleanup;
                        }

                        Guid = DN = Sid = NULL;   
                    }
                }
                if ( !_wcsicmp( Attr, AttrsToSearch[2] ) )
                {
                    AttsFound[2] = TRUE;
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        if (!LdapGetGuid(Values[0],
                                         &Guid)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetDN(Values[0],
                                       &DN)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetSid(Values[0],
                                        &Sid)) 
                        {
                            goto Cleanup;
                        }
                        
                        m_SchemaNC = new CDsName(Guid,
                                                 DN,
                                                 Sid);
                        if (!m_SchemaNC) {
                            m_Error.SetMemErr();
                            goto Cleanup;
                        }

                        Guid = DN = Sid = NULL;   
                    }
                }

                LdapError =  ldap_value_freeW(Values);
                Values = NULL;
                if (LDAP_SUCCESS != LdapError) 
                {
                    m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                    L"Failed to Free Values\n");
                    goto Cleanup;
                }

                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
            }
        }
    }

    //Fail is any of the attributes were not found.
    for (DWORD i = 0; i < NELEMENTS(AttsFound); i++) {
        if (!AttsFound[i]) {
            if (!m_Error.isError()) {
                m_Error.SetErr(ERROR_DS_ATT_IS_NOT_ON_OBJ,
                               L"Failed to find %ws on the RootDSE\n",
                               AttrsToSearch[i]);
            } else {
                m_Error.AppendErr(L"Failed to find %ws on the RootDSE\n",
                                    AttrsToSearch[i]);
            }
        }
    }
    if (m_Error.isError()) {
        goto Cleanup;
    }
    
    Cleanup:


    if (Attr) {
        ldap_memfree(Attr);
    }
    if (Values) {
        ldap_value_freeW(Values);
    }
    if (Guid) 
    {
        delete [] Guid;
    }
    if (Sid) 
    {
        delete [] Sid;
    }
    if (DN) 
    {
        delete [] DN;
    }
    if (SearchResult) {
        ldap_msgfree( SearchResult );
        SearchResult = NULL;
    }
    if ( m_Error.isError() ) 
    {
        return false;
    }
    return true;




}

BOOL CEnterprise::GetSpnInfo(CDomain *d)
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG         LdapError = LDAP_SUCCESS;

    LDAPMessage   *SearchResult = NULL;
    LDAPMessage   *SearchResult2 = NULL;
    PLDAPSearch   SearchHandle = NULL;
    ULONG         NumberOfEntries;
    WCHAR         *Attr = NULL;
    BerElement    *pBerElement = NULL;

    WCHAR         *AttrsToSearch[2];
    WCHAR         *AttrsToSearch2[3];

    WCHAR         *SitesRdn = L"CN=Sites,";

    ULONG         Length;

    WCHAR         *SitesDn = NULL;
    WCHAR         **Values = NULL;

    WCHAR         **ExplodedDN = NULL;
    
    WCHAR         *ServerDN    = NULL;
    WCHAR         *DNSname     = NULL;
    WCHAR         *NtdsGuid    = NULL;
    WCHAR         *ServerMachineAccountDN = NULL;
    WCHAR         *Filter      = NULL;
    PLDAPControlW ServerControls[2];
    LDAPControlW  ExtDNcontrol;

    WCHAR         *ConfigurationDN = m_ConfigNC->GetDN(FALSE);

    ASSERT(ConfigurationDN);

    // Set up the extended DN control.
    ExtDNcontrol.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    ExtDNcontrol.ldctl_iscritical = TRUE;
    ExtDNcontrol.ldctl_value.bv_len = 0;
    ExtDNcontrol.ldctl_value.bv_val = NULL;
    ServerControls[0] = &ExtDNcontrol;
    ServerControls[1] = NULL;

    AttrsToSearch[0] = L"distinguishedName";
    AttrsToSearch[1] = NULL;

     // next ldap search will require this attribute
    AttrsToSearch2[0] = L"dNSHostName";
    AttrsToSearch2[1] = L"serverReference";
    AttrsToSearch2[2] = NULL;


    Length =  (wcslen( ConfigurationDN )
            + wcslen( SitesRdn )   
            + 1);

    SitesDn = new WCHAR[Length];
    if (!SitesDn) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    wcscpy( SitesDn, SitesRdn );
    wcscat( SitesDn, ConfigurationDN );

    // NTRAID#NTBUG9-582921-2002/03/21-Brettsh - When we no longer require Win2k (or 
    // .NET Beta3) compatibility then we can move this to ATT_MS_DS_HAS_MASTER_NCS.
    Filter = new WCHAR[wcslen(L"(&(objectCategory=nTDSDSA)(hasMasterNCs=))")+wcslen(d->GetDomainDnsObject()->GetDN(FALSE))+1]; // deprecated, bug OK because looking for domain
    if (!Filter) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    //build the filter to be used in the search.
    wcscpy(Filter,L"(&(objectCategory=nTDSDSA)(hasMasterNCs=");   // deprecated, bug OK because looking for domain

    wcscat(Filter,d->GetDomainDnsObject()->GetDN(FALSE));
    wcscat(Filter,L"))");

    SearchHandle =  ldap_search_init_page( m_hldap,
                                           SitesDn,
                                           LDAP_SCOPE_SUBTREE,
                                           Filter,
                                           AttrsToSearch,
                                           FALSE,
                                           (PLDAPControlW *)&ServerControls,
                                           NULL,
                                           0,
                                           0,
                                           NULL);

    if ( !SearchHandle )
    {
        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,                                         
                           L"Search to find Trusted Domain Objects Failed on %ws",
                           GetDcUsed(FALSE));  

        goto Cleanup;
    }

    while(LDAP_SUCCESS == (LdapError = ldap_get_next_page_s( m_hldap,
                                                             SearchHandle,
                                                             NULL,
                                                             200,
                                                             NULL,
                                                             &SearchResult)))
    {

   
        NumberOfEntries = ldap_count_entries( m_hldap, SearchResult );
        if ( NumberOfEntries > 0 )
        {
            LDAPMessage *Entry;
            
            for ( Entry = ldap_first_entry(m_hldap, SearchResult);
                      Entry != NULL;
                          Entry = ldap_next_entry(m_hldap, Entry))
            {
                for( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                      Attr != NULL;
                          Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement))
                {
                    if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                    {
    
                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //

                            WCHAR *DN = NULL;
                                
                            if (!LdapGetDN(Values[0],
                                           &DN))
                            {
                                goto Cleanup;
                            }

                            if (!LdapGetGuid(Values[0],
                                             &NtdsGuid))
                            {
                                goto Cleanup;
                            }

                            ExplodedDN = ldap_explode_dn(DN,
                                                         FALSE );
                            if (!ExplodedDN) {
                                m_Error.SetMemErr();
                                goto Cleanup;
                            }

                            if (DN) {
                                delete [] DN;
                            }
    
                            DWORD i = 1;
                            DWORD allocSize = 0;
                            while (ExplodedDN[i]) {
                                allocSize += wcslen(ExplodedDN[i++])+1;
                            }
                            
                            // +2 for a short period of time a extra charater will be required
                            ServerDN = new WCHAR[allocSize+2];
                            if (!ServerDN) {
                                m_Error.SetMemErr();
                                goto Cleanup;    
                            }
    
                            i = 1;
                            *ServerDN = 0;
                            while (ExplodedDN[i]) {
                                wcscat(ServerDN,ExplodedDN[i++]);
                                wcscat(ServerDN,L",");
                            }
                            ServerDN[allocSize-1] = 0;
    
                            LdapError = ldap_value_free(ExplodedDN);
                            ExplodedDN = NULL;
                            if (LDAP_SUCCESS != LdapError) 
                            {
                                m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                                L"Failed to Free values from a ldap search");
                                goto Cleanup;
                            }
    
                            LDAPMessage   *Entry2;
                            BerElement    *pBerElement2 = NULL;
                            WCHAR         **Values2 = NULL;
    
                            LdapError = ldap_search_sW( m_hldap,
                                                        ServerDN,
                                                        LDAP_SCOPE_BASE,
                                                        LDAP_FILTER_DEFAULT,
                                                        AttrsToSearch2,
                                                        FALSE,
                                                        &SearchResult2);
        
                            if ( LDAP_SUCCESS != LdapError )
                            {
                                
                                m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                                L"Search to find Configuration container failed");
                                goto Cleanup;
                            }
    
                            Entry2 = ldap_first_entry(m_hldap, SearchResult2);
                            Values2 = ldap_get_valuesW( m_hldap, Entry2, AttrsToSearch2[0] );
    
                            if (Values2 && *Values2) {
                            
                                DNSname = new WCHAR[wcslen(*Values2)+1];
                                if (!DNSname) {
                                    m_Error.SetMemErr();
                                }
        
                                wcscpy(DNSname,*Values2);
        
                                LdapError = ldap_value_freeW(Values2);
                                Values2 = NULL;
        
                                if (m_Error.isError()) {
                                    goto Cleanup;
                                }
    
                            } else {
    
                                m_Error.SetErr(ERROR_DS_NO_ATTRIBUTE_OR_VALUE,
                                               L"A dnshost name for %ws could not be found",
                                               ServerDN);
    
                            }

                            Values2 = ldap_get_valuesW( m_hldap, Entry2, AttrsToSearch2[1] );
    
                            if (Values2 && *Values2) {
                            
                                ServerMachineAccountDN = new WCHAR[wcslen(*Values2)+1];
                                if (!ServerMachineAccountDN) {
                                    m_Error.SetMemErr();
                                }
        
                                wcscpy(ServerMachineAccountDN,*Values2);
        
                                LdapError = ldap_value_freeW(Values2);
                                Values2 = NULL;
        
                                if (m_Error.isError()) {
                                    goto Cleanup;
                                }
    
                            } else {
    
                                m_Error.SetErr(ERROR_DS_NO_ATTRIBUTE_OR_VALUE,
                                               L"A serverReference for %ws could not be found",
                                               ServerDN);
    
                            }
                                
                        }
    
                    }

                    if ( SearchResult2 )
                    {
                        ldap_msgfree( SearchResult2 );
                        SearchResult2 = NULL;
                    }
                    
                    LdapError = ldap_value_freeW(Values);
                    Values = NULL;
                    if (LDAP_SUCCESS != LdapError) 
                    {
                        m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                        L"Failed to Free values from a ldap search");
                        goto Cleanup;
                    }

                    if (!d->AddDcSpn(new CDcSpn(DNSname,
                                                NtdsGuid,
                                                ServerMachineAccountDN))) 
                    {
                        goto Cleanup;
                    }
                
                }
            }
        }
    }

    if (LdapError != LDAP_SUCCESS && LdapError != LDAP_NO_RESULTS_RETURNED) {

        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,                                         
                           L"Search to find Ntds Settings objects failed on %ws",
                           GetDcUsed(FALSE));

        goto Cleanup;
    }

    Cleanup:

    if (Values) {
        ldap_value_free(Values);
    }
    if (SitesDn) {
        delete [] SitesDn;
    }
    if (ExplodedDN) {
        ldap_value_free(ExplodedDN);
    }
    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }
    if ( SearchResult2 )
    {
        ldap_msgfree( SearchResult2 );
    }
    if ( m_Error.isError() ) 
    {
        return FALSE;
    }
    return TRUE;


}

//This will get the Trust domain object for the specified domain
BOOL CEnterprise::GetTrustsInfoTDO(CDomain *d)
{
    ASSERT(d);
    DWORD WinError = ERROR_SUCCESS;

    ULONG         LdapError = LDAP_SUCCESS;
    
    LDAPMessage   *SearchResult = NULL;
    PLDAPSearch   SearchHandle = NULL;
    PLDAPControlW ServerControls[2];
    LDAPControlW  ExtDNcontrol;
    ULONG         NumberOfEntries;
    WCHAR         *Attr = NULL;
    
    WCHAR         *AttrsToSearch[6];
    BOOL          AttsFound[5] = { FALSE, FALSE, FALSE, FALSE, FALSE };
    
    WCHAR         *SystemRdn = L"CN=System,";
    
    ULONG         Length;
    BerElement    *pBerElement = NULL;
    
    WCHAR         *SystemDn = NULL;
    WCHAR         *DomainDN = NULL;
    WCHAR         **Values = NULL;
    struct berval **ppSid = NULL;
    
    WCHAR         *Guid = NULL;
    WCHAR         *DN = NULL;
    WCHAR         *Sid = NULL;

    WCHAR         *pzSecurityID = NULL;
    CDsName       *Trust = NULL;
    CDsName       *DomainDns = NULL;
    BOOL          RecordTrust = FALSE;
    DWORD         TrustType = 0;
    DWORD         TrustDirection = 0;
    DWORD         TrustCount = 0;
    WCHAR         *DomainDn = NULL;
    WCHAR         *TrustpartnerNetbiosName = NULL;
    CDomain       *Trustpartner = NULL;
    CTrustedDomain *NewTrust = NULL;
    CInterDomainTrust *NewInterTrust = NULL;

    // Set up the extended DN control.
    ExtDNcontrol.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    ExtDNcontrol.ldctl_iscritical = TRUE;
    ExtDNcontrol.ldctl_value.bv_len = 0;
    ExtDNcontrol.ldctl_value.bv_val = NULL;
    ServerControls[0] = &ExtDNcontrol;
    ServerControls[1] = NULL;

    DomainDn = d->GetDomainDnsObject()->GetDN();
    ASSERT(DomainDn);
    if (m_Error.isError()) 
    {
        goto Cleanup;
    }

    //Get Info Dealing with Domain Trust Objects
    AttrsToSearch[0] = L"securityIdentifier";
    AttrsToSearch[1] = L"distinguishedName";
    AttrsToSearch[2] = L"trustType";
    AttrsToSearch[3] = L"trustPartner";
    AttrsToSearch[4] = L"trustDirection";
    AttrsToSearch[5] = NULL;
    
    Length =  (wcslen( DomainDn )
            + wcslen( SystemRdn )   
            + 1);
    
    SystemDn = new WCHAR[Length];
    if (!SystemDn) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    wcscpy( SystemDn, SystemRdn );
    wcscat( SystemDn, DomainDn ); 
    SearchHandle =  ldap_search_init_page( m_hldap,
                                           SystemDn,
                                           LDAP_SCOPE_ONELEVEL,
                                           LDAP_FILTER_TRUSTEDDOMAIN,
                                           AttrsToSearch,
                                           FALSE,
                                           (PLDAPControlW *)&ServerControls,
                                           NULL,
                                           0,
                                           0,
                                           NULL);

    if ( !SearchHandle )
    {
        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,                                         
                           L"Search to find Trusted Domain Objects Failed on %ws",
                           GetDcUsed(FALSE));

        goto Cleanup;
    }

    while(LDAP_SUCCESS == (LdapError = ldap_get_next_page_s( m_hldap,
                                                             SearchHandle,
                                                             NULL,
                                                             200,
                                                             NULL,
                                                             &SearchResult)))
    {
        NumberOfEntries = ldap_count_entries( m_hldap, SearchResult );
        TrustCount += NumberOfEntries;
        if ( NumberOfEntries > 0 )
        {
            LDAPMessage *Entry;
            
            for ( Entry = ldap_first_entry(m_hldap, SearchResult);
                      Entry != NULL;
                          Entry = ldap_next_entry(m_hldap, Entry))
            {
                TrustType = 0;

                for( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                      Attr != NULL;
                          Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement))
                {
                    if ( !_wcsicmp( Attr, AttrsToSearch[2] ) )
                    {
                        AttsFound[2] = TRUE;
                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //
                            TrustType = _wtoi(Values[0]);
                        
                        }
        
                    }
                    if ( !_wcsicmp( Attr, AttrsToSearch[4] ) )
                    {
                        AttsFound[4] = TRUE;
                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //
                            TrustDirection = _wtoi(Values[0]);
                        
                        }
        
                    }
                    if ( !_wcsicmp( Attr, AttrsToSearch[3] ) )
                    {
                        AttsFound[3] = TRUE;
                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //
                            TrustpartnerNetbiosName = new WCHAR[wcslen(Values[0])+1];
                            if (!TrustpartnerNetbiosName) 
                            {
                                m_Error.SetMemErr();
                                goto Cleanup;
                            }
                            wcscpy(TrustpartnerNetbiosName,Values[0]);
                        
                        }
        
                    }

                    if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                    {
                        AttsFound[1] = TRUE;
                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //
                            if (!LdapGetGuid(Values[0],
                                             &Guid)) 
                            {
                                goto Cleanup;
                            }
                            if (!LdapGetDN(Values[0],
                                           &DN)) 
                            {
                                goto Cleanup;
                            }
                            if (!LdapGetSid(Values[0],
                                            &Sid)) 
                            {
                                goto Cleanup;
                            }
        
                            
                            Trust = new CDsName(Guid,
                                                DN,
                                                Sid);
                            if (!Trust) {
                                m_Error.SetMemErr();
                                goto Cleanup;
                            }
        
                            Guid = DN = Sid = NULL; 
        
                        }
        
                    }
                    if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                    {
                        AttsFound[0] = TRUE;
                        ppSid = ldap_get_values_lenW( m_hldap, Entry, Attr );
                        if ( ppSid && ppSid[0] )
                        {
                            //
                            // Found it
                            //
                            
                            if (! ConvertSidToStringSidW((*ppSid)->bv_val,
                                                         &pzSecurityID))
                            {
                                m_Error.SetErr(GetLastError(),
                                                L"Failed to convert Sid to Sid String");
                                LocalFree(pzSecurityID);
                                goto Cleanup;
                            }
                            Trustpartner = m_DomainList->LookupbySid(pzSecurityID);
                            LocalFree(pzSecurityID);
                            
                            if (Trustpartner)
                            {

                                RecordTrust = TRUE;

                            } else {

                                Trustpartner = NULL;

                            } 
                            
                        }
        
                    }
                    
                    if (ppSid) {
                        LdapError = ldap_value_free_len(ppSid);
                        ppSid = NULL;
                        if (LDAP_SUCCESS != LdapError) 
                        {
                            m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                            L"Failed to Free values from a ldap search");
                            goto Cleanup;
                        }
                    }

                    if (Values) {
                        LdapError = ldap_value_freeW(Values);
                        Values = NULL;
                        if (LDAP_SUCCESS != LdapError) 
                        {
                            m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                            L"Failed to Free values from a ldap search");
                            goto Cleanup;
                        }
                    }
                    if (Attr) {
                        ldap_memfree(Attr);
                        Attr = NULL;
                    }
                }

                if ( TRUST_TYPE_DOWNLEVEL == TrustType ) {

                    Trustpartner = m_DomainList->LookupByPrevNetbiosName(TrustpartnerNetbiosName);
                    if (Trustpartner)
                    {

                        RecordTrust = TRUE;

                    } else {

                        Trustpartner = NULL;

                    }

                }

                if (RecordTrust) 
                {
                    //Fail is any of the attributes were not found.
                    for (DWORD i = 0; i < 5; i++) {
                        if (!AttsFound[i]) {
                            if (!m_Error.isError()) {
                                m_Error.SetErr(ERROR_DS_ATT_IS_NOT_ON_OBJ,
                                               L"Failed to find %ws on %ws\n",
                                               AttrsToSearch[i],
                                               SystemDn);
                            } else {
                                m_Error.AppendErr(L"Failed to find %ws on %ws\n",
                                                  AttrsToSearch[i],
                                                  SystemDn);
                            }
                        }
                    }
                    if (m_Error.isError()) {
                        goto Cleanup;
                    }
                    
                    NewTrust = new CTrustedDomain(Trust,
                                                  Trustpartner,
                                                  TrustType,
                                                  TrustDirection);
                    Trust = NULL;
                    Trustpartner = NULL;
                    TrustType = TrustDirection = 0;
                    if (!NewTrust) 
                    {
                        m_Error.SetMemErr();
                        goto Cleanup;
                    }
        
                    if (!d->AddDomainTrust(NewTrust))
                    {
                        Trust = NULL;
                        Trustpartner = NULL;
                        goto Cleanup;
                    }
                    NewTrust = NULL;
                    RecordTrust = FALSE;
        
                } else {
        
                    if (Trust) 
                    {
                        delete Trust;
                        Trust = NULL;
                    }
                    if (Trustpartner) 
                    {
                        Trustpartner = NULL;
                    }
        
                }

                if (TrustpartnerNetbiosName) 
                {
                    delete [] TrustpartnerNetbiosName;
                    TrustpartnerNetbiosName = NULL;
                }

                AttsFound[0] = FALSE;
                AttsFound[1] = FALSE;
                AttsFound[2] = FALSE;
                AttsFound[3] = FALSE;
                AttsFound[4] = FALSE;
            
            }

        }

        if (Values) {
            ldap_value_freeW(Values);
            Values = NULL;
        }


        if (SearchResult) {
            ldap_msgfree(SearchResult);
            SearchResult = NULL;
        }

    }

    Cleanup:

    if ( LdapError != LDAP_SUCCESS && LdapError != LDAP_NO_RESULTS_RETURNED )
    {
        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,                                         
                           L"Search to find Trusted Domain Objects Failed on %ws",
                           GetDcUsed(FALSE));

    }

    //Set the Number of trusts found for this domain.
    d->SetTrustCount(TrustCount);

    if (ppSid) 
    {
        ldap_value_free_len(ppSid);
        ppSid = NULL;
    }
    if (SystemDn) 
    {
        delete [] SystemDn;
        SystemDn = NULL;
    }
    if (TrustpartnerNetbiosName) 
    {
        delete [] TrustpartnerNetbiosName;
        TrustpartnerNetbiosName = NULL;
    }
    if (Values) 
    {
        ldap_value_freeW(Values);
        Values = NULL;
    }
    if (Guid) 
    {
        delete [] Guid;
        Guid = NULL;
    }
    if (SearchResult) 
    {
        ldap_msgfree(SearchResult);    
        SearchResult = NULL;
    }
    if (DN)
    {
        delete [] DN;
        DN = NULL; 
    }
    if (Sid)
    {
        delete [] Sid;
        Sid = NULL;
    }
    if (DomainDn)
    {
        delete [] DomainDn;
        DomainDn = NULL;
    }
    
    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;
}

BOOL CEnterprise::GetTrustsInfoITA(CDomain *d)
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG         LdapError = LDAP_SUCCESS;
    
    LDAPMessage   *SearchResult = NULL;
    PLDAPSearch   SearchHandle = NULL;
    PLDAPControlW ServerControls[2];
    LDAPControlW  ExtDNcontrol;
    ULONG         NumberOfEntries;
    WCHAR         *Attr = NULL;
    
    WCHAR         *AttrsToSearch[5];
    BOOL          AttsFound[4] = { FALSE, FALSE, FALSE, FALSE };
    
    WCHAR         *SystemRdn = L"CN=System,";
    
    ULONG         Length;
    BerElement    *pBerElement = NULL;
    
    WCHAR         *SystemDn = NULL;
    WCHAR         *DomainDN = NULL;
    WCHAR         **Values = NULL;
    struct berval **ppSid = NULL;
    
    WCHAR         *Guid = NULL;
    WCHAR         *DN = NULL;
    WCHAR         *Sid = NULL;

    WCHAR         *pzSecurityID = NULL;
    CDsName       *Trust = NULL;
    CDsName       *DomainDns = NULL;
    BOOL          RecordTrust = FALSE;
    DWORD         TrustType = 0;
    WCHAR         *DomainDn = NULL;
    WCHAR         *TrustpartnerNetbiosName = NULL;
    CDomain       *Trustpartner = NULL;
    CTrustedDomain *NewTrust = NULL;
    CInterDomainTrust *NewInterTrust = NULL;

    DomainDn = d->GetDomainDnsObject()->GetDN();
    if (m_Error.isError()) 
    {
        goto Cleanup;
    }

    // Set up the extended DN control.
    ExtDNcontrol.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    ExtDNcontrol.ldctl_iscritical = TRUE;
    ExtDNcontrol.ldctl_value.bv_len = 0;
    ExtDNcontrol.ldctl_value.bv_val = NULL;
    ServerControls[0] = &ExtDNcontrol;
    ServerControls[1] = NULL;

    //Get information Dealing with InterDomain Trust Objects

    AttrsToSearch[0] = L"samAccountName";
    AttrsToSearch[1] = L"distinguishedName";
    AttrsToSearch[2] = NULL;

    SearchHandle = ldap_search_init_page( m_hldap,
                                          DomainDn,
                                          LDAP_SCOPE_SUBTREE,
                                          LDAP_FILTER_SAMTRUSTACCOUNT,
                                          AttrsToSearch,
                                          FALSE,
                                          (PLDAPControlW *)&ServerControls,
                                          NULL,
                                          0,
                                          0,
                                          NULL);

    if ( !SearchHandle )
    {
        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,                                         
                           L"Search to find Trusted Domain Objects Failed on %ws",
                           GetDcUsed(FALSE));

        goto Cleanup;
    }

    while(LDAP_SUCCESS == (LdapError = ldap_get_next_page_s( m_hldap,
                                                             SearchHandle,
                                                             NULL,
                                                             200,
                                                             NULL,
                                                             &SearchResult)))

    {
        BOOL MyTrust = FALSE;
        NumberOfEntries = ldap_count_entries( m_hldap, SearchResult );
        if ( NumberOfEntries > 0 )
        {
            LDAPMessage *Entry;
            
            for ( Entry = ldap_first_entry(m_hldap, SearchResult);
                      Entry != NULL;
                          Entry = ldap_next_entry(m_hldap, Entry))
            {
                for( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                      Attr != NULL;
                          Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement))
                {
                    if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                    {
                        AttsFound[1] = TRUE;
                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //
                            WCHAR *p = NULL;
                            if (!LdapGetGuid(Values[0],
                                             &Guid)) 
                            {
                                goto Cleanup;
                            }
                            if (!LdapGetDN(Values[0],
                                           &DN)) 
                            {
                                goto Cleanup;
                            }
                            DomainDN = d->GetDomainDnsObject()->GetDN();
                            if (m_Error.isError()) 
                            {
                                goto Cleanup;
                            }
                            // need to make sure that this trust
                            // does belong to this domain and not
                            // a child.
                            p = wcsstr(DN,L"DC=");
                            if (0 == _wcsicmp(p,DomainDN))
                            {
                                MyTrust = TRUE;            
                            }
                            if (DomainDN) {
                                delete [] DomainDN;
                                DomainDN = NULL;
                            }
                            if (!LdapGetSid(Values[0],
                                            &Sid)) 
                            {
                                goto Cleanup;
                            }
        
                            
                            Trust = new CDsName(Guid,
                                                DN,
                                                Sid);
                            
                            if (!Trust) {
                                m_Error.SetMemErr();
                                goto Cleanup;
                            }
        
                            Guid = DN = Sid = NULL; 
        
                        }
        
                    }
                    if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                    {
                        AttsFound[0] = TRUE;
                        //
                        // Found it - these are NULL-terminated strings
                        //

                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //
                            WCHAR *MachineName = new WCHAR[wcslen(Values[0])+1];
                            if (!MachineName) {
                                m_Error.SetMemErr();
                                goto Cleanup;
                            }
                            wcscpy(MachineName,Values[0]);
                            //remove the trailing $
                            MachineName[wcslen(MachineName)-1] = L'\0';
                            Trustpartner = m_DomainList->LookupByNetbiosName(MachineName);
                            if (Trustpartner)
                            {
    
                                RecordTrust = TRUE;
    
                            } 
                            delete [] MachineName;
        
                        }
                    }
                    
                    LdapError = ldap_value_freeW(Values);
                    Values = NULL;
                    if (LDAP_SUCCESS != LdapError) 
                    {
                        m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                        L"Failed to Free values from a ldap search");
                        goto Cleanup;
                    }

                    if (Attr) {
                        ldap_memfree(Attr);
                        Attr = NULL;
                    }
                }

                if (RecordTrust && MyTrust) 
                {
                    //Fail is any of the attributes were not found.
                    for (DWORD i = 0; i < 2; i++) {
                        if (!AttsFound[i]) {
                            if (!m_Error.isError()) {
                                m_Error.SetErr(ERROR_DS_ATT_IS_NOT_ON_OBJ,
                                               L"Failed to find %ws\n",
                                               AttrsToSearch[i],
                                               SystemDn);
                            } else {
                                m_Error.AppendErr(L"Failed to find %ws\n",
                                                  AttrsToSearch[i],
                                                  SystemDn);
                            }
                        }
                    }
                    if (m_Error.isError()) {
                        goto Cleanup;
                    }

                    NewInterTrust = new CInterDomainTrust(Trust,
                                                          Trustpartner);
                    Trust = NULL;
                    Trustpartner = NULL;
                    if (!NewInterTrust) 
                    {
                        m_Error.SetMemErr();
                        goto Cleanup;
                    }
        
                    if (!d->AddInterDomainTrust(NewInterTrust))
                    {
                        Trust = NULL;
                        Trustpartner = NULL;
                        goto Cleanup;
                    }
                    RecordTrust = FALSE;
                    MyTrust = FALSE;
        
                } else {
        
                    if (Trust) 
                    {
                        delete Trust;
                        Trust = NULL;
                    }
                    if (Trustpartner) 
                    {
                        Trustpartner = NULL;
                    }
                    RecordTrust = FALSE;
                    MyTrust = FALSE;
                
                }

                AttsFound[0] = FALSE;
                AttsFound[1] = FALSE;
        
            }

        }
        if (Values) {
            ldap_value_freeW(Values);
            Values = NULL;
        }


        if (SearchResult) {
            ldap_msgfree(SearchResult);
            SearchResult = NULL;
        }

    }

    Cleanup:

    if ( LdapError != LDAP_SUCCESS && LdapError != LDAP_NO_RESULTS_RETURNED )
    {
        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,                                         
                           L"Search to find InterDomain Trusts Failed on %ws",
                           GetDcUsed(FALSE));
    }
    
    if (ppSid) 
    {
        ldap_value_free_len(ppSid);
        ppSid = NULL;
    }
    if (SystemDn) 
    {
        delete [] SystemDn;
        SystemDn = NULL;
    }
    if (TrustpartnerNetbiosName) 
    {
        delete [] TrustpartnerNetbiosName;
        TrustpartnerNetbiosName = NULL;
    }
    if (Values) 
    {
        ldap_value_freeW(Values);
        Values = NULL;
    }
    if (Guid) 
    {
        delete [] Guid;
        Guid = NULL;
    }
    if (SearchResult) 
    {
        ldap_msgfree(SearchResult);    
        SearchResult = NULL;
    }
    if (DN)
    {
        delete [] DN;
        DN = NULL; 
    }
    if (Sid)
    {
        delete [] Sid;
        Sid = NULL;
    }
    if (DomainDn)
    {
        delete [] DomainDn;
        DomainDn = NULL;
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;

}

/*++
Routine Description:
This function will find Interdomain trust object and trusted domain objects information.  
It will only look for intradomain trusts and ignore external trust.

--*/
BOOL CEnterprise::GetTrustsAndSpnInfo()
{
    CDomain *d = m_DomainList;

    while (d) 
    {
        //Connect to the current domain.
        if (!LdapConnectandBind(d))
        {
            //BUGBUG:  I believe this should Fail!
            if ((m_Error.GetErr() == ERROR_NO_SUCH_DOMAIN) ||
                (m_Error.GetErr() ==ERROR_BAD_NET_RESP)) {
                m_Error.SetErr(0,
                                L"No Error");
                d = d->GetNextDomain();
                continue;
            }
            return FALSE;
        }

        if (!d->isDomain()) 
        {
            //since this is not a Domain
            //There will be no trust objects
            //Just continue on to the next domain
            d = d->GetNextDomain();
            continue;
        }

        if (!GetSpnInfo(d)) 
        {
            goto Cleanup;
        }

        if (!GetTrustsInfoTDO(d))
        {
            goto Cleanup;
        }

        if (!GetTrustsInfoITA(d))
        {
            goto Cleanup;
        }

        std::list<CTrust> ltdo;
        CTrust *tdo = d->GetTrustedDomainList();
        while (tdo) {
            ltdo.push_front(*tdo);
            tdo = tdo->GetNext();
        }
        ltdo.sort();

        std::list<CTrust> lita;
        CTrust *ita = d->GetInterDomainTrustList();
        while (ita) {
            lita.push_front(*ita);
            ita = ita->GetNext();
        }
        lita.sort();

        std::list<CTrust>::iterator itITA;
        std::list<CTrust>::iterator itTDO;
        for (itITA = lita.begin(),itTDO = ltdo.begin();
             itTDO != ltdo.end();
             itTDO++,itITA++) 
        {
            if ((*itTDO).isInbound()) {
                if (!( (*itTDO).GetTrustPartner() == (*itITA).GetTrustPartner() )) {
                    if (!m_Error.isError()) {
                        m_Error.SetErr(ERROR_DOMAIN_TRUST_INCONSISTENT,
                                       L"The trusted domain object %ws does not have a corresponding interdomain trust for the domain %ws",
                                       (*itTDO).GetTrustDsName()->GetDN(FALSE),
                                       d->GetDnsRoot(FALSE));
                    } else {
                        m_Error.AppendErr(L"The trusted domain object %ws does not have a corresponding interdomain trust for the domain %ws",
                                       (*itTDO).GetTrustDsName()->GetDN(FALSE),
                                       d->GetDnsRoot(FALSE));
                    }
                }
            } else {
                itITA--;
            }
        }

        ltdo.clear(); lita.clear();

        // Move on to the next Domain
        d = d->GetNextDomain();
    }

    Cleanup:

    //Connect back to the Domain Naming FSMO
    if (!LdapConnectandBindToDomainNamingFSMO())
    {
        return FALSE;
    }

    return TRUE;
}


BOOL CEnterprise::LdapConnectandBindToServer(WCHAR *Server)
{
    ASSERT(Server);
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG ldapErr = LDAP_SUCCESS;
    PVOID ldapOption;

    if (m_hldap) {
        ldapErr = ldap_unbind(m_hldap);
        m_hldap = NULL;
        //NOTE:Log errors to a log file
        /*if ( LDAP_SUCCESS != ldapErr) {
            m_Error.SetErr(LdapMapErrorToWin32(ldapErr),
                            L"Failed to close the old Ldap session");
            //print the extented error as wel;
            PWCHAR pErrorString;
            ldap_get_option(m_hldap, LDAP_OPT_SERVER_ERROR, (void*) &pErrorString);
            
            m_Error.AppendErr(pErrorString);

            ldap_memfree(pErrorString);
            return false;
        } */
    }

    SetDcUsed(Server);
    if( m_Error.isError() )
    {
        return FALSE;
    }

    m_hldap = ldap_initW(Server,
                         LDAP_PORT
                         );

    if (NULL == m_hldap) {
        ldapErr = LdapGetLastError();

        m_Error.SetLdapErr(m_hldap,                                           
                           ldapErr?ldapErr:LDAP_SERVER_DOWN,                                         
                           L"Failed to open a ldap connection to %s",
                           Server);

        return false;
    }

    // request encryption -- it is now required for script modify operations
    ldapOption = LDAP_OPT_ON;
    ldapErr = ldap_set_option(m_hldap, LDAP_OPT_ENCRYPT, &ldapOption);
    if ( LDAP_SUCCESS != ldapErr) {
        
        m_Error.SetLdapErr(m_hldap,                                           
                           ldapErr,
                           L"Failed to set LDAP encryption option for Ldap session on %s",
                           Server);

        return false;

    }


    ldapErr = ldap_bind_s(m_hldap,
                          NULL,
                          (PWCHAR)m_Opts->pCreds,
                          LDAP_AUTH_SSPI
                          );
    if ( LDAP_SUCCESS != ldapErr) {

        m_Error.SetLdapErr(m_hldap,                                           
                           ldapErr,
                           L"Failed to Bind to Ldap session on %s",
                           Server);

        return false;

    }

    return true;
}

BOOL CEnterprise::CheckForExistingScript(BOOL *found)
{
    ASSERT(found);
    WCHAR *AttrsToSearch[2];
    ULONG LdapError        = LDAP_SUCCESS;
    WCHAR *ConfigurationDN = NULL;
    WCHAR *PartitionsDn    = NULL;
    WCHAR *PartitionsRdn = L"CN=Partitions,";
    WCHAR **Values         = NULL;
    LDAPMessage  *SearchResult = NULL;
    DWORD Length = 0;
    LDAPMessage *Entry = NULL;
    
    *found = FALSE;

    //
    // Build string for the partitions DN
    //
    ConfigurationDN = m_ConfigNC->GetDN(FALSE);
    if (m_Error.isError()) {
        goto Cleanup;
    }
    ASSERT(ConfigurationDN);
    if (!ConfigurationDN) {
        goto Cleanup;
    }
    
    Length =  (wcslen( ConfigurationDN )
            + wcslen( PartitionsRdn )   
            + 1);
                                                          
    PartitionsDn = new WCHAR[Length];
    if (!PartitionsDn) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    wcscpy( PartitionsDn, PartitionsRdn );
    wcscat( PartitionsDn, ConfigurationDN );

    AttrsToSearch[0] = L"msDS-UpdateScript";
    AttrsToSearch[1] = NULL;
    
    LdapError = ldap_search_sW( m_hldap,
                                PartitionsDn,
                                LDAP_SCOPE_BASE,
                                LDAP_FILTER_DEFAULT,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    Entry = ldap_first_entry(m_hldap, SearchResult);
    if ( !Entry ) {
        m_Error.SetErr(LdapMapErrorToWin32(LdapGetLastError()),
                       L"Failed to determine if a rename is already in progress");
    }

    Values = ldap_get_valuesW( m_hldap, Entry, AttrsToSearch[0] );
    if ( Values && Values[0] )
    {
        *found = TRUE;
    }

    Cleanup:

    if (PartitionsDn) {

        delete [] PartitionsDn;
        
    }

    if (m_Error.isError()) {
        return FALSE;
    }

    return TRUE;

}

BOOL CEnterprise::LdapConnectandBindToDomainNamingFSMO()
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];
    WCHAR        *Attr = NULL;
    BerElement   *pBerElement = NULL;

    WCHAR        *PartitionsRdn = L"CN=Partitions,";

    WCHAR        *PartitionsDn = NULL;
    WCHAR        *FSMORoleOwnerAttr = L"fSMORoleOwner";
    WCHAR        *DnsHostNameAttr = L"dNSHostName";

    WCHAR        *DomainNamingFSMOObject = NULL;
    WCHAR        *DomainNamingFSMODsa = NULL;
    WCHAR        *DomainNamingFSMOServer = NULL;
    WCHAR        *DomainNamingFSMODnsName = NULL;

    WCHAR        **Values = NULL;

    WCHAR        *ConfigurationDN = NULL;

    ULONG         Length;

    BOOL          found = false;

    if (!m_hldap) {
        if (!LdapConnectandBind())
        {
           return FALSE;
        }
    }

    //
    // Read the reference to the fSMORoleOwner
    //
    AttrsToSearch[0] = L"configurationNamingContext";
    AttrsToSearch[1] = NULL;
    
    LdapError = ldap_search_sW( m_hldap,
                                NULL,
                                LDAP_SCOPE_BASE,
                                LDAP_FILTER_DEFAULT,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {

        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,
                           L"Search to find Configuration container failed on %ws",
                           GetDcUsed(FALSE));
                           

        goto Cleanup;
    }
    
    NumberOfEntries = ldap_count_entries(m_hldap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
            
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(m_hldap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {
    
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ConfigurationDN = new WCHAR[wcslen(Values[0])+1];
                        if (!ConfigurationDN) {
                            m_Error.SetMemErr();
                            goto Cleanup;
                        }
                        wcscpy( ConfigurationDN, Values[0] );
                        found = true;
                    }

                    LdapError = ldap_value_freeW(Values);
                    Values = NULL;
                    if (LDAP_SUCCESS != LdapError) 
                    {
                        m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                        L"Failed to Free values from a ldap search");
                        goto Cleanup;
                    }

                 }
                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
            }

            
        }
    }
    
    if ( SearchResult ) {
        ldap_msgfree( SearchResult );
        SearchResult = NULL;
    }
    if (!found) {

        m_Error.SetErr( ERROR_DS_CANT_RETRIEVE_ATTS,
                         L"Could not find the configurationNamingContext attribute on the RootDSE object" );
        goto Cleanup;

    }

    
    Length =  (wcslen( ConfigurationDN )
            + wcslen( PartitionsRdn )
            + 1);

    PartitionsDn = new WCHAR[Length];

    wcscpy( PartitionsDn, PartitionsRdn );
    wcscat( PartitionsDn, ConfigurationDN );
    //
    // Next get the role owner
    //
    AttrsToSearch[0] = FSMORoleOwnerAttr;
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( m_hldap,
                                PartitionsDn,
                                LDAP_SCOPE_BASE,
                                LDAP_FILTER_DEFAULT,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,                                     
                           L"ldap_search_sW for rid fsmo dns name failed on %ws",
                           GetDcUsed(FALSE)); 

        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries(m_hldap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
                 Entry != NULL;
                     Entry = ldap_next_entry(m_hldap, Entry) )
        {
            for( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                     Attr != NULL;
                        Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, FSMORoleOwnerAttr ) ) {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW(m_hldap, Entry, Attr);
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        DomainNamingFSMODsa = new WCHAR[Length+1];
                        if (!DomainNamingFSMODsa) {
                            m_Error.SetMemErr();
                            goto Cleanup;
                        }
                        wcscpy( DomainNamingFSMODsa, Values[0] );
                    }

                    LdapError = ldap_value_freeW(Values);
                    Values = NULL;
                    if (LDAP_SUCCESS != LdapError) 
                    {
                        m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                        L"Failed to Free values from a ldap search");
                        goto Cleanup;
                    }
                }
                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
             }

            
         }
    }

    ldap_msgfree( SearchResult );
    SearchResult = NULL;

    if ( !DomainNamingFSMODsa )
    {
        m_Error.SetErr(ERROR_DS_MISSING_FSMO_SETTINGS,
                        L"Could not find the DN of the Domain naming FSMO");
        goto Cleanup;
    }

    //
    // Ok, we now have the domain naming object; find its dns name
    //
    DomainNamingFSMOServer = new WCHAR[wcslen( DomainNamingFSMODsa ) + 1];
    if (!DomainNamingFSMOServer) {
        m_Error.SetMemErr();
        goto Cleanup;
    }
    if ( ERROR_SUCCESS != TrimDNBy( DomainNamingFSMODsa ,1 ,&DomainNamingFSMOServer) )
    {
        // an error! The name must be mangled, somehow
        delete [] DomainNamingFSMOServer;
        DomainNamingFSMOServer = NULL;
        m_Error.SetErr(ERROR_DS_MISSING_FSMO_SETTINGS,
                        L"The DomainNaming FSMO is missing");
        goto Cleanup;
    }

    AttrsToSearch[0] = DnsHostNameAttr;
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW(m_hldap,
                               DomainNamingFSMOServer,
                               LDAP_SCOPE_BASE,
                               LDAP_FILTER_DEFAULT,
                               AttrsToSearch,
                               FALSE,
                               &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,                                     
                           L"ldap_search_sW for rid fsmo dns name failed on %ws",
                           GetDcUsed(FALSE));

        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries( m_hldap, SearchResult );
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
                  Entry != NULL;
                      Entry = ldap_next_entry(m_hldap, Entry))
        {
            for( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                  Attr != NULL;
                      Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement))
            {
                if ( !_wcsicmp( Attr, DnsHostNameAttr ) )
                {

                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                         //
                         // Found it - these are NULL-terminated strings
                         //
                         Length = wcslen( Values[0] );
                         DomainNamingFSMODnsName = new WCHAR[Length+1];
                         if (!DomainNamingFSMODnsName) {
                             m_Error.SetMemErr();
                             goto Cleanup;
                         }
                         wcscpy( DomainNamingFSMODnsName, Values[0] );
                    }

                    LdapError = ldap_value_freeW(Values);
                    Values = NULL;
                    if (LDAP_SUCCESS != LdapError) 
                    {
                        m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                        L"Failed to Free values from a ldap search");
                        goto Cleanup;
                    }
                }
                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
            }

            
        }
    }

    ldap_msgfree( SearchResult );
    SearchResult = NULL;

    if ( !DomainNamingFSMODnsName )
    {
        m_Error.SetErr(ERROR_DS_MISSING_FSMO_SETTINGS,
                        L"Unable to find DnsName of the Domain naming fsmo");
        goto Cleanup;
    }

    if ( !LdapConnectandBindToServer(DomainNamingFSMODnsName) )
    {
        m_Error.AppendErr(L"Cannot connect and bind to the Domain Naming FSMO.  Cannot Continue.");
        goto Cleanup;
    }



Cleanup:

    if (Attr) {
        ldap_memfree(Attr);
        Attr = NULL;
    }
    if (Values) {
        ldap_value_free(Values);
    }
    if ( PartitionsDn ) 
    {
        delete [] PartitionsDn;
    }
    if ( DomainNamingFSMOObject ) 
    {
        delete [] DomainNamingFSMOObject;
    }
    if ( DomainNamingFSMODsa )
    {
        delete [] DomainNamingFSMODsa;
    }
    if ( DomainNamingFSMOServer) 
    {
        delete [] DomainNamingFSMOServer;
    }
    if ( DomainNamingFSMODnsName ) 
    {
        delete [] DomainNamingFSMODnsName;
    }
    if ( ConfigurationDN )
    {
        delete [] ConfigurationDN;
    }
    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }
    if ( m_Error.isError() ) 
    {
        return false;
    }
    return true;
}


BOOL CEnterprise::EnumeratePartitions()
{
    if (!m_hldap) 
    {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Call to EnumeratePartitions without having a valid handle to an ldap server\n");
        return false;
    }

    if (!m_ConfigNC) 
    {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Call to EnumeratePartitions without having a valid ConfigNC\n");
        return false;
    }

    DWORD WinError = ERROR_SUCCESS;

    ULONG         LdapError = LDAP_SUCCESS;

    LDAPMessage   *SearchResult = NULL;
    PLDAPControlW ServerControls[2];
    LDAPControlW  ExtDNcontrol;
    ULONG         NumberOfEntries;
    WCHAR         *Attr = NULL;
    BerElement    *pBerElement = NULL;
    WCHAR         **Result = NULL;
    DWORD         BehaviorVerison = 0;

    WCHAR         *AttrsToSearch[7];
    BOOL          AttsFound[5] = { FALSE, FALSE, FALSE, FALSE, FALSE };

    WCHAR         *PartitionsRdn = L"CN=Partitions,";

    WCHAR         *ConfigurationDN = m_ConfigNC->GetDN();
    if (!ConfigurationDN) 
    {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                       L"ConfigNC does not have a DN");
        goto Cleanup;
    }

    ULONG         Length;

    WCHAR         *PartitionsDn = NULL;
    WCHAR         **Values = NULL;
    LDAPMessage   *Entry = NULL;

    WCHAR         *Guid = NULL;
    WCHAR         *DN = NULL;
    WCHAR         *Sid = NULL;

    CDsName       *Crossref = NULL;
    CDsName       *DomainDns = NULL;
    BOOL          isDomain = FALSE;
    BOOL          isExtern = FALSE;
    BOOL          isDisabled = FALSE;
    DWORD         systemflags = 0;
    WCHAR         *dnsRoot = NULL;
    WCHAR         *NetBiosName = NULL;

    //check the forest behavior version if less that 2 Fail.
    AttrsToSearch[0] = L"msDS-Behavior-Version";
    AttrsToSearch[1] = NULL;

    Length =  (wcslen( ConfigurationDN )
            + wcslen( PartitionsRdn )   
            + 1);

    PartitionsDn = new WCHAR[Length];
    if (!PartitionsDn) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    wcscpy( PartitionsDn, PartitionsRdn );
    wcscat( PartitionsDn, ConfigurationDN );

    LdapError = ldap_search_sW( m_hldap,
                                PartitionsDn,
                                LDAP_SCOPE_BASE,
                                LDAP_FILTER_DEFAULT,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,                                     
                           L"Search to find the partitions container failed on %ws",
                           GetDcUsed(FALSE));

        goto Cleanup;
    }

    Entry = ldap_first_entry(m_hldap, SearchResult);
    if (!Entry) {
        m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                        L"The Behavior version of the Forest has not been set to 2 or greater");
        goto Cleanup;
    }

    Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
    if (!Attr) {
        m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                        L"The Behavior version of the Forest has not been set to 2 or greater");
        goto Cleanup;
    }

    Result = ldap_get_valuesW (m_hldap,
                               Entry,
                               Attr
                               );
    if (!Result) {                
        m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                        L"The Behavior version of the Forest has not been set to 2 or greater");
        goto Cleanup;
    }

    BehaviorVerison = (DWORD)_wtoi(*Result);

    if (BehaviorVerison < 2) {
        m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                       L"The Behavior version of the Forest is %d it must be 2 or greater to perform a domain rename",
                       BehaviorVerison);
        goto Cleanup;    
    }

    if (Result) {
        LdapError = ldap_value_freeW(Result);
        Result = NULL;
        if ( LDAP_SUCCESS != LdapError )
        {
            m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                            L"Failed to free memory");
            goto Cleanup;
        }
    }

    if (Result) {
        ldap_value_free(Result);
    }
    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }

    SearchResult = NULL;
    Entry = NULL;
    Attr  = NULL;
    
    AttrsToSearch[0] = L"systemFlags";
    AttrsToSearch[1] = L"nCName";
    AttrsToSearch[2] = L"dnsRoot";
    AttrsToSearch[3] = L"nETBIOSName";
    AttrsToSearch[4] = L"distinguishedName";
    AttrsToSearch[5] = L"Enabled";
    AttrsToSearch[6] = NULL;

    #define ATTS_FOUND_DNSROOT     2
    #define ATTS_FOUND_NETBIOSNAME 3

    // Set up the extended DN control.
    ExtDNcontrol.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    ExtDNcontrol.ldctl_iscritical = TRUE;
    ExtDNcontrol.ldctl_value.bv_len = 0;
    ExtDNcontrol.ldctl_value.bv_val = NULL;
    ServerControls[0] = &ExtDNcontrol;
    ServerControls[1] = NULL;

    LdapError = ldap_search_ext_sW( m_hldap,
                                    PartitionsDn,
                                    LDAP_SCOPE_ONELEVEL,
                                    LDAP_FILTER_DEFAULT,
                                    AttrsToSearch,
                                    FALSE,
                                    (PLDAPControlW *)&ServerControls,
                                    NULL,
                                    NULL,
                                    0,
                                    &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {
        
        m_Error.SetLdapErr(m_hldap,                                           
                           LdapError,                                     
                           L"Search to find the partitions container failed on %ws",
                           GetDcUsed(FALSE));

        goto Cleanup;
    }

    NumberOfEntries = ldap_count_entries( m_hldap, SearchResult );
    if ( NumberOfEntries > 0 )
    {
        for ( Entry = ldap_first_entry(m_hldap, SearchResult);
                  Entry != NULL;
                      Entry = ldap_next_entry(m_hldap, Entry))
        {
            for( Attr = ldap_first_attributeW(m_hldap, Entry, &pBerElement);
                  Attr != NULL;
                      Attr = ldap_next_attributeW(m_hldap, Entry, pBerElement))
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[4] ) )
                {
                    AttsFound[4] = TRUE;
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //
                        // Found it - these are NULL-terminated strings
                        //
                        if (!LdapGetGuid(Values[0],
                                         &Guid)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetDN(Values[0],
                                       &DN)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetSid(Values[0],
                                        &Sid)) 
                        {
                            goto Cleanup;
                        }

                        
                        Crossref = new CDsName(Guid,
                                               DN,
                                               Sid);
                        if (!Crossref) {
                            m_Error.SetMemErr();
                            goto Cleanup;
                        }

                        Guid = DN = Sid = NULL; 

                    }

                }
                if ( !_wcsicmp( Attr, AttrsToSearch[2] ) )
                {
                    AttsFound[2] = TRUE;
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //
                        // Found it - these are NULL-terminated strings
                        //
                        dnsRoot = new WCHAR[wcslen(Values[0])+1];
                        if (!dnsRoot) {
                            m_Error.SetMemErr();
                            goto Cleanup;
                        }
                        wcscpy(dnsRoot,Values[0]);
                    }

                }
                if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                {
                    AttsFound[1] = TRUE;
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //
                        // Found it - these are NULL-terminated strings
                        //
                        if (!LdapGetGuid(Values[0],
                                         &Guid)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetDN(Values[0],
                                       &DN)) 
                        {
                            goto Cleanup;
                        }
                        if (!LdapGetSid(Values[0],
                                        &Sid)) 
                        {
                            goto Cleanup;
                        }

                        
                        DomainDns = new CDsName(Guid,
                                                DN,
                                                Sid);
                        if (!DomainDns) {
                            m_Error.SetMemErr();
                            goto Cleanup;
                        }

                        Guid = DN = Sid = NULL;

                    }

                }
                if ( !_wcsicmp( Attr, AttrsToSearch[3] ) )
                {
                    AttsFound[3] = TRUE;
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                         //
                         // Found it - these are NULL-terminated strings
                         //
                        NetBiosName = new WCHAR[wcslen(Values[0])+1];
                        if (!NetBiosName) {
                            m_Error.SetMemErr();
                            goto Cleanup;
                        }
                        wcscpy(NetBiosName,Values[0]);

                    }

                }
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {
                    AttsFound[0] = TRUE;
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //
                        // Found it - these are NULL-terminated strings
                        //
                        systemflags=_wtoi(Values[0]);

                        if ( !(systemflags & FLAG_CR_NTDS_NC) ) 
                        {
                            // If systemflags doesn't have the FLAG_CR_NTDS_NC
                            // so it must be an external crossref  
                            isExtern = TRUE;
                            break;
                        }

                        if ( systemflags & FLAG_CR_NTDS_DOMAIN ) {
                            isDomain = TRUE;
                        } else {
                            isDomain = FALSE;
                        }

                        systemflags = 0;
                    
                    }

                }

                if ( !_wcsicmp( Attr, AttrsToSearch[5] ) )
                {
                    AttsFound[0] = TRUE;
                    Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //
                        // Found it - these are NULL-terminated strings
                        //
                        Values = ldap_get_valuesW( m_hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                           if (wcscmp(L"FALSE",Values[0]) == 0)
                           {
                                //This is not an enabled crossref skipping it
                                LdapError = ldap_value_freeW(Values);
                                Values = NULL;
                                if (LDAP_SUCCESS != LdapError) 
                                {
                                    m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                                    L"Failed to Free values from a ldap search");
                                    goto Cleanup;
                                }

                                isDisabled = TRUE;
                           }
                        }

                    }

                }

                LdapError = ldap_value_freeW(Values);
                Values = NULL;
                if (LDAP_SUCCESS != LdapError) 
                {
                    m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                    L"Failed to Free values from a ldap search");
                    goto Cleanup;
                }

                if (Attr) {
                    ldap_memfree(Attr);
                    Attr = NULL;
                }
            }

            Guid = DomainDns->GetGuid();

            //
            // If this crossref doesn't have a systemFlags attribute it
            // is a extern crossref.
            //
            if (!AttsFound[0]) {

                isExtern = TRUE;

            }

            if ( (TRUE == m_ConfigNC->CompareByObjectGuid(Guid)) ||
                 (TRUE == m_SchemaNC->CompareByObjectGuid(Guid)) ||
                 isDisabled)
            {
                // This is the crossref for the Configuration, the schema
                // or is disabled. Therefore we are going to ignore it. 
                if (Crossref)
                {
                    delete Crossref;
                    Crossref = NULL;
                }
                if (DomainDns) 
                {
                    delete DomainDns;
                    DomainDns = NULL;
                }
                if (dnsRoot)
                {
                    delete [] dnsRoot;
                    dnsRoot = NULL;
                }
                if (NetBiosName) 
                {
                    delete [] NetBiosName;
                    NetBiosName = NULL;
                }
                if (Guid) {
                    delete [] Guid;
                    Guid = NULL;
                }

                isExtern = FALSE;
                isDisabled = FALSE;

                AttsFound[0] = FALSE;
                AttsFound[1] = FALSE;
                AttsFound[2] = FALSE;
                AttsFound[3] = FALSE;
                AttsFound[4] = FALSE;

                continue;
                   
            }
            if (Guid) {
                delete [] Guid;
                Guid = NULL;
            }

            //Fail is any of the attributes were not found.
            for (DWORD i = 1; i < NELEMENTS(AttsFound); i++) {
                if (!AttsFound[i]) {
                    // if this is an NDNC or extern crossref 
                    // then we do not expect a netbios name.
                    if ((i == ATTS_FOUND_NETBIOSNAME) && (!isDomain || isExtern)) {
                        continue;
                    }
                    if (!m_Error.isError()) {
                        m_Error.SetErr(ERROR_DS_ATT_IS_NOT_ON_OBJ,
                                       Crossref?L"Failed to find %ws on %ws\n":
                                       L"Failed to find %ws on an object under %ws\n",
                                       AttrsToSearch[i],
                                       Crossref?Crossref->GetDN(FALSE):PartitionsDn);
                    } else {
                        m_Error.AppendErr(Crossref?L"Failed to find %ws on %ws\n":
                                          L"Failed to find %ws on an object under %ws\n",
                                          AttrsToSearch[i],
                                          Crossref?Crossref->GetDN(FALSE):PartitionsDn);
                    }
                }
            }
            if (m_Error.isError()) {
                goto Cleanup;
            }

            //after we have read all of the attributes
            //we are going to create a new domain using the information
            //gathered and we are going to add this domain to the domain
            //list that we keep.
            CDomain *d = new CDomain(Crossref,
                                     DomainDns,
                                     dnsRoot,
                                     NetBiosName,
                                     isDomain,
                                     isExtern,
                                     isDisabled,
                                     NULL);
            if (m_Error.isError()) {
                goto Cleanup;
            }
            if (!d) {
                m_Error.SetMemErr();
                goto Cleanup;
            }
            Crossref = NULL;
            DomainDns = NULL;
            dnsRoot = NULL;
            NetBiosName = NULL;
            isExtern = FALSE;
            isDisabled = FALSE;
            if (!AddDomainToDomainList(d))
            {
                delete d;
                d = NULL;
                return false;
            }
            // if this domain is the forest root we should mark
            // have a pointer to it.
            WCHAR *dGuid = m_ForestRootNC->GetGuid();
            if ( d->GetDomainDnsObject()->CompareByObjectGuid( dGuid ) )
            {
                delete [] dGuid;
                dGuid = NULL;
                m_ForestRoot = d;
            }

            AttsFound[0] = FALSE;
            AttsFound[1] = FALSE;
            AttsFound[2] = FALSE;
            AttsFound[3] = FALSE;
            AttsFound[4] = FALSE;
        }
    }

    Cleanup:

    if (Attr) {
        ldap_memfree(Attr);
    }
    if (Values) {
        ldap_value_free(Values);
    }
    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }
    if (ConfigurationDN) {
        delete [] ConfigurationDN;
    }
    if (PartitionsDn) {
        delete [] PartitionsDn;
    }
    if (Guid) {
        delete [] Guid;
    }
    if (DN) {
        delete [] DN;
    }
    if (Sid) {
        delete [] Sid;
    }
    if (!m_ForestRootNC) {
        m_Error.SetErr(ERROR_GEN_FAILURE,
                        L"There is an inconsitancy in the Forest.  A crossref could not be found for the forest root.");
    }
    if (Result) {
        ldap_value_free(Result);
    }
    if (m_Error.isError() ) 
    {
        return false;
    }
    return true;

    
}

//
// This function will check to see if exchange has been installed in the
// enterprise.
//
BOOL CEnterprise::CheckForExchangeNotInstalled()
{
    if (!LdapConnectandBindToDomainNamingFSMO())
    {
        return FALSE;
    }
    WCHAR         *AttrsToSearch[2];
    LDAPMessage   *SearchResult = NULL;
    ULONG         NumberOfEntries = 0;
    WCHAR         *Base = NULL;
    ULONG         LdapError = LDAP_SUCCESS;
    WCHAR         *BaseRDN = L"CN=Microsoft Exchange,CN=Services,CN=Configuration,";

    AttrsToSearch[0] = L"distinguishedName";
    AttrsToSearch[1] = NULL;

    //
    // Create the base to search on
    //
    Base = new WCHAR[wcslen(BaseRDN)+wcslen(m_ForestRoot->GetDomainDnsObject()->GetDN(FALSE))+1];
    if (!Base) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    wcscpy(Base,BaseRDN);
    wcscat(Base,m_ForestRoot->GetDomainDnsObject()->GetDN(FALSE));

    LdapError = ldap_search_sW( m_hldap,
                                Base,
                                LDAP_SCOPE_SUBTREE,
                                LDAP_FILTER_EXCHANGE,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    
    if ( LDAP_SUCCESS != LdapError )
    {
        if (LDAP_NO_SUCH_OBJECT == LdapError) {
            //
            // There are no exchange objects.
            //
            goto Cleanup;
        }
        m_Error.SetLdapErr(m_hldap,
                           LdapError,
                           L"Search to find Exchange Objects Failed on %ws",
                           GetDcUsed(FALSE));
        
        goto Cleanup;
    }

    //
    // If any object are return then the domain rename needs to be blocked
    // 
    NumberOfEntries = ldap_count_entries(m_hldap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        m_Error.SetErr(ERROR_DS_UNWILLING_TO_PERFORM,
                       L"Domain rename is not supported in an Active Directory forest with Exchange deployed.");
        goto Cleanup;
    }


    Cleanup:

    if (Base) {
        delete [] Base;
    }

    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }

    if (m_Error.isError()) {
        return FALSE;
    }         

    return TRUE;

}

BOOL CDcList::GenerateDCListFromEnterprise(LDAP  *hldap,
                                           WCHAR *DcUsed,
                                           WCHAR *ConfigurationDN)
{
    ASSERT(hldap);
    ASSERT(ConfigurationDN);
    
    DWORD WinError = ERROR_SUCCESS;

    ULONG         LdapError = LDAP_SUCCESS;

    LDAPMessage   *SearchResult = NULL;
    LDAPMessage   *SearchResult2 = NULL;
    PLDAPSearch   SearchHandle = NULL;
    ULONG         NumberOfEntries;
    WCHAR         *Attr = NULL;
    BerElement    *pBerElement = NULL;

    WCHAR         *AttrsToSearch[2];
    WCHAR         *AttrsToSearch2[2];

    WCHAR         *SitesRdn = L"CN=Sites,";

    ULONG         Length;

    WCHAR         *SitesDn = NULL;
    WCHAR         **Values = NULL;

    WCHAR         **ExplodedDN = NULL;
    
    WCHAR         *ServerDN    = NULL;
    WCHAR         *DNSname     = NULL;

    AttrsToSearch[0] = L"distinguishedName";
    AttrsToSearch[1] = NULL;

     // next ldap search will require this attribute
    AttrsToSearch2[0] = L"dNSHostName";
    AttrsToSearch2[1] = NULL;


    Length =  (wcslen( ConfigurationDN )
            + wcslen( SitesRdn )   
            + 1);

    SitesDn = new WCHAR[Length];
    if (!SitesDn) {
        m_Error.SetMemErr();
        goto Cleanup;
    }

    wcscpy( SitesDn, SitesRdn );
    wcscat( SitesDn, ConfigurationDN );    
    
    SearchHandle =  ldap_search_init_page( hldap,
                                           SitesDn,
                                           LDAP_SCOPE_SUBTREE,
                                           LDAP_FILTER_NTDSA,
                                           AttrsToSearch,
                                           FALSE,
                                           NULL,
                                           NULL,
                                           0,
                                           0,
                                           NULL);

    if ( !SearchHandle )
    {

        m_Error.SetLdapErr(hldap,                                           
                           LdapError,                                     
                           L"Search to find Trusted Domain Objects Failed on %ws",
                           DcUsed);
        
        goto Cleanup;
    }

    while(LDAP_SUCCESS == (LdapError = ldap_get_next_page_s( hldap,
                                                             SearchHandle,
                                                             NULL,
                                                             200,
                                                             NULL,
                                                             &SearchResult)))
    {

        NumberOfEntries = ldap_count_entries( hldap, SearchResult );
        if ( NumberOfEntries > 0 )
        {
            LDAPMessage *Entry;
            
            for ( Entry = ldap_first_entry(hldap, SearchResult);
                      Entry != NULL;
                          Entry = ldap_next_entry(hldap, Entry))
            {
                for( Attr = ldap_first_attributeW(hldap, Entry, &pBerElement);
                      Attr != NULL;
                          Attr = ldap_next_attributeW(hldap, Entry, pBerElement))
                {
                    if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                    {
    
                        Values = ldap_get_valuesW( hldap, Entry, Attr );
                        if ( Values && Values[0] )
                        {
                            //
                            // Found it - these are NULL-terminated strings
                            //
                            ExplodedDN = ldap_explode_dn(Values[0],
                                                         FALSE );
                            if (!ExplodedDN) {
                                m_Error.SetMemErr();
                                goto Cleanup;
                            }
    
                            DWORD i = 1;
                            DWORD allocSize = 0;
                            while (ExplodedDN[i]) {
                                allocSize += wcslen(ExplodedDN[i++])+1;
                            }
                            
                            // +2 for a short period of time a extra charater will be required
                            ServerDN = new WCHAR[allocSize+2];
                            if (!ServerDN) {
                                m_Error.SetMemErr();
                                goto Cleanup;    
                            }
    
                            i = 1;
                            *ServerDN = 0;
                            while (ExplodedDN[i]) {
                                wcscat(ServerDN,ExplodedDN[i++]);
                                wcscat(ServerDN,L",");
                            }
                            ServerDN[allocSize-1] = 0;
    
                            LdapError = ldap_value_free(ExplodedDN);
                            ExplodedDN = NULL;
                            if (LDAP_SUCCESS != LdapError) 
                            {
                                m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                                L"Failed to Free values from a ldap search");
                                goto Cleanup;
                            }
    
                            LDAPMessage   *Entry2;
                            BerElement    *pBerElement2 = NULL;
                            WCHAR         **Values2 = NULL;
    
                            LdapError = ldap_search_sW( hldap,
                                                        ServerDN,
                                                        LDAP_SCOPE_BASE,
                                                        LDAP_FILTER_DEFAULT,
                                                        AttrsToSearch2,
                                                        FALSE,
                                                        &SearchResult2);
        
                            if ( LDAP_SUCCESS != LdapError )
                            {
                                
                                m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                                L"Search to find Configuration container failed");
                                goto Cleanup;
                            }
    
                            Entry2 = ldap_first_entry(hldap, SearchResult2);
                            Values2 = ldap_get_valuesW( hldap, Entry2, AttrsToSearch2[0] );
    
                            if (Values2 && *Values2) {
                            
                                DNSname = new WCHAR[wcslen(*Values2)+1];
                                if (!DNSname) {
                                    m_Error.SetMemErr();
                                }
        
                                wcscpy(DNSname,*Values2);
        
                                LdapError = ldap_value_freeW(Values2);
                                Values2 = NULL;
        
                                if (m_Error.isError()) {
                                    goto Cleanup;
                                }
    
                            } else {
    
                                m_Error.SetErr(ERROR_DS_NO_ATTRIBUTE_OR_VALUE,
                                               L"A dnshost name for %ws could not be found",
                                               ServerDN);
    
                            }
                                
                        }
    
                    }

                    if ( SearchResult2 )
                    {
                        ldap_msgfree( SearchResult2 );
                        SearchResult2 = NULL;
                    }

                    LdapError = ldap_value_freeW(Values);
                    Values = NULL;
                    if (LDAP_SUCCESS != LdapError) 
                    {
                        m_Error.SetErr(LdapMapErrorToWin32(LdapError),
                                        L"Failed to Free values from a ldap search");
                        goto Cleanup;
                    }
    
                    if (!AddDcToList(new CDc(DNSname,
                                             0,
                                             NULL,
                                             0,
                                             0,
                                             NULL,
                                             NULL,
                                             NULL)))
                    {
                        goto Cleanup;
                    }
                
                }
            }
        }
    }

    if (LdapError != LDAP_SUCCESS && LdapError != LDAP_NO_RESULTS_RETURNED) {

        m_Error.SetLdapErr(hldap,                                           
                           LdapError,                                     
                           L"Search to find Ntds Settings objects failed on %ws",
                           DcUsed);

        goto Cleanup;
    }

    Cleanup:

    if (Values) {
        ldap_value_free(Values);
    }
    if (SitesDn) {
        delete [] SitesDn;
    }
    if (ExplodedDN) {
        ldap_value_free(ExplodedDN);
    }
    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
    }
    if ( SearchResult2 )
    {
        ldap_msgfree( SearchResult2 );
    }
    if ( m_Error.isError() ) 
    {
        return FALSE;
    }
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\util\renutil.cxx ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    renutil.cxx

ABSTRACT:

    This is the implementation of loader of the sax parser for rendom.exe.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winldap.h>
#include <stdio.h>
#include <stdlib.h>                          
#include <rpc.h>
#include <windns.h>
#include <wtypes.h>
#include <rendom.h>
#include <ntdsapi.h>

#define CR        0xD
#define BACKSPACE 0x8

//From ds\ds\src\sam\server\utility.c
WCHAR InvalidDownLevelChars[] = TEXT("\"/\\[]:|<>+=;?,*")
                                TEXT("\001\002\003\004\005\006\007")
                                TEXT("\010\011\012\013\014\015\016\017")
                                TEXT("\020\021\022\023\024\025\026\027")
                                TEXT("\030\031\032\033\034\035\036\037");
DWORD
AddModOrAdd(
    IN PWCHAR  AttrType,
    IN LPCWSTR  AttrValue,
    IN ULONG  mod_op,
    IN OUT LDAPModW ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_add() function to add an object to the DS. The null-
    terminated array referenced by pppMod grows with each call to this
    routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    mod_op          - LDAP_MOD_ADD/REPLACE
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    DWORD    NumMod;     // Number of entries in the Mod array
    LDAPModW **ppMod;    // Address of the first entry in the Mod array
    LDAPModW *Attr;      // An attribute structure
    PWCHAR   *Values;    // An array of pointers to bervals

    ASSERT(mod_op == LDAP_MOD_ADD || mod_op == LDAP_MOD_REPLACE);

    if (AttrValue == NULL || pppMod == NULL || AttrType == NULL)
        return ERROR_INVALID_PARAMETER;

    //
    // The null-terminated array doesn't exist; create it
    //
    if (*pppMod == NULL) {
        *pppMod = (LDAPMod **)malloc(sizeof (*pppMod));
        if (!*pppMod) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        **pppMod = NULL;
    }

    //
    // Increase the array's size by 1
    //
    for (ppMod = *pppMod, NumMod = 2; *ppMod != NULL; ++ppMod, ++NumMod);
    LDAPModW **tpppMod = NULL;
    tpppMod = (LDAPMod **)realloc(*pppMod, sizeof (*pppMod) * NumMod);
    if (!tpppMod) {

        free(*pppMod);
        return ERROR_NOT_ENOUGH_MEMORY;

    } else {

        *pppMod = tpppMod;

    }

    //
    // Add the new attribute + value to the Mod array
    //
    Values = (PWCHAR  *)malloc(sizeof (PWCHAR ) * 2);
    if (!Values) {
        free(*pppMod);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Values[0] = _wcsdup(AttrValue);
    if (!Values[0]) {
        free(*pppMod);
        free(Values);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    Values[1] = NULL;

    Attr = (LDAPMod *)malloc(sizeof (*Attr));
    if (!Attr) {
        free(*pppMod);
        free(Values);
        free(Values[0]);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    Attr->mod_values = Values;
    Attr->mod_type = _wcsdup(AttrType);
    if (!Attr->mod_type) {
        free(*pppMod);
        free(Values);
        free(Values[0]);
        free(Attr);
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    Attr->mod_op = mod_op;

    (*pppMod)[NumMod - 1] = NULL;
    (*pppMod)[NumMod - 2] = Attr;

    return ERROR_SUCCESS;

} 
 
VOID
AddModMod(
    IN PWCHAR  AttrType,
    IN LPCWSTR  AttrValue,
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Add an attribute (plus values) to a structure that will eventually be
    used in an ldap_modify() function to change an object in the DS.
    The null-terminated array referenced by pppMod grows with each call
    to this routine. The array is freed by the caller using FreeMod().

Arguments:
    AttrType        - The object class of the object.
    AttrValue       - The value of the attribute.
    pppMod          - Address of an array of pointers to "attributes". Don't
                      give me that look -- this is an LDAP thing.

Return Value:
    The pppMod array grows by one entry. The caller must free it with
    FreeMod().
--*/
{
    AddModOrAdd(AttrType, AttrValue, LDAP_MOD_REPLACE, pppMod);
}

VOID
FreeMod(
    IN OUT LDAPMod ***pppMod
    )
/*++
Routine Description:
    Free the structure built by successive calls to AddMod().

Arguments:
    pppMod  - Address of a null-terminated array.

Return Value:
    *pppMod set to NULL.
--*/
{
    DWORD   i, j;
    LDAPMod **ppMod;

    if (!pppMod || !*pppMod) {
        return;
    }

    // For each attibute
    ppMod = *pppMod;
    for (i = 0; ppMod[i] != NULL; ++i) {
        //
        // For each value of the attribute
        //
        for (j = 0; (ppMod[i])->mod_values[j] != NULL; ++j) {
            // Free the value
            if (ppMod[i]->mod_op & LDAP_MOD_BVALUES) {
                free(ppMod[i]->mod_bvalues[j]->bv_val);
            }
            free((ppMod[i])->mod_values[j]);
        }
        free((ppMod[i])->mod_values);   // Free the array of pointers to values
        free((ppMod[i])->mod_type);     // Free the string identifying the attribute
        free(ppMod[i]);                 // Free the attribute
    }
    free(ppMod);        // Free the array of pointers to attributes
    *pppMod = NULL;     // Now ready for more calls to AddMod()
}

ULONG
ReplaceRDN(
    IN OUT WCHAR *DN,
    IN WCHAR *RDN
    )
//
// This function will replace the RDN of the passed in DN with the new RDN.
// The buffer of the DN must be large enought to hold the new DN
//
{
    WCHAR **DNParts=0;
    DWORD i = 0;
    ULONG err = 0;

    if (!DN || !RDN) {
        return ERROR_INVALID_PARAMETER;   
    }
    
    DNParts = ldap_explode_dnW(DN,
                               0);

    if (!DNParts) {
        return LdapMapErrorToWin32(LdapGetLastError());
    }

    //set the String to empty.  The caller is suppose to have ensure that
    //the buffer for DN is large enough to hold the new string.
    DN[0] = L'\0';

    wcscpy(DN,RDN);

    //Skip the RDN
    i++;

    while(0 != DNParts[i]) {
        wcscat(DN,L",");
        wcscat(DN,DNParts[i++]);
    }
    
    if (DNParts) {
        ldap_value_freeW(DNParts);
    }
        
    return ERROR_SUCCESS;

}

ULONG RemoveRootofDn(WCHAR *DN) 
{
    WCHAR **DNParts=0;
    DWORD i = 0;
    ULONG err = 0;

    if (!DN) {
        return ERROR_INVALID_PARAMETER;   
    }
    
    DNParts = ldap_explode_dnW(DN,
                               0);

    if (!DNParts) {
        return LdapMapErrorToWin32(LdapGetLastError());
    }
    
    //set the String to empty.  The new string will
    //be shorter than the old so we don't need to 
    //allocate new memory.
    DN[0] = L'\0';

    wcscpy(DN,DNParts[i++]);
    while(0 != DNParts[i]) {
        wcscat(DN,L",");
        if (wcsstr(DNParts[i],L"DC=")) {
            break;
        }
        wcscat(DN,DNParts[i++]);
    }
        
    if( err = ldap_value_freeW(DNParts) )
    {
        return err;
    }
    
    return ERROR_SUCCESS;
}

DWORD
GetRDNWithoutType(
       WCHAR *pDNSrc,
       WCHAR **pDNDst
       )
/*++

Routine Description:

    Takes in a DN and Returns the RDN.
    
Arguments:

    pDNSrc - the source DN

    pDNDst - the destination for the RDN

Return Values:

    0 if all went well

 --*/
{
    WCHAR **DNParts=0;
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG err = 0;

    ASSERT(pDNSrc);
    ASSERT(pDNDst);

    //init the incoming parameter
    *pDNDst = NULL;

    DNParts = ldap_explode_dnW(pDNSrc,
                               TRUE);
    if (DNParts) {
        DWORD size = wcslen(DNParts[0])+1;
        *pDNDst = new WCHAR[size];
        if (!*pDNDst) {
            Win32Err = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wcscpy(*pDNDst,DNParts[0]);
        
        ULONG err = ldap_value_freeW(DNParts);
        DNParts = NULL;
        if( err )
        {
            Win32Err = LdapMapErrorToWin32(err);
            goto Cleanup;
        }
    }

Cleanup:

    if( DNParts && (err = ldap_value_freeW(DNParts)) 
        && (Win32Err == ERROR_SUCCESS) )
    {
        Win32Err = LdapMapErrorToWin32(err);
    }

    // In case of error free any memory that may have
    // been allocated.
    if (Win32Err != ERROR_SUCCESS) {
        if (*pDNDst) {
            delete [] *pDNDst;
            *pDNDst = NULL;
        }
    }
    
    return Win32Err;
}


DWORD
TrimDNBy(
       WCHAR *pDNSrc,
       ULONG cava,
       WCHAR **pDNDst
       )
/*++

Routine Description:

    Takes in a dsname and copies the first part of the dsname to the
    dsname it returns.  The number of AVAs to remove are specified as an
    argument.

Arguments:

    pDNSrc - the source Dsname

    cava - the number of AVAs to remove from the first name

    pDNDst - the destination Dsname

Return Values:

    0 if all went well, the number of AVAs we were unable to remove if not

 N.B. This routine is exported to in-process non-module callers
--*/
{
    ASSERT(pDNSrc);
    ASSERT(pDNDst);

    //init the incoming parameter
    *pDNDst = NULL;
    DWORD cDNParts = 0;
    DWORD i = 0;

    WCHAR **DNParts=0;
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG err = 0;

    DNParts = ldap_explode_dnW(pDNSrc,
                               0);
    if (DNParts) {
        DWORD size = wcslen(pDNSrc)+1;
        *pDNDst = new WCHAR[size];
        if (!*pDNDst) {
           Win32Err = ERROR_NOT_ENOUGH_MEMORY;
           goto Cleanup;
        }

        while (DNParts[i]){
        
            cDNParts++;
            i++;

        }

        if (cava >= cDNParts) {
            Win32Err = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        wcscpy(*pDNDst,DNParts[cava]);
        i = cava+1;
        while(0 != DNParts[i]){
            wcscat(*pDNDst,L",");
            wcscat(*pDNDst,DNParts[i++]);
        }
            
    }

Cleanup:

    if( DNParts && (err = ldap_value_freeW(DNParts)) 
        && (Win32Err == ERROR_SUCCESS) )
    {
        Win32Err = LdapMapErrorToWin32(err);
    }

    // In case of error free any memory that may have
    // been allocated.
    if (Win32Err != ERROR_SUCCESS) {
        if (*pDNDst) {
            delete [] *pDNDst;
            *pDNDst = NULL;
        }
    }
    
    return Win32Err;
}

INT
GetPassword(
    WCHAR *     pwszBuf,
    DWORD       cchBufMax,
    DWORD *     pcchBufUsed
    )
/*++

Routine Description:

    Retrieve password from command line (without echo).
    Code stolen from LUI_GetPasswdStr (net\netcmd\common\lui.c).

Arguments:

    pwszBuf - buffer to fill with password
    cchBufMax - buffer size (incl. space for terminating null)
    pcchBufUsed - on return holds number of characters used in password

Return Values:

    DRAERR_Success - success
    other - failure

--*/
{
    WCHAR   ch;
    WCHAR * bufPtr = pwszBuf;
    DWORD   c;
    INT     err;
    INT     mode;

    ASSERT(pwszBuf);
    ASSERT(pcchBufUsed);

    cchBufMax -= 1;    /* make space for null terminator */
    *pcchBufUsed = 0;               /* GP fault probe (a la API's) */
    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), (LPDWORD)&mode)) {
        return GetLastError();
    }
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
        if (!err || c != 1)
            ch = 0xffff;

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
            break;

        if (ch == BACKSPACE) {  /* back up one or two */
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != pwszBuf) {
                bufPtr--;
                (*pcchBufUsed)--;
            }
        }
        else {

            *bufPtr = ch;

            if (*pcchBufUsed < cchBufMax)
                bufPtr++ ;                   /* don't overflow buf */
            (*pcchBufUsed)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = L'\0';         /* null terminate the string */
    putchar('\n');

    if (*pcchBufUsed > cchBufMax)
    {
        wprintf(L"Password too long!\n");
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}

int
PreProcessGlobalParams(
    IN OUT    INT *    pargc,
    IN OUT    LPWSTR** pargv,
    SEC_WINNT_AUTH_IDENTITY_W *& gpCreds      
    )
/*++

Routine Description:

    Scan command arguments for user-supplied credentials of the form
        [/-](u|user):({domain\username}|{username})
        [/-](p|pw|pass|password):{password}
    Set credentials used for future DRS RPC calls and LDAP binds appropriately.
    A password of * will prompt the user for a secure password from the console.

    CODE.IMPROVEMENT: The code to build a credential is also available in
    ntdsapi.dll\DsMakePasswordCredential().

Arguments:

    pargc
    pargv


Return Values:

    ERROR_SUCCESS - success
    other - failure

--*/
{
    INT     ret = 0;
    INT     iArg;
    LPWSTR  pszOption;

    DWORD   cchOption;
    LPWSTR  pszDelim;
    LPWSTR  pszValue;
    DWORD   cchValue;

    static SEC_WINNT_AUTH_IDENTITY_W  gCreds = { 0 };

    for (iArg = 1; iArg < *pargc; ){
        if (((*pargv)[iArg][0] != L'/') && ((*pargv)[iArg][0] != L'-')){
            // Not an argument we care about -- next!
            iArg++;
        } else {
            pszOption = &(*pargv)[iArg][1];
            pszDelim = wcschr(pszOption, L':');

        cchOption = (DWORD)(pszDelim - (*pargv)[iArg]);

        if (    (0 == _wcsnicmp(L"p:",        pszOption, cchOption))
            || (0 == _wcsnicmp(L"pw:",       pszOption, cchOption))
            || (0 == _wcsnicmp(L"pwd:",      pszOption, cchOption))
            || (0 == _wcsnicmp(L"pass:",     pszOption, cchOption))
            || (0 == _wcsnicmp(L"password:", pszOption, cchOption)) ){
            // User-supplied password.
          //            char szValue[ 64 ] = { '\0' };

        pszValue = pszDelim + 1;
        cchValue = 1 + wcslen(pszValue);

        if ((2 == cchValue) && (L'*' == pszValue[0])){
            // Get hidden password from console.
            cchValue = 64;

            gCreds.Password = new WCHAR[cchValue];

            if (NULL == gCreds.Password){
                wprintf( L"No memory.\n" );
            return ERROR_NOT_ENOUGH_MEMORY;
            }

            wprintf( L"Password: ");

            ret = GetPassword(gCreds.Password, cchValue, &cchValue);
        } else {
            // Get password specified on command line.
            gCreds.Password = new WCHAR[cchValue];

            if (NULL == gCreds.Password){
                wprintf( L"No memory.\n");
            return ERROR_NOT_ENOUGH_MEMORY;
            }
            wcscpy(gCreds.Password, pszValue); //, cchValue);

        }

        // Next!
        memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
        --(*pargc);
        } else if (    (0 == _wcsnicmp(L"u:",    pszOption, cchOption))
               || (0 == _wcsnicmp(L"user:", pszOption, cchOption)) ){


            // User-supplied user name (and perhaps domain name).
            pszValue = pszDelim + 1;
        cchValue = 1 + wcslen(pszValue);

        pszDelim = wcschr(pszValue, L'\\');

        if (NULL == pszDelim){
            // No domain name, only user name supplied.
            wprintf( L"User name must be prefixed by domain name.\n");
            return ERROR_INVALID_PARAMETER;
        }

        gCreds.Domain = new WCHAR[cchValue];
        gCreds.User = gCreds.Domain + (int)(pszDelim+1 - pszValue);

        if (NULL == gCreds.Domain){
            wprintf( L"No memory.\n");
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcsncpy(gCreds.Domain, pszValue, cchValue);
        // wcscpy(gCreds.Domain, pszValue); //, cchValue);
        gCreds.Domain[ pszDelim - pszValue ] = L'\0';

        // Next!
        memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
            sizeof(**pargv)*(*pargc-(iArg+1)));
        --(*pargc);
        } else {
            iArg++;
        }
    }
    }

    if (NULL == gCreds.User){
        if (NULL != gCreds.Password){
        // Password supplied w/o user name.
        wprintf( L"Password must be accompanied by user name.\n" );
            ret = ERROR_INVALID_PARAMETER;
        } else {
        // No credentials supplied; use default credentials.
        ret = ERROR_SUCCESS;
        }
        gpCreds = NULL;
    } else {
        gCreds.PasswordLength = gCreds.Password ? wcslen(gCreds.Password) : 0;
        gCreds.UserLength   = wcslen(gCreds.User);
        gCreds.DomainLength = gCreds.Domain ? wcslen(gCreds.Domain) : 0;
        gCreds.Flags        = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        // CODE.IMP: The code to build a SEC_WINNT_AUTH structure also exists
        // in DsMakePasswordCredentials.  Someday use it

        // Use credentials in DsBind and LDAP binds
        gpCreds = &gCreds;
    }

    return ret;
}

BOOLEAN
ValidateNetbiosName(
    IN  PWSTR Name
    )

/*++

Routine Description:

    Determines whether a computer name is valid or not

Arguments:

    Name    - pointer to zero terminated wide-character computer name
    Length  - of Name in characters, excluding zero-terminator

Return Value:

    BOOLEAN
        TRUE    Name is valid computer name
        FALSE   Name is not valid computer name

--*/

{
    ASSERT(Name);

    DWORD Length = wcslen(Name);

    if (1==DnsValidateName_W(Name,DnsNameHostnameFull))
    {
        return(FALSE);
    }

    //
    // Fall down to netbios name validation
    //

    if (Length > MAX_COMPUTERNAME_LENGTH || Length < 1) {
        return FALSE;
    }

    //
    // Don't allow leading or trailing blanks in the computername.
    //

    if ( Name[0] == ' ' || Name[Length-1] == ' ' ) {
        return(FALSE);
    }

    return (BOOLEAN)((ULONG)wcscspn(Name, InvalidDownLevelChars) == Length);
}

int
MyStrToOleStrN(LPOLESTR pwsz, int cchWideChar, LPCSTR psz)
{
    int i;
    i=MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cchWideChar);
    if (!i)
    {
        //DBG_WARN("MyStrToOleStrN string too long; truncated");
        pwsz[cchWideChar-1]=0;
    }
    else
    {
        ZeroMemory(pwsz+i, sizeof(OLECHAR)*(cchWideChar-i));
    }
    return i;
}

WCHAR *
Convert2WChars(char * pszStr)
{
    ASSERT(pszStr);

    WCHAR * pwszStr = (WCHAR *)LocalAlloc(LMEM_FIXED, ((sizeof(WCHAR))*(strlen(pszStr) + 2)));
    if (pwszStr)
    {
        HRESULT hr = MyStrToOleStrN(pwszStr, (strlen(pszStr) + 1), pszStr);
        if (FAILED(hr))
        {
            LocalFree(pwszStr);
            pwszStr = NULL;
        }
    } else {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return pwszStr;
}

CHAR * 
Convert2Chars(LPCWSTR lpWideCharStr)
{
	int cWchar;

	ASSERT ( lpWideCharStr );

	cWchar= wcslen(lpWideCharStr)+1;
	LPSTR lpMultiByteStr = ( CHAR * ) LocalAlloc(LMEM_FIXED, cWchar * sizeof ( CHAR ) );
    if ( !lpMultiByteStr )
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

	int Chars = WideCharToMultiByte(  
                            CP_ACP,			    // code page
                            0,					// character-type options
                            lpWideCharStr,		// address of string to map
                            -1,					// number of bytes in string
                            lpMultiByteStr,	    // address of wide-character buffer
                            cWchar*sizeof(CHAR) ,// size of buffer
                            NULL,
                            NULL
                            );

    if (Chars == 0) {
        return NULL;
    }

     return lpMultiByteStr;
}

WCHAR* Tail(WCHAR *dnsName,
            BOOL  Allocate /*= TRUE*/)
{
    if (!dnsName) {
        return NULL;
    }

    WCHAR *pdnsName = dnsName;
    while (*pdnsName != L'.' && *pdnsName != L'\0') {
        pdnsName++;
    }
    if (*pdnsName == L'\0') {
        return NULL;    
    }
    pdnsName++;

    if (Allocate) {

        WCHAR *ret = new WCHAR[wcslen(pdnsName)+1];
        if (!ret) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
    
        wcscpy(ret,pdnsName);
    
        return ret;

    }

    return pdnsName;
}

//gobal for the eventhandle function
extern HANDLE gSaveandExit;
HANDLE ghThreadEventHandler = NULL;


DWORD 
WINAPI 
ThreadEventHandler(
    LPVOID lpThreadParameter
    )
{
    DWORD Win32Err = ERROR_SUCCESS;
    DWORD WaitResult;
    WaitResult = WaitForSingleObject(gSaveandExit,       // handle to object
                                     INFINITE            // time-out interval
                                     );
    if (WAIT_OBJECT_0 != WaitResult) {
        CRenDomErr::SetErr(GetLastError(),
                           L"Failed wait on exit event"
                           );
        goto Exit;
    }

    CEnterprise *enterprise = (CEnterprise*)lpThreadParameter;

    enterprise->GenerateDcListForSave();
    if (enterprise->Error()) {
        goto Exit;
    }

    Exit:

    return Win32Err;
                        
}


BOOL 
WINAPI 
RendomHandlerRoutine(
  DWORD dwCtrlType   //  control signal type
  )
/*++

Routine Description:

    Handles cleanup if application is being terminated early

Arguments:

    dwCtrlType - control signal type
    
Return Value:

--*/
{
    DWORD ButtonPushed = 0;
    DWORD WaitResult;

    switch(dwCtrlType) {
    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
        ButtonPushed = MessageBoxW(NULL,                                 // handle to owner window
                                   L"Are you sure you want to quit",     // text in message box
                                   L"Rendom",                            // message box title
                                   MB_YESNO | MB_ICONQUESTION 
                                   | MB_SETFOREGROUND | MB_TASKMODAL     // message box style
                                   );
        if (IDYES == ButtonPushed) {
            wprintf(L"Saving work and Exiting\r\n");
            if ( !SetEvent(gSaveandExit) ) 
            {
                wprintf(L"Failed to save work : %d\r\n",
                        GetLastError());
            }
            WaitResult = WaitForSingleObject(ghThreadEventHandler,// handle to object
                                             INFINITE             // time-out interval
                                             );
            if (WAIT_OBJECT_0 != WaitResult) {
                wprintf(L"Failed wait on exit thread : %d\r\n",
                        GetLastError());
            }
            return FALSE;
        } else {
            return TRUE;
        }
        break;
    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
        WaitResult = WaitForSingleObject(ghThreadEventHandler,// handle to object
                                         INFINITE             // time-out interval
                                         );
        if (WAIT_OBJECT_0 != WaitResult) {
            wprintf(L"Failed wait on exit thread : %d\r\n",
                    GetLastError());
        }
        return FALSE;
        break;
    }

    return TRUE;

}

BOOL
ProcessHandlingInit(CEnterprise *enterprise)
/*++

Routine Description:

    Handles cleanup if application is being terminated early

Arguments:
    
Return Value:

    Win32 Error

--*/
{
    DWORD ThreadID = 0;

    //setup event handler
    if (!SetConsoleCtrlHandler(RendomHandlerRoutine,
                               TRUE))
    {
        CRenDomErr::SetErr(GetLastError(),
                           L"Failed to set up event handler"
                           );
        return FALSE;
    }

    gSaveandExit = CreateEvent(NULL, // SD
                               TRUE, // reset type
                               FALSE,// initial state
                               NULL  // object name
                               );
    if (!gSaveandExit) {
        CRenDomErr::SetErr(GetLastError(),
                           L"Failed to set up exit event"
                           );
        return FALSE;

    }

    ghThreadEventHandler =  CreateThread(NULL,                 // SD
                                         0,                    // initial stack size
                                         ThreadEventHandler,   // thread function
                                         enterprise,           // thread argument
                                         0,                    // creation option
                                         &ThreadID             // thread identifier
                                         );
    if (!ghThreadEventHandler) {
        CRenDomErr::SetErr(GetLastError(),
                           L"Failed to set up exit event thread"
                           );
        return FALSE;

    }

    
    return TRUE;


}

WCHAR*
GetLdapSamFilter(
    DWORD SamAccountType
    )
{
    static WCHAR FilterBuf[64] = {0};
    WCHAR NumBuf[32] = {0};

    return wcscat(wcscpy(FilterBuf,L"samAccountType="),_itow(SamAccountType,NumBuf,10));
}

DWORD
WrappedMakeSpnW(
               WCHAR   *ServiceClass,
               WCHAR   *ServiceName,
               WCHAR   *InstanceName,
               USHORT  InstancePort,
               WCHAR   *Referrer,
               DWORD   *pcbSpnLength, // This is the num of bytes without the NULL
               WCHAR  **ppszSpn
               )
//this function wraps DsMakeSpnW for the purpose of memory
{
    DWORD cchSpnLength=128;
    WCHAR SpnBuff[128];
    DWORD err;

    cchSpnLength = 128;
    err = DsMakeSpnW(ServiceClass,
                     ServiceName,
                     InstanceName,
                     InstancePort,
                     Referrer,
                     &cchSpnLength,
                     SpnBuff);

    if ( err && err != ERROR_BUFFER_OVERFLOW )
    {
        return err;
    }

    *ppszSpn = new WCHAR[cchSpnLength];
    if ( !*ppszSpn )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    *pcbSpnLength = cchSpnLength * sizeof(WCHAR);

    if ( err == ERROR_BUFFER_OVERFLOW )
    {
        err = DsMakeSpnW(ServiceClass,
                         ServiceName,
                         InstanceName,
                         InstancePort,
                         Referrer,
                         &cchSpnLength,
                         *ppszSpn);
        if ( err )
        {
            if ( *ppszSpn )
                free(*ppszSpn);
            return err;
        }
    } else
    {
        memcpy(*ppszSpn, SpnBuff, *pcbSpnLength);
    }
    ASSERT(!err);
    ASSERT(*pcbSpnLength == (sizeof(WCHAR) * (1 + wcslen(*ppszSpn))));
    // Drop the null off.
    *pcbSpnLength -= sizeof(WCHAR);
    return 0;
}

LPWSTR
Win32ErrToString (
    IN    DWORD            dwWin32Err
    )
/*++

Routine Description:

    Converts a win32 error code to a string; useful for error reporting.
    This was basically stolen from repadmin.

Arguments:

    dwWin32Err        (IN ) -    The win32 error code.

Return Value:

    The converted string.  This is part of system memory and does not
    need to be freed.

--*/
{
    #define ERROR_BUF_LEN    4096
    static WCHAR        szError[ERROR_BUF_LEN];

    if (FormatMessageW (
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dwWin32Err,
        GetSystemDefaultLangID (),
        szError,
        ERROR_BUF_LEN,
        NULL) != NO_ERROR)
    szError[wcslen (szError) - 2] = '\0';    // Remove \r\n

    else swprintf (szError, L"Win32 Error %d", dwWin32Err);

    return szError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\util\xml.cxx ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    xml.cxx

ABSTRACT:

    This is the implementation of the xml parser for rendom.exe.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wchar.h>
#include <wincrypt.h>
#include <base64.h>

#define DEBSUB "RENDOM:"

#include "debug.h"

#include "rendom.h"
#include "DomainListparser.h"
#include "DcListparser.h"
#include "renutil.h"

#define INT_SIZE_LENGTH 20;

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0)

CXMLAttributeBlock::CXMLAttributeBlock(const WCHAR *p_Name,
                                       WCHAR *p_Value)
{
    ASSERT(p_Name);
    m_Name = new WCHAR[wcslen(p_Name)+1];
    if (!m_Name) {
        m_Error.SetMemErr();
        return;
    }
    wcscpy(m_Name,p_Name);
    m_Value = p_Value;
    
}

CXMLAttributeBlock::~CXMLAttributeBlock()
{
    if (m_Name) {
        delete [] m_Name;
    }
    if (m_Value) {
        delete [] m_Value;
    }
}

//returns a copy of the Name value of
//the CXMLAttributeBlock
WCHAR* CXMLAttributeBlock::GetName(BOOL ShouldAllocate /*= TRUE*/)
{
    if (ShouldAllocate) {
        WCHAR *ret = new WCHAR[wcslen(m_Name)+1];
        if (!ret) {
            m_Error.SetMemErr();
            return NULL;
        }
        wcscpy(ret,m_Name);
        return ret;
    }

    return m_Name;
}

//returns a copy of the value of
//the CXMLAttributeBlock
WCHAR* CXMLAttributeBlock::GetValue(BOOL ShouldAllocate /*= TRUE*/)
{
    if (!m_Value) {
        return NULL;
    }
    if (ShouldAllocate) {
        WCHAR *ret = new WCHAR[wcslen(m_Value)+1];
        if (!ret) {
            m_Error.SetMemErr();
            return NULL;
        }
        wcscpy(ret,m_Value);
        return ret;    
    }
    return m_Value;
}

CXMLGen::CXMLGen()
{
    m_ErrorNum = 30000;  //starting error number
    m_xmldoc.resize(10000);
    
}

CXMLGen::~CXMLGen()
{

}

BOOL CXMLGen::WriteScriptToFile(WCHAR* filename)
{
    HANDLE hFile = NULL;
    DWORD bytesWritten = 0;
    WCHAR ByteOrderMark = (WCHAR)0xFEFF;
    BOOL  bsuccess = TRUE;

    ASSERT(filename);
    ASSERT(m_xmldoc.size()>0);

    hFile =  CreateFile(filename,               // file name
                        GENERIC_WRITE,          // access mode
                        0,                      // share mode
                        NULL,                   // SD
                        CREATE_ALWAYS,          // how to create
                        FILE_ATTRIBUTE_NORMAL,  // file attributes
                        NULL                    // handle to template file
                        );
    if (INVALID_HANDLE_VALUE == hFile) {
        m_Error.SetErr(GetLastError(),
                        L"Could not create File %s",
                        filename);
        return FALSE;
    }

    bsuccess = WriteFile(hFile,                    // handle to file
                         &ByteOrderMark,            // data buffer
                         sizeof(WCHAR),            // number of bytes to write
                         &bytesWritten,            // number of bytes written
                         NULL                      // overlapped buffer
                         );
    if (!bsuccess)
    {
        m_Error.SetErr(GetLastError(),
                        L"Could not Write to File %s",
                        filename);
        CloseHandle(hFile);
        return FALSE;
    }


    bsuccess = WriteFile(hFile,                          // handle to file
                         m_xmldoc.c_str(),                       // data buffer
                         m_xmldoc.size()*sizeof(WCHAR), // number of bytes to write
                         &bytesWritten,                  // number of bytes written
                         NULL                            // overlapped buffer
                         );
    CloseHandle(hFile);
    if (!bsuccess)
    {
        m_Error.SetErr(GetLastError(),
                        L"Could not Write to File %s",
                        filename);
        return FALSE;
    }

    return TRUE;

}

BOOL CXMLGen::StartDcList()
{
    try {
        m_xmldoc = L"<?xml version =\"1.0\"?>\r\n<DcList>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;    
}

BOOL CXMLGen::EndDcList()
{
    try{
        m_xmldoc += L"\r\n</DcList>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }


    return TRUE;    
}

BOOL CXMLGen::WriteSignature(WCHAR *signature)
{
    try{
        m_xmldoc += (std::wstring)L"\r\n\t<Signature>" + (std::wstring)signature + (std::wstring)L"</Signature>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }


    return TRUE;

}

BOOL CXMLGen::DctoXML(CDc *dc)
{
    if (!dc) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"NULL passed to DctoXML");
        return FALSE;
    }

    WCHAR *EmptyString = L"\0";
    WCHAR *buf = NULL;
    WCHAR *Password = NULL;
    WCHAR Error[20];
    WCHAR *LastError = dc->GetLastErrorMsg();
    WCHAR *FatalError = dc->GetLastFatalErrorMsg();
    BYTE  encodedbytes[100];
    WCHAR *State;
    DWORD dwErr = ERROR_SUCCESS;

    switch(dc->GetState()){
    case 0:
        State = L"Initial";
        break;
    case 1:
        State = L"Prepared";
        break;
    case 2:
        State = L"Done";
        break;
    case 3:
        State = L"Error";
        break;
    }

    _itow(dc->GetLastError(),Error,10);

    if (!LastError) {
        LastError = EmptyString;
    }
    if (!FatalError) {
        FatalError = EmptyString;
    }

    if (dc->GetPasswordSize() != 0) {
        if (dwErr = base64encode(dc->GetPassword(), 
                                 dc->GetPasswordSize(), 
                                 (LPSTR)encodedbytes,
                                 100,
                                 NULL)) {
    
            m_Error.SetErr(RtlNtStatusToDosError(dwErr),
                            L"Error encoding Password");
            
            return FALSE;
        }
    
        Password = Convert2WChars((LPSTR)encodedbytes);
        if (!Password) {
            m_Error.SetMemErr();
            return FALSE;
        }
    } else  {
        Password = EmptyString;
    }
    
    try{
        m_xmldoc += (std::wstring)L"\r\n\t<DC>\r\n\t\t<Name>" + (std::wstring)dc->GetName() + (std::wstring)L"</Name>\r\n\t\t<State>" +
            (std::wstring)State + (std::wstring)L"</State>\r\n\t\t<Password>" + (std::wstring)Password + (std::wstring)L"</Password>\r\n\t\t<LastError>" +
            (std::wstring)Error + (std::wstring)L"</LastError>\r\n\t\t<LastErrorMsg>" + (std::wstring)LastError + (std::wstring)L"</LastErrorMsg>\r\n\t\t<FatalErrorMsg>" +
            (std::wstring)FatalError + (std::wstring)L"</FatalErrorMsg>\r\n\t\t<Retry></Retry>\r\n\t</DC>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }


    return TRUE;
}

BOOL CXMLGen::WriteHash(WCHAR *hash)
{
    try {
        m_xmldoc += (std::wstring)L"\r\n\t<Hash>" + (std::wstring)hash + (std::wstring)L"</Hash>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;

}

BOOL CXMLGen::StartDomainList()
{
    try{
        m_xmldoc = L"<?xml version =\"1.0\"?>\r\n<Forest>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }
    
    return TRUE;
}

BOOL CXMLGen::StartScript()
{
    try{
        m_xmldoc = RENDOM_SCRIPT_PREFIX;
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;
}

BOOL CXMLGen::EndDomainList()
{
    try{
        m_xmldoc += L"\r\n</Forest>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;
}

BOOL CXMLGen::EndScript()
{
    try{
        m_xmldoc += L"\r\n</NTDSAscript>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;
} 

BOOL CXMLGen::StartAction(WCHAR *Actionname,BOOL Preprocess)
{
    if (!Actionname) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Actionname passed to StartAction was NULL");
        return FALSE;
    }

    try{
        if (Preprocess) {
            m_xmldoc += (std::wstring)L"\r\n\t<action name=\"" + (std::wstring)Actionname +
                (std::wstring)L"\" stage=\"preprocess\">";
        } else {
            m_xmldoc += (std::wstring)L"\r\n\t<action name=\"" + (std::wstring)Actionname +
                (std::wstring)L"\">";
        }
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }
    
    return TRUE;
}

BOOL CXMLGen::EndAction()
{
    try{
        m_xmldoc += L"\r\n\t</action>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;
}

BOOL CXMLGen::AddDomain(CDomain *d,CDomain *ForestRoot)
{
    std::wstring Guid = d->GetGuid(FALSE);
    std::wstring DnsRoot = d->GetDnsRoot(FALSE);
    WCHAR *NetBiosName = d->GetNetBiosName(FALSE);

    if (m_Error.isError()) {
        goto Cleanup;
    }

    //We will not record extern or disabled NCs in the domainlist file
    if (d->isDisabled() || d->isExtern()) {
        return TRUE;
    }

    try{

        m_xmldoc +=  (std::wstring)L"\r\n\t<Domain>";

        if (d==ForestRoot) {
            
            m_xmldoc += L"\r\n\t\t<!-- ForestRoot -->";
    
        }
    
        if (!d->isDomain() && !d->isDisabled()) {
    
            m_xmldoc += L"\r\n\t\t<!-- PartitionType:Application -->";
    
        } else if (d->isDisabled()) {
    
            m_xmldoc += L"\r\n\t\t<!-- PartitionType:Disabled -->";
    
        } else if (d->isExtern()) {

            m_xmldoc += L"\r\n\t\t<!-- PartitionType:External -->";

        } else {

            ;//m_xmldoc += L"\r\n\t\t<!-- PartitionType:Domain -->";

        }
    
        if (!NetBiosName) {
            NetBiosName = L"";
        }
    
        m_xmldoc +=  (std::wstring)L"\r\n\t\t<Guid>" + Guid + (std::wstring)L"</Guid>\r\n\t\t<DNSname>" + 
            DnsRoot + (std::wstring)L"</DNSname>\r\n\t\t<NetBiosName>" + (std::wstring)NetBiosName + 
            (std::wstring)L"</NetBiosName>\r\n\t\t<DcName></DcName>\r\n\t</Domain>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }
    
    Cleanup:
    
    return TRUE;
}

BOOL CXMLGen::Move(WCHAR *FromPath,
                   WCHAR *ToPath,
                   DWORD Metadata /* = 0 */)
{
    if (!FromPath || !ToPath) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Move was passed a NULL");
        return FALSE;
    }
    if (Metadata != 0 && Metadata != 1) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Metadata passed to update is %d.  This is not a valid value.",
                        Metadata);
        return FALSE;
    }

    WCHAR MetadataBuf[] = { 0, 0 };

    try{
        m_xmldoc += (std::wstring)L"\r\n\t\t<move path=\"dn:" + (std::wstring)FromPath + (std::wstring)L"\" metadata=\"" + (std::wstring)_itow(Metadata,MetadataBuf,10) +
            (std::wstring)L"\">\r\n\t\t\t<to path=\"dn:" + (std::wstring)ToPath +(std::wstring) L"\"/>\r\n\t\t</move>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;
}

BOOL CXMLGen::EndifInstantiated()
{
    try{
        m_xmldoc += L"\r\n\t\t\t</action>\r\n\t\t\t</then>\r\n\t\t</condition>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;

}

BOOL CXMLGen::Cardinality(WCHAR *path,
                          WCHAR *filter,
                          DWORD cardinality,
                          WCHAR *ErrorMsg)
{
    WCHAR ErrorNumBuf[30]       = {0};
    WCHAR cardinalityNumBuf[30] = {0};

    try{
        m_xmldoc +=  (std::wstring)L"\r\n\t\t<predicate test=\"cardinality\" type=\"subTree\" path=\"" + (std::wstring)path + 
            (std::wstring)L"\" filter=\"" + (std::wstring)filter + (std::wstring)L"\" cardinality=\"" + (std::wstring)_itow(cardinality,cardinalityNumBuf,10) + 
            (std::wstring)L"\" errMessage=\"" + (std::wstring)ErrorMsg + (std::wstring)L"\" returnCode=\"" + 
            (std::wstring)_itow(m_ErrorNum++,ErrorNumBuf,10) + (std::wstring)L"\"/>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;
}

BOOL CXMLGen::Compare(WCHAR *path,
                      WCHAR *Attribute,
                      WCHAR *value,
                      WCHAR *errMessage)
{
    WCHAR ErrorNumBuf[30] = {0};

    try{
        m_xmldoc += (std::wstring)L"\r\n\t\t<predicate test=\"compare\" path=\"" + (std::wstring)path + 
            (std::wstring)L"\" attribute=\"" + (std::wstring)Attribute + (std::wstring)L"\" attrval=\"" + (std::wstring)value +
            (std::wstring)L"\" defaultvalue=\"0\" type=\"base\" errMessage=\"" + (std::wstring)errMessage +
            (std::wstring)L"\" returnCode=\"" + (std::wstring)_itow(m_ErrorNum++,ErrorNumBuf,10) + 
            (std::wstring)L"\"/>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;

}

BOOL CXMLGen::Not(WCHAR *errMessage)
{
    WCHAR ErrorNumBuf[30] = {0};

    try{
        m_xmldoc += (std::wstring)L"\r\n\t\t<predicate test=\"not\" errMessage=\"" + (std::wstring)errMessage +
            (std::wstring)L"\" returnCode=\"" + (std::wstring)_itow(m_ErrorNum++,ErrorNumBuf,10) + (std::wstring)L"\">";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;
}

BOOL CXMLGen::EndNot()
{
    try{
        m_xmldoc += L"\r\n\t\t</predicate>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;
}

BOOL CXMLGen::Instantiated(WCHAR *path,
                           WCHAR *errMessage,
                           WCHAR *InstanceType /* = L"write"*/)
{
    if (!path) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Instantiated was passed a NULL");
        return FALSE;
    }

    WCHAR ErrorNumBuf[30] = {0};

    try{
        m_xmldoc += (std::wstring)L"\r\n\t\t<predicate test=\"instantiated\" instancetype=\"" + (std::wstring)InstanceType + 
            (std::wstring)L"\" path=\"" + (std::wstring)path + (std::wstring)L"\" type=\"base\" errMessage=\"" + 
            (std::wstring)errMessage + (std::wstring)L"\" returnCode=\"" + (std::wstring)_itow(m_ErrorNum++,ErrorNumBuf,10) + 
            (std::wstring)L"\"/>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;

}

BOOL CXMLGen::ifInstantiated(WCHAR *guid,
                             WCHAR *InstanceType /* = L"write"*/)
{
    if (!guid) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"ifInstantiated was passed a NULL");
        return FALSE;
    }

    try{
        m_xmldoc += (std::wstring)L"\r\n\t\t<condition>\r\n\t\t\t<if>\r\n\t\t\t\t<predicate test=\"instantiated\" instancetype=\"" + 
            (std::wstring)InstanceType +  (std::wstring)L"\" path=\"guid:" + (std::wstring)guid + 
            (std::wstring)L"\" type=\"base\"/>\r\n\t\t\t</if>\r\n\t\t\t<then>\r\n\t\t\t<action>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;
}

BOOL CXMLGen::Update(WCHAR *Object,
                     CXMLAttributeBlock **attblock,
                     DWORD Metadata /* = 0 */)
{
    if (!Object) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Move was passed a NULL");
        return FALSE;
    }
    if (Metadata != 0 && Metadata != 1) {
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Metadata passed to update is %d.  This is not a valid value.",
                        Metadata);
        return FALSE;
    }

    WCHAR MetadataBuf[] = { 0, 0 };

    try{
        m_xmldoc += (std::wstring)L"\r\n\t\t<update path=\"" + 
            (std::wstring)(Object[0] == L'$'?L"":L"dn:") + 
            (std::wstring)Object + 
            (std::wstring)L"\" metadata=\"" + (std::wstring)_itow(Metadata,MetadataBuf,10) +
            L"\">";
    
        for (DWORD i = 0 ;attblock[i]; i ++) 
        {
            
            m_xmldoc += (std::wstring)L"\r\n\t\t\t<" + (std::wstring)attblock[i]->GetName(FALSE) + (std::wstring)L" op=\"" + 
                (std::wstring)(attblock[i]->GetValue(FALSE)?L"replace\">":L"delete\">") +
                (std::wstring)(attblock[i]->GetValue(FALSE)?attblock[i]->GetValue(FALSE):L"") + (std::wstring)L"</" + 
                (std::wstring)attblock[i]->GetName(FALSE) + (std::wstring)L">";
    
        }
    
        m_xmldoc += L"\r\n\t\t</update>";
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;
}

VOID CXMLGen::DumpScript()
{
    _putws(m_xmldoc.c_str());
}

// {0916C8E3-3431-4586-AF77-44BD3B16F961}
static const GUID guidDomainRename = 
{ 0x916c8e3, 0x3431, 0x4586, { 0xaf, 0x77, 0x44, 0xbd, 0x3b, 0x16, 0xf9, 0x61 } };

BOOL CXMLGen::AddSignatureToScript(WCHAR *signature)
{
    try{
        m_xmldoc += signature;
    }
    catch(...)
    {
        m_Error.SetMemErr();
        return FALSE;
    }

    return TRUE;
}

BOOL CXMLGen::UploadScript(LDAP *hLdapConn,PWCHAR ObjectDN, CDcList *dclist)
{
    LDAPModW         **pLdapMod = NULL;
    DWORD             dwErr = ERROR_SUCCESS;
    FILE             *fpScript;
    DWORD             dwFileLen, dwEncoded, dwDecoded;
    CHAR             *pScript, *pEndScript;
    WCHAR            *pwScript;
    BYTE              encodedbytes[100];

    HCRYPTPROV        hCryptProv = (HCRYPTPROV) NULL; 
    HCRYPTHASH        hHash = (HCRYPTHASH)NULL;
    HCRYPTHASH        hDupHash = (HCRYPTHASH)NULL;
    BYTE              *pbHashBody = NULL;
    DWORD             cbHashBody = 0;
    BYTE              *pbSignature = NULL;
    DWORD             cbSignature = 0;

    pbHashBody =  new BYTE[20];
    if (!pbHashBody) {
        m_Error.SetMemErr();
        return FALSE;
    }
    pbSignature = new BYTE[20];
    if (!pbSignature) {
        m_Error.SetMemErr();
        return FALSE;
    } 
    cbSignature = cbHashBody = 20;

    __try {
        // Get a handle to the default PROV_RSA_FULL provider.

        if(!CryptAcquireContext(&hCryptProv, 
                                NULL, 
                                NULL, 
                                PROV_RSA_FULL, 
                                CRYPT_SILENT /*| CRYPT_MACHINE_KEYSET*/)) {

            dwErr = GetLastError();

            if (dwErr == NTE_BAD_KEYSET) {

                dwErr = 0;

                if(!CryptAcquireContext(&hCryptProv, 
                                        NULL, 
                                        NULL, 
                                        PROV_RSA_FULL, 
                                        CRYPT_SILENT | /*CRYPT_MACHINE_KEYSET |*/ CRYPT_NEWKEYSET)) {

                    dwErr = GetLastError();

                }

            }
            else {
                __leave;
            }
        }

        // Create the hash object.

        if(!CryptCreateHash(hCryptProv, 
                            CALG_SHA1, 
                            0, 
                            0, 
                            &hHash)) {
            dwErr = GetLastError();
            __leave;
        }


        // Compute the cryptographic hash of the buffer.

        if(!CryptHashData(hHash, 
                         (BYTE *)(m_xmldoc.c_str()),
                         m_xmldoc.size()*sizeof (WCHAR),
                         0)) {
            dwErr = GetLastError();
            __leave;
        }

        // we have the common part of the hash ready (H(buf), now duplicate it
        // so as to calc the H (buf + guid)

        if (!CryptDuplicateHash(hHash, 
                               NULL, 
                               0, 
                               &hDupHash)) {
            dwErr = GetLastError();
            __leave;
        }


        if (!CryptGetHashParam(hHash,    
                               HP_HASHVAL,
                               pbHashBody,
                               &cbHashBody,
                               0)) {
            dwErr = GetLastError();
            __leave;
        }

        ASSERT (cbHashBody == 20);

        
        if(!CryptHashData(hDupHash, 
                         (BYTE *)&guidDomainRename,
                         sizeof (GUID),
                         0)) {
            dwErr = GetLastError();
            __leave;
        }
        
        if (!CryptGetHashParam(hDupHash,    
                               HP_HASHVAL,
                               pbSignature,
                               &cbSignature,
                               0)) {
            dwErr = GetLastError();
            __leave;
        }

        ASSERT (cbSignature == 20);

    }
    __finally {

        if (hDupHash)
            CryptDestroyHash(hDupHash);

        if(hHash) 
            CryptDestroyHash(hHash);

        if(hCryptProv) 
            CryptReleaseContext(hCryptProv, 0);

    }

    dclist->SetbodyHash(pbHashBody,
                        cbHashBody);

    dclist->SetSignature(pbSignature,
                         cbSignature);

    if (0 != dwErr) {
        m_Error.SetErr(dwErr,
                        L"Failed to encrypt the script");
        return FALSE;
    }

    if (dwErr = base64encode(pbSignature, 
                             cbSignature, 
                             (LPSTR)encodedbytes,
                             100,
                             NULL)) {

        m_Error.SetErr(RtlNtStatusToDosError(dwErr),
                        L"Error encoding signature");
        
        return FALSE;
    }

    pwScript = Convert2WChars((LPSTR)encodedbytes);
    if (!pwScript) {
        m_Error.SetMemErr();
    }

    if (!AddSignatureToScript(pwScript))
    {
        return FALSE;
    }

    AddModMod (L"msDS-UpdateScript", m_xmldoc.c_str() , &pLdapMod);
    
    dwErr = ldap_modify_s (hLdapConn, ObjectDN, pLdapMod);

    if(dwErr != LDAP_SUCCESS) {
        m_Error.SetLdapErr(hLdapConn,
                           dwErr,
                           L"Failed to upload rename instructions to %S, %ws",
                           hLdapConn->ld_host,
                           ldap_err2stringW(dwErr));
    }
    
    FreeMod (&pLdapMod);

    return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
//                                                                                //
//                        parser implementation                                   //
//                                                                                //
////////////////////////////////////////////////////////////////////////////////////

CXMLDomainListContentHander::CXMLDomainListContentHander(CEnterprise *p_enterprise)
{                          
	m_eDomainParsingStatus = SCRIPT_STATUS_WAITING_FOR_FOREST;
    m_eDomainAttType       = DOMAIN_ATT_TYPE_NONE;

    m_enterprise           = p_enterprise;
    m_Domain               = NULL;
    
    m_DcToUse              = NULL;
    m_NetBiosName          = NULL;
    m_Dnsname              = NULL;
    m_Guid                 = NULL;
    m_Sid                  = NULL;
    m_DN                   = NULL;
    
    m_CrossRef             = NULL;
    m_ConfigNC             = NULL;
    m_SchemaNC             = NULL;
    
}

CXMLDomainListContentHander::~CXMLDomainListContentHander()
{
    if (m_DcToUse) {
        delete [] m_DcToUse;         
    }
    if (m_Dnsname) {
        delete [] m_Dnsname;
    }
    if (m_NetBiosName) {
        delete [] m_NetBiosName;
    }
    if (m_Guid) {
        delete [] m_Guid;
    }
}


HRESULT STDMETHODCALLTYPE CXMLDomainListContentHander::startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes)
{
    if (_wcsnicmp(DOMAINSCRIPT_FOREST, pwchLocalName, cchLocalName) == 0) {

        // we accept only one, at the start
        if (SCRIPT_STATUS_WAITING_FOR_FOREST != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Encountered <Forest> tag in the middle of a another <Forest> tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN);
        }
    }
    else if (_wcsnicmp(DOMAINSCRIPT_ENTERPRISE_INFO, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_ENTERPRISE_INFO);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_CONFIGNC, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_ENTERPRISE_INFO != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_CONFIGURATION_NC);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_SCHEMANC, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_ENTERPRISE_INFO != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_SCHEMA_NC);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_DOMAIN, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Domain> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_GUID, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT   != CurrentDomainParsingStatus()) &&
            (SCRIPT_STATUS_PARSING_CONFIGURATION_NC != CurrentDomainParsingStatus()) && 
            (SCRIPT_STATUS_PARSING_SCHEMA_NC        != CurrentDomainParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Guid> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_GUID);
        }
    }
    else if (_wcsnicmp(DOMAINSCRIPT_SID, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT   != CurrentDomainParsingStatus()) &&
            (SCRIPT_STATUS_PARSING_CONFIGURATION_NC != CurrentDomainParsingStatus()) && 
            (SCRIPT_STATUS_PARSING_SCHEMA_NC        != CurrentDomainParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Guid> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_SID);
        }
    }
    else if (_wcsnicmp(DOMAINSCRIPT_DN, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT   != CurrentDomainParsingStatus()) &&
            (SCRIPT_STATUS_PARSING_CONFIGURATION_NC != CurrentDomainParsingStatus()) && 
            (SCRIPT_STATUS_PARSING_SCHEMA_NC        != CurrentDomainParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Guid> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_DN);
        }
    }
    else if (_wcsnicmp(DOMAINSCRIPT_DNSROOT, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <DNSName> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_DNSROOT);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_NETBIOSNAME, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <NetBiosName> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NETBIOSNAME);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_DCNAME, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <DCName> Tag.");
            return E_FAIL;
        }                   
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_PARSING_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_DCNAME);
        }

    } else {
        WCHAR temp[100] = L"";
        wcsncpy(temp,pwchLocalName,cchLocalName);
        temp[cchLocalName] = L'\0';
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Unknown Tag <%ws>",
                        temp);
        return E_FAIL;
    }
    
    if (m_Error.isError()) {
        return E_FAIL;
    }

    return S_OK;
}
        
       
HRESULT STDMETHODCALLTYPE CXMLDomainListContentHander::endElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName)
{
	if (_wcsnicmp(DOMAINSCRIPT_FOREST, pwchLocalName, cchLocalName) == 0) {

        // we accept only one, at the start
        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Encountered <Forest> tag in the middle of a another <Forest> tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_FOREST);
        }
    }
    else if (_wcsnicmp(DOMAINSCRIPT_DOMAIN, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Domain> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN);
            if (!m_Guid) {
                m_Error.SetErr(ERROR_GEN_FAILURE,
                                L"Failed parsing script.  A Guid was not specified for the domain.");
            }
            if (!m_Dnsname) {
                m_Error.SetErr(ERROR_GEN_FAILURE,
                                L"Failed parsing script.  A Dnsname was not specified for the domain.");
            }

            //set up a domain
            CDsName *GuidDsName = new CDsName(m_Guid,
                                              NULL,
                                              NULL);
            if (!GuidDsName) {
                m_Error.SetMemErr();
                return E_FAIL;
            }

            if (m_Error.isError()) {
                return E_FAIL;
            }
            m_Domain = new CDomain(NULL,
                                   GuidDsName,
                                   m_Dnsname,
                                   m_NetBiosName,
                                   FALSE,
                                   FALSE,
                                   FALSE,
                                   m_DcToUse);
            if (!m_Domain) {
                m_Error.SetMemErr();
                return E_FAIL;
            }

            if (m_Error.isError()) {
                return E_FAIL;
            }

            //place domain on descList
            m_enterprise->AddDomainToDescList(m_Domain);
            if (m_Error.isError()) {
                return E_FAIL;
            }

            //set all info to NULL
            m_Domain               = NULL;
            m_DcToUse              = NULL;
            m_NetBiosName          = NULL;
            m_Dnsname              = NULL;
            m_Guid                 = NULL;
            m_Sid                  = NULL;
            m_DN                   = NULL;
         
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_GUID, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Guid> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }
    }
    else if (_wcsnicmp(DOMAINSCRIPT_DNSROOT, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <DNSName> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_NETBIOSNAME, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <NetBiosName> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_DCNAME, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <DCName> Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_DN, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_SID, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }

    }
    else if (_wcsnicmp(DOMAINSCRIPT_ENTERPRISE_INFO, pwchLocalName, cchLocalName) == 0) {

        if (SCRIPT_STATUS_PARSING_DOMAIN_ATT != CurrentDomainParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected Tag.");
            return E_FAIL;
        }
        else {
            SetDomainParsingStatus(SCRIPT_STATUS_WAITING_FOR_DOMAIN_ATT);
            SetCurrentDomainAttType(DOMAIN_ATT_TYPE_NONE);
        }

    } else {
        WCHAR temp[100] = L"";
        wcsncpy(temp,pwchLocalName,cchLocalName);
        temp[cchLocalName] = L'\0';
        m_Error.SetErr(ERROR_INVALID_PARAMETER,
                        L"Unknown Tag <%ws>",
                        temp);
        return E_FAIL;
    }

    if (m_Error.isError()) {  
        return E_FAIL;         
    }
    
    
    /*DOMAINSCRIPT_ENTERPRISE_INFO 
    DOMAINSCRIPT_CONFIGNC        
    DOMAINSCRIPT_SCHEMANC        
    DOMAINSCRIPT_FORESTROOT      */

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CXMLDomainListContentHander::characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    switch(CurrentDomainAttType()) {
    case DOMAIN_ATT_TYPE_NONE:
        break;
    case DOMAIN_ATT_TYPE_GUID:
        m_Guid = new WCHAR[cchChars+1];
        if (!m_Guid) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_Guid,pwchChars,cchChars);
        m_Guid[cchChars] = 0;
        break;
    case DOMAIN_ATT_TYPE_DNSROOT:
        m_Dnsname = new WCHAR[cchChars+1];
        if (!m_Dnsname) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_Dnsname,pwchChars,cchChars);
        m_Dnsname[cchChars] = 0;
        break;
    case DOMAIN_ATT_TYPE_NETBIOSNAME:
        m_NetBiosName = new WCHAR[cchChars+1];
        if (!m_NetBiosName) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_NetBiosName,pwchChars,cchChars);
        m_NetBiosName[cchChars] = 0;
        for (int i = 0; i < cchChars; i++) {
            m_NetBiosName[i] = towupper(m_NetBiosName[i]);
        }
        break;
    case DOMAIN_ATT_TYPE_DCNAME:
        m_DcToUse = new WCHAR[cchChars+1];
        if (!m_DcToUse) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_DcToUse,pwchChars,cchChars);
        m_DcToUse[cchChars] = 0;
        break;
    case DOMAIN_ATT_TYPE_SID:
        m_Sid = new WCHAR[cchChars+1];
        if (!m_Sid) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_Sid,pwchChars,cchChars);
        m_Sid[cchChars] = 0;
        break;
    case DOMAIN_ATT_TYPE_DN:
        m_DN = new WCHAR[cchChars+1];
        if (!m_DN) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_DN,pwchChars,cchChars);
        m_DN[cchChars] = 0;
        break;
    case DOMAIN_ATT_TYPE_FORESTROOTGUID:
        m_DomainRootGuid = new WCHAR[cchChars+1];
        if (!m_DomainRootGuid) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_DomainRootGuid,pwchChars,cchChars);
        m_DomainRootGuid[cchChars] = 0;
        break;
    default:
        m_Error.SetErr(ERROR_GEN_FAILURE,
                        L"Failed This should not be possible.");
        return E_FAIL;
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CXMLDomainListContentHander::startDocument()
{
    m_eDomainParsingStatus = SCRIPT_STATUS_WAITING_FOR_FOREST;
    m_eDomainAttType       = DOMAIN_ATT_TYPE_NONE;

    m_Domain               = NULL;
    m_DcToUse              = NULL;
    m_NetBiosName          = NULL;
    m_Dnsname              = NULL;
    m_Guid                 = NULL;
    m_Sid                  = NULL;
    m_DN                   = NULL;
    m_CrossRef             = NULL;
    m_ConfigNC             = NULL;
    m_SchemaNC             = NULL;
    m_DomainRootGuid       = NULL;

    return S_OK;
}

CXMLDcListContentHander::CXMLDcListContentHander(CEnterprise *enterprise)
{
    m_eDcParsingStatus      = SCRIPT_STATUS_WAITING_FOR_DCLIST;  
    m_eDcAttType            = DC_ATT_TYPE_NONE;

    m_DcList                = enterprise->GetDcList();

    m_dc                    = NULL;
    m_Name                  = NULL;
    m_State                 = NULL;
    m_Password              = NULL;
    m_LastError             = NULL;
    m_LastErrorMsg          = NULL;
    m_FatalErrorMsg         = NULL; 
    m_Retry                 = NULL;
}

CXMLDcListContentHander::~CXMLDcListContentHander()
{
    
}

HRESULT STDMETHODCALLTYPE CXMLDcListContentHander::startDocument()
{
    m_eDcParsingStatus      = SCRIPT_STATUS_WAITING_FOR_DCLIST;  
    m_eDcAttType            = DC_ATT_TYPE_NONE;

    m_dc                    = NULL;
    m_Name                  = NULL;
    m_State                 = NULL;
    m_Password              = NULL;
    m_LastError             = NULL;
    m_LastErrorMsg          = NULL;
    m_FatalErrorMsg         = NULL;

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CXMLDcListContentHander::startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes)
{
    if ((wcslen(DCSCRIPT_DCLIST) == cchLocalName) && _wcsnicmp(DCSCRIPT_DCLIST, pwchLocalName, cchLocalName) == 0) {

        // we accept only one, at the start
        if (SCRIPT_STATUS_WAITING_FOR_DCLIST != CurrentDcParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Encountered <DcList> tag in the middle of a another <DcList> tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT);
        }
    }
    else if ((wcslen(DCSCRIPT_HASH) == cchLocalName) && _wcsnicmp(DCSCRIPT_HASH, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT != CurrentDcParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Hash> Tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_PARSING_HASH);
        }

    }
    else if ((wcslen(DCSCRIPT_SIGNATURE) == cchLocalName) && _wcsnicmp(DCSCRIPT_SIGNATURE, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT != CurrentDcParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Signature> Tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_PARSING_SIGNATURE);
        }

    }
    else if ((wcslen(DCSCRIPT_DC) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <DC> Tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_PARSING_DCLIST_ATT);
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_NAME) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_NAME, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Name> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NAME);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_STATE) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_STATE, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <State> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_STATE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_PASSWORD) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_PASSWORD, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Password> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_PASSWORD);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_RETRY) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_RETRY, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <Retry> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_RETRY);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_LASTERROR) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_LASTERROR, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <LastError> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_LASTERROR);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_LASTERRORMSG) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_LASTERRORMSG, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <LastErrorMsg> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_LASTERRORMSG);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_FATALERRORMSG) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_FATALERRORMSG, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected <FatalErrorMsg> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_FATALERRORMSG);
        }
    }

    
    
    if (m_Error.isError()) {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT STDMETHODCALLTYPE CXMLDcListContentHander::endElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName)
{
	if ((wcslen(DCSCRIPT_DCLIST) == cchLocalName) && _wcsnicmp(DCSCRIPT_DCLIST, pwchLocalName, cchLocalName) == 0) {

        // we accept only one, at the start
        if (SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT != CurrentDcParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Encountered </DcList> tag in the middle of a another <Forest> tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_WAITING_FOR_DCLIST);
        }
    }
    else if ((wcslen(DCSCRIPT_HASH) == cchLocalName) && _wcsnicmp(DCSCRIPT_HASH, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_PARSING_HASH != CurrentDcParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </Hash> Tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT);
        }

    }
    else if ((wcslen(DCSCRIPT_SIGNATURE) == cchLocalName) && _wcsnicmp(DCSCRIPT_SIGNATURE, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_PARSING_SIGNATURE != CurrentDcParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </Signature> Tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT);
        }

    }
    else if ((wcslen(DCSCRIPT_DC) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </DC> Tag.");
            return E_FAIL;
        }
        else {
            SetDcParsingStatus(SCRIPT_STATUS_WAITING_FOR_DCLIST_ATT);
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
            if (!m_Name) {
                m_Error.SetErr(ERROR_GEN_FAILURE,
                                L"Failed parsing script.  A Name was not specified for the DC.");
            }
            
            //set up a domain
            CDc *dc = new CDc(m_Name,
                              m_State,
                              m_Password,
                              m_LastError,
                              m_FatalErrorMsg,
                              m_LastErrorMsg,
                              m_Retry,
                              NULL);
            if (!dc) {
                m_Error.SetMemErr();
                return E_FAIL;
            }

            if (m_Error.isError()) {
                return E_FAIL;
            }
            
            //place dc on dcList
            m_DcList->AddDcToList(dc);
            if (m_Error.isError()) {
                return E_FAIL;
            }

            //set all info to NULL
            m_dc                  = NULL;
            m_Name                = NULL;
            m_State               = 0;
            if (m_Password) {
                delete [] m_Password;
            }
            m_Password            = NULL;
            m_LastError           = 0;
            m_LastErrorMsg        = NULL;
            m_FatalErrorMsg       = NULL;
            m_Retry               = FALSE;
        }
    }
    else if ((wcslen(DCSCRIPT_DC_NAME) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_NAME, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </Name> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_STATE) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_STATE, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </State> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_RETRY) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_RETRY, pwchLocalName, cchLocalName) == 0) {
        
        if (SCRIPT_STATUS_PARSING_DCLIST_ATT != CurrentDcParsingStatus()) {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </Retry> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }

    }
    else if ((wcslen(DCSCRIPT_DC_PASSWORD) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_PASSWORD, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </Password> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_LASTERROR) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_LASTERROR, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </LastError> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_LASTERRORMSG) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_LASTERRORMSG, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </LastErrorMsg> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }
    else if ((wcslen(DCSCRIPT_DC_FATALERRORMSG) == cchLocalName) && _wcsnicmp(DCSCRIPT_DC_FATALERRORMSG, pwchLocalName, cchLocalName) == 0) {
        
        if ((SCRIPT_STATUS_PARSING_DCLIST_ATT   != CurrentDcParsingStatus()) )  
        {
            m_Error.SetErr(ERROR_GEN_FAILURE,
                            L"Failed parsing script.  Unexpected </FatalErrorMsg> Tag.");
            return E_FAIL;
        }
        else {
            SetCurrentDcAttType(DC_ATT_TYPE_NONE);
        }
    }

    if (m_Error.isError()) {  
        return E_FAIL;         
    }
    
    return S_OK;
}

HRESULT STDMETHODCALLTYPE CXMLDcListContentHander::characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    WCHAR error[20+1] = {0};


    if (CurrentDcParsingStatus() == SCRIPT_STATUS_PARSING_HASH) {
        WCHAR *temp = new WCHAR[cchChars+1];
        if (!temp) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(temp,pwchChars,cchChars);
        temp[cchChars] = 0;

        m_DcList->SetbodyHash(temp);

        delete [] temp;
    }
    if (CurrentDcParsingStatus() == SCRIPT_STATUS_PARSING_SIGNATURE) {
        WCHAR *temp = new WCHAR[cchChars+1];
        if (!temp) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(temp,pwchChars,cchChars);
        temp[cchChars] = 0;

        m_DcList->SetSignature(temp);

        delete [] temp;
    }
    switch(CurrentDcAttType()) {
    case DC_ATT_TYPE_NONE:
        break;
    case DC_ATT_TYPE_NAME:
        m_Name = new WCHAR[cchChars+1];
        if (!m_Name) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_Name,pwchChars,cchChars);
        m_Name[cchChars] = 0;
        break;
    case DC_ATT_TYPE_STATE:
        if (0 == _wcsnicmp(DC_STATE_STRING_INITIAL,pwchChars,cchChars)) {
            m_State = DC_STATE_INITIAL;
        }
        if (0 == _wcsnicmp(DC_STATE_STRING_PREPARED,pwchChars,cchChars)) {
            m_State = DC_STATE_PREPARED;
        }
        if (0 == _wcsnicmp(DC_STATE_STRING_DONE,pwchChars,cchChars)) {
            m_State = DC_STATE_DONE;
        }
        if (0 == _wcsnicmp(DC_STATE_STRING_ERROR,pwchChars,cchChars)) {
            m_State = DC_STATE_ERROR;
        }
        break;
    case DC_ATT_TYPE_PASSWORD:
        m_Password = new WCHAR[cchChars+1];
        if (!m_Password) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_Password,pwchChars,cchChars);
        m_Password[cchChars] = 0;
        break;
    case DC_ATT_TYPE_LASTERROR:
        wcsncpy(error,pwchChars,cchChars);
        error[cchChars] = 0;
        m_LastError = _wtoi(error);
        break;
    case DC_ATT_TYPE_RETRY:
        if (0 == _wcsnicmp(L"Yes",pwchChars,cchChars)) {
            m_Retry = TRUE;
        }
        break;
    case DC_ATT_TYPE_LASTERRORMSG:
        m_LastErrorMsg = new WCHAR[cchChars+1];
        if (!m_LastErrorMsg) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_LastErrorMsg,pwchChars,cchChars);
        m_LastErrorMsg[cchChars] = 0;
        break;
    case DC_ATT_TYPE_FATALERRORMSG:
        m_FatalErrorMsg = new WCHAR[cchChars+1];
        if (!m_FatalErrorMsg) {
            m_Error.SetMemErr();
            return E_FAIL;
        }
        wcsncpy(m_FatalErrorMsg,pwchChars,cchChars);
        m_FatalErrorMsg[cchChars] = 0;
        break;
    default:
        m_Error.SetErr(ERROR_GEN_FAILURE,
                        L"Failed This should not be possible.");
        return E_FAIL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\util\clsfactory.cxx ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    clsFactory.cxx

ABSTRACT:

    This is the implementation of loader of the sax parser for rendom.exe.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/


#include <ntdspchx.h>
#pragma  hdrstop

#include "debug.h"
#define DEBSUB "CLSFACTORY:"


#include "ole2.h"

#include <tchar.h>



////////////////////////////
// helpers

HRESULT
FindDllPathFromCLSID( LPCTSTR pszCLSID, LPTSTR pBuf, DWORD cbBuf)
{
    HRESULT hr = S_OK;

    HKEY hCatalog   = NULL;
    HKEY hCLSID     = NULL;
    HKEY hInProc    = NULL;
    DWORD dwType;
    DWORD cbSize;

    if (ERROR_SUCCESS != ::RegOpenKeyEx( HKEY_CLASSES_ROOT, _T("CLSID"), 0, KEY_READ, &hCatalog))
    {
        DPRINT (0, "Unable to access registry\n");
        goto Fail;
    }

    if (ERROR_SUCCESS != ::RegOpenKeyEx( hCatalog, pszCLSID, 0, KEY_READ, &hCLSID))
    {
        DPRINT1 (0, "Unable to access registry key HKCR\\CLSID\\%s\n", pszCLSID);
        goto Fail;
    }

    if (ERROR_SUCCESS != ::RegOpenKeyEx( hCLSID, _T("InProcServer32"), 0, KEY_READ, &hInProc))
    {
        DPRINT1 (0, "Unable to access registry key HKCR\\CLSID\\%s\\InProcServer32 \n", pszCLSID);
        goto Fail;
    }

    cbSize = cbBuf-sizeof(TCHAR);
    if (ERROR_SUCCESS != ::RegQueryValueEx( hInProc, NULL, NULL, &dwType, (LPBYTE)pBuf, &cbSize))
    {
        DPRINT1 (0, "Unable to read registry key HKCR\\CLSID\\%s\\InProcServer32 \n", pszCLSID);
        goto Fail;
    }

    switch (dwType)
    {
    case REG_EXPAND_SZ:
        {
            TCHAR rgchTemp[1024];

            //ensure that the string is NULL terminated
            pBuf[cbSize/sizeof(TCHAR)] = L'\0';

            DWORD cchReqSize = ExpandEnvironmentStrings( pBuf, NULL, 0);
            if (!cchReqSize || (cchReqSize>cbBuf/sizeof(TCHAR)) || (cbSize>1024*sizeof(TCHAR)) ) 
            {
                DPRINT1(0, "Failed to expand string :%d", GetLastError());
                goto Fail;
            }
            memcpy( rgchTemp, pBuf, cbSize);
            ExpandEnvironmentStrings( rgchTemp, pBuf, cchReqSize);
            
        }
        break;

    case REG_SZ:
        break;

    default:
        DPRINT1 (0, "Unable to understand registry key HKCR\\CLSID\\%s\\InProcServer32 \n", pszCLSID);
        goto Fail;
    }

    goto Cleanup;

Fail:
    ::RegCloseKey( hCatalog);
    ::RegCloseKey( hCLSID);
    ::RegCloseKey( hInProc);

    hr = E_FAIL;

Cleanup:
    return hr;
}


HRESULT
FindDllPathFromPROGID( LPCTSTR pszPROGID, LPTSTR pBuf, DWORD cbBuf)
{
    HRESULT hr = S_OK;

    HKEY hPROGID   = NULL;
    HKEY hCLSID     = NULL;
    TCHAR rgchCLSID[128];
    DWORD dwType;
    DWORD cbSize = sizeof(rgchCLSID);

    if (ERROR_SUCCESS != ::RegOpenKeyEx( HKEY_CLASSES_ROOT, pszPROGID, 0, KEY_READ, &hPROGID))
    {
        DPRINT1 (0, "Unable to access registry key HKCR\\%s \n", pszPROGID);
        goto Fail;
    }

    if (ERROR_SUCCESS != ::RegOpenKeyEx( hPROGID, _T("CLSID"), 0, KEY_READ, &hCLSID))
    {
        DPRINT1 (0, "Unable to access registry key HKCR\\%s\\CLSID\n", pszPROGID);
        goto Fail;
    }

    if (ERROR_SUCCESS != ::RegQueryValueEx( hCLSID, NULL, NULL, &dwType, (LPBYTE)rgchCLSID, &cbSize))
    {
        DPRINT1 (0, "Unable to read registry key HKCR\\%s\\CLSID \n", pszPROGID);
        goto Fail;
    }

    if (dwType != REG_SZ)
    {
        DPRINT1 (0, "Unable to understand registry key HKCR\\%s\\CLSID\n", pszPROGID);
        goto Fail;
    }

    hr = FindDllPathFromCLSID( rgchCLSID, pBuf, cbBuf);

    goto Cleanup;

Fail:
    ::RegCloseKey( hCLSID);
    ::RegCloseKey( hPROGID);

    hr = E_FAIL;

Cleanup:
    return hr;
}


class CClassFactoryWrapper : public IClassFactory
{
private:
    ULONG _ulRefs;
    HINSTANCE _hLibrary;
    IClassFactory * _pWrapped;

public:
    CClassFactoryWrapper( HINSTANCE hLibrary, IClassFactory * pWrap)
        : _ulRefs( 1), _hLibrary( hLibrary), _pWrapped( pWrap)
    {
    }

    ~CClassFactoryWrapper()
    {
        if (_pWrapped)
            _pWrapped->Release();
        ::FreeLibrary( _hLibrary);
    }

public:
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID iid, void ** ppv)
    {
        if (iid == IID_IUnknown || iid == IID_IClassFactory) 
        {
            *ppv = this;
            AddRef();
            return S_OK;    
        }
        else
        {
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }

    ULONG STDMETHODCALLTYPE AddRef()
    {
        return (ULONG)InterlockedIncrement((LPLONG)&_ulRefs);
    }

    ULONG STDMETHODCALLTYPE Release()
    {
        ULONG ul = (ULONG)InterlockedDecrement((LPLONG)&_ulRefs);
        if (0 == ul)
            delete this;
        return ul;
    }

    // IClassFactory methods
    HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock)
    {
        if (_pWrapped)
            return _pWrapped->LockServer( fLock);
        return S_OK;
    }

    HRESULT STDMETHODCALLTYPE CreateInstance(
            IUnknown *pUnkOuter,
            REFIID iid,
            void **ppvObj)
    {
        if (_pWrapped)
            return _pWrapped->CreateInstance( pUnkOuter, iid, ppvObj);
        return E_FAIL;
    }
};

typedef HRESULT (__stdcall *FN_DLLGETCLASSOBJECT)(REFCLSID, REFIID, LPVOID FAR*);

HRESULT GetClassFactory( REFCLSID clsid, IClassFactory ** ppFactory)
{
    HRESULT hr;
    TCHAR rgchDllPath[1024];
#ifdef UNICODE
    WCHAR rgszCLSID[128];
#else
    WCHAR rgwszCLSID[128];
    TCHAR rgszCLSID[128];
#endif

    HINSTANCE hLibrary = NULL;
    FN_DLLGETCLASSOBJECT fnDllGetClassObject = NULL;
    IClassFactory * pFactory = NULL;


#ifdef UNICODE
    StringFromGUID2( clsid, rgszCLSID, sizeof(rgszCLSID)/sizeof(rgszCLSID[0]));
#else
    StringFromGUID2( clsid, rgwszCLSID, sizeof(rgwszCLSID)/sizeof(rgwszCLSID[0]));
    ::WideCharToMultiByte( CP_ACP, NULL, rgwszCLSID, -1, rgszCLSID, sizeof(rgszCLSID)/sizeof(rgszCLSID[0]), NULL, NULL);
#endif

    if (FAILED(hr = FindDllPathFromCLSID( rgszCLSID, rgchDllPath, sizeof(rgchDllPath))))
    {
        goto Failed;
    }

    hLibrary = ::LoadLibrary( rgchDllPath);
    if ( !hLibrary)
    {
        DPRINT1 (0, "failed to load dll: %s\n", rgchDllPath);
        hr = E_FAIL;
        goto Failed;
    }

    fnDllGetClassObject = (FN_DLLGETCLASSOBJECT)::GetProcAddress( hLibrary, "DllGetClassObject");
    if ( !fnDllGetClassObject)
    {
        DPRINT1 (0, "Unable to find \"DllGetClassObject\" export in dll: %s\n", rgchDllPath);
        hr = E_FAIL;
        goto Failed;
    }

    if (FAILED(hr = (*fnDllGetClassObject)( clsid, IID_IClassFactory, (void**)&pFactory)))
    {
        goto Failed;
    }

    *ppFactory = new CClassFactoryWrapper( hLibrary, pFactory);
    hr = S_OK;

    goto Cleanup;

Failed:
    if (hLibrary)
    {
        if (pFactory)
        {
            pFactory->Release();
            pFactory = NULL;
        }

        ::FreeLibrary( hLibrary);
        hLibrary = NULL;
    }

Cleanup:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\csv.h ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

   csv.h - include file for the CSV info.

Abstract:

   This has a list of the CSV formats/commands.  Each "CSV_CMD()" 
   represents a given format for printing.

Author:

    Brett Shirley   (BrettSh)

Environment:

Notes:

Revision History:

    Brett Shirley   BrettSh     7/12/2002
         Created

--*/

#if DEFINE_CSV_TABLE
// This is the table defining version of CSV_CMD()
#define CSV_CMD(cmd, cmdstr, cmdtbl)  {cmd, cmdstr, ARRAY_SIZE(cmdtbl), cmdtbl, FALSE}, 

#else 
// This is the enum "constant" defining version of CSV_CMD()                                     
#define CSV_CMD(cmd, cmdstr, cmdtbl)  cmd,

#endif



#if DEFINE_CSV_TABLE

DWORD gRepadminCols [] = {
    REPADMIN_CSV_REPADMIN_C0, // First column will be manually made.
    REPADMIN_CSV_REPADMIN_C1,
    REPADMIN_CSV_REPADMIN_C2,
    REPADMIN_CSV_REPADMIN_C3
};

DWORD gShowReplCols [] = {
    REPADMIN_CSV_REPADMIN_C0, // First column will be manually made.
    REPADMIN_CSV_REPADMIN_C1, // Destination DC Site
    REPADMIN_CSV_REPADMIN_C2, // Destination DC

    REPADMIN_CSV_SHOWREPL_C3, // Naming Context
    REPADMIN_CSV_SHOWREPL_C4, // Source DC Site
    REPADMIN_CSV_SHOWREPL_C5, // Source DC
    REPADMIN_CSV_SHOWREPL_C6, // Transport Type
    REPADMIN_CSV_SHOWREPL_C7, // Number of Failures
    REPADMIN_CSV_SHOWREPL_C8, // Last Failure Time
    REPADMIN_CSV_SHOWREPL_C9, // Last Success Time
    REPADMIN_CSV_SHOWREPL_C10 // Last Failure Status
};

WCHAR * gszCsvTypeError = L"_ERROR";
WCHAR * gszCsvTypeColumns = L"_COLUMNS";
WCHAR * gszCsvTypeInfo = L"_INFO";

CSV_MODE_STATE  gCsvMode = { eCSV_NULL_CMD, NULL, NULL };

#endif


//
// This is where the CSV command table and enums are created.
//
#if DEFINE_CSV_TABLE

CSV_CMD_TBL gCsvCmds [] = {

#else 

enum {

#endif

CSV_CMD(eCSV_NULL_CMD,       L"(none)",     gRepadminCols)
CSV_CMD(eCSV_REPADMIN_CMD,   L"repadmin",   gRepadminCols)
CSV_CMD(eCSV_SHOWREPL_CMD,   L"showrepl",   gShowReplCols)

#if DEFINE_CSV_TABLE

};

#else 

} eCsvCmd;

#endif

//
// This is just more typedef structs.
//

#ifndef DEFINE_CSV_TABLE
typedef struct _CSV_CMD_TBL {  
    enum eCsvCmd    eCsvCmd; 
    WCHAR *         szCsvCmd;
    ULONG           cCmdArgs;
    DWORD *         aCmdCols;
    BOOL            bPrintedCols;
} CSV_CMD_TBL;

typedef struct _CSV_MODE_STATE {
    enum eCsvCmd    eCsvCmd;
    WCHAR *         szSite;
    WCHAR *         szServer;
} CSV_MODE_STATE;

extern CSV_MODE_STATE gCsvMode;
#define  bCsvMode()      (gCsvMode.eCsvCmd != eCSV_NULL_CMD)

extern CSV_MODE_STATE gCsvMode;

void 
PrintCsv(
    IN  enum eCsvCmd eCsvCmd,
    IN  ...
    );

#endif


#undef CSV_CMD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\rendom\util\saxcontenthandlerimpl.cxx ===
/*++

Copyright (c) 2002 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    SAXContentHandlerImpl.cxx

ABSTRACT:

    This is the implementation of the sax parser for rendom.exe.

DETAILS:

CREATED:

    13 Nov 2000   Dmitry Dukat (dmitrydu)

REVISION HISTORY:

--*/


#include "SAXContentHandlerImpl.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////


SAXContentHandlerImpl::SAXContentHandlerImpl()
{
    _cRef = 1;
}

SAXContentHandlerImpl::~SAXContentHandlerImpl()
{
}


//+-----------------------------------------------------------------------------
//
// ISAXContentHandler implementation
//
//------------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::putDocumentLocator( 
            /* [in] */ ISAXLocator __RPC_FAR *pLocator
            )
{
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::startDocument()
{
    return S_OK;
}
        

        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::endDocument( void)
{
    return S_OK;
}
        
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::startPrefixMapping( 
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix,
            /* [in] */ const wchar_t __RPC_FAR *pwchUri,
            /* [in] */ int cchUri)
{
    return S_OK;
}
        
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::endPrefixMapping( 
            /* [in] */ const wchar_t __RPC_FAR *pwchPrefix,
            /* [in] */ int cchPrefix)
{
    return S_OK;
}
        

        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::startElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName,
            /* [in] */ ISAXAttributes __RPC_FAR *pAttributes)
{
    return S_OK;
}
        
       
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::endElement( 
            /* [in] */ const wchar_t __RPC_FAR *pwchNamespaceUri,
            /* [in] */ int cchNamespaceUri,
            /* [in] */ const wchar_t __RPC_FAR *pwchLocalName,
            /* [in] */ int cchLocalName,
            /* [in] */ const wchar_t __RPC_FAR *pwchRawName,
            /* [in] */ int cchRawName)
{
    return S_OK;
}
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::characters( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    return S_OK;
}
        

HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::ignorableWhitespace( 
            /* [in] */ const wchar_t __RPC_FAR *pwchChars,
            /* [in] */ int cchChars)
{
    return S_OK;
}
        

HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::processingInstruction( 
            /* [in] */ const wchar_t __RPC_FAR *pwchTarget,
            /* [in] */ int cchTarget,
            /* [in] */ const wchar_t __RPC_FAR *pwchData,
            /* [in] */ int cchData)
{
    return S_OK;
}
        
        
HRESULT STDMETHODCALLTYPE SAXContentHandlerImpl::skippedEntity( 
            /* [in] */ const wchar_t __RPC_FAR *pwchVal,
            /* [in] */ int cchVal)
{
    return S_OK;
}


//+-----------------------------------------------------------------------------
//
// IUnknown implementation
//
//------------------------------------------------------------------------------

long __stdcall SAXContentHandlerImpl::QueryInterface(const struct _GUID &riid,void ** ppvObject)
{
    if (riid == IID_IUnknown || riid == IID_ISAXContentHandler)
    {
        *ppvObject = static_cast<ISAXContentHandler *>(this);
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

unsigned long __stdcall SAXContentHandlerImpl::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

unsigned long __stdcall SAXContentHandlerImpl::Release()
{
    if (InterlockedDecrement(&_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return _cRef;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\repadmin.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

    Rsraghav has been in here too

    Will Lees    wlees   Feb 11, 1998
         Converted code to use ntdsapi.dll functions

    Aaron Siegel t-asiege 18 June 1998
	 Added support for DsReplicaSyncAll

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#define INCLUDE_OPTION_TRANSLATION_TABLES
#include <mdglobal.h>
#undef INCLUDE_OPTION_TRANSLATION_TABLES
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>
#include "ndnc.h"
                              
#include "ReplRpcSpoof.hxx"
#include "repadmin.h"
#include "resource.h"

#define DSID(x, y)     (0 | (0xFFFF & __LINE__))
#include "debug.h"

#define DS_CON_LIB_CRT_VERSION
#include "dsconlib.h"
     
// Global credentials.
SEC_WINNT_AUTH_IDENTITY_W   gCreds = { 0 };
SEC_WINNT_AUTH_IDENTITY_W * gpCreds = NULL;

// Global DRS RPC call flags.  Should hold 0 or DRS_ASYNC_OP.
ULONG gulDrsFlags = 0;

// An zero-filled filetime to compare against
FILETIME ftimeZero = { 0 };


int PreProcessGlobalParams(int * pargc, LPWSTR ** pargv);
int GetPassword(WCHAR * pwszBuf, DWORD cchBufMax, DWORD * pcchBufUsed);

int ExpertHelp(int argc, LPWSTR argv[]) {
    PrintHelp( TRUE /* expert */ );
    return 0;
}

typedef int (REPADMIN_FN)(int argc, LPWSTR argv[]);

// Help constants.
#define   HELP_BASIC     (1 << 0)
#define   HELP_EXPERT    (1 << 1)
#define   HELP_OLD       (1 << 2)
#define   HELP_LIST      (1 << 3)
#define   HELP_CSV       (1 << 4)


#define  REPADMIN_DEPRECATED_CMD    (1 << 0)
#define  REPADMIN_NO_DC_LIST_ARG    (1 << 1)
#define  REPADMIN_ADVANCED_CMD      (1 << 2)
#define  REPADMIN_CSV_ENABLED       (1 << 3)

#define  bIsDcArgCmd(x)             ( !((x.ulOptions) & REPADMIN_DEPRECATED_CMD) && \
                                      !((x.ulOptions) & REPADMIN_NO_DC_LIST_ARG) && \
                                      !((x.ulOptions) & REPADMIN_ADVANCED_CMD) )
// Need to use a pointer on this check for implementation reasons.                                      
#define  bIsCsvCmd(x)               ( ((x)->ulOptions) & REPADMIN_CSV_ENABLED )

#define   STD_CMD(cmd_id, pfunc)         { cmd_id, pfunc, 0 },
#define   OLD_CMD(cmd_id, pfunc)         { cmd_id, pfunc, REPADMIN_DEPRECATED_CMD },
#define   ADV_CMD(cmd_id, pfunc)         { cmd_id, pfunc, REPADMIN_ADVANCED_CMD},
#define   FLG_CMD(cmd_id, pfunc, flags)  { cmd_id, pfunc, flags },

typedef struct _REPADMIN_CMD_ENTRY {
    UINT            uNameID;
    REPADMIN_FN *   pfFunc;
    ULONG           ulOptions;
} REPADMIN_CMD_ENTRY;

REPADMIN_CMD_ENTRY rgCmdTable[] = {
    
    // Normal commands that take DC_LIST argument as first argument
    STD_CMD( IDS_CMD_RUN_KCC,                       RunKCC          )
    STD_CMD( IDS_CMD_BIND,                          Bind            )
    STD_CMD( IDS_CMD_QUEUE,                         Queue           )
    STD_CMD( IDS_CMD_FAILCACHE,                     FailCache       )
    STD_CMD( IDS_CMD_SHOWSIG,                       ShowSig         )
    STD_CMD( IDS_CMD_SHOWCTX,                       ShowCtx         )
    STD_CMD( IDS_CMD_SHOW_CONN,                     ShowConn        )
    STD_CMD( IDS_CMD_EXPERT_HELP,                   ExpertHelp      )
    STD_CMD( IDS_CMD_SHOW_CERT,                     ShowCert        )
    STD_CMD( IDS_CMD_SHOW_VALUE,                    ShowValue       )
    STD_CMD( IDS_CMD_LATENCY,                       Latency         )
    STD_CMD( IDS_CMD_ISTG,                          Istg            )
    STD_CMD( IDS_CMD_BRIDGEHEADS,                   Bridgeheads     )
    STD_CMD( IDS_CMD_DSAGUID,                       DsaGuid         )
    STD_CMD( IDS_CMD_SHOWPROXY,                     ShowProxy       )
    STD_CMD( IDS_CMD_REMOVELINGERINGOBJECTS,        RemoveLingeringObjects )
    STD_CMD( IDS_CMD_NOTIFYOPT,                     NotifyOpt       )
    STD_CMD( IDS_CMD_REPL_SINGLE_OBJ,               ReplSingleObj   )
    STD_CMD( IDS_CMD_SHOW_TRUST,                    ShowTrust       )       
    STD_CMD( IDS_CMD_SHOWSERVERCALLS,               ShowServerCalls )
//  STD_CMD( IDS_CMD_FULL_SYNC_ALL,                 FullSyncAll     ) // removed
    STD_CMD( IDS_CMD_SHOWNCSIG,                     ShowNcSig       )
    STD_CMD( IDS_CMD_VIEW_LIST,                     ViewList        )  
    STD_CMD( IDS_CMD_SHOW_UTD_VEC,                  ShowUtdVec      )   // new ShowVector
    STD_CMD( IDS_CMD_REPLICATE,                     Replicate       )   // new Sync
    STD_CMD( IDS_CMD_REPL,                          Replicate       )       // alias
    FLG_CMD( IDS_CMD_SHOW_REPL,                     ShowRepl        , REPADMIN_CSV_ENABLED)   // new ShowReps
    STD_CMD( IDS_CMD_SHOW_OBJ_META,                 ShowObjMeta     )   // new ShowMeta
    STD_CMD( IDS_CMD_CHECKPROP,                     CheckProp       )   // new PropCheck
    STD_CMD( IDS_CMD_SHOWCHANGES,                   ShowChanges     )   // new GetChanges
    STD_CMD( IDS_CMD_SHOWATTR,                      ShowAttr        )
    STD_CMD( IDS_CMD_SHOWATTR_P,                    ShowAttr        )   // private/internal version of /showattr

    //
    // <-------- Add new commands above here.  Please see RepadminPssFeatures.doc
    //                                         spec for standard command format.
    //
    
    // Special exceptions!!  Normal commands that don't/shouldn't take a 
    // DC_LIST argumnet
    FLG_CMD( IDS_CMD_SYNC_ALL,                      SyncAll         , REPADMIN_NO_DC_LIST_ARG )
    FLG_CMD( IDS_CMD_SHOW_TIME,                     ShowTime        , REPADMIN_NO_DC_LIST_ARG )
    FLG_CMD( IDS_CMD_SHOW_MSG,                      ShowMsg         , REPADMIN_NO_DC_LIST_ARG )
    FLG_CMD( IDS_CMD_SHOW_ISM,                      ShowIsm         , REPADMIN_NO_DC_LIST_ARG )
    FLG_CMD( IDS_CMD_QUERY_SITES,                   QuerySites      , REPADMIN_NO_DC_LIST_ARG )
    FLG_CMD( IDS_CMD_REPLSUMMARY,                   ReplSummary     , REPADMIN_NO_DC_LIST_ARG )
    FLG_CMD( IDS_CMD_REPLSUM,                       ReplSummary     , REPADMIN_NO_DC_LIST_ARG ) // alias
    
    // Advanced commands to be used only with PSS.  Not adviseable to take 
    // DC_LIST, since  these commands are so dangerous.
    ADV_CMD( IDS_CMD_ADD,                           Add             )
    ADV_CMD( IDS_CMD_DEL,                           Del             )
    ADV_CMD( IDS_CMD_MOD,                           Mod             )
    ADV_CMD( IDS_CMD_ADD_REPS_TO,                   AddRepsTo       )
    ADV_CMD( IDS_CMD_UPD_REPS_TO,                   UpdRepsTo       )
    ADV_CMD( IDS_CMD_DEL_REPS_TO,                   DelRepsTo       )
    ADV_CMD( IDS_CMD_TESTHOOK,                      TestHook        )
    ADV_CMD( IDS_CMD_SITEOPTIONS,                   SiteOptions     )
    // Exception this command takes DC_LIST, because it is so useful, and is 
    // one of the least dangerous commands.  Imagine the convience of:
    //         "repadmin options site:Red-Bldg40 -DISABLE_NTDSCONN_XLATE"
    STD_CMD( IDS_CMD_OPTIONS,                       Options         ) 
    // FUTURE-2002/07/21-BrettSh - It'd be cool if to check if the /Options
    // command had more than two options to confirm from the user that he
    // indeed wanted to modify the options on all these servers?  Also this
    // capability would be very useful to expand to the SiteOptions command
    // if a SITE_LIST type was ever created in the xList API.


    STD_CMD( IDS_CMD_REHOSTPARTITION,               RehostPartition )
    STD_CMD( IDS_CMD_UNHOSTPARTITION,               UnhostPartition )
    STD_CMD( IDS_CMD_REMOVESOURCES,                 RemoveSourcesPartition )

    // Old deprecated commands ... took commands in the wrong order.
    OLD_CMD( IDS_CMD_SHOW_VECTOR,                   ShowVector      )
    OLD_CMD( IDS_CMD_SYNC,                          Sync            )
    OLD_CMD( IDS_CMD_SHOW_REPS,                     ShowReps        )
    OLD_CMD( IDS_CMD_SHOW_META,                     ShowMeta        )
    OLD_CMD( IDS_CMD_PROPCHECK,                     PropCheck       )
    OLD_CMD( IDS_CMD_GETCHANGES,                    GetChanges      )

};

void
RepadminPrintDcListError(
    DWORD   dwXListReason
    )
/*++

Routine Description:

    Function for isolating all the printing needs for the xList()/DcList() functions.

Arguments:

    dwXListReason (IN) - 

--*/
{
    DWORD   dwReason = 0;
    WCHAR * szReasonArg = NULL; 
    
    DWORD   dwWin32Err = 0;
    WCHAR * szWin32Err = NULL;
    
    DWORD   dwLdapErr = 0;
    WCHAR * szLdapErr = NULL;
    DWORD   dwLdapExtErr = 0;
    WCHAR * szLdapExtErr = NULL;
    WCHAR * szExtendedErr = NULL;

    //
    // 1) Get all the error information the xList library has for us.
    //
    xListGetError(dwXListReason,
                  &dwReason,
                  &szReasonArg,
                  
                  &dwWin32Err,

                  &dwLdapErr,
                  &szLdapErr,
                  &dwLdapExtErr,
                  &szLdapExtErr,
                  &szExtendedErr
                  );

    //
    // 2) Try to print out something intelligent about why the DcList() function
    // couldn't continue.
    //
    Assert(dwReason); 
    switch (dwReason) {
    case XLIST_ERR_CANT_CONTACT_DC:
        PrintMsgCsvErr(REPADMIN_XLIST_CANT_CONNECT, szReasonArg);
        break;

    case XLIST_ERR_CANT_LOCATE_HOME_DC:                       
        PrintMsgCsvErr(REPADMIN_XLIST_CANT_LOCATE);
        break;
    
    case XLIST_ERR_CANT_RESOLVE_DC_NAME:                        
        if (szReasonArg) {
            PrintMsgCsvErr(REPADMIN_XLIST_CANT_RESOLVE_DC, szReasonArg);
        } else {
            Assert(!"This shouldn't happen");
            PrintMsgCsvErr(REPADMIN_XLIST_CANT_RESOLVE_DC, L" ");
        }
        break;

    case XLIST_ERR_CANT_RESOLVE_SITE_NAME:
        PrintMsgCsvErr(REPADMIN_XLIST_CANT_RESOLVE_SITE, szReasonArg);
        break;

    case XLIST_ERR_CANT_GET_FSMO:
        PrintMsgCsvErr(REPADMIN_XLIST_CANT_GET_FSMO, szReasonArg);
        break;

    case XLIST_ERR_NO_ERROR:
    default:
        // Unknown error, we'll still print out the real LDAP|Win32 error below.
        break;
    }

    if(bCsvMode()){
        // Extra error output not needed in CSV mode.
        return;
    }
                    
    //
    // 3) Next just print out the error that we recieved.
    //
    if (dwLdapErr) {
        PrintMsg(REPADMIN_XLIST_LDAP_EXTENDED_ERR,
                 dwLdapErr, szLdapErr,
                 dwLdapExtErr, szLdapExtErr,
                 szExtendedErr);
    } else if (dwWin32Err) {
        szWin32Err = GetWinErrMsg(dwWin32Err);
        if (szWin32Err) {
            PrintMsg(REPADMIN_XLIST_WIN32_ERR_MSG, dwWin32Err, szWin32Err);
            LocalFree(szWin32Err);
        } else {
            PrintMsg(REPADMIN_XLIST_WIN32_ERR, dwWin32Err);

        }
    }
    
}

int
DoDcListCmd(
    REPADMIN_CMD_ENTRY * pCmd,
    int argc, 
    LPWSTR argv[] 
    )
/*++

Routine Description:

    This command will take a normal repadmin command and run it once each
    time on each DC from the DC_LIST in the command. 
    
    This routine assumes that the first parameter after the command arg
    (ex: "/showrepl") excluding options (indicated by a "/" at the front) 
    is the DC_LIST argument.

Arguments:

    pCmd - The cmd to run.
    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    Error returned from the cmd, or possible error from the DcList.

--*/
{
    int         ret, iArg, err;
    int         iDsaArg = 0;
    PDC_LIST    pDcList = NULL;
    WCHAR *     szDsa = NULL;
    WCHAR **    pszArgV = NULL;

    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // 1) Get the DC_LIST argument
    //
    // First we must find the DC_LIST arg, which for a typical command is the 
    // first arg after the command that doesn't begin with a "/".
    for (iArg = 2; iArg < argc; iArg++) {
        if(argv[iArg][0] != L'/'){
            iDsaArg = iArg;
            break;
        }
    }

    if (iDsaArg == 0) {
        // User didn't specify DC ... DcListXxx functions will pick 
        // one for us, but we need to extend the argv by 1 parameter.
        
        pszArgV = LocalAlloc(LMEM_FIXED, (argc+1) * sizeof(WCHAR *));
        if (pszArgV == NULL) {
            PrintMsgCsvErr(REPADMIN_GENERAL_NO_MEMORY);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        for (iArg = 0; iArg < argc; iArg++) {
            pszArgV[iArg] = argv[iArg];
        }
        pszArgV[iArg] = L"."; // This means the DcList API will picks DC.
        iDsaArg = iArg;
        argc++;

    } else {
        pszArgV = argv;
    }

    // pszArgV[iDsaArg] is now the DC_LIST arg.
    Assert(iDsaArg != 0 && iDsaArg < argc && pszArgV[iDsaArg]);

    //
    // 2) Parse the DC_LIST argument.
    //
    err = DcListParse(pszArgV[iDsaArg], &pDcList);
    if (err) {
        // If we fail to even parse the command, lets just fall_back to
        // the command as is.
        PrintMsgCsvErr(REPADMIN_XLIST_UNPARSEABLE_DC_LIST, pszArgV[iDsaArg]);
        xListClearErrors();
        return(err);
    }
    Assert(pDcList);

    //
    // 3) Begine enumeration of the DC_LIST argument.
    //
    err = DcListGetFirst(pDcList, &szDsa);

    while ( err == ERROR_SUCCESS && szDsa ) {

        //
        // 4) Actually run the command.
        //
        if( ( !DcListIsSingleType(pDcList) ||
              (pDcList->cDcs == 1 && wcscmp(pszArgV[iDsaArg], szDsa)) )
            && ( pCmd->uNameID != IDS_CMD_VIEW_LIST )
           ){
            if (!bCsvMode()){
                PrintMsg(REPADMIN_DCLIST_RUNNING_SERVER_X, pszArgV[1], szDsa);
            }
        }

        pszArgV[iDsaArg] = szDsa;

        if (bCsvMode() &&
            !bIsCsvCmd(pCmd)) {

            // Hmmm, someone specified "/csv" output mode, but also specified a 
            // non-CSV capable command.  Print out an appropriate CSV'd error.
            PrintMsgCsvErr(REPADMIN_UNSUPPORTED_CSV_CMD, pszArgV[1]);

        } else {
        
            ret = (*pCmd->pfFunc)(argc, pszArgV);
            // We skip errors from the command and continue, command should've
            // printed out an appropriate error message.
            if (bCsvMode()){
                // The commands can't be trusted to reset the CSV params.
                ResetCsvParams();
            }
            
        }

        //
        // 5) Continue enumeration of the DC_LIST argument.
        //
        xListFree(szDsa);
        szDsa = NULL;
        pszArgV[iDsaArg] = NULL;
        err = DcListGetNext(pDcList, &szDsa);

    }
    Assert(szDsa == NULL);

    //
    // 6) Print errors if any and clean up.
    //
    if (err) {
        RepadminPrintDcListError(err);
        xListClearErrors();
    }
    
    if (!bCsvMode()){
        PrintMsg(REPADMIN_PRINT_CR);
    }

    // Clean up DcList.
    DcListFree(&pDcList);
    Assert(pDcList == NULL);
    if (pszArgV != argv) {
        // We allocated our own argv clean that.
        LocalFree(pszArgV);
    }

    return(ret);
}

int
__cdecl wmain( int argc, LPWSTR argv[] )
{
    int     ret = 0;
    WCHAR   szCmdName[64];
    DWORD   i;
    HMODULE hMod = GetModuleHandle(NULL);

    // Sets the locale properly and initializes DsConLib
    DsConLibInit();

    // Initialize debug library.
    DEBUGINIT(0, NULL, "repadmin");

#ifdef DBG
    // Print out the command line arguments for debugging, except 
    // the credential arguments ...
    for (i = 0; i < (DWORD) argc; i++) {
        if (wcsprefix(argv[i], L"/p:")        ||
            wcsprefix(argv[i], L"/pw:")       ||
            wcsprefix(argv[i], L"/pass:")     ||
            wcsprefix(argv[i], L"/password:")
            ){
            PrintMsg(REPADMIN_PRINT_STR_NO_CR, L"/pw:*****");
        } else if (wcsprefix(argv[i], L"/u:")        ||
                   wcsprefix(argv[i], L"/user:")) {
            PrintMsg(REPADMIN_PRINT_STR_NO_CR, L"/u:<user>");
        } else {
            PrintMsg(REPADMIN_PRINT_STR_NO_CR, argv[i]);
        }
        PrintMsg(REPADMIN_PRINT_SPACE);
    }
    PrintMsg(REPADMIN_PRINT_CR);
#endif
    
    if (argc < 2) {
       PrintHelp(FALSE);
       return(0);
    }
    
    ret = PreProcessGlobalParams(&argc, &argv);
    if (ret) {
        return(ret);
    }

    // 
    // Now figure out which command we want
    //
    for (i=0; i < ARRAY_SIZE(rgCmdTable); i++) {
        raLoadString(rgCmdTable[i].uNameID,
                     ARRAY_SIZE(szCmdName),
                     szCmdName);

        if (((argv[1][0] == L'-') || (argv[1][0] == L'/'))
            && (0 == _wcsicmp(argv[1]+1, szCmdName))) {
            
            // Execute requested command.

            if ( bIsDcArgCmd(rgCmdTable[i]) ) {

                // This command takes a DC_LIST as it's first argument
                DoDcListCmd( &rgCmdTable[i], argc, argv);

            } else {

                // Some commands are very simple or do thier own arg processing ...
                // call them directly ...

                if (bCsvMode() &&
                    !bIsCsvCmd(&(rgCmdTable[i]))) {

                    // Hmmm, someone specified "/csv" output mode, but also specified a 
                    // non-CSV capable command.  Print out an appropriate CSV'd error.
                    PrintMsgCsvErr(REPADMIN_UNSUPPORTED_CSV_CMD);

                } else {

                    ret = (*rgCmdTable[i].pfFunc)(argc, argv);
                    if (bCsvMode()){
                        // The commands can't be trusted to reset the CSV params.
                        ResetCsvParams();
                    }

                }
            
            }
            break;
        }
    }

    if (i == ARRAY_SIZE(rgCmdTable)) {
        // Invalid command.
        PrintHelp( FALSE /* novice help */ );
        ret = ERROR_INVALID_FUNCTION;
    }

    xListCleanLib();

    DEBUGTERM();
    
    return ret;
}

void
PrintHelpEx(
    DWORD  dwHelp
    )
{
    if (bCsvMode()) {
        PrintMsgCsvErr(REPADMIN_HELP_NO_HELP_IN_CSV_MODE);
        return;
    }
    if (dwHelp & HELP_BASIC) {
        PrintMsg(REPADMIN_NOVICE_HELP);
    }
    if (dwHelp & HELP_OLD) {
        PrintMsg(REPADMIN_OLD_HELP);
    }
    if (dwHelp & HELP_LIST) {
        PrintMsg(REPADMIN_XLIST_LIST_HELP);
    }
    if (dwHelp & HELP_CSV) {
        PrintMsg(REPADMIN_CSV_HELP);
    }
    
    // Expert help
    if (dwHelp & HELP_EXPERT) {
        PrintMsg(REPADMIN_EXPERT_HELP);
    }
}

void PrintHelp(
    BOOL fExpert
    ){
    PrintHelpEx((fExpert) ? HELP_BASIC | HELP_EXPERT : HELP_BASIC);
}


#define CR        0xD
#define BACKSPACE 0x8

int
GetPassword(
    WCHAR *     pwszBuf,
    DWORD       cchBufMax,
    DWORD *     pcchBufUsed
    )
/*++

Routine Description:

    Retrieve password from command line (without echo).
    Code stolen from LUI_GetPasswdStr (net\netcmd\common\lui.c).

Arguments:

    pwszBuf - buffer to fill with password
    cchBufMax - buffer size (incl. space for terminating null)
    pcchBufUsed - on return holds number of characters used in password

Return Values:

    DRAERR_Success - success
    other - failure

--*/
{
    WCHAR   ch;
    WCHAR * bufPtr = pwszBuf;
    DWORD   c;
    int     err;
    int     mode;

    cchBufMax -= 1;    /* make space for null terminator */
    *pcchBufUsed = 0;               /* GP fault probe (a la API's) */
    
    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode)) {
        err = GetLastError();
        PrintToErr(REPADMIN_FAILED_TO_READ_CONSOLE_MODE);
        return err;
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
        if (!err || c != 1)
            ch = 0xffff;

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
            break;

        if (ch == BACKSPACE) { /* back up one or two */
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != pwszBuf) {
                bufPtr--;
                (*pcchBufUsed)--;
            }
        }
        else {

            *bufPtr = ch;

            if (*pcchBufUsed < cchBufMax)
                bufPtr++ ;                   /* don't overflow buf */
            (*pcchBufUsed)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = L'\0';         /* null terminate the string */
    PrintToErr(REPADMIN_PRINT_CR);

    if (*pcchBufUsed > cchBufMax)
    {
        //printf("Password too long!\n");
        PrintToErr( REPADMIN_PASSWORD_TOO_LONG );
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}

int
PreProcessGlobalParams(
    int *    pargc,
    LPWSTR **pargv
    )
/*++

Routine Description:

    Scan command arguments for user-supplied credentials of the form
        [/-](u|user):({domain\username}|{username})
        [/-](p|pw|pass|password):{password}
    Set credentials used for future DRS RPC calls and LDAP binds appropriately.
    A password of * will prompt the user for a secure password from the console.

    Also scan args for /async, which adds the DRS_ASYNC_OP flag to all DRS RPC
    calls.

    CODE.IMPROVEMENT: The code to build a credential is also available in
    ntdsapi.dll\DsMakePasswordCredential().

Arguments:

    pargc
    pargv

Return Values:

    ERROR_Success - success
    other - failure

--*/
{
    int     ret = 0;
    int     iArg;
    LPWSTR  pszOption;
    DWORD   cchOption;
    LPWSTR  pszDelim;
    LPWSTR  pszValue;
    DWORD   cchValue;
    DWORD   dwHelp = 0;

    for (iArg = 1; iArg < *pargc; )
    {
        if (((*pargv)[iArg][0] != L'/') && ((*pargv)[iArg][0] != L'-'))
        {
            // Not an argument we care about -- next!
            iArg++;
        }
        else
        {
            pszOption = &(*pargv)[iArg][1];
            pszDelim = wcschr(pszOption, L':');

            if (NULL == pszDelim)
            {
                if (0 == _wcsicmp(L"async", pszOption))
                {
                    // This constant is the same for all operations
                    gulDrsFlags |= DS_REPADD_ASYNCHRONOUS_OPERATION;

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else if (0 == _wcsicmp(L"csv", pszOption))
                {
                    //
                    // Initialize the CSV state.
                    //
                    CsvSetParams(eCSV_REPADMIN_CMD, L"-", L"-");

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else if (0 == _wcsicmp(L"ldap", pszOption))
                {
                    _DsBindSpoofSetTransportDefault( TRUE /* use LDAP */ );

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else if (0 == _wcsicmp(L"rpc", pszOption))
                {
                    _DsBindSpoofSetTransportDefault( FALSE /* use RPC */ );

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else if (0 == _wcsicmp(L"help", pszOption))
                {
                    dwHelp |= HELP_BASIC;
                    iArg++; // The help screens are going kill this run of
                    // repadmin anyway, so it doesn't matter if we absorb them
                }
                else if (0 == _wcsicmp(L"advhelp", pszOption) ||
                         0 == _wcsicmp(L"experthelp", pszOption))
                {
                    dwHelp |= HELP_BASIC | HELP_EXPERT;
                    iArg++;
                }
                else if (0 == _wcsicmp(L"oldhelp", pszOption))
                {
                    dwHelp |= HELP_OLD;
                    iArg++;
                }
                else if (0 == _wcsicmp(L"listhelp", pszOption))
                {
                    dwHelp |= HELP_LIST;
                    iArg++;
                }
                else if (0 == _wcsicmp(L"csvhelp", pszOption))
                {
                    dwHelp |= HELP_CSV;
                    iArg++;
                }
                else if (0 == _wcsicmp(L"allhelp", pszOption))
                {
                    dwHelp |= HELP_BASIC | HELP_LIST | HELP_OLD | HELP_EXPERT | HELP_CSV;
                    iArg++;
                }
                else
                {
                    // Not an argument we care about -- next!
                    iArg++;
                }
            }
            else
            {
                cchOption = (DWORD)(pszDelim - (*pargv)[iArg]);

                if (    (0 == _wcsnicmp(L"p:",        pszOption, cchOption))
                     || (0 == _wcsnicmp(L"pw:",       pszOption, cchOption))
                     || (0 == _wcsnicmp(L"pass:",     pszOption, cchOption))
                     || (0 == _wcsnicmp(L"password:", pszOption, cchOption)) )
                {
                    // User-supplied password.
                    pszValue = pszDelim + 1;
                    cchValue = 1 + wcslen(pszValue);

                    if ((2 == cchValue) && ('*' == pszValue[0]))
                    {
                        // Get hidden password from console.
                        cchValue = 64;

                        gCreds.Password = malloc(sizeof(WCHAR) * cchValue);

                        if (NULL == gCreds.Password)
                        {
                            PrintToErr(REPADMIN_PRINT_STRING_ERROR, 
                                     Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }

                        // Note: we're not technically printing an error here, but this
                        // function just prints to stderr because this gets past any 
                        // file redirects on the command line.
                        PrintToErr(REPADMIN_PASSWORD_PROMPT);

                        ret = GetPassword(gCreds.Password, cchValue, &cchValue);
                    }
                    else
                    {
                        // Get password specified on command line.
                        gCreds.Password = pszValue;
                    }

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else if (    (0 == _wcsnicmp(L"u:",    pszOption, cchOption))
                          || (0 == _wcsnicmp(L"user:", pszOption, cchOption)) )
                {
                    // User-supplied user name (and perhaps domain name).
                    pszValue = pszDelim + 1;
                    cchValue = 1 + wcslen(pszValue);

                    pszDelim = wcschr(pszValue, L'\\');

                    if (NULL == pszDelim)
                    {
                        // No domain name, only user name supplied.
                        //printf("User name must be prefixed by domain name.\n");
                        PrintToErr( REPADMIN_DOMAIN_BEFORE_USER );
                        return ERROR_INVALID_PARAMETER;
                    }

                    *pszDelim = L'\0';
                    gCreds.Domain = pszValue;
                    gCreds.User = pszDelim + 1;

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else if (0 == _wcsnicmp(L"homeserver:", pszOption, cchOption))
                {
                    xListSetHomeServer(pszDelim+1);

                    // Next!
                    memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
                    --(*pargc);
                }
                else
                {
                    iArg++;
                }
            }
        }
    }

    if (NULL == gCreds.User)
    {
        if (NULL != gCreds.Password)
        {
            // Password supplied w/o user name.
            //printf( "Password must be accompanied by user name.\n" );
            PrintToErr( REPADMIN_PASSWORD_NEEDS_USERNAME );
            ret = ERROR_INVALID_PARAMETER;
        }
        else
        {
            // No credentials supplied; use default credentials.
            ret = ERROR_SUCCESS;
        }
    }
    else
    {
        gCreds.PasswordLength = gCreds.Password ? wcslen(gCreds.Password) : 0;
        gCreds.UserLength   = wcslen(gCreds.User);
        gCreds.DomainLength = gCreds.Domain ? wcslen(gCreds.Domain) : 0;
        gCreds.Flags        = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        // CODE.IMP: The code to build a SEC_WINNT_AUTH structure also exists
        // in DsMakePasswordCredentials.  Someday use it

        // Use credentials in DsBind and LDAP binds
        gpCreds = &gCreds;
    }

    if (dwHelp) {
        // We're going to print help here and return an error so we bail, 
        PrintHelpEx(dwHelp);
        return(ERROR_INVALID_PARAMETER);
    }

    return ret;
}

void
RepadminPrintObjListError(
    DWORD   xListRet
    )
/*++

Routine Description:

    Function for isolating all the printing needs for the xList()/DcList() functions.

Arguments:

    xListRet (IN) - 

--*/
{
    DWORD   dwReason = 0;
    WCHAR * szReasonArg = NULL; 
    
    DWORD   dwWin32Err = 0;
    WCHAR * szWin32Err = NULL;
    
    DWORD   dwLdapErr = 0;
    WCHAR * szLdapErr = NULL;
    DWORD   dwLdapExtErr = 0;
    WCHAR * szLdapExtErr = NULL;
    WCHAR * szExtendedErr = NULL;

    //
    // 1) Get all the error information the xList library has for us.
    //
    xListGetError(xListRet,
                  &dwReason,
                  &szReasonArg,
                  
                  &dwWin32Err,

                  &dwLdapErr,
                  &szLdapErr,
                  &dwLdapExtErr,
                  &szLdapExtErr,
                  &szExtendedErr
                  );

    //
    // 2) Try to print out something intelligent about why the DcList() function
    // couldn't continue.
    //
    Assert(dwReason); 
    switch (dwReason) {
    case XLIST_ERR_BAD_PARAM:
        PrintMsgCsvErr(REPADMIN_GENERAL_INVALID_ARGS);
        break;

    case XLIST_ERR_NO_MEMORY:
        PrintMsgCsvErr(REPADMIN_GENERAL_NO_MEMORY);

    case XLIST_ERR_NO_SUCH_OBJ:
        if (szReasonArg) {
            PrintMsgCsvErr(REPADMIN_OBJ_LIST_BAD_DN, szReasonArg);
        } else {
            PrintMsgCsvErr(REPADMIN_GENERAL_INVALID_ARGS);
            break;
        }

    case XLIST_ERR_PARSE_FAILURE:
        if (szReasonArg) {
            PrintMsgCsvErr(REPADMIN_OBJ_LIST_BAD_SYNTAX);
            if (!bCsvMode()) {
                PrintMsgCsvErr(REPADMIN_PRINT_STR, szReasonArg);
            }
        } else {
            PrintMsgCsvErr(REPADMIN_OBJ_LIST_BAD_SYNTAX);
            break;
        }

    case XLIST_ERR_NO_ERROR:
    default:
        // Unknown error, we'll still print out the real LDAP|Win32 error below.
        break;
    }

    if(bCsvMode()){
        // Extra error output not needed in CSV mode.
        return;
    }
                    
    //
    // 3) Next just print out the error that we recieved.
    //
    if (dwLdapErr) {
        PrintMsg(REPADMIN_XLIST_LDAP_EXTENDED_ERR,
                 dwLdapErr, szLdapErr,
                 dwLdapExtErr, szLdapExtErr,
                 szExtendedErr);
    } else if (dwWin32Err) {
        szWin32Err = GetWinErrMsg(dwWin32Err);
        if (szWin32Err) {
            PrintMsg(REPADMIN_XLIST_WIN32_ERR_MSG, dwWin32Err, szWin32Err);
            LocalFree(szWin32Err);
        } else {
            PrintMsg(REPADMIN_XLIST_WIN32_ERR, dwWin32Err);

        }
    }
    
}


int ViewList(
    int argc, 
    LPWSTR argv[]
    )
/*++

Routine Description:

    This is just a debug or displayer routine for the results/DCs returned bye the 
    xList/DcList() APIs.

Arguments:

    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    1

--*/
{
    static int  iDc = 1;
    int         iObj = 1;
    LDAP *      hLdap = NULL;
    DWORD       dwRet;
    OBJ_LIST *  pObjList = NULL;
    WCHAR *     szObj = NULL;
    WCHAR **              argvTemp = NULL;

    __try {

        // Since this command can be called over and over again, we can't
        // consume the args from the master arg list.
        argvTemp  = LocalAlloc(LMEM_FIXED, argc * sizeof(WCHAR *));
        CHK_ALLOC(argvTemp);
        memcpy(argvTemp, argv, argc * sizeof(WCHAR *));
        argv = argvTemp;

        dwRet = ConsumeObjListOptions(&argc, argv, &pObjList);
        if (dwRet) {
            RepadminPrintObjListError(dwRet);
            xListClearErrors();
            dwRet = ERROR_INVALID_PARAMETER;
            __leave;
        }

        if (argc < 3) {
            Assert(!"Hmmm, why did the DcList API let us through...");
            dwRet = ERROR_INVALID_PARAMETER;
            __leave;
        }

        PrintMsg(REPADMIN_VIEW_LIST_DC, iDc++, argv[2]);

        if (argc < 4) {
            //
            // Success, they didn't ask for any object DNs, so we get to bail early.
            //
            dwRet = 0;
            __leave;
        }

        //
        // More than 3 args, we've got an OBJ_LIST parameter (argv[3])!
        //

        dwRet = RepadminLdapBind(argv[2], &hLdap);
        if (dwRet) {
            // error printed by repadmin.
            __leave;
        }

        dwRet = ObjListParse(hLdap, 
                             argv[3],
                             aszNullAttrs,
                             NULL, // No controls ...
                             &pObjList);
        if (dwRet) {
            RepadminPrintObjListError(dwRet);
            xListClearErrors();
            __leave;
        }


        dwRet = ObjListGetFirstDn(pObjList, &szObj);
        if (dwRet) {
            RepadminPrintObjListError(dwRet);
            xListClearErrors();
            __leave;
        }
        Assert(szObj);

        do {

            PrintMsg(REPADMIN_VIEW_LIST_OBJ, iObj++, szObj);

            xListFree(szObj);
            szObj = NULL;
            dwRet = ObjListGetNextDn(pObjList, &szObj);

        } while ( dwRet == ERROR_SUCCESS && szObj );

        if (dwRet) {
            RepadminPrintObjListError(dwRet);
            xListClearErrors();
            __leave;
        }


    } __finally {
        if (hLdap) { RepadminLdapUnBind(&hLdap); }
        if (pObjList) { ObjListFree(&pObjList); }
        if (szObj) { xListFree(szObj); }
        if (argvTemp) { LocalFree(argvTemp); }
        xListClearErrors();
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\repadmin.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    repadmin.h

Abstract:

    abstract

Author:

    Will Lees (wlees) 02-Jul-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#ifndef _REPADMIN_
#define _REPADMIN_

#include "msg.h"            
#include "x_list.h"
#include <drasig.h>   // REPL_DSA_SIGNATURE_VECTOR_NATIVE

// Global credentials.
extern SEC_WINNT_AUTH_IDENTITY_W   gCreds;
extern SEC_WINNT_AUTH_IDENTITY_W * gpCreds;

// Global DRS RPC call flags.  Should hold 0 or DRS_ASYNC_OP.
extern ULONG gulDrsFlags;

// Global is repadmin in CSV output mode state.  CSV = Comma Seperated Values
#include "csv.h"


// An zero-filled filetime to compare against
extern FILETIME ftimeZero;

void PrintHelp(
    BOOL fExpert
    );

int Add(int argc, LPWSTR argv[]);
int Del(int argc, LPWSTR argv[]);
int Sync(int argc, LPWSTR argv[]);
int Replicate(int argc, LPWSTR argv[]); // new /sync
int SyncAll(int argc, LPWSTR argv[]);
int ShowReps(int argc, LPWSTR argv[]);
int ShowRepl(int argc, LPWSTR argv[]); // new /showreps
int ShowVector(int argc, LPWSTR argv[]);
int ShowUtdVec(int argc, LPWSTR argv[]); // new /showutdvec
int ShowMeta(int argc, LPWSTR argv[]);
int ShowObjMeta(int argc, LPWSTR argv[]); // new /showmeta
int ShowTime(int argc, LPWSTR argv[]);
int ShowMsg(int argc, LPWSTR argv[]);
int Options(int argc, LPWSTR argv[]);
int FullSyncAll(int argc, LPWSTR argv[]);
int RunKCC(int argc, LPWSTR argv[]);
int Bind(int argc, LPWSTR argv[]);
int Queue(int argc, LPWSTR argv[]);
int PropCheck(int argc, LPWSTR argv[]);
int CheckProp(int argc, LPWSTR argv[]); // new /propcheck
int FailCache(int argc, LPWSTR argv[]);
int ShowIsm(int argc, LPWSTR argv[]);
int GetChanges(int argc, LPWSTR argv[]);
int ShowChanges(int argc, LPWSTR argv[]); // new /getchanges
int ShowSig(int argc, LPWSTR argv[]);
int ShowCtx(int argc, LPWSTR argv[]);
int ShowConn(int argc, LPWSTR argv[]);
int ShowCert(int argc, LPWSTR argv[]);
int UpdRepsTo(int argc, LPWSTR argv[]);
int AddRepsTo(int argc, LPWSTR argv[]);
int DelRepsTo(int argc, LPWSTR argv[]);
int ShowValue(int argc, LPWSTR argv[]);
int Mod(int argc, LPWSTR argv[]);
int Latency(int argc, LPWSTR argv[]);
int Istg(int argc, LPWSTR argv[]);
int Bridgeheads(int argc, LPWSTR argv[]);
int TestHook(int argc, LPWSTR argv[]);
int DsaGuid(int argc, LPWSTR argv[]);
int SiteOptions(int argc, LPWSTR argv[]);
int ShowProxy(int argc, LPWSTR argv[]);
int RemoveLingeringObjects(int argc, LPWSTR argv[]);
int NotifyOpt(int argc, LPWSTR argv[]);
int ReplSingleObj(int argc, LPWSTR argv[]);
int ShowTrust(int argc, LPWSTR argv[]);
int QuerySites(int argc, LPWSTR argv[]);
int ShowServerCalls(int argc, LPWSTR argv[]);
int ShowNcSig(int argc, LPWSTR argv[]);
int ViewList(int argc, LPWSTR argv[]);
int ShowAttr(int argc, LPWSTR argv[]);
int ReplSummary(int argc, LPWSTR argv[]);
int RehostPartition(int argc, LPWSTR argv[]);
int UnhostPartition(int argc, LPWSTR argv[]);
int RemoveSourcesPartition(int argc, LPWSTR argv[]);

#define IS_REPS_FROM    ( TRUE )
#define IS_REPS_TO      ( FALSE )

#define DEFAULT_PAGED_SEARCH_PAGE_SIZE   (1000)

typedef struct {
    BOOL        fNotFirst;
    BOOL        fVerbose;
    BOOL        fErrorsOnly;
    BOOL        fIntersiteOnly;
    LPWSTR      pszSiteRdn; // for fIntersiteOnly..
    LPWSTR      pszLastNC;
} SHOW_NEIGHBOR_STATE;

DWORD
ShowNeighbor(
    DS_REPL_NEIGHBORW * pNeighbor,
    ULONG               fRepsFrom,
    void *              pvState
    );

LPWSTR GetNtdsDsaDisplayName(LPWSTR pszDsaDN);
LPWSTR GetNtdsSiteDisplayName(LPWSTR pszSiteDN);

int GetSiteOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszSiteDN,
    OUT int *   pnOptions
    );

LPWSTR GetTransportDisplayName(LPWSTR pszTransportDN);

int
GetRootDomainDNSName(
    IN  LPWSTR   pszDSA,
    OUT LPWSTR * ppszRootDomainDNSName
    );

#define AllocConvertWide(a,w) AllocConvertWideEx(CP_ACP,a,w)

DWORD
AllocConvertWideEx(
    IN  INT     nCodePage,
    IN  LPCSTR  StringA,
    OUT LPWSTR *pStringW
    );

LPSTR GetDsaOptionsString(int nOptions);
LPSTR GetSiteOptionsString(int nOptions);
LPWSTR
GetDsaDnsName(
    PLDAP       hld,
    LPWSTR      pwszDsa
    );

void
PrintMsgCsvErr(
    IN  DWORD        dwMessageCode,
    IN  ...
    );


#define ARRAY_SIZE(x) (sizeof(x)/sizeof(*(x)))


#define GET_EXT_LD_ERROR( hld, x, pRet ) {        \
    if (x!=LDAP_SUCCESS) {                        \
        ULONG ulError = ERROR_SUCCESS;            \
	ULONG ldapErr = LDAP_SUCCESS;             \
        ldapErr = ldap_get_option(hld, LDAP_OPT_SERVER_EXT_ERROR, &ulError); \
	if (ldapErr == LDAP_SUCCESS) {            \
           *pRet = ulError;                       \
	} else {                                  \
           *pRet = LdapMapErrorToWin32(x);        \
	}                                         \
     } else {                                     \
        *pRet = ERROR_SUCCESS;                    \
     }                                            \
}

#define CHK_LD_STATUS( x )                        \
{                                                 \
    ULONG err;                                    \
    if ( LDAP_SUCCESS != (x) )                    \
    {                                             \
        err = LdapMapErrorToWin32(x);             \
        PrintMsgCsvErr(REPADMIN_GENERAL_LDAP_ERR,       \
                __FILE__,                         \
                __LINE__,                         \
                (x),                              \
                ldap_err2stringW( x ),            \
                err );                            \
        return( x );                              \
    }                                             \
}

#define REPORT_LD_STATUS( x )                     \
{                                                 \
    if ( LDAP_SUCCESS != (x) )                    \
    {                                             \
        PrintMsgCsvErr(REPADMIN_GENERAL_LDAP_ERR,       \
                __FILE__,                         \
                __LINE__,                         \
                (x),                              \
                ldap_err2stringW( x ) );          \
    }                                             \
}

#define CHK_ALLOC(x) {                            \
    if (NULL == (x)) {                            \
        PrintMsgCsvErr(REPADMIN_GENERAL_NO_MEMORY);     \
        exit(ERROR_OUTOFMEMORY);                  \
    }                                             \
}

#define PrintErrEnd(err)                PrintMsgCsvErr(REPADMIN_GENERAL_ERR, err, err, Win32ErrToString(err));

#define PrintTabErrEnd(tab, err)        { PrintMsg(REPADMIN_GENERAL_ERR_NUM, err, err); \
                                          PrintTabMsg(tab, REPADMIN_PRINT_STR, Win32ErrToString(err)); }
                                          
#define PrintFuncFailed(pszFunc, err)   { if (bCsvMode()){ \
                                             PrintMsgCsvErr(REPADMIN_GENERAL_FUNC_FAILED_STATUS, pszFunc, err); \
                                          } else { \
                                              PrintMsg(REPADMIN_GENERAL_FUNC_FAILED, pszFunc);  \
                                              PrintErrEnd(err); \
                                          } \
                                        }
                                          
#define PrintFuncFailedArgs(pszFunc, args, err)   { PrintMsg(REPADMIN_GENERAL_FUNC_FAILED_ARGS, pszFunc, args);  \
                                          PrintErrEnd(err); }
                                          
#define PrintBindFailed(pszHost, err)   { if (bCsvMode()){ \
                                              PrintMsgCsvErr(REPADMIN_BIND_FAILED_STATUS, pszHost, err); \
                                          } else { \
                                              PrintMsg(REPADMIN_BIND_FAILED, pszHost);  \
                                              PrintErrEnd(err); \
                                          } \
                                        }
                                          
#define PrintUnBindFailed(err)          { PrintMsgCsvErr(REPADMIN_BIND_UNBIND_FAILED);  \
                                          PrintErrEnd(err); }


// Define Assert for the free build
#if !DBG
#undef Assert
#define Assert( exp )   { if (!(exp)) PrintMsg(REPADMIN_GENERAL_ASSERT, #exp, __FILE__, __LINE__ ); }
#endif

// reputil.c

typedef struct _GUID_CACHE_ENTRY {
    GUID    Guid;
    WCHAR   szDisplayName[132];
} GUID_CACHE_ENTRY;

typedef struct _DSA_CACHE_ENTRY {
    GUID    DsaGuid;
    GUID    InvocId;
    REPL_DSA_SIGNATURE_VECTOR_NATIVE * pDsaSigVec;
    WCHAR   szDisplayName[132];
} DSA_CACHE_ENTRY;

LPWSTR
Win32ErrToString(
    IN  ULONG   dwMsgId
    );

LPWSTR
NtdsmsgToString(
    IN  ULONG   dwMsgId
    );

int
BuildGuidCache(
    IN  LDAP *  hld
    );

LPWSTR
GetDsaGuidDisplayName(
    IN  GUID *  pGuid
    );

LPWSTR
GetTrnsGuidDisplayName(
    IN  GUID *  pGuid
    );

ULONG
GetPublicOptionByNameW(
    OPTION_TRANSLATION * Table,
    LPWSTR pszPublicOption
    );

LPWSTR
GetOptionsString(
    IN  OPTION_TRANSLATION *  Table,
    IN  ULONG                 PublicOptions
    );

LPWSTR
GetStringizedGuid(
    IN  GUID *  pGuid
    );

void
printBitField(
    DWORD BitField,
    WCHAR **ppszBitNames
    );

void
printSchedule(
    PBYTE pSchedule,
    DWORD cbSchedule
    );

void
totalScheduleUsage(
    PVOID *ppContext,
    PBYTE pSchedule,
    DWORD cbSchedule,
    DWORD cNCs
    );

void
raLoadString(
    IN  UINT    uID,
    IN  DWORD   cchBuffer,
    OUT LPWSTR  pszBuffer
    );

// repldap.c
int
SetDsaOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszDsaDN,
    IN  int     nOptions
    );

int
GetDsaOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszDsaDN,
    OUT int *   pnOptions
    );

void
PrintTabMsg(
    IN  DWORD   dwTabs,
    IN  DWORD   dwMessageCode,
    IN  ...
    );

void
PrintString(
    IN  WCHAR * szString
    );

void
PrintMsg(
    IN  DWORD   dwMessageCode,
    IN  ...
    );

void
PrintToErr(
    IN  DWORD   dwMessageCode,
    IN  ...
    );

DWORD
GeneralizedTimeToSystemTime(
    LPWSTR IN                   szTime,
    PSYSTEMTIME OUT             psysTime);

void
InitDSNameFromStringDn(
    LPWSTR pszDn,
    PDSNAME pDSName
    );

DWORD
CountNamePartsStringDn(
    LPWSTR pszDn
    );

DWORD
WrappedTrimDSNameBy(
           IN  WCHAR *                          InString,
           IN  DWORD                            NumbertoCut,
           OUT WCHAR **                         OutString
           );

int
GetNCLists(
    IN  LDAP *  hld,
    IN  LPWSTR  pszDsaDN,
    OUT LPWSTR ** prgpszNameContexts,
    OUT int *   pcNameContexts
    );

int
GetNTDSA(
    IN LDAP * hld,
    OUT LPWSTR * ppszDsaDN
    );

// API for replctrl.c
// Move this to ntdsapi.h someday
DWORD
DsMakeReplCookieForDestW(
    DS_REPL_NEIGHBORW *pNeighbor,
    DS_REPL_CURSORS * pCursors,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    );
DWORD
DsFreeReplCookie(
    PBYTE pCookie
    );
DWORD
DsGetSourceChangesW(
    LDAP *m_pLdap,
    LPWSTR m_pSearchBase,
    LPWSTR pszSourceFilter,
    DWORD dwReplFlags,
    PBYTE pCookieCurr,
    DWORD dwCookieLenCurr,
    LDAPMessage **ppSearchResult,
    BOOL *pfMoreData,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    PWCHAR *ppAttListArray
    );

int
FindConnections(
    LDAP *          hld,
    LPWSTR          pszBaseSearchDn,
    LPWSTR          pszFrom,
    BOOL            fShowConn,
    BOOL            fVerbose,
    BOOL            fIntersite
    );

DWORD
ConvertAttList(
    LPWSTR pszAttList,
    PWCHAR ** paszAttrList
    );

LPWSTR
ParseInputW(
    LPWSTR pszInput,
    WCHAR wcDelim,
    DWORD dwInputIndex
    );

DWORD
RepadminDsBind(
    LPWSTR   szServer,
    HANDLE * phDS
    );

void
CsvSetParams(
    IN  enum eCsvCmd eCsvCmd,
    WCHAR *  szSite,
    WCHAR *  szServer
    );

#define ResetCsvParams()  CsvSetParams(eCSV_REPADMIN_CMD, L"-", L"-");

DWORD
GetNtdsDsaSiteServerPair(
    IN  LPWSTR pszDsaDN,
    IN  LPWSTR * ppszSiteName,
    IN  LPWSTR * ppszServerName
    );

WCHAR *        
DSTimeToDisplayStringW(
    DSTIME  dsTime,
    WCHAR * wszTime,
    ULONG   cchTime
    );

INT
MemWtoi(WCHAR *pb, ULONG cch);


#define RepadminLdapBind(szS, phL)     RepadminLdapBindEx(szS, LDAP_PORT, TRUE, TRUE, phL)
#define RepadminLdapBindGc(szS, phL)   RepadminLdapBindEx(szS, LDAP_GC_PORT, TRUE, TRUE, phL)

DWORD
RepadminLdapBindEx(
    WCHAR *     szServer,
    ULONG       iPort,
    BOOL	fReferrals,
    BOOL        fPrint,
    LDAP **     phLdap
    );

DWORD
RepadminLdapUnBind(
    LDAP **    phLdap
    );

void
RepadminPrintDcListError(
    DWORD   dwXListReason
    );

void
RepadminPrintObjListError(
    DWORD   xListRet
    );

#endif /* _REPADMIN_ */

/* end repadmin.h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\repbind.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repldap.c - ldap based utility functions

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

    09 14 1999 - BrettSh added paged

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>   // byte order funtions
#include <ntldap.h>     // SHOW_DELETED_OID

#include <ndnc.h>     // Various CorssRef manipulations helper functions.

#include "repadmin.h"

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0 | (0xFFFF & __LINE__))


DWORD
RepadminDsBind(
    LPWSTR   szServer,
    HANDLE * phDS
    )
/*++

Routine Description:

    This gets the appropriate binding for the server specified.

Arguments:

    szServer [IN] - string DNS of server to bind to
    phDS [OUT]    - binding handle out.

Return Value:

    win 32 error code from DsBindXxxx()

--*/
{
    Assert(phDS);
    *phDS = NULL;
    return(DsBindWithSpnExW(szServer,
                            NULL,
                            (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                            NULL,
                            0,
                            phDS));
}

DWORD
RepadminLdapBindEx(
    WCHAR *     szServer,
    ULONG       iPort,
    BOOL        fReferrals,
    BOOL        fPrint,
    LDAP **     phLdap
    )
/*++

Routine Description:

    This gets the appropriate binding for the server specified.

Arguments:

    szServer [IN] - string DNS of server to bind to. (expects server, not domain dns)
    iPort [IN] - Port to bind to.  Typical choices are.
    fPrint [IN] - Whether to print bind failures ...
    phDS [OUT] - binding handle out.

Return Value:

    win 32 error code from DsBindXxxx()

--*/
{
    DWORD ldStatus;
    ULONG ulOptions;
    DWORD err = 0;

    Assert(phLdap);
    
    // Connect & bind to target DSA.
    *phLdap = ldap_initW(szServer, iPort);
    if (NULL == *phLdap) {
        if (fPrint) {
            PrintMsgCsvErr(REPADMIN_GENERAL_LDAP_UNAVAILABLE, szServer);
        }
        return ERROR_DS_UNAVAILABLE;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( *phLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    // Follow referrals if the user specified to.
    if (fReferrals) {
        ulOptions = PtrToUlong(LDAP_OPT_ON);
    } else {
        ulOptions = PtrToUlong(LDAP_OPT_OFF);
    }   
    (void)ldap_set_optionW( *phLdap, LDAP_OPT_REFERRALS, &ulOptions );

    ldStatus = ldap_bind_s(*phLdap, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    if ( LDAP_SUCCESS != ldStatus ){
        err = LdapMapErrorToWin32(ldStatus);
        if (fPrint) {
            PrintMsgCsvErr(REPADMIN_GENERAL_LDAP_ERR, __FILE__, __LINE__,
                    ldStatus, ldap_err2stringW( ldStatus ), err );
        }
        ldap_unbind(*phLdap);
        *phLdap = NULL;
        return( err );
    }

    return(err);
}


DWORD
RepadminLdapUnBind(
    LDAP **    phLdap
    )
/*++

Routine Description:

    This unbinds the appropriate server binding handle ... we may wish to not
    unbind and cache binding handles some day, so this is preferrable to ldap_unbind()

Arguments:

    szServer [IN] - string DNS of server to bind to. (expects server, not domain dns)
    phDS [OUT]    - binding handle out.

Return Value:

    win 32 error code from DsBindXxxx()

--*/
{
    LDAP * hLdap;
    DWORD ldStatus;
    ULONG ulOptions;
    DWORD err;

    Assert(phLdap);
    hLdap = *phLdap;
    *phLdap = NULL;

    ldap_unbind(hLdap);

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\repcrypt.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repcrypt.c - CRYPT API related commands

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <wincrypt.h>
#include <certca.h>
#include <cryptui.h>

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "repadmin.h"

#define SECURITY_WIN32
#include "security.h" // Needed for GetComputerObjectName

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0)


/* External */

/* Static */

/* Forward */
/* End Forward */

// Fake out the core environment enough for this routine to compile



CERT_ALT_NAME_INFO *
draGetCertAltNameInfo(
    IN  PCCERT_CONTEXT  pCertContext
    )

/*++

Routine Description:

    Retrieve the Alt Name Info structure

Arguments:

    pCertContext 

Return Value:

    Alt Name Info or NULL
    Free with free()

--*/

{
    CERT_EXTENSION *      pCertExtension;
    CERT_ALT_NAME_INFO *  pCertAltNameInfo;
    DWORD                 cbCertAltNameInfo = 0;
    BOOL                  ok;
    DWORD                 winError;

    // Find the cert extension containing the alternate subject names.
    pCertExtension = CertFindExtension(szOID_SUBJECT_ALT_NAME2,
                                       pCertContext->pCertInfo->cExtension,
                                       pCertContext->pCertInfo->rgExtension);
    if (NULL == pCertExtension) {
	PrintMsg(REPADMIN_SHOWCERT_CERT_NO_ALT_SUBJ);
        return NULL;
    }
        
    // Decode the list of alternate subject names.
    ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                           X509_ALTERNATE_NAME,
                           pCertExtension->Value.pbData,
                           pCertExtension->Value.cbData,
                           0,
                           NULL,
                           &cbCertAltNameInfo);
    if (!ok || (0 == cbCertAltNameInfo)) {
        winError = GetLastError();
        PrintMsg(REPADMIN_SHOWCERT_CANT_DECODE_CERT,
                 winError, Win32ErrToString(winError));
        return NULL;
    }
    
    pCertAltNameInfo = malloc(cbCertAltNameInfo);
    
    if (NULL == pCertAltNameInfo) {
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
        return NULL;
    }
        
    ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                           X509_ALTERNATE_NAME,
                           pCertExtension->Value.pbData,
                           pCertExtension->Value.cbData,
                           0,
                           pCertAltNameInfo,
                           &cbCertAltNameInfo);
    if (!ok) {
        winError = GetLastError();
        PrintMsg(REPADMIN_SHOWCERT_CANT_DECODE_CERT,
                 winError, Win32ErrToString(winError));
        return NULL;
    }
    
    return pCertAltNameInfo;
}

CERT_ALT_NAME_ENTRY *
draFindCertAltNameEntry(
    IN  CERT_ALT_NAME_INFO *  pCertAltNameInfo,
    IN  DWORD                 dwAltNameChoice,
    IN  LPSTR                 pszOtherNameOID     OPTIONAL
    )
/*++

Routine Description:

    Retrieve a specific alt subject name entry from the given certificate.

Arguments:

    pCertAltNameInfo - Certificate Alt Name Info block
    
    dwAltNameChoice (IN) - The CERT_ALT_NAME_* for the desired alternate name.
    
    pszOtherNameOID (IN) - If retrieving CERT_ALT_NAME_OTHER_NAME, an OID
        specifying the specific "other name" desired.  Must be NULL for other
        values of dwAltNameChoice.
        
Return Values:

    A pointer to the CERT_ALT_NAME_ENTRY (success) or NULL (failure).
    
--*/
{
    CERT_ALT_NAME_ENTRY * pCertAltNameEntry = NULL;
    DWORD                 i;
    
    Assert((CERT_ALT_NAME_OTHER_NAME == dwAltNameChoice)
           || (NULL == pszOtherNameOID));

    // Grovel through the alternate names to find the one the caller asked for.
    for (i = 0; i < pCertAltNameInfo->cAltEntry; i++) {
        if ((dwAltNameChoice
             == pCertAltNameInfo->rgAltEntry[i].dwAltNameChoice)
            && ((NULL == pszOtherNameOID)
                || (0 == strcmp(pszOtherNameOID,
                                pCertAltNameInfo->rgAltEntry[i]
                                    .pOtherName->pszObjId)))) {
            pCertAltNameEntry = &pCertAltNameInfo->rgAltEntry[i];
            break;
        }
    }

    return pCertAltNameEntry;
}


BOOL
draCheckEnrollExtensionHelper(
    PCCERT_CONTEXT          pCertContext
    )

/*++

Routine Description:

    Check whether an ENROLL type extension is present.
    These are only found in V1 certificates.

Arguments:

    pTHS - thread state
    pCertContext - The certificate to check

Return Value:

    BOOL - TRUE if extension is found, FALSE otherwise or on error
    No exceptions are raised

--*/

{
    CERT_EXTENSION *        pCertExtension;
    DWORD                   cbCertTypeMax = 512;
    DWORD                   cbCertType;
    CERT_NAME_VALUE *       pCertType = NULL, *pCertTypeRealloc;
    HRESULT                 hr;
    HCERTTYPE               hCertType;
    LPWSTR *                ppszCertTypePropertyList;
    BOOL                    ok = FALSE;
    BOOL                    fCertFound = FALSE;

    // Allocate buffer to hold cert type extension.
    pCertType = malloc(cbCertTypeMax);
    CHK_ALLOC(pCertType);

    // Find the cert type.
    pCertExtension = CertFindExtension(szOID_ENROLL_CERTTYPE_EXTENSION,
                                       pCertContext->pCertInfo->cExtension,
                                       pCertContext->pCertInfo->rgExtension);

    if (NULL != pCertExtension) {
    
        // Decode the cert type.
        cbCertType = cbCertTypeMax;
        ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                               X509_UNICODE_ANY_STRING,
                               pCertExtension->Value.pbData,
                               pCertExtension->Value.cbData,
                               0,
                               (void *) pCertType,
                               &cbCertType);
            
        if (!ok && (ERROR_MORE_DATA == GetLastError())) {
            // Our buffer isn't big enough to hold this cert; realloc and
            // try again.
            pCertTypeRealloc = realloc(pCertType, cbCertType);
            CHK_ALLOC(pCertTypeRealloc);
            pCertType = pCertTypeRealloc;

            cbCertTypeMax = cbCertType;
            
            ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                                   X509_UNICODE_ANY_STRING,
                                   pCertExtension->Value.pbData,
                                   pCertExtension->Value.cbData,
                                   0,
                                   (void *) pCertType,
                                   &cbCertType);
        }
            
        if (ok && (0 != cbCertType)) {
            LPWSTR pszCertTypeName = (LPWSTR) pCertType->Value.pbData;

            hCertType = NULL;
            ppszCertTypePropertyList = NULL;

            // Get a handle to the cert type
            hr = CAFindCertTypeByName( 
                pszCertTypeName,
                NULL, // hCAInfo
                CT_FIND_LOCAL_SYSTEM | CT_ENUM_MACHINE_TYPES, // dwFlags
                &hCertType
                );

            if (FAILED(hr)) {
                NOTHING;
            } else {

                // Get the base name property of the cert type object
                hr = CAGetCertTypeProperty( hCertType,
                                            CERTTYPE_PROP_CN,
                                            &ppszCertTypePropertyList
                    );
                if (FAILED(hr)) {
                    NOTHING;
                } else {
                    Assert( ppszCertTypePropertyList[1] == NULL );

                    if (0 == _wcsicmp(ppszCertTypePropertyList[0],
                                      wszCERTTYPE_DC )) {
                        // We found our DC certificate; we're done!
                        fCertFound = TRUE;
                    }
                } // if failed
            } // if failed

            if (ppszCertTypePropertyList != NULL) {
                hr = CAFreeCertTypeProperty( hCertType,
                                             ppszCertTypePropertyList );
                if (FAILED(hr)) {
                    NOTHING;
                }
            }
            if (hCertType != NULL) {
                hr = CACloseCertType( hCertType );
                if (FAILED(hr)) {
                    NOTHING;
                }
            }
        } // if ok
    } // if null == cert extension

    if (NULL != pCertType) {
        free(pCertType);
    }

    return fCertFound;
}

BOOL
getDCCert(
    IN  THSTATE *   pTHS,
    IN  HCERTSTORE  hCertStore,
    IN  BOOL        fRequestV2Certificate
    )
/*++

THIS CODE SHAMELESSLY STOLEN FROM DRACRYPT.C

Note that dracrypt.c can be built as a standalone module outside of the
core. We may consider building the entire file in if we have need of more
of its functions.

Routine Description:

    Retrieve the "DomainController" type certificate associated with the local
    machine.

Arguments:

    hCertStore (IN) - Handle to the cert store to search.
    fRequestV2Certificate - Whether we should only accept a V2 certificate    

Return Values:

    BOOL - whether a suitable cert was found

--*/
{
    PCCERT_CONTEXT          pCertContext = NULL;
    CERT_ALT_NAME_INFO *  pCertAltNameInfo;
    CERT_ALT_NAME_ENTRY * pCertAltNameEntry;
    CRYPT_OBJID_BLOB *    pEncodedGuidBlob = NULL;
    DWORD                 cbDecodedGuidBlob;
    CRYPT_DATA_BLOB *     pDecodedGuidBlob = NULL;
    GUID                  ComputerObjGuid;
    BOOL                  ok;
    DWORD                 winError;
    CHAR szUuid1[SZUUID_LEN];
    BOOL                  fFound = FALSE;

    // Grovel through each of our certificates, looking for the one of type DC.
    for (pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext);
         (NULL != pCertContext);
         pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext)) {

        if (fRequestV2Certificate) {
            // A V2 certificate has a CERTIFICATE_TEMPLATE extension, but
            // no ENROLL_CERTTYPE extension.
            if (!CertFindExtension(szOID_CERTIFICATE_TEMPLATE,
                                   pCertContext->pCertInfo->cExtension,
                                   pCertContext->pCertInfo->rgExtension)) {
                continue;
            }
        } else {
            if (!draCheckEnrollExtensionHelper( pCertContext )) {
                continue;
            }
        }

        // We found one!
        // A certificate suitable for mail-based replication will have our
        // OID in it, by definition.
        pCertAltNameInfo = draGetCertAltNameInfo( pCertContext );
        if (!pCertAltNameInfo) {
            // Doesn't have one? Skip it.
            continue;
        }
        pCertAltNameEntry = draFindCertAltNameEntry( pCertAltNameInfo,
                                                    CERT_ALT_NAME_OTHER_NAME,
                                                    szOID_NTDS_REPLICATION);
        if (!pCertAltNameEntry) {
            // Doesn't have one? Skip it.
            free( pCertAltNameInfo );
            continue;
        }

        // Validate that the computer guid found in the dc cert is our own and not
        // some stale one left behind from a previous dcpromo

        pEncodedGuidBlob = &pCertAltNameEntry->pOtherName->Value;

        cbDecodedGuidBlob = 64;
        pDecodedGuidBlob = (CRYPT_DATA_BLOB *) malloc(cbDecodedGuidBlob);
        CHK_ALLOC(pDecodedGuidBlob);

        ok = CryptDecodeObject(pCertContext->dwCertEncodingType,
                               X509_OCTET_STRING,
                               pEncodedGuidBlob->pbData,
                               pEncodedGuidBlob->cbData,
                               0,
                               pDecodedGuidBlob,
                               &cbDecodedGuidBlob);
        if (!ok
            || (0 == cbDecodedGuidBlob)
            || (sizeof(GUID) != pDecodedGuidBlob->cbData)) {
            winError = GetLastError();
            free( pCertAltNameInfo );
            free( pDecodedGuidBlob );
            continue;
        }

        memcpy(&ComputerObjGuid, pDecodedGuidBlob->pbData, sizeof(GUID)); // align

        // Done with it
        free( pCertAltNameInfo );
        free( pDecodedGuidBlob );

        // Just dump out the guid and keep going. This allows us to check if there is
        // more than one dc cert registered, with different guids

        PrintMsg(REPADMIN_CERT_FOUND_GUID, 
                 DsUuidToStructuredString(&(ComputerObjGuid), szUuid1) );

        fFound = TRUE;
    } // for

    return fFound;
}


int
ShowCert(
    int argc,
    LPWSTR argv[]
    )

/*++

Routine Description:

Check whether the DC cert is present on the named DSA

Arguments:

    None

Return Value:

    None

--*/

{
    BOOL fVerbose = FALSE;
    LPWSTR pszDSA = NULL;
    int iArg;
    HCERTSTORE hRemoteStore = NULL;
    WCHAR wszStorePath[MAX_PATH];
    DWORD status = ERROR_SUCCESS;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if ( (_wcsicmp( argv[iArg], L"/v" ) == 0) ||
             (_wcsicmp( argv[iArg], L"/verbose" ) == 0) ) {
            fVerbose = TRUE;
        } else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        } else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (pszDSA) {
        _snwprintf(wszStorePath, ARRAY_SIZE(wszStorePath),
                   L"\\\\%ls\\MY", pszDSA);
        wszStorePath[ARRAY_SIZE(wszStorePath) - 1] = L'\0';
    } else {
        DWORD cchName = 0;
        LPWSTR pName = NULL;
        BOOL fSuccess;

        fSuccess = GetComputerObjectNameW( NameUniqueId, NULL, &cchName );
        if (cchName) {
            pName = malloc( cchName * sizeof( WCHAR ) );
            CHK_ALLOC(pName);
            fSuccess = GetComputerObjectNameW( NameUniqueId, pName, &cchName );
            if (fSuccess) {
                PrintMsg(REPADMIN_COMPUTER_OBJ_GUID, pName);
            }
            free( pName );
        }

        wcscpy( wszStorePath, L"MY" );
    }

    PrintMsg(REPADMIN_SHOWCERT_STATUS_CHECKING_DC_CERT, wszStorePath);

    hRemoteStore = CertOpenStore(
        CERT_STORE_PROV_SYSTEM_W,
        0, //X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
        0,
        CERT_STORE_READONLY_FLAG | CERT_SYSTEM_STORE_LOCAL_MACHINE,
        (LPVOID) wszStorePath
        );
    if (NULL == hRemoteStore) {
        status = GetLastError();
        if (status == ERROR_ACCESS_DENIED) {
            PrintMsg(REPADMIN_SHOWCERT_STORE_ACCESS_DENIED);
        } else {
            PrintMsg(REPADMIN_SHOWCERT_CERTOPENSTORE_FAILED, Win32ErrToString(status));
        }
        goto cleanup;
    }


    if (getDCCert( NULL, hRemoteStore, TRUE /* v2 */ )) {
        PrintMsg(REPADMIN_SHOWCERT_DC_V2_CERT_PRESENT);
    } else {
        if (getDCCert( NULL, hRemoteStore, FALSE /* v1 */  )) {
            PrintMsg(REPADMIN_SHOWCERT_DC_V1_CERT_PRESENT);
        } else {
            PrintMsg(REPADMIN_SHOWCERT_DC_CERT_NOT_FOUND);
            status = ERROR_NOT_FOUND;
        }
    }

cleanup:
    if (NULL != hRemoteStore) {
        CertCloseStore(hRemoteStore, 0);
    }

    return status;

}

/* end repcrypt.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\repfull.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repfull.c - full sync all command functions

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "ReplRpcSpoof.hxx"
#include "repadmin.h"

typedef struct _DSA_INFO {
    LDAP *  hld;
    HANDLE  hDs;
    HKEY    hKey;
    LPWSTR  pszDN;
    WCHAR   szDisplayName[80];
} DSA_INFO;

int
FullSyncAll(
    IN  int     argc,
    IN  LPWSTR  argv[]
    )
{
    int             ret = 0;
    LPWSTR          pszNC = NULL;
    LPWSTR          pszDSA = NULL;
    WCHAR *         pszTemp = NULL;
    int             iArg;
    LDAP *          hld;
    BOOL            fCacheGuids = TRUE;
    int             ldStatus;
    LDAPMessage *   pRootResults;
    LDAPSearch *    pSearch = NULL;
    LDAPMessage *   pResults;
    LDAPMessage *   pDsaEntry;
    LPSTR           rgpszRootAttrsToRead[] = {"configurationNamingContext", NULL};
    LPWSTR          rgpszDsaAttrs[] = {L"objectGuid", NULL};
    LPWSTR *        ppszConfigNC;
    WCHAR           szFilter = NULL;
    WCHAR           szGuidDNSName[256];
    DWORD           iDsa;
    DWORD           cNumDsas;
    DSA_INFO *      pDsaInfo;
    LPWSTR          pszRootDomainDNSName;
    int             nOptions;
    BOOL            fLeaveOff = FALSE;
    ULONG           ulTotalEstimate;
    ULONG           ulOptions;
    LDAPMessage *     pNCResults;
    struct berval **  ppbvReps;

    // Parse command-line arguments.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/n")
            || !_wcsicmp(argv[iArg], L"/nocache")) {
            fCacheGuids = FALSE;
        }
        else if (!_wcsicmp(argv[iArg], L"/l")
                 || !_wcsicmp(argv[iArg], L"/leaveoff")) {
            fLeaveOff = TRUE;
        }
        else if (NULL == pszNC) {
            pszNC = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszNC) {
        PrintMsg(REPADMIN_PRINT_NO_NC);
        return ERROR_INVALID_FUNCTION;
    }

    if (NULL == pszDSA) {
        // This is here as a safeguard -- it's not really required.
        // Wouldn't want someone accidentally running this against the wrong
        // enterprise....
        PrintMsg(REPADMIN_SYNCALL_NO_DSA);
        return ERROR_INVALID_FUNCTION;
    }


    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    __try {
	hld = ldap_initW(pszDSA, LDAP_PORT);
	if (NULL == hld) {
	    PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
	    ret = ERROR_DS_SERVER_DOWN;
	    __leave;
	}

	// use only A record dns name discovery
	ulOptions = PtrToUlong(LDAP_OPT_ON);
	(void)ldap_set_optionW( LdapHandle, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

	// Bind.
	ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
	CHK_LD_STATUS(ldStatus);

	if (fCacheGuids) {
	    // Populate GUID cache (DSA GUIDs to display names).
	    BuildGuidCache(hld);
	}

	// What's the DNS name of the enterprise root domain?
	ret = GetRootDomainDNSName(pszDSA, &pszRootDomainDNSName);
	if (ret) {
	    PrintFuncFailed(L"GetRootDomainDNSName", ret);
	    __leave;
	}

	// What's the DN of the config NC?
	ldStatus = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
				 rgpszRootAttrsToRead, 0, &pRootResults);
	CHK_LD_STATUS(ldStatus);

	ppszConfigNC = ldap_get_valuesW(hld, pRootResults,
					L"configurationNamingContext");
	Assert(NULL != ppszConfigNC);

#define ALL_DSAS_WITH_WRITEABLE_NC_FILTER L"(& (objectCategory=ntdsDsa) (| (hasMasterNCs=%ls)(msDS-HasMasterNCs=%ls)))"
	// Find all DCs that hold a writeable copy of the target NC.
    szFilter = malloc( (wcslen(ALL_DSAS_WITH_WRITEABLE_NC_FILTER) + (2 * wcslen(pszNC)) + 1) * sizeof(WCHAR) );
	swprintf(szFilter, ALL_DSAS_WITH_WRITEABLE_NC_FILTER, pszNC, pszNC);

	// Do paged search ...
	pSearch = ldap_search_init_pageW(hld,
					 *ppszConfigNC,
					 LDAP_SCOPE_SUBTREE,
					 szFilter,
					 rgpszDsaAttrs,
					 FALSE, NULL, NULL, 0, 0, NULL);
	if(pSearch == NULL){
	    ldStatus = LdapGetLastError();
	    CHK_LD_STATUS(ldStatus);
	    __leave;
	}

	ldStatus = ldap_get_next_page_s(hld,
					pSearch,
					0,
					DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					&ulTotalEstimate,
					&pResults);
	if(ldStatus == LDAP_NO_RESULTS_RETURNED){
	    PrintMsg(REPADMIN_SYNCALL_NO_INSTANCES_OF_NC);
	    ret = ERROR_NOT_FOUND;
	    __leave;
	}

	iDsa = 0;

	// Connect to each writeable DC,
	PrintMsg(REPADMIN_SYNCALL_CONNECTING_TO_DCS);

	while(ldStatus == LDAP_SUCCESS){

	    pDsaInfo = realloc(pDsaInfo,
			       (ldap_count_entries(hld, pResults) + iDsa)
			       * sizeof(*pDsaInfo));
	    if(pDsaInfo == NULL){
		//printf("Error not enough memory, asked for %d\n",
		//       (ldap_count_entries(hld, pResults) + iDsa) * sizeof(*pDsaInfo));
		PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
		ret = ERROR_NOT_ENOUGH_MEMORY;
		__leave;
	    }
	    for (pDsaEntry = ldap_first_entry(hld, pResults);
		 NULL != pDsaEntry;
		 iDsa++, pDsaEntry = ldap_next_entry(hld, pDsaEntry)) {
		struct berval **  ppbvGuid;
		LPSTR             pszGuid;
		RPC_STATUS        rpcStatus;
		HKEY              hKLM;

		// Cache DSA DN.
		pDsaInfo[iDsa].pszDN = ldap_get_dnW(hld, pDsaEntry);
		Assert(NULL != pDsaInfo[iDsa].pszDN);

		// Cache DSA display name (e.g., "Site\Server").
		lstrcpynW(pDsaInfo[iDsa].szDisplayName,
			  GetNtdsDsaDisplayName(pDsaInfo[iDsa].pszDN),
			  ARRAY_SIZE(pDsaInfo[iDsa].szDisplayName));

		// Derive DSA's GUID-based DNS name.
		ppbvGuid = ldap_get_values_len(hld, pDsaEntry, "objectGuid");
		Assert(NULL != ppbvGuid);
		Assert(1 == ldap_count_values_len(ppbvGuid));

		rpcStatus = UuidToStringA((GUID *) (*ppbvGuid)->bv_val,
					  (UCHAR **) &pszGuid);

		swprintf(szGuidDNSName, L"%hs._msdcs.%ls", pszGuid, pszRootDomainDNSName);

		RpcStringFree((UCHAR **) &pszGuid);
		ldap_value_free_len(ppbvGuid);

		// Cache LDAP handle.
		pDsaInfo[iDsa].hld = ldap_initW(szGuidDNSName, LDAP_PORT);
		if (NULL == hld) {
		    PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE_2,
			     szGuidDNSName, pDsaInfo[iDsa].szDisplayName);
		    err = ERROR_DS_SERVER_DOWN;
		    __leave;
		}

		// use only A record dns name discovery
		ulOptions = PtrToUlong(LDAP_OPT_ON);
		(void)ldap_set_optionW( LdapHandle, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


		ldStatus = ldap_bind_s(pDsaInfo[iDsa].hld, NULL, (char *) gpCreds,
				       LDAP_AUTH_SSPI);
		CHK_LD_STATUS(ldStatus);

		// Cache replication handle.
		ret = RepadminDsBind(szGuidDNSName, &pDsaInfo[iDsa].hDs);
		if (ret != ERROR_SUCCESS) {
		    PrintBindFailed(pDsaInfo[iDsa].szDisplayName, ret);
		    __leave;
		}

		// Cache registry handle.
		ret = RegConnectRegistryW(szGuidDNSName, HKEY_LOCAL_MACHINE, &hKLM);
		if (ERROR_SUCCESS != ret) {
		    PrintMsg(REPADMIN_SYNCALL_REGISTRY_BIND_FAILED,
			     pDsaInfo[iDsa].szDisplayName);
		    PrintErrEnd(ret);
		    __leave;
		}

		ret = RegOpenKeyEx(hKLM,
				   "System\\CurrentControlSet\\Services\\NTDS\\Parameters",
				   0, KEY_ALL_ACCESS, &pDsaInfo[iDsa].hKey);
		if (ERROR_SUCCESS != ret) {
		    PrintMsg(REPADMIN_SYNCALL_OPEN_DS_REG_KEY_FAILED, 
			     pDsaInfo[iDsa].szDisplayName);
		    PrintErrEnd(ret);
		    __leave;
		}

		RegCloseKey(hKLM);
	    } // end of _one_ page of results

	    ldap_msgfree(pResults);
	    pResults = NULL;

	    ldStatus = ldap_get_next_page_s(hld,
					    pSearch,
					    0,
					    DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					    &ulTotalEstimate,
					    &pResults);
	} // end of paged results
	if(ldStatus != LDAP_NO_RESULTS_RETURNED){
	    CHK_LD_STATUS(ldStatus);
	}
	ldStatus = ldap_search_abandon_page(hld, pSearch);
	pSearch = NULL;
	CHK_LD_STATUS(ldStatus);

	cNumDsas = iDsa;

	PrintMsg(REPADMIN_SYNCALL_DISABLING_REPL);
	for (iDsa = 0; iDsa < cNumDsas; iDsa++) { 
	    LDAPMessage *     pNCEntry;
	    LPWSTR            rgpszNCAttrsToRead[] = {L"repsFrom", L"whenChanged", NULL};
	    int               cReps;
	    int               iReps;
	    LDAPModW          ModOpt = {LDAP_MOD_DELETE, L"replUpToDateVector", NULL};
	    LDAPModW *        rgpMods[] = {&ModOpt, NULL};
	    DWORD             dwAllowSysOnlyChange;
	    DWORD             cbAllowSysOnlyChange;
	    REPLICA_LINK *    prl;


	    PrintMsg(REPADMIN_SYNCALL_DSA_LINE, pDsaInfo[iDsa].szDisplayName);

	    // Turn off inbound/outbound replication.
	    ldStatus = GetDsaOptions(pDsaInfo[iDsa].hld, pDsaInfo[iDsa].pszDN,
				     &nOptions);
	    CHK_LD_STATUS(ldStatus);

	    if (!(nOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL)
		|| !(nOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL)) {
		nOptions |= NTDSDSA_OPT_DISABLE_INBOUND_REPL
		    | NTDSDSA_OPT_DISABLE_OUTBOUND_REPL;

		ldStatus = SetDsaOptions(pDsaInfo[iDsa].hld, pDsaInfo[iDsa].pszDN,
					 nOptions);
		CHK_LD_STATUS(ldStatus);

		PrintMsg(REPADMIN_SYNCALL_REPL_DISABLED);
	    }

	    // Remove the replUpToDateVector for this NC.
	    // Requires adding the extra-special flag to allow modification of
	    // system-only attributes.
	    PrintMsg(REPADMIN_SYNCALL_REMOVING_UTD_VEC);

	    dwAllowSysOnlyChange = 1;
	    cbAllowSysOnlyChange = sizeof(dwAllowSysOnlyChange);
	    ret = RegSetValueEx(pDsaInfo[iDsa].hKey, "Allow System Only Change",
				0, REG_DWORD, (BYTE *) &dwAllowSysOnlyChange,
				cbAllowSysOnlyChange);
	    if (ERROR_SUCCESS != ret) {
		PrintMsg(REPADMIN_SYNCALL_COULDNT_SET_REGISTRY);
		PrintErrEnd(ret);
		__leave;
	    }

	    ldStatus = ldap_modify_sW(pDsaInfo[iDsa].hld, pszNC, rgpMods);
	    CHK_LD_STATUS(ldStatus);

	    dwAllowSysOnlyChange = 0;
	    cbAllowSysOnlyChange = sizeof(dwAllowSysOnlyChange);
	    ret = RegSetValueEx(pDsaInfo[iDsa].hKey, "Allow System Only Change",
				0, REG_DWORD, (BYTE *) &dwAllowSysOnlyChange,
				cbAllowSysOnlyChange);
	    if (ERROR_SUCCESS != ret) {
		PrintMsg(REPADMIN_SYNCALL_COULDNT_SET_REGISTRY);
		PrintErrEnd(ret);
		__leave;
	    }

	    // Enumerate and delete all repsFrom's for this NC.
	    ldStatus = ldap_search_sW(pDsaInfo[iDsa].hld, pszNC, LDAP_SCOPE_BASE,
				      L"(objectClass=*)", rgpszNCAttrsToRead, 0,
				      &pNCResults);
	    CHK_LD_STATUS(ldStatus);

	    pNCEntry = ldap_first_entry(hld, pNCResults);
	    Assert(NULL != pNCEntry);

	    if (NULL == pNCEntry) {
		PrintMsg(REPADMIN_SYNCALL_NO_INBOUND_REPL_PARTNERS);
	    }
	    else {
		ppbvReps = ldap_get_values_len(hld, pNCEntry, "repsFrom");
		cReps = ldap_count_values_len(ppbvReps);

		for (iReps = 0; iReps < cReps; iReps++) {
		    LPWSTR pwszSrcDsaAddr = NULL;

		    prl = (REPLICA_LINK *) ppbvReps[iReps]->bv_val;
		    PrintMsg(REPADMIN_SYNCALL_REMOVE_LINK,
			     GetDsaGuidDisplayName(&prl->V1.uuidDsaObj));

		    ret = AllocConvertWideEx(CP_UTF8,
					     RL_POTHERDRA(prl)->mtx_name,
					     &pwszSrcDsaAddr);
		    if (!ret) {
			ret = DsReplicaDelW(pDsaInfo[iDsa].hDs,
					    pszNC,
					    pwszSrcDsaAddr,
					    DS_REPDEL_WRITEABLE | DS_REPDEL_IGNORE_ERRORS);
		    }

		    if (NULL != pwszSrcDsaAddr) {
			LocalFree(pwszSrcDsaAddr);
		    }

		    if (ERROR_SUCCESS != ret) {
			PrintMsg(REPADMIN_SYNCALL_DEL_REPLICA_LINK_FAILED);
			PrintErrEnd(ret);
			__leave;
		    }
		}

		ldap_value_free_len(ppbvReps);
		ppbvReps = NULL;
	    }

	    ldap_msgfree(pNCResults);
	    pNCResults = NULL;
	}

	// Now all replication bookmarks have been wiped from DCs on which this NC
	// is writeable.
	if (!fLeaveOff) {
	    PrintMsg(REPADMIN_SYNCALL_RE_ENABLING_REPL);
	    for (iDsa = 0; iDsa < cNumDsas; iDsa++) {
		PrintMsg(REPADMIN_SYNCALL_DSA_LINE, pDsaInfo[iDsa].szDisplayName);

		// Turn on inbound/outbound replication.
		ldStatus = GetDsaOptions(pDsaInfo[iDsa].hld, pDsaInfo[iDsa].pszDN,
					 &nOptions);
		CHK_LD_STATUS(ldStatus);

		nOptions &= ~(NTDSDSA_OPT_DISABLE_INBOUND_REPL
			      | NTDSDSA_OPT_DISABLE_OUTBOUND_REPL);

		ldStatus = SetDsaOptions(pDsaInfo[iDsa].hld, pDsaInfo[iDsa].pszDN,
					 nOptions);
		CHK_LD_STATUS(ldStatus);
	    }
	}
	else {
	    PrintMsg(REPADMIN_SYNCALL_NOTE_DISABLED_REPL);
	}
    }
    __finally {

	// Clean up.
    if (szFilter){
        free(szFilter);
    }

	if (pszRootDomainDNSName) {
	    free(pszRootDomainDNSName);
	}

	if (ppszConfigNC) {
	    ldap_value_free(ppszConfigNC);
	}

	if (pDsaInfo) { 
	    for (iDsa = 0; iDsa < cNumDsas; iDsa++) {
		if (pDsaInfo[iDsa].pszDN) {
		    ldap_memfreeW(pDsaInfo[iDsa].pszDN);
		}
		if (pDsaInfo[iDsa].hld) {
		    ldap_unbind(pDsaInfo[iDsa].hld);
		}
		if (pDsaInfo[iDsa].hDs) {
		    DsUnBind(&pDsaInfo[iDsa].hDs);
		}
		if (pDsaInfo[iDsa].hKey) {
		    RegCloseKey(pDsaInfo[iDsa].hKey);
		}
	    }
	    free(pDsaInfo);
	}


	if (pRootResults) {
	    ldap_msgfree(pRootResults);
	}

	if (pResults) {
	    ldap_msgfree(pResults);
	}

	if (pNCResults) {
	    ldap_msgfree(pNCResults);
	}

	if (hld) {
	    ldap_unbind(hld);
	}

    }
    if (ret==ERROR_SUCCESS) {
	PrintMsg(REPADMIN_SYNCALL_SUCCESS);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\repgtchg.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repgtchg.c - get changes command

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

    2002/07/21 - Brett Shirley (BrettSh) - Added the /showattr command.
                                                                             
--*/

#include <NTDSpch.h>
#pragma hdrstop

#undef LDAP_UNICODE
#define LDAP_UNICODE 1

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "ReplRpcSpoof.hxx"
#include "repadmin.h"
#include "resource.h"  // We need to know the difference between /showattr and /showattrp

#define UNICODE 1
#define STRSAFE_NO_DEPRECATE 1
#include "strsafe.h"

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0 | (0xFFFF & y))

//
// LDAP names
//
const WCHAR g_szObjectGuid[]        = L"objectGUID";
const WCHAR g_szParentGuid[]        = L"parentGUID";
const WCHAR g_szObjectClass[]       = L"objectClass";
const WCHAR g_szIsDeleted[]         = L"isDeleted";
const WCHAR g_szRDN[]               = L"name";
const WCHAR g_szProxiedObjectName[] = L"proxiedObjectName";

#define OBJECT_UNKNOWN              0
#define OBJECT_ADD                  1
#define OBJECT_MODIFY               2
#define OBJECT_DELETE               3
#define OBJECT_MOVE                 4
#define OBJECT_UPDATE               5
#define OBJECT_INTERDOMAIN_MOVE     6
#define OBJECT_MAX                  7

static LPSTR szOperationNames[] = {
    "unknown",
    "add",
    "modify",
    "delete",
    "move",
    "update",
    "interdomain move"
};

#define NUMBER_BUCKETS 5
#define BUCKET_SIZE 250

typedef struct _STAT_BLOCK {
    DWORD dwPackets;
    DWORD dwObjects;
    DWORD dwOperations[OBJECT_MAX];
    DWORD dwAttributes;
    DWORD dwValues;
// dn-value performance monitoring
    DWORD dwDnValuedAttrOnAdd[NUMBER_BUCKETS];
    DWORD dwDnValuedAttrOnMod[NUMBER_BUCKETS];
    DWORD dwDnValuedAttributes;
    DWORD dwDnValuesMaxOnAttr;
    WCHAR szMaxObjectName[1024];
    WCHAR szMaxAttributeName[256];
} STAT_BLOCK, *PSTAT_BLOCK;


void
printStatistics(
    ULONG ulTitle,
    PSTAT_BLOCK pStatistics
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PrintMsg(ulTitle);
    PrintMsg(REPADMIN_GETCHANGES_PRINT_STATS_1,
             pStatistics->dwPackets,
             pStatistics->dwObjects,
             pStatistics->dwOperations[OBJECT_ADD],
             pStatistics->dwOperations[OBJECT_MODIFY],
             pStatistics->dwOperations[OBJECT_DELETE],
             (pStatistics->dwOperations[OBJECT_MOVE] +
                pStatistics->dwOperations[OBJECT_UPDATE] +
                pStatistics->dwOperations[OBJECT_INTERDOMAIN_MOVE]) );
    PrintMsg(REPADMIN_GETCHANGES_PRINT_STATS_2,
             pStatistics->dwAttributes,
             pStatistics->dwValues,
             pStatistics->dwDnValuedAttributes,
             pStatistics->dwDnValuesMaxOnAttr,
             pStatistics->szMaxObjectName,
             pStatistics->szMaxAttributeName ); 
    PrintMsg(REPADMIN_GETCHANGES_PRINT_STATS_3,
             pStatistics->dwDnValuedAttrOnAdd[0],
             pStatistics->dwDnValuedAttrOnAdd[1],
             pStatistics->dwDnValuedAttrOnAdd[2],
             pStatistics->dwDnValuedAttrOnAdd[3],
             pStatistics->dwDnValuedAttrOnAdd[4],
             pStatistics->dwDnValuedAttrOnMod[0],
             pStatistics->dwDnValuedAttrOnMod[1],
             pStatistics->dwDnValuedAttrOnMod[2],
             pStatistics->dwDnValuedAttrOnMod[3],
             pStatistics->dwDnValuedAttrOnMod[4] );
}

DWORD
GetSourceOperation(
    LDAP *pLdap,
    LDAPMessage *pLdapEntry
    )

/*++

THIS ROUTINE TAKEN FROM DIRSYNC\DSSERVER\ADREAD\UTILS.CPP

Routine Description:

    Depending on the attributes found in the entry, this function determines
    what changes were done on the DS to cause us to read this entry. For
    example, this funciton whether the entry was Added, Deleted, Modified,
    or Moved since we last read changes from the DS.

Arguments:

    pLdap - Pointer to LDAP session
    pLdapEntry - Pointer to the LDAP entry

Return Value:

    Source operation performed on the entry

--*/

{
    BerElement *pBer = NULL;
    PWSTR attr;
    BOOL fModify = FALSE;
    DWORD dwSrcOp = OBJECT_UNKNOWN;

    for (attr = ldap_first_attribute(pLdap, pLdapEntry, &pBer);
         attr != NULL;
         attr = ldap_next_attribute(pLdap, pLdapEntry, pBer))
    {
        //
        // Check if we have an Add operation
        //

        if (wcscmp(attr, g_szObjectClass) == 0)
        {
            //
            // Delete takes higher priority
            //

            if (dwSrcOp != OBJECT_DELETE)
                dwSrcOp = OBJECT_ADD;
         }

        //
        // Check if we have a delete operation
        //

        else if (wcscmp(attr, g_szIsDeleted) == 0)
        {
            //
            // Inter-domain move takes highest priority
            //

            if (dwSrcOp != OBJECT_INTERDOMAIN_MOVE)
            {
                //
                // Check if the value of the attribute is "TRUE"
                //

                PWCHAR *ppVal;

                ppVal = ldap_get_values(pLdap, pLdapEntry, attr);

                if (ppVal &&
                    ppVal[0] &&
                    wcscmp(ppVal[0], L"TRUE") == 0) {
                    dwSrcOp = OBJECT_DELETE;
                }

                ldap_value_free(ppVal);
            }
        }

        //
        // Check if we have a move operation
        //

        else if (wcscmp(attr, g_szRDN) == 0)
        {
            //
            // Add and delete both get RDN and take higher priority
            //

            if (dwSrcOp == OBJECT_UNKNOWN)
                dwSrcOp = OBJECT_MOVE;
        }

        //
        // Check if we have an interdomain object move
        //

        else if (wcscmp(attr, g_szProxiedObjectName) == 0)
        {
            dwSrcOp = OBJECT_INTERDOMAIN_MOVE;
            break;      // Has highest priority
        }

        //
        // Everything else is a modification
        //

        else
            fModify = TRUE;

    }

    if (fModify)
    {
        //
        // A move can be combined with a modify, if so mark as such
        //

        if (dwSrcOp == OBJECT_MOVE)
            dwSrcOp = OBJECT_UPDATE;

        //
        // Check if it is a vanilla modify
        //

        else if (dwSrcOp == OBJECT_UNKNOWN)
            dwSrcOp = OBJECT_MODIFY;
    }


    //
    // If all went well, the entry cannot be unknown anymore
    //

    ASSERT(dwSrcOp != OBJECT_UNKNOWN);

    return dwSrcOp;
}


void
RepadminObjDumpPrint(
    DWORD       dwReason, // dwRetCode
    WCHAR *     szString,
    void *      pv
    )
{
    BOOL bErr = xListErrorCheck(dwReason);
    dwReason = xListReason(dwReason);
    
    if (bErr) {
        //
        // These are quasi errors ...
        //
        switch (dwReason) {
        case XLIST_ERR_ODUMP_UNMAPPABLE_BLOB:
            PrintMsg(REPADMIN_GETCHANGES_BYTE_BLOB_NO_CR, * (int *) pv);
            break;

        case XLIST_ERR_ODUMP_NEVER:
            PrintMsg(REPADMIN_NEVER);
            break;

        case XLIST_ERR_ODUMP_NONE:
            PrintMsg(REPADMIN_NONE);
            break;

        default:
            Assert(!"Unheard of error");
        }
        xListClearErrors();

    } else {

        switch (dwReason) {
        case XLIST_PRT_OBJ_DUMP_DN:
            PrintMsg(REPADMIN_OBJ_DUMP_DN, szString);
            break;

        case XLIST_PRT_OBJ_DUMP_ATTR_AND_COUNT:
            PrintMsg(REPADMIN_GETCHANGES_DATA_2_NO_CR, * (int *)pv, szString);
            break;
        case XLIST_PRT_OBJ_DUMP_ATTR_AND_COUNT_RANGED:
            PrintMsg(REPADMIN_OBJ_DUMP_RANGED, * (int *)pv, szString);
            break;

        case XLIST_PRT_STR:
            PrintString(szString);
            break;

        case XLIST_PRT_OBJ_DUMP_MORE_VALUES:
            PrintMsg(REPADMIN_OBJ_DUMP_MORE_VALUES);
            break;

        default:
            Assert(!"New reason, but no ...");
            break;
        }
    }
}



void
displayChangeEntries(
    LDAP *pLdap,
    LDAPMessage *pSearchResult,
    OBJ_DUMP_OPTIONS * pObjDumpOptions,
    PSTAT_BLOCK pStatistics
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    DWORD i;
    DWORD dwObjects = 0, dwAttributes = 0, dwValues = 0;
    PWSTR pszLdapDN, pszActualDN;
    LDAPMessage *pLdapEntry;
    BerElement *pBer = NULL;
    PWSTR attr;
    LPWSTR p1, p2;
    DWORD dwSrcOp, bucket;

    dwObjects = ldap_count_entries(pLdap, pSearchResult);
    if (dwObjects == 0) {
        PrintMsg(REPADMIN_GETCHANGES_NO_CHANGES);
        return;
    }

    if (pObjDumpOptions->dwFlags & OBJ_DUMP_DISPLAY_ENTRIES) {
        PrintMsg(REPADMIN_GETCHANGES_OBJS_RET, dwObjects);
    }

    i=0;
    pLdapEntry = ldap_first_entry( pLdap, pSearchResult );
    while ( i < dwObjects ) {

        pszLdapDN = ldap_get_dnW(pLdap, pLdapEntry);
        if (pszLdapDN == NULL) {
            PrintMsg(REPADMIN_GETCHANGES_DN_MISSING);
            goto next_entry;
        }

        // What kind of operation is it?
        dwSrcOp = GetSourceOperation( pLdap, pLdapEntry );
        pStatistics->dwOperations[dwSrcOp]++;

        // Parse extended dn (fyi guid and sid in here if we need it)
        p1 = wcsstr( pszLdapDN, L">;" );
        if (p1) {
            p1 += 2;
            p2 = wcsstr( p1, L">;" );
            if (p2) {
                p1 = p2 + 2;
            }
            if (pObjDumpOptions->dwFlags & OBJ_DUMP_DISPLAY_ENTRIES) {
                PrintMsg(REPADMIN_GETCHANGES_DATA_1, i,
                            szOperationNames[dwSrcOp], p1 );
            }
        } else {
            PrintMsg(REPADMIN_GETCHANGES_INVALID_DN_2, i);
        }

        // List attributes in object
        for (attr = ldap_first_attributeW(pLdap, pLdapEntry, &pBer);
             attr != NULL;
             attr = ldap_next_attributeW(pLdap, pLdapEntry, pBer))
        {
            struct berval **ppBerVal = NULL;
            DWORD cValues, i;

            ppBerVal = ldap_get_values_lenW(pLdap, pLdapEntry, attr);
            if (ppBerVal == NULL) {
                goto loop_end;
            }
            cValues = ldap_count_values_len( ppBerVal );
            if (!cValues) {
                goto loop_end;
            }

            dwAttributes++;
            dwValues += cValues;

            // Detect dn-valued attributes
            if ( (cValues) &&
                 (strncmp( ppBerVal[0]->bv_val, "<GUID=", 6) == 0 )) {

                pStatistics->dwDnValuedAttributes++;
                if (cValues > pStatistics->dwDnValuesMaxOnAttr) {
                    pStatistics->dwDnValuesMaxOnAttr = cValues;
                    lstrcpynW( pStatistics->szMaxObjectName, p1, 1024 );
                    lstrcpynW( pStatistics->szMaxAttributeName, attr, 256 );
                }

                bucket = (cValues - 1) / BUCKET_SIZE;
                if (bucket >= NUMBER_BUCKETS) {
                    bucket = NUMBER_BUCKETS - 1;
                }
                if (dwSrcOp == OBJECT_ADD) {
                    pStatistics->dwDnValuedAttrOnAdd[bucket]++;
                } else {
                    pStatistics->dwDnValuedAttrOnMod[bucket]++;
                }
            }

            if (pObjDumpOptions->dwFlags & OBJ_DUMP_DISPLAY_ENTRIES) {
                PrintMsg(REPADMIN_GETCHANGES_DATA_2_NO_CR, cValues, attr );

                ObjDumpValues(attr, NULL, RepadminObjDumpPrint, ppBerVal, min(cValues, 1000), pObjDumpOptions);

                PrintMsg(REPADMIN_PRINT_CR);
            }

        loop_end:
            ldap_value_free_len(ppBerVal);
        }

    next_entry:
        if (pszLdapDN)
            ldap_memfreeW(pszLdapDN);
        i++;
        pLdapEntry = ldap_next_entry( pLdap, pLdapEntry );
    }

    pStatistics->dwPackets++;
    pStatistics->dwObjects += dwObjects;
    pStatistics->dwAttributes += dwAttributes;
    pStatistics->dwValues += dwValues;
}


int ShowChangesEx(
    WCHAR *     pszDSA,
    UUID *      puuid,
    WCHAR *     pszNC,
    DWORD       dwReplFlags,
    WCHAR *     pszCookieFile,
    WCHAR *     pszSourceFilter,
    OBJ_DUMP_OPTIONS *    pObjDumpOptions
    );

int GetChanges(int argc, LPWSTR argv[])
{
    DWORD                 ret, lderr;
    int                   iArg;
    BOOL                  fVerbose = FALSE;
    BOOL                  fStatistics = FALSE;
    LPWSTR                pszDSA = NULL;
    UUID *                puuid = NULL;
    UUID                  uuid;
    LPWSTR                pszNC = NULL;
    LPWSTR                pszCookieFile = NULL;
    LPWSTR                pszAttList = NULL;
    LPWSTR                pszSourceFilter = NULL;
    DWORD                 dwReplFlags = DRS_DIRSYNC_INCREMENTAL_VALUES;
    OBJ_DUMP_OPTIONS *    pObjDumpOptions = NULL;

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/v")
            || !_wcsicmp(argv[ iArg ], L"/verbose")) {
            fVerbose = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/s")
            || !_wcsicmp(argv[ iArg ], L"/statistics")) {
            fStatistics = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/ni")
            || !_wcsicmp(argv[ iArg ], L"/noincremental")) {
            dwReplFlags &= ~DRS_DIRSYNC_INCREMENTAL_VALUES;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/a")
            || !_wcsicmp(argv[ iArg ], L"/ancestors")) {
            dwReplFlags |= DRS_DIRSYNC_ANCESTORS_FIRST_ORDER;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/os")
            || !_wcsicmp(argv[ iArg ], L"/objectsecurity")) {
            dwReplFlags |= DRS_DIRSYNC_OBJECT_SECURITY;
        }
        else if (!_wcsnicmp(argv[ iArg ], L"/cookie:", 8)) {
            pszCookieFile = argv[ iArg ] + 8;
        }
        else if (!_wcsnicmp(argv[ iArg ], L"/atts:", 6)) {
            // Don't add 6, because ConsumeObjDumpOptions() will parse
            // the pszAttList variable.
            pszAttList = argv[ iArg ]; 
        }
        else if (!_wcsnicmp(argv[ iArg ], L"/filter:", 8)) {
            pszSourceFilter = argv[ iArg ] + 8;
        }
        else if ((NULL == pszNC) && (NULL != wcschr(argv[iArg], L'='))) {
            pszNC = argv[iArg];
        }
        else if ((NULL == puuid)
                 && (0 == UuidFromStringW(argv[iArg], &uuid))) {
            puuid = &uuid;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (pszNC == NULL) {
        PrintMsg(REPADMIN_PRINT_NO_NC);
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    // Get our ObjDumpOptions ... we just need it to consume the att list.
    if (pszAttList != NULL) {
        // Need to claim one arg, so ConsumeObjDumpOptions() will consume att list.
        argc = 1; 
    } else {
        argc = 0; // no args, just setup the default options.
    }
    ret = ConsumeObjDumpOptions(&argc, &pszAttList,
                                0 , // any defaults?  guess now
                                &pObjDumpOptions);
    if (ret) {
        RepadminPrintObjListError(ret);
        xListClearErrors();
        return(ret);
    }
    Assert(argc == 0);


    ret = ShowChangesEx(pszDSA,
                         puuid,
                         pszNC,
                         dwReplFlags,
                         pszCookieFile,
                         pszSourceFilter,
                         pObjDumpOptions);

    ObjDumpOptionsFree(&pObjDumpOptions);

    return(ret);
}

int ShowChanges(int argc, LPWSTR argv[])
{
    int                   iArg;
    BOOL                  fVerbose = FALSE;
    BOOL                  fStatistics = FALSE;
    LPWSTR                pszDSA = NULL;
    UUID *                puuid = NULL;
    UUID                  uuid;
    LPWSTR                pszNC = NULL;
    LPWSTR                pszCookieFile = NULL;
    LPWSTR                pszSourceFilter = NULL;
    DWORD                 dwReplFlags = DRS_DIRSYNC_INCREMENTAL_VALUES;
    OBJ_DUMP_OPTIONS *    pObjDumpOptions = NULL;
    DWORD                 ret = 0;

    argc -= 2; 
    // First we want to create our ObjDumpOptions ...
    ret = ConsumeObjDumpOptions(&argc, &argv[2],
                                0 , // any default values? guess not?
                                &pObjDumpOptions);
    if (ret) {
        RepadminPrintObjListError(ret);
        xListClearErrors();
        return(ret);
    }
    argc += 2;

    // Parse the remaining command-line arguments.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/v")
            || !_wcsicmp(argv[ iArg ], L"/verbose")) {
            pObjDumpOptions->dwFlags |= OBJ_DUMP_DISPLAY_ENTRIES;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/s")
            || !_wcsicmp(argv[ iArg ], L"/statistics")) {
            pObjDumpOptions->dwFlags |= OBJ_DUMP_ACCUMULATE_STATS;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/ni")
            || !_wcsicmp(argv[ iArg ], L"/noincremental")) {
            dwReplFlags &= ~DRS_DIRSYNC_INCREMENTAL_VALUES;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/a")
            || !_wcsicmp(argv[ iArg ], L"/ancestors")) {
            dwReplFlags |= DRS_DIRSYNC_ANCESTORS_FIRST_ORDER;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/os")
            || !_wcsicmp(argv[ iArg ], L"/objectsecurity")) {
            dwReplFlags |= DRS_DIRSYNC_OBJECT_SECURITY;
        }
        else if (!_wcsnicmp(argv[ iArg ], L"/cookie:", 8)) {
            pszCookieFile = argv[ iArg ] + 8;
        }
        else if (!_wcsnicmp(argv[ iArg ], L"/filter:", 8)) {
            pszSourceFilter = argv[ iArg ] + 8;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else if ((NULL == puuid)
                 && (0 == UuidFromStringW(argv[iArg], &uuid))) {
            puuid = &uuid;
        }
        else if ((NULL == pszNC) && (NULL != wcschr(argv[iArg], L'='))) {
            pszNC = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszDSA) {
        PrintMsg(REPADMIN_SYNCALL_NO_DSA);
        Assert(!"Hmmm, DC_LIST API, shouldn't let us continue w/o a DC DNS name");
        return ERROR_INVALID_PARAMETER;
    }

    if (pszNC == NULL) {
        PrintMsg(REPADMIN_PRINT_NO_NC);
        return ERROR_INVALID_PARAMETER;
    }

    ret = ShowChangesEx(pszDSA,
                         puuid,
                         pszNC,
                         dwReplFlags,
                         pszCookieFile,
                         pszSourceFilter,
                         pObjDumpOptions);

    // Clean up.
    ObjDumpOptionsFree(&pObjDumpOptions);

    return(ret);
}

int ShowChangesEx(
    WCHAR *     pszDSA,
    UUID *      puuid,
    WCHAR *     pszNC,
    DWORD       dwReplFlags,
    WCHAR *     pszCookieFile,
    WCHAR *     pszSourceFilter,
    OBJ_DUMP_OPTIONS *    pObjDumpOptions
    )
{
    #define fStatistics   
    DWORD                 ret, lderr;
    PBYTE                 pCookie = NULL;
    DWORD                 dwCookieLength = 0;
    LDAP *                hld = NULL;
    BOOL                  fMoreData = TRUE;
    LDAPMessage *         pChangeEntries = NULL;
    HANDLE                hDS = NULL;
    DS_REPL_NEIGHBORSW *  pNeighbors = NULL;
    DS_REPL_NEIGHBORW *   pNeighbor;
    DWORD                 i;
    DS_REPL_CURSORS * pCursors = NULL;
    DWORD             iCursor;
#define INITIAL_COOKIE_BUFFER_SIZE (8 * 1024)
    BYTE              bCookie[INITIAL_COOKIE_BUFFER_SIZE];
    BOOL              fCookieAllocated = FALSE;
    STAT_BLOCK        statistics;
    ULONG             ulOptions;
    SHOW_NEIGHBOR_STATE ShowState = { 0 };
    ShowState.fVerbose = TRUE;
    
    Assert(pObjDumpOptions);

    memset( &statistics, 0, sizeof( STAT_BLOCK ) );


    // TODO TODO TODO TODO
    // Provide a way to construct customized cookies.  For example, setting
    // the usn vector to zero results in a full sync.  This may be done by
    // specifying no or an empty cookie file. Setting the attribute filter usn
    // itself to zero results in changed objects with all attributes.  Specifying
    // a usn vector without an UTD results in all objects not received by the dest
    // from the source, even throught the source may have gotten them through other
    // neighbors.
    // TODO TODO TODO TODO

    // Default is stream
    if ( (!(pObjDumpOptions->dwFlags & OBJ_DUMP_DISPLAY_ENTRIES)) &&
         (!(pObjDumpOptions->dwFlags & OBJ_DUMP_ACCUMULATE_STATS)) ) {
        pObjDumpOptions->dwFlags |= OBJ_DUMP_DISPLAY_ENTRIES;
    }
    
    /**********************************************************************/
    /* Compute the initial cookie */
    /**********************************************************************/

    if (puuid == NULL) {
        FILE *stream = NULL;
        DWORD size;
        if ( (pszCookieFile) &&
             (stream = _wfopen( pszCookieFile, L"rb" )) ) {
            size = fread( bCookie, 1/*bytes*/,INITIAL_COOKIE_BUFFER_SIZE/*items*/, stream );
            if (size) {
                pCookie = bCookie;
                dwCookieLength = size;
                PrintMsg(REPADMIN_GETCHANGES_USING_COOKIE_FILE,
                        pszCookieFile, size );
            } else {
                PrintMsg(REPADMIN_GETCHANGES_COULDNT_READ_COOKIE, pszCookieFile );
            }
            fclose( stream );
        } else {
            PrintMsg(REPADMIN_GETCHANGES_EMPTY_COOKIE);
        }
    } else {
        PrintMsg(REPADMIN_GETCHANGES_BUILDING_START_POS, pszDSA);
        ret = RepadminDsBind(pszDSA, &hDS);
        if (ERROR_SUCCESS != ret) {
            PrintBindFailed(pszDSA, ret);
            goto error;
        }

        //
        // Display replication state associated with inbound neighbors.
        //

        ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, pszNC, puuid,
                                &pNeighbors);
        if (ERROR_SUCCESS != ret) {
            PrintFuncFailed(L"DsReplicaGetInfo", ret);
            goto error;
        }

        Assert( pNeighbors->cNumNeighbors == 1 );

        pNeighbor = &pNeighbors->rgNeighbor[0];
        PrintMsg(REPADMIN_GETCHANGES_SRC_NEIGHBOR, pNeighbor->pszNamingContext);

        ShowNeighbor(pNeighbor, IS_REPS_FROM, &ShowState);
        ShowState.pszLastNC = NULL;

        // Get Up To Date Vector

        ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_CURSORS_FOR_NC, pszNC, NULL,
                                &pCursors);
        if (ERROR_SUCCESS != ret) {
            PrintFuncFailed(L"DsReplicaGetInfo", ret);
            goto error;
        }

        
        PrintMsg(REPADMIN_GETCHANGES_DST_UTD_VEC);
        for (iCursor = 0; iCursor < pCursors->cNumCursors; iCursor++) {
            PrintMsg(REPADMIN_GETCHANGES_DST_UTD_VEC_ONE_USN, 
                   GetDsaGuidDisplayName(&pCursors->rgCursor[iCursor].uuidSourceDsaInvocationID),
                   pCursors->rgCursor[iCursor].usnAttributeFilter);
        }

        // Get the changes

        ret = DsMakeReplCookieForDestW( pNeighbor, pCursors, &pCookie, &dwCookieLength );
        if (ERROR_SUCCESS != ret) {
            PrintFuncFailed(L"DsGetReplCookieFromDest", ret);
            goto error;
        }
        fCookieAllocated = TRUE;
        pszDSA = pNeighbor->pszSourceDsaAddress;
    }

    /**********************************************************************/
    /* Get the changes using the cookie */
    /**********************************************************************/

    //
    // Connect to source
    //

    PrintMsg(REPADMIN_GETCHANGES_SRC_DSA_HDR, pszDSA);
    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        ret = ERROR_DS_SERVER_DOWN;
        goto error;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    //
    // Bind
    //

    lderr = ldap_bind_sA(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(lderr);

    //
    // Check filter syntax
    //
    if (pszSourceFilter) {
        lderr = ldap_check_filterW( hld, pszSourceFilter );
        CHK_LD_STATUS(lderr);
    }

    //
    // Loop getting changes untl done or error
    //

    ZeroMemory( &statistics, sizeof( STAT_BLOCK ) );

    ret = ERROR_SUCCESS;
    while (fMoreData) {
        PBYTE pCookieNew;
        DWORD dwCookieLengthNew;

        ret = DsGetSourceChangesW(
            hld,
            pszNC,
            pszSourceFilter,
            dwReplFlags,
            pCookie,
            dwCookieLength,
            &pChangeEntries,
            &fMoreData,
            &pCookieNew,
            &dwCookieLengthNew,
            pObjDumpOptions->aszDispAttrs
            );
        if (ret != ERROR_SUCCESS) {
            // New cookie will not be allocated
            break;
        }

        // Display changes
        displayChangeEntries(hld,
                             pChangeEntries, 
                             pObjDumpOptions,
                             &statistics );

        if (pObjDumpOptions->dwFlags & OBJ_DUMP_ACCUMULATE_STATS) {
            printStatistics( REPADMIN_GETCHANGES_PRINT_STATS_HDR_CUM_TOT,
                             &statistics );
        }

        // Release changes
        ldap_msgfree(pChangeEntries);

        // get rid of old cookie
        if ( fCookieAllocated && pCookie ) {
            DsFreeReplCookie( pCookie );
        }
        // Make new cookie the current cookie
        pCookie = pCookieNew;
        dwCookieLength = dwCookieLengthNew;
        fCookieAllocated = TRUE;
    }

    if (pObjDumpOptions->dwFlags & OBJ_DUMP_ACCUMULATE_STATS) {
        printStatistics( REPADMIN_GETCHANGES_PRINT_STATS_HDR_GRD_TOT,
                         &statistics );
    }

    /**********************************************************************/
    /* Write out new cookie */
    /**********************************************************************/

    // If we have a cookie and cookie file was specified, write out the new cookie
    if (pCookie && pszCookieFile) {
        FILE *stream = NULL;
        DWORD size;
        if (stream = _wfopen( pszCookieFile, L"wb" )) {
            size = fwrite( pCookie, 1/*bytes*/, dwCookieLength/*items*/, stream );
            if (size == dwCookieLength) {
                PrintMsg(REPADMIN_GETCHANGES_COOKIE_FILE_WRITTEN,
                         pszCookieFile, size );
            } else {
                PrintMsg(REPADMIN_GETCHANGES_COULDNT_WRITE_COOKIE, pszCookieFile );
            }
            fclose( stream );
        } else {
            PrintMsg(REPADMIN_GETCHANGES_COULDNT_OPEN_COOKIE, pszCookieFile );
        }
    }
error:
    if (hDS) {
        DsUnBind(&hDS);
    }

    if (hld) {
        ldap_unbind(hld);
    }

    // Free replica info

    if (pNeighbors) {
        DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
    }
    if (pCursors) {
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors);
    }
    // Close DS handle

    if ( fCookieAllocated && pCookie) {
        DsFreeReplCookie( pCookie );
    }

    return ret;
}




int ShowAttr(int argc, LPWSTR argv[])
{
    int                   iArg;
    DWORD                 dwRet;
    LDAP *                hLdap = NULL;
    BOOL                  fVerbose = FALSE;
    BOOL                  fGc = FALSE;
    LPWSTR                pszDSA = NULL;
    LPWSTR                pszObj = NULL;
    LPWSTR                pszAttList = NULL;
    LPWSTR                pszFilter = NULL;
    LDAPMessage *         pEntry = NULL;
    WCHAR                 szCmdName[64];
    BOOL                  fPrivate = FALSE;
    POBJ_LIST             pObjList = NULL;
    OBJ_DUMP_OPTIONS *    pObjDumpOptions = NULL;
    WCHAR **              argvTemp = NULL;

    __try {

        // Since this command can be called over and over again, we can't
        // consume the args from the master arg list.
        argvTemp  = LocalAlloc(LMEM_FIXED, argc * sizeof(WCHAR *));
        CHK_ALLOC(argvTemp);
        memcpy(argvTemp, argv, argc * sizeof(WCHAR *));
        argv = argvTemp;

        //
        // First, we're going to parse all the commands options.
        //

        // See if were running the private undocumented version of this function.
        raLoadString(IDS_CMD_SHOWATTR_P,
                     ARRAY_SIZE(szCmdName),
                     szCmdName);
        fPrivate = wcsequal(argv[1]+1, szCmdName);

        // Skip the "repadmin" and "/showattr" args ...
        argc -= 2; 
        dwRet = ConsumeObjDumpOptions(&argc, &argv[2],
                                      OBJ_DUMP_VAL_FRIENDLY_KNOWN_BLOBS | 
                                      ((fPrivate) ? OBJ_DUMP_PRIVATE_BLOBS : 0),
                                      &pObjDumpOptions);
        if (dwRet) {
            RepadminPrintObjListError(dwRet);
            xListClearErrors();
            __leave;
        }
        dwRet = ConsumeObjListOptions(&argc, &argv[2], 
                                      &pObjList);
        if (dwRet) {
            RepadminPrintObjListError(dwRet);
            xListClearErrors();
            __leave;
        }
        argc += 2;

        // Parse the remaining command-line arguments.
        for (iArg = 2; iArg < argc; iArg++) {
            if (!_wcsicmp(argv[ iArg ], L"/gc")) {
                fGc = TRUE;
            }
            else if (NULL == pszDSA) {
                pszDSA = argv[iArg];
            }
            else if (NULL == pszObj) {
                pszObj = argv[iArg];
            }
            else {
                PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
                dwRet = ERROR_INVALID_FUNCTION;
                __leave;
            }
        }

        if (pszDSA == NULL) {
            PrintMsg(REPADMIN_SYNCALL_NO_DSA);
            Assert(!"Hmmm, DC_LIST API, shouldn't let us continue w/o a DC DNS name");
            dwRet = ERROR_INVALID_PARAMETER;
            __leave;
        }
        
        if (pszObj == NULL) {
            PrintMsg(REPADMIN_PRINT_NO_NC);
            dwRet = ERROR_INVALID_PARAMETER;
            __leave;
        }
            
        // Note pObjList may or may not be allocated by ConsumeObjListOptions()
        Assert(pObjDumpOptions && pszDSA && pszObj);


        //
        // Now, connect to the server...
        //

        if (fGc) {
            dwRet = RepadminLdapBindEx(pszDSA, LDAP_GC_PORT, FALSE, TRUE, &hLdap);
        } else {
            dwRet = RepadminLdapBindEx(pszDSA, LDAP_PORT, FALSE, TRUE, &hLdap);
        }
        if (dwRet) {
            // RepadminLdapBind should've printed.
            __leave;
        }
        Assert(hLdap);
        
        dwRet = ObjListParse(hLdap, 
                             pszObj,
                             pObjDumpOptions->aszDispAttrs,
                             pObjDumpOptions->apControls,
                             &pObjList);
        if (dwRet) {
            RepadminPrintObjListError(dwRet);
            xListClearErrors();
            __leave;
        }


        dwRet = ObjListGetFirstEntry(pObjList, &pEntry);
        if (dwRet) {
            RepadminPrintObjListError(dwRet);
            xListClearErrors();
            __leave;
        }
        Assert(pEntry);

        do {
            
            dwRet = ObjDump(hLdap, RepadminObjDumpPrint, pEntry, 0, pObjDumpOptions);
            if (dwRet) {
                RepadminPrintObjListError(dwRet);
                xListClearErrors();
                __leave;
            }
            pEntry = NULL; // Don't need to free, it's just a current entry

            dwRet = ObjListGetNextEntry(pObjList, &pEntry);

        } while ( dwRet == ERROR_SUCCESS && pEntry );

        if (dwRet) {
            RepadminPrintObjListError(dwRet);
            xListClearErrors();
            __leave;
        }


    } __finally {

        if (hLdap) { RepadminLdapUnBind(&hLdap); }
        if (pObjDumpOptions) { ObjDumpOptionsFree(&pObjDumpOptions); }
        if (pObjList) { ObjListFree(&pObjList); }
        if (argvTemp) { LocalFree(argvTemp); }

    }
    
    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\repdsrep.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repdsrep.c - DS Replica functions

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "ReplRpcSpoof.hxx"
#include "repadmin.h"

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0)


int Bind(int argc, LPWSTR argv[])
{
    // Keep this in sync with ntdsa.h
    const struct {
        DWORD ID;
        LPSTR psz;
    } rgKnownExts[] = {
        { DRS_EXT_BASE,                         "BASE"                         },
        { DRS_EXT_ASYNCREPL,                    "ASYNCREPL"                    },
        { DRS_EXT_REMOVEAPI,                    "REMOVEAPI"                    },
        { DRS_EXT_MOVEREQ_V2,                   "MOVEREQ_V2"                   },
        { DRS_EXT_GETCHG_COMPRESS,              "GETCHG_COMPRESS"              },
        { DRS_EXT_DCINFO_V1,                    "DCINFO_V1"                    },
        { DRS_EXT_RESTORE_USN_OPTIMIZATION,     "RESTORE_USN_OPTIMIZATION"     },
        // DRS_EXT_ADDENTRY not interesting
        { DRS_EXT_KCC_EXECUTE,                  "KCC_EXECUTE"                  },
        { DRS_EXT_ADDENTRY_V2,                  "ADDENTRY_V2"                  },
        { DRS_EXT_LINKED_VALUE_REPLICATION,     "LINKED_VALUE_REPLICATION"     },
        { DRS_EXT_DCINFO_V2,                    "DCINFO_V2"                    },
        { DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD, "INSTANCE_TYPE_NOT_REQ_ON_MOD" },
        { DRS_EXT_CRYPTO_BIND,                  "CRYPTO_BIND"                  },
        { DRS_EXT_GET_REPL_INFO,                "GET_REPL_INFO"                },
        { DRS_EXT_STRONG_ENCRYPTION,            "STRONG_ENCRYPTION"            },
        { DRS_EXT_DCINFO_VFFFFFFFF,             "DCINFO_VFFFFFFFF"             },
        { DRS_EXT_TRANSITIVE_MEMBERSHIP,        "TRANSITIVE_MEMBERSHIP"        },
        { DRS_EXT_ADD_SID_HISTORY,              "ADD_SID_HISTORY"              },
        { DRS_EXT_POST_BETA3,                   "POST_BETA3"                   },
        // DRS_EXT_GETCHGREQ_V5 not interesting
        { DRS_EXT_GETMEMBERSHIPS2,              "GET_MEMBERSHIPS2"             },
        { DRS_EXT_GETCHGREQ_V6,                 "GETCHGREQ_V6 (WHISTLER PREVIEW)" },
        { DRS_EXT_NONDOMAIN_NCS,                "NONDOMAIN_NCS"                },
        { DRS_EXT_GETCHGREQ_V8,                 "GETCHGREQ_V8 (WHISTLER BETA 1)"  },
        { DRS_EXT_GETCHGREPLY_V5,               "GETCHGREPLY_V5 (WHISTLER BETA 2)"  },
        { DRS_EXT_GETCHGREPLY_V6,               "GETCHGREPLY_V6 (WHISTLER BETA 2)"  },
        { DRS_EXT_ADDENTRYREPLY_V3,             "ADDENTRYREPLY_V3 (WHISTLER BETA 3)" },
        { DRS_EXT_GETCHGREPLY_V7,               "GETCHGREPLY_V7 (WHISTLER BETA 3) " },
        { DRS_EXT_VERIFY_OBJECT,                "VERIFY_OBJECT (WHISTLER BETA 3)" },
        { DRS_EXT_XPRESS_COMPRESSION,           "XPRESS_COMPRESSION"  },
    };

    ULONG       ret = 0;
    ULONG       secondary;
    ULONG       ulOptions = 0;
    int         iArg;
    LPWSTR      pszOnDRA = NULL;
    HANDLE      hDS;
    BindState * pBindState;
    DWORD       iExt;
    GUID *      pSiteGuid;
    DWORD       dwReplEpoch;

    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszOnDRA) {
            pszOnDRA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszOnDRA) {
        pszOnDRA = L"localhost";
    }

    ret = RepadminDsBind(pszOnDRA, &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    // Crack DS handle to retrieve extensions of the target DSA.
    pBindState = (BindState *) hDS;

    PrintMsg(REPADMIN_BIND_SUCCESS, pszOnDRA);

    PrintMsg(REPADMIN_BIND_EXT_SUPPORTED_HDR);
    for (iExt = 0; iExt < ARRAY_SIZE(rgKnownExts); iExt++) {
        if(IS_DRS_EXT_SUPPORTED(pBindState->pServerExtensions,
                                    rgKnownExts[iExt].ID)){
            PrintMsg(REPADMIN_BIND_EXT_SUPPORTED_LINE_YES, 
                     rgKnownExts[iExt].psz);
        } else {
            PrintMsg(REPADMIN_BIND_EXT_SUPPORTED_LINE_NO,
                     rgKnownExts[iExt].psz);
        }
    }

    pSiteGuid = SITE_GUID_FROM_DRS_EXT(pBindState->pServerExtensions);
    if (NULL != pSiteGuid) {
        PrintMsg(REPADMIN_BIND_SITE_GUID, GetStringizedGuid(pSiteGuid));
    }

    dwReplEpoch = REPL_EPOCH_FROM_DRS_EXT(pBindState->pServerExtensions);
    PrintMsg(REPADMIN_BIND_REPL_EPOCH, dwReplEpoch);

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    return 0;
}

int Add(int argc, LPWSTR argv[])
{
    ULONG ret = 0, secondary;
    ULONG ulOptions =
        DS_REPADD_WRITEABLE |
        DS_REPADD_INITIAL |
        DS_REPADD_PERIODIC |
        DS_REPADD_USE_COMPRESSION |
        gulDrsFlags;
    UCHAR buffer[sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES];
    PSCHEDULE pSchedule = (PSCHEDULE) &buffer;
    int i = 0;
    BOOL fLocal = FALSE;
    int iArg;
    LPWSTR pszNC;
    LPWSTR pszOnDRA;
    LPWSTR pszSrcDsa;
    LPWSTR DsaDN = NULL;
    LPWSTR TransportDN = NULL;
    HANDLE hDS;


    // assume all the parameters are available and syntactically correct
    if (argc < 5)
    {
        PrintHelp( TRUE /* expert */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments

    pszNC     = argv[ 2 ];
    pszOnDRA  = argv[ 3 ];
    pszSrcDsa = argv[ 4 ];

    // Construct schedule with every 15 minute interval selected

    pSchedule->Size = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    pSchedule->Bandwidth = 0;
    pSchedule->NumberOfSchedules = 1;
    pSchedule->Schedules[0].Type = SCHEDULE_INTERVAL;
    pSchedule->Schedules[0].Offset = sizeof( SCHEDULE );

    memset( buffer + sizeof(SCHEDULE), 0x0f, SCHEDULE_DATA_ENTRIES );

    // Optional arguments

    for ( iArg = 5; iArg < argc; iArg++ )
    {
        if (!_wcsicmp(argv[iArg], L"/syncdisable"))
            ulOptions |= (DS_REPADD_DISABLE_NOTIFICATION |
                          DS_REPADD_DISABLE_PERIODIC);
        else if (!_wcsicmp(argv[iArg], L"/readonly"))
            ulOptions &= ~DS_REPADD_WRITEABLE;
        else if (!_wcsicmp(argv[iArg], L"/mail")) {
            ulOptions |= DS_REPADD_INTERSITE_MESSAGING;
        }
        else if (!_wcsicmp(argv[iArg], L"/asyncrep")) {
            ulOptions |= DS_REPADD_ASYNCHRONOUS_REPLICA;
        }
        else if (!_wcsnicmp(argv[iArg], L"/dsadn:", sizeof("/dsadn:")-1)) {
            DsaDN = argv[iArg] + sizeof("/dsadn:") - 1;
        }
        else if (!_wcsnicmp(argv[iArg], L"/transportdn:",
                            sizeof("/transportdn:")-1)) {
            TransportDN = argv[iArg] + sizeof("/transportdn:") - 1;
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    ret = RepadminDsBind(pszOnDRA, &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaAddW(hDS,
                        pszNC,
                        DsaDN,
                        TransportDN,
                        pszSrcDsa,
                        pSchedule,
                        ulOptions);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaAdd", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
        if (ulOptions & DS_REPADD_ASYNCHRONOUS_OPERATION) {
            PrintMsg(REPADMIN_ADD_ENQUEUED_ONE_WAY_REPL, 
                   pszSrcDsa, pszOnDRA);
        }
        else {
            PrintMsg(REPADMIN_ADD_ONE_WAY_REPL_ESTABLISHED,
                     pszSrcDsa, pszOnDRA);
        }
    }

    return ret;
}

int Mod(int argc, LPWSTR argv[])
/*

These are the modifications we support:

DS_REPMOD_UPDATE_FLAGS     - Yes
DS_REPMOD_UPDATE_ADDRESS   - Yes
DS_REPMOD_UPDATE_SCHEDULE  - Is possible from client, but not implemented.
DS_REPMOD_UPDATE_RESULT    - Not possible from client.
DS_REPMOD_UPDATE_TRANSPORT - Not possible from client.

 */

{
    ULONG ret = 0, secondary;
    int i = 0;
    int iArg;
    UUID uuid;
    LPWSTR pszNC;
    LPWSTR pszOnDRA;
    LPWSTR pszUUID;
    LPWSTR pszSrcDsa = NULL;
    LPWSTR DsaDN = NULL;
    LPWSTR TransportDN = NULL;
    PSCHEDULE pSchedule = NULL;
    HANDLE hDS;
    ULONG ulOptions = gulDrsFlags;
    ULONG ulReplicaFlags = 0, ulSetFlags = 0, ulClearFlags = 0;
    ULONG ulModifyFields = 0;
    DS_REPL_NEIGHBORSW *  pNeighbors;
    DS_REPL_NEIGHBORW *   pNeighbor;

    // assume all the parameters are available and syntactically correct
    if (argc < 5)
    {
        PrintHelp( TRUE /* expert */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments

    pszNC     = argv[ 2 ];
    pszOnDRA  = argv[ 3 ];
    pszUUID   = argv[ 4 ];

    // TODO: Provide the ability to specify and modify the schedule

    ret = UuidFromStringW(pszUUID, &uuid);
    if (ret != ERROR_SUCCESS) {
        PrintMsg(REPADMIN_MOD_GUID_CONVERT_FAILED, pszUUID);
        PrintErrEnd(ret);
        return ret;
    }

    ret = RepadminDsBind(pszOnDRA, &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    // Verify that the reps-from exists, and read the old flags
    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, pszNC, &uuid,
                            &pNeighbors);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        return ret;
    }

    Assert( pNeighbors );
    pNeighbor = &pNeighbors->rgNeighbor[0];
    ulReplicaFlags = pNeighbor->dwReplicaFlags;
    PrintMsg(REPADMIN_MOD_CUR_REPLICA_FLAGS, 
                    GetOptionsString( RepNbrOptionToDra, ulReplicaFlags ) );

    PrintMsg(REPADMIN_MOD_CUR_SRC_ADDRESS, pNeighbor->pszSourceDsaAddress);

    // Optional arguments

    for ( iArg = 5; iArg < argc; iArg++ )
    {
        if (!_wcsnicmp(argv[iArg], L"/srcdsaaddr:", sizeof("/srcdsaaddr:")-1)) {
            pszSrcDsa = argv[iArg] + sizeof("/srcdsaaddr:") - 1;
            ulModifyFields |= DS_REPMOD_UPDATE_ADDRESS;
        }
        // This is for future use
        else if (!_wcsnicmp(argv[iArg], L"/transportdn:",
                            sizeof("/transportdn:")-1)) {
            TransportDN = argv[iArg] + sizeof("/transportdn:") - 1;
            ulModifyFields |= DS_REPMOD_UPDATE_TRANSPORT;
        }
        else if (*argv[iArg] == L'+') {
            ulSetFlags |=
                GetPublicOptionByNameW( RepNbrOptionToDra, (argv[iArg] + 1) );
        }
        else if (*argv[iArg] == L'-') {
            ulClearFlags |=
                GetPublicOptionByNameW( RepNbrOptionToDra, (argv[iArg] + 1) );
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (ulSetFlags | ulClearFlags) {
        ULONG ulBadFlags = ( (ulSetFlags | ulClearFlags) &
                             (~DS_REPL_NBR_MODIFIABLE_MASK) );
        if (ulBadFlags) {
            PrintMsg( REPADMIN_MOD_FLAGS_NOT_MODABLE, 
                    GetOptionsString( RepNbrOptionToDra, ulBadFlags ) );
        } else {
            ulReplicaFlags |= ulSetFlags;
            ulReplicaFlags &= ~ulClearFlags;
            ulModifyFields |= DS_REPMOD_UPDATE_FLAGS;
        }
    }

    ret = DsReplicaModifyW(hDS,             // hDS
                           pszNC,           // pNameContext
                           &uuid,           // pUuidSourceDsa
                           TransportDN,     // pTransportDn
                           pszSrcDsa,       // pSourceDsaAddress
                           pSchedule,       // pSchedule (NULL)
                           ulReplicaFlags,  // ReplicaFlags
                           ulModifyFields,  // ModifyFields
                           ulOptions        // Options
                           );
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaModify", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
        PrintMsg(REPADMIN_MOD_REPL_LINK_MODIFIED, pszUUID, pszOnDRA);
        if (ulModifyFields & DS_REPMOD_UPDATE_ADDRESS) {
            PrintMsg(REPADMIN_MOD_SRC_ADDR_SET, pszSrcDsa);
        }
        if (ulModifyFields & DS_REPMOD_UPDATE_TRANSPORT) {
            PrintMsg(REPADMIN_MOD_TRANSPORT_DN_SET, TransportDN);
        }
        if (ulModifyFields & DS_REPMOD_UPDATE_FLAGS) {
            PrintMsg(REPADMIN_MOD_REPLICA_FLAGS_SET, 
                    GetOptionsString( RepNbrOptionToDra, ulReplicaFlags ) );
        }
    }

    DsReplicaFreeInfo(DS_REPL_INFO_REPSTO, pNeighbors);

    return ret;
}

int Del(int argc, LPWSTR argv[])
{
    ULONG ret = 0, secondary;
    ULONG ulOptions = DS_REPDEL_WRITEABLE | gulDrsFlags;
    DWORD cLen = 0;
    int iArg;
    LPWSTR pszNC;
    LPWSTR pszOnDRA;
    LPWSTR pszRepsTo = NULL; // aka pszDsaSrc
    HANDLE hDS;

    // assume all the parameters are available and syntactically correct
    if (argc < 5) {
        PrintHelp( TRUE /* expert */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments

    pszNC    = argv[ 2 ];
    pszOnDRA = argv[ 3 ];

    // Optional arguments

    for (iArg = 4; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/localonly")) {
            ulOptions |= DS_REPDEL_LOCAL_ONLY;
        }
        else if (!_wcsicmp(argv[iArg], L"/nosource")) {
            ulOptions |= DS_REPDEL_NO_SOURCE;
        }
        else if (NULL == pszRepsTo) {
            pszRepsTo = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (    ((NULL == pszRepsTo) && !(ulOptions & DS_REPDEL_NO_SOURCE))
         || ((NULL != pszRepsTo) && (ulOptions & DS_REPDEL_NO_SOURCE)) ) {
        PrintMsg(REPADMIN_DEL_ONE_REPSTO);
        return ERROR_INVALID_PARAMETER;
    }

    ret = RepadminDsBind(pszOnDRA, &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaDelW(hDS,
                        pszNC,
                        pszRepsTo,
                        ulOptions);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaDel", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
        if (ulOptions & DS_REPDEL_ASYNCHRONOUS_OPERATION) {
            PrintMsg(REPADMIN_DEL_ENQUEUED_ONE_WAY_REPL_DEL,
                   pszRepsTo, pszOnDRA);
        }
        else {
            PrintMsg(REPADMIN_DEL_DELETED_REPL_LINK,
                   pszRepsTo, pszOnDRA);
        }
    }

    return ret;
}

int UpdRefs(int argc, LPWSTR argv[], ULONG ulOptions)
{
    ULONG       ret = 0, secondary;
    LPWSTR      pszNC;
    LPWSTR      pszOnDRA;
    LPWSTR      pszRepsToDRA;
    LPWSTR      pszUUID;
    UUID        uuid;
    int         iArg;
    HANDLE hDS;

    // assume all the parameters are available and syntactically correct
    if (argc < 6) {
        PrintHelp( TRUE /* expert */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments

    pszNC        = argv[ 2 ];
    pszOnDRA     = argv[ 3 ];
    pszRepsToDRA = argv[ 4 ];   // aka pszDsaSrc
    pszUUID      = argv[ 5 ];

    // Optional arguments

    ulOptions |= DS_REPUPD_WRITEABLE | gulDrsFlags;
    for (iArg = 6; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/readonly")) {
            ulOptions &= ~DS_REPUPD_WRITEABLE;
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    ret = UuidFromStringW(pszUUID, &uuid);
    if (ret != ERROR_SUCCESS) {
        PrintMsg(REPADMIN_MOD_GUID_CONVERT_FAILED, pszUUID);
        PrintErrEnd(ret);
        return ret;
    }

    ret = RepadminDsBind( pszOnDRA, &hDS );
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaUpdateRefsW(hDS,
                               pszNC,
                               pszRepsToDRA,
                               &uuid,
                               ulOptions);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaUpdateRefs", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
        if (ulOptions & DS_REPUPD_ASYNCHRONOUS_OPERATION) {
            PrintMsg(REPADMIN_UPDREFS_ENQUEUED_UPDATE_NOTIFICATIONS,
                     pszRepsToDRA, pszOnDRA);
        }
        else {
            PrintMsg(REPADMIN_UPDREFS_UPDATED_NOTIFICATIONS,
                     pszRepsToDRA, pszOnDRA);
        }
    }

    return ret;
}

int UpdRepsTo(int argc, LPWSTR argv[]) {
    return UpdRefs(argc,
                   argv,
                   DS_REPUPD_ADD_REFERENCE | DS_REPUPD_DELETE_REFERENCE);
}

int AddRepsTo(int argc, LPWSTR argv[]) {
    return UpdRefs(argc, argv, DS_REPUPD_ADD_REFERENCE);
}

int DelRepsTo(int argc, LPWSTR argv[]) {
    return UpdRefs(argc, argv, DS_REPUPD_DELETE_REFERENCE);
}

int RunKCC(int argc, LPWSTR argv[])
{
    ULONG   ret = 0;
    ULONG   secondary;
    ULONG   ulOptions = 0;
    int     iArg;
    LPWSTR  pszOnDRA = NULL;
    HANDLE  hDS;

    for (iArg = 2; iArg < argc; iArg++) {

        if (!_wcsicmp(argv[iArg], L"/damped")) {
            ulOptions |= DS_KCC_FLAG_DAMPED;
            continue;
        }

        if( NULL==pszOnDRA ) {
            pszOnDRA = argv[iArg];
        } else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszOnDRA) {
        pszOnDRA = L"localhost";
    }

    if (gulDrsFlags & DS_REPADD_ASYNCHRONOUS_OPERATION) {
        ulOptions |= DS_KCC_FLAG_ASYNC_OP;
    }

    ret = RepadminDsBind(pszOnDRA, &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaConsistencyCheck(hDS,
                                    DS_KCC_TASKID_UPDATE_TOPOLOGY,
                                    ulOptions);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaConsistencyCheck", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
        if (ulOptions & DS_KCC_FLAG_ASYNC_OP) {
            PrintMsg(REPADMIN_KCC_ENQUEUED_KCC, pszOnDRA);
        }
        else {
            PrintMsg(REPADMIN_KCC_KCC_SUCCESS, pszOnDRA);
        }
    }

    return ret;
}

int
ReplicateEx(
    WCHAR *   pszOnDRA,
    WCHAR *   pszNC,
    WCHAR *   pszUuid,
    UUID *    pSrcGuid,
    ULONG     ulOptions
    );

int Sync(
    int argc, 
    LPWSTR argv[]
    )
/*++

Routine Description:

    This is the deprecated version of the /Replicate command.

Arguments:

    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    error from the repadmin cmd.

--*/
{
    ULONG ulOptions = DS_REPSYNC_WRITEABLE | gulDrsFlags;
    ULONG ret = 0, secondary;
    int iArg;
    UUID uuid = {0};
    HANDLE hDS;

    LPWSTR pszNC;
    LPWSTR pszOnDRA;
    LPWSTR pszUuid;

    // assume all the parameters are available and syntactically correct
    if (argc < 5) {
        PrintHelp( FALSE /* novice */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments
    pszNC    = argv[ 2 ];
    pszOnDRA = argv[ 3 ];
    pszUuid  = argv[ 4 ];

    iArg = 5;

    // Was UUID specified?
    ret = UuidFromStringW(pszUuid, &uuid);
    if (ret != ERROR_SUCCESS) {
        pszUuid = NULL;
        --iArg;
    }

    // Optional arguments
    for (; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/Force")) {
            ulOptions |= DS_REPSYNC_FORCE;
        }
        else if (!_wcsicmp(argv[iArg], L"/ReadOnly")) {
            ulOptions &= ~DS_REPSYNC_WRITEABLE;
        }
        else if (!_wcsicmp(argv[iArg], L"/mail")) {
            ulOptions |= DS_REPSYNC_INTERSITE_MESSAGING;
        }
        else if (!_wcsicmp(argv[iArg], L"/Full")) {
            ulOptions |= DS_REPSYNC_FULL;
        }
        else if (!_wcsicmp(argv[iArg], L"/addref")) {
            ulOptions |= DS_REPSYNC_ADD_REFERENCE;
        }
        else if (!_wcsicmp(argv[iArg], L"/periodic")) {
            ulOptions |= DS_REPSYNC_PERIODIC;
        }
        else if (!_wcsicmp(argv[iArg], L"/notify")) {
            ulOptions |= DS_REPSYNC_NOTIFICATION;
        }
        else if (!_wcsicmp(argv[iArg], L"/init")) {
            ulOptions |= DS_REPSYNC_INITIAL;
        }
        else if (!_wcsicmp(argv[iArg], L"/urgent")) {
            ulOptions |= DS_REPSYNC_URGENT;
        }
        else if (!_wcsicmp(argv[iArg], L"/allsources")) {
            ulOptions |= DS_REPSYNC_ALL_SOURCES;
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (((NULL == pszUuid) && !(ulOptions & DS_REPSYNC_ALL_SOURCES))
        || ((NULL != pszUuid) && (ulOptions & DS_REPSYNC_ALL_SOURCES))) {
        PrintMsg(REPADMIN_SYNC_SRC_GUID_OR_ALLSRC);
        return ERROR_INVALID_FUNCTION;
    }

    ret = ReplicateEx(pszOnDRA, pszNC, pszUuid, &uuid, ulOptions);

    return(ret);
}

int Replicate( // new /Sync
    int argc, 
    LPWSTR argv[]
    )
/*++

Routine Description:

    This is the newer version of the /Sync command, that takes
    the DC_LIST argument first.

Arguments:

    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    error from the repadmin cmd.

--*/
{
    ULONG ulOptions = DS_REPSYNC_WRITEABLE | gulDrsFlags;
    ULONG ret = 0, secondary;
    int iArg;
    UUID SrcGuid = {0};
    HANDLE hDS;

    LPWSTR pszNC = NULL;
    LPWSTR pszDstDsa = NULL;
    LPWSTR pszSrcDcName = NULL;

    // assume all the parameters are available and syntactically correct
    if (argc < 5) {
        PrintHelp( FALSE /* novice */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Optional arguments
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/Force")) {
            ulOptions |= DS_REPSYNC_FORCE;
        }
        else if (!_wcsicmp(argv[iArg], L"/ReadOnly")) {
            ulOptions &= ~DS_REPSYNC_WRITEABLE;
        }
        else if (!_wcsicmp(argv[iArg], L"/mail")) {
            ulOptions |= DS_REPSYNC_INTERSITE_MESSAGING;
        }
        else if (!_wcsicmp(argv[iArg], L"/Full")) {
            ulOptions |= DS_REPSYNC_FULL;
        }
        else if (!_wcsicmp(argv[iArg], L"/addref")) {
            ulOptions |= DS_REPSYNC_ADD_REFERENCE;
        }
        else if (!_wcsicmp(argv[iArg], L"/allsources")) {
            ulOptions |= DS_REPSYNC_ALL_SOURCES;
        } else if (pszDstDsa == NULL) {
            pszDstDsa = argv[iArg];
        } else if (pszSrcDcName == NULL) {
            pszSrcDcName = argv[iArg];
        } else if (pszNC == NULL) {
            pszNC = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Was UUID specified, or other convertible name, use "." to not specify.
    ret = ResolveDcNameToDsaGuid(NULL, pszSrcDcName, &SrcGuid);
    if (ret != ERROR_SUCCESS) {
        xListClearErrors();
        pszSrcDcName = NULL;
        --iArg;
    }

    if (((NULL == pszSrcDcName) && !(ulOptions & DS_REPSYNC_ALL_SOURCES))
        || ((NULL != pszSrcDcName) && (ulOptions & DS_REPSYNC_ALL_SOURCES))) {
        PrintMsg(REPADMIN_SYNC_SRC_GUID_OR_ALLSRC);
        return ERROR_INVALID_PARAMETER;
    }
    
    ret = ReplicateEx(pszDstDsa, pszNC, pszSrcDcName, &SrcGuid, ulOptions);

    return(ret);
}

int
ReplicateEx(
    WCHAR *   pszOnDRA,
    WCHAR *   pszNC,
    WCHAR *   pszUuid,
    UUID *    pSrcGuid,
    ULONG     ulOptions
    )
/*++

Routine Description:

    This is the heart of the /Sync and /Replicate commands.

Arguments:

    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    error from the repadmin cmd.

--*/
{
    ULONG ret = 0, secondary;
    HANDLE hDS;


    ret = RepadminDsBind(pszOnDRA, &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaSyncW(hDS, pszNC, pSrcGuid, ulOptions);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaSync", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
        if (ulOptions & DS_REPUPD_ASYNCHRONOUS_OPERATION) {
            if(pszUuid){
                PrintMsg(REPADMIN_SYNC_ENQUEUED_SYNC,
                       pszUuid,
                       pszOnDRA);
            } else {
                PrintMsg(REPADMIN_SYNC_ENQUEUED_SYNC_ALL_NEIGHBORS,
                       pszOnDRA);
            }
        } else {
            if(pszUuid){
                PrintMsg(REPADMIN_SYNC_SYNC_SUCCESS,
                       pszUuid,
                       pszOnDRA);
            } else {
                PrintMsg(REPADMIN_SYNC_SYNC_SUCCESS_ALL_NEIGHBORS,
                       pszOnDRA);
            }
        }
    }

    return ret;
}

int ReplSingleObj(int argc, LPWSTR argv[])
{
    int         ret = 0;
    ULONG       secondary;
    LDAP *      hld;
    HANDLE      hDS;
    int         iArg;
    int         ldStatus;
    LPWSTR      pszValue = NULL;
    LPWSTR      rgpszValues[2];
    LDAPModW    ModOpt = {LDAP_MOD_REPLACE, L"replicateSingleObject", rgpszValues};
    LDAPModW *  rgpMods[] = {&ModOpt, NULL};
    ULONG       ulOptions;
    LPWSTR      pszDsaDest = NULL;
    LPWSTR      pszObj = NULL;
    LPWSTR      pszDsaSource = NULL;
    LPWSTR      pszGuidEqB = L"<GUID=";
    LPWSTR      pszGuidEqE = L">";

    // Parse command-line arguments.
    
    // format [dsa-dest] <dsa-source-guid> <obj-dn>

    iArg = 2;

    // the first arg is dsa-dest or there's only 2 params
    if (argc>4) {
	pszDsaDest = argv[iArg++];
    } else if (argc<4) {
	PrintMsg(REPADMIN_GENERAL_INVALID_ARGS);
	return ERROR_INVALID_PARAMETER;
    }

    // get the source
    // assume that it's a GUID
    pszDsaSource = malloc(sizeof(WCHAR) * (wcslen(pszGuidEqB) + wcslen(pszGuidEqE) + wcslen(argv[iArg]) + 1));
    if (!pszDsaSource) {
	PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
	return ERROR_NOT_ENOUGH_MEMORY; 
    }
    wcscpy(pszDsaSource,pszGuidEqB);
    wcscat(pszDsaSource,argv[iArg++]);
    wcscat(pszDsaSource,pszGuidEqE);

    pszObj = argv[iArg];

    pszValue = malloc(sizeof(WCHAR) * (wcslen(pszDsaSource) + wcslen(pszObj) + 2));
    if (!pszValue) {
	free(pszDsaSource);
	PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
	return ERROR_NOT_ENOUGH_MEMORY;
    }
    wcscpy(pszValue, pszDsaSource);
    wcscat(pszValue, L":");
    wcscat(pszValue, pszObj);

    rgpszValues[0] = pszValue;
    rgpszValues[1] = NULL;

    // Connect.
    if (NULL == pszDsaDest) {
        pszDsaDest = L"localhost";
    }

    hld = ldap_initW(pszDsaDest, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDsaDest);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Modify.
    ldStatus = ldap_modify_sW(hld, NULL, rgpMods);
    CHK_LD_STATUS(ldStatus);

    PrintMsg(REPADMIN_REPL_SINGLE_OBJ_SUCCESSFULLY_INVOKED, pszObj, pszDsaDest, pszDsaSource);
    free(pszValue);
    free(pszDsaSource);

    return 0;
}

int RemoveLingeringObjects(int argc, LPWSTR argv[])
{
    ULONG   ret = 0;
    ULONG   secondary;
    int     iArg;
    LPWSTR  pszNC = NULL;
    HANDLE  hDS;
    LPWSTR  pszSourceInput = NULL;
    LPWSTR  pszDestinationInput = NULL;
    UUID    uuidSource;
    ULONG   ulOptions = 0;
    RPC_STATUS rpcStatus = RPC_S_OK;

    // input should be 
    // <computer-name-of-destiniation>
    //      <computer-guid-of-source>
    //      <NC>
    //      [/ADVISORY_MODE]
    if (argc<4) {
	PrintMsg(REPADMIN_GENERAL_INVALID_ARGS);
	return ERROR_INVALID_FUNCTION;
    }

    for (iArg = 2; iArg < argc; iArg++) { 
        if (iArg==2) {
            pszDestinationInput = argv[iArg];
        }
	else if (iArg==3) {
	    pszSourceInput = argv[iArg];
	}
	else if (iArg==4) {
	    pszNC = argv[iArg];
	}
	else if ((iArg==5) && (!_wcsicmp(argv[iArg],L"/ADVISORY_MODE"))) {
	    ulOptions = DS_EXIST_ADVISORY_MODE;  
	} 
    }

    ret = RepadminDsBind(pszDestinationInput, &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszDestinationInput, ret);
        return ret;
    }

    // currently input is <dns or netbios name> <guid> <NC>
    rpcStatus = UuidFromStringW(pszSourceInput, &uuidSource);	
    if (rpcStatus!=RPC_S_OK) {
	PrintMsg(REPADMIN_GENERAL_INVALID_ARGS);
	return ERROR_INVALID_FUNCTION;
    }

    ret = DsReplicaVerifyObjectsW(hDS, 
				  pszNC,
				  &uuidSource,
				  ulOptions);

    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaVerifyObjectsW", ret);
        // keep going
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    if (ret == ERROR_SUCCESS) {
	PrintMsg(REPADMIN_REMOVELINGERINGOBJECTS_SUCCESS, pszDestinationInput);
    }

    return ret;
}


int
RemoveSources(
    HANDLE hDS,
    LPWSTR pszDsaDest,
    LPWSTR pszNC,
    DS_REPL_NEIGHBORSW *  pNeighbors
    )
/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG   ret = 0;
    ULONG ulOptions = 0;
    DWORD i;
    DS_REPL_NEIGHBORW *   pNeighbor;

    for( i = 0; i < pNeighbors->cNumNeighbors; i++ ) {
        pNeighbor = &pNeighbors->rgNeighbor[i];
        ulOptions = DS_REPDEL_LOCAL_ONLY;
        ret = DsReplicaDelW(hDS,
                            pszNC,
                            pNeighbor->pszSourceDsaAddress,
                            ulOptions);
        if (ret != ERROR_SUCCESS) {
            PrintFuncFailed(L"DsReplicaDel LOCAL_ONLY", ret);
            goto error;
        }
        PrintMsg(REPADMIN_DEL_DELETED_REPL_LINK,
                 pNeighbor->pszSourceDsaAddress, pszDsaDest);
    }

 error:

    return ret;
}


int
TeardownPartition(
    HANDLE hDS,
    LPWSTR pszDsaDest,
    LPWSTR pszNC
    )
/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG   ret = 0;
    ULONG ulOptions = 0;
    DWORD i;

    ulOptions = DS_REPDEL_NO_SOURCE | DS_REPDEL_REF_OK;
    while (1) {
        PrintMsg( REPADMIN_REBUILD_TEARDOWN_IN_PROGRESS, pszNC );
        // Request a synchronous tree delete
        ret = DsReplicaDelW(hDS,
                            pszNC,
                            NULL,
                            ulOptions);
        if (ret == ERROR_DS_DRA_PREEMPTED) {
            PrintMsg( REPADMIN_TEARDOWN_PREEMPTED,
                      pszNC );
        } else {
            break;
        }
    }
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaDel NO_SOURCE", ret);
        goto error;
    }
    PrintMsg(REPADMIN_DEL_DELETED_REPL_LINK,
             NULL, pszDsaDest);

 error:

    return ret;
}


int
AddSyncPartition(
    HANDLE hDS,
    LPWSTR pszDsaDest,
    LPWSTR pszNC,
    LPWSTR pszDsaSrc,
    BOOL fApplication
    )
/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG   ret = 0;
    ULONG ulOptions = 0;
    DWORD i;
    UCHAR buffer[sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES];
    PSCHEDULE pSchedule = (PSCHEDULE) &buffer;
    UUID uuidDsaSrc;

    // Was UUID specified, or other convertible name, use "." to not specify.
    ret = ResolveDcNameToDsaGuid(NULL, pszDsaSrc, &uuidDsaSrc);
    if (ret != ERROR_SUCCESS) {
        xListClearErrors();
        PrintFuncFailed(L"ResolveDcNameToDsaGuid", ret);
        return ret;
    }

    pSchedule->Size = sizeof(SCHEDULE) + SCHEDULE_DATA_ENTRIES;
    pSchedule->Bandwidth = 0;
    pSchedule->NumberOfSchedules = 1;
    pSchedule->Schedules[0].Type = SCHEDULE_INTERVAL;
    pSchedule->Schedules[0].Offset = sizeof( SCHEDULE );

    memset( buffer + sizeof(SCHEDULE), 0x0f, SCHEDULE_DATA_ENTRIES );

    ulOptions =
        (fApplication ? DS_REPADD_WRITEABLE : 0) |
        DS_REPADD_INITIAL |
        DS_REPADD_PERIODIC ;

    // Future. It might be interesting to spawn this add off in another thread, then
    // poll the progress of the newly added reps-from in this thread.

    PrintMsg( REPADMIN_REBUILD_FULL_SYNC_IN_PROGRESS, pszNC );
    ret = DsReplicaAddW(hDS,
                        pszNC,
                        NULL, // DSADN
                        NULL, // TransportDN,
                        pszDsaSrc,
                        pSchedule,
                        ulOptions);

    if (ret == ERROR_SUCCESS) {
        PrintMsg(REPADMIN_ADD_ONE_WAY_REPL_ESTABLISHED,
                 pszDsaSrc, pszDsaDest);
    } else if (ret == ERROR_DS_DRA_PREEMPTED) {

        ulOptions = (fApplication ? DS_REPSYNC_WRITEABLE : 0);
        while (1) {
            PrintMsg( REPADMIN_REBUILD_ADD_PREEMPTED, pszNC, pszDsaSrc );

            ret = DsReplicaSyncW(hDS, pszNC, &uuidDsaSrc, ulOptions);
            if (ret == ERROR_SUCCESS) {
                PrintMsg(REPADMIN_SYNC_SYNC_SUCCESS,
                       pszDsaSrc,
                       pszDsaDest);
                break;
            } else if (ret == ERROR_DS_DRA_PREEMPTED) {
                PrintMsg( REPADMIN_REBUILD_ADD_PREEMPTED, pszNC, pszDsaSrc );
            } else if (ret != ERROR_SUCCESS) {
                PrintFuncFailed(L"DsReplicaSync", ret);
                goto error;
            }
        }

    } else {
        PrintFuncFailed(L"DsReplicaAdd", ret);
        goto error;
    }

 error:

    return ret;
}

int RehostPartition(int argc, LPWSTR argv[])
{
    int lderr;
    ULONG   ret = 0;
    int         ldStatus;
    int     iArg;
    LPWSTR pszNC;
    LPWSTR pszDsaDest;
    LPWSTR pszDsaSrc;
    LDAP *      hld;
    HANDLE                hDS = NULL;
    DS_REPL_NEIGHBORSW *  pNeighbors = NULL;
    DS_REPL_NEIGHBORW *   pNeighbor;
    SHOW_NEIGHBOR_STATE ShowState = { 0 };
    ULONG ulOptions = 0, ulRestoreOptions;
    DWORD i;
    BOOL fApplication = FALSE;
    LDAPMessage *   pldmRootResults = NULL;
    LDAPMessage *   pldmRootEntry;
    LPSTR           rgpszRootAttrsToRead[] = {"dsServiceName", NULL};
    LPWSTR *        ppszServerNames;
    LPWSTR          pszDestDsaDn = NULL;
    BOOL            fRestoreOptions = FALSE;

    ShowState.fVerbose = TRUE;

    // assume all the parameters are available and syntactically correct
    if (argc < 5) {
        PrintHelp( TRUE /* expert */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments

    pszDsaDest = argv[ 2 ];
    pszNC    = argv[ 3 ];
    pszDsaSrc = argv[ 4 ];
    for ( iArg = 5; iArg < argc; iArg++ ) {
        if (!_wcsicmp(argv[iArg], L"/application")) {
            fApplication = TRUE;
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect.

    hld = ldap_initW(pszDsaDest, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDsaDest);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Retrieve dsServiceName DN.
    ldStatus = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
                             rgpszRootAttrsToRead, 0, &pldmRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pldmRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        goto error;
    }

    pldmRootEntry = ldap_first_entry(hld, pldmRootResults);
    if (NULL != pldmRootEntry) {
        ppszServerNames = ldap_get_valuesW(hld, pldmRootEntry, L"dsServiceName");

        if (NULL != ppszServerNames) {
            Assert(1 == ldap_count_valuesW(ppszServerNames));
            pszDestDsaDn = ppszServerNames[0];
        } else {
            ret = ERROR_DS_MISSING_REQUIRED_ATT;
            PrintFuncFailed(L"ldap_search dsServiceName", ret);
            goto error;
        }
    }

    // Display this nc neighbor info
    ret = RepadminDsBind(pszDsaDest, &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDsaDest, ret);
        goto error;
    }

    // Display inbound neighbor info for this nc

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, pszNC, NULL, &pNeighbors);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        goto error;
    }

    ShowState.pszLastNC = NULL;
    for( i = 0; i < pNeighbors->cNumNeighbors; i++ ) {
        pNeighbor = &pNeighbors->rgNeighbor[i];
        ShowNeighbor(pNeighbor, IS_REPS_FROM, &ShowState);
    }

    // Validation
    for( i = 0; i < pNeighbors->cNumNeighbors; i++ ) {
        BOOL fCompat;
        pNeighbor = &pNeighbors->rgNeighbor[i];
        fCompat = (!!(pNeighbor->dwReplicaFlags & DS_REPL_NBR_WRITEABLE)) == fApplication;
        if (!fCompat) {
            PrintMsg( REPADMIN_INCOMPATIBLE_WRITEABILITY,
                    pNeighbor->pszNamingContext, pNeighbor->pszSourceDsaAddress );
            ret = ERROR_DS_DRA_BAD_NC;
            PrintFuncFailed(L"Writeability Check", ret);
            goto error;
        }
    }
    // Step 1 - Disable connection translation

    lderr = GetDsaOptions( hld, pszDestDsaDn, &ulRestoreOptions );
    if (0 != lderr) {
        REPORT_LD_STATUS(lderr);
        goto error;
    }

    ulOptions = ulRestoreOptions | NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE;
    if (ulOptions != ulRestoreOptions) {
        lderr = SetDsaOptions(hld, pszDestDsaDn, ulOptions);
        if (0 != lderr) {
            REPORT_LD_STATUS(lderr);
            goto error;
        }
        PrintMsg(REPADMIN_PRINT_NEW_NO_CR);
        PrintMsg(REPADMIN_SHOWREPS_DSA_OPTIONS, GetDsaOptionsString(ulOptions));
        fRestoreOptions = TRUE;
    }
    __try {
        // Step 2 - Delete sources for a partition

        ret = RemoveSources( hDS, pszDsaDest, pszNC, pNeighbors );
        if (ret) {
            __leave;
        }

        // Step 3 - Delete partition w/o/ sources

        ret = TeardownPartition( hDS, pszDsaDest, pszNC );
        if (ret) {
            __leave;
        }

        // Step 4 - Add link to writeable source

        ret = AddSyncPartition( hDS, pszDsaDest, pszNC, pszDsaSrc, fApplication );
        if (ret) {
            __leave;
        }

    } __finally {

        // Step 5 - Enable connection translation again

        if (fRestoreOptions) {
            lderr = SetDsaOptions(hld, pszDestDsaDn, ulRestoreOptions);
            if (0 != lderr) {
                REPORT_LD_STATUS(lderr);
            }
            PrintMsg(REPADMIN_PRINT_NEW_NO_CR);
            PrintMsg(REPADMIN_SHOWREPS_DSA_OPTIONS, GetDsaOptionsString(ulRestoreOptions));
        }
    }

    // Show updated neighbors

    if (!ret) {
        if (pNeighbors) {
            DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
        }

        ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, pszNC, NULL, &pNeighbors);
        if (ERROR_SUCCESS != ret) {
            PrintFuncFailed(L"DsReplicaGetInfo", ret);
            goto error;
        }

        ShowState.pszLastNC = NULL;
        for( i = 0; i < pNeighbors->cNumNeighbors; i++ ) {
            pNeighbor = &pNeighbors->rgNeighbor[i];
            ShowNeighbor(pNeighbor, IS_REPS_FROM, &ShowState);
        }
    }


error:

    if (hDS) {
        DsUnBind(&hDS);
    }

    if (hld) {
        ldap_unbind(hld);
    }

    if (pNeighbors) {
        DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
    }

    if (ppszServerNames) {
        ldap_value_freeW(ppszServerNames);
    }
    if (pldmRootResults) {
        ldap_msgfree(pldmRootResults);
    }

    return ret;
}

int UnhostPartition(int argc, LPWSTR argv[])
{
    ULONG   ret = 0;
    int         ldStatus;
    int     iArg;
    LPWSTR pszNC;
    LPWSTR pszDsaDest;
    LPWSTR pszDsaSrc;
    HANDLE                hDS = NULL;
    DS_REPL_NEIGHBORSW *  pNeighbors = NULL;
    DS_REPL_NEIGHBORW *   pNeighbor;
    SHOW_NEIGHBOR_STATE ShowState = { 0 };
    DWORD i;

    ShowState.fVerbose = TRUE;

    // assume all the parameters are available and syntactically correct
    if (argc < 4) {
        PrintHelp( TRUE /* expert */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments

    pszDsaDest = argv[ 2 ];
    pszNC    = argv[ 3 ];

    // Display this nc neighbor info
    ret = RepadminDsBind(pszDsaDest, &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDsaDest, ret);
        goto error;
    }

    // Display inbound neighbor info for this nc

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, pszNC, NULL, &pNeighbors);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        goto error;
    }

    ShowState.pszLastNC = NULL;
    for( i = 0; i < pNeighbors->cNumNeighbors; i++ ) {
        pNeighbor = &pNeighbors->rgNeighbor[i];
        ShowNeighbor(pNeighbor, IS_REPS_FROM, &ShowState);
    }

    ret = RemoveSources( hDS, pszDsaDest, pszNC, pNeighbors );
    if (ret) {
        goto error;
    }

    ret = TeardownPartition( hDS, pszDsaDest, pszNC );
    if (ret) {
        goto error;
    }

    // Show updated neighbors

    if (pNeighbors) {
        DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
    }

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, pszNC, NULL, &pNeighbors);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        goto error;
    }

    ShowState.pszLastNC = NULL;
    for( i = 0; i < pNeighbors->cNumNeighbors; i++ ) {
        pNeighbor = &pNeighbors->rgNeighbor[i];
        ShowNeighbor(pNeighbor, IS_REPS_FROM, &ShowState);
    }


error:

    if (hDS) {
        DsUnBind(&hDS);
    }

    if (pNeighbors) {
        DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
    }

    return ret;
}

int RemoveSourcesPartition(int argc, LPWSTR argv[])
{
    ULONG   ret = 0;
    int         ldStatus;
    int     iArg;
    LPWSTR pszNC;
    LPWSTR pszDsaDest;
    LPWSTR pszDsaSrc;
    HANDLE                hDS = NULL;
    DS_REPL_NEIGHBORSW *  pNeighbors = NULL;
    DS_REPL_NEIGHBORW *   pNeighbor;
    SHOW_NEIGHBOR_STATE ShowState = { 0 };
    DWORD i;

    ShowState.fVerbose = TRUE;

    // assume all the parameters are available and syntactically correct
    if (argc < 4) {
        PrintHelp( TRUE /* expert */ );
        return ERROR_INVALID_FUNCTION;
    }

    // Select fixed arguments

    pszDsaDest = argv[ 2 ];
    pszNC    = argv[ 3 ];

    // Display this nc neighbor info
    ret = RepadminDsBind(pszDsaDest, &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDsaDest, ret);
        goto error;
    }

    // Display inbound neighbor info for this nc

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, pszNC, NULL, &pNeighbors);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        goto error;
    }

    ShowState.pszLastNC = NULL;
    for( i = 0; i < pNeighbors->cNumNeighbors; i++ ) {
        pNeighbor = &pNeighbors->rgNeighbor[i];
        ShowNeighbor(pNeighbor, IS_REPS_FROM, &ShowState);
    }

    ret = RemoveSources( hDS, pszDsaDest, pszNC, pNeighbors );
    if (ret) {
        goto error;
    }

    // Show updated neighbors

    if (pNeighbors) {
        DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
    }

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, pszNC, NULL, &pNeighbors);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        goto error;
    }

    ShowState.pszLastNC = NULL;
    for( i = 0; i < pNeighbors->cNumNeighbors; i++ ) {
        pNeighbor = &pNeighbors->rgNeighbor[i];
        ShowNeighbor(pNeighbor, IS_REPS_FROM, &ShowState);
    }


error:

    if (hDS) {
        DsUnBind(&hDS);
    }

    if (pNeighbors) {
        DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\replctrl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    replctrl.c

Abstract:

    Callable api to the ldap replication control

    Use the dirsync replication control to get changes from a
    source and nc given a usn and utd

    This code derived from
    \nt\private\dirsync\dsserver\adread\read.cpp:
        GetMoreDataFromDS()

    The source is essentially stateless for change positioning. The caller
    (destination) records where he was last.  A change position is represented
    by a opaque data structure called a cookie.

    The is no support at the moment to explode and construct cookies, so that
    one could build an arbitrary one.  Instead, you may either duplicate a cookie
    from a reps-from, or you can start with no cookie, and iterate sequentially 
    through all the changes, and then proceeding incrementally from there.

Author:

    Will Lees (wlees) 30-Apr-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <ntldap.h>
#include <winber.h>

#include "msg.h"

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0)

// Someone should make the repadmin.h includeable here, by making the repadmin.h 
// macros work with this piece of code.  Since it's late in the product stage, I'm
// going with the low impact method of making PrintMsg() work in this file, and
// including it here.
void
PrintMsg(
    IN  DWORD   dwMessageCode,
    IN  ...
    );


#define CHK_LD_STATUS( x )                        \
{                                                 \
    if ( LDAP_SUCCESS != (x) )                    \
    {                                             \
        err = LdapMapErrorToWin32(x);             \
        PrintMsg(REPADMIN_GENERAL_LDAP_ERR,        \
                __FILE__,                         \
                __LINE__,                         \
                (x),                              \
                ldap_err2stringW( x ),            \
                err );                            \
       goto error;                                \
    }                                             \
}

#define MemAlloc( x ) malloc( x )
#define MemFree( x ) free( x )

#define BAIL() \
PrintMsg(REPADMIN_REPLCTRL_BAIL, __LINE__, __FILE__); \
goto error;
#define BAIL_ON_NULL(x) if (!(x)) { \
PrintMsg(REPADMIN_REPLCTRL_BAIL_ON_NULL, #x, __LINE__, __FILE__ ); \
err = ERROR_NOT_ENOUGH_MEMORY; \
goto error; \
}
#define BAIL_ON_FAILURE(x) if (x) { \
PrintMsg(REPADMIN_REPLCTRL_BAIL_ON_FAILURE, #x, __LINE__, __FILE__ ); \
goto error; \
}

// Read 100 objects at a time
#define DIRSYNC_SIZE_LIMIT 100
// Maximum attrs to return
// sic
#define MAX_ATTIBUTES        1048576

// The following is from  dsamain/ldap/const.hxx

//
// version of the repl dirsync control cookie structure
//
// structure for v1
//   REPL VERSION
//   vector To
//   UTD Vector
//
// structure for v2
//   REPL VERSION
//   cb UTD vector
//   vectorTo
//   invocation ID
//   UTD Vector
//
// structure for v3
//   REPL_SIGNATURE
//   REPL_VERSION
//   TIMESTAMP
//   RESERVED
//   cb UTD vector
//   vectorTo
//   invocation ID
//   UTD Vector
//

#define REPL_VERSION        3
#define REPL_SIGNATURE      'SDSM'
#define LDAP_VALID_DIRSYNC_CONTROL_FLAGS    (DRS_GET_ANC)

//
// minimum size of a repl control cookie
//

#define MIN_REPL_CONTROL_BLOB_LENGTH    (sizeof(DWORD) + sizeof(DWORD) + sizeof(FILETIME) + \
                                        sizeof(LARGE_INTEGER) + sizeof(DWORD) + \
                                        sizeof(USN_VECTOR) + sizeof(UUID))

#define ASCII_TO_INT(x)    ((x)<='9' ? (x)-'0' : ((x) <='F' ? (x)-'A' + 10 : (x)-'a' + 10))
#define ASCII_TO_INTW(x)    ((x)<=L'9' ? (x)-L'0' : ((x) <=L'F' ? (x)-L'A' + 10 : (x)-L'a' + 10))

/* External */

/* Static */

/* Forward */ /* Generated by Emacs 19.34.1 on Mon May 03 15:25:45 1999 */

DWORD
BerEncodeReplicationControl(
    DWORD dwReplFlags,
    PBYTE pCookie,
    DWORD dwLen,
    PBERVAL *ppBerVal
    );

DWORD
BerDecodeReplicationCookie(
    LDAP *m_pLdap,
    LDAPMessage *m_pSearchResult,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    BOOL *pfMoreData
    );

void
displayResults(
    LDAP *pLdap,
    LDAPMessage *pSearchResult,
    BOOL fVerbose
    );

void
dumpCookie(
    PBYTE pCookieNext,
    DWORD dwCookieLenNext
    );

DWORD
packCookie(
    USN_VECTOR *pUsnVec,
    GUID *puuidInvocationId,
    UPTODATE_VECTOR *pUtdvecV1,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    );

/* End Forward */


DWORD
DsMakeReplCookieForDestW(
    DS_REPL_NEIGHBORW *pNeighbor,
    DS_REPL_CURSORS * pCursors,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    )

/*++

Routine Description:

A Cookie represents a position in the changes stream for a particular source.

Build a cookie from neighbor and cursor information representing the
position of a destination with respect to some source

Cookie is output on success, otherwise not returned.

Arguments:

    pNeighbor - 
    pCursors - 
    ppCookieNext - 
    pdwCookieLenNext - 

Return Value:

    DWORD - 

--*/

{
    DWORD err, i;
    USN_VECTOR usnVec;
    UPTODATE_VECTOR *pUTD = NULL;
    DWORD cbUTD = 0;

    // Initialize out parameters
    *ppCookieNext = NULL;
    *pdwCookieLenNext = 0;

    // Construct USN VECTOR
    ZeroMemory( &usnVec, sizeof( USN_VECTOR ) );
    usnVec.usnHighObjUpdate = pNeighbor->usnLastObjChangeSynced;
    usnVec.usnHighPropUpdate = pNeighbor->usnAttributeFilter;

    // Construct UPTODATE VECTOR
    cbUTD = UpToDateVecV1SizeFromLen( pCursors->cNumCursors );
    pUTD = malloc( cbUTD );
    if (pUTD == NULL) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto error;
    }
    ZeroMemory( pUTD, cbUTD );
    pUTD->dwVersion = 1;
    pUTD->V1.cNumCursors = pCursors->cNumCursors;
    for( i = 0; i < pCursors->cNumCursors; i++ ) {
        pUTD->V1.rgCursors[i].uuidDsa = pCursors->rgCursor[i].uuidSourceDsaInvocationID;
        pUTD->V1.rgCursors[i].usnHighPropUpdate = pCursors->rgCursor[i].usnAttributeFilter;
    }

    // Build the initial cookie
    err = packCookie(
        &usnVec,
        &(pNeighbor->uuidSourceDsaInvocationID),
        pUTD,
        ppCookieNext,
        pdwCookieLenNext
        );
    if (err != ERROR_SUCCESS) {
        goto error;
    }

    err = ERROR_SUCCESS;
error:

    if (pUTD) {
        free(pUTD);
    }

    return err;
} /* DsMakeReplCookieForDest */


DWORD
DsFreeReplCookie(
    PBYTE pCookie
    )

/*++

Routine Description:

Free a cookie returned by DsMakeReplCookie

Arguments:

    pCookie - pointer to cookie

Return Value:

    DWORD - errors if cookie not valid

--*/

{
    DWORD dwSignature;

    if (pCookie == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Get the Signature.
    //
    dwSignature = *((PDWORD)pCookie);

    if (dwSignature != REPL_SIGNATURE) {
        return ERROR_INVALID_PARAMETER;
    }

    MemFree( pCookie );

    return ERROR_SUCCESS;
} /* DsFreeReplCookie */


DWORD
DsGetSourceChangesW(
    LDAP *m_pLdap,
    LPWSTR m_pSearchBase,
    LPWSTR pszSourceFilter,
    DWORD dwReplFlags,
    PBYTE pCookieCurr,
    DWORD dwCookieLenCurr,
    LDAPMessage **ppSearchResult,
    BOOL *pfMoreData,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    PWCHAR *ppAttListArray
    )

/*++

Return a packet of changes given position information in "current cookie".

If successful, an updated position will be returned in "next cookie".

Cookies are self describing and position independent: they may be saved to long
term storage and retrieved later as a kind of bookmark.  Cookies are specific to
the source server and naming context they were created for.

The caller is responsible for deallocating the cookies himself.  The "next
cookie" in particular must be deallocated using DsFreeReplCookie.  The current
cookie may come from a file or other long term storage.

The changes are returned as an LDAP message of entries, attributes and values.
Secret data will have been supressed.

Arguments:

The out parameters are initialized to null at the start.

    m_pLdap - ldap handle to source server.
    m_pSearchBase - The dn of the nc head to search
    pszSourceFilter - Ldap search filter, if any
    dwReplFlags - Replication flags, DRS_GET_ANC, etc
    pCookieCurr - null, or cookie previously returned by DsGetSourceChanges.
          The cookie must have come from a call with the same source server and
          same naming context.
    dwCookieLenCurr - cookie length, or zero
    ppSearchResult - pointer to pointer, to receive ldap message
    pfMoreData - Indication whether there is more data and this call should be made
        again with the updated cookie.  This is independent of whether the current
        call returned data.
    ppCookieNext - Newly allocated cookie for the updated position
    pdwCookieLenNext - Length of new cookie
    ppAttListArray - A Null terminated list of pointers to attributes to return

The out parameters are not allocated on error.

Even if there are no changes (entries in result are zero), the cookie may
have been updated with the latest positioning information.

Return Value:

    DWORD - 

--*/

{
    PBERVAL pBerVal = NULL;
    LDAPControlW replControl;
    LDAPControlW extDNControl;
    PLDAPControlW controlArray[3];
    int lderr, err;
    LDAP_TIMEVAL TimeVal;

    // Initialize out parameters
    *ppSearchResult = NULL;
    *pfMoreData = FALSE;
    *ppCookieNext = NULL;
    *pdwCookieLenNext = 0;

    //
    // The replication control has the USN that specifies where to
    // continue from. This can be treated as opaque information by us.
    //

    err = BerEncodeReplicationControl(dwReplFlags,
                                      pCookieCurr, dwCookieLenCurr,
                                      &pBerVal);
    BAIL_ON_FAILURE( err );

    replControl.ldctl_oid = LDAP_SERVER_DIRSYNC_OID_W;
    replControl.ldctl_iscritical = TRUE;
    replControl.ldctl_value.bv_len = pBerVal->bv_len;
    replControl.ldctl_value.bv_val = (PCHAR)(pBerVal->bv_val);
    extDNControl.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    extDNControl.ldctl_iscritical = TRUE;
    extDNControl.ldctl_value.bv_len = 0;
    extDNControl.ldctl_value.bv_val = NULL;

    controlArray[0] = &replControl;
    controlArray[1] = &extDNControl;
    controlArray[2] = NULL;

    //
    // Adding in timeout so that we can recover if the server do not respond
    //
    TimeVal.tv_usec = 0;
    TimeVal.tv_sec = LDAP_TIMEOUT;

//    dumpCookie( *ppCookieNext, *pdwCookieLenNext );

    lderr = ldap_search_ext_sW(m_pLdap,
                               m_pSearchBase,
                               LDAP_SCOPE_SUBTREE, // m_pSessionData->SourceScope
                               pszSourceFilter,
                               ppAttListArray,
                               0,
                               (PLDAPControlW *) &controlArray,
                               NULL,
                               &TimeVal,
                               DIRSYNC_SIZE_LIMIT,
                               ppSearchResult);

    CHK_LD_STATUS( lderr );

    if ( (*ppSearchResult) == NULL )
    {
        // Let caller know there is no search result or cookie
        err = ERROR_DS_PROTOCOL_ERROR;
        goto error;
    }

    //
    // Save the returned cookie value
    //

    err = BerDecodeReplicationCookie(
        m_pLdap,
        *ppSearchResult,
        ppCookieNext,
        pdwCookieLenNext,
        pfMoreData
        );
    BAIL_ON_FAILURE( err );

    err = ERROR_SUCCESS;

error:

    // On error, return the same cookie that came in

    // Release results on error
    if ( (err != ERROR_SUCCESS) && (*ppSearchResult) )
    {
        ldap_msgfree(*ppSearchResult);
        *ppSearchResult = NULL;
    }

    if (pBerVal)
        ber_bvfree(pBerVal);

    return err;

} /* DsGetSourceChanges */


DWORD
BerEncodeReplicationControl(
    DWORD dwReplFlags,
    PBYTE pCookie,
    DWORD dwLen,
    PBERVAL *ppBerVal
    )

/*++

Routine Description:

    This encodes the replication cookie into a BERVAL that can be put in
    an LDAP control.

Arguments:

    dwReplFlags - Replication flags
    pCookie - Pointer to replication cookie
    dwLen - Length of cookie
    ppBerVal - Pointer that received the BERVAL structure. Called needs to
               free this using ber_bvfree().

Return Value:

    S_OK on success, error code otherwise

--*/

{
    DWORD err = ERROR_INVALID_PARAMETER;
    BerElement *pBer = NULL;

    pBer = ber_alloc_t(LBER_USE_DER);
    BAIL_ON_NULL(pBer);

    //
    // flag - set to zero, so order of parent & child objects is not important
    //

    if (ber_printf(pBer, "{iio}", dwReplFlags, MAX_ATTIBUTES, pCookie, dwLen) == -1)
    {
        err = ERROR_INTERNAL_ERROR;
        PrintMsg(REPADMIN_REPLCTRL_ERROR_IN_BER_PRINTF);
        BAIL();
    }

    //
    // Pull data from the BerElement into a BERVAL struct.
    // Caller needs to free ppBerVal.
    //

    if (ber_flatten(pBer, ppBerVal) != 0)
    {
        err = ERROR_INTERNAL_ERROR;
        PrintMsg(REPADMIN_REPLCTRL_ERROR_IN_BER_FLATTEN);
        BAIL();
    }

    err = ERROR_SUCCESS;

error:
    if (pBer)
    {
        ber_free(pBer,1);
    }

    return err;

}



DWORD
BerDecodeReplicationCookie(
    LDAP *m_pLdap,
    LDAPMessage *m_pSearchResult,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext,
    BOOL *pfMoreData
    )

/*++

Routine Description:

    This saves the replication cookie that came back from the server so that
    it can be used for the next call

Arguments:

    m_pLdap - 
    m_pSearchResult - 
    ppCookieNext - 
    pdwCookieLenNext - 
    pfMoreData - 

Return Value:

    DWORD - 

--*/

{
    PLDAPControlW *ppServerControl = NULL;
    BERVAL berVal;
    DWORD err = ERROR_INVALID_PARAMETER;
    ULONG lderr;
    BerElement *pBer = NULL;
    PBERVAL pbv = NULL;
    DWORD size;
    DWORD i;

    lderr = ldap_parse_resultW(m_pLdap,
                               m_pSearchResult,
                               NULL,
                               NULL,
                               NULL,
                               NULL,
                               &ppServerControl,
                               FALSE);
    CHK_LD_STATUS( lderr );

    //
    // Find the replication control
    //

    i = 0;
    while (ppServerControl[i] &&
           wcscmp(ppServerControl[i]->ldctl_oid,LDAP_SERVER_DIRSYNC_OID_W) != 0)
    {
        i++;
    }

    if (!ppServerControl[i])
    {
        err = ERROR_NOT_FOUND;
        PrintMsg(REPADMIN_REPLCTRL_NO_REPL_SERVER_CONTROL_RET);
        BAIL();
    }

    berVal.bv_len = ppServerControl[i]->ldctl_value.bv_len;
    berVal.bv_val = ppServerControl[i]->ldctl_value.bv_val;
    pBer = ber_init(&berVal);

    ber_scanf(pBer, "{iiO}", pfMoreData, &size, &pbv);

    *pdwCookieLenNext = pbv->bv_len;
    *ppCookieNext = (PBYTE)MemAlloc(pbv->bv_len);
    BAIL_ON_NULL(*ppCookieNext);

    memcpy(*ppCookieNext, pbv->bv_val, *pdwCookieLenNext);

    err = ERROR_SUCCESS;

error:
    if (pbv)
        ber_bvfree(pbv);
    if (pBer)
        ber_free(pBer, 1);
    if (ppServerControl)
        ldap_controls_freeW(ppServerControl);

    return err;
} /* BerDecodeReplicationCookie */


#if DBG


void
dumpCookie(
    PBYTE pCookieNext,
    DWORD dwCookieLenNext
    )

/*++

Routine Description:

    //
    // If the cookie is available, this debug code will dump out the cookie
    // value to the debugger
    //

Arguments:

    None

Return Value:

    None

--*/

{
    PUCHAR p;
    DWORD dwVersion, dwSignature;
    DWORD cbVecSize;
    USN_VECTOR usnVec;

    if (!pCookieNext)  {
        PrintMsg(REPADMIN_GETCHANGES_COOKIE_NULL);
    }

    p = pCookieNext;

    //
    // Get the Signature.
    //
    dwSignature = *((PDWORD)p);
    p += sizeof(DWORD);

    //
    // Get the Version.
    //
    dwVersion = *((PDWORD)p);
    p += sizeof(DWORD);

    // Skip filetime
    p += sizeof(FILETIME);

    // Skip reserved
    p += sizeof(LARGE_INTEGER);

    //
    // Get the size of the up to date vector
    //
    cbVecSize = *((PDWORD)p);
    p += sizeof(DWORD);

    // Usnvec
    memcpy(&usnVec,p,sizeof(USN_VECTOR));

    // todo: invocation uuid
    // todo: uptodatevec

    PrintMsg(REPADMIN_GETCHANGES_COOKIE_DATA,
           dwVersion, usnVec.usnHighObjUpdate);
    PrintMsg(REPADMIN_GETCHANGES_COOKIE_DATA_HACK2,
             usnVec.usnHighPropUpdate);
}
#endif


DWORD
packCookie(
    USN_VECTOR *pUsnVec,
    GUID *puuidInvocationId,
    UPTODATE_VECTOR *pUtdvecV1,
    PBYTE *ppCookieNext,
    DWORD *pdwCookieLenNext
    )

/*++

Routine Description:

The following logic is taken from
    dsamain\ldap\ldapconv.cxx:LDAP_PackReplControl

Arguments:

    pUsnVec - 
    puuidInvocationId - 
    pUtdvecV1 - 
    ppCookieNext - 
    pdwCookieLenNext - 

Return Value:

    DWORD - 

--*/

{
    DWORD cbCookie = MIN_REPL_CONTROL_BLOB_LENGTH;
    DWORD cbVecSize = 0;
    PBYTE p, pbCookie = NULL;

    // todo: deal with not having a utd

    Assert( pUtdvecV1 != NULL );
    Assert(IS_VALID_UPTODATE_VECTOR(pUtdvecV1));

    if (pUtdvecV1->V1.cNumCursors > 0) {      
        cbVecSize = UpToDateVecV1Size(pUtdvecV1);
        cbCookie += cbVecSize;
    }

    pbCookie = MemAlloc( cbCookie );
    if (pbCookie == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( pbCookie, cbCookie );

    p = pbCookie;

    //
    // Pack the signature
    //

    *((PDWORD)p) = REPL_SIGNATURE;
    p += sizeof(DWORD);

    //
    // Pack the Version. 
    //

    *((PDWORD)p) = REPL_VERSION;    
    p += sizeof(DWORD);

    //
    // Set the current time
    //

    GetSystemTimeAsFileTime((PFILETIME)p);
    p += sizeof(FILETIME);

    //
    // reserved for now
    //

    p += sizeof(LARGE_INTEGER);

    //
    // Pack the size of the up to date vector
    //

    *((PDWORD)p) = cbVecSize;
    p += sizeof(DWORD);

    //
    // Copy the usnvecTo. 
    //

    CopyMemory( p,pUsnVec, sizeof(USN_VECTOR));
    p += sizeof(USN_VECTOR);

    //
    // Copy the invocation UUID
    //

    CopyMemory( p, puuidInvocationId, sizeof(UUID));

    p += sizeof(UUID);

    //
    // Copy the UPTODATE_VECTOR if it exists
    //

    if( cbVecSize > 0 ) {
        CopyMemory( p,
                    pUtdvecV1, 
                    cbVecSize);
    }

    *pdwCookieLenNext = cbCookie;
    *ppCookieNext = pbCookie;

    return ERROR_SUCCESS;
} /* packCookie */

/* end dirsync.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\repinfo.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repinfo.c - commands that get information

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

    10/12/2000    Greg Johnson (gregjohn)

        Added support for /latency in ShowVector to order the UTD Vector by repl latencies.
   

--*/

#include <NTDSpch.h>
#pragma hdrstop

#define INCLUDE_CALL_TABLES 1
#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "ReplRpcSpoof.hxx"
#include "repadmin.h"
#include "ndnc.h"
#define DS_CON_LIB_CRT_VERSION 1
#include "dsconlib.h"

#define STRSAFE_NO_DEPRECATE 1
#include <strsafe.h>

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0 | (0xFFFF & y))

// Forwared declarations
DWORD
ReplSummaryAccumulate(
    DS_REPL_NEIGHBORW * pNeighbor,
    ULONG               fRepsFrom,
    void *              pvState
    );

int Queue(int argc, LPWSTR argv[])
{
    ULONG                   ret = 0;
    ULONG                   secondary;
    int                     iArg;
    LPWSTR                  pszOnDRA = NULL;
    HANDLE                  hDS;
    DS_REPL_PENDING_OPSW *  pPendingOps;
    DS_REPL_OPW *           pOp;
    CHAR                    szTime[SZDSTIME_LEN];
    DSTIME                  dsTime;
    DWORD                   i;
    LPSTR                   pszOpType;
    OPTION_TRANSLATION *    pOptionXlat;

    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszOnDRA) {
            pszOnDRA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszOnDRA) {
        pszOnDRA = L"localhost";
    }

    ret = RepadminDsBind(pszOnDRA, &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_PENDING_OPS, NULL, NULL,
                            &pPendingOps);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        // keep going
    }
    else {
        PrintMsg(REPADMIN_QUEUE_CONTAINS, pPendingOps->cNumPendingOps);
        if (pPendingOps->cNumPendingOps) {
            if (memcmp( &pPendingOps->ftimeCurrentOpStarted, &ftimeZero,
                    sizeof( FILETIME ) ) == 0) {
                PrintMsg(REPADMIN_QUEUE_MAIL_TH_EXEC);
                PrintMsg(REPADMIN_PRINT_CR);
            } else {
                DSTIME dsTimeNow = GetSecondsSince1601();
                int dsElapsed;

                FileTimeToDSTime(pPendingOps->ftimeCurrentOpStarted, &dsTime);

                PrintMsg(REPADMIN_QUEUE_CUR_TASK_EXEC,
                       DSTimeToDisplayString(dsTime, szTime));

                dsElapsed = (int) (dsTimeNow - dsTime);
                PrintMsg(REPADMIN_QUEUE_CUR_TASK_EXEC_TIME, 
                        dsElapsed / 60, dsElapsed % 60 );
            }
        }

        pOp = &pPendingOps->rgPendingOp[0];
        for (i = 0; i < pPendingOps->cNumPendingOps; i++, pOp++) {
            FileTimeToDSTime(pOp->ftimeEnqueued, &dsTime);

            PrintMsg(REPADMIN_QUEUE_ENQUEUED_DATA_ITEM_HDR,
                   pOp->ulSerialNumber,
                   DSTimeToDisplayString(dsTime, szTime),
                   pOp->ulPriority);

            switch (pOp->OpType) {
            case DS_REPL_OP_TYPE_SYNC:
                pszOpType = "SYNC FROM SOURCE";
                pOptionXlat = RepSyncOptionToDra;
                break;

            case DS_REPL_OP_TYPE_ADD:
                pszOpType = "ADD NEW SOURCE";
                pOptionXlat = RepAddOptionToDra;
                break;

            case DS_REPL_OP_TYPE_DELETE:
                pszOpType = "DELETE SOURCE";
                pOptionXlat = RepDelOptionToDra;
                break;

            case DS_REPL_OP_TYPE_MODIFY:
                pszOpType = "MODIFY SOURCE";
                pOptionXlat = RepModOptionToDra;
                break;

            case DS_REPL_OP_TYPE_UPDATE_REFS:
                pszOpType = "UPDATE CHANGE NOTIFICATION";
                pOptionXlat = UpdRefOptionToDra;
                break;

            default:
                pszOpType = "UNKNOWN";
                pOptionXlat = NULL;
                break;
            }

            PrintMsg(REPADMIN_QUEUE_ENQUEUED_DATA_ITEM_DATA,
                     pszOpType,
                     pOp->pszNamingContext,
                     (pOp->pszDsaDN
                         ? GetNtdsDsaDisplayName(pOp->pszDsaDN)
                         : L"(null)"),
                     GetStringizedGuid(&pOp->uuidDsaObjGuid),
                     (pOp->pszDsaAddress
                         ? pOp->pszDsaAddress
                         : L"(null)") );
            if (pOptionXlat) {
                PrintTabMsg(2, REPADMIN_PRINT_STR,
                            GetOptionsString(pOptionXlat, pOp->ulOptions));
            }
        }
    }

    DsReplicaFreeInfo(DS_REPL_INFO_PENDING_OPS, pPendingOps);

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    return ret;
}


void ShowFailures(
    IN  DS_REPL_KCC_DSA_FAILURESW * pFailures
    )
{
    DWORD i;

    if (0 == pFailures->cNumEntries) {
        PrintMsg(REPADMIN_FAILCACHE_NONE);
        return;
    }

    for (i = 0; i < pFailures->cNumEntries; i++) {
        DS_REPL_KCC_DSA_FAILUREW * pFailure = &pFailures->rgDsaFailure[i];

        PrintTabMsg(2, REPADMIN_PRINT_STR, 
                    GetNtdsDsaDisplayName(pFailure->pszDsaDN));
        PrintTabMsg(4, REPADMIN_PRINT_DSA_OBJ_GUID,
                    GetStringizedGuid(&pFailure->uuidDsaObjGuid));

        if (0 == pFailure->cNumFailures) {
            PrintTabMsg(4, REPADMIN_PRINT_NO_FAILURES);
        }
        else {
            DSTIME dsTime;
            CHAR   szTime[SZDSTIME_LEN];

            FileTimeToDSTime(pFailure->ftimeFirstFailure, &dsTime);

            PrintMsg(REPADMIN_FAILCACHE_FAILURES_LINE,
                     pFailure->cNumFailures,
                     DSTimeToDisplayString(dsTime, szTime));

            if (0 != pFailure->dwLastResult) {
                PrintTabMsg(4, REPADMIN_FAILCACHE_LAST_ERR_LINE);
                PrintTabErrEnd(6, pFailure->dwLastResult);
            }
        }
    }
}

int FailCache(int argc, LPWSTR argv[])
{
    ULONG   ret = 0;
    ULONG   secondary;
    int     iArg;
    LPWSTR  pszOnDRA = NULL;
    HANDLE  hDS;
    DS_REPL_KCC_DSA_FAILURESW * pFailures;
    DWORD   dwVersion;
    CHAR    szTime[SZDSTIME_LEN];

    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszOnDRA) {
            pszOnDRA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszOnDRA) {
        pszOnDRA = L"localhost";
    }

    ret = RepadminDsBind(pszOnDRA, &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszOnDRA, ret);
        return ret;
    }

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,
                            NULL, NULL, &pFailures);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        // keep going
    }
    else {
        PrintMsg(REPADMIN_FAILCACHE_CONN_HDR);
        ShowFailures(pFailures);
        DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pFailures);

        ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                                NULL, NULL, &pFailures);
        if (ret != ERROR_SUCCESS) {
            PrintFuncFailed(L"DsReplicaGetInfo", ret);
            // keep going
        }
        else {
            PrintMsg(REPADMIN_PRINT_CR);
            PrintMsg(REPADMIN_FAILCACHE_LINK_HDR);
            ShowFailures(pFailures);
            DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pFailures);
        }
    }

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

    return ret;
}

int ShowReplEx(
    WCHAR *     pszDSA,
    WCHAR *     pszNC,
    GUID *      puuid,
    BOOL        fShowRepsTo,
    BOOL        fShowConn,
    SHOW_NEIGHBOR_STATE * pShowState
    );

typedef ULONG (NEIGHBOR_PROCESSOR)(DS_REPL_NEIGHBORW *, ULONG , void *);

DWORD            
IterateNeighbors(
    HANDLE      hDS,
    WCHAR *     szNc, 
    GUID *      pDsaGuid,
    ULONG       eRepsType, // IS_REPS_FROM == 1 || IS_REPS_TO = 0
    NEIGHBOR_PROCESSOR * pfNeighborProcessor,
//    DWORD (*pfNeighborProcessor)(DS_REPL_NEIGHBORW * pNeighbor, ULONG eRepsType, void * pvState),
    void *      pvState
    );

int ShowReps(int argc, LPWSTR argv[])
/*++

Routine Description:

    This is the deprecated version of the /ShowRepl command.

Arguments:

    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    error from the repadmin cmd.

--*/
{
    int                   ret = 0;
    LPWSTR                pszDSA = NULL;
    int                   iArg;
    LPWSTR                pszNC = NULL;
    BOOL                  fShowRepsTo = FALSE;
    BOOL                  fShowConn = FALSE;
    UUID *                puuid = NULL;
    UUID                  uuid;
    ULONG                 ulOptions;
    static WCHAR          wszSiteSettingsRdn[] = L"CN=NTDS Site Settings,";
    WCHAR *               pszSiteRdn = NULL;
    WCHAR *               pszTempSiteRdn = NULL;
    WCHAR *               pszTempServerRdn = NULL;
    SHOW_NEIGHBOR_STATE   ShowState = { 0 };

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/v")
            || !_wcsicmp(argv[ iArg ], L"/verbose")) {
            ShowState.fVerbose = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/to")
            || !_wcsicmp(argv[ iArg ], L"/repsto")) {
            fShowRepsTo = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/conn")) {
            fShowConn = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/all")) {
            fShowRepsTo = TRUE;
            fShowConn = TRUE;
        }
        else if ((NULL == pszNC) && (NULL != wcschr(argv[iArg], L','))) {
            pszNC = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else if ((NULL == puuid)
                 && (0 == UuidFromStringW(argv[iArg], &uuid))) {
            puuid = &uuid;
        }
        else {
            PrintMsgCsvErr(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    ret = ShowReplEx(pszDSA, pszNC, puuid, fShowRepsTo, fShowConn, &ShowState);

    return(ret);
}

int ShowRepl(int argc, LPWSTR argv[]){ // new /showreps
    int                   ret = 0;
    LPWSTR                pszDSA = NULL;
    int                   iArg;
    LPWSTR                pszNC = NULL;
    BOOL                  fShowRepsTo = FALSE;
    BOOL                  fShowConn = FALSE;
    UUID *                puuid = NULL;
    UUID                  uuid;
    SHOW_NEIGHBOR_STATE   ShowState = { 0 };

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/v")
            || !_wcsicmp(argv[ iArg ], L"/verbose")) {
            ShowState.fVerbose = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/to")
            || !_wcsicmp(argv[ iArg ], L"/repsto")) {
            fShowRepsTo = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/conn")) {
            fShowConn = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/all")) {
            fShowRepsTo = TRUE;
            fShowConn = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/intersite")
                 || !_wcsicmp(argv[ iArg ], L"/i")) {
            ShowState.fIntersiteOnly = TRUE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/errorsonly")
                 || !_wcsicmp(argv[ iArg ], L"/e")) {
            ShowState.fErrorsOnly = TRUE;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else if (NULL == pszNC) {
            pszNC = argv[iArg];
        }
        else if ((NULL == puuid)
                 && (0 == UuidFromStringW(argv[iArg], &uuid))) {
            puuid = &uuid;
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszDSA) {
        Assert(!"Should never fire anymore");
        pszDSA = L"localhost";
    }
    
    ret = ShowReplEx(pszDSA, pszNC, puuid, fShowRepsTo, fShowConn, &ShowState);

    return(ret);
}

DWORD
DisplayDsaInfo(
    LDAP *      hld,
    WCHAR **    pszDsaDn,
    WCHAR **    pszSiteRdn
    )
{
    int                   ret = 0;
    LPWSTR                rgpszServerAttrsToRead[] = {L"options", L"objectGuid", L"invocationId", NULL};
    LPWSTR                rgpszRootAttrsToRead[] = {L"dsServiceName",L"isGlobalCatalogReady", NULL};
    LPWSTR *              ppszServerNames = NULL;
    LDAPMessage *         pldmRootResults;
    LDAPMessage *         pldmRootEntry;
    LDAPMessage *         pldmServerResults;
    LDAPMessage *         pldmServerEntry;
    LPWSTR *              ppszOptions = NULL;
    LPWSTR                pszSiteName = NULL;
    LPWSTR                pszSiteSpecDN;
    LPWSTR *              ppszIsGlobalCatalogReady;
    int                   nOptions = 0;
    struct berval **      ppbvGuid;
    static WCHAR          wszSiteSettingsRdn[] = L"CN=NTDS Site Settings,";
    WCHAR *               pszTempSiteRdn = NULL;
    WCHAR *               pszTempServerRdn = NULL;

    if (pszSiteRdn) {
        *pszSiteRdn = NULL;
    }
    if (pszDsaDn) {
        *pszDsaDn = NULL;
    }

    __try{

        Assert(!bCsvMode());

        //
        // Display DSA info.
        //

        ret = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)", NULL,
                             0, &pldmRootResults);
        CHK_LD_STATUS(ret);

        pldmRootEntry = ldap_first_entry(hld, pldmRootResults);
        Assert(NULL != pldmRootEntry);

        ppszServerNames = ldap_get_valuesW(hld, pldmRootEntry, L"dsServiceName");
        Assert(NULL != ppszServerNames);
        if (ppszServerNames == NULL) {
            return(ERROR_INVALID_PARAMETER);
        }

        // Display ntdsDsa.
        *pszDsaDn = LocalAlloc(LPTR, wcslencb(ppszServerNames[0]));
        CHK_ALLOC(*pszDsaDn);
        wcscpy(*pszDsaDn, ppszServerNames[ 0 ]);
        PrintMsg(REPADMIN_PRINT_STR, GetNtdsDsaDisplayName(*pszDsaDn));

        GetNtdsDsaSiteServerPair(*pszDsaDn, &pszTempSiteRdn, &pszTempServerRdn);

        if (pszSiteRdn) {
            *pszSiteRdn = LocalAlloc(LPTR, wcslencb(pszTempSiteRdn));
            CHK_ALLOC(*pszSiteRdn);
            wcscpy(*pszSiteRdn, pszTempSiteRdn);
        }

        ret = ldap_search_sW(hld, *pszDsaDn, LDAP_SCOPE_BASE, L"(objectClass=*)",
                             rgpszServerAttrsToRead, 0, &pldmServerResults);
        CHK_LD_STATUS(ret);

        pldmServerEntry = ldap_first_entry(hld, pldmServerResults);
        Assert(NULL != pldmServerEntry);

        // Display options.
        ppszOptions = ldap_get_valuesW(hld, pldmServerEntry, L"options");
        if (NULL == ppszOptions) {
            nOptions = 0;
        } else {
            nOptions = wcstol(ppszOptions[0], NULL, 10);
        }
            
        PrintMsg(REPADMIN_SHOWREPS_DSA_OPTIONS, GetDsaOptionsString(nOptions));

        //check if nOptions has is_gc and if yes, check if dsa is advertising as gc
        //if is_gc is set and not advertising as gc, then display warning message
        if (nOptions & NTDSDSA_OPT_IS_GC) {
            ppszIsGlobalCatalogReady = ldap_get_valuesW(hld, pldmRootEntry, L"isGlobalCatalogReady");
            Assert(NULL != ppszIsGlobalCatalogReady);
            if (!_wcsicmp(*ppszIsGlobalCatalogReady,L"FALSE")) {
                    
                PrintMsg(REPADMIN_SHOWREPS_WARN_GC_NOT_ADVERTISING);
            }
            if (ppszIsGlobalCatalogReady) {
                ldap_value_freeW(ppszIsGlobalCatalogReady);
            }
        }
        //get site options
        ret = WrappedTrimDSNameBy(ppszServerNames[0],3,&pszSiteSpecDN); 
        Assert(!ret);

        pszSiteName = malloc((wcslen(pszSiteSpecDN) + 1)*sizeof(WCHAR) + sizeof(wszSiteSettingsRdn));
        CHK_ALLOC(pszSiteName);
        wcscpy(pszSiteName,wszSiteSettingsRdn);
        wcscat(pszSiteName,pszSiteSpecDN);

        ret = GetSiteOptions(hld, pszSiteName, &nOptions);
        if (!ret) {
            PrintMsg(REPADMIN_SHOWREPS_SITE_OPTIONS, GetSiteOptionsString(nOptions));  
        }

        // Display ntdsDsa objectGuid.
        ppbvGuid = ldap_get_values_len(hld, pldmServerEntry, "objectGuid");
        Assert(NULL != ppbvGuid);
        if (NULL != ppbvGuid) {
            PrintMsg(REPADMIN_PRINT_DSA_OBJ_GUID, 
                     GetStringizedGuid((GUID *) ppbvGuid[0]->bv_val));
        }
        ldap_value_free_len(ppbvGuid);

        // Display ntdsDsa invocationID.
        ppbvGuid = ldap_get_values_len(hld, pldmServerEntry, "invocationID");
        Assert(NULL != ppbvGuid);
        if (NULL != ppbvGuid) {
            PrintTabMsg(0, REPADMIN_PRINT_INVOCATION_ID, 
                        GetStringizedGuid((GUID *) ppbvGuid[0]->bv_val));
        }
        ldap_value_free_len(ppbvGuid);

        PrintMsg(REPADMIN_PRINT_CR);

    } __finally {

        if (pldmServerResults) {
            ldap_msgfree(pldmServerResults);
        }
        if (pldmRootResults) {
            ldap_msgfree(pldmRootResults);
        }
        if (ppszServerNames) { ldap_value_freeW(ppszServerNames); }
        if (ppszOptions) { ldap_value_freeW(ppszOptions); }
        if (pszSiteName) { free(pszSiteName); }

    }

    return(ERROR_SUCCESS);
}

int ShowReplEx(
    WCHAR *     pszDSA,
    WCHAR *     pszNC,
    GUID *      puuid,
    BOOL        fShowRepsTo,
    BOOL        fShowConn,
    SHOW_NEIGHBOR_STATE * pShowState
    )
{
    HANDLE                hDS = NULL;
    LDAP *                hld = NULL;
    int                   ret = 0;
    LPWSTR                szDsaDn = NULL; 
    WCHAR *               pszTempSiteRdn = NULL;
    WCHAR *               pszTempServerRdn = NULL;

    if (pszDSA == NULL || pShowState == NULL) {
        Assert(!"Hmm, this should not happen.");
        return(ERROR_INVALID_PARAMETER);
    }

    __try {

        //
        // Get the LDAP binding ...
        //
        if (bCsvMode()) {
            // RepadminLdapBind() prints errors, and if it does, it'll will
            // print out a bogus DC, so temporarily set a nice DC argument
            // for column 2.
            // Note: We're temporarily using pszTempServerRdn.
            pszTempServerRdn = wcschr(pszDSA, L'.');
            if (pszTempServerRdn) {
                *pszTempServerRdn = L'\0';
            }
            CsvSetParams(eCSV_SHOWREPL_CMD, L"-", pszDSA);
            if (pszTempServerRdn) {
                // Replace period
                *pszTempServerRdn = L'.';
                pszTempServerRdn = NULL;
            }
        }

        ret = RepadminLdapBind(pszDSA, &hld);
        if (ret) {
            __leave; // errors already printed.
        }

        //
        // Collect or print basic header information 
        //      we need szDsaDn & ShowState.pszSiteRdn
        //
        if (bCsvMode()) {
            ret = GetRootAttr(hld, L"dsServiceName", &szDsaDn);
            if (ret) {
                PrintFuncFailed(L"GetRootAttr", ret);
                __leave;
            }

            GetNtdsDsaSiteServerPair(szDsaDn, &pszTempSiteRdn, &pszTempServerRdn);
            Assert(pszTempSiteRdn && pszTempServerRdn);

            // Set CSV Params properly now that we've got the real site and server RDNs
            CsvSetParams(eCSV_SHOWREPL_CMD, pszTempSiteRdn, pszTempServerRdn);

            pShowState->pszSiteRdn = LocalAlloc(LPTR, wcslencb(pszTempSiteRdn));
            CHK_ALLOC(pShowState->pszSiteRdn);
            wcscpy(pShowState->pszSiteRdn, pszTempSiteRdn);

        } else {
            ret = DisplayDsaInfo(hld, &szDsaDn, &(pShowState->pszSiteRdn));
            if (ret) {
                __leave;
            }
        }
        Assert(szDsaDn && pShowState->pszSiteRdn);

        //
        // Get DS binding ...
        //
        ret = RepadminDsBind(pszDSA, &hDS);
        if (ERROR_SUCCESS != ret) {
            PrintBindFailed(pszDSA, ret);
            return ret;
        }
        
        //
        // Display replication state associated with inbound neighbors.
        //
        pShowState->fNotFirst = FALSE;
        pShowState->pszLastNC = NULL;
        IterateNeighbors(hDS, pszNC, puuid, IS_REPS_FROM, ShowNeighbor, pShowState);

        if (!bCsvMode()) {

            if (fShowRepsTo){

                //
                // Display replication state associated with outbound neighbors.
                //
                pShowState->fNotFirst = FALSE;
                pShowState->pszLastNC = NULL;
                IterateNeighbors(hDS, pszNC, puuid, IS_REPS_TO, ShowNeighbor, pShowState);

            }

            //
            // Look for missing neighbors
            //
            if (fShowConn) {
                PrintMsg(REPADMIN_PRINT_CR);
                PrintMsg(REPADMIN_SHOWREPS_KCC_CONN_OBJS_HDR);
            }
            ret = FindConnections( hld, szDsaDn, NULL, fShowConn, pShowState->fVerbose, FALSE );

        }

    } __finally {

        //
        // Clean up.
        //
        if (pShowState->pszSiteRdn) { LocalFree(pShowState->pszSiteRdn); }
        if (szDsaDn) { LocalFree(szDsaDn); }
        ldap_unbind(hld);
        DsUnBind(&hDS);

    }

    return ret;
}


DWORD            
IterateNeighbors(
    HANDLE      hDS,
    WCHAR *     szNc, 
    GUID *      pDsaGuid,
    ULONG       eRepsType,
    NEIGHBOR_PROCESSOR * pfNeighborProcessor,
//    DWORD (*pfNeighborProcessor)(DS_REPL_NEIGHBORW * pNeighbor, ULONG eRepsType, void * pvState ),
    void *      pvState
    )
/*++

Routine Description:

    This routine takes a processing function and retrieves the reps-from
    or reps-to information for a given DC (hDS) and runs each neighbor
    structure through the processing function. 

Arguments:

    hDS - Connded ntdsapi bind of DC to get neighbor info from
    szNc [OPTIONAL] - NC to specify to the DsReplicaGetInfoW() call
    pDsaGuid [OPTIONAL] - GUID ptr to specify to the DsReplicaGetInfoW() call
    eRepsType - Must be IS_REPS_FROM or IS_REPS_TO
    pfNeighborProcessor - Function to process each neighbor entry
    pvState - private state to pass to the pfNeighborProcessor

Return Value:

    An error means that there was an error returned by the
    DsReplicaGetInfoW() call or the pfNeighborProcessor.
    
NOTES:
   
    If the processor function returns an error, the IterateNeighbors
    function will abort processing of this neighbor structure and
    just return.

--*/
{
    DS_REPL_NEIGHBORSW *    pNeighbors = NULL;
    DS_REPL_NEIGHBORW *     pNeighbor;
    ULONG                   i;
    DWORD                   ret = ERROR_SUCCESS;
    
    __try {

        //
        // First get the neighbor info.
        //
        ret = DsReplicaGetInfoW(hDS, 
                                (eRepsType == IS_REPS_FROM) ? 
                                     DS_REPL_INFO_NEIGHBORS :
                                     DS_REPL_INFO_REPSTO, 
                                szNc, 
                                pDsaGuid,
                                &pNeighbors);
        if (ERROR_SUCCESS != ret) {
            if (pfNeighborProcessor != ReplSummaryAccumulate) {
                PrintFuncFailed(L"DsReplicaGetInfo", ret);
            }
            __leave;
        }

        for (i = 0; i < pNeighbors->cNumNeighbors; i++) {
            pNeighbor = &pNeighbors->rgNeighbor[i];

            ret = (*pfNeighborProcessor)(pNeighbor, eRepsType, pvState);
            if (ret) {
                // A non-successful return value from the processor means 
                // abort neighbor processing.
                __leave;
            }
        }

    } __finally {

        if (pNeighbors) {
            DsReplicaFreeInfo((eRepsType == IS_REPS_FROM) ? 
                                     DS_REPL_INFO_NEIGHBORS :
                                     DS_REPL_INFO_REPSTO,   
                              pNeighbors);
        }

    }

    return(ret);

}


DWORD
ShowNeighbor(
    DS_REPL_NEIGHBORW * pNeighbor,
    ULONG               fRepsFrom,
    void *              pvState
    )
/*++

Routine Description:

    Passed to IterateNeighbors() for printing out the neighbor information passed
    in.  Note that 

Arguments:

    pNeighbor - The neighbor structure to display.
    fRepsFrom - TRUE if neighbor is a reps-from, FALSE for reps-to
    pvState   - Private state, so we know when we've printed the first neighbor
        and so we know when we've switched NCs (pszLastNC).  
        
        Note that for instance the pszLastNC element of pvState is only good for
        a given IterateNeighbors() call, and so can be used between calls to
        ShowNeighbor() but shouldn't be used by say ShowReplEx() after 
        IterateNeighbors() finishes.

Return Value:

    Win32 Error.

--*/
{
    const UUID uuidNull = {0};
    DWORD   status;
    LPSTR   pszTransportName = "RPC";
    CHAR    szTime[ SZDSTIME_LEN ];
    DSTIME  dsTime;
    SHOW_NEIGHBOR_STATE * pShowState = (SHOW_NEIGHBOR_STATE *) pvState;
    WCHAR * pszTempSiteRdn = NULL;
    WCHAR * pszTempServerRdn = NULL;

    //
    // If this is the first time we've hit this function print the header.
    //
    if (!pShowState->fNotFirst) {
        if (!bCsvMode()) {
            if (fRepsFrom) {
                PrintMsg(REPADMIN_SHOWREPS_IN_NEIGHBORS_HDR);
            } else {
                PrintMsg(REPADMIN_PRINT_CR);
                PrintMsg(REPADMIN_SHOWREPS_OUT_NEIGHBORS_HDR);
            }
        }
        // This causes us not to print this again, until someone resets fNotFirst.
        pShowState->fNotFirst = TRUE; 
    }

    if (fRepsFrom) {

        //
        // Under certain conditions we just decide not to print this Neighbor.
        //

        // Errors only mode.
        if (pShowState->fErrorsOnly &&
            ( (pNeighbor->dwLastSyncResult == 0) ||
              (pNeighbor->cNumConsecutiveSyncFailures == 0) || // probably failure like repl_pending
              DsIsMangledDnW( pNeighbor->pszSourceDsaDN, DS_MANGLE_OBJECT_RDN_FOR_DELETION ))){
            // We return without printing this neighbor...
            return(ERROR_SUCCESS);
        }

        // Intersite only mode.
        GetNtdsDsaSiteServerPair(pNeighbor->pszSourceDsaDN, &pszTempSiteRdn, &pszTempServerRdn);
        if (pShowState->fIntersiteOnly &&
            pShowState->pszSiteRdn &&
            (0 == wcscmp(pShowState->pszSiteRdn, pszTempSiteRdn))) {
            // We return without printing this neighbor...
            return(ERROR_SUCCESS);
        }

    }

    if (bCsvMode()) {
        WCHAR * pszSiteName = NULL;
        WCHAR * pszServerName = NULL;
        WCHAR   szLastResult[15];
        WCHAR   szNumFailures[15];
        WCHAR   szLastFailureTime[ SZDSTIME_LEN ];
        WCHAR   szLastSuccessTime[ SZDSTIME_LEN ];

        // This is the order of strings to pass to PrintCsv()
        // REPADMIN_CSV_SHOWREPL_C3, // Naming Context
        // REPADMIN_CSV_SHOWREPL_C4, // Source DC Site
        // REPADMIN_CSV_SHOWREPL_C5, // Source DC
        // REPADMIN_CSV_SHOWREPL_C6, // Transport Type
        // REPADMIN_CSV_SHOWREPL_C7, // Number of Failures
        // REPADMIN_CSV_SHOWREPL_C8, // Last Failure Time
        // REPADMIN_CSV_SHOWREPL_C9, // Last Success Time
        // REPADMIN_CSV_SHOWREPL_C10 // Last Failure Status

        GetNtdsDsaSiteServerPair(pNeighbor->pszSourceDsaDN, &pszSiteName, &pszServerName);
        Assert(pszSiteName && pszServerName);

        wsprintfW(szNumFailures, L"%d", pNeighbor->cNumConsecutiveSyncFailures);


        FileTimeToDSTime(pNeighbor->ftimeLastSyncAttempt, &dsTime);
        DSTimeToDisplayStringW(dsTime, szLastFailureTime, ARRAY_SIZE(szLastFailureTime));

        FileTimeToDSTime(pNeighbor->ftimeLastSyncSuccess, &dsTime);
        DSTimeToDisplayStringW(dsTime, szLastSuccessTime, ARRAY_SIZE(szLastSuccessTime));

        wsprintfW(szLastResult, L"%d", pNeighbor->dwLastSyncResult);

        Assert(pNeighbor->pszNamingContext);
        Assert(pszSiteName);
        Assert(pszServerName);
        Assert(GetTransportDisplayName(pNeighbor->pszAsyncIntersiteTransportDN));
        Assert(szNumFailures && szLastFailureTime && szLastSuccessTime && szLastResult);

        PrintCsv(eCSV_SHOWREPL_CMD,
                 pNeighbor->pszNamingContext,
                 pszSiteName,
                 pszServerName,
                 GetTransportDisplayName(pNeighbor->pszAsyncIntersiteTransportDN),
                 szNumFailures,
                 (pNeighbor->dwLastSyncResult != 0) ? szLastFailureTime : L"0",
                 szLastSuccessTime,
                 szLastResult);
                 


        return(ERROR_SUCCESS);
    }

    //
    // From here on out it's all non-csv user friendly printing 
    //

    // If we've hit a new NC then print the NC out.
    if ((NULL == pShowState->pszLastNC)
        || (0 != wcscmp(pShowState->pszLastNC, pNeighbor->pszNamingContext))) {
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_PRINT_STR, pNeighbor->pszNamingContext);
        pShowState->pszLastNC = pNeighbor->pszNamingContext;
    }

    // Display server name.
    PrintMsg(REPADMIN_SHOWNEIGHBOR_DISP_SERVER, 
           GetNtdsDsaDisplayName(pNeighbor->pszSourceDsaDN),
           GetTransportDisplayName(pNeighbor->pszAsyncIntersiteTransportDN));

    PrintTabMsg(4, REPADMIN_PRINT_DSA_OBJ_GUID,
                GetStringizedGuid(&pNeighbor->uuidSourceDsaObjGuid));
    // Only display deleted sources if Verbose
    if ( (!(pShowState->fVerbose)) &&
         (DsIsMangledDnW( pNeighbor->pszSourceDsaDN, DS_MANGLE_OBJECT_RDN_FOR_DELETION )) ) {
        return(ERROR_SUCCESS);
    }

    if (pShowState->fVerbose) {
        PrintTabMsg(4, REPADMIN_GENERAL_ADDRESS_COLON_STR,
                    pNeighbor->pszSourceDsaAddress);

        if (fRepsFrom) {
            // Display DSA invocationId.
            PrintTabMsg(4, REPADMIN_PRINT_INVOCATION_ID, 
                        GetStringizedGuid(&pNeighbor->uuidSourceDsaInvocationID));
        }

        if (0 != memcmp(&pNeighbor->uuidAsyncIntersiteTransportObjGuid,
                        &uuidNull, sizeof(UUID))) {
            // Display transport objectGuid.
            PrintTabMsg(6, REPADMIN_PRINT_INTERSITE_TRANS_OBJ_GUID,
                   GetTrnsGuidDisplayName(&pNeighbor->uuidAsyncIntersiteTransportObjGuid));
        }


        //
        // Display replica flags.
        //

        PrintTabMsg(4, REPADMIN_PRINT_STR, 
                GetOptionsString( RepNbrOptionToDra, pNeighbor->dwReplicaFlags ) );

        if ( fRepsFrom )
        {
            //
            // Display USNs.
            //

            PrintMsg(REPADMIN_SHOWNEIGHBOR_USNS,
                     pNeighbor->usnLastObjChangeSynced);
            PrintMsg(REPADMIN_SHOWNEIGHBOR_USNS_HACK2,
                     pNeighbor->usnAttributeFilter);
        }
    }

    //
    // Display time of last successful replication (for Reps-From),
    // or notification (for Reps-To).  The reps-to timestamps may not
    // be filled in on a w2k box.
    //

    // Display status and time of last replication attempt/success.
    if (0 == pNeighbor->dwLastSyncResult) {
        FileTimeToDSTime(pNeighbor->ftimeLastSyncSuccess, &dsTime);
        PrintMsg(REPADMIN_SHOWNEIGHBOR_LAST_ATTEMPT_SUCCESS,
                 DSTimeToDisplayString(dsTime, szTime));
    }
    else {
        FileTimeToDSTime(pNeighbor->ftimeLastSyncAttempt, &dsTime);

        if (0 == pNeighbor->cNumConsecutiveSyncFailures) {
            // A non-zero success status
            PrintMsg(REPADMIN_SHOWNEIGHBOR_LAST_ATTEMPT_DELAYED, 
                     DSTimeToDisplayString(dsTime, szTime));
            PrintErrEnd(pNeighbor->dwLastSyncResult);
        } else {
            // A non-zero failure status
            PrintTabMsg(4, REPADMIN_SHOWNEIGHBOR_LAST_ATTEMPT_FAILED,
                        DSTimeToDisplayString(dsTime, szTime));
            PrintMsg(REPADMIN_GENERAL_ERR_NUM, 
                     pNeighbor->dwLastSyncResult, 
                     pNeighbor->dwLastSyncResult);
            PrintTabMsg(6, REPADMIN_PRINT_STR, 
                        Win32ErrToString(pNeighbor->dwLastSyncResult));

            PrintMsg(REPADMIN_SHOWNEIGHBOR_N_CONSECUTIVE_FAILURES,
                     pNeighbor->cNumConsecutiveSyncFailures);
        }

        FileTimeToDSTime(pNeighbor->ftimeLastSyncSuccess, &dsTime);
        PrintMsg(REPADMIN_SHOWNEIGHBOR_LAST_SUCCESS,
                 DSTimeToDisplayString(dsTime, szTime));

    }

    return(ERROR_SUCCESS);
}


int
__cdecl
ftimeCompare(
    IN const void *elem1,
    IN const void *elem2
    )
/*++

Description:

    This function is used as the comparison for qsort in the function
    ShowVector().

Parameters:

    elem1 - This is the first element and is a pointer to a 
    elem2 - This is the second element and is a pointer to a

Return Value:
  

  --*/
{
    return(       	
	(int) CompareFileTime(
	    (FILETIME *) &(((DS_REPL_CURSOR_2 *)elem1)->ftimeLastSyncSuccess),
	    (FILETIME *) &(((DS_REPL_CURSOR_2 *)elem2)->ftimeLastSyncSuccess)
	    )
    );
                  
}

int
ShowUtdVecEx(
    WCHAR *  pszDSA,
    WCHAR *  pszNC,
    BOOL     fCacheGuids,
    BOOL     fLatencySort
    );

int
ShowVector(
    int     argc,
    LPWSTR  argv[]
    )
/*++

Routine Description:

    This is the deprecated version of the /ShowUtdVec command.

Arguments:

    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    error from the repadmin cmd.

--*/
{
    LPWSTR              pszNC = NULL;
    LPWSTR              pszDSA = NULL;
    int                 iArg;
    BOOL                fCacheGuids = TRUE;
    BOOL                fLatencySort = FALSE;

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/n")
            || !_wcsicmp(argv[ iArg ], L"/nocache")) {
            fCacheGuids = FALSE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/latency")
             || !_wcsicmp(argv[ iArg ], L"/l")) {
            fLatencySort = TRUE;
        }
        else if (NULL == pszNC) {
            pszNC = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        } 
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszNC) {
        PrintMsg(REPADMIN_PRINT_NO_NC);
        return ERROR_INVALID_FUNCTION;
    }

    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    return(ShowUtdVecEx(pszDSA, pszNC, fCacheGuids, fLatencySort));
}

int
ShowUtdVec( // new ShowVector
    int     argc,
    LPWSTR  argv[]
    )
/*++

Routine Description:

    This is the newer version of the /ShowVector command, that takes
    the DC_LIST argument first.

Arguments:

    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    error from the repadmin cmd.

--*/
{
    LPWSTR              pszNC = NULL;
    LPWSTR              pszDSA = NULL;
    int                 iArg;
    BOOL                fCacheGuids = TRUE;
    BOOL                fLatencySort = FALSE;

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/n")
            || !_wcsicmp(argv[ iArg ], L"/nocache")) {
            fCacheGuids = FALSE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/latency")
             || !_wcsicmp(argv[ iArg ], L"/l")) {
            fLatencySort = TRUE;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        } 
        else if (NULL == pszNC) {
            pszNC = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    Assert(pszDSA && "Hmmm, the DC_LIST API should've given us a DC.");
    
    if (NULL == pszNC) {
        PrintMsg(REPADMIN_PRINT_NO_NC);
        // FUTURE-2002/07/12-BrettSh it would be will do very basic NC_LISTs
        // here, like "config:", "schema:", "domain:" (of home server), 
        // "rootdom:", etc...
        return ERROR_INVALID_FUNCTION;
    }

    return(ShowUtdVecEx(pszDSA, pszNC, fCacheGuids, fLatencySort));
}

int
ShowUtdVecEx(
    WCHAR *  pszDSA,
    WCHAR *  pszNC,
    BOOL     fCacheGuids,
    BOOL     fLatencySort
    )
/*++

Routine Description:

    This is the heart of the /ShowUtdVec and /ShowVector commands/functions.

Arguments:

    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    error from the repadmin cmd.

--*/
{
    int                 ret = 0;
    int                 iArg;
    LDAP *              hld;
    int                 ldStatus;
    HANDLE              hDS;
    DS_REPL_CURSORS *   pCursors1;
    DS_REPL_CURSORS_3W *pCursors3;
    DWORD               iCursor;
    ULONG               ulOptions;
    DSTIME              dsTime;
    CHAR                szTime[SZDSTIME_LEN];

    Assert(pszDSA && pszNC);

    ret = RepadminDsBind(pszDSA, &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDSA, ret);
        return ret;
    }

    if (fCacheGuids) {
        // Connect
        hld = ldap_initW(pszDSA, LDAP_PORT);
        if (NULL == hld) {
            PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
            return LDAP_SERVER_DOWN;
        }

        // use only A record dns name discovery
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

        // Bind
        ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
        CHK_LD_STATUS(ldStatus);

        // Populate the guid cache
        BuildGuidCache(hld);

        ldap_unbind(hld);
    }
    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_CURSORS_3_FOR_NC, pszNC, NULL, &pCursors3);
    if (ERROR_SUCCESS == ret) {
        //check for latency sort
        if (fLatencySort) {
            qsort(pCursors3->rgCursor,
                  pCursors3->cNumCursors, 
                  sizeof(pCursors3->rgCursor[0]), 
                  ftimeCompare); 
        } 
	
        for (iCursor = 0; iCursor < pCursors3->cNumCursors; iCursor++) {
            LPWSTR pszDsaName;

            FileTimeToDSTime(pCursors3->rgCursor[iCursor].ftimeLastSyncSuccess,
                             &dsTime);

            if (!fCacheGuids // want raw guids displayed
                || (NULL == pCursors3->rgCursor[iCursor].pszSourceDsaDN)) {
                pszDsaName = GetDsaGuidDisplayName(&pCursors3->rgCursor[iCursor].uuidSourceDsaInvocationID);
            } else {
                pszDsaName = GetNtdsDsaDisplayName(pCursors3->rgCursor[iCursor].pszSourceDsaDN);
            }
            PrintMsg(REPADMIN_SHOWVECTOR_ONE_USN, 
                     pszDsaName,
                     pCursors3->rgCursor[iCursor].usnAttributeFilter);
            PrintMsg(REPADMIN_SHOWVECTOR_ONE_USN_HACK2,
                     dsTime ? DSTimeToDisplayString(dsTime, szTime) : "(unknown)");
        }
    
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_3_FOR_NC, pCursors3);
    } else if (ERROR_NOT_SUPPORTED == ret) {
    
        ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_CURSORS_FOR_NC, pszNC, NULL,
                                &pCursors1);
        if (ERROR_SUCCESS == ret) {
            for (iCursor = 0; iCursor < pCursors1->cNumCursors; iCursor++) {
                PrintMsg(REPADMIN_GETCHANGES_DST_UTD_VEC_ONE_USN,
                       GetDsaGuidDisplayName(&pCursors1->rgCursor[iCursor].uuidSourceDsaInvocationID),
                       pCursors1->rgCursor[iCursor].usnAttributeFilter);
            }
        
            DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors1);
        }
    }

    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
    }

    DsUnBind(&hDS);

    return ret;
}

int
ShowObjMetaEx(
    WCHAR *   pszDSA,
    WCHAR *   pszObject,
    BOOL      fCacheGuids,
    DWORD     dwInfoFlags
    );

int
ShowMeta(
    int     argc,
    LPWSTR  argv[]
    )
/*++

Routine Description:

    This is the deprecated version of the /ShowObjMeta command.

Arguments:

    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    error from the repadmin cmd.

--*/
{
    int                         ret = 0;
    int                         iArg;
    BOOL                        fCacheGuids = TRUE;
    LPWSTR                      pszObject = NULL;
    LPWSTR                      pszDSA = NULL;
    DWORD                       dwInfoFlags = 0;

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/n")
            || !_wcsicmp(argv[ iArg ], L"/nocache")) {
            fCacheGuids = FALSE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/l")
            || !_wcsicmp(argv[ iArg ], L"/linked")) {
            dwInfoFlags |= DS_REPL_INFO_FLAG_IMPROVE_LINKED_ATTRS;
        }
        else if (NULL == pszObject) {
            pszObject = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszObject) {
        PrintMsg(REPADMIN_SHOWMETA_NO_OBJ_SPECIFIED);
        return ERROR_INVALID_FUNCTION;
    }

    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    ret = ShowObjMetaEx(pszDSA, pszObject, fCacheGuids, dwInfoFlags);

    
    // This command logically means show all metadata, so we show it all
    if (!ret) {
        LPWSTR rgpszShowValueArgv[4];
        rgpszShowValueArgv[0] = argv[0];
        rgpszShowValueArgv[1] = argv[1];
        rgpszShowValueArgv[2] = pszDSA;
        rgpszShowValueArgv[3] = pszObject;
        ret = ShowValue( 4, rgpszShowValueArgv );
    }

    return ret;
}

int
ShowObjMeta(
    int     argc,
    LPWSTR  argv[]
    )
{
    int                         ret = 0;
    int                         iArg;
    BOOL                        fCacheGuids = TRUE;
    LPWSTR                      pszObject = NULL;
    LPWSTR                      pszDSA = NULL;
    DWORD                       dwInfoFlags = 0;
    BOOL                        fSuppressValues = FALSE;

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/n")
            || !_wcsicmp(argv[ iArg ], L"/nocache")) {
            fCacheGuids = FALSE;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/l")
            || !_wcsicmp(argv[ iArg ], L"/linked")) {
            dwInfoFlags |= DS_REPL_INFO_FLAG_IMPROVE_LINKED_ATTRS;
        }
        else if (!_wcsicmp(argv[ iArg ], L"/nv")
            || !_wcsicmp(argv[ iArg ], L"/novalue")
            || !_wcsicmp(argv[ iArg ], L"/novalues")) {
            fSuppressValues = TRUE;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else if (NULL == pszObject) {
            pszObject = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszObject) {
        PrintMsg(REPADMIN_SHOWMETA_NO_OBJ_SPECIFIED);
        return ERROR_INVALID_FUNCTION;
    }

    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    ret = ShowObjMetaEx(pszDSA, pszObject, fCacheGuids, dwInfoFlags);
    if ( (!ret) && (!fSuppressValues) ) {
        LPWSTR rgpszShowValueArgv[4];
        rgpszShowValueArgv[0] = argv[0];
        rgpszShowValueArgv[1] = argv[1];
        rgpszShowValueArgv[2] = pszDSA;
        rgpszShowValueArgv[3] = pszObject;
        ret = ShowValue( 4, rgpszShowValueArgv );
    }

    return(ret);
}


int
ShowObjMetaEx(
    WCHAR *   pszDSA,
    WCHAR *   pszObject,
    BOOL      fCacheGuids,
    DWORD     dwInfoFlags
    )
{
    int                         ret = 0;
    LDAP *                      hld;
    int                         ldStatus;
    DS_REPL_OBJ_META_DATA *     pObjMetaData1 = NULL;
    DS_REPL_OBJ_META_DATA_2 *   pObjMetaData2 = NULL;
    DWORD                       iprop;
    HANDLE                      hDS;
    ULONG                       ulOptions;
    DWORD                       cNumEntries;

    Assert(pszDSA && pszObject);

    ret = RepadminDsBind(pszDSA, &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDSA, ret);
        return ret;
    }
    
    ret = DsReplicaGetInfo2W(hDS,
                             DS_REPL_INFO_METADATA_2_FOR_OBJ,
                             pszObject,
                             NULL, // puuid
                             NULL, // pszattributename
                             NULL, // pszvaluedn
                             dwInfoFlags,
                             0, // dwEnumeration Context
                             &pObjMetaData2);
    
    if (ERROR_NOT_SUPPORTED == ret) {
        if (fCacheGuids) {
            // Connect
            hld = ldap_initW(pszDSA, LDAP_PORT);
            if (NULL == hld) {
                PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
                return LDAP_SERVER_DOWN;
            }
    
            // use only A record dns name discovery
            ulOptions = PtrToUlong(LDAP_OPT_ON);
            (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );
    
            // Bind
            ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
            CHK_LD_STATUS(ldStatus);
    
            // Populate the guid cache
            BuildGuidCache(hld);
    
            ldap_unbind(hld);
        }
        
        ret = DsReplicaGetInfo2W(hDS,
                                 DS_REPL_INFO_METADATA_FOR_OBJ,
                                 pszObject,
                                 NULL, // puuid
                                 NULL, // pszattributename
                                 NULL, // pszvaluedn
                                 dwInfoFlags,
                                 0, // dwEnumeration Context
                                 &pObjMetaData1);
    }
    
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        return ret;
    }

    cNumEntries = pObjMetaData2 ? pObjMetaData2->cNumEntries : pObjMetaData1->cNumEntries;
    PrintMsg(REPADMIN_PRINT_CR);
    PrintMsg(REPADMIN_SHOWMETA_N_ENTRIES, cNumEntries);

    PrintMsg(REPADMIN_SHOWMETA_DATA_HDR);

    for (iprop = 0; iprop < cNumEntries; iprop++) {
        CHAR   szTime[ SZDSTIME_LEN ];
        DSTIME dstime;

        if (pObjMetaData2) {
            LPWSTR pszDsaName;

            if (!fCacheGuids // want raw guids displayed
                || (NULL == pObjMetaData2->rgMetaData[iprop].pszLastOriginatingDsaDN)) {
                pszDsaName = GetDsaGuidDisplayName(&pObjMetaData2->rgMetaData[iprop].uuidLastOriginatingDsaInvocationID);
            } else {
                pszDsaName = GetNtdsDsaDisplayName(pObjMetaData2->rgMetaData[iprop].pszLastOriginatingDsaDN);
            }

            FileTimeToDSTime(pObjMetaData2->rgMetaData[ iprop ].ftimeLastOriginatingChange,
                             &dstime);

            // BUGBUG if anyone fixes how the message file handles ia64 qualifiers,
            // then we can combine these message strings into one.
            PrintMsg(REPADMIN_SHOWMETA_DATA_LINE,
                     pObjMetaData2->rgMetaData[ iprop ].usnLocalChange
                     );
            PrintMsg(REPADMIN_SHOWMETA_DATA_LINE_HACK2,
                     pszDsaName,
                     pObjMetaData2->rgMetaData[ iprop ].usnOriginatingChange
                     );
            PrintMsg(REPADMIN_SHOWMETA_DATA_LINE_HACK3,
                     DSTimeToDisplayString(dstime, szTime),
                     pObjMetaData2->rgMetaData[ iprop ].dwVersion,
                     pObjMetaData2->rgMetaData[ iprop ].pszAttributeName
                     );
        } else {
            FileTimeToDSTime(pObjMetaData1->rgMetaData[ iprop ].ftimeLastOriginatingChange,
                             &dstime);
    
            PrintMsg(REPADMIN_SHOWMETA_DATA_LINE,
                     pObjMetaData1->rgMetaData[ iprop ].usnLocalChange
                     );
            PrintMsg(REPADMIN_SHOWMETA_DATA_LINE_HACK2,
                     GetDsaGuidDisplayName(&pObjMetaData1->rgMetaData[iprop].uuidLastOriginatingDsaInvocationID),
                     pObjMetaData1->rgMetaData[ iprop ].usnOriginatingChange
                     );
            PrintMsg(REPADMIN_SHOWMETA_DATA_LINE_HACK3,
                     DSTimeToDisplayString(dstime, szTime),
                     pObjMetaData1->rgMetaData[ iprop ].dwVersion,
                     pObjMetaData1->rgMetaData[ iprop ].pszAttributeName
                     );
        }
    }

    if (pObjMetaData2) {
        DsReplicaFreeInfo(DS_REPL_INFO_METADATA_2_FOR_OBJ, pObjMetaData2);
    } else {
        DsReplicaFreeInfo(DS_REPL_INFO_METADATA_FOR_OBJ, pObjMetaData1);
    }

    DsUnBind(&hDS);

    return ret;
}

int
ShowValue(
    int     argc,
    LPWSTR  argv[]
    )
{
    int                     ret = 0;
    int                     iArg;
    BOOL                    fCacheGuids = TRUE;
    LPWSTR                  pszObject = NULL;
    LPWSTR                  pszDSA = NULL;
    LPWSTR                  pszAttributeName = NULL;
    LPWSTR                  pszValue = NULL;
    LDAP *                  hld;
    int                     ldStatus;
    DS_REPL_ATTR_VALUE_META_DATA * pAttrValueMetaData1 = NULL;
    DS_REPL_ATTR_VALUE_META_DATA_2 * pAttrValueMetaData2 = NULL;
    DWORD                   iprop;
    HANDLE                  hDS;
    DWORD                   context;
    ULONG                   ulOptions;
    BOOL                    fGuidsAlreadyCached = FALSE;
    DWORD                   cNumEntries;

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/n")
            || !_wcsicmp(argv[ iArg ], L"/nocache")) {
            fCacheGuids = FALSE;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else if (NULL == pszObject) {
            pszObject = argv[iArg];
        }
        else if (NULL == pszAttributeName) {
            pszAttributeName = argv[iArg];
        }
        else if (NULL == pszValue) {
            pszValue = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (NULL == pszObject) {
        PrintMsg(REPADMIN_SHOWMETA_NO_OBJ_SPECIFIED);
        return ERROR_INVALID_FUNCTION;
    }

    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    ret = RepadminDsBind(pszDSA, &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDSA, ret);
        return ret;
    }

    // Context starts at zero
    context = 0;
    while (1) {
        ret = DsReplicaGetInfo2W(hDS,
                                 DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE,
                                 pszObject,
                                 NULL /*guid*/,
                                 pszAttributeName,
                                 pszValue,
                                 0 /*flags*/,
                                 context,
                                 &pAttrValueMetaData2);
        if (ERROR_NOT_SUPPORTED == ret) {
            if (fCacheGuids && !fGuidsAlreadyCached) {
                // Connect
                hld = ldap_initW(pszDSA, LDAP_PORT);
                if (NULL == hld) {
                    PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
                    return LDAP_SERVER_DOWN;
                }
        
                // use only A record dns name discovery
                ulOptions = PtrToUlong(LDAP_OPT_ON);
                (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );
        
                // Bind
                ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
                CHK_LD_STATUS(ldStatus);
        
                // Populate the guid cache
                BuildGuidCache(hld);
        
                ldap_unbind(hld);

                fGuidsAlreadyCached = TRUE;
            }
        
            ret = DsReplicaGetInfo2W(hDS,
                                     DS_REPL_INFO_METADATA_FOR_ATTR_VALUE,
                                     pszObject,
                                     NULL /*guid*/,
                                     pszAttributeName,
                                     pszValue,
                                     0 /*flags*/,
                                     context,
                                     &pAttrValueMetaData1);
        }

        if (ERROR_NO_MORE_ITEMS == ret) {
            // This is the successful path out of the loop
            PrintMsg(REPADMIN_SHOWVALUE_NO_MORE_ITEMS);
            ret = ERROR_SUCCESS;
            goto cleanup;
        } else if (ERROR_SUCCESS != ret) {
            PrintFuncFailed(L"DsReplicaGetInfo", ret);
            goto cleanup;
        }

        cNumEntries = pAttrValueMetaData2 ? pAttrValueMetaData2->cNumEntries : pAttrValueMetaData1->cNumEntries;
        
        PrintMsg(REPADMIN_SHOWMETA_N_ENTRIES, cNumEntries);

        PrintMsg(REPADMIN_SHOWVALUE_DATA_HDR);

        for (iprop = 0; iprop < cNumEntries; iprop++) {
            if (pAttrValueMetaData2) {
                DS_REPL_VALUE_META_DATA_2 *pValueMetaData = &(pAttrValueMetaData2->rgMetaData[iprop]);
                CHAR   szTime1[ SZDSTIME_LEN ], szTime2[ SZDSTIME_LEN ];
                DSTIME dstime1, dstime2;
                BOOL fPresent =
                    (memcmp( &pValueMetaData->ftimeDeleted, &ftimeZero, sizeof( FILETIME )) == 0);
                BOOL fLegacy = (pValueMetaData->dwVersion == 0);
                LPWSTR pszDsaName;
    
                if (!fCacheGuids // want raw guids displayed
                    || (NULL == pValueMetaData->pszLastOriginatingDsaDN)) {
                    pszDsaName = GetDsaGuidDisplayName(&pValueMetaData->uuidLastOriginatingDsaInvocationID);
                } else {
                    pszDsaName = GetNtdsDsaDisplayName(pValueMetaData->pszLastOriginatingDsaDN);
                }
    
                FileTimeToDSTime(pValueMetaData->ftimeCreated, &dstime1);
                
                if(fLegacy){
                    // Windows 2000 Legacy value.
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_LEGACY);
                } else if (fPresent) {
                    // Windows XP Present value.
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_PRESENT);
                } else {
                    // Windows XP Absent value.
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_ABSENT);
                }
                
                PrintMsg(REPADMIN_SHOWVALUE_DATA_BASIC,
                         pValueMetaData->pszAttributeName
                         );

                if (!fLegacy) {
                    // We'll need the last mod time.
                    FileTimeToDSTime(pValueMetaData->ftimeLastOriginatingChange,
                                     &dstime2);
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_VALUE_META_DATA,
                             DSTimeToDisplayString(dstime2, szTime2),
                             pszDsaName,
                             pValueMetaData->usnLocalChange);
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_VALUE_META_DATA_HACK2,
                             pValueMetaData->usnOriginatingChange);
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_VALUE_META_DATA_HACK3,
                             pValueMetaData->dwVersion);
                } else {
                    PrintMsg(REPADMIN_PRINT_CR);
                }

                PrintTabMsg(4, REPADMIN_PRINT_STR,
                            pValueMetaData->pszObjectDn);

            } else {
                DS_REPL_VALUE_META_DATA *pValueMetaData = &(pAttrValueMetaData1->rgMetaData[iprop]);
                CHAR   szTime1[ SZDSTIME_LEN ], szTime2[ SZDSTIME_LEN ];
                DSTIME dstime1, dstime2;
                BOOL fPresent =
                    (memcmp( &pValueMetaData->ftimeDeleted, &ftimeZero, sizeof( FILETIME )) == 0);
                BOOL fLegacy = (pValueMetaData->dwVersion == 0);
    
                FileTimeToDSTime(pValueMetaData->ftimeCreated, &dstime1);
                if (fPresent) {
                    if(fLegacy){
                        PrintMsg(REPADMIN_SHOWVALUE_DATA_LINE_LEGACY,
                                 pValueMetaData->pszAttributeName,
                                 pValueMetaData->pszObjectDn,
                                 pValueMetaData->cbData,
                                 DSTimeToDisplayString(dstime1, szTime1) );
                    } else {
                        PrintMsg(REPADMIN_SHOWVALUE_DATA_LINE_PRESENT,
                                 pValueMetaData->pszAttributeName,
                                 pValueMetaData->pszObjectDn,
                                 pValueMetaData->cbData,
                                 DSTimeToDisplayString(dstime1, szTime1) );
                    }
                } else {
                    FileTimeToDSTime(pValueMetaData->ftimeDeleted, &dstime2);
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_LINE_ABSENT,
                             pValueMetaData->pszAttributeName,
                             pValueMetaData->pszObjectDn,
                             pValueMetaData->cbData,
                             DSTimeToDisplayString(dstime1, szTime1),
                             DSTimeToDisplayString(dstime2, szTime2) );
                }
    
                if (!fLegacy) {
                    FileTimeToDSTime(pValueMetaData->ftimeLastOriginatingChange,
                                     &dstime2);
    
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_LINE, 
                             pValueMetaData->usnLocalChange);
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_LINE_HACK2, 
                             GetDsaGuidDisplayName(&pValueMetaData->uuidLastOriginatingDsaInvocationID),
                             pValueMetaData->usnOriginatingChange);
                    PrintMsg(REPADMIN_SHOWVALUE_DATA_LINE_HACK3, 
                             DSTimeToDisplayString(dstime2, szTime2),
                             pValueMetaData->dwVersion );
                }
            }
        }
        
        if (pAttrValueMetaData2) {
            context = pAttrValueMetaData2->dwEnumerationContext;
            DsReplicaFreeInfo(DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE, pAttrValueMetaData2);
            pAttrValueMetaData2 = NULL;
        } else {
            context = pAttrValueMetaData1->dwEnumerationContext;
            DsReplicaFreeInfo(DS_REPL_INFO_METADATA_FOR_ATTR_VALUE, pAttrValueMetaData1);
            pAttrValueMetaData1 = NULL;
        }

        // When requesting a single value, we are done
        // The context will indicate if all values returned
        if ( (pszValue) || (context == 0xffffffff) ) {
            break;
        }
    }

cleanup:
    DsUnBind(&hDS);

    return ret;
}

int
ShowCtx(
    int     argc,
    LPWSTR  argv[]
    )
{
    int                       ret = 0;
    LPWSTR                    pszDSA = NULL;
    int                       iArg;
    LDAP *                    hld;
    BOOL                      fCacheGuids = TRUE;
    int                       ldStatus;
    HANDLE                    hDS;
    DS_REPL_CLIENT_CONTEXTS * pContexts;
    DS_REPL_CLIENT_CONTEXT  * pContext;
    DWORD                     iCtx;
    LPWSTR                    pszClient;
    const UUID                uuidNtDsApiClient = NtdsapiClientGuid;
    char                      szTime[SZDSTIME_LEN];
    ULONG                     ulOptions;

    // Parse command-line arguments.
    // Default to local DSA, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[ iArg ], L"/n")
            || !_wcsicmp(argv[ iArg ], L"/nocache")) {
            fCacheGuids = FALSE;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    if (fCacheGuids) {
        hld = ldap_initW(pszDSA, LDAP_PORT);
        if (NULL == hld) {
            PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
            return LDAP_SERVER_DOWN;
        }

        // use only A record dns name discovery
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

        // Bind
        ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
        CHK_LD_STATUS(ldStatus);

        // Populate the guid cache
        BuildGuidCache(hld);

        ldap_unbind(hld);
    }

    ret = RepadminDsBind(pszDSA, &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDSA, ret);
        return ret;
    }

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_CLIENT_CONTEXTS, NULL, NULL,
                            &pContexts);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        return ret;
    }

    PrintMsg(REPADMIN_SHOWCTX_OPEN_CONTEXT_HANDLES, pContexts->cNumContexts);

    for (iCtx = 0; iCtx < pContexts->cNumContexts; iCtx++) {
        pContext = &pContexts->rgContext[iCtx];

        if (0 == memcmp(&pContext->uuidClient, &uuidNtDsApiClient, sizeof(GUID))) {
            pszClient = L"NTDSAPI client";
        }
        else {
// Will Lees, is this a transport id or a invocation id?
            pszClient = GetDsaGuidDisplayName(&pContext->uuidClient);
        }

        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_SHOWCTX_DATA_1, 
               pszClient,
               inet_ntoa(*((IN_ADDR *) &pContext->IPAddr)),
               pContext->pid,
               pContext->hCtx);
        if(pContext->fIsBound){
            PrintMsg(REPADMIN_SHOWCTX_DATA_2, 
               pContext->lReferenceCount,
               DSTimeToDisplayString(pContext->timeLastUsed, szTime));
        } else {
            PrintMsg(REPADMIN_SHOWCTX_DATA_2_NOT, 
               pContext->lReferenceCount,
               DSTimeToDisplayString(pContext->timeLastUsed, szTime));
        }
    }

    DsReplicaFreeInfo(DS_REPL_INFO_CLIENT_CONTEXTS, pContexts);
    DsUnBind(&hDS);

    return ret;
}

int
ShowServerCalls(
    int     argc,
    LPWSTR  argv[]
    )
{
    int                       ret = 0;
    LPWSTR                    pszDSA = NULL;
    int                       iArg;
    HANDLE                    hDS;
    DS_REPL_SERVER_OUTGOING_CALLS * pCalls = NULL;
    DS_REPL_SERVER_OUTGOING_CALL  * pCall;
    DWORD                     iCtx;
    char                      szTime[SZDSTIME_LEN];
    DSTIME                    dstimeNow;
    DWORD                     duration;

    // Parse command-line arguments.
    // Default to local DSA, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    ret = RepadminDsBind(pszDSA, &hDS);
    if (ERROR_SUCCESS != ret) {
        PrintBindFailed(pszDSA, ret);
        return ret;
    }

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_SERVER_OUTGOING_CALLS, NULL, NULL,
                            &pCalls);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        return ret;
    }

    dstimeNow = GetSecondsSince1601();

    if (pCalls->cNumCalls == 0) {
        PrintMsg( REPADMIN_CALLS_NO_OUTGOING_CALLS,
                pszDSA );
    } else {
        PrintMsg( REPADMIN_CALLS_IN_PROGRESS,
                pszDSA, pCalls->cNumCalls );

        for (iCtx = 0; iCtx < pCalls->cNumCalls; iCtx++) {
            pCall = &pCalls->rgCall[iCtx];
            PrintMsg(REPADMIN_PRINT_CR);
            if (pCall->dwCallType >= ARRAY_SIZE(rgCallTypeNameTable)) {
                pCall->dwCallType = 0;
            }
            PrintMsg( REPADMIN_CALLS_CALL_TYPE,
                    rgCallTypeNameTable[pCall->dwCallType] );
            PrintMsg( REPADMIN_CALLS_TARGET_SERVER,
                    pCall->pszServerName );
            PrintMsg( REPADMIN_CALLS_HANDLE_INFO,
                    pCall->fIsHandleBound,
                    pCall->fIsHandleFromCache,
                    pCall->fIsHandleInCache );
            PrintMsg( REPADMIN_CALLS_THREAD_ID,
                    pCall->dwThreadId );
            PrintMsg( REPADMIN_CALLS_TIME_STARTED,
                    DSTimeToDisplayString(pCall->dstimeCreated, szTime));
            PrintMsg( REPADMIN_CALLS_CALL_TIMEOUT,
                    pCall->dwBindingTimeoutMins );

            if (dstimeNow > pCall->dstimeCreated) {
                duration = ((DWORD) (dstimeNow - pCall->dstimeCreated));
            } else {
                duration = 0;
            }
            PrintMsg( REPADMIN_CALLS_CALL_DURATION,
                    duration / 60, duration % 60 );
        }
    }

    DsReplicaFreeInfo(DS_REPL_INFO_SERVER_OUTGOING_CALLS, pCalls);
    DsUnBind(&hDS);

    return ret;
}


typedef struct _BY_DEST_REPL {

    // Identity.
    WCHAR *     szConnectString;
    WCHAR *     szName;
    GUID        dsaGuid;

    // Operational error binding or getting neighbor info
    DWORD       dwOpError;
    
    // Replication state.
    DSTIME      llLastSuccess;
    DSTIME      llConnectTime;
    DSTIME      llDelta;
    DWORD       dwError;        
    DWORD       cReplPartners;  // Number of NCs * Number of replicas for each NC.
    DWORD       cPartnersInErr; 

} BY_DEST_REPL;

// Maybe some day the array of sources will have different elements.
typedef   BY_DEST_REPL  BY_SRC_REPL;

typedef struct _REPL_SUM {

    //
    // Global information for the repl summary
    //
    DSTIME          llStartTime;
    BOOL            fBySrc;
    BOOL            fByDest;
    BOOL            fErrorsOnly;

    //
    // Array of repl info organized by destination.
    //
    ULONG           cDests;
    ULONG           cDestsAllocd;
    BY_DEST_REPL *  pDests;
    BY_DEST_REPL *  pCurDsa; // just an optimization

    //
    // Array of repl info organized by source.
    //
    ULONG           cSrcs;
    ULONG           cSrcsAllocd;
    BY_SRC_REPL *   pSrcs;

} REPL_SUM;

#define REPL_SUM_NO_SERVER 0xFFFFFFFF

DWORD
ReplSumFind(
    REPL_SUM *      pReplSum,
    BY_DEST_REPL *  pDcs,
    GUID *          pGuid
    )
/*++

Routine Description:

    This function attempts to find and return the index of the server
    specified by GUID.

Arguments:

    pReplSum - The global replication summary structure.
    pDcs - The (source or destination) list of DCs.
    pGuid - The guid of the desired server.

Return Value:

    If no server can be found REPL_SUM_NO_SERVER, otherwise the index 
    in pDcs of the server will be returned.

--*/
{
    ULONG    cDcs;
    ULONG    i;

    Assert(pReplSum->pDests != pReplSum->pSrcs);
    
    // Figure out whether to grow the src or dst array.
    if(pReplSum->pDests == pDcs){
        cDcs = pReplSum->cDests;
    } else {
        Assert(pReplSum->pSrcs == pDcs);
        cDcs = pReplSum->cSrcs;
    }

    for (i = 0; i < cDcs; i++) {
        if (0 == memcmp(&(pDcs[i].dsaGuid), pGuid, sizeof(GUID))) {
            return(i);
        }
    }

    return(REPL_SUM_NO_SERVER);
}

DWORD
GetPssFriendlyName(
    WCHAR *     szDsaDn,
    WCHAR **    pszFriendlyName
    )
/*++

Routine Description:

    This gets a PSS friendly name, in such a way that the string
    is guaranteed to be 15 chars or less.

Arguments:

    szDsaDn - The DN of the DSA object.
    pszFriendlyName - LocalAlloc()d friendly name.

Return Value:

    Win32 Error

--*/
{
    DWORD dwRet;
    WCHAR * szTemp = NULL;

    //
    // Getting server name ...
    //
    dwRet = GetNtdsDsaSiteServerPair(szDsaDn, NULL, &szTemp);
    if (dwRet) {
        return(dwRet);
    }
    QuickStrCopy(*pszFriendlyName, szTemp, dwRet, return(dwRet));


    if ((NULL != (szTemp = wcschr(*pszFriendlyName, L' '))) ||
        (wcslen(*pszFriendlyName) > 15) ){
        if (szTemp) {
            *szTemp = L'\0';
        }
        if (wcslen(*pszFriendlyName) > 15) {
            // Too long, shorten to 15 characters.
            (*pszFriendlyName)[15] = L'\0';
        }
    }
    
    return(ERROR_SUCCESS);
}

BY_DEST_REPL *
ReplSumGrow(
    REPL_SUM *      pReplSum,
    BY_DEST_REPL *  pDcs,
    WCHAR *         szConnectString,
    WCHAR *         szName,
    GUID *          pGuid
    )
/*++

Routine Description:

    This grows our DC array by one for the szConnectString, szName, 
    pGuid provided.  Re-allocates the array if necessary.  On failure
    it means an allocation failure, so it bails (exit(1)) repadmin.

Arguments:

    pReplSum - The repl summary context block
    pDcs - The specific DCs array to expand, must be either
        pReplSum->pDests or pReplSum->pSrcs 
    szConnectString - The string used to bind to this DC
    szName - the PSS friendly name format (must be 15 chars or less
    pGuid - A unique ID (Dsa Guid) so we can always find existing
        servers in the array.

Return Value:

    Returns a pointer to the newly allocated element.

--*/
{
    ULONG       cDcs;
    ULONG       cAllocdDcs;
    BY_DEST_REPL * pTempDcs;

    Assert(pReplSum->pDests != pReplSum->pSrcs);

    // Figure out whether to grow the src or dst array.
    if(pReplSum->pDests == pDcs){
        cDcs = pReplSum->cDests;
        cAllocdDcs = pReplSum->cDestsAllocd;
    } else {
        Assert(pReplSum->pSrcs == pDcs);
        cDcs = pReplSum->cSrcs;
        cAllocdDcs = pReplSum->cSrcsAllocd;
    }

    if (cDcs + 1 >= cAllocdDcs) {
        // Need to grow DC array.
        cAllocdDcs *= 2; // Double array.

        pTempDcs = realloc(pDcs, sizeof(BY_DEST_REPL) * cAllocdDcs);
        CHK_ALLOC(pTempDcs);

    } else {
        pTempDcs = pDcs;
    }
    Assert(pTempDcs);
    
    //
    // Can't fail after here..
    //

    if (pReplSum->pDests == pDcs) {
        pReplSum->pDests = pTempDcs;
        pReplSum->cDests = cDcs + 1;
        pReplSum->cDestsAllocd = cAllocdDcs;
    } else {
        pReplSum->pSrcs = pTempDcs;
        pReplSum->cSrcs = cDcs + 1;
        pReplSum->cSrcsAllocd = cAllocdDcs;
    }

    memset(&(pTempDcs[cDcs]), 0, sizeof(BY_DEST_REPL));
    pTempDcs[cDcs].szConnectString = szConnectString;
    pTempDcs[cDcs].szName = szName;
    memcpy(&(pTempDcs[cDcs].dsaGuid), pGuid, sizeof(GUID));

    return(&(pTempDcs[cDcs]));
}

GUID NullGuid = { 0 };

// FUTURE-2002/08/12-BrettSh put this in a library ...
DWORD
DcDiagGeneralizedTimeToSystemTime(
    LPWSTR IN                   szTime,
    PSYSTEMTIME OUT             psysTime)
/*++

Routine Description:

    Converts a generalized time string to the equivalent system time.

Parameters:
    szTime - [Supplies] This is string containing generalized time.
    psysTime - [Returns] This is teh SYSTEMTIME struct to be returned.

Return Value:
  
    Win 32 Error code, note could only result from invalid parameter.

  --*/
{
   DWORD       status = ERROR_SUCCESS;
   ULONG       cch;
   ULONG       len;

    //
    // param sanity
    //
    if (!szTime || !psysTime)
    {
       return STATUS_INVALID_PARAMETER;
    }

    len = wcslen(szTime);

    if( len < 15 || szTime[14] != '.')
    {
       return STATUS_INVALID_PARAMETER;
    }

    // initialize
    memset(psysTime, 0, sizeof(SYSTEMTIME));

    // Set up and convert all time fields

    // year field
    cch=4;
    psysTime->wYear = (USHORT)MemWtoi(szTime, cch) ;
    szTime += cch;
    // month field
    psysTime->wMonth = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // day of month field
    psysTime->wDay = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // hours
    psysTime->wHour = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // minutes
    psysTime->wMinute = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // seconds
    psysTime->wSecond = (USHORT)MemWtoi(szTime, (cch=2));

    return status;

}


BY_DEST_REPL *
ReplSummaryAddDest(
    WCHAR *         szDest,
    LDAP **         phLdap, 
    REPL_SUM *      pReplSum
    )
/*++

Routine Description:

    This routine adds a destination DC to the destinations array, note
    it assumes a valid phLdap is passed in, and the szDest string used
    to connect to that LDAP *.
    
    On a few failures (certain critical memory allocation failures) 
    repadmin will just exit, but on any other failures the new destination
    DC element will simply have it's dwOpError set indicating there was
    trouble contacting it or something like that.  Basically, except on
    certain early memory allocation failures this function pretty much
    always succeeds, and if it doesn't it exits repadmin.

Arguments:

    szDest - the Connection string used to get the phLdap
    phLdap - LDAP binding handle to the server we're trying to add to the
        destination DCs array.
    pReplSum - The repl summary context block

Return Value:

    Returns a pointer to the newly allocated destination DC element

--*/
{
    DWORD  dwRet = 0;
    WCHAR * szDestAllocd = NULL;
    WCHAR * szDsaDn = NULL;
    WCHAR * szFriendlyName = NULL;
    WCHAR * szTemp;
    LDAP * hLdap = NULL;
    WCHAR * aszAttrs [] = { L"objectGuid", NULL };
    LDAPMessage * pResults = NULL;
    LDAPMessage * pEntry = NULL;
    struct berval **      ppbvGuid = NULL;
    WCHAR * szTime = NULL;
    BY_DEST_REPL * pDest;
    SYSTEMTIME systemTime;
    FILETIME llTime;

    __try {

        //
        // These first two parts are critical failure to even allocate
        // this much memory will kill repadmin.
        //
        
        QuickStrCopy(szDestAllocd, szDest, dwRet, ;);
        if (dwRet) {
            CHK_ALLOC(0); // Memory failure
        }
        pDest = ReplSumGrow(pReplSum, pReplSum->pDests, szDestAllocd, NULL, &NullGuid);
        Assert(pDest);

        //
        // After here we succeed no matter what.
        //

        dwRet = RepadminLdapBindEx(szDest, LDAP_PORT, FALSE, FALSE, &hLdap);
        if (ERROR_SUCCESS != dwRet) {
            __leave;
        }

        dwRet = GetRootAttr(hLdap, L"dsServiceName", &szDsaDn);
        if (dwRet) {
            dwRet = LdapMapErrorToWin32(dwRet); 
            Assert(dwRet);
            __leave;
        }

        dwRet = ldap_search_sW(hLdap, szDsaDn, LDAP_SCOPE_BASE, L"(objectClass=*)",
                             aszAttrs, 0, &pResults);
        if (dwRet) {
            dwRet = LdapMapErrorToWin32(dwRet);
            Assert(dwRet);
            __leave;
        }

        pEntry = ldap_first_entry(hLdap, pResults);
        Assert(NULL != pEntry);
        if (pEntry == NULL) {
            dwRet = ERROR_INVALID_PARAMETER;
            __leave;
        }

        ppbvGuid = ldap_get_values_len(hLdap, pEntry, "objectGuid");
        Assert(NULL != ppbvGuid);
        if (NULL == ppbvGuid) {
            dwRet = ERROR_INVALID_PARAMETER;
            __leave;
        }
        
        if (szDsaDn) {
            dwRet = GetPssFriendlyName(szDsaDn, &szFriendlyName);
            if (dwRet) {
                __leave;
            }
        }

        dwRet = GetRootAttr(hLdap, L"currentTime", &szTime);

        dwRet = DcDiagGeneralizedTimeToSystemTime((LPWSTR) szTime, &systemTime);
        if(dwRet == ERROR_SUCCESS){
            SystemTimeToFileTime(&systemTime, &llTime);
            FileTimeToDSTime(llTime, &(pDest->llConnectTime));
        }

    } __finally {


        Assert(szDestAllocd);
        if (dwRet == ERROR_SUCCESS) {
            //
            // Fill in the rest of the identity portion of the structure.
            //
            Assert(hLdap && szFriendlyName && !fNullUuid(((GUID *) ppbvGuid[0]->bv_val)));
            Assert(szDestAllocd);
            pDest->szName = szFriendlyName;
            memcpy(&(pDest->dsaGuid), ((GUID *) ppbvGuid[0]->bv_val), sizeof(GUID));
            *phLdap = hLdap;
        } else {
            //
            // Set error trying to connect to this DC.
            //
            Assert(pDest->szConnectString);
            pDest->dwOpError = dwRet;
            if (hLdap) {
                RepadminLdapUnBind(&hLdap);
            }
        }

        if (szDsaDn) {
            LocalFree(szDsaDn);
        }

        if (ppbvGuid) {
            ldap_value_free_len(ppbvGuid);
        }
        if (pResults) {
            ldap_msgfree(pResults);
        }
    }
    
    return(pDest);
}


DWORD
ReplSummaryAccumulate(
    DS_REPL_NEIGHBORW * pNeighbor,
    ULONG               fRepsFrom,
    void *              pvState
    )
/*++

Routine Description:

    This is the processor function passed to IterateNeighbors().  This function
    accumulates the replication information/errors for a single neighbor into the
    repl summary context block (pReplSum).  This function doesn't actually print
    anything, just accumulates the information for use/printing by ReplSummary().

Arguments:

    pNeighbor - the particular neighbor to process
    fRepsFrom - Should always be TRUE.
    pvState is really this:
        pReplSum - The repl summary context block

Return Value:

    Win32 Error

--*/
{
    DWORD dwRet = ERROR_SUCCESS;
    REPL_SUM * pReplSum = (REPL_SUM *) pvState;
    BY_SRC_REPL * pCurSrcDsa;
    BY_DEST_REPL * pCurDstDsa;
    WCHAR * szFriendlyName;
    ULONG  iDc;
    DSTIME llLastSyncSuccess;
        
    if (!fRepsFrom || (pReplSum == NULL) || (pNeighbor == NULL) || (pReplSum->pCurDsa == NULL)) {
        Assert(!"Huh");
        return(ERROR_INVALID_PARAMETER);
    }

    if (DsIsMangledDnW( pNeighbor->pszSourceDsaDN, DS_MANGLE_OBJECT_RDN_FOR_DELETION )) {
        // Skip this DSA, it's probably not alive anymore.
        return(0);
    }

    FileTimeToDSTime(pNeighbor->ftimeLastSyncSuccess, &llLastSyncSuccess);

    if (pReplSum->fByDest) {
        
        pCurDstDsa = pReplSum->pCurDsa;

        //
        // Update by destination
        //

        pCurDstDsa->cReplPartners++;
        
        if (pNeighbor->dwLastSyncResult != ERROR_SUCCESS &&
            pNeighbor->cNumConsecutiveSyncFailures > 0
            ) {
            pCurDstDsa->cPartnersInErr++;

            if (pCurDstDsa->dwError == 0 ||
                pCurDstDsa->llLastSuccess == 0 ||
                pCurDstDsa->llLastSuccess > llLastSyncSuccess){
                pCurDstDsa->dwError = pNeighbor->dwLastSyncResult;
            }

        }

        if (pCurDstDsa->llLastSuccess == 0 ||
            pCurDstDsa->llLastSuccess > llLastSyncSuccess) {
            pCurDstDsa->llLastSuccess = llLastSyncSuccess;
            // Set Delta.
            pCurDstDsa->llDelta = ((pCurDstDsa->llConnectTime) ? pCurDstDsa->llConnectTime : pReplSum->llStartTime);
            pCurDstDsa->llDelta = pCurDstDsa->llDelta - pCurDstDsa->llLastSuccess;
            pCurDstDsa->llDelta = (pCurDstDsa->llDelta > 0) ? pCurDstDsa->llDelta : 0;
        }

    }
    
    if (pReplSum->fBySrc) {

        //
        // Add an entry for the source if necessary
        //
            
        iDc = ReplSumFind(pReplSum, pReplSum->pSrcs, &(pNeighbor->uuidSourceDsaObjGuid));
        if (iDc == REPL_SUM_NO_SERVER) {
            dwRet = GetPssFriendlyName(pNeighbor->pszSourceDsaDN, &szFriendlyName);
            if (dwRet) {
                Assert(!"Can we get such a malformed DN?");
                return(dwRet);
            }
            pCurSrcDsa = ReplSumGrow(pReplSum, pReplSum->pSrcs, NULL, szFriendlyName, &(pNeighbor->uuidSourceDsaObjGuid));
            Assert(pCurSrcDsa != NULL);
        } else {
            pCurSrcDsa = &(pReplSum->pSrcs[iDc]);
        }

        //
        // Update by source
        //

        pCurSrcDsa->cReplPartners++;

        if (pNeighbor->dwLastSyncResult != ERROR_SUCCESS &&
            pNeighbor->cNumConsecutiveSyncFailures > 0 ) {
            pCurSrcDsa->cPartnersInErr++;

            if (pCurSrcDsa->dwError == 0 ||
                pCurSrcDsa->llLastSuccess == 0 ||
                pCurSrcDsa->llLastSuccess > llLastSyncSuccess){
                pCurSrcDsa->dwError = pNeighbor->dwLastSyncResult;
            }
        }

        if (pCurSrcDsa->llLastSuccess == 0 ||
            pCurSrcDsa->llLastSuccess > llLastSyncSuccess) {
            pCurSrcDsa->llLastSuccess = llLastSyncSuccess;
            // Set Delta.
            pCurSrcDsa->llDelta = ((pCurSrcDsa->llConnectTime) ? pCurSrcDsa->llConnectTime : pReplSum->llStartTime);
            pCurSrcDsa->llDelta = pCurSrcDsa->llDelta - pCurSrcDsa->llLastSuccess;
            pCurSrcDsa->llDelta = (pCurSrcDsa->llDelta > 0) ? pCurSrcDsa->llDelta : 0;
        }

    }
    
    return(ERROR_SUCCESS);
}

       
void
ReplSumFree(
    REPL_SUM *   pReplSum
    )
/*++

Routine Description:

    This safely frees the replication summary context block.

Arguments:

    pReplSum - The repl summary context block

--*/
{
    ULONG i;
    if (pReplSum) {
        if (pReplSum->pDests) {
            for (i = 0; i < pReplSum->cDests; i++) {
                if (pReplSum->pDests[i].szName) {
                    LocalFree(pReplSum->pDests[i].szName);
                    pReplSum->pDests[i].szName = NULL;
                }
                if (pReplSum->pDests[i].szConnectString) {
                    LocalFree(pReplSum->pDests[i].szConnectString);
                    pReplSum->pDests[i].szConnectString = NULL;
                }
            }
            free(pReplSum->pDests);
        }
        if (pReplSum->pSrcs) {
            for (i = 0; i < pReplSum->cSrcs; i++) {
                if (pReplSum->pSrcs[i].szName) {
                    LocalFree(pReplSum->pSrcs[i].szName);
                    pReplSum->pSrcs[i].szName = NULL;
                }
                if (pReplSum->pSrcs[i].szConnectString) {
                    LocalFree(pReplSum->pSrcs[i].szConnectString);
                    pReplSum->pSrcs[i].szConnectString = NULL;
                }
            }
            free(pReplSum->pSrcs);
        }

        // Note the actual *pReplSum is allocated on the stack of ReplSummary()
    }

}

DWORD
ReplPrintEntry(
    REPL_SUM *     pReplSum,
    BY_DEST_REPL * pDc
    )
/*++

Routine Description:

    This function is a very specific function that generates the exact format that
    PSS insisted upon having printed out.  This function is unfortunately not 
    internationalizable/localizable and makes certain assumptions about how time 
    should be displayed.

Arguments:

    pReplSum - The repl summary context block
    pDc - A pointer to the particular DC entry to print assumed to be either
        in pReplSum->pDests or in pReplSum->pSrcs.

Return Value:

    0

--*/
{
    ULONG cchBuffer = 1025;
    WCHAR szBuffer[1024];
    WCHAR szBuff2[20];
    WCHAR * szTemp;
    ULONG iCh;
    ULONG dwPercent;
    BOOL  fPrinting;

    LONGLONG llTime;
    DWORD dwSec, dwMin, dwHr, dwDay, dwTemp;;

    if (pDc->cPartnersInErr == 0) {
        dwPercent = 0;
    } else if (pDc->cPartnersInErr == pDc->cReplPartners) {
        dwPercent = 100;
    } else {
        Assert(pDc->cPartnersInErr < pDc->cReplPartners);
        dwPercent = (ULONG) (((float) pDc->cPartnersInErr) / ((float) pDc->cReplPartners) * 100);
    }

    if (pDc->cReplPartners == 0) {
        // Skip this DC, as we probably had an operation error talking to it.
        Assert(pDc->dwOpError);
        return(0);
    }

    memset(szBuffer, 0, sizeof(szBuffer));

    //
    // Construct a very specific PSS defined buffer
    //

    iCh = 0;
    szBuffer[iCh] = L' '; 
    szBuffer[iCh+1] = L'\0';
    StringCchCatW(szBuffer, cchBuffer, pDc->szName ?
                                                pDc->szName :
                                                L" (unknown)");
    iCh = wcslen(szBuffer);
    for (;iCh < 16; iCh++) {
        Assert(iCh < cchBuffer);
        szBuffer[iCh] = L' '; 
    }
    szBuffer[iCh] = L'\0';
    szBuffer[iCh++] = L' ';
    szBuffer[iCh++] = L' ';

    llTime = pDc->llDelta;
    Assert(llTime >= 0);

    dwSec = (DWORD) (llTime % 60);
    llTime = llTime / 60;
    dwMin = (DWORD) (llTime % 60);
    llTime = llTime / 60;
    dwHr = (DWORD) (llTime % 24);
    llTime = llTime / 24;
    dwDay = (DWORD) llTime;

    fPrinting = FALSE;

    if (pDc->llLastSuccess == 0) {

        // Hmmm, this has sync never succeded, so we don't know the delta
        StringCchCatW(szBuffer, cchBuffer, L"   (unknown)      ");
        iCh = wcslen(szBuffer);
    
    } else if (dwDay > 60) {
        
        // Uh-oh greater than 60 days ...
        StringCchCatW(szBuffer, cchBuffer, L">60 days          ");
        iCh = wcslen(szBuffer);

    } else {

        if (dwDay) {

            dwTemp = dwDay % 10;
            dwDay = dwDay / 10;
            szBuffer[iCh++] = L' ';
            szBuffer[iCh++] = L'0' + (WCHAR) dwDay;
            szBuffer[iCh++] = L'0' + (WCHAR) dwTemp;
            szBuffer[iCh++] = L'd';
            fPrinting = TRUE;

        } else {
            szBuffer[iCh++] = L' ';
            szBuffer[iCh++] = L' ';
            szBuffer[iCh++] = L' ';
            szBuffer[iCh++] = L' ';
        }

        if (dwHr || fPrinting) {
            if (fPrinting) {
                szBuffer[iCh++] = L'.';
            } else {
                szBuffer[iCh++] = L' ';
            }
            dwTemp = dwHr % 10;
            dwHr = dwHr / 10;
            szBuffer[iCh++] = L'0' + (WCHAR) dwHr;
            szBuffer[iCh++] = L'0' + (WCHAR) dwTemp;
            szBuffer[iCh++] = L'h';
            fPrinting = TRUE;
        } else {
            szBuffer[iCh++] = L' ';
            szBuffer[iCh++] = L' ';
            szBuffer[iCh++] = L' ';
            szBuffer[iCh++] = L' ';
        }
        if (dwMin || fPrinting) {
            if (fPrinting) {
                szBuffer[iCh++] = L':';
            } else {
                szBuffer[iCh++] = L' ';
            }
            dwTemp = dwMin % 10;
            dwMin = dwMin / 10;
            szBuffer[iCh++] = L'0' + (WCHAR) dwMin;
            szBuffer[iCh++] = L'0' + (WCHAR) dwTemp;
            szBuffer[iCh++] = L'm';
            fPrinting = TRUE;
        } else {
            szBuffer[iCh++] = L' ';
            szBuffer[iCh++] = L' ';
            szBuffer[iCh++] = L' ';
            szBuffer[iCh++] = L' ';
        }
        if (dwSec || fPrinting) {
            szBuffer[iCh++] = L':';
            dwTemp = dwSec % 10;
            dwSec = dwSec / 10;
            szBuffer[iCh++] = L'0' + (WCHAR) dwSec;
            szBuffer[iCh++] = L'0' + (WCHAR) dwTemp;
            szBuffer[iCh++] = L's';
        } else {
            szBuffer[iCh++] = L' ';
            szBuffer[iCh++] = L' ';
            szBuffer[iCh++] = L'0';
            szBuffer[iCh++] = L's';
        }
        szBuffer[iCh++] = L' ';
        szBuffer[iCh++] = L' ';
    }

    // We're going to reuse dwHr, dwMin, and dwSec as the most 
    // significant to least significant tens.

    // Print Partners in error.
    if (pDc->cPartnersInErr >= 999) {
        dwHr = dwMin = dwSec = 9;
    } else {
        dwHr = pDc->cPartnersInErr / 100;
        dwMin = pDc->cPartnersInErr % 100 / 10;
        dwSec = pDc->cPartnersInErr % 10;
    }
    szBuffer[iCh+2] = L'0' + (WCHAR) dwSec;
    if (dwMin || dwHr) {
        szBuffer[iCh+1] = L'0' + (WCHAR) dwMin;
    } else {
        szBuffer[iCh+1] = L' ';
    }
    if (dwHr) {
        szBuffer[iCh] = L'0' + (WCHAR) dwHr;
    } else {
        szBuffer[iCh] = L' ';
    }
    iCh += 3;

    szBuffer[iCh++] = L' ';
    szBuffer[iCh++] = L'/';
    szBuffer[iCh++] = L' ';

    // print partners
    if (pDc->cReplPartners >= 999) {
        dwHr = dwMin = dwSec = 9;
    } else {
        dwHr = pDc->cReplPartners / 100;
        dwMin = pDc->cReplPartners % 100 / 10;
        dwSec = pDc->cReplPartners % 10;
    }

    szBuffer[iCh+2] = L'0' + (WCHAR) dwSec;
    if (dwMin || dwHr) {
        szBuffer[iCh+1] = L'0' + (WCHAR) dwMin;
    } else {
        szBuffer[iCh+1] = L' ';
    }
    if (dwHr) {
        szBuffer[iCh] = L'0' + (WCHAR) dwHr;
    } else {
        szBuffer[iCh] = L' ';
    }
    iCh += 3;

    szBuffer[iCh++] = L' ';
    szBuffer[iCh++] = L' ';

    // print percentage
    if (dwPercent >= 999) {
        dwHr = dwMin = dwSec = 9;
    } else {
        dwHr = dwPercent / 100;
        dwMin = dwPercent % 100 / 10;
        dwSec = dwPercent % 10;
    }

    szBuffer[iCh+2] = L'0' + (WCHAR) dwSec;
    if (dwMin || dwHr) {
        szBuffer[iCh+1] = L'0' + (WCHAR) dwMin;
    } else {
        szBuffer[iCh+1] = L' ';
    }
    if (dwHr) {
        szBuffer[iCh] = L'0' + (WCHAR) dwHr;
    } else {
        szBuffer[iCh] = L' ';
    }
    iCh += 3;


    szBuffer[iCh++] = L' ';
    szBuffer[iCh++] = L' ';
    szBuffer[iCh] = L'\0';

    if (pDc->dwError) {
        StringCchPrintfW(szBuff2, 20, L"(%lu) ", pDc->dwError);
        StringCchCatW(szBuffer, cchBuffer, szBuff2);
        StringCchCatW(szBuffer, cchBuffer, Win32ErrToString(pDc->dwError));
    }

    if (!gConsoleInfo.bStdOutIsFile &&
        wcslen(szBuffer) >= (ULONG) gConsoleInfo.wScreenWidth) {
        // PSS wants this truncated to screen width if not to file
        dwTemp = gConsoleInfo.wScreenWidth;
        if (dwTemp > 5) {
            // Should always be true.
            szBuffer[dwTemp-1] = L'\0';
            szBuffer[dwTemp-2] = L'.';
            szBuffer[dwTemp-3] = L'.';
            szBuffer[dwTemp-4] = L'.';
        }
    }
    PrintMsg(REPADMIN_PRINT_STR, szBuffer);

    return(0);
}

//
// Couple global variables for controlling the ReplSumSort() sorter 
// function passed to qsort().
//
enum {
    eName,
    eDelta,
    ePartners,
    eFailCount,
    eError,
    eFailPercent,
    eUnresponsive
} geSorter;
BY_DEST_REPL * gpSortDcs = NULL;

int __cdecl
ReplSumSort(
    const void * pFirst, 
    const void * pSecond
    )
/*++

Routine Description:

    Sorting function for passing to qsort().

Arguments:

    pFirst  - pointer to an int that indexes into the array of gpSortDcs
    pSecond - pointer to an int that indexes into the array of gpSortDcs.

    ----- global arguments too ----- MAKE SURE YOU SET
             
    gpSortDcs - The array of DCs to sort, the pFirst/pSecond variables
        will be assumed to be pointers into this array.
    geSorter - Used to determine what field in the DC entries to sort by.

Return Value:

    <0  if pFirst is "less than" pSecond
    0   if pFirst is "equal to" pSecond
    >0  if pFirst is "more than" pSecond

--*/
{
    ULONG dwP1, dwP2;
    int ret = 0;

    if (gpSortDcs == NULL ||
        pFirst == NULL ||
        pSecond == NULL) {
        Assert(!"Invalid paramter to the qsort ReplSumSort() function");
        exit(1);
    }

    switch (geSorter) {
    
    case eName:
        if (gpSortDcs[*(ULONG*)pFirst].szName == NULL &&
            gpSortDcs[*(ULONG*)pSecond].szName == NULL) {
            ret = 0;
        } else if (gpSortDcs[*(ULONG*)pFirst].szName == NULL) {
            ret = -1;
        } else if (gpSortDcs[*(ULONG*)pSecond].szName == NULL) {
            ret = 1;
        } else {
            ret = _wcsicmp( gpSortDcs[*(ULONG*)pFirst].szName, gpSortDcs[*(ULONG*)pSecond].szName );
        }
        break;

    case eDelta:
        ret = (int) (gpSortDcs[*(ULONG*)pSecond].llDelta - gpSortDcs[*(ULONG*)pFirst].llDelta);
        break;

    case eFailCount:
        ret = gpSortDcs[*(ULONG*)pSecond].cPartnersInErr - gpSortDcs[*(ULONG*)pFirst].cPartnersInErr;
        break;

    case ePartners:
        ret = gpSortDcs[*(ULONG*)pFirst].cReplPartners - gpSortDcs[*(ULONG*)pSecond].cReplPartners;
        break;
    
    case eError:
        ret = gpSortDcs[*(ULONG*)pSecond].dwError - gpSortDcs[*(ULONG*)pFirst].dwError;
        break;

    case eFailPercent:
        if (gpSortDcs[*(ULONG*)pFirst].cPartnersInErr == 0) {
            dwP1 = 0;
        } else if (gpSortDcs[*(ULONG*)pFirst].cPartnersInErr == gpSortDcs[*(ULONG*)pFirst].cReplPartners) {
            dwP1 = 100;
        } else {
            dwP1 = (ULONG) (((float) gpSortDcs[*(ULONG*)pFirst].cPartnersInErr) / ((float) gpSortDcs[*(ULONG*)pFirst].cReplPartners) * 100);
        }
        if (gpSortDcs[*(ULONG*)pSecond].cPartnersInErr == 0) {
            dwP2 = 0;
        } else if (gpSortDcs[*(ULONG*)pSecond].cPartnersInErr == gpSortDcs[*(ULONG*)pSecond].cReplPartners) {
            dwP2 = 100;
        } else {
            dwP2 = (ULONG) (((float) gpSortDcs[*(ULONG*)pSecond].cPartnersInErr) / ((float) gpSortDcs[*(ULONG*)pSecond].cReplPartners) * 100);
        }
        ret = dwP1 - dwP2;
        break;

    case eUnresponsive:
        ret = gpSortDcs[*(ULONG*)pSecond].dwOpError - gpSortDcs[*(ULONG*)pFirst].dwOpError;
        break;

    default:
        Assert(!"Unknown sort type?!");
        exit(1);
    }

    return(ret);
}

int 
ReplSummary(
    int argc, 
    LPWSTR argv[]
    )
/*++

Routine Description:

    The function that maps the repadmin /replsummary command.  This function
    takes and parese it's own DC_LIST argument so it can accumulate all the
    information for a set of DCs.

Arguments:

    argc - number of command line arguments
    argv - array of arguments to command

Return Value:

    Win32

--*/
{
    #define     REPL_SUM_INIT_GUESS   10
    HANDLE      hDS = NULL;
    LDAP *      hLdap = NULL;
    int         ret, iArg, err;
    int         iDsaArg = 0;
    PDC_LIST    pDcList = NULL;
    WCHAR *     szDsa = NULL;
    REPL_SUM    ReplSummary = { 0 };
    BOOL        fPickBest = FALSE;
    WCHAR *     szTemp;
    ULONG       i, dwTemp;
    ULONG *     piSortedDests;
    ULONG *     piSortedSrcs;
    CHAR        szTime[SZDSTIME_LEN];
    ULONG       cDots;


    if (argc < 2) {
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // 0) Parse command line arguments
    //
    // repadmin /replsum /bysrc /bydest /errorsonly
    //      /sort:[name|delta|partners|failures|error|percent]

    for (iArg = 2; iArg < argc; iArg++) {
        if (wcsequal(argv[iArg], L"/bysrc")) {
            ReplSummary.fBySrc = TRUE;
        } else if (wcsequal(argv[iArg], L"/bydest") ||
                 wcsequal(argv[iArg], L"/bydst")) {
            ReplSummary.fByDest = TRUE;
        } else if (wcsequal(argv[ iArg ], L"/errorsonly")) {
            ReplSummary.fErrorsOnly = TRUE;
        } else if (wcsprefix(argv[ iArg ], L"/sort:")) {
            szTemp = wcschr(argv[iArg], L':');
            if (szTemp == NULL ||
                *(szTemp+1) == L'\0') {
                PrintMsg(REPADMIN_GENERAL_INVALID_ARGS);
                return(ERROR_INVALID_PARAMETER);
            }
            szTemp++;
            if (wcsequal(szTemp, L"name")) {
                geSorter = eName;
            } else if (wcsequal(szTemp, L"delta")) {
                geSorter = eDelta;
            } else if (wcsequal(szTemp, L"partners")) {
                geSorter = ePartners;
            } else if (wcsequal(szTemp, L"failures")) {
                geSorter = eFailCount;
            } else if (wcsequal(szTemp, L"error")) {
                geSorter = eError;
            } else if (wcsequal(szTemp, L"percent") ||
                       wcsequal(szTemp, L"per")) {
                geSorter = eFailPercent;
            } else if (wcsequal(szTemp, L"unresponsive")) {
                geSorter = eUnresponsive;
            } else {
                // Unknown sort option "szTemp".
                PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, szTemp);
                return(ERROR_INVALID_PARAMETER);
            }
        }  else if (iDsaArg == 0) {
            iDsaArg = iArg;
        } else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (!ReplSummary.fBySrc && !ReplSummary.fByDest) {
        // If user didn't specify whether they wanted us to collect our
        // information by source or by destination we'll collect both,
        // and decide at the end which makes the most sense to print.
        ReplSummary.fBySrc = TRUE;
        ReplSummary.fByDest = TRUE;
        fPickBest = TRUE;
    }

    __try {

        //
        // 1) Initilize ReplSummary and print initial start time.
        //
        // Init ReplSummary Dest and Src lists with REPL_SUM_INIT_GUESS
        ReplSummary.pDests = malloc(sizeof(BY_DEST_REPL) * REPL_SUM_INIT_GUESS);
        memset(ReplSummary.pDests, 0, sizeof(BY_DEST_REPL) * REPL_SUM_INIT_GUESS);
        ReplSummary.pSrcs = malloc(sizeof(BY_DEST_REPL) * REPL_SUM_INIT_GUESS);
        memset(ReplSummary.pSrcs, 0, sizeof(BY_DEST_REPL) * REPL_SUM_INIT_GUESS);
        if (ReplSummary.pDests == NULL || ReplSummary.pSrcs == NULL) {
            err = GetLastError();
            CHK_ALLOC(0);
            __leave;
        }
        ReplSummary.cDestsAllocd = REPL_SUM_INIT_GUESS;
        ReplSummary.cSrcsAllocd = REPL_SUM_INIT_GUESS;
        // Set and print the start time
        ReplSummary.llStartTime = GetSecondsSince1601();;

        PrintMsg(REPADMIN_REPLSUM_START_TIME, 
                 DSTimeToDisplayString(ReplSummary.llStartTime, szTime));
        PrintMsg(REPADMIN_PRINT_CR);

        //
        // 2) Parse the DC_LIST argument.
        //
        // iDsaArg is the DC_LIST if iDsaArg != 0, else we'll use * to 
        // summarize the replication over all partners.
        err = DcListParse(iDsaArg ? argv[iDsaArg] : L"*", &pDcList);
        if (err) {
            // If we fail to even parse the command, lets just fall_back to
            // the command as is.
            PrintMsg(REPADMIN_XLIST_UNPARSEABLE_DC_LIST, iDsaArg ? argv[iDsaArg] : L".");
            xListClearErrors();
            return(err);
        }
        Assert(pDcList);

        //
        // 3) Begin enumeration of the DC_LIST argument.
        //
        err = DcListGetFirst(pDcList, &szDsa);

        while ( err == ERROR_SUCCESS && szDsa ) {

            if (pDcList->cDcs == 1) {                                        
                // On first one print header ...
                PrintMsg(REPADMIN_REPLSUM_START_COLLECTING);
                cDots = 4;
            } else {
                if (cDots >= 50) { // only 50 dots per line.
                    PrintMsg(REPADMIN_PRINT_CR);
                    PrintMsg(REPADMIN_PRINT_STR_NO_CR, L"  ");
                    cDots = 0;
                }
                PrintMsg(REPADMIN_PRINT_DOT_NO_CR);
                cDots++;
            }

            //
            // 4) Actually collect some information ...
            //
            
            ReplSummary.pCurDsa = ReplSummaryAddDest(szDsa, &hLdap, &ReplSummary);
            Assert(ReplSummary.pCurDsa);
            if (ReplSummary.pCurDsa->dwOpError) {
                goto NextDsa;
            }

            err = RepadminDsBind(szDsa, &hDS);
            if (ERROR_SUCCESS != err) {
                ReplSummary.pCurDsa->dwOpError = err;
                goto NextDsa;
            }

            // Aside pszNC would be an improvement to specify specific NC.
            ret = IterateNeighbors(hDS, NULL, NULL, IS_REPS_FROM, ReplSummaryAccumulate, &ReplSummary);
            if (ret) {
                ReplSummary.pCurDsa->dwOpError = ret;
            }

            // We skip errors from the command and continue, command should've
            // printed out an appropriate error message.

          NextDsa:
            //
            // 5) Continue enumeration of the DC_LIST argument.
            //
            if (hLdap) {
                RepadminLdapUnBind(&hLdap);
                hLdap = NULL;
            }
            if (hDS) {
                DsUnBind(hDS);
                hDS = NULL;
            }
            xListFree(szDsa);
            szDsa = NULL;
            err = DcListGetNext(pDcList, &szDsa);

        }
        Assert(szDsa == NULL);

        //
        // 6) Print errors if any and clean up xList errors.
        //
        if (err) {
            RepadminPrintDcListError(err);
            xListClearErrors();
        }
        PrintMsg(REPADMIN_PRINT_CR);

        
        //
        // 7) Do some post collection processing of the summary info.
        //
        
        // We've gathered all the info, now we need to print it out in
        // the best (or requested) possible manner.
        if (fPickBest) {
            // We want to print BySrc or ByDest for which ever way would
            // print the least number of errors.
            dwTemp = 0; // first use this to count # of error'd destinations
            for (i = 0; i < ReplSummary.cDests; i++) {
                if (ReplSummary.pDests[i].cPartnersInErr > 0) {
                    dwTemp++;
                }
            }
            for (i = 0; i < ReplSummary.cSrcs; i++) {
                if (ReplSummary.pSrcs[i].cPartnersInErr > 0) {
                    if (dwTemp == 0) {
                        // This means that by destination is better.
                        ReplSummary.fByDest = TRUE;
                        ReplSummary.fBySrc = FALSE;
                        break;
                    } else {
                        dwTemp--;
                    }
                }
            }
            if (dwTemp > 0) {
                // This means by src is better.
                ReplSummary.fByDest = FALSE;
                ReplSummary.fBySrc = TRUE;
            }
        }
        
        // Do sorting of our DC arrays, by the requested method. geSorter was 
        // set during command line argument processing.
        if (ReplSummary.fByDest) {
            gpSortDcs = ReplSummary.pDests;

            piSortedDests = LocalAlloc(LPTR, sizeof(ULONG) * ReplSummary.cDests);
            CHK_ALLOC(piSortedDests);
            for (i = 0; i < ReplSummary.cDests; i++) {
                piSortedDests[i] = i;
            }
            qsort(piSortedDests, 
                  ReplSummary.cDests, 
                  sizeof(ULONG),
                  ReplSumSort);
        }
        if (ReplSummary.fBySrc) {
            gpSortDcs = ReplSummary.pSrcs;

            piSortedSrcs = LocalAlloc(LPTR, sizeof(ULONG) * ReplSummary.cSrcs);
            CHK_ALLOC(piSortedSrcs);
            for (i = 0; i < ReplSummary.cSrcs; i++) {
                piSortedSrcs[i] = i;
            }
            qsort(piSortedSrcs, 
                  ReplSummary.cSrcs, 
                  sizeof(ULONG),
                  ReplSumSort);
        }

        //
        // 8) Finally, actually print it all out.
        //

        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_PRINT_CR);

        // PSS/ITG likes "by source" first
        if (ReplSummary.fBySrc) {

            PrintMsg(REPADMIN_REPLSUM_BY_SRC_HDR);

            for (i = 0; i < ReplSummary.cSrcs; i++) {

                ReplPrintEntry(&ReplSummary, &(ReplSummary.pSrcs[piSortedSrcs[i]]));

            }
        }

        // " 123456789012345  >xxd.xxh:xxm:xxs fails/total  %%%%  error ..."
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_PRINT_CR);

        if (ReplSummary.fByDest) {

            PrintMsg(REPADMIN_REPLSUM_BY_DEST_HDR);

            for (i = 0; i < ReplSummary.cDests; i++) {

                ReplPrintEntry(&ReplSummary, &(ReplSummary.pDests[piSortedDests[i]]));
            
            }
        }

        //
        // Now we're going to print out any operational errors we had.
        //
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_PRINT_CR);
        fPickBest = FALSE; // Reuse fPickBest for whether we've printed the header
        for (i = 0; i < ReplSummary.cDests; i++) {
            if (ReplSummary.pDests[i].dwOpError) {
                if (!fPickBest) {
                    PrintMsg(REPADMIN_REPLSUM_OP_ERRORS_HDR);
                    fPickBest = TRUE;
                }
                PrintMsg(REPADMIN_REPLSUM_OP_ERROR,
                         ReplSummary.pDests[i].dwOpError,
                         ReplSummary.pDests[i].szName ? 
                            ReplSummary.pDests[i].szName :
                            ReplSummary.pDests[i].szConnectString);
            }
        }
        for (i = 0; i < ReplSummary.cSrcs; i++) {
            if (ReplSummary.pSrcs[i].dwOpError) {
                if (!fPickBest) {
                    PrintMsg(REPADMIN_REPLSUM_OP_ERRORS_HDR);
                    fPickBest = TRUE;
                }
                PrintMsg(REPADMIN_REPLSUM_OP_ERROR,
                         ReplSummary.pDests[i].dwOpError,
                         ReplSummary.pDests[i].szName ? 
                            ReplSummary.pDests[i].szName :
                            ReplSummary.pDests[i].szConnectString);
            }
        }

    } __finally {

        if (hLdap) {
            RepadminLdapUnBind(&hLdap);
            hLdap = NULL;
        }
        if (hDS) {
            DsUnBind(hDS);
            hDS = NULL;
        }
        ReplSumFree(&ReplSummary);
        DcListFree(&pDcList);
        Assert(pDcList == NULL);
        xListClearErrors(); // just in case ...

    }

    return(ret);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\repism.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repism.c - ISM command functions

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>
#include <ntdsapi.h>

#include "repadmin.h"

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0)


int
ShowBridgeHelp(
    LPWSTR pwzTransportDn,
    LPWSTR pwzSiteDn
    )

/*++

Routine Description:

    Description

Arguments:

    pwzTransportDn -
    pwzSiteDn -

Return Value:

    int -

--*/

{
    ISM_SERVER_LIST * pServerList = NULL;
    DWORD iServer, err;

    err = I_ISMGetTransportServers(pwzTransportDn, pwzSiteDn, &pServerList);

    if (NO_ERROR != err) {
        PrintFuncFailed(L"I_ISMGetTransportServers", err);
        goto cleanup;
    }

    // All this is supposed to be heiarchically printed out under the data for
    // a site.  The CR's seemed unnecessary.
    if (NULL == pServerList) {
//        PrintMsg(REPADMIN_PRINT_CR);
        PrintTabMsg(2, REPADMIN_SHOWISM_ALL_DCS_BRIDGEHEAD_CANDIDATES, pwzSiteDn);
    }
    else {
//            PrintMsg(REPADMIN_PRINT_CR);
        PrintTabMsg(2, REPADMIN_SHOWISM_N_SERVERS_ARE_BRIDGEHEADS,
                    pServerList->cNumServers, 
                    pwzTransportDn,  
                    pwzSiteDn);
        for (iServer = 0; iServer < pServerList->cNumServers; iServer++) {
//            PrintMsg(REPADMIN_PRINT_CR);
            PrintTabMsg(4, REPADMIN_SHOWISM_N_SERVERS_ARE_BRIDGEHEADS_DATA,
                        iServer,
                        pServerList->ppServerDNs[iServer]);
        }
    }

cleanup:
    if (pServerList) {
        I_ISMFree( pServerList );
    }
    return err;
} /* ShowBridgeHelp */


int
ShowIsmHelp(
    LPWSTR pwzTransportDn,
    BOOL fVerbose
    )

/*++

Routine Description:

    Description

Arguments:

    pwzTransportDn -

Return Value:

    int -

--*/

{
    ISM_CONNECTIVITY * pSiteConnect = NULL;
    DWORD iSite1, iSite2, err;


    err = I_ISMGetConnectivity(pwzTransportDn, &pSiteConnect);

    if (NO_ERROR != err) {
        PrintFuncFailedArgs(L"I_ISMGetConnectivity", pwzTransportDn, err);
        goto cleanup;
    }
    if (pSiteConnect == NULL) {
        PrintMsg(REPADMIN_SHOWISM_SITE_CONNECTIVITY_NULL);
        err = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    PrintMsg(REPADMIN_SHOWISM_TRANSPORT_CONNECTIVITY_HDR, 
           pwzTransportDn, pSiteConnect->cNumSites);


    // Check for unreachable sites
    // Note we will report a site that has no servers
    if (pSiteConnect->cNumSites > 1) {
        for (iSite1 = 0; iSite1 < pSiteConnect->cNumSites; iSite1++) {
            for (iSite2 = 0; iSite2 < pSiteConnect->cNumSites; iSite2++) {
                PISM_LINK pLink = &(pSiteConnect->pLinkValues[iSite1 * pSiteConnect->cNumSites + iSite2]);
                // Don't count self reachability
                if (iSite1 == iSite2) {
                    continue;
                }
                if (pLink->ulCost != -1) {
                    break;
                }
            }
            if (iSite2 == pSiteConnect->cNumSites) {
                // Site iSite1 is not connected
                PrintMsg(REPADMIN_SHOWISM_SITE_NOT_CONN, pSiteConnect->ppSiteDNs[iSite1]);
            }
        }
    }

    for (iSite2 = 0; iSite2 < pSiteConnect->cNumSites; iSite2++) {
        PrintMsg(REPADMIN_SHOWISM_SITES_HDR, iSite2 ? L", " : L"     ", iSite2);
    }
    PrintMsg(REPADMIN_PRINT_CR);
    for (iSite1 = 0; iSite1 < pSiteConnect->cNumSites; iSite1++) {

        // First print out the site we are working on
        PrintMsg(REPADMIN_SHOWISM_SITES_HDR_2, iSite1, pSiteConnect->ppSiteDNs[iSite1]);

        // Print out some obscure number iSite times ??? :)
        for (iSite2 = 0; iSite2 < pSiteConnect->cNumSites; iSite2++) {
            PISM_LINK pLink = &(pSiteConnect->pLinkValues[iSite1 * pSiteConnect->cNumSites + iSite2]);

            PrintMsg(REPADMIN_SHOWISM_SITES_DATA, iSite2 ? L", " : L"    ",
                     pLink->ulCost, pLink->ulReplicationInterval, pLink->ulOptions );

        }
        PrintMsg(REPADMIN_PRINT_CR);

        // Print out information about which servers can be bridgeheads.
        err = ShowBridgeHelp( pwzTransportDn, pSiteConnect->ppSiteDNs[iSite1] );

        // If verbose print out the schedule for kicks.
        if (fVerbose) {

            for (iSite2 = 0; iSite2 < pSiteConnect->cNumSites; iSite2++) {
                PISM_LINK pLink = &(pSiteConnect->pLinkValues[iSite1 * pSiteConnect->cNumSites + iSite2]);

                if(iSite1 == iSite2){
                    // Doesn't make much sense to check against our own site, it 
                    // just comes up as 0 cost, connection always available.
                    continue;
                }

                if (pLink->ulCost != 0xffffffff) {
                    ISM_SCHEDULE * pSchedule = NULL;
                    PrintTabMsg(2, REPADMIN_SHOWISM_SCHEDULE_DATA, 
                            pSiteConnect->ppSiteDNs[iSite1],
                            pSiteConnect->ppSiteDNs[iSite2],
                            pLink->ulCost, pLink->ulReplicationInterval );

                    err = I_ISMGetConnectionSchedule(
                        pwzTransportDn,
                        pSiteConnect->ppSiteDNs[iSite1],
                        pSiteConnect->ppSiteDNs[iSite2],
                        &pSchedule);

                    if (NO_ERROR == err) {
                        if (NULL == pSchedule) {
                            PrintTabMsg(4, REPADMIN_SHOWISM_CONN_ALWAYS_AVAIL);
                        }
                        else {
                            printSchedule( pSchedule->pbSchedule, pSchedule->cbSchedule );
                            I_ISMFree( pSchedule );
                            pSchedule = NULL;
                        }
                    }
                    else {
                        PrintFuncFailed(L"I_ISMGetTransportServers", err);
                    }
                }
                
            } // for site 2

        } // if verbose

        // Finally, print out a line return to seperate the sites.
        PrintMsg(REPADMIN_PRINT_CR);

    } // for site 1

cleanup:
    if (pSiteConnect) {
        I_ISMFree( pSiteConnect );
    }

    return err;
} /* ShowIsmHelp */


int
ShowIsm(
    int     argc,
    LPWSTR  argv[]
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    LPWSTR          pwzTransportDn = NULL;
    DWORD           err;
    LDAP *          hld = NULL;
    int             ldStatus;
    LDAPMessage *   pRootResults = NULL;
    LPSTR           rgpszRootAttrsToRead[] = {"configurationNamingContext", NULL};
    LPWSTR *        ppwzConfigNC = NULL;
    BOOL            fVerbose = FALSE;
    ULONG           ulOptions;

    if (argc > 2) {
        if ( (_wcsicmp( argv[argc-1], L"/v" ) == 0) ||
             (_wcsicmp( argv[argc-1], L"/verbose" ) == 0) ) {
            fVerbose = TRUE;
            argc--;
        }
    }

    if (argc == 2) {
        // Connect & bind to target DSA.
        hld = ldap_initW(L"localhost", LDAP_PORT);
        if (NULL == hld) {
            PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE_LOCALHOST);
            return ERROR_DS_UNAVAILABLE;
        }

        // use only A record dns name discovery
        ulOptions = PtrToUlong(LDAP_OPT_ON);
        (void)ldap_set_optionW(hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

        ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
        CHK_LD_STATUS(ldStatus);

        // What's the DN of the config NC?
        ldStatus = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
                                 rgpszRootAttrsToRead, 0, &pRootResults);
        CHK_LD_STATUS(ldStatus);

        ppwzConfigNC = ldap_get_valuesW(hld, pRootResults,
                                        L"configurationNamingContext");
        Assert(NULL != ppwzConfigNC);

        pwzTransportDn = malloc( ( wcslen(*ppwzConfigNC) + 64 ) * sizeof(WCHAR) );
        if (pwzTransportDn == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        wcscpy( pwzTransportDn, L"CN=IP,CN=Inter-Site Transports,CN=Sites," );
        wcscat( pwzTransportDn, *ppwzConfigNC );
        err = ShowIsmHelp( pwzTransportDn, fVerbose );
        wcscpy( pwzTransportDn, L"CN=SMTP,CN=Inter-Site Transports,CN=Sites," );
        wcscat( pwzTransportDn, *ppwzConfigNC );
        err = ShowIsmHelp( pwzTransportDn, fVerbose );
        // Add new inter-site transport here
        // As an improvement, we could enumerate through the whole container.
    } else if (argc == 3 ) {
        // argv[2] is the transport dn
        err = ShowIsmHelp( argv[2], fVerbose );
    } else {
        PrintMsg(REPADMIN_SHOWISM_SUPPLY_TRANS_DN_HELP);
        return ERROR_INVALID_FUNCTION;
    }

    if (pwzTransportDn) {
        free( pwzTransportDn );
    }
    if (ppwzConfigNC) {
        ldap_value_freeW(ppwzConfigNC);
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    if (hld) {
        ldap_unbind(hld);
    }

    return err;
}

int
QuerySites(
    int     argc,
    LPWSTR  argv[]
    )
/*++

Routine Description:

    Bind to an ISTG and call the DsQuerySitesByCost API.
    This API determines the cost from a site to a set of sites.

Arguments:

    <From-Site-Name> <To-Site-Name-1> [ <To-Site-Name-2> ... ]

Return Value:

    None

--*/
{
    #define TIMEOUT     60

    HANDLE              hDS = NULL;
    PDS_SITE_COST_INFO  rgSiteInfo;
    DWORD               err, iSites, cToSites, len;
    LONGLONG            timeBefore, timeAfter, timeFreq;
    PWSTR               str;

    // Ignore first two arguments "repadmin /querysites"
    argc-=2; argv+=2;

    // Check that user at least passed FromSite and one ToSite
    if( argc < 2 ) {
        PrintMsg(REPADMIN_GENERAL_INVALID_ARGS);
        err = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Bind to ISTG
    err = DsBindToISTG( NULL, &hDS );
    if( err ) {
        PrintFuncFailed(L"DsBindToISTG", err);
        goto Cleanup;
    }

    // Set a ten-second timeout
    err = DsBindingSetTimeout( hDS, TIMEOUT );
    if( err ) {
        PrintFuncFailed(L"DsBindingSetTimeout", err);
        goto Cleanup;
    }

    // Execute the query
    cToSites = argc-1;
    err = DsQuerySitesByCostW(
        hDS,            // Binding Handle
        argv[0],        // From Site
        argv+1,         // Array of To Sites
        cToSites,       // Count of To Sites
        0,              // No Flags
        &rgSiteInfo);   // Array of Results
    if( err ) {
        PrintFuncFailed(L"DsQuerySitesByCostW", err);
        goto Cleanup;
    }

    // Print the results
    PrintMsg(REPADMIN_QUERYSITES_OUTPUT_HEADER, argv[0]);

    for( iSites=0; iSites<cToSites; iSites++ ) {

        // Truncate string at 64 characters
        str = argv[iSites+1];
        if( wcslen(str)>64 ) {
            str[64] = 0;
        }

        PrintMsg(REPADMIN_QUERYSITES_OUTPUT_SITENAME, argv[iSites+1]);
        if( ERROR_SUCCESS==rgSiteInfo[iSites].errorCode ) {
            PrintMsg(REPADMIN_QUERYSITES_OUTPUT_COST, rgSiteInfo[iSites].cost);
        } else {
            PrintMsg(REPADMIN_QUERYSITES_OUTPUT_ERROR, rgSiteInfo[iSites].errorCode);
        }
    }
    wprintf(L"\n");

    DsQuerySitesFree( rgSiteInfo );

Cleanup:

    if( hDS ) DsUnBind( &hDS );
    
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\repldap.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repldap.c - ldap based utility functions

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

    09 14 1999 - BrettSh added paged

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>   // byte order funtions
#include <ntldap.h>     // SHOW_DELETED_OID
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#include <ndnc.h>     // Various CorssRef manipulations helper functions.

#include "repadmin.h"

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0 | (0xFFFF & __LINE__))

// Use this macro when the results may be null and you want a result
// consistent with the result being present but empty
#define SAFE_LDAP_FIRST_ENTRY(h, r) (r ? ldap_first_entry( h, r ) : NULL)

// Connection Option Names
// Keep these in sync with ntdsa.h
static WCHAR * ppszNtdsConnOptionNames[] = {
    L"isGenerated",
    L"twowaySync",
    L"overrideNotifyDefault",
    L"useNotify",
    L"disableIntersiteCompression",
    L"userOwnedSchedule",
    NULL
};

// Kcc Reason Names
// Keep these in sync with kccconn.hxx
static WCHAR * ppszKccReasonNames[] = {
    L"GCtopology",
    L"RingTopology",
    L"MinimizeHopsTopology",
    L"StaleServersTopology",
    L"OscillatingConnectionTopology",
    L"GCTopology",
    L"IntersiteTopology",
    L"ServerFailoverTopology",
    L"SiteFailoverTopology",
    L"RedundantServerTopology",
    NULL
};

// Transport Guid Cache
static GUID_CACHE_ENTRY grgCachedTrns[5];
static DWORD gcCachedTrns = 0;

// Dsa Guid Cache
// FUTURE-2002/05/20-BrettSh This could be improved, it's kind of lazy
// to just make a global array of 1000 entries, this array takes up at
// least 280K out of the memory footprint of about 3 MBs!
static DSA_CACHE_ENTRY grgCachedDsas[1000];
static DWORD gcCachedDsas = 0;

// ShowIstg function types
typedef enum _SHOW_ISTG_FUNCTION_TYPE {
    SHOW_ISTG_PRINT,
    SHOW_ISTG_LATENCY,
    SHOW_ISTG_BRIDGEHEADS
} SHOW_ISTG_FUNCTION_TYPE;

DWORD
GetNativeReplDsaSignatureVec(
    REPL_DSA_SIGNATURE_VECTOR *         pSigVec,
    DWORD                               cbSigVec,
    DWORD *                             pdwVersion,
    REPL_DSA_SIGNATURE_VECTOR_NATIVE *  pNativeSigVec,
    DWORD *                             pcbNativeSigVec
    )
/*++

Routine Description:

    This converts the version of the vector stored on the DSA object 
    (either REPL_DSA_SIGNATURE_VECTOR || REPL_DSA_SIGNATURE_VECTOR_OLD
    at this writing) to a pdwVersion and a pure vector
    REPL_DSA_SIGNATURE_VECTOR_NATIVE (which should always be typedefed
    to the lastest version of the vector, which as of this writing
    is REPL_DSA_SIGNATURE_VECTOR_V1.
    
    This allows us to avoid non-portable xxx->V1 labels in code, and
    just use the vector as is, if no pre-existing field names change,
    as long as someone consistently updates this to handle older 
    versions.

Arguments:

    pSigVec - the binary blob pulled off the DSA object for the 
        "retiredReplDSASignatures" attribute.
    cbSigVec - the length of the pSigVec.  There is required to
        accurately determine the version.
        
    pdwVersion - the original version.  1 for _V1, 0, for oldest,
        -1 for a version we don't recognize.
        
    pNativeSigVec - Buffer to hold the converted vector.  This is
        a typedev so update this code and the typedev is all that
        should be required to add a version of the DSA signature.
        caller should allocate this buffer.
    pcbNativeSigVec - Length of the buffer to hold the converted 
        vector.  If not enough buffer is provided, then we'll store
        the required buffer size in here and return an error.

Return Value:

    Returns one of 3 Win32 values:
        ERROR_INVALID_PARAMETER - Unknown DSA Signature version.
        ERROR_DS_USER_BUFFER_TO_SMALL - pNativeSigVec not big enough.
        ERROR_SUCCESS - Successfully converted pSigVec to pNativeSigVec.

--*/
{
    REPL_DSA_SIGNATURE_VECTOR_OLD * pOldVec;
    DWORD cbNeeded;
    ULONG i;

    Assert(pSigVec && cbSigVec);
    Assert(pdwVersion && pcbNativeSigVec);

    // Crack the version of the retired DSA signature -

    // In the oldest version (win2k beta3) there was no version, 
    // and the number of signatures was where the version is now. 
    // So for each case/version the size of the vector must  be 
    // right, otherwise we can assume that this vector is a
    // (future) version we've never seen.

    if (1 == pSigVec->dwVersion &&
        cbSigVec == ReplDsaSignatureVecV1Size(pSigVec)) {

        *pdwVersion = 1;

        // Note: that since the original version (Win2k Beta3) didn't
        // have a version each new clause, must be like this first
        // clause and check that the cbSigVec size is right. Ex:
        // } else if (2 == pSigVec->dwVersion &&
        //           cbSigVec == ReplDsaSignatureVecV2Size(pSigVec)) {
        //    *pdwVersion = 2;

    } else if (cbSigVec == ReplDsaSignatureVecOldSize((REPL_DSA_SIGNATURE_VECTOR_OLD *)pSigVec)){
        
        *pdwVersion = 0; // 0 for old win2k beta 3.

    } else {

        // Unknown future version of the vector.
        *pdwVersion = -1; // unknown version.
        return(ERROR_INVALID_PARAMETER);

    }

    Assert(*pdwVersion == 1);

    // This gets a size that is 1 dword too much, but tis OK with me.
    // This is because we're just returning the vector VX, not the 
    // vector struct with the dwVersion
    cbNeeded = (*pdwVersion) ? 
                        ReplDsaSignatureVecV1Size(pSigVec) :
                        ReplDsaSignatureVecOldSize((REPL_DSA_SIGNATURE_VECTOR_OLD *)pSigVec);
    if (pNativeSigVec == NULL || *pcbNativeSigVec < cbNeeded ) {
        *pcbNativeSigVec = cbNeeded; // Return size needed for pNativeSigVec if need more buffer.
        return(ERROR_DS_USER_BUFFER_TO_SMALL);
    }

    //
    // Do actual conversion
    //
    memset(pNativeSigVec, 0, *pcbNativeSigVec);

    switch (*pdwVersion) {
    case 0:
        Assert(!"We shouldn't be dealing w/ old versions win2k beta3 versions");
        return(ERROR_INVALID_PARAMETER);
    case 1:
        // Native version, simply copy parts.
        pNativeSigVec->cNumSignatures = pSigVec->V1.cNumSignatures;
        memcpy(pNativeSigVec->rgSignature, 
               pSigVec->V1.rgSignature, 
               sizeof(REPL_DSA_SIGNATURE_V1) * pNativeSigVec->cNumSignatures);
        break;
    default:
        Assert(!"Should've failed in the version cracking code above");
        return(ERROR_INVALID_PARAMETER);
        break;
    }

    // Successfully converted pSigVec to pNativeSigVec!
    return(ERROR_SUCCESS);
}

DWORD
RepadminGetNativeDsaSigVec(
    IN  LDAP *          hld,
    LDAPMessage *       pEntry,
    REPL_DSA_SIGNATURE_VECTOR_NATIVE ** ppNativeDsaSigVec
    )
/*++

Routine Description:

    This retrieves the DSA signature vector from the DSA
    object located by pEntry, and then converts the stored
    blob to the latest version of the DSA_SIGNATURE_VECTOR.

Arguments:

    hld - LDAP Handle
    pEntry - LDAPMessage Entry located on the DSA object you
        want the DSA Signature Vector of.
    ppNativeDsaSigVec - A LocalAlloc()'d buffer of DSA Sig Vec.

Return Value:

    Returns one of 3 Win32 values:
        ERROR_SUCCESS - all's cool
        ERROR_NOT_ENOUGH_MEMORY - allocation failure.
        ERROR_INVALID_PARAMETER - unrecognized version.

--*/
{

    REPL_DSA_SIGNATURE_VECTOR_NATIVE *  pNativeSigVec = NULL;
    DWORD                               cbNativeSigVec = 0;
    DWORD                               dwOrigVersion = 0;
    DWORD                               ret;
    REPL_DSA_SIGNATURE_VECTOR *         pSigVec = NULL;
    DWORD                               cbSigVec = 0;
    struct berval **                    ppbvRetiredDsaSig;

    Assert(ppNativeDsaSigVec);
    *ppNativeDsaSigVec = NULL;

    //
    // First get the actual vector of DSA object.
    //
    ppbvRetiredDsaSig = ldap_get_values_lenW(hld, pEntry, L"retiredReplDSASignatures");
    if (ppbvRetiredDsaSig != NULL) {
        Assert(1 == ldap_count_values_len(ppbvRetiredDsaSig));
        cbSigVec = ppbvRetiredDsaSig[0]->bv_len;
        pSigVec = (REPL_DSA_SIGNATURE_VECTOR *)ppbvRetiredDsaSig[0]->bv_val;
    }

    if (pSigVec == NULL || cbSigVec == 0) {
        // Great empty DSA Signature Vector.
        return(ERROR_SUCCESS);
    }

    //
    // Second, get size and allocate memory for the converted vector
    //
    ret = GetNativeReplDsaSignatureVec(pSigVec, cbSigVec, &dwOrigVersion, NULL, &cbNativeSigVec);
    if (ret == ERROR_INVALID_PARAMETER) {
        // unknown version, return empty signature list
        Assert(dwOrigVersion != 1); // wait this function knows version 1.
        ldap_value_free_len(ppbvRetiredDsaSig);
        return(ret);
    }
    Assert(ret == ERROR_DS_USER_BUFFER_TO_SMALL);
    pNativeSigVec = LocalAlloc(LMEM_FIXED, cbNativeSigVec);
    if (pNativeSigVec == NULL) {
        // Hmmm, not enough memory but only for caching guids, guess go on and return NULL.
        ldap_value_free_len(ppbvRetiredDsaSig);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Third, actually get the converted vector
    //
    ret = GetNativeReplDsaSignatureVec(pSigVec, cbSigVec, &dwOrigVersion, pNativeSigVec, &cbNativeSigVec);
    Assert(ret == 0);
    *ppNativeDsaSigVec = pNativeSigVec;

    ldap_value_free_len(ppbvRetiredDsaSig);
    return(ERROR_SUCCESS);
}

void
CacheDsaInfo(
    IN  LPWSTR  pszSite,
    IN  LPWSTR  pszServer,
    IN  GUID *  pDsaGuid,
    IN  GUID *  pInvocId,
    IN  REPL_DSA_SIGNATURE_VECTOR_NATIVE *  pDsaSigVec
    )
{
    if (gcCachedDsas < ARRAY_SIZE(grgCachedDsas)) {
        grgCachedDsas[gcCachedDsas].DsaGuid = *pDsaGuid;
        grgCachedDsas[gcCachedDsas].InvocId = *pInvocId;
        grgCachedDsas[gcCachedDsas].pDsaSigVec = pDsaSigVec;
        _snwprintf(grgCachedDsas[gcCachedDsas].szDisplayName,
                   ARRAY_SIZE(grgCachedDsas[gcCachedDsas].szDisplayName),
                   L"%ls\\%ls",
                   pszSite,
                   pszServer);
        grgCachedDsas[gcCachedDsas].szDisplayName[
            ARRAY_SIZE(grgCachedDsas[gcCachedDsas].szDisplayName) - 1] = '\0';
        gcCachedDsas++;
    }
}

void
CacheTransportGuid(
    IN  GUID *  pGuid,
    IN  LPWSTR  pszTransport
    )
{
    if (gcCachedTrns < ARRAY_SIZE(grgCachedTrns)) {
        grgCachedTrns[gcCachedTrns].Guid = *pGuid;
        _snwprintf(grgCachedTrns[gcCachedTrns].szDisplayName,
                   ARRAY_SIZE(grgCachedTrns[gcCachedTrns].szDisplayName),
                   L"%ls",
                   pszTransport);
        grgCachedTrns[gcCachedTrns].szDisplayName[
            ARRAY_SIZE(grgCachedTrns[gcCachedTrns].szDisplayName) - 1] = '\0';

        gcCachedTrns++;
    } else {
        Assert(!"There are more than 2 transports?!");
    }
}


LPWSTR
GetStringizedGuid(
    IN  GUID *  pGuid
    )
{
    LPWSTR        pszDisplayName = NULL;
    static WCHAR  szDisplayName[40];
    RPC_STATUS    rpcStatus;

    rpcStatus = UuidToStringW(pGuid, &pszDisplayName);
    Assert(0 == rpcStatus);

    if (pszDisplayName) {
        wcscpy(szDisplayName, pszDisplayName);
        RpcStringFreeW(&pszDisplayName);
    } else {
        swprintf(szDisplayName, L"Err%d", rpcStatus);
    }

    return szDisplayName;
}

LPWSTR
GetDsaGuidDisplayName(
    IN  GUID *  pGuid
    )
/*++

   This may return a pointer to a statically allocated buffer, so you can't
   call this twice in one print function, if you want to get correct 
   behaviour.  This routine will need to be improved to take a user specified
   buffer if you want to do this.
   
--*/
{
    LPWSTR  pszDisplayName = NULL;
    WCHAR szRetiredTag [] = L" (retired)";
    static WCHAR szRetiredBuffer[ 1 +  // szDisplayName len + len" (retired)" + L'\0'
                                  (sizeof(grgCachedDsas[0].szDisplayName)/sizeof(grgCachedDsas[0].szDisplayName[0])) +
                                  (sizeof(szRetiredTag)/sizeof(szRetiredTag[0]))]; 
    REPL_DSA_SIGNATURE_VECTOR_NATIVE * pNativeDsaSigVec = NULL;
    REPL_DSA_SIGNATURE_ENTRY_NATIVE  * pCurrDsaSigEntry = NULL;
    REPL_DSA_SIGNATURE_ENTRY_NATIVE  * pBestDsaSigEntry = NULL;
    DSA_CACHE_ENTRY * pBestDsa;
    DWORD   i, j;

    pBestDsa = NULL;
    pBestDsaSigEntry = NULL;

    for (i = 0; (NULL == pszDisplayName) && (i < gcCachedDsas); i++) {
        if (!memcmp(&grgCachedDsas[i].DsaGuid, pGuid, sizeof(GUID))) {
            pszDisplayName = grgCachedDsas[i].szDisplayName;
            break;
        }
        if (!memcmp(&grgCachedDsas[i].InvocId, pGuid, sizeof(GUID))) {
            pszDisplayName = grgCachedDsas[i].szDisplayName;
            break;
        }           

        if (grgCachedDsas[i].pDsaSigVec) {

            // Walk all the retired signatures and see if any of them match
            // the provided guid.
            for (j = 0; j < grgCachedDsas[i].pDsaSigVec->cNumSignatures; j++ ) {
                pCurrDsaSigEntry = &(grgCachedDsas[i].pDsaSigVec->rgSignature[j]);

                if (!memcmp(&(pCurrDsaSigEntry->uuidDsaSignature), pGuid, sizeof(GUID))) {

                    // Guid matches, but not good enough, 
                    //      we need this retired DSA signature to be the earliest sig!
                    
                    if (pBestDsa == NULL) {
                        // No one cached, winner!
                        // Cache the DSA and the signature entry that matched
                        pBestDsa = &(grgCachedDsas[i]);
                        pBestDsaSigEntry = pCurrDsaSigEntry;
                        break;
                    }

                    if (pCurrDsaSigEntry->timeRetired == 0) {
                        // This is a win2k beta3 retired invoc id, winner! ;)
                        // Cache the DSA and the signature entry that matched
                        pBestDsa = &(grgCachedDsas[i]);
                        pBestDsaSigEntry = pCurrDsaSigEntry;
                        break;
                    }

                    if (pCurrDsaSigEntry->timeRetired < pBestDsaSigEntry->timeRetired) {
                        // We have an earlier entry, new winner!
                        Assert(!memcmp(&(pCurrDsaSigEntry->uuidDsaSignature), 
                                       &(pBestDsaSigEntry->uuidDsaSignature),
                                       sizeof(GUID)));
                        // Cache the DSA and the signature entry that matched
                        pBestDsa = &(grgCachedDsas[i]);
                        pBestDsaSigEntry = pCurrDsaSigEntry;
                        break;
                    }

                } // if retired signature matched provided guid.
            } // for each retired signature.
        }
    }

    if (NULL == pszDisplayName) {
        
        // if we didn't find an invocationId w/ that GUID, did we find
        // a retired signature that matched?
        if (pBestDsa) {
            StringCbCopyW(szRetiredBuffer, sizeof(szRetiredBuffer), pBestDsa->szDisplayName);
            StringCbCatW(szRetiredBuffer, sizeof(szRetiredBuffer), szRetiredTag);
            pszDisplayName = szRetiredBuffer;
        } else {
            pszDisplayName = GetStringizedGuid(pGuid);
        }
    }

    return(pszDisplayName);
}

LPWSTR
GetTrnsGuidDisplayName(
    IN  GUID *  pGuid
    )
{
    LPWSTR  pszDisplayName = NULL;
    DWORD   i;

    for (i = 0; (NULL == pszDisplayName) && (i < gcCachedTrns); i++) {
        if (!memcmp(&grgCachedTrns[i].Guid, pGuid, sizeof(GUID))) {
            pszDisplayName = grgCachedTrns[i].szDisplayName;
            break;
        }
    }

    if (NULL == pszDisplayName) {
        Assert(!"What, we should always have all the transports, right!");
        pszDisplayName = GetStringizedGuid(pGuid);
    }

    return pszDisplayName;
}


int
BuildGuidCache(
    IN  LDAP *  hld
    )
{
    static LPWSTR rgpszDsaAttrs[] = {L"objectGuid", L"invocationId", L"retiredReplDSASignatures", NULL};
    static LPWSTR rgpszTransportAttrs[] = {L"objectGuid", NULL};

    int                 lderr;
    LDAPSearch *        pSearch;
    LDAPMessage *       pRootResults = NULL;
    LDAPMessage *       pResults = NULL;
    LDAPMessage *       pEntry;
    LPWSTR *            ppszConfigNC = NULL;
    LPWSTR              pszDN;
    LPWSTR *            ppszRDNs;
    LPWSTR              pszSite;
    LPWSTR              pszServer;
    LPWSTR              pszTransport;
    struct berval **    ppbvDsaGuid;
    struct berval **    ppbvInvocId;
    struct berval **    ppbvGuid;
    GUID *              pGuid;
    ULONG               ulTotalEstimate;
    REPL_DSA_SIGNATURE_VECTOR_NATIVE * pDsaSigVec;

    PrintMsg(REPADMIN_GUIDCACHE_CACHING);

    lderr = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)", NULL,
                          0, &pRootResults);
    CHK_LD_STATUS(lderr);
    if (NULL == pRootResults) {
        lderr = LDAP_NO_RESULTS_RETURNED;
        REPORT_LD_STATUS(lderr);
        goto cleanup;
    }

    ppszConfigNC = ldap_get_valuesW(hld, pRootResults,
                                    L"configurationNamingContext");
    if (ppszConfigNC == NULL) {
        lderr = LDAP_NO_RESULTS_RETURNED;
        REPORT_LD_STATUS(lderr);
        goto cleanup;
    }

    // Cache ntdsDsa guids.
    pSearch = ldap_search_init_pageW(hld,
				     *ppszConfigNC,
				     LDAP_SCOPE_SUBTREE,
				     L"(objectCategory=ntdsDsa)",
				     rgpszDsaAttrs,
				     FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
        REPORT_LD_STATUS(LdapGetLastError());
        goto cleanup;
    }

    lderr = ldap_get_next_page_s(hld,
				 pSearch,
				 0,
				 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
				 &ulTotalEstimate,
				 &pResults);

    while(lderr == LDAP_SUCCESS){
        PrintMsg(REPADMIN_PRINT_DOT_NO_CR);

        for (pEntry = SAFE_LDAP_FIRST_ENTRY(hld, pResults);
	     NULL != pEntry;
	     pEntry = ldap_next_entry(hld, pEntry)) {

	    // Get site & server names.
	    pszDN = ldap_get_dnW(hld, pEntry);
            if (pszDN == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }

	    ppszRDNs = ldap_explode_dnW(pszDN, 1);
            if (ppszRDNs == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                ldap_memfreeW(pszDN);
                continue;
            }
	    Assert(4 < ldap_count_valuesW(ppszRDNs));

	    pszSite = ppszRDNs[3];
	    pszServer = ppszRDNs[1];

        // Get objectGuid and invocationId for DSA
	    ppbvDsaGuid = ldap_get_values_len(hld, pEntry, "objectGuid");
        ppbvInvocId = ldap_get_values_len(hld, pEntry, "invocationId");
        Assert(ppbvDsaGuid && ppbvInvocId && "objectGuid and invocationId should be present");
        
	    // Associate objectGuid, invocationId, and retiredReplDSASignatures
        // with this DSA (pszSite\pszServer).
        CacheDsaInfo(pszSite, 
                     pszServer, 
                     ppbvDsaGuid ? (GUID *) ppbvDsaGuid[0]->bv_val : NULL,
                     ppbvInvocId ? (GUID *) ppbvInvocId[0]->bv_val : NULL,
                     (RepadminGetNativeDsaSigVec(hld, pEntry, &pDsaSigVec), pDsaSigVec) // comma operator useage, to ignore error
                     );

        ldap_value_free_len(ppbvDsaGuid);
        ldap_value_free_len(ppbvInvocId);
	    ldap_value_freeW(ppszRDNs);
	    ldap_memfreeW(pszDN);
	}

	ldap_msgfree(pResults);
	pResults = NULL;

	lderr = ldap_get_next_page_s(hld,
                                     pSearch,
                                     0,
                                     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                     &ulTotalEstimate,
                                     &pResults);
    } // end while more pages to search.
    if(lderr != LDAP_NO_RESULTS_RETURNED){
        REPORT_LD_STATUS(lderr);
        goto cleanup;
    }

    lderr = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(lderr);
    
    PrintMsg(REPADMIN_PRINT_DOT_NO_CR);
    
    // Cache interSiteTransport guids.
    lderr = ldap_search_sW(hld, *ppszConfigNC, LDAP_SCOPE_SUBTREE,
                           L"(objectCategory=interSiteTransport)",
                           rgpszTransportAttrs, 0,
                           &pResults);
    CHK_LD_STATUS(lderr);
    if (NULL == pResults) {
        lderr = LDAP_NO_RESULTS_RETURNED;
	REPORT_LD_STATUS(lderr);	
        goto cleanup;
    }

    for (pEntry = ldap_first_entry(hld, pResults);
         NULL != pEntry;
         pEntry = ldap_next_entry(hld, pEntry)) {
        // Get transport name.
        pszDN = ldap_get_dnW(hld, pEntry);
        if (pszDN == NULL) {
            REPORT_LD_STATUS(LdapGetLastError());	
            continue;
        }

        ppszRDNs = ldap_explode_dnW(pszDN, 1);
        if (ppszRDNs == NULL) {
            REPORT_LD_STATUS(LdapGetLastError());	
            ldap_memfreeW(pszDN);
            continue;
        }
        pszTransport = ppszRDNs[0];

        // Associate objectGuid with this transport.
        ppbvGuid = ldap_get_values_len(hld, pEntry, "objectGuid");
        if (NULL != ppbvGuid) {
            Assert(1 == ldap_count_values_len(ppbvGuid));
            pGuid = (GUID *) ppbvGuid[0]->bv_val;
            CacheTransportGuid(pGuid, pszTransport);
            ldap_value_free_len(ppbvGuid);
        } else {
            Assert( !"objectGuid should have been present" );
        }

        ldap_value_freeW(ppszRDNs);
        ldap_memfreeW(pszDN);
    }

cleanup:

    if (ppszConfigNC) {
        ldap_value_freeW(ppszConfigNC);
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    if (pResults) {
	ldap_msgfree(pResults);
    }
    
    PrintMsg(REPADMIN_PRINT_CR);

    return lderr;
}

int
CheckPropEx(
    WCHAR *     pszTargetDSA,
    UUID        uuidInvocID,
    WCHAR *     pszNC,
    USN         usnOrig
    );

int PropCheck(
    int argc, 
    LPWSTR argv[]
    )
/*++

Routine Description:

    This is the deprecated version of the /CheckProp command.

Arguments:

    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    error from the repadmin cmd.

--*/
{
    int             iArg;
    LPWSTR          pszNC = NULL;
    LPWSTR          pszInvocID = NULL;
    LPWSTR          pszOrigUSN = NULL;
    LPWSTR          pszTargetDSA = NULL;
    UUID            uuidInvocID;
    USN             usnOrig;

    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszNC) {
            pszNC = argv[iArg];
        }
        else if (NULL == pszInvocID) {
            pszInvocID = argv[iArg];
        }
        else if (NULL == pszOrigUSN) {
            pszOrigUSN = argv[iArg];
        }
        else if (NULL == pszTargetDSA) {
            pszTargetDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if ((NULL == pszNC)
        || (NULL == pszInvocID)
        || (NULL == pszOrigUSN)
        || UuidFromStringW(pszInvocID, &uuidInvocID)
        || (1 != swscanf(pszOrigUSN, L"%I64d", &usnOrig))) {
        PrintMsg(REPADMIN_GENERAL_INVALID_ARGS);
        return ERROR_INVALID_FUNCTION;
    }

    if (NULL == pszTargetDSA) {
        pszTargetDSA = L"localhost";
    }

    return(CheckPropEx(pszTargetDSA, uuidInvocID, pszNC, usnOrig));
}

int
CheckProp(
    int argc, 
    LPWSTR argv[]
    )
/*++

Routine Description:

    This is the deprecated version of the /PropCheck command.

Arguments:

    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    error from the repadmin cmd.

--*/
{
    int             iArg;
    LPWSTR          pszNC = NULL;
    LPWSTR          pszInvocID = NULL;
    LPWSTR          pszOrigUSN = NULL;
    LPWSTR          pszTargetDSA = NULL;
    UUID            uuidInvocID;
    USN             usnOrig;

    for (iArg = 2; iArg < argc; iArg++) {

        if (NULL == pszTargetDSA) {
            pszTargetDSA = argv[iArg];
        } 
        // BAS_TODO do we want pszInvocID next hmmm, it kind of goes with the USN...
        else if (NULL == pszNC) {
            pszNC = argv[iArg];
        }
        else if (NULL == pszInvocID) {
            pszInvocID = argv[iArg];
        }
        else if (NULL == pszOrigUSN) {
            pszOrigUSN = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if ((NULL == pszNC)
        || (NULL == pszInvocID)
        || (NULL == pszOrigUSN)
        || UuidFromStringW(pszInvocID, &uuidInvocID)
        || (1 != swscanf(pszOrigUSN, L"%I64d", &usnOrig))) {
        PrintMsg(REPADMIN_GENERAL_INVALID_ARGS);
        return ERROR_INVALID_FUNCTION;
    }

    if (NULL == pszTargetDSA) {
        pszTargetDSA = L"localhost";
    }

    return(CheckPropEx(pszTargetDSA, uuidInvocID, pszNC, usnOrig));
}


int
CheckPropEx(
    WCHAR *     pszTargetDSA,
    UUID        uuidInvocID,
    WCHAR *     pszNC,
    USN         usnOrig
    )
/*++

Routine Description:

    This is the deprecated version of the /PropCheck command.

Arguments:

    argc - # of arguments for this cmd.
    argv - Arguments for the cmd.

Return Value:

    error from the repadmin cmd.

--*/
{
    int             iArg;
    LDAP *          hld;
    LDAPMessage *   pRootResults = NULL;
    LDAPSearch *    pSearch = NULL;
    LDAPMessage *   pResults;
    LDAPMessage *   pDsaEntry;
    int             ldStatus;
    DWORD           ret;
    LPWSTR          pszRootDomainDNSName;
    LPWSTR          rgpszRootAttrsToRead[] = {L"configurationNamingContext", NULL};
    LPWSTR          rgpszDsaAttrs[] = {L"objectGuid", NULL};
    LPWSTR *        ppszConfigNC = NULL;
    LPWSTR          pszFilter = NULL;
    LPWSTR          pszGuidBasedDNSName;
    DWORD           cNumDsas;
    ULONG           ulTotalEstimate;
    ULONG           ulOptions;

    Assert(pszTargetDSA && pszNC && !fNullUuid(&uuidInvocID));

    // Connect & bind to target DSA.
    hld = ldap_initW(pszTargetDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszTargetDSA);
        return ERROR_DS_UNAVAILABLE;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);


    // What's the DNS name of the enterprise root domain?
    ret = GetRootDomainDNSName(pszTargetDSA, &pszRootDomainDNSName);
    if (ret) {
        PrintFuncFailed(L"GetRootDomainDNSName", ret);
        return ret;
    }

    // What's the DN of the config NC?
    ldStatus = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)",
                              rgpszRootAttrsToRead, 0, &pRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    ppszConfigNC = ldap_get_valuesW(hld, pRootResults,
                                    L"configurationNamingContext");
    if (NULL == ppszConfigNC) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }

    // Find all DCs that hold a read-only or writeable copy of the target NC.
#define ALL_DSAS_WITH_NC_FILTER L"(& (objectCategory=ntdsDsa) (|(hasMasterNCs=%ls) (msDS-HasMasterNCs=%ls) (hasPartialReplicaNCs=%ls)))"
    pszFilter = malloc(sizeof(WCHAR) * (1 + wcslen(ALL_DSAS_WITH_NC_FILTER) + 3*wcslen(pszNC)));

    if (NULL == pszFilter) {
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    swprintf(pszFilter, ALL_DSAS_WITH_NC_FILTER, pszNC, pszNC, pszNC);

    CHK_LD_STATUS(ldStatus);
    pSearch = ldap_search_init_pageW(hld,
				    *ppszConfigNC,
				    LDAP_SCOPE_SUBTREE,
				    pszFilter,
				    rgpszDsaAttrs,
				    FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
	REPORT_LD_STATUS(LdapGetLastError());
        goto cleanup;
    }
		
    pszGuidBasedDNSName = malloc(sizeof(WCHAR) * (100 + wcslen(pszRootDomainDNSName)));
    if (NULL == pszGuidBasedDNSName) {
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ldStatus = ldap_get_next_page_s(hld,
				     pSearch,
				     0,
				     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
				     &ulTotalEstimate,
				     &pResults);
    if(ldStatus == LDAP_NO_RESULTS_RETURNED){
        PrintMsg(REPADMIN_SYNCALL_NO_INSTANCES_OF_NC);
        return ERROR_NOT_FOUND;
    }

    while(ldStatus == LDAP_SUCCESS){

	for (pDsaEntry = SAFE_LDAP_FIRST_ENTRY(hld, pResults);
	     NULL != pDsaEntry;
	     pDsaEntry = ldap_next_entry(hld, pDsaEntry)) {
	    struct berval **  ppbvGuid;
	    LPWSTR            pszGuid;
	    LPWSTR            pszDsaDN;
	    HANDLE            hDS;
	    DS_REPL_CURSORS * pCursors;
	    DWORD             iCursor;
	
	    // Display DSA name (e.g., "Site\Server").
	    pszDsaDN = ldap_get_dnW(hld, pDsaEntry);
            if (pszDsaDN) {
                PrintMsg(REPADMIN_PROPCHECK_DSA_COLON_NO_CR,
                         GetNtdsDsaDisplayName(pszDsaDN));
                ldap_memfreeW(pszDsaDN);
            }

	    // Derive DSA's GUID-based DNS name.
	    ppbvGuid = ldap_get_values_len(hld, pDsaEntry, "objectGuid");
	    if (NULL != ppbvGuid) {
                Assert(1 == ldap_count_values_len(ppbvGuid));

                UuidToStringW((GUID *) (*ppbvGuid)->bv_val,
                              &pszGuid);
                swprintf(pszGuidBasedDNSName, L"%ls._msdcs.%ls",
                         pszGuid, pszRootDomainDNSName);

                RpcStringFreeW(&pszGuid);
                ldap_value_free_len(ppbvGuid);
            } else {
                Assert( !"objectGuid should have been present" );
            }

	    // DsBind() to DSA.
	    ret = RepadminDsBind(pszGuidBasedDNSName, &hDS);
	    if (ret) {
                PrintBindFailed(pszGuidBasedDNSName, ret);
		continue;
	    }

	    // Retrieve up-to-dateness vector.
	    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_CURSORS_FOR_NC, pszNC, NULL,
				    &pCursors);
	    if (ERROR_SUCCESS != ret) {
                PrintFuncFailed(L"DsReplicaGetInfo", ret);
		DsUnBind(&hDS);
		continue;
	    }

	    // Check cursor for propagation.
	    for (iCursor = 0; iCursor < pCursors->cNumCursors; iCursor++) {
            if (0 == memcmp(&pCursors->rgCursor[iCursor].uuidSourceDsaInvocationID,
				&uuidInvocID,
				sizeof(UUID))) {
                    if(pCursors->rgCursor[iCursor].usnAttributeFilter >= usnOrig){
                        PrintMsg(REPADMIN_PRINT_YES);
                    } else {
                        PrintMsg(REPADMIN_PRINT_NO_NO);
                    }
                    PrintMsg(REPADMIN_PROPCHECK_USN, 
                             pCursors->rgCursor[iCursor].usnAttributeFilter);
                    break;
            }
        }

	    if (iCursor == pCursors->cNumCursors) {
                PrintMsg(REPADMIN_PRINT_NO_NO);
                PrintMsg(REPADMIN_PRINT_SPACE);
                PrintMsg(REPADMIN_PROPCHECK_NO_CURSORS_FOUND);
	    }

	    DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors);
	    DsUnBind(&hDS);
	} // end for each entry in a single results page.

	ldap_msgfree(pResults);
	pResults = NULL;
	
	ldStatus = ldap_get_next_page_s(hld,
					 pSearch,
					 0,
					 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					 &ulTotalEstimate,
					 &pResults);
    }
    if(ldStatus != LDAP_NO_RESULTS_RETURNED){
	REPORT_LD_STATUS(ldStatus);
        goto cleanup;
    }

    ldStatus = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(ldStatus);

cleanup:

    if (pszFilter) {
        free(pszFilter);
    }

    if (ppszConfigNC) {
        ldap_value_freeW(ppszConfigNC);
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    ldap_unbind(hld);

    return 0;
}

int
GetDsaOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszDsaDN,
    OUT int *   pnOptions
    )
{
    int             ldStatus;
    LDAPMessage *   pldmServerResults = NULL;
    LDAPMessage *   pldmServerEntry;
    LPWSTR          rgpszServerAttrsToRead[] = {L"options", NULL};
    LPSTR *         ppszOptions;
    int             nOptions;

    ldStatus = ldap_search_sW(hld,
                              pszDsaDN,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgpszServerAttrsToRead,
                              0,
                              &pldmServerResults);
    if (ldStatus) {
        REPORT_LD_STATUS(LdapGetLastError()); 
	if (pldmServerResults) {
	    ldap_msgfree(pldmServerResults);
	}
        return ldStatus;
    }
    if (NULL == pldmServerResults) {
        REPORT_LD_STATUS(LDAP_NO_RESULTS_RETURNED);	
        return LDAP_NO_RESULTS_RETURNED;
    }

    pldmServerEntry = ldap_first_entry(hld, pldmServerResults);
    Assert(NULL != pldmServerEntry);

    // Parse current options.
    ppszOptions = ldap_get_values(hld, pldmServerEntry, "options");
    if (NULL == ppszOptions) {
        *pnOptions = 0;
    }
    else {
        *pnOptions = atoi(ppszOptions[0]);
        ldap_value_free(ppszOptions);
    }

    ldap_msgfree(pldmServerResults);

    return 0;
}

int
SetDsaOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszDsaDN,
    IN  int     nOptions
    )
{
    int         ldStatus;
    WCHAR       szOptionsValue[20];
    LPWSTR      rgpszOptionsValues[] = {szOptionsValue, NULL};
    LDAPModW    ModOpt = {LDAP_MOD_REPLACE, L"options", rgpszOptionsValues};
    LDAPModW *  rgpMods[] = {&ModOpt, NULL};

    swprintf(szOptionsValue, L"%d", nOptions);

    ldStatus = ldap_modify_sW(hld, pszDsaDN, rgpMods);

    return ldStatus;
}

int
Options(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    LPWSTR          pszDSA = NULL;
    LDAP *          hld;
    int             iArg;
    int             ldStatus;
    LDAPMessage *   pldmRootResults = NULL;
    LDAPMessage *   pldmRootEntry;
    LPSTR           rgpszRootAttrsToRead[] = {"dsServiceName", NULL};
    LPWSTR *        ppszServerNames;
    int             nOptions;
    int             nAddOptions = 0;
    int             nRemoveOptions = 0;
    int             nBit;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if ((argv[iArg][0] == '+') || (argv[iArg][0] == '-')) {
            // Options to change.
            if (!_wcsicmp(&argv[iArg][1], L"IS_GC")) {
                nBit = NTDSDSA_OPT_IS_GC;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"DISABLE_INBOUND_REPL")) {
                nBit = NTDSDSA_OPT_DISABLE_INBOUND_REPL;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"DISABLE_OUTBOUND_REPL")) {
                nBit = NTDSDSA_OPT_DISABLE_OUTBOUND_REPL;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"DISABLE_NTDSCONN_XLATE")) {
                nBit = NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE;
            }
            else {
                PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
                return ERROR_INVALID_FUNCTION;
            }

            if (argv[iArg][0] == '+') {
                nAddOptions |= nBit;
            }
            else {
                nRemoveOptions |= nBit;
            }
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (0 != (nAddOptions & nRemoveOptions)) {
        PrintMsg(REPADMIN_OPTIONS_CANT_ADD_REMOVE_SAME_OPTION);
        return ERROR_INVALID_FUNCTION;
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Retrieve dsServiceName DN.
    ldStatus = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
                             rgpszRootAttrsToRead, 0, &pldmRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pldmRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    pldmRootEntry = ldap_first_entry(hld, pldmRootResults);
    if (NULL != pldmRootEntry) {
        ppszServerNames = ldap_get_valuesW(hld, pldmRootEntry, L"dsServiceName");

        if (NULL != ppszServerNames) {
            Assert(1 == ldap_count_valuesW(ppszServerNames));

            // Read options attribute from ntdsDsa object.
	    ldStatus = GetDsaOptions(hld, ppszServerNames[0], &nOptions);
            CHK_LD_STATUS(ldStatus);

            // Display current options.
            PrintMsg(REPADMIN_PRINT_CURRENT_NO_CR);
            PrintMsg(REPADMIN_SHOWREPS_DSA_OPTIONS, GetDsaOptionsString(nOptions));

            if (nAddOptions || nRemoveOptions) {
                nOptions |= nAddOptions;
                nOptions &= ~nRemoveOptions;
                PrintMsg(REPADMIN_PRINT_NEW_NO_CR);
                PrintMsg(REPADMIN_SHOWREPS_DSA_OPTIONS, GetDsaOptionsString(nOptions));

                ldStatus = SetDsaOptions(hld, ppszServerNames[0], nOptions);
                CHK_LD_STATUS(ldStatus);
            }
            ldap_value_freeW(ppszServerNames);
        } else {
            Assert( !"Service name should have been present" );
        }
    }

cleanup:

    if (pldmRootResults) {
        ldap_msgfree(pldmRootResults);
    }

    ldap_unbind(hld);

    return ret;
}

int
GetSiteOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszSiteDN,
    OUT int *   pnOptions
    )
{
    int             ldStatus;
    LDAPMessage *   pldmSiteResults = NULL;
    LDAPMessage *   pldmSiteEntry;
    LPWSTR          rgpszSiteAttrsToRead[] = {L"options", L"whenChanged", NULL};
    LPSTR *         ppszOptions;
    int             nOptions;

    ldStatus = ldap_search_sW(hld,
                              pszSiteDN,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgpszSiteAttrsToRead,
                              0,
                              &pldmSiteResults);
    if (ldStatus) {
        REPORT_LD_STATUS(LdapGetLastError()); 
	if (pldmSiteResults) {
	    ldap_msgfree(pldmSiteResults);
	}
        return ldStatus;
    }
    if (NULL == pldmSiteResults) {
        REPORT_LD_STATUS(LDAP_NO_RESULTS_RETURNED);	
        return LDAP_NO_RESULTS_RETURNED;
    }

    pldmSiteEntry = ldap_first_entry(hld, pldmSiteResults);
    Assert(NULL != pldmSiteEntry);

    // Parse current options.
    ppszOptions = ldap_get_values(hld, pldmSiteEntry, "options");
    if (NULL == ppszOptions) {
        *pnOptions = 0;
    }
    else {
        *pnOptions = atoi(ppszOptions[0]);
        ldap_value_free(ppszOptions);
    }

    ldap_msgfree(pldmSiteResults);

    return 0;
}

int
SetSiteOptions(
    IN  LDAP *  hld,
    IN  LPWSTR  pszSiteDN,
    IN  int     nOptions
    )
{
    int         ldStatus;
    WCHAR       szOptionsValue[20];
    LPWSTR      rgpszOptionsValues[] = {szOptionsValue, NULL};
    LDAPModW    ModOpt = {LDAP_MOD_REPLACE, L"options", rgpszOptionsValues};
    LDAPModW *  rgpMods[] = {&ModOpt, NULL};

    swprintf(szOptionsValue, L"%d", nOptions);

    ldStatus = ldap_modify_sW(hld, pszSiteDN, rgpMods);

    return ldStatus;
}

int
SiteOptions(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    LPWSTR          pszDSA = NULL;
    LPWSTR          pszSite = NULL;
    LPWSTR          pszSiteDN = NULL;
    LPWSTR          pszSiteSpecDN = NULL;
    LDAP *          hld;
    int             iArg;
    int             ldStatus;
    LDAPMessage *   pldmRootResults = NULL;
    LDAPMessage *   pldmRootEntry;
    LDAPMessage *   pldmCheckSiteResults = NULL;
    LPWSTR          rgpszRootAttrsToRead[] = {L"dsServiceName", L"configurationNamingContext", NULL};
    static WCHAR    wszSitesRdn[] = L",CN=Sites,";
    static WCHAR    wszSiteSettingsRdn[] = L"CN=NTDS Site Settings,";
    static WCHAR    wszCNEquals[] = L"CN=";
    LPWSTR *        ppszServiceName = NULL;
    LPWSTR *        ppszConfigNC = NULL;
    LPWSTR          pszSiteName = NULL;
    int             nOptions;
    int             nAddOptions = 0;
    int             nRemoveOptions = 0;
    int             nBit;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if ((argv[iArg][0] == '+') || (argv[iArg][0] == '-')) {
            // Options to change.
            if (!_wcsicmp(&argv[iArg][1], L"IS_AUTO_TOPOLOGY_DISABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"IS_TOPL_CLEANUP_DISABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"IS_TOPL_MIN_HOPS_DISABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED;
            }
	    else if (!_wcsicmp(&argv[iArg][1], L"IS_TOPL_DETECT_STALE_DISABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED;
            }
	    else if (!_wcsicmp(&argv[iArg][1], L"IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED;
            }
	    else if (!_wcsicmp(&argv[iArg][1], L"IS_GROUP_CACHING_ENABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"FORCE_KCC_WHISTLER_BEHAVIOR")) {
                nBit = NTDSSETTINGS_OPT_FORCE_KCC_WHISTLER_BEHAVIOR;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"FORCE_KCC_W2K_ELECTION")) {
                nBit = NTDSSETTINGS_OPT_FORCE_KCC_W2K_ELECTION;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"IS_RAND_BH_SELECTION_DISABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_RAND_BH_SELECTION_DISABLED;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"IS_SCHEDULE_HASHING_ENABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_SCHEDULE_HASHING_ENABLED;
            }
            else if (!_wcsicmp(&argv[iArg][1], L"IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED")) {
                nBit = NTDSSETTINGS_OPT_IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED;
            }
            else {
                PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
                return ERROR_INVALID_FUNCTION;
            }

            if (argv[iArg][0] == '+') {
                nAddOptions |= nBit;
            }
            else {
                nRemoveOptions |= nBit;
            }
        }  
	else if (!_wcsnicmp(argv[ iArg ], L"/site:", 6)) {
            pszSite = argv[ iArg ] + 6;
        } 
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (0 != (nAddOptions & nRemoveOptions)) {
        PrintMsg(REPADMIN_OPTIONS_CANT_ADD_REMOVE_SAME_OPTION);
        return ERROR_INVALID_FUNCTION;
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Retrieve dsServiceName DN and the configuration NC DN
    ldStatus = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)",
			     rgpszRootAttrsToRead, 0, &pldmRootResults);

    CHK_LD_STATUS(ldStatus);
    if (NULL == pldmRootResults) {
	ret = ERROR_DS_OBJ_NOT_FOUND;
	Assert( !ret );
	goto cleanup;
    }

    pldmRootEntry = ldap_first_entry(hld, pldmRootResults);
    if (NULL != pldmRootEntry) { 
	
	ppszConfigNC = ldap_get_valuesW(hld, pldmRootEntry, L"configurationNamingContext");
	ppszServiceName = ldap_get_valuesW(hld, pldmRootEntry, L"dsServiceName");
	Assert(ppszConfigNC);
	Assert(ppszServiceName);

       	//if user inputed a site name on the command line, use it.
	if (pszSite) { 
	    pszSiteDN = malloc((wcslen(pszSite) 
					+ wcslen(*ppszConfigNC) + 1) * sizeof(WCHAR) + sizeof(wszCNEquals) + sizeof(wszSitesRdn) + sizeof(wszSiteSettingsRdn));
	    wcscpy(pszSiteDN,wszSiteSettingsRdn);
	    wcscat(pszSiteDN,wszCNEquals);
	    wcscat(pszSiteDN,pszSite);
	    wcscat(pszSiteDN,wszSitesRdn);
	    wcscat(pszSiteDN,*ppszConfigNC);

	    //verify that this is a real site name.
	    ldStatus = ldap_search_sW(hld,
                              pszSiteDN,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              NULL,
                              0,
                              &pldmCheckSiteResults);
	    if (ldStatus==LDAP_NO_SUCH_OBJECT) {
            PrintMsg(REPADMIN_GENERAL_SITE_NOT_FOUND, pszSite);
            ret = LdapMapErrorToWin32(ldStatus);
            goto cleanup;  
	    } 
	}
	else { 
	    //default to local site name
	    if (ppszServiceName) {

		//get the site name of this server from the server DN, should be 3rd in order  
		ret = WrappedTrimDSNameBy(*ppszServiceName,3,&pszSiteSpecDN);
		if (ret) {  
		    Assert(!ret);
		    goto cleanup;
		}
		pszSiteDN = malloc((wcslen(pszSiteSpecDN) + 1)*sizeof(WCHAR) + sizeof(wszSiteSettingsRdn));
		wcscpy(pszSiteDN,wszSiteSettingsRdn);
		wcscat(pszSiteDN,pszSiteSpecDN);  
	    }
	    else{
		Assert( !"Service name should have been present" ); 
	    }
	}
    }
    else {
	//error, set ret and goto cleanup
    }

    //now read the attribute from the ntds settings object
    ldStatus = GetSiteOptions(hld, pszSiteDN, &nOptions);    
    CHK_LD_STATUS(ldStatus);

    // Display current options.
    PrintMsg(REPADMIN_PRINT_STR, GetNtdsSiteDisplayName(pszSiteDN));
    PrintMsg(REPADMIN_PRINT_CURRENT_NO_CR);
    PrintMsg(REPADMIN_SHOWREPS_SITE_OPTIONS, GetSiteOptionsString(nOptions));

    if (nAddOptions || nRemoveOptions) {
        nOptions |= nAddOptions;
        nOptions &= ~nRemoveOptions;
        
        PrintMsg(REPADMIN_PRINT_NEW_NO_CR);
        PrintMsg(REPADMIN_SHOWREPS_SITE_OPTIONS, GetSiteOptionsString(nOptions));

        ldStatus = SetSiteOptions(hld, pszSiteDN, nOptions);
        CHK_LD_STATUS(ldStatus);
    }


 cleanup:
     if (ppszServiceName) {
	 ldap_value_freeW(ppszServiceName);
     }
     if (ppszConfigNC) {
	 ldap_value_freeW(ppszConfigNC);
     }
     if (pldmRootResults) {
	 ldap_msgfree(pldmRootResults);
     }
     if (pldmCheckSiteResults) {
	 ldap_msgfree(pldmCheckSiteResults);
     }
     if (pszSiteDN) {
	 free(pszSiteDN);
     }
    ldap_unbind(hld);

    return ret;
}

int
ShowSig(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    LPWSTR          pszDSA = NULL;
    LDAP *          hld;
    int             iArg;
    int             ldStatus;
    LDAPMessage *   pldmRootResults = NULL;
    LDAPMessage *   pldmRootEntry;
    LDAPMessage *   pldmDsaResults = NULL;
    LDAPMessage *   pldmDsaEntry;
    LPSTR           rgpszRootAttrsToRead[] = {"dsServiceName", NULL};
    LPWSTR          rgpszDsaAttrsToRead[] = {L"invocationId", L"retiredReplDsaSignatures", NULL};
    LPWSTR *        ppszServerNames = NULL;
    struct berval **ppbvInvocID;
    CHAR            szTime[SZDSTIME_LEN];
    DWORD           i;
    ULONG           ulOptions;
    REPL_DSA_SIGNATURE_VECTOR_NATIVE * pDsaSigVec;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Retrieve dsServiceName DN.
    ldStatus = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
                             rgpszRootAttrsToRead, 0, &pldmRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pldmRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    pldmRootEntry = ldap_first_entry(hld, pldmRootResults);
    if (NULL == pldmRootEntry) {
        ret = ERROR_INTERNAL_ERROR;
        Assert( !ret );
        goto cleanup;
    }

    ppszServerNames = ldap_get_valuesW(hld, pldmRootEntry, L"dsServiceName");
    if (NULL == ppszServerNames) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    Assert(1 == ldap_count_valuesW(ppszServerNames));

    PrintMsg(REPADMIN_PRINT_STR, GetNtdsDsaDisplayName(*ppszServerNames));
    PrintMsg(REPADMIN_PRINT_CR);

    // Read current and retired DSA signatures from DSA object.
    ldStatus = ldap_search_sW(hld, *ppszServerNames, LDAP_SCOPE_BASE,
                              L"(objectClass=*)", rgpszDsaAttrsToRead, 0,
                              &pldmDsaResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pldmDsaResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    pldmDsaEntry = ldap_first_entry(hld, pldmDsaResults);
    if (NULL == pldmDsaEntry) {
        ret = ERROR_INTERNAL_ERROR;
        Assert( !ret );
        goto cleanup;
    }

    ppbvInvocID = ldap_get_values_len(hld, pldmDsaEntry, "invocationId");
    if (NULL != ppbvInvocID) {
        Assert(1 == ldap_count_values_len(ppbvInvocID));
        PrintMsg(REPADMIN_PRINT_CURRENT_NO_CR);
        PrintTabMsg(0, REPADMIN_PRINT_INVOCATION_ID, 
               GetStringizedGuid((GUID *) ppbvInvocID[0]->bv_val));
        ldap_value_free_len(ppbvInvocID);
    } else {
        Assert( !"invocationId should have been returned" );
    }

    ret = RepadminGetNativeDsaSigVec(hld, pldmDsaEntry, &pDsaSigVec); //, &pDsaSigVec);
    if (ret == ERROR_INVALID_PARAMETER) {
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_SHOWSIG_RETIRED_SIGS_UNRECOGNIZED);
    } else if (pDsaSigVec) {
        REPL_DSA_SIGNATURE_ENTRY_NATIVE * pEntry;

        for (i = 0; i < pDsaSigVec->cNumSignatures; i++) {
            pEntry = &pDsaSigVec->rgSignature[pDsaSigVec->cNumSignatures - i -1];

            PrintMsg(REPADMIN_SHOWSIG_RETIRED_INVOC_ID,
                     GetStringizedGuid(&pEntry->uuidDsaSignature),
                     DSTimeToDisplayString(pEntry->timeRetired, szTime),
                     pEntry->usnRetired);
        }
    } else if (ret == ERROR_NOT_ENOUGH_MEMORY) {
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
    } else {
        Assert(ret == ERROR_SUCCESS);
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_SHOWSIG_NO_RETIRED_SIGS);
    }

cleanup:
 
    if (pDsaSigVec != NULL) {
        LocalFree(pDsaSigVec);
    }

    if (ppszServerNames) {
        ldap_value_freeW(ppszServerNames);
    }
    if (pldmDsaResults) {
        ldap_msgfree(pldmDsaResults);
    }
    if (pldmRootResults) {
        ldap_msgfree(pldmRootResults);
    }

    ldap_unbind(hld);

    return ret;
}

int
ShowNcSig(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    LPWSTR          pszDSA = NULL;
    LDAP *          hld;
    int             iArg;
    int             ldStatus;
    LDAPMessage *   pldmRootResults = NULL;
    LDAPMessage *   pldmRootEntry;
    LDAPMessage *   pldmDsaResults = NULL;
    LDAPMessage *   pldmDsaEntry;
    LPSTR           rgpszRootAttrsToRead[] = {"dsServiceName", NULL};
    LPWSTR          rgpszDsaAttrsToRead[] = {L"invocationId", L"msds-retiredreplncsignatures", NULL};
    LPWSTR *        ppszServerNames = NULL;
    struct berval **ppbvRetiredIDs;
    struct berval **ppbvInvocID;
    CHAR            szTime[SZDSTIME_LEN];
    DWORD           i;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Retrieve dsServiceName DN.
    ldStatus = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
                             rgpszRootAttrsToRead, 0, &pldmRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pldmRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    pldmRootEntry = ldap_first_entry(hld, pldmRootResults);
    if (NULL == pldmRootEntry) {
        ret = ERROR_INTERNAL_ERROR;
        Assert( !ret );
        goto cleanup;
    }

    ppszServerNames = ldap_get_valuesW(hld, pldmRootEntry, L"dsServiceName");
    if (NULL == ppszServerNames) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    Assert(1 == ldap_count_valuesW(ppszServerNames));

    PrintMsg(REPADMIN_PRINT_STR, GetNtdsDsaDisplayName(*ppszServerNames));
    PrintMsg(REPADMIN_PRINT_CR);

    // Read current and retired DSA signatures from DSA object.
    ldStatus = ldap_search_sW(hld, *ppszServerNames, LDAP_SCOPE_BASE,
                              L"(objectClass=*)", rgpszDsaAttrsToRead, 0,
                              &pldmDsaResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pldmDsaResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    pldmDsaEntry = ldap_first_entry(hld, pldmDsaResults);
    if (NULL == pldmDsaEntry) {
        ret = ERROR_INTERNAL_ERROR;
        Assert( !ret );
        goto cleanup;
    }

    ppbvInvocID = ldap_get_values_len(hld, pldmDsaEntry, "invocationId");
    if (NULL != ppbvInvocID) {
        Assert(1 == ldap_count_values_len(ppbvInvocID));
        PrintMsg(REPADMIN_PRINT_CURRENT_NO_CR);
        PrintTabMsg(0, REPADMIN_PRINT_INVOCATION_ID, 
               GetStringizedGuid((GUID *) ppbvInvocID[0]->bv_val));
        ldap_value_free_len(ppbvInvocID);
    } else {
        Assert( !"invocationId should have been returned" );
    }

    ppbvRetiredIDs = ldap_get_values_len(hld, pldmDsaEntry, "msds-retiredreplncSignatures");
    if (NULL != ppbvRetiredIDs) {
        REPL_NC_SIGNATURE_VECTOR * pVec;
        REPL_NC_SIGNATURE_V1 *     pEntry;
            
        Assert(1 == ldap_count_values_len(ppbvRetiredIDs));

        pVec = (REPL_NC_SIGNATURE_VECTOR *) ppbvRetiredIDs[0]->bv_val;

        if (ReplNcSignatureVecV1Size(pVec) != ppbvRetiredIDs[0]->bv_len) {
            PrintMsg(REPADMIN_PRINT_CR);
            PrintMsg(REPADMIN_SHOWSIG_RETIRED_SIGS_UNRECOGNIZED);
        }
        else {
            PrintMsg(REPADMIN_SHOWNCSIG_INVOCATION_ID, 
                     GetStringizedGuid(&(pVec->V1.uuidInvocationId)));
            for (i = 0; i < pVec->V1.cNumSignatures; i++) {
                LPWSTR pszNc = NULL;
                RPC_STATUS rpcStatus;

                pEntry = &pVec->V1.rgSignature[i];

                // TODO: map this nc guid back to a string
                rpcStatus = UuidToStringW(&pEntry->uuidNamingContext, &pszNc);

                PrintMsg(REPADMIN_SHOWNCSIG_RETIRED_NC,
                         pszNc,
                         DSTimeToDisplayString(pEntry->dstimeRetired, szTime),
                         pEntry->usnRetired);

                RpcStringFreeW(&pszNc);
            }
        }
            
        ldap_value_free_len(ppbvRetiredIDs);
    }
    else {
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_SHOWSIG_NO_RETIRED_SIGS);
    }

cleanup:

    if (ppszServerNames) {
        ldap_value_freeW(ppszServerNames);
    }
    if (pldmDsaResults) {
        ldap_msgfree(pldmDsaResults);
    }
    if (pldmRootResults) {
        ldap_msgfree(pldmRootResults);
    }

    ldap_unbind(hld);

    return ret;
}

LPSTR
GetSiteOptionsString(
    IN  int nOptions
    )
{
    static CHAR szOptions[512];

    // BAS_TODO use my getString...

    if (0 == nOptions) {
        strcpy(szOptions, "(none)");
    }
    else {
        *szOptions = '\0';

	if (nOptions & NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED) {
            strcat(szOptions, "IS_AUTO_TOPOLOGY_DISABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED) {
            strcat(szOptions, "IS_TOPL_CLEANUP_DISABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED) {
            strcat(szOptions, "IS_TOPL_MIN_HOPS_DISABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED) {
            strcat(szOptions, "IS_TOPL_DETECT_STALE_DISABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED) {
            strcat(szOptions, "IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED) {
            strcat(szOptions, "IS_GROUP_CACHING_ENABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_FORCE_KCC_WHISTLER_BEHAVIOR) {
            strcat(szOptions, "FORCE_KCC_WHISTLER_BEHAVIOR ");
        }
	if (nOptions & NTDSSETTINGS_OPT_FORCE_KCC_W2K_ELECTION) {
            strcat(szOptions, "FORCE_KCC_W2K_ELECTION ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_RAND_BH_SELECTION_DISABLED) {
            strcat(szOptions, "IS_RAND_BH_SELECTION_DISABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_SCHEDULE_HASHING_ENABLED) {
            strcat(szOptions, "IS_SCHEDULE_HASHING_ENABLED ");
        }
	if (nOptions & NTDSSETTINGS_OPT_IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED) {
            strcat(szOptions, "IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED ");
        }
    }

    return szOptions;
}


LPSTR
GetDsaOptionsString(
    IN  int nOptions
    )
{
    static CHAR szOptions[128];
    
    // BAS_TODO use my getString...


    if (0 == nOptions) {
        strcpy(szOptions, "(none)");
    }
    else {
        *szOptions = '\0';

        if (nOptions & NTDSDSA_OPT_IS_GC) {
            strcat(szOptions, "IS_GC ");
        }
        if (nOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL) {
            strcat(szOptions, "DISABLE_INBOUND_REPL ");
        }
        if (nOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL) {
            strcat(szOptions, "DISABLE_OUTBOUND_REPL ");
        }
        if (nOptions & NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE) {
            strcat(szOptions, "DISABLE_NTDSCONN_XLATE ");
        }
    }

    return szOptions;
}


LPWSTR
GetDsaDnsName(
    PLDAP       hld,
    LPWSTR      pwszDsa
    )
/*++

Routine Description:

    Returns (allocated) dns name of the DSA represented
    by the DN of the ntdsDsa object.

Arguments:

    hld - ldap handle
    pwszDsa - the DN of the server's ntdsDsa object

Return Value:

    Success: a ptr to ldap allocated dns name
    Failure: NULL


Remarks:

    - hld is an active (connected/authenticated connection)
    - Caller must free returned string w/ free()




--*/
{

    LPWSTR pServer = NULL;
    ULONG ulErr = ERROR_SUCCESS;
    LPWSTR attrs[] = { L"dNSHostName", NULL };
    PLDAPMessage res = NULL, entry = NULL;
    LPWSTR *ppVals = NULL;
    LPWSTR pDnsName = NULL;


    Assert(hld && pwszDsa);

    //
    // compute the server DN from the child ntdsDsa DN
    //
    ulErr = WrappedTrimDSNameBy(pwszDsa,1, &pServer);
    if ( ulErr ) {
        Assert( !ulErr );
	goto cleanup;
    }

    //
    // Retrieve the data from server
    //
    ulErr = ldap_search_sW(
                hld,
                pServer,
                LDAP_SCOPE_BASE,
                L"objectclass=*",
                attrs,
                FALSE,
                &res);

    if ( ERROR_SUCCESS != ulErr ) {
        REPORT_LD_STATUS(LdapGetLastError());	
	goto cleanup;
    }

    // initialization worked: from here, failures go thru cleanup

    entry = ldap_first_entry(hld, res);
    if (!entry) {
        Assert( !"entry should have been returned" );
        goto cleanup;
    }

    ppVals = ldap_get_valuesW(hld, entry, attrs[0]);
    if (!ppVals || !ppVals[0]) {
        Assert( !"value should have been returned" );
        REPORT_LD_STATUS(LdapGetLastError());	
        goto cleanup;
    }

    pDnsName = malloc((wcslen(ppVals[0])+1)*sizeof(WCHAR));
    if (!pDnsName) {
        CHK_ALLOC(pDnsName);
        goto cleanup;
    }

    // copy dns name to returned buffer
    wcscpy(pDnsName, ppVals[0]);

cleanup:

    if (pServer) {
        free(pServer);
    }
    if (ppVals) {
        ldap_value_freeW(ppVals);
    }
    if ( res ) {
        ldap_msgfree(res);
    }

    return pDnsName;
}


void
printLdapTime(
    LPSTR pszTime
    )

/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/

{
    PrintMsg(REPADMIN_PRINT_SHORT_STR, pszTime);
}


BOOL
decodeLdapDistnameBinary(
    LPWSTR pszLdapDistnameBinaryValue,
    PVOID *ppvData,
    LPDWORD pcbLength,
    LPWSTR *ppszDn
    )

/*++

Routine Description:

    Description

Arguments:

    pszLdapDistnameBinaryValue - Incoming ldap encoded distname binary value
    ppvData - Newly allocated data. Caller must deallocate
    pcbLength - length of returned data
    ppszDn - pointer to dn within incoming buffer, do not deallocate

Return Value:

    BOOL -

--*/

{
    LPWSTR pszColon, pszData;
    DWORD length, i;

    // Check for 'B'
    if (*pszLdapDistnameBinaryValue != L'B') {
        return FALSE;
    }

    // Check for 1st :
    pszLdapDistnameBinaryValue++;
    if (*pszLdapDistnameBinaryValue != L':') {
        return FALSE;
    }

    // Get the length
    pszLdapDistnameBinaryValue++;
    length = wcstol(pszLdapDistnameBinaryValue, NULL, 10);
    if (length & 1) {
        // Length should be even
        return FALSE;
    }
    *pcbLength = length / 2;

    // Check for 2nd :
    pszColon = wcschr(pszLdapDistnameBinaryValue, L':');
    if (!pszColon) {
        return FALSE;
    }

    // Make sure length is correct
    pszData = pszColon + 1;
    if (pszData[length] != L':') {
        return FALSE;
    }
    pszColon = wcschr(pszData, L':');
    if (!pszColon) {
        return FALSE;
    }
    if (pszColon != pszData + length) {
        return FALSE;
    }

    // Decode the data
    *ppvData = malloc( *pcbLength );
    CHK_ALLOC(*ppvData);

    for( i = 0; i < *pcbLength; i++ ) {
        WCHAR szHexString[3];
        szHexString[0] = *pszData++;
        szHexString[1] = *pszData++;
        szHexString[2] = L'\0';
        ((PCHAR) (*ppvData))[i] = (CHAR) wcstol(szHexString, NULL, 16);
    }

    Assert( pszData == pszColon );

    // Return pointer to dn
    *ppszDn = pszColon + 1;

    return TRUE;
} /* decodeLdapDistnameBinary */

BOOL
showMatchingFailure(
    IN  DS_REPL_KCC_DSA_FAILURESW * pFailures,
    IN  LPWSTR pszDn,
    IN  BOOL fErrorsOnly
    )
{
    DWORD i;
    BOOL fFound = FALSE;
    LPWSTR *ppszRDNs;

    if ( (!pFailures) || (0 == pFailures->cNumEntries) ) {
        return FALSE;
    }

    ppszRDNs = ldap_explode_dnW(pszDn, 1);
    if (ppszRDNs == NULL) {
        REPORT_LD_STATUS(LdapGetLastError());	
        return FALSE;
    }

    for (i = 0; i < pFailures->cNumEntries; i++) {
        DS_REPL_KCC_DSA_FAILUREW * pFailure = &pFailures->rgDsaFailure[i];

        if ( (pFailure->pszDsaDN) &&
             (!wcscmp( pszDn, pFailure->pszDsaDN)) &&
             (pFailure->cNumFailures) ) {
            DSTIME dsTime;
            CHAR   szTime[SZDSTIME_LEN];

            FileTimeToDSTime(pFailure->ftimeFirstFailure, &dsTime);

            if (fErrorsOnly) {
                PrintMsg(REPADMIN_PRINT_CR);
                PrintMsg(REPADMIN_SHOW_MATCH_FAIL_SRC,  ppszRDNs[3], ppszRDNs[1] );
            }
            PrintMsg(REPADMIN_SHOW_MATCH_FAIL_N_CONSECUTIVE_FAILURES, 
                   pFailure->cNumFailures,
                   DSTimeToDisplayString(dsTime, szTime));

            if (0 != pFailure->dwLastResult) {
                PrintMsg(REPADMIN_FAILCACHE_LAST_ERR_LINE);
                PrintTabErrEnd(6, pFailure->dwLastResult);
            }
            fFound = TRUE;
            break;
        }
    } // end for...

//cleanup:
    ldap_value_freeW(ppszRDNs);
    return fFound;
}

BOOL
findFailure(
    IN  DS_REPL_KCC_DSA_FAILURESW * pFailures,
    IN  LPWSTR pszDn,
    OUT DSTIME *pdsFirstFailure,
    OUT DWORD *pcNumFailures,
    OUT DWORD *pdwLastResult
    )
{
    DWORD i;
    BOOL fFound = FALSE;

    if ( (!pFailures) || (0 == pFailures->cNumEntries) ) {
        return FALSE;
    }

    for (i = 0; i < pFailures->cNumEntries; i++) {
        DS_REPL_KCC_DSA_FAILUREW * pFailure = &pFailures->rgDsaFailure[i];

        if ( (pFailure->pszDsaDN) &&
             (!wcscmp( pszDn, pFailure->pszDsaDN)) &&
             (pFailure->cNumFailures) ) {

            FileTimeToDSTime(pFailure->ftimeFirstFailure, pdsFirstFailure);
            *pcNumFailures = pFailure->cNumFailures;
            *pdwLastResult = pFailure->dwLastResult;
            fFound = TRUE;
            break;
        }
    } // end for...

//cleanup:
    return fFound;
}

void
showMissingNeighbor(
    DS_REPL_NEIGHBORSW *pNeighbors,
    LPWSTR pszNc,
    LPWSTR pszSourceDsaDn,
    BOOL fErrorsOnly
    )
{
    DWORD i;
    DS_REPL_NEIGHBORW *   pNeighbor;
    BOOL fFound = FALSE;

    if (!pNeighbors) {
        return;
    }

    if ( (DsIsMangledDnW( pszNc, DS_MANGLE_OBJECT_RDN_FOR_DELETION ))
         || (DsIsMangledDnW( pszSourceDsaDn, DS_MANGLE_OBJECT_RDN_FOR_DELETION )) ) {
        return;
    }

    for (i = 0; i < pNeighbors->cNumNeighbors; i++) {
        pNeighbor = &pNeighbors->rgNeighbor[i];

        if ( (!wcscmp( pNeighbor->pszNamingContext, pszNc )) &&
             (!wcscmp( pNeighbor->pszSourceDsaDN, pszSourceDsaDn )) ) {
            fFound = TRUE;
            break;
        }
    }

    if (fFound) {
        if (!fErrorsOnly) {
            PrintMsg(REPADMIN_SHOW_MISSING_NEIGHBOR_REPLICA_ADDED);
        }
    } else {
        if (fErrorsOnly) {
            LPWSTR *ppszRDNs;

            PrintMsg(REPADMIN_PRINT_CR);
#ifdef DISPLAY_ABBREV_NC
            ppszRDNs = ldap_explode_dnW(pszNc, 1);
            if (ppszRDNs != NULL) {
                // Display more of the nc name to disambiguate?
                PrintMsg(REPADMIN_PRINT_NAMING_CONTEXT_NO_CR, ppszRDNs[0]);
                ldap_value_freeW(ppszRDNs);
            } else {
                REPORT_LD_STATUS(LdapGetLastError());	
            }
#else
            PrintMsg(REPADMIN_PRINT_NAMING_CONTEXT_NO_CR, pszNc);
#endif

            ppszRDNs = ldap_explode_dnW(pszSourceDsaDn, 1);
            if (ppszRDNs != NULL) {
                PrintMsg(REPADMIN_SHOW_MATCH_FAIL_SRC, ppszRDNs[3], ppszRDNs[1] );
                ldap_value_freeW(ppszRDNs);
            } else {
                REPORT_LD_STATUS(LdapGetLastError());	
            }
        }
        PrintMsg(REPADMIN_SHOW_MISSING_NEIGHBOR_WARN_KCC_COULDNT_ADD_REPLICA_LINK);
    }
}

int
ShowBridgeheadNeighbor(
    LDAP *hldHome,
    BOOL fPrintTitle,
    LPWSTR pszBridgeheadDsaDn,
    LPWSTR pszNcDn,
    LPWSTR pszFromServerDsaDn
    )
/*
 */
{
    int             ret = 0;
    int             ldStatus;
    ULONG           secondary;
    HANDLE          hDS = NULL;
    LPWSTR          rgpszFromAttrsToRead[] = {L"objectGuid",
                                              NULL };
    LDAPMessage *   pBaseResults = NULL;
    LDAPMessage *   pFromResults = NULL;
    LPWSTR *        ppszDnsHostName = NULL;
    LPWSTR          pszDSA = NULL;
    struct berval **    ppbvGuid = NULL;
    GUID            * pGuidFromDsa;
    DS_REPL_NEIGHBORSW *pNeighbors = NULL;
    DS_REPL_NEIGHBORW *pNeighbor = NULL;
    CHAR    szTime[ SZDSTIME_LEN ];
    CHAR    szTime2[ SZDSTIME_LEN ];
    DSTIME  dsTime;
    LPWSTR *ppszNcRDNs = NULL;

    if (fPrintTitle) {
        PrintMsg( REPADMIN_SHOW_BRIDGEHEADS_HDR );
    }

    ppszNcRDNs = ldap_explode_dnW(pszNcDn, 1);
    if (NULL == ppszNcRDNs) {
        REPORT_LD_STATUS(LdapGetLastError());	
        ret = ERROR_DS_DRA_BAD_DN;
        goto cleanup;
    }

    // What's the dns host name of this object?
    pszDSA = GetDsaDnsName(hldHome, pszBridgeheadDsaDn);
    Assert(NULL != pszDSA);

    // What's the guid of the from server dsa
    ldStatus = ldap_search_sW(hldHome, pszFromServerDsaDn, LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              rgpszFromAttrsToRead, 0, &pFromResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pFromResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    ppbvGuid = ldap_get_values_len(hldHome, pFromResults, "objectGuid");
    if (NULL == ppbvGuid) {
        REPORT_LD_STATUS(LdapGetLastError());	
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        goto cleanup;
    }
    Assert(1 == ldap_count_values_len(ppbvGuid));
    pGuidFromDsa = (GUID *) ppbvGuid[0]->bv_val;

    // Get a DS Handle too
    ret = RepadminDsBind(pszDSA, &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszDSA, ret);
        goto cleanup;
    }

    // *******************************************

    // Display more of the nc name to disambiguate?
    PrintMsg( REPADMIN_SHOW_BRIDGEHEADS_DATA_1, ppszNcRDNs[0] );
    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS,
                            pszNcDn /* pszNc*/, pGuidFromDsa /* puuid */,
                            &pNeighbors);
    if (ERROR_SUCCESS != ret) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        goto cleanup;
    }

    // When asking for a specific source guid that is not present, get
    // neighbors may return an empty structure.
    if ( (!pNeighbors) || (pNeighbors->cNumNeighbors == 0) ) {
        goto cleanup;
    }

    pNeighbor = &(pNeighbors->rgNeighbor[0]);

    // Display status and time of last replication attempt/success.
    FileTimeToDSTime(pNeighbor->ftimeLastSyncAttempt, &dsTime);
    DSTimeToDisplayString(dsTime, szTime);
    FileTimeToDSTime(pNeighbor->ftimeLastSyncSuccess, &dsTime);
    DSTimeToDisplayString(dsTime, szTime2);
    PrintMsg(REPADMIN_SHOW_BRIDGEHEADS_DATA_2, 
             szTime, szTime2, 
             pNeighbor->cNumConsecutiveSyncFailures,
             Win32ErrToString(pNeighbor->dwLastSyncResult) );

    DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
    pNeighbors = NULL;

    // *******************************************

cleanup:

    if (pszDSA) {
        free(pszDSA);
    }
    if (ppszNcRDNs) {
        ldap_value_freeW(ppszNcRDNs);
    }
    if (ppszDnsHostName) {
        ldap_value_freeW(ppszDnsHostName);
    }
    if (ppbvGuid) {
        ldap_value_free_len(ppbvGuid);
    }
    if (pBaseResults) {
        ldap_msgfree(pBaseResults);
    }
    if (pFromResults) {
        ldap_msgfree(pFromResults);
    }
    if (hDS) {
        secondary = DsUnBindW(&hDS);
        if (secondary != ERROR_SUCCESS) {
            PrintUnBindFailed(secondary);
            // keep going
        }
    }

    return ret;
}

int
FindConnections(
    LDAP *          hld,
    LPWSTR          pszBaseSearchDn,
    LPWSTR          pszFrom,
    BOOL            fShowConn,
    BOOL            fVerbose,
    BOOL            fIntersite
    )
{
    int             ret = 0;
    LPWSTR          pszServerRdn = NULL;
    int             ldStatus, ldStatus1;
    LDAPSearch *    pSearch = NULL;
    LDAPMessage *   pldmConnResults;
    LDAPMessage *   pldmConnEntry;
    LPWSTR          rgpszConnAttrsToRead[] = {L"enabledConnection", L"fromServer", L"mS-DS-ReplicatesNCReason", L"options", L"schedule", L"transportType", L"whenChanged", L"whenCreated", NULL};
    CHAR            szTime[SZDSTIME_LEN];
    DWORD           i, cConn = 0;
    ULONG           ulTotalEstimate;
    WCHAR           pszServerRDN[MAX_RDN_SIZE + 1];
    DS_REPL_KCC_DSA_FAILURESW * pConnFailures = NULL, * pLinkFailures = NULL;
    DS_REPL_NEIGHBORSW *pNeighbors = NULL;
    HANDLE hDS = NULL;
    LPWSTR          pwszDnsName = NULL;
    LPWSTR pNtdsDsa = NULL;
    PVOID pvScheduleTotalContext = NULL;

    *pszServerRDN = L'\0';

    // Retrieve all the connections under the given base

    pSearch = ldap_search_init_pageW(hld,
                                     pszBaseSearchDn,
                                     LDAP_SCOPE_SUBTREE,
                                     L"(objectClass=nTDSConnection)",
                                     rgpszConnAttrsToRead,
                                     FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
        CHK_LD_STATUS(LdapGetLastError());
    }

    ldStatus = ldap_get_next_page_s(hld,
                                     pSearch,
                                     0,
                                     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                     &ulTotalEstimate,
                                     &pldmConnResults);

    while (ldStatus == LDAP_SUCCESS) {

        for (pldmConnEntry = SAFE_LDAP_FIRST_ENTRY(hld, pldmConnResults);
            NULL != pldmConnEntry;
            pldmConnEntry = ldap_next_entry(hld, pldmConnEntry)) {
            LPWSTR pszDn;
            LPWSTR *ppszRDNs, *ppszFromRDNs;
            LPSTR  *ppszEnabledConnection;
            LPWSTR *ppszFromServer;
            LPWSTR *ppszTransportType;
            LPSTR  *ppszOptions;
            LPSTR  *ppszTime;
            DWORD  dwOptions, i, cNCs = 3;
            struct berval **ppbvSchedule;
            LPWSTR *ppszNcReason;

            // fromServer filter
            ppszFromServer = ldap_get_valuesW(hld, pldmConnEntry, L"fromServer");
            if (NULL == ppszFromServer) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            Assert(1 == ldap_count_valuesW(ppszFromServer));
            ppszFromRDNs = ldap_explode_dnW(*ppszFromServer, 1);
            if (ppszFromRDNs == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            Assert(NULL != ppszFromRDNs);
            Assert(6 < ldap_count_valuesW(ppszFromRDNs));
            // NTDS settings,<server>,Servers,<site>,Sites,<Config NC>
            if ( pszFrom && (_wcsicmp( ppszFromRDNs[1], pszFrom ))) {
                ldap_value_freeW(ppszFromRDNs);
                continue;
            }


            // Connection object dn filter
            pszDn = ldap_get_dnW(hld, pldmConnEntry);
            if (NULL == pszDn) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }

            // get ntdsdsa name (& free previously allocated)
            if ( pNtdsDsa ) {
                free(pNtdsDsa);
            }
            ret = WrappedTrimDSNameBy( pszDn, 1, &pNtdsDsa );
            Assert(pNtdsDsa && !ret);

            // Get dns name (free previously allocated)
            if (pwszDnsName) {
                free(pwszDnsName);
            }
            pwszDnsName = GetDsaDnsName(hld, pNtdsDsa);
            Assert(pwszDnsName);

            // explode to RDNs
            ppszRDNs = ldap_explode_dnW(pszDn, 1);
            if (ppszRDNs == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            ldap_memfreeW(pszDn);
            Assert(NULL != ppszRDNs);
            Assert(6 < ldap_count_valuesW(ppszRDNs));
            // <conn>,ntds settings,<server>,Servers,<site>,Sites,Config NC
            if (fIntersite && (!wcscmp( ppszFromRDNs[3], ppszRDNs[4] ))) {
                continue;
            }

            // Connection object dn
            if (fShowConn) {
                PrintMsg(REPADMIN_SHOWCONN_DATA,
                       ppszRDNs[0],
                       pwszDnsName,
                       pNtdsDsa);
                cConn++;
            }

            // Dump failure counts for each unique server
            if (wcscmp( pszServerRDN, ppszRDNs[2] ) ) {
                wcscpy( pszServerRDN, ppszRDNs[2] );

                if (pConnFailures) {
                    DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pConnFailures);
                    pConnFailures = NULL;
                }
                if (pLinkFailures) {
                    DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pLinkFailures);
                    pLinkFailures = NULL;
                }
                if (pNeighbors) {
                    DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
                    pNeighbors = NULL;
                }
                if (hDS) {
                    ret = DsUnBindW(&hDS);
                    if (ret != ERROR_SUCCESS) {
                        PrintUnBindFailed(ret);
                        // keep going
                    }
                    hDS = NULL;
                }

                ret = RepadminDsBind(pwszDnsName, &hDS);
                if (ret != ERROR_SUCCESS) {
                    // This means the destination is down
                    PrintBindFailed(pszServerRDN, ret);
                }

                if (hDS) {
                    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,
                                            NULL, NULL, &pConnFailures);
                    if (ret != ERROR_SUCCESS) {
                        PrintFuncFailed(L"DsReplicaGetInfo", ret);
                        // keep going
                    }

                    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                                            NULL, NULL, &pLinkFailures);
                    if (ret != ERROR_SUCCESS) {
                        PrintFuncFailed(L"DsReplicaGetInfo", ret);
                        // keep going
                    }

                    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS,
                                            NULL /* pszNc*/, NULL /* puuid */,
                                            &pNeighbors);
                    if (ERROR_SUCCESS != ret) {
                        PrintFuncFailed(L"DsReplicaGetInfo", ret);
                        // keep going
                    }
                }
            }
            ldap_value_freeW(ppszRDNs);
            if ( pNtdsDsa ) {
                free(pNtdsDsa);
                pNtdsDsa = NULL;
            }

            // fromServer
            if (fShowConn) {
                PrintTabMsg(4, REPADMIN_SHOW_MATCH_FAIL_SRC,
                            ppszFromRDNs[3], ppszFromRDNs[1]);
            }
            if ( (!showMatchingFailure( pConnFailures, *ppszFromServer, !fShowConn )) &&
                 (!showMatchingFailure( pLinkFailures, *ppszFromServer, !fShowConn )) ) {
                if (fShowConn) {
                    PrintTabMsg(8, REPADMIN_PRINT_NO_FAILURES);
                }
            }
            ldap_value_freeW(ppszFromRDNs);

            // transportType
            ppszTransportType = ldap_get_valuesW(hld, pldmConnEntry, L"transportType");
            // Not present on intra-site connections
            if (ppszTransportType != NULL) {
                Assert(1 == ldap_count_valuesW(ppszTransportType));
                ppszRDNs = ldap_explode_dnW(*ppszTransportType, 1);
                if (ppszRDNs != NULL) {
                    Assert(4 < ldap_count_valuesW(ppszRDNs));
                    // <transport>,Intersite Transports,Sites,<Config NC>
                    if (fShowConn) {
                        PrintMsg(REPADMIN_SHOWCONN_TRANSPORT_TYPE, ppszRDNs[0] );
                    }
                    ldap_value_freeW(ppszRDNs);
                } else {
                    REPORT_LD_STATUS(LdapGetLastError());	
                }
                ldap_value_freeW(ppszTransportType);
            } else {
                if (fShowConn) {
                    PrintMsg(REPADMIN_SHOWCONN_TRANSPORT_TYPE_INTRASITE_RPC);
                }
            }

            // options
            ppszOptions = ldap_get_values( hld, pldmConnEntry, "options" );
            if (NULL != ppszOptions) {
                Assert(1 == ldap_count_values(ppszOptions));
                dwOptions = atol( *ppszOptions );
                if (dwOptions) {
                    if (fShowConn) {
                        PrintMsg(REPADMIN_SHOWCONN_OPTIONS);
                        printBitField( dwOptions, ppszNtdsConnOptionNames );
                    }
                }
                ldap_value_free(ppszOptions);
            }

            // ms-DS-ReplicatesNCReason
            ppszNcReason = ldap_get_valuesW(hld, pldmConnEntry, L"mS-DS-ReplicatesNCReason");
            // See if new attribute written by post-b3 server
            if (ppszNcReason) {
                DWORD dwReason, cbLength;
                PVOID pvData;

                cNCs = ldap_count_valuesW(ppszNcReason);

                for ( i = 0; i < cNCs; i++ ) {
                    if (!decodeLdapDistnameBinary(
                                                 ppszNcReason[i], &pvData, &cbLength, &pszDn)) {
                        PrintMsg(REPADMIN_SHOWCONN_INVALID_DISTNAME_BIN_VAL, ppszNcReason[i]);
                        break;
                    }
                    if (fShowConn) {
                        PrintTabMsg(4, REPADMIN_SHOWCONN_REPLICATES_NC, pszDn);
                        if (cbLength != sizeof(DWORD)) {
                            PrintMsg(REPADMIN_SHOWCONN_INVALID_DISTNAME_BIN_LEN, cbLength);
                            break;
                        }
                        dwReason = ntohl( *((LPDWORD) pvData) );
                        if (dwReason) {
                            PrintMsg(REPADMIN_SHOWCONN_REASON);
                            printBitField( dwReason, ppszKccReasonNames );
                        }
                    }
                    free( pvData );
                    showMissingNeighbor( pNeighbors, pszDn, *ppszFromServer, !fShowConn );
                }
                ldap_value_freeW(ppszNcReason);
            }
            ldap_value_freeW(ppszFromServer);

            // All other attributes are considered verbose
            if (!(fShowConn && fVerbose)) {
                continue;
            }

            // enabledConnection
            ppszEnabledConnection = ldap_get_values(hld, pldmConnEntry, "enabledConnection");
            if (NULL != ppszEnabledConnection) {
                Assert(1 == ldap_count_values(ppszEnabledConnection));
                PrintMsg(REPADMIN_SHOWCONN_ENABLED_CONNECTION, *ppszEnabledConnection);
                ldap_value_free(ppszEnabledConnection);
            }

            // whenChanged
            ppszTime = ldap_get_values( hld, pldmConnEntry, "whenChanged" );
            if (NULL != ppszTime) {
                Assert(1 == ldap_count_values(ppszTime));
                PrintMsg(REPADMIN_SHOWCONN_WHEN_CHANGED);
                printLdapTime( *ppszTime );
                ldap_value_free(ppszTime);
            }

            // whenCreated
            ppszTime = ldap_get_values( hld, pldmConnEntry, "whenCreated" );
            if (NULL != ppszTime) {
                Assert(1 == ldap_count_values(ppszTime));
                PrintMsg(REPADMIN_SHOWCONN_WHEN_CREATED);
                printLdapTime( *ppszTime );
                ldap_value_free(ppszTime);
            }

            // schedule
            ppbvSchedule = ldap_get_values_len( hld, pldmConnEntry, "schedule" );
            if (NULL != ppbvSchedule ) {
                Assert(1 == ldap_count_values_len(ppbvSchedule));
                PrintMsg(REPADMIN_SHOWCONN_SCHEDULE);
                printSchedule( (*ppbvSchedule)->bv_val, (*ppbvSchedule)->bv_len );
                totalScheduleUsage( &pvScheduleTotalContext, 
                                    (*ppbvSchedule)->bv_val, (*ppbvSchedule)->bv_len,
                                    cNCs);
                ldap_value_free_len( ppbvSchedule );
            }

        } // end for more entries in a single page


        ldap_msgfree(pldmConnResults);
        pldmConnResults = NULL;

        ldStatus = ldap_get_next_page_s(hld,
                                         pSearch,
                                         0,
                                         DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                         &ulTotalEstimate,
                                         &pldmConnResults);
    } // End while more pages to search
    if (ldStatus != LDAP_NO_RESULTS_RETURNED) {
        CHK_LD_STATUS(ldStatus);
    }

    if (fShowConn && cConn) {
        PrintMsg(REPADMIN_SHOWCONN_N_CONNECTIONS_FOUND, cConn);
        // Dump schedule totals
        if (fVerbose) {
            totalScheduleUsage( &pvScheduleTotalContext, NULL, 0, 0 );
        }
    }

    if (pConnFailures) {
        DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pConnFailures);
        pConnFailures = NULL;
    }
    if (pLinkFailures) {
        DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pLinkFailures);
        pLinkFailures = NULL;
    }
    if (pNeighbors) {
        DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
        pNeighbors = NULL;
    }
    if (hDS) {
        ret = DsUnBindW(&hDS);
        if (ret != ERROR_SUCCESS) {
            PrintUnBindFailed(ret);
            // keep going
        }
        hDS = NULL;
    }

    ldStatus1 = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(ldStatus1);

    // free dns name
    if (pwszDnsName) {
        free(pwszDnsName);
    }


    return LdapMapErrorToWin32( ldStatus );
}

int
ShowConn(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    LPWSTR          pszDSA = NULL;
    LPWSTR          pszFrom = NULL;
    LDAP *          hld;
    BOOL            fVerbose = FALSE;
    BOOL            fIntersite = FALSE;
    LPWSTR          pszBaseSearchDn = NULL;
    LPWSTR          pszServerRdn = NULL;
    UUID *          puuid = NULL;
    UUID            uuid;
    LPWSTR          pszGuid = NULL;
    int             iArg;
    int             ldStatus;
    LPWSTR          rgpszRootAttrsToRead[] = {L"serverName", L"configurationNamingContext", NULL};
    WCHAR           szGuidDn[50];
    LDAPMessage *   pRootResults = NULL;
    BOOL            fBaseAlloced = FALSE;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/v")
            || !_wcsicmp(argv[iArg], L"/verbose")) {
            fVerbose = TRUE;
        }
        else if (!_wcsicmp(argv[iArg], L"/i")
            || !_wcsicmp(argv[iArg], L"/bridge")
            || !_wcsicmp(argv[iArg], L"/brideheads")
            || !_wcsicmp(argv[iArg], L"/inter")
            || !_wcsicmp(argv[iArg], L"/intersite")) {
            fIntersite = TRUE;
        }
        else if (!_wcsnicmp(argv[iArg], L"/from:", 6)) {
            pszFrom = argv[iArg] + 6;
        }
        else if ((NULL == pszBaseSearchDn) &&
                 ( CountNamePartsStringDn( argv[iArg] ) > 1 ) ) {
            pszBaseSearchDn = argv[iArg];
        }
        else if ((NULL == puuid)
                 && (0 == UuidFromStringW(argv[iArg], &uuid))) {
            puuid = &uuid;
            pszGuid = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else if (NULL == pszServerRdn) {
            pszServerRdn = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // What's the DN of the server?
    ldStatus = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)",
                             rgpszRootAttrsToRead, 0, &pRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    // Construct the base dn for search
    if (puuid) {
        // Guid was specified
        if (pszBaseSearchDn || pszServerRdn) {
            PrintMsg(REPADMIN_SHOWCONN_SPECIFY_RDN_DN_OR_GUID);
            return ERROR_INVALID_PARAMETER;
        }
        swprintf(szGuidDn, L"<GUID=%ls>", pszGuid);
        pszBaseSearchDn = szGuidDn;
    } else if (pszServerRdn) {
        // Computer the dn of the server object from the server rdn
        LPWSTR *ppszConfigNc;
        WCHAR szFilter[50 + MAX_RDN_SIZE];
        LPWSTR rgpszServerAttrsToRead[] = {L"invalid", NULL};  // just want dn
        LDAPMessage *pServerResults;
        LDAPMessage *pldmServerEntry;

        ppszConfigNc = ldap_get_valuesW(hld, pRootResults, L"configurationNamingContext");
        if (NULL == ppszConfigNc) {
            ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
            Assert( !ret );
            goto cleanup;
        }

        swprintf( szFilter, L"(& (objectClass=server) (cn=%ls))", pszServerRdn );

        ldStatus = ldap_search_sW(hld, *ppszConfigNc, LDAP_SCOPE_SUBTREE, szFilter,
                                 rgpszServerAttrsToRead, 0, &pServerResults);
        CHK_LD_STATUS(ldStatus);
        if (NULL == pServerResults) {
            ret = ERROR_DS_OBJ_NOT_FOUND;
            Assert( !ret );
            goto cleanup;
        }

        pldmServerEntry = ldap_first_entry(hld, pServerResults);
        Assert( pldmServerEntry );

        if (1 == ldap_count_entries(hld, pServerResults)) {
            pszBaseSearchDn = ldap_get_dnW(hld, pldmServerEntry);
            if ( pszBaseSearchDn == NULL ) {
                REPORT_LD_STATUS(LdapGetLastError());	
                return ERROR_DS_DRA_BAD_DN;
            }
        } else {
            PrintMsg(REPADMIN_SHOWCONN_AMBIGUOUS_NAME, pszServerRdn);
            return ERROR_DUP_NAME;
        }

        ldap_value_freeW(ppszConfigNc);
        ldap_msgfree(pServerResults);

    } else if (!pszBaseSearchDn) {
        // No explicit dn was specified, Construct the site container name
        LPWSTR *        ppszServerDn;

        ppszServerDn = ldap_get_valuesW(hld, pRootResults, L"serverName");
        if (NULL != ppszServerDn) {

            // Trim two dn's for the local site
            ret = WrappedTrimDSNameBy( *ppszServerDn, 2, &pszBaseSearchDn );
            Assert( !ret );
            fBaseAlloced = TRUE;

            ldap_value_freeW(ppszServerDn);
        } else {
            Assert( !"serverName should have been returned" );
        }
    }

    PrintMsg(REPADMIN_SHOWCONN_BASE_DN, pszBaseSearchDn);
    PrintMsg(REPADMIN_SHOWCONN_KCC_CONN_OBJS_HDR);

    ret = FindConnections( hld, pszBaseSearchDn, pszFrom,
                           TRUE /*showconn*/, fVerbose, fIntersite );

cleanup:

    ldap_unbind(hld);

    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }

    if (fBaseAlloced) {
        free( pszBaseSearchDn );
    }

    return ret;
}

int
ShowSiteLatency(
    LDAP *          hld,
    HANDLE          hDS,
    BOOL            fVerbose,
    LPWSTR          pszSitesContainer
    )
/*
One possible enhancement is to check whether the latency exceeds some threshold.
If so, report that replication is taking too long. A related check would be to
check whether the last local update occurred a long time ago in the past. If
current time - local time > threshold, report an error for an overdue update.

 */
{
    int ret = 0;
    int             ldStatus;
    DWORD           status;
    BOOL            result;
    static LPWSTR   rgpszSSAttrs[] = {L"whenChanged", NULL};
    LDAPSearch *    pSearch;
    LDAPMessage *   pResults;
    LDAPMessage *   pEntry;
    ULONG           ulTotalEstimate;
    SYSTEMTIME      stTime;
    FILETIME        ftTime, ftTimeCurrent;
    DSTIME          dsTimeLocal, dsTimeOrig, dsTimeCurrent;
    CHAR            szTime[SZDSTIME_LEN];
    CHAR            szTime2[SZDSTIME_LEN];
    DWORD           hours, mins, secs, ver;

    GetSystemTimeAsFileTime( &ftTimeCurrent );
    FileTimeToDSTime(ftTimeCurrent, &dsTimeCurrent);

    // Search for all Site Settings Objects

    pSearch = ldap_search_init_pageW(hld,
				    pszSitesContainer,
				    LDAP_SCOPE_SUBTREE,
				    L"(objectCategory=ntdsSiteSettings)",
				    rgpszSSAttrs,
				    FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
	CHK_LD_STATUS(LdapGetLastError());	
    }

    ldStatus = ldap_get_next_page_s(hld,
				     pSearch,
				     0,
				     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
				     &ulTotalEstimate,
				     &pResults);
    if (ldStatus == LDAP_SUCCESS) {
        PrintMsg(REPADMIN_LATENCY_HDR);
    }
    while(ldStatus == LDAP_SUCCESS){

        for (pEntry = SAFE_LDAP_FIRST_ENTRY(hld, pResults);
	     NULL != pEntry;
	     pEntry = ldap_next_entry(hld, pEntry)) {

            LPWSTR          pszDN;
            LPWSTR *        ppszRDNs;
            LPWSTR *        ppszWhenChanged;
            DS_REPL_OBJ_META_DATA * pObjMetaData;
            DWORD iprop;
            LPWSTR pszSite;

	    pszDN = ldap_get_dnW(hld, pEntry);
	    if (NULL == pszDN) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }

	    ppszRDNs = ldap_explode_dnW(pszDN, 1);
            if (ppszRDNs == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
	    pszSite = ppszRDNs[1];

            ppszWhenChanged = ldap_get_valuesW(hld, pEntry,
                                    L"whenChanged");
            if (ppszWhenChanged == NULL) {
                continue;
            }

            status = GeneralizedTimeToSystemTime( *ppszWhenChanged, &stTime );
            Assert( status == 0 );
            result = SystemTimeToFileTime( &stTime, &ftTime );
            Assert( result );
            FileTimeToDSTime(ftTime, &dsTimeLocal);

            ret = DsReplicaGetInfoW(hDS,
                                    DS_REPL_INFO_METADATA_FOR_OBJ,
                                    pszDN,
                                    NULL, // puuid
                                    &pObjMetaData);
            if (ERROR_SUCCESS != ret) {
                PrintFuncFailed(L"DsReplicaGetInfo", ret);
                return ret;
            }

            // TODO: lookup entry in metadata vector using bsearch()
            for (iprop = 0; iprop < pObjMetaData->cNumEntries; iprop++) {
                if (wcscmp( pObjMetaData->rgMetaData[iprop].pszAttributeName,
                             L"interSiteTopologyGenerator" ) == 0) {
                    FileTimeToDSTime(pObjMetaData->rgMetaData[iprop].ftimeLastOriginatingChange, &dsTimeOrig);
                    ver = pObjMetaData->rgMetaData[iprop].dwVersion;
                    break;
                }
            }
            Assert( iprop < pObjMetaData->cNumEntries );

            if (dsTimeLocal >= dsTimeOrig) {
                secs = (DWORD)(dsTimeLocal - dsTimeOrig);
            } else {
                secs = 0;
            }
            mins = secs / 60;
            secs %= 60;
            hours = mins / 60;
            mins %= 60;

            PrintMsg(REPADMIN_LATENCY_DATA_1,
                     pszSite, ver,
                     DSTimeToDisplayString(dsTimeLocal, szTime),
                     DSTimeToDisplayString(dsTimeOrig, szTime2) );
            PrintMsg(REPADMIN_PRINT_STR_NO_CR, L" ");
            PrintMsg(REPADMIN_PRINT_HH_MM_SS_TIME,
                     hours, mins, secs );
                     
            if (dsTimeCurrent >= dsTimeLocal) {
                secs = (DWORD)(dsTimeCurrent - dsTimeLocal);
            } else {
                secs = 0;
            }
            mins = secs / 60;
            secs %= 60;
            hours = mins / 60;
            mins %= 60;

            PrintMsg(REPADMIN_PRINT_STR_NO_CR, L"  ");
            PrintMsg(REPADMIN_PRINT_HH_MM_SS_TIME,
                     hours, mins, secs );
            PrintMsg(REPADMIN_PRINT_CR);

            DsReplicaFreeInfo(DS_REPL_INFO_METADATA_FOR_OBJ, pObjMetaData);
            ldap_memfreeW(pszDN);
	    ldap_value_freeW(ppszRDNs);
            ldap_value_freeW(ppszWhenChanged);
        }

	ldap_msgfree(pResults);
	pResults = NULL;

	ldStatus = ldap_get_next_page_s(hld,
                                     pSearch,
                                     0,
                                     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                     &ulTotalEstimate,
                                     &pResults);
    } // end while more pages to search.
    if(ldStatus != LDAP_NO_RESULTS_RETURNED){
        CHK_LD_STATUS(ldStatus);
    }

    ldStatus = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(ldStatus);

    // Cleanup

    return ret;
}

int
ShowSiteBridgeheads(
    LDAP *          hld,
    HANDLE          hDS,
    BOOL            fVerbose,
    LPWSTR          pszSiteDn
    )
/*
It is helpful to understand how failures are cached. Failures are added to a server's
cache as follows:
1. A connection failure is added when the KCC's DsReplicaAdd fails. It is added in
   the destination's cache on behalf of the source.
2. A link failure is added if there are any replica link errors on that server. This
   is refreshed each time the KCC runs.  It is added on the destination's cache on
   behalf of whichever link source failed.
3. The ISTG adds a connection failure for each bridgehead it cannot contact.
4. The ISTG merge's each bridgehead's cache into its own.

Thus, a bridgehead (or any destination) has cached entries on behalf of sources
it talks to.  An ISTG has cached connection failures for bridgeheads it cannot
reach, and cached entries for remote bridgeheads which the local bridgeheads
can't reach.
 */

{
    int             ret = 0;
    int             ldStatus, ldStatus1;
    LDAPSearch *    pSearch = NULL;
    LDAPMessage *   pldmConnResults;
    LDAPMessage *   pldmConnEntry;
    LPWSTR          rgpszConnAttrsToRead[] = {L"fromServer", L"mS-DS-ReplicatesNCReason", L"transportType", NULL};
    CHAR            szTime[SZDSTIME_LEN];
    DWORD           i;
    ULONG           ulTotalEstimate;
    DS_REPL_KCC_DSA_FAILURESW * pConnFailures = NULL, * pLinkFailures = NULL;
    DSTIME dsFirstFailure;
    DWORD cNumFailures, dwLastResult;

    // Dump failure counts for each unique server
    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,
                            NULL, NULL, &pConnFailures);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        // keep going
    }

    ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                            NULL, NULL, &pLinkFailures);
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"DsReplicaGetInfo", ret);
        // keep going
    }

    // Retrieve all the connections under the given base

    pSearch = ldap_search_init_pageW(hld,
                                     pszSiteDn,
                                     LDAP_SCOPE_SUBTREE,
                                     L"(objectClass=nTDSConnection)",
                                     rgpszConnAttrsToRead,
                                     FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
        CHK_LD_STATUS(LdapGetLastError());
    }

    ldStatus = ldap_get_next_page_s(hld,
                                     pSearch,
                                     0,
                                     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                     &ulTotalEstimate,
                                     &pldmConnResults);

    if (ldStatus == LDAP_SUCCESS) {
        PrintMsg(REPADMIN_BRIDGEHEADS_HDR);
    }
    while (ldStatus == LDAP_SUCCESS) {

        for (pldmConnEntry = SAFE_LDAP_FIRST_ENTRY(hld, pldmConnResults);
            NULL != pldmConnEntry;
            pldmConnEntry = ldap_next_entry(hld, pldmConnEntry)) {
            LPWSTR pszDn;
            LPWSTR *ppszRDNs, *ppszFromRDNs;
            LPWSTR *ppszFromServer;
            LPWSTR *ppszTransportType;
            DWORD  dwOptions, i;
            LPWSTR *ppszNcReason;
            LPWSTR pszBridgeheadDn;

            // fromServer filter
            ppszFromServer = ldap_get_valuesW(hld, pldmConnEntry, L"fromServer");
            if (NULL == ppszFromServer) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            Assert(1 == ldap_count_valuesW(ppszFromServer));
            ppszFromRDNs = ldap_explode_dnW(*ppszFromServer, 1);
            if (ppszFromRDNs == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            Assert(6 < ldap_count_valuesW(ppszFromRDNs));
            // NTDS settings,<server>,Servers,<site>,Sites,<Config NC>

            // Connection object dn filter
            pszDn = ldap_get_dnW(hld, pldmConnEntry);
            if (NULL == pszDn) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            ppszRDNs = ldap_explode_dnW(pszDn, 1);
            if (ppszRDNs == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }
            Assert(6 < ldap_count_valuesW(ppszRDNs));
            // <conn>,ntds settings,<server>,Servers,<site>,Sites,Config NC
            // Only want destination and source which are in different sites
            if (!wcscmp( ppszFromRDNs[3], ppszRDNs[4] )) {
                ldap_value_freeW(ppszRDNs);
                ldap_value_freeW(ppszFromRDNs);
                ldap_value_freeW(ppszFromServer);
                ldap_memfreeW(pszDn);
                continue;
            }
            PrintMsg(REPADMIN_BRIDGEHEADS_DATA_1,
                     ppszFromRDNs[3], ppszRDNs[2] );

            ldap_value_freeW(ppszRDNs);
            ldap_value_freeW(ppszFromRDNs);

            // transportType
            ppszTransportType = ldap_get_valuesW(hld, pldmConnEntry, L"transportType");
            // Not present on intra-site connections
            if (ppszTransportType != NULL) {
                Assert(1 == ldap_count_valuesW(ppszTransportType));
                ppszRDNs = ldap_explode_dnW(*ppszTransportType, 1);
                if (ppszRDNs != NULL) {
                    Assert(6 < ldap_count_valuesW(ppszRDNs));
                    // <transport>,Intersite Transports,Sites,<Config NC>
                    PrintMsg(REPADMIN_BRIDGEHEADS_DATA_2, ppszRDNs[0] );
                    ldap_value_freeW(ppszRDNs);
                } else {
                    REPORT_LD_STATUS(LdapGetLastError());	
                }
                ldap_value_freeW(ppszTransportType);
            } else {
                PrintMsg(REPADMIN_BRIDGEHEADS_DATA_2, L"RPC");
            }

            // Look for failures. The failures that can be displayed are either that
            // we can't reach the bridgehead, or that the bridgehead can't reach
            // the remote source.

            // Trim name by one part
            ret = WrappedTrimDSNameBy( pszDn, 1, &pszBridgeheadDn );
            Assert( !ret );
            if ( (!findFailure( pConnFailures, pszBridgeheadDn, &dsFirstFailure, &cNumFailures, &dwLastResult )) &&
                 (!findFailure( pConnFailures, *ppszFromServer, &dsFirstFailure, &cNumFailures, &dwLastResult )) &&
                 (!findFailure( pLinkFailures, *ppszFromServer, &dsFirstFailure, &cNumFailures, &dwLastResult )) ) {
                dsFirstFailure = 0;
                cNumFailures = 0;
                dwLastResult = 0;
            }
            PrintMsg(REPADMIN_BRIDGEHEADS_DATA_3, 
                     DSTimeToDisplayString(dsFirstFailure, szTime), cNumFailures, Win32ErrToString(dwLastResult) );
            PrintMsg(REPADMIN_PRINT_CR);

            // ms-DS-ReplicatesNCReason
            ppszNcReason = ldap_get_valuesW(hld, pldmConnEntry, L"mS-DS-ReplicatesNCReason");
            // See if new attribute written by post-b3 server
            if (ppszNcReason) {
                DWORD dwReason, cbLength;
                PVOID pvData;
                LPWSTR pszNcDn;

                if (!fVerbose) { PrintMsg(REPADMIN_PRINT_STR_NO_CR, L"                " ); } // end of line
                for ( i = 0; i < ldap_count_valuesW(ppszNcReason); i++ ) {
                    if (!decodeLdapDistnameBinary(
                                                 ppszNcReason[i], &pvData, &cbLength, &pszNcDn)) {
                        PrintMsg(REPADMIN_SHOWCONN_INVALID_DISTNAME_BIN_VAL,
                                ppszNcReason[i] );
                        break;
                    }
                    if (!fVerbose) {
                        ppszRDNs = ldap_explode_dnW(pszNcDn, 1);
                        if (NULL != ppszRDNs) {
                            PrintMsg(REPADMIN_PRINT_STR_NO_CR, L" ");
                            PrintMsg(REPADMIN_PRINT_STR_NO_CR, ppszRDNs[0] );
                            ldap_value_freeW(ppszRDNs);
                        } else {
                            REPORT_LD_STATUS(LdapGetLastError());	
                        }
                    } else {
                        ShowBridgeheadNeighbor( hld, (i == 0),
                                                pszBridgeheadDn, pszNcDn, *ppszFromServer );
                    }

                    free( pvData );
                }

                if(fVerbose){
                    // After we show the bridghead neighbors info, we need
                    // to reprint the header, because otherwise the output
                    // is very confusing.
                    PrintMsg(REPADMIN_BRIDGEHEADS_HDR);
                }

                ldap_value_freeW(ppszNcReason);
                if (!fVerbose) { PrintMsg(REPADMIN_PRINT_CR); } // end of line
            }

            ldap_memfreeW(pszDn);
            ldap_value_freeW(ppszFromServer);
            free( pszBridgeheadDn );

        } // end for more entries in a single page


        ldap_msgfree(pldmConnResults);
        pldmConnResults = NULL;

        ldStatus = ldap_get_next_page_s(hld,
                                         pSearch,
                                         0,
                                         DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                         &ulTotalEstimate,
                                         &pldmConnResults);
    } // End while more pages to search
    if (ldStatus != LDAP_NO_RESULTS_RETURNED) {
        CHK_LD_STATUS(ldStatus);
    }

    if (pConnFailures) {
        DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pConnFailures);
        pConnFailures = NULL;
    }
    if (pLinkFailures) {
        DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, pLinkFailures);
        pLinkFailures = NULL;
    }

    ldStatus1 = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(ldStatus1);

    ret = LdapMapErrorToWin32( ldStatus );

    return ret;
}

int
ShowIstgSite(
    LDAP *          hld,
    HANDLE          hDS,
    SHOW_ISTG_FUNCTION_TYPE eFunc,
    BOOL fVerbose
    )
{
    int ret = 0;
    int             ldStatus;
    LPWSTR          rgpszRootAttrsToRead[] = {L"configurationNamingContext",
                                              L"dsServiceName",
                                              L"dnsHostName",
                                              NULL};
    static WCHAR    wszSitesRdn[] = L"CN=Sites,";
    LDAPMessage *   pRootResults = NULL;
    LPWSTR *        ppszConfigNC = NULL;
    LPWSTR *        ppszDsServiceName = NULL;
    LPWSTR *        ppszServiceRDNs = NULL;
    LPWSTR *        ppszDnsHostName = NULL;
    LPWSTR          pszSitesContainer = NULL;

    // What's the DN of the config NC?
    ldStatus = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)",
                              rgpszRootAttrsToRead, 0, &pRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    ppszConfigNC = ldap_get_valuesW(hld, pRootResults,
                                    L"configurationNamingContext");
    if (NULL == ppszConfigNC) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    ppszDsServiceName = ldap_get_valuesW(hld, pRootResults,
                                    L"dsServiceName");
    if (NULL == ppszDsServiceName) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    ppszDnsHostName = ldap_get_valuesW(hld, pRootResults,
                                    L"dnsHostName");
    if (NULL == ppszDnsHostName) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }

    // Build the Sites Container DN
    pszSitesContainer = malloc( ( wcslen( *ppszConfigNC ) * sizeof( WCHAR ) ) +
                                sizeof( wszSitesRdn ) );
    CHK_ALLOC( pszSitesContainer );
    wcscpy( pszSitesContainer, wszSitesRdn );
    wcscat( pszSitesContainer, *ppszConfigNC );

    // Get the site name
    ppszServiceRDNs = ldap_explode_dnW(*ppszDsServiceName, 1);
    if (ppszServiceRDNs == NULL) {
        REPORT_LD_STATUS(LdapGetLastError());	
        ret = ERROR_DS_DRA_BAD_DN;
        goto cleanup;
    }

    switch(eFunc) {
    case SHOW_ISTG_LATENCY:
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_LATENCY_FOR_SITE, 
                ppszServiceRDNs[3], *ppszDnsHostName );
        ret = ShowSiteLatency( hld, hDS, fVerbose, pszSitesContainer );
        break;
    case SHOW_ISTG_BRIDGEHEADS:
    {
        LPWSTR pszSiteDn;
        // Trim name by 3 parts
        // Remove NTDS Settings, <server>, Servers
        ret = WrappedTrimDSNameBy( *ppszDsServiceName, 3, &pszSiteDn );
        Assert( !ret );

        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_SHOWISTG_BRDIGEHEADS,
                ppszServiceRDNs[3], *ppszDnsHostName );
        ret = ShowSiteBridgeheads( hld, hDS, fVerbose, pszSiteDn );
        free( pszSiteDn );
        break;
    }
    }

    // Cleanup
cleanup:

    if (ppszConfigNC) {
        ldap_value_freeW(ppszConfigNC);
    }
    if (ppszServiceRDNs) {
        ldap_value_freeW(ppszServiceRDNs);
    }
    if (ppszDsServiceName) {
        ldap_value_freeW(ppszDsServiceName);
    }
    if (ppszDnsHostName) {
        ldap_value_freeW(ppszDnsHostName);
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    if (pszSitesContainer) {
        free( pszSitesContainer );
    }

    return ret;
}

int
ShowIstgServerToSite(
    LDAP *hldHome,
    SHOW_ISTG_FUNCTION_TYPE eFunc,
    BOOL fVerbose,
    LPWSTR pszISTG
    )
{
    int ret = 0;
    int             ldStatus;
    ULONG           secondary;
    LDAP *          hld = NULL;
    HANDLE          hDS;
    LPWSTR          rgpszBaseAttrsToRead[] = {L"dnsHostName",
                                              NULL };
    LDAPMessage *   pBaseResults;
    LPWSTR *        ppszDnsHostName;
    LPWSTR          pszDSA;
    ULONG           ulOptions;

    // What's the dns host name of this object?
    ldStatus = ldap_search_sW(hldHome, pszISTG, LDAP_SCOPE_BASE, L"(objectClass=*)",
                              rgpszBaseAttrsToRead, 0, &pBaseResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pBaseResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    ppszDnsHostName = ldap_get_valuesW(hldHome, pBaseResults,
                                    L"dnsHostName");
    if (NULL == ppszDnsHostName) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    pszDSA = *ppszDnsHostName;

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        ret = ERROR_DS_SERVER_DOWN;
	goto cleanup;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Get a DS Handle too
    ret = RepadminDsBind(pszDSA, &hDS);
    if (ret != ERROR_SUCCESS) {
        PrintBindFailed(pszDSA, ret);
        goto cleanup;
    }

    ret = ShowIstgSite( hld, hDS, eFunc, fVerbose );

    secondary = DsUnBindW(&hDS);
    if (secondary != ERROR_SUCCESS) {
        PrintUnBindFailed(secondary);
        // keep going
    }

cleanup:

    if (hld != NULL) {
        ldap_unbind(hld);
    }
    if (pBaseResults) {
	ldap_msgfree(pBaseResults);
    }
    if (ppszDnsHostName) {
	ldap_value_freeW(ppszDnsHostName);
    }
    
    return ret;
}

int
ShowIstg(
    LDAP *hld,
    SHOW_ISTG_FUNCTION_TYPE eFunc,
    BOOL fVerbose
    )
{
    int ret = 0;
    int             ldStatus;
    DWORD           status;
    BOOL            result;
    LPWSTR          rgpszRootAttrsToRead[] = {L"configurationNamingContext",
                                              L"dsServiceName",
                                              L"dnsHostName",
                                              NULL};
    static WCHAR    wszSitesRdn[] = L"CN=Sites,";
    static LPWSTR   rgpszSSAttrs[] = {L"interSiteTopologyGenerator", NULL};
    LDAPMessage *   pRootResults = NULL;
    LPWSTR *        ppszConfigNC = NULL;
    LPWSTR *        ppszDsServiceName = NULL;
    LPWSTR *        ppszServiceRDNs = NULL;
    LPWSTR *        ppszDnsHostName = NULL;
    LPWSTR          pszSitesContainer = NULL;
    LDAPSearch *    pSearch;
    LDAPMessage *   pResults;
    LDAPMessage *   pEntry;
    ULONG           ulTotalEstimate;

    // What's the DN of the config NC?
    ldStatus = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)",
                              rgpszRootAttrsToRead, 0, &pRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pRootResults) {
        ret = ERROR_DS_OBJ_NOT_FOUND;
        Assert( !ret );
        goto cleanup;
    }

    ppszConfigNC = ldap_get_valuesW(hld, pRootResults,
                                    L"configurationNamingContext");
    if (NULL == ppszConfigNC) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    ppszDsServiceName = ldap_get_valuesW(hld, pRootResults,
                                    L"dsServiceName");
    if (NULL == ppszDsServiceName) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }
    ppszDnsHostName = ldap_get_valuesW(hld, pRootResults,
                                    L"dnsHostName");
    if (NULL == ppszDnsHostName) {
        ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        Assert( !ret );
        goto cleanup;
    }

    // Build the Sites Container DN
    pszSitesContainer = malloc( ( wcslen( *ppszConfigNC ) * sizeof( WCHAR ) ) +
                                sizeof( wszSitesRdn ) );
    CHK_ALLOC( pszSitesContainer );
    wcscpy( pszSitesContainer, wszSitesRdn );
    wcscat( pszSitesContainer, *ppszConfigNC );

    // Get the site name
    ppszServiceRDNs = ldap_explode_dnW(*ppszDsServiceName, 1);
    if (NULL == ppszServiceRDNs) {
        REPORT_LD_STATUS(LdapGetLastError());	
        ret = ERROR_DS_DRA_BAD_DN;
        goto cleanup;
    }

    PrintMsg(REPADMIN_SHOWISTG_GATHERING_TOPO, 
            ppszServiceRDNs[3], *ppszDnsHostName );

    // Search for all Site Settings Objects

    pSearch = ldap_search_init_pageW(hld,
				    pszSitesContainer,
				    LDAP_SCOPE_SUBTREE,
				    L"(objectCategory=ntdsSiteSettings)",
				    rgpszSSAttrs,
				    FALSE, NULL, NULL, 0, 0, NULL);
    if(pSearch == NULL){
	CHK_LD_STATUS(LdapGetLastError());	
    }

    ldStatus = ldap_get_next_page_s(hld,
				     pSearch,
				     0,
				     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
				     &ulTotalEstimate,
				     &pResults);
    if (ldStatus == LDAP_SUCCESS) {
        if (eFunc == SHOW_ISTG_PRINT) {
            PrintMsg(REPADMIN_SHOWISTG_HDR);
        }
    }
    while(ldStatus == LDAP_SUCCESS){

        for (pEntry = SAFE_LDAP_FIRST_ENTRY(hld, pResults);
	     NULL != pEntry;
	     pEntry = ldap_next_entry(hld, pEntry)) {

            LPWSTR          pszDN;
            LPWSTR *        ppszRDNs1, * ppszRDNs2;
            LPWSTR *        ppszISTG;
            LPWSTR          pszSiteRDN;

	    pszDN = ldap_get_dnW(hld, pEntry);
	    if (NULL == pszDN) {
                REPORT_LD_STATUS(LdapGetLastError());	
                continue;
            }

	    ppszRDNs1 = ldap_explode_dnW(pszDN, 1);
            if (ppszRDNs1 == NULL) {
                REPORT_LD_STATUS(LdapGetLastError());	
                ldap_memfreeW(pszDN);
                continue;
            }
	    pszSiteRDN = ppszRDNs1[1];

            ppszISTG = ldap_get_valuesW(hld, pEntry,
                                    L"interSiteTopologyGenerator");

            if (ppszISTG) {
                LPWSTR pszISTGRDN;
                LPWSTR pszISTG;

                // Trim name by one part, remove NTDS Settings
                ret = WrappedTrimDSNameBy( *ppszISTG, 1, &pszISTG );
                Assert( !ret );

                switch (eFunc) {
                case SHOW_ISTG_PRINT:
                    ppszRDNs2 = ldap_explode_dnW(*ppszISTG, 1);
                    if (NULL != ppszRDNs2) {
                        pszISTGRDN = ppszRDNs2[1];
                        PrintMsg(REPADMIN_SHOWISTG_DATA_1, pszSiteRDN, pszISTGRDN );
                        ldap_value_freeW(ppszRDNs2);
                    } else {
                        REPORT_LD_STATUS(LdapGetLastError());	
                    }
                    break;
                case SHOW_ISTG_LATENCY:
                    (void) ShowIstgServerToSite( hld, eFunc, fVerbose, pszISTG );
                    break;
                case SHOW_ISTG_BRIDGEHEADS:
                    (void) ShowIstgServerToSite( hld, eFunc, fVerbose, pszISTG );
                    break;
                }

                ldap_value_freeW(ppszISTG);
                free( pszISTG );
            }

            ldap_memfreeW(pszDN);
	    ldap_value_freeW(ppszRDNs1);
        }

	ldap_msgfree(pResults);
	pResults = NULL;

	ldStatus = ldap_get_next_page_s(hld,
                                     pSearch,
                                     0,
                                     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                     &ulTotalEstimate,
                                     &pResults);
    } // end while more pages to search.
    if(ldStatus != LDAP_NO_RESULTS_RETURNED){
        CHK_LD_STATUS(ldStatus);
    }

    ldStatus = ldap_search_abandon_page(hld, pSearch);
    pSearch = NULL;
    CHK_LD_STATUS(ldStatus);

    // Cleanup
cleanup:

    if (ppszConfigNC) {
        ldap_value_freeW(ppszConfigNC);
    }
    if (ppszServiceRDNs) {
        ldap_value_freeW(ppszServiceRDNs);
    }
    if (ppszDsServiceName) {
        ldap_value_freeW(ppszDsServiceName);
    }
    if (ppszDnsHostName) {
        ldap_value_freeW(ppszDnsHostName);
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    if (pszSitesContainer) {
        free( pszSitesContainer );
    }

    return ret;

}

int
Latency(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    ULONG           secondary;
    LPWSTR          pszDSA = NULL;
    BOOL            fVerbose = FALSE;
    LDAP *          hld;
    HANDLE          hDS;
    int             iArg;
    int             ldStatus;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/v")
            || !_wcsicmp(argv[iArg], L"/verbose")) {
            fVerbose = TRUE;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    PrintMsg(REPADMIN_LATENCY_DISCLAIMER);

    ret = ShowIstg( hld, SHOW_ISTG_LATENCY, fVerbose );

    ldap_unbind(hld);

    return ret;
}

int
Istg(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    ULONG           secondary;
    LPWSTR          pszDSA = NULL;
    BOOL            fVerbose = FALSE;
    LDAP *          hld;
    HANDLE          hDS;
    int             iArg;
    int             ldStatus;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/v")
            || !_wcsicmp(argv[iArg], L"/verbose")) {
            fVerbose = TRUE;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    ret = ShowIstg( hld, SHOW_ISTG_PRINT, fVerbose );

    ldap_unbind(hld);

    return ret;
}

int
Bridgeheads(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             ret = 0;
    ULONG           secondary;
    LPWSTR          pszDSA = NULL;
    BOOL            fVerbose = FALSE;
    LDAP *          hld;
    HANDLE          hDS;
    int             iArg;
    int             ldStatus;
    ULONG           ulOptions;

    // Parse command-line arguments.
    // Default to local DSA.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/v")
            || !_wcsicmp(argv[iArg], L"/verbose")) {
            fVerbose = TRUE;
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    ret = ShowIstg( hld, SHOW_ISTG_BRIDGEHEADS, fVerbose );

    ldap_unbind(hld);

    return ret;
}

int
TestHook(
    int     argc,
    LPWSTR  argv[]
    )
{
    int         ret = 0;
    ULONG       secondary;
    LPWSTR      pszDSA = NULL;
    LDAP *      hld;
    HANDLE      hDS;
    int         iArg;
    int         ldStatus;
    LPWSTR      pszValue = NULL;
    ULONG       ulValue = 2048;
    LPWSTR      rgpszValues[2];
    LDAPModW    ModOpt = {LDAP_MOD_REPLACE, L"replTestHook", rgpszValues};
    LDAPModW *  rgpMods[] = {&ModOpt, NULL};
    ULONG       ulOptions;

    pszValue = malloc(ulValue * sizeof(WCHAR));
    if (pszValue==NULL) {
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
	return ERROR_NOT_ENOUGH_MEMORY; 
    }
    wcscpy(pszValue, L"");
    // Parse command-line arguments.
    // Default to local DSA.

    // the first (only the first) argument can be a DSA
    if (argc < 3){
        PrintMsg(REPADMIN_GENERAL_INVALID_ARGS);
	return ERROR_INVALID_PARAMETER;
    }
    iArg = 2;
    if ((argv[iArg][0]!=L'+') && (argv[iArg][0]!=L'-')) {
	// assume it's a DSA
	pszDSA = argv[iArg++];
    }


    for (; iArg < argc; iArg++) {
        if ((wcslen(pszValue) + 1 + wcslen(argv[iArg]) + 1)
                >= ulValue) { 
	    // allocate a bigger array and copy in contents
            WCHAR * pszNewValue = NULL;
	    
	    ulValue = ulValue*2;
            Assert(ulValue);
	    pszNewValue = realloc(pszValue, ulValue*sizeof(WCHAR));  
	    if (pszNewValue==NULL) {
                free(pszValue);
                return ERROR_NOT_ENOUGH_MEMORY;
	    }

	    pszValue = pszNewValue; 

	    // return and re-loop
	    iArg--;
	    continue;
	}
	if (pszValue[0]) {
	    wcscat(pszValue, L" ");
	}  
	wcscat(pszValue, argv[iArg]); 
    }

    rgpszValues[0] = pszValue;
    rgpszValues[1] = NULL;

    // Connect.
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Modify.
    ldStatus = ldap_modify_sW(hld, NULL, rgpMods);
    CHK_LD_STATUS(ldStatus);

    PrintMsg(REPADMIN_TESTHOOK_SUCCESSFULLY_INVOKED, pszValue);
    free(pszValue);

    return 0;
}

int
DsaGuid(
    int     argc,
    LPWSTR  argv[]
    )
{
    int     ret = 0;
    LDAP *  hld;
    int     iArg;
    int     ldStatus;
    LPWSTR  pszDSA;
    LPWSTR  pszUuid;
    UUID    invocationID;
    ULONG   ulOptions;

    if (argc < 3) {
        PrintMsg(REPADMIN_DSAGUID_NEED_INVOC_ID);
        return ERROR_INVALID_PARAMETER;
    } else if (argc == 3) {
        pszUuid = argv[2];
        pszDSA = L"localhost";
    } else {
        pszDSA = argv[2];
        pszUuid = argv[3];
    }

    ret = UuidFromStringW(pszUuid, &invocationID);
    if (ret) {
        PrintFuncFailed(L"UuidFromString", ret);
        return ret;
    }

    // Connect.
    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // Translate DSA invocationID / objectGuid.
    BuildGuidCache(hld);
    PrintMsg(REPADMIN_DSAGUID_DATA_LINE, pszUuid, GetDsaGuidDisplayName(&invocationID));

    return 0;
}

int
ShowProxy(
    int     argc,
    LPWSTR  argv[]
    )
{
    int             iArg;
    LPWSTR          pszNC = NULL;
    LPWSTR          pszDSA = NULL;
    LPWSTR          pszMatch = NULL; 
    LDAP *          hld = NULL;
    ULONG           ulOptions;
    int             ldStatus;
    LDAPMessage *   pRootResults = NULL;
    int             ret = 0;
    LPWSTR          *ppszDefaultNc = NULL;
    LDAPSearch *    pSearch = NULL;
    LPWSTR          pszContainer = NULL;
#define INFRASTRUCTURE_CONTAINER_W L"cn=Infrastructure,"
    LPWSTR          pszSearchBase;
    DWORD           dwSearchScope;
    LPWSTR          rgpszUpdateAttrsToRead[] = {
        // Code below depends on this order
        L"objectGuid", L"proxiedObjectName", NULL };
    LDAPControlW     ctrlShowDeleted = { LDAP_SERVER_SHOW_DELETED_OID_W };
    LDAPControlW *   rgpctrlServerCtrls[] = { &ctrlShowDeleted, NULL };
    LDAPMessage *   pldmUpdateResults = NULL;
    LDAPMessage *   pldmUpdateEntry;
    BOOL            fVerbose = FALSE;
    BOOL            fMovedObjectSearch = FALSE;
    LPWSTR          pszLdapHostList = NULL;

    // Parse command-line arguments.
    // Default to local DSA, not verbose, cache guids.
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/v")
            || !_wcsicmp(argv[iArg], L"/verbose")) {
            fVerbose = TRUE;
        } else if (!_wcsicmp(argv[iArg], L"/m")
            || !_wcsicmp(argv[iArg], L"/moved")
            || !_wcsicmp(argv[iArg], L"/movedobject")) {
            fMovedObjectSearch = TRUE;
        }
        else if ((NULL == pszNC) && (NULL != wcschr(argv[iArg], L'='))) {
            pszNC = argv[iArg];
        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else if (NULL == pszMatch) {
            pszMatch = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    // Select our target server
    if (NULL == pszDSA) {
        pszDSA = L"localhost";
    }
    // Bind on the GC port first if available
    pszLdapHostList = (LPWSTR) malloc(
        (wcslen(pszDSA) * 2 + 15) * sizeof( WCHAR ) );
    if (pszLdapHostList == NULL) {
        ret = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    swprintf( pszLdapHostList, L"%s:%d %s:%d",
              pszDSA, LDAP_GC_PORT,
              pszDSA, LDAP_PORT );

    hld = ldap_initW(pszLdapHostList, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        ret = ERROR_DS_UNAVAILABLE;
        goto cleanup;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    // Don't follow referrals.
    ulOptions = PtrToUlong(LDAP_OPT_OFF);
    (void)ldap_set_optionW( hld, LDAP_OPT_REFERRALS, &ulOptions );

    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    // If NC not specified, get default nc for this server
    if (NULL == pszNC) {
        LPWSTR rgpszRootAttrsToRead[] = {L"defaultNamingContext", NULL};

        ldStatus = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)",
                                  rgpszRootAttrsToRead, 0, &pRootResults);
        CHK_LD_STATUS(ldStatus);
        if (NULL == pRootResults) {
            ret = ERROR_DS_OBJ_NOT_FOUND;
            goto cleanup;
        }

        ppszDefaultNc = ldap_get_valuesW(hld, pRootResults, rgpszRootAttrsToRead[0] );
        if (NULL == ppszDefaultNc) {
            ret = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
            goto cleanup;
        }
        pszNC = *ppszDefaultNc;
        PrintMsg(REPADMIN_SHOWPROXY_SEARCHING_NC, pszNC);
    }

    // Construct the search container
    if (fMovedObjectSearch) {
        pszSearchBase = pszNC;
        dwSearchScope = LDAP_SCOPE_BASE;
    } else {
        pszContainer = malloc( ( wcslen( INFRASTRUCTURE_CONTAINER_W ) +
                                 wcslen( pszNC ) +
                                 1) * sizeof( WCHAR ) );
        if (pszContainer == NULL) {
            ret = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        wcscpy( pszContainer, INFRASTRUCTURE_CONTAINER_W );
        wcscat( pszContainer, pszNC );

        pszSearchBase = pszContainer;
        dwSearchScope = LDAP_SCOPE_ONELEVEL;
    }

    // Search for proxy objects on this server under the container
    //
    // ***************************************************************************************
    //

    pSearch = ldap_search_init_pageW(hld,
                                     pszSearchBase,
                                     dwSearchScope,
                                     L"(proxiedObjectName=*)",  // this is indexed
                                     rgpszUpdateAttrsToRead,
                                     FALSE,
                                     rgpctrlServerCtrls, NULL,
                                     0, 0, NULL);
    if(pSearch == NULL){
        CHK_LD_STATUS(LdapGetLastError());
    }

    ldStatus = ldap_get_next_page_s(hld,
                                    pSearch,
                                    0,
                                    DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                    NULL,
                                    &pldmUpdateResults);

    while (ldStatus == LDAP_SUCCESS) {

        for (pldmUpdateEntry = SAFE_LDAP_FIRST_ENTRY(hld, pldmUpdateResults);
            NULL != pldmUpdateEntry;
            pldmUpdateEntry = ldap_next_entry(hld, pldmUpdateEntry))
        {
            LPWSTR *ppszProxiedObjectName;
            DWORD cbLength = 0;
            PVOID pvData = NULL;
            LPWSTR pszTargetDn = NULL;

            ppszProxiedObjectName = ldap_get_valuesW(hld, pldmUpdateEntry,
                                                     rgpszUpdateAttrsToRead[1] );
            // By virtue of search filter, this attr should be present
            if (!decodeLdapDistnameBinary(
                *ppszProxiedObjectName, &pvData, &cbLength, &pszTargetDn)) {
                PrintMsg(REPADMIN_SHOWCONN_INVALID_DISTNAME_BIN_VAL,
                        *ppszProxiedObjectName );
                goto loop_cleanup;
            }

            if ( pszMatch &&
                 pszTargetDn &&
                 !wcsstr( pszTargetDn, pszMatch ) ) {
                // No match, skip
                goto loop_cleanup;
            }

            PrintMsg(REPADMIN_PRINT_CR);
            // DN
            if (fVerbose || fMovedObjectSearch) {
                LPWSTR pszDn;
                pszDn = ldap_get_dnW(hld, pldmUpdateEntry);
                if (NULL == pszDn) {
                    REPORT_LD_STATUS(LdapGetLastError());	
                    continue;
                }
                if (fMovedObjectSearch)
                    PrintMsg(REPADMIN_SHOWPROXY_OBJECT_DN, pszDn);
                else
                    PrintMsg(REPADMIN_SHOWPROXY_PROXY_DN, pszDn);
                ldap_memfreeW(pszDn);
            }

            // objectGuid
            if (fVerbose || fMovedObjectSearch) {
                struct berval **ppbvGuid = NULL;
                GUID *pGuid;

                ppbvGuid = ldap_get_values_lenW(hld, pldmUpdateEntry, rgpszUpdateAttrsToRead[0]);
                if (NULL == ppbvGuid) {
                    REPORT_LD_STATUS(LdapGetLastError());	
                    continue;
                }
                pGuid = (GUID *) ppbvGuid[0]->bv_val;
                PrintMsg(REPADMIN_SHOWPROXY_OBJECT_GUID, GetStringizedGuid( pGuid ));
                ldap_value_free_len(ppbvGuid);
            }

            // proxiedObjectName
            if (fMovedObjectSearch)
                PrintMsg(REPADMIN_SHOWPROXY_MOVED_FROM_NC, pszTargetDn);
            else
                PrintMsg(REPADMIN_SHOWPROXY_MOVED_TO_DN, pszTargetDn );
            if (cbLength >= 2 * sizeof(DWORD)) {
                DWORD dwProxyType, dwProxyEpoch;

                dwProxyType = ntohl( *( (LPDWORD) (pvData) ) );
                dwProxyEpoch = ntohl( *( (LPDWORD) ( ((PBYTE)pvData) + sizeof(DWORD)) ) );
                PrintMsg(REPADMIN_SHOWPROXY_PROXY_TYPE, dwProxyType);
                switch (dwProxyType) {
                case 0: 
                    PrintMsg(REPADMIN_SHOWPROXY_PROXY_TYPE_MOVED_OBJ);
                    break;
                case 1:
                    PrintMsg(REPADMIN_SHOWPROXY_PROXY_TYPE_PROXY);
                    break;
                default:
                    PrintMsg(REPADMIN_SHOWPROXY_PROXY_TYPE_UNKNOWN);
                    break;
                }
                PrintMsg(REPADMIN_PRINT_CR);
                PrintMsg(REPADMIN_SHOWPROXY_PROXY_EPOCH, dwProxyEpoch);
            }

        loop_cleanup:

            if (pvData) {
                free( pvData );
            }
            ldap_value_freeW(ppszProxiedObjectName);

        } // end for more entries in a single page

        ldap_msgfree(pldmUpdateResults);
        pldmUpdateResults = NULL;

        ldStatus = ldap_get_next_page_s(hld,
                                        pSearch,
                                        0,
                                        DEFAULT_PAGED_SEARCH_PAGE_SIZE,
                                        NULL,
                                        &pldmUpdateResults);
    } // End while more pages to search
    if (ldStatus != LDAP_NO_RESULTS_RETURNED) {
        CHK_LD_STATUS(ldStatus);
    }    


cleanup:

    if (hld){
        ldap_unbind(hld);
    }

    if (ppszDefaultNc) {
        ldap_value_freeW(ppszDefaultNc);
    }
    if (pRootResults) {
        ldap_msgfree(pRootResults);
    }
    if (pszContainer) {
        free( pszContainer );
    }
    if (pszLdapHostList) {
        free( pszLdapHostList );
    }

    return 0;
}


void PrintNotifyOpt(IN LPOPTIONAL_VALUE  pFirstInterval,
                    IN LPOPTIONAL_VALUE  pSubsInterval,
                    IN BOOL fNewlySet)
/*++

Routine Description:

    Helper function for NotifyOpt()
    Responsible for priniting First and Subsequent 
    replication delays
    
    If any of the delays are equal to -1 it prints that the value is not set.

Arguments:

    iFirstInterval - First delay
    iSubsInterval  - Subsequent delay
    fNewlySet      - flag, that controls what header to print.

Return Value:

    None

--*/
{
    Assert(pFirstInterval);
    Assert(pSubsInterval);

    if ( !fNewlySet ) 
    {
        PrintMsg(REPADMIN_NOTIFYOPT_CURRENT);
    }
    else
    {
        PrintMsg(REPADMIN_NOTIFYOPT_NEWLYSET);
    }
    
    if (pFirstInterval->fPresent ) 
    {
        PrintMsg(REPADMIN_NOTIFYOPT_SHOWFIRST, pFirstInterval->dwValue );
    }
    else
    {
        PrintMsg(REPADMIN_NOTIFYOPT_SHOWFIRST_NOTSET);
    }
    
    if (pSubsInterval->fPresent) 
    {
        PrintMsg(REPADMIN_NOTIFYOPT_SHOWSUBS, pSubsInterval->dwValue);
    }
    else
    {
        PrintMsg(REPADMIN_NOTIFYOPT_SHOWSUBS_NOTSET);
    }
}

int NotifyOpt(int argc, LPWSTR argv[])
/*++

Routine Description:

    Responsible for handling /notifyopt switch. Displays and sets 
    Replication Notification intervals.

Arguments:

    argc and argv - same arguments that is passed to main()

Return Value:

    Win32 error

--*/
{
    DWORD                 ret = 0;
    DWORD                 lderr = 0;

    INT                   iArg;
    
    LPWSTR                pszDSA = NULL;
    LPWSTR                pszNC = NULL;

    LPWSTR                pszFirstIntervalToSet = NULL;
    LPWSTR                pszSubsIntervalToSet  = NULL;
    
    OPTIONAL_VALUE        stFirstIntervalToSet = {0};
    OPTIONAL_VALUE        stSubsIntervalToSet =  {0};
    
    LPOPTIONAL_VALUE      pFirstIntervalToSet = NULL;
    LPOPTIONAL_VALUE      pSubsIntervalToSet =  NULL;
    
    INT                   iTemp = 0;

    LDAP *                hld = NULL;
    ULONG                 ulOptions;

    OPTIONAL_VALUE        stCurrentFirstInterval = {0};
    OPTIONAL_VALUE        stCurrentSubsInterval  = {0};
    
    LPWSTR                pszCurrentServerDn = NULL;
    LPWSTR                pszDomainNamingFsmoDn = NULL;

    //
    // Parse command-line arguments.
    // Default to local DSA
    //
    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsnicmp(argv[ iArg ], L"/first:", 7)) {
            pszFirstIntervalToSet = argv[ iArg ] + 7;
        }
        else if (!_wcsnicmp(argv[ iArg ], L"/subs:", 6)) {
            pszSubsIntervalToSet = argv[ iArg ] + 6;
        }
        else if ((NULL == pszNC) && (NULL != wcschr(argv[iArg], L','))) {
            pszNC = argv[iArg];        

        }
        else if (NULL == pszDSA) {
            pszDSA = argv[iArg];
        }
        else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_FUNCTION;
        }
    }

    if (pszNC == NULL) {
        PrintMsg(REPADMIN_PRINT_NO_NC);
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == pszDSA) {
        pszDSA = L"localhost"; 
                                    
    }

    if (NULL != pszFirstIntervalToSet) {
        pFirstIntervalToSet = &stFirstIntervalToSet;
        
        iTemp = _wtoi(pszFirstIntervalToSet );

        if ( iTemp > 0) 
        {
            stFirstIntervalToSet.fPresent = TRUE;
            stFirstIntervalToSet.dwValue  = iTemp;
        }
        //else stFirstIntervalToSet.fPresent initialized as false.
    }
    
    if (NULL != pszSubsIntervalToSet) {
        pSubsIntervalToSet = &stSubsIntervalToSet;
        
        iTemp = _wtoi(pszSubsIntervalToSet );
        
        if ( iTemp > 0) 
        {
            stSubsIntervalToSet.fPresent = TRUE;
            stSubsIntervalToSet.dwValue  = iTemp;
        }
        //else initialized as false.
    }

    //
    // Connect to source
    //
    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        ret = ERROR_DS_SERVER_DOWN;
        goto error;
    }

    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    //
    //Bind
    //
    lderr = ldap_bind_sA(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(lderr);

    lderr =  GetNCReplicationDelays( hld, pszNC, &stCurrentFirstInterval, &stCurrentSubsInterval );
    CHK_LD_STATUS(lderr);

    
    PrintNotifyOpt( &stCurrentFirstInterval, &stCurrentSubsInterval, FALSE );

    //
    // In case we need to modify 
    //
    if( pFirstIntervalToSet || pSubsIntervalToSet )
    {
        //
        // Check if we can modify, i.e. We are the domain naming fsmo
        //
        lderr = GetRootAttr(hld, L"dsServiceName", &pszCurrentServerDn);
        CHK_LD_STATUS(lderr);

        if(pszCurrentServerDn == NULL)
        {
            PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
            ret = ERROR_NOT_ENOUGH_MEMORY;
            goto error;
        }
        
        lderr = GetDomainNamingFsmoDn(hld, &pszDomainNamingFsmoDn);
        CHK_LD_STATUS(lderr);

        if( pszDomainNamingFsmoDn == NULL)
        {
            PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
            ret = ERROR_NOT_ENOUGH_MEMORY;
            goto error;
        }
        
        //
        // Check if they are equal
        //
        if( wcscmp(pszCurrentServerDn, pszDomainNamingFsmoDn) )
        {
            // 
            // Apparently we're not using domain naming fsmo to set the interval.
            // 
            PrintMsg(REPADMIN_PLEASE_USE_DOMAIN_NAMING_FSMO, pszDomainNamingFsmoDn+17 ); //17 is for skipping "cn=ntds settings,"
            goto error;

        }
        
        //
        // If we're trying to delete the attribute, that is already not present, we need not touch it at all
        // since SetNCReplicationDelays will complain otherwise
        //
        if ( (stCurrentFirstInterval.fPresent == FALSE) && pFirstIntervalToSet && (pFirstIntervalToSet->fPresent == FALSE) ) 
        {
            pFirstIntervalToSet = NULL;
        }
        
        if ( (stCurrentSubsInterval.fPresent == FALSE) && pSubsIntervalToSet && (pSubsIntervalToSet->fPresent == FALSE) ) 
        {
            pSubsIntervalToSet = NULL;
        }
        
        if ( pFirstIntervalToSet ||  pSubsIntervalToSet ) 
        {
            lderr = SetNCReplicationDelays(hld, pszNC, pFirstIntervalToSet, pSubsIntervalToSet );
            CHK_LD_STATUS(lderr);
        }
        
        lderr =  GetNCReplicationDelays( hld, pszNC, &stCurrentFirstInterval, &stCurrentSubsInterval );
        CHK_LD_STATUS(lderr);

        PrintNotifyOpt( &stCurrentFirstInterval, &stCurrentSubsInterval, TRUE );

    }


error:
    if (pszCurrentServerDn) 
    {
        LocalFree(pszCurrentServerDn);
    }
    
    if( pszDomainNamingFsmoDn == NULL)
    {
        LocalFree(pszDomainNamingFsmoDn);
    }

    if (hld) 
    {
        ldap_unbind(hld);
    }

    return ret;
}

int
GetNTDSA(
    IN LDAP * hld,
    OUT LPWSTR * ppszDsaDN
    )
/*++

Routine Description:

    Get the ndts settings object of the dc connected to with hld

Arguments:

    hld - ldap handle to use for search
    ppszDsaDN - DN of the ntds settings object of the dc to return
    
Return Value:

    error codes

--*/
{
    int             ret = 0;
    LDAPMessage *   pldmRootResults = NULL;
    LDAPMessage *   pldmRootEntry;
    LPSTR           rgpszRootAttrsToRead[] = {"dsServiceName", NULL};
    LPWSTR *        ppszServerNames;
    int             ldStatus;
    
    ret = ERROR_DS_OBJ_NOT_FOUND;
    // Retrieve dsServiceName DN.
    ldStatus = ldap_search_s(hld, NULL, LDAP_SCOPE_BASE, "(objectClass=*)",
                             NULL, 0, &pldmRootResults);
    CHK_LD_STATUS(ldStatus);
    if (NULL == pldmRootResults) { 
	return ret;
    } 

    pldmRootEntry = ldap_first_entry(hld, pldmRootResults);
    if (NULL != pldmRootEntry) {
        ppszServerNames = ldap_get_valuesW(hld, pldmRootEntry, L"dsServiceName");
        if (NULL != ppszServerNames) {
            Assert(1 == ldap_count_valuesW(ppszServerNames));
	    *ppszDsaDN = malloc((wcslen(ppszServerNames[0])+1)*sizeof(WCHAR));
	    if (*ppszDsaDN!=NULL) {
		wcscpy(*ppszDsaDN,ppszServerNames[0]);
		ret = ERROR_SUCCESS;
	    } 
	    ldap_value_freeW(ppszServerNames);
	}
    }

    ldap_msgfree(pldmRootResults);
    return ret;   
}

int
GetNCLists(
    IN  LDAP *  hld,
    IN  LPWSTR  pszDsaDN,
    OUT LPWSTR ** prgpszNameContexts,
    OUT int *   pcNameContexts
    )
/*++

Routine Description:

    Fill the prgpszNameContexts with all NC's held by the ntds settings object
    given by pszDsaDN.

Arguments:

    hld - ldap handle to use for search
    pszDsaDN - DN of the ntds settings object of the dc to find NC's
    prgpszNameContexts - array to hold NC list
    pcNameContexts - number of NC's in list

Return Value:

    error codes

--*/
{
    int             ldStatus;
    int             ret = ERROR_SUCCESS;
    LDAPMessage *   pldmServerResults = NULL;
    LDAPMessage *   pldmServerEntry = NULL;
    LPWSTR          rgpszServerAttrsToRead[] = {L"msDS-HasMasterNCs", L"hasMasterNCs", L"hasPartialReplicaNCs", NULL};
    LPWSTR *        ppszMasterNCs = NULL;
    LPWSTR *        ppszPartialReplicaNCs = NULL;
    ULONG           cPartialNCs = 0;
    ULONG           cMasterNCs = 0;
    ULONG           i = 0;

    __try {
	ldStatus = ldap_search_sW(hld,
				  pszDsaDN,
				  LDAP_SCOPE_BASE,
				  L"(objectClass=*)",
				  rgpszServerAttrsToRead,
				  0,
				  &pldmServerResults);
	if (ldStatus) {
	    REPORT_LD_STATUS(LdapGetLastError());	
	    GET_EXT_LD_ERROR( hld, ldStatus, &ret ); 
	    __leave;
	}
	if (NULL == pldmServerResults) {
	    REPORT_LD_STATUS(LDAP_NO_RESULTS_RETURNED);	
	    GET_EXT_LD_ERROR( hld, LDAP_NO_RESULTS_RETURNED, &ret ); 
	    __leave;
	}

	// get ldap count of return values and 

	pldmServerEntry = ldap_first_entry(hld, pldmServerResults);
	Assert(NULL != pldmServerEntry);

	// Parse nc's to calculate size requirements
	ppszMasterNCs = ldap_get_valuesW(hld, pldmServerEntry, L"msDS-HasMasterNCs");
    if (ppszMasterNCs == NULL) {
        // Fail back to "old" hasMasterNCs
        ppszMasterNCs = ldap_get_valuesW(hld, pldmServerEntry, L"hasMasterNCs");
    }
	ppszPartialReplicaNCs = ldap_get_valuesW(hld, pldmServerEntry, L"hasPartialReplicaNCs");

	if (NULL != ppszMasterNCs) {
	    cMasterNCs = ldap_count_valuesW(ppszMasterNCs);
	}

	if (NULL!= ppszPartialReplicaNCs) {
	    cPartialNCs = ldap_count_valuesW(ppszPartialReplicaNCs);
	}

	*pcNameContexts = cPartialNCs + cMasterNCs; 

	*prgpszNameContexts = malloc(*pcNameContexts * sizeof(LPWSTR));
	if (*prgpszNameContexts==NULL) {
	    *pcNameContexts = 0;
	    PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
	    ret = ERROR_NOT_ENOUGH_MEMORY;
	    __leave;
	}

	for (i=0; i<cMasterNCs; i++) { 
	    (*prgpszNameContexts)[i] = malloc(sizeof(WCHAR) *(1 + wcslen(ppszMasterNCs[i])));
	    if ((*prgpszNameContexts)[i]==NULL) {
		PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
		 ret = ERROR_NOT_ENOUGH_MEMORY;
		 __leave;
	    }
	    wcscpy((*prgpszNameContexts)[i], ppszMasterNCs[i]);
	}

	for (i=0; i < cPartialNCs; i++) {
	    (*prgpszNameContexts)[i+cMasterNCs] = malloc(sizeof(WCHAR) *(1 + wcslen(ppszPartialReplicaNCs[i])));
	    if ((*prgpszNameContexts)[i+cMasterNCs]==NULL) {
		PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
		ret = ERROR_NOT_ENOUGH_MEMORY;
		__leave;
	    }
	    wcscpy((*prgpszNameContexts)[i+cMasterNCs], ppszPartialReplicaNCs[i]);
	}

	
    }
    __finally {
	if (pldmServerResults) {
	    ldap_msgfree(pldmServerResults);
	}
	if (ppszMasterNCs) {
	    ldap_value_freeW(ppszMasterNCs);
	}
	if (ppszPartialReplicaNCs) {
	    ldap_value_freeW(ppszPartialReplicaNCs);
	}
    }
    return ret;
}

int ShowTrust(int argc, LPWSTR argv[]) 
/*++

Routine Description:

    Show domain trust information for every domain NC in all cross-refs

Arguments:

    argc -
    argv

Return Value:

    error codes

--*/
{
    LPWSTR pszDSA = L"localhost";
    DWORD err = 0;
    LDAP * hld = NULL;
    ULONG ulOptions = 0;
    LPWSTR  ppszRootDseServerAttrs [] = {
	L"configurationNamingContext",
	NULL };

    LPWSTR ppszConfigAttrs [] = {
	L"nCName",
	L"systemFlags",
	NULL };

    LPWSTR * ppszNCs;
    BERVAL ** ppSystemFlags;

    LDAPMessage *              pldmEntry = NULL;
    LDAPMessage *              pldmRootResults = NULL;
    LDAPMessage *              pldmConfigResults = NULL;
    ULONG lderr = LDAP_SUCCESS;
    LPWSTR *            ppszConfigNC = NULL;

    LDAPControlW     ctrlExtDN;
    
    LDAPControlW *   rgpctrlServerCtrls[] = { &ctrlExtDN, NULL };

    ctrlExtDN.ldctl_oid = LDAP_SERVER_EXTENDED_DN_OID_W;
    ctrlExtDN.ldctl_iscritical = TRUE;
    ctrlExtDN.ldctl_value.bv_len = 0;
    ctrlExtDN.ldctl_value.bv_val = NULL; // how do I get the sequence in here?

    if (argc > 2) {
	pszDSA = argv[2];
    }

    __try {
	hld = ldap_initW(pszDSA, LDAP_PORT);

	if (NULL == hld) {
	    PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
	    __leave;
	}

	// use only A record dns name discovery
	ulOptions = PtrToUlong(LDAP_OPT_ON);
	(void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

	lderr = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
	CHK_LD_STATUS(lderr);

	lderr = ldap_search_sW(hld, NULL, LDAP_SCOPE_BASE, L"(objectClass=*)", ppszRootDseServerAttrs,
			      0, &pldmRootResults);
	CHK_LD_STATUS(lderr);
	if (NULL == pldmRootResults) {
	    lderr = LDAP_NO_RESULTS_RETURNED;
	    REPORT_LD_STATUS(lderr);
	    __leave;
	}

	ppszConfigNC = ldap_get_valuesW(hld, pldmRootResults,
					L"configurationNamingContext");
	if (ppszConfigNC == NULL) {
	    lderr = LDAP_NO_RESULTS_RETURNED;
	    REPORT_LD_STATUS(lderr);
	    __leave;
	}

	// get the cross-refs and see which we trust
	// when markpu check's in the new TDO object code, we will need to
	// add to this so that first the TDO, then the crossref is searched for.
	lderr = ldap_search_ext_sW(hld, 
				  *ppszConfigNC,  
				  LDAP_SCOPE_SUBTREE,
				  L"(objectCategory=crossRef)", 
				  ppszConfigAttrs, 
				  0, 
				  rgpctrlServerCtrls, // Server Controls
				  NULL, // Client Controls
				  NULL, // timeout
				  0, // sizelimit
				  &pldmConfigResults);

	CHK_LD_STATUS(lderr);
	if (NULL == pldmConfigResults) {
	    lderr = LDAP_NO_RESULTS_RETURNED;
	    REPORT_LD_STATUS(lderr);
	    __leave;
	} 

        pldmEntry = ldap_first_entry( hld, pldmConfigResults );
	PrintMsg(REPADMIN_SHOW_TRUST_INFO);
	while (pldmEntry != NULL) 
	    { 
	    ppszNCs = ldap_get_valuesW( hld, pldmEntry, ppszConfigAttrs[0] );
	    ppSystemFlags = ldap_get_values_lenW( hld, pldmEntry, ppszConfigAttrs[1] );
 
	    // parse for sid, if sid is there, then domain is trusted, print TRUSTED, else UNTRUSTED 	 
	    if (ppSystemFlags && ppszNCs && ((*(ppSystemFlags[0]->bv_val)) & FLAG_CR_NTDS_DOMAIN)) {
		LPWSTR pszSID = wcsstr(*ppszNCs,L"SID");
		LPWSTR pszDomain = ParseInputW(*ppszNCs, L';', pszSID ? 2 : 1);    
		if (pszDomain) {
		    PrintTabMsg(2, pszSID!=NULL ? REPADMIN_TRUST_DOMAIN : REPADMIN_UNTRUST_DOMAIN, pszDomain);   	
		    free(pszDomain);
		    pszDomain = NULL;
		}  
	    }

	    if (ppszNCs) {
		ldap_value_freeW(ppszNCs);
		ppszNCs = NULL;
	    }
	    if (ppSystemFlags) {
		ldap_value_free_len(ppSystemFlags);
		ppSystemFlags = NULL;
	    }
	    pldmEntry = ldap_next_entry( hld, pldmEntry );
	}
       
    }
    __finally {

	// free hld.
	if (hld) {
	    ldap_unbind(hld);
	}
	
	if (pldmConfigResults) {
	    ldap_msgfree(pldmConfigResults);
	}

	if (pldmRootResults) {
	    ldap_msgfree(pldmRootResults);
	}
    }
    return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\resource.h ===
#define IDS_CMD_ADD                          (1000)
#define IDS_CMD_DEL                          (1001)
#define IDS_CMD_SYNC                         (1002)
#define IDS_CMD_SYNC_ALL                     (1003)
#define IDS_CMD_SHOW_REPS                    (1004)
#define IDS_CMD_SHOW_VECTOR                  (1005)
#define IDS_CMD_SHOW_META                    (1006)
#define IDS_CMD_ADD_REPS_TO                  (1007)
#define IDS_CMD_UPD_REPS_TO                  (1008)
#define IDS_CMD_DEL_REPS_TO                  (1009)
#define IDS_CMD_SHOW_TIME                    (1010)
#define IDS_CMD_SHOW_MSG                     (1011)
#define IDS_CMD_OPTIONS                      (1012)
#define IDS_CMD_FULL_SYNC_ALL                (1013)
#define IDS_CMD_RUN_KCC                      (1014)
#define IDS_CMD_BIND                         (1015)
#define IDS_CMD_SHOW_VALUE                   (1016)
#define IDS_CMD_QUEUE                        (1017)
#define IDS_CMD_PROPCHECK                    (1018)
#define IDS_CMD_FAILCACHE                    (1019)
#define IDS_CMD_SHOW_ISM                     (1020)
#define IDS_CMD_GETCHANGES                   (1021)
#define IDS_CMD_SHOWSIG                      (1022)
#define IDS_CMD_SHOWCTX                      (1023)
#define IDS_CMD_SHOW_CONN                    (1024)
#define IDS_CMD_EXPERT_HELP                  (1025)
#define IDS_CMD_SHOW_CERT                    (1026)
#define IDS_CMD_MOD                          (1027)
#define IDS_CMD_LATENCY                      (1028)
#define IDS_CMD_ISTG                         (1029)
#define IDS_CMD_BRIDGEHEADS                  (1030)
#define IDS_CMD_TESTHOOK                     (1031)
#define IDS_CMD_DSAGUID                      (1032)
#define IDS_CMD_SITEOPTIONS                  (1033)
#define IDS_CMD_SHOWPROXY                    (1034)
#define IDS_CMD_REMOVELINGERINGOBJECTS       (1035)
#define IDS_CMD_NOTIFYOPT                    (1036)
#define IDS_CMD_REPL_SINGLE_OBJ              (1037)
#define IDS_CMD_SHOW_TRUST                   (1038)
#define IDS_CMD_QUERY_SITES                  (1039)
#define IDS_CMD_SHOWSERVERCALLS              (1040)
#define IDS_CMD_SHOWNCSIG                    (1041)
#define IDS_CMD_SHOW_UTD_VEC                 (1042)
#define IDS_CMD_REPLICATE                    (1043)
#define IDS_CMD_SHOW_REPL                    (1044)
#define IDS_CMD_SHOW_OBJ_META                (1045)
#define IDS_CMD_CHECKPROP                    (1046)
#define IDS_CMD_SHOWCHANGES                  (1047)
#define IDS_CMD_VIEW_LIST                    (1048)
#define IDS_CMD_SHOWATTR                     (1049)
#define IDS_CMD_SHOWATTR_P                   (1050)
#define IDS_CMD_REPLSUMMARY                  (1051)
#define IDS_CMD_REPLSUM                      (1052)
#define IDS_CMD_REPL                         (1053)
#define IDS_CMD_REHOSTPARTITION              (1054)
#define IDS_CMD_UNHOSTPARTITION              (1055)
#define IDS_CMD_REMOVESOURCES                (1056)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\replmsdnex\msdnldapex.cxx ===
#include <windows.h>
#include <stdio.h>
#include <winldap.h> // Ldap functions
#include <rpc.h>
#include <rpcdce.h>
#include <ntdsapi.h> // Repl structure definitions

void
sample(PWCHAR AuthIdentity,
       LPWSTR szDomain,
       LPWSTR szDns,
       LPWSTR szBase,
       LPWSTR szGroup)
{
    LDAP * pLdap;
    PWCHAR szFilter = L"(objectclass=*)";
    DWORD err;
    ULONG ulOptions;

    // Open an LDAP session and see if replication information via LDAP is supported
    pLdap = ldap_initW(szDns, LDAP_PORT);
    if (NULL == pLdap) {
        printf("Cannot open LDAP connection to %ls.\n", szDns);
        return;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( pLdap, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );


    // Bind
    err = ldap_bind_sW(pLdap, szDns, AuthIdentity, LDAP_AUTH_SSPI);
    if (LDAP_SUCCESS != err)
    {
        err = LdapMapErrorToWin32(err);
        return;
    }

    // Test for LDPA support for replication information
    {
        LDAPMessage * pRes = NULL;
        PWCHAR attrs[2] = { L"ms-DS-NC-ReplPendingOpsBinary", NULL };

        err = ldap_search_sW(pLdap, NULL, LDAP_SCOPE_BASE, szFilter, attrs, TRUE, &pRes);
	if (pRes) {
	    ldap_msgfree(pRes);
	}
        if (LDAP_SUCCESS == err)
        {
            wprintf(L"Replication information via LDAP support found.\n");
        }
        else
        {
            wprintf(L"Replication information via LDAP not supported.\n");
            return;
        }
    }

    // Get non root attributes in binary blob format
    LDAPMessage * pBinNRAttrs = NULL;
    LPWSTR SomeBinaryNonRootAttributes[] = {
        L"msDS-NCReplInboundNeighbors;binary;range=0-*",
        L"msDS-NCReplOutboundNeighbors;binary;Range=0-*",
        L"msDS-NCReplCursors;Binary;Range=0-*",
        L"msDS-ReplAttributeMetaData;Binary;Range=0-*",
        NULL
    };
    err = ldap_search_sW(pLdap, szDomain, LDAP_SCOPE_BASE, szFilter,
        SomeBinaryNonRootAttributes , FALSE, &pBinNRAttrs);

    // Get non root attributes in xml format
    LDAPMessage * pXmlNRAttrs = NULL;
    LPWSTR SomeXmlNonRootAttributes[] = {
        L"msDS-NCReplInboundNeighbors;Range=0-*",
        L"msDS-NCReplOutboundNeighbors;Range=0-*",
        L"msDS-NCReplCursors;Range=0-*",
        L"msDS-ReplAttributeMetaData;Range=0-*",
        NULL
    };
    err = ldap_search_sW(pLdap, szDomain, LDAP_SCOPE_BASE, szFilter,
        SomeXmlNonRootAttributes, FALSE, &pXmlNRAttrs);

    // Get root attributes in binary blob format
    LDAPMessage * pBinRAttrs = NULL;
    LPWSTR SomeBinaryRootAttributes[] = {
        L"msDS-ReplConnectionFailuresBinary",
        L"msDS-ReplLinkFailuresBinary",
        L"msDS-ReplAllInboundNeighborsBinary",
        L"msDS-ReplAllOutboundNeighborsBinary",
        L"msDS-ReplQueueStatisticsBinary",
        NULL
    };
    err = ldap_search_sW(pLdap, NULL, LDAP_SCOPE_BASE, szFilter,
        SomeBinaryRootAttributes , FALSE, &pBinRAttrs);

    // Get root attributes in xml format
    LDAPMessage * pXmlRAttrs = NULL;
    LPWSTR SomeXmlRootAttributes[] = {
        L"msDS-ReplConnectionFailuresXml",
        L"msDS-ReplLinkFailuresXml",
        L"msDS-ReplAllInboundNeighborsXml",
        L"msDS-ReplAllOutboundNeighborsXml",
        L"msDS-ReplQueueStatisticsXml",
        NULL
    };
    err = ldap_search_sW(pLdap, NULL, LDAP_SCOPE_BASE, szFilter,
        SomeXmlRootAttributes , FALSE, &pXmlRAttrs);

    // Prepare to retreive values
    WCHAR ** ppXml;
    berval ** ppBerval;
    PWCHAR szRetAttribute;
    berelement * pCookie;

    // Print out all the XML values for non root attributes
    szRetAttribute = ldap_first_attributeW(pLdap, pXmlNRAttrs, &pCookie);
    while(szRetAttribute)
    {
        ppXml = ldap_get_valuesW(pLdap, pXmlNRAttrs, szRetAttribute);
        wprintf(L"szRetAttribute %ws = {\n", szRetAttribute);
        while(*ppXml)
        {
            wprintf(L"   %ws \n", *ppXml);
            ppXml ++;
        }
        wprintf(L"}\n");
        ldap_memfreeW(szRetAttribute);
        szRetAttribute = ldap_next_attributeW(pLdap, pXmlNRAttrs, pCookie);
    }
    ldap_memfreeW(szRetAttribute);

    // Print out all the XML values for root attributes
    szRetAttribute = ldap_first_attributeW(pLdap, pXmlRAttrs, &pCookie);
    while(szRetAttribute)
    {
        ppXml = ldap_get_valuesW(pLdap, pXmlRAttrs, szRetAttribute);
        wprintf(L"szRetAttribute %ws = {\n", szRetAttribute);
        while(*ppXml)
        {
            wprintf(L"   %ws \n", *ppXml);
            ppXml ++;
        }
        wprintf(L"}\n");
        ldap_memfreeW(szRetAttribute);
        szRetAttribute = ldap_next_attributeW(pLdap, pXmlRAttrs, pCookie);
    }
    ldap_memfreeW(szRetAttribute);

    // Print out binary blob neighbors structure
    szRetAttribute = ldap_first_attributeW(pLdap, pBinNRAttrs, &pCookie);
    while(szRetAttribute)
    {
        if (wcsstr(szRetAttribute,L"Neighbors"))
        {

            CHAR * pReplBlob;
            ppBerval = ldap_get_values_lenW(pLdap, pBinNRAttrs, szRetAttribute);

            wprintf(L"szRetAttribute %ws = {\n", szRetAttribute);
            while(*ppBerval)
            {
                pReplBlob = (*ppBerval)->bv_val;
                DS_REPL_NEIGHBORW_BLOB * pReplNeighborBlob =
                    (DS_REPL_NEIGHBORW_BLOB *)pReplBlob;

                LPWSTR pszAsyncIntersiteTransportDN = pReplNeighborBlob->oszAsyncIntersiteTransportDN ?
                    (LPWSTR)(pReplBlob + pReplNeighborBlob->oszAsyncIntersiteTransportDN) : NULL;
                LPWSTR pszNamingContext = pReplNeighborBlob->oszNamingContext ?
                    (LPWSTR)(pReplBlob + pReplNeighborBlob->oszNamingContext) : NULL;

                // Print out a couple fields
                wprintf(L"{AsyncInterSiteTransportDN=%ws}, {NamingContext=%ws}, {LastSyncResult=%d}, {ReplicaFlags=%d}\n",
                    pszAsyncIntersiteTransportDN,
                    pszNamingContext,
                    pReplNeighborBlob->dwLastSyncResult,
                    pReplNeighborBlob->dwReplicaFlags);
                ppBerval ++;
            }
            wprintf(L"}\n");
        }

        ldap_memfreeW(szRetAttribute);
        szRetAttribute = ldap_next_attributeW(pLdap, pBinNRAttrs, pCookie);
    }
    ldap_memfreeW(szRetAttribute);

    // clean up ldap search results
    if (pXmlNRAttrs) {
	ldap_msgfree(pXmlNRAttrs);
    }
    if (pXmlRAttrs) {
	ldap_msgfree(pXmlRAttrs);
    }
    if (pBinNRAttrs) {
	ldap_msgfree(pBinNRAttrs);
    }
    if (pBinRAttrs) {
	ldap_msgfree(pBinRAttrs);
    }

    // Get attribute value metadata for a group of users
    LDAPMessage * pBinValueAttrs = NULL;
    WCHAR buf[255];
    DWORD dwPageSize = 2;   // number of users requested at once
    DWORD dwBaseIndex = 0;  // index to start retreiving users from
    DWORD dwUpperRetIndex;

    LPWSTR ValueMetaData[] = {
        buf,
        NULL
    };

    do {
        // Prepare the range syntax
        wsprintfW(buf, L"msDS-ReplValueMetaData;binary;range=%d-%d",
            dwBaseIndex, dwBaseIndex + dwPageSize - 1);

        // Preform the search
        err = ldap_search_sW(pLdap, szGroup, LDAP_SCOPE_BASE, szFilter,
            ValueMetaData, FALSE, &pBinValueAttrs);

        // Examin results
        szRetAttribute = ldap_first_attributeW(pLdap, pBinValueAttrs, &pCookie);
        if (!szRetAttribute)
        {
            // Either the attribute name does not exist or the base index
            // is beyond the last possible index
            dwUpperRetIndex = -1;
            wprintf(L"Error!");
        }
        else if (!swscanf(wcsstr(szRetAttribute, L"ange="), L"ange=%*d-%d", &dwUpperRetIndex))
        {
            // The number of values returned is equal to or less than the requested page size
            // and there are no more valeus to be returned
            dwUpperRetIndex = -1; // range=?-*
            wprintf(L"All values returned.\n");
        }
        else
        {
            // The requested number of values have been returned and more are available
            wprintf(L"%d values returned.\n", dwUpperRetIndex - dwBaseIndex + 1);
        }

        ldap_memfreeW(szRetAttribute);
        dwBaseIndex += dwPageSize;
    } while (dwUpperRetIndex != -1);

    ldap_memfreeW((PUSHORT)pCookie);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\replstruct\repldemarshal.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:
    ReplDeMarshal.cxx

Abstract:
    De-marshals a repl blob. See ReplMarshalBlob.cxx for an explination of the 
    marshaling algorithm.

Author:

    Chris King          [t-chrisk]    July-2000
    
Revision History:

--*/
#include <NTDSpchx.h>
#pragma hdrstop

#include <align.h>

#include <ntdsa.h>
#include <winldap.h>
#include <debug.h>

#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"

#include <fileno.h>
#define FILENO   FILENO_UTIL_REPLSTRUCT_REPLDEMARSHAL

DWORD
Repl_DeMarshalBerval(DS_REPL_STRUCT_TYPE structId, 
                     berval * ldapValue[], OPTIONAL
                     DWORD dwNumValues,
                     puReplStructArray pReplStructArray, OPTIONAL
                     PDWORD pdwReplStructArrayLen)
/*++
Routine Description:

  Translates a berval to a replication array container.

Arguments:

  dwReplInfoType - the replication information type used by RPC
  ldapValues - the berval returned by LDAP representing the dwReplInfoType multivalue, may be NULL if
    dwNumValues == 0;
  dwNumValues - the number of multivalues in the berval
  pReplStructArray - location to construct the replication array container.
  pdwReplStructArrayLen -
    Address of a DWORD value of the signature data length. Upon function entry, 
    this DWORD value contains the number of bytes allocated for the pReplStructArray buffer. 
    Upon exit, it is set to the number of bytes required for the pReplStructArray buffer. 
    May return zero if the repl struct is w/o array container (see ROOT_DSE_ATT_MS_DS_REPL_QUEUE_STATISTICS)
    in which case no repl struct was returned.
    
Return values
    If memory allocated for the pbSignature buffer is not large enough to hold the signature, 
    the ERROR_MORE_DATA error code is returned. The required buffer size is returned in pdwReplStructArrayLen. 
    If this function fails with any error code other than ERROR_MORE_DATA, zero is returned in pdwReplStructArrayLen. 
--*/
{   
    DWORD dwElemSize        = Repl_GetElemSize(structId);
    PCHAR rDSRepl           = NULL;
    DWORD i, err = 0, dwReplStructArrayLen;
    signed long ulNumValues = (signed long)dwNumValues;

    Assert(ARGUMENT_PRESENT(ldapValue) || !dwNumValues);

    // Check memory enviornment
    dwReplStructArrayLen = Repl_GetArrayContainerSize(structId) + 
        (ulNumValues - 1) * // the ArrayContainer has a repl element in it already
        Repl_GetElemSize(structId);
    if (!pReplStructArray)
    {
        *pdwReplStructArrayLen = dwReplStructArrayLen;
        return 0;
    }
    else if (*pdwReplStructArrayLen < dwReplStructArrayLen)
    {
        *pdwReplStructArrayLen = dwReplStructArrayLen;
        return ERROR_MORE_DATA;
    }
    *pdwReplStructArrayLen = 0;
    
    // Set container length
    Repl_SetArrayLength(structId, pReplStructArray, dwNumValues);
    
    // Fill in array
    Repl_GetElemArray(structId, pReplStructArray, &rDSRepl);
    for (i = 0; i < dwNumValues; i ++)
    {
        err = Repl_DeMarshalValue(
            structId,
            ldapValue[i]->bv_val,           // a binary blob containing a single marshaled structure
            ldapValue[i]->bv_len,           // single blob value length
            rDSRepl + (i * dwElemSize));    // a structure to demarshal the blob into
    }

    *pdwReplStructArrayLen = dwReplStructArrayLen;
    return err;
}


DWORD
Repl_DeMarshalValue(DS_REPL_STRUCT_TYPE structId, 
                    IN PCHAR pValue,
                    IN DWORD dwValueLen,
                    OUT PCHAR pStruct)  
/*++ 

Routine Description:

  Demarshals a replication blob into its orig structure. The blob structure
  contains a head and a body. The head maps to the origional structure by 
  transforming the pointers into 32bit offsets into the body of the blob. This
  demarshaling routine transforms the head of the blob back into a structure
  by transforming the offsets into pointers which point back into the body
  of the blob.

  The marshaled blob can not be demarshaled into the same memory.

  The extensibility rules of the structures allow for them to grow in the
  future. Thus, the incoming value may have more or fewer fields than the
  struct we are trying to populate.

Arguments:

  pValue - A pointer to the blob
  dwValueLen - The length of the blob
  pStruct - A pointer to the orig struct

Return value
  Currently no error codes are returned (return 0).
  
--*/
{
    Assert(ARGUMENT_PRESENT(pValue) &&
           ARGUMENT_PRESENT(pStruct));

    DWORD dwFieldIndex, dwPtrIndex;
    DWORD dwFieldCount = Repl_GetFieldCount(structId);
    DWORD dwPtrCount = Repl_GetPtrCount(structId);
    DWORD dwStructLen = Repl_GetElemSize(structId);
    DWORD * rPtrOffset = Repl_GetPtrOffsets(structId);
    psReplStructField aReplStructField = Repl_GetFieldInfo(structId);

    // No overlap should exist between the marshaled structure and the
    // demarshaled location
    Assert(pValue < pStruct || pValue > pStruct + dwStructLen);

    // Without pointer case is easy
    if (!dwPtrCount) {
        if (dwStructLen <= dwValueLen) {
            // Native structure is smaller: truncate
            memcpy(pStruct, pValue, dwStructLen );
        } else {
            // Native structure is bigger: zero fill
            memcpy(pStruct, pValue, dwValueLen );
            memset(pStruct + dwValueLen, 0, dwStructLen - dwValueLen );
        }

        return 0;
    }
    
    // Copy the fields one at a time
    for (dwFieldIndex = 0, dwPtrIndex = 0; dwFieldIndex < dwFieldCount; dwFieldIndex++)
    {

        psReplStructField pField = aReplStructField + dwFieldIndex;
        PCHAR from = pValue + pField->dwBlobOffset;
        PCHAR to = pStruct + pField->dwOffset;
        DWORD dwSize = Repl_GetTypeSize(pField->eType);

        if (pField->dwBlobOffset >= dwValueLen) {
            // Native structure is bigger: zero fill
            Assert( (pField->dwOffset + dwSize) < dwStructLen );
            memset( to, 0, dwSize );
            
        } else if ( (pField->eType == dsReplString) || (pField->eType == dsReplBinary) ) {

            DWORD length;
            Assert( pField->dwOffset == rPtrOffset[dwPtrIndex] );

            Assert( POINTER_IS_ALIGNED( from, ALIGN_DWORD ) );
            length = *((PDWORD)from);

            // set pointer
            Assert( POINTER_IS_ALIGNED( to, ALIGN_LPVOID ) );
            if (length) {
                *(PCHAR*)to = (pValue + length);
            } else {
                *(PCHAR*)to = NULL;
            }

            dwPtrIndex++;

        } else {
            Assert( (pField->dwBlobOffset + dwSize - 1) < dwValueLen );
            Assert( (pField->dwOffset + dwSize - 1) < dwStructLen );
            memcpy( to, from, dwSize );
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\repmisc.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   repmisc.c - misc command functions

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "repadmin.h"

int
ShowMsg(
    int     argc,
    LPWSTR  argv[]
    )
{
    DWORD dwMsgID = 0;
    BOOL fWin32Msg = TRUE;
    int iArg;

    for (iArg = 2; iArg < argc; iArg++) {
        if (!_wcsicmp(argv[iArg], L"/ntdsmsg")) {
            fWin32Msg = FALSE;
        } else if (0 == dwMsgID) {
            if ((argv[iArg][0] == L'0') && (tolower(argv[iArg][1]) == L'x')) {
                dwMsgID = wcstoul(&argv[iArg][2], NULL, 16);
            }
            else {
                dwMsgID = wcstoul(&argv[iArg][0], NULL, 10);
            }

            if (0 == dwMsgID) {
                PrintMsg(REPADMIN_SHOWMSG_INVALID_MSG_ID, argv[iArg]);
                return ERROR_INVALID_PARAMETER;
            }
        } else {
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, argv[iArg]);
            return ERROR_INVALID_PARAMETER;
        }
    }

    PrintMsg(REPADMIN_SHOWMSG_DATA, 
             dwMsgID,
             dwMsgID,
             fWin32Msg ? Win32ErrToString(dwMsgID) : NtdsmsgToString(dwMsgID));
    
    return 0;
}



int
ShowTime(
    int     argc,
    LPWSTR  argv[]
    )
{
    int         ret = 0;
    DSTIME      time = 0;
    SYSTEMTIME  systime;
    CHAR        szLocalTime[ SZDSTIME_LEN ];
    CHAR        szUtcTime[ SZDSTIME_LEN ];

    if (argc < 3) {
        time = GetSecondsSince1601();
    }
    else if ((argv[2][0] == L'0') && (towlower(argv[2][1]) == L'x')) {
        swscanf(&argv[2][2], L"%I64x", &time);
    }
    else {
        swscanf(&argv[2][0], L"%I64d", &time);
    }

    DSTimeToDisplayString(time, szLocalTime);

    if (0 == time) {
        strcpy(szUtcTime, "(never)");
    }
    else {
        DSTimeToUtcSystemTime(time, &systime);

        sprintf(szUtcTime,
                "%02d-%02d-%02d %02d:%02d.%02d",
                systime.wYear % 100,
                systime.wMonth,
                systime.wDay,
                systime.wHour,
                systime.wMinute,
                systime.wSecond);
    }
    PrintMsg(REPADMIN_SHOWTIME_TIME_DATA, 
             time);
    PrintMsg(REPADMIN_SHOWTIME_TIME_DATA_HACK2, 
             time);
    PrintMsg(REPADMIN_SHOWTIME_TIME_DATA_HACK3, 
             szUtcTime, szLocalTime);

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\replstruct\replmarshalblob.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:
    ReplMarshalBlob.cxx

Abstract:
    Takes a structure and marshals it into a blob.

    The marshaling protocol does not support marshaling of structures containing arrays or
    pointers to arrays of structures containing pointers. Currently, the DS_REPL_XXX structures contain
    pointers to strings or binary blobs containing no pointers. Here is an explanation of how the 
    structures are marshaled:

	The un-marshaled structure will not be converted network byte order. 

    Each pointer in the unmarshaled structure has been replaced with a 32bit offset value 
    in its corresponding marshaled structure. Thus marshaled structures will be the same size 
    on either 32 or 64 bit architectures.
	
        If the pointer is NULL in the unmarshaled structure its offset is zero in the marshaled structure.
	    So a an EMPTY string, as opposed to a NULL string, is represented by a NON-NULL offset to a 
        single character containing a zero. '\0'

        If the pointer is non-NULL the data it referenced can be located by adding the address of the
        marshaled structure to its corresponding offset. 

	    The first non-zero offset value in the marshaled structure is guaranteed to be the size of the 
        corresponding unmarshaled structure.

        The version of the marshaled structure can be inferred from its size which can be calculated, 
        given only the unmarshaled structure as follows:

        	The blob containing a marshaled structure with no offset fields or zero value offset 
            fields is the size of the un-marshaled structure on a 32-bit computer.
	        Else the size of the unmarshaled structure is equal to the value of the first non-zero
            offset on a 32-bit computer.

	If a pointer points to another structure, that structure will also have a marshaled data structure and 
    its offsets will be calculated relative to its own base and not that of the parent structure. Its offsets
    are subject to the same constraints listed above. Currently there are no structures that require this type of
    recursive marshaling and there is no support for such marshaling.
    This point is included for future extensions of the API.
  

Author:

    Chris King          [t-chrisk]    July-2000
    
Revision History:

--*/
#include <NTDSpchx.h>
#pragma hdrstop

#include <align.h>

#include <ntdsa.h>
#include <debug.h>

#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"

#include <fileno.h>
#define FILENO   FILENO_UTIL_REPLSTRUCT_REPLMARSHALBLOB

DWORD
Repl_MarshalBlob(IN DS_REPL_STRUCT_TYPE structId,
                 IN PCHAR pStruct, 
                 IN DWORD dwStructLen, 
                 IN DWORD dwPtrOffset[],
                 IN DWORD dwPtrLen[],
                 IN DWORD dwPtrCount, 
                 IN OUT PCHAR pBinBlob, OPTIONAL
                 IN OUT PDWORD pdwBlobLen)
/*++
Routine Description:

  Marshals a structure into a blob. The structure may contain pointers to data without any pointers.
  The structure is copied to the begining of the blob. Pointer data is appended to the blob in 
  the order the pointers appeared in the structure. The pointer fields are replaced with offsets
  from the start of the blob into the appended data section. NULL pointers map to zero valued
  offset fields.

Arguments:

  pStruct - the structure to marshal
  dwStructLen - the lenght of the pStruct
  dwPtrOffset - array of pointer offsets from pStruct
  dwPtrLen - array indicating the range of data each pointer refers to 
  dwPtrCount - number of pointers in the pStruct
  pBinBlob - memory to hold marshaled pStruct
  pdwBlobLen -
    Address of a DWORD value of the signature data length. Upon function entry, 
    this DWORD value contains the number of bytes allocated for the pBinBlob buffer. 
    Upon exit, it is set to the number of bytes required for the pBinBlob buffer. 

Return values:

    If memory allocated for the pbSignature buffer is not large enough to hold the blob, 
    the ERROR_MORE_DATA error code is returned. The required buffer size is returned in pdwBlobLen. 
    If this function fails with any error code other than ERROR_MORE_DATA, zero is returned in pdwBlobLen. 

--*/
{
    Assert(ARGUMENT_PRESENT(pdwBlobLen) && dwStructLen);
    Assert(IMPLIES(dwPtrCount && ARGUMENT_PRESENT(pBinBlob), 
                   ARGUMENT_PRESENT(dwPtrOffset) && ARGUMENT_PRESENT(dwPtrLen)));

    DWORD dwBlobHeadLen = Repl_GetElemBlobSize(structId);
    DWORD dwFieldCount = Repl_GetFieldCount(structId);
    psReplStructField aReplStructField = Repl_GetFieldInfo(structId);
    PCHAR pMarshal;
    DWORD dwTotalPtrLen, dwTotalBlobLen;
    DWORD i, dwFieldIndex, dwPtrIndex, ret;
    
    for (i = 0, dwTotalPtrLen = 0; i < dwPtrCount; i ++) {
        dwTotalPtrLen += dwPtrLen[i];
    }
    dwTotalBlobLen = ROUND_UP_COUNT( dwBlobHeadLen + dwTotalPtrLen, ALIGN_DWORD );

    if(requestLargerBuffer(pBinBlob, pdwBlobLen, dwTotalBlobLen, &ret))
    {
        return ret;
    }
    
    // A structure without pointer case is easy
    if (!dwPtrCount) {
        memcpy(pBinBlob, pStruct, dwStructLen);
        *pdwBlobLen = dwStructLen;
        Assert( COUNT_IS_ALIGNED( dwStructLen, ALIGN_DWORD ) );
        return 0;
    }
    
    pMarshal = pBinBlob + dwBlobHeadLen;

    for (dwFieldIndex = 0, dwPtrIndex = 0; dwFieldIndex < dwFieldCount; dwFieldIndex++)
    {
        psReplStructField pField = aReplStructField + dwFieldIndex;
        DWORD dwSize = Repl_GetTypeSize(pField->eType);
        PCHAR from = pStruct + pField->dwOffset;
        PCHAR to = pBinBlob + pField->dwBlobOffset;

        Assert( pField->dwOffset < dwStructLen );
        Assert( pField->dwBlobOffset < dwBlobHeadLen );

        if ( (pField->eType == dsReplString) || (pField->eType == dsReplBinary) ) {

            DWORD length = dwPtrLen[dwPtrIndex];

            Assert( pField->dwOffset == dwPtrOffset[dwPtrIndex] );

            if (length) {
                Assert( POINTER_IS_ALIGNED( to, ALIGN_DWORD ) );
                *(PDWORD)(to) = (DWORD)(pMarshal - pBinBlob); 

                Assert( POINTER_IS_ALIGNED( from, ALIGN_LPVOID ) );
                memcpy(pMarshal, *(LPWSTR *)(from), length);
                pMarshal += length;
            }
            else {
                *(PDWORD)(to) = 0; 
            }
            dwPtrIndex++;
        } else {
            memcpy( to, from, dwSize );

            Assert( to + dwSize - 1 < pBinBlob + dwBlobHeadLen );
        }

    }

    // Pointer data should not exceed buffer
    Assert( pMarshal <= (pBinBlob + dwTotalBlobLen) );

    *pdwBlobLen = dwTotalBlobLen;
    return 0; 
};


DWORD
Repl_StructArray2Attr(IN DS_REPL_STRUCT_TYPE structId,
                      IN puReplStructArray pReplStructArray,
                      IN OUT PDWORD pdwBufferSize,
                      IN PCHAR pBuffer, OPTIONAL
                      OUT ATTR * pAttr)
/*++

Routine Description:

  Replication information stored in repl structures containted in repl array containers ==>
  Replication information stored in marshaled format containted in a pAttrs

  Initialize a ATTR structure.

  For every elment in the array container the function, marshal the element by 
  calling draReplStruct2Attr.

Arguments:

  pTHS - thread state used to allocate memory for the blobs and garbage collect
  attrId - the type of replication information requested
  puReplStructArray - the repl struct containing the structure to be marshaled
  pAttr - returned structure representing a single attribute. 
  pBuffer - memory to construct the pAttr links with
  pdwBufferSize - size of buffer or requested buffer size

Return Values:

  pAttr
    pAttr->AttrTyp ~ not modified or read
    pAttr->AttrVal.valCount = number of elements in replication array container
    pAttr->AttrVal.pAVals[i].pVal = contains the marshaled i'th replication structure
    pAttr->AttrVal.pAVals[i].valLen = the size of the marshaled i'th replication structure

  returns any errors generated by Repl_MarshalBlob or returns zero to indicate no error.
  ERROR_MORE_DATA if pdwBufferSize is NonNULL and too small. See requestLargerBuffer().
--*/
{
    PCHAR rDSRepl = NULL, pAlloc = NULL;
    DWORD err = 0, dwBufferSize = 0, dwReplStructSize, dwReplNumValues = 0;
    DWORD dwPtrCount;
    DWORD * pgdwPtrOffsets;
    DWORD * pdwPtrLengths;
    DWORD dwSumPtrLengths;

    Assert(ARGUMENT_PRESENT(pAttr));
    Assert(IMPLIES(ARGUMENT_PRESENT(pBuffer),ARGUMENT_PRESENT(pReplStructArray)));

    // Gather Parameters
    dwReplNumValues = Repl_GetArrayLength(structId, pReplStructArray);
    if (dwReplNumValues)
    {
        dwPtrCount = Repl_GetPtrCount(structId);
        dwReplStructSize = Repl_GetElemSize(structId);
        // dwReplStructSize = Repl_GetElemSize(structId);
        Repl_GetElemArray(structId, pReplStructArray, &rDSRepl);
    }

    // Set the number of values
    pAttr->AttrVal.valCount = dwReplNumValues;

    if (dwReplNumValues)
    {
        DWORD i;
        uReplStruct * pReplStruct;

        // Calculate the amount of memory needed, store the result in dwBufferSize
        // Memory to store blob pointer and blob lenght
        dwBufferSize = dwReplNumValues * sizeof(ATTRVAL);

        // Memory to store pointer lengths
        dwBufferSize += sizeof(PDWORD) * dwPtrCount;
        
        // Memory to store the blob
        for (i = 0; i < pAttr->AttrVal.valCount; i ++)
        {
            DWORD dwBlobSize;
            pReplStruct = (puReplStruct)(rDSRepl + (i * dwReplStructSize));
            Repl_GetPtrLengths(structId, pReplStruct, NULL, 0, &dwSumPtrLengths);
            err = Repl_MarshalBlob(structId, NULL, dwReplStructSize, NULL, &dwSumPtrLengths, 1, NULL, &dwBlobSize);
            if (err) {
                goto exit;
            }
            dwBufferSize += dwBlobSize;
        }

        // See if enough memory is available
        if (requestLargerBuffer(pBuffer, pdwBufferSize, dwBufferSize, &err)) {
            goto exit;
        }

        // Distribute memory
        pAlloc = pBuffer;
        
        // Store pointer lenghts here
        pdwPtrLengths = (PDWORD)pAlloc;
        pAlloc += sizeof(PDWORD) * dwPtrCount;

        // Store the blob pointer and blob length here
        pAttr->AttrVal.pAVal = (ATTRVAL *)pAlloc;
        pAlloc += dwReplNumValues * sizeof(ATTRVAL);

        // Enough memory is available so preform the transform from
        // replication structure to attr vals
        for (i = 0; i < pAttr->AttrVal.valCount; i ++)
        {
            // Locate the next repl structure in the container array
            pReplStruct = (puReplStruct)(rDSRepl + (i * dwReplStructSize));
            Repl_GetPtrLengths(structId, pReplStruct, pdwPtrLengths, dwPtrCount, NULL);
            pgdwPtrOffsets = Repl_GetPtrOffsets(structId);
            
            pAttr->AttrVal.pAVal[i].pVal = (PUCHAR)pAlloc;
            pAttr->AttrVal.pAVal[i].valLen = dwBufferSize - (DWORD)(pAlloc - pBuffer);
            err = Repl_MarshalBlob(
                structId,
                (PCHAR)pReplStruct, 
                dwReplStructSize, 
                pgdwPtrOffsets, 
                pdwPtrLengths, 
                dwPtrCount, 
                (PCHAR)pAttr->AttrVal.pAVal[i].pVal,       // Destination
                &pAttr->AttrVal.pAVal[i].valLen);          // Destination length
            if (err) {
                goto exit;
            }
            
            pAlloc += pAttr->AttrVal.pAVal[i].valLen;
        }
        // The buffer was lager enough
        Assert(dwBufferSize - (pAlloc - pBuffer) < dwBufferSize);
    }

exit:
    if (!err) {
        *pdwBufferSize = dwBufferSize;
    }
    return err;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\reprsa.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   reprsa.c - replica sync all command

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "ReplRpcSpoof.hxx"
#include "repadmin.h"

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0)

VOID SyncAllPrintError (
    PDS_REPSYNCALL_ERRINFOW	pErrInfo
    )
{
    switch (pErrInfo->error) {

	case DS_REPSYNCALL_WIN32_ERROR_CONTACTING_SERVER:
            PrintMsg(REPADMIN_SYNCALL_CONTACTING_SERVER_ERR, pErrInfo->pszSvrId);
            PrintErrEnd(pErrInfo->dwWin32Err);
	    break;

	case DS_REPSYNCALL_WIN32_ERROR_REPLICATING:
	    if (pErrInfo->dwWin32Err == ERROR_CANCELLED){
                PrintMsg(REPADMIN_SYNCALL_REPL_SUPPRESSED);
            } else {
                PrintMsg(REPADMIN_SYNCALL_ERR_ISSUING_REPL);
                PrintErrEnd(pErrInfo->dwWin32Err);
            }

            PrintMsg(REPADMIN_SYNCALL_FROM_TO, pErrInfo->pszSrcId, pErrInfo->pszSvrId);

	    break;

	case DS_REPSYNCALL_SERVER_UNREACHABLE:
            PrintMsg(REPADMIN_SYNCALL_SERVER_BAD_TOPO_INCOMPLETE, pErrInfo->pszSvrId);
	    break;

	default:
            PrintMsg(REPADMIN_GENERAL_UNKNOWN_ERROR);
	    break;

    }
}

BOOL __stdcall SyncAllFnCallBack (
    LPVOID			pDummy,
    PDS_REPSYNCALL_UPDATEW	pUpdate
    )
{
    PrintMsg(REPADMIN_SYNCALL_CALLBACK_MESSAGE);

    switch (pUpdate->event) {

	case DS_REPSYNCALL_EVENT_SYNC_STARTED:
            PrintMsg(REPADMIN_SYNCALL_REPL_IN_PROGRESS);
            PrintMsg(REPADMIN_SYNCALL_FROM_TO,
                     pUpdate->pSync->pszSrcId,
                     pUpdate->pSync->pszDstId );
	    break;

	case DS_REPSYNCALL_EVENT_SYNC_COMPLETED:
            PrintMsg(REPADMIN_SYNCALL_REPL_COMPLETED);
            PrintMsg(REPADMIN_SYNCALL_FROM_TO, 
                    pUpdate->pSync->pszSrcId,
                    pUpdate->pSync->pszDstId );
	    break;

	case DS_REPSYNCALL_EVENT_ERROR:
	    SyncAllPrintError (pUpdate->pErrInfo);
	    break;

	case DS_REPSYNCALL_EVENT_FINISHED:
            PrintMsg(REPADMIN_SYNCALL_FINISHED);
	    break;

	default:
            PrintMsg(REPADMIN_SYNCALL_UNKNOWN);
	    break;

    }

    return TRUE;
}

BOOL __stdcall SyncAllFnCallBackInfo (
    LPVOID			pDummy,
    PDS_REPSYNCALL_UPDATEW	pUpdate
    )
{
    LPWSTR pszGuidSrc = NULL, pszGuidDst = NULL;
    DWORD ret;
    LPWSTR argv[10];
    BOOL result;

    if (pUpdate->event != DS_REPSYNCALL_EVENT_SYNC_STARTED) {
        return TRUE;
    }

    ret = UuidToStringW( pUpdate->pSync->pguidSrc, &pszGuidSrc );
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"UuidToString", ret);
        result = FALSE;
        goto cleanup;
    }
    ret = UuidToStringW( pUpdate->pSync->pguidDst, &pszGuidDst );
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"UuidToString", ret);
        result = FALSE;
        goto cleanup;
    }

    PrintMsg(REPADMIN_PRINT_CR);
    PrintMsg(REPADMIN_SYNCALL_SHOWREPS_CMDLINE, 
             pszGuidDst,
             pUpdate->pSync->pszNC,
             pszGuidSrc );
    argv[0] = L"repadmin";
    argv[1] = L"/showreps";
    argv[2] = pszGuidDst;
    argv[3] = pUpdate->pSync->pszNC;
    argv[4] = pszGuidSrc;
    argv[5] = NULL;

    ret = ShowReps( 5, argv );
    if (ret != ERROR_SUCCESS) {
        PrintFuncFailed(L"repadmin:ShowReps", ret);
        result = FALSE;
        goto cleanup;
    }

    result = TRUE;

cleanup:

    if (pszGuidSrc) {
        RpcStringFreeW( &pszGuidSrc );
    }
    if (pszGuidDst) {
        RpcStringFreeW( &pszGuidDst );
    }

    return result;
}

BOOL __stdcall SyncAllFnCallBackPause (
    LPVOID			pDummy,
    PDS_REPSYNCALL_UPDATEW	pUpdate
    )
{
    BOOL			bContinue;

    SyncAllFnCallBack (pDummy, pUpdate);
    if (pUpdate->event == DS_REPSYNCALL_EVENT_FINISHED)
	bContinue = TRUE;
    else {
        PrintMsg(REPADMIN_SYNCALL_Q_OR_CONTINUE_PROMPT);
	bContinue = (toupper (_getch ()) != 'Q');
    }
    return bContinue;
}

int SyncAllGetNCs (
    LPWSTR pszDSA,
    LPWSTR ** prgpszNameContexts,
    int * pcNameContexts
    )
/*++

Routine Description:

    Fill prgpszNameContexts with all NC's held by pszDSA.

Arguments:

    pszDSA - 
    prgpszNameContexts - array to hold NC list
    pcNameContexts - number of NC's in list

Return Value:

    error codes

--*/
{
    int             ret = 0;
    LDAP *          hld;
    int             ldStatus;
   
    int             nOptions;
    int             nAddOptions = 0;
    int             nRemoveOptions = 0;
    int             nBit;
    ULONG           ulOptions;
    LPWSTR          pszDsaDN = NULL;

    hld = ldap_initW(pszDSA, LDAP_PORT);
    if (NULL == hld) {
        PrintMsg(REPADMIN_GENERAL_LDAP_UNAVAILABLE, pszDSA);
        return LDAP_SERVER_DOWN;
    }
    // use only A record dns name discovery
    ulOptions = PtrToUlong(LDAP_OPT_ON);
    (void)ldap_set_optionW( hld, LDAP_OPT_AREC_EXCLUSIVE, &ulOptions );

    // Bind.
    ldStatus = ldap_bind_s(hld, NULL, (char *) gpCreds, LDAP_AUTH_SSPI);
    CHK_LD_STATUS(ldStatus);

    ret = GetNTDSA(hld,
			  &pszDsaDN);

    if (ret!=0 || pszDsaDN==NULL) {
	return ret;
    }

    ret = GetNCLists(hld, pszDsaDN, prgpszNameContexts, pcNameContexts);

    free(pszDsaDN);
    if (hld) {
	ldap_unbind(hld);
    }
    return ret;
}

int SyncAll (int argc, LPWSTR argv[])
{
    ULONG                       ret;
    HANDLE			hDS;
    DWORD			dwWin32Err;
    ULONG			ulFlags;
    LPWSTR                      pszNameContext;
    LPWSTR                      pszServer;
    PDS_REPSYNCALL_ERRINFOW *	apErrInfo;
    BOOL			bPause;
    BOOL			bQuiet;
    BOOL			bVeryQuiet;
    BOOL			bIterate;
    BOOL                        bInfo;
    ULONG			ulIteration;
    ULONG			ul;
    INT				i;
    INT                         j;
    BOOL                        fSyncAllNC = FALSE;
    BOOL (__stdcall *		pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEW);
    LPWSTR *                    rgpszNameContexts = NULL;
    INT                         cNameContexts = 0;

    ulFlags = 0L;
    pszNameContext = pszServer = NULL;
    bPause = bQuiet = bVeryQuiet = bIterate = bInfo = FALSE;
    pFnCallBack = NULL;

    // Parse commandline.

    for (i = 2; i < argc; i++) {
	if (argv[i][0] == L'/')
	    for (ul = 1; ul < wcslen (argv[i]); ul++)
		switch (argv[i][ul]) {
		    case 'a':
			ulFlags |= DS_REPSYNCALL_ABORT_IF_SERVER_UNAVAILABLE;
			break;
		    case 'd':
			ulFlags |= DS_REPSYNCALL_ID_SERVERS_BY_DN;
			break;
		    case 'e':
			ulFlags |= DS_REPSYNCALL_CROSS_SITE_BOUNDARIES;
			break;
		    case 'h':
                    case '?':
                        PrintMsg(REPADMIN_SYNCALL_HELP);
			return 0;
		    case 'i':
			bIterate = TRUE;
			break;
                    case 'I':
                        bInfo = TRUE;
			ulFlags |= DS_REPSYNCALL_DO_NOT_SYNC |
                            DS_REPSYNCALL_SKIP_INITIAL_CHECK |
                            DS_REPSYNCALL_ID_SERVERS_BY_DN;
                        break;
		    case 'j':
			ulFlags |= DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY;
			break;
		    case 'p':
			bPause = TRUE;
			break;
		    case 'P':
			ulFlags |= DS_REPSYNCALL_PUSH_CHANGES_OUTWARD;
			break;
		    case 'q':
			bQuiet = TRUE;
			break;
		    case 'Q':
			bVeryQuiet = TRUE;
			break;
		    case 's':
			ulFlags |= DS_REPSYNCALL_DO_NOT_SYNC;
			break;
		    case 'S':
			ulFlags |= DS_REPSYNCALL_SKIP_INITIAL_CHECK;
			break;
		    case 'A':
		        fSyncAllNC = TRUE;
		    default:
			break;
		}
	else if (pszServer == NULL) pszServer = argv[i];
	else if (pszNameContext == NULL) pszNameContext = argv[i];
    }

    if (bQuiet || bVeryQuiet) {
        pFnCallBack = NULL;
    } else if (bPause) {
        pFnCallBack = SyncAllFnCallBackPause;
    } else if (bInfo) {
        pFnCallBack = SyncAllFnCallBackInfo;
    } else {
        pFnCallBack = SyncAllFnCallBack;
    }

    if (pszServer == NULL) {
	pszServer = L"localhost";
    }

    ret = RepadminDsBind(pszServer, &hDS);
    if (ERROR_SUCCESS != ret) {
	    PrintBindFailed(pszServer, ret);
	    return ret;
    }

    // fill nc list - 
    if (fSyncAllNC) {
	// we want to sync all NC's on pszServer, so call it and fill the Name Contexts
	// array with all NC's we want to sync
	ret = SyncAllGetNCs(pszServer, &rgpszNameContexts, &cNameContexts); 
	if (ret!=ERROR_SUCCESS) {
	    return ret;
	}
	PrintMsg(REPADMIN_SYNCALL_ALL_NCS, pszServer);
    } else {
	// either the user wants a single naming context specified in pszNameContext, or
	// nothing was specified and we will pass null to the DsReplicaSyncAllW call which
	// will default to the configuration naming context.
	rgpszNameContexts = malloc(sizeof(LPWSTR));
	if (rgpszNameContexts==NULL) {
	    PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
	    return ERROR_NOT_ENOUGH_MEMORY;
	}
	if (pszNameContext) {
	    rgpszNameContexts[0] = malloc(sizeof(WCHAR) * (1 + wcslen(pszNameContext)));
	    wcscpy(rgpszNameContexts[0], pszNameContext);
	} else {
	    rgpszNameContexts[0] = pszNameContext;
	}
	cNameContexts = 1;
    }

    for (j=0;j<cNameContexts;j++) {
	ulIteration = 0;
	if (fSyncAllNC || pszNameContext) {
	    PrintMsg(REPADMIN_SYNCALL_NC, rgpszNameContexts[j]);  
	}
	do {

	    if (ulIteration % 100L == 1L) {
		PrintMsg(REPADMIN_SYNCALL_ANY_KEY_PROMPT);
		_getch ();
	    }
	    if (dwWin32Err = DsReplicaSyncAllW(
		hDS,
		rgpszNameContexts[j],
		ulFlags,
		pFnCallBack,
		NULL,
		&apErrInfo)) {

		PrintMsg(REPADMIN_PRINT_CR);
		if (dwWin32Err == ERROR_CANCELLED){
		    PrintMsg(REPADMIN_SYNCALL_USER_CANCELED);
		} else {
		    PrintMsg(REPADMIN_SYNCALL_EXITED_FATALLY_ERR);
		    PrintErrEnd(dwWin32Err);
		}
		return -1;
	    }

	    if (!bVeryQuiet) {
		if (apErrInfo) {
		    PrintMsg(REPADMIN_PRINT_CR);
		    PrintMsg(REPADMIN_SYNCALL_ERRORS_HDR);
		    for (i = 0; apErrInfo[i] != NULL; i++)
			SyncAllPrintError (apErrInfo[i]);
		} else {
		    PrintMsg(REPADMIN_SYNCALL_TERMINATED_WITH_NO_ERRORS);
		}
	    }
	    if (apErrInfo){
		LocalFree (apErrInfo);
	    }
	    if (bIterate) {
		PrintMsg(REPADMIN_SYNCALL_PRINT_ITER, ++ulIteration);
	    } else {
		PrintMsg(REPADMIN_PRINT_CR);
	    }

	} while (bIterate);
	if (rgpszNameContexts[j]!=NULL) {
	    free(rgpszNameContexts[j]);
	}
    }

    free(rgpszNameContexts);
    DsUnBind (&hDS);


    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\replstruct\replmarshalxml.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:
    ReplMarshalXml.cxx

Abstract:
    Function to convert repl structs to XML.

Author:

    Chris King          [t-chrisk]    July-2000
    
Revision History:

--*/

#include <NTDSpchx.h>
#pragma hdrstop

#include <ntdsa.h>
#include <debug.h>
#include <dsutil.h>

#include "ReplStructInfo.hxx"
#include "ReplMarshal.hxx"
#include "ReplTables.hxx"

#include <fileno.h>
#define FILENO   FILENO_UTIL_REPLSTRUCT_REPLMARSHALXML

DWORD
Repl_XmlTemplateLength(ReplStructInfo * pRow)
/*++
Routine Description:

  Calculate the lenght of the XML representation if all the data fileds were empty. This function
  is called during the creation of a table and the result is stored as a field in that table.
  
Arguments:

  pRow - the row of the table.
  
Return values:

  The length of the xml template.
  
--*/
{
    DWORD dwXmlStrLength = 0, i;

    dwXmlStrLength += wcslen(pRow->szStructName) * 2 + wcslen(L"<></>\n\n");
    for (i = 0; i < pRow->dwFieldCount; i ++)
    {
        dwXmlStrLength += 
            wcslen(pRow->aReplTypeInfo[i].szFieldName) * 2 +
            wcslen(L"\t<></>\n");
    }
    return (dwXmlStrLength + 1) * 2;
}

DWORD
Repl_TypeToString(DS_REPL_DATA_TYPE typeId, PVOID pData, PCHAR pBuf, PDWORD pdwBufSize)
/*++
Routine Description:

  Converts a field in a replication structure into its XML string representation.
  
Arguments:

  typeId - the id of the type
  pData - the value to convert
  pBuf - the location to put the data, NULL to see how much memory is needed
  pdwBufSize - the size of the buffer or the amount of memory needed to hold the data
  
Return values:

    If memory allocated for the xml representation buffer is not large enough to hold the XML, 
    the ERROR_MORE_DATA error code is returned. The required buffer size is returned in pdwBufSize. 
    If this function fails with any error code other than ERROR_MORE_DATA, zero is returned in pdwBufSize. 
  
--*/
{
    Assert(ARGUMENT_PRESENT(pdwBufSize));
    Assert(ARGUMENT_PRESENT(pData));

    DWORD dwLength, dwStrLength, err = 0;
    LPWSTR szStr;
    WCHAR wbuf[256];
    SYSTEMTIME sysTime;

    // Calculate the number of characters in the string representation of the data
    // type w/o the terminating null character
    switch (typeId)
    {
    case dsReplDWORD:
    case dsReplLONG:
    case dsReplOPTYPE:
        dwStrLength = wcslen(_itow(*(PDWORD)pData, wbuf, 10));
        break;

    case dsReplUSN:
        dwStrLength = wcslen(_i64tow(*(PLONGLONG)pData, wbuf, 10));
        break;

    case dsReplString:
        if (*(LPWSTR*)pData) {
            dwStrLength = wcslen(*(LPWSTR*)pData);
        }
        else {
            dwStrLength = 0;
        }
        break;

    case dsReplUUID:
        err = UuidToStringW((UUID *)pData, &szStr);
        if (err != RPC_S_OK) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        dwStrLength = wcslen(szStr);
        RpcStringFreeW(&szStr);
        break;

    case dsReplFILETIME:
        // Generate XML datetime syntaxed value -- date in a subset of ISO 8601
        // format, with optional time and no optional zone.  For example,
        // "1988-04-07T18:39:09".  Z is appended to denote UTC time (to
        // differentiate from unadorned local time).
        if (FileTimeToSystemTime((FILETIME *) pData, &sysTime)) {
            dwStrLength = swprintf(wbuf,
                                   L"%04d-%02d-%02dT%02d:%02d:%02dZ",
                                   sysTime.wYear % 10000,
                                   sysTime.wMonth,
                                   sysTime.wDay,
                                   sysTime.wHour,
                                   sysTime.wMinute,
                                   sysTime.wSecond);
        } else {
            Assert(!"Invalid FILETIME!");
            dwStrLength = 0;
        }
        break;        
        
    case dsReplPadding:
    case dsReplBinary:
        dwStrLength = 0;
        break;
    }

    // Convert from the number of characters to the number of bytes needed to represent
    // the string version of the type
    dwLength = sizeof(WCHAR) * dwStrLength;
    if(requestLargerBuffer((PCHAR)pBuf, pdwBufSize, dwLength, &err)) {
        return err;
    }

    if (!dwLength) {
        goto exit;
    }

    switch (typeId)
    {
    case dsReplDWORD:
    case dsReplLONG:
    case dsReplOPTYPE:
    case dsReplUSN:
        memcpy(pBuf, (PVOID)wbuf, dwLength);
        break;
       
    case dsReplUUID:
        err = UuidToStringW((UUID *)pData, &szStr);
        if (err != RPC_S_OK) {
            err = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        memcpy(pBuf, (PVOID)szStr, dwLength);
        RpcStringFreeW(&szStr);
        break;

    case dsReplString:
        memcpy(pBuf, *(PVOID *)pData, dwLength);
        break;

    case dsReplFILETIME:
        memcpy(pBuf, wbuf, dwLength);
        break;

    case dsReplPadding:
    case dsReplBinary:
        break;
    }

    *pdwBufSize = dwLength;

exit:
    return err;
}

DWORD
Repl_MarshalXml(IN puReplStruct pReplStruct, 
                IN ATTRTYP attrId,
                IN OUT LPWSTR szXmlBuf, OPTIONAL
                IN OUT PDWORD pdwXmlLength)
/*++
Routine Description:

  Calculate how much memory is needed to transform a replication structure into the XML 
  representation and preform the transform a replication stucture into an XML string.

  The transform from struct to XML is simple. The struct is converted into a string with
  the following format:

  <STRUCT_NAME>
        <FIELD_NAME>[value]<\FIELD_NAME>
        ...
  <\STRUCT_NAME>
  
Arguments:
  pReplStruct - a pointer to a union of suppored replication structures
  attrId - indentifies a replication attributes
  szXML - 
  pdwXMLLen -
    Address of a DWORD value of the signature data length. Upon function entry, 
    this DWORD value contains the number of bytes allocated for the szXML buffer. 
    Upon exit, it is set to the number of bytes required for the szXML buffer. 

  
Return values:

    If memory allocated for the pbSignature buffer is not large enough to hold the signature, 
    the ERROR_MORE_DATA error code is returned. The required buffer size is returned in pdwXMLLen. 
    If this function fails with any error code other than ERROR_MORE_DATA, zero is returned in pdwXMLLen. 
  
--*/
{
    Assert(pdwXmlLength);
    Assert(Repl_IsConstructedReplAttr(attrId));
    
    DWORD i, err;
    LPWSTR szXml = szXmlBuf;
    DS_REPL_STRUCT_TYPE structId = Repl_Attr2StructTyp(attrId);
    DWORD dwXmlLength = Repl_GetXmlTemplateLength(structId);
    DWORD dwFieldCount = Repl_GetFieldCount(structId);
    psReplStructField aReplStructField = Repl_GetFieldInfo(structId);
    LPCWSTR szStructName = Repl_GetStructName(structId);

    // Calculate how much memory is needed
    for (i = 0; i < dwFieldCount; i ++)
    {
        DWORD dwSize;
        err = Repl_TypeToString(
                aReplStructField[i].eType, 
                ((PCHAR)pReplStruct + aReplStructField[i].dwOffset),
                NULL,
                &dwSize);
        if (err) {
            goto exit;
        }
        dwXmlLength += dwSize;
    }

    if(requestLargerBuffer((PCHAR)szXmlBuf, pdwXmlLength, dwXmlLength, &err)) {
        goto exit;
    }
    

    // Construct string
    szXml += wsprintfW(szXml, L"<%ws>\n", szStructName);
    for (i = 0; i < dwFieldCount; i ++)
    {
        DWORD dwSize = dwXmlLength - (DWORD)(szXml - szXmlBuf);
        szXml += wsprintfW(szXml, L"\t<%ws>", aReplStructField[i].szFieldName);
        err = Repl_TypeToString(
            aReplStructField[i].eType, 
            ((PCHAR)pReplStruct + aReplStructField[i].dwOffset),
            (PCHAR)szXml,
            &dwSize);
        if (err) {
            goto exit;
        }
        szXml = (PWCHAR)((PCHAR)szXml + dwSize);
        szXml += wsprintfW(szXml, L"</%ws>\n", aReplStructField[i].szFieldName);
    }
    szXml += wsprintfW(szXml, L"</%ws>\n", szStructName);

    *pdwXmlLength = (wcslen(szXmlBuf) + 1) * 2;
    Assert(*pdwXmlLength == dwXmlLength);

exit:
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\repadmin\reputil.c ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

   Repadmin - Replica administration test tool

   reputil.c - utility routines

Abstract:

   This tool provides a command line interface to major replication functions

Author:

Environment:

Notes:

Revision History:

    Rsraghav has been in here too

    Will Lees    wlees   Feb 11, 1998
         Converted code to use ntdsapi.dll functions

    Aaron Siegel t-asiege 18 June 1998
         Added support for DsReplicaSyncAll

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntdsa.h>
#include <dsaapi.h>
#include <mdglobal.h>
#include <scache.h>
#include <drsuapi.h>
#include <dsconfig.h>
#include <objids.h>
#include <stdarg.h>
#include <drserr.h>
#include <drax400.h>
#include <dbglobal.h>
#include <winldap.h>
#include <anchor.h>
#include "debug.h"
#include <dsatools.h>
#include <dsevent.h>
#include <dsutil.h>
#include <bind.h>       // from ntdsapi dir, to crack DS handles
#include <ismapi.h>
#include <schedule.h>
#include <minmax.h>     // min function
#include <mdlocal.h>
#include <winsock2.h>

#include "repadmin.h"

// Stub out FILENO and DSID, so the Assert()s will work
#define FILENO 0
#define DSID(x, y)  (0)

//
// Note: We're including csv.h a second time,
// but when we define DEFINE_CSV_TABLE it behaves 
// differently.  This is a clever way to get around
// keeping two tables in sync.
//
#define DEFINE_CSV_TABLE 1
#include "csv.h"
#undef DEFINE_CSV_TABLE

//
// Helper quasi function for csv routines...
//
#define CHK_BUFFER_USED(FailAction)     if (cchTemp == 0){ \
                                            Assert(!"Should never happen"); \
                                            fwprintf(stderr, L"Internal error, repadmin must quit."); \
                                            FailAction; \
                                        }


LPWSTR
Win32ErrToString(
    IN  ULONG   dwMsgId
    )
{
    static WCHAR szError[4096];

    DWORD       cch;

    cch = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
                          | FORMAT_MESSAGE_IGNORE_INSERTS,
                         NULL,
                         dwMsgId,
                         GetSystemDefaultLangID(),
                         szError,
                         ARRAY_SIZE(szError),
                         NULL);
    if (0 != cch) {
        // Chop off trailing \r\n.
        Assert(L'\r' == szError[wcslen(szError)-2]);
        Assert(L'\n' == szError[wcslen(szError)-1]);
        szError[wcslen(szError)-2] = L'\0';
    }
    else {
        swprintf(szError, L"Can't retrieve message string %d (0x%x), error %d.",
                 dwMsgId, dwMsgId, GetLastError());
    }

    return szError;
}

LPWSTR
NtdsmsgToString(
    IN  ULONG   dwMsgId
    )
{
    static WCHAR szError[4096];
    static HMODULE hmodNtdsmsg = NULL;

    DWORD       cch;

    if (NULL == hmodNtdsmsg) {
        hmodNtdsmsg = LoadLibrary("ntdsmsg.dll");
    }
    
    if (NULL == hmodNtdsmsg) {
        swprintf(szError, L"Can't load ntdsmsg.dll, error %d.",
                 GetLastError());
    } else {
        DWORD iTry;
        
        for (iTry = 0; iTry < 4; iTry++) {
            DWORD dwTmpMsgId = dwMsgId;

            switch (iTry) {
            case 0:
                dwTmpMsgId = dwMsgId;
                break;

            case 1:
                dwTmpMsgId = (dwMsgId & 0x3FFFFFFF) | 0x40000000;
                break;

            case 2:
                dwTmpMsgId = (dwMsgId & 0x3FFFFFFF) | 0x80000000;
                break;

            case 3:
                dwTmpMsgId = (dwMsgId & 0x3FFFFFFF) | 0xC0000000;
                break;
            }

            cch = FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE
                                  | FORMAT_MESSAGE_IGNORE_INSERTS,
                                 hmodNtdsmsg,
                                 dwTmpMsgId,
                                 GetSystemDefaultLangID(),
                                 szError,
                                 ARRAY_SIZE(szError),
                                 NULL);
            if (0 != cch) {
                // Chop off trailing \r\n.
                Assert(L'\r' == szError[wcslen(szError)-2]);
                Assert(L'\n' == szError[wcslen(szError)-1]);
                szError[wcslen(szError)-2] = L'\0';
                break;
            }
        }

        if (0 == cch) {
            swprintf(szError, L"Can't retrieve message string %d (0x%x), error %d.",
                     dwMsgId, dwMsgId, GetLastError());
        }
    }

    return szError;
}


WCHAR *        
DSTimeToDisplayStringW(
    DSTIME  dsTime,
    WCHAR * wszTime,
    ULONG   cchTime
    )
{
    CHAR    szTime[ SZDSTIME_LEN ];

    DSTimeToDisplayStringCch(dsTime, szTime, ARRAY_SIZE(szTime));

    Assert(cchTime >= ARRAY_SIZE(szTime));

    wsprintfW(wszTime, L"%S", szTime);

    return(wszTime);
}


DWORD
GetNtdsDsaSiteServerPair(
    IN  LPWSTR pszDsaDN,
    IN OPTIONAL LPWSTR * ppszSiteName,
    IN OPTIONAL LPWSTR * ppszServerName
    )
/*++

Routine Description:

    This gets the Site and Dsa names from the DSA DN, because
    the /csv mode needs them seperate.
    
Arguments:

    pszDsaDN - The DSA DN to split
    ppszSiteName - 
    ppszServerName - 
        The static buffers for the site and server name respectively.
        Make sure you copy them if you want to keep them.
      
        If there is no way to get the site and server here, then 
        this function returns a "-" in each buffer.

Return Value:

    Win32 Error code.

--*/
{
    static WCHAR  szSiteDisplayName[2 + MAX_RDN_SIZE + 20];
    static WCHAR  szServerDisplayName[2 + MAX_RDN_SIZE + 20];
    LPWSTR *      ppszRDNs;
    LPWSTR        pszSite;
    LPWSTR        pszServer;
    
    // FUTURE-2002/08/03-BrettSh - Would be better to combine
    // this function and GetNtdsDsaDisplayName().

    if (NULL == pszDsaDN) {
        Assert(!"I don't think this is valid");
        // Just in case, safe punt
        szSiteDisplayName[0] = L'-';
        szSiteDisplayName[1] = L'\0';
        szServerDisplayName[0] = L'-';
        szServerDisplayName[1] = L'\0';
        return(ERROR_INVALID_PARAMETER);
    } else {
        ppszRDNs = ldap_explode_dnW(pszDsaDN, 1);

        if ((NULL == ppszRDNs)
            || (4 > ldap_count_valuesW(ppszRDNs))) {
            // No memory or bad DN -- return what we have.
            szSiteDisplayName[0] = L'-';
            szSiteDisplayName[1] = L'\0';
            return(ERROR_INVALID_PARAMETER);
        } else {
            pszSite = ppszRDNs[3];
            pszServer = ppszRDNs[1];

            // Check for deleted NTDS-DSA object
            wsprintfW(szSiteDisplayName, L"%ls", pszSite);
            wsprintfW(szServerDisplayName, L"%ls", pszServer);
            if (DsIsMangledRdnValueW( ppszRDNs[0], wcslen(ppszRDNs[0]),
                                     DS_MANGLE_OBJECT_RDN_FOR_DELETION )) {
                wcscat( szServerDisplayName, L" (deleted DSA)" );
            }

            ldap_value_freeW(ppszRDNs);
        }

    }
    if (ppszSiteName) {
        *ppszSiteName = szSiteDisplayName;
    }
    if (ppszServerName) {
        *ppszServerName = szServerDisplayName;
    }

    return ERROR_SUCCESS;
}


LPWSTR
GetNtdsDsaDisplayName(
    IN  LPWSTR pszDsaDN
    )
{
    static WCHAR  szDisplayName[2 + 2*MAX_RDN_SIZE + 20];
    LPWSTR *      ppszRDNs;
    LPWSTR        pszSite;
    LPWSTR        pszServer;

    if (NULL == pszDsaDN) {
        return L"(null)";
    }

    ppszRDNs = ldap_explode_dnW(pszDsaDN, 1);
    
    if ((NULL == ppszRDNs)
        || (4 > ldap_count_valuesW(ppszRDNs))) {
        // No memory or bad DN -- return what we have.
        lstrcpynW(szDisplayName, pszDsaDN, ARRAY_SIZE(szDisplayName));
    } else {
        pszSite = ppszRDNs[3];
        pszServer = ppszRDNs[1];
    
        // Check for deleted NTDS-DSA object
        wsprintfW(szDisplayName, L"%ls\\%ls", pszSite, pszServer);
        if (DsIsMangledRdnValueW( ppszRDNs[0], wcslen(ppszRDNs[0]),
                                 DS_MANGLE_OBJECT_RDN_FOR_DELETION )) {
            wcscat( szDisplayName, L" (deleted DSA)" );
        }
    
        ldap_value_freeW(ppszRDNs);
    }

    return szDisplayName;
}

LPWSTR
GetNtdsSiteDisplayName(
    IN  LPWSTR pszSiteDN
    )
{
    static WCHAR  szDisplayName[2 + 2*MAX_RDN_SIZE + 20];
    LPWSTR *      ppszRDNs;
    LPWSTR        pszSite;

    if (NULL == pszSiteDN) {
        return L"(null)";
    }

    ppszRDNs = ldap_explode_dnW(pszSiteDN, 1);
    Assert(NULL != ppszRDNs);
    Assert(2 < ldap_count_valuesW(ppszRDNs));

    pszSite = ppszRDNs[1];

    // Check for deleted NTDS-Site object
    wsprintfW(szDisplayName, L"%ls", pszSite);
    if (DsIsMangledRdnValueW( ppszRDNs[0], wcslen(ppszRDNs[0]),
                             DS_MANGLE_OBJECT_RDN_FOR_DELETION)) {
        wcscat( szDisplayName, L" (deleted Site)" );
    }

    ldap_value_freeW(ppszRDNs);

    return szDisplayName;
}

LPWSTR
GetTransportDisplayName(
    IN  LPWSTR pszTransportDN   OPTIONAL
    )
{
    static WCHAR  szDisplayName[1 + MAX_RDN_SIZE];
    LPWSTR *      ppszRDNs;

    if (NULL == pszTransportDN) {
        return L"RPC";
    }

    ppszRDNs = ldap_explode_dnW(pszTransportDN, 1);
    if (NULL == ppszRDNs) {
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
        exit(ERROR_OUTOFMEMORY);
    }

    wcscpy(szDisplayName, ppszRDNs[0]);

    ldap_value_freeW(ppszRDNs);

    return szDisplayName;
}

ULONG
GetPublicOptionByNameW(
    OPTION_TRANSLATION * Table,
    LPWSTR pwszPublicOption
    )
{
    while (Table->pwszPublicOption) {
        if (_wcsicmp( pwszPublicOption, Table->pwszPublicOption ) == 0) {
            return Table->PublicOption;
        }
        Table++;
    }

    PrintMsg(REPADMIN_GENERAL_UNKNOWN_OPTION, pwszPublicOption);
    return 0;
}

LPWSTR
GetOptionsString(
    IN  OPTION_TRANSLATION *  Table,
    IN  ULONG                 PublicOptions
    )
{
    static WCHAR wszOptions[1024];
    DWORD i, publicOptions;
    BOOL fFirstOption = TRUE;

    if (0 == PublicOptions) {
        wcscpy(wszOptions, L"(no options)");
    }
    else {
        *wszOptions = L'\0';

        for(i = 0; 0 != Table[i].InternalOption; i++) {
            if (PublicOptions & Table[i].PublicOption) {
                if (!fFirstOption) {
                    wcscat(wszOptions, L" ");
                }
                else {
                    fFirstOption = FALSE;
                }

                wcscat(wszOptions, Table[i].pwszPublicOption);
                PublicOptions &= ~Table[i].PublicOption;
            }
        }

        if (0 != PublicOptions) {
            // A new public option has been added that this incarnation of
            // repadmin doesn't understand.  Display its hex value.
            if (!fFirstOption) {
                wcscat(wszOptions, L" ");
            }

            swprintf(wszOptions+wcslen(wszOptions), L"0x%x", PublicOptions);
        }
    }

    return wszOptions;
}


int
GetRootDomainDNSName(
    IN  LPWSTR   pszDSA,
    OUT LPWSTR * ppszRootDomainDNSName
    )
{
    NTSTATUS                    ntStatus;
    LSA_OBJECT_ATTRIBUTES       oa;
    LSA_HANDLE                  hPolicy;
    POLICY_DNS_DOMAIN_INFO *    pDnsDomainInfo;
    DWORD                       cchRootDomainDNSName;
    DWORD                       cbDSA;
    UNICODE_STRING              strDSA;
    UNICODE_STRING *            pstrDSA = NULL;

    // Ideally this should derive the enterprise root domain DNS name from the
    // NC names on the root DSE and DsCrackNames().  The method below won't work
    // in many cases where alternate credentials are supplied.  This function is
    // called only by the relatively rarely used /propcheck and /fullsyncall
    // functions, however.

    memset(&oa, 0, sizeof(oa));

    if ((NULL != pszDSA) && (0 != wcscmp(pszDSA, L"localhost"))) {
        cbDSA = sizeof(WCHAR) * wcslen(pszDSA);
        strDSA.Buffer = pszDSA;
        strDSA.Length = (USHORT) cbDSA;
        strDSA.MaximumLength = (USHORT) cbDSA;
        pstrDSA = &strDSA;
    }

    // Cache the DNS name of the root domain.
    ntStatus = LsaOpenPolicy(pstrDSA, &oa,
                             POLICY_VIEW_LOCAL_INFORMATION, &hPolicy);
    if (!NT_SUCCESS(ntStatus)) {
        PrintFuncFailed(L"LsaOpenPolicy", ntStatus);
        return ntStatus;
    }

    ntStatus = LsaQueryInformationPolicy(hPolicy, PolicyDnsDomainInformation,
                                         &pDnsDomainInfo);
    if (!NT_SUCCESS(ntStatus)) {
        PrintFuncFailed(L"LsaQueryInformationPolicy", ntStatus);
        return ntStatus;
    }

    cchRootDomainDNSName = pDnsDomainInfo->DnsForestName.Length/sizeof(WCHAR);
    *ppszRootDomainDNSName = (LPWSTR) malloc(sizeof(WCHAR) * (1 + cchRootDomainDNSName));

    if (NULL == *ppszRootDomainDNSName) {
        PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
        return STATUS_NO_MEMORY;
    }

    wcsncpy(*ppszRootDomainDNSName,
            pDnsDomainInfo->DnsForestName.Buffer,
            cchRootDomainDNSName);
    (*ppszRootDomainDNSName)[cchRootDomainDNSName] = L'\0';

    return STATUS_SUCCESS;
}


void
printBitField(
    DWORD BitField,
    WCHAR **ppszBitNames
    )

/*++

Routine Description:

Utility routine to stringize a bit mask with readable names

Arguments:

    BitField - Value to be decoded
    ppszBitNames - Table mapping bit position to string name

Return Value:

    None

--*/

{
    DWORD bit, mask;
    for( bit = 0, mask = 1; bit < 32; bit++, mask <<= 1 ) {
        if (!ppszBitNames[bit] ) {
            // That's all the fields we know about
            break;
        }
        if (BitField & mask) {
            PrintMsg(REPADMIN_PRINT_SPACE);
            PrintMsg(REPADMIN_PRINT_STR_NO_CR, ppszBitNames[bit]);
        }
    }
    PrintMsg(REPADMIN_PRINT_CR);
} /* printBitField */


DWORD
AllocConvertWideEx(
    IN  INT     nCodePage,
    IN  LPCSTR  StringA,
    OUT LPWSTR *pStringW
    )

/*++

Routine Description:

Stolen from ntdsapi\util.c
Helper routine to convert a narrow string to a newly allocated wide one

Arguments:

    StringA -
    pStringW -

Return Value:

    DWORD -

--*/

{
    DWORD numberWideChars, numberConvertedChars, status;
    LPWSTR stringW;

    if (pStringW == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    if (StringA == NULL) {
        *pStringW = NULL;
        return ERROR_SUCCESS;
    }

    // Get the needed length
    numberWideChars = MultiByteToWideChar(
        nCodePage,
        MB_PRECOMPOSED,
        StringA,
        -1,
        NULL,
        0);

    if (numberWideChars == 0) {
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the new buffer
    stringW = LocalAlloc( LPTR, (numberWideChars + 1) * sizeof( WCHAR ) );
    if (stringW == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Do the conversion into the new buffer
    numberConvertedChars = MultiByteToWideChar(
        nCodePage,
        MB_PRECOMPOSED,
        StringA,
        -1,
        stringW,
        numberWideChars + 1);
    if (numberConvertedChars == 0) {
        LocalFree( stringW );
        return ERROR_INVALID_PARAMETER;
    }

    // return user parameter
    *pStringW = stringW;

    return ERROR_SUCCESS;
} /* allocConvertWide */


void
printSchedule(
    PBYTE pSchedule,
    DWORD cbSchedule
    )
/*++

Routine Description:

    Description

Arguments:

    None

Return Value:

    None

--*/
{
    PSCHEDULE header = (PSCHEDULE) pSchedule;
    PBYTE data = (PBYTE) (header + 1);
    DWORD day, hour;
    ULONG dow[] = { REPADMIN_SUN, REPADMIN_MON, REPADMIN_TUE,
                    REPADMIN_WED, REPADMIN_THU, REPADMIN_FRI,
                    REPADMIN_SAT };

    Assert( header->Size == cbSchedule );
    Assert( header->NumberOfSchedules == 1 );
    Assert( header->Schedules[0].Type == SCHEDULE_INTERVAL );

    PrintMsg(REPADMIN_SCHEDULE_HOUR_HDR);
    for( day = 0; day < 7; day++ ) {
        PrintMsg(dow[day]);
        PrintMsg(REPADMIN_PRINT_STR_NO_CR, L": ");
        for( hour = 0; hour < 24; hour++ ) {
            PrintMsg(REPADMIN_PRINT_HEX_NO_CR, (*data & 0xf));
            data++;
        }
        PrintMsg(REPADMIN_PRINT_CR);
    }
}


void
totalScheduleUsage(
    PVOID *ppContext,
    PBYTE pSchedule,
    DWORD cbSchedule,
    DWORD cNCs
    )

/*++

Routine Description:

Helper routine to total many usages of a schedule.  The counts for each quarter hour
are totaled. The final tally can also be printed.

Arguments:

    ppContext - Opaque context block
    if *ppContext = NULL, allocate a context block
    if *ppContext != NULL, use preallocated context block

    pSchedule - Schedule structure on a connection
    if pSchedule = NULL, print report and free context
    if pSchedule != NULL, add to totals

    cbSchedule - Schedule length

    cNCs - Number of NC's using this schedule

Return Value:

    None

--*/

{
    DWORD day, hour, quarter;
    PBYTE pbCounts = (PBYTE) *ppContext;
    ULONG dow[] = { REPADMIN_SUN, REPADMIN_MON, REPADMIN_TUE,
                    REPADMIN_WED, REPADMIN_THU, REPADMIN_FRI,
                    REPADMIN_SAT };

    if (!pbCounts) {
        *ppContext = pbCounts = calloc( 7 * 24 * 4, 1 ) ;
    }
    if (!pbCounts) {
        // No context, fail
        Assert( FALSE );
        return;
    }

    if (pSchedule) {
        PSCHEDULE header = (PSCHEDULE) pSchedule;
        PBYTE data = (PBYTE) (header + 1);

        Assert( header->Size == cbSchedule );
        Assert( header->NumberOfSchedules == 1 );
        Assert( header->Schedules[0].Type == SCHEDULE_INTERVAL );

        for( day = 0; day < 7; day++ ) {
            for( hour = 0; hour < 24; hour++ ) {
                if (*data & 0x1) (*pbCounts) += (BYTE) cNCs;
                pbCounts++;
                if (*data & 0x2) (*pbCounts) += (BYTE) cNCs;
                pbCounts++;
                if (*data & 0x4) (*pbCounts) += (BYTE) cNCs;
                pbCounts++;
                if (*data & 0x8) (*pbCounts) += (BYTE) cNCs;
                pbCounts++;

                data++;
            }
        }
    } else {

        PrintMsg(REPADMIN_SCHEDULE_LOADING);
        PrintMsg(REPADMIN_PRINT_STR, L"     ");
        for( hour = 0; hour < 12; hour++ ) {
            PrintTabMsg(3, REPADMIN_SCHEDULE_DATA_HOUR, hour);
        }
        PrintMsg(REPADMIN_PRINT_CR);
        PrintMsg(REPADMIN_PRINT_STR, L"     ");
        for( hour = 0; hour < 12; hour++ ) {
            for( quarter = 0; quarter < 4; quarter++ ) {
                PrintMsg(REPADMIN_SCHEDULE_DATA_QUARTER, quarter);
            }
        }
        PrintMsg(REPADMIN_PRINT_CR);
        for( day = 0; day < 7; day++ ) {
            PrintMsg(dow[day]);
            PrintMsg(REPADMIN_PRINT_STR_NO_CR, L": ");
            for( hour = 0; hour < 12; hour++ ) {
                for( quarter = 0; quarter < 4; quarter++ ) {
                    PrintMsg(REPADMIN_SCHEDULE_DATA_HOUR, *pbCounts);
                    pbCounts++;
                }
            }
            PrintMsg(REPADMIN_PRINT_CR);
            PrintMsg(dow[day]);
            PrintMsg(REPADMIN_PRINT_STR_NO_CR, L": ");
            for( hour = 12; hour < 24; hour++ ) {
                for( quarter = 0; quarter < 4; quarter++ ) {
                    PrintMsg(REPADMIN_SCHEDULE_DATA_HOUR, *pbCounts);
                    pbCounts++;
                }
            }
            PrintMsg(REPADMIN_PRINT_CR);
        }

        free( *ppContext );
        *ppContext = NULL;
    }

} /* totalScheduleUsage */


void
raLoadString(
    IN  UINT    uID,
    IN  DWORD   cchBuffer,
    OUT LPWSTR  pszBuffer
    )
/*++

Routine Description:

    Load the string resource corresponding to the given ID into a buffer.

Arguments:

    uID (IN) - ID of string resource to load.

    cchBuffer (IN) - size in characters of pszBuffer.

    pszBuffer (OUT) - buffer to receive string.

Return Values:

    None.  Loads the null string on error.

--*/
{
    static HMODULE s_hMod = NULL;
    int cch;
    DWORD err;

    if (NULL == s_hMod) {
        s_hMod = GetModuleHandle(NULL);
    }

    cch = LoadStringW(s_hMod, uID, pszBuffer, cchBuffer);
    if (0 == cch) {
        err = GetLastError();
        wprintf(L"** Cannot load string resource %d, error %d:\n"
                L"**     %ls\n",
                uID, err, Win32ErrToString(err));
        Assert(!"Cannot load string resource!");
        *pszBuffer = L'\0';
    }
}
              
void
CsvSetParams(
    IN  enum eCsvCmd eCsvCmd,
    WCHAR *  szSite,
    WCHAR *  szServer
    )
/*++

Routine Description:

    This sets the first 3 automatic CSV columns.

Arguments:

    eCsvCmd   - The 1st column is the command mode we're in, this
                get translated to the string name when it's printed.
    szSite    - The 2nd column is the site name to the targeted server.
    szServer  - The 3rd column is the server name of the targeted server.

Return Value:

    None.

--*/
{
    WCHAR *  szNewSite;
    WCHAR *  szNewServer;

    if (szSite == NULL ||
        szServer == NULL) {
        Assert(!"Must always set a valid site/server pair, even if it's just a -");
        return;
    }

    if (gCsvMode.eCsvCmd == eCSV_NULL_CMD &&
        eCsvCmd != eCSV_REPADMIN_CMD) {
        Assert(!"Programmer error, can't go from NULL to non repadmin cmd");
        return;
    }
    if (gCsvMode.eCsvCmd != eCSV_NULL_CMD &&
        eCsvCmd == eCSV_NULL_CMD) {
        Assert(!"Programmer error, once in CSV mode, can't get out of this mode");
        return;
    }

    gCsvMode.eCsvCmd = eCsvCmd;

    szNewSite = malloc((wcslen(szSite)+1) *sizeof(WCHAR));
    CHK_ALLOC(szNewSite);
    wcscpy(szNewSite, szSite);
    free(gCsvMode.szSite);
    gCsvMode.szSite = szNewSite;
    
    szNewServer = malloc((wcslen(szServer)+1) *sizeof(WCHAR));
    CHK_ALLOC(szNewServer);
    wcscpy(szNewServer, szServer);
    free(gCsvMode.szServer);
    gCsvMode.szServer = szNewServer;

}

DWORD
formatMsgHelp(
    IN  DWORD   dwWidth,
    IN  LPWSTR  pszBuffer,
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwMessageCode,
    IN  va_list *vaArgList
    )

/*++

Routine Description:

Print a message where the format comes from a message file. The message in the
message file does not use printf-style formatting. Use %1, %2, etc for each
argument. Use %<arg>!printf-format! for non string inserts.

Note that this routine also forces each line to be the current indention width.
Also, each line is printed at the right indentation.

Arguments:

    dwWidth - Maximum width of line
    pszBuffer - Buffer to write formatted text into
    dwBufferSize - Maximum size of buffer
    dwMessageCode - Message code to be formatted
    vaArgList - Arguments

Return Value:

--*/

{
    UINT nBuf;

    // Format message will store a multi-line message in the buffer
    nBuf = FormatMessageW(
        FORMAT_MESSAGE_FROM_HMODULE | (FORMAT_MESSAGE_MAX_WIDTH_MASK & dwWidth),
        0,
        dwMessageCode,
        0,
        pszBuffer,
        dwBufferSize,
        vaArgList );
    if (nBuf == 0) {
        nBuf = swprintf( pszBuffer, L"Message 0x%x not found. Error %d.\n",
                         dwMessageCode, GetLastError() );
        nBuf = wcslen(pszBuffer);
    }
    Assert(nBuf < dwBufferSize);
    return(nBuf);
} /* formatMsgHelp */

void
PrintMsgInternal(
    IN  FILE *  hOut,
    IN  DWORD   dwMessageCode,
    IN  WCHAR * wszSpaces,
    IN  va_list *vaArgList
    )

/*++

Routine Description:

Wrapper around PrintMsgHelp with width restrictions.
This is the usual routine to use.

Arguments:

    hOut - either stdout or stderr ...                
    dwMessageCode - Message code
    Args - Variable length argument list, if any

Return Value:

--*/

{
    static WCHAR s_szBuffer[4096];

    formatMsgHelp( 0,          // Width restriction, not used
                   s_szBuffer,
                   ARRAY_SIZE( s_szBuffer ),
                   dwMessageCode,
                   vaArgList );


    if (hOut == stdout && bCsvMode()) {
        // Uh-oh ...
        Assert(!"PrintMsg() can't be called ");
        return;
    }

    fwprintf(hOut, L"%ws%ws", (wszSpaces) ? wszSpaces : L"", s_szBuffer );

} /* PrintMsgInternal */

DWORD
CsvAppendField(
    WCHAR * szBuffer,
    ULONG   cchBuffer,
    WCHAR * szField
    )
/*++

Routine Description:

    This routine takes a pointer into an existing buffer and a size left in
    the buffer, and appends the field in a CSV friendly way to the buffer,
    checking for enough space.
    
    Examples of proper CSV quoting style. Strings are on their own lines
    for clarity in what is and isn't printed.  All quotes are printed.
    
        if szField equals 
                Just A Plain Field
            then this will be appended
                ,Just A Plain Field
                
        if szField equals 
                A Field With A Comma, In The Field
            then this will be appended
                ,"A Field With A Comma, In The Field"
                
        if szField equals
                A Field With a Comma, And a Quote" In the Field
            then this will be appended
                ,"A Field With a Comma, And a Quote"" In the Field"
                
        if szField equals
                A Field With Only A Quote" In the Field
            then this will be appended
                ,A Field With Only A Quote" In the Field
                

Arguments:

    szBuffer  - pointer to middle of a buffer for appending the CSV field.
    cchBuffer - wide char count of buffer left.
    szField   - string to concatonate with proper CSV quoting

Return Value:

    wide char count of buffer used.

--*/
{
    // This quasi-routine ensures we've got at least one more
    // slot in our buffer, and if not ensures NULL termination
    // and fails the function.
    #define CHECK_BUFFER()  if (iDst >= cchBuffer) { \
                                Assert(!"We actually ran out of buffer!?!"); \
                                szBuffer[iDst-1] = L'\0'; \
                                return(0); \
                            }
    ULONG cchUsed = 0;
    ULONG iDst, iSrc;
    ULONG cchField;
    BOOL  bQuoteIt;

    Assert(szField);

    if (szField != NULL) {
        cchField = wcslen(szField);
    }

    if (cchBuffer < 1) {
        // Return early if cchBuffer < 1, because then CHECK_BUFFER
        // could corrupt memory.  Also we should never be called 
        // with this little buffer
        Assert(!"We got called with less than 1 buffer!");
        return(0);
    }

    // If there is a comma in the string quote it.
    bQuoteIt = (NULL != wcschr(szField, L','));

    iSrc = 0;
    iDst = 0;

    CHECK_BUFFER();
    szBuffer[iDst++] = L',';

    if (bQuoteIt) {
        CHECK_BUFFER();
        szBuffer[iDst++] = L'"';
    }

    while (iSrc < cchField) {

        if (szField[iSrc] == L'\n' ||
            szField[iSrc] == L'\r') {
            iSrc++; // skip this one.

        } else if (szField[iSrc] == L'"' && bQuoteIt) {
            CHECK_BUFFER();
            szBuffer[iDst++] = szField[iSrc];
            CHECK_BUFFER();
            szBuffer[iDst++] = szField[iSrc++];

        } else {
            CHECK_BUFFER();
            szBuffer[iDst++] = szField[iSrc++];

        }
    }

    if (bQuoteIt) {
        CHECK_BUFFER();
        szBuffer[iDst++] = L'"';
    }
    
    CHECK_BUFFER();
    szBuffer[iDst] = L'\0';

#undef CHECK_BUFFER

    return(iDst);
}

DWORD
CsvBeginRow(
    WCHAR *  szBuffer,
    ULONG    cchBuffer,
    BOOL     bDoSiteServer,
    WCHAR *  szCmd,
    WCHAR *  szType
    )
/*++

Routine Description:

    This correctly begins one of our CSV formatted rows.

Arguments:

    szBuffer  - pointer to a buffer to begin a fresh the CSV row
    cchBuffer - wide char count of buffer
    bDoSiteServer - whether to do the site and server fields (2nd and 3rd columns)
    szCmd - the command, such as "repadmin" or "showrepl" for this CSV row (1st half of 1st column)
    szType - the type, such as "_ERROR" or "COLUMNS" or "INFO" for this CSV row (2nd half of 1st column)

Return Value:

    wide char count of buffer used.

--*/
{
    ULONG cchTemp;
    ULONG cchBufferUsed = 0;

    //
    // We straight copy the first field, because we don't need
    // the hard validation of CsvAppendField() and we don't want
    // a comma on the front of the string.
    //
    if ( ((wcslen(szCmd) + wcslen(szType) + 1) > cchBuffer) ||
         (NULL != wcschr(szCmd, L',')) ||
         (NULL != wcschr(szType, L'"'))) {
        Assert(!"This should never happen");
        szBuffer[0] = L'\0';
        return(0);
    }
    wcscpy(szBuffer, szCmd);
    wcscat(szBuffer, szType);
    cchTemp = wcslen(szBuffer);
    CHK_BUFFER_USED(return(0));
    cchBufferUsed += cchTemp;

    if (bDoSiteServer) {
        //
        // Now append site.
        //

        cchTemp = CsvAppendField(szBuffer + cchBufferUsed,
                                 cchBuffer - cchBufferUsed,  
                                 gCsvMode.szSite);
        CHK_BUFFER_USED(return(0));
        cchBufferUsed += cchTemp;

        //
        // Now append server.
        //
        cchTemp = CsvAppendField(szBuffer + cchBufferUsed,
                                 cchBuffer - cchBufferUsed,  
                                 gCsvMode.szServer);
        CHK_BUFFER_USED(return(0));
        cchBufferUsed += cchTemp;
    }

    return(cchBufferUsed);
}
    

DWORD
CsvEndRow(
    WCHAR *  szBuffer,
    DWORD    cchBuffer
    )
/*++

Routine Description:

    This correctly ends the CSV formatted row.

Arguments:

    szBuffer  - pointer to middle of a buffer for appending the CSV field.
    cchBuffer - wide char count of buffer left.

Return Value:

    wide char count of buffer used.

--*/
{

    if (cchBuffer < 2) {
        return(0);
    }

    szBuffer[0] = L'\n';
    szBuffer[1] = L'\0';
    return(2);
}


void 
PrintCsvCols(
    IN  enum eCsvCmd eCsvCmd,
    IN  WCHAR *      szBuffer,
    IN  ULONG        cchBuffer
    )
/*++

Routine Description:

    This prints the "_COLUMNS" row for a given command type.

Arguments:

    eCsvCmd   - the command for this columns row
    szBuffer  - pointer to a buffer to begin a fresh the CSV row
    cchBuffer - wide char count of buffer

Return Value:

    wide char count of buffer used.

--*/
{
    static WCHAR szTempField[128];
    ULONG cchTemp;
    ULONG cchBufferUsed = 0;
    ULONG i;
    
    //
    // Construct first field (such as "showrepl_COLUMNS" )
    //
    cchTemp = CsvBeginRow(szBuffer,
                          cchBuffer,     
                          FALSE,
                          gCsvCmds[eCsvCmd].szCsvCmd,
                          gszCsvTypeColumns);
    CHK_BUFFER_USED(return);
    cchBufferUsed = cchTemp;
    
    //
    // Print each of the column headings, note we pull these from the msg.mc
    // file so they can be localized.  The first column "repadmin_INFO" will
    // however not be localized.
    //
    // We start at 1, because the first column is taken care of by CsvBeginRow()
    for (i = 1; i < gCsvCmds[eCsvCmd].cCmdArgs; i++) {

        cchTemp = formatMsgHelp( 0,          // Width restriction, not used
                                 szTempField,
                                 ARRAY_SIZE( szTempField ) ,
                                 gCsvCmds[eCsvCmd].aCmdCols[i],
                                 NULL );
        CHK_BUFFER_USED(return);

        cchTemp = CsvAppendField(szBuffer + cchBufferUsed,
                                 cchBuffer - cchBufferUsed,  
                                 szTempField);
        CHK_BUFFER_USED(return);
        cchBufferUsed += cchTemp;
    }
    CsvEndRow(szBuffer + cchBufferUsed,
              cchBuffer - cchBufferUsed);
    
    wprintf(L"%ws", szBuffer);
    return;
}


void 
PrintCsv(
    IN  enum eCsvCmd eCsvCmd,
    IN  ...
    )

/*++

Routine Description:

    This prints out as many CSV strings as match the eCsvCmd specifier
    passed in.  gCsvCmds[eCsvCmds.cCmdArgs is how many strings this
    function expects.  Make sure you get it right, or :{

Arguments:

    eCsvCmd - The specifier for the number of string args.
    Args - Variable length argument list, if any

Return Value:

--*/

{
    static WCHAR s_szBuffer[4096];
    ULONG   i;
    va_list args;
    WCHAR * szTempArg;
    ULONG cchTemp;
    ULONG cchBufferUsed = 0;

    if (!bCsvMode()) {
        Assert(!"Huh, we're not in CSV mode, who's calling CSV output function?");
        return;
    }

    //
    // For a given output format, we print the columns on the first
    // print of a row of this output format.
    //
    if (!gCsvCmds[eCsvCmd].bPrintedCols) {
        PrintCsvCols(eCsvCmd, s_szBuffer, ARRAY_SIZE(s_szBuffer));
        gCsvCmds[eCsvCmd].bPrintedCols = TRUE;
    }

    //
    // Construct first 3 fields (such as "showrepl_INFO, Red-Bldg40, ntdev-dc-03" )
    //
    cchTemp = CsvBeginRow(s_szBuffer,
                          ARRAY_SIZE(s_szBuffer),     
                          TRUE,
                          gCsvCmds[eCsvCmd].szCsvCmd,
                          gszCsvTypeInfo);
    CHK_BUFFER_USED(return);
    cchBufferUsed += cchTemp;

    //
    // For each expected argument append a ",<FieldOfData>" to the 
    // output buffer. 
    //
    va_start(args, eCsvCmd);
    // We start at 3, because the first 3 columns are taken care of by CsvBeginRow()
    for (i = 3; i < gCsvCmds[eCsvCmd].cCmdArgs; i++) {

        szTempArg = va_arg(args, WCHAR *);
        cchTemp = CsvAppendField(s_szBuffer + cchBufferUsed,
                                 ARRAY_SIZE(s_szBuffer) - cchBufferUsed,  
                                 szTempArg);
        CHK_BUFFER_USED(return);
        cchBufferUsed += cchTemp;

    }

    //
    // Put the line return on it.  We could do this in the wprintf() 
    // below, but we want the whole buffer to write at once.
    //
    cchTemp  = CsvEndRow(s_szBuffer + cchBufferUsed,
                         ARRAY_SIZE(s_szBuffer) - cchBufferUsed);
    CHK_BUFFER_USED(return);

    //
    // Finally, output the buffer to the screen.
    //
    wprintf(L"%ws", s_szBuffer);

    va_end(args);

} /* PrintCsv */

void
PrintCsvErr(
    WCHAR * szMsgBuffer
    )

/*++

Routine Description:

    This function will print any buffer in the error column.  The format
    will be "repadmin_ERROR, site_if_available, server_if_available, errorMsg"
    or "showrepl_ERROR, site_if_available, server_if_available, errorMsg".

Arguments:

    szMsgBuffer - The error message to print CSV safe.

Return Value:

--*/

{
    static WCHAR s_szBuffer[4096];
    ULONG   i;
    ULONG cchTemp;
    ULONG cchBufferUsed = 0;

    if (!bCsvMode()) {
        Assert(!"Huh, we're not in CSV mode, who's calling CSV output function?");
        return;
    }

    //
    // Construct first 3 fields (such as "showrepl_ERROR, Red-Bldg40, ntdev-dc-03" )
    //
    cchTemp = CsvBeginRow(s_szBuffer,
                          ARRAY_SIZE(s_szBuffer),     
                          TRUE,
                          gCsvCmds[gCsvMode.eCsvCmd].szCsvCmd,
                          gszCsvTypeError);
    CHK_BUFFER_USED(return);
    cchBufferUsed = cchTemp;

    //
    // Now append in a CSV safe manner the large szMsgBuffer Error buffer
    //
    cchTemp = CsvAppendField(s_szBuffer + cchBufferUsed,
                             ARRAY_SIZE(s_szBuffer) - cchBufferUsed,  
                             szMsgBuffer);
    CHK_BUFFER_USED(return);
    cchBufferUsed += cchTemp;

    //
    // Put the line return on it.  We could do this in the wprintf() 
    // below, but we want the whole buffer to write at once.
    //
    cchTemp  = CsvEndRow(s_szBuffer + cchBufferUsed,
                         ARRAY_SIZE(s_szBuffer) - cchBufferUsed);
    CHK_BUFFER_USED(return);
    cchBufferUsed += cchTemp; // Not needed.

    //
    // Finally, output the buffer to the screen.
    //
    wprintf(L"%ws", s_szBuffer);

} /* PrintMsgInternal */


void
PrintMsgCsvErr(
    IN  DWORD        dwMessageCode,
    IN  ...
    )
/*++

Routine Description:

	This function can take a normal PrintMsg() and turn it into a 
    proper CSV print.  The error message will be printed to stderr
    regularly, and then printed again to stdout in a CSV mode safe
    manner, for redirection to a file.

Arguments:

    dwMessageCode - Message code
    Args - Variable length argument list, if any

Return Value:

--*/
{
    static WCHAR szMsgBuffer[4096];
    
    va_list args;

    va_start(args, dwMessageCode);
    
    if (bCsvMode()) {
        
        formatMsgHelp( 0,          // Width restriction, not used
                       szMsgBuffer,
                       ARRAY_SIZE( szMsgBuffer ),
                       dwMessageCode,
                       &args );

        fwprintf(stderr, L"%ws", szMsgBuffer);

        PrintCsvErr(szMsgBuffer);

    } else {

        PrintMsgInternal(stdout, dwMessageCode, NULL, &args );

    }

    va_end(args);
}

void
PrintString(
    IN  WCHAR * szString
    )
/*++

Routine Description:

	Needed function so we can just send long strings straight to the
    screen.

Arguments:

    szString - string to print

--*/
{
    fwprintf(stdout, L"%ws", szString);
}
void
PrintMsg(
    IN  DWORD   dwMessageCode,
    IN  ...
    )
/*++

Routine Description:

	Wrapper for PrintMsgInternal, doesn't add tabs.

Arguments:

    dwMessageCode - Message code
    Args - Variable length argument list, if any

Return Value:

--*/
{
    va_list args;

    va_start(args, dwMessageCode);
    
    PrintMsgInternal(stdout, dwMessageCode, NULL, &args );

    va_end(args);
}

void
PrintToErr(
    IN  DWORD   dwMessageCode,
    IN  ...
    )
/*++

Routine Description:

	Wrapper for PrintMsgInternal, doesn't add tabs, BUT does
    print out to stderr instead of stdout.  This should be used
    for printing "past" a shell output redirect (such as for 
    the "Password:" prompt or for not corrupting the CSV output
    mode).

Arguments:

    dwMessageCode - Message code
    Args - Variable length argument list, if any

Return Value:

--*/
{
    va_list args;

    va_start(args, dwMessageCode);

    PrintMsgInternal(stderr, dwMessageCode, NULL, &args );

    va_end(args);
}

void
PrintTabMsg(
    IN  DWORD   dwTabs,
    IN  DWORD   dwMessageCode,
    IN  ...
    )

/*++

Routine Description:

    Wrapper around PrintMsgInternal() to proceed the message printed with
    a certain number of tabs.

Arguments:

    dwTabs - Number of tabs, tab size is 2, often used in multiples of 2 for
	tab spaces of 4.
    dwMessageCode - Message code
    Args - Variable length argument list, if any

Return Value:

--*/

{
    va_list args;
    static WCHAR s_szSpaces[] = L"                                                                                               ";
    ULONG  cNumSpaces;
    ULONG  iSpace;

    cNumSpaces = dwTabs * 2;
    Assert( cNumSpaces < ARRAY_SIZE(s_szSpaces) );
    iSpace = ARRAY_SIZE(s_szSpaces) - cNumSpaces - 1;
    
    va_start(args, dwMessageCode);

    PrintMsgInternal(stdout, dwMessageCode, &s_szSpaces[iSpace], &args );

    va_end(args);

} /* PrintMsg */


INT
MemWtoi(WCHAR *pb, ULONG cch)
/*++

Routine Description:

    This function will take a string and a length of numbers to convert.

Parameters:
    pb - [Supplies] The string to convert.
    cch - [Supplies] How many characters to convert.

Return Value:

    The value of the integers.

  --*/
{
    int res = 0;
    int fNeg = FALSE;

    if (*pb == L'-') {
        fNeg = TRUE;
        pb++;
    }


    while (cch--) {
        res *= 10;
        res += *pb - L'0';
        pb++;
    }
    return (fNeg ? -res : res);
}

DWORD
GeneralizedTimeToSystemTime(
    LPWSTR IN                   szTime,
    PSYSTEMTIME OUT             psysTime)
/*++

Routine Description:

    Converts a generalized time string to the equivalent system time.

Parameters:
    szTime - [Supplies] This is string containing generalized time.
    psysTime - [Returns] This is teh SYSTEMTIME struct to be returned.

Return Value:

    Win 32 Error code, note could only result from invalid parameter.

  --*/
{
   DWORD       status = ERROR_SUCCESS;
   ULONG       cch;
   ULONG       len;

    //
    // param sanity
    //
    if (!szTime || !psysTime)
    {
       return STATUS_INVALID_PARAMETER;
    }

    len = wcslen(szTime);

    if( len < 15 || szTime[14] != '.')
    {
       return STATUS_INVALID_PARAMETER;
    }

    // initialize
    memset(psysTime, 0, sizeof(SYSTEMTIME));

    // Set up and convert all time fields

    // year field
    cch=4;
    psysTime->wYear = (USHORT)MemWtoi(szTime, cch) ;
    szTime += cch;
    // month field
    psysTime->wMonth = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // day of month field
    psysTime->wDay = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // hours
    psysTime->wHour = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // minutes
    psysTime->wMinute = (USHORT)MemWtoi(szTime, (cch=2));
    szTime += cch;

    // seconds
    psysTime->wSecond = (USHORT)MemWtoi(szTime, (cch=2));

    return status;

}

void
InitDSNameFromStringDn(
    LPWSTR pszDn,
    PDSNAME pDSName
    )
/*
 Initialize a preallocated, maximally sized DSNAME.
 */
{
    memset( pDSName, 0, sizeof( DSNAME ) );
    pDSName->NameLen = wcslen( pszDn );
    pDSName->structLen = DSNameSizeFromLen( pDSName->NameLen );
    wcscpy( pDSName->StringName, pszDn );
}

DWORD
CountNamePartsStringDn(
    LPWSTR pszDn
    )
{
    DWORD count = 0;
    PDSNAME pDSName;

    // alloc dsname buff temporarily
    pDSName = malloc( DSNameSizeFromLen( wcslen( pszDn ) ) );
    if (!pDSName) {
        return 0;
    }

    // fill in dsname
    InitDSNameFromStringDn( pszDn, pDSName );

    // count parts
    if (CountNameParts( pDSName, &count )) {
        count = 0; // error occurred
    }

    // free allocated name
    Assert(pDSName != NULL);
    free(pDSName);

    return count;
}

DWORD
WrappedTrimDSNameBy(
           IN  WCHAR *                          InString,
           IN  DWORD                            NumbertoCut,
           OUT WCHAR **                         OutString
           )
/*++

Routine Description:

    This Function is wrapping TrimDSNameBy to hanndle the
    DSNAME struct.  Usage is the same as TrimDSNameBy except
    that you send WCHAR instead of DSNAME.

    Callers: make sure that you send InString as a DN
             make sure to free OutString when done

Arguments:

    InString - A WCHAR that is a DN that we need to trim
    NumbertoCut - The number of parts to take off the front of the DN
    OutString - The Machine Reference in DN form

Return Value:

    A WinError is return to indicate if there were any problems.

--*/

{
    ULONG  Size;
    DSNAME *src, *dst, *QuotedSite;
    DWORD  WinErr=NO_ERROR;

    if ( *InString == L'\0' )
    {
        *OutString=NULL;
        return ERROR_INVALID_PARAMETER;
    }

    Size = (ULONG)DSNameSizeFromLen( wcslen(InString) );

    src = alloca(Size);
    RtlZeroMemory(src, Size);
    src->structLen = Size;

    dst = alloca(Size);
    RtlZeroMemory(dst, Size);
    dst->structLen = Size;

    src->NameLen = wcslen(InString);
    wcscpy(src->StringName, InString);

    WinErr = TrimDSNameBy(src, NumbertoCut, dst);
    if ( WinErr != NO_ERROR )
    {
        *OutString=NULL;
        return WinErr;
    }

    *OutString = malloc((dst->NameLen+1)*sizeof(WCHAR));
    if (NULL == *OutString) {
        return ERROR_OUTOFMEMORY;
    }

    wcscpy(*OutString,dst->StringName);

    return NO_ERROR;


}


/*++ ParseInput
 *
 * Description:
 *    This function takes an input string, a delimiter and an index value
 *    and returns a pointer to a substring.  The index value
 *    describes which string to return.  For example:
 *    
 *    	"gregjohndomain" == ParseInput("gregjohndomain.nttest.microsoft.com", '.', 0);
 *    	"nttest" == ParseInput("gregjohndomain.nttest.microsoft.com", '.', 1)
 *    	NULL == ParseInput("gregjohndomain.nttest.microsoft.com", '.', 4) 
 *	"ain.nttest." = ParseInput("gregjohndomain.nttest.microsoft.com", 'm', 1)
 *
 * Arguments:
 *    
 *    pszInput - the string to parse
 *    chDelim  - the delimiter to parse with
 *    dwInputIndex - the index of the item to parse
 * 
 * Return Value:
 *    a pointer to the requested index within pszInput (malloc'ed), NULL if not found
 */
LPWSTR
ParseInputW(
    LPWSTR pszInput,
    WCHAR wcDelim,
    DWORD dwInputIndex
    )
{
    DWORD i = 0;
    LPWSTR pszOutputBegin = pszInput;
    LPWSTR pszOutputEnd = NULL;
    LPWSTR pszOutput = NULL;
    ULONG cchOutput = 0;

    for (i=0; (i<dwInputIndex) && (pszOutputBegin!=NULL); i++) {
        pszOutputBegin = wcschr(pszOutputBegin,wcDelim);
        if (pszOutputBegin) {
            pszOutputBegin++;
        }
    }
    if (pszOutputBegin==NULL) {
        return NULL;
    }

    pszOutputEnd = wcschr(pszOutputBegin,wcDelim);
    cchOutput = pszOutputEnd ? (ULONG) (pszOutputEnd-pszOutputBegin) : (wcslen(pszOutputBegin));
    pszOutput = malloc((cchOutput+1)*sizeof(WCHAR));
    if (pszOutput==NULL) {
	PrintMsg(REPADMIN_GENERAL_NO_MEMORY);
        return NULL;
    }

    memcpy(pszOutput, pszOutputBegin, cchOutput*sizeof(WCHAR));
    pszOutput[cchOutput] = L'\0';

    return pszOutput;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\reptool-collector\global.h ===
#define _WIN32_DCOM\

// BAS_TODO remove this, define in sources
#define UNICODE

								//should be equal to 2 weeks / injeciton period
#include <windows.h>
#include <windowsx.h>
#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <hlink.h>
#include <dispex.h>
#include <msxml.h>
#include <winnls.h>
#include <urlmon.h>
#include <windows.h>
#include <msxml.h>
#include <msxml2.h>
#include <COMDEF.H>  //_variant_t
#include <objbase.h>

#include <Rpc.h>
#include <Rpcdce.h>
#include <Ntdsapi.h>
#include <Dsgetdc.h>

#include <malloc.h>
#include <lm.h>


#include <stdlib.h>
#include <stdio.h>

#include <Winnetwk.h>
#include <Iads.h>
#include <Adshlp.h>
#include <activeds.h>

#include <FwCommon.h>

#include <Wbemcli.h>
#include <comdef.h>
#include <comutil.h>

#include <Winerror.h>
#include <Lmerr.h>

// Local reptoolc utilities
#include "utils.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\reptool-collector\adrepl-latency.cpp ===
#include "global.h"


static TimeCube arrivalTime;
static TimeCube currentLag;


//the following two functions enumerate all pairs of
// (DC,NC) where NC is of a given type (e.g. a Read-Write naming context)
// other than schema stored at the DC

HRESULT enumarateDCandNCpairsInit(IXMLDOMDocument* pXMLDoc, int* state, long* totalDNSs, long* totalNCs)
// invoke this function first
{
	HRESULT hr;

	*state = 0;


	if( pXMLDoc == NULL )
		return S_FALSE;


	//get the root element of the XML
	IXMLDOMElement* pRootElem;
	hr = pXMLDoc->get_documentElement(&pRootElem);
	if( hr != S_OK )
		return S_FALSE;


	//get the total number of DCs and naming contexts in the forest
	BSTR totalNCsText,totalDCsText;
	hr = getTextOfChild(pRootElem,L"totalNCs",&totalNCsText);
	if( hr != S_OK ) {
		printf("getTextOfChild failed\n");
		return S_FALSE;
	};
	*totalNCs = _wtol(totalNCsText);
	hr = getTextOfChild(pRootElem,L"totalDCs",&totalDCsText);
	if( hr != S_OK ) {
		printf("getTextOfChild failed\n");
		return S_FALSE;
	};
	*totalDNSs = _wtol(totalDCsText);

	return S_OK;
}

HRESULT enumarateDCandNCpairsNext(IXMLDOMDocument* pXMLDoc, int* state, BSTR type, BSTR* dnsName, BSTR* ncName, long* dnsID, long* ncID, long* ncType, IXMLDOMElement** ppDCElem, IXMLDOMElement** ppNCElem)
// then repeatedly call this function until
// it returns something other than S_OK
{
	static WCHAR xpath[TOOL_MAX_NAME];
	static HRESULT hr;

	if( *state==1 )
		goto RESUME_HERE;

	if( pXMLDoc == NULL )
		return S_FALSE;


	//get the root element of the XML
	static IXMLDOMElement* pRootElem;
	hr = pXMLDoc->get_documentElement(&pRootElem);
	if( hr != S_OK )
		return S_FALSE;


	//we will query for NCs of a given type, construct an xpath representing them
	wcscpy(xpath,L"");
	wcsncat(xpath,L"partitions/partition",TOOL_MAX_NAME-wcslen(xpath)-1);
	wcsncat(xpath,type,TOOL_MAX_NAME-wcslen(xpath)-1);
	wcsncat(xpath,L"/nCName",TOOL_MAX_NAME-wcslen(xpath)-1);
//printf("%S\n",xpath);

	
	//find the name of the schema partition
	//we will not inject changes into this partition
	static IXMLDOMNode *pSchemaNode;
	static BSTR schemaName;
	hr = findUniqueNode(pRootElem,L"partitions/partition[@type=\"schema\"]",&pSchemaNode);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		return S_FALSE;
	};
	hr = getTextOfChild(pSchemaNode,L"nCName",&schemaName);
	if( hr != S_OK ) {
		printf("getTextOfChild failed\n");
		return S_FALSE;
	};
//printf("%S\n",schemaName);


	//enumerate all domain controllers
	static IXMLDOMNodeList *resultDCList;
	hr = createEnumeration(pRootElem,L"sites/site/DC",&resultDCList);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		return S_FALSE;
	};

	
	//loop through all DCs
	static IXMLDOMNode *pDCNode;
	while( true ){
		hr = resultDCList->nextNode(&pDCNode);
		if( hr != S_OK || pDCNode == NULL ) break; // iterations across DCs have finished


		//the query actually retrives elements not nodes (elements inherit from nodes)
		//so get site element
		hr=pDCNode->QueryInterface(IID_IXMLDOMElement,(void**)ppDCElem );
		if( hr != S_OK ) {
			printf("QueryInterface failed\n");
			continue;	// skip this site
		};


		//find the DNS Name of the DC and the identifier of its DNS name
//		static BSTR dnsName;
		hr = getTextOfChild(pDCNode,L"dNSHostName",dnsName);
		if( hr != S_OK ) {
			printf("getTextOfChild failed\n");
			continue;
		}
//printf("%S\n",*dnsName);
		hr = getAttrOfChild(pDCNode,L"dNSHostName",L"_id",dnsID);
//printf("%ld\n",*dnsID);


		//enumerate all naming contexts stored at the DC that satisfy the xpath
		static IXMLDOMNodeList *resultRWList;
		hr = createEnumeration(pDCNode,xpath,&resultRWList);
		if( hr != S_OK ) {
			printf("createEnumeration failed\n");
			continue;
		}


		//loop through all naming contexts
		static IXMLDOMNode *pNCNode;
		while( true ){
			hr = resultRWList->nextNode(&pNCNode);
			if( hr != S_OK || pNCNode == NULL ) break; // iterations across DCs have finished

		
			//the query actually retrives elements not nodes (elements inherit from nodes)
			//so get site element
			hr=pNCNode->QueryInterface(IID_IXMLDOMElement,(void**)ppNCElem );
			if( hr != S_OK ) {
				printf("QueryInterface failed\n");
				continue;	// skip this site
			};


			//find the name of the naming context
			hr = getTextOfNode(pNCNode,ncName);
			if( hr != S_OK ) {
				printf("getTextOfNode failed\n");
				continue;
			};
//printf("  %S\n",*ncName);
			hr = getAttrOfNode(pNCNode,L"_id",ncID);
			if( hr != S_OK ) {
				printf("getAttrOfNode failed\n");
				continue;
			};
//printf("%ld\n",*ncID);
			//find the type of the naming context
			IXMLDOMNode* pPartNode;
			hr = pNCNode->get_parentNode(&pPartNode);
			if( hr != S_OK ) {
				printf("get_parentNode failed\n");
				continue;
			};
			hr = getTypeOfNCNode(pPartNode,ncType);
			if( hr != S_OK ) {
				printf("getTypeOfNCNode failed\n");
				continue;
			};


			//do not inject into schema partition (we would like to do it but I do not know how)
			//configuration partition has forest reach so we
			//can detect lack of global replicaiton
			//so it does not seem to be a problem 
			//that we do not inject into schema
			if( wcscmp(*ncName,schemaName) == 0 )
				continue;

			*state = 1;
			return S_OK;
	
RESUME_HERE:
			;
		
		};
		resultRWList->Release();
	};
	resultDCList->Release();

	
	return S_FALSE ;
}



void itFree(IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd )
{
	departureTimeFree();
	timeCubeFree(&arrivalTime);
	timeCubeFree(&currentLag);

	//we can also delete AD objects in _ratTool_
}



HRESULT itInit(IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd )
// Initializes the injection process.
// For each DC and each Read-Write naming context the DC stores
// exept for schema NC the function inserts a container _ratTool_
// and inside of this container another container
// with name equal to the DNS name of the DC
// such containers may already exist.
// Prior to this the function inserts <replicationLag> element inside each <DC>
// element of the XML document
//
// Returns S_OK iff succesful (failure means a serious problem). Network problems DO NOT
// cause the function to fail. If the function is unable to create containers at a remote machine,
// it logs failures as attributes of <replicationLag> element). The <replicationLag> elements
// from previous run of itInit() are removed, so hresult does not carry over from one run to
// the next unless causes persist.
//
// EXAMPLE of what is inserted into <DC> elements. The first <replicationLag> element means that
// _ratTool_ and the other containers have been inserted succesfuly, The second is generated
// when one of the insertions fail and shows what the hresult of the error was and when it 
// was generated.
/*
	<DC cn="ntdev-dc-01">
		...
		<replicationLag>
		</replicationLag>
		...
	</DC>

	<DC cn="ntdev-dc-02">
		...
		<replicationLag>
			<injectionInitError timestamp="20011212073319.000627+000" hresult="2121">
		</replicationLag>
		...
	</DC>
*/
{
	HRESULT hr,hr1,hr2,retHR;
	long dnsID, ncID,ncType;
	long totalDNSs, totalNCs;
	BSTR dnsName, ncName;
	int state;
	WCHAR objectpath[TOOL_MAX_NAME];
	WCHAR dnsobjectpath[TOOL_MAX_NAME];
	WCHAR userpath[TOOL_MAX_NAME];
	ADSVALUE   classValue;
	LPDISPATCH pDisp;
	ADS_ATTR_INFO  attrInfoContainer[] = 
	{  
		{	L"objectClass", ADS_ATTR_UPDATE, 
			ADSTYPE_CASE_IGNORE_STRING, &classValue, 1 },
	};
	classValue.dwType = ADSTYPE_CASE_IGNORE_STRING;
	classValue.CaseIgnoreString = L"container";

	

	if( pXMLDoc == NULL )
		return S_FALSE;


	//remove all <replicationLag> nodes from the pXMLDoc document (so that their childeren perish, too)
	hr = removeNodes(pXMLDoc,L"sites/site/DC/replicationLag");
	if( hr != S_OK ) {
		printf("removeNodes failed\n");
		return S_FALSE;
	};


	//insert new <replicationLag> element for each DC node
	IXMLDOMNodeList *resultDCList=NULL;
	IXMLDOMElement* pRLElem;
	hr = createEnumeration( pXMLDoc, L"sites/site/DC", &resultDCList);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		return S_FALSE;
	};
	//loop through all DCs
	IXMLDOMNode *pDCNode;
	while( true ){
		hr = resultDCList->nextNode(&pDCNode);
		if( hr != S_OK || pDCNode == NULL ) break; // iterations across DCs have finished
			//<replicationLag> node does not exist
			hr = addElement(pXMLDoc,pDCNode,L"replicationLag",L"",&pRLElem);
			if( hr != S_OK ) {
				printf("addElement falied\n");
				resultDCList->Release();
				return S_FALSE;
			};
	};
	resultDCList->Release();


	wcscpy(userpath,L"");
	wcsncat(userpath,domain,TOOL_MAX_NAME-wcslen(userpath)-1);
	wcsncat(userpath,L"\\",TOOL_MAX_NAME-wcslen(userpath)-1);
	wcsncat(userpath,username,TOOL_MAX_NAME-wcslen(userpath)-1);


	//enumerate only Read-Write namin contexts
	hr = enumarateDCandNCpairsInit(pXMLDoc, &state,&totalDNSs,&totalNCs);
	if( hr != S_OK ) {
		printf("enumarateDCandNCpairsInit failed\n");
		itFree(pXMLDoc,username,domain,passwd);
		return S_FALSE;
	};

	
	//allocate the injection history table for all DCs and NCs
	hr = departureTimeInit(totalDNSs,totalNCs);
	if( hr != S_OK ) {
		printf("CyclicBufferTableInit failed\n");
		itFree(pXMLDoc,username,domain,passwd);
		return S_FALSE;
	};
	hr1 = timeCubeInit(&arrivalTime,totalDNSs,totalNCs);
	hr2 = timeCubeInit(&currentLag,totalDNSs,totalNCs);
	if( hr1 != S_OK || hr2 != S_OK ) {
		printf("timeCubeInit failed\n");
		itFree(pXMLDoc,username,domain,passwd);
		return S_FALSE;
	};
	
	
	//loop through the enumeration (only Read-Write NCs)
	IXMLDOMElement* pDCElem;
	IXMLDOMElement* pNCElem;
	IDirectoryObject* pDObj = NULL;
	retHR = S_OK;
	while( true ) {
		hr = enumarateDCandNCpairsNext(pXMLDoc,&state,L"[@ type=\"rw\"]",&dnsName,&ncName,&dnsID,&ncID,&ncType,&pDCElem,&pNCElem);
		if( hr != S_OK ) break;
//printf("---\n%ld %S\n%ld %S\n",dnsID,dnsName,ncID,ncName);


		//find the <replicationLag> node inside the <DC> node
		hr = findUniqueElem(pDCElem,L"replicationLag",&pRLElem);
		if( hr != S_OK ) {
			printf("findUniqueElem failed\n");
			retHR = S_FALSE;  //this is a serious problem, exit the function with an error
			break;
		};


		//build a string representing the naming context at the server given by the DNS name
		wcscpy(objectpath,L"");
		wcsncat(objectpath,L"LDAP://",TOOL_MAX_NAME-wcslen(objectpath)-1);
		wcsncat(objectpath,dnsName,TOOL_MAX_NAME-wcslen(objectpath)-1);
		wcsncat(objectpath,L"/",TOOL_MAX_NAME-wcslen(objectpath)-1);
		wcsncat(objectpath,ncName,TOOL_MAX_NAME-wcslen(objectpath)-1);

//printf("%S\n",objectpath);

		//open a connection to the AD object (given by the DNS name) and using provided credentials
		if( pDObj != NULL ) { //release previously bound object
			pDObj->Release();
			pDObj = NULL;
		};
//************************   NETWORK PROBLEMS
		hr = ADsOpenObject(objectpath,userpath,passwd,ADS_SECURE_AUTHENTICATION,IID_IDirectoryObject, (void **)&pDObj);
//************************
		if( hr!=S_OK ) {
//printf("ADsGetObject failed\n");
			//record the failure in a <retrievalError> node (if it already exists, do not create it)
			IXMLDOMElement* pIInitErrElem;
			hr1 = findUniqueElem(pRLElem,L"injectionInitError",&pIInitErrElem);
			if( hr1!=E_UNEXPECTED && hr1!=S_OK ) {
				printf("findUniqueElem failed");
				retHR = S_FALSE;
				continue;
			};
			if( hr1 == E_UNEXPECTED ) { //<retrievalError> node did not exist => create it
				hr1 = addElement(pXMLDoc,pRLElem,L"injectionInitError",L"",&pIInitErrElem);
				if( hr1 != S_OK ) {
					printf("addElement failed");
					retHR = S_FALSE;
					continue;
				};
			};
			setHRESULT(pIInitErrElem,hr);
			continue;
		};  


		//create a _ratTool container under the root of the naming context
//************************   NETWORK PROBLEMS
		hr = pDObj->CreateDSObject( L"CN=_ratTool_",  attrInfoContainer, 1, &pDisp );
//************************
		if( hr != 0x80071392L && hr != S_OK ) {
			// object did not exist and we failed to create it
//printf("CreateDSObject failed");
			IXMLDOMElement* pIInitErrElem;
			hr1 = findUniqueElem(pRLElem,L"injectionInitError",&pIInitErrElem);
			if( hr1!=E_UNEXPECTED && hr1!=S_OK ) {
				printf("findUniqueElem failed");
				retHR = S_FALSE;
				continue;
			};
			if( hr1 == E_UNEXPECTED ) { //<retrievalError> node did not exist => create it
				hr1 = addElement(pXMLDoc,pRLElem,L"injectionInitError",L"",&pIInitErrElem);
				if( hr1 != S_OK ) {
					printf("addElement failed");
					retHR = S_FALSE;
					continue;
				};
			};
			setHRESULT(pIInitErrElem,hr);
			continue;
		};

	
		//create another container inside the _ratTool_ container
		wcscpy(dnsobjectpath,L"");
		wcsncat(dnsobjectpath,L"CN=",TOOL_MAX_NAME-wcslen(dnsobjectpath)-1);
		wcsncat(dnsobjectpath,dnsName,TOOL_MAX_NAME-wcslen(dnsobjectpath)-1);
		wcsncat(dnsobjectpath,L",CN=_ratTool_",TOOL_MAX_NAME-wcslen(dnsobjectpath)-1);
//printf("%S\n",dnsobjectpath);
//************************   NETWORK PROBLEMS
		hr = pDObj->CreateDSObject( dnsobjectpath,  attrInfoContainer, 1, &pDisp );
//************************
		if( hr != 0x80071392L && hr != S_OK ) {
			// object did not exist and we failed to create it
//printf("CreateDSObject failed");
			IXMLDOMElement* pIInitErrElem;
			hr1 = findUniqueElem(pRLElem,L"injectionInitError",&pIInitErrElem);
			if( hr1!=E_UNEXPECTED && hr1!=S_OK ) {
				printf("findUniqueElem failed");
				retHR = S_FALSE;
				continue;
			};
			if( hr1 == E_UNEXPECTED ) { //<retrievalError> node did not exist => create it
				hr1 = addElement(pXMLDoc,pRLElem,L"injectionInitError",L"",&pIInitErrElem);
				if( hr1 != S_OK ) {
					printf("addElement failed");
					retHR = S_FALSE;
					continue;
				};
			};
			setHRESULT(pIInitErrElem,hr);
			continue;
		};

	};


	 //release previously bound object
	if( pDObj != NULL ) {
		pDObj->Release();
		pDObj = NULL;
	};

	
//timeCubePrint(&arrivalTime);	

	return retHR;
}







HRESULT itInject(IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd )
// This function injects changes to certian Active Directory objects.
// For each DC and each Read-Write naming context it stores
// exept for schema NC the function finds a container _ratTool_
// and inside of this container a container X
// with name equal to the DNS name of the DC.
// Then it sets the value of the "description"
// attribute of the container X to the current time (this value is
// then supposed to be propagated to other DCs that
// store RW or R replica of the naming context -
// this is because the "description" attribute has
// the flag isMemberOfPartialAttributeSet set to True
// and so it is replicated to Global Catalogs).
// The function does not report in the XML network problems directly.
// Instead it writes, for each DC and each NC when the latest succesful injection
// occured. If the diference between current system time and this time is large,
// say more than 1 day, then it means that the injection procedure cannot evaluate
// replication lag from this DC and for this NC - which is an alert that customer
// should be aware of because we cannot accurately eveluate replication lag.
// (we do not report duration because if we fail to run itInject() then duration
// will become out of date).
//
// Returns S_OK iff succesful (failure means a serious problem). Network problems DO NOT
// cause the function to fail. If the function is unable to inject packets into a remote machine
// or the function is not invoked, then the time of <latestInjectionSuccess> will become more
// distant from the current system time. The <latestInjectionSuccess> elements from previous run
// of itInject() are removed.
//
// EXAMPLE of what is inserted into the <replicationLag> elements
//
/*
	<DC>
		<replicationLag>
			...
			<latestInjectionSuccess nCName="DC=ntdev,DC=microsoft,DC=com">
				20011117034932000000+000
			</latestInjectionSuccess>
			...
		</replicationLag>
	</DC>
*/
{
	HRESULT hr,retHR;
	long dnsID, ncID,ncType;
	long totalDNSs, totalNCs;
	BSTR dnsName, ncName;
	int state;
	WCHAR objectpath[TOOL_MAX_NAME];
	WCHAR userpath[TOOL_MAX_NAME];
	WCHAR time[TOOL_MAX_NAME];
	WCHAR injection[TOOL_MAX_NAME];
	WCHAR dnsIDtext[TOOL_MAX_NAME];
	ADSVALUE   descriptionValue;
	ADS_ATTR_INFO  attrInfoDescription[] = 
		{  
		   {	L"description", ADS_ATTR_UPDATE, 
				ADSTYPE_CASE_IGNORE_STRING, &descriptionValue, 1},
		};


	if( pXMLDoc == NULL )
		return S_FALSE;


	wcscpy(userpath,L"");
	wcsncat(userpath,domain,TOOL_MAX_NAME-wcslen(userpath)-1);
	wcsncat(userpath,L"\\",TOOL_MAX_NAME-wcslen(userpath)-1);
	wcsncat(userpath,username,TOOL_MAX_NAME-wcslen(userpath)-1);


	//loop through all pairs of (DC,NC) for Read-Write NC only
	hr = enumarateDCandNCpairsInit(pXMLDoc, &state,&totalDNSs,&totalNCs);
	if( hr != S_OK ) {
		printf("enumarateDCandNCpairsInit failed\n");
		return S_FALSE;
	};
	IXMLDOMElement* pDCElem;
	IXMLDOMElement* pNCElem;
	IDirectoryObject* pDObj = NULL;
	retHR = S_OK;
	while( true ) {
		hr = enumarateDCandNCpairsNext(pXMLDoc,&state,L"[@ type=\"rw\"]",&dnsName,&ncName,&dnsID,&ncID,&ncType,&pDCElem,&pNCElem);
		if( hr != S_OK ) break;
//printf("---\n%ld %S\n%ld %S\n",dnsID,dnsName,ncID,ncName);


		//build a string representing the naming context
		//of the container to which changes will be injected
		wcscpy(objectpath,L"");
		wcsncat(objectpath,L"LDAP://",TOOL_MAX_NAME-wcslen(objectpath)-1);
		wcsncat(objectpath,dnsName,TOOL_MAX_NAME-wcslen(objectpath)-1);
		wcsncat(objectpath,L"/",TOOL_MAX_NAME-wcslen(objectpath)-1);
		wcsncat(objectpath,L"CN=",TOOL_MAX_NAME-wcslen(objectpath)-1);
		wcsncat(objectpath,dnsName,TOOL_MAX_NAME-wcslen(objectpath)-1);
		wcsncat(objectpath,L",CN=_ratTool_,",TOOL_MAX_NAME-wcslen(objectpath)-1);
		wcsncat(objectpath,ncName,TOOL_MAX_NAME-wcslen(objectpath)-1);


//printf("%S\n",objectpath);


		//open a connection to the AD object (given by the DNS name) and using provided credentials
		if( pDObj != NULL ) { //release previously bound object
			pDObj->Release();
			pDObj = NULL;
		};
//************************   NETWORK PROBLEMS
		hr = ADsOpenObject(objectpath,userpath,passwd,ADS_SECURE_AUTHENTICATION,IID_IDirectoryObject, (void **)&pDObj);
//************************
		if( hr!=S_OK ) {
//			printf("ADsGetObject failed\n");  //ignore network problems 
			continue;
		};  


		//create a string that represents current UTC time
		//proceeded with the dnsID of the DC that
		//injects the string (will be easier to analyze)
		FILETIME currentUTCTime;
		GetSystemTimeAsFileTime( &currentUTCTime );
		ULARGE_INTEGER x;
		x.LowPart = currentUTCTime.dwLowDateTime;
		x.HighPart = currentUTCTime.dwHighDateTime;
		LONGLONG z = x.QuadPart;
		_ui64tow(z,time,10);
		_ltow(dnsID,dnsIDtext,10);
		wcscpy(injection,L"");
		wcsncat(injection,L"V1,",TOOL_MAX_NAME-wcslen(injection)-1);
		wcsncat(injection,dnsIDtext,TOOL_MAX_NAME-wcslen(injection)-1);
		wcsncat(injection,L",",TOOL_MAX_NAME-wcslen(injection)-1);
		wcsncat(injection,time,TOOL_MAX_NAME-wcslen(injection)-1);
//printf("%S\n",injection);


		//set the value of the "description" attribute to this string
		descriptionValue.dwType=ADSTYPE_CASE_IGNORE_STRING;
		descriptionValue.CaseIgnoreString = injection;
		DWORD numMod;
//************************   NETWORK PROBLEMS
		hr = pDObj->SetObjectAttributes(attrInfoDescription,1,&numMod);
//************************
		if( hr != S_OK ) {
			// object did not exist and we failed to create it
//printf("SetObjectAttributes failed");   //ignore network problems 
			continue;
		};


		//since injection was succesful, mark it in the injection history table
		CyclicBuffer* pCB;
		pCB = departureTimeGetCB(dnsID,ncID);
		if( pCB == NULL ) {
			printf("CyclicBufferTableGetCB failed");
			retHR = S_FALSE;
			continue;
		};
//printf("dns %ld ,  nc %ld\n",dnsID,ncID);
		cyclicBufferInsert(pCB,z);


		//also if this was the first injection then mark when it occured
		if( pCB->firstInjection == 0 )
			pCB->firstInjection = z;

		
	};

	
	//release previously bound object
	if( pDObj != NULL ) { 
		pDObj->Release();
		pDObj = NULL;
	};



	//produce <latestInjectionSuccess> elements for each DC and each NC it stores

	
	//remove old <latestInjectionSuccess> elements
	hr = removeNodes(pXMLDoc,L"sites/site/DC/replicationLag/latestInjectionSuccess");
	if( hr != S_OK ) {
		printf("removeNodes failed\n");
		return S_FALSE;
	};

	
	//in the loop below we create new <latestInjectionSuccess> elements that reflect most recent injections
	hr = enumarateDCandNCpairsInit(pXMLDoc, &state,&totalDNSs,&totalNCs);
	if( hr != S_OK ) {
		printf("enumarateDCandNCpairsInit failed\n");
		return S_FALSE;
	};
	IXMLDOMElement* pRLElem;
	VARIANT varValue;
	while( true ) {
		hr = enumarateDCandNCpairsNext(pXMLDoc,&state,L"[@ type=\"rw\"]",&dnsName,&ncName,&dnsID,&ncID,&ncType,&pDCElem,&pNCElem);
		if( hr != S_OK ) break;
//printf("---\n%ld %S\n%ld %S\n",dnsID,dnsName,ncID,ncName);
		

		//find the <replicationLag> element inside the pDCElem <DC> element
		hr = findUniqueElem(pDCElem,L"replicationLag",&pRLElem);
		if( hr != S_OK ) {
			printf("findUniqueElem failed\n");
			retHR = S_FALSE; //some seriuos problem
			continue;
		};


		//find the time of latest succesful injection (if none, then say "NO")
		CyclicBuffer* pCB;
		pCB = departureTimeGetCB(dnsID,ncID);
		if( pCB == NULL ) {
			printf("CyclicBufferTableGetCB failed");
			retHR = S_FALSE;
			continue;
		};
//printf("dns %ld ,  nc %ld\n",dnsID,ncID);
		LONGLONG successTime;
		cyclicBufferFindLatest(pCB,&successTime);


		//convert this time to CIM string (if the time is equal to 0, then there has been no injections)
		BSTR stime;
		if( successTime == 0 )
			stime = SysAllocString(L"NO");
		else
			stime = UTCFileTimeToCIM(successTime); //it also allocates a string


//printf("%S\n",stime);


		//insert <latestInjectionSuccess> element under the <replicationLag> element
		IXMLDOMElement* pLSElem;
		hr = addElement(pXMLDoc,pRLElem,L"latestInjectionSuccess",stime,&pLSElem);
		SysFreeString(stime);  //free the string
		if( hr != S_OK ) {
			printf("addElement failed\n");
			continue;
		};


		//set the naming context as an attribute of <latestInjectionSuccess> element
		varValue.vt = VT_BSTR;
		varValue.bstrVal = ncName;
		hr = pLSElem->setAttribute(L"nCName", varValue);
		if( hr != S_OK ) {
			printf("setAttribute failed\n");
			continue; //some problems => skip this DC
		};


	};


//	departureTimePrint();
	return retHR;
}




HRESULT itAnalyze(IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd )
//ALGORITHM for calculating current propagation lag between a source and a destination for a naming context.
//It is used to analyze the observations on how injected packets propagate across the forest.
//
// Definition
//		The current replication lag at time T at a DC called destination from a DC called source
//		for a naming context NC is defined as the duration of time between T and the instance when
//		the latest update to an attribute of an NC occurred at the source, which has been propagated
//		to the destination DC by T.
//
// When current replication lag is X then the destination has almost always received all updates to NC
// from the source DC that had occured prior to T-X at the source DC. There are rare cases when it is 
// not true (see the presentation that Greg Malewicz delivered to Will's team on 12/17/01).
//
// Returns S_OK iff succesful (failure means a serious problem). Network problems DO NOT
// cause the function to fail. If the function is unable to retrieve packets from a remote machine
// then it creates a <retrievalError> element inside the <replicationLag> element of the DC which we could
// not be contacted. The <retrievalError> elements from previous run of itAnalyze() are removed,
// so hresult does not carry over from one run to the next unless causes persist. There is only one
// <retrievalError> element even though we try to contact a DC several times, each for a diferent naming context.
//
// EXAMPLE of what is inserted into <replicationLag> elements.
// When network failure occurs the attributes of the <retrievalError> element show what the hresult of
// the error was and when it was generated. 
/*
	<DC cn="ntdev-dc-02">
		...
		<replicationLag>
			<retrievalError timestamp="20011212073319.000627+000" hresult="2121"> </retrievalError>
		</replicationLag>
		...
	</DC>
*/
{
	HRESULT hr,retHR,hr1;
	long dnsDesID, ncID, ncType, dnsSrcID;
	long totalDNSs, totalNCs;
	BSTR dnsDesName, ncName;
	int state;
	WCHAR xpath[TOOL_MAX_NAME];
	LPWSTR pszAttr[] = { L"description", L"cn"};
	IDirectorySearch* pDSSearch;
	ADS_SEARCH_HANDLE hSearch;
	WCHAR objpath[TOOL_MAX_NAME];
	WCHAR dnsSrcName[TOOL_MAX_NAME];
	WCHAR descriptionText[TOOL_MAX_NAME];
	WCHAR temp[TOOL_MAX_NAME];
	LONGLONG sourcePacketInjectionTime;


//printf("\n\nEntry arrival\n");
//timeCubePrint(&arrivalTime);	
//printf("Entry lag\n");
//timeCubePrint(&currentLag);	


	//remove old <retrievalError> elements
	hr = removeNodes(pXMLDoc,L"sites/site/DC/replicationLag/retrievalError");
	if( hr != S_OK ) {
		printf("removeNodes failed\n");
		return S_FALSE;
	};



	hr = enumarateDCandNCpairsInit(pXMLDoc, &state,&totalDNSs,&totalNCs);
	if( hr != S_OK ) {
		printf("enumarateDCandNCpairsInit failed\n");
		return S_FALSE;
	};


	//allocate a 1-dim table called oneCRL with LONGLONG entries for each DC, an entry in the table represents 
	//the Current Replication Lag from a source DC into the dnsID DC for the ncID NC
	LONGLONG* oneCRL;
	oneCRL = (LONGLONG*)malloc(sizeof(LONGLONG) * totalDNSs );
	if( oneCRL == NULL ) {
		printf("malloc failed\n");
		return S_FALSE;
	};

	
	//loop through all pairs of (dnsID,ncID) for any Read-Write or Read only naming context ncID stored at a DC dnsID
	//(important because we also want to see if updates arrive at Global Catalogs)
	IXMLDOMElement* pDesDCElem;
	IXMLDOMElement* pNCElem;
	IXMLDOMElement* pDesRLElem;
	hSearch = NULL;
	pDSSearch = NULL;
	retHR = S_OK;
	while( true ) {
		hr = enumarateDCandNCpairsNext(pXMLDoc,&state,L"[@type=\"rw\" or @type=\"r\"]",&dnsDesName,&ncName,&dnsDesID,&ncID,&ncType,&pDesDCElem,&pNCElem);
		if( hr != S_OK ) break;
//printf("\n---\n%ld Des %S\n%ld NC  %S\n",dnsDesID,dnsDesName,ncID,ncName);


		//if the type of naming context is neither Read nor Read-Write then skip it
		if( ncType!=1 && ncType!=2 )
			continue;


		//find the <replicationLag> node inside the <DC> node - will be used to deposit network failures
		hr = findUniqueElem(pDesDCElem,L"replicationLag",&pDesRLElem);
		if( hr != S_OK ) {
			printf("findUniqueElem failed\n");
			retHR = S_FALSE;  //this is a serious problem, exit the function with an error
			break;
		};


		//enumerate all DCs that have a RW copy of the NC (these are 
		//the sources of injections) and mark the entry of the oneCRL table as
			//-2 when DC does not store a RW of the NC
			//when the DC stores a RW of the NC
				//0 if first injection occured (from the injectionHistory table)
				//-1 if first injection has not occured
		LONGLONG* p = oneCRL;
		for( int i=0; i<totalDNSs; i++ )
			*p++ = -2;
		wcscpy(xpath,L"");
		wcsncat(xpath,L"sites/site/DC/partitions/partition[@type=\"rw\"]/nCName[.=\"",TOOL_MAX_NAME-wcslen(xpath)-1);
		wcsncat(xpath,ncName,TOOL_MAX_NAME-wcslen(xpath)-1);
		wcsncat(xpath,L"\"]",TOOL_MAX_NAME-wcslen(xpath)-1);
//printf("%S\n",xpath);
		IXMLDOMNodeList *resultNCList;
		hr = createEnumeration(pXMLDoc,xpath,&resultNCList);
		if( hr != S_OK ) {
			printf("createEnumeration failed\n");
			retHR = S_FALSE;
			continue;
		};
		//loop through all NC of "rw" type
		IXMLDOMNode *pNCNode;
		while( true ){
			hr = resultNCList->nextNode(&pNCNode);
			if( hr != S_OK || pNCNode == NULL ) break; // iterations across DCs have finished
			//get the DC node
		    IXMLDOMNode* pDCNode;
			hr = pNCNode->get_parentNode(&pDCNode);
			hr = pDCNode->get_parentNode(&pDCNode);
			hr = pDCNode->get_parentNode(&pDCNode);
			//find the DNS Name of the DC and the identifier of its DNS name
			BSTR dnsSrcName;
			hr = getTextOfChild(pDCNode,L"dNSHostName",&dnsSrcName);
			if( hr != S_OK ) {
				printf("getTextOfChild failed\n");
				retHR = S_FALSE;
				continue;
			};
			hr = getAttrOfChild(pDCNode,L"dNSHostName",L"_id",&dnsSrcID);
//printf("  %ld Src %S\n",dnsSrcID,dnsSrcName);
			//now dnsSrcID, dnsID, and ncID are the identifiers of
			//a source DC that stores a Read-Write replica of naming
			//context ncID, dnsID is a destination DC that stores
			//a Read or Read-Write replica of the naming context
			CyclicBuffer* pCB;
			pCB = departureTimeGetCB(dnsSrcID,ncID);
			if( pCB == NULL ) {
				printf("CyclicBufferTableGetCB failed");
				retHR = S_FALSE;
				continue;
			};
			if( pCB->firstInjection == 0 )
				*(oneCRL+dnsSrcID) = -1; // first injection has not yet occured
			else
				*(oneCRL+dnsSrcID) = 0; // first injection occured
		};
		resultNCList->Release();
		p = oneCRL;
//for( i=0; i<totalDNSs; i++ )
//	printf("%ld ",*p++ );
//printf("\n");

		

		
		
		//retrieve all containers X from _ratTool_ in this NC at this destination DC
		//for each X, convert its description attribute into sourceDNSID (long)
		//and sourcePacketInjectionTime (LONGLONG)


		//issue an ADSI query to retrieve all container objects under the _ratTool
		//container at the dnsDesName DC
		if( pDSSearch != NULL ) {
			if( hSearch!=NULL ) {
				pDSSearch->CloseSearchHandle(hSearch);
				hSearch = NULL;
			};
			pDSSearch->Release();
			pDSSearch = NULL;
		};
		wcscpy(objpath,L"");
		wcsncat(objpath,L"CN=_ratTool_,",TOOL_MAX_NAME-wcslen(objpath)-1);
		wcsncat(objpath,ncName,TOOL_MAX_NAME-wcslen(objpath)-1);
//************************   NETWORK PROBLEMS
		switch( ncType ) {
		case 1:
			hr = ADSIquery(L"LDAP", dnsDesName,objpath,ADS_SCOPE_SUBTREE,L"container",pszAttr,sizeof(pszAttr)/sizeof(LPWSTR),username,domain,passwd,&hSearch,&pDSSearch);
			break;
		case 2:
			hr = ADSIquery(L"GC", dnsDesName,objpath,ADS_SCOPE_SUBTREE,L"container",pszAttr,sizeof(pszAttr)/sizeof(LPWSTR),username,domain,passwd,&hSearch,&pDSSearch);
			break;
		};
//************************
		if( hr != S_OK ) {
//printf("ADSIquery failed\n");

			//record the failure in a <retrievalError> node (if it already exists, do not create it)
			IXMLDOMElement* pDesRErrElem;
			hr1 = findUniqueElem(pDesRLElem,L"retrievalError",&pDesRErrElem);
			if( hr1!=E_UNEXPECTED && hr1!=S_OK ) {
				printf("findUniqueElem failed");
				retHR = S_FALSE;
				continue;
			};
			if( hr1 == E_UNEXPECTED ) { //<retrievalError> node did not exist => create it
				hr1 = addElement(pXMLDoc,pDesRLElem,L"retrievalError",L"",&pDesRErrElem);
				if( hr1 != S_OK ) {
					printf("addElement failed");
					retHR = S_FALSE;
					continue;
				};
			};
			setHRESULT(pDesRErrElem,hr);
			continue;
		};
		//loop through the container objects
		while( true ) {
			// get the next container object
//************************   NETWORK PROBLEMS
			hr = pDSSearch->GetNextRow( hSearch );
//************************
			if( hr != S_ADS_NOMORE_ROWS && hr != S_OK ) {
//printf("GetNextRow failed\n");

				//record the failure in a <retrievalError> node
				//(if it already exists, do not create it)
				IXMLDOMElement* pDesRErrElem;
				hr1 = findUniqueElem(pDesRLElem,L"retrievalError",&pDesRErrElem);
				if( hr1!=E_UNEXPECTED && hr1!=S_OK ) {
					printf("findUniqueElem failed");
					retHR = S_FALSE;
					continue;
				};
				if( hr1 == E_UNEXPECTED ) { //<retrievalError> node did not exist => create it
					hr1 = addElement(pXMLDoc,pDesRLElem,L"retrievalError",L"",&pDesRErrElem);
					if( hr1 != S_OK ) {
						printf("addElement failed");
						retHR = S_FALSE;
						continue;
					};
				};
				setHRESULT(pDesRErrElem,hr);
				continue;
			};
			if( hr == S_ADS_NOMORE_ROWS ) // if all objects have been retrieved then STOP
				break;


			hr = getCItypeString( pDSSearch, hSearch, L"cn", dnsSrcName, sizeof(dnsSrcName)/sizeof(WCHAR) );
			if( _wcsicmp(dnsSrcName,L"_ratTool_") == 0 )
				continue;
//printf(">>from source %S\n",dnsSrcName);
			hr = getCItypeString( pDSSearch, hSearch, L"description", descriptionText, sizeof(dnsSrcName)/sizeof(WCHAR) );
//printf("   received packet %S\n",descriptionText);
			//check if the packet was inserted by V1.0 of the ratTool
			if( _wcsnicmp(descriptionText,L"V1,",3) != 0 ) {
//printf("reveived packet is not Version 1 packet\n");
				continue; // ignore it
			};
			tailncp(descriptionText,temp,1,TOOL_MAX_NAME);
			dnsSrcID = _wtol(temp);
			tailncp(descriptionText,temp,2,TOOL_MAX_NAME);
			sourcePacketInjectionTime = _wtoi64(temp);
//printf("dnsSrcID %ld   injectionTime %I64d\n",dnsSrcID,sourcePacketInjectionTime);
			


		//verify that there has been the first injection at the source
		//(check for 0 in the table)
			//no => skip this source because the packet must be from the previous run of the algorithm
			if( *(oneCRL+dnsSrcID) == -2 ) {
//				printf("there is a packet from a source that does not store RW of the NC - IGNORE IT\n");
//				retHR = S_FALSE; << THIS condition can sometimes happen
				continue;
			};
			if( *(oneCRL+dnsSrcID) == -1 ) {
//				printf("There is a packet but we have not yet inserted it - IGNORE IT\n");
//				retHR = S_FALSE; << THIS condition can sometimes happen
				continue;
			};
			if( *(oneCRL+dnsSrcID) != 0 ) {
//				printf("Unknown oneCRL value failure - IGNORE IT\n");
//				retHR = S_FALSE; << THIS condition can sometimes happen
				continue;
			}

			
			//at this point we are guaranteed that there has been the first injection at the source


			//get current time
			FILETIME currentUTCTime;
			GetSystemTimeAsFileTime( &currentUTCTime );
			ULARGE_INTEGER x;
			x.LowPart = currentUTCTime.dwLowDateTime;
			x.HighPart = currentUTCTime.dwHighDateTime;
			LONGLONG currentTime = x.QuadPart;


			//if sourcePacketInjectionTime is smaller than the instance of the first
			//injection
			CyclicBuffer* pCB;
			pCB = departureTimeGetCB(dnsSrcID,ncID);
			if( sourcePacketInjectionTime < pCB->firstInjection ) {
					//then the packet must be from some old run of the algorithm and
					//the new update has not yet arrived at the destination thus the
					//current system time minus the first injection time estimates
					//the current replication lag from the dnsSrcID DC to the
					//dnsDesID DC for the ncID. Write this difference into the
					//dnsSrcID entry of the current replication lags oneCRL table
				*(oneCRL+dnsSrcID) = currentTime - (pCB->firstInjection);
				continue;
			};
			

			//is it a new packet that we have not yet received from the source?
			LONGLONG latest;
			latest = timeCubeGet(&arrivalTime,dnsSrcID,dnsDesID,ncID);
//cyclicBufferFindLatest(pCB,&latest);
			if( sourcePacketInjectionTime > latest ) {
				//then the lag is the difference between the current time and the 
				//time when the packet was injected
				*(oneCRL+dnsSrcID) = currentTime - (sourcePacketInjectionTime);

				//record the arrival of the packet
				timeCubePut(&arrivalTime,dnsSrcID,dnsDesID,ncID,sourcePacketInjectionTime);
				continue;
			};


			//so the packet that we observe is not new (we have already received it
			//and processed it in some previous calls to the function),
			//and there has been no new arrivals thus far


			//find the nextAfter the time of the latest arrival. The time of the
			//nextAfter is the instance of the first injection following the one
			//we have most recently received (i.e., latest)
			LONGLONG nextAfter;
			hr = cyclicBufferFindNextAfter(pCB,latest,&nextAfter);
			if( hr != S_OK ) {
				//previousArrival not found => ERROR, buffer looped, so the destination dnsDeID
				//have not received updates for time equal to at least buffer langth * injection period
				*(oneCRL+dnsSrcID) = MAXLONGLONG;

				continue;
			};


			//check if nextAfter exists
			if( nextAfter == 0 ) {
				//does not exist => there has been no new injections (if we cannot inject changes
				//for long enough period of time then we lose the ability to evaluate the lag from
				//the DC. We will know the period of time of our inability from the
				//<latestInjectionSuccess> element). But anyways we report that lag is the difference
				//between current time and the time of the latest arrival.

				*(oneCRL+dnsSrcID) = currentTime - latest;

				continue;
			};


			//a packet nextAfter has been inserted after the packet called latest
			//was inserted, however we have not received any packet following the
			//packet latest, so the replication lag is the difference
			//between the current time and the nextAfter

			*(oneCRL+dnsSrcID) = currentTime - nextAfter;

			continue;

		};


		//free memory used by the search and release binding to directory object
		if( pDSSearch != NULL ) {
			if( hSearch!=NULL ) {
				pDSSearch->CloseSearchHandle(hSearch);
				hSearch = NULL;
			};
			pDSSearch->Release();
			pDSSearch = NULL;
		};

		
			
		//we have just processed all packets that have arrived at the dnsDesID DC
		//for the ncID. Those DCs that still have 0 at the corresponding entry of
		//the oneCRL table haven't delivered any packet to the dnsDesID at all


		//get current time
		FILETIME currentUTCTime;
		GetSystemTimeAsFileTime( &currentUTCTime );
		ULARGE_INTEGER x;
		x.LowPart = currentUTCTime.dwLowDateTime;
		x.HighPart = currentUTCTime.dwHighDateTime;
		LONGLONG currentTime = x.QuadPart;

		for( int j=0; j<totalDNSs; j++) {


			//obtain the history of injections for the source DC j
			CyclicBuffer* pCB;
			pCB = departureTimeGetCB(j,ncID);
			if( pCB == NULL ) {
				printf("CyclicBufferTableGetCB failed");
				retHR = S_FALSE;
				continue;
			};


			if( *(oneCRL+j) == 0 ) {
				//there has been an injection for the DC with id j but no packet
				//has been received so the difference between curren system time
				//and the injection time is the current lag and will replace 0 in
				//the table
				*(oneCRL+j) = currentTime - (pCB->firstInjection);
			};
			//if no injection then ignore
		};

		//copy the 1-dim replication lag table into the 3-dim replicationLags table
		for( int k=0; k<totalDNSs; k++)
			timeCubePut(&currentLag,k,dnsDesID,ncID,*(oneCRL+k));

	};

//printf("Exit arrival\n");
//timeCubePrint(&arrivalTime);	
//printf("Exit lag\n");
//timeCubePrint(&currentLag);	



	free(oneCRL);
	return retHR;
}



HRESULT itDumpIntoXML(IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd, LONGLONG errorLag )
//for each source DC and NC lists all destination DCs that currently have replication lag
//greater than errorLag, and puts the result inside <replicationLag> element
/*
            <replicationLag>
               <destinationDC>
                 <dNSHostName> haifa-dc-05.haifa.ntdev.microsoft.com </dNSHostName>
                 <currentLag> 1 day </currentLag>
               </destinationDC>
            </replicationLag>
*/
{
	HRESULT hr,retHR,hr1,hr2,hr3,hr4;
	long dnsSrcID, dnsDesID, ncID, ncType;
	BSTR MAXdnsSrcName=NULL, MAXdnsDesName=NULL, MAXncName=NULL;
	LONGLONG MAXlag;
	long totalDNSs, totalNCs;
	BSTR dnsSrcName, ncName;
	int state;
	LPWSTR pszAttr[] = { L"description", L"cn"};
	WCHAR xpath[TOOL_MAX_NAME];
	WCHAR temp[TOOL_MAX_NAME];
	LONGLONG lag;
	VARIANT varValue;


	//remove <destinationDC> nodes from the pXMLDoc document (we will be inserting new if lag for them
	//is sufficiently large)
	hr = removeNodes(pXMLDoc,L"sites/site/DC/replicationLag/destinationDC");
	if( hr != S_OK ) {
		printf("removeNodes failed\n");
		return hr;
	};

	
	//loop through all pairs of (DC,NC) for Read-Write NC only
	hr = enumarateDCandNCpairsInit(pXMLDoc, &state,&totalDNSs,&totalNCs);
	if( hr != S_OK ) {
		printf("enumarateDCandNCpairsInit failed\n");
		return S_FALSE;
	};
	IXMLDOMElement* pSrcDCElem;
	IXMLDOMElement* pDesDNSElem;
	IXMLDOMElement* pNCElem;
	retHR = S_OK;
	MAXlag = 0;
	while( true ) {
		hr = enumarateDCandNCpairsNext(pXMLDoc,&state,L"[@ type=\"rw\"]",&dnsSrcName,&ncName,&dnsSrcID,&ncID,&ncType,&pSrcDCElem,&pNCElem);
		if( hr != S_OK ) break;
//printf("---\n%ld %S\n%ld %S\n",dnsSrcID,dnsSrcName,ncID,ncName);

		//does this source have any destination that has lag more than a thereshold?
		for( dnsDesID=0; dnsDesID<totalDNSs; dnsDesID++) {
			lag = timeCubeGet(&currentLag,dnsSrcID,dnsDesID,ncID);
//printf("%I64d\n%I64d\n",lag,errorLag);
			if( lag >= errorLag ) {
				//report an error into XML

				//find the DNS Name of the dnsDesID DC
				_ltow(dnsDesID,temp,10);
				wcscpy(xpath,L"");
				wcsncat(xpath,L"sites/site/DC/dNSHostName[@_id=\"",TOOL_MAX_NAME-wcslen(xpath)-1);
				wcsncat(xpath,temp,TOOL_MAX_NAME-wcslen(xpath)-1);
				wcsncat(xpath,L"\"]",TOOL_MAX_NAME-wcslen(xpath)-1);
//printf("%S\n",xpath);
				hr = findUniqueElem(pXMLDoc,xpath,&pDesDNSElem);
				if( hr != S_OK ) {
					printf("findUniqueElem failed\n");
					retHR = S_FALSE;
					continue;
				};
				BSTR dnsDesName;
				hr = getTextOfNode(pDesDNSElem,&dnsDesName);
				if( hr != S_OK ) {
					printf("getTextOfNode failed\n");
					retHR = S_FALSE;
					continue;
				};
//printf("%S\n",dnsDesName);


				//calculate maximum lag for the forest (called the FOREST DIAMETER)
				if( lag > MAXlag ) {
					MAXlag = lag;
					MAXdnsSrcName = dnsSrcName;
					MAXdnsDesName = dnsDesName;
					MAXncName = ncName;
				};


				//skip when replicaiton it to itself
				if( _wcsicmp(dnsSrcName,dnsDesName) == 0 )
					continue;


				//find <replicationLag> node
				IXMLDOMElement* pRLElem;
				hr = findUniqueElem(pSrcDCElem,L"replicationLag",&pRLElem);
				if( hr != S_OK ) {
					printf("findUniqueElem failed\n");
					retHR = S_FALSE;
					continue;
				};


				//set timestamp attribute on the <replicationLag> node
				BSTR currentTime;
				currentTime = GetSystemTimeAsCIM();
				varValue.vt = VT_BSTR;
				varValue.bstrVal = currentTime;
				hr = pRLElem->setAttribute(L"timestamp", varValue);
				SysFreeString(currentTime);
				if( hr != S_OK ) {
					printf("setAttribute failed\n");
					retHR = S_FALSE;
					continue; //some problems => skip this DC
				};


				//deposit the following XML structure inside the <replicationLag> node
                //<destinationDC>
                //  <dNSHostName> haifa-dc-05.haifa.ntdev.microsoft.com </dNSHostName>
                //  <currentLag> 1 day </currentLag>
                //</destinationDC>

				IXMLDOMElement* pDesLagElem;
				hr = addElement(pXMLDoc,pRLElem,L"destinationDC",L"",&pDesLagElem);
				if( hr!=S_OK ) {
					printf("addElement falied\n");
					retHR = S_FALSE;
					continue;
				};


				varValue.vt = VT_BSTR;
				varValue.bstrVal = ncName;
				hr = pDesLagElem->setAttribute(L"nCName",varValue);
				if( hr != S_OK ) {
					printf("setAttribute falied\n");
					retHR = S_FALSE;
					continue;
				};


				IXMLDOMElement* pTempElem;
				hr = addElement(pXMLDoc,pDesLagElem,L"dNSHostName",dnsDesName,&pTempElem);
				if( hr!=S_OK ) {
					printf("addElement falied\n");
					retHR = S_FALSE;
					continue;
				};
				hr = addElement(pXMLDoc,pDesLagElem,L"currentLag",(long)(lag/10000000),&pTempElem);
				if( hr!=S_OK ) {
					printf("addElement falied\n");
					retHR = S_FALSE;
					continue;
				};


			};
		};
	};

	
	//deposit forest diameter (max lag) into XML - this should be done by the Viewer
/*
	printf("\nMAX lag of %ld seconds occurs\n",(long)(MAXlag/10000000) );
	printf("  from DC\n");
	printf("     %S\n",MAXdnsSrcName);
	printf("  to DC\n");
	printf("     %S\n",MAXdnsDesName);
	printf("  for NC\n");
	printf("     %S\n",MAXncName);
*/
	//get the root element of the XML
	IXMLDOMElement* pRootElem;
	hr = pXMLDoc->get_documentElement(&pRootElem);
	if( hr != S_OK ) {
		printf("get_documentElement failed\n");
		return hr;
	};
	IXMLDOMElement* pMLElem;
	hr = addElement(pXMLDoc,pRootElem,L"forestMaxLag",L"",&pMLElem);
	if( hr != S_OK ) {
		printf("addElement failed\n");
		return hr;
	};
	hr = setHRESULT(pMLElem,0); // set a timestamp so that we know when this max lag occured
	if( hr != S_OK ) {
		printf("setHRESULT failed\n");
		return hr;
	};
	IXMLDOMElement* pTempElem;
	hr1 = addElement(pXMLDoc,pMLElem,L"MAXlag",(long)(MAXlag/10000000),&pTempElem);
	hr2 = addElement(pXMLDoc,pMLElem,L"MAXdnsSrcName",MAXdnsSrcName,&pTempElem);
	hr3 = addElement(pXMLDoc,pMLElem,L"MAXdnsDesName",MAXdnsDesName,&pTempElem);
	hr4 = addElement(pXMLDoc,pMLElem,L"MAXncName",MAXncName,&pTempElem);
	if( hr1 != S_OK || hr2 != S_OK || hr3 != S_OK || hr3 != S_OK ) {
		printf("addElement failed\n");
		return S_FALSE;
	};

	
	return retHR;
}




HRESULT it(IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd, LONGLONG errorLag )
{
	HRESULT hr;
	
	hr = itInject(pXMLDoc, username, domain, passwd );
	if( hr != S_OK ) {
		printf("itInject failed\n");
		return hr;
	};
	hr = itAnalyze(pXMLDoc, username, domain, passwd );
	if( hr != S_OK ) {
		printf("itAnalyze failed\n");
		return hr;
	};
	hr = itDumpIntoXML(pXMLDoc, username, domain, passwd,errorLag );
	if( hr != S_OK ) {
		printf("itDumpIntoXML failed\n");
		return hr;
	};
	return S_OK;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\reptool-collector\istg-retrieve.cpp ===
#include "global.h"

HRESULT istg( IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd )
// Finds the DC that holds the ISTG role for each site and populates
// the results of the findings in the site elements of the XML document.
// These results are based on contacting a pseudorandomly selected DC
// in a site (to avoid failures and to do load-balancing).
//
// Returns S_OK iff succesful. Network failures do not cause the function to fail.
// If succesful then there are three ways in which a site element can be populated
// (see examples below). 1) when ISTG for the site was found, 2) when the 
// ISTG cannot be determined because we failed to contact the randomely selected DC,
// 3) when ISTG was found but, per current configuration, there is no such DC in the site
// this means lack of coherence in the configuration data across DCs in the forest.
//
/*

1)
	<site>
		<DC>
			<ISTG sourceOfInformation="a.b.com" timestamp="..">
				<distinguishedName> CN=HAIFA-DC-99,CN=Servers,CN=Redmond-Haifa,CN=Sites,CN=Configuration,DC=ntdev,DC=microsoft,DC=com </distinguishedName>
			</ISTG>
		</DC>
	</site>


2)
	<site>
		<DC>
			<cannotFindISTGError timestamp="20011212073319.000627+000" hresult="2121"> </cannotFindISTGError>
		</DC>
	</site>


3)
	<site>
		<ISTG sourceOfInformation="a.b.com" timestamp="..">
			<distinguishedName> CN=HAIFA-DC-99,CN=Servers,CN=Redmond-Haifa,CN=Sites,CN=Configuration,DC=ntdev,DC=microsoft,DC=com </distinguishedName>
		</ISTG>
	</site>

*/
{
	HRESULT hr,hr1,retHR; // COM result variable
	ADS_SEARCH_COLUMN col;  // COL for iterations
	WCHAR dcxpath[TOOL_MAX_NAME];
	WCHAR userpath[TOOL_MAX_NAME];
	_variant_t varValue3,varValue2;
	LPWSTR pszAttr[] = { L"interSiteTopologyGenerator" };
	ADS_SEARCH_HANDLE hSearch;
	IDirectorySearch* pDSSearch;


	if( pXMLDoc == NULL )
		return S_FALSE;


	//get the root element of the XML
	IXMLDOMElement* pRootElem;
	hr = pXMLDoc->get_documentElement(&pRootElem);
	if( hr != S_OK )
		return hr;


	//construct a path will be used to connect to LDAP object
	wcscpy(userpath,L"");
	wcsncat(userpath,domain,TOOL_MAX_NAME-wcslen(userpath)-1);
	wcsncat(userpath,L"\\",TOOL_MAX_NAME-wcslen(userpath)-1);
	wcsncat(userpath,username,TOOL_MAX_NAME-wcslen(userpath)-1);
//	printf("%S\n",userpath);


	//remove all <ISTG> and <cannotFindISTGError> elements and their content from DOM
	hr = removeNodes( pRootElem, L"sites/site/ISTG" );
	if( hr != S_OK ) {
		printf("removeNodes failed\n");
		return hr; // skip entire processing
	};
	hr = removeNodes( pRootElem, L"sites/site/DC/ISTG" );
	if( hr != S_OK ) {
		printf("removeNodes failed\n");
		return hr; // skip entire processing
	};
	hr = removeNodes( pRootElem, L"sites/site/DC/cannotFindISTGError" );
	if( hr != S_OK ) {
		printf("removeNodes failed\n");
		return hr; // skip entire processing
	};

 	
	// create an enumerattion of all sites
	IXMLDOMNodeList *resultSiteList;
	hr = createEnumeration( pRootElem, L"sites/site", &resultSiteList);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		return hr; // skip entire processing
	};


	//seed the random-number generator with current time so that the numbers will be different every time we run
	srand( (unsigned)time( NULL ) ); rand();


	// loop through all sites using the enumeration
	IXMLDOMNode *pSiteNode;
	IXMLDOMNode *pDCNode;
	BSTR siteDN;
	BSTR dcDN;
	BSTR dcDNSname;
	long len;
	int pick;
	WCHAR istgDN[TOOL_MAX_NAME];
	WCHAR object[TOOL_MAX_NAME];
	hSearch = NULL;
	pDSSearch = NULL;
	retHR = S_OK;
	while( true ) {
		hr = resultSiteList->nextNode(&pSiteNode);
		if( hr != S_OK || pSiteNode == NULL ) break; // iterations across partition elements have finished


		//the query actually retrives elements not nodes (elements inherit from nodes)
		//so get site element
		IXMLDOMElement* pSiteElem;
		hr=pSiteNode->QueryInterface(IID_IXMLDOMElement,(void**)&pSiteElem );
		if( hr != S_OK ) {
			printf("QueryInterface failed\n");
			retHR = hr;
			continue;	// skip this site
		};


		//get distinguished name of the site
		hr = getTextOfChild(pSiteNode,L"distinguishedName",&siteDN);
		if( hr != S_OK ) {
			printf("getTextOfChild failed\n");
			retHR = hr;
			continue;	// skip this site
		};
//		printf("SITE\n   %S\n",siteDN);


		// create an enumeration of all DCs in the site
		IXMLDOMNodeList *resultDCList;
		hr = createEnumeration( pSiteNode, L"DC", &resultDCList);
		if( hr != S_OK ) {
			printf("createEnumeration failed\n");
			retHR = hr;
			continue;	// skip this site
		};
		//pick a random DC in the enumeration and get its DNS name and distinguished name
		// if failure then skip this site
		hr = resultDCList->get_length(&len);
		if( hr != S_OK ) { // if failure then skip this site
			printf("get_length failed\n");
			retHR = hr;
			continue;
		};
		if( len <1 ) { // empty site - ignore it
			continue;
		};
		pick = random(len);
		hr = resultDCList->get_item(pick-1,&pDCNode);
		if( hr != S_OK ) {
			printf("item failed\n");
			retHR = hr;
			continue;
		}	
		hr = getTextOfChild(pDCNode,L"dNSHostName",&dcDNSname);
		if( hr != S_OK ) { //does not have dNSHostName - ignore it
			printf("getTextOfChild failed\n");
			retHR = hr;
			continue;
		};
		hr = getTextOfChild(pDCNode,L"distinguishedName",&dcDN);
		if( hr != S_OK ) { // does not have distinguished name - ignore it
			printf("getTextOfChild failed\n");
			retHR = hr;
			continue;
		};
		resultDCList->Release();


//		printf("   sourceOfInformation %S\n",dcDNSname);


		//build a string representing an Active Directory object to which we will connect using ADSI
		if( pDSSearch != NULL ) {
			if( hSearch!=NULL ) {
				pDSSearch->CloseSearchHandle(hSearch);
				hSearch = NULL;
			};
			pDSSearch->Release();
			pDSSearch = NULL;
		};
		wcscpy(object,L"");
		wcsncat(object,L"LDAP://",TOOL_MAX_NAME-wcslen(object)-1);
		wcsncat(object,dcDNSname,TOOL_MAX_NAME-wcslen(object)-1);
		wcsncat(object,L"/",TOOL_MAX_NAME-wcslen(object)-1);
		wcsncat(object,siteDN,TOOL_MAX_NAME-wcslen(object)-1);
//printf("%S\n",object);
//************************   NETWORK PROBLEMS
		hr = ADSIquery(L"LDAP",dcDNSname,siteDN,ADS_SCOPE_ONELEVEL,L"nTDSSiteSettings",pszAttr,1,username,domain,passwd,&hSearch,&pDSSearch);
//************************
		if( hr!= S_OK ) {
//			printf("ADSIquery failed\n");
			IXMLDOMElement* pCFErrElem;
			hr1 = addElement(pXMLDoc,pDCNode,L"cannotFindISTGError",L"",&pCFErrElem);
			if( hr1 != S_OK ) {
				printf("addElement failed\n");
				retHR = hr1;
				continue;
			};
			setHRESULT(pCFErrElem,hr);
			continue;
		};


		//get the first (and hopefuly) only row
//************************   NETWORK PROBLEMS
		hr = pDSSearch->GetFirstRow( hSearch );
//************************
		if( hr != S_OK ) {
//			printf("GetColumn failed\n");
			IXMLDOMElement* pCFErrElem;
			hr1 = addElement(pXMLDoc,pDCNode,L"cannotFindISTGError",L"",&pCFErrElem);
			if( hr1 != S_OK ) {
				printf("addElement failed\n");
				retHR = hr1;
				continue;
			};
			setHRESULT(pCFErrElem,hr);
			continue;
		};


		
		//get ISTG
		hr = pDSSearch->GetColumn( hSearch, L"interSiteTopologyGenerator", &col );
		if( hr != S_OK ) {
			printf("GetColumn failed\n");
			retHR = hr;
			continue;
		};
                assert(ADSTYPE_DN_STRING == 1);
		if( col.dwADsType != ADSTYPE_DN_STRING ) {
			//something wrong with the datatype of the interSiteTopologyGenerator attribute
			retHR = S_FALSE;
			pDSSearch->FreeColumn( &col );
			continue;
		}
		else {

			tailncp(col.pADsValues->DNString,istgDN,1,TOOL_MAX_NAME);
//				printf("  ISTG       %S\n",istgDN);


			//create an <ISTG> element, we later append it under the <site> or <DC> element
			IXMLDOMElement* pISTGElem;
			hr = createTextElement(pXMLDoc,L"ISTG",L"",&pISTGElem);
			if( hr != S_OK ) {
				printf("createTextElement failed\n");
				retHR = hr;
				continue;
			};
			//set the source of information and timestamp attributes of the <ISTG> node
			varValue2 = dcDNSname;
			hr = pISTGElem->setAttribute(L"sourceOfInformation", varValue2);
			if( hr != S_OK ) {
				printf("setAttribute failed\n");
				retHR = hr;
				continue;
			};
			BSTR ct;
			ct = GetSystemTimeAsCIM();
			varValue3 = ct;
			hr = pISTGElem->setAttribute(L"timestamp", varValue3);
			SysFreeString( ct );
			if( hr != S_OK ) {
				printf("setAttribute failed\n");
				retHR = hr;
				continue;
			};
			IXMLDOMElement* pTempElem;
			hr = addElement(pXMLDoc,pISTGElem,L"distinguishedName",istgDN,&pTempElem);
			if( hr != S_OK ) {
				printf("addElement failed\n");
				retHR = hr;
				continue;
			};


			//find the DC in the DOM
			IXMLDOMNodeList *resultOneDC;
			wcscpy(dcxpath,L"");
			wcsncat(dcxpath,L"DC[distinguishedName=\"",TOOL_MAX_NAME-wcslen(dcxpath)-1);
			wcsncat(dcxpath,istgDN,TOOL_MAX_NAME-wcslen(dcxpath)-1);
			wcsncat(dcxpath,L"\"]",TOOL_MAX_NAME-wcslen(dcxpath)-1);
//		printf("%S\n",dcxpath);
			hr = createEnumeration( pSiteElem, dcxpath, &resultOneDC);
			if( hr != S_OK ) {
				printf("createEnumeration failed\n");
				retHR = hr;
				pDSSearch->FreeColumn( &col );
				continue;
			};
			long len;
			hr = resultOneDC->get_length(&len);
			if( hr != S_OK ) {
				printf("get_length failed\n");
				retHR = hr;
				pDSSearch->FreeColumn( &col );
				continue;
			};


			//if a single <DC> node is found then append the <ISTG> node under the <DC> node
			if( len == 1 ) {
				IXMLDOMNode* pDCNode;
				hr = resultOneDC->get_item(0,&pDCNode);
				if( hr != S_OK ) {
					printf("get_item failed\n");
					retHR = hr;
					pDSSearch->FreeColumn( &col );
					continue;
				};
				IXMLDOMNode* pTempNode;
				hr = pDCNode->appendChild(pISTGElem,&pTempNode);
				if( hr != S_OK ) {
					printf("appendChild failed\n");
					retHR = hr;
					pDSSearch->FreeColumn( &col );
					continue;
				};
			}
			else {
				//the DC node was not found or there are more than one (impossible), so append upder the <site> node
				IXMLDOMNode* pTempNode;
				hr = pSiteElem->appendChild(pISTGElem,&pTempNode);
				if( hr != S_OK ) {
					printf("appendChild failed\n");
					retHR = hr;
					pDSSearch->FreeColumn( &col );
					continue;
				};
			};

				
			pDSSearch->FreeColumn( &col );
		};


		//if there are more than 1 nTDSSiteSettings objects under the site container then report an error 
//************************   NETWORK PROBLEMS, TRICKY **********************
		hr = pDSSearch->GetNextRow( hSearch );
//************************
		if( hr != S_ADS_NOMORE_ROWS  ) {
			printf("GetNextRow failed\n");
			//ignore it
		};


		if( pDSSearch != NULL ) {
			if( hSearch!=NULL ) {
				pDSSearch->CloseSearchHandle(hSearch);
				hSearch = NULL;
			};
			pDSSearch->Release();
			pDSSearch = NULL;
		};


	};
	resultSiteList->Release();

	return retHR;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\replstruct\replstructinfo.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:
    replStructInfo.cxx

Abstract:
    This file contains a set of tables which can be indexed and cross-referanced with
    each other to provide access to data about replication structures. To understand how
    these tables relate, examin their definitions. The tables are accesed via functions
    to hide the class structure from .c files.

    Note on dynamic memory allocation during table construction: The tables are implemented
    as a link list. The links are allocated with the new operator. The tables exist until the
    process ends and thus the links are reclaimed during process termination.

    * How do I add another replication structure?

        Update the rows of the tables to included the new replication structure.
        Updating the DS_REPL_STRUCT_TYPE enumeration to include the new structure.
        Include the structure in the _uReplStruct union.
        If there is an array wrapper struct, include it in the _uReplStructArray union.
        If the attribute is a ROOT_DSE attribute, #define an ATTRTYP following the convention
            for ROOT_DSE_MS_DS_REPL_PENDING_OPS and the others.

        There are a few functions which are not driven by the tables which will have to be
        updated by hand.

            Repl_MarshalXML - repl struct -> XML string
            Repl_GetPtrLengths - repl struct -> length of its pointers
            Repl_TypeToString - repl struct field -> XML string
            draGetReplStruct in drainfo.c - replication id -> populated replication structure
            examine locations where draGetLdapReplInfo is called from to ensure that control
            is passed to it when appropriate.

        If there are any code paths that are specific to the new replication structure, such as
        aquiring mutexes, add those where appropriate. See draGetLdapReplInfo and note how
        a critical section is aquired for ROOT_DSE_MS_DS_REPL_PENDING_OPS and
        ROOT_DSE_MS_DS_REPL_QUEUE_STATISTICS.

        Recompile replStruct, ntdsa.dll, ldp.exe and repadmin.exe.

Author:

    Chris King          [t-chrisk]    July-2000

Revision History:

--*/

#include <NTDSpchx.h>
#pragma hdrstop

#include <drs.h>            // ATTRTYP
#include <attids.h>
#include <debug.h>
#include <dsexcept.h>

#include "ReplStructInfo.hxx"
#include "ReplTables.hxx"

#define DEBSUB "ReplStructInfo:"               /* define the subsystem for debugging */

#include <fileno.h>
#define FILENO  FILENO_UTIL_REPLSTRUCT_REPLMARSHALXML

template<class Index, class Type>
cTable<Index,Type>::cTable()
{
    m_root.next = NULL;
    m_dwRowCount = 0;
}

template<class Index, class Type>
Type &
cTable<Index,Type>::findRow(Index I)
/*++

Routine Description:
    Given the "primary key" return the corrisponding "row" or structure and assert if
    the structure is not found.

Arguments:
    index - the index used as the "primary key" for the table (ie the key to the map)

Return Values:
    a referance to the "row" (ie the structure associated with the primary key.

--*/
{
    sLink<Index, Type> *pLink = &m_root;

    while(pLink->next)
    {
        pLink = pLink->next;
        if (pLink->I == I)
            return pLink->T;
        Assert(pLink->next);
    }

    Assert(!"We couldn't find the right row!");
    RaiseException( DRA_GEN_EXCEPTION, 0, 0, NULL );
    // Should never execute, but we have to return something.
    return(pLink->T);
}

template<class Index, class Type>
Type &
cTable<Index,Type>::getRow(DWORD rowNum)
/*++

Routine Description:
    Allows for simple enumeration of the rows in the table. Indexes start at zero and any
    request for non-existent rows result in assertions. Use getNumRows to discover how many
    rows are in the table.

Arguments:
    rowNum - the row numbers start at zero.

Return Values:
    a referance to the requested row

--*/
{
    sLink<Index, Type> *pLink = &m_root;
    DWORD i;

    for(i = 0; i < rowNum + 1; i++)
    {
        Assert(pLink->next);
        pLink = pLink->next;
    }

    return pLink->T;
}

template<class Index, class Type>
BOOL
cTable<Index,Type>::indexExists(Index I)
/*++

Routine Description:
    Discover if a given index exists in the table.

Arguments:
    I - the index in question

Return Values:
    TRUE/FALSE depending on whether or not the index exists

--*/
{
    sLink<Index, Type> *pLink = &m_root;

    while(pLink->next)
    {
        pLink = pLink->next;
        if (pLink->I == I)
            return TRUE;
    }

    return FALSE;
}

template<class Index, class Type>
DWORD
cTable<Index,Type>::getNumRows()
    {
        return m_dwRowCount;
    }

template<class Index, class Type>
void
cTable<Index,Type>::insert(Index I, Type T)
/*++
Routine Description:
    Inserts a row with values T in the table under index I

Arguments:
    I - index of the new row, must be unique in the table
    T - the value of the row

Return Values:
    none

--*/
{
    sLink<Index, Type> *pLink = &m_root;

    while(pLink->next)
    {
        pLink = pLink->next;
        /* When the tables are constructed in my user land test program this
           assertion does not fire and the test program works properly. When
           the tables are constructed during boot up as part of ntdsa.dll removal
           of this assertion allowed the boot up to complete. The tests still
           ran and visual inspection showed no duplicate rows so I don't know
           why this assertion caused the boot up to fail.
        */
//            Assert(pLink->I != I);
    }

    pLink->next = new sLink<Index, Type>;
    if (pLink->next == NULL) {
/* ISSUE JeffParh/Wlees Sept 27, 2000.  Yeah, in general I think it's questionable
form to have anything in a constructor that can fail.  If you do you have to define
some way for those failures to be communicated back to the caller.  If it's a global
it's even harder to define what should happen.  Hmm.  Ideally I think we'd make
the initialization explicit and have it return an error if unsuccessful.  */
        RaiseException( DSA_MEM_EXCEPTION, 0, 0, NULL );
    }
    m_dwRowCount++;
    Assert(pLink->next);
    pLink = pLink->next;
    pLink->next = NULL;
    pLink->I = I;
    pLink->T = T;
}


//
// add "rows" to the ReplMetaInfoAttrType "table"
/////////////////////////////////////////////////////////////////////////////////////
class cReplMetaInfoAttrTyp : public tReplMetaInfoAttrTyp {
public:
    cReplMetaInfoAttrTyp() {
        insert(DS_REPL_INFO_NEIGHBORS,                  ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS);
        insert((DS_REPL_INFO_TYPE)DS_REPL_INFO_REPSTO,  ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS);
        insert(DS_REPL_INFO_CURSORS_3_FOR_NC,           ATT_MS_DS_NC_REPL_CURSORS);
        insert(DS_REPL_INFO_METADATA_2_FOR_OBJ,         ATT_MS_DS_REPL_ATTRIBUTE_META_DATA);
        insert(DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE,  ATT_MS_DS_REPL_VALUE_META_DATA);
        insert(DS_REPL_INFO_PENDING_OPS,                ROOT_DSE_MS_DS_REPL_PENDING_OPS);
        insert(DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,   ROOT_DSE_MS_DS_REPL_CONNECTION_FAILURES);
        insert(DS_REPL_INFO_KCC_DSA_LINK_FAILURES,      ROOT_DSE_MS_DS_REPL_LINK_FAILURES);
    }
} gmReplMetaInfoAttrTyp;

// add "rows" to the ReplTypeInfo "table"
/////////////////////////////////////////////////////////////////////////////////////
class cReplTypeInfo : public tReplTypeInfo {
public:
    cReplTypeInfo() {
        ReplTypeInfo row;

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(DWORD);
        insert(dsReplDWORD, row);

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(LONG);
        insert(dsReplLONG, row);

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(FILETIME);
        insert(dsReplFILETIME, row);

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(UUID);
        insert(dsReplUUID, row);

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(USN);
        insert(dsReplUSN, row);

        row.bIsPointer                  = TRUE;
        row.dwSizeof                    = sizeof(LPCSTR);
        insert(dsReplString, row);

        row.bIsPointer                  = TRUE;
        row.dwSizeof                    = sizeof(PVOID);
        insert(dsReplBinary, row);

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(DWORD);
        insert(dsReplPadding, row);

        row.bIsPointer                  = FALSE;
        row.dwSizeof                    = sizeof(OpType);
        insert(dsReplOPTYPE, row);
    }
} gmReplTypeInfo;

// add "rows" to the ReplLdapInfo "table"
/////////////////////////////////////////////////////////////////////////////////////
class cReplLdapInfo : public tReplLdapInfo {
public:
    cReplLdapInfo() {
        ReplLdapInfo row;

        row.eReplStructIndex                                = dsReplNeighbor;
        row.pszLdapCommonNameBinary                         = L"msDS-NCReplInboundNeighbors;binary";
        row.pszLdapCommonNameXml                            = L"msDS-NCReplInboundNeighbors";
        row.bIsRootDseAttribute                             = FALSE;
        insert(ATT_MS_DS_NC_REPL_INBOUND_NEIGHBORS, row);

        row.eReplStructIndex                                = dsReplNeighbor;
        row.pszLdapCommonNameBinary                         = L"msDS-NCReplOutboundNeighbors;binary";
        row.pszLdapCommonNameXml                            = L"msDS-NCReplOutboundNeighbors";
        row.bIsRootDseAttribute                             = FALSE;
        insert(ATT_MS_DS_NC_REPL_OUTBOUND_NEIGHBORS, row);

        row.eReplStructIndex                                = dsReplCursor;
        row.pszLdapCommonNameBinary                         = L"msDS-NCReplCursors;binary";
        row.pszLdapCommonNameXml                            = L"msDS-NCReplCursors";
        row.bIsRootDseAttribute                             = FALSE;
        insert(ATT_MS_DS_NC_REPL_CURSORS, row);

        row.eReplStructIndex                                = dsReplAttrMetaData;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplAttributeMetaData;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplAttributeMetaData";
        row.bIsRootDseAttribute                             = FALSE;
        insert(ATT_MS_DS_REPL_ATTRIBUTE_META_DATA, row);

        row.eReplStructIndex                                = dsReplAttrValueMetaData;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplValueMetaData;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplValueMetaData";
        row.bIsRootDseAttribute                             = FALSE;
        insert(ATT_MS_DS_REPL_VALUE_META_DATA, row);

        row.eReplStructIndex                                = dsReplOp;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplPendingOps;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplPendingOps";
        row.bIsRootDseAttribute                             = TRUE;
        insert(ROOT_DSE_MS_DS_REPL_PENDING_OPS, row);

        row.eReplStructIndex                                = dsReplKccDsaFailure;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplConnectionFailures;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplConnectionFailures";
        row.bIsRootDseAttribute                             = TRUE;
        insert(ROOT_DSE_MS_DS_REPL_CONNECTION_FAILURES, row);

        row.eReplStructIndex                                = dsReplKccDsaFailure;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplLinkFailures;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplLinkFailures";
        row.bIsRootDseAttribute                             = TRUE;
        insert(ROOT_DSE_MS_DS_REPL_LINK_FAILURES, row);

        row.eReplStructIndex                                = dsReplNeighbor;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplAllInboundNeighbors;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplAllInboundNeighbors";
        row.bIsRootDseAttribute                             = TRUE;
        insert(ROOT_DSE_MS_DS_REPL_ALL_INBOUND_NEIGHBORS, row);

        row.eReplStructIndex                                = dsReplNeighbor;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplAllOutboundNeighbors;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplAllOutboundNeighbors";
        row.bIsRootDseAttribute                             = TRUE;
        insert(ROOT_DSE_MS_DS_REPL_ALL_OUTBOUND_NEIGHBORS, row);

        row.eReplStructIndex                                = dsReplQueueStatistics;
        row.pszLdapCommonNameBinary                         = L"msDS-ReplQueueStatistics;binary";
        row.pszLdapCommonNameXml                            = L"msDS-ReplQueueStatistics";
        row.bIsRootDseAttribute                             = TRUE;
        insert(ROOT_DSE_MS_DS_REPL_QUEUE_STATISTICS, row);
    }
} gmReplLdapInfo;




// add "rows" to the ReplStructInfo "table"
/////////////////////////////////////////////////////////////////////////////////////

#define REPL_STRUCT_INFO(field,type) { \
      L#field,\
      offsetof(CURRENT_REPL_STRUCT,field),\
      offsetof(CURRENT_REPL_STRUCT_BLOB,field),\
      type }
#define REPL_STRUCT_INFO1(field,blobField,type) { \
      L#field,\
      offsetof(CURRENT_REPL_STRUCT,field),\
      offsetof(CURRENT_REPL_STRUCT_BLOB,blobField),\
      type }

#define CURRENT_REPL_STRUCT DS_REPL_NEIGHBORW
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_NEIGHBORW_BLOB
sReplStructField aDsReplNeighbor[] = {
    REPL_STRUCT_INFO1(pszNamingContext, oszNamingContext,                dsReplString),
    REPL_STRUCT_INFO1(pszSourceDsaDN, oszSourceDsaDN,                    dsReplString),
    REPL_STRUCT_INFO1(pszSourceDsaAddress, oszSourceDsaAddress,          dsReplString),
    REPL_STRUCT_INFO1(pszAsyncIntersiteTransportDN, oszAsyncIntersiteTransportDN, dsReplString),
    REPL_STRUCT_INFO(dwReplicaFlags,                    dsReplDWORD),
    REPL_STRUCT_INFO(uuidNamingContextObjGuid,          dsReplUUID),
    REPL_STRUCT_INFO(uuidSourceDsaObjGuid,              dsReplUUID),
    REPL_STRUCT_INFO(uuidSourceDsaInvocationID,         dsReplUUID),
    REPL_STRUCT_INFO(uuidAsyncIntersiteTransportObjGuid,dsReplUUID),
    REPL_STRUCT_INFO(usnLastObjChangeSynced,            dsReplUSN),
    REPL_STRUCT_INFO(usnAttributeFilter,                dsReplUSN),
    REPL_STRUCT_INFO(ftimeLastSyncSuccess,              dsReplFILETIME),
    REPL_STRUCT_INFO(ftimeLastSyncAttempt,              dsReplFILETIME),
    REPL_STRUCT_INFO(dwLastSyncResult,                  dsReplDWORD),
    REPL_STRUCT_INFO(cNumConsecutiveSyncFailures,       dsReplDWORD)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#define CURRENT_REPL_STRUCT DS_REPL_CURSOR_3W
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_CURSOR_BLOB
sReplStructField aDsReplCursor[] = {
    REPL_STRUCT_INFO(uuidSourceDsaInvocationID,         dsReplUUID),
    REPL_STRUCT_INFO(usnAttributeFilter,                dsReplUSN),
    REPL_STRUCT_INFO(ftimeLastSyncSuccess,              dsReplFILETIME),
    REPL_STRUCT_INFO1(pszSourceDsaDN, oszSourceDsaDN, dsReplString)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#define CURRENT_REPL_STRUCT DS_REPL_ATTR_META_DATA_2
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_ATTR_META_DATA_BLOB
sReplStructField aDsReplAttrMetaData[] = {
    REPL_STRUCT_INFO1(pszAttributeName, oszAttributeName, dsReplString),
    REPL_STRUCT_INFO(dwVersion,                         dsReplDWORD),
    REPL_STRUCT_INFO(ftimeLastOriginatingChange,        dsReplFILETIME),
    REPL_STRUCT_INFO(uuidLastOriginatingDsaInvocationID,dsReplUUID),
    REPL_STRUCT_INFO(usnOriginatingChange,              dsReplUSN),
    REPL_STRUCT_INFO(usnLocalChange,                    dsReplUSN),
    REPL_STRUCT_INFO1(pszLastOriginatingDsaDN, oszLastOriginatingDsaDN, dsReplString)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#define CURRENT_REPL_STRUCT DS_REPL_VALUE_META_DATA_2
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_VALUE_META_DATA_BLOB
sReplStructField aDsReplAttrValueMetaData[] = {
    REPL_STRUCT_INFO1(pszAttributeName, oszAttributeName, dsReplString),
    REPL_STRUCT_INFO1(pszObjectDn, oszObjectDn,         dsReplString),
    REPL_STRUCT_INFO(cbData,                            dsReplDWORD),
    REPL_STRUCT_INFO1(pbData, obData,                   dsReplBinary),
    REPL_STRUCT_INFO(ftimeDeleted,                      dsReplFILETIME),
    REPL_STRUCT_INFO(ftimeCreated,                      dsReplFILETIME),
    REPL_STRUCT_INFO(dwVersion,                         dsReplDWORD),
    REPL_STRUCT_INFO(ftimeLastOriginatingChange,        dsReplFILETIME),
    REPL_STRUCT_INFO(uuidLastOriginatingDsaInvocationID,dsReplUUID),
    REPL_STRUCT_INFO(usnOriginatingChange,              dsReplUSN),
    REPL_STRUCT_INFO(usnLocalChange,                    dsReplUSN),
    REPL_STRUCT_INFO1(pszLastOriginatingDsaDN, oszLastOriginatingDsaDN, dsReplString)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#define CURRENT_REPL_STRUCT DS_REPL_OPW
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_OPW_BLOB
sReplStructField aDsReplOp[] = {
    REPL_STRUCT_INFO(ftimeEnqueued,                     dsReplFILETIME),
    REPL_STRUCT_INFO(ulSerialNumber,                    dsReplLONG),
    REPL_STRUCT_INFO(ulPriority,                        dsReplLONG),
    REPL_STRUCT_INFO(OpType,                            dsReplOPTYPE),
    REPL_STRUCT_INFO(ulOptions,                         dsReplLONG),
    REPL_STRUCT_INFO1(pszNamingContext, oszNamingContext, dsReplString),
    REPL_STRUCT_INFO1(pszDsaDN, oszDsaDN,               dsReplString),
    REPL_STRUCT_INFO1(pszDsaAddress, oszDsaAddress, dsReplString),
    REPL_STRUCT_INFO(uuidNamingContextObjGuid,          dsReplUUID),
    REPL_STRUCT_INFO(uuidDsaObjGuid,                    dsReplUUID)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#define CURRENT_REPL_STRUCT DS_REPL_KCC_DSA_FAILUREW
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_KCC_DSA_FAILUREW_BLOB
sReplStructField aDsReplKccDsaFailure[] = {
    REPL_STRUCT_INFO1(pszDsaDN, oszDsaDN,               dsReplString),
    REPL_STRUCT_INFO(uuidDsaObjGuid,                    dsReplUUID),
    REPL_STRUCT_INFO(ftimeFirstFailure,                 dsReplFILETIME),
    REPL_STRUCT_INFO(cNumFailures,                      dsReplDWORD),
    REPL_STRUCT_INFO(dwLastResult,                      dsReplDWORD)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#define CURRENT_REPL_STRUCT DS_REPL_QUEUE_STATISTICSW
#define CURRENT_REPL_STRUCT_BLOB DS_REPL_QUEUE_STATISTICSW_BLOB
sReplStructField aDsReplQueueStatistics[] = {
    REPL_STRUCT_INFO(ftimeCurrentOpStarted,             dsReplFILETIME),
    REPL_STRUCT_INFO(cNumPendingOps,                    dsReplDWORD),
    REPL_STRUCT_INFO(ftimeOldestSync,                   dsReplFILETIME),
    REPL_STRUCT_INFO(ftimeOldestAdd,                    dsReplFILETIME),
    REPL_STRUCT_INFO(ftimeOldestDel,                    dsReplFILETIME),
    REPL_STRUCT_INFO(ftimeOldestMod,                    dsReplFILETIME),
    REPL_STRUCT_INFO(ftimeOldestUpdRefs,                dsReplFILETIME)
};

#undef CURRENT_REPL_STRUCT
#undef CURRENT_REPL_STRUCT_BLOB
#undef REPL_STRUCT_INFO
#undef REPL_STRUCT_INFO1

DWORD
Repl_XmlTemplateLength(ReplStructInfo * pRow);

class cReplStructInfo : public tReplStructInfo {
public:

    cReplStructInfo() {
        ReplStructInfo row;
        // dsReplNeighbor
        row.szStructName                                    = L"DS_REPL_NEIGHBOR"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_NEIGHBORW);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_NEIGHBORW_BLOB);
        row.aReplTypeInfo                                   = aDsReplNeighbor;
        row.dwFieldCount                                    = sizeof(aDsReplNeighbor)/sizeof(sReplStructField);
        row.bHasContainerArray                              = TRUE;
        calcRow(&row);
        insert(dsReplNeighbor,row);

        // dsReplCursor
        row.szStructName                                    = L"DS_REPL_CURSOR"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_CURSOR_3W);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_CURSOR_BLOB);
        row.aReplTypeInfo                                   = aDsReplCursor;
        row.dwFieldCount                                    = sizeof(aDsReplCursor)/sizeof(sReplStructField);
        row.bHasContainerArray                              = TRUE;
        calcRow(&row);
        insert(dsReplCursor,row);

        // dsReplAttrMetaData
        row.szStructName                                    = L"DS_REPL_ATTR_META_DATA"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_ATTR_META_DATA_2);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_ATTR_META_DATA_BLOB);
        row.aReplTypeInfo                                   = aDsReplAttrMetaData;
        row.dwFieldCount                                    = sizeof(aDsReplAttrMetaData)/sizeof(sReplStructField);
        row.bHasContainerArray                              = TRUE;
        calcRow(&row);
        insert(dsReplAttrMetaData,row);

        // dsReplAttrValueMetaData
        row.szStructName                                    = L"DS_REPL_VALUE_META_DATA"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_VALUE_META_DATA_2);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_VALUE_META_DATA_BLOB);
        row.aReplTypeInfo                                   = aDsReplAttrValueMetaData;
        row.dwFieldCount                                    = sizeof(aDsReplAttrValueMetaData)/sizeof(sReplStructField);
        row.bHasContainerArray                              = TRUE;
        calcRow(&row);
        insert(dsReplAttrValueMetaData,row);

        // dsReplOp
        row.szStructName                                    = L"DS_REPL_OP"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_OPW);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_OPW_BLOB);
        row.aReplTypeInfo                                   = aDsReplOp;
        row.dwFieldCount                                    = sizeof(aDsReplOp)/sizeof(sReplStructField);
        row.bHasContainerArray                              = TRUE;
        calcRow(&row);
        insert(dsReplOp,row);

        // dsReplKccDsaFailure
        row.szStructName                                    = L"DS_REPL_KCC_DSA_FAILURE"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_KCC_DSA_FAILUREW);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_KCC_DSA_FAILUREW_BLOB);
        row.aReplTypeInfo                                   = aDsReplKccDsaFailure;
        row.dwFieldCount                                    = sizeof(aDsReplKccDsaFailure)/sizeof(sReplStructField);
        row.bHasContainerArray                              = TRUE;
        calcRow(&row);
        insert(dsReplKccDsaFailure,row);

        // dsReplQueueStatistics
        row.szStructName                                    = L"DS_REPL_QUEUE_STATISTICS"; // XML obj name -- do not change
        row.dwSizeof                                        = sizeof(DS_REPL_QUEUE_STATISTICSW);
        row.dwBlobSizeof                                    = sizeof(DS_REPL_QUEUE_STATISTICSW_BLOB);
        row.aReplTypeInfo                                   = aDsReplQueueStatistics;
        row.dwFieldCount                                    = sizeof(aDsReplQueueStatistics)/sizeof(sReplStructField);
        row.bHasContainerArray                              = FALSE;
        calcRow(&row);
        insert(dsReplQueueStatistics,row);
    }

    void
    calcRow(ReplStructInfo * pRow) {
        DWORD i;
        DWORD dwSizeof = 0;

        Assert(ARGUMENT_PRESENT(pRow));
        Assert(ARGUMENT_PRESENT(pRow->aReplTypeInfo));

        // Count the number of pointers
        pRow->dwPtrCount = 0;
        for (i = 0; i < pRow->dwFieldCount; i++)
        {
            dwSizeof += Repl_GetTypeSize(pRow->aReplTypeInfo[i].eType);
            if (Repl_IsPointerType(pRow->aReplTypeInfo[i].eType)) {
                pRow->dwPtrCount ++;
            }
        }

        // Gather the pointer offsets into an array
        pRow->pdwPtrOffsets = NULL;
        if (pRow->dwPtrCount)
        {
            DWORD j;
            pRow->pdwPtrOffsets = (PDWORD) new DWORD[ pRow->dwPtrCount ];
            if (pRow->pdwPtrOffsets == NULL) {
                // ISSUE Jeffparh/Wlees Sept 27, 2000 Memory alloc in constructors
                RaiseException( DSA_MEM_EXCEPTION, 0, 0, NULL );
            }
            for (i = 0, j = 0; j < pRow->dwPtrCount && i < pRow->dwFieldCount; i ++)
            {
                if (Repl_IsPointerType(pRow->aReplTypeInfo[i].eType)) {
                    pRow->pdwPtrOffsets[j] = pRow->aReplTypeInfo[i].dwOffset;
                    j ++;
                }
            }
        }

        // Figure out the lenght of the xml template
        pRow->dwXmlTemplateLength = Repl_XmlTemplateLength(pRow);

        Assert(dwSizeof <= pRow->dwSizeof);
    }

} gmReplStructInfo;

// add "rows" to the ReplContainerArrayInfo "table"
/////////////////////////////////////////////////////////////////////////////////////
class cReplContainerArrayInfo : public tReplContainerArrayInfo {
public:
    cReplContainerArrayInfo() {
        ReplContainerArrayInfo row;

        // dsReplNeighbor
        row.dwOffsetArrayLength                             = offsetof(DS_REPL_NEIGHBORSW,cNumNeighbors);
        row.dwOffsetArray                                   = offsetof(DS_REPL_NEIGHBORSW,rgNeighbor);
        row.dwContainerSize                                 = sizeof(DS_REPL_NEIGHBORSW);
        insert(dsReplNeighbor,row);

        // dsReplCursor
        row.dwOffsetArrayLength                             = offsetof(DS_REPL_CURSORS_3W,cNumCursors);
        row.dwOffsetArray                                   = offsetof(DS_REPL_CURSORS_3W,rgCursor);
        row.dwContainerSize                                 = sizeof(DS_REPL_CURSORS_3W);
        insert(dsReplCursor,row);

        // dsReplAttrMetaData
        row.dwOffsetArrayLength                             = offsetof(DS_REPL_OBJ_META_DATA_2,cNumEntries);
        row.dwOffsetArray                                   = offsetof(DS_REPL_OBJ_META_DATA_2,rgMetaData);
        row.dwContainerSize                                 = sizeof(DS_REPL_OBJ_META_DATA_2);
        insert(dsReplAttrMetaData,row);

        // dsReplAttrValueMetaData
        row.dwOffsetArrayLength                             = offsetof(DS_REPL_ATTR_VALUE_META_DATA_2,cNumEntries);
        row.dwOffsetArray                                   = offsetof(DS_REPL_ATTR_VALUE_META_DATA_2,rgMetaData);
        row.dwContainerSize                                 = sizeof(DS_REPL_ATTR_VALUE_META_DATA_2);
        insert(dsReplAttrValueMetaData,row);

        // dsReplOp
        row.dwOffsetArrayLength                             = offsetof(DS_REPL_PENDING_OPSW,cNumPendingOps);
        row.dwOffsetArray                                   = offsetof(DS_REPL_PENDING_OPSW,rgPendingOp);
        row.dwContainerSize                                 = sizeof(DS_REPL_PENDING_OPSW);
        insert(dsReplOp,row);

        // dsReplKccDsaFailure
        row.dwOffsetArrayLength                             = offsetof(DS_REPL_KCC_DSA_FAILURESW,cNumEntries);
        row.dwOffsetArray                                   = offsetof(DS_REPL_KCC_DSA_FAILURESW,rgDsaFailure);
        row.dwContainerSize                                 = sizeof(DS_REPL_KCC_DSA_FAILURESW);
        insert(dsReplKccDsaFailure,row);
    }
} gmReplContainerArrayInfo;

ATTRTYP
Repl_Info2AttrTyp(DS_REPL_INFO_TYPE infoType)
/*++
Routine Description:
    Maps the replication type identifier used by the RPC functions
    to the attribute id used internally. The function is one to one
    but not onto.

Arguments:
    infoType - repl type id used by RPC

Return Values:
    the attrId used internally

--*/
{
    return gmReplMetaInfoAttrTyp.findRow(infoType);
}

LPCWSTR
Repl_GetLdapCommonName(ATTRTYP attrId, BOOL bBinary)
/*++
Routine Description:
    Returns the attribute name of the attrId which should be used during
    ldap queries.

Arguments:
    attrId - the internal attribute identifier
    bBinary - specifies the binary or XML format.

Return Values:
    The attribute name sutible for use by ldap queires.

--*/
{
    LPCWSTR szCn;

    if (bBinary)
    {
        szCn = gmReplLdapInfo.findRow(attrId).pszLdapCommonNameBinary;
    }
    else
    {
        szCn = gmReplLdapInfo.findRow(attrId).pszLdapCommonNameXml;
    }

    return szCn;
}

BOOL
Repl_IsRootDseAttr(ATTRTYP attrId)
{
    return gmReplLdapInfo.findRow(attrId).bIsRootDseAttribute;
}

BOOL
Repl_IsConstructedReplAttr(ATTRTYP index)
/*++
Routine Description:
    Discovers if an attrId specifies a replication attribute.

Arguments:
    index - the attrId

Return Values:
    TRUE if the attrId is a repl attrId, FALSE otherwise.

--*/
{
    return gmReplLdapInfo.indexExists(index);
}

DS_REPL_STRUCT_TYPE
Repl_Attr2StructTyp(ATTRTYP attrId)
/*++
Routine Description:
    Maps an attrId to the replication structure. This function is
    onto but not one to one.

Arguments:
    attrId - the attrId

Return Values:
    the structId sutible for indexing gmReplStructInfo

--*/
{
    return gmReplLdapInfo.findRow(attrId).eReplStructIndex;
}

DWORD
Repl_GetArrayContainerSize(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    The replication structures come in wrapper array structures. This function
    returns the sizeof that strucutre. Some repl structs have no array container
    structs explicity but that fact is hidden by this function. The size of a
    container array for a struct without one is the size of the struct. This makes
    sense because the container arrays have one struct inside the array struct along
    with the DWORD length field.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    size of the repl struct container array

--*/
{
    DWORD dwSize;
    ReplStructInfo & replStructInfo = gmReplStructInfo.findRow(structId);
    if (replStructInfo.bHasContainerArray)
    {
        ReplContainerArrayInfo & replContainerArrayInfo =
            gmReplContainerArrayInfo.findRow(structId);
        dwSize = replContainerArrayInfo.dwContainerSize;
    }
    else
    {
        dwSize = replStructInfo.dwSizeof;
    }

    return dwSize;
}

DWORD
Repl_GetArrayLength(DS_REPL_STRUCT_TYPE structId, puReplStructArray pStructArray)
/*++
Routine Description:
    Returns the lenght of the repl struct array.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp
    pStructArray - a pointer to the replication structure array. This union includes
        uReplStruct to include those structs without wrapper array structs.

Return Values:
    Returns the lenght of the replication array if the struct has a repl array struct
    wrapper. If there is no array wrapper struct then 1 is returned unless pStructArray
    is NULL in which case zero is returned.


--*/
{
    DWORD dwLen;
    ReplStructInfo & replStructInfo = gmReplStructInfo.findRow(structId);
    if (replStructInfo.bHasContainerArray)
    {
        ReplContainerArrayInfo & replContainerArrayInfo =
            gmReplContainerArrayInfo.findRow(structId);
        // Note that dwLen is a misnomer, since it is a count of elements in the array
        dwLen = *((LPDWORD)((PCHAR)pStructArray + replContainerArrayInfo.dwOffsetArrayLength));
    }
    else
    {
        dwLen = pStructArray ? 1 : 0;
    }

    return dwLen;
}

DWORD
Repl_SetArrayLength(DS_REPL_STRUCT_TYPE structId, puReplStructArray pStructArray, DWORD dwLength)
/*++
Routine Description:
    Sets the array length field in the array wrapper struct if there is one or does nothing if
    there is no array wrapper sturct.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp
    pStructArray - a pointer to the replication structure array. This union includes
        uReplStruct to include those structs without wrapper array structs.
    dwLength - the length of the array

Return Values:

--*/
{
    ReplStructInfo & replStructInfo = gmReplStructInfo.findRow(structId);
    if (replStructInfo.bHasContainerArray)
    {
        ReplContainerArrayInfo & replContainerArrayInfo =
            gmReplContainerArrayInfo.findRow(structId);

        *(PDWORD)((PCHAR)pStructArray + replContainerArrayInfo.dwOffsetArrayLength) = dwLength;
    }
    else
    {
        Assert((dwLength == 1 && pStructArray) ||
               (dwLength == 0 && !pStructArray));
    }

    return 0;
}

void
Repl_GetElemArray(DS_REPL_STRUCT_TYPE structId, puReplStructArray pStructArray, PCHAR *ppElemArray)
/*++
Routine Description:
    Returns a pointer to an array or replication structures given the array wrapper struct.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp
    pStructArray - a pointer to the replication structure array. This union includes
        uReplStruct to include those structs without wrapper array structs.
    ppElemArray - the pointer to the array of replication structures.

Return Values:

--*/
{
    ReplStructInfo & replStructInfo = gmReplStructInfo.findRow(structId);
    if (replStructInfo.bHasContainerArray)
    {
        ReplContainerArrayInfo & replContainerArrayInfo =
            gmReplContainerArrayInfo.findRow(structId);
        *ppElemArray = ((PCHAR)pStructArray + replContainerArrayInfo.dwOffsetArray);
    }
    else
    {
        *ppElemArray = (PCHAR)&pStructArray->singleReplStruct;
    }
}

DWORD
Repl_GetElemSize(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Gets the size of the replication strucure

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    The sizeof the replication structure

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.dwSizeof;
}

DWORD
Repl_GetElemBlobSize(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Gets the size of the replication strucure

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    The sizeof the replication structure

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.dwBlobSizeof;
}

PDWORD
Repl_GetPtrOffsets(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Used to locate the pointers in a replication structure.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    Returns an array of the offsets of pointers in the replication structure
    in acending order.


--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.pdwPtrOffsets;
}

DWORD
Repl_GetPtrCount(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Get the number of pointers in a replication structure.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    Returns the number of pointers in a replication structure

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.dwPtrCount;
}

DWORD
Repl_GetFieldCount(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Get the number of fields in a replication structure.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    Returns the number of fields in a replication structure

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.dwFieldCount;
}

psReplStructField
Repl_GetFieldInfo(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Return information on the fields in a structure.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    Return information on the fields in a structure.

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.aReplTypeInfo;
}


LPCWSTR
Repl_GetStructName(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Yet another access function.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    Returns the name of the structure.

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.szStructName;
}

DWORD
Repl_GetXmlTemplateLength(DS_REPL_STRUCT_TYPE structId)
/*++
Routine Description:
    Yet another access function.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp

Return Values:
    Returns the length of the Xml template w/o any data in it.

--*/
{
    ReplStructInfo & replStructInfo =
        gmReplStructInfo.findRow(structId);

    return replStructInfo.dwXmlTemplateLength;
}

BOOL
Repl_IsPointerType(DS_REPL_DATA_TYPE typeId)
/*++
Routine Description:
    Is the type a pointer.

Arguments:
    typeId - the type id

Return Values:
    TRUE if the type is a pointer, false otherwise

--*/
{
    ReplTypeInfo & replTypeInfo =
        gmReplTypeInfo.findRow(typeId);

    return replTypeInfo.bIsPointer;
}

DWORD
Repl_GetTypeSize(DS_REPL_DATA_TYPE typeId)
/*++
Routine Description:
    Sizeof the field.

Arguments:
    typeId - the type id

Return Values:
    The size of the field

--*/
{
    ReplTypeInfo & replTypeInfo =
        gmReplTypeInfo.findRow(typeId);

    return replTypeInfo.dwSizeof;
}

#define REPL_TOTAL_WCSLEN(repl,str) (repl.str ? wcslen(repl.str) * 2 + 2 : 0)
#define REPL_LOG_STRING(index,repl,str) \
    { if (aPtrLengths) { aPtrLengths[(index)] = (REPL_TOTAL_WCSLEN(repl,str)); } \
      if (pdwSum) { *(pdwSum) += (DWORD)(REPL_TOTAL_WCSLEN(repl,str)); } }
#define REPL_LOG_BLOB(index,len) \
    { if (aPtrLengths) { (aPtrLengths)[(index)] = (len); } \
      if (pdwSum) { *(pdwSum) += (len); } }

void
Repl_GetPtrLengths(DS_REPL_STRUCT_TYPE structId,
                   puReplStruct pReplStruct,
                   DWORD aPtrLengths[],
                   DWORD dwArrLength,
                   PDWORD pdwSum)
/*++
Routine Description:
    Returns the length of the data pointed to by pointers in a replication structure.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp
    pReplStruct - a pointer to the replication structure in question
    aPtrLenghts - an array to hold the pointer lenghts
    dwArrLenght - the lenght of aPtrLenghts. Must be >= the number of pointers
        in the replication structure.

Return Values:


--*/
{
    DWORD dwPtrCount = Repl_GetPtrCount(structId);
    DS_REPL_STRUCT_TYPE structIndex = structId;

    Assert(IMPLIES(aPtrLengths, dwArrLength >= dwPtrCount));

    if (pdwSum) {
        *pdwSum = 0;
    }

    if (0 == dwPtrCount) {
        return;
    }

    switch (structIndex)
    {
    case dsReplNeighbor:
        REPL_LOG_STRING(0, pReplStruct->neighborw, pszNamingContext);
        REPL_LOG_STRING(1, pReplStruct->neighborw, pszSourceDsaDN)
        REPL_LOG_STRING(2, pReplStruct->neighborw, pszSourceDsaAddress)
        REPL_LOG_STRING(3, pReplStruct->neighborw, pszAsyncIntersiteTransportDN)
        break;

    case dsReplAttrMetaData:
        REPL_LOG_STRING(0, pReplStruct->attrMetaData, pszAttributeName)
        REPL_LOG_STRING(1, pReplStruct->attrMetaData, pszLastOriginatingDsaDN);
        break;

    case dsReplAttrValueMetaData:	
        REPL_LOG_STRING(0, pReplStruct->valueMetaData, pszAttributeName);
        REPL_LOG_STRING(1, pReplStruct->valueMetaData, pszObjectDn);
        REPL_LOG_BLOB(2, pReplStruct->valueMetaData.cbData); // All this work for this!
        REPL_LOG_STRING(3, pReplStruct->valueMetaData, pszLastOriginatingDsaDN);
        break;

    case dsReplOp:
        REPL_LOG_STRING(0, pReplStruct->op, pszNamingContext);
        REPL_LOG_STRING(1, pReplStruct->op, pszDsaDN);
        REPL_LOG_STRING(2, pReplStruct->op, pszDsaAddress);
        break;

    case dsReplKccDsaFailure:
        REPL_LOG_STRING(0, pReplStruct->kccFailure, pszDsaDN);
        break;

    case dsReplCursor:
        REPL_LOG_STRING(0, pReplStruct->cursor, pszSourceDsaDN);
        break;

    default:
        Assert(0);
    }
}

BOOL
/*++
Routine Description:
    Inorder to decouple an algorithm from a memory allocation scheme many replication
    functions require the user to allocate any memory and pass it to the algorithm as
    a buffer (pBuffer). The function will return by referance in pdwBufferSize the
    amount of memory it needs unless an error code other than ERROR_MORE_DATA is returned
    in which case zero is returned by referance in pdwBufferSize.

    If NULL is passed in place of the buffer no error code will be returned from the
    replication function. If the buffer is too small then ERROR_MORE_DATA will be returned
    from the replication function.

    This function:

        1. Returns true if the replication function has enough memory to continue or
           false if it should request more memory.
        2. If false is returned then the return code from the replication function should
           return is returned by referance (in pRet) from this function and will either be
           ERROR_SUCCESS if pBuffer is NULL or ERROR_MORE_DATA if pBuffer is too small.
           If true is returned pRet should be ignored and pdwBufferSize is set to 0. The
           replication function should set pdwBufferSize to dwRequired size before returing
           if the function was successful and should leave it as zero if an error occures.
        3. pdwBufferSize is set to dwRequiredSize.

Arguments:
    structId - usually aquired by a call to Repl_Attr2StructTyp
    pReplStruct - a pointer to the replication structure in question
    aPtrLenghts - an array to hold the pointer lenghts
    dwArrLenght - the lenght of aPtrLenghts. Must be >= the number of pointers
        in the replication structure.

Return Values:


--*/
requestLargerBuffer(PCHAR pBuffer, PDWORD pdwBufferSize, DWORD dwRequiredSize, PDWORD pRet)
{
    Assert(ARGUMENT_PRESENT(pRet));
    Assert(ARGUMENT_PRESENT(pdwBufferSize));

    *pRet = ERROR_SUCCESS;
    if (!pBuffer) {
        *pdwBufferSize = dwRequiredSize;
        *pRet = ERROR_SUCCESS;
        return TRUE;
    }
    else if(*pdwBufferSize < dwRequiredSize) {
        *pdwBufferSize = dwRequiredSize;
        *pRet = ERROR_MORE_DATA;
        return TRUE;
    }
    *pdwBufferSize = 0;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\reptool-collector\forestconfig-retrieve.cpp ===
#include "global.h"



HRESULT partitionObjects(BSTR sourceDCdns, BSTR confDN, BSTR username, BSTR domain, BSTR passwd, IXMLDOMDocument* pXMLDoc, IXMLDOMElement* pPartitionsElem )
//populates the <partitions> node with the list of <partition> nodes
//based on crossRef objects inside the Partitions container
/*
  <partition cn="haifa" type="domain">
    <distinguishedName> CN=HAIFA,CN=Partitions,CN=Configuration,DC=ntdev,DC=microsoft,DC=com </distinguishedName>
    <nCName> DC=haifa,DC=ntdev,DC=microsoft,DC=com </nCName>
  </partition>
  <partition cn=".." type="configuration">
  </partition>
  <partition cn=".." type="schema">
  </partition>
  <partition cn=".." type="application">
  </partition>
*/
//
// returns S_OK iff succesful, if not succesful (due to network or other problems) this
// is a serious error and the collector should rerun the cf() function against some other sourceDC
// or at a later time against the same sourceDC
{
	HRESULT hr,hr1,hr2,hr3,hr4,retHR;
	LPWSTR pszAttr[] = { L"distinguishedName", L"cn", L"nCName", L"systemFlags"};
	IDirectorySearch* pDSSearch;
	ADS_SEARCH_HANDLE hSearch;
	WCHAR objpath[TOOL_MAX_NAME];
	WCHAR cn[TOOL_MAX_NAME];
	WCHAR dn[TOOL_MAX_NAME];
	WCHAR nc[TOOL_MAX_NAME];
	WCHAR temp[TOOL_MAX_NAME];
	int sf;
	_variant_t varValue;


	//issue an ADSI query to retrieve all crossRef objects under the Partitions container
	wcscpy(objpath,L"");
	wcsncat(objpath,L"CN=Partitions,",TOOL_MAX_NAME-wcslen(objpath)-1);
	wcsncat(objpath,confDN,TOOL_MAX_NAME-wcslen(objpath)-1);
//************************   NETWORK PROBLEMS
	hr = ADSIquery(L"LDAP", sourceDCdns,objpath,ADS_SCOPE_ONELEVEL,L"crossRef",pszAttr,sizeof(pszAttr)/sizeof(LPWSTR),username,domain,passwd,&hSearch,&pDSSearch);
//************************
	if( hr != S_OK ) {
//		printf("ADSIquery failed\n");
		return hr;
	};


	//loop through the crossRef objects
	retHR = S_OK;
	while( true ) {

		// get the next crossRef object
//************************   NETWORK PROBLEMS
		hr = pDSSearch->GetNextRow( hSearch );
//************************
		if( hr != S_ADS_NOMORE_ROWS && hr != S_OK ) {
//			printf("GetNextRow failed\n");
			retHR = S_FALSE;
			continue;
		};
		if( hr == S_ADS_NOMORE_ROWS ) // if all objects have been retrieved then STOP
			break;


		//create a new <partition> element
		IXMLDOMElement* pPartElem;
		hr = addElement(pXMLDoc,pPartitionsElem,L"partition",L"",&pPartElem);
		if( hr != S_OK ) {
			printf("addElement failed\n");
			retHR = S_FALSE;
			continue;
		};


		//get distinguished name, common name, NC name of the object
		hr1 = getDNtypeString( pDSSearch, hSearch, L"distinguishedName", dn, sizeof(dn)/sizeof(WCHAR) );
		hr2 = getCItypeString( pDSSearch, hSearch, L"cn", cn, sizeof(cn)/sizeof(WCHAR) );
		hr3 = getDNtypeString( pDSSearch, hSearch, L"nCName", nc, sizeof(nc)/sizeof(WCHAR) );
		hr4 = getINTtypeString( pDSSearch, hSearch, L"systemFlags", &sf);
		if( hr1 != S_OK || hr2 != S_OK || hr3 != S_OK || hr4 != S_OK ) {
			printf("get??typeString failed\n");
			retHR = S_FALSE;
			continue;
		};
//		printf("   %S\n",dn);
//		printf("   %S\n",cn);
//		printf("   %S\n",nc);
//		printf("   %d\n",sf);


		//set the cn attribute of <partition> to the common name of the site
		varValue = cn;
		hr = pPartElem->setAttribute(L"cn",varValue);
		if( hr != S_OK ) {
			printf("setAttribute failed\n");
			retHR = S_FALSE;
			continue;
		};


		//determine the type of the partition based on the value of systemFlags
		varValue = L"unknown";
		if( wcscmp(confDN,nc) == 0 ) {
			// this is a configuration partition
			varValue = L"configuration";
		}
		else {
			wcscpy(temp,L"");
			wcsncat(temp,L"CN=Schema,",TOOL_MAX_NAME-wcslen(temp)-1);
			wcsncat(temp,confDN,TOOL_MAX_NAME-wcslen(temp)-1);
			if( wcscmp(temp,nc) == 0 ) {
				// this is a schema partition
				varValue = L"schema";
			}
			else {
				if( ((sf & 2) > 0) && ((sf & 1) > 0) ) {
					// this is a domain partition
					varValue = L"domain";
				}
				else {
					// this is an application partition
					//there may ba a problem that we assign schema or confing partitions to be application partitions
					//if their dn has changed since we set the valu of confDN when contacting RootDSE of the source machine
					//this is rare, so we ignore it
					varValue = L"application";
				}

			};
		};
		hr = pPartElem->setAttribute(L"type",varValue);
		if( hr != S_OK ) {
			printf("setAttribute failed\n");
			retHR = S_FALSE;
			continue;
		};


		//add a distinguished name and a naming context elements under the <partition>
		IXMLDOMElement* pDNElem;
		IXMLDOMElement* pNCElem;
		hr1 = addElement(pXMLDoc,pPartElem,L"distinguishedName",dn,&pDNElem);
		hr2 = addElement(pXMLDoc,pPartElem,L"nCName",nc,&pNCElem);
		if( hr1 != S_OK || hr2 != S_OK ) {
			printf("addElement failed\n");
			retHR = S_FALSE;
			continue;
		};



	};

	//end the current search
	hr = pDSSearch->CloseSearchHandle(hSearch);
	if( hr != S_OK ) {
		printf("CloseSearchHandle failed\n");
		retHR = S_FALSE;
	};
	pDSSearch->Release();

	return retHR;
}





HRESULT siteObjects(BSTR sourceDCdns, BSTR confDN, BSTR username, BSTR domain, BSTR passwd, IXMLDOMDocument* pXMLDoc, IXMLDOMElement* pSitesElem )
//populates the <sites> node with the list of <site> nodes
/*
  <site cn="redmond-haifa">
    <distinguishedName> CN=Redmond-Haifa,CN=Sites,CN=Configuration,DC=ntdev,DC=microsoft,DC=com </distinguishedName>
  </site>
*/
//
// returns S_OK iff succesful, if not succesful (due to network or other problems) this
// is a serious error and the collector should rerun the cf() function against some other sourceDC
// or at a later time against the same sourceDC
{
	HRESULT hr,retHR;
	LPWSTR pszAttrDNCN[] = { L"distinguishedName", L"cn" };
	IDirectorySearch* pDSSearch;
	ADS_SEARCH_HANDLE hSearch;
	WCHAR objpath[TOOL_MAX_NAME];
	WCHAR cn[TOOL_MAX_NAME];
	WCHAR dn[TOOL_MAX_NAME];
	_variant_t varValue;


	//issue an ADSI query to retrieve all site objects under the Sites container
	wcscpy(objpath,L"");
	wcsncat(objpath,L"CN=Sites,",TOOL_MAX_NAME-wcslen(objpath)-1);
	wcsncat(objpath,confDN,TOOL_MAX_NAME-wcslen(objpath)-1);
//************************   NETWORK PROBLEMS
	hr = ADSIquery(L"LDAP", sourceDCdns,objpath,ADS_SCOPE_SUBTREE,L"site",pszAttrDNCN,sizeof(pszAttrDNCN)/sizeof(LPWSTR),username,domain,passwd,&hSearch,&pDSSearch);
//************************
	if( hr != S_OK ) {
//		printf("ADSIquery failed\n");
		return hr;
	};


	//loop through the site objects
	retHR = S_OK;
	while( true ) {

		// get the next site object
//************************   NETWORK PROBLEMS
		hr = pDSSearch->GetNextRow( hSearch );
//************************
		if( hr != S_ADS_NOMORE_ROWS && hr != S_OK ) {
//			printf("GetNextRow failed\n");
			retHR = hr;
			continue;
		};
		if( hr == S_ADS_NOMORE_ROWS ) // if all objects have been retrieved then STOP
			break;


		//create a new <site> element
		IXMLDOMElement* pSiteElem;
		hr = addElement(pXMLDoc,pSitesElem,L"site",L"",&pSiteElem);
		if( hr != S_OK ) {
			printf("addElement failed\n");
			retHR = hr;
			continue;
		};


		//get common name of the site and turn it into lowercase
		hr = getCItypeString( pDSSearch, hSearch, L"cn", cn, sizeof(cn)/sizeof(WCHAR) );
		if( hr != S_OK ) {
			printf("getCommonName failed\n");
			retHR = hr;
			continue;
		};
//		printf("   %S\n",cn);


		//set the cn attribute of <site> to the common name of the site
		varValue = cn;
		hr = pSiteElem->setAttribute(L"cn",varValue);
		if( hr != S_OK ) {
			printf("setAttribute failed\n");
			retHR = hr;
			continue;
		};


		//get distinguished name of the site
		hr = getDNtypeString( pDSSearch, hSearch, L"distinguishedName", dn, sizeof(dn)/sizeof(WCHAR) );
		if( hr != S_OK ) {
			printf("getDistinguishedName failed\n");
			retHR = hr;
			continue;
		};
//		printf("   %S\n",dn);


		//add a distinguished name element under the <site>
		IXMLDOMElement* pDNElem;
		hr = addElement(pXMLDoc,pSiteElem,L"distinguishedName",dn,&pDNElem);
		if( hr != S_OK ) {
			printf("addElement failed\n");
			retHR = hr;
			continue;
		};

	};

	//end the current search
	hr = pDSSearch->CloseSearchHandle(hSearch);
	if( hr != S_OK ) {
		printf("CloseSearchHandle failed\n");
		retHR = hr;
	};
	pDSSearch->Release();

	return retHR;
}





HRESULT serverObjects(BSTR sourceDCdns, BSTR confDN, BSTR username, BSTR domain, BSTR passwd, IXMLDOMDocument* pXMLDoc, IXMLDOMElement* pSitesElem )
//retrieve all server objects in all sites and produces an XML
/*
    <DC cn="haifa-dc-05">
      <distinguishedName> CN=HAIFA-DC-05,CN=Servers,CN=Redmond-Haifa,CN=Sites,CN=Configuration,DC=ntdev,DC=microsoft,DC=com </distinguishedName>
      <dNSHostName> haifa-dc-05.haifa.ntdev.microsoft.com </dNSHostName>
	</DC>
*/
//
// returns S_OK iff succesful, if not succesful (due to network or other problems) this
// is a serious error and the collector should rerun the cf() function against some other sourceDC
// or at a later time against the same sourceDC
{
	HRESULT hr,hr1,hr2,retHR;
	LPWSTR pszAttrDNCNDNS[] = { L"distinguishedName", L"cn", L"dNSHostName" };
	IDirectorySearch* pDSSearch;
	ADS_SEARCH_HANDLE hSearch;
	WCHAR objpath[TOOL_MAX_NAME];
	WCHAR cn[TOOL_MAX_NAME];
	WCHAR dn[TOOL_MAX_NAME];
	WCHAR dns[TOOL_MAX_NAME];
	WCHAR site[TOOL_MAX_NAME];
	WCHAR xpath[TOOL_MAX_NAME];
	_variant_t varValue;


	//issue an ADSI query to retrieve all server objects under the Sites container
	//from the domain controller given by the sourceDCdns DNS Name
	wcscpy(objpath,L"");
	wcsncat(objpath,L"CN=Sites,",TOOL_MAX_NAME-wcslen(objpath)-1);
	wcsncat(objpath,confDN,TOOL_MAX_NAME-wcslen(objpath)-1);
//************************   NETWORK PROBLEMS
	hr = ADSIquery(L"LDAP", sourceDCdns,objpath,ADS_SCOPE_SUBTREE,L"server",pszAttrDNCNDNS,sizeof(pszAttrDNCNDNS)/sizeof(LPWSTR),username,domain,passwd,&hSearch,&pDSSearch);
//************************
	if( hr != S_OK ) {
//		printf("ADSIquery failed\n");
		return hr; // skip listing server objects
	};


	//loop through the server objects
	retHR = S_OK;
	while( true ) {

		// get the next server object
//************************   NETWORK PROBLEMS
		hr = pDSSearch->GetNextRow( hSearch );
//************************
		if( hr != S_ADS_NOMORE_ROWS && hr != S_OK ) {
//			printf("GetNextRow failed\n");
			retHR = hr;
			continue;
		};
		if( hr == S_ADS_NOMORE_ROWS ) // if all objects have been retrieved then STOP
			break;


		//get distinguished name, common name, and DNS name of the server object
		hr = getDNtypeString( pDSSearch, hSearch, L"distinguishedName", dn, sizeof(dn)/sizeof(WCHAR) );
		if( hr != S_OK ) {
			continue; //ignore this server (sometimes demoted servers do not have this attribute)
		};
//printf("   %S\n",dn);
		hr = getCItypeString( pDSSearch, hSearch, L"cn", cn, sizeof(cn)/sizeof(WCHAR) );
		if( hr != S_OK ) {
			continue; //ignore this server (sometimes demoted servers do not have this attribute)
		};
//printf("   %S\n",cn);
		hr = getCItypeString( pDSSearch, hSearch, L"dNSHostName", dns, sizeof(dns)/sizeof(WCHAR) );
		if( hr != S_OK ) {
			continue; //ignore this server (sometimes demoted servers do not have this attribute)
		};
//printf("   %S\n",dns);


		//create an XML element representing the server (possibly a domain controller)
		IXMLDOMElement* pDCElem;
		hr = createTextElement(pXMLDoc,L"DC",L"",&pDCElem);
		if( hr != S_OK ) {
			printf("createTextElement failed\n");
			retHR = hr;
			continue;
		};

		
		//set the cn attribute of <DC> to the common name of the DC
		varValue = cn;
		hr = pDCElem->setAttribute(L"cn",varValue);
		if( hr != S_OK ) {
			printf("setAttribute failed\n");
			retHR = hr;
			continue;
		};


		//add distinguished and DNS name nodes under the DC node
		IXMLDOMElement* pTempElem;
		hr1 = addElement(pXMLDoc,pDCElem,L"distinguishedName",dn,&pTempElem);
		hr2 = addElement(pXMLDoc,pDCElem,L"dNSHostName",dns,&pTempElem);
		if( hr1 != S_OK || hr2 != S_OK ) {
			printf("addElement failed\n");
			retHR = S_FALSE;
			continue;
		};
		
		
		//get the site the server belongs to
		tailncp(dn,site,2,sizeof(site)/sizeof(WCHAR));
//		printf("  site %S\n",site);

		
		//find this site in the XML document (ther must be one
		//site, otherwise topology is not consistent => error)
		IXMLDOMNode* pSiteNode;
		wcscpy(xpath,L"");
		wcsncat(xpath,L"site[distinguishedName=\"",TOOL_MAX_NAME-wcslen(xpath)-1);
		wcsncat(xpath,site,TOOL_MAX_NAME-wcslen(xpath)-1);
		wcsncat(xpath,L"\"]",TOOL_MAX_NAME-wcslen(xpath)-1);
//		printf("  xpath %S\n",xpath);
//************************   LACK OF DATA CONSISTENCY PROBLEMS
		hr = findUniqueNode(pSitesElem,xpath,&pSiteNode);
//************************
		if( hr != S_OK ) {
			printf("findUniqueNode failed\n");
			retHR = hr;
			continue;
		};


		IXMLDOMNode* pTempNode;
		hr = pSiteNode->appendChild(pDCElem,&pTempNode);
		if( hr != S_OK ) {
			printf("appendChild failed\n");
			retHR = hr;
			continue;
		};


	};


	//end the current search
	hr = pDSSearch->CloseSearchHandle(hSearch);
	if( hr != S_OK ) {
		printf("CloseSearchHandle failed\n");
		retHR = hr;
	};
	pDSSearch->Release();

	return retHR;
}






HRESULT partitionDistribution(BSTR sourceDCdns, BSTR confDN, BSTR username, BSTR domain, BSTR passwd, IXMLDOMDocument* pXMLDoc, IXMLDOMElement* pSitesElem )
//retrieve the list of master and partial partitions stored by each DC
//and deposit them into <DC> nodes under the <sites> node given by pSitesElem.
//Here is an example of what the partitionDistribution() function does
/*
    <DC _temp="isDC" cn="haifa-dc-05">
      <distinguishedName> CN=HAIFA-DC-05,CN=Servers,CN=Redmond-Haifa,CN=Sites,CN=Configuration,DC=ntdev,DC=microsoft,DC=com </distinguishedName>
      ...
      <partitions>
        <partition type="rw">
          <nCName> DC=haifa,DC=ntdev,DC=microsoft,DC=com </nCName>
          <nCName> CN=Configuration,DC=ntdev,DC=microsoft,DC=com </nCName>
          <nCName> CN=Schema,CN=Configuration,DC=ntdev,DC=microsoft,DC=com </nCName>
        </partition>
        <partition type="r">
          <nCName> DC=jpn-sysrad,DC=ntdev,DC=microsoft,DC=com </nCName>
          <nCName> DC=ntdev,DC=microsoft,DC=com </nCName>
          <nCName> DC=ntwksta,DC=ntdev,DC=microsoft,DC=com </nCName>
          <nCName> DC=sys-ntgroup,DC=ntdev,DC=microsoft,DC=com </nCName>
        </partition>
      </partitions>
*/
//
// returns S_OK iff succesful, if not succesful (due to network or other problems) this
// is a serious error and the collector should rerun the cf() function against some other sourceDC
// or at a later time against the same sourceDC
{
	HRESULT hr,hr1,hr2,retHR;
	LPWSTR pszAttrDNPart[] = { L"distinguishedName", L"hasPartialReplicaNCs", L"msDS-HasMasterNCs", L"hasMasterNCs" };
	IDirectorySearch* pDSSearch;
	ADS_SEARCH_HANDLE hSearch;
	WCHAR objpath[TOOL_MAX_NAME];
	WCHAR dn[TOOL_MAX_NAME];
	WCHAR server[TOOL_MAX_NAME];
	WCHAR xpath[TOOL_MAX_NAME];
	_variant_t varValue;


	//issue an ADSI query to retrieve all nTDSDSA objects under the Sites container
	//from the domain controller given by the sourceDCdns DNS Name
	wcscpy(objpath,L"");
	wcsncat(objpath,L"CN=Sites,",TOOL_MAX_NAME-wcslen(objpath)-1);
	wcsncat(objpath,confDN,TOOL_MAX_NAME-wcslen(objpath)-1);
//************************   NETWORK PROBLEMS
	hr = ADSIquery(L"LDAP", sourceDCdns,objpath,ADS_SCOPE_SUBTREE,L"nTDSDSA",pszAttrDNPart,sizeof(pszAttrDNPart)/sizeof(LPWSTR),username,domain,passwd,&hSearch,&pDSSearch);
//************************
	if( hr != S_OK ) {
//		printf("ADSIquery failed\n");
		return hr; // do not provide partition distribution
	};


	//loop through all the nTDSDSA objects
	retHR = S_OK;
	while( true ) {

		// get the next nTDSDSA object
//************************   NETWORK PROBLEMS
		hr = pDSSearch->GetNextRow( hSearch );
//************************
		if( hr != S_ADS_NOMORE_ROWS && hr != S_OK ) {
//			printf("GetNextRow failed\n");
			retHR = hr;
			continue;
		};
		if( hr == S_ADS_NOMORE_ROWS ) // if all objects have been retrieved then STOP
			break;


		//get distinguished name of the nTDSDSA object
		hr = getDNtypeString( pDSSearch, hSearch, L"distinguishedName", dn, sizeof(dn)/sizeof(WCHAR) );
		if( hr != S_OK ) {
			printf("getDistinguishedName failed\n");
			retHR = hr;
			continue;
		};
//		printf("   %S\n",dn);


		//create an XML element representing the <partitions>
		IXMLDOMElement* pPartitionsElem;
		hr = createTextElement(pXMLDoc,L"partitions",L"",&pPartitionsElem);
		if( hr != S_OK ) {
			printf("createTextElement failed\n");
			retHR = hr;
			continue;
		};

		
		//add partition of two types under the <partitions> node
		IXMLDOMElement* pPartRWElem;
		IXMLDOMElement* pPartRElem;
		hr1 = addElement(pXMLDoc,pPartitionsElem,L"partition",L"",&pPartRWElem);
		hr2 = addElement(pXMLDoc,pPartitionsElem,L"partition",L"",&pPartRElem);
		if( hr1 != S_OK || hr2 != S_OK ) {
			printf("addElement failed\n");
			retHR = S_FALSE;
			continue;
		};
		varValue = L"rw";
		hr = pPartRWElem->setAttribute(L"type",varValue);
		if( hr != S_OK ) {
			printf("setAttribute failed\n");
			retHR = hr;
			continue;
		};
		varValue = L"r";
		hr = pPartRElem->setAttribute(L"type",varValue);
		if( hr != S_OK ) {
			printf("setAttribute failed\n");
			retHR = hr;
			continue;
		};


		//populate each <partition> node with the with nCName-s
		ADS_SEARCH_COLUMN col;
		PADSVALUE pp;
		int i;
		hr = pDSSearch->GetColumn( hSearch, L"msDS-HasMasterNCs", &col );
                if( FAILED(hr) ){
		    hr = pDSSearch->GetColumn( hSearch, L"hasMasterNCs", &col );
                }
		if( hr == S_OK ) {
			pp = col.pADsValues;
			for( i=0; i<col.dwNumValues; i++) {
				if( pp->dwType != ADSTYPE_DN_STRING ) {
					printf("wrong type\n");
					retHR = S_FALSE;
					continue;
				};
//				printf("%S\n",pp->DNString);
				IXMLDOMElement* pTempElem;
				hr = addElement(pXMLDoc,pPartRWElem,L"nCName",pp->DNString,&pTempElem);
				if( hr != S_OK ) {
					printf("addElement failed\n");
					retHR = hr;
					continue;
				};
				pp++;
			};
			pDSSearch->FreeColumn(&col);
		};
		hr = pDSSearch->GetColumn( hSearch, L"hasPartialReplicaNCs", &col );
		if( hr == S_OK ) {
			pp = col.pADsValues;
			for( i=0; i<col.dwNumValues; i++) {
				if( pp->dwType != ADSTYPE_DN_STRING ) {
					printf("wrong type\n");
					retHR = S_FALSE;
					continue;
				};
//				printf("%S\n",pp->DNString);
				IXMLDOMElement* pTempElem;
				hr = addElement(pXMLDoc,pPartRElem,L"nCName",pp->DNString,&pTempElem);
				if( hr != S_OK ) {
					printf("addElement failed\n");
					retHR = hr;
					continue;
				};
				pp++;
			};
			pDSSearch->FreeColumn(&col);
		};

		
		//get the server under whcih the nTDSDSA object resides
		tailncp(dn,server,1,sizeof(server)/sizeof(WCHAR));
//		printf("  server %S\n",server);

		
		//find this server in the XML document (there must be one
		//server, otherwise topology is not consistent => error)
		IXMLDOMNode* pDCNode;
		wcscpy(xpath,L"");
		wcsncat(xpath,L"site/DC[distinguishedName=\"",TOOL_MAX_NAME-wcslen(xpath)-1);
		wcsncat(xpath,server,TOOL_MAX_NAME-wcslen(xpath)-1);
		wcsncat(xpath,L"\"]",TOOL_MAX_NAME-wcslen(xpath)-1);
//		printf("  xpath %S\n",xpath);
//************************   DATA CONSISTENCY PROBLEMS
		hr = findUniqueNode(pSitesElem,xpath,&pDCNode);
//************************
		if( hr != S_OK ) {
			printf("findUniqueNode failed\n");
			retHR = hr;
			continue;
		};
		IXMLDOMElement* pDCElem;
		hr=pDCNode->QueryInterface(IID_IXMLDOMElement,(void**)&pDCElem );
		if( hr != S_OK ) {
			printf("QueryInterface failed\n");
			retHR = hr;
			continue;	// skip this site
		};


		//append the <partitions> element under the DC node that we have found
		IXMLDOMNode* pTempNode;
		hr = pDCNode->appendChild(pPartitionsElem,&pTempNode);
		if( hr != S_OK ) {
			printf("appendChild failed\n");
			retHR = hr;
			continue;
		};


		//mark that this server is a DC
		varValue = L"isDC";
		hr = pDCElem->setAttribute(L"_temp",varValue);
		if( hr != S_OK ) {
			printf("setAttribute failed\n");
			retHR = hr;
			continue;
		};


	};

	//end the current search
	hr = pDSSearch->CloseSearchHandle(hSearch);
	if( hr != S_OK ) {
		printf("CloseSearchHandle failed\n");
		retHR = hr;
	};
	pDSSearch->Release();
	return retHR;
}







HRESULT setIdentifiers(IXMLDOMDocument* pXMLDoc)
// Assigns unique identifiers to all naming contexts
// and sets the identifiers in the _id attribute.
// The same for all DCs
//
// returns S_OK iff succesful, if not succesful (due to network or other problems) this
// is a serious error and the collector should rerun the cf() function against some other sourceDC
// or at a later time against the same sourceDC
{
	HRESULT hr,retHR;
	WCHAR xpath[TOOL_MAX_NAME];
	_variant_t varValue;

	if( pXMLDoc == NULL )
		return S_FALSE;

	//get the root element of the XML
	IXMLDOMElement* pRootElem;
	hr = pXMLDoc->get_documentElement(&pRootElem);
	if( hr != S_OK )
		return hr;



	
	//set values for the <partitions> subtree
	
	
	// create an enumerattion of all partitions
	IXMLDOMNodeList *resultPartList;
	hr = createEnumeration( pRootElem, L"partitions/partition/nCName", &resultPartList);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		return hr; // skip entire processing
	};


	retHR = S_OK;

	// loop through all partitions using the enumeration
	IXMLDOMNode *pPartNode;
	long id=0;
	while( true ) {
		hr = resultPartList->nextNode(&pPartNode);
		if( hr != S_OK || pPartNode == NULL ) break; // iterations across partition elements have finished


		//the query actually retrives elements not nodes (elements inherit from nodes)
		//so get site element
		IXMLDOMElement* pPartElem;
		hr=pPartNode->QueryInterface(IID_IXMLDOMElement,(void**)&pPartElem );
		if( hr != S_OK ) {
			printf("QueryInterface failed\n");
			retHR = hr;
			continue;	// skip this site
		};

		//set the value of the identifier
		varValue = id;  // this identifier is used by injector
		hr = pPartElem->setAttribute(L"_id",varValue);
		if( hr != S_OK ) {
			printf("addElement failed\n");
			retHR = hr;
			continue;
		};
		id ++;
	};
	resultPartList->Release();
	IXMLDOMElement* pTempElem;
	hr = addElement(pXMLDoc,pRootElem,L"totalNCs",id,&pTempElem);
	if( hr != S_OK ) {
		printf("addElement failed\n");
		retHR = hr;
	};

	
	
	//copy the values from the <partitions> subtree
	//into the <sites> subtree
	
	
	
		// create an enumerattion of all partitions
	IXMLDOMNodeList *resultNCList;
	hr = createEnumeration( pRootElem, L"sites/site/DC/partitions/partition/nCName", &resultNCList);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		return hr; // skip the rest of processing
	};


	// loop through all sites using the enumeration
	IXMLDOMNode *pNCNode;
	while( true ) {
		hr = resultNCList->nextNode(&pNCNode);
		if( hr != S_OK || pNCNode == NULL ) break; // iterations across partition elements have finished


		//the query actually retrives elements not nodes (elements inherit from nodes)
		//so get site element
		IXMLDOMElement* pNCElem;
		hr=pNCNode->QueryInterface(IID_IXMLDOMElement,(void**)&pNCElem );
		if( hr != S_OK ) {
			printf("QueryInterface failed\n");
			retHR = hr;
			continue;	// skip this site
		};


		BSTR NCtext;
		hr = getTextOfNode(pNCElem,&NCtext);
		if( hr != S_OK ) {
			printf("getTextOfNode failed\n");
			retHR = hr;
			continue;	// skip this site
		};

		wcscpy(xpath,L"");
		wcsncat(xpath,L"partitions/partition/nCName[.=\"",TOOL_MAX_NAME-wcslen(xpath)-1);
		wcsncat(xpath,NCtext,TOOL_MAX_NAME-wcslen(xpath)-1);
		wcsncat(xpath,L"\"]",TOOL_MAX_NAME-wcslen(xpath)-1);
//printf("%S\n",xpath);

		
		//find the definition of the NC in the <partitions> subtree
		IXMLDOMNode *pNCDefNode;
//************************   DATA CONSISTENCY PROBLEMS
		hr = findUniqueNode(pRootElem,xpath,&pNCDefNode);
//************************
		if( hr != S_OK ) {
			printf("QueryInterface failed\n");
			retHR = hr;
			continue;	// skip this site
		};



		//get the value of _id attribute for the NCDef Node
		IXMLDOMElement* pNCDefElem;
		hr=pNCDefNode->QueryInterface(IID_IXMLDOMElement,(void**)&pNCDefElem );
		if( hr != S_OK ) {
			printf("QueryInterface failed\n");
			retHR = hr;
			continue;	// skip this site
		};
		pNCDefElem->getAttribute(L"_id",&varValue);
		

		hr = pNCElem->setAttribute(L"_id",varValue);
		if( hr != S_OK ) {
			printf("addElement failed\n");
			retHR = hr;
			continue;
		};

	};
	resultNCList->Release();
	

	


	// create an enumerattion of all dNSHostName elements
	IXMLDOMNodeList *resultDNSList;
	hr = createEnumeration( pRootElem, L"sites/site/DC/dNSHostName", &resultDNSList);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		return hr; // skip the rest of processing
	};


	// loop through all dNSHostName and assign identifiers
	IXMLDOMNode *pDNSNode;
	id=0;
	while( true ) {
		hr = resultDNSList->nextNode(&pDNSNode);
		if( hr != S_OK || pDNSNode == NULL ) break; // iterations across partition elements have finished


		//the query actually retrives elements not nodes (elements inherit from nodes)
		//so get site element
		IXMLDOMElement* pDNSElem;
		hr=pDNSNode->QueryInterface(IID_IXMLDOMElement,(void**)&pDNSElem );
		if( hr != S_OK ) {
			printf("QueryInterface failed\n");
			retHR = hr;
			continue;	// skip this site
		};

		//set the value of the identifier
		varValue = id;  // this identifier is used by injector
		hr = pDNSElem->setAttribute(L"_id",varValue);
		if( hr != S_OK ) {
			printf("addElement failed\n");
			retHR = hr;
			continue;
		};
		id ++;
	};
	hr = addElement(pXMLDoc,pRootElem,L"totalDCs",id,&pTempElem);
	if( hr != S_OK ) {
		printf("addElement failed\n");
		retHR = hr;
	};
	resultDNSList->Release();
	
	
	return retHR;
}





HRESULT cf( BSTR sourceDCdns, BSTR username, BSTR domain, BSTR passwd, IXMLDOMDocument** ppXMLDoc)
// retrieves forest configuration from the machine with DNS name given by sourceDCdns
// using provided credentials
// as a result produces an XML document describing the configuration
//
// returns S_OK iff the XML is constructed
// if the function fails then it is a serious problem, and the XML doc is set to NULL
{
	HRESULT hr,hr1,hr2;
	WCHAR userpath[TOOL_MAX_NAME];
	_variant_t varValue;
	VARIANT varValue1;

	*ppXMLDoc = NULL;

	wcscpy(userpath,L"");
	wcsncat(userpath,domain,TOOL_MAX_NAME-wcslen(userpath)-1);
	wcsncat(userpath,L"\\",TOOL_MAX_NAME-wcslen(userpath)-1);
	wcsncat(userpath,username,TOOL_MAX_NAME-wcslen(userpath)-1);
	
	
	// create DOM where configuration retrieved from the forest will be populated
	IXMLDOMDocument* pXMLDoc;
	IXMLDOMElement* pRootElem;
	hr = createXML( &pXMLDoc, &pRootElem, L"ActiveDirectoryRAT" );
	if( hr != S_OK ) {
		printf("createXML failed\n");
		return( hr );
	};


	//set timestamp attribute on the <replicationLag> node
	BSTR currentTime;
	currentTime = GetSystemTimeAsCIM();
	varValue1.vt = VT_BSTR;
	varValue1.bstrVal = currentTime;
	hr = pRootElem->setAttribute(L"timestamp", varValue1);
	SysFreeString(currentTime);
	if( hr != S_OK ) {
		printf("setAttribute failed\n");
		return hr; //some problems
	};

					
	//create first children of the root
	IXMLDOMElement* pSitesElem;
	IXMLDOMElement* pPartitionsElem;
	hr1 = addElement(pXMLDoc,pRootElem,L"sites",L"",&pSitesElem);
	hr2 = addElement(pXMLDoc,pRootElem,L"partitions",L"",&pPartitionsElem);
	if( hr1 != S_OK || hr2 != S_OK ) {
		printf("addElement failed\n");
		return S_FALSE;
	};


	//find the distingulshed name of the configuration container stored at the machine sourceDCdns
	BSTR confDN;
//************************   NETWORK PROBLEMS
	hr = getStringProperty(sourceDCdns,L"RootDSE",L"configurationNamingContext",username,domain,passwd,&confDN);
//************************
	if( hr != S_OK ) {
//		printf("getStringProperty failed\n");
		return hr;
	};
//	printf("%S\n",confDN);


	//populate the <sites> node with a list of sites
	hr = siteObjects( sourceDCdns,confDN,username,domain,passwd,pXMLDoc,pSitesElem );
	if( hr != S_OK ) {
		printf("siteObjects failed\n");
		return hr;
	};


	//populate each <site> node with <DC> nodes representing server objects that it contains
	hr = serverObjects( sourceDCdns,confDN,username,domain,passwd,pXMLDoc,pSitesElem );
	if( hr != S_OK ) {
		printf("serverObjects failed\n");
		return hr;
	};


	//populate each <DC> node with a list of naming contexts that it stores
	//this determines which server object is a DC
	hr = partitionDistribution( sourceDCdns,confDN,username,domain,passwd,pXMLDoc,pSitesElem );
	if( hr != S_OK ) {
		printf("partitionDistribution failed\n");
		return hr;
	};


	//remove all <DC> nodes that are not domain controllers
	hr = removeNodes(pSitesElem,L"site/DC[@ _temp!=\"isDC\"]");
	if( hr != S_OK ) {
		printf("removeNodes failed\n");
		return hr;
	};
	hr = removeAttributes(pSitesElem,L"site/DC[@ _temp=\"isDC\"]",L"_temp");
	if( hr != S_OK ) {
		printf("removeAttributes failed\n");
		return hr;
	};


	//populate the <partitions> node with a list of partitions
	hr = partitionObjects( sourceDCdns,confDN,username,domain,passwd,pXMLDoc,pPartitionsElem );
	if( hr != S_OK ) {
		printf("partitionObjects failed\n");
		return hr;
	};


	//assign unique identifiers to naming contexts and DNS names of domain controllers
	//this is needed by the inject procedure
	hr = setIdentifiers(pXMLDoc);
	if( hr != S_OK ) {
		printf("setIdentifiers failed\n");
		return hr;
	};


	//configuration retrieved succesfuly
	*ppXMLDoc = pXMLDoc;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\reptool-collector\repsfroms-retrieve.cpp ===
#include "global.h"



HRESULT ra( IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd )
// Retrieves the status of replication agreements from each DC.
// Stores the result inside a <ReplicationAgreements> element under the <DC> element.
// The timestamp denotes when the retrieval took place.
//
// There are three cases of how the function may modify the pXMLDoc document
// as given in the examples of which are below. 1) For each partition 
// of name nCName the function lists sources DCs from which replication occurs,
// when last replication attempt occured,its result (0 means succes),
// when last succesful replicaiton occured, and the number of consecutive failures.
// The case 2) occurs when the function cannot retrieve information about 
// a given naming context from the DC. It may be due network failure or the
// fact that the DC does not store the NC (indicates lack of data consistency).
// The case 3) occurs when the function cannot connect to the DC.
//
// The function removes all prior <ReplicationAgreements> from each <DC>, which
// implicitly removes the <cannotBindError> and <cannotRetrieveNCRAError> errors
//
// Returns S_OK iff succesful (network problems do not cause the function to fail,
// tyically these are lack of mamory problems that make the function fail)
//
/*

1)
	<ReplicationAgreements timestamp="20011213065827.000214+000">
		...
		<partition nCName="CN=Schema,CN=Configuration,DC=aclchange,DC=nttest,DC=microsoft,DC=com">
			...
			<source>
				<distinguishedName>CN=NTALUTHER5,CN=Servers,CN=Default-First-Site-Name,CN=Sites,CN=Configuration,DC=aclchange,DC=nttest,DC=microsoft,DC=com</distinguishedName> 
				<timeOfLastSyncAttempt>20011213065220.000000+000</timeOfLastSyncAttempt> 
				<resultOfLastSync>0</resultOfLastSync> 
				<timeOfLastSuccess>20011213065220.000000+000</timeOfLastSuccess> 
				<numberOfConsecutiveFailures>0</numberOfConsecutiveFailures> 
			</source>
			...


2)
		<partition nCName="CN=Schema,CN=Configuration,DC=aclchange,DC=nttest,DC=microsoft,DC=com">
			<cannotRetrieveNCRAError timestamp="20011212073319.000627+000" hresult="2121"> </cannotRetrieveNCRAError>
		</partition>
		...
	</ReplicationAgreements>



3)
	<ReplicationAgreements timestamp="20011213065827.000214+000">
		<cannotBindError timestamp="20011212073319.000627+000" hresult="2121"> </cannotBindError>
	</ReplicationAgreements>
*/
{
	WCHAR computerName[TOOL_MAX_NAME];
	WCHAR sourceDN[TOOL_MAX_NAME];
	WCHAR num[30];
	HRESULT hr,hr1,hr2,hr3,hr4,hr5,retHR;
	_variant_t varValue1,varValue2;
    RPC_AUTH_IDENTITY_HANDLE hAuthIdentity; // this will contain a handle to credentials
	HANDLE hDS; // this will contain a handle to Directory Service (a specific DC)
	VOID* pInfo;
	BSTR currentTime;


	if( pXMLDoc == NULL )
		return S_FALSE;

	//get the root element of the XML
	IXMLDOMElement* pRootElem;
	hr = pXMLDoc->get_documentElement(&pRootElem);
	if( hr != S_OK )
		return S_FALSE;

	
	//remove all <replicationAgreements> and their children <> from the XML 
	//so that we can populate them from scratch
	hr = removeNodes(pRootElem,L"sites/site/DC/ReplicationAgreements");
	if( hr != S_OK ) {
		printf("removeNodes failed\n");
		return hr;
	};
	

	// create an enumerattion of all DCs from the loaded XML file
	IXMLDOMNodeList *resultDCList=NULL;
	hr = createEnumeration( pRootElem, L"sites/site/DC", &resultDCList);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		return hr;
	};


	//loop through all DCs
	IXMLDOMNode *pDCNode;
    hAuthIdentity=NULL; //must set both to NULL
	hDS=NULL;
	retHR = S_OK;
	while( true ){
		hr = resultDCList->nextNode(&pDCNode);
		if( hr != S_OK || pDCNode == NULL ) break; // iterations across DCs have finished

		
		//release any credentials or bindings used in the previous iteration
		if( hAuthIdentity != NULL ) { //release credentials
			DsFreePasswordCredentials( hAuthIdentity );
			hAuthIdentity = NULL;
		};
		if( hDS != NULL ) { // release binding to previous DC, if any
			DsUnBind( &hDS );
			hDS=NULL;
		};

		
		//we have found a DC, now retrive the DNS Name of the domain controller
		BSTR DNSName;
		hr = getTextOfChild(pDCNode,L"dNSHostName",&DNSName);
		if( hr != S_OK ) {
			printf("getTextOfChild falied\n");
			retHR = hr;
			continue; // some problems => skip this DC
		};
//print for our enjoyment
//		printf("\n--- DC %S\n",DNSName);


		//add a new <ReplicationAgreements> node under the <DC> node
		IXMLDOMElement* pRAsElem;
		hr = addElement(pXMLDoc,pDCNode,L"ReplicationAgreements",L"",&pRAsElem);
		if( hr != S_OK ) {
			printf("addElement falied\n");
			retHR = hr;
			continue; // some problems => skip this DC
		};


		//create credentials that will be used to bind to a DC
		hr = DsMakePasswordCredentialsW(username,domain, passwd, &hAuthIdentity); //does not involve network calls
		if( hr != NO_ERROR ) {
			printf("DsMakePasswordCredentials failed\n");
			retHR = S_FALSE;
			continue;	//skip this DC
		};

		
		// bind to the DC with given credentials
		wcscpy(computerName,L"");
		wcsncat(computerName,L"\\\\",TOOL_MAX_NAME-wcslen(computerName)-1);
		wcsncat(computerName,DNSName,TOOL_MAX_NAME-wcslen(computerName)-1);
//		printf("%S\n",computerName);
//************************   NETWORK PROBLEMS
		hr = DsBindWithCredW( computerName,NULL,hAuthIdentity,&hDS );
//************************
		if( hr != ERROR_SUCCESS ) {
//			printf("DsBindWithCred failed\n");
			IXMLDOMElement* pCCErrElem;
			hr1 = addElement(pXMLDoc,pRAsElem,L"cannotBindError",L"",&pCCErrElem);
			if( hr1 != S_OK ) {
				printf("addElement falied\n");
				retHR = hr1;
				continue; // some problems => skip this DC
			};
			setHRESULT(pCCErrElem,hr);
			continue;	//skip this DC
		};

		
		//enumerate all partitions that this DC holds
		IXMLDOMNodeList* resultPartitionsList=NULL;
		hr = createEnumeration(pDCNode,L"partitions/partition/nCName",&resultPartitionsList);
		if( hr != S_OK ) {
			printf("createEnumeration failed\n");
			retHR = hr;
			continue;	//skip this DC
		};


		//loop through all naming contexts that this DC stores
		IXMLDOMNode *pNCnode;
		pInfo = NULL;
		while( true ) {
			hr = resultPartitionsList->nextNode(&pNCnode);
			if( hr != S_OK || pNCnode == NULL ) break; // iterations across NCs have finished
			

			//release any neighbours structure that was allocated by the previous iteration
			if( pInfo != NULL ) {
				DsReplicaFreeInfo( DS_REPL_INFO_NEIGHBORS, pInfo);
				pInfo=NULL;
			};

			
			//get the string from the <nCName> node
			BSTR nCName;
			hr = getTextOfNode(pNCnode,&nCName);
			if( hr != S_OK ) {
				printf("getTextOfNode failed\n");
				retHR = hr;
				continue;	//skip this DC
			};
//			printf("  >> NC >> %S\n",nCName);


			//add a <partition> element under the RAs element
			//with attributes: timestamp and nCName
			IXMLDOMElement* pPartElem;
			hr = addElement(pXMLDoc,pRAsElem,L"partition",L"",&pPartElem);
			if( hr != S_OK ) {
				printf("addElement falied\n");
				retHR = hr;
				continue; // some problems => skip this DC
			};
			varValue1 = nCName;
			hr1 = pPartElem->setAttribute(L"nCName", varValue1);
			currentTime = GetSystemTimeAsCIM();
			varValue2 = currentTime;
			hr2 = pRAsElem->setAttribute(L"timestamp", varValue2);
			SysFreeString(currentTime);
			if( hr1 != S_OK ) {
				printf("setAttribute failed\n");
				retHR = S_FALSE;
				continue; //some problems => skip this DC
			};


			//retrive the current status of neighbors for the NC from the DC
//************************   NETWORK PROBLEMS
			hr = DsReplicaGetInfoW(
							hDS,
							DS_REPL_INFO_NEIGHBORS,
							nCName,
							NULL,
							&pInfo
						);
//************************
			// if failed to contact the DC then report it in XML
			// it may happen that the DC no longer stores the Naming Context which causes error
			if( hr != ERROR_SUCCESS ) {
//printf("DsReplicaGetInfoW failure\n");
				IXMLDOMElement* pCRErrElem;
				hr1 = addElement(pXMLDoc,pPartElem,L"cannotRetrieveNCRAError",L"",&pCRErrElem);
				if( hr1 != S_OK ) {
					printf("addElement falied\n");
					retHR = hr1;
					continue; // some problems => skip this DC
				};
				setHRESULT(pCRErrElem,hr);
				continue;	//skip this DC
			};

//			printf("Info retrieved ");

			DS_REPL_NEIGHBORSW* ngs = (DS_REPL_NEIGHBORSW*) pInfo;
//						printf("about %d neighbors\n",(ngs->cNumNeighbors));

			DS_REPL_NEIGHBORW* ng = ngs->rgNeighbor;

			for( DWORD i=0; i<(ngs->cNumNeighbors); i++ ) {
//							printf("\n    source number %d\n",i+1);
//							printf("<NTDS>  %S\n", ng->pszSourceDsaDN  );
//							printf("<timeOfLastSync>   %d\n", ng->ftimeLastSyncAttempt   );
//							printf("<resultOfLastSync>   %d\n", ng->dwLastSyncResult   );
//							printf("<timeOfLastSuccess>   %d\n", ng->ftimeLastSyncSuccess   );
//							printf("<numberOfConsecutiveFailures>   %d\n", ng->cNumConsecutiveSyncFailures   );

				//insert a <source> element representing replication status from a DC under the <partition> element
				IXMLDOMElement* pSourceElem;
				hr = addElement(pXMLDoc,pPartElem,L"source",L"",&pSourceElem);
				if( hr != S_OK ) {
					printf("addElement falied\n");
					retHR = hr;
					continue; // some problems => skip this DC
				};

				
				IXMLDOMElement* pElement;
				BSTR time;

				//convert the distinguished name of a NTDS object into DN of
				tailncp(ng->pszSourceDsaDN,sourceDN,1,TOOL_MAX_NAME);
				hr1 = addElement(pXMLDoc,pSourceElem,L"distinguishedName",sourceDN,&pElement);

				time = UTCFileTimeToCIM(ng->ftimeLastSyncAttempt);
				hr2 = addElement(pXMLDoc,pSourceElem,L"timeOfLastSyncAttempt",time,&pElement);
				SysFreeString(time);

				_itow(ng->dwLastSyncResult,num,10);
				hr3 = addElement(pXMLDoc,pSourceElem,L"resultOfLastSync",num,&pElement);

				time = UTCFileTimeToCIM(ng->ftimeLastSyncSuccess);
				hr4 = addElement(pXMLDoc,pSourceElem,L"timeOfLastSuccess",time,&pElement);
				SysFreeString(time);

				_itow(ng->cNumConsecutiveSyncFailures,num,10);
				hr5 = addElement(pXMLDoc,pSourceElem,L"numberOfConsecutiveFailures",num,&pElement);

				if( hr1!=S_OK || hr2!=S_OK || hr3!=S_OK || hr4!=S_OK || hr5!=S_OK ) {
					printf("addTextElement failed\n");
					// set hresult of the <partition> element
					retHR = S_FALSE;
					continue; // some problems => skip this source
				};


				ng++;
			};
	
		};


		if( resultPartitionsList!=NULL )
			resultPartitionsList->Release();

		//release any neighbours structure that was allocated by the previous iteration
		if( pInfo != NULL ) {
			DsReplicaFreeInfo( DS_REPL_INFO_NEIGHBORS, pInfo);
			pInfo=NULL;
		};
		//release handles to a DC and to credentials
		if( hDS != NULL ) { // release binding to previous DC, if any
			DsUnBind( &hDS );
			hDS=NULL;
		};
		if( hAuthIdentity != NULL ) { //release credentials
			DsFreePasswordCredentials( hAuthIdentity );
			hAuthIdentity = NULL;
		};
	}

	if( resultDCList!=NULL )
		resultDCList->Release();


	return retHR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\reptool-collector\istgtopoerrors-retrieve.cpp ===
#include "global.h"

 

//////////////////////////////////////////////////////////////////////////////
//
//  SCODE ParseAuthorityUserArgs
//
//  DESCRIPTION:
//
//  Examines the Authority and User argument and determines the authentication
//  type and possibly extracts the domain name from the user arugment in the
//  NTLM case.  For NTLM, the domain can be at the end of the authentication
//  string, or in the front of the user name, ex;  "redmond\a-davj"
//
//  PARAMETERS:
//
//  ConnType            Returned with the connection type, ie wbem, ntlm
//  AuthArg             Output, contains the domain name
//  UserArg             Output, user name
//  Authority           Input
//  User                Input
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//////////////////////////////////////////////////////////////////////////////
 

SCODE ParseAuthorityUserArgs(BSTR & AuthArg, BSTR & UserArg,BSTR & Authority,BSTR & User)
{


    // Determine the connection type by examining the Authority string
 
    if(!(Authority == NULL || wcslen(Authority) == 0 || !_wcsnicmp(Authority, L"NTLMDOMAIN:",11)))
        return E_INVALIDARG;
 
    // The ntlm case is more complex.  There are four cases
    // 1)  Authority = NTLMDOMAIN:name" and User = "User"
    // 2)  Authority = NULL and User = "User"
    // 3)  Authority = "NTLMDOMAIN:" User = "domain\user"
    // 4)  Authority = NULL and User = "domain\user"
 

    // first step is to determine if there is a backslash in the user name somewhere between the
    // second and second to last character
 
    WCHAR * pSlashInUser = NULL;
    if(User)
    {
        WCHAR * pEnd = User + wcslen(User) - 1;
        for(pSlashInUser = User; pSlashInUser <= pEnd; pSlashInUser++)
            if(*pSlashInUser == L'\\')      // dont think forward slash is allowed!
                break;
        if(pSlashInUser > pEnd)
            pSlashInUser = NULL;
    }
 

    if(Authority && wcslen(Authority) > 11)
    {
        if(pSlashInUser)
            return E_INVALIDARG;
 
        AuthArg = SysAllocString(Authority + 11);
        if(User) UserArg = SysAllocString(User);
        return S_OK;
    }
    else if(pSlashInUser)
    {
        INT_PTR iDomLen = min(MAX_PATH-1, pSlashInUser-User);
        WCHAR cTemp[MAX_PATH];
        wcsncpy(cTemp, User, iDomLen);
        cTemp[iDomLen] = 0;
        AuthArg = SysAllocString(cTemp);
        if(wcslen(pSlashInUser+1))
            UserArg = SysAllocString(pSlashInUser+1);
    }
    else
        if(User) UserArg = SysAllocString(User);
 
    return S_OK;
}
 

//////////////////////////////////////////////////////////////////////////////
//
//  SCODE SetInterfaceSecurity
//
//  DESCRIPTION:
//
//  This routine is used by clients in order to set the identity to be used by a connection.
//  NOTE that setting the security blanket on the interface is not recommended.
//  The clients should typically just call CoInitializeSecurity( NULL, -1, NULL, NULL, 
//  before calling out to WMI.
//
//
//  PARAMETERS:
//
//  pInterface         Interface to be set
//  pDomain           Input, domain
//  pUser                Input, user name
//  pPassword        Input, password.
//  pFrom               Input, if not NULL, then the authentication level of this interface
//                           is used
//  bAuthArg          If pFrom is NULL, then this is the authentication level
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//////////////////////////////////////////////////////////////////////////////

 

HRESULT SetInterfaceSecurity(IUnknown * pInterface, LPWSTR pAuthority, LPWSTR pUser,
                             LPWSTR pPassword, DWORD dwAuthLevel, DWORD dwImpLevel)
{
 
    SCODE sc;
    if(pInterface == NULL)
        return E_INVALIDARG;
 
    // If we are lowering the security, no need to deal with the identification info
 
    if(dwAuthLevel == RPC_C_AUTHN_LEVEL_NONE)
        return CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
 
    // If we are doing trivial case, just pass in a null authentication structure which is used
    // if the current logged in user's credentials are OK.
 
    if((pAuthority == NULL || wcslen(pAuthority) < 1) &&
        (pUser == NULL || wcslen(pUser) < 1) &&
        (pPassword == NULL || wcslen(pPassword) < 1))
            return CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       dwAuthLevel, dwImpLevel, NULL, EOAC_NONE);
 
    // If user, or Authority was passed in, the we need to create an authority argument for the login
 
    COAUTHIDENTITY  authident;
    BSTR AuthArg = NULL, UserArg = NULL;
    sc = ParseAuthorityUserArgs(AuthArg, UserArg, pAuthority, pUser);
    if(sc != S_OK)
        return sc;
 
    memset((void *)&authident,0,sizeof(COAUTHIDENTITY));
 
    if(UserArg)
    {
        authident.UserLength = (ULONG)wcslen(UserArg);
        authident.User = (LPWSTR)UserArg;
    }
    if(AuthArg)
    {
        authident.DomainLength = (ULONG)wcslen(AuthArg);
        authident.Domain = (LPWSTR)AuthArg;
    }
    if(pPassword)
    {
        authident.PasswordLength = (ULONG)wcslen(pPassword);
        authident.Password = (LPWSTR)pPassword;
    }
    authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    sc = CoSetProxyBlanket(pInterface, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                       dwAuthLevel, dwImpLevel, &authident, EOAC_NONE);
 
    if(UserArg)
        SysFreeString(UserArg);
    if(AuthArg)
        SysFreeString(AuthArg);
    return sc;
}

 

 

////////////////////////////////////////////////////////////////////
//
// Get string property from a wbem object
//
////////////////////////////////////////////////////////////////////
 
HRESULT GetStringProperty(IWbemClassObject * pFrom, LPCWSTR propName, BSTR* propValue)
{

	*propValue = NULL;

	if( pFrom == NULL ) {
		printf("GetStringProperty failed\n");
		return S_FALSE;
	};
	
	VARIANT v;
	VariantInit(&v);
		
	HRESULT hr = pFrom->Get(propName, 0, &v, NULL, NULL);
	
	if( hr != WBEM_S_NO_ERROR ) {
		printf("Get failed\n");
		VariantClear(&v);
		return S_FALSE;
	}
		
	if( v.vt != VT_BSTR ) {
		printf("Get failed\n");
		VariantClear(&v);
		return S_FALSE;
	}

	*propValue = SysAllocString(v.bstrVal);
	VariantClear(&v);
	
	return S_OK;
}
 
 

////////////////////////////////////////////////////////////////////
//
// Get string property from a wbem object
//
////////////////////////////////////////////////////////////////////
 
HRESULT GetLongProperty(IWbemClassObject * pFrom, LPCWSTR propName, long* propValue)
{

	*propValue = 0;

	if( pFrom == NULL ) {
		printf("GetStringProperty failed\n");
		return S_FALSE;
	};
	
	VARIANT v;
	VariantInit(&v);
		
	HRESULT hr = pFrom->Get(propName, 0, &v, NULL, NULL);
	
	if( hr != WBEM_S_NO_ERROR ) {
		printf("Get failed\n");
		VariantClear(&v);
		return S_FALSE;
	}
		
	if( v.vt != VT_I4 ) {
		printf("Get failed\n");
		VariantClear(&v);
		return S_FALSE;
	}

	*propValue = v.lVal;
	VariantClear(&v);
	
	return S_OK;
}



////////////////////////////////////////////////////////////////////
//
// Get an array of strings from a wbem object
//
////////////////////////////////////////////////////////////////////
 
HRESULT GetStringArrayProperty(IWbemClassObject * pFrom, LPCWSTR propName, SAFEARRAY** ppOutArray )
// when succesful returns S_OK and an array of string (*outArray)[lbArray], (*outArray)[lbArray+1], ... , (*outArray)[ubArray]
// this array must be freed by calling
{
	HRESULT hr;

	if( pFrom == NULL ) {
		printf("GetStringProperty failed\n");
		return S_FALSE;
	};
	
	VARIANT v;
	VariantInit(&v);
	CIMTYPE vtType;
	hr = pFrom->Get(propName, 0, &v, &vtType, NULL);
	if( hr != WBEM_S_NO_ERROR ) {
		printf("Get failed\n");
		VariantClear(&v);
		return S_FALSE;
	}
		
	if( v.vt != (CIM_FLAG_ARRAY|CIM_STRING) ) {
		printf("Get failed\n");
		VariantClear(&v);
		return S_FALSE;
	}

	*ppOutArray = v.parray;

	return S_OK;
}



////////////////////////////////////////////////////////////////////
//
// Create IWbemServices Pointer to the given namespace. Initialize Security.
//
////////////////////////////////////////////////////////////////////
 
HRESULT CreateIWbemServices(IWbemServices ** ppIWbemServices, BSTR nameSpace, BSTR userName, BSTR password)
// if succesful then returns S_OK and we must release the service by calling (*ppIWbemServices)->Release
// COM must be already initialized
{
 
//	char str[128];     
//	BOOLEAN bResult = 0;
	HRESULT hr = 0;


 	//create a connection to a WMI namespace 
	IWbemLocator *pIWbemLocator = NULL;
    hr = CoCreateInstance(	CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER,
							IID_IWbemLocator, (LPVOID *) &pIWbemLocator) ;
 
	if(hr != S_OK) {
		printf("CoCreateInstance falied %X\n", hr);
		return hr;
	};

 
// this will be inside collector loop


	//connect to WMI using provided credentials (NTLM), if NULL then use current
	//avoid hanging if server is broken by specifying MAX_WAIT
//************************   NETWORK PROBLEMS
	hr = pIWbemLocator->ConnectServer(	_bstr_t(nameSpace), _bstr_t(userName), _bstr_t(password),
//this does not work, why?	hr = pIWbemLocator->ConnectServer(	nameSpace, userName, password,
										NULL, WBEM_FLAG_CONNECT_USE_MAX_WAIT,
										NULL, NULL, ppIWbemServices);
//************************
	if( hr != WBEM_S_NO_ERROR) {
//		printf("ConnectServer failed\n");
		return hr;
	};
	

	//set the security levels on a WMI connection 
// Set the proxy so that impersonation of the client occurs.
	if ( *nameSpace == L'\\' ) { //if it's remote
		hr = SetInterfaceSecurity(	*ppIWbemServices, 0, userName, password, 
									RPC_C_AUTHN_LEVEL_PKT,
									RPC_C_IMP_LEVEL_IMPERSONATE );
		if( hr != S_OK ) {
			//PrintErrorAndExit("SetInterfaceSecurity Failed on ConnectServer", hr, g_dwErrorFlags);
			printf("SetInterfaceSecurity failed\n");
			return hr;
		}
	}
	else { // use blaknet if local 
		hr = CoSetProxyBlanket((*ppIWbemServices),    // proxy
			RPC_C_AUTHN_WINNT,        // authentication service
			NULL,         // authorization service
			NULL,                         // server principle name
			RPC_C_AUTHN_LEVEL_PKT,   // authentication level
			RPC_C_IMP_LEVEL_IMPERSONATE,    // impersonation level
			NULL,                         // identity of the client
			EOAC_NONE );               // capability flags         
		
		if( hr != WBEM_S_NO_ERROR ) {
			printf("CoSetProxyBlanket failed\n");
			return S_FALSE;
		}                                   
	}


	// this will be outside the collector loop
	pIWbemLocator->Release();        
	
	return S_OK;
}

 

 

HRESULT crossSiteIntegrity(IXMLDOMDocument * pXMLDoc, BSTR istgDNSName, BSTR userName, BSTR doman, BSTR password, long timeWindow, IXMLDOMElement** ppRetErrorsElement )
// Verifies cross site topology integrity for a site as reported by the KCC.
// Takes a dns name of an ISTG for the site and
// retrives errors 1311 from its Directory Service
// NT Event Log that have occured during the past timeWindow minutes
// If succesful then produces an XML element:
/*
       <crossSiteTopologyIntegrityErrors timeWindow="....">
          <partition>
             <nCName> DC=ldapadsi,DC=nttest,DC=microsoft,DC=com </nCName>
             <lastTimeGenerated> 20011129194506.000000-480 </lastTimeGenerated>
          </partition>
          <partition>
          </partition>
       </crossSiteTopologyIntegrityErrors>
*/
// that describes if events 1311 where generated during the last timeWindow seconds
// and if so then for which naming context, and when they occured last.
// The function takes credentials which are used to retrieve
// events from the ISTG using WMI.
//
// returns S_OK iff succesful
// if not succesful (due to network or other problems) the function returns a NULL XML element,
// this is is a mild problem and should be reported in the XML file
//
// COM must be initialized before calling the function
{           
	wchar_t  USERNAME[TOOL_MAX_NAME];
	wchar_t  PASSWORD[TOOL_MAX_NAME];
	wchar_t  NAMESPACE[TOOL_MAX_NAME];
	wchar_t  query[TOOL_MAX_NAME];
	_variant_t varValue2;
	BSTR nc[TOOL_MAX_NCS]; // will be used to find latest errors for each nc
	BSTR time[TOOL_MAX_NCS];
	HRESULT hr,hr1,hr2,hr3;
	VARIANT v;
	CIMTYPE vtType;

	
	// initialize to NULL the value that the function will return
	*ppRetErrorsElement = NULL;


	//create the <crossSiteIntegrityErrors> element with "timeWindow" attribute
	IXMLDOMElement* pErrorsElem;
	hr = createTextElement(pXMLDoc,L"crossSiteTopologyIntegrityErrors",L"",&pErrorsElem);
	if( hr != S_OK ) {
		printf("createTextElement failed\n");
		return hr;
	};
	varValue2 = timeWindow;
	hr = pErrorsElem->setAttribute(L"timeWindow", varValue2);
	if( hr != S_OK ) {
		printf("setAttribute failed\n");
		pErrorsElem->Release();
		return hr;
	};


	//construct USERNAME using the doman name and userName
	wcscpy(USERNAME,L"");
	wcsncat(USERNAME,doman,TOOL_MAX_NAME-wcslen(USERNAME)-1);
	wcsncat(USERNAME,L"\\",TOOL_MAX_NAME-wcslen(USERNAME)-1);
	wcsncat(USERNAME,userName,TOOL_MAX_NAME-wcslen(USERNAME)-1);
	//construct PASSWORD
	wcscpy(PASSWORD,L"");
	wcsncat(PASSWORD,password,TOOL_MAX_NAME-wcslen(PASSWORD)-1);
	//construct NAMESPACE using the DNS name of ISTG and a path
	//(we connect to a specific DC using possibly global credentials)
	wcscpy(NAMESPACE,L"");
	wcsncat(NAMESPACE,L"\\\\",TOOL_MAX_NAME-wcslen(NAMESPACE)-1);
	wcsncat(NAMESPACE,istgDNSName,TOOL_MAX_NAME-wcslen(NAMESPACE)-1);
	wcsncat(NAMESPACE,L"\\root\\cimv2",TOOL_MAX_NAME-wcslen(NAMESPACE)-1);
//	printf("USERNAME %S\n",USERNAME);
//	printf("PASSWORD %S\n",PASSWORD);
//	printf("NAMESPACE %S\n",NAMESPACE);
 
	
	//create IWbemServices pointer
	IWbemServices * pIWbemServices = NULL;
//************************   NETWORK PROBLEMS
	hr = CreateIWbemServices(&pIWbemServices, NAMESPACE, USERNAME, PASSWORD );
//************************
	if( hr != S_OK ) {
//		printf( "CreateIWbemServices falied\n");
		pErrorsElem->Release();
		return hr;
	}


	//issue a query to retrive recent 1311 events from the ISTG
	IEnumWbemClassObject *pEnum = NULL;
	wcscpy(query,L"");
	wcsncat(query,L"select * from win32_ntlogevent where logfile = 'Directory Service' AND eventcode=1311 and timewritten>='",TOOL_MAX_NAME-wcslen(query)-1);
	wcsncat(query,GetSystemTimeAsCIM(-timeWindow*60),TOOL_MAX_NAME-wcslen(query)-1);
	wcsncat(query,L"'",TOOL_MAX_NAME-wcslen(query)-1);
//	printf("%S\n",query);
//************************   NETWORK PROBLEMS
	hr = pIWbemServices->ExecQuery(
		_bstr_t( "WQL" ), 
		_bstr_t( query ), 
		WBEM_FLAG_FORWARD_ONLY, 
		NULL, 
		&pEnum
		);
//************************
	if( hr != S_OK || pEnum == NULL ) {
//		printf("ExecQuery failed\n");
		pIWbemServices->Release();
		pErrorsElem->Release();
		if( hr != S_OK ) 
			return hr;
		return( S_FALSE );
	};
//************************   SECURITY PROBLEMS
	hr = SetInterfaceSecurity( pEnum, 0, USERNAME, PASSWORD, RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE );
//************************
	if( hr != S_OK ) {
//		printf("SetInterfaceSecurity faled\n");
		pIWbemServices->Release();
		pErrorsElem->Release();
		return hr ;
	};



	//we need to find the most recent events perteinig to each naming context
	//sieving will be done using a dictionary, which we now set to empty
	for( int i=0; i<TOOL_MAX_NCS; i++)
		nc[i] = NULL;


	//retrieve each event
	IWbemClassObject *pInstance;
	ULONG ulReturned;
	int counter=0;
	while( true ) {


		// get only one event but wait at most 60 seconds
		// later we can try to get a bulk in one invocation of Next 
//************************   NETWORK PROBLEMS
		hr = pEnum->Next( 60000, 1, &pInstance, &ulReturned );
//************************
		if( hr != WBEM_S_NO_ERROR && hr != WBEM_S_FALSE ) {
//			printf("Next failed\n");
			pIWbemServices->Release();
			pErrorsElem->Release();
			return hr ;
		};
		if( hr == WBEM_S_FALSE ) //all events have been retrieved
			break;


		counter++;


		// get the time when the log event was generated
		BSTR timeWri;
		hr = GetStringProperty( pInstance, L"TimeGenerated", &timeWri );
		if( hr != S_OK ) {
			printf( "TimeGenerated failed\n" );
			pIWbemServices->Release();
			pErrorsElem->Release();
			return hr;
		};

			
		//get the naiming contexts that failed
		//for this purpose obtain the array of insertion strings assicated with the NT Log Event
		VariantInit(&v);
		hr = pInstance->Get(L"InsertionStrings", 0, &v, &vtType, NULL);
		if( hr != WBEM_S_NO_ERROR ) {
			printf("Get failed\n");
			VariantClear(&v);
			pIWbemServices->Release();
			pErrorsElem->Release();
			if( hr != S_OK ) 
				return hr;
			return S_FALSE;
		};
		if( v.vt != (CIM_FLAG_ARRAY|CIM_STRING) ) {
			printf("Get failed\n");
			VariantClear(&v);
			pIWbemServices->Release();
			pErrorsElem->Release();
			return S_FALSE;
		};
		SAFEARRAY* safeArray;
		hr = GetStringArrayProperty( pInstance, L"InsertionStrings", &safeArray );
		if( hr != S_OK ) {
			printf("GetStringArrayProperty failed\n");
			pIWbemServices->Release();
			pErrorsElem->Release();
			return hr;
		};


		//loop through all strings in the array (should be only one)
		long iLBound = 0, iUBound = 0;
		BSTR * pbstr = NULL;
		hr1 = SafeArrayAccessData(safeArray, (void**)&pbstr);
		hr2 = SafeArrayGetLBound(safeArray, 1, &iLBound);
		hr3 = SafeArrayGetUBound(safeArray, 1, &iUBound);
		if( hr1 != S_OK || hr2 != S_OK || hr3 != S_OK ) {
			printf("SafeArray failed\n");
			pIWbemServices->Release();
			pErrorsElem->Release();
			return S_FALSE;
		};
		for (long i = iLBound; i <= iUBound; i++) {

//			printf("---\n");
//			printf("  nCName %S\n", pbstr[i]);
//			printf("  timeGenerated %S\n", timeWri);

			//check if the dictionary already has an entry with key pbstr[i]
			//this will be a quadratic in the number of events algorithm - ignore for now
			BOOL has = false;
			int j=0;
			while( j<TOOL_MAX_NCS-1 && nc[j]!=NULL ) {
				if( wcscmp(nc[j],pbstr[i]) == 0 ) {
					has = true;
					break;
				};
				j++;
			};
			// if it has an entry then find out which has later value of TimeGenerated
			if( has ) {
				WBEMTime wt1(time[j]);
				WBEMTime wt2(timeWri);
				if( wt2 > wt1 ) { // newer event
					// release memory of the previous pair
					SysFreeString( nc[j] );
					SysFreeString( time[j] );
					// allocate memory for the new pair
					nc[j] = SysAllocString(pbstr[i]);
					time[j] = SysAllocString(timeWri);
				};
//				printf("  1) %S\n", nc[j] );
//				printf("  1) %S\n", time[j] );
				
			}
			// when the dictionary does not have an entry, create it (new piece of memory is allocated)
			else {
				nc[j] = SysAllocString(pbstr[i]);
				time[j] = SysAllocString(timeWri);
			}

		}
		SafeArrayUnaccessData(safeArray);
	};


//	printf( "Number of events %d\n",counter );


	// put the latest naming contexts for which we had events into XML
	int j=0;
	while( j<TOOL_MAX_NCS-1 && nc[j]!=NULL ) {
//		printf("--\n  1) %S\n", nc[j] );
//		printf("  2) %S\n", time[j] );

		IXMLDOMElement* pPartitionElem;
		hr = addElement(pXMLDoc,pErrorsElem,L"partition",L"",&pPartitionElem);
		if( hr != S_OK ) {
			printf("addElement failed\n");
			pIWbemServices->Release();
			pErrorsElem->Release();
			return hr;
		};
		IXMLDOMElement* pTempElem;
		hr = addElement(pXMLDoc,pPartitionElem,L"nCName",nc[j],&pTempElem);
		if( hr != S_OK ) {
			printf("addElement failed\n");
			pIWbemServices->Release();
			pErrorsElem->Release();
			return hr;
		};
		hr = addElement(pXMLDoc,pPartitionElem,L"lastTimeGenerated",time[j],&pTempElem);
		if( hr != S_OK ) {
			printf("addElement failed\n");
			pIWbemServices->Release();
			pErrorsElem->Release();
			return hr;
		};


		j++;
	};


	pIWbemServices->Release();


	//succesful execution of the function
	*ppRetErrorsElement = pErrorsElem;
	return S_OK;

}

 

 





HRESULT ci( IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd )
// For each ISTG checks the content of its NT Event Log for 1311 errors
// that indicate lack of topology integrity
//
// If a check to an ISTG is succesful then the corresponding <ISTG> element
// is populated with integrity errors for each naming context (there may be no integrity
// errors, in which case the content of <crossSiteTopologyIntegrityErrors> is empty)
// If a check fails (typically due to network problems) then the corresponding <ISTG>
// element is populated with a <cannotConnectError> element that indicates when the 
// check failed and what the hresult was.
//
// The function removes all prior <crossSiteTopologyIntegrityErrors> and <cannotConnectError>
// for each <ISTG>
//
// Returns S_OK iff succesful (network problems do not cause the function to fail,
// tyically these are lack of mamory problems that make the function fail)
//
// EXAMPLE
/*
	<DC>
		<ISTG>
			<crossSiteTopologyIntegrityErrors timeWindow="....">
				...
				<partition>
					<nCName> DC=ldapadsi,DC=nttest,DC=microsoft,DC=com </nCName>
					<lastTimeGenerated> 20011129194506.000000-480 </lastTimeGenerated>
				</partition>
				...
			</crossSiteTopologyIntegrityErrors>
		</ISTG>
	</DC>
...
	<DC>
		<ISTG>
			<cannotConnectError timestamp="20011212073319.000627+000" hresult="2121"> </cannotConnectError>
		</ISTG>
	</DC>
*/
{
	HRESULT hr,hr1,retHR;
	_variant_t varValue0,varValue2;


	if( pXMLDoc == NULL )
		return S_FALSE;

	//get the root element of the XML
	IXMLDOMElement* pRootElem;
	hr = pXMLDoc->get_documentElement(&pRootElem);
	if( hr != S_OK )
		return S_FALSE;


	//remove previous <crossSiteTopologyIntegrityErrors> and <cannotConnectError> elements
	hr = removeNodes(pRootElem,L"sites/site/DC/ISTG/crossSiteTopologyIntegrityErrors");
	if( hr != S_OK ) {
		printf("removeNodes failed\n");
		return hr;
	};
	hr = removeNodes(pRootElem,L"sites/site/DC/ISTG/cannotConnectError");
	if( hr != S_OK ) {
		printf("removeNodes failed\n");
		return hr;
	};


	// create an enumeration of all ISTGs
	IXMLDOMNodeList *resultISTGList;
	hr = createEnumeration( pRootElem, L"sites/site/DC/ISTG", &resultISTGList);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		return hr;
	};


	// loop through all the ISTGs in the config file using the enumeration
	retHR = S_OK;
	IXMLDOMNode *pISTGNode;
	while(1){
		hr = resultISTGList->nextNode(&pISTGNode);
		if( hr != S_OK || pISTGNode == NULL ) break; // iterations across ISTGs have finished


		//the query actually retrieves elements not nodes (elements inherit from nodes)
		//so we can obtain ISTG element
		IXMLDOMElement* pISTGElem;
		hr = pISTGNode->QueryInterface(IID_IXMLDOMElement,(void**)&pISTGElem );
		if( hr != S_OK ) {
			printf("QueryInterface failed\n");
			retHR = hr;
			continue;	// skip this site
		};


		//get DNS Name of the ISTG
		IXMLDOMNode *pDCNode;
		hr = pISTGElem->get_parentNode(&pDCNode);
		if( hr != S_OK ) {
			printf("get_parentNode failed\n");
			retHR = hr;
			continue;	// skip this site
		};
		BSTR DNSname;
		hr = getTextOfChild(pDCNode,L"dNSHostName",&DNSname);
		if( hr != S_OK ) {
			printf("getTextOfChild failed\n");
			retHR = hr;
			continue;	// skip this site
		};
//		printf("SITE\n   %S\n",DNSname);


		// get events 1311 from the Directory Service NT Event Log
		IXMLDOMElement* pErrorsElem;
		hr = crossSiteIntegrity(pXMLDoc,DNSname,username,domain,passwd,120,&pErrorsElem);
		if( hr != S_OK ) {
			// there was a network problem
			IXMLDOMElement* pConnErrElem;
			hr1 = addElement(pXMLDoc,pISTGElem,L"cannotConnectError",L"",&pConnErrElem);
			if( hr1 != S_OK ) {
				retHR = hr1;
				continue;
			};
			setHRESULT(pConnErrElem,hr);
		}
		else {
			//no networks problem while contacting the ISTG
			IXMLDOMNode* pTempNode;
			hr = pISTGElem->appendChild(pErrorsElem,&pTempNode);
			if( hr != S_OK ) {
				printf("appendChild failed\n");
				retHR = hr;
				continue;
			};
		};
	
	};


	return retHR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\reptool-collector\reptoolc.cpp ===
#include "global.h"


void save( IXMLDOMDocument* pXMLDoc )
// save XML to file with timestamped name
{
	HRESULT hr;
	WCHAR fileName[TOOL_MAX_NAME];
	_variant_t varValue;

	BSTR time = GetSystemTimeAsCIM();
	wcscpy(fileName,L"");
	wcsncat(fileName,L"co", TOOL_MAX_NAME-wcslen(fileName)-1 );
	wcsncat(fileName,time, TOOL_MAX_NAME-wcslen(fileName)-1 );
	wcsncat(fileName,L".xml", TOOL_MAX_NAME-wcslen(fileName)-1 );
	SysFreeString(time);
	varValue = fileName;
	hr = pXMLDoc->save(varValue);
	if( hr != S_OK ) {
		printf("save failed\n");
	};
}



HRESULT loadPreferences(char* fileName, WBEMTimeSpan* period, BSTR* sourceDC, LONGLONG* reportLagBeyond, DWORD* configRetryAfter )
{
	LPWSTR pszAttr[TOOL_PROC] = { L"cf",L"istg",L"ci",L"ra",L"it", L"sv" };
	HRESULT hr;

	//load XML with preferences
	IXMLDOMDocument* pXMLPrefDoc;
	IXMLDOMElement* pPrefRootElem;
	hr = loadXML(fileName,&pXMLPrefDoc,&pPrefRootElem);
	if( hr != S_OK ) {
		printf("loadXML failed\n");
		return hr;
	};


	//set probe interval values based on the nodes of XML file
	IXMLDOMNode* pProbeIntNode;
	hr = findUniqueNode(pPrefRootElem,L"probeIntervals",&pProbeIntNode);
	if( hr != S_OK ) {
		printf("findUniqueNode failed\n");
		return hr;
	};

	BSTR intervalText;
	for( int i=0; i<TOOL_PROC; i++ ) {
		hr = getTextOfChild(pProbeIntNode,pszAttr[i],&intervalText);
		if( hr != S_OK ) {
			printf("getTextOfChild failed\n");
			return hr;
		};
		*(period+i) = intervalText;
		printf("%S   @ %S\n",pszAttr[i],intervalText);
	};


	//set the source DC
	IXMLDOMNode* pSourceDCNode;
	hr = findUniqueNode(pPrefRootElem,L"sourceDC",&pSourceDCNode);
	if( hr != S_OK ) {
		printf("findUniqueNode failed\n");
		return hr;
	};
	hr = getTextOfChild(pSourceDCNode,L"dNSHostName",sourceDC);
	if( hr != S_OK ) {
		printf("getTextOfChild failed\n");
		return hr;
	};
	printf("Source DC: %S\n",*sourceDC);

	
	//get the number of seconds beyond which lag is reported
	BSTR temp;
	hr = getTextOfChild(pPrefRootElem,L"reportLagBeyond",&temp);
	if( hr != S_OK ) {
		printf("getTextOfChild failed\n");
		return hr;
	};
	*reportLagBeyond = _wtoi64(temp) * 10000000;
	printf("Report lag beyond %S seconds\n",temp);

	
	//get the number of seconds it takes to retry retrieving configuration 
	//from the sourceDC when retrieving fails
	hr = getTextOfChild(pPrefRootElem,L"configRetryAfter",&temp);
	if( hr != S_OK ) {
		printf("getTextOfChild failed\n");
		return hr;
	};
	*configRetryAfter = _wtoi64(temp) * 1000;
	printf("Retry retrieving configuration after %S seconds\n",temp);

	return S_OK;

}

int _cdecl main(int argc, char* argv[])
{
	IXMLDOMDocument* pXMLDoc;
	HRESULT hr,hr1,hr2,hr3,hr4;
	WBEMTimeSpan period[5];
	BSTR sourceDC;
	LONGLONG reportLagBeyond;
	DWORD configRetryAfter;
    _variant_t var;


	if( argc!=5 ) {
		printf("Usage: reptoolc preferences.xml userName domain password\n");
		return 0;
	};

	
	// initialize a single-thread apartment - needed to use a DOM object (COM)
	hr = CoInitialize(NULL); 
	if( hr != S_OK ){
		return hr;
	};
	//set the default process security level - this is needed by WMI
	hr = CoInitializeSecurity(	NULL, -1, NULL, NULL, 
								RPC_C_AUTHN_LEVEL_DEFAULT, 
								RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 
								EOAC_NONE, 0);
	if( hr != S_OK ) {
		printf("CoInitializeSecurity failed %X\n", hr);
		return hr;
	};


	// convert command line ANSI input parameters into UNICODE
	BSTR file=NULL;
	BSTR username=NULL;
	BSTR domain=NULL;
	BSTR passwd=NULL;
	hr1 = AnsiToUnicode(argv[1],&file);
	hr2 = AnsiToUnicode(argv[2],&username);
	hr3 = AnsiToUnicode(argv[3],&domain);
	hr4 = AnsiToUnicode(argv[4],&passwd);
	if( hr1!=NOERROR || hr2!=NOERROR || hr3!=NOERROR || hr4!=NOERROR ) {
		printf("AnsiToUnicode failed\n");
		goto QUIT;
	};
	
	


	
//	BSTR sourceDC = L"nw15t1.ldapadsi.nttest.microsoft.com";
//	username = L"Administrator";
//	domain = L"aclchange.nttest.microsoft.com";
//	passwd = L"xyz";
//	BSTR sourceDC = L"aluther-s12.aclchange.nttest.microsoft.com";



//	period[0] = L"00000000000001.000000:000";
//	period[1] = L"00000000100101.000000:000";
//	period[2] = L"00000000100101.000000:000";
//	period[3] = L"00000000100115.000000:000";
//	period[4] = L"00000000100105.000000:000";
//	period[5] = L"00000000100105.000000:000";


	printf("\nStarting the periodic health check...\n\n");


	pXMLDoc = NULL;
START:

	
	//loop until we succesfully reprieve configuration information
	while( true ) {

		printf("We load preferences ");
		
		hr = loadPreferences(argv[1],period,&sourceDC,&reportLagBeyond,&configRetryAfter);
		if( hr != S_OK ) {
			printf("loadPreferences failed\n");
			goto QUIT;
		};
		suspendInit();
		
		
		printf(" and run cf\n");
		hr = cf(sourceDC,username,domain,passwd,&pXMLDoc);
		if( hr == S_OK ) // if succesful then stop looping
			break;
		if( hr != S_OK ) {
			printf("cf failed - possibly because the source DC %S is down\n",sourceDC);
		};
		Sleep(configRetryAfter); //try again later
	};


	//perform other tests
	printf(" Then we run and run istg+ci+ra+it+sv\n");
	istg(pXMLDoc,username,domain,passwd);
		printf(".");
	ci(pXMLDoc,username,domain,passwd);
		printf(".");
	ra(pXMLDoc,username,domain,passwd);
		printf(".");
	itInit(pXMLDoc, username, domain, passwd );
		printf(".");
	it(pXMLDoc, username, domain, passwd, reportLagBeyond );
		printf(".");
	sysvol( pXMLDoc,username,domain,passwd );
		printf(".");
	save(pXMLDoc);
		printf("]\n");

	while( true ) {
		int sel = suspend(period);
//		printf("%d ",sel);

		switch( sel ) {
		case 0:
			// clean up because we will restart from scratch
			itFree(pXMLDoc, username, domain, passwd );
			if( pXMLDoc != NULL ) {
				pXMLDoc->Release();
				pXMLDoc = NULL;
			};
			goto START;
			break;
		case 1:
			printf("We run istg+ci ");
			istg(pXMLDoc,username,domain,passwd);
			printf(".");
			ci(pXMLDoc,username,domain,passwd);
			printf(".");
			printf("]\n");
			break;
		case 2:
			printf("We run ci ");
			ci(pXMLDoc,username,domain,passwd);
			printf(".");
			printf("]\n");
			break;
		case 3:
			printf("We run ra ");
			ra(pXMLDoc,username,domain,passwd);
			printf(".");
			printf("]\n");
			break;
		case 4:
			printf("We run it ");
			it(pXMLDoc, username, domain, passwd, reportLagBeyond );
			printf(".");
			printf("]\n");
			break;
		case 5:
			printf("We run sv ");
			sysvol(pXMLDoc, username, domain, passwd );
			printf(".");
			printf("]\n");
			break;
		};
		save(pXMLDoc);
	
	}




	//return
QUIT:
//	arrivalTimeFree()
	if( pXMLDoc != NULL )
		pXMLDoc->Release();
	CoTaskMemFree(file);
	CoTaskMemFree(username);
	CoTaskMemFree(domain);
	CoTaskMemFree(passwd);
	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\reptool-collector\sysvol-latency.cpp ===
#include "global.h"





HRESULT enumerateRec( BSTR fullName, BSTR shortName, IXMLDOMDocument * pXMLDoc, IXMLDOMElement* pStorageElement )
// recursive function that lists the content of folders
// under the folder specified by the name argument
// and stores the result in the DOM object (XML)
// returns S_OK only if success
{
  WIN32_FIND_DATA FindFileData;
  HANDLE hFind;
  WCHAR newShortName[TOOL_MAX_NAME]; // name will never exceed this
  WCHAR newFullName[TOOL_MAX_NAME]; // name will never exceed this
  WCHAR searchName[TOOL_MAX_NAME]; // name will never exceed this
  WCHAR time[30]; // text version of LONGLONG never exceeds 30 characters
  HRESULT hr,retHR;
  _variant_t var;
	ULARGE_INTEGER x;
	LONGLONG zLWT,zCT,zOWT;


//printf("Searching %S\n",fullName);

	//append *.* to the name because we want the entire content of the folder
	wcscpy(searchName,L"");
	wcsncat(searchName,fullName, TOOL_MAX_NAME-wcslen(searchName)-1 );
	wcsncat(searchName,L"\\*.*", TOOL_MAX_NAME-wcslen(searchName)-1 );
//printf ("We search for %S\n", searchName);

	//find the first file in the folder, if error then report in the father element and stop recursion
//************************   NETWORK PROBLEMS
	hFind = FindFirstFile(searchName, &FindFileData);
//************************
	if( hFind == INVALID_HANDLE_VALUE ) {
//printf ("Invalid File Handle for %S. Get Last Error reports %d\n", searchName, GetLastError ());
//printf("FindFirstFile failed\n");
		return(GetLastError());
	};


	retHR = S_OK;
	do {
//printf ("Found a file %S\n", FindFileData.cFileName);

		// skip . and .. files and other files
		if( 
			wcscmp(FindFileData.cFileName,L".")!=0 &&
			wcscmp(FindFileData.cFileName,L"..")!=0 &&
			wcscmp(FindFileData.cFileName,L"DO_NOT_REMOVE_NtFrs_PreInstall_Directory") != 0 
			)
		{


        //construct the full and short name of the file/folder (append fileName after name)
		wcscpy(newFullName,L"");
		wcsncat(newFullName,fullName, TOOL_MAX_NAME-wcslen(newFullName)-1 );
		wcsncat(newFullName,L"\\", TOOL_MAX_NAME-wcslen(newFullName)-1 );
		wcsncat(newFullName,FindFileData.cFileName, TOOL_MAX_NAME-wcslen(newFullName)-1 );
		wcscpy(newShortName,L"");
		wcsncat(newShortName,shortName, TOOL_MAX_NAME-wcslen(newShortName)-1 );
		wcsncat(newShortName,L"\\", TOOL_MAX_NAME-wcslen(newShortName)-1 );
		wcsncat(newShortName,FindFileData.cFileName, TOOL_MAX_NAME-wcslen(newShortName)-1 );
//printf("full name %S\n",newFullName);
//printf("short name %S\n",newShortName);


		//find the Originating Write Time of the file
		x.LowPart = FindFileData.ftLastWriteTime.dwLowDateTime;
		x.HighPart = FindFileData.ftLastWriteTime.dwHighDateTime;
		zLWT = x.QuadPart;
		x.LowPart = FindFileData.ftCreationTime.dwLowDateTime;
		x.HighPart = FindFileData.ftCreationTime.dwHighDateTime;
		zCT = x.QuadPart;
		if( zCT > zLWT )
			zOWT = zCT;
		else
			zOWT = zLWT;


		//create a DOM element that describes the file including timestamps (ONLY FILES, ignore FOLDERS)
	    if( (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0 ) {
			IXMLDOMElement* pFileElement;
			hr = addElement(pXMLDoc,pStorageElement,L"file",L"",&pFileElement);
			if( hr != S_OK ) {
				printf("addElement failed\n");
				retHR = hr;
				continue;  // need to check if the exit condition "while" is evaluated - must be!!!
			};
			var = newShortName;
			hr = pFileElement->setAttribute(L"name", var);
			if( hr != S_OK ) {
				printf("setAttribute failed\n");
				retHR = hr;
				continue;  // need to check if the exit condition "while" is evaluated - must be!!!
			};
			_i64tow(zOWT,time,10);
			var = time;
			hr = pFileElement->setAttribute(L"owt", var);
			if( hr != S_OK ) {
				printf("setAttribute failed\n");
				retHR = hr;
				continue;  // need to check if the exit condition "while" is evaluated - must be!!!
			};
		};



		// if a folder then recursively call the enumarate function
	    if( (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)!=0 ) {
/*
// this is not needed
			//set attribute type of the node to "folder"
			var = L"folder";
			hr1 = pFileElement->setAttribute(L"type", var);
			if( hr1 != S_OK ) {
				printf("setAttribute failed\n");
				retHR = hr;
				continue;  // need to check if the exit condition "while" is evaluated - must be!!!
			};
*/

//printf ("Will search inside %S\n", newFullName);


			hr = enumerateRec(newFullName,newShortName,pXMLDoc,pStorageElement);

			//if the recursive call fails then set hresult for the pElement node
			if( hr != S_OK ) {
//				printf("enumerateRec failed\n");
				retHR = hr;
				continue;  // need to check if the exit condition "while" is evaluated - must be!!!
			};

		}
		// if a file then set the type attribute to "file"
		else {
/*
// this is not needed
			var = L"file";
			hr1 = pFileElement->setAttribute(L"type", var);
*/			
		};

	}

//************************   NETWORK PROBLEMS
  } while( FindNextFile(hFind,&FindFileData) != 0 );
//************************


	//check what caused the do-while loop to exit
	if( GetLastError() != ERROR_NO_MORE_FILES ) {
		//network problems
		retHR = GetLastError();
		// do note return because must close
	};

	FindClose(hFind);

	return(retHR);
}





HRESULT shapshotOfSharesAtDC( IXMLDOMDocument * pXMLDoc, BSTR DNSname, BSTR username, BSTR domain, BSTR passwd, IXMLDOMElement** ppRetSnapshotElem )
// Lists all files in SYSVOL and NETLOGON shares at the DC given by the DNSname,
// and the Originating Write Time for each file (folders are NOT listed).
// The owt if the maximum of the ftLastWriteTime and ftCreationTime attributes of the file.
// As a result produces an XML element that contains the list.
//
// retruns S_OK iff succesful,
// when failure then may return some partial list in *ppRetSnapshotElem
// when total failure, the *ppRetSnapshotElem is NULL
//
// Example of what can be generated
/*
	<sharesAtDC>
		<file name="NETLOGON\corpsec\patch\ITGSecLogOnGPExec.exe" owt="owt="126495477452437409"></file>
		<file name="SYSVOL\haifa.ntdev.microsoft.com\scripts\corpsec\patch\wucrtupd.exe" owt="126495477452437409"></file>
	</sharesAtDC>
*/
{
	WCHAR domainuser[TOOL_MAX_NAME]; // name will never exceed this
	WCHAR remotename[TOOL_MAX_NAME]; // name will never exceed this
	WCHAR foldername[TOOL_MAX_NAME]; // name will never exceed this
	NETRESOURCE ns;
	HRESULT hr,retHR;
	IXMLDOMElement* pSnapshot;


	*ppRetSnapshotElem = NULL;


	//create the element where attributes of files from remote shares will be populated
	hr = createTextElement(pXMLDoc,L"sharesAtDC",L"",&pSnapshot);
	if( hr != S_OK )
		return hr;


	//setup a connection to the remote DC DNSname using credentials
	//if there is a failure ignore it, and let the recursive procedure report problems
	wcscpy(domainuser,L"");
	wcsncat(domainuser,domain,TOOL_MAX_NAME-wcslen(domainuser)-1);
	wcsncat(domainuser,L"\\",TOOL_MAX_NAME-wcslen(domainuser)-1);
	wcsncat(domainuser,username,TOOL_MAX_NAME-wcslen(domainuser)-1);
//printf("%S\n",domainuser);
	wcscpy(remotename,L"\\\\");
	wcsncat(remotename,DNSname,TOOL_MAX_NAME-wcslen(remotename)-1);
	wcsncat(remotename,L"",TOOL_MAX_NAME-wcslen(remotename)-1);
//printf("%S\n",remotename);
	ns.dwScope = 0;
	ns.dwType = RESOURCETYPE_ANY;
	ns.dwDisplayType = 0;
	ns.dwUsage = 0;
	ns.lpLocalName = NULL;
	ns.lpRemoteName = remotename;
	ns.lpComment = NULL;
	ns.lpProvider = NULL;
	hr = WNetAddConnection2(&ns,passwd,domainuser,0);
//	hr = WNetAddConnection2(&ns,L"ldapadsinb",L"ldapadsi.nttest.microsoft.com\\administrator",0);
	if( hr != NO_ERROR ) {
//		printf("WNetAddConnection2 failed\n"); // ignore 
	};


	//enumerate the content of SYSVOL and NETLOGON shares on the remote machine DNSname
	retHR = S_OK;
	wcscpy(foldername,L"\\\\");
	wcsncat(foldername,DNSname, TOOL_MAX_NAME-wcslen(foldername)-1 );
	wcsncat(foldername,L"\\SYSVOL", TOOL_MAX_NAME-wcslen(foldername)-1 );
//printf("%S\n",foldername);
	hr = enumerateRec( foldername, L"SYSVOL", pXMLDoc, pSnapshot);
	if( hr != S_OK )
		retHR = hr;
	wcscpy(foldername,L"\\\\");
	wcsncat(foldername,DNSname, TOOL_MAX_NAME-wcslen(foldername)-1 );
	wcsncat(foldername,L"\\NETLOGON", TOOL_MAX_NAME-wcslen(foldername)-1 );
//printf("%S\n",foldername);
	hr = enumerateRec( foldername, L"NETLOGON", pXMLDoc, pSnapshot);
	if( hr != S_OK )
		retHR = hr;


	// tear down the connection to the DC			
	hr = WNetCancelConnection2(remotename, 0, FALSE);
	if( hr != NO_ERROR ) {
//printf("WNetCancelConnection2 failed\n"); // ignore
	};


	*ppRetSnapshotElem = pSnapshot;
	return retHR;
}






HRESULT sysvol( IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd )
// For each domain partition contacts all DCs that store this partition and retrieves 
// all the files in SYSVOL and NETLOGON shares. Retrieving from some DCs may fail.
// If retrieving from a DC fails or partially fails then this DC obtains
// an element <FRSretrievalError>.
// Even when some part of the retrieving from a DC fails but the procedure is 
// able to retrieve some other files from the DC we still process the files as described below.
// Takes all retrieved files and for each file finds the list of DCs that do not
// have this file and puts them into the <notExistAt> element.
// Takes all retrieved files and for each file finds the maximum, minimum,
// and the second minimum value (if exists) of the Originating Write Time.
// These values are reported as attributes of the <file> element.
// Some files are not reported at all. These are files that converged (maximum=minimum)
// and are present on all domain controllers (even those for which retrieval
// failed partially).
//
// Returns S_OK iff succesful. If not S_OK then usually it means there is lack of memory.
//
// Example
/*
	<DC>
		<FRSretrievalError hresult="5" timestamp="20011226075139.000596+000" />
	</DC>


	<FRS>
		<partition nCName="DC=ldapadsichild,DC=ldapadsi,DC=nttest,DC=microsoft,DC=com" /> 
		<partition nCName="DC=ldapadsi,DC=nttest,DC=microsoft,DC=com">
			<file		name="SYSVOL\......\GptTmpl.inf" 
						maxOwt="20011228023818.000754+000"
						minOwt="20011214205953.000627+000"
						fluxSince="20011228023818.000754+000"
			>

				<notExistAt>
					<dNSHostName>nw15t1.ldapadsi.nttest.microsoft.com</dNSHostName>
				</notExistAt> 

				<notMaxOwtAt>
					<dNSHostName>nw14f2.ldapadsi.nttest.microsoft.com</dNSHostName> 
				</notMaxOwtAt>

			</file>
		</partition>
	</FRS>

*/

{
	WCHAR searchname[TOOL_MAX_NAME];
	WCHAR xpath[TOOL_MAX_NAME];
	WCHAR nameDouble[TOOL_MAX_NAME];
	WCHAR maxlonglong[40];
	HRESULT hr,hr1,hr2,hr3,hr4,retHR;
	_variant_t var;


	_i64tow(MAXLONGLONG,maxlonglong,10);

	//get the root element of the XML
	IXMLDOMElement* pRootElem;
	hr = pXMLDoc->get_documentElement(&pRootElem);
	if( hr != S_OK )
		return S_FALSE;


	//remove <FRSretrievalError> from all DCs
	hr1 = removeNodes(pXMLDoc,L"sites/site/DC/FRSretrievalError");
	hr2 = removeNodes(pXMLDoc,L"FRS");
	if( hr1 != S_OK || hr2 != S_OK ) {
		printf("removeNodes failed\n");
		return S_FALSE;
	};


	//lack of convergence will be reported inside the <FRS> element
	IXMLDOMElement* pFRSElem;
	hr = addElement(pXMLDoc,pRootElem,L"FRS",L"",&pFRSElem);
	if( hr != S_OK ) {
		printf("addElement failed\n");
		return( hr );
	};


	// create an enumerattion of all domain partitions
	IXMLDOMNodeList *resultList;
	hr = createEnumeration(pXMLDoc,L"partitions/partition[@ type = \"domain\"]",&resultList);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		return( hr );
	};


	// loop through all domain partitions using the enumeration
	IXMLDOMNode *pPartitionNode;
	retHR = S_OK;
	while(1){
		hr = resultList->nextNode(&pPartitionNode);
		if( hr != S_OK || pPartitionNode == NULL ) break; // iterations across partition elements have finished


		//get the naming context name from the <nCName> element of the <partition> element
		BSTR nCName;
		hr = getTextOfChild(pPartitionNode,L"nCName",&nCName);
		if( hr != S_OK ) {
			printf("getTextOfChild failed\n");
			retHR = hr;
			continue;	// skip this partition
		};

//printf("%S\n",nCName);


		//create the element where maximal Originating Write Times will be populated
		IXMLDOMElement* pAllFilesElem;
		hr = createTextElement(pXMLDoc,L"partition",L"",&pAllFilesElem);
		if( hr != S_OK ) {
			printf("createTextElement failed\n");
			retHR = hr;
			continue;	// skip this partition
		};
		var = nCName;
		hr = pAllFilesElem->setAttribute(L"nCName",var);
		if( hr != S_OK ) {
			printf("setAttribute failed\n");
			retHR = hr;
			continue;	// skip this partition
		};


		//create the element where succesfully visited DCs will be populated
		IXMLDOMElement* pnotMaxOwtAt;
		IXMLDOMElement* pnotExistAt;
		hr1 = createTextElement(pXMLDoc,L"notMaxOwtAt",L"",&pnotMaxOwtAt);
		hr2 = createTextElement(pXMLDoc,L"notExistAt",L"",&pnotExistAt);
		if( hr1 != S_OK || hr2 != S_OK ) {
			printf("createTextElement failed\n");
			retHR = S_FALSE;
			continue;	// skip this partition
		};


		// for a given domain naming context enumerate all DCs that store it (type="rw")
		wcscpy(searchname,L"sites/site/DC/partitions/partition[@ type=\"rw\"]/nCName[. =\"");
		wcsncat(searchname,nCName, TOOL_MAX_NAME-wcslen(searchname)-1 );
		wcsncat(searchname,L"\"]", TOOL_MAX_NAME-wcslen(searchname)-1 );
//printf("%S\n",searchname);
		IXMLDOMNodeList* resultDCList;
		hr = createEnumeration(pXMLDoc,searchname,&resultDCList);
		if( hr != S_OK ) {
			printf("createEnumeration failed\n");
			retHR = hr;
			continue;	// skip this partition
		};
	
	
		// loop through all DCs using the enumeration
		IXMLDOMNode *pDCchildnode;
		while(1){
			hr = resultDCList->nextNode(&pDCchildnode);
			if( hr != S_OK || pDCchildnode == NULL ) break; // iterations across partition elements have finished


			//obtain the DC node from its grand grand grand child, if error then skip the DC
			IXMLDOMNode *ptPartition,*ptPartitions,*pDC;
			if( pDCchildnode->get_parentNode(&ptPartition) != S_OK ) continue;
			if( ptPartition->get_parentNode(&ptPartitions) != S_OK ) continue;
			if( ptPartitions->get_parentNode(&pDC) != S_OK ) continue;


			//get the DNS name and distinguished name of the DC
			BSTR DNSname,DNname;
			hr1 = getTextOfChild(pDC,L"dNSHostName",&DNSname);
			hr2 = getTextOfChild(pDC,L"distinguishedName",&DNname);
			if( hr1 != S_OK || hr2 != S_OK ) {
				printf("getTextOfChild failed\n");
				retHR = S_FALSE;
				continue;	// skip this partition
			};
//printf("%S\n",DNSname);
//printf("%S\n",DNname);


			//take a snapshot of Originating Write Time of all files in SYSVOL and NETLOGON shares at the DNSname DC 
			IXMLDOMElement* pSnapDC;
//************************   NETWORK PROBLEMS
			hr = shapshotOfSharesAtDC(pXMLDoc,DNSname,username,domain,passwd, &pSnapDC);
//************************
			if( pSnapDC == NULL || hr != S_OK ) {
//printf("shapshotOfSharesAtDC failed\n");

				
				//report that we had problems retrieving info from the DC
				IXMLDOMElement* pErrElem;
				hr1 = addElement(pXMLDoc,pDC,L"FRSretrievalError",L"",&pErrElem);
				if( hr1 != S_OK ) {
					printf("addElement failed");
					retHR = hr1;
					continue;
				};
				setHRESULT(pErrElem,hr);

				//however continue processing if shapshotOfSharesAtDC managed to retrieve
				//partial snapshot from the DC
				if( pSnapDC == NULL )
					continue;	// skip this DC
			};


			//process the result
			IXMLDOMNodeList* resultFileList;
			hr = createEnumeration(pSnapDC,L"file",&resultFileList);
			if( hr != S_OK ) {
				printf("createEnumeration failed\n");
				retHR = hr;
				continue;	// skip this partition
			};


			//at this moment we consider that we have succesfully visited the DC
			//which happens even when retrieval fails partially


			// loop through all the File nodes in the snapshot using the enumeration
			IXMLDOMNode *pFileNode;
			while(1){
				hr = resultFileList->nextNode(&pFileNode);
				if( hr != S_OK || pFileNode == NULL ) break; // iterations across ISTGs have finished

				BSTR name;
				BSTR owtText;
				hr1 = getAttrOfNode(pFileNode,L"name",&name);
				hr2 = getAttrOfNode(pFileNode,L"owt",&owtText);
				if( hr1 != S_OK || hr2 != S_OK ) {
					printf("getAttrOfNode failed\n");
					retHR = S_FALSE;
					continue;
				};
				LONGLONG owt = _wtoi64(owtText);

//printf("%S %S\n",owtText,name);


				//does the file f exist inside the allFiles element?
				IXMLDOMElement* pFileElem;
				doubleSlash(name,nameDouble);
				wcscpy(xpath,L"file[@name=\"");
//				name = L"SYSVOL\\\\haifa.ntdev.microsoft.com\\\\Policies";
				wcsncat(xpath,nameDouble, TOOL_MAX_NAME-wcslen(xpath)-1 );
				wcsncat(xpath,L"\"]", TOOL_MAX_NAME-wcslen(xpath)-1 );
//				wcscpy(xpath,L"file[.>=\"SYSVOL\"]");
//printf("%S\n",xpath);
				hr = findUniqueElem(pAllFilesElem,xpath,&pFileElem);
				if( hr != E_UNEXPECTED && hr != S_OK ) {
					printf("findUniqueElem failed\n");
					retHR = hr;
					continue;
				};



	//CASE ONE

				//no, the file does not exist in the allFiles element => put it there
				if( hr == E_UNEXPECTED ) {
					IXMLDOMElement* pNewFileElem;
					hr = addElement(pXMLDoc,pAllFilesElem,L"file",L"",&pNewFileElem);
					if( hr != S_OK ) {
						printf("addElement failed\n");
						retHR = hr;
						continue;
					};
					var = name;
					hr1 = pNewFileElem->setAttribute(L"name", var);
					var = owtText;
					hr2 = pNewFileElem->setAttribute(L"maxOwt", var); // a new file so maxOwt = minOwt = owt of the file
					hr3 = pNewFileElem->setAttribute(L"minOwt", var);
					var = maxlonglong;
					hr4 = pNewFileElem->setAttribute(L"fluxSince", var);
					if( hr1 != S_OK || hr2 != S_OK || hr3 != S_OK|| hr4 != S_OK ) {
						printf("setAttribute failed\n");
						retHR = S_FALSE;
						continue;
					};
					//this file does not exist on all the DCs that we have visited so far
					IXMLDOMNode* pCloneNode;
					_variant_t vb = true;
					hr = pnotExistAt->cloneNode(vb,&pCloneNode);  // clonning is required because we keep on adding DCs to the list after succesful retrieval from each DC
					if( hr != S_OK ) {
						printf("cloneNode failed\n");
						retHR = hr;
						continue;
					};

//BSTR xml;
//pnotExistAt->get_xml(&xml);
//printf("%S\n",xml);
					
					
					
					IXMLDOMNode* pTempNode;
					hr = pNewFileElem->appendChild(pCloneNode,&pTempNode);
					if( hr != S_OK ) {
						printf("appendChild failed\n");
						retHR = hr;
						continue;
					};


					continue; // NO error here - this is normal continuation
				};


	//CASE TWO

				//yes, the file exists under the allFiles element


				//get the Originating Write Time of the file under the allFiles element
				LONGLONG maxOwt;
				hr = getAttrOfNode(pFileElem,L"maxOwt",&maxOwt);
				if( hr != S_OK ) {
					printf("getAttrOfNode failed\n");
					retHR = hr;
					continue;
				};

//BSTR nameMax;
//getAttrOfNode(pFileElem,L"name",&nameMax);
//printf("%S\n",nameMax);


				//if the Originating Write Time of f is more recent than the one in the allFiles Element
				if( owt > maxOwt ) {
					//  then the DC stores a more recent originating write for file f,
					//  so replace the maxOwt in allFiles element
					//  the divergent DCs are all those
					//  we have succesfully visited so far

					var = owtText;
					hr = pFileElem->setAttribute(L"maxOwt", var);
					if( hr != S_OK ) {
						printf("setAttribute failed\n");
						retHR = hr;
						continue;
					};


					//note that the content of <notExistAt> element remains valid

					// remove the previous divergent replica element (this frees the memory)
					hr = removeNodes(pFileElem,L"notMaxOwtAt");
					if( hr != S_OK ) {
						printf("removeNodes failed\n");
						retHR = hr;
						continue;
					};

					// add new divergent replica element
					IXMLDOMNode* pCloneNode;
					_variant_t vb = true;
					hr = pnotMaxOwtAt->cloneNode(vb,&pCloneNode);  // clonning is required because we keep on adding DCs to the list after succesful retrieval from each DC
					if( hr != S_OK ) {
						printf("cloneNode failed\n");
						retHR = hr;
						continue;
					};
					IXMLDOMNode* pTempNode;
					hr = pFileElem->appendChild(pCloneNode,&pTempNode);
					if( hr != S_OK ) {
						printf("appendChild failed\n");
						retHR = hr;
						continue;
					};

				};


				//if the OWT of f is less recent than the one for f inside allFiles
				if( owt < maxOwt ) {
					// then the update with maximal owt has not propagated to the DC
					// and we have a divergent state of the file
					//(replicas have not converged to a single value),
					// add the DC to the list of replicas with notMaxOwtAt

					// create the <notMaxOwtAt> element, if needed
					IXMLDOMElement* pDRElem;
					hr = addElementIfDoesNotExist(pXMLDoc,pFileElem,L"notMaxOwtAt",L"",&pDRElem);
					if( hr != S_OK ) {
						printf("addElementIfDoesNotExist failed\n");
						retHR = hr;
						continue;
					};
					IXMLDOMElement* pTempElem;
					hr = addElement(pXMLDoc,pDRElem,L"dNSHostName",DNSname,&pTempElem);
					if( hr != S_OK ) {
						printf("addElement failed\n");
						retHR = hr;
						continue;
					};
				};


				//update the minOwt and the fluxSince (i.e., the 2nd min) values for the file in allFiles
				// recall that by definition minOwt is the smallest owt encountered so far
				// and fluxSince is the second smallest owt encountered so far (if does not exist then is MAXLONGLONG)
				LONGLONG minOwt,fluxSince;
				hr1 = getAttrOfNode(pFileElem,L"minOwt",&minOwt);
				hr2 = getAttrOfNode(pFileElem,L"fluxSince",&fluxSince);
				if( hr1 != S_OK || hr2 != S_OK ) {
					printf("getAttrOfNode failed\n");
					retHR = S_FALSE;
					continue;
				};
				if( owt < minOwt ) {  
					fluxSince = minOwt;
					minOwt = owt;
				} else if( minOwt < owt && owt < fluxSince )
					fluxSince = owt;
				hr1 = setAttributeOfNode(pFileElem, L"minOwt", minOwt);
				hr2 = setAttributeOfNode(pFileElem, L"fluxSince", fluxSince);
				if( hr1 != S_OK || hr2 != S_OK ) {
					printf("getAttrOfNode failed\n");
					retHR = S_FALSE;
					continue;
				};


			};

/*
			long len;
			hr = resultFileList->get_length(&len);
			if( hr != S_OK ) {
				printf("get_length failed");
				retHR = hr;
				continue;
			};

printf("%ld\n",len);
*/

			
			resultFileList->Release();




	//CASE THREE
			//for each file f in the list of AllFiles check if f is not
			//in the snapshot and if so then mark in f that DNSname does not have f

			
			
			
			// loop through all the file nodes under the allFiles element
			hr = createEnumeration(pAllFilesElem,L"file",&resultFileList);
			if( hr != S_OK ) {
				printf("createEnumeration failed\n");
				retHR = hr;
				continue;	// skip this partition
			};
			while(1){
				hr = resultFileList->nextNode(&pFileNode);
				if( hr != S_OK || pFileNode == NULL ) break;

				BSTR name;
				hr = getAttrOfNode(pFileNode,L"name",&name);
				if( hr != S_OK ) {
					printf("getAttrOfNode failed\n");
					retHR = hr;
					continue;
				};

//printf("%S %S\n",owtText,name);


				//does the file f exist inside the snapshot?
				IXMLDOMElement* pFileElem;
				doubleSlash(name,nameDouble);
				wcscpy(xpath,L"file[@name=\"");
//				name = L"SYSVOL\\\\haifa.ntdev.microsoft.com\\\\Policies";
				wcsncat(xpath,nameDouble, TOOL_MAX_NAME-wcslen(xpath)-1 );
				wcsncat(xpath,L"\"]", TOOL_MAX_NAME-wcslen(xpath)-1 );
//				wcscpy(xpath,L"file[.>=\"SYSVOL\"]");
//printf("%S\n",xpath);
				hr = findUniqueElem(pSnapDC,xpath,&pFileElem);
				if( hr != E_UNEXPECTED && hr != S_OK ) {
					printf("findUniqueElem failed\n");
					retHR = hr;
					continue;
				};


				//no, the file does not exist inside the snapshot element => 
				if( hr == E_UNEXPECTED ) {
					//so file f has been present at some DC among those that we
					//have visited so far (because it is under the allFiles element)
					//but f is not in the snapshot
					//so we must remember this in the element under allFiles
					// create the <notExistAt> element, if needed
					IXMLDOMElement* pElem;
					hr = addElementIfDoesNotExist(pXMLDoc,pFileNode,L"notExistAt",L"",&pElem);
					if( hr != S_OK ) {
						printf("addElementIfDoesNotExist failed\n");
						retHR = hr;
						continue;
					};
					IXMLDOMElement* pTempElem;
					hr = addElement(pXMLDoc,pElem,L"dNSHostName",DNSname,&pTempElem);
					if( hr != S_OK ) {
						printf("addElement failed\n");
						retHR = hr;
						continue;
					};
				};

			};
			
			
			//add the DC to the list of succesfully visited DC
			IXMLDOMElement* pTempElem;
			hr1 = addElement(pXMLDoc,pnotMaxOwtAt,L"dNSHostName",DNSname,&pTempElem);
			hr2 = addElement(pXMLDoc,pnotExistAt,L"dNSHostName",DNSname,&pTempElem);
			if( hr1 != S_OK || hr2 != S_OK ) {
				printf("addElement failed");
				retHR = S_FALSE;
				continue;
			};


//BSTR xml;
//pMaxElem->get_xml(&xml);
//printf("%S\n",xml);

			//release the result
			pSnapDC->Release();

		
		};


		resultDCList->Release();


		//remove files that are convergent and present on all succesfully visited DCs
		//(i.e., they have maxOWT=minOWT and the <notExistAt> element which is inside
		//the file element does not have any dNSHostName element inside)
		hr = removeNodes(pAllFilesElem,L"file[ (@maxOwt = @minOwt) and not(notExistAt/dNSHostName) ]");
		if( hr != S_OK ) {
			printf("removeNodes failed");
			retHR = hr;
			continue;
		};


		//if max = min then fluxSince does not exist, so remove it
		hr = removeAttributes(pAllFilesElem,L"file[ @maxOwt = @minOwt ]",L"fluxSince");
		if( hr != S_OK ) {
			printf("removeNodes failed");
			retHR = hr;
			continue;
		};


		//report lack of convergence for files in the demain (if any)
		IXMLDOMNode* pTempNode;
		hr = pFRSElem->appendChild(pAllFilesElem,&pTempNode);
		if( hr != S_OK ) {
			printf("appendChild failed");
			retHR = hr;
			continue;
		};


		//release the tree
		pAllFilesElem->Release(); // do we need it ????
		pnotMaxOwtAt->Release();
		pnotExistAt->Release();
	
	
	};


	resultList->Release();


	//convert the LONGLONG time into CIM time
	IXMLDOMNodeList* resultFileList;
	hr = createEnumeration(pRootElem,L"FRS/partition/file",&resultFileList);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		retHR = hr;
	}
	else {
		// loop through all the File elements under the FRS element using the enumeration
		IXMLDOMNode *pFileNode;
		while(1){
			hr = resultFileList->nextNode(&pFileNode);
			if( hr != S_OK || pFileNode == NULL ) break; // iterations across ISTGs have finished


			hr1 = convertLLintoCIM(pFileNode,L"maxOwt");
			hr2 = convertLLintoCIM(pFileNode,L"minOwt");
			convertLLintoCIM(pFileNode,L"fluxSince");
			if( hr1 != S_OK || hr2 != S_OK ) {
				printf("convertLLintoCIM failed");
				retHR = S_FALSE;
				continue;
			};


		};
		resultFileList->Release();
	};


	return retHR;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\reptool-collector\utils.h ===
#define TOOL_MAX_NAME 1000 //maximal lenght of file names and user names, etc.
#define TOOL_MAX_NCS 500 //maximal number of naming contexts
#define TOOL_PROC 6 //the total number of tests
#define TOOL_CYCLIC_BUFFER 1000	//the maximum number of historical injection times kept for each source,


HRESULT __fastcall AnsiToUnicode(LPCSTR pszA, LPOLESTR* ppszW);
HRESULT __fastcall UnicodeToAnsi(LPCOLESTR pszW, LPSTR* ppszA);
HRESULT createEnumeration( IXMLDOMNode* pXMLNode, WCHAR* xpath, IXMLDOMNodeList** ppResultList);
HRESULT createEnumeration( IXMLDOMDocument* pXMLDoc, WCHAR* xpath, IXMLDOMNodeList** ppResultList);
HRESULT loadXML( char* filename, IXMLDOMDocument** pXMLDoc, IXMLDOMElement** pXMLRootElement );
HRESULT loadXMLW( BSTR filename, IXMLDOMDocument** pXMLDoc, IXMLDOMElement** pXMLRootElement );
HRESULT getTextOfNode(IXMLDOMNode* pNode, BSTR* text);
HRESULT getTextOfChild( IXMLDOMNode* pNode, WCHAR* name, BSTR* text);
HRESULT getAttrOfChild( IXMLDOMNode* pNode, WCHAR* childName, WCHAR* attrName, long* value);
HRESULT getAttrOfNode( IXMLDOMNode* pNode, WCHAR* attrName, long* value);
HRESULT getAttrOfNode( IXMLDOMNode* pNode, WCHAR* attrName, BSTR* strValue);
HRESULT getAttrOfNode( IXMLDOMNode* pNode, WCHAR* attrName, LONGLONG* value);
HRESULT setAttributeOfNode(IXMLDOMNode* pNode, WCHAR* name, LONGLONG value);
HRESULT getTypeOfNCNode( IXMLDOMNode* pNode, long* retType);
int	random( int limit );
void tailncp( BSTR input, BSTR output, int num, int n);
HRESULT createTextElement( IXMLDOMDocument * pXMLDoc, BSTR name, BSTR text, IXMLDOMElement** pretElement );
HRESULT createXML( IXMLDOMDocument** ppXMLDoc, IXMLDOMElement** ppRootElem, BSTR rootName);
HRESULT addElement(IXMLDOMDocument* pXMLDoc, IXMLDOMNode* pParent, BSTR name, BSTR value, IXMLDOMElement** ppChildElement);
HRESULT addElement(IXMLDOMDocument* pXMLDoc, IXMLDOMNode* pParent, BSTR name, long value, IXMLDOMElement** ppChildElement);
HRESULT addElementIfDoesNotExist(IXMLDOMDocument* pXMLDoc, IXMLDOMNode* pParent, BSTR name, BSTR value, IXMLDOMElement** ppRetElem);
void rightDigits( int i, wchar_t * output, int num);
BSTR UTCFileTimeToCIM( FILETIME ft );
BSTR UTCFileTimeToCIM( LONGLONG time );
BSTR GetSystemTimeAsCIM();
BSTR GetSystemTimeAsCIM(int deltaSeconds);
HRESULT setHRESULT( IXMLDOMElement* pElem, HRESULT hr );
HRESULT removeNodes( IXMLDOMElement* pRootElement, BSTR XPathSelection );
HRESULT removeNodes( IXMLDOMDocument* pXMLDoc, BSTR XPathSelection );
HRESULT removeAttributes( IXMLDOMElement* pRootElement, BSTR XPathSelection, BSTR attrName );
HRESULT getStringProperty( BSTR DNSName, BSTR object, BSTR property, BSTR username, BSTR domain, BSTR passwd, BSTR* pRetValue );
HRESULT ADSIquery( BSTR protocol, BSTR DNSName, BSTR searchRoot, int scope, BSTR objectCategory, LPWSTR attributesTable[], DWORD sizeOfTable, BSTR username, BSTR domain, BSTR passwd, ADS_SEARCH_HANDLE* pRetHSearch, IDirectorySearch** ppRetDSSearch );
HRESULT getDNtypeString(IDirectorySearch* pDSSearch, ADS_SEARCH_HANDLE hSearch, BSTR stringName, WCHAR* dnOutput, long sizeOutput);
HRESULT getCItypeString(IDirectorySearch* pDSSearch, ADS_SEARCH_HANDLE hSearch, BSTR stringName, WCHAR* cnOutput, long sizeOutput);
HRESULT getINTtypeString(IDirectorySearch* pDSSearch, ADS_SEARCH_HANDLE hSearch, BSTR stringName, int* intOutput);
HRESULT getDNSName(IDirectorySearch* pDSSearch, ADS_SEARCH_HANDLE hSearch, WCHAR* dnsOutput, long sizeOutput);
HRESULT findUniqueNode( IXMLDOMNode* pXMLNode, WCHAR* xpath, IXMLDOMNode** ppRetNode);
HRESULT findUniqueElem( IXMLDOMNode* pXMLNode, WCHAR* xpath, IXMLDOMElement** ppRetElem);
HRESULT findUniqueElem( IXMLDOMDocument* pXMLDoc, WCHAR* xpath, IXMLDOMElement** ppRetElem);

HRESULT cf( BSTR sourceDCdns, BSTR username, BSTR domain, BSTR passwd, IXMLDOMDocument** ppXMLDoc);
HRESULT istg( IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd );
HRESULT ci( IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd );
HRESULT ra( IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd );
HRESULT it(IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd, LONGLONG errorLag );
HRESULT sysvol( IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd );

void suspendInit();
int suspend( WBEMTimeSpan period[]);
HRESULT itInit(IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd );
void itFree(IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd );
HRESULT itInject(IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd );
HRESULT itAnalyze(IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd );
HRESULT itDumpIntoXML(IXMLDOMDocument* pXMLDoc, BSTR username, BSTR domain, BSTR passwd, LONGLONG errorLag );

struct CyclicBuffer
{
	LONGLONG tab[TOOL_CYCLIC_BUFFER];
	int head;
	LONGLONG firstInjection;
};

struct CyclicBufferTable
{
	CyclicBuffer* root;
	int totalDNSs;
	int totalNCs;
};
void cyclicBufferInit( CyclicBuffer* pCB );
void cyclicBufferInsert( CyclicBuffer* pCB, LONGLONG timestamp);
HRESULT cyclicBufferFindNextAfter(CyclicBuffer* pCB, LONGLONG timestamp, LONGLONG* ret);
void cyclicBufferFindLatest(CyclicBuffer* pCB, LONGLONG* ret);
HRESULT departureTimeInit(int totalDNSs, int totalNCs);
void departureTimeFree();
CyclicBuffer* departureTimeGetCB(int dnsID, int ncID);
void departureTimePrint();


struct TimeCube
{
	LONGLONG* aTime;
	long totalDNSs;
	long totalNCs;
};

HRESULT timeCubeInit(TimeCube* timeCube, long totalDNSs, long totalNCs);
void timeCubeFree(TimeCube* timeCube);
LONGLONG timeCubeGet(TimeCube* timeCube, long sourceID, long destinationID, long ncID );
void timeCubePut(TimeCube* timeCube, long sourceID, long destinationID, long ncID, LONGLONG value );
void timeCubePrint(TimeCube* timeCube);


void doubleSlash( WCHAR* inText, WCHAR* outText );
HRESULT convertLLintoCIM(IXMLDOMNode* pNode, BSTR attrName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\ds\src\util\reptool-collector\utils.cpp ===
#include "global.h"



/*
 * AnsiToUnicode converts the ANSI string pszA to a Unicode string
 * and returns the Unicode string through ppszW. Space for the
 * the converted string is allocated by AnsiToUnicode.
 */ 

HRESULT __fastcall AnsiToUnicode(LPCSTR pszA, LPOLESTR* ppszW)
{

    ULONG cCharacters;
    DWORD dwError;

    // If input is null then just return the same.
    if (NULL == pszA)
    {
        *ppszW = NULL;
        return NOERROR;
    }

    // Determine number of wide characters to be allocated for the
    // Unicode string.
    cCharacters =  strlen(pszA)+1;

    // Use of the OLE allocator is required if the resultant Unicode
    // string will be passed to another COM component and if that
    // component will free it. Otherwise you can use your own allocator.
    *ppszW = (LPOLESTR) CoTaskMemAlloc(cCharacters*2);
    if (NULL == *ppszW)
        return E_OUTOFMEMORY;

    // Covert to Unicode.
    if (0 == MultiByteToWideChar(CP_ACP, 0, pszA, cCharacters,
                  *ppszW, cCharacters))
    {
        dwError = GetLastError();
        CoTaskMemFree(*ppszW);
        *ppszW = NULL;
        return HRESULT_FROM_WIN32(dwError);
    }

    return NOERROR;

}


/*
 * UnicodeToAnsi converts the Unicode string pszW to an ANSI string
 * and returns the ANSI string through ppszA. Space for the
 * the converted string is allocated by UnicodeToAnsi.
 */ 

HRESULT __fastcall UnicodeToAnsi(LPCOLESTR pszW, LPSTR* ppszA)
{

    ULONG cbAnsi, cCharacters;
    DWORD dwError;

    // If input is null then just return the same.
    if (pszW == NULL)
    {
        *ppszA = NULL;
        return NOERROR;
    }

    cCharacters = wcslen(pszW)+1;
    // Determine number of bytes to be allocated for ANSI string. An
    // ANSI string can have at most 2 bytes per character (for Double
    // Byte Character Strings.)
    cbAnsi = cCharacters*2;

    // Use of the OLE allocator is not required because the resultant
    // ANSI  string will never be passed to another COM component. You
    // can use your own allocator.
    *ppszA = (LPSTR) CoTaskMemAlloc(cbAnsi);
    if (NULL == *ppszA)
        return E_OUTOFMEMORY;

    // Convert to ANSI.
    if (0 == WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, *ppszA,
                  cbAnsi, NULL, NULL))
    {
        dwError = GetLastError();
        CoTaskMemFree(*ppszA);
        *ppszA = NULL;
        return HRESULT_FROM_WIN32(dwError);
    }
    return NOERROR;

} 


HRESULT createEnumeration( IXMLDOMNode* pXMLNode, WCHAR* xpath, IXMLDOMNodeList** ppResultList)
// creates an enumeration of elements in the DOM tree rooted at pXMLNode
// that satisfy the criterium given by xpath, and resets the selection
// if succesful then retrns S_OK and *ppResultList is a pointer to the resulting
// selection
//   then the resulting list must me released usng (*ppResultList)->Release();
// if not succesful then returns other than S_OK and *ppResultList is NULL
{
	HRESULT hr;

	*ppResultList = NULL;

	IXMLDOMNodeList* pResultList;

	//select the nodes that satisfy the criterium given by xpath
	hr = pXMLNode->selectNodes(xpath,&pResultList);
	if( hr != S_OK ) {
		printf("selectNodes failed\n");
		return( hr );
	};
	//reset the selection (needed so that enumeration works well)
	hr = pResultList->reset();
	if( hr != S_OK ) {
		printf("reset failed\n");
		pResultList->Release();
		return( hr );
	};

	//if succesful return the selection
	*ppResultList = pResultList;
	return( S_OK );
}


HRESULT createEnumeration( IXMLDOMDocument* pXMLDoc, WCHAR* xpath, IXMLDOMNodeList** ppResultList)
// returns S_OK iff succesful, 
//   then the resulting list must me released usng (*ppResultList)->Release();
{
	HRESULT hr;

	if( pXMLDoc == NULL )
		return S_FALSE;


	//get the root element of the XML
	IXMLDOMElement* pRootElem;
	hr = pXMLDoc->get_documentElement(&pRootElem);
	if( hr != S_OK )
		return S_FALSE;

	return( createEnumeration(pRootElem,xpath,ppResultList) );	
}


HRESULT loadXML( char* filename, IXMLDOMDocument** pXMLDoc, IXMLDOMElement** pXMLRootElement )
// loads an XML fiele into a DOM object
// if succesful then returns S_OK and *pXMLDoc points to the newly created document
// and *pDOMRootElement to its root element,
// if failure then returns something other than S_OK and 
// *pXMLDoc and *pDOMRootElement are set to NULL
// COM must be initialized prior to calling the loadXML function
{
	HRESULT hr;


	//set output to NULL
	*pXMLDoc = NULL;
	*pXMLRootElement = NULL;


	// create a DOM object
	IXMLDOMDocument* pXMLtempDoc;
	hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
       IID_IXMLDOMDocument, (void**)&pXMLtempDoc);
	if( hr != S_OK ) {
		printf("CoCreateInstance failed\n");
		return( hr );
	};


	//load an XML file into a DOM object (synchronously)
	_variant_t vLoadFileName  = filename;
	VARIANT_BOOL ret;
	VARIANT_BOOL b_false=false;
	hr = pXMLtempDoc->put_async(b_false);
	if( hr != S_OK ) {
		printf("put_async failed\n");
		pXMLtempDoc->Release();
		return( hr );
	};
	hr = pXMLtempDoc->load(vLoadFileName,&ret);
	if( hr != S_OK || ret!=-1 ) {
		printf("load failed\n");
		pXMLtempDoc->Release();
		return( S_FALSE );
	};


	//find the root element of the DOM object (root of the XML file)
	IXMLDOMElement* pXMLtempRootElement;
	hr = pXMLtempDoc->get_documentElement(&pXMLtempRootElement);
	if( hr != S_OK || pXMLtempRootElement == NULL ) {
		printf("get_documentElement failed\n");
		pXMLtempDoc->Release(); // skip entire processing
		return( S_FALSE );
	};
	

	//loading succeded
	*pXMLDoc = pXMLtempDoc;
	*pXMLRootElement = pXMLtempRootElement;
	return( S_OK );
}


HRESULT loadXMLW( BSTR filename, IXMLDOMDocument** ppXMLDoc, IXMLDOMElement** ppXMLRootElement )
{
	HRESULT hr;
	char* fn=NULL;
	UnicodeToAnsi( filename, &fn );
	hr = loadXML(fn,ppXMLDoc,ppXMLRootElement);
	CoTaskMemFree(fn);
	return 0;
}


HRESULT getTextOfNode(IXMLDOMNode* pNode, BSTR* text)
//
{
	HRESULT hr;
	VARIANT varType;


	*text = NULL;

	//get the list of children, there should be the TEXT child among them
	IXMLDOMNodeList* childList;
	hr = pNode->get_childNodes(&childList);
	if( hr != S_OK ) {
		printf("get_childNodes falied\n");
		return hr;
	};
	hr = childList->reset();
	if( hr != S_OK ) {
		printf("reset falied\n");
		return hr;
	};


	//search for the TEXT child
	IXMLDOMNode *pChildNode;
	while( true ){
		hr = childList->nextNode(&pChildNode);
		if( hr != S_OK || pChildNode == NULL ) break; // iterations across DCs have finished

	    DOMNodeType nt;
		hr = pChildNode->get_nodeType(&nt);
		if( hr != S_OK ) {
			printf("get_nodeType failed\n");
			continue;
		};
		if( nt != NODE_TEXT )
			continue;

		hr = pChildNode->get_nodeValue(&varType);
		if( hr != S_OK ) {
			printf("get_nodeValue failed\n");
			continue;
		};
		if( varType.vt != VT_BSTR ) {
			printf("node type failed\n");
			continue;
		};


		//we have found the text child
		*text = varType.bstrVal;
		return S_OK;
	};

	return S_FALSE;
};



HRESULT getTextOfChild( IXMLDOMNode* pNode, WCHAR* name, BSTR* text)
//obtains the value of the <name> child node of a given node pNode
//and returns it in *text
//returns S_OK when succesful
//otherwise returns something else than S_OK and *text set to NULL
{
	HRESULT hr;
	
	*text = NULL;

	//select one child of the pNode that has a given name
	IXMLDOMNode* resultNode;
	hr = pNode->selectSingleNode(name,&resultNode);
	if( hr != S_OK ) {
		printf("selectSingleNode failed\n");
		return( hr );
	};
	//retrieve the text associated with the child
	hr = getTextOfNode(resultNode,text);
	return( hr );
}


HRESULT getAttrOfNode( IXMLDOMNode* pNode, WCHAR* attrName, BSTR* strValue)
{
	HRESULT hr;
	VARIANT varValue;

	
	*strValue = NULL;


	IXMLDOMElement* pElem;
	hr=pNode->QueryInterface(IID_IXMLDOMElement,(void**)&pElem );
	if( hr != S_OK ) {
		printf("QueryInterface failed\n");
		return( hr );
	};


	//
	hr = pElem->getAttribute(attrName,&varValue);
	if( hr != S_OK ) {
//		printf("getAttribute falied\n");
		return hr;
	};

	if( varValue.vt != VT_BSTR ) {
		printf("wrong type falied\n");
		return S_FALSE;
	};

	*strValue = varValue.bstrVal;
	return S_OK;
}


HRESULT getAttrOfNode( IXMLDOMNode* pNode, WCHAR* attrName, long* value)
{
	HRESULT hr;

	BSTR strValue;
	hr = getAttrOfNode(pNode,attrName,&strValue);
	if( hr != S_OK )
		return hr;

	*value = _wtol(strValue);
	return S_OK;
}


HRESULT getAttrOfNode( IXMLDOMNode* pNode, WCHAR* attrName, LONGLONG* value)
{
	HRESULT hr;

	BSTR strValue;
	hr = getAttrOfNode(pNode,attrName,&strValue);
	if( hr != S_OK )
		return hr;

	*value = _wtoi64(strValue);
	return S_OK;
}


HRESULT getAttrOfChild( IXMLDOMNode* pNode, WCHAR* childName, WCHAR* attrName, long* value)
{
	HRESULT hr;

	//select one child of the pNode that has a given name
	IXMLDOMNode* resultNode;
	hr = pNode->selectSingleNode(childName,&resultNode);
	if( hr != S_OK ) {
		printf("selectSingleNode failed\n");
		return( hr );
	};

	return( getAttrOfNode(resultNode,attrName,value) );
}



HRESULT getTypeOfNCNode( IXMLDOMNode* pNode, long* retType)
// retrieves the type of a naming context node
// returns S_OK iff succesful
//   then *retType == 
//			1 when Read-Write
//			2 when Read
{
	HRESULT hr;
	VARIANT varValue;

	//
	IXMLDOMElement* pElem;
	hr=pNode->QueryInterface(IID_IXMLDOMElement,(void**)&pElem );
	if( hr != S_OK ) {
		printf("QueryInterface failed\n");
		return( hr );
	};


	//
	hr = pElem->getAttribute(L"type",&varValue);
	if( hr != S_OK ) {
		printf("getAttribute falied\n");
		return hr;
	};

	if( varValue.vt != VT_BSTR ) {
		printf("wrong type falied\n");
		return S_FALSE;
	};

	if( _wcsicmp(varValue.bstrVal,L"rw") == 0 ) {
		*retType = 1;
		return S_OK;
	};
	if( _wcsicmp(varValue.bstrVal,L"r") == 0 ) {
		*retType = 2;
		return S_OK;
	};

	printf("unknown type of naming context\n");
	return S_FALSE;
}






int	random( int limit )
// returns a number drawn uniformly at random from the set {1,2,..,limit}
{
	if( limit < 1 ) return 1;
	int x=(rand()*limit) / RAND_MAX;
	if( x<0 ) x=0;
	if( x>=limit) x=limit-1;
	return x+1;
}

void tailncp( BSTR input, BSTR output, int num, int n)
//copies input to output skiping the prefix with num occurences
//of character ',' (comma) the output has at most n wide characters
//and that many should be allocated for the output before calling the function
{
	BSTR next=input;
	for( int i=0; i< num; i++) {
		next = wcschr(next,L',');
		if( next == NULL ) {
			//return an empty string
			wcscpy(output,L"");
			return;
		}
//		next = _wcsinc(next);  // Why couldn't the compiler find this function?
		next++;
//	printf("%S\n",next);
	};

	wcscpy(output,L"");
	wcsncat(output,next,n-1);
}



HRESULT createTextElement( IXMLDOMDocument * pXMLDoc, BSTR name, BSTR text, IXMLDOMElement** pretElement )
// creates a node <name> with the text value text,
// returns S_OK and pretElement only if succesful
{
	HRESULT hr;
	*pretElement=NULL;

	//create a <name> element 
	IXMLDOMElement* pElement;
	hr = pXMLDoc->createElement(name,&pElement);
	if( hr != S_OK ) {
		printf("createElement failed\n");
		return hr;
	};

	//set its text field
	IXMLDOMText *pText;
	hr = pXMLDoc->createTextNode(text,&pText);
	if( hr != S_OK ) {
		printf("createTextNode failed\n");
		return hr;
	};
	IXMLDOMNode *pTempnode;
	hr = pElement->appendChild(pText, &pTempnode);
	if( hr != S_OK ) {
		printf("appendChild failed\n");
		return hr;
	};

	*pretElement=pElement;
	return S_OK;
}



HRESULT createXML( IXMLDOMDocument** ppXMLDoc, IXMLDOMElement** ppRootElem, BSTR rootName)
{
	HRESULT hr;

	*ppXMLDoc = NULL;
	*ppRootElem = NULL;

	// create a DOM object
	IXMLDOMDocument * pXMLDoc;
	hr = CoCreateInstance(CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, 
							IID_IXMLDOMDocument, (void**)&pXMLDoc);
	if( hr != S_OK ) {
		printf("CoCreateInstance failed\n");
		return( hr );
	};
		

	//create a root element of the DOM 
	IXMLDOMElement* pRootElem;
	hr = createTextElement(pXMLDoc,rootName,L"",&pRootElem);
	if( hr != S_OK ) {
		printf("createTextElement failed\n");
		pXMLDoc->Release();
		return( hr );
	};
	IXMLDOMNode* pRootNode; 
	hr = pXMLDoc->appendChild(pRootElem,&pRootNode);
	if( hr != S_OK ) {
		printf("appendChild failed\n");
		pXMLDoc->Release();
		return( hr );
	};

	//document succesfuly created
	*ppXMLDoc = pXMLDoc;
	*ppRootElem = pRootElem;
	return( S_OK );
}



HRESULT addElement(IXMLDOMDocument* pXMLDoc, IXMLDOMNode* pParent, BSTR name, BSTR value, IXMLDOMElement** ppChildElement)
//adds an element with a given name and text under the parent element
//if succesful returns S_OK and the node in *ppChildNode
//if not succesful returns something other than S_OK and sets *ppChildNode to NULL
{
	HRESULT hr;

	*ppChildElement = NULL;

	//add <name> element under the parent
	IXMLDOMElement* pElem;
	hr = createTextElement(pXMLDoc,name,value,&pElem);
	if( hr != S_OK ) {
		printf("createTextElement failed\n");
		return( hr );
	};
	IXMLDOMNode* pNode; 
	hr = pParent->appendChild(pElem,&pNode);
	if( hr != S_OK ) {
		printf("appendChild failed\n");
		return( hr );
	};

	*ppChildElement = pElem;
	return( S_OK );
}



HRESULT addElement(IXMLDOMDocument* pXMLDoc, IXMLDOMNode* pParent, BSTR name, long value, IXMLDOMElement** ppChildElement)
// adds a node with integer value
{
	WCHAR text[30];

	_itow(value,text,10);
	return( addElement(pXMLDoc,pParent,name,text,ppChildElement) );
}



HRESULT addElementIfDoesNotExist(IXMLDOMDocument* pXMLDoc, IXMLDOMNode* pParent, BSTR name, BSTR value, IXMLDOMElement** ppRetElem)
{
	HRESULT hr;

	*ppRetElem = NULL;

	//check if the element <name> already exists as a child of the *pParent element
	IXMLDOMElement* pElem;
	hr = findUniqueElem(pParent,name,&pElem);
	if( hr!=E_UNEXPECTED && hr!=S_OK ) {
		printf("findUniqueElem failed");
		return S_FALSE;
	};


	//if it exsits then return it
	if( hr == S_OK ) {
		*ppRetElem = pElem;
		return S_OK;
	};


	//since it does not exist create it
	if( hr == E_UNEXPECTED ) {
		hr = addElement(pXMLDoc,pParent,name,value,&pElem);
		if( hr != S_OK ) {
			printf("addElement failed");
			return hr;
		};
		*ppRetElem = pElem;
		return S_OK;
	};

	return S_FALSE;
}


void rightDigits( int i, wchar_t * output, int num)
// takes the least significant num digits of the integer i
// and converts them into a string of length num
// possibly prefixing it with leading zeros
// output must be at lest 20 bytes long
// num is from 1 to 8
{
	wchar_t buffer[20];
	wchar_t buf2[20];
	wcscpy(output,L"");
	wcscpy(buf2,L"00000000");
	_itow(i,buffer,10);
	wcsncat(buf2,buffer,20-wcslen(buf2)-1);
	wchar_t* pp = buf2;
	pp += wcslen(buf2)-num;
	wcsncat(output,pp, 20-wcslen(output)-1 );

}



BSTR UTCFileTimeToCIM( FILETIME ft )
// converts time given in FILETIME format into a string that
// represens the time in CIM format (used by WMI)
// the string MUST be deallocated using SysFreeString() function
{
	wchar_t  output[40];
	wchar_t  buffer[30];
	SYSTEMTIME pst;
	FileTimeToSystemTime( &ft, &pst);


	wcscpy(output,L"");
	rightDigits(pst.wYear,buffer,4);
	wcsncat(output,buffer,40-wcslen(output)-1);
//	strcat(output," ");
	rightDigits(pst.wMonth,buffer,2);
	wcsncat(output,buffer,40-wcslen(output)-1);
//	strcat(output," ");
	rightDigits(pst.wDay,buffer,2);
	wcsncat(output,buffer,40-wcslen(output)-1);
//	strcat(output," ");
	rightDigits(pst.wHour,buffer,2);
	wcsncat(output,buffer,40-wcslen(output)-1);
//	strcat(output," ");
	rightDigits(pst.wMinute,buffer,2);
	wcsncat(output,buffer,40-wcslen(output)-1);
//	strcat(output," ");
	rightDigits(pst.wSecond,buffer,2);
	wcsncat(output,buffer,40-wcslen(output)-1);
	wcsncat(output,L".",40-wcslen(output)-1);
//	strcat(output," ");
	rightDigits(pst.wMilliseconds,buffer,6);
	wcsncat(output,buffer,40-wcslen(output)-1);
//	strcat(output," ");
	wcsncat(output,L"+000",40-wcslen(output)-1);

//	printf("%s\n",output);
	return(SysAllocString(output));

}


BSTR UTCFileTimeToCIM( LONGLONG time )
// the string MUST be deallocated using SysFreeString() function
{
	ULARGE_INTEGER x;
	FILETIME ft;

	x.QuadPart=time;
	ft.dwLowDateTime = x.LowPart;
	ft.dwHighDateTime = x.HighPart;

	return( UTCFileTimeToCIM(ft) );
};


BSTR GetSystemTimeAsCIM()
// returns a string that represents current system time in CIM format
// the string MUST be deallocated using SysFreeString() function
{
	FILETIME currentUTCTime;

	GetSystemTimeAsFileTime( &currentUTCTime );
	return(UTCFileTimeToCIM(currentUTCTime));
}



void moveTime( FILETIME* ft, int deltaSeconds )
// shifts time by s seconds
{
	ULARGE_INTEGER x;
	x.LowPart = ft->dwLowDateTime;
	x.HighPart = ft->dwHighDateTime;
	LONGLONG z = x.QuadPart;
	z = z + ((LONGLONG)10000000) * deltaSeconds;
	x.QuadPart = z;
	ft->dwLowDateTime = x.LowPart;
	ft->dwHighDateTime = x.HighPart;
}



BSTR GetSystemTimeAsCIM(int deltaSeconds )
// returns a string that represents current system time in CIM format
// the string MUST be deallocated using SysFreeString() function
{
	FILETIME currentUTCTime;

	GetSystemTimeAsFileTime( &currentUTCTime );
	moveTime( &currentUTCTime, deltaSeconds );
	return(UTCFileTimeToCIM(currentUTCTime));
}


HRESULT setHRESULT( IXMLDOMElement* pElem, HRESULT hr )
// sets the hresut and the timestamp attributes of a given element
// to value hr and to current time
{
	HRESULT hr2;
	_variant_t varValue;

	varValue = hr;
	hr2 = pElem->setAttribute(L"hresult", varValue);
	if( hr2 != S_OK ) { // ignore the failure
		printf("setAttribute failed\n");
	}; 
	BSTR currentTime = GetSystemTimeAsCIM();
	varValue = currentTime;
	hr2 = pElem->setAttribute(L"timestamp", varValue);
	SysFreeString(currentTime);

	return hr2;
};




HRESULT removeNodes( IXMLDOMElement* pRootElement, BSTR XPathSelection )
// removes all nodes under the root element that match a given XPath selection
// if succesful then returns S_OK
// otherwise returns something else than S_OK and the tree under the root
// may be modified
{
	HRESULT hr;

	IXMLDOMNodeList *pResultList;
	hr = createEnumeration( pRootElement, XPathSelection , &pResultList);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		return( hr );
	};
	IXMLDOMSelection *pIXMLDOMSelection;
	hr=pResultList->QueryInterface(IID_IXMLDOMSelection,(void**)&pIXMLDOMSelection );
	if( hr != S_OK ) {
		printf("QueryInterface failed\n");
		return( hr );
	};
	hr = pIXMLDOMSelection->removeAll();
	if( hr != S_OK ) {
		printf("removeAll failed\n");
		return( hr );
	};

	return S_OK;
}

HRESULT removeNodes( IXMLDOMDocument* pXMLDoc, BSTR XPathSelection )
{
	HRESULT hr;


	//find the root element of the DOM object (root of the XML file)
	IXMLDOMElement* pRootElement;
	hr = pXMLDoc->get_documentElement(&pRootElement);
	if( hr != S_OK || pRootElement == NULL ) {
		printf("get_documentElement failed\n");
		return( S_FALSE );
	};

	return( removeNodes(pRootElement,XPathSelection) );
}



HRESULT removeAttributes( IXMLDOMElement* pRootElement, BSTR XPathSelection, BSTR attrName )
// removes all attrName attributes of nodes under the root element that match
// a given XPath selection
// if succesful then returns S_OK
// otherwise returns something else than S_OK and the tree under the root
// may be modified
{
	HRESULT hr;


	//find all nodes that match the xpath selection
	IXMLDOMNodeList *pResultList;
	hr = createEnumeration( pRootElement, XPathSelection , &pResultList);
	if( hr != S_OK ) {
		printf("createEnumeration failed\n");
		return( hr );
	};
	
	
	//loop through all nodes
	IXMLDOMNode *pNode;
	while( true ) {

		hr = pResultList->nextNode(&pNode);
		if( hr != S_OK || pNode == NULL ) break; // iterations across nodes have finished


		//the query actually retrives elements not nodes (elements inherit from nodes)
		//so get the element
		IXMLDOMElement* pElem;
		hr=pNode->QueryInterface(IID_IXMLDOMElement,(void**)&pElem );
		if( hr != S_OK ) {
			printf("QueryInterface failed\n");
			continue;	// skip this node
		};


		//remove the attribute
		hr = pElem->removeAttribute(attrName);
		if( hr != S_OK ) {
			printf("removeAttribute failed\n");
			continue;	// skip this node
		};
	};
	
	return S_OK;
}




HRESULT getStringProperty( BSTR DNSName, BSTR object, BSTR property, BSTR username, BSTR domain, BSTR passwd, BSTR* pRetValue )
// retrieves the value of a string property of an LDAP object using given credentials
// if succesful returns S_OK and a string that must be freed using SysFreeString
// if failed then returns something other than S_OK
{
	HRESULT hr;
	WCHAR userpath[TOOL_MAX_NAME];
	WCHAR objectpath[TOOL_MAX_NAME];
	IADsOpenDSObject *pDSO;
 

	*pRetValue = NULL;


//************************   NETWORK PROBLEMS
	hr = ADsGetObject(L"LDAP:", IID_IADsOpenDSObject, (void**) &pDSO);
//************************
	if( hr != S_OK ) {
//		printf("ADsGetObject falied\n");
		return hr;
	};


	wcscpy(userpath,L"");
	wcsncat(userpath,domain,TOOL_MAX_NAME-wcslen(userpath)-1);
	wcsncat(userpath,L"\\",TOOL_MAX_NAME-wcslen(userpath)-1);
	wcsncat(userpath,username,TOOL_MAX_NAME-wcslen(userpath)-1);

//printf("%S\n",userpath);

	//build a string representing an Active Directory object to which we will conect using ADSI
	wcscpy(objectpath,L"");
	wcsncat(objectpath,L"LDAP://",TOOL_MAX_NAME-wcslen(objectpath)-1);
	wcsncat(objectpath,DNSName,TOOL_MAX_NAME-wcslen(objectpath)-1);
	wcsncat(objectpath,L"/",TOOL_MAX_NAME-wcslen(objectpath)-1);
	wcsncat(objectpath,object,TOOL_MAX_NAME-wcslen(objectpath)-1);

//printf("%S\n",objectpath);

	//get the object and proper interface
    IDispatch *pDisp;
//************************   NETWORK PROBLEMS
    hr = pDSO->OpenDSObject( objectpath, userpath, passwd, ADS_SECURE_AUTHENTICATION, &pDisp);
//************************
    pDSO->Release();
    if( hr != S_OK ) {
//		printf("OpenDSObject falied\n");
		return hr;
	};
	IADs *pADs;
	hr = pDisp->QueryInterface(IID_IADs, (void**) &pADs);
	pDisp->Release();
	if( hr != S_OK ) {
		printf("QueryInterface falied\n");
		return hr;
	};
	
	
	//retrieve the value of a given property and check if the value is a BSTR
	VARIANT var;
	VariantInit(&var);
	hr = pADs->Get(property, &var );
	if( hr != S_OK || var.vt != VT_BSTR) {
		printf("Get falied\n");
		return hr;
	};


	//create a new string which represents the value
	BSTR ret;
	ret = SysAllocString(V_BSTR(&var));
	if( ret == NULL ) {
		printf("SysAllocString falied\n");
		return hr;
	};

	//cleanup and return the string
    VariantClear(&var);
	pADs->Release();
	*pRetValue = ret;

	return S_OK;
}




HRESULT ADSIquery( BSTR protocol, BSTR DNSName, BSTR searchRoot, int scope, BSTR objectCategory, LPWSTR attributesTable[], DWORD sizeOfTable, BSTR username, BSTR domain, BSTR passwd, ADS_SEARCH_HANDLE* pRetHSearch, IDirectorySearch** ppRetDSSearch )
// isses an ADSI query to a server given by the DNSName
// using a given protocol (e.g., LDAP or GC)
// the query starts from the searchRoot object at the server
// and has a given scope, the search finds objects of category
// given by objectCategory, and retrieves their attributes
// provided by an array attributesTable with sizeOfTable
// entries, the search uses given credentials to access
// the remote machine.
//
// if succesful returns S_OK and pointers to ADS_SEARCH_HANDLE
// and to IDirectorySearch
//   the caller must release the pointers as follows:
//		(*ppRetDSSearch)->CloseSearchHandle(pRetHSearch);
//      (*ppRetDSSearch)->Release();
// if failure then returns something other than S_OK
//    and the caller do not release anything
{
	HRESULT hr;
	WCHAR userpath[TOOL_MAX_NAME];
	WCHAR objectpath[TOOL_MAX_NAME];
	WCHAR searchstring[TOOL_MAX_NAME];

	*pRetHSearch = NULL;

	wcscpy(userpath,L"");
	wcsncat(userpath,domain,TOOL_MAX_NAME-wcslen(userpath)-1);
	wcsncat(userpath,L"\\",TOOL_MAX_NAME-wcslen(userpath)-1);
	wcsncat(userpath,username,TOOL_MAX_NAME-wcslen(userpath)-1);

//printf("%S\n",userpath);

	//build a string representing an Active Directory object to which we will conect using ADSI
	wcscpy(objectpath,L"");
	wcsncat(objectpath,protocol,TOOL_MAX_NAME-wcslen(objectpath)-1);
	wcsncat(objectpath,L"://",TOOL_MAX_NAME-wcslen(objectpath)-1);
	wcsncat(objectpath,DNSName,TOOL_MAX_NAME-wcslen(objectpath)-1);
	wcsncat(objectpath,L"/",TOOL_MAX_NAME-wcslen(objectpath)-1);
	wcsncat(objectpath,searchRoot,TOOL_MAX_NAME-wcslen(objectpath)-1);

//printf("%S\n",objectpath);


	//open a connection to the AD object (given by the DNS name) and using provided credentials
	IDirectorySearch* pDSSearch = NULL;
//************************   NETWORK PROBLEMS
	hr = ADsOpenObject(objectpath,userpath,passwd,ADS_SECURE_AUTHENTICATION,IID_IDirectorySearch, (void **)&pDSSearch); 
//************************
	if( hr!=S_OK ) {
//		printf("ADsOpenObject failed\n");
		return hr;
	};  


	//set search scope
	ADS_SEARCHPREF_INFO arSearchPrefs[1];
	arSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE; 
	arSearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER; 
	arSearchPrefs[0].vValue.Integer = scope; 
	hr = pDSSearch->SetSearchPreference(arSearchPrefs, 1); 
	if( hr!= S_OK ) {
		printf("SetSearchPreference failed\n");
		return hr;
	};


	//search for all objectCategory objects and retrieve their
	//properties given by the attributes table
//	DWORD dwCount = 0;
//	DWORD dwAttrNameSize = sizeof(attributes)/sizeof(LPWSTR); 
	ADS_SEARCH_HANDLE hSearch;
	wcscpy(searchstring,L"");
	wcsncat(searchstring,L"(objectCategory=",TOOL_MAX_NAME-wcslen(searchstring)-1);
	wcsncat(searchstring,objectCategory,TOOL_MAX_NAME-wcslen(searchstring)-1);
	wcsncat(searchstring,L")",TOOL_MAX_NAME-wcslen(searchstring)-1);
//	printf("searchstring %S\n",searchstring);
//************************   NETWORK PROBLEMS
	hr = pDSSearch->ExecuteSearch(searchstring,attributesTable ,sizeOfTable,&hSearch );
//************************
	if( hr!= S_OK ) {
//		printf("ExecuteSearch failed\n");
		pDSSearch->Release();
		return hr;
	};

	*pRetHSearch = hSearch;
	*ppRetDSSearch = pDSSearch;
	return S_OK;
}






HRESULT getDNtypeString(IDirectorySearch* pDSSearch, ADS_SEARCH_HANDLE hSearch, BSTR stringName, WCHAR* dnOutput, long sizeOutput)
// retrieves the value of an attribute of type "distinguished name" that has
// name stringName of a row and copies the result into the dnOutput table
// that has size sizeOutput
//
// returns S_OK iff succesful
{
	ADS_SEARCH_COLUMN col;  // COL for iterations
	HRESULT hr;


	//it the output talbe is too small then quit
	if( sizeOutput < 2 )
		return S_FALSE;


	//otherwise retrieve the value of the stringName attribute
	hr = pDSSearch->GetColumn( hSearch, stringName, &col );
	if( hr != S_OK ) {
//		printf("GetColumn failed\n");
		return hr;
	};
	if( col.dwADsType != ADSTYPE_DN_STRING ) {
		//something wrong, the datatype should be distinguished name
//		printf("wrong type\n");
		pDSSearch->FreeColumn(&col);
		return hr;
	}


	//and copy the result to the output
	wcscpy(dnOutput,L"");
	wcsncat(dnOutput,col.pADsValues->DNString,sizeOutput-wcslen(dnOutput)-1);
	pDSSearch->FreeColumn(&col);
	return S_OK;
}




HRESULT getCItypeString(IDirectorySearch* pDSSearch, ADS_SEARCH_HANDLE hSearch, BSTR stringName, WCHAR* cnOutput, long sizeOutput)
// retrieves the value of an attribute of type "case ignore" that has
// name stringName of a row and copies the result into the dnOutput table
// that has size sizeOutput
//
// returns S_OK iff succesful
{
	ADS_SEARCH_COLUMN col;  // COL for iterations
	HRESULT hr;


	//it the output talbe is too small then quit
	if( sizeOutput < 2 )
		return S_FALSE;


	//otherwise retrieve the value of stringName attribute
	hr = pDSSearch->GetColumn( hSearch, stringName, &col );
	if( hr != S_OK ) {
//		printf("GetColumn failed\n");
		return hr;
	};
	if( col.dwADsType != ADSTYPE_CASE_IGNORE_STRING ) {
		//something wrong with the datatype of the distinguishedName attribute
//		printf("wrong type\n");
		pDSSearch->FreeColumn(&col);
		return hr;
	};


	//and copy the result to the output
	wcscpy(cnOutput,L"");
	wcsncat(cnOutput,col.pADsValues->DNString,sizeOutput-wcslen(cnOutput)-1);

	
	//since it is a "case ignore" type, so turn it into lowercase
	_wcslwr(cnOutput);


	pDSSearch->FreeColumn(&col);
	return S_OK;
}




HRESULT getINTtypeString(IDirectorySearch* pDSSearch, ADS_SEARCH_HANDLE hSearch, BSTR stringName, int* intOutput)
// retrieves the value of an attribute of type "case ignore" that has
// name stringName of a row and copies the result into the dnOutput table
// that has size sizeOutput
//
// returns S_OK iff succesful
{
	ADS_SEARCH_COLUMN col;  // COL for iterations
	HRESULT hr;



	//otherwise retrieve the value of stringName attribute
	hr = pDSSearch->GetColumn( hSearch, stringName, &col );
	if( hr != S_OK ) {
//		printf("GetColumn failed\n");
		return hr;
	};
	if( col.dwADsType != ADSTYPE_INTEGER ) {
		//something wrong with the datatype of the distinguishedName attribute
//		printf("wrong type\n");
		pDSSearch->FreeColumn(&col);
		return hr;
	};


	//and copy the result to the output
	*intOutput = col.pADsValues->Integer;
	pDSSearch->FreeColumn(&col);
	return S_OK;
}



HRESULT findUniqueNode( IXMLDOMNode* pXMLNode, WCHAR* xpath, IXMLDOMNode** ppRetNode)
//finds a node under the pXMLNode that satisfies xpath
//there must be only one such node, otherwise returns failure
//
//returns S_OK iff only one node is found, in which case 
//*ppRetNode is the node
//if node was not found then returns E_UNEXPECTED
//if there is an error returns S_FALSE;
{
	HRESULT hr;


	*ppRetNode = NULL;


	IXMLDOMNodeList* pList;
	hr = createEnumeration( pXMLNode,xpath,&pList);
	if( hr != S_OK ) {
//		printf("createEnumeration failed\n");
		return S_FALSE;
	};
	long len;
	hr = pList->get_length( &len );
	if( hr != S_OK ) {
//		printf("get_length failed\n");
		pList->Release();
		return S_FALSE;
	};
	if( len != 1 ) {
//		printf("node not found\n");
		pList->Release();
		return E_UNEXPECTED;
	};
	IXMLDOMNode* pNode;
	hr = pList->get_item(0,&pNode );
	if( hr != S_OK ) {
//		printf("get_length failed\n");
		pList->Release();
		return S_FALSE;
	};

	*ppRetNode = pNode;
	pList->Release();
	return S_OK;
}


HRESULT findUniqueElem( IXMLDOMNode* pXMLNode, WCHAR* xpath, IXMLDOMElement** ppRetElem)
//if element was not found then returns E_UNEXPECTED
//if there is an error returns S_FALSE;
{
	HRESULT hr;
	IXMLDOMNode* pNode;

	*ppRetElem = NULL;

	hr = findUniqueNode(pXMLNode, xpath, &pNode);
	if( hr != S_OK ) {
//		printf("findUniqueNode failed\n");
		return( hr );
	};

	IXMLDOMElement* pElem;
	hr=pNode->QueryInterface(IID_IXMLDOMElement,(void**)&pElem );
	if( hr != S_OK ) {
//		printf("QueryInterface failed\n");
		return( S_FALSE );
	};

	*ppRetElem = pElem;
	return S_OK;
}


HRESULT findUniqueElem( IXMLDOMDocument* pXMLDoc, WCHAR* xpath, IXMLDOMElement** ppRetElem)
//if element was not found then returns E_UNEXPECTED
//if there is an error returns S_FALSE;
{
	HRESULT hr;


	*ppRetElem = NULL;
	
	//find the root element of the DOM object (root of the XML file)
	IXMLDOMElement* pRootElement;
	hr = pXMLDoc->get_documentElement(&pRootElement);
	if( hr != S_OK || pRootElement == NULL ) {
//		printf("get_documentElement failed\n");
		return( S_FALSE );
	};
	
	
	return( findUniqueElem(pRootElement,xpath,ppRetElem) );
}



static int lastSelection;
static WBEMTime lastTime[TOOL_PROC];


void suspendInit()
{
	FILETIME currentUTCTime;
	GetSystemTimeAsFileTime( &currentUTCTime );

	for( int i=0; i<TOOL_PROC; i++)
		lastTime[i] = currentUTCTime;
	lastSelection= -1;
}


int suspend( WBEMTimeSpan period[])
{
	LONGLONG lo[TOOL_PROC];

	FILETIME currentUTCTime;
	WBEMTime now;
	int i;

	
	GetSystemTimeAsFileTime( &currentUTCTime );
	now = currentUTCTime;
	for( i=0; i<TOOL_PROC; i++ )
		lo[i] = ((lastTime[i]+period[i])-now).GetTime();
	for( i=0; i<TOOL_PROC; i++ )
		lo[i] = lo[i]/10000;


	//find minimal and sleep if necessary
	long min=lo[0];
	for( int j=1; j<TOOL_PROC; j++)
		if( lo[j]<min ) {
			min = lo[j];
			i = j;
		};
	if( min > 0 ) {
//		printf("\nWaiting for %d\n",i);
		Sleep(min+50);
	};


	GetSystemTimeAsFileTime( &currentUTCTime );
	now = currentUTCTime;
	for( i=0; i<TOOL_PROC; i++ )
		lo[i] = ((lastTime[i]+period[i])-now).GetTime();
	for( i=0; i<TOOL_PROC; i++ )
		lo[i] = lo[i]/10000;

	
	//find first zero starting from other than the most recent
	//in a round-robin fashion
	bool found=false;
	for( i=lastSelection+1; i<TOOL_PROC; i++)
		if( lo[i] == 0 ) {
			found = true;
			break;
		};
	if( !found )
		for( i=0; i<=lastSelection; i++)
			if( lo[i] == 0 ) {
				found = true;
				break;
			};

	GetSystemTimeAsFileTime( &currentUTCTime );
	now = currentUTCTime;
	lastTime[i] = now;
	lastSelection = i;
	return i;
}





// the functions below implement a cyclic buffer that stores NONZERO entries,
// the buffer has TOOL_CYCLIC_BUFFER-1 entries,
// we can insert elements and find 
// the next element after the element that
// is euqal to a given timestamp
// the location pointed by the head is ALWAYS equal to zero, which indicates
// that this location is empty (no entry is stored there)


void cyclicBufferInit( CyclicBuffer* pCB )
//initialy all buffer becomes empty
{
	pCB->head=0;
	pCB->firstInjection=0;
	for( int i=0; i<TOOL_CYCLIC_BUFFER; i++ )
		pCB->tab[i]=0;
}
void cyclicBufferInsert( CyclicBuffer* pCB, LONGLONG timestamp)
{
	pCB->tab[pCB->head] = timestamp;
	(pCB->head)++;
	if( (pCB->head) == TOOL_CYCLIC_BUFFER )
		(pCB->head)=0;

	//mark the entry under the head as empty
	pCB->tab[pCB->head] = 0;
}
HRESULT cyclicBufferFindNextAfter(CyclicBuffer* pCB, LONGLONG timestamp, LONGLONG* ret)
// we search the entire buffer irrespective of the order of insertions
// we return S_OK iff we find an element equal to timestamp, then  *ret is the value of the
// next element in the cyclic buffer
// if this value is ZERO then it means that the found element is at the head of the buffer
// (no other element has been inserted after him)
{
	*ret = 0;
	for( int i=0; i<TOOL_CYCLIC_BUFFER; i++ )
		if( pCB->tab[i] == timestamp ) break;


	// if we have found the timestamp then get the next
	if( i<TOOL_CYCLIC_BUFFER ) {
		if( i<TOOL_CYCLIC_BUFFER-1 )
			*ret = pCB->tab[i+1];
		else
			*ret = pCB->tab[0];
		return S_OK;
	}
	else
		return S_FALSE;
}
void cyclicBufferFindLatest(CyclicBuffer* pCB, LONGLONG* ret)
{
	if( (pCB->head) == 0 )
		*ret = pCB->tab[TOOL_CYCLIC_BUFFER-1];
	else
		*ret = pCB->tab[(pCB->head)-1];
}

static CyclicBufferTable departureTime;

HRESULT departureTimeInit(int totalDNSs, int totalNCs)
{
	departureTime.totalDNSs = totalDNSs;
	departureTime.totalNCs = totalNCs;
	departureTime.root=(CyclicBuffer*)malloc(totalDNSs*totalNCs*sizeof(CyclicBuffer));
	if( departureTime.root == NULL )
		return S_FALSE;

	CyclicBuffer* pCB;
	pCB = departureTime.root;
	for(int i=0; i<totalDNSs*totalNCs; i++ ) {
		cyclicBufferInit(pCB);
		pCB++;
	};
	return S_OK;
}
void departureTimeFree()
{
	free(departureTime.root);
	departureTime.root = NULL;
};

CyclicBuffer* departureTimeGetCB(int dnsID, int ncID)
{
	if( dnsID<0 || dnsID>=departureTime.totalDNSs || ncID<0 || ncID>=departureTime.totalNCs )
		return NULL;

	CyclicBuffer* pCB;
	pCB = departureTime.root;
	pCB += dnsID+ncID*(departureTime.totalDNSs);
	return pCB;
}


void departureTimePrint()
{
	LONGLONG time,sek,mili;
	long sourceID, 